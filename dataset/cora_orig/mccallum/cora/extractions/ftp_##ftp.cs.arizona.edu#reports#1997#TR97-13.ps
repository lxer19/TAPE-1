URL: ftp://ftp.cs.arizona.edu/reports/1997/TR97-13.ps
Refering-URL: http://www.cs.arizona.edu/research/reports.html
Root-URL: http://www.cs.arizona.edu
Email: fdebray, muth, weippertg@cs.arizona.edu  
Title: Alias Analysis of Executable Code  
Author: Saumya Debray Robert Muth Matthew Weippert 
Note: This work was supported in part by the National Science Foundation under grant CCR-9502826  
Date: July 1997  
Address: Tucson, AZ 85721, U.S.A.  
Affiliation: Department of Computer Science University of Arizona  
Pubnum: Technical Report 97-13  
Abstract: Recent years have seen increasing interest in systems that reason about and manipulate executable code. Such systems can generally benefit from information about aliasing. Unfortunately, most existing alias analyses are formulated in terms of high-level language features, and are unable to cope with features, such as pointer arithmetic, that pervade executable programs. This paper describes a simple algorithm that can be used to obtain aliasing information for executable code. In order to be practical, the algorithm is careful to keep its memory requirements low, sacrificing precision where necessary to achieve this goal. Experimental results indicate that it is nevertheless able to provide a reasonable amount of information about memory references across a variety of benchmark programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi and J. D. Ullman, </author> <booktitle> Compilers Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Given the handling of individual instructions as described in the previous section, the analysis is now a conceptually straightforward forward dataflow analysis where we compute the meet-over-all-paths solution, 4 with union as the meet operator <ref> [1] </ref>. It turns out that if each register, at each program point, is mapped to a set of address descriptors, the memory requirements for the analysis can become excessive for large programs.
Reference: [2] <author> M. Burke, P. Carini, J. D. Choi, and M. Hind, </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers, </title> <booktitle> in Languages and Compilers for Parallel Computing: Proceedings of the 7th International Workshop, </booktitle> <editor> eds. K. Pingali, U. Bannerjee, D. Gelernter, A. Nicolau and D. Padua, </editor> <address> Aug. 1994. </address> <publisher> Springer-Verlag LNCS vol. </publisher> <pages> 892, pp. 234-250. </pages>
Reference: [3] <author> D. R. Chase, M. Wegman, and F. K. Zadeck, </author> <title> Analysis of Pointers and Structures, </title> <booktitle> Proc. SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1990, </year> <pages> pp. 296-310. </pages>
Reference: [4] <author> J.-D. Choi, M. Burke, and P. Carini, </author> <title> Efficient Flow-Sensitive Interprocedural Computation of Pointer-Induced Aliases and Side Effects, </title> <booktitle> Proc. 20th ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1993, </year> <pages> pp. 232-245. </pages>
Reference: [5] <author> R. Cohn, D. Goodwin, P. G. Lowney, and N. Rubin, Spike: </author> <title> An Optimizer for Alpha/NT Executables, </title> <booktitle> Proc. USENIX Windows NT Workshop, </booktitle> <month> Aug. </month> <year> 1997. </year> <month> 11 </month>
Reference-contexts: 1 Introduction Recent years have seen increasing interest in reasoning about and manipulating executable files <ref> [5, 14, 19, 24, 26, 29, 30, 32] </ref>. When working with an executable file, we typically have information about the entire programincluding, potentially, library functionsthat is usually not available at compile time. <p> As with the compilation of source-level programs, code transformations on executable code can benefit greatly from pointer alias information. For example, to obtain the full benefits of a superscalar architecture such as the DEC Alpha, link-time optimizers such as Spike <ref> [5] </ref>, alto [9], and OM [29] need to carry out instruction scheduling again after link-time optimizations. Without pointer alias information, however, the scheduler must be conservative in its treatment of all loads and stores, and this severely limits the amount of code reordering that is possible. <p> also plan to incorporate the results of alias analysis into our instruction scheduler as well as a number other optimizations, and expect to have more extensive experimental results for the utility of this information shortly. 5 Related Work While a number of systems have been described for link-time code optimization <ref> [5, 14, 15, 26, 29, 30, 32] </ref>, to the best of our knowledge none of these carry out any alias analysis on the executable files they process.
Reference: [6] <author> K. D. Cooper and K. Kennedy, </author> <title> Fast Interprocedural Alias Analysis, </title> <booktitle> Proc. 16th ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1989, </year> <pages> pp. 49-59. </pages>
Reference: [7] <author> P. Cousot and R. Cousot, </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Apporoximation of Fixpoints, </title> <booktitle> Proc. Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1977, </year> <pages> pp. 238-252. </pages>
Reference-contexts: For pragmatic reasonssee Section 3.2.2 for detailswe use a widening operation <ref> [7] </ref> to ensure that at each program point, each register is mapped to a singleton set of address descriptors. <p> This is due partly because fully linked executables tend to be considerably larger than source language modules, and partly because reasoning about address arithmetic is usually less precise than, say, reasoning about aliasing at the source level. As a pragmatic measure, therefore, a widening operation <ref> [7] </ref> is used to ensure that at each program point, each register is mapped to a singleton set of address descriptorsor, equivalently, a single address descriptor. As mentioned in Section 3.1, the set of address descriptors forms a lattice with respect to the precision ordering fi.
Reference: [8] <author> D. Coutant, </author> <title> Retargetable High-Level Alias Analysis, </title> <booktitle> Proc. 13th ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1986, </year> <pages> pp. 110-118. </pages>
Reference: [9] <author> K. De Bosschere and S. K. Debray, </author> <title> alto : A Link-Time Optimizer for the DEC Alpha, </title> <type> Technical Report 96-15, </type> <institution> Dept. of Computer Science, The University of Arizona, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: As with the compilation of source-level programs, code transformations on executable code can benefit greatly from pointer alias information. For example, to obtain the full benefits of a superscalar architecture such as the DEC Alpha, link-time optimizers such as Spike [5], alto <ref> [9] </ref>, and OM [29] need to carry out instruction scheduling again after link-time optimizations. Without pointer alias information, however, the scheduler must be conservative in its treatment of all loads and stores, and this severely limits the amount of code reordering that is possible. <p> As this example illustrates, pointer arithmetic cannot be ignored during alias analysis at the machine code level. In this paper, we describe a low-level, flow-sensitive, context-insensitive interprocedural pointer alias analysis algorithm, designed and implemented in the context of the alto link time optimizer <ref> [9] </ref>, that can handle significant pointer arithmetic and features, such as out-of-bound references, that are ignored by most existing alias analysis algorithms. For simplicity in the discussion that follows, we assume a more or less canonical RISC instruction set.
Reference: [10] <author> A. Deutsch, </author> <title> On determining lifetime and aliasing of dynamically allocated data in higher-order functional specifications, </title> <booktitle> Proc. 17th ACm Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1990, </year> <pages> pp. 157-168. </pages>
Reference: [11] <author> A. Deutsch, </author> <title> Interprocedural May-Alias Analysis for Pointers: Beyond k-limiting, </title> <booktitle> Proc. SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1994, </year> <pages> pp. 230-241. </pages>
Reference: [12] <author> A. Diwan, K. S. McKinley and J. E. B. Moss, </author> <title> Type-Based Alias Analysis, </title> <type> Manuscript, </type> <institution> Dept. of Computer Science, University of Massachusetts, Amherst, </institution> <year> 1996. </year>
Reference: [13] <author> M. Emami, R. Ghiya and L. J. Hendren, </author> <title> Context-Sensitive Interprocedural Points-to Analysis in the Presence of Function Pointers, </title> <booktitle> Proc. SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1994, </year> <pages> pp. 242-256. </pages>
Reference: [14] <author> M. F. Fernandez, </author> <title> Simple and Effective Link-Time Optimization of Module-3 Programs, </title> <booktitle> Proc. SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 103-115. </pages>
Reference-contexts: 1 Introduction Recent years have seen increasing interest in reasoning about and manipulating executable files <ref> [5, 14, 19, 24, 26, 29, 30, 32] </ref>. When working with an executable file, we typically have information about the entire programincluding, potentially, library functionsthat is usually not available at compile time. <p> also plan to incorporate the results of alias analysis into our instruction scheduler as well as a number other optimizations, and expect to have more extensive experimental results for the utility of this information shortly. 5 Related Work While a number of systems have been described for link-time code optimization <ref> [5, 14, 15, 26, 29, 30, 32] </ref>, to the best of our knowledge none of these carry out any alias analysis on the executable files they process.
Reference: [15] <author> D. W. Goodwin, </author> <title> Interprocedural Dataflow Analysis in an Executable Optimizer, </title> <booktitle> Proc. SIGPLAN '97 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1997, </year> <pages> pp. 122-133. </pages>
Reference-contexts: also plan to incorporate the results of alias analysis into our instruction scheduler as well as a number other optimizations, and expect to have more extensive experimental results for the utility of this information shortly. 5 Related Work While a number of systems have been described for link-time code optimization <ref> [5, 14, 15, 26, 29, 30, 32] </ref>, to the best of our knowledge none of these carry out any alias analysis on the executable files they process.
Reference: [16] <author> R. L. Graham, D. E. Knuth, and O. Patashnik, </author> <title> Concrete Mathematics, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: This representation can cope with address arithmetic, e.g., as illustrated in Figure 1, since such arithmetic translates in a straightforward way to mod-k arithmetic (see, for example, <ref> [16] </ref>). Finally, since x mod k 6= (x ffi) mod k for 0 &lt; ffi &lt; 2 m , the representation can distinguish between addresses involving distinct small displacements (i.e., less than 2 m ) from a base register. <p> Otherwise, we can't say anything about the result of this operation, so the address descriptor for dest after I is taken to be hI; f0gi. The correctness of the first case follows straightforwardly from the rules for mod-k arithmetic <ref> [16] </ref>; the second case is obviously safe, but merits some discussion: if A a ' ?, A b ' ?, or I a 6= I b , it's easy to see that we can't say anything about the result of the operation; if I a = I b = I 0
Reference: [17] <author> S. Horwitz, P. Pfeiffer, and T. Reps, </author> <title> Dependence Analysis for Pointer Variables, </title> <booktitle> Proc. SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1989, </year> <pages> pp. 28-40. </pages>
Reference: [18] <author> J. Hummel, L. J. Hendren, and A. Nicolau, </author> <title> A General Data Dependence Test for Dynamic, Pointer-Based Data Structures, </title> <booktitle> Proc. SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1994, </year> <pages> pp. 218-229. </pages>
Reference: [19] <author> M. S. Johnson and T. C. Miller, </author> <title> Effectiveness of a Machine-Level Global Optimizer, </title> <booktitle> Proc. SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <month> June </month> <year> 1986, </year> <pages> pp. 99-108. </pages>
Reference-contexts: 1 Introduction Recent years have seen increasing interest in reasoning about and manipulating executable files <ref> [5, 14, 19, 24, 26, 29, 30, 32] </ref>. When working with an executable file, we typically have information about the entire programincluding, potentially, library functionsthat is usually not available at compile time.
Reference: [20] <author> N. D. Jones and S. S. Muchnick, </author> <title> Flow analysis and optimization of LISP-like structures, in Program Flow Analysis, </title> <editor> eds. S. S. Muchnick and N. D. Jones, </editor> <publisher> Prentice Hall, </publisher> <year> 1981, </year> <pages> pp. 102-131. </pages>
Reference: [21] <author> N. D. Jones and S. S. Muchnick, </author> <title> A flexible approach to interprocedural data flow analysis and programs with recursive data structures, </title> <booktitle> Proc. 9th ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1982, </year> <pages> pp. 66-74 </pages>
Reference: [22] <author> W. Landi and B. G. Ryder, </author> <title> Pointer-induced Aliasing: A Problem Classification, </title> <booktitle> Proc. 18th ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1991, </year> <pages> pp. 93-103. 12 </pages>
Reference: [23] <author> W. Landi and B. G. Ryder, </author> <title> A Safe Approximate Algorithm for Interprocedural Pointer Aliasing, </title> <booktitle> Proc. SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992, </year> <pages> pp. 235-248. </pages>
Reference: [24] <author> J. R. Larus and E. Schnarr, EEL: </author> <title> Machine-independent Executable Editing, </title> <booktitle> Proc. SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 291-300. </pages>
Reference-contexts: 1 Introduction Recent years have seen increasing interest in reasoning about and manipulating executable files <ref> [5, 14, 19, 24, 26, 29, 30, 32] </ref>. When working with an executable file, we typically have information about the entire programincluding, potentially, library functionsthat is usually not available at compile time.
Reference: [25] <author> J. R. Larus and P. N. Hilfinger, </author> <title> Detecting Conflicts Between Structure Accesses, </title> <booktitle> Proc. SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988, </year> <pages> pp. 21-34. </pages>
Reference: [26] <author> T. Romer, G. Voelker, D. Lee, A. Wolman, W. Wong, H. Levy, B. N. Bershad, and J. B. Chen, </author> <note> Instrumentation and Optimization of Win32/Intel Executables, 1997 USENIX Windows NT Workshop (to appear). </note>
Reference-contexts: 1 Introduction Recent years have seen increasing interest in reasoning about and manipulating executable files <ref> [5, 14, 19, 24, 26, 29, 30, 32] </ref>. When working with an executable file, we typically have information about the entire programincluding, potentially, library functionsthat is usually not available at compile time. <p> also plan to incorporate the results of alias analysis into our instruction scheduler as well as a number other optimizations, and expect to have more extensive experimental results for the utility of this information shortly. 5 Related Work While a number of systems have been described for link-time code optimization <ref> [5, 14, 15, 26, 29, 30, 32] </ref>, to the best of our knowledge none of these carry out any alias analysis on the executable files they process.
Reference: [27] <author> E. Ruf, </author> <title> Context-Insensitive Alias Analysis Reconsidered, </title> <booktitle> Proc. SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 13-22. </pages>
Reference: [28] <author> M. Shapiro and S. Horwitz, </author> <title> Fast and Accurate Flow-Insensitive Points-To Analysis, </title> <booktitle> Proc. 24th. ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1997, </year> <pages> pp. 1-14. </pages>
Reference: [29] <author> A. Srivastava and D. W. Wall, </author> <title> A Practical System for Intermodule Code Optimization at Link-Time, </title> <journal> Journal of Programming Languages, </journal> <pages> pp. 1-18, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Recent years have seen increasing interest in reasoning about and manipulating executable files <ref> [5, 14, 19, 24, 26, 29, 30, 32] </ref>. When working with an executable file, we typically have information about the entire programincluding, potentially, library functionsthat is usually not available at compile time. <p> As with the compilation of source-level programs, code transformations on executable code can benefit greatly from pointer alias information. For example, to obtain the full benefits of a superscalar architecture such as the DEC Alpha, link-time optimizers such as Spike [5], alto [9], and OM <ref> [29] </ref> need to carry out instruction scheduling again after link-time optimizations. Without pointer alias information, however, the scheduler must be conservative in its treatment of all loads and stores, and this severely limits the amount of code reordering that is possible. <p> also plan to incorporate the results of alias analysis into our instruction scheduler as well as a number other optimizations, and expect to have more extensive experimental results for the utility of this information shortly. 5 Related Work While a number of systems have been described for link-time code optimization <ref> [5, 14, 15, 26, 29, 30, 32] </ref>, to the best of our knowledge none of these carry out any alias analysis on the executable files they process.
Reference: [30] <author> A. Srivastava and D. W. Wall, </author> <title> Link-time Optimization of Address Calculation on a 64-bit Architecture, </title> <booktitle> Proc. SIGPLAN '94 Conference Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1994, </year> <pages> pp. 49-60. </pages>
Reference-contexts: 1 Introduction Recent years have seen increasing interest in reasoning about and manipulating executable files <ref> [5, 14, 19, 24, 26, 29, 30, 32] </ref>. When working with an executable file, we typically have information about the entire programincluding, potentially, library functionsthat is usually not available at compile time. <p> also plan to incorporate the results of alias analysis into our instruction scheduler as well as a number other optimizations, and expect to have more extensive experimental results for the utility of this information shortly. 5 Related Work While a number of systems have been described for link-time code optimization <ref> [5, 14, 15, 26, 29, 30, 32] </ref>, to the best of our knowledge none of these carry out any alias analysis on the executable files they process.
Reference: [31] <author> B. Steensgaard, </author> <title> Points-to Analysis in Almost Linear Time, </title> <booktitle> Proc. 23th. ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1996, </year> <pages> pp. 32-41 </pages>
Reference: [32] <author> D. W. Wall, </author> <title> Global Register Allocation at Link Time, </title> <booktitle> Proc. SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <month> July </month> <year> 1986, </year> <pages> pp. 264-275. </pages>
Reference-contexts: 1 Introduction Recent years have seen increasing interest in reasoning about and manipulating executable files <ref> [5, 14, 19, 24, 26, 29, 30, 32] </ref>. When working with an executable file, we typically have information about the entire programincluding, potentially, library functionsthat is usually not available at compile time. <p> also plan to incorporate the results of alias analysis into our instruction scheduler as well as a number other optimizations, and expect to have more extensive experimental results for the utility of this information shortly. 5 Related Work While a number of systems have been described for link-time code optimization <ref> [5, 14, 15, 26, 29, 30, 32] </ref>, to the best of our knowledge none of these carry out any alias analysis on the executable files they process.
Reference: [33] <author> W. E. Weihl, </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables, and label variables, </title> <booktitle> Proc. ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1980, </year> <pages> pp. 83-94. </pages>
Reference: [34] <author> R. P. Wilson and M. S. Lam, </author> <title> Efficient Context-Sensitive Pointer Analysis for C Programs, </title> <booktitle> Proc. SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 1-12. </pages>
Reference-contexts: The work most closely related to ours is that of Wilson and Lam <ref> [34] </ref>, who describe a low-level pointer alias analysis for C programs. Their work attempts to deal with nasty features of real programs and can handle simple pointer increments and decrements, but is unable to cope with the more complex address arithmetic common in executable code (see Example 3.2).
Reference: [35] <author> M. Wolfe, </author> <title> Optimizing Supercompilers for Supercomputers, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: As argued earlier, such analyses are of limited utility at the machine code level. Also related is the work on dependence analysis in the scientific computing literature (see, for example, <ref> [35, 36] </ref>). 10 While the goals of this work are conceptually similar to oursnamely, disambiguating array references whose indices can involve arithmetic expressionsthe algorithms used for dependence analysis are very different from that described here.
Reference: [36] <author> H. Zima and B. Chapman, </author> <title> Supercompilers for Parallel and Vector Computers, </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1991. </year> <month> 13 </month>
Reference-contexts: As argued earlier, such analyses are of limited utility at the machine code level. Also related is the work on dependence analysis in the scientific computing literature (see, for example, <ref> [35, 36] </ref>). 10 While the goals of this work are conceptually similar to oursnamely, disambiguating array references whose indices can involve arithmetic expressionsthe algorithms used for dependence analysis are very different from that described here.
References-found: 36

