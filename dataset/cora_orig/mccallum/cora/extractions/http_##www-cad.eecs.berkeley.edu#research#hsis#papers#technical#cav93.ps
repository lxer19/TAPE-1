URL: http://www-cad.eecs.berkeley.edu/research/hsis/papers/technical/cav93.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/research/hsis/index.html
Root-URL: 
Title: Abstract  
Abstract: Formal design verification should be used to reveal bugs early in the design cycle. A tool exhibiting counter-examples (a debugger) is therefore essential. We describe debugging techniques for two important approaches to formal design verification: model checking using Computation Tree Logic ([Cla86]) and language containment using L-automata ([Kur90]). The contributions of this work are: 
Abstract-found: 1
Intro-found: 1
Reference: [Agg83] <author> S. Aggarwal, R. P. Kurshan, K. Sabnani, </author> <title> A Calculus for Protocol Specification and Validation, in Protocol Specification, </title> <booktitle> Testing and Verification III (193) North-Holland, </booktitle> <pages> pp. 19-34. </pages>
Reference: [Alu92] <author> R. Alur, A. Itai, R. P. Kurshan, </author> <title> Timing Verification by Successive Approximation, Computer-Aided Verification, </title> <year> 1992. </year>
Reference-contexts: A debug trace can be used in another context: timing verification. In some situations, a property holds if realistic timing constraints are considered. An example of a timing constraint is the system can stay in state for only 2 ns. A method used in [Bal92] and <ref> [Alu92] </ref> is not to consider all timing constraints. If the property holds of the system when only a subset of timing constraints is considered, we are done. Otherwise, the debugger is called to find a counterexample.
Reference: [Bal92] <author> Felice Balarin, A. S. Vincentelli, </author> <title> A Verification Strategy for Timing-Constrained Systems, </title> <booktitle> Fourth Workshop On Computer-Aided Verification, </booktitle> <year> 1992. </year>
Reference-contexts: A debug trace can be used in another context: timing verification. In some situations, a property holds if realistic timing constraints are considered. An example of a timing constraint is the system can stay in state for only 2 ns. A method used in <ref> [Bal92] </ref> and [Alu92] is not to consider all timing constraints. If the property holds of the system when only a subset of timing constraints is considered, we are done. Otherwise, the debugger is called to find a counterexample.
Reference: [Cla86] <author> E. M. Clarke, E. A. Emerson, A. P. Sistla. </author> <title> Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications, </title> <journal> ACM Transactions on Programming Languages and Systems. </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference: [Eme87] <author> E. A. Emerson, C. L. Lei, </author> <title> Modalities for Model Checking: Branching Time Logic Strikes Back, </title> <booktitle> Science of Computer Programming 8, </booktitle> <pages> 275-306, </pages> <publisher> Elsevier Science Publishers, </publisher> <year> 1987. </year>
Reference-contexts: A canonical fairness constraint (CFC) is a fairness constraint of the form , where and are atomic prop ositions. Lemma (<ref> [Eme87] </ref>) Any general fairness constraint can be expressed as a CFC; but, the translation may be exponential. However, [Eme87] argues that most practical fairness constraints can be represented efficiently using CFCs. In practice, usually a subset of the CFCs is supported, e.g. , where is one of the two infinitary operators.
Reference: [Hoj92] <author> Ramin Hojati, Herve Touati, Robert P. Kurshan, Robert K. Brayton, </author> <title> Efficient w-Regular Language Containment, Computer-Aided Verification, </title> <year> 1992. </year>
Reference-contexts: When existential quantification is used, the user has to interact with the debugger to find the source of error. For ACTL formulas the debugger is capable of returning the debug trace automatically, although the option to interact is provided. An important feature of the algorithms presented in <ref> [Hoj92] </ref> for LC using L-automata is early failure detection (EFD). Here, we enhance these techniques by avoiding the full reachability set for simple errors. We apply the same ideas to ACTL formulas, described in positive normal form (PNF). <p> This feature is important for EFD, where a subset of bad states is passed to the debugger. 1.3 Outline In section 2, we introduce some preliminary concepts, and present some utilities. In section 3, we present debugging algorithms for LC. In section 4, we enhance EFD algorithms of <ref> [Hoj92] </ref> for LC, and describe how one finds error traces when EFD is used. Section 5 describes techniques for debugging of fair CTL formulas, using the utilities in section 3. <p> The first BDD-based algorithm for this problem was presented in [Tou91] ([Ste92] implemented a debugger based on ideas of [Tou91]). This algorithm depended on having the transitive closure of system. However, as <ref> [Hoj92] </ref> points out the transitive closure computation is rather expensive. Here, we present another debugger which needs very little pre-processed information. Specifically, we only assume there are some bad states, and we are given a set containing all bad states. <p> Here, we present another debugger which needs very little pre-processed information. Specifically, we only assume there are some bad states, and we are given a set containing all bad states. Recall that a state is bad if it is contained in some bad cycle. Note that the algorithms of <ref> [Hoj92] </ref> return a set which is larger than the set of bad states. Definition A bad CSCC of is one that is not completely contained in any one of its cycle sets. Lemma A CSCC is bad iff it contains a bad cycle (see the orem 2). <p> x i = l 1= x Q S Q S = g i l x m x y x 1 y= P x 1 ( )= x i P P x 1 P 4 Early Failure Detection In this section, we describe an enhancement of the technique for EFD in <ref> [Hoj92] </ref>. This attempts to avoid computing the full-reachability set. We also explain how our debugger works with EFD. 4.1 Enhanced Early Failure Detection Let . <p> It has been noted in practice many simple errors lead to bad cycles of the first or second kind. Techniques of <ref> [Hoj92] </ref> find these errors quickly. However, these techniques still first compute the full reachability set, when in practice many early errors can be computed with only a partial set of reachable states. <p> R f AGf= x f x R p AXf f It should be noted that the large difference in running times between LC and MC in property checking is partly due to the fact that the full computation is avoided in the case of LC, since the EFD techniques of <ref> [Hoj92] </ref> find a cycle of the first kind early in the computation. It is possible that these techniques can be extended to MC as well. 7 Conclusion We presented BDD-based debugging techniques (which can deal with large graphs) for language containment using L-automata and fair CTL model checking. <p> Our debugger for LC has the following advantages. First, it requires very little information to compute a bad error trace; in general, it requires a set which includes some bad state. Hence, the debugger is able to work with the EFD algorithms of <ref> [Hoj92] </ref>. Second, if the input to the debugger contains all bad states, it returns an error trace whose path to the bad cycle is minimum. This is augmented with a short bad cycle using heuristics (we proved that the problem of finding a minimum length bad cycle in NP-complete). <p> The debugger for fair CTL is based on the LC debugger, using results of [Hoj93]. This debugger is interactive, in order to allow the user to explore many alternatives. We have also extended the techniques of <ref> [Hoj92] </ref> for EFD so that in some cases the full reachability computation can be avoided. This method of avoiding the full reachability set applies to LC and to ACTL formulas.
Reference: [Hoj93] <author> Ramin Hojati, Thomas Shiple, Robert Brayton, Robert Kurshan, </author> <title> A Unified Environment for Language Containment and Fair CTL Model Checking, </title> <booktitle> submitted to Design Automation Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Model checking (MC) using CTL and language containment using L-automata are two methods for property specification for which efficient verification algorithms exist. <ref> [Hoj93] </ref> described a technique for integrating fair CTL (an expressive member of the CTL family of logics) and LC using L-automata in one environment. In this paper, we first describe debugging algorithms for LC (section 2, 3 and 4), thereby building a debugging environment. <p> All that is required is that contains some bad state. The debugger guarantees that a bad cycle in is chosen whose distance to the initial states in minimum. 5 Debugging for Fair CTL <ref> [Hoj93] </ref> described a method for performing language containment using L-automata, and fair CTL model checking in a unified environment. Using these ideas, we describe algorithms for reporting errors for fair CTL formulas, which use the utilities presented in section 3. <p> This is augmented with a short bad cycle using heuristics (we proved that the problem of finding a minimum length bad cycle in NP-complete). The debugger for fair CTL is based on the LC debugger, using results of <ref> [Hoj93] </ref>. This debugger is interactive, in order to allow the user to explore many alternatives. We have also extended the techniques of [Hoj92] for EFD so that in some cases the full reachability computation can be avoided.
Reference: [GJ79] <author> R. Garey, D. S. Johnson, </author> <title> Computers and Intractability, </title>
References-found: 8

