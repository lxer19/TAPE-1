URL: ftp://ftp.cs.kun.nl/pub/CSI/SoftwEng.FunctLang/papers/baks-JLC93-3-6.ps.gz
Refering-URL: http://www.cs.kun.nl/~clean/Clean.Papers.html
Root-URL: 
Email: E-mail: steffen@cs.kun.nl  
Title: Principal Type Schemes for the Strict Type Assignment System  
Author: STEFFEN VAN BAKEL, 
Keyword: Lambda Calculus, type assignment systems, principal type scheme, intersection types, approximate normal forms  
Address: Nijmegen, Toernooiveld 1, 6525 ED Nijmegen, The Netherlands.  
Affiliation: Department of Informatics, Faculty of Mathematics and Informatics, University of  
Abstract: We study the strict type assignment system, a restriction of the intersection type discipline [6], and prove that it has the principal type property. We define, for a term M, the principal pair (of basis and type). We specify three operations on pairs, and prove that all pairs deducible for M can be obtained from the principal one by these operations, and that these map deducible pairs to deducible pairs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. van Bakel. </author> <title> Complete restrictions of the Intersection Type Discipline. </title> <journal> Theoretical Computer Science, </journal> <volume> 102:135 163, </volume> <year> 1992. </year>
Reference-contexts: It is, in this system, for example not possible to assign a type to the term (x:xx), and although the lambda terms (cd:d) and ((xyz:xz (yz))(ab:a)) are fi-equal, the principal type schemes for these terms are different. The intersection type discipline as presented in [9] (see also [6], and <ref> [1] </ref>) is an extension of Curry's system that does not have these drawbacks. The extension to Curry's system is essentially that terms and term-variables are allowed to have more than one type. <p> The rule () is introduced mainly to prove completeness of type assignment. In <ref> [1] </ref> two independent restrictions of the BCD-system are presented. <p> In <ref> [1] </ref> it is shown that the strict system is the kernel of the BCD-system: strict types are the types that are strictly needed to assign a type to a term in that system. <p> The most significant difference between the BCD-system and the strict one is that the former is closed for -reduction, whereas the latter is not. The main result proved for the strict system in <ref> [1] </ref> is that of completeness of type assignment without the -relation, by using inference type semantics as defined in [20] instead of the simple type semantics as defined in [16]. <p> The set of types assignable to a term M in the strict system is significantly smaller than the set of types assignable to M in the BCD-system. In fact, the results of <ref> [1] </ref> show that the strict type assignment system is the `minimal' intersection type assignment system. In particular, the problem of type checking for the strict system is less complicated than for the BCD-system. <p> In this paper we use the word `subtype' for a type that is a syntactic component of another type. 2 The Strict Type Assignment System In this section we present the strict type assignment system, as defined in <ref> [1] </ref>. It is an extension of Curry's system, and a restricted version of the BCD-system as presented in [6], in which the derivation rule () is no longer present, together with a restricted set of types. It is also a generalization of the CDV-system presented in [8]. <p> It seems straightforward to use the results of this paper to prove the principal type property for a strict intersection type assignment system without !, which is a strict subsystem of the intersection type assignment system without ! that was studied in <ref> [1] </ref> and [21]. There is, however, one great difficulty: the technique used in this paper cannot be used for such a proof. This is caused by the fact that the notion of type assignment without ! is not closed for fi-equality, as is remarked in [1]. <p> ! that was studied in <ref> [1] </ref> and [21]. There is, however, one great difficulty: the technique used in this paper cannot be used for such a proof. This is caused by the fact that the notion of type assignment without ! is not closed for fi-equality, as is remarked in [1]. Take for example the two lambda terms yz:(b:z)(yz) and yz:z. Notice that the first term reduces to the second. Let ` ! denote the notion of derivability in the system without !.
Reference: [2] <author> S. van Bakel. </author> <title> Partial Intersection Type Assignment of Rank 2 in Applicative Term Rewriting Systems. </title> <type> Technical Report 92-03, </type> <institution> Department of Computer Science, University of Nijmegen, </institution> <year> 1992. </year>
Reference-contexts: Since the strict system is closed under fi-equality, type assignment in this system is not decidable, but semi-decidable. This means of course that in an implementation of the strict system some restrictions have to be made, as is done for example in [10] and <ref> [2] </ref>. Limiting the notion of type assignment by restricting the situations in which the derivation rules can be applied (the technique used in [10]), or by limiting the structure of types (as is done in [2]) changes the notion of type assignment, and, therefore, also the principal types for these systems <p> system some restrictions have to be made, as is done for example in [10] and <ref> [2] </ref>. Limiting the notion of type assignment by restricting the situations in which the derivation rules can be applied (the technique used in [10]), or by limiting the structure of types (as is done in [2]) changes the notion of type assignment, and, therefore, also the principal types for these systems differ. The general outline of this paper is as follows: in Section 2 we present the strict type assignment system.
Reference: [3] <author> S. van Bakel. </author> <title> Essential Intersection Type Assignment. </title> <booktitle> Proceedings of FST&TCS '93. 13 th Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: As a counter example, take fx:!g ` s x:!. Notice that ! L "t !, but we can not derive fx:!g ` S x:"t !. (A notion of type assignment that is a minor variant of the strict system is presented in <ref> [3] </ref>. (A short version of this paper appeared as [4].) This variant consists of replacing the type assignment rule ("E) of the strict system by one for ( L ), also allowed only for term-variables.
Reference: [4] <author> S. van Bakel. </author> <title> Partial Intersection Type Assignment in Applicative Term Rewriting Systems. </title> <editor> In M. Bezem, J.F. Groote, editors, </editor> <booktitle> Proceedings of TLCA '93. International Conference on Typed Lambda Calculi and Applications, Utrecht, The Netherlands, volume 664 of Lecture Notes in Computer Science, </booktitle> <pages> pages 29-44. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Notice that ! L "t !, but we can not derive fx:!g ` S x:"t !. (A notion of type assignment that is a minor variant of the strict system is presented in [3]. (A short version of this paper appeared as <ref> [4] </ref>.) This variant consists of replacing the type assignment rule ("E) of the strict system by one for ( L ), also allowed only for term-variables. In this way a notion of type assignment is obtained that is truly the essential intersection type assignment system.
Reference: [5] <author> H. Barendregt. </author> <title> The Lambda Calculus: its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <note> revised edition, </note> <year> 1984. </year>
Reference-contexts: Many of the now existing type assignment systems for functional programming languages that use the `untyped'-approach are based on (extensions of) the Curry type assignment system [11, 12] for the pure, untyped lambda calculus <ref> [5] </ref>. For example, the functional programming language ML [19] is in fact an extended lambda calculus and its type system is based on Curry's system. <p> Finally, in Subsection 5.2 we generalize this result to arbitrary lambda terms. We assume the reader to be familiar with the lambda calculus. For definitions and notions used here, see <ref> [5] </ref>. In this paper, the symbol ' (often indexed, like in ' i ) will be a type-variable and the greek symbols like , -, , , , and t will range over types. <p> As in [8, 22], in this section we define, for each term in ?-normal form, a principal pair (basis and type) in the strict type assignment system. (We will generalize these to arbitrary lambda terms in Subsection 5.2.) As in <ref> [5] </ref>, we use here the symbol ? instead of . Definition 3.1 ([5]) 1. The set of fl?-terms is defined as the set of lambda terms, extended by ? 2 fl?. 2.
Reference: [6] <author> H. Barendregt, M. Coppo, and M. Dezani-Ciancaglini. </author> <title> A filter lambda model and the completeness of type assignment. </title> <journal> The Journal of Symbolic Logic, </journal> <volume> 48(4) </volume> <pages> 931-940, </pages> <year> 1983. </year>
Reference-contexts: It is, in this system, for example not possible to assign a type to the term (x:xx), and although the lambda terms (cd:d) and ((xyz:xz (yz))(ab:a)) are fi-equal, the principal type schemes for these terms are different. The intersection type discipline as presented in [9] (see also <ref> [6] </ref>, and [1]) is an extension of Curry's system that does not have these drawbacks. The extension to Curry's system is essentially that terms and term-variables are allowed to have more than one type. <p> The first type assignment system with intersection types was presented in [7]; the CDV-system with intersection types and ! is introduced in [9] and in [23]. The best-known intersection type assignment system is the BCD-system, as presented in <ref> [6] </ref>, that is an extension of the CDV-system: there it is strengthened further by introducing a partial order relation `' on types as well as adding the type assignment rule () and a more general form of the rules concerning intersection. <p> The results presented in this paper show that this is not the case.) For the system as defined in <ref> [6] </ref>, principal type schemes can be defined as in [22]. There three operations are provided substitution, expansion, and rise that are sound and sufficient to generate all suitable pairs for a term M from its principal pair. <p> In the strict type assignment system these rules are not present and there is a one-one relationship between terms and skeletons of derivations: that system is syntax directed. Moreover, in <ref> [6] </ref> the relation induces an equivalence relation ~ on types. <p> The main result of this paper the proof of the principal type property for the strict system is then, that if one wants to use intersection types in a type-checker, there is no need to restrict the types as in [8], or to extend the types as in <ref> [6] </ref>; one can use the strict types. The results of this paper can be used as a guideline to develop type-inferencing (and type-checking) algorithms using strict types in functional programming languages. Since the strict system is closed under fi-equality, type assignment in this system is not decidable, but semi-decidable. <p> It is an extension of Curry's system, and a restricted version of the BCD-system as presented in <ref> [6] </ref>, in which the derivation rule () is no longer present, together with a restricted set of types. It is also a generalization of the CDV-system presented in [8]. Strict types and strict derivations are closely related. Strict derivations are syntax directed and yield strict types.
Reference: [7] <author> M. Coppo and M. Dezani-Ciancaglini. </author> <title> An Extension of the Basic Functionality Theory for the -Calculus. </title> <journal> Notre Dame, Journal of Formal Logic, </journal> <volume> 21(4) </volume> <pages> 685-693, </pages> <year> 1980. </year>
Reference-contexts: By introducing this extension a system is obtained that is closed under fi-equality: if B ` M : and M = fi N , then B ` N :. The first type assignment system with intersection types was presented in <ref> [7] </ref>; the CDV-system with intersection types and ! is introduced in [9] and in [23].
Reference: [8] <author> M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. </author> <title> Principal type schemes and -calculus semantics. </title> <editor> In J. R. Hindley and J. P. Seldin, editors, To H. B. </editor> <booktitle> Curry, Essays in combinatory logic, lambda-calculus and formalism, </booktitle> <pages> pages 535-560. </pages> <publisher> Academic press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: There exists two of those systems for which this property is proved. In <ref> [8] </ref> principal type schemes are defined for a type assignment system that is a restriction of the system as presented in [9]. <p> Therefore, in this system it is impossible to derive ' 0 !' 1 !' 0 for the lambda term ab:a. That type is derivable for that term in Curry's system. (There is one important remark to be made. On page 540 of <ref> [8] </ref> it is suggested that it is straightforward to extend the results of that paper to an intersection type assignment system that is a true extension of Curry's system. <p> In fact, the results of [1] show that the strict type assignment system is the `minimal' intersection type assignment system. In particular, the problem of type checking for the strict system is less complicated than for the BCD-system. As shown in Section 3 of this paper, the results of <ref> [8] </ref> and [22] do not provide principal types for the strict system. <p> The main result of this paper the proof of the principal type property for the strict system is then, that if one wants to use intersection types in a type-checker, there is no need to restrict the types as in <ref> [8] </ref>, or to extend the types as in [6]; one can use the strict types. The results of this paper can be used as a guideline to develop type-inferencing (and type-checking) algorithms using strict types in functional programming languages. <p> The operation of lifting is new and forms the strict counterpart of the operation of rise as defined in [22]. The operation of substitution is a modification of the one normally used. The operation of expansion coincides with the one given in <ref> [8, 22] </ref>. 4 Principal Type Schemes In order to prove that the operations defined are sufficient, we define three subsets of the set of all pairs of basis and type, namely: principal pairs (Section 3), ground pairs (Subsection 4.2) and primitive pairs (Subsection 4.3). (The definition of ground pairs coincides with <p> Schemes In order to prove that the operations defined are sufficient, we define three subsets of the set of all pairs of basis and type, namely: principal pairs (Section 3), ground pairs (Subsection 4.2) and primitive pairs (Subsection 4.3). (The definition of ground pairs coincides with the one given in <ref> [8] </ref>.) We show that these form a true hierarchy, that the set of admissible ground pairs for a term is closed under the operation of expansion, that the set of primitive pairs is closed under the operation of lifting, and that the set of pairs is closed for substitution. <p> It is an extension of Curry's system, and a restricted version of the BCD-system as presented in [6], in which the derivation rule () is no longer present, together with a restricted set of types. It is also a generalization of the CDV-system presented in <ref> [8] </ref>. Strict types and strict derivations are closely related. Strict derivations are syntax directed and yield strict types. Intersection type schemes occur in strict types only as subtypes at the left-hand Principal Type Schemes 5 side of an arrow type scheme. <p> Proof. By Lemmas 2.4 and 2.6, and Definition 2.7. 3 Principal pairs for terms in ?-normal form In <ref> [8] </ref> principal pairs are defined for a type assignment system similar to the strict system. In [22] principal pairs are defined for the BCD-system. In order to understand the necessity of defining principal pairs for the strict system, we focus on the differences between the latter and the other two. <p> In [22] principal pairs are defined for the BCD-system. In order to understand the necessity of defining principal pairs for the strict system, we focus on the differences between the latter and the other two. In the CDV-system as presented in <ref> [8] </ref>, instead of using intersections in bases, it is allowed to let a basis contain several statements whose subject is a term-variable. <p> It is not possible to derive x:' 0 !' 1 !' 0 from the basis fx:' 0 !!!' 0 g in the strict system. So the results of <ref> [8] </ref> and [22] do not provide principal types for the strict type assignment system. In proving that the strict type assignment system has the principal pair property, we could have used the same technique as [18]. <p> A major difference between that technique and the one used in this paper (which is similar to the one used in [15], <ref> [8] </ref>, and [22]), is that the latter provides, given a pair hB, i suitable for A, a sequence of operations that will transform the principal pair of A into hB, i. <p> The technique of [18] is sufficient to show that for every term in ?-normal form there exists a principal type, but not to provide the way of creating a suitable pair from the principal one, as is done in this paper. As in <ref> [8, 22] </ref>, in this section we define, for each term in ?-normal form, a principal pair (basis and type) in the strict type assignment system. (We will generalize these to arbitrary lambda terms in Subsection 5.2.) As in [5], we use here the symbol ? instead of . <p> This pair will be called the principal pair of A. Definition 3.2 (cf. <ref> [8, 22] </ref>) 1. Let A 2 N . pp (A), the principal pair of A, is defined by: (a) pp (?) = h;, !i. (c) If A 0 6= ?, and pp (A 0 ) = hP 0 , 0 i, then: i. <p> Notice that if hP , i 2 P, then 2 T s , and that if pp (A) = hP , i, then P is used for A:. The principal pairs for lambda terms in the systems as presented in <ref> [8] </ref> and [22] are exactly the same. <p> The operation of substitution defined in Subsection 4.1 is a slight modification of the one normally used; this modification is needed to make sure that substitution is closed on strict types. The operation of expansion defined in Subsection 4.2 coincides with the one given in <ref> [8, 22] </ref>. The operations of lifting defined in Subsection 4.3 is new, and forms the strict counterpart of the operation of rise. It deals with the introduction of extra (types to) statements in the basis of a derivation and introduces extra types for term-variables that are bound. <p> Proof. By induction on the definition of ` S , using Definition 4.1, and Lemmas 4.2 and 4.3. 4.2 Expansion The operation of expansion, as defined in this subsection, corresponds to the one given in <ref> [8] </ref> and is a simplified version of the one defined in [22]. It is an operation on types that deals with the replacement of (sub)types by an intersection of a number of copies of that type. <p> The definition of the operation of expansion can be found in Definition 4.10; it is based on the definition of a type-expansion, as given in Definition 4.6. The definition of expansion as presented here is different from the ones given in <ref> [8] </ref> and [22]. In those definitions subtypes are collected, whereas this definition collects type-variables. Definition 4.5 The last type-variable of a strict type is defined by: 1. The last type-variable of ' is '. 2. <p> Easy, using Definitions 4.10 and 4.6, and Lemma 4.7. We now prove that the operation of expansion is closed on the set of ground pairs, as defined in <ref> [8] </ref>. This property is needed in the proof that the operations defined in this paper are complete (as given in Subsection 5). Ground pairs are those pairs that can be obtained from principal pairs (and ground pairs) by expansion. Definition 4.12 ([8]) The pair hB, i is a ground pair for <p> So hfB 1 0 , fx:t 1 0 !'gg, 'i is a ground pair for xA 1 : : : A m . Example 4.15 (cf. <ref> [8] </ref>) Take the pair h;, (!!(' 0 !' 0 )!' 1 )!' 1 i, which is the principal pair for x:x?(y:y). [x:!!(' 0 !' 0 )!' 1 ] [y:' 0 ] x?(y:y):' 1 Take the expansion E = h' 0 !' 0 , 2i. <p> Since our definition of principal pairs of an approximate normal form coincides with the corresponding definition in <ref> [8] </ref> and [22], we can use the following result proved there: Theorem 5.6 ([8, 22]) 1.
Reference: [9] <author> M. Coppo, M. Dezani-Ciancaglini, and B. Venneri. </author> <title> Functional characters of solvable terms. </title> <journal> Zeitschrift fur Mathematische Logik und Grundlagen der Mathematik, </journal> <volume> 27 </volume> <pages> 45-58, </pages> <year> 1981. </year>
Reference-contexts: It is, in this system, for example not possible to assign a type to the term (x:xx), and although the lambda terms (cd:d) and ((xyz:xz (yz))(ab:a)) are fi-equal, the principal type schemes for these terms are different. The intersection type discipline as presented in <ref> [9] </ref> (see also [6], and [1]) is an extension of Curry's system that does not have these drawbacks. The extension to Curry's system is essentially that terms and term-variables are allowed to have more than one type. <p> The first type assignment system with intersection types was presented in [7]; the CDV-system with intersection types and ! is introduced in <ref> [9] </ref> and in [23]. <p> The strict type assignment system is constructed from the set of strict types and a slight extension of the derivation rules as defined in <ref> [9] </ref>. <p> There exists two of those systems for which this property is proved. In [8] principal type schemes are defined for a type assignment system that is a restriction of the system as presented in <ref> [9] </ref>. This system has as a disadvantage that it is not an extension of Curry's system: if B ` M :t , and the term-variable x does not occur in B, then for x:M only the type !!t can be derived.
Reference: [10] <author> M. Coppo and P. Giannini. </author> <title> A complete type inference algorithm for simple intersection types. </title> <editor> In J.-C. Raoult, editor, </editor> <booktitle> Proceedings of CAAP '92. 17th Colloquim on Trees in Algebra and Programming, Rennes, France, volume 581 of Lecture Notes in Computer Science, </booktitle> <pages> pages 102-123. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Since the strict system is closed under fi-equality, type assignment in this system is not decidable, but semi-decidable. This means of course that in an implementation of the strict system some restrictions have to be made, as is done for example in <ref> [10] </ref> and [2]. Limiting the notion of type assignment by restricting the situations in which the derivation rules can be applied (the technique used in [10]), or by limiting the structure of types (as is done in [2]) changes the notion of type assignment, and, therefore, also the principal types for <p> This means of course that in an implementation of the strict system some restrictions have to be made, as is done for example in <ref> [10] </ref> and [2]. Limiting the notion of type assignment by restricting the situations in which the derivation rules can be applied (the technique used in [10]), or by limiting the structure of types (as is done in [2]) changes the notion of type assignment, and, therefore, also the principal types for these systems differ. The general outline of this paper is as follows: in Section 2 we present the strict type assignment system.
Reference: [11] <author> H.B. Curry. </author> <title> Functionality in combinatory logic. </title> <journal> In Proc. Nat. Acad. Sci. U.S.A., </journal> <volume> volume 20, </volume> <pages> pages 584-590, </pages> <year> 1934. </year>
Reference-contexts: Many of the now existing type assignment systems for functional programming languages that use the `untyped'-approach are based on (extensions of) the Curry type assignment system <ref> [11, 12] </ref> for the pure, untyped lambda calculus [5]. For example, the functional programming language ML [19] is in fact an extended lambda calculus and its type system is based on Curry's system.
Reference: [12] <author> H.B. Curry and R. </author> <title> Feys. </title> <booktitle> Combinatory Logic. </booktitle> <volume> volume 1. </volume> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference-contexts: Many of the now existing type assignment systems for functional programming languages that use the `untyped'-approach are based on (extensions of) the Curry type assignment system <ref> [11, 12] </ref> for the pure, untyped lambda calculus [5]. For example, the functional programming language ML [19] is in fact an extended lambda calculus and its type system is based on Curry's system.
Reference: [13] <author> P. Giannini and S. Ronchi della Rocca. </author> <title> Characterization of Typings in Polymorphic Type Discipline. </title> <booktitle> In Proceedings of the Third Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 61-70, </pages> <year> 1988. </year>
Reference-contexts: There exist type assignment systems for which it is uncertain whether or not this property holds. For example, in the polymorphic type discipline [14], there is no known way to obtain the types (8'.')!(8'.') and (8'.'!')!(8'.'!') both types for the lambda term x:xx from a unique type. (See <ref> [13] </ref>.) Moreover, there exists no type derivable for x:xx such that both types can be obtained from by substitution. Although frequently used as a basis for type assignment algorithms for functional programming languages, the Curry type assignment system has drawbacks.
Reference: [14] <author> J.Y. Girard. </author> <title> The System F of Variable Types, Fifteen years later. </title> <journal> Theoretical Computer Science, </journal> <volume> 45 </volume> <pages> 159-192, </pages> <year> 1986. </year>
Reference-contexts: There exist type assignment systems for which it is uncertain whether or not this property holds. For example, in the polymorphic type discipline <ref> [14] </ref>, there is no known way to obtain the types (8'.')!(8'.') and (8'.'!')!(8'.'!') both types for the lambda term x:xx from a unique type. (See [13].) Moreover, there exists no type derivable for x:xx such that both types can be obtained from by substitution. <p> In that paper principal typings for the type assignment system as presented in [17] are studied. That system is a combination of the BCD-system and the polymorphic type discipline as presented in <ref> [14] </ref>. This combination can be seen as an extension of the BCD-system by adding the type constructor `8': if ' is a type-variable and is a type, then 8'. is a type. Also the type inclusion relation is extended in a natural way.
Reference: [15] <author> J.R. Hindley. </author> <title> The principal type scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <year> 1969. </year>
Reference-contexts: The type is then called the principal type for M . For Curry's system the operation O consists entirely of substitutions, i.e. operations that replace type-variables by types. (Principal type schemes for Curry's system are defined in <ref> [15] </ref>.) The existence of a principal type for a typeable lambda term M shows an internal coherence between all types that can be assigned to M . Since substitution is an easy operation, in Curry's system the set J. <p> A major difference between that technique and the one used in this paper (which is similar to the one used in <ref> [15] </ref>, [8], and [22]), is that the latter provides, given a pair hB, i suitable for A, a sequence of operations that will transform the principal pair of A into hB, i.
Reference: [16] <author> J.R. Hindley. </author> <title> The Completeness Theorem for Typing -terms. </title> <journal> Theoretical Computer Science, </journal> <volume> 22(1) </volume> <pages> 1-17, </pages> <year> 1983. </year>
Reference-contexts: The main result proved for the strict system in [1] is that of completeness of type assignment without the -relation, by using inference type semantics as defined in [20] instead of the simple type semantics as defined in <ref> [16] </ref>. As stated above, if for the construction of a type inference system for an untyped functional programming language instead of Curry's system a type assignment system with intersection types Principal Type Schemes 3 is to be used, then such a system should at least have the principal pair property.
Reference: [17] <author> B. Jacobs, I. Margaria, and M. Zacchi. </author> <title> Filter Models with Polymorphic Types. </title> <journal> Theoretical Computer Science, </journal> <volume> 95 </volume> <pages> 143-158, </pages> <year> 1992. </year> <title> 28 Principal Type Schemes </title>
Reference-contexts: In proving that the strict type assignment system has the principal pair property, we could have used the same technique as [18]. In that paper principal typings for the type assignment system as presented in <ref> [17] </ref> are studied. That system is a combination of the BCD-system and the polymorphic type discipline as presented in [14].
Reference: [18] <author> I. Margaria and M. Zacchi. </author> <title> Principal Typing in a 8"-Discipline. </title> <journal> Journal of Logic and Computation, </journal> <note> to appear. </note>
Reference-contexts: So the results of [8] and [22] do not provide principal types for the strict type assignment system. In proving that the strict type assignment system has the principal pair property, we could have used the same technique as <ref> [18] </ref>. In that paper principal typings for the type assignment system as presented in [17] are studied. That system is a combination of the BCD-system and the polymorphic type discipline as presented in [14]. <p> Also the type inclusion relation is extended in a natural way. The type assignment rules consist of (!I), (!E), (8I), ("I), () and (!) the rules ("E) and (8E) are omitted since they can be derived from (). The technique used in <ref> [18] </ref> is the following: For every A in ?-normal form (see Definition 3.1) a relation A is defined on the inductively defined set of pairs hB, i admissible for A (i.e. such that B ` A:). <p> The technique of <ref> [18] </ref> is sufficient to show that for every term in ?-normal form there exists a principal type, but not to provide the way of creating a suitable pair from the principal one, as is done in this paper.
Reference: [19] <author> R. Milner. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: Many of the now existing type assignment systems for functional programming languages that use the `untyped'-approach are based on (extensions of) the Curry type assignment system [11, 12] for the pure, untyped lambda calculus [5]. For example, the functional programming language ML <ref> [19] </ref> is in fact an extended lambda calculus and its type system is based on Curry's system. It is well known that in Curry's system, the problem of typeability Given a term M , are there B and such that B ` M : (i.e.
Reference: [20] <author> J.C. Mitchell. </author> <title> Polymorphic Type Inference and Containment. </title> <journal> Information and Computation, </journal> <volume> 76 </volume> <pages> 211-249, </pages> <year> 1988. </year>
Reference-contexts: The main result proved for the strict system in [1] is that of completeness of type assignment without the -relation, by using inference type semantics as defined in <ref> [20] </ref> instead of the simple type semantics as defined in [16].
Reference: [21] <author> S. Ronchi della Rocca. </author> <title> Principal type scheme and unification for intersection type discipline. </title> <journal> Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 181-209, </pages> <year> 1988. </year>
Reference-contexts: A (M ) is infinite. Then there exist a pair hP , i 2 (M ) and a strict chain C such that C (hP , i) = hB, i. Final remarks In <ref> [21] </ref> a unification semi-algorithm for intersection types is presented, together with a semi-algorithm PP that finds the principal type for every strongly normalizable lambda term. The unification algorithm is built on the operations of substitution and expansion and is only proved correct when used inside the procedure PP. <p> The unification algorithm is built on the operations of substitution and expansion and is only proved correct when used inside the procedure PP. Because in this paper we prove that the strict type assignment system has the principal type property, it is possible, as in <ref> [21] </ref>, to implement an efficient semi-algorithm for finding types for untyped lambda terms, using the here defined operations. <p> It seems straightforward to use the results of this paper to prove the principal type property for a strict intersection type assignment system without !, which is a strict subsystem of the intersection type assignment system without ! that was studied in [1] and <ref> [21] </ref>. There is, however, one great difficulty: the technique used in this paper cannot be used for such a proof. This is caused by the fact that the notion of type assignment without ! is not closed for fi-equality, as is remarked in [1]. <p> This means that the approach of this paper cannot be used, since there is no counterpart for Theorem 5.4 in this system. This problem can be solved in a different way. In <ref> [21] </ref>, section 6 it is overcome by defining a unification procedure for !-free intersection types, and a proof for the statement that the procedure PP' (as specified in that section) which calls this unification procedure, returns in fact the principal pair for a lambda term within the system without !. <p> Notice that in the same way as the BCD-system was restricted to obtain the strict system, the system without ! of <ref> [21] </ref> can be restricted to obtain a strict system without !. As mentioned before, the algorithm for the computation of principal pairs in both the BCD-system and the strict system is exactly the same; in both cases the procedure PP suffices.
Reference: [22] <author> S. Ronchi della Rocca and B. Venneri. </author> <title> Principal type schemes for an extended type theory. </title> <journal> Theoretical Computer Science, </journal> <volume> 28 </volume> <pages> 151-169, </pages> <year> 1984. </year>
Reference-contexts: The results presented in this paper show that this is not the case.) For the system as defined in [6], principal type schemes can be defined as in <ref> [22] </ref>. There three operations are provided substitution, expansion, and rise that are sound and sufficient to generate all suitable pairs for a term M from its principal pair. <p> In particular, the problem of type checking for the strict system is less complicated than for the BCD-system. As shown in Section 3 of this paper, the results of [8] and <ref> [22] </ref> do not provide principal types for the strict system. <p> In Section 4 we define three operations on pairs of basis and types: substitution (Subsection 4.1), expansion (Subsection 4.2), and lifting (Subsection 4.3). The operation of lifting is new and forms the strict counterpart of the operation of rise as defined in <ref> [22] </ref>. The operation of substitution is a modification of the one normally used. <p> The operation of lifting is new and forms the strict counterpart of the operation of rise as defined in [22]. The operation of substitution is a modification of the one normally used. The operation of expansion coincides with the one given in <ref> [8, 22] </ref>. 4 Principal Type Schemes In order to prove that the operations defined are sufficient, we define three subsets of the set of all pairs of basis and type, namely: principal pairs (Section 3), ground pairs (Subsection 4.2) and primitive pairs (Subsection 4.3). (The definition of ground pairs coincides with <p> Proof. By Lemmas 2.4 and 2.6, and Definition 2.7. 3 Principal pairs for terms in ?-normal form In [8] principal pairs are defined for a type assignment system similar to the strict system. In <ref> [22] </ref> principal pairs are defined for the BCD-system. In order to understand the necessity of defining principal pairs for the strict system, we focus on the differences between the latter and the other two. <p> That type is derivable for that term in the strict system. The restriction being made from the BCD-system to the strict system consists of eliminating the derivation rule (). This rule plays an important part in <ref> [22] </ref>, where the derivation rule ("E) is left out because it is in fact derivable from (). <p> It is not possible to derive x:' 0 !' 1 !' 0 from the basis fx:' 0 !!!' 0 g in the strict system. So the results of [8] and <ref> [22] </ref> do not provide principal types for the strict type assignment system. In proving that the strict type assignment system has the principal pair property, we could have used the same technique as [18]. In that paper principal typings for the type assignment system as presented in [17] are studied. <p> A major difference between that technique and the one used in this paper (which is similar to the one used in [15], [8], and <ref> [22] </ref>), is that the latter provides, given a pair hB, i suitable for A, a sequence of operations that will transform the principal pair of A into hB, i. <p> The technique of [18] is sufficient to show that for every term in ?-normal form there exists a principal type, but not to provide the way of creating a suitable pair from the principal one, as is done in this paper. As in <ref> [8, 22] </ref>, in this section we define, for each term in ?-normal form, a principal pair (basis and type) in the strict type assignment system. (We will generalize these to arbitrary lambda terms in Subsection 5.2.) As in [5], we use here the symbol ? instead of . <p> This pair will be called the principal pair of A. Definition 3.2 (cf. <ref> [8, 22] </ref>) 1. Let A 2 N . pp (A), the principal pair of A, is defined by: (a) pp (?) = h;, !i. (c) If A 0 6= ?, and pp (A 0 ) = hP 0 , 0 i, then: i. <p> Notice that if hP , i 2 P, then 2 T s , and that if pp (A) = hP , i, then P is used for A:. The principal pairs for lambda terms in the systems as presented in [8] and <ref> [22] </ref> are exactly the same. <p> The operation of substitution defined in Subsection 4.1 is a slight modification of the one normally used; this modification is needed to make sure that substitution is closed on strict types. The operation of expansion defined in Subsection 4.2 coincides with the one given in <ref> [8, 22] </ref>. The operations of lifting defined in Subsection 4.3 is new, and forms the strict counterpart of the operation of rise. It deals with the introduction of extra (types to) statements in the basis of a derivation and introduces extra types for term-variables that are bound. <p> Proof. By induction on the definition of ` S , using Definition 4.1, and Lemmas 4.2 and 4.3. 4.2 Expansion The operation of expansion, as defined in this subsection, corresponds to the one given in [8] and is a simplified version of the one defined in <ref> [22] </ref>. It is an operation on types that deals with the replacement of (sub)types by an intersection of a number of copies of that type. <p> The definition of the operation of expansion can be found in Definition 4.10; it is based on the definition of a type-expansion, as given in Definition 4.6. The definition of expansion as presented here is different from the ones given in [8] and <ref> [22] </ref>. In those definitions subtypes are collected, whereas this definition collects type-variables. Definition 4.5 The last type-variable of a strict type is defined by: 1. The last type-variable of ' is '. 2. <p> Definition 4.5 The last type-variable of a strict type is defined by: 1. The last type-variable of ' is '. 2. The last type-variable of 1 " " n !t (n 0) is the last type-variable of t . Definition 4.6 (cf. <ref> [22] </ref>) For every 2 T s , n 2, basis B and 2 T S , the quadruple h, n, B, i determines a type-expansion T h;n;B;i : T S ! T S , that is constructed as follows. 1. <p> The next theorem is also proved in <ref> [22] </ref> for the BCD-system, and states that expansion is a sound operation on pairs. Theorem 4.17 If B ` S A:, and h, ni (hB, i) = hB 0 , 0 i, then B 0 ` S A: 0 . Proof. <p> Also this notion of type assignment has the principal type property; the needed operations are exactly the same as defined in this paper for the strict system, only for the proof of that property one could use the exact same technique as used in <ref> [22] </ref>, which is different from the one used here.) As in Definition 2.5 (1) with the relation S we extend the relation L to bases. For the relation L the following properties hold: 20 Principal Type Schemes Lemma 4.19 1. <p> Proof. 1. By Theorems 4.14, 4.25, and 4.4. 2. By Theorem 5.2. 5.2 Principal pairs for lambda terms We conclude this paper by, like in <ref> [22] </ref>, generalizing the concept of principal pairs to arbitrary lambda terms, using the fact that hB, i is a suitable pair for M if and only if there is an A 2 A (M ) such that hB, i is a suitable pair for A. <p> Theorem 5.4 ([1]) B ` S M : () 9 A 2 A (M ) [ B ` S A: ]. Definition 5.5 (cf. <ref> [22] </ref>) 1. For all terms M we define the set (M ) as follows: (M ) = fhP , i j 9 A 2 A (M ) [ pp (A) = hP , i ]g. 2. <p> Since our definition of principal pairs of an approximate normal form coincides with the corresponding definition in [8] and <ref> [22] </ref>, we can use the following result proved there: Theorem 5.6 ([8, 22]) 1. <p> The principal pair of M is then the infinite set of pairs (M ). By Theorems 5.4 and 5.3, we have the following: Theorem 5.7 (cf. <ref> [22] </ref>) Let M 2 fl, and B and such that B ` S M :. 1. A (M ) is finite. Let hP , i be the principal pair of M . Then there exists a strict chain C such that C (hP , i) = hB, i. 2.
Reference: [23] <author> P. </author> <title> Salle. Une extension de la theorie des types. </title> <editor> In G. Ausiello and C. Bohm, editors, </editor> <booktitle> Automata, languages and programming. Fifth Colloquium, Udine, Italy, volume 62 of Lecture Notes in Computer Science, </booktitle> <pages> pages 398-410. </pages> <publisher> Springer-Verlag, </publisher> <year> 1978. </year> <note> Received 3 August 1992 </note>
Reference-contexts: The first type assignment system with intersection types was presented in [7]; the CDV-system with intersection types and ! is introduced in [9] and in <ref> [23] </ref>.
References-found: 23

