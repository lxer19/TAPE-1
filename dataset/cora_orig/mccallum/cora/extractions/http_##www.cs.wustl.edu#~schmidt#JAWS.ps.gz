URL: http://www.cs.wustl.edu/~schmidt/JAWS.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/ACE-papers.html
Root-URL: 
Email: jxh@cs.wustl.edu  schmidt@cs.wustl.edu  
Title: JAWS: A Framework for High-performance Web Servers  
Author: James C. Hu Douglas C. Schmidt 
Address: St. Louis, MO 63130  
Affiliation: Department of Computer Science Washington University  
Abstract: Developers of communication software face many challenges. Communication software contains both inherent complexities, such as fault detection and recovery, and accidental complexities, such as the continuous re-rediscovery and re-invention of key concepts and components. Meeting these challenges requires a thorough understanding of object-oriented application frameworks and patterns. This paper illustrates how we have applied frameworks and patterns for communication software to develop a high-performance Web server called JAWS. JAWS is an object-oriented framework that supports the configuration of various Web server strategies, such as a Thread Pool concurrency model with asynchronous I/O and LRU caching vs.. a Thread-per-Request concurrency model with synchronous I/O and LFU caching. Because JAWS is a framework, these strategies can be customized systematically and measured both independently and collaboratively to determine the best strategy profiles. Using these profiles, JAWS can statically and dynamically adapt its behavior to deploy the most effective strategies for a given software/hardware platform and workload. JAWS' adaptive software features make it a powerful application framework for constructing high-performance Web servers. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Hu, I. Pyarali, and D. C. Schmidt, </author> <title> Measuring the Impact of Event Dispatching and Concurrency Models on Web Server Performance Over High-speed Networks, </title> <booktitle> in Proceedings of the 2 nd Global Internet Conference, IEEE, </booktitle> <month> November </month> <year> 1997. </year>
Reference-contexts: Likewise, Web protocols and browsers are increasingly applied to specialized computation-ally expensive tasks, such as image processing servers used by fl The work described here was made possible by funds from Siemens AG, Eastman Kodak, and NSF Research Grant NCR-9628218. Siemens <ref> [1] </ref> and Kodak [2] and database search engines such as AltaVista and Lexis-Nexis. To keep pace with increasing demand, it is essential to develop high-performance Web servers. However, developers face a remarkably rich set of design strategies when configuring and optimizing Web servers. <p> Thread Pool), dispatching models (such as synchronous vs. asynchronous dispatching), file caching models (such as LRU vs. LFU), and protocol processing models (such as HTTP/1.0 vs. HTTP/1.1). No single configuration is optimal for all hardware/software platform and workloads <ref> [1, 3] </ref>. The existence of all these alternative strategies ensures that Web servers can be tailored to their users' needs. However, navigating through many design and optimization strategies is tedious and error-prone. <p> In contrast, OO class libraries provide the raw materials necessary to build applications, but no guidance as to how to put the pieces together. This paper focuses on the patterns and framework components used to develop a high-performance Web server called JAWS <ref> [1, 3] </ref>. JAWS is both a Web server and a framework from which other types of servers can be built. The JAWS framework itself was developed using the ACE framework [6, 7]. The ACE framework reifies key patterns [5] in the domain of communication software. <p> More sophisticated Single-Threaded implementations attempt to process multiple requests concurrently using asynchronous or reactive I/O (which are described in Section 3.4). Single-threaded concurrency strategies can perform better than multi-threaded solutions on uni-processor machines that support asynchronous I/O <ref> [1] </ref>. Since JAWS' I/O framework is orthogonal to its concurrency framework, we consider the Single-Threaded concurrency strategy as a special case of the Thread Pool where the pool size is 1. Experiments in [1] and [3] demonstrate that the choice of concurrency and event dispatching strategies significantly affect the performance of <p> Single-threaded concurrency strategies can perform better than multi-threaded solutions on uni-processor machines that support asynchronous I/O <ref> [1] </ref>. Since JAWS' I/O framework is orthogonal to its concurrency framework, we consider the Single-Threaded concurrency strategy as a special case of the Thread Pool where the pool size is 1. Experiments in [1] and [3] demonstrate that the choice of concurrency and event dispatching strategies significantly affect the performance of Web servers that experience varying load conditions. In particular, no single server strategy provides optimal performance for all cases. Thus, a server framework should provide at least two degrees of freedom: 1. <p> The synchronous I/O strategy: Synchronous I/O describes the model of I/O interaction between a Web server process and the kernel. In this model, the kernel does not return the thread of control to the server until the requested I/O operation either completes, completes partially, or fails. <ref> [1] </ref> shows that synchronous I/O usually performs well for small file transfers on Windows NT over high-speed ATM networks. Synchronous I/O is well known to UNIX server programmers and is arguably the easiest to use. However, there are disadvantages to this model. <p> The disadvantage of asynchronous I/O is that it is not available on many OS platforms (particularly UNIX). In addition, writing asynchronous programs can be more complicated than writing synchronous programs [21, 22, 28]. 3.4.3 JAWS I/O Strategy Framework Empirical studies in <ref> [1] </ref> systematically subjected different server strategies to various load conditions. The results reveal that each I/O strategy behaves differently under different load conditions. Furthermore, no single I/O strategy performed optimally under all load conditions. <p> This section summarizes the most significant determinants of Web server performance. These observations are based on our studies <ref> [1, 3] </ref> of existing Web server designs and implementation strategies, as well as our experience tuning JAWS. These studies reveal the primary targets for optimizations to develop high performance Web servers. Lightweight concurrency: Process-based concurrency mechanisms can yield poor performance, as seen in [3].
Reference: [2] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: Likewise, Web protocols and browsers are increasingly applied to specialized computation-ally expensive tasks, such as image processing servers used by fl The work described here was made possible by funds from Siemens AG, Eastman Kodak, and NSF Research Grant NCR-9628218. Siemens [1] and Kodak <ref> [2] </ref> and database search engines such as AltaVista and Lexis-Nexis. To keep pace with increasing demand, it is essential to develop high-performance Web servers. However, developers face a remarkably rich set of design strategies when configuring and optimizing Web servers. <p> The ACE framework reifies key patterns [5] in the domain of communication software. The framework and patterns in JAWS and ACE are representative of solutions that have been applied successfully to communication systems ranging from telecommunication system management [8] to enterprise medical imaging <ref> [2] </ref> and real-time avionics [9].
Reference: [3] <author> J. Hu, S. Mungee, and D. C. Schmidt, </author> <title> Principles for Developing and Measuring High-performance Web Servers over ATM, </title> <booktitle> in Proceeedings of INFOCOM '98, </booktitle> <month> March/April </month> <year> 1998. </year>
Reference-contexts: Thread Pool), dispatching models (such as synchronous vs. asynchronous dispatching), file caching models (such as LRU vs. LFU), and protocol processing models (such as HTTP/1.0 vs. HTTP/1.1). No single configuration is optimal for all hardware/software platform and workloads <ref> [1, 3] </ref>. The existence of all these alternative strategies ensures that Web servers can be tailored to their users' needs. However, navigating through many design and optimization strategies is tedious and error-prone. <p> In contrast, OO class libraries provide the raw materials necessary to build applications, but no guidance as to how to put the pieces together. This paper focuses on the patterns and framework components used to develop a high-performance Web server called JAWS <ref> [1, 3] </ref>. JAWS is both a Web server and a framework from which other types of servers can be built. The JAWS framework itself was developed using the ACE framework [6, 7]. The ACE framework reifies key patterns [5] in the domain of communication software. <p> Then, we explain how each JAWS framework is structured to support the configuration of alternative strategy profiles. 3.3 Concurrency Strategies 3.3.1 Design Challenges Concurrency strategies impact the design and performance of a Web system significantly. Empirical studies <ref> [3] </ref> of existing Web servers, including Roxen, Apache, PHTTPD, Zeus, Netscape and the Java Web server, indicate that a large portion of non-I/O related Web server overhead is due to the Web server's concurrency strategy. Key overheads include synchronization, thread/process creation, and context switching. <p> Since JAWS' I/O framework is orthogonal to its concurrency framework, we consider the Single-Threaded concurrency strategy as a special case of the Thread Pool where the pool size is 1. Experiments in [1] and <ref> [3] </ref> demonstrate that the choice of concurrency and event dispatching strategies significantly affect the performance of Web servers that experience varying load conditions. In particular, no single server strategy provides optimal performance for all cases. Thus, a server framework should provide at least two degrees of freedom: 1. <p> However, a limitation of CGI is that the server must spawn a new process to extend server functionality. It is typical for each request requiring CGI to spawn its own process to handle it, causing the server to behave as a Process-per-Request server, which is a performance inhibitor <ref> [3] </ref>. The challenge for a high-performance Web server framework is to allow developers to extend server functionality without resorting to CGI processes. 3.5.2 Alternative Solution Strategies Most Web servers conceptually process or transform a stream of data in several stages. <p> Thus, the composition of the components causes a chain of calls pulling data through the pipeline. The chain ends at the component responsible for retrieving the raw input, which derives directly from Protocol Pipeline abstraction. 3.6 File Caching Strategies 3.6.1 Design Challenges The results in <ref> [3] </ref> show that accessing the filesystem is a significant source of overhead for Web servers. Most distributed applications can benefit from caching, and Web servers are no exception. Therefore, it is not surprising that research on Web server performance focuses on file caching to achieve better performance [29, 30]. <p> This section summarizes the most significant determinants of Web server performance. These observations are based on our studies <ref> [1, 3] </ref> of existing Web server designs and implementation strategies, as well as our experience tuning JAWS. These studies reveal the primary targets for optimizations to develop high performance Web servers. Lightweight concurrency: Process-based concurrency mechanisms can yield poor performance, as seen in [3]. <p> These studies reveal the primary targets for optimizations to develop high performance Web servers. Lightweight concurrency: Process-based concurrency mechanisms can yield poor performance, as seen in <ref> [3] </ref>. In multi-processor systems, a process-based concurrency mechanism might perform well, especially when the number of processes are equal to the number of processors. In this case, each processor can run a Web server process and context switching overhead is minimized. <p> However, the use synchronization penalizes performance. Thus, it is important to minimize the number of locks acquired (or released) during the request lifecycle. In <ref> [3] </ref>, it is shown that servers that average a lower number of lock operations per request perform much better than servers that perform a high number of lock operations. In some cases, acquiring and releasing locks can also result in preemption.
Reference: [4] <author> R. Johnson, </author> <title> Frameworks = Patterns + Components, </title> <journal> Communications of the ACM, </journal> <volume> vol. 40, </volume> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: An OO class libarary is a collection of software object implemetations that provide reusable functionality as the user calls into the object methods. A framework is a reusable, semi-complete application that can be specialized to produce custom applications <ref> [4] </ref>. A pattern represents a recurring solution to a software development problem within a particular context [5]. A component refers to a reifiable object. Both OO class libraries and frameworks are collections of components that are reified by instantiation and specialization. <p> re-invention of standard Web server components by implementing common design patterns and factoring out common implementation roles. 2.3 Relationship Between Frameworks, Pat terns, and Other Reuse Techniques Frameworks provide reusable software components for applications by integrating sets of abstract classes and defining standard ways that instances of these classes collaborate <ref> [4] </ref>. In general, the components are not self-contained, since they usually depend upon functionality provided by other components within the framework. However, the collection of these components forms a partial implementation, i.e., an application skeleton. This skeleton can be customized by inheriting and instantiating from reusable components in the framework. <p> We used JAWS as an example of how frameworks and patterns can enable programmers to avoid common pitfalls of developing Web server software. Together, patterns and frameworks support the reuse of integrated components and design abstractions <ref> [4] </ref>. 14 Section 3 has described how the JAWS framework is archi--tected and the strategies it provides. To articulate the organization of JAWS' design, we outlined the strategic and tactical design patterns that had the largest impact on the JAWS framework.
Reference: [5] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: A framework is a reusable, semi-complete application that can be specialized to produce custom applications [4]. A pattern represents a recurring solution to a software development problem within a particular context <ref> [5] </ref>. A component refers to a reifiable object. Both OO class libraries and frameworks are collections of components that are reified by instantiation and specialization. <p> JAWS is both a Web server and a framework from which other types of servers can be built. The JAWS framework itself was developed using the ACE framework [6, 7]. The ACE framework reifies key patterns <ref> [5] </ref> in the domain of communication software. The framework and patterns in JAWS and ACE are representative of solutions that have been applied successfully to communication systems ranging from telecommunication system management [8] to enterprise medical imaging [2] and real-time avionics [9]. <p> Patterns and frameworks help alleviate the continual re-discovery and re-invention of key Web server concepts and components by capturing solutions to common software development problems <ref> [5] </ref>. The benefits of patterns for Web servers: Patterns document the structure and participants in common Web server micro-architectures. For instance, the Reactor [14] and Active Object [15] patterns are widely used as Web server dispatching and concurrency strategies, respectively. <p> In particular, software developers are solely responsible for identifying and applying patterns in designing their applications. In contrast to class libraries, components in a framework are more active. In particular, they manage the canonical flow of control within an application via event dispatching patterns like Reactor [14] and Observer <ref> [5] </ref>. The callback-driven run-time architecture of a framework is shown in Figure 2. inversion of control at run-time. This design enables the canonical application processing steps to be customized by event handler objects that are invoked via the framework's reactive dispatching mechanism [14]. <p> New incoming requests are serviced by a concurrency strategy. As events are processed, they are dispatched to the Protocol Handler, which is parameterized by an I/O strategy. The ability to dynamically bind to a particular concurrency strategy and I/O strategy from a range of alternatives follows the Strategy pattern <ref> [5] </ref>. Concurrency Strategy: This framework implements con-currency mechanisms (such as Single Threaded, Thread-per-Request, or Thread Pool) that can be selected adaptively at run-time using the State pattern [5] or pre-determined at initialization-time. <p> The ability to dynamically bind to a particular concurrency strategy and I/O strategy from a range of alternatives follows the Strategy pattern <ref> [5] </ref>. Concurrency Strategy: This framework implements con-currency mechanisms (such as Single Threaded, Thread-per-Request, or Thread Pool) that can be selected adaptively at run-time using the State pattern [5] or pre-determined at initialization-time. The Service Configurator pattern [20] is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern [15]. <p> Multiple I/O mechanisms can be used simultaneously. Asynchronous I/O is implemented via the Proactor [21] and Asynchronous Completion Token [22] patterns. Reactive I/O is accomplished through the Reactor pattern [14]. Reactive I/O utilizes the Memento pattern <ref> [5] </ref> to capture and externalize the state of a request so that it can be restored at a later time. Protocol Handler: This framework allows system developers to apply the JAWS framework to a variety of Web system applications. <p> Protocol Handler: This framework allows system developers to apply the JAWS framework to a variety of Web system applications. A Protocol Handler is parameterized by a con-currency strategy and an I/O strategy. These strategies remain opaque to the protocol handler by following the Adapter <ref> [5] </ref> pattern. In JAWS, this component implements the parsing and handling of HTTP/1.0 request methods. The abstraction allows for other protocols (such as HTTP/1.1 and DICOM) to be incorporated easily into JAWS. <p> Pipeline components can be linked dynamically at run-time using the Service Configurator pattern. 5 Cached Virtual Filesystem: The component improves Web server performance by reducing the overhead of filesystem accesses. Various caching strategies, such as LRU, LFU, Hinted, and Structured, can be selected following the Strategy pattern <ref> [5] </ref>. This allows different caching strategies to be profiled for effectiveness and enables optimal strategies to be configured statically or dynamically. The cache for each Web server is instantiated using the Singleton pattern [5]. <p> Various caching strategies, such as LRU, LFU, Hinted, and Structured, can be selected following the Strategy pattern <ref> [5] </ref>. This allows different caching strategies to be profiled for effectiveness and enables optimal strategies to be configured statically or dynamically. The cache for each Web server is instantiated using the Singleton pattern [5]. Tilde Expander: This component is another cache component that uses a perfect hash table [24] that maps abbreviated user login names (e.g., ~schmidt) to user home directories (e.g., /home/cs/faculty/schmidt). <p> JAWS uses the Acceptor pattern to adaptively change its concurrency and I/O strategies independently from its connection management strategy. Figure 5 illustrates the structure of the Acceptor pattern in the context of JAWS. The Acceptor is a factory <ref> [5] </ref>. It creates, accepts, and activates a new Protocol Handler whenever the Event Dispatcher notifies it that a connection has arrived from a client. <p> The following tactical patterns are used in JAWS: The Strategy pattern: This pattern defines a family of algorithms, encapsulates each one, and make them interchangeable <ref> [5] </ref>. JAWS uses this pattern extensively to selectively configure different cache replacement strategies without affecting the core software architecture of the Web server. The Adapter pattern: This pattern transforms a nonconforming interface into one that can be used by a client [5]. <p> of algorithms, encapsulates each one, and make them interchangeable <ref> [5] </ref>. JAWS uses this pattern extensively to selectively configure different cache replacement strategies without affecting the core software architecture of the Web server. The Adapter pattern: This pattern transforms a nonconforming interface into one that can be used by a client [5]. JAWS uses this pattern in its I/O Strategy Framework to uniformly encapsulate the operations of synchronous, asynchronous and reactive I/O operations. The State pattern: This pattern defines a composite object whose behavior depends upon its state [5]. <p> transforms a nonconforming interface into one that can be used by a client <ref> [5] </ref>. JAWS uses this pattern in its I/O Strategy Framework to uniformly encapsulate the operations of synchronous, asynchronous and reactive I/O operations. The State pattern: This pattern defines a composite object whose behavior depends upon its state [5]. The Event Dispatcher component in JAWS uses the State pattern to seamlessly support different concurrency strategies and both synchronous and asynchronous I/O. The Singleton pattern: This pattern ensures a class only has one instance and provides a global point of access to it [5]. <p> whose behavior depends upon its state <ref> [5] </ref>. The Event Dispatcher component in JAWS uses the State pattern to seamlessly support different concurrency strategies and both synchronous and asynchronous I/O. The Singleton pattern: This pattern ensures a class only has one instance and provides a global point of access to it [5]. JAWS uses a Singleton to ensure that only one copy of its Cached Virtual Filesystem exists in a Web server process. In contrast to the strategic patterns described earlier, tactical pattern have a relatively localized impact on a software design.
Reference: [6] <author> D. C. Schmidt and T. Suda, </author> <title> An Object-Oriented Framework for Dynamically Configuring Extensible Distributed Communication Systems, </title> <journal> IEE/BCS Distributed Systems Engineering Journal (Special Issue on Configurable Distributed Systems), </journal> <volume> vol. 2, </volume> <pages> pp. 280293, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: This paper focuses on the patterns and framework components used to develop a high-performance Web server called JAWS [1, 3]. JAWS is both a Web server and a framework from which other types of servers can be built. The JAWS framework itself was developed using the ACE framework <ref> [6, 7] </ref>. The ACE framework reifies key patterns [5] in the domain of communication software. The framework and patterns in JAWS and ACE are representative of solutions that have been applied successfully to communication systems ranging from telecommunication system management [8] to enterprise medical imaging [2] and real-time avionics [9].
Reference: [7] <author> D. C. Schmidt, </author> <title> Applying Design Patterns and Frameworks to Develop Object-Oriented Communication Software, in Handbook of Programming Languages (P. Salus, </title> <editor> ed.), </editor> <publisher> MacMillan Computer Publishing, </publisher> <year> 1997. </year>
Reference-contexts: This paper focuses on the patterns and framework components used to develop a high-performance Web server called JAWS [1, 3]. JAWS is both a Web server and a framework from which other types of servers can be built. The JAWS framework itself was developed using the ACE framework <ref> [6, 7] </ref>. The ACE framework reifies key patterns [5] in the domain of communication software. The framework and patterns in JAWS and ACE are representative of solutions that have been applied successfully to communication systems ranging from telecommunication system management [8] to enterprise medical imaging [2] and real-time avionics [9].
Reference: [8] <author> D. C. Schmidt, </author> <title> A Family of Design Patterns for Application-level Gateways, </title> <journal> The Theory and Practice of Object Systems (Special Issue on Patterns and Pattern Languages), </journal> <volume> vol. 2, no. 1, </volume> <year> 1996. </year>
Reference-contexts: The ACE framework reifies key patterns [5] in the domain of communication software. The framework and patterns in JAWS and ACE are representative of solutions that have been applied successfully to communication systems ranging from telecommunication system management <ref> [8] </ref> to enterprise medical imaging [2] and real-time avionics [9].
Reference: [9] <author> T. H. Harrison, D. L. Levine, and D. C. Schmidt, </author> <title> The Design and Performance of a Real-time CORBA Event Service, </title> <booktitle> in Proceedings of OOPSLA '97, </booktitle> <address> (Atlanta, GA), </address> <publisher> ACM, </publisher> <month> October </month> <year> 1997. </year>
Reference-contexts: The ACE framework reifies key patterns [5] in the domain of communication software. The framework and patterns in JAWS and ACE are representative of solutions that have been applied successfully to communication systems ranging from telecommunication system management [8] to enterprise medical imaging [2] and real-time avionics <ref> [9] </ref>.
Reference: [10] <author> D. C. Schmidt and C. Cleeland, </author> <title> Applying Patterns to Develop Extensible and Maintainable ORB Middleware, </title> <journal> Communications of the ACM, </journal> <note> to appear, </note> <year> 1998. </year>
Reference-contexts: Unfortunately, native OS APIs are not an effective way to develop Web servers or other types of communication middle-ware and applications <ref> [10] </ref>. The following are common pitfalls associated with the use of native OS APIs: Excessive low-level details: Building Web servers with native OS APIs requires developers to have intimate knowledge of low-level OS details.
Reference: [11] <author> M. K. McKusick, K. Bostic, M. J. Karels, and J. S. Quarter-man, </author> <title> The Design and Implementation of the 4.4BSD Operating System. </title> <publisher> Addison Wesley, </publisher> <year> 1996. </year>
Reference-contexts: High potential for errors: Programming to low-level OS APIs is tedious and error-prone due to their lack of type-safety. For example, most Web servers are programmed with the Socket API <ref> [11] </ref>. However, endpoints of communication in the Socket API are represented as untyped handles. This increases the potential for subtle programming mistakes and run-time errors. Lack of portability: Low-level OS APIs are notoriously non-portable, even across releases of the same OS. <p> The reactive I/O strategy: Early versions of UNIX provided synchronous I/O exclusively. System V UNIX introduced non-blocking I/O to avoid the blocking problem. However, non-blocking I/O requires the Web server to poll the kernel to discover if any input is available <ref> [11] </ref>. Reactive I/O alleviates the blocking problems of synchronous I/O without resorting to polling. In this model, a Web server uses an OS event demultiplexing system call (e.g. select in UNIX or WaitForMultipleObjects in Win32) to determine which socket handles can perform I/O.
Reference: [12] <institution> Information Technology Portable Operating System Interface (POSIX) Part 1: System Application: Program Interface (API) [C Language], </institution> <year> 1995. </year>
Reference-contexts: Steep learning curve: Due to the excessive level of detail, the effort required to master OS-level APIs can be very high. For instance, it is hard to learn how to program with POSIX asynchronous I/O <ref> [12] </ref> correctly. It is even harder to learn how to write a portable application using asynchronous I/O mechanisms since they differ widely across OS platforms. Inability to handle increasing complexity: OS APIs define basic interfaces to mechanisms like process and thread management, interprocess communication, file systems, and memory management.
Reference: [13] <author> W. R. Stevens, </author> <title> UNIX Network Programming, Second Edition. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: However, these basic interfaces do not scale up gracefully as applications grow in size and complexity. For instance, a typical UNIX process allows a backlog of only ~7 pending connections <ref> [13] </ref>. This number is inadequate for heavily accessed Web servers that must handle hundreds of simultaneous clients. 2.2 Overcoming Web Server Pitfalls with Pat terns and Frameworks Software reuse is a a widely touted method of reducing development effort. Reuse leverages the domain knowledge and prior effort of experienced developers.
Reference: [14] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, </editor> <booktitle> eds.), </booktitle> <pages> pp. 529545, </pages> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Patterns and frameworks help alleviate the continual re-discovery and re-invention of key Web server concepts and components by capturing solutions to common software development problems [5]. The benefits of patterns for Web servers: Patterns document the structure and participants in common Web server micro-architectures. For instance, the Reactor <ref> [14] </ref> and Active Object [15] patterns are widely used as Web server dispatching and concurrency strategies, respectively. These patterns are generalizations of object-structures that have proven useful to build flexible and efficient Web servers. <p> In particular, software developers are solely responsible for identifying and applying patterns in designing their applications. In contrast to class libraries, components in a framework are more active. In particular, they manage the canonical flow of control within an application via event dispatching patterns like Reactor <ref> [14] </ref> and Observer [5]. The callback-driven run-time architecture of a framework is shown in Figure 2. inversion of control at run-time. This design enables the canonical application processing steps to be customized by event handler objects that are invoked via the framework's reactive dispatching mechanism [14]. <p> event dispatching patterns like Reactor <ref> [14] </ref> and Observer [5]. The callback-driven run-time architecture of a framework is shown in Figure 2. inversion of control at run-time. This design enables the canonical application processing steps to be customized by event handler objects that are invoked via the framework's reactive dispatching mechanism [14]. When events occur, the framework's dispatcher reacts by invoking hook methods on pre-registered handler objects, which perform application-specific processing on the events. <p> I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously. Asynchronous I/O is implemented via the Proactor [21] and Asynchronous Completion Token [22] patterns. Reactive I/O is accomplished through the Reactor pattern <ref> [14] </ref>. Reactive I/O utilizes the Memento pattern [5] to capture and externalize the state of a request so that it can be restored at a later time. Protocol Handler: This framework allows system developers to apply the JAWS framework to a variety of Web system applications. <p> The Reactor pattern: This pattern decouples the synchronous event demultiplexing and event handler notification dispatching logic of server applications from the service (s) performed in response to events <ref> [14] </ref>. JAWS uses the Reactor pattern to process multiple synchronous events from multiple sources of events, without polling all event sources or blocking indefinitely on any single source of events. Figure 6 illustrates the structure of the Reactor pattern in the context of JAWS. <p> When the call returns, the server can perform I/O on the returned handles, i.e., the server reacts to multiple events occurring on separate handles. Reactive I/O is widely used by event-driven applications (such as X windows) and has been codified as the Reactor design pattern <ref> [14] </ref>. Unless reactive I/O is carefully encapsulated, however, the technique is error-prone due to the complexity of managing multiple I/O handles. Moreover, reactive I/O may not make effective use of multiple CPUs. <p> Each I/O strategy issues requests using the appropriate mechanism. For instance, the Synchronous IO component utilizes the traditional blocking read and write system calls; the Asynchronous IO performs requests according to the Proactor pattern [21]; and Reactive IO utilizes the Reactor pattern <ref> [14] </ref>. 11 An InputOutput component is created with respect to the stream associated by the Acceptor from the Task component described in Section 3.3. File operations are performed with respect to a Filecache Handle component, described in Section 3.6.
Reference: [15] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Object Behavioral Pattern for Concurrent Programming, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: The benefits of patterns for Web servers: Patterns document the structure and participants in common Web server micro-architectures. For instance, the Reactor [14] and Active Object <ref> [15] </ref> patterns are widely used as Web server dispatching and concurrency strategies, respectively. These patterns are generalizations of object-structures that have proven useful to build flexible and efficient Web servers. <p> The Service Configurator pattern [20] is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern <ref> [15] </ref>. I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously. Asynchronous I/O is implemented via the Proactor [21] and Asynchronous Completion Token [22] patterns. Reactive I/O is accomplished through the Reactor pattern [14]. <p> The Proactor pattern is used by the asynchronous variant of the Thread Pool in Section 3.3.2. The Active Object pattern: This pattern decouples method invocation from method execution, allowing methods to run concurrently <ref> [15] </ref>. JAWS uses the Active Object pattern to execute client requests concurrently in separate threads of control. in the context of JAWS. The Protocol Handler issues requests to the Scheduler, which transforms the request method (such as an HTTP request) into Method Objects that are stored on an Activation Queue.
Reference: [16] <author> D. C. Schmidt, </author> <title> Experience Using Design Patterns to Develop Reuseable Object-Oriented Communication Software, </title> <journal> Communications of the ACM (Special Issue on Object-Oriented Experiences), </journal> <volume> vol. 38, </volume> <month> October </month> <year> 1995. </year>
Reference-contexts: However, reuse of patterns alone is not sufficient to create flexible and efficient Web server software. While patterns enable reuse of abstract design and architecture knowledge, abstractions documented as patterns do not directly yield reusable code <ref> [16] </ref>. Therefore, it is essential to augment the study of patterns with the creation and use of application frameworks.
Reference: [17] <author> A. Stepanov and M. Lee, </author> <title> The Standard Template Library, </title> <type> Tech. Rep. </type> <institution> HPL-94-34, Hewlett-Packard Laboratories, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: In practice, frameworks, class libraries, and components are complementary technologies. Frameworks often utilize class libraries and components internally to simplify the development of the framework. For instance, portions of the JAWS framework use the string and vector containers provided by the C++ Standard Template Library <ref> [17] </ref> to manage connection maps and other search structures.
Reference: [18] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: JAWS is structured as a framework of frameworks. The overall JAWS framework contains the following components and frameworks: an Event Dispatcher, Concurrency Strategy, I/O Strategy, Protocol Pipeline, Protocol Handlers, and Cached Virtual Filesystem. Each framework is structured as a set of collaborating objects implemented using components in ACE <ref> [18] </ref>. The collaborations among JAWS components and frameworks are guided by a family of patterns, which are listed along the borders in Figure 3. An outline of the key frameworks, components, and patterns in JAWS is presented below.
Reference: [19] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Initializing Communication Services, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: A more detailed description of how these patterns have been applied to JAWS' design will be shown in Section 3.2. Event Dispatcher: This component is responsible for coordinating JAWS' Concurrency Strategy with its I/O Strategy. The passive establishment of connections with Web clients follows the Acceptor pattern <ref> [19] </ref>. New incoming requests are serviced by a concurrency strategy. As events are processed, they are dispatched to the Protocol Handler, which is parameterized by an I/O strategy. <p> These patterns are also widely used to guide the architecture of many other types of communication software. The Acceptor pattern: This pattern decouples passive connection establishment from the service performed once the connection is established <ref> [19] </ref>. JAWS uses the Acceptor pattern to adaptively change its concurrency and I/O strategies independently from its connection management strategy. Figure 5 illustrates the structure of the Acceptor pattern in the context of JAWS. The Acceptor is a factory [5].
Reference: [20] <author> P. Jain and D. C. Schmidt, </author> <title> Service Configurator: A Pattern for Dynamic Configuration of Services, </title> <booktitle> in Proceedings of the 3 rd Conference on Object-Oriented Technologies and Systems, USENIX, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Concurrency Strategy: This framework implements con-currency mechanisms (such as Single Threaded, Thread-per-Request, or Thread Pool) that can be selected adaptively at run-time using the State pattern [5] or pre-determined at initialization-time. The Service Configurator pattern <ref> [20] </ref> is used to configure a particular concurrency strategy into a Web server at run-time. When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern [15]. I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O.
Reference: [21] <author> T. Harrison, I. Pyarali, D. C. Schmidt, and T. Jordan, </author> <title> Proac-tor An Object Behavioral Pattern for Dispatching Asynchronous Event Handlers, </title> <booktitle> in The 4 th Pattern Languages of Programming Conference (Washington University technical report #WUCS-97-34), </booktitle> <month> September </month> <year> 1997. </year>
Reference-contexts: When concurrency involves multiple threads, the strategy creates protocol handlers that follow the Active Object pattern [15]. I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously. Asynchronous I/O is implemented via the Proactor <ref> [21] </ref> and Asynchronous Completion Token [22] patterns. Reactive I/O is accomplished through the Reactor pattern [14]. Reactive I/O utilizes the Memento pattern [5] to capture and externalize the state of a request so that it can be restored at a later time. <p> The Reactor pattern is used by the Single-Threaded Web server concurrency model presented in Section 3.3.2. The Proactor pattern pattern: This pattern decouples the asynchronous event demultiplexing and event handler completion dispatching logic of server applications from the service (s) performed in response to events <ref> [21] </ref>. JAWS uses the Proactor pattern to perform server-specific processing, such as parsing the headers of a request, while asynchronously processing other I/O events. Figure 7 illustrates the structure of the Proactor pattern in the context of JAWS. <p> This allows the server to scale efficiently for operations with high I/O latency, such as large file transfers. The disadvantage of asynchronous I/O is that it is not available on many OS platforms (particularly UNIX). In addition, writing asynchronous programs can be more complicated than writing synchronous programs <ref> [21, 22, 28] </ref>. 3.4.3 JAWS I/O Strategy Framework Empirical studies in [1] systematically subjected different server strategies to various load conditions. The results reveal that each I/O strategy behaves differently under different load conditions. Furthermore, no single I/O strategy performed optimally under all load conditions. <p> The JAWS framework provides Synchronous, Asynchronous and Reactive IO component implementations derived from In-putOutput. Each I/O strategy issues requests using the appropriate mechanism. For instance, the Synchronous IO component utilizes the traditional blocking read and write system calls; the Asynchronous IO performs requests according to the Proactor pattern <ref> [21] </ref>; and Reactive IO utilizes the Reactor pattern [14]. 11 An InputOutput component is created with respect to the stream associated by the Acceptor from the Task component described in Section 3.3. File operations are performed with respect to a Filecache Handle component, described in Section 3.6.
Reference: [22] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Asynchronous Completion Token: an Object Behavioral Pattern for Efficient Asynchronous Event Handling, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: I/O Strategy: This framework implements various I/O mechanisms, such as asynchronous, synchronous and reactive I/O. Multiple I/O mechanisms can be used simultaneously. Asynchronous I/O is implemented via the Proactor [21] and Asynchronous Completion Token <ref> [22] </ref> patterns. Reactive I/O is accomplished through the Reactor pattern [14]. Reactive I/O utilizes the Memento pattern [5] to capture and externalize the state of a request so that it can be restored at a later time. <p> This allows the server to scale efficiently for operations with high I/O latency, such as large file transfers. The disadvantage of asynchronous I/O is that it is not available on many OS platforms (particularly UNIX). In addition, writing asynchronous programs can be more complicated than writing synchronous programs <ref> [21, 22, 28] </ref>. 3.4.3 JAWS I/O Strategy Framework Empirical studies in [1] systematically subjected different server strategies to various load conditions. The results reveal that each I/O strategy behaves differently under different load conditions. Furthermore, no single I/O strategy performed optimally under all load conditions.
Reference: [23] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: Protocol Pipeline: This framework allows filter operations to be incorporated easily with the data being processed by the Protocol Handler. This integration is achieved by employing the Adapter pattern. Pipelines follow the Pipes and Filters pattern <ref> [23] </ref> for input processing. Pipeline components can be linked dynamically at run-time using the Service Configurator pattern. 5 Cached Virtual Filesystem: The component improves Web server performance by reducing the overhead of filesystem accesses. <p> Thus, developers are left to custom engineer their own solutions without the benefits of an application framework based on design patterns. Structuring a server to process data in logical stages is known as the Pipes and Filters pattern <ref> [23] </ref>. While the pattern helps developers recognize how to organize the components of a processing pipeline, it does not provide a framework for doing so.
Reference: [24] <author> D. C. Schmidt, GPERF: </author> <title> A Perfect Hash Function Generator, </title> <booktitle> in Proceedings of the 2 nd C++ Conference, </booktitle> <address> (San Francisco, California), </address> <pages> pp. 87102, </pages> <publisher> USENIX, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: This allows different caching strategies to be profiled for effectiveness and enables optimal strategies to be configured statically or dynamically. The cache for each Web server is instantiated using the Singleton pattern [5]. Tilde Expander: This component is another cache component that uses a perfect hash table <ref> [24] </ref> that maps abbreviated user login names (e.g., ~schmidt) to user home directories (e.g., /home/cs/faculty/schmidt).
Reference: [25] <author> P. Jain and D. C. Schmidt, </author> <title> Service Configurator: A Pattern for Dynamic Configuration and Reconfiguration of Communication Services, </title> <booktitle> in The 3 rd Pattern Languages of Programming Conference (Washington University technical report #WUCS-97-07), </booktitle> <month> February </month> <year> 1997. </year>
Reference-contexts: The Service Configurator pattern: This pattern decouples the implementation of individual components in a system from the time when they are configured into the system. JAWS uses the Service Configurator pattern to dynamically optimize, control, and reconfigure the behavior of Web server strategies at installation-time or during run-time <ref> [25] </ref>. Figure 9 illustrates the structure of the Service Configurator pattern in the context of the Protocol Pipeline Filters and Caching Strategies. JAWS The figure depicts how the Service Configurator can dynamically manage DLLs, which are dynamically linked libraries.
Reference: [26] <author> T. Berners-Lee, R. T. Fielding, and H. Frystyk, </author> <title> Hypertext Transfer Protocol HTTP/1.0, Informational RFC 1945, </title> <institution> Network Working Group, </institution> <month> May </month> <year> 1996. </year> <note> Available from http://www.w3.org/. </note>
Reference-contexts: For example, if both the Web client and Web server are HTTP/1.1 compliant, Thread-per-Session can be used between them. However, if either the client or server only supports HTTP/1.0, then Thread-per-Session degrades to Thread-per-Request <ref> [26, 27] </ref>. Thread Pool: In this model, a group of threads are pre-spawned during Web server initialization. Each thread from the pool retrieves a task from a job queue. While the thread is processing the job, it is removed from the pool.
Reference: [27] <author> R. Fielding, J. Gettys, J. Mogul, H. Frystyk, and T. Berners-Lee, </author> <title> Hypertext Transfer Protocol HTTP/1.1, Standards Track RFC 2068, </title> <institution> Network Working Group, </institution> <month> January </month> <year> 1997. </year> <note> Available from http://www.w3.org/. </note>
Reference-contexts: For example, if both the Web client and Web server are HTTP/1.1 compliant, Thread-per-Session can be used between them. However, if either the client or server only supports HTTP/1.0, then Thread-per-Session degrades to Thread-per-Request <ref> [26, 27] </ref>. Thread Pool: In this model, a group of threads are pre-spawned during Web server initialization. Each thread from the pool retrieves a task from a job queue. While the thread is processing the job, it is removed from the pool.
Reference: [28] <author> D. C. Schmidt and C. D. Cranor, Half-Sync/Half-Async: </author> <title> an Architectural Pattern for Efficient and Well-structured Concurrent I/O, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: This allows the server to scale efficiently for operations with high I/O latency, such as large file transfers. The disadvantage of asynchronous I/O is that it is not available on many OS platforms (particularly UNIX). In addition, writing asynchronous programs can be more complicated than writing synchronous programs <ref> [21, 22, 28] </ref>. 3.4.3 JAWS I/O Strategy Framework Empirical studies in [1] systematically subjected different server strategies to various load conditions. The results reveal that each I/O strategy behaves differently under different load conditions. Furthermore, no single I/O strategy performed optimally under all load conditions.
Reference: [29] <author> J. C. Mogul, </author> <title> Hinted caching in the Web, </title> <booktitle> in Proceedings of the Seventh SIGOPS European Workshop: Systems Support for Worldwide Applications, </booktitle> <year> 1996. </year> <month> 20 </month>
Reference-contexts: Most distributed applications can benefit from caching, and Web servers are no exception. Therefore, it is not surprising that research on Web server performance focuses on file caching to achieve better performance <ref> [29, 30] </ref>. A cache is a storage medium that provides more efficient retrieval than the medium on which the desired information is normally located. In the case of a Web server, the cache resides in the server's main memory. <p> Thus, cache files that have been least frequently used are the first to be replaced in the cache. This strategy is relevant to Web systems with relatively static content, such as Lexis-Nexis and other databases of historical fact. Hinted caching: This form of caching is proposed in <ref> [29] </ref>. This strategy stems from analysis of Web page retrieval patterns that seem to indicate that Web pages have spatial locality. That is, a user browsing a Web page is likely to browse the links within the page. Hinted caching is related to pre-fetching, though [29] suggests that the HTTP protocol <p> of caching is proposed in <ref> [29] </ref>. This strategy stems from analysis of Web page retrieval patterns that seem to indicate that Web pages have spatial locality. That is, a user browsing a Web page is likely to browse the links within the page. Hinted caching is related to pre-fetching, though [29] suggests that the HTTP protocol be altered to allow statistical information about the links (or hints) to be sent back to the requester. This modification allows the client to decide which pages to pre-fetch.
Reference: [30] <author> S. Williams, M. Abrams, C. R. Standridge, G. Abdulla, and E. A. Fox, </author> <title> Removal Policies in Network Caches for World Wide Web Documents, </title> <booktitle> in Proceedings of SIGCOMM '96, </booktitle> <address> (Stanford, CA), </address> <pages> pp. 293305, </pages> <publisher> ACM, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: Most distributed applications can benefit from caching, and Web servers are no exception. Therefore, it is not surprising that research on Web server performance focuses on file caching to achieve better performance <ref> [29, 30] </ref>. A cache is a storage medium that provides more efficient retrieval than the medium on which the desired information is normally located. In the case of a Web server, the cache resides in the server's main memory.
Reference: [31] <author> E. P. Markatos, </author> <title> Main memory caching of web documents, </title> <booktitle> in Proceedings of the Fifth International World Wide Web Conference, </booktitle> <month> May </month> <year> 1996. </year>
Reference-contexts: However, employing a fixed caching strategy does not always provide optimal performance <ref> [31] </ref>. The JAWS Cached Virtual Filesystem Framework addresses this issue in two ways. For one, it allows the cache replacement algorithms and cache strategy to be easily integrated into the framework.
Reference: [32] <author> Gene Trent and Mark Sake, WebSTONE: </author> <title> The First Generation in HTTP Server Benchmarking. Silicon Graphics, </title> <publisher> Inc. </publisher> <address> whitepaper, </address> <month> February </month> <year> 1995. </year> <note> Available from http://www.sgi.com/. </note>
Reference-contexts: The two workstations were connected via an ATM network running through a FORE Systems ASX-200BX, with a maximum bandwidth of 622 Mbps. However, due to limitations of LAN emulation mode, the peak bandwidth of our testbed is approximately 120 Mbps. 4.2 Software Request Generator We used the WebSTONE <ref> [32] </ref> v2.0 benchmarking software to collect client- and server-side metrics. These metrics included average server throughput, and average client latency. Web-STONE is a standard benchmarking utility, capable of generating load requests that simulate typical Web server file access patterns.
Reference: [33] <author> A. Carlton, </author> <title> An Explanation of the SPECweb96 Benchmark. Standard Performance Evaluation Corporation whitepa-per, </title> <note> 1996. Available from http://www.specbench.org/. </note>
Reference-contexts: This table represents actual load conditions on popular servers, based on a study of file access patterns conducted by 15 Document Size Frequency 500 bytes 35% 5 Kbytes 50% 50 Kbytes 14% 5 Mbytes 1% Table 1: File Access Patterns SPEC <ref> [33] </ref>. 4.3 Experimental Results The results presented below compare the performance of several different adaptations of the JAWS Web server. We discuss the effect of different event dispatching and I/O models on throughput and latency. For this experiment, three adaptations of JAWS were used. 1.
Reference: [34] <author> H. F. Nielsen, J. Gettys, A. Baird-Smith, E. Prud'hommeaux, H. W. Lie, and C. Lilley, </author> <title> Network Performance Effects of HTTP/1.1, CSS1, </title> <journal> and PNG, </journal> <note> in To appear in Proceedings of ACM SIGCOMM '97, </note> <year> 1997. </year>
Reference-contexts: dispatching and file I/O model, depending on the server's workload and distribution of file requests. 17 4.4 A Summary of Techniques for Optimizing Web Servers From our research, we have found that it is possible to improve server performance with a superior server design (a similar observation was made in <ref> [34] </ref>). Thus, while it is undeniable that a hard-coded server (i.e., one that uses fixed concurrency, I/O, and caching strategies) can provide excellent performance, a flexible server framework, such as JAWS, does not necessarily correlate with poor performance. This section summarizes the most significant determinants of Web server performance.
Reference: [35] <author> M. S. </author> <title> Johns, Identification Protocol, Network Information Center RFC 1413, </title> <month> Feb. </month> <year> 1993. </year> <month> 21 </month>
Reference-contexts: This is typically done using reverse DNS lookups. Since these lookups often involve network I/O, they are very costly. Therefore, they should be avoided or completed asynchronously (using threads or asynchronous I/O). * Ident lookups: The Ident protocol <ref> [35] </ref> allows a Web server to obtain the user name for a given HTTP connection. This typically involves setting up a new TCP/IP connection to the user's machine and thus involves a round-trip delay.
References-found: 35

