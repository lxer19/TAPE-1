URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/93-02.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Email: email: sarnath@cs.buffalo.edu  
Phone: Phone (716)  
Title: Lower bounds for padded sorting and approximate counting  
Author: R.Sarnath 
Keyword: lower bounds, sorting, circuit complexity  
Address: 226, Bell Hall  Amherst NY 14260  636-3774  
Affiliation: Deptt of Computer Science  SUNY at Buffalo  
Abstract: We examine the relationship between running time and error of parallel sorting algorithms. This is done by applying Hastad's main lemma to relate the size depth and error of simple circuits, that sort an input of 0's and 1's. As a consequence, we obtain lower bounds for approximate counting as well. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Beame P. and Hastad J., </author> <title> Optimal bounds for decision problems on the CRCW PRAM. </title> <journal> J of the ACM, </journal> <volume> 36(3) </volume> <pages> 643-670, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Recently, attempts have been made to sidestep the lowerbound of Beame and Hastad <ref> [1] </ref>, by separating the sorting problem from the list ranking problem. These attempts have been of two kinds chain sorting, i.e., sorting the elements into a linked list [2], and padded sorting, i.e., sorting into a larger array [3,5,6]. <p> The algorithms in [5] require the elements to be uniformly distributed in a certain range, whereas the algorithms in [3,6] are for the general case. The question we examine here, is what must the size of the output array be, if the lowerbound of <ref> [1] </ref> must be circumvented? In other words, if an algorithm sorts n items using polynomially many processors in time o ( log n log log n ), what is the minimum required size of the ouput array? A lowerbound of n + f (n), where f (n) is o (n *
Reference: [2] <author> Hagerup T., </author> <title> Fast parallel space allocation, estimation and integer sorting, </title> <type> tech rep MPI-I-91-106, </type> <institution> Max Planck Institut fur Informatik, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Recently, attempts have been made to sidestep the lowerbound of Beame and Hastad [1], by separating the sorting problem from the list ranking problem. These attempts have been of two kinds chain sorting, i.e., sorting the elements into a linked list <ref> [2] </ref>, and padded sorting, i.e., sorting into a larger array [3,5,6]. The algorithms in [5] require the elements to be uniformly distributed in a certain range, whereas the algorithms in [3,6] are for the general case.
Reference: [3] <author> Hagerup T. and Raman R., </author> <title> Waste makes haste tight bounds for loose parallel sorting, </title> <note> to appear in Proc of 33rd annual IEEE FOCS. </note>
Reference: [4] <author> Hastad J., </author> <title> Almost optimal lower bounds for small depth circuits, </title> <booktitle> in proc of 18th annual ACM STOC, </booktitle> <pages> pp 6-20, </pages> <year> 1986. </year>
Reference-contexts: As it turns out, it is easier to derive the lowerbound for the case of padded sorting. 2 2 A lowerbound for padded sorting Our approach is very similar to the one in <ref> [4] </ref>, and we shall use the main lemma therein, along with the method of restrictions, to obtain our result. <p> This would imply that the depth-k circuit that we started with, does not exist. For the sake of completeness, we shall reproduce here, some definitions, and the main lemma from <ref> [4] </ref>. <p> Corollary 2:No circuit of depth d 0 1 exists, for n * -approximate counting, that satisfies the above constraints. 3 Conclusion The best upper bound on the size of the output array for general sorting is O (n) <ref> [4] </ref>. Clearly some work needs to be done to close this gap. If f (n) were log c n, we have a randomised PRAM algorithm for f (n)-approximate counting that uses o (n) processors and O (log log n) time.
Reference: [5] <author> Mackenzie P. and Stout Q., </author> <title> Ultra-fast expected time parallel algorithms. </title> <booktitle> Proc. of symposium on discrete algorithms, </booktitle> <pages> 414-424, </pages> <year> 1991. </year>
Reference-contexts: These attempts have been of two kinds chain sorting, i.e., sorting the elements into a linked list [2], and padded sorting, i.e., sorting into a larger array [3,5,6]. The algorithms in <ref> [5] </ref> require the elements to be uniformly distributed in a certain range, whereas the algorithms in [3,6] are for the general case. <p> This implies that a running time of log n c+log log n is unavoidable if the size of the final array is to be n + o (n * ). In this paper, we prove a better lowerbound we have shown, as a consequence of the main lemma in <ref> [5] </ref>, that any circuit of size polynomial in the size of the input, that sorts n items into an array of size n + n * 1, 0 &lt; * &lt; 1, requires depth at least ( (1*) log n log log n+c ), for some constant c.
Reference: [6] <author> Sarnath R., </author> <title> Doubly logarithmic time parallel sorting, </title> <type> manuscript. 5 </type>
References-found: 6

