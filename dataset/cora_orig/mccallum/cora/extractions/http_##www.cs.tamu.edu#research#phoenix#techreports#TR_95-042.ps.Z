URL: http://www.cs.tamu.edu/research/phoenix/techreports/TR_95-042.ps.Z
Refering-URL: http://www.cs.tamu.edu/research/phoenix/papers_bib.html
Root-URL: http://www.cs.tamu.edu
Title: Fault Tolerant Object Replication Algorithm  
Author: Ganesha Beedubail, Anish Karmarkar and Udo Pooch 
Address: College Station, TX 77843.  
Affiliation: Department of Computer Science, Texas A&M University,  
Abstract: Technical Report (TR 95-042) October 1995. Abstract This report describes a Fault Tolerant Object Replication Algorithm. The algorithm (protocol) uses Master/Slave configuration for replica consistency and fault tolerance. The novelty of this protocol is that, it is specified and implemented using only Remote Procedure Calls (RPCs). Lower layer (level) message passing mechanism is not used (which is usually difficult to implement and not easily portable on heterogeneous systems). To our knowledge this is the first protocol that is specified in terms of RPC only. This makes the implementation of the protocol very simple. Also the implementation is portable on heterogeneous systems which support a common RPC mechanism (like the DCE RPC). Another interesting feature of this protocol is that it is self contained. It does not assume the existence of any lower level reliable (like reliable communication of reliable group membership) services. However it assumes simple timeout mechanism for failure detection. The report also presents the proof of correctness of the algorithm and an analysis of the complexity of the algorithm. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Yap, P. Jalote, and S. Tripati, </author> <title> "Fault tolerant remote procedure call," </title> <booktitle> In International Conf. Distributed Computing Systems, </booktitle> <pages> pp. 48-54, </pages> <year> 1988. </year>
Reference-contexts: Thus many of the system vendors provide RPC support either directly in their Operating System (e.g.:SUN RPC) or as a middleware (e.g.: OSF DCE RPC). The design and implementation of RPC mechanisms under various contexts are discussed in <ref> [1, 2, 3, 4] </ref>. 1 Since RPC is a well accepted communication mechanism in distributed systems 1 it is natural to expect to use RPC for implementing fault tolerant distributed system protocols. Of course, RPCs are implemented using the message passing facility of the underlying system. <p> Of course, RPCs are implemented using the message passing facility of the underlying system. Thus with the help of appropriate message passing algorithms we can provide the fault tolerant RPCs <ref> [1, 4, 2] </ref>. But we feel that, it is not a good idea to provide fault tolerant RPC using message passing for the following reason. RPC mechanism is accepted because it is easier to develop distributed application using RPCs.
Reference: [2] <author> E. C. Cooper, </author> <title> "Replicated distributed programs," </title> <booktitle> In ACM Symp. on Oper. Syst. Princ., </booktitle> <pages> pp. 63-78, </pages> <year> 1985. </year>
Reference-contexts: Thus many of the system vendors provide RPC support either directly in their Operating System (e.g.:SUN RPC) or as a middleware (e.g.: OSF DCE RPC). The design and implementation of RPC mechanisms under various contexts are discussed in <ref> [1, 2, 3, 4] </ref>. 1 Since RPC is a well accepted communication mechanism in distributed systems 1 it is natural to expect to use RPC for implementing fault tolerant distributed system protocols. Of course, RPCs are implemented using the message passing facility of the underlying system. <p> Of course, RPCs are implemented using the message passing facility of the underlying system. Thus with the help of appropriate message passing algorithms we can provide the fault tolerant RPCs <ref> [1, 4, 2] </ref>. But we feel that, it is not a good idea to provide fault tolerant RPC using message passing for the following reason. RPC mechanism is accepted because it is easier to develop distributed application using RPCs. <p> In [13] Beedubail et. al. extend the primary backup protocol for nested object invocation where to service a client request and object can invoke the services of other objects. That scheme assumes the existence of a reliable multicast and group management service. The replicated distributed programs described by Cooper <ref> [2] </ref> is an example of active replication. Here, all the replicas (called the members of a troupe) execute the client calls independently. A higher level application protocol should make sure that all the replicas get their client calls in the same order.
Reference: [3] <author> A. D. Birrel and B. J. Nelson, </author> <title> "Implementing remote procedure calls," </title> <journal> ACM Transactions on Computer Systesm, </journal> <volume> vol. 2, no. 1, </volume> <pages> pp. 39-59, </pages> <month> February </month> <year> 1984. </year>
Reference-contexts: Thus many of the system vendors provide RPC support either directly in their Operating System (e.g.:SUN RPC) or as a middleware (e.g.: OSF DCE RPC). The design and implementation of RPC mechanisms under various contexts are discussed in <ref> [1, 2, 3, 4] </ref>. 1 Since RPC is a well accepted communication mechanism in distributed systems 1 it is natural to expect to use RPC for implementing fault tolerant distributed system protocols. Of course, RPCs are implemented using the message passing facility of the underlying system.
Reference: [4] <author> M. D. Wood, </author> <title> "Replicated rpc using amoeba closed group communication," </title> <booktitle> In International Conf. Distributed Computing Systems, </booktitle> <pages> pp. 499-507, </pages> <year> 1993. </year>
Reference-contexts: Thus many of the system vendors provide RPC support either directly in their Operating System (e.g.:SUN RPC) or as a middleware (e.g.: OSF DCE RPC). The design and implementation of RPC mechanisms under various contexts are discussed in <ref> [1, 2, 3, 4] </ref>. 1 Since RPC is a well accepted communication mechanism in distributed systems 1 it is natural to expect to use RPC for implementing fault tolerant distributed system protocols. Of course, RPCs are implemented using the message passing facility of the underlying system. <p> Of course, RPCs are implemented using the message passing facility of the underlying system. Thus with the help of appropriate message passing algorithms we can provide the fault tolerant RPCs <ref> [1, 4, 2] </ref>. But we feel that, it is not a good idea to provide fault tolerant RPC using message passing for the following reason. RPC mechanism is accepted because it is easier to develop distributed application using RPCs.
Reference: [5] <author> J. Mitchel et al., </author> <title> "An overview of the spring system," </title> <booktitle> In Proceedings of of Compcon Spring 1994, </booktitle> <month> February </month> <year> 1994. </year>
Reference-contexts: It also integrates the re-joining of a replica to the replica group after a failure. 1 Note that RPC is also the "Object Oriented' communication mechanism. 2 Spring is an object oriented distributed operating system <ref> [5] </ref>. 3 This helps us to re-order the received messages to satisfy some kind of message order requirement. 2 1.1 Assumptions We assume that a set of machines connected by a network. The machines in the network can fail only by crashing (fail stop assumption).
Reference: [6] <author> G. Beedubail, P. Kessler, and U. Pooch, </author> <title> "Object replication in spring using subcontracts," </title> <type> Technical Report TR95-041, </type> <institution> Computer Science Department,Texas A&M University, </institution> <month> Septem-ber </month> <year> 1995. </year>
Reference-contexts: Also most of the current object oriented systems hide the underlying message passing mechanism from the user, thus making it difficult (almost impossible) for the programmer to directly handle the system messages. We faced this problem when we were developing a frame work for object replication in Spring 2 <ref> [6] </ref>. Spring is one of the systems we encountered. The CORBA [7] framework is another such environment (if one is developing an application on CORBA, RPC is the only communication facility available). Thus it makes sense to explore the possibility of implementing fault tolerant replica consistency algorithm using only RPCs. <p> However the feasibility of such a scheme (i.e., object replication is a WAN) needs to be studied more carefully. The algorithm assumes that it does not have an access to a distributed naming service (in fact, we developed this algorithm to replicate naming service (NS) in Spring <ref> [6] </ref>). Thus, it is imperative that all the machines in the system know the location of the object servers (by some means, other than getting it from a name server). <p> A preliminary implementation of this algorithm is carried out to provide aa replicated name service for the Spring Operating System. The implementation details and the performance figures can be found in <ref> [6] </ref>.
Reference: [7] <author> T. J. Mowbray and R. Zahavi, </author> <title> The Essential Corba: System Integration Using Distributed Objects, </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1994. </year>
Reference-contexts: We faced this problem when we were developing a frame work for object replication in Spring 2 [6]. Spring is one of the systems we encountered. The CORBA <ref> [7] </ref> framework is another such environment (if one is developing an application on CORBA, RPC is the only communication facility available). Thus it makes sense to explore the possibility of implementing fault tolerant replica consistency algorithm using only RPCs.
Reference: [8] <author> F. Schneider, </author> <title> "Implementing fault tolerant services using the state machine approach: A tutorial," </title> <journal> ACM Computing Surveys, </journal> <volume> vol. 22, no. 4, </volume> <pages> pp. 299-319, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: This approach is known as active replication or the state machine approach <ref> [8] </ref>. 2) Designate one server as the primary and all others as backups. Clients make requests by sending messages only to the primary. The primary forwards the requests to the backups (so that, backups can synchronize their state with the primary) and then responds to the client 5 .
Reference: [9] <author> P. Alsberg and J. Day, </author> <title> "A principle for resilient sharing of distributed resrources," </title> <booktitle> In Proc. Of Second Intl' Conf. on software Engg., </booktitle> <address> San Francisco, CA., </address> <pages> pp. 562-570, </pages> <year> 1976. </year>
Reference-contexts: The primary forwards the requests to the backups (so that, backups can synchronize their state with the primary) and then responds to the client 5 . If the primary fails, then one of the backups becomes the primary. This approach is known as the primary-backup or the primary copy <ref> [9] </ref>. <p> Alsberg and Day <ref> [9] </ref> proposed one of the earliest primary-backup protocol. The paper presents the error detection and recovery schemes for two-host resiliency (tolerating one failure) and the extension of this concept n hosts. In [10] Budhiraja et. al. present some theoretical aspects of primary backup approach.
Reference: [10] <author> N. Budhiraja et al., </author> <title> "The primary-backup approach," In Distributed Systems, 2ed Edition, </title> <editor> S. Mullender, </editor> <booktitle> editor, </booktitle> <pages> pp. 199-216, </pages> <publisher> Addison-Wesley, </publisher> <year> 1993. </year> <month> 20 </month>
Reference-contexts: Alsberg and Day [9] proposed one of the earliest primary-backup protocol. The paper presents the error detection and recovery schemes for two-host resiliency (tolerating one failure) and the extension of this concept n hosts. In <ref> [10] </ref> Budhiraja et. al. present some theoretical aspects of primary backup approach. Their system assumes closely synchronized clocks in the system.
Reference: [11] <author> B. Liskov et al., </author> <title> "Replication in the harp file system," </title> <type> Technical Report MIT/LCS/TM-456, </type> <institution> Massachusetts Institute Of Technology, </institution> <month> August </month> <year> 1991. </year>
Reference-contexts: Their system assumes closely synchronized clocks in the system. They classify the primary-backup algorithms as blocking and non-blocking and provide lower bounds (under various failure conditions) on the degree of replication, blocking time and failover time for any primary-backup algorithm. The Harp File System also uses a primary-backup protocol <ref> [11] </ref>. It is assumed that the system clocks are closely synchronized and all the machines are equipped with a UPS (uninterrupted power supply). The protocol keeps a log of updates on volatile memory (the UPS is necessary to write back this log to disk in case of power failure).
Reference: [12] <author> K. P. Birman et al., </author> <title> "Implementing fault-tolerant distributed objects," </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> vol. 6, no. 11, </volume> <pages> pp. 502-508, </pages> <year> 1985. </year>
Reference-contexts: Operations on the log are applied to the system in the background. Thus the disk access is removed from the critical path, and good response time is achieved. In <ref> [12] </ref> Birman et. al. describe a technique to implement k-resilient distributed object. They use coordinator-cohort scheme, a variation of primary-backup scheme. The coordinator services the client requests and periodically checkpoints its state to the cohorts.
Reference: [13] <author> G. Beedubail et al., </author> <title> "Fault tolerant objects in distributed systems using hot replication," </title> <type> Technical Report TR95-023, </type> <institution> Computer Science Department,Texas A&M University, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: The coordinator also forwards the result of any external action to the cohorts (called retained results). Thus the cohorts will have all the information to take over as a coordinator if the original coordinator fails. In <ref> [13] </ref> Beedubail et. al. extend the primary backup protocol for nested object invocation where to service a client request and object can invoke the services of other objects. That scheme assumes the existence of a reliable multicast and group management service. <p> of all the machines is the same in all the files. 5 typedef struct glist type f int IP address; int status; //UP or DOWN obj ref t obj ref; // Object reference g glist t; glist t glist [MAX REPLICA]; 4 Fault Tolerant Replica Consistency Algorithm We use Master-Slave <ref> [13] </ref> configuration for replica consistency control and fault tolerance. The novelty of this algorithm is that: 1) It is self contained. It does not use any other services (other than the basic "time-out" mechanism to detect failures. 2) It is specified and implemented using only RPCs (synchronous communication).
Reference: [14] <author> T. Joseph and K. Birman, </author> <title> "Exploiting replication in distributed systems," In Distributed Systems, </title> <editor> S. Mullender, </editor> <booktitle> editor, </booktitle> <pages> pp. 319-367, </pages> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Here, all the replicas (called the members of a troupe) execute the client calls independently. A higher level application protocol should make sure that all the replicas get their client calls in the same order. In <ref> [14] </ref> Birman et.al., describe, how the totally ordered, reliable broadcasts can be used to maintain replicated data (active replication). Object Replication in Arjuna [15] uses active replication 7 . The replication algorithm uses the support of naming and binding service and the atomic action service provided by Arjuna system.
Reference: [15] <author> M. C. Little, </author> <title> Object Replication in a Distributed System, </title> <type> PhD thesis, </type> <institution> Computer Science Dept., University of Newcastle upon Tyne, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: A higher level application protocol should make sure that all the replicas get their client calls in the same order. In [14] Birman et.al., describe, how the totally ordered, reliable broadcasts can be used to maintain replicated data (active replication). Object Replication in Arjuna <ref> [15] </ref> uses active replication 7 . The replication algorithm uses the support of naming and binding service and the atomic action service provided by Arjuna system. A higher level group locking (issued by the application program) protocol avoids the need of reliable ordered broadcast. <p> That is, the execution should be equivalent to a serial execution on non-replicated object. This correctness property is called one copy serializability (1SR). Following is a definition of 1SR <ref> [15] </ref>. Definition 1 One Copy Serializability (1SR): If the effect of a group of [atomic] actions executing on a replicated object is equivalent to running those same [atomic] actions on a single copy of the object then the overall execution is said to be one copy serializable (1SR). <p> Due to this consistency requirement, replica control algorithms are also called consistency control algorithms. As we can see, if the algorithm can ensure 1SR then the algorithm also ensures the mutual consistency of replicas. Following definition restates this <ref> [15] </ref>. Definition 2 A replica consistency protocol is one, which ensures 1SR. 13 Outline of Proof: We use the master-slave configuration. Here the clients always contact the master. Hence clients always see one copy of the object.
Reference: [16] <author> M. F. Kaasshoek, A. S. Tanenbaum, and K. Verstoep, </author> <title> "Using group communication to implement a fault-tolerant directory service," </title> <booktitle> In International Conf. Distributed Computing Systems, </booktitle> <pages> pp. 130-139, </pages> <year> 1993. </year>
Reference-contexts: Object Replication in Arjuna [15] uses active replication 7 . The replication algorithm uses the support of naming and binding service and the atomic action service provided by Arjuna system. A higher level group locking (issued by the application program) protocol avoids the need of reliable ordered broadcast. In <ref> [16] </ref> Kaashoek et.al., describe the fault tolerant directory service implemented in Amoeba distributed operating system.
Reference: [17] <author> T. Mann, A. Hisgen, and G. Swart, </author> <title> "An algorithm for data replication," </title> <type> Technical Report 46, </type> <institution> DEC Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: The reader can refer to <ref> [17, 18, 19] </ref> for additional reading on replication. 3 System Model Our algorithm is intended to work in a local area network (LAN). In principle, the algorithm will work in a wide area network (WAN).
Reference: [18] <author> E. N. Elnozahy and W. Zwaenepoel, </author> <title> "Replicated distributed processes in manetho," </title> <booktitle> In Digest of papers: The 22 nd Int. Symp. Fault-Tolerant Comp., </booktitle> <pages> pp. 18-27, </pages> <year> 1992. </year>
Reference-contexts: The reader can refer to <ref> [17, 18, 19] </ref> for additional reading on replication. 3 System Model Our algorithm is intended to work in a local area network (LAN). In principle, the algorithm will work in a wide area network (WAN).
Reference: [19] <author> A. Borg, W. Blau, W. Graetsch, F. Herrmann, and W. Oberle, </author> <title> "Fault tolerance under UNIX," </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> vol. 7, no. 1, </volume> <pages> pp. 1-24, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: The reader can refer to <ref> [17, 18, 19] </ref> for additional reading on replication. 3 System Model Our algorithm is intended to work in a local area network (LAN). In principle, the algorithm will work in a wide area network (WAN).
Reference: [20] <author> P. Jalote, </author> <title> Fault Tolerance in Distributed Systems, </title> <publisher> Prentice Hall, </publisher> <year> 1994. </year> <month> 21 </month>
Reference-contexts: I am master = NO; upd unlock (); return (OK); g Join forward (int dst idx, dst obj ref ) f glist [dst idx].obj ref = dst obj ref; glist [dst idx].status = UP; g tolerance against failures, the replication should not be visible at the user or action level <ref> [20] </ref>. For performing actions, it should appear as if there is a single copy of the object. An action will perform operations on logical copy of the object and the underlying system (algorithm) should map it to operations on multiple copies of the objects.
References-found: 20

