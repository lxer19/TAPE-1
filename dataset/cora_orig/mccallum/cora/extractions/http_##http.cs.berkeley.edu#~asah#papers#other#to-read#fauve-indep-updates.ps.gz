URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/fauve-indep-updates.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Email: ceri@ipmel2.elet.polimi.it  M.A.W. HOUTSMA houtsma@trc.nl  ark@cs.stanford.edu  samarati@dsi.unimi.it  
Title: Independent Updates and Incremental Agreement in Replicated Databases  
Author: S. CERI A.M. KELLER P. SAMARATI 
Keyword: Replicated databases, update propagation, transaction reconciliation, failures.  
Address: Milano (Italy)  Netherlands)  (U.S.A.)  Milano Milano (Italy)  
Affiliation: Dipartimento di Elettronica e Informatica Politecnico di  Department of Computer Science University of Twente (the  Department of Computer Science Stanford University  Dipartimento di Scienze dell'Informazione Universita di  
Note: 1-23 c Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.  
Abstract: Update propagation and transaction atomicity are major obstacles to the development of replicated databases. Many practical applications, such as automated teller machine networks, flight reservation, and part inventory control, do not require these properties. In this paper we present an approach for incrementally updating a distributed, replicated database without requiring multi-site atomic commit protocols. We prove that the mechanism is correct, as it asymptotically performs all the updates on all the copies. Our approach has two important characteristics: it is progressive, and non-blocking. Progressive means that the transaction's coordinator always commits, possibly together with a group of other sites. The update is later propagated asynchronously to the remaining sites. Non-blocking means that each site can take unilateral decisions at each step of the algorithm. Sites which cannot commit updates are brought to the same final state by means of a reconciliation mechanism. This mechanism uses the history logs, which are stored locally at each site, to bring sites to agreement. It requires a small auxiliary data structure, called reception vector, to keep track of the time unto which the other sites are guaranteed to be up-to-date. Several optimizations to the basic mechanism are also discussed. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> D. Agrawal and A. El Abbadi, </author> <title> "The Tree Quorum Protocol: an Efficient Approach for Managing Replicated Data," </title> <booktitle> in Proc. of the 16th Int. Conf. on Very Large Data Bases, </booktitle> <address> Brisbane, </address> <month> Aug. </month> <year> 1990, </year> <pages> pp. 243-254. </pages>
Reference-contexts: The first problem with propagation of updates is to guarantee that a sufficient number of copies be updated so that their consistency is constantly preserved; strategies developed for this purpose include voting or token passing <ref> [1] </ref>, [18], [26]; 2 S.CERI, M.A.W. HOUTSMA, A.M. KELLER, P. SAMARATI they are generally very complex and difficult to implement. In [8] we have given a classification and overview of many of these update strategies. <p> Algorithms for indipendent update executions and for reconciliations in such a framework are illustrated together with the proofs of their correctness. 1.1. Previous related work Several update propagation strategies to replicated databases guarantee full consistency <ref> [1] </ref>, [6], [14], [18], [26]. In case of network partitions, either updates are INDEPENDENT UPDATES AND INCREMENTAL AGREEMENT IN REPLICATED DATABASES3 accepted on a subset of the sites, or transactions that are known not to lead to inconsistency are the only ones allowed to run [3]. <p> For each site q and each object o, we introduce a small auxiliary data structure called reception vector, denoted by RV o q . This vector has an entry for each site k, RV o q <ref> [1; : : :; n] </ref>. (The idea of using a vector for detecting inconsistency among sites, was proposed before in [16], [27], [31].) The semantics of the reception vector is illustrated by the following invariant condition: 6 S.CERI, M.A.W. HOUTSMA, A.M. KELLER, P.
Reference: 2. <author> R. Alonso, D. Barbara. H. Garcia Molina, and S. Abad, "Quasi-Copies: </author> <title> Efficient Data Sharing for Information Retrieval Systems," </title> <booktitle> in Advances in Database Technology-EDBT'88, </booktitle> <editor> J.W. Schmidt, S. Ceri, and M. Missikoff (Eds.), </editor> <volume> LNCS 303, </volume> <year> 1988. </year>
Reference-contexts: A whole family of methods, each one different in the level of asynchrony, can be described using the concept of epsilon-serializability. Another example of research that does not enforce immediate propagation of updates is the work on quasi-copies <ref> [2] </ref>; here, each replica is allowed a certain bounded deviation from the actual data value. Along the same lines, the work on the demarcation protocol [5] allows some degree of independence among the sites, allowing some updates to execute locally and be propagated asynchronously to other sites.
Reference: 3. <author> P.M.G. Apers and G. Wiederhold, </author> <title> "Transaction Classification to Survive a Network Partition," </title> <type> Technical report STAN-CS-85-1053, </type> <institution> Stanford University, </institution> <month> Aug. </month> <year> 1984. </year>
Reference-contexts: In case of network partitions, either updates are INDEPENDENT UPDATES AND INCREMENTAL AGREEMENT IN REPLICATED DATABASES3 accepted on a subset of the sites, or transactions that are known not to lead to inconsistency are the only ones allowed to run <ref> [3] </ref>. These protocols suffer from unrealistically strong assumptions [34]; therefore, a lot of work has been done to allow some more flexibility [4], [9], [25]. A noticeable example of this is the work on epsilon-serializability [32], [33].
Reference: 4. <author> D. Barbara and H. Garcia-Molina, </author> <title> "The Case for Controlled Inconsistency in Replicated Data," </title> <booktitle> Proc. of the Workshop on Management of Replicated Data, </booktitle> <address> Houston, TX, </address> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Therefore, current research focuses on delayed propagation of updates [32], [33], and transformation of global constraints into local constraints (thereby increasing local autonomy) <ref> [4] </ref>, [5]. Some commercial systems are also developing products for dealing with asynchronous updates to replicated databases (e.g., Sybase, [12]). In this paper we allow updates to be initiated at any site, and propagate them to other sites immediately if possible, or otherwise later. <p> The disadvantages of our approach are loss of strict serializability of transactions, and less strict constraint enforcement, but such disadvantages are acceptable for many applications. Some global constraints can be split into local constraints (e.g., using the demarcation protocol <ref> [4] </ref>) and therefore still be enforced; compensating actions can be applied to restore consistency after violation of global constraints [17], [35]. The main contribution of the paper is to combine gossip techniques for update propagation and techniques for transaction reconciliation in a unique framework. <p> These protocols suffer from unrealistically strong assumptions [34]; therefore, a lot of work has been done to allow some more flexibility <ref> [4] </ref>, [9], [25]. A noticeable example of this is the work on epsilon-serializability [32], [33]. Updates are allowed to propagate through the system asynchronously; eventual consistency of the system is an asymptotical property.
Reference: 5. <author> D. Barbara and H. Garcia-Molina, </author> <title> The Demarcation Protocol: a Technique for Maintaining Arithmetic Constraints in Distributed Database Systems, </title> <booktitle> in Advances in Database Technology-EDBT'92, LNCS 580, </booktitle> <year> 1992, </year> <pages> pp. 373-397. </pages>
Reference-contexts: Therefore, current research focuses on delayed propagation of updates [32], [33], and transformation of global constraints into local constraints (thereby increasing local autonomy) [4], <ref> [5] </ref>. Some commercial systems are also developing products for dealing with asynchronous updates to replicated databases (e.g., Sybase, [12]). In this paper we allow updates to be initiated at any site, and propagate them to other sites immediately if possible, or otherwise later. <p> Another example of research that does not enforce immediate propagation of updates is the work on quasi-copies [2]; here, each replica is allowed a certain bounded deviation from the actual data value. Along the same lines, the work on the demarcation protocol <ref> [5] </ref> allows some degree of independence among the sites, allowing some updates to execute locally and be propagated asynchronously to other sites. Another way of providing somewhat more flexibility is to avoid regular two-phase commit.
Reference: 6. <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems, </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Algorithms for indipendent update executions and for reconciliations in such a framework are illustrated together with the proofs of their correctness. 1.1. Previous related work Several update propagation strategies to replicated databases guarantee full consistency [1], <ref> [6] </ref>, [14], [18], [26]. In case of network partitions, either updates are INDEPENDENT UPDATES AND INCREMENTAL AGREEMENT IN REPLICATED DATABASES3 accepted on a subset of the sites, or transactions that are known not to lead to inconsistency are the only ones allowed to run [3].
Reference: 7. <author> P.A. Bernstein, M. Hsu, and B. Mann, </author> <title> "Implementing Recoverable Requests Using Queues," </title> <booktitle> in Proc. ACM SIGMOD'90, Atlantic City, </booktitle> <pages> pp. 112-122. </pages>
Reference-contexts: Each of these subtransactions commits locally, with the provision that if the root of the tree commits, all its children commit too. In this approach, persistent transmission of messages is required, for instance, by mean of stable queues <ref> [7] </ref>, or gossip mechanisms [22], [37]. Another approach that avoids two-phase commit is given in [29]; transactions commit at a primary site and are propagated asynchronously.
Reference: 8. <author> S. Ceri, M.A.W. Houtsma, A.M. Keller, and P. Samarati, </author> <title> "A Classification of Update Methods for Replicated Databases," </title> <type> Technical Report STAN-CS-91-1932, </type> <institution> Stanford University, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: HOUTSMA, A.M. KELLER, P. SAMARATI they are generally very complex and difficult to implement. In <ref> [8] </ref> we have given a classification and overview of many of these update strategies. The second problem with propagation of updates is transaction atomicity; two-phase commit is the most widely used commit protocol in commercial database systems [11]. Commit protocols have intrinsic disadvantages, such as cost, delay, and reduced availability.
Reference: 9. <author> S. Ceri, M.A.W. Houtsma, A.M. Keller, and P. Samarati, </author> <title> "The case for independent updates," </title> <booktitle> in Proc. 2nd Workshop on Replicated Data Management, </booktitle> <address> Monterey, CA, </address> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: These protocols suffer from unrealistically strong assumptions [34]; therefore, a lot of work has been done to allow some more flexibility [4], <ref> [9] </ref>, [25]. A noticeable example of this is the work on epsilon-serializability [32], [33]. Updates are allowed to propagate through the system asynchronously; eventual consistency of the system is an asymptotical property.
Reference: 10. <author> S. Ceri, M.A.W. Houtsma, A.M. Keller, and P. Samarati, </author> <title> "Achieving Incremental Consistency among Autonomous Replicated Databases," </title> <booktitle> in Proc. DS-5, "Semantic Interoperability," </booktitle> <address> Lorne, Australia, </address> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: The use of the history log for propagation of updates was suggested in [24], and a preliminary description of how to apply history logs for propagating independent updates was given by us in <ref> [10] </ref>. Update propagation was considered also in the context of maintaining replicated dictionaries, with an approach which has several similarities with the one proposed in this paper. In [16], a vector is introduced in order to keep track, at each site, of the 4 S.CERI, M.A.W. HOUTSMA, A.M. KELLER, P.
Reference: 11. <author> S. Ceri and G. Pelagatti, </author> <title> Distributed Database Systems, </title> <publisher> McGraw-Hill, </publisher> <year> 1984. </year>
Reference-contexts: SAMARATI they are generally very complex and difficult to implement. In [8] we have given a classification and overview of many of these update strategies. The second problem with propagation of updates is transaction atomicity; two-phase commit is the most widely used commit protocol in commercial database systems <ref> [11] </ref>. Commit protocols have intrinsic disadvantages, such as cost, delay, and reduced availability. Sites may be blocked once they have transferred their right to decide on abort or commit to the commit coordinator. Network partitions or site failures may thus lead to smaller availability of the database system.
Reference: 12. <author> M. Colten, </author> <title> "The Sybase Approach to Replicated Data," Oral Presentation, CS347 Course on Distributed Databases, </title> <institution> Stanford University, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Therefore, current research focuses on delayed propagation of updates [32], [33], and transformation of global constraints into local constraints (thereby increasing local autonomy) [4], [5]. Some commercial systems are also developing products for dealing with asynchronous updates to replicated databases (e.g., Sybase, <ref> [12] </ref>). In this paper we allow updates to be initiated at any site, and propagate them to other sites immediately if possible, or otherwise later. However, if a site cannot accept an update, the other sites still continue with the transaction.
Reference: 13. <author> A.R. Downing, I.B. Greenberg, and J.M. Peh, "Oscar: </author> <title> an Architecture for Weak-Consistency Replication," </title> <booktitle> in Proc. Parbase Conference, </booktitle> <year> 1990. </year>
Reference-contexts: A partial order among transactions is defined for controlling update propagation; the use of a partial order is also proposed in [27] and in [15] (in the context of concurrency control for groupware systems). Finally, some systems allow even more flexibility. In <ref> [13] </ref> a system is described for maintaining weak consistency among various database systems. Updates are accepted at any site, and are guaranteed to be reflected at all other sites eventually.
Reference: 14. <author> A. El Abbadi, D. Skeen, and F. Christian, </author> <title> "An Efficient Fault-Tolerant Protocol for Replicated Data Management," </title> <booktitle> Proc. 4th ACM SIGACTSIGMOD Symp. on Principles of Database Systems, </booktitle> <address> Portland, OR, </address> <month> March </month> <year> 1985, </year> <pages> pp. 215-228. </pages>
Reference-contexts: Algorithms for indipendent update executions and for reconciliations in such a framework are illustrated together with the proofs of their correctness. 1.1. Previous related work Several update propagation strategies to replicated databases guarantee full consistency [1], [6], <ref> [14] </ref>, [18], [26]. In case of network partitions, either updates are INDEPENDENT UPDATES AND INCREMENTAL AGREEMENT IN REPLICATED DATABASES3 accepted on a subset of the sites, or transactions that are known not to lead to inconsistency are the only ones allowed to run [3].
Reference: 15. <author> C.A. Ellis and S.J. Gibbs, </author> <title> "Concurrency Control in Groupware Systems," </title> <booktitle> Proc. ACM SIG-MOD'89, </booktitle> <address> Portland, OR, </address> <month> May </month> <year> 1989, </year> <pages> pp. 399-407. </pages>
Reference-contexts: Another approach that avoids two-phase commit is given in [29]; transactions commit at a primary site and are propagated asynchronously. A partial order among transactions is defined for controlling update propagation; the use of a partial order is also proposed in [27] and in <ref> [15] </ref> (in the context of concurrency control for groupware systems). Finally, some systems allow even more flexibility. In [13] a system is described for maintaining weak consistency among various database systems. Updates are accepted at any site, and are guaranteed to be reflected at all other sites eventually.
Reference: 16. <author> M.J. Fischer and A. Michael, </author> <title> "Sacrificing Serializability to Attain High Availability of Data in an Unreliable Network," </title> <booktitle> ACM SIGACTSIGMOD Symposium on Principles of Database Systems, </booktitle> <year> 1982, </year> <pages> pp. 70-75. </pages>
Reference-contexts: Network partitions or site failures may thus lead to smaller availability of the database system. Not all applications should pay the price for maintaining a consistent view on replicated data and immediate update propagation <ref> [16] </ref>, [20], [30]. Examples of such applications are automated teller machine networks, flight reservation, and part inventory control. For instance, it is clearly unacceptable for a flight reservation system to become globally unavailable in case of a site failure or network partition. <p> Update propagation was considered also in the context of maintaining replicated dictionaries, with an approach which has several similarities with the one proposed in this paper. In <ref> [16] </ref>, a vector is introduced in order to keep track, at each site, of the 4 S.CERI, M.A.W. HOUTSMA, A.M. KELLER, P. SAMARATI events that originated in the system. <p> Therefore, this approach requires a site to send its entire copy of a dictionary at each message. In [37], the approach of <ref> [16] </ref> was extended by storing at each site a matrix, instead of a vector. The matrix at each site indicates how up to date all sites are, thus limiting the communication requirements among sites. <p> As we will see, [37] has therefore many features in common with our paper; however there are also major differences. [37] is limited to solving the dictionary problem, and both <ref> [16] </ref>, [37] do not consider a reconciliation phase, which is one of the main component of our approach. Instead of using a specific reconciliation mechanism, a site can synchrously send part of its log and matrix to other sites. <p> This vector has an entry for each site k, RV o q [1; : : :; n]. (The idea of using a vector for detecting inconsistency among sites, was proposed before in <ref> [16] </ref>, [27], [31].) The semantics of the reception vector is illustrated by the following invariant condition: 6 S.CERI, M.A.W. HOUTSMA, A.M. KELLER, P.
Reference: 17. <author> H. Garcia-Molina and K. Salem, "Sagas," </author> <booktitle> Proc. ACM SIGMOD'87, </booktitle> <month> May </month> <year> 1987. </year>
Reference-contexts: Some global constraints can be split into local constraints (e.g., using the demarcation protocol [4]) and therefore still be enforced; compensating actions can be applied to restore consistency after violation of global constraints <ref> [17] </ref>, [35]. The main contribution of the paper is to combine gossip techniques for update propagation and techniques for transaction reconciliation in a unique framework. Algorithms for indipendent update executions and for reconciliations in such a framework are illustrated together with the proofs of their correctness. 1.1.
Reference: 18. <author> D.K. Gifford, </author> <title> "Weighted Voting for Replicated Data," </title> <booktitle> Proc. 7th ACM-SIGOPS Symp. on Operating Systems Principles, </booktitle> <address> Pacific Grove, CA, </address> <month> Dec. </month> <year> 1979, </year> <pages> pp. 150-159. </pages>
Reference-contexts: The first problem with propagation of updates is to guarantee that a sufficient number of copies be updated so that their consistency is constantly preserved; strategies developed for this purpose include voting or token passing [1], <ref> [18] </ref>, [26]; 2 S.CERI, M.A.W. HOUTSMA, A.M. KELLER, P. SAMARATI they are generally very complex and difficult to implement. In [8] we have given a classification and overview of many of these update strategies. <p> Algorithms for indipendent update executions and for reconciliations in such a framework are illustrated together with the proofs of their correctness. 1.1. Previous related work Several update propagation strategies to replicated databases guarantee full consistency [1], [6], [14], <ref> [18] </ref>, [26]. In case of network partitions, either updates are INDEPENDENT UPDATES AND INCREMENTAL AGREEMENT IN REPLICATED DATABASES3 accepted on a subset of the sites, or transactions that are known not to lead to inconsistency are the only ones allowed to run [3].
Reference: 19. <author> R.A. Golding, </author> <title> "Weak-Consistency Group communication and membership," </title> <type> PhD Thesis, </type> <institution> University of Santa Cruz, </institution> <year> 1992. </year>
Reference-contexts: This mechanism achieves consistency by undoing and re-executing updates which are out-of-order, and saves some of these operations at the cost of restoring additional information, such as read/write sets for update transactions. In <ref> [19] </ref> a timestamp message delivery protocol that implements eventual delivery is proposed. The approach uses periodic exchanges of messages between pairs of principals to propagate messages to groups of sites. Incoming messages are stored in a log and later delivered to the application in a defined order.
Reference: 20. <author> J.N. Gray and M. Anderton, </author> <title> "Distributed Computer Systems: Four Case Studies," </title> <journal> Proc. of the IEEE, </journal> <volume> Vol. 75, No. 5, </volume> <month> May </month> <year> 1987. </year>
Reference-contexts: Network partitions or site failures may thus lead to smaller availability of the database system. Not all applications should pay the price for maintaining a consistent view on replicated data and immediate update propagation [16], <ref> [20] </ref>, [30]. Examples of such applications are automated teller machine networks, flight reservation, and part inventory control. For instance, it is clearly unacceptable for a flight reservation system to become globally unavailable in case of a site failure or network partition.
Reference: 21. <author> J.N. Gray and A. Reuter, </author> <title> Transaction Processing: Concepts and Techniques, </title> <publisher> Morgan-Kaufmann, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: In Sec. 6 we will drop the assumption that actions be commutative. Logging Each site logs all actions on a local history log on stable storage using the Write Ahead Log protocol <ref> [21] </ref>. Conventional transaction mechanisms ensure that all actions that are logged and then committed, are subsequently correctly reflected in the database. We assume that the local history log kept at each site is a sequence of unique records. <p> We assume that actions are executed on data items that are contained within a single object, therefore, items have smaller granularity than objects. Locking When a transaction or the reconciliation process reads or writes an ob ject, it follows the 2-phase locking protocol locally <ref> [21] </ref>. 2.2. Notation and invariant condition In the following a o q denotes an action a executed on object o with site q as coordina tor of the transaction, time (a o q ) denotes the timestamp of action a o q .
Reference: 22. <author> A. Heddaya, M. Hsu, and W.E. Weihl, </author> <title> "Two Phase Gossip: Managing Distributed Event Histories," </title> <journal> in Information Sciences, </journal> <volume> 49(1), </volume> <year> 1989, </year> <pages> pp. </pages> <month> 35-57. </month> <title> INDEPENDENT UPDATES AND INCREMENTAL AGREEMENT IN REPLICATED DATABASES23 </title>
Reference-contexts: Each of these subtransactions commits locally, with the provision that if the root of the tree commits, all its children commit too. In this approach, persistent transmission of messages is required, for instance, by mean of stable queues [7], or gossip mechanisms <ref> [22] </ref>, [37]. Another approach that avoids two-phase commit is given in [29]; transactions commit at a primary site and are propagated asynchronously.
Reference: 23. <author> M. Hsu and A. Silberschatz, </author> <title> "Unilateral Commit: a New Paradigm for Reliable Distributed Transaction Processing," </title> <booktitle> in Proc. 7th Int. Conf. on Data Engineering, </booktitle> <year> 1991, </year> <pages> pp. 286-293. </pages>
Reference-contexts: Along the same lines, the work on the demarcation protocol [5] allows some degree of independence among the sites, allowing some updates to execute locally and be propagated asynchronously to other sites. Another way of providing somewhat more flexibility is to avoid regular two-phase commit. For instance, in <ref> [23] </ref> a distributed transaction is split into several single-site atomic transactions that are put into a logical tree structure. Each of these subtransactions commits locally, with the provision that if the root of the tree commits, all its children commit too.
Reference: 24. <author> B. Kahler and O. Risnes, </author> <title> "Extending Logging for Database Snapshot Refresh," </title> <booktitle> in Proc. 13th Int. Conf. on Very Large Data Bases, </booktitle> <address> Brighton, England, </address> <year> 1987, </year> <pages> pp. 389-398. </pages>
Reference-contexts: The protocol maintains summary information on the messages it has received to decrease communication and to purge messages from the log. The use of the history log for propagation of updates was suggested in <ref> [24] </ref>, and a preliminary description of how to apply history logs for propagating independent updates was given by us in [10]. Update propagation was considered also in the context of maintaining replicated dictionaries, with an approach which has several similarities with the one proposed in this paper.
Reference: 25. <author> N. Krishnakumar and A.J. Bernstein, </author> <title> "Bounded Ignorance in Replicated Systems," </title> <booktitle> in Proc. </booktitle> <address> ACM-PODS'91, Denver, CO, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: These protocols suffer from unrealistically strong assumptions [34]; therefore, a lot of work has been done to allow some more flexibility [4], [9], <ref> [25] </ref>. A noticeable example of this is the work on epsilon-serializability [32], [33]. Updates are allowed to propagate through the system asynchronously; eventual consistency of the system is an asymptotical property.
Reference: 26. <author> A. Kumar and A. Segev, </author> <title> "Optimizing Voting-Type Algorithms for Replicated Data," </title> <booktitle> in Advances in Database Technology-EDBT'88, </booktitle> <editor> J.W. Schmidt, S. Ceri, and M. Missikoff (Eds.), </editor> <volume> LNCS 303, </volume> <year> 1988, </year> <pages> pp. 428-442. </pages>
Reference-contexts: The first problem with propagation of updates is to guarantee that a sufficient number of copies be updated so that their consistency is constantly preserved; strategies developed for this purpose include voting or token passing [1], [18], <ref> [26] </ref>; 2 S.CERI, M.A.W. HOUTSMA, A.M. KELLER, P. SAMARATI they are generally very complex and difficult to implement. In [8] we have given a classification and overview of many of these update strategies. <p> Algorithms for indipendent update executions and for reconciliations in such a framework are illustrated together with the proofs of their correctness. 1.1. Previous related work Several update propagation strategies to replicated databases guarantee full consistency [1], [6], [14], [18], <ref> [26] </ref>. In case of network partitions, either updates are INDEPENDENT UPDATES AND INCREMENTAL AGREEMENT IN REPLICATED DATABASES3 accepted on a subset of the sites, or transactions that are known not to lead to inconsistency are the only ones allowed to run [3].
Reference: 27. <author> R. Ladin, B. Liskov, and L. Shira, </author> <title> "Lazy Replication: Exploiting the Semantics of Distributed Services," </title> <booktitle> Proc. 1st Workshop on Replicated Data, </booktitle> <address> Houston, TX, </address> <month> Nov. </month> <year> 1990, </year> <pages> pp. 31-34. </pages>
Reference-contexts: Another approach that avoids two-phase commit is given in [29]; transactions commit at a primary site and are propagated asynchronously. A partial order among transactions is defined for controlling update propagation; the use of a partial order is also proposed in <ref> [27] </ref> and in [15] (in the context of concurrency control for groupware systems). Finally, some systems allow even more flexibility. In [13] a system is described for maintaining weak consistency among various database systems. <p> Instead of using a specific reconciliation mechanism, a site can synchrously send part of its log and matrix to other sites. The use of vectors for update propagation is also suggested in <ref> [27] </ref>; this is based on gossip messages, where update propagation is enforced by two kinds of messages: update messages through which events are propagated, and ack messages by which a site acknowledges the reception of updates. 1.2. Outline The paper is organized as follows. <p> This vector has an entry for each site k, RV o q [1; : : :; n]. (The idea of using a vector for detecting inconsistency among sites, was proposed before in [16], <ref> [27] </ref>, [31].) The semantics of the reception vector is illustrated by the following invariant condition: 6 S.CERI, M.A.W. HOUTSMA, A.M. KELLER, P.
Reference: 28. <author> L. Lamport, </author> <title> "Time, Clocks, and Ordering of Events in a Distributed System," </title> <journal> CACM, </journal> <volume> Vol. 21, No.7, </volume> <month> July </month> <year> 1978. </year>
Reference-contexts: Furthermore, we assume a time-out mechanism that allows a process to detect that its messages were not acknowledged within a given time interval. Time Each site has a logical local clock. Global ordering of actions executed at different sites is possible using a Lamport-style timestamping mechanism <ref> [28] </ref>. INDEPENDENT UPDATES AND INCREMENTAL AGREEMENT IN REPLICATED DATABASES5 Objects For the purpose of our reconciliation mechanism, we assume a universal space of object identifiers. Objects are distinct (i.e., non-overlapping).
Reference: 29. <author> T. Mostardi and C. Siciliano, "Bitransactions, </author> <title> Relay Races, and their Applications to the Management of Replicated Data," </title> <type> CRAI Internal Report, </type> <institution> S. Stefano di Rende (CS), Italy, </institution> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: In this approach, persistent transmission of messages is required, for instance, by mean of stable queues [7], or gossip mechanisms [22], [37]. Another approach that avoids two-phase commit is given in <ref> [29] </ref>; transactions commit at a primary site and are propagated asynchronously. A partial order among transactions is defined for controlling update propagation; the use of a partial order is also proposed in [27] and in [15] (in the context of concurrency control for groupware systems).
Reference: 30. <author> N. Natarajan and T.V. Laksman, </author> <title> "An Open Architecture Facilitating Semantics Based Transaction Management for Telecommunications Applications," </title> <booktitle> in Proc. Int. Workshop on High-Performance Transaction Systems, Asilomar, </booktitle> <month> Sep. </month> <year> 1991. </year>
Reference-contexts: Network partitions or site failures may thus lead to smaller availability of the database system. Not all applications should pay the price for maintaining a consistent view on replicated data and immediate update propagation [16], [20], <ref> [30] </ref>. Examples of such applications are automated teller machine networks, flight reservation, and part inventory control. For instance, it is clearly unacceptable for a flight reservation system to become globally unavailable in case of a site failure or network partition.
Reference: 31. <author> D.S. Parker, et al., </author> <title> "Detection of Mutual Inconsistency in Distributed Systems," </title> <journal> IEEE T-SE, </journal> <month> May </month> <year> 1983. </year>
Reference-contexts: This vector has an entry for each site k, RV o q [1; : : :; n]. (The idea of using a vector for detecting inconsistency among sites, was proposed before in [16], [27], <ref> [31] </ref>.) The semantics of the reception vector is illustrated by the following invariant condition: 6 S.CERI, M.A.W. HOUTSMA, A.M. KELLER, P.
Reference: 32. <author> C. Pu and A. Leff, "Epsilon-Serializability," </author> <type> Technical Report No. </type> <institution> CUCS-054-90, Columbia University, </institution> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: It is preferable to take the risk to overbook a plane (and possibly correct this situation at the end of the failure), than to stop making reservations. Therefore, current research focuses on delayed propagation of updates <ref> [32] </ref>, [33], and transformation of global constraints into local constraints (thereby increasing local autonomy) [4], [5]. Some commercial systems are also developing products for dealing with asynchronous updates to replicated databases (e.g., Sybase, [12]). <p> These protocols suffer from unrealistically strong assumptions [34]; therefore, a lot of work has been done to allow some more flexibility [4], [9], [25]. A noticeable example of this is the work on epsilon-serializability <ref> [32] </ref>, [33]. Updates are allowed to propagate through the system asynchronously; eventual consistency of the system is an asymptotical property. A whole family of methods, each one different in the level of asynchrony, can be described using the concept of epsilon-serializability.
Reference: 33. <author> C. Pu and A. Leff, </author> <title> "Replica Control in Distributed Systems: an Asynchronous Approach," </title> <booktitle> Proc. ACM SIGMOD'91, </booktitle> <address> Denver, CO, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: It is preferable to take the risk to overbook a plane (and possibly correct this situation at the end of the failure), than to stop making reservations. Therefore, current research focuses on delayed propagation of updates [32], <ref> [33] </ref>, and transformation of global constraints into local constraints (thereby increasing local autonomy) [4], [5]. Some commercial systems are also developing products for dealing with asynchronous updates to replicated databases (e.g., Sybase, [12]). <p> These protocols suffer from unrealistically strong assumptions [34]; therefore, a lot of work has been done to allow some more flexibility [4], [9], [25]. A noticeable example of this is the work on epsilon-serializability [32], <ref> [33] </ref>. Updates are allowed to propagate through the system asynchronously; eventual consistency of the system is an asymptotical property. A whole family of methods, each one different in the level of asynchrony, can be described using the concept of epsilon-serializability.
Reference: 34. <author> K.V.S. Ramarao, </author> <title> "Transaction Atomicity in the Presence of Network Partition," </title> <booktitle> in Proc. 4th Int. Conf. on Data Engineering, </booktitle> <address> Feb. 1988, Los Angeles, CA, </address> <pages> pp. 512-519. </pages>
Reference-contexts: In case of network partitions, either updates are INDEPENDENT UPDATES AND INCREMENTAL AGREEMENT IN REPLICATED DATABASES3 accepted on a subset of the sites, or transactions that are known not to lead to inconsistency are the only ones allowed to run [3]. These protocols suffer from unrealistically strong assumptions <ref> [34] </ref>; therefore, a lot of work has been done to allow some more flexibility [4], [9], [25]. A noticeable example of this is the work on epsilon-serializability [32], [33]. Updates are allowed to propagate through the system asynchronously; eventual consistency of the system is an asymptotical property.
Reference: 35. <author> A. Reuter and H. Wachter, </author> <title> "The Contract Model," </title> <journal> IEEE Database Engineering Bulletin Vol. </journal> <volume> 14, No. 1, </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: Some global constraints can be split into local constraints (e.g., using the demarcation protocol [4]) and therefore still be enforced; compensating actions can be applied to restore consistency after violation of global constraints [17], <ref> [35] </ref>. The main contribution of the paper is to combine gossip techniques for update propagation and techniques for transaction reconciliation in a unique framework. Algorithms for indipendent update executions and for reconciliations in such a framework are illustrated together with the proofs of their correctness. 1.1.
Reference: 36. <author> S.K. Sarin, C.W. Kaufman, and J.E. Somers, </author> <title> "Using History Information to Process Delayed Database Updates," </title> <booktitle> Proc. 12th Int. Conf. on Very Large Data Bases, </booktitle> <address> Kyoto, Japan, </address> <month> Aug. </month> <year> 1986, </year> <pages> pp. 71-78. </pages>
Reference-contexts: Finally, some systems allow even more flexibility. In [13] a system is described for maintaining weak consistency among various database systems. Updates are accepted at any site, and are guaranteed to be reflected at all other sites eventually. In <ref> [36] </ref> a system is described that uses timestamp-based concurrency control and proposes to apply updates to replicated data in their arrival order, possibly restoring inconsistencies when arrivals violate the timestamp ordering of transactions.
Reference: 37. <author> G.T.J. Wuu and A. Bernstein, </author> <title> "Efficient Solutions to the Replicated Log and Dictionary Problems," </title> <booktitle> in Proc. 3rd ACM Symposium on Principles of Distributed Computing, </booktitle> <year> 1984. </year>
Reference-contexts: Each of these subtransactions commits locally, with the provision that if the root of the tree commits, all its children commit too. In this approach, persistent transmission of messages is required, for instance, by mean of stable queues [7], or gossip mechanisms [22], <ref> [37] </ref>. Another approach that avoids two-phase commit is given in [29]; transactions commit at a primary site and are propagated asynchronously. <p> However, only the insert and delete operations are allowed, and the vector does not give any indication of how up to date other sites of the system are. Therefore, this approach requires a site to send its entire copy of a dictionary at each message. In <ref> [37] </ref>, the approach of [16] was extended by storing at each site a matrix, instead of a vector. The matrix at each site indicates how up to date all sites are, thus limiting the communication requirements among sites. As we will see, [37] has therefore many features in common with our <p> In <ref> [37] </ref>, the approach of [16] was extended by storing at each site a matrix, instead of a vector. The matrix at each site indicates how up to date all sites are, thus limiting the communication requirements among sites. As we will see, [37] has therefore many features in common with our paper; however there are also major differences. [37] is limited to solving the dictionary problem, and both [16], [37] do not consider a reconciliation phase, which is one of the main component of our approach. <p> The matrix at each site indicates how up to date all sites are, thus limiting the communication requirements among sites. As we will see, <ref> [37] </ref> has therefore many features in common with our paper; however there are also major differences. [37] is limited to solving the dictionary problem, and both [16], [37] do not consider a reconciliation phase, which is one of the main component of our approach. Instead of using a specific reconciliation mechanism, a site can synchrously send part of its log and matrix to other sites. <p> As we will see, <ref> [37] </ref> has therefore many features in common with our paper; however there are also major differences. [37] is limited to solving the dictionary problem, and both [16], [37] do not consider a reconciliation phase, which is one of the main component of our approach. Instead of using a specific reconciliation mechanism, a site can synchrously send part of its log and matrix to other sites.
References-found: 37

