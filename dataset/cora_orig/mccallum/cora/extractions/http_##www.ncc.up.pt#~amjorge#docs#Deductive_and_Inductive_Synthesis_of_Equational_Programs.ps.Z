URL: http://www.ncc.up.pt/~amjorge/docs/Deductive_and_Inductive_Synthesis_of_Equational_Programs.ps.Z
Refering-URL: http://www.ncc.up.pt/~amjorge/Personal_Repository.html
Root-URL: 
Email: Net: fnachum,reddyg@cs.uiuc.edu  
Title: Deductive and Inductive Synthesis of Equational Programs |Draft|  
Author: Nachum Dershowitz and Uday S. Reddy 
Date: August 3, 1992  
Address: Urbana, IL 61801  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: An equational approach to the synthesis of functional and logic program is taken. Typically, the synthesis task involves finding equations which make the given specification an inductive theorem. To synthesize such programs, induction is necessary. We formulate efficient procedures for inductive proof as well as program synthesis using the framework of ordered rewriting. We also propose heuristics for generalizing from a sequence of equational consequences. These heuristics handle cases where the deductive process alone is not adequate to come with a program.
Abstract-found: 1
Intro-found: 1
Reference: [ACM91] <editor> ACM. </editor> <title> Symp. Partial Evaluation and Semantics-Based Program Manipulation. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(9):1991, </volume> <year> 1991. </year>
Reference-contexts: It has also been adapted to reasoning about logic programs, see, for example, [Dev90, Hog76, TS84]. Significant effort has been devoted to building automated systems based on the methodology [Dar81, Fea79, Fea82]. Partial evaluation systems, which have been increasingly successful in recent times <ref> [ACM91, BEJ88] </ref>, are also based on the unfold-fold method.
Reference: [Bac88] <author> L. Bachmair. </author> <title> Proof by consistency. </title> <booktitle> In Symp. on Logic in Comp. Science. IEEE, </booktitle> <year> 1988. </year>
Reference-contexts: In the cited work, we treat rewrite systems, and, here, generalize the techniques to unoriented equations using the notion of "ordered rewriting". The application of ordered rewriting to program synthesis and inductive proofs has also been considered in <ref> [Bac88, Bel91a, Gra89] </ref>. [FF86] compares rewriting techniques with the plain equational methods of Burstall and Darlington. 2 Overview of program synthesis Assume that we wish to synthesize a program for some function f and are given a specification S of the function f together with an axiomatization E of the problem <p> The above Cases rule considers superposition at a single position of the given equation. It is also possible to choose any position on either side of the equation for critical pairs, using ideas from <ref> [Bac88] </ref>. 10 Definition 4 A set of equations C is said to be a cover set for an equation t = u (with respect to E and &gt;) if, for every irreducible ground substitution , either t u or there exist equation r = s in C and ground substitution t <p> So, inductive reasoning is an integral part of program synthesis. In this section, we briefly outline our inductive reasoning procedure based on term rewriting induction. This method was first presented in [Red90b] and is based on the "induction by completion" method studied in <ref> [Bac88, Der85, Fri86, JK86, KM84, Kuc89, Mus80] </ref>. The latter is also referred to by "inductionless induction" or "proof by consistency".
Reference: [BD77] <author> R. M. Burstall and J. Darlington. </author> <title> A transformation system for developing recursive programs. </title> <journal> Journal of the ACM, </journal> <volume> 24(1) </volume> <pages> 44-67, </pages> <month> January </month> <year> 1977. </year>
Reference-contexts: 1 Introduction In a seminal piece of work, Burstall and Darlington <ref> [BD77] </ref> showed how functional programs, expressed as equations, can be transformed to more efficient ones using equational reasoning. <p> Y )) = append (reverse (U ); A Y ) = rev (U; A Y ) All the steps use axioms to replace "equals by equals", except for the last step which uses the original specification for a smaller instance. (Such use of the original specification is termed "folding" in <ref> [BD77] </ref>.) Note also that all these steps can be viewed as either forward or backward reasoning steps. In the forward reasoning view, we depend on an appropriate synthesis procedure to generate only "interesting" consequences of the specification. <p> So, this is indeed the final program for rev. As a somewhat intricate example of the synthesis process, consider the problem of checking two binary trees for the equality of their fringes. (This is a problem considered by Burstall and Darlington <ref> [BD77] </ref>.) We start with the following axioms: f (tip (A)) = A nil (17) f ((U ffi V ) ffi R) = f (U ffi (V ffi R)) (19) nil L nil = true (20) A U L nil = false (21) nil L B V = false (22) A U <p> Note that we did not need to postulate an auxiliary function to calculate the fringe of a list of trees, as done in <ref> [BD77] </ref>. 7 Generalization Running the synthesis procedure with domain equations 2 x + 0 = x and specification x + x = dx 2 In this section, we usually omit parentheses for unary function symbols. 18 generates an infinite set of equations: d0 = 0 ds0 = ss0 ssssx + x
Reference: [BDP89] <author> L. Bachmair, N. Dershowitz, and D. A. Plaisted. </author> <title> Completion without failure. </title> <editor> In H. At Kaci and M. Nivat, editors, </editor> <title> Resolution of Equations in Algebraic Structures, </title> <booktitle> volume 2: Rewriting Techniques, chapter 1, </booktitle> <pages> pages 1-30. </pages> <publisher> Academic Press, </publisher> <year> 1989. </year>
Reference-contexts: Superposition uses two given rewrite rules to deduce a new rewrite rule. The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations <ref> [BDP89, HR87, MN90] </ref>, conditional equations [BK86, Gan91, Kap87, KR87], and first-order reasoning [BR91, HD83, HR86, NO91, ZK88]. See [Der89, DJ90, HO80] for accessible surveys of this rapidly developing area. <p> The conventional term rewriting theory deals with rewrite systems, i.e., sets of equations r ! s which are all oriented in a particular direction. The idea that unoriented equations can also be used for rewriting provided they are used along a reducing direction was proposed in <ref> [BDP89, HR87] </ref>. This form of rewriting is often called ordered rewriting. The results of this paper generalize our previous results [Der82a, Der85, DP90, Red89, Red90b] to the framework of ordered rewriting. The mixing of programs and program synthesis with termination issues needs some explanation. <p> This process, together with 9 simplification of the resulting equations, is called (ordered) completion. Since proofs of the above form are the only obstacles to confluence, the result of completion is a ground confluent system that defines unique normal forms for all ground terms. See <ref> [BDP89, MN90] </ref> for a discussion of completion. In applying equational reasoning to program verification and synthesis, we have a fixed equational program. The equation l = r used in the superposition inference belongs to the fixed program, and need not be treated as a premise of the ifnerence.
Reference: [BEJ88] <editor> D. Bjorner, A. P. Erschov, and N. D. Jones (eds). </editor> <title> Partial Evaluation and Mixed Computation. </title> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: It has also been adapted to reasoning about logic programs, see, for example, [Dev90, Hog76, TS84]. Significant effort has been devoted to building automated systems based on the methodology [Dar81, Fea79, Fea82]. Partial evaluation systems, which have been increasingly successful in recent times <ref> [ACM91, BEJ88] </ref>, are also based on the unfold-fold method.
Reference: [Bel91a] <author> F. Bellegarde. </author> <title> Program transformation and rewriting. </title> <editor> In R. Book, editor, </editor> <booktitle> Fourth Intern. Conf. on Rewriting Techniques and Applications, </booktitle> <pages> pages 226-239. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1991. </year> <note> Vol. 488 of Lect. Notes in Comp. Science. </note>
Reference-contexts: In the cited work, we treat rewrite systems, and, here, generalize the techniques to unoriented equations using the notion of "ordered rewriting". The application of ordered rewriting to program synthesis and inductive proofs has also been considered in <ref> [Bac88, Bel91a, Gra89] </ref>. [FF86] compares rewriting techniques with the plain equational methods of Burstall and Darlington. 2 Overview of program synthesis Assume that we wish to synthesize a program for some function f and are given a specification S of the function f together with an axiomatization E of the problem
Reference: [Bel91b] <author> Francois Bellegarde. </author> <title> Program transformation and rewriting. </title> <editor> In Ron Book, editor, </editor> <booktitle> Proceedings of the Fourth International Conference on Rewriting Techniques and Applications, </booktitle> <pages> pages 226-239, </pages> <address> Como, Italy, </address> <month> April </month> <year> 1991. </year> <title> Vol. </title> <booktitle> 488 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <address> Berlin. </address> <month> 23 </month>
Reference-contexts: Two heuristics come into play: The first is to abstract a subterm appearing in a program, creating a subprogram to compute it (cf. <ref> [Bel91b] </ref>). The second is to compute two functions at once, or one function for two arguments, when expanding (unfolding) the definition of one leads to multiple applications of the same function (cf. [Red89, Bel91b]). <p> The second is to compute two functions at once, or one function for two arguments, when expanding (unfolding) the definition of one leads to multiple applications of the same function (cf. <ref> [Red89, Bel91b] </ref>).
Reference: [BH84] <author> W. Bibel and K. M. Hornig. </author> <title> LOPS A system based on a strategical approach to program synthesis. </title> <editor> In A. W. Biermann, G. Guiho, and Y. Kodratoff, editors, </editor> <title> Automatic Program Construction Techniques, </title> <booktitle> chapter 3, </booktitle> <pages> pages 69-90. </pages> <publisher> MacMillan Pub. Co., </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: 1 * How does the method generalize to forms of programs (and logics) other than equational ones? (For instance, conditional equations, Horn clauses or first-order clauses.) * What role does (mathematical) induction play in the synthesis process? * How does the method relate to other techniques of deductive synthesis, like <ref> [BH84, MW80, Smi90] </ref>? In attempting to answer such questions, we are led to the framework of term rewriting, which is the best known technique of controlled equational reasoning. Term rewriting was first used in automated reasoning by Knuth and Bendix [KB70] for solving word problems in equational theories.
Reference: [BK86] <author> J. A. Bergstra and Jan Willem Klop. </author> <title> Conditional rewrite rules: Confluency and termination. </title> <journal> J. of Computer and System Sciences, </journal> <volume> 32 </volume> <pages> 323-362, </pages> <year> 1986. </year>
Reference-contexts: Superposition uses two given rewrite rules to deduce a new rewrite rule. The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations [BDP89, HR87, MN90], conditional equations <ref> [BK86, Gan91, Kap87, KR87] </ref>, and first-order reasoning [BR91, HD83, HR86, NO91, ZK88]. See [Der89, DJ90, HO80] for accessible surveys of this rapidly developing area.
Reference: [BK89] <author> R. Bundgen and W. Kuchlin. </author> <title> Computing ground reducibility and inductively complete positions. </title> <editor> In N. Dershowitz, editor, </editor> <booktitle> Rewriting Techniques and Applications, </booktitle> <pages> pages 59-75. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1989. </year>
Reference-contexts: The advantage of this method is that the test set is computed only once and reused in each Cases inference. However, this method still requires all critical pairs to be computed for the cover set. Other methods for testing ground reducibility may found in <ref> [JK86, KZ85, BK89] </ref>. 5 Induction In synthesizing a program from a specification, we must ensure that the derived program verifies the specification. That is, the specification must be an inductive theorem of the derived program. So, inductive reasoning is an integral part of program synthesis.
Reference: [BM77] <author> Robert S. Boyer and J Strother Moore. </author> <title> A lemma driven automatic theorem prover for recursive function theory. </title> <booktitle> In Proceedings of the Fifth International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 511-519, </pages> <address> Cambridge, MA, </address> <year> 1977. </year>
Reference-contexts: What is needed is some way of guessing the more general equation dsx = ssdx. We use two processes to generate hypotheses. The first involves generating critical pairs between equations; the second is a syntactic form of generalization, a la <ref> [BM77] </ref>. The intuition is that if we are dissatisfied from the computational point of view with the equations generated, we look for new equations between terms containing the defined function symbol in the hope of discovering a pattern.
Reference: [BR91] <author> F. Bronsard and U. S. Reddy. </author> <title> Conditional rewriting in Focus. </title> <editor> In S. Kaplan and M. Okada, editors, </editor> <booktitle> Conditional and Typed Rewriting Systems | Second International CTRS Workshop, </booktitle> <pages> pages 2-13. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations [BDP89, HR87, MN90], conditional equations [BK86, Gan91, Kap87, KR87], and first-order reasoning <ref> [BR91, HD83, HR86, NO91, ZK88] </ref>. See [Der89, DJ90, HO80] for accessible surveys of this rapidly developing area. The contributions of this paper are three fold: First, we enrich the basic equational reasoning techniques used by Burstall and Darlington with additional structure to obtain rewrite-based reasoning. <p> Conditional rewriting and goal solving may provide a better combination of functional and logic programming than purely equational programs; see, for instance, [DP88]. Conditional synthesis, however, would necessitate more powerful deductive and inductive methods for handling conditional equations, such as have been investigated in <ref> [BR91, KR90, Gan91] </ref>. More elaborate generalization methods would also be required.
Reference: [BW88] <author> R. Bird and P. Wadler. </author> <title> Introduction to Functional Programming. </title> <booktitle> Prentice-Hall International, </booktitle> <address> London, </address> <year> 1988. </year>
Reference-contexts: The method has come to be called the "fold-unfold" method and forms an important component in reasoning about functional programs. (Cf. <ref> [BW88] </ref>). It has also been adapted to reasoning about logic programs, see, for example, [Dev90, Hog76, TS84]. Significant effort has been devoted to building automated systems based on the methodology [Dar81, Fea79, Fea82]. <p> First, it ensures that programs terminate along all evaluation paths. While this is a reasonable requirement for most common programs, some applications also require programs which do not terminate but make progress indefinitely. Programs in lazy functional languages <ref> [BW88] </ref> often exhibit this property.
Reference: [Dar81] <author> J. Darlington. </author> <title> The structured description of algorithm derivations. </title> <editor> In J. W. de Bakker and J. C. van Vliet, editors, </editor> <booktitle> Algorithmic Languages, </booktitle> <pages> pages 221-250. </pages> <publisher> North-Holland, </publisher> <year> 1981. </year>
Reference-contexts: It has also been adapted to reasoning about logic programs, see, for example, [Dev90, Hog76, TS84]. Significant effort has been devoted to building automated systems based on the methodology <ref> [Dar81, Fea79, Fea82] </ref>. Partial evaluation systems, which have been increasingly successful in recent times [ACM91, BEJ88], are also based on the unfold-fold method.
Reference: [Der82a] <author> N. Dershowitz. </author> <title> Applications of the Knuth-Bendix completion procedure. </title> <booktitle> In Proc. of the Seminaire d'Informatique Theorique, Paris, </booktitle> <pages> pages 95-111, </pages> <month> December </month> <year> 1982. </year>
Reference-contexts: Second, we propose (mathematical) induction techniques to define and ensure the correctness of synthesized programs. Third, we demonstrate how inductive generalization techniques supplement the basic deductive techniques to achieve an automated program synthesis system. This paper consolidates and extends our previous work reported in <ref> [Der82a, DP90, Red89, Red90b] </ref>. In the cited work, we treat rewrite systems, and, here, generalize the techniques to unoriented equations using the notion of "ordered rewriting". <p> The idea that unoriented equations can also be used for rewriting provided they are used along a reducing direction was proposed in [BDP89, HR87]. This form of rewriting is often called ordered rewriting. The results of this paper generalize our previous results <ref> [Der82a, Der85, DP90, Red89, Red90b] </ref> to the framework of ordered rewriting. The mixing of programs and program synthesis with termination issues needs some explanation. Requiring that the rewrite relation be always included in a well-founded order has two consequences. First, it ensures that programs terminate along all evaluation paths.
Reference: [Der82b] <author> N. Dershowitz. </author> <title> Orderings for term-rewriting systems. </title> <journal> Theoretical Computer Science, </journal> <volume> 17(3) </volume> <pages> 279-301, </pages> <year> 1982. </year>
Reference-contexts: implies t u for all substitutions . (In practice, it suffices to use some simplification ordering on free terms for , provided it has the substitution property and t u implies t &gt; u for all ground substitutions .) Of particular interest in program synthesis is the lexicographic path ordering <ref> [Der82b, KL80] </ref>. Assume a total order on function symbols referred to as a "precedence order".
Reference: [Der85] <author> N. Dershowitz. </author> <title> Computing with rewrite systems. </title> <journal> Inf. Control, </journal> 65(2/3):122-157, 1985. 
Reference-contexts: The two equations div (X; X + Z + 1; 0; X) ! true div (U + Y + 1; Y + 1; N + 1; R) ! div (U; Y + 1; N; R) can be viewed as a logic program for division. (See <ref> [Der85] </ref> for a discussion of how logic programs are treated in the equational framework.) 3 Equational programs First, we briefly explain our notation. By an alphabet of function symbols , we mean a set of function symbols together with an arity associated with each. <p> The idea that unoriented equations can also be used for rewriting provided they are used along a reducing direction was proposed in [BDP89, HR87]. This form of rewriting is often called ordered rewriting. The results of this paper generalize our previous results <ref> [Der82a, Der85, DP90, Red89, Red90b] </ref> to the framework of ordered rewriting. The mixing of programs and program synthesis with termination issues needs some explanation. Requiring that the rewrite relation be always included in a well-founded order has two consequences. First, it ensures that programs terminate along all evaluation paths. <p> For example, the natural number axioms (13-15) only model the true cases of comparisons. It is not, in general, possible to specify the sets and in a mechanically verifiable fashion, but <ref> [Der85] </ref> gives methods for some important cases. 8 4 Superposition and case-based reasoning An important component in the informal synthesis procedure outlined in Section 2 is the instan-tiation of equations for the various cases of their variables. <p> So, inductive reasoning is an integral part of program synthesis. In this section, we briefly outline our inductive reasoning procedure based on term rewriting induction. This method was first presented in [Red90b] and is based on the "induction by completion" method studied in <ref> [Bac88, Der85, Fri86, JK86, KM84, Kuc89, Mus80] </ref>. The latter is also referred to by "inductionless induction" or "proof by consistency".
Reference: [Der89] <author> N. Dershowitz. </author> <title> Completion and its applications. In Resolution of Equations in Algebraic Structures, </title> <booktitle> volume 2: Rewriting Techniques, </booktitle> <pages> pages 31-86. </pages> <publisher> Academic Press, </publisher> <address> San Diego, </address> <year> 1989. </year>
Reference-contexts: The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations [BDP89, HR87, MN90], conditional equations [BK86, Gan91, Kap87, KR87], and first-order reasoning [BR91, HD83, HR86, NO91, ZK88]. See <ref> [Der89, DJ90, HO80] </ref> for accessible surveys of this rapidly developing area. The contributions of this paper are three fold: First, we enrich the basic equational reasoning techniques used by Burstall and Darlington with additional structure to obtain rewrite-based reasoning.
Reference: [Dev90] <author> Y. Deville. </author> <title> Logic Programming: Systematic Program Development. </title> <publisher> Addison-Wesley, </publisher> <address> Wokingham, </address> <year> 1990. </year>
Reference-contexts: The method has come to be called the "fold-unfold" method and forms an important component in reasoning about functional programs. (Cf. [BW88]). It has also been adapted to reasoning about logic programs, see, for example, <ref> [Dev90, Hog76, TS84] </ref>. Significant effort has been devoted to building automated systems based on the methodology [Dar81, Fea79, Fea82]. Partial evaluation systems, which have been increasingly successful in recent times [ACM91, BEJ88], are also based on the unfold-fold method.
Reference: [DJ90] <author> N. Dershowitz and J.-P. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science B: Formal Methods and Semantics, chapter 6, </booktitle> <pages> pages 243-320. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations [BDP89, HR87, MN90], conditional equations [BK86, Gan91, Kap87, KR87], and first-order reasoning [BR91, HD83, HR86, NO91, ZK88]. See <ref> [Der89, DJ90, HO80] </ref> for accessible surveys of this rapidly developing area. The contributions of this paper are three fold: First, we enrich the basic equational reasoning techniques used by Burstall and Darlington with additional structure to obtain rewrite-based reasoning.
Reference: [DK89] <author> N. Dershowitz and S. Kaplan. </author> <title> Rewrite, rewrite, rewrite, rewrite, rewrite,: </title> : : . <booktitle> In Sixteenth Ann. ACM Symp. on Princ. of Program. Lang., </booktitle> <pages> pages 250-259. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: Programs in lazy functional languages [BW88] often exhibit this property. We envisage that the techniques of this paper will eventually be extended to such programs by suitable relaxation of the termination requirements. (Cf. <ref> [DK89] </ref>.) A second consequence of the termination of rewrite relations is that the automated reasoning procedures have some heuristic guidance about the direction they should employ in reducing problems. Without such guidance, the reasoning procedures need to explore too many possibilities resulting in large search spaces and much redundancy.
Reference: [DP88] <author> Nachum Dershowitz and David A. Plaisted. </author> <title> Equational programming. </title> <editor> In J. E. Hayes, D. Michie, and J. Richards, editors, </editor> <booktitle> Machine Intelligence 11: The logic and acquisition of knowledge, chapter 2, </booktitle> <pages> pages 21-56. </pages> <publisher> Oxford Press, Oxford, </publisher> <year> 1988. </year> <note> To be reprinted in Logical Foundations of Machine Intelligence, Horwood. 24 </note>
Reference-contexts: It has been used to synthesize several interesting examples including some reasonably large programs [Red88, Red90a, Red91]. In this paper, we have considered rewriting with equations. Conditional rewriting and goal solving may provide a better combination of functional and logic programming than purely equational programs; see, for instance, <ref> [DP88] </ref>. Conditional synthesis, however, would necessitate more powerful deductive and inductive methods for handling conditional equations, such as have been investigated in [BR91, KR90, Gan91]. More elaborate generalization methods would also be required.
Reference: [DP90] <author> N. Dershowitz and E. Pinchover. </author> <title> Inductive synthesis of equational programs. </title> <booktitle> In Eighth National Conf. on Artificial Intelligence, </booktitle> <pages> pages 234-239, </pages> <address> Boston, MA, </address> <month> July </month> <year> 1990. </year> <note> AAAI. </note>
Reference-contexts: Second, we propose (mathematical) induction techniques to define and ensure the correctness of synthesized programs. Third, we demonstrate how inductive generalization techniques supplement the basic deductive techniques to achieve an automated program synthesis system. This paper consolidates and extends our previous work reported in <ref> [Der82a, DP90, Red89, Red90b] </ref>. In the cited work, we treat rewrite systems, and, here, generalize the techniques to unoriented equations using the notion of "ordered rewriting". <p> The idea that unoriented equations can also be used for rewriting provided they are used along a reducing direction was proposed in [BDP89, HR87]. This form of rewriting is often called ordered rewriting. The results of this paper generalize our previous results <ref> [Der82a, Der85, DP90, Red89, Red90b] </ref> to the framework of ordered rewriting. The mixing of programs and program synthesis with termination issues needs some explanation. Requiring that the rewrite relation be always included in a well-founded order has two consequences. First, it ensures that programs terminate along all evaluation paths.
Reference: [Fea79] <author> M. S. Feather. </author> <title> A System for Developing Programs by Transformation. </title> <type> PhD thesis, </type> <institution> Univ. of Edinburgh, </institution> <year> 1979. </year>
Reference-contexts: It has also been adapted to reasoning about logic programs, see, for example, [Dev90, Hog76, TS84]. Significant effort has been devoted to building automated systems based on the methodology <ref> [Dar81, Fea79, Fea82] </ref>. Partial evaluation systems, which have been increasingly successful in recent times [ACM91, BEJ88], are also based on the unfold-fold method.
Reference: [Fea82] <author> M. S. Feather. </author> <title> A system for assisting program transformation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(1) </volume> <pages> 1-20, </pages> <year> 1982. </year>
Reference-contexts: It has also been adapted to reasoning about logic programs, see, for example, [Dev90, Hog76, TS84]. Significant effort has been devoted to building automated systems based on the methodology <ref> [Dar81, Fea79, Fea82] </ref>. Partial evaluation systems, which have been increasingly successful in recent times [ACM91, BEJ88], are also based on the unfold-fold method.
Reference: [FF86] <author> B. Fronhofer and U. Furbach. </author> <title> Knuth-Bendix completion versus fold/unfold: A comparative study in program synthesis. </title> <editor> In C. Rollinger and W. Horn, editors, </editor> <booktitle> Proc. of the Tenth German Workshop on Artificial Intelligence, </booktitle> <pages> pages 289-300, </pages> <year> 1986. </year>
Reference-contexts: In the cited work, we treat rewrite systems, and, here, generalize the techniques to unoriented equations using the notion of "ordered rewriting". The application of ordered rewriting to program synthesis and inductive proofs has also been considered in [Bac88, Bel91a, Gra89]. <ref> [FF86] </ref> compares rewriting techniques with the plain equational methods of Burstall and Darlington. 2 Overview of program synthesis Assume that we wish to synthesize a program for some function f and are given a specification S of the function f together with an axiomatization E of the problem domain.
Reference: [Fri86] <author> L. </author> <title> Fribourg. A strong restriction of the inductive completion procedure. </title> <booktitle> In Intern. Colloq. Automata, Languages. and Programming, </booktitle> <pages> pages 105-115, </pages> <month> July </month> <year> 1986. </year> <booktitle> (Springer Lect. Notes in Comp. Science, </booktitle> <volume> Vol. </volume> <pages> 226). </pages>
Reference-contexts: The extraneous critical pairs included in the cover set generate other critical pairs so that the proof procedures based on such cover sets may not terminate. A useful optimization that has been suggested in <ref> [Fri86, Kuc89] </ref> is to consider a subterm s of either t or u that is ground reducible. (A term is ground reducible if every ground instance is reducible.) Then superposition at the subterm s is enough to obtain a cover set. Kapur, et al. [KNZ86] suggest another optimization. <p> So, inductive reasoning is an integral part of program synthesis. In this section, we briefly outline our inductive reasoning procedure based on term rewriting induction. This method was first presented in [Red90b] and is based on the "induction by completion" method studied in <ref> [Bac88, Der85, Fri86, JK86, KM84, Kuc89, Mus80] </ref>. The latter is also referred to by "inductionless induction" or "proof by consistency".
Reference: [Gan91] <author> H. Ganzinger. </author> <title> A completion procedure for conditional equations. </title> <journal> J. Symbolic Computation, </journal> <volume> 11 </volume> <pages> 51-81, </pages> <year> 1991. </year>
Reference-contexts: Superposition uses two given rewrite rules to deduce a new rewrite rule. The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations [BDP89, HR87, MN90], conditional equations <ref> [BK86, Gan91, Kap87, KR87] </ref>, and first-order reasoning [BR91, HD83, HR86, NO91, ZK88]. See [Der89, DJ90, HO80] for accessible surveys of this rapidly developing area. <p> Conditional rewriting and goal solving may provide a better combination of functional and logic programming than purely equational programs; see, for instance, [DP88]. Conditional synthesis, however, would necessitate more powerful deductive and inductive methods for handling conditional equations, such as have been investigated in <ref> [BR91, KR90, Gan91] </ref>. More elaborate generalization methods would also be required.
Reference: [Gra89] <author> B. Gramlich. </author> <title> Induction theorem proving using refined unfailing completion techniques. </title> <type> Technical Report SR89-14, </type> <institution> Universitat Kaiserslautern, Germany, </institution> <year> 1989. </year>
Reference-contexts: In the cited work, we treat rewrite systems, and, here, generalize the techniques to unoriented equations using the notion of "ordered rewriting". The application of ordered rewriting to program synthesis and inductive proofs has also been considered in <ref> [Bac88, Bel91a, Gra89] </ref>. [FF86] compares rewriting techniques with the plain equational methods of Burstall and Darlington. 2 Overview of program synthesis Assume that we wish to synthesize a program for some function f and are given a specification S of the function f together with an axiomatization E of the problem
Reference: [HD83] <author> Jieh Hsiang and Nachum Dershowitz. </author> <title> Rewrite methods for clausal and non-clausal theorem proving. </title> <booktitle> In Proceedings of the Tenth International Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 331-346, </pages> <address> Barcelona, Spain, </address> <month> July </month> <year> 1983. </year> <booktitle> European Association of Theoretical Computer Science. Vol. 154 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <address> Berlin. </address>
Reference-contexts: The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations [BDP89, HR87, MN90], conditional equations [BK86, Gan91, Kap87, KR87], and first-order reasoning <ref> [BR91, HD83, HR86, NO91, ZK88] </ref>. See [Der89, DJ90, HO80] for accessible surveys of this rapidly developing area. The contributions of this paper are three fold: First, we enrich the basic equational reasoning techniques used by Burstall and Darlington with additional structure to obtain rewrite-based reasoning. <p> All predicate symbols are treated as function symbols and so are the logical connectives :, ^, _, , and ,. Figure 1 gives an equational axiomatization of propositional calculus in this notation. (Cf. <ref> [HD83] </ref>.) Consider the following axiomatization of addition, multiplication and comparison of natural numbers in the unary number system, wherein the number n is represented as a sum of n 1's: M + 0 = M (8) (M + N ) + K = M + (N + K) (10) M fi
Reference: [HH82] <author> Gerard Huet and Jean-Marie Hullot. </author> <title> Proofs by induction in equational theories with constructors. </title> <journal> J. of Computer and System Sciences, </journal> <volume> 25 </volume> <pages> 239-266, </pages> <year> 1982. </year>
Reference-contexts: In particular, we can take advantage of constructors, replacing hypotheses of the from c (s 1 ; : : : ; s n ) = c (t 1 ; : : : ; t n ) with n hypotheses s i = t i , when the constructor is free <ref> [HH82] </ref>. In the above case, we are free to strip off matching outer s's from the generated hypotheses: sx + x = s (x + x) . . . Generalizing, as before, leads to the hypothesis sx + y = s (x + y), exactly what we were looking for.
Reference: [HO80] <author> G. Huet and D. C. Oppen. </author> <title> Equations and rewrite rules: A survey. </title> <editor> In R. Book, editor, </editor> <booktitle> Formal Language Theory: Perspectives and Open Problems, </booktitle> <pages> pages 349-405. </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1980. </year>
Reference-contexts: The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations [BDP89, HR87, MN90], conditional equations [BK86, Gan91, Kap87, KR87], and first-order reasoning [BR91, HD83, HR86, NO91, ZK88]. See <ref> [Der89, DJ90, HO80] </ref> for accessible surveys of this rapidly developing area. The contributions of this paper are three fold: First, we enrich the basic equational reasoning techniques used by Burstall and Darlington with additional structure to obtain rewrite-based reasoning.
Reference: [Hoa71] <author> C. A. R. Hoare. </author> <title> Procedures and parameters: An axiomatic approach. </title> <editor> In E. Engeler, editor, </editor> <booktitle> Symp. Semantics of Algorithmic Languages, volume 188 of (Lect. Notes in Math.), </booktitle> <pages> pages 102-116. </pages> <publisher> Springer-Verlag, </publisher> <year> 1971. </year> <note> (Lect. Notes in Math. Vo. 188). </note>
Reference-contexts: The proof method itself takes care of the condition. Such implicit application of induction may also be found in a variety of program verification methods such as Hoare logic (especially, the treatment of recursion <ref> [Hoa71] </ref>) and fixed point induction [Man74, Sco76]. We make these ideas precise by the following inference procedure.
Reference: [Hog76] <author> C. J. </author> <title> Hogger. Derivation of logic programs. </title> <journal> Journal of the ACM, </journal> <volume> 23(4), </volume> <year> 1976. </year>
Reference-contexts: The method has come to be called the "fold-unfold" method and forms an important component in reasoning about functional programs. (Cf. [BW88]). It has also been adapted to reasoning about logic programs, see, for example, <ref> [Dev90, Hog76, TS84] </ref>. Significant effort has been devoted to building automated systems based on the methodology [Dar81, Fea79, Fea82]. Partial evaluation systems, which have been increasingly successful in recent times [ACM91, BEJ88], are also based on the unfold-fold method.
Reference: [HR86] <author> J. Hsiang and M. Rusinowitch. </author> <title> A new method for establishing refutational completeness in theorem proving. </title> <editor> In J. Siekmann, editor, </editor> <booktitle> 8th Intern. Conf. on Automated Deduction, </booktitle> <pages> pages 141-152. </pages> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> (Lect. Notes in Comp. Science). </note>
Reference-contexts: The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations [BDP89, HR87, MN90], conditional equations [BK86, Gan91, Kap87, KR87], and first-order reasoning <ref> [BR91, HD83, HR86, NO91, ZK88] </ref>. See [Der89, DJ90, HO80] for accessible surveys of this rapidly developing area. The contributions of this paper are three fold: First, we enrich the basic equational reasoning techniques used by Burstall and Darlington with additional structure to obtain rewrite-based reasoning.
Reference: [HR87] <author> J. Hsiang and M. Rusinowitch. </author> <title> On word problems in equational theories. </title> <editor> In T. Ottmann, editor, </editor> <booktitle> 14th Intern. Colloq. Automata, Languages and Programming, </booktitle> <pages> pages 54-71. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1987. </year> <note> (Lect. Notes in Comp. Science Vol. 267). 25 </note>
Reference-contexts: Superposition uses two given rewrite rules to deduce a new rewrite rule. The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations <ref> [BDP89, HR87, MN90] </ref>, conditional equations [BK86, Gan91, Kap87, KR87], and first-order reasoning [BR91, HD83, HR86, NO91, ZK88]. See [Der89, DJ90, HO80] for accessible surveys of this rapidly developing area. <p> The conventional term rewriting theory deals with rewrite systems, i.e., sets of equations r ! s which are all oriented in a particular direction. The idea that unoriented equations can also be used for rewriting provided they are used along a reducing direction was proposed in <ref> [BDP89, HR87] </ref>. This form of rewriting is often called ordered rewriting. The results of this paper generalize our previous results [Der82a, Der85, DP90, Red89, Red90b] to the framework of ordered rewriting. The mixing of programs and program synthesis with termination issues needs some explanation.
Reference: [Jan89] <author> Klaus P. </author> <title> Jantke. Algorithmic learning from incomplete information: Principles and problems. </title> <editor> In J. Dassow and J. Kelemen, editors, </editor> <booktitle> Machines, Languages, and Complexity (Selected Contributions of the 5th International Meeting of Young Computer Scientists, </booktitle> <address> Smolenice, Czechoslovakia, </address> <month> November </month> <year> 1988), </year> <pages> pages 188-207, </pages> <year> 1989. </year> <title> Vol. </title> <booktitle> 381 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <address> Berlin. </address>
Reference-contexts: Clearly, we need to substitute the (missing) lemma sx + y = s (x + y) for these instances. We employ the same generalization methods as for synthesis (cf. <ref> [Jan89, Lan89] </ref>). An additional helpful technique is cancellation, as used in deduction, for example, in [Sti84].
Reference: [JK86] <author> J.-P. Jouannaud and E. Kounalis. </author> <title> Automatic proofs by induction in equational theories without constructors. </title> <booktitle> In Symp. on Logic in Comp. Science, </booktitle> <pages> pages 358-366. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: The advantage of this method is that the test set is computed only once and reused in each Cases inference. However, this method still requires all critical pairs to be computed for the cover set. Other methods for testing ground reducibility may found in <ref> [JK86, KZ85, BK89] </ref>. 5 Induction In synthesizing a program from a specification, we must ensure that the derived program verifies the specification. That is, the specification must be an inductive theorem of the derived program. So, inductive reasoning is an integral part of program synthesis. <p> So, inductive reasoning is an integral part of program synthesis. In this section, we briefly outline our inductive reasoning procedure based on term rewriting induction. This method was first presented in [Red90b] and is based on the "induction by completion" method studied in <ref> [Bac88, Der85, Fri86, JK86, KM84, Kuc89, Mus80] </ref>. The latter is also referred to by "inductionless induction" or "proof by consistency".
Reference: [Kap87] <author> S. Kaplan. </author> <title> Simplifying conditional term rewriting systems: Unification, termination and confluence. </title> <journal> J. of Symbolic Computation, </journal> <volume> 4 </volume> <pages> 295-334, </pages> <year> 1987. </year>
Reference-contexts: Superposition uses two given rewrite rules to deduce a new rewrite rule. The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations [BDP89, HR87, MN90], conditional equations <ref> [BK86, Gan91, Kap87, KR87] </ref>, and first-order reasoning [BR91, HD83, HR86, NO91, ZK88]. See [Der89, DJ90, HO80] for accessible surveys of this rapidly developing area.
Reference: [KB70] <author> D. Knuth and P. Bendix. </author> <title> Simple word problems in Universal algebras. </title> <editor> In J. Leech, editor, </editor> <booktitle> Computational Problems in Abstract Algebra, </booktitle> <pages> pages 263-297. </pages> <publisher> Pergamon Press, Oxford, </publisher> <year> 1970. </year>
Reference-contexts: Term rewriting was first used in automated reasoning by Knuth and Bendix <ref> [KB70] </ref> for solving word problems in equational theories. Two fundamental operations underlie the technique: rewriting and superposition. Rewriting uses a terminating rewrite system to rewrite a term to a normal form. Superposition uses two given rewrite rules to deduce a new rewrite rule.
Reference: [KL80] <author> S. Kamin and J.-J. Levy. </author> <title> Two generalizations of the recursive path ordering. Unpublished note, </title> <institution> Department of Computer Science, University of Illinois, Urbana, IL, </institution> <month> Feb </month> <year> 1980. </year>
Reference-contexts: implies t u for all substitutions . (In practice, it suffices to use some simplification ordering on free terms for , provided it has the substitution property and t u implies t &gt; u for all ground substitutions .) Of particular interest in program synthesis is the lexicographic path ordering <ref> [Der82b, KL80] </ref>. Assume a total order on function symbols referred to as a "precedence order".
Reference: [KM84] <author> D. Kapur and D. R. Musser. </author> <title> Proof by consistency. </title> <booktitle> In Proc. of NSF Workshop on the Rewrite Rule Laboratory, </booktitle> <month> Sep 4-6, </month> <year> 1983, </year> <pages> Schenectady, </pages> <month> April </month> <year> 1984. </year> <note> G.E. R&D Center Report GEN 84008. </note>
Reference-contexts: So, inductive reasoning is an integral part of program synthesis. In this section, we briefly outline our inductive reasoning procedure based on term rewriting induction. This method was first presented in [Red90b] and is based on the "induction by completion" method studied in <ref> [Bac88, Der85, Fri86, JK86, KM84, Kuc89, Mus80] </ref>. The latter is also referred to by "inductionless induction" or "proof by consistency".
Reference: [KNZ86] <author> D. Kapur, P. Narendran, and H. Zhang. </author> <title> Proof by induction using test sets. </title> <editor> In J. Siekmann, editor, </editor> <booktitle> 8th Intern. Conf. on Automated Deduction. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year> <note> (Lect. Notes in Comp. Science). </note>
Reference-contexts: Kapur, et al. <ref> [KNZ86] </ref> suggest another optimization. Note that it is enough to restrict attention to irreducible 's in the definition of "ground reducible". Suppose t = u is not ground reducible.
Reference: [KR87] <author> E. Kounalis and M. Rusinowitch. </author> <title> On word problems in Horn theories. </title> <editor> In S. Kaplan and J.-P. Jouannaud, editors, </editor> <booktitle> Conditional Term Rewriting Systems, </booktitle> <pages> pages 144-160. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> (LNCS Vol 308). </note>
Reference-contexts: Superposition uses two given rewrite rules to deduce a new rewrite rule. The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations [BDP89, HR87, MN90], conditional equations <ref> [BK86, Gan91, Kap87, KR87] </ref>, and first-order reasoning [BR91, HD83, HR86, NO91, ZK88]. See [Der89, DJ90, HO80] for accessible surveys of this rapidly developing area.
Reference: [KR90] <author> Emmanuel Kounalis and Michael Rusinowitch. </author> <title> Inductive reasoning in conditional theories. </title> <editor> In M. Okada, editor, </editor> <booktitle> Proceedings of the Second International Workshop on Conditional and Typed Rewriting Systems, </booktitle> <address> Montreal, Canada, </address> <month> June </month> <year> 1990. </year> <note> Lecture Notes in Computer Science, Springer, Berlin; to appear. </note>
Reference-contexts: Conditional rewriting and goal solving may provide a better combination of functional and logic programming than purely equational programs; see, for instance, [DP88]. Conditional synthesis, however, would necessitate more powerful deductive and inductive methods for handling conditional equations, such as have been investigated in <ref> [BR91, KR90, Gan91] </ref>. More elaborate generalization methods would also be required.
Reference: [Kuc89] <author> W. Kuchlin. </author> <title> Inductive completion by ground proof transformation. </title> <editor> In H. At-Kaci and M. Nivat, editors, </editor> <title> Resolution of Equations in Algebraic Structures, </title> <booktitle> volume 2: Rewriting Techniques, </booktitle> <pages> pages 211-245. </pages> <publisher> Academic Press, </publisher> <address> San Diego, </address> <year> 1989. </year>
Reference-contexts: The extraneous critical pairs included in the cover set generate other critical pairs so that the proof procedures based on such cover sets may not terminate. A useful optimization that has been suggested in <ref> [Fri86, Kuc89] </ref> is to consider a subterm s of either t or u that is ground reducible. (A term is ground reducible if every ground instance is reducible.) Then superposition at the subterm s is enough to obtain a cover set. Kapur, et al. [KNZ86] suggest another optimization. <p> So, inductive reasoning is an integral part of program synthesis. In this section, we briefly outline our inductive reasoning procedure based on term rewriting induction. This method was first presented in [Red90b] and is based on the "induction by completion" method studied in <ref> [Bac88, Der85, Fri86, JK86, KM84, Kuc89, Mus80] </ref>. The latter is also referred to by "inductionless induction" or "proof by consistency".
Reference: [KZ85] <author> E. Kounalis and H. Zhang. </author> <title> A general completeness test for equational specifications. </title> <type> Unpublished report, </type> <institution> Centre de Recherche en Informatique de Nancy, </institution> <address> Nancy, France, </address> <year> 1985. </year>
Reference-contexts: The advantage of this method is that the test set is computed only once and reused in each Cases inference. However, this method still requires all critical pairs to be computed for the cover set. Other methods for testing ground reducibility may found in <ref> [JK86, KZ85, BK89] </ref>. 5 Induction In synthesizing a program from a specification, we must ensure that the derived program verifies the specification. That is, the specification must be an inductive theorem of the derived program. So, inductive reasoning is an integral part of program synthesis.
Reference: [Lan89] <author> Steffen Lange. </author> <title> Towards a set of inference rules for solving divergence in Knuth-Bendix completion. </title> <editor> In K. P. Jantke, editor, </editor> <booktitle> Proceedings of the International Workshop on Analogical and Inductive Inference, </booktitle> <pages> pages 304-316, </pages> <month> October </month> <year> 1989. </year> <title> Vol. </title> <booktitle> 397 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <address> Berlin. </address> <month> 26 </month>
Reference-contexts: Clearly, we need to substitute the (missing) lemma sx + y = s (x + y) for these instances. We employ the same generalization methods as for synthesis (cf. <ref> [Jan89, Lan89] </ref>). An additional helpful technique is cancellation, as used in deduction, for example, in [Sti84].
Reference: [Man74] <author> Z Manna. </author> <title> Mathematical Theory of Computation. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1974. </year>
Reference-contexts: The proof method itself takes care of the condition. Such implicit application of induction may also be found in a variety of program verification methods such as Hoare logic (especially, the treatment of recursion [Hoa71]) and fixed point induction <ref> [Man74, Sco76] </ref>. We make these ideas precise by the following inference procedure.
Reference: [MN90] <author> Ursula Martin and Tobias Nipkow. </author> <title> Ordered completion. </title> <editor> In M. Stickel, editor, </editor> <booktitle> Proceedings of the Tenth International Conference on Automated Deduction, </booktitle> <pages> pages 366-380, </pages> <address> Kaiserslautern, West Germany, </address> <month> July </month> <year> 1990. </year> <title> Vol. </title> <booktitle> 449 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <address> Berlin. </address>
Reference-contexts: Superposition uses two given rewrite rules to deduce a new rewrite rule. The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations <ref> [BDP89, HR87, MN90] </ref>, conditional equations [BK86, Gan91, Kap87, KR87], and first-order reasoning [BR91, HD83, HR86, NO91, ZK88]. See [Der89, DJ90, HO80] for accessible surveys of this rapidly developing area. <p> This process, together with 9 simplification of the resulting equations, is called (ordered) completion. Since proofs of the above form are the only obstacles to confluence, the result of completion is a ground confluent system that defines unique normal forms for all ground terms. See <ref> [BDP89, MN90] </ref> for a discussion of completion. In applying equational reasoning to program verification and synthesis, we have a fixed equational program. The equation l = r used in the superposition inference belongs to the fixed program, and need not be treated as a premise of the ifnerence.
Reference: [Mus80] <author> D. R. Musser. </author> <title> On proving inductive properties of abstract data types. </title> <booktitle> In ACM Symp. on Princ. of Program. Lang., </booktitle> <pages> pages 154-162. </pages> <publisher> ACM, </publisher> <year> 1980. </year>
Reference-contexts: So, inductive reasoning is an integral part of program synthesis. In this section, we briefly outline our inductive reasoning procedure based on term rewriting induction. This method was first presented in [Red90b] and is based on the "induction by completion" method studied in <ref> [Bac88, Der85, Fri86, JK86, KM84, Kuc89, Mus80] </ref>. The latter is also referred to by "inductionless induction" or "proof by consistency".
Reference: [MW80] <author> Z. Manna and R. Waldinger. </author> <title> A deductive approach to program synthesis. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 2(1) </volume> <pages> 90-121, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: 1 * How does the method generalize to forms of programs (and logics) other than equational ones? (For instance, conditional equations, Horn clauses or first-order clauses.) * What role does (mathematical) induction play in the synthesis process? * How does the method relate to other techniques of deductive synthesis, like <ref> [BH84, MW80, Smi90] </ref>? In attempting to answer such questions, we are led to the framework of term rewriting, which is the best known technique of controlled equational reasoning. Term rewriting was first used in automated reasoning by Knuth and Bendix [KB70] for solving word problems in equational theories.
Reference: [NO91] <author> R. Nieuwenhuis and F. Orejas. </author> <title> Clausal rewriting. </title> <editor> In S. Kaplan and M. Okada, editors, </editor> <booktitle> Conditional and Typed Rewriting Systems | Second International CTRS Workshop. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations [BDP89, HR87, MN90], conditional equations [BK86, Gan91, Kap87, KR87], and first-order reasoning <ref> [BR91, HD83, HR86, NO91, ZK88] </ref>. See [Der89, DJ90, HO80] for accessible surveys of this rapidly developing area. The contributions of this paper are three fold: First, we enrich the basic equational reasoning techniques used by Burstall and Darlington with additional structure to obtain rewrite-based reasoning.
Reference: [Pla85] <author> D. Plaisted. </author> <title> Semantic confluence tests and completion methods. </title> <journal> Inf. Control, </journal> <volume> 65 </volume> <pages> 182-215, </pages> <year> 1985. </year>
Reference-contexts: Several methods are possible. First, a a set of terms called test set may be computed such that every irreducible ground term is an instance of some member of the test set <ref> [Pla85] </ref>. To check if a given set of critical pairs is a cover set, it is enough to see if each combination of terms from the test set is covered in the overlap substitutions. For instance, for the three-rule append system, fnil; A U g is a test set.
Reference: [Plo70] <author> Gordon Plotkin. </author> <title> Lattice theoretic properties of subsumption. </title> <type> Technical Report MIP-R 77, </type> <institution> University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <year> 1970. </year>
Reference-contexts: From dss0 = ssss0 dsss0 = ssssss0 . . . dsss0 = ssdss0 . . . For the second step, we generate most specific generalizations of pairs of equations, by replacing conflicting subterms with a new variable (see <ref> [Plo70] </ref>). This process has been called "anti-unification"; given two terms s and t, it computes their greatest lower bound (glb) in the subsumption lattice. The above two critical pairs generate the hypothesis dsx = ssdx.
Reference: [Red88] <author> U. S. Reddy. </author> <title> Transformational derivation of programs using the Focus system. </title> <booktitle> SIGSOFT Software Engineering Notes, </booktitle> <volume> 13(5) </volume> <pages> 163-172, </pages> <month> Nov </month> <year> 1988. </year> <title> (Proceedings, </title> <journal> ACM SIG-SOFT/SIGPLAN Softw. Eng. Symp. on Practical Software Development Environments, </journal> <note> Also published as SIGPLAN Notices, </note> <month> Feb. </month> <year> 1989). </year>
Reference-contexts: The system incorporates oriented rewrite techniques (a special case of the ordered rewriting techniques considered here) and also several extensions to conditional and first-order reasoning. It has been used to synthesize several interesting examples including some reasonably large programs <ref> [Red88, Red90a, Red91] </ref>. In this paper, we have considered rewriting with equations. Conditional rewriting and goal solving may provide a better combination of functional and logic programming than purely equational programs; see, for instance, [DP88].
Reference: [Red89] <author> U. S. Reddy. </author> <title> Rewriting techniques for program synthesis. </title> <editor> In N. Dershowitz, editor, </editor> <booktitle> Rewriting Techniques and Applications, </booktitle> <pages> pages 388-403. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <note> (LNCS Vol. 355). </note>
Reference-contexts: Second, we propose (mathematical) induction techniques to define and ensure the correctness of synthesized programs. Third, we demonstrate how inductive generalization techniques supplement the basic deductive techniques to achieve an automated program synthesis system. This paper consolidates and extends our previous work reported in <ref> [Der82a, DP90, Red89, Red90b] </ref>. In the cited work, we treat rewrite systems, and, here, generalize the techniques to unoriented equations using the notion of "ordered rewriting". <p> The idea that unoriented equations can also be used for rewriting provided they are used along a reducing direction was proposed in [BDP89, HR87]. This form of rewriting is often called ordered rewriting. The results of this paper generalize our previous results <ref> [Der82a, Der85, DP90, Red89, Red90b] </ref> to the framework of ordered rewriting. The mixing of programs and program synthesis with termination issues needs some explanation. Requiring that the rewrite relation be always included in a well-founded order has two consequences. First, it ensures that programs terminate along all evaluation paths. <p> The second is to compute two functions at once, or one function for two arguments, when expanding (unfolding) the definition of one leads to multiple applications of the same function (cf. <ref> [Red89, Bel91b] </ref>).
Reference: [Red90a] <author> U. S. Reddy. </author> <title> Formal methods in transformational derivation of programs. </title> <journal> Software Engineering Notices, </journal> <volume> 15(4) </volume> <pages> 104-114, </pages> <month> Sep </month> <year> 1990. </year> <booktitle> (Proceedings of the ACM SIGSOFT Workshop on Formal Methods in Software Development). </booktitle>
Reference-contexts: The system incorporates oriented rewrite techniques (a special case of the ordered rewriting techniques considered here) and also several extensions to conditional and first-order reasoning. It has been used to synthesize several interesting examples including some reasonably large programs <ref> [Red88, Red90a, Red91] </ref>. In this paper, we have considered rewriting with equations. Conditional rewriting and goal solving may provide a better combination of functional and logic programming than purely equational programs; see, for instance, [DP88].
Reference: [Red90b] <author> U. S. Reddy. </author> <title> Term rewriting induction. </title> <editor> In M. Stickel, editor, </editor> <booktitle> 10th Intern. Conf. on Automated Deduction, </booktitle> <pages> pages 162-177. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <booktitle> (Lecture Notes in Artificial Intelligence, </booktitle> <volume> Vol. </volume> <pages> 449). </pages>
Reference-contexts: Second, we propose (mathematical) induction techniques to define and ensure the correctness of synthesized programs. Third, we demonstrate how inductive generalization techniques supplement the basic deductive techniques to achieve an automated program synthesis system. This paper consolidates and extends our previous work reported in <ref> [Der82a, DP90, Red89, Red90b] </ref>. In the cited work, we treat rewrite systems, and, here, generalize the techniques to unoriented equations using the notion of "ordered rewriting". <p> The idea that unoriented equations can also be used for rewriting provided they are used along a reducing direction was proposed in [BDP89, HR87]. This form of rewriting is often called ordered rewriting. The results of this paper generalize our previous results <ref> [Der82a, Der85, DP90, Red89, Red90b] </ref> to the framework of ordered rewriting. The mixing of programs and program synthesis with termination issues needs some explanation. Requiring that the rewrite relation be always included in a well-founded order has two consequences. First, it ensures that programs terminate along all evaluation paths. <p> That is, the specification must be an inductive theorem of the derived program. So, inductive reasoning is an integral part of program synthesis. In this section, we briefly outline our inductive reasoning procedure based on term rewriting induction. This method was first presented in <ref> [Red90b] </ref> and is based on the "induction by completion" method studied in [Bac88, Der85, Fri86, JK86, KM84, Kuc89, Mus80]. The latter is also referred to by "inductionless induction" or "proof by consistency".
Reference: [Red91] <author> U. S. Reddy. </author> <title> Design principles for an interactive program derivation system. </title> <editor> In M. Lowry and R. D. McCartney, editors, </editor> <booktitle> Automating Software Design, chapter 18. </booktitle> <publisher> AAAI Press, </publisher> <year> 1991. </year>
Reference-contexts: The system incorporates oriented rewrite techniques (a special case of the ordered rewriting techniques considered here) and also several extensions to conditional and first-order reasoning. It has been used to synthesize several interesting examples including some reasonably large programs <ref> [Red88, Red90a, Red91] </ref>. In this paper, we have considered rewriting with equations. Conditional rewriting and goal solving may provide a better combination of functional and logic programming than purely equational programs; see, for instance, [DP88].
Reference: [RW69] <author> G. Robinson and L. Wos. </author> <title> Paramodulation and theorem-proving in first order theories with equality. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence 4, </booktitle> <pages> pages 135-150. </pages> <publisher> Edinburgh University Press, Edinburgh, </publisher> <address> Scotland, </address> <year> 1969. </year>
Reference-contexts: We should choose instantiations which make further simplifications possible. For example, in the synthesis of rev , we chose instantiations which enable simplification by the axioms (1) and (3). In this section, we define formal methods for such instantiation. The conventional inference rule for equational reasoning is paramodulation <ref> [RW69] </ref>: PM t [r] = u where mgu denotes the most general unifier. Thus, unification of the subterm s with l suggests how the variables in s should be instantiated so as to apply the equation l = r.
Reference: [Sco76] <author> D. Scott. </author> <title> Data types as lattices. </title> <journal> SIAM Journal on Computing, </journal> <volume> 5(3) </volume> <pages> 522-587, </pages> <month> Sept. </month> <year> 1976. </year> <month> 27 </month>
Reference-contexts: The proof method itself takes care of the condition. Such implicit application of induction may also be found in a variety of program verification methods such as Hoare logic (especially, the treatment of recursion [Hoa71]) and fixed point induction <ref> [Man74, Sco76] </ref>. We make these ideas precise by the following inference procedure.
Reference: [Smi90] <author> D. Smith. </author> <title> KIDS A knowledge-based software development system. </title> <editor> In M. Lowry and R. D. McCartney, editors, </editor> <title> Automating Software Design. </title> <publisher> AAAI Press, </publisher> <year> 1990. </year>
Reference-contexts: 1 * How does the method generalize to forms of programs (and logics) other than equational ones? (For instance, conditional equations, Horn clauses or first-order clauses.) * What role does (mathematical) induction play in the synthesis process? * How does the method relate to other techniques of deductive synthesis, like <ref> [BH84, MW80, Smi90] </ref>? In attempting to answer such questions, we are led to the framework of term rewriting, which is the best known technique of controlled equational reasoning. Term rewriting was first used in automated reasoning by Knuth and Bendix [KB70] for solving word problems in equational theories.
Reference: [Sti84] <author> Mark E. Stickel. </author> <title> A case study of theorem proving by the Knuth Bendix method discovering that x 3 = x implies ring commutativity. </title> <editor> In R. E. Shostak, editor, </editor> <booktitle> Proceedings of the Seventh International Conference on Automated Deduction, </booktitle> <pages> pages 248-259, </pages> <address> Napa, CA, </address> <month> May </month> <year> 1984. </year> <title> Vol. </title> <booktitle> 170 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer, </publisher> <address> Berlin. </address>
Reference-contexts: Clearly, we need to substitute the (missing) lemma sx + y = s (x + y) for these instances. We employ the same generalization methods as for synthesis (cf. [Jan89, Lan89]). An additional helpful technique is cancellation, as used in deduction, for example, in <ref> [Sti84] </ref>.
Reference: [TS84] <author> H. Tamaki and T. Sato. </author> <title> Unfold/fold transformation of logic programs. </title> <booktitle> In Intern. Conf. on Logic Programming, </booktitle> <pages> pages 127-138, </pages> <year> 1984. </year>
Reference-contexts: The method has come to be called the "fold-unfold" method and forms an important component in reasoning about functional programs. (Cf. [BW88]). It has also been adapted to reasoning about logic programs, see, for example, <ref> [Dev90, Hog76, TS84] </ref>. Significant effort has been devoted to building automated systems based on the methodology [Dar81, Fea79, Fea82]. Partial evaluation systems, which have been increasingly successful in recent times [ACM91, BEJ88], are also based on the unfold-fold method.
Reference: [ZK88] <author> H. Zhang and D. Kapur. </author> <title> First-order theorem proving using conditional rewrite rules. </title> <editor> In E. Lusk and R. Overbeek, editors, </editor> <booktitle> 9th Intern. Conf. on Automated Deduction, </booktitle> <pages> pages 1-20. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year> <month> 28 </month>
Reference-contexts: The combination of the two techniques achieves an extremely high performance in equational reasoning. In recent work, term rewriting techniques have been extended to deal with unoriented equations [BDP89, HR87, MN90], conditional equations [BK86, Gan91, Kap87, KR87], and first-order reasoning <ref> [BR91, HD83, HR86, NO91, ZK88] </ref>. See [Der89, DJ90, HO80] for accessible surveys of this rapidly developing area. The contributions of this paper are three fold: First, we enrich the basic equational reasoning techniques used by Burstall and Darlington with additional structure to obtain rewrite-based reasoning.
References-found: 66

