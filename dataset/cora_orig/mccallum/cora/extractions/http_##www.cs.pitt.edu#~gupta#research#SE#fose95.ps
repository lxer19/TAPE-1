URL: http://www.cs.pitt.edu/~gupta/research/SE/fose95.ps
Refering-URL: http://www.cs.pitt.edu/~gupta/research/testing.html
Root-URL: 
Email: fgupta,soffag@cs.pitt.edu  
Title: Hybrid Slicing: An Approach for Refining Static Slices Using Dynamic Information  
Author: Rajiv Gupta and Mary Lou Soffa 
Address: Pittsburgh Pittsburgh, PA 15260  
Affiliation: Dept. of Computer Science University of  
Abstract: Program slicing is an effective technique for narrowing the focus of attention to the relevant parts of a program during the debugging process. However, imprecision is a problem in static slices since they are based on all executions that reach a given program point rather than the specific execution under which the program is being debugged. Dynamic slices are precise but require a large amount of run time overhead due to the tracing information that is collected during the program's execution. We present a general approach for improving the precision and quality of static slices by incorporating dynamic information in static slicing, enabling the computation of hybrid slices. The technique exploits dynamic information that is readily available during debugging, namely breakpoint information and the dynamic call graph. The precision of static slicing is improved in hybrid slicing by more accurately estimating the potential paths taken by the program. The breakpoints and call/return points, used as reference points, divide the execution path into intervals. By associating each statement in the slice with an execution interval, hybrid slicing technique also improves the quality of slicing information. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Agrawal, </author> <title> "On Slicing Programs with Jump Statements," </title> <booktitle> Proc. SIGPLAN Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 302-312, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Static slicing algorithms determine the fl Supported in part by the National Science Foundation Presidential Young Investigator Award CCR-9157371 and Grant CCR-9109089 to the University of Pittsburgh. set of program statements that may affect the computation of the value of a variable at a specified program point <ref> [4, 1, 19, 15, 10] </ref>. However, since static slices are computed under all possible executions of the program that reach a specified point, the generated slices are large and imprecise (for a particular execution), which limits their usefulness in practice.
Reference: [2] <author> H. Agrawal and B. Horgan, </author> <title> "Dynamic Program Slicing," </title> <booktitle> Proc. SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 246-256, </pages> <year> 1990. </year>
Reference-contexts: Therefore techniques that improve the precision and reduce the size of the slice are of significant interest. One approach for improving the precision of slices is to employ dynamic slicing <ref> [2, 13, 7] </ref>. Dynamic slices are constructed for a single program execution in contrast to static slices which are constructed for all possible executions of the program. However, the construction of a dynamic slice is expensive since it requires tracing of the program's execution.
Reference: [3] <author> A. Aho, R. Sethi, and J. Ullman, </author> <title> Compiler Principles, Techniques, and Tools, </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference: [4] <author> J-D. Choi and J. Ferrante, </author> <title> "Static Slicing in the Presence of Goto Statements," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 16, No. 4, </volume> <pages> pages 1097-1113, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: Static slicing algorithms determine the fl Supported in part by the National Science Foundation Presidential Young Investigator Award CCR-9157371 and Grant CCR-9109089 to the University of Pittsburgh. set of program statements that may affect the computation of the value of a variable at a specified program point <ref> [4, 1, 19, 15, 10] </ref>. However, since static slices are computed under all possible executions of the program that reach a specified point, the generated slices are large and imprecise (for a particular execution), which limits their usefulness in practice.
Reference: [5] <author> J-D. Choi, B. Miller, and R. Netzer, </author> <title> "Techniques for Debugging Parallel Programs with Flow-back Analysis," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, </volume> <editor> N. </editor> <volume> 4, </volume> <pages> pages 491-530, </pages> <year> 1991. </year>
Reference-contexts: Therefore we would like to develop techniques that construct accurate slices without utilizing expensive tracing techniques. An approach to improve the efficiency of dynamic slicing focuses on the use of static information to reduce the run-time overhead by limiting the amount of tracing that is needed during execution <ref> [14, 5, 7, 16] </ref>. Static information is used to determine a subset of program points that should be traced. Although this approach does reduce the tracing effort, the size of traces can still be quite large, since the program state must be saved at the selected points.
Reference: [6] <author> K. Cooper, </author> <title> "Analyzing Aliases of Reference Formal Parameters," </title> <booktitle> Proc. of the 12th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 281-290, </pages> <year> 1985. </year>
Reference-contexts: The algorithms continue in this manner, finally finding the subslices given in Figure 7. The hybrid interprocedural algorithm can be ex tended to include aliases caused by reference parameters. The computation of the alias sets is performed before slicing begins <ref> [6] </ref>. The alias sets for a procedure are placed on the program nodes for that procedure. As a variable name is propagated in search of its definition, we include in the slice any definition of an alias as well as any definition of the variable itself.
Reference: [7] <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa, "Distributed Slicing and Partial Re-execution for Distributed Programs," </title> <booktitle> Fifth Workshop on Languages and Compilers for Parallel Computing, </booktitle> <publisher> LNCS 757 Springer Verlag, </publisher> <pages> pages 497-511, </pages> <institution> Yale University, </institution> <address> New Haven, Connecticut, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Therefore techniques that improve the precision and reduce the size of the slice are of significant interest. One approach for improving the precision of slices is to employ dynamic slicing <ref> [2, 13, 7] </ref>. Dynamic slices are constructed for a single program execution in contrast to static slices which are constructed for all possible executions of the program. However, the construction of a dynamic slice is expensive since it requires tracing of the program's execution. <p> Therefore we would like to develop techniques that construct accurate slices without utilizing expensive tracing techniques. An approach to improve the efficiency of dynamic slicing focuses on the use of static information to reduce the run-time overhead by limiting the amount of tracing that is needed during execution <ref> [14, 5, 7, 16] </ref>. Static information is used to determine a subset of program points that should be traced. Although this approach does reduce the tracing effort, the size of traces can still be quite large, since the program state must be saved at the selected points.
Reference: [8] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren, </author> <title> "The Program Dependence Graph and its use in Optimization," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 9, No. 3, </volume> <pages> pages 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Our technique uses the control flow graph as the program representation. Another representation that has been used in slicing is the program dependence graph <ref> [12, 8] </ref>. The program dependence graph is not directly applicable to the hybrid slicing technique for it represents control dependence and not control flow.
Reference: [9] <author> J. Field, G. Ramalingam, and F. </author> <title> Tip, "Parametric Program Slicing," </title> <booktitle> Proc. ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 379-392, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: The notion of a constrained/quasi-static slice is another approach to reduce the size of static slices [18]. An algorithm for computing constrained slices appears in <ref> [9] </ref>. Constraints on input values are provided and, using this information, a static slice is produced that excludes program executions requiring inputs that do not satisfy the given constraints. In contrast, hybrid slicing exploits dynamic information for improving the precision and quality of slicing information during debugging.
Reference: [10] <author> R. Gupta and M.L. Soffa, </author> <title> "A Framework for Partial Data Flow Analysis," </title> <booktitle> International Conference on Software Maintenance, </booktitle> <address> Victoria, British Columbia, </address> <pages> pages 4-13, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Static slicing algorithms determine the fl Supported in part by the National Science Foundation Presidential Young Investigator Award CCR-9157371 and Grant CCR-9109089 to the University of Pittsburgh. set of program statements that may affect the computation of the value of a variable at a specified program point <ref> [4, 1, 19, 15, 10] </ref>. However, since static slices are computed under all possible executions of the program that reach a specified point, the generated slices are large and imprecise (for a particular execution), which limits their usefulness in practice.
Reference: [11] <author> R. Gupta and M.L. Soffa, </author> <title> "Hybrid Slicing: An Approach for Refining Static Slices Using Dynamic Information," </title> <type> Technical Report TR-95-30, </type> <institution> University of Pittsburgh, Pittsburgh, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: However, in the hybrid interprocedural slicing algorithms, the points of interest are procedure call, entry and exit points where propagation starts or terminates. In the remainder of the section we provide a brief overview of the algorithms. More detailed algorithms can be found in <ref> [11] </ref>. The algorithm, ComputeInterTentativeSlice propagates variables and call/return history points backwards until either an entry of the current procedure P is reached, a call to a procedure is reached, or an assignment to a variable being sliced is encountered.
Reference: [12] <author> S. Horwitz, T. Reps, and D. Binkley, </author> <title> "Interpro-cedural Slicing using Dependence Graphs," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 12, No. 1, </volume> <pages> pages 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Our technique uses the control flow graph as the program representation. Another representation that has been used in slicing is the program dependence graph <ref> [12, 8] </ref>. The program dependence graph is not directly applicable to the hybrid slicing technique for it represents control dependence and not control flow. <p> If static slices are obtained using Weiser's interproce-dural slicing technique [19], which does not take into account the calling contexts of the calls, the following slice is computed: f2; 3; 6; 11; 12; 15; 16; 20; 27; 30g. If a static slice is computed using the calling context <ref> [12, 14] </ref>, more precise information can be found. Using the calling context, only the call site related to the call is processed. Thus, statement 6 would not be included as part of the slice, as P 2 in statement 7 is not a possible call site.
Reference: [13] <author> B. Korel and J. Laski, </author> <title> "Dynamic Program Slicing," </title> <journal> Information Processing Letters, </journal> <volume> Vol. 29, </volume> <pages> pages 155-163, </pages> <month> Oct. </month> <year> 1988. </year>
Reference-contexts: Therefore techniques that improve the precision and reduce the size of the slice are of significant interest. One approach for improving the precision of slices is to employ dynamic slicing <ref> [2, 13, 7] </ref>. Dynamic slices are constructed for a single program execution in contrast to static slices which are constructed for all possible executions of the program. However, the construction of a dynamic slice is expensive since it requires tracing of the program's execution.
Reference: [14] <author> M. Kamkar, O. Fritzson, and N. Shahmehri, </author> <title> "Three Approaches to Interprocedural Dynamic Slicing," </title> <booktitle> Microprocessing and Microprogramming 38, </booktitle> <pages> pages 625-636, </pages> <year> 1993. </year>
Reference-contexts: Therefore we would like to develop techniques that construct accurate slices without utilizing expensive tracing techniques. An approach to improve the efficiency of dynamic slicing focuses on the use of static information to reduce the run-time overhead by limiting the amount of tracing that is needed during execution <ref> [14, 5, 7, 16] </ref>. Static information is used to determine a subset of program points that should be traced. Although this approach does reduce the tracing effort, the size of traces can still be quite large, since the program state must be saved at the selected points. <p> If static slices are obtained using Weiser's interproce-dural slicing technique [19], which does not take into account the calling contexts of the calls, the following slice is computed: f2; 3; 6; 11; 12; 15; 16; 20; 27; 30g. If a static slice is computed using the calling context <ref> [12, 14] </ref>, more precise information can be found. Using the calling context, only the call site related to the call is processed. Thus, statement 6 would not be included as part of the slice, as P 2 in statement 7 is not a possible call site.
Reference: [15] <author> J.R. Lyle and M. Weiser, </author> <title> "Automatic Program Bug Location by Program Slicing," </title> <booktitle> Proc. Second IEEE Symposium on Computers and Applications, </booktitle> <pages> pages 877-883, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Static slicing algorithms determine the fl Supported in part by the National Science Foundation Presidential Young Investigator Award CCR-9157371 and Grant CCR-9109089 to the University of Pittsburgh. set of program statements that may affect the computation of the value of a variable at a specified program point <ref> [4, 1, 19, 15, 10] </ref>. However, since static slices are computed under all possible executions of the program that reach a specified point, the generated slices are large and imprecise (for a particular execution), which limits their usefulness in practice.
Reference: [16] <author> R. Netzer and M. Weaver, </author> <title> "Optimal Tracing and Incremental Reexecution for Debugging Long-Running Programs," </title> <booktitle> Proc. SIGPLAN Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 313-325, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Therefore we would like to develop techniques that construct accurate slices without utilizing expensive tracing techniques. An approach to improve the efficiency of dynamic slicing focuses on the use of static information to reduce the run-time overhead by limiting the amount of tracing that is needed during execution <ref> [14, 5, 7, 16] </ref>. Static information is used to determine a subset of program points that should be traced. Although this approach does reduce the tracing effort, the size of traces can still be quite large, since the program state must be saved at the selected points.
Reference: [17] <author> J. Ning, A. Engberts, and W. Kozaczynski, </author> <title> "Automated Support for Legacy Code Understanding," </title> <journal> Communications of the ACM, </journal> <volume> Vol. 37, No. 3, </volume> <pages> pages 50-57, </pages> <year> 1994. </year>
Reference-contexts: In contrast, hybrid slicing exploits dynamic information for improving the precision and quality of slicing information during debugging. The usefulness of constrained slicing for understanding legacy codes has been demonstrated in <ref> [17] </ref>. While constrained slicing is useful for program understanding, hybrid slicing is more appropriate for program debugging. In section 2 of this paper, we describe the hybrid slicing technique for a single module that uses breakpoint information. In section 3 we describe interpro-cedural slicing that uses call/return information.
Reference: [18] <author> A. Venkatesh and C.N. Fischer, "SPARE: </author> <title> A Development Environment for Program Analysis Algorithms," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 18, No. 4, </volume> <month> April </month> <year> 1992. </year>
Reference-contexts: In order to utilize breakpointing information during PDG slicing, a mapping would have to be provided between various points in the control flow graph and the program dependence graph. The notion of a constrained/quasi-static slice is another approach to reduce the size of static slices <ref> [18] </ref>. An algorithm for computing constrained slices appears in [9]. Constraints on input values are provided and, using this information, a static slice is produced that excludes program executions requiring inputs that do not satisfy the given constraints.
Reference: [19] <author> M. Weiser, </author> <title> "Program Slicing," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-10, No. 4, </volume> <pages> pages 352-357, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Static slicing algorithms determine the fl Supported in part by the National Science Foundation Presidential Young Investigator Award CCR-9157371 and Grant CCR-9109089 to the University of Pittsburgh. set of program statements that may affect the computation of the value of a variable at a specified program point <ref> [4, 1, 19, 15, 10] </ref>. However, since static slices are computed under all possible executions of the program that reach a specified point, the generated slices are large and imprecise (for a particular execution), which limits their usefulness in practice. <p> Consider the example program given in Figure 7, which consists of a main program and four procedures. Assume the call/return history and the slicing criteria of variable d at statement 28 as given in Figure 7. If static slices are obtained using Weiser's interproce-dural slicing technique <ref> [19] </ref>, which does not take into account the calling contexts of the calls, the following slice is computed: f2; 3; 6; 11; 12; 15; 16; 20; 27; 30g. If a static slice is computed using the calling context [12, 14], more precise information can be found.
References-found: 19

