URL: http://www.cs.purdue.edu/coast/archive/clife/thesis/phd/palmer-phd.ps.gz
Refering-URL: http://www.cs.purdue.edu/coast/archive/clife/thesis/phd/
Root-URL: http://www.cs.purdue.edu
Title: AN APPROACH TO A PROBLEM IN NETWORK DESIGN USING GENETIC ALGORITHMS  
Author: by Charles Campbell Palmer 
Degree: DISSERTATION Submitted in Partial Fulfillment of the Requirements for the Degree of DOCTOR OF PHILOSOPHY (Computer Science) at the  Approved: Department Head  
Note: Date Copy No.  
Date: April 1994  
Affiliation: POLYTECHNIC UNIVERSITY  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> E. Aarts and J. Korst. </author> <title> Simulated annealing and boltzmann machines. </title> <publisher> Wiley and Sons, </publisher> <year> 1989. </year>
Reference-contexts: This technique subtracts a constant times the standard deviation of the population fitness values from the raw fitness values as follows f itness scaled = f itness raw (f itness average c) where c is a constant usually in the range <ref> [1; 5] </ref>. <p> Unfortunately, this encoding proved only productive for small numbers of nodes. Using several sets of genetic algorithm control parameters, experiments using this CHAPTER 4. REPRESENTING TREES IN GENETIC ALGORITHMS 65 i = 1; j = P [i] = 2; k = 2 since X [2] = j; S2 <ref> [1] </ref> = i + k = 3 Exchange X [2] and X [5]: X = 15342 i = 2; j = P [i] = 1; k = 1 since X [1] = j; S2 [2] = i + k = 3 Exchange X [1] and X [4]: X = 45312 i <p> ALGORITHMS 65 i = 1; j = P [i] = 2; k = 2 since X [2] = j; S2 <ref> [1] </ref> = i + k = 3 Exchange X [2] and X [5]: X = 15342 i = 2; j = P [i] = 1; k = 1 since X [1] = j; S2 [2] = i + k = 3 Exchange X [1] and X [4]: X = 45312 i = 3; j = P [i] = 5; k = 2 since X [2] = j; S2 [3] = i + k = 5 Exchange X [2] and X [3]: <p> 2 since X [2] = j; S2 <ref> [1] </ref> = i + k = 3 Exchange X [2] and X [5]: X = 15342 i = 2; j = P [i] = 1; k = 1 since X [1] = j; S2 [2] = i + k = 3 Exchange X [1] and X [4]: X = 45312 i = 3; j = P [i] = 5; k = 2 since X [2] = j; S2 [3] = i + k = 5 Exchange X [2] and X [3]: X = 43512 i = 4; j = P [i] = 4; k <p> = 45312 i = 3; j = P [i] = 5; k = 2 since X [2] = j; S2 [3] = i + k = 5 Exchange X [2] and X [3]: X = 43512 i = 4; j = P [i] = 4; k = 1 since X <ref> [1] </ref> = j; S2 [3] = i + k = 5 Exchange X [1] and X [2]: X = 34512 i = 5; j = P [i] = 3; k = 1 since X [1] = j; S2 [3] = i + k = 6 Exchange X [1] and X [1]: <p> 2 since X [2] = j; S2 [3] = i + k = 5 Exchange X [2] and X [3]: X = 43512 i = 4; j = P [i] = 4; k = 1 since X <ref> [1] </ref> = j; S2 [3] = i + k = 5 Exchange X [1] and X [2]: X = 34512 i = 5; j = P [i] = 3; k = 1 since X [1] = j; S2 [3] = i + k = 6 Exchange X [1] and X [1]: X = 34512 technique 6 12 24 47 98 GA 1,386,360 7,035,895 45,712,100 <p> = 43512 i = 4; j = P [i] = 4; k = 1 since X <ref> [1] </ref> = j; S2 [3] = i + k = 5 Exchange X [1] and X [2]: X = 34512 i = 5; j = P [i] = 3; k = 1 since X [1] = j; S2 [3] = i + k = 6 Exchange X [1] and X [1]: X = 34512 technique 6 12 24 47 98 GA 1,386,360 7,035,895 45,712,100 192,500,000 1,800,810,000 Heuristic 1,386,360 7,134,530 37,952,000 158,612,156 780,999,474 Table 4.3: Comparison of "right hand rule" GA and Heuristic results encoding scheme <p> 1 since X <ref> [1] </ref> = j; S2 [3] = i + k = 5 Exchange X [1] and X [2]: X = 34512 i = 5; j = P [i] = 3; k = 1 since X [1] = j; S2 [3] = i + k = 6 Exchange X [1] and X [1]: X = 34512 technique 6 12 24 47 98 GA 1,386,360 7,035,895 45,712,100 192,500,000 1,800,810,000 Heuristic 1,386,360 7,134,530 37,952,000 158,612,156 780,999,474 Table 4.3: Comparison of "right hand rule" GA and Heuristic results encoding scheme produced results that did not compare well to those provided by a simple <p> <ref> [1] </ref> = j; S2 [3] = i + k = 5 Exchange X [1] and X [2]: X = 34512 i = 5; j = P [i] = 3; k = 1 since X [1] = j; S2 [3] = i + k = 6 Exchange X [1] and X [1]: X = 34512 technique 6 12 24 47 98 GA 1,386,360 7,035,895 45,712,100 192,500,000 1,800,810,000 Heuristic 1,386,360 7,134,530 37,952,000 158,612,156 780,999,474 Table 4.3: Comparison of "right hand rule" GA and Heuristic results encoding scheme produced results that did not compare well to those provided by a simple heuristic 4 . <p> In this case, the neighborhood structure used by the simulated annealing was defined as any two spanning tree topologies which have all the branches except one in common. The cooling schedule chosen was similar to one described in <ref> [1] </ref>. The overall complexity of the simulated annealing process was reported as O (n 5 ).
Reference: [2] <author> R. Cahn, P. Kermani, A. Kershenbaum, and D. Milch. </author> <title> A library of network benchmarks. Unpublished report, Network Design Tools Group, </title> <institution> IBM T. J. Wat-son Research Center, </institution> <year> 1990. </year>
Reference-contexts: Unfortunately, this encoding proved only productive for small numbers of nodes. Using several sets of genetic algorithm control parameters, experiments using this CHAPTER 4. REPRESENTING TREES IN GENETIC ALGORITHMS 65 i = 1; j = P [i] = 2; k = 2 since X <ref> [2] </ref> = j; S2 [1] = i + k = 3 Exchange X [2] and X [5]: X = 15342 i = 2; j = P [i] = 1; k = 1 since X [1] = j; S2 [2] = i + k = 3 Exchange X [1] and X [4]: <p> Using several sets of genetic algorithm control parameters, experiments using this CHAPTER 4. REPRESENTING TREES IN GENETIC ALGORITHMS 65 i = 1; j = P [i] = 2; k = 2 since X <ref> [2] </ref> = j; S2 [1] = i + k = 3 Exchange X [2] and X [5]: X = 15342 i = 2; j = P [i] = 1; k = 1 since X [1] = j; S2 [2] = i + k = 3 Exchange X [1] and X [4]: X = 45312 i = 3; j = P [i] = 5; k <p> 1; j = P [i] = 2; k = 2 since X <ref> [2] </ref> = j; S2 [1] = i + k = 3 Exchange X [2] and X [5]: X = 15342 i = 2; j = P [i] = 1; k = 1 since X [1] = j; S2 [2] = i + k = 3 Exchange X [1] and X [4]: X = 45312 i = 3; j = P [i] = 5; k = 2 since X [2] = j; S2 [3] = i + k = 5 Exchange X [2] and X [3]: X = 43512 i <p> = 15342 i = 2; j = P [i] = 1; k = 1 since X [1] = j; S2 <ref> [2] </ref> = i + k = 3 Exchange X [1] and X [4]: X = 45312 i = 3; j = P [i] = 5; k = 2 since X [2] = j; S2 [3] = i + k = 5 Exchange X [2] and X [3]: X = 43512 i = 4; j = P [i] = 4; k = 1 since X [1] = j; S2 [3] = i + k = 5 Exchange X [1] and X [2]: <p> 1 since X [1] = j; S2 <ref> [2] </ref> = i + k = 3 Exchange X [1] and X [4]: X = 45312 i = 3; j = P [i] = 5; k = 2 since X [2] = j; S2 [3] = i + k = 5 Exchange X [2] and X [3]: X = 43512 i = 4; j = P [i] = 4; k = 1 since X [1] = j; S2 [3] = i + k = 5 Exchange X [1] and X [2]: X = 34512 i = 5; j = P [i] = 3; k <p> <ref> [2] </ref> = j; S2 [3] = i + k = 5 Exchange X [2] and X [3]: X = 43512 i = 4; j = P [i] = 4; k = 1 since X [1] = j; S2 [3] = i + k = 5 Exchange X [1] and X [2]: X = 34512 i = 5; j = P [i] = 3; k = 1 since X [1] = j; S2 [3] = i + k = 6 Exchange X [1] and X [1]: X = 34512 technique 6 12 24 47 98 GA 1,386,360 7,035,895 45,712,100 192,500,000 1,800,810,000 Heuristic <p> GA FITNESS FUNCTION FOR THE OCSTP 96 maxcost = 0; for (i=0; i&lt;n; ++i) f if (costs [i][j] &gt; maxcost) maxcost = costs [i][j]; g p1 = atof (GArgv <ref> [2] </ref>); p2 = atof (GArgv [3]); numlinks = (nfl (n1))/2; /fl the Bij factor is p1 times max link cost / 2flflk fl/ Bij factor = p1 fl maxcost / (1 t K BITS); /fl the Bi & Bj factors are p2 times max link cost / 2flflk fl/ Bi factor <p> requirements fl/ sum = 0L; for ( j = 0 ; j &lt; N MAX ; j++ ) sum += (dists [i][j] fl req [i][j]); return ( sum ); g Appendix B Input Data for OCSTP Experiments The input data for these experiments was generated using the tools described in <ref> [2] </ref>. While there always seems to be a source of inter-city link costs or city locations, obtaining requirements matrices is always difficult. The referenced report describes a tool that will produce requirements parametrically. <p> j++ ) gamma += 0.1 fl req [i][j]; g /fl find the max link costs to precalculate the fl/ /fl bias constants and extract P1 and P2 fl/ maxcost = 0; for (i=0; i&lt;n; ++i) f if (costs [i][j] &gt; maxcost) maxcost = costs [i][j]; g p1 = atof (GArgv <ref> [2] </ref>); p2 = atof (GArgv [3]); numlinks = (nfl (n1))/2; /fl the Bij factor is p1 times max link cost / 2flflk fl/ Bij factor = p1 fl maxcost / (1 t K BITS); APPENDIX C.
Reference: [3] <author> L. A. Cox, L. Davis, and Y. Qiu. </author> <title> Dynamic anticipatory routing in circuit-switched telecommunications networks. </title> <editor> In L. Davis, editor, </editor> <booktitle> Handbook of Genetic Algorithms, </booktitle> <pages> pages 124-143. </pages> <publisher> Van Nostrand Reinhold, </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: Cox et al. <ref> [3] </ref> used a genetic algorithm to address a combinatorial system control problem of dynamic anticipatory routing in circuit-switched telecommunications networks. Whitley et al. [39] applied genetic algorithms to the traveling salesman and sequence scheduling problems. <p> For example, with n = 5, a chromosome of <ref> [3; 11; 22; 23; 13] </ref> yields the array 2 6 6 6 6 4 3 7 7 7 7 5 This array is then input to the algorithm in figure 4.11 to produce the tree in figure 4.12. The crossover operator for this encoding presents several possibilities. <p> 2; j = P [i] = 1; k = 1 since X [1] = j; S2 [2] = i + k = 3 Exchange X [1] and X [4]: X = 45312 i = 3; j = P [i] = 5; k = 2 since X [2] = j; S2 <ref> [3] </ref> = i + k = 5 Exchange X [2] and X [3]: X = 43512 i = 4; j = P [i] = 4; k = 1 since X [1] = j; S2 [3] = i + k = 5 Exchange X [1] and X [2]: X = 34512 i <p> [1] = j; S2 [2] = i + k = 3 Exchange X [1] and X [4]: X = 45312 i = 3; j = P [i] = 5; k = 2 since X [2] = j; S2 <ref> [3] </ref> = i + k = 5 Exchange X [2] and X [3]: X = 43512 i = 4; j = P [i] = 4; k = 1 since X [1] = j; S2 [3] = i + k = 5 Exchange X [1] and X [2]: X = 34512 i = 5; j = P [i] = 3; k = 1 since <p> 3; j = P [i] = 5; k = 2 since X [2] = j; S2 <ref> [3] </ref> = i + k = 5 Exchange X [2] and X [3]: X = 43512 i = 4; j = P [i] = 4; k = 1 since X [1] = j; S2 [3] = i + k = 5 Exchange X [1] and X [2]: X = 34512 i = 5; j = P [i] = 3; k = 1 since X [1] = j; S2 [3] = i + k = 6 Exchange X [1] and X [1]: X = 34512 technique <p> 4; j = P [i] = 4; k = 1 since X [1] = j; S2 <ref> [3] </ref> = i + k = 5 Exchange X [1] and X [2]: X = 34512 i = 5; j = P [i] = 3; k = 1 since X [1] = j; S2 [3] = i + k = 6 Exchange X [1] and X [1]: X = 34512 technique 6 12 24 47 98 GA 1,386,360 7,035,895 45,712,100 192,500,000 1,800,810,000 Heuristic 1,386,360 7,134,530 37,952,000 158,612,156 780,999,474 Table 4.3: Comparison of "right hand rule" GA and Heuristic results encoding scheme produced results that did <p> GA FITNESS FUNCTION FOR THE OCSTP 96 maxcost = 0; for (i=0; i&lt;n; ++i) f if (costs [i][j] &gt; maxcost) maxcost = costs [i][j]; g p1 = atof (GArgv [2]); p2 = atof (GArgv <ref> [3] </ref>); numlinks = (nfl (n1))/2; /fl the Bij factor is p1 times max link cost / 2flflk fl/ Bij factor = p1 fl maxcost / (1 t K BITS); /fl the Bi & Bj factors are p2 times max link cost / 2flflk fl/ Bi factor = Bj factor = p2 <p> fl req [i][j]; g /fl find the max link costs to precalculate the fl/ /fl bias constants and extract P1 and P2 fl/ maxcost = 0; for (i=0; i&lt;n; ++i) f if (costs [i][j] &gt; maxcost) maxcost = costs [i][j]; g p1 = atof (GArgv [2]); p2 = atof (GArgv <ref> [3] </ref>); numlinks = (nfl (n1))/2; /fl the Bij factor is p1 times max link cost / 2flflk fl/ Bij factor = p1 fl maxcost / (1 t K BITS); APPENDIX C.
Reference: [4] <author> L. Davis. </author> <title> Genetic Algorithms and Simulated Annealing. </title> <booktitle> Research Notes in Artificial Intelligence. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1987. </year>
Reference-contexts: Whitley et al. [39] applied genetic algorithms to the traveling salesman and sequence scheduling problems. To address the problem of producing language-to-keyboard mappings for East Asian languages, Glover [14] also chose to use a genetic algorithm. Several other examples may be found in <ref> [15, 4, 10] </ref>. The success of genetic algorithms is due to the fact that genetic algorithms are computationally simple while providing a powerful parallel search capability. <p> It is these features of natural selection and parallelism that make genetic algorithms appealing for large search problems that exhibit little or no locality. 3.3 Genetic Algorithm Components As described in Davis' book <ref> [4] </ref>, a genetic algorithm has five components: 1. a means of encoding solutions to the problem as a chromosome 2. a function that evaluates the "fitness" of a solution 3. a means of obtaining an initial population of solutions 4. reproduction operators for the encoded solutions 5. appropriate settings for the <p> [2] = j; S2 [1] = i + k = 3 Exchange X [2] and X [5]: X = 15342 i = 2; j = P [i] = 1; k = 1 since X [1] = j; S2 [2] = i + k = 3 Exchange X [1] and X <ref> [4] </ref>: X = 45312 i = 3; j = P [i] = 5; k = 2 since X [2] = j; S2 [3] = i + k = 5 Exchange X [2] and X [3]: X = 43512 i = 4; j = P [i] = 4; k = 1 since
Reference: [5] <author> K. A. DeJong. </author> <title> Analysis of the Behavior of a class of genetic adaptive systems. </title> <type> PhD thesis, </type> <institution> Department of Computer and Communications Sciences, Univ. of Michigan, </institution> <year> 1975. </year>
Reference-contexts: Without such a guarantee it is possible that the best chromosome of a generation might be lost due to mutation, crossover, or selection. DeJong originated this idea and studied its effect on a selection of problems in his dissertation <ref> [5] </ref>. Scaling specifies the level of scaling used. Scaling is done to maintain good levels of competition throughout the search process. In the absence of scaling, a few highly-fit chromosomes could dominate the population very early in the process. <p> This technique subtracts a constant times the standard deviation of the population fitness values from the raw fitness values as follows f itness scaled = f itness raw (f itness average c) where c is a constant usually in the range <ref> [1; 5] </ref>. <p> Using several sets of genetic algorithm control parameters, experiments using this CHAPTER 4. REPRESENTING TREES IN GENETIC ALGORITHMS 65 i = 1; j = P [i] = 2; k = 2 since X [2] = j; S2 [1] = i + k = 3 Exchange X [2] and X <ref> [5] </ref>: X = 15342 i = 2; j = P [i] = 1; k = 1 since X [1] = j; S2 [2] = i + k = 3 Exchange X [1] and X [4]: X = 45312 i = 3; j = P [i] = 5; k = 2 since <p> In addition, the genetic algorithm control parameters described in chapter 3 must be set. Prior research by DeJong <ref> [5] </ref> and Grefenstette [17] has provided guidelines for setting the control parameters for a typical problem, but there is always some doubt as to how typical one's problem really is. Grefenstette's parameters were determined through the use of a meta-genetic algorithm (meta-GA). <p> For these meta-GA's, approximately sixty days of workstation time was consumed. The average of the meta-GAs' parameter choices varied little from those parameters chosen for the experiments described in this thesis. The general recommendations from DeJong <ref> [5] </ref> and Grefenstette [17] are also included in table 5.5 for comparison. The pairs of values in the last column reflect Grefenstette's separate study of which parameter values would optimize DeJong's two kinds of effectiveness measures for a genetic algorithm: off-line and on-line performance. <p> DeJong defined on-line performance as an average of all objective function evaluations so far, and off-line performance as a running average of the best performance values so far. The values used in the experiments being reported in this thesis differ somewhat CHAPTER 5. EXPERIMENTAL RESULTS 80 parameter thesis Meta-GA <ref> [5] </ref> [17] population 100 80 50 30=80 p c 0:6 1:0 0:6 0:95=0:45 gap 1:0 0:74 1:0 1:0 -scaling 1:0 1:37 1:0 0:9 P 1 0:0 0:044 n.a. n.a. Table 5.5: Meta-GA results comparison. from those of the meta-GA and others.
Reference: [6] <author> E. W. Dijkstra. </author> <title> A note on two problems in connexion with graphs. </title> <journal> Numerische Mathematik, </journal> <volume> 1 </volume> <pages> 269-271, </pages> <year> 1959. </year>
Reference-contexts: For some of these, highly efficient algorithms have been developed that solve them exactly. An algorithm for finding the shortest path between a pair of nodes in a graph was designed by Dijkstra <ref> [6] </ref>. Prim [35] designed an algorithm to find the minimal cost spanning tree over the n nodes of a graph. Both of these algorithms can accomplish their goal by doing an amount of work that is on the order of n 2 operations.
Reference: [7] <author> R. Dionne and M. Florian. </author> <title> Exact and approximate algorithms for optimal network design. </title> <journal> Networks, </journal> <volume> 9 </volume> <pages> 39-59, </pages> <year> 1979. </year>
Reference-contexts: In addition, the effectiveness of an algorithm may be a function of its input data. Some algorithms, such as Dionne and Florian's <ref> [7] </ref> algorithm for finding solutions to the optimal communications network problem, work quite well for typical kinds of input data but perform poorly, perhaps even failing to terminate, for some special cases of input data. <p> He did make the observation that a big part of the problem is the selection of the interior nodes. This observation proved to be a key insight toward the development of the approach proposed by this thesis. Dionne and Florian <ref> [7] </ref> and Lin [30] studied the general problem at length and provided heuristic algorithms that required little computation time and that produced solutions that were either optimal or nearly so. However, they made some assumptions that are incompatible with the OCSTP.
Reference: [8] <author> Cem Ersoy. </author> <title> Topological Design of Interconnected Local and Metropolitan Area Networks. </title> <type> PhD thesis, </type> <institution> Polytechnic University, Electrical Engineering Department, Brooklyn, </institution> <address> New York, </address> <year> 1992. </year> <note> 119 BIBLIOGRAPHY 120 </note>
Reference-contexts: The goal is to select a spanning tree such that the capacities of LANs and bridges used by the tree are not exceeded and such that the total end-to-end delay for the traffic between all pairs of nodes is minimized. In his dissertation <ref> [8] </ref>, Ersoy investigated this problem using the simulated annealing local search technique [29]. He approximated the average network delay by CHAPTER 5. EXPERIMENTAL RESULTS 87 limiting his model to delays due to LANs and bridges only. <p> Ersoy's work <ref> [8] </ref> and were used with his permission. The input files contain a list of LANs, the inter-LAN traffic requirements, and a constant cost for each bridge. Due to their bulk, the input files for the 15, 20, and 30 node minimum delay spanning tree problems are not included here.
Reference: [9] <author> S. Forrest. </author> <title> Documentation for prisoners dilemma and norms programs that use the genetic algorithm. </title> <type> Unpublished manuscript, </type> <institution> University of Michagan, </institution> <address> Ann Arbor, </address> <year> 1985. </year>
Reference-contexts: Later, the population becomes more and more similar and thus the competition between chromosomes is smaller. To counter this effect, the fitness function is scaled up to magnify the remaining differences between chromosomes. The sigma-truncation technique <ref> [9] </ref> was used for this work. This technique subtracts a constant times the standard deviation of the population fitness values from the raw fitness values as follows f itness scaled = f itness raw (f itness average c) where c is a constant usually in the range [1; 5].
Reference: [10] <editor> S. Forrest, editor. </editor> <booktitle> Fifth International Conference on Genetic Algorithms, </booktitle> <institution> University of Illinois at Urbana-Champaign, </institution> <address> 1993. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Whitley et al. [39] applied genetic algorithms to the traveling salesman and sequence scheduling problems. To address the problem of producing language-to-keyboard mappings for East Asian languages, Glover [14] also chose to use a genetic algorithm. Several other examples may be found in <ref> [15, 4, 10] </ref>. The success of genetic algorithms is due to the fact that genetic algorithms are computationally simple while providing a powerful parallel search capability.
Reference: [11] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractibility. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, NY, </address> <year> 1979. </year>
Reference-contexts: CHAPTER 2. THE OCST PROBLEM 7 CHAPTER 2. THE OCST PROBLEM 8 The work by Johnson et al. [26] includes a proof that NDP is NP-complete by demonstrating that the KNAPSACK NP-complete problem <ref> [11] </ref> is reducible to NDP. If the budget constraint is reduced to B = n 1, all solutions must be tree networks. <p> THE OCST PROBLEM 10 Subproblem 1: When all the requirements are equal and the link costs are arbitrary, this is the Optimum Link Cost Spanning Tree Problem (OLCSTP). This problem is still NP-complete except for the two cases for which Hu provided a polynomial time solution <ref> [11] </ref>: Case 1: When all the link costs are equal, then the optimum link cost spanning tree is a star around the city with the highest requirements. <p> Subproblem 2: When all the link costs are equal and the requirements are arbitrary, the problem may be solved in polynomial time using the Gomory-Hu spanning tree algorithm [16][23]. Hu called this the Optimum Requirement Spanning Tree Problem (ORSTP). In the general case, the OCSTP is NP-complete <ref> [11] </ref>. Other problems can be derived from these as shown in figure 2.1. The unnamed NP-complete problem must be NP-complete if it is derived from the NP-complete NDP, and the NP-complete OLCSTP is, in turn, derived from it. <p> For example, with n = 5, a chromosome of <ref> [3; 11; 22; 23; 13] </ref> yields the array 2 6 6 6 6 4 3 7 7 7 7 5 This array is then input to the algorithm in figure 4.11 to produce the tree in figure 4.12. The crossover operator for this encoding presents several possibilities.
Reference: [12] <author> B. Gavish. </author> <title> Formulations and algorithms for the capacitated minimal directed tree problem. </title> <journal> Journal of the ACM, </journal> <volume> 30(1) </volume> <pages> 118-132, </pages> <year> 1983. </year>
Reference-contexts: To do so would require changing several links at once, perhaps moving groups of links from one node to another. Identifying which group of links to move is very difficult. Gavish <ref> [12] </ref> applied Lagrangian relaxation in order to find good solutions to the general problem. These approaches work very well when the fixed cost of installing links is low to moderate, with respect to the cost per unit capacity of the links.
Reference: [13] <author> A. Gibbons. </author> <title> Algorithmic Graph Theory. </title> <publisher> Cambridge University Press, </publisher> <address> New York, NY, </address> <year> 1985. </year>
Reference-contexts: Other times its selection is part of the problem. In all cases, it is possible to represent an arbitrary tree as a rooted tree. Rooted tree representations will be used in this thesis. It has been shown by Cayley [31] and others <ref> [13] </ref> that the number of possible trees in a complete graph on n nodes is n (n2) . Since each such tree can correspond to n possible rooted trees, with any node designated as the root, there are n (n1) possible rooted trees. <p> For example, with n = 5, a chromosome of <ref> [3; 11; 22; 23; 13] </ref> yields the array 2 6 6 6 6 4 3 7 7 7 7 5 This array is then input to the algorithm in figure 4.11 to produce the tree in figure 4.12. The crossover operator for this encoding presents several possibilities. <p> The cost matrix would be biased by these values using C 0 The tree that the chromosome represents is then found by applying Prim's algorithm <ref> [13] </ref> to find a minimal spanning tree (MST) over the nodes using the biased cost matrix. Finally, this MST is evaluated using the original cost matrix to determine the tree's fitness for the OCSTP.
Reference: [14] <author> D. Glover. </author> <title> Solving a complex keyboard configuration problem through generalized adaptive search. </title> <editor> In L. Davis, editor, </editor> <booktitle> Genetic Algorithms and Simulated Annealing, </booktitle> <pages> pages 12-31. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1987. </year>
Reference-contexts: Whitley et al. [39] applied genetic algorithms to the traveling salesman and sequence scheduling problems. To address the problem of producing language-to-keyboard mappings for East Asian languages, Glover <ref> [14] </ref> also chose to use a genetic algorithm. Several other examples may be found in [15, 4, 10]. The success of genetic algorithms is due to the fact that genetic algorithms are computationally simple while providing a powerful parallel search capability.
Reference: [15] <author> D. E. Goldberg. </author> <title> Genetic algorithms in search, optimization, and machine learning. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: What is needed is some other approach that can move easily from one point in the solution space to another that is significantly different. Genetic algorithms [22] have this capability and have been successfully applied to many optimization problems in the past <ref> [15] </ref>. The next chapter discusses the genetic algorithm technique, and the succeeding chapters describe how genetic algorithms were successfully applied to the OCSTP and other related problems. Chapter 3 Genetic Algorithm Technique The genetic algorithm technique has been successfully applied in numerous problem areas, including combinatorial optimization problems. <p> Whitley et al. [39] applied genetic algorithms to the traveling salesman and sequence scheduling problems. To address the problem of producing language-to-keyboard mappings for East Asian languages, Glover [14] also chose to use a genetic algorithm. Several other examples may be found in <ref> [15, 4, 10] </ref>. The success of genetic algorithms is due to the fact that genetic algorithms are computationally simple while providing a powerful parallel search capability. <p> For example, the strings and fitnesses may seem to imply that strings starting with 10 are better than the others (at least in a given population). These similarity templates are the schemata. Goldberg offered two basic principles for choosing a genetic algorithm encoding <ref> [15] </ref>. The first addressed the kinds of symbols used to represent the information contained in the chromosome: Principle of Minimal Alphabets: select the smallest alphabet that per mits a natural expression of the problem. <p> This would favor the use of a binary encoding, for example, over an alphabet-based encoding wherein a set of several symbols is used. Binary encodings maximize the number of schemata available to the genetic algorithm's search process <ref> [15] </ref>. If each position on a binary-encoded chromosome of length L can have schema values 0 , 1 , and fl, then there are 3 L possible schemata. <p> It can then be easily shown that the binary alphabet will provide more schemata than any other coding. For example, using this four symbol alphabet to encode the integers <ref> [0; 15] </ref> results in a length L 0 = 2 which results in a total of 5 2 = 25 schemata. The binary encoding for the same numbers would have L = 4 and would result in 3 4 = 81 CHAPTER 3. GENETIC ALGORITHM TECHNIQUE 20 schemata. <p> In a population of size n, there are between 2 L (all the chromosomes are identical) and n2 L (all are different) schemata represented. It was shown in Holland's [22] and Goldberg's <ref> [15] </ref> works that despite the processing of only n chromosomes during each generation, the genetic algorithm actually processes O (n 3 ) schemata each generation. Goldberg described the derivation of this value in detail. <p> evaluate the fitness of the offspring (e) replace some or all of the previous population with the offspring population 3.5 Fundamental Theorem of Genetic Algorithms To show how all these pieces fit together into an effective search mechanism, the schema theorem, also known as the fundamental theorem of genetic algorithms <ref> [15] </ref>, is examined. The goal of the genetic algorithm is for each successive generation's population to have a favorable chance of containing more highly fit chromosomes. As explained earlier, the search through the schemata is the central issue.
Reference: [16] <author> R. E. Gomory and T. C. Hu. </author> <title> Multi-terminal network flows. </title> <journal> SIAM Journal on Applied Math, </journal> <volume> 9 </volume> <pages> 551-570, </pages> <year> 1961. </year>
Reference: [17] <author> J. J. Grefenstette. </author> <title> Optimization of control parameters for genetic algorithms. </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, </journal> <volume> 16(1) </volume> <pages> 122-128, </pages> <year> 1986. </year>
Reference-contexts: 100 Scaling 1:0 Crossover 0:6 P 1 0:0 M utation 0:01 P 2 1:0 Gen Gap 1:0 These parameters, with the exception of P 1 and P 2 , which are specific to this new encoding, closely matched those generally held to be good choices for by other re searchers <ref> [17] </ref>. CHAPTER 4. <p> In addition, the genetic algorithm control parameters described in chapter 3 must be set. Prior research by DeJong [5] and Grefenstette <ref> [17] </ref> has provided guidelines for setting the control parameters for a typical problem, but there is always some doubt as to how typical one's problem really is. Grefenstette's parameters were determined through the use of a meta-genetic algorithm (meta-GA). <p> For these meta-GA's, approximately sixty days of workstation time was consumed. The average of the meta-GAs' parameter choices varied little from those parameters chosen for the experiments described in this thesis. The general recommendations from DeJong [5] and Grefenstette <ref> [17] </ref> are also included in table 5.5 for comparison. The pairs of values in the last column reflect Grefenstette's separate study of which parameter values would optimize DeJong's two kinds of effectiveness measures for a genetic algorithm: off-line and on-line performance. <p> The values used in the experiments being reported in this thesis differ somewhat CHAPTER 5. EXPERIMENTAL RESULTS 80 parameter thesis Meta-GA [5] <ref> [17] </ref> population 100 80 50 30=80 p c 0:6 1:0 0:6 0:95=0:45 gap 1:0 0:74 1:0 1:0 -scaling 1:0 1:37 1:0 0:9 P 1 0:0 0:044 n.a. n.a. Table 5.5: Meta-GA results comparison. from those of the meta-GA and others.
Reference: [18] <author> J. J. Grefenstette. </author> <title> Incorporating problem specific knowledge into genetic algorithms. </title> <editor> In L. Davis, editor, </editor> <booktitle> Genetic Algorithms and Simulated Annealing, </booktitle> <pages> pages 42-60. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1987. </year>
Reference-contexts: GENETIC ALGORITHM TECHNIQUE 24 to mutation, available to the genetic algorithm during its search. One might employ a heuristic to choose the initial population in an attempt to introduce the "right" genetic building blocks into the population. However, this can lead to problems since genetic algorithms are "notoriously opportunistic" <ref> [18] </ref>. The presence of just a few chromosomes with fitnesses far better than all the others may cause genetic algorithms to converge prematurely to a local optimum. 3.3.5 Genetic algorithm control parameters There are other parameters that govern the genetic algorithm search process.
Reference: [19] <author> J. J. Grefenstette. </author> <title> A user's guide to genesis 4.5. </title> <type> Technical report, </type> <institution> Navy Center for Applied Research in Artificial Intelligence, Naval Research Laboratory, </institution> <address> Washington, D.C. 20375-5000, </address> <year> 1987. </year> <note> The Genesis package is available from the author who may be reached via email at gref@aix.nrl.navy.mil. BIBLIOGRAPHY 121 </note>
Reference-contexts: This tool is supplied in C source code form and has been ported to most of the popular platforms. Well-suited for genetic algorithm research, the GAucsd tool, and its ancestor Genesis <ref> [19] </ref>, have been used by researchers around the world. Since the tool is supplied in source form the user is able to change any aspect of the genetic algorithm process, such as crossover operation, mutation, or selection.
Reference: [20] <author> J. J. Grefenstette and J. M. Fitzpatrick. </author> <title> Genetic search with approximate function evaluations. </title> <editor> In J. J. Grefenstette, editor, </editor> <booktitle> Proceedings of the First International Conference on Genetic Algorithms, </booktitle> <pages> pages 112-120, </pages> <institution> Carnegie-Mellon University, </institution> <address> Pittsburgh, PA, July 24-26 1985. </address> <publisher> Lawrence Erlbaum Associates. </publisher>
Reference-contexts: For the case when exact methods are too expensive, the use of approximation functions for the fitness were investigated by Grefenstette and Fitzpatrick <ref> [20] </ref>. They were studying the use of a genetic algorithm to perform image registration as part of a digital subtraction angiography system.
Reference: [21] <author> J. H. Holland. </author> <title> Hierarchical descriptions of universal spaces and adaptive systems. </title> <type> Technical Report ORA Projects 01252 and 08226, </type> <institution> University of Michigan, Department of Computer and Communication Sciences, </institution> <address> Ann Arbor, MI, </address> <year> 1968. </year>
Reference-contexts: All CHAPTER 3. GENETIC ALGORITHM TECHNIQUE 19 sorts of genetic material must be possible in the population since good solutions may result from the mixing of one or more inferior ones. Another key to understanding what makes a good encoding is a schema. The concept of a schema <ref> [21, 22] </ref> is the basis of genetic algorithm theory. Holland described a schema as a template describing a subset of strings in a population with similarities at certain string positions. For example, 101 and 100 are identical when the rightmost position is ignored.
Reference: [22] <author> J. H. Holland. </author> <title> Adaptation in Natural and Artificial Systems. </title> <publisher> Univ. of Michigan Press, </publisher> <address> Ann Arbor, MI, </address> <publisher> 1975; reprinted by MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992, 1992. </year>
Reference-contexts: So far, a good, general-purpose approximation algorithm for it has proven elusive. A totally different approach to hard problems like these was needed because of their lack of structure and locality, and in 1975, John Holland <ref> [22] </ref> provided one: the Genetic Algorithm. He likened this new search technique to the search for more highly "fit" organisms that is effectively carried out in nature through the processes of evolution. <p> However, codifying the knowledge in an algorithm that would lead to such an observation would be difficult. What is needed is some other approach that can move easily from one point in the solution space to another that is significantly different. Genetic algorithms <ref> [22] </ref> have this capability and have been successfully applied to many optimization problems in the past [15]. The next chapter discusses the genetic algorithm technique, and the succeeding chapters describe how genetic algorithms were successfully applied to the OCSTP and other related problems. <p> Since the fitness function is really a part of the input to the general-purpose genetic algorithm process, these data and algorithms are not the target of the optimization. 3.2 Genetic Algorithm Background The genetic algorithm technique was invented by Holland <ref> [22] </ref> in the early 1970's and has been successfully applied to numerous combinatorial search space problems. Cox et al. [3] used a genetic algorithm to address a combinatorial system control problem of dynamic anticipatory routing in circuit-switched telecommunications networks. <p> All CHAPTER 3. GENETIC ALGORITHM TECHNIQUE 19 sorts of genetic material must be possible in the population since good solutions may result from the mixing of one or more inferior ones. Another key to understanding what makes a good encoding is a schema. The concept of a schema <ref> [21, 22] </ref> is the basis of genetic algorithm theory. Holland described a schema as a template describing a subset of strings in a population with similarities at certain string positions. For example, 101 and 100 are identical when the rightmost position is ignored. <p> In a population of size n, there are between 2 L (all the chromosomes are identical) and n2 L (all are different) schemata represented. It was shown in Holland's <ref> [22] </ref> and Goldberg's [15] works that despite the processing of only n chromosomes during each generation, the genetic algorithm actually processes O (n 3 ) schemata each generation. Goldberg described the derivation of this value in detail. <p> For example, with n = 5, a chromosome of <ref> [3; 11; 22; 23; 13] </ref> yields the array 2 6 6 6 6 4 3 7 7 7 7 5 This array is then input to the algorithm in figure 4.11 to produce the tree in figure 4.12. The crossover operator for this encoding presents several possibilities.
Reference: [23] <author> T. C. Hu. </author> <title> Optimum communication spanning trees. </title> <journal> SIAM Journal on Computing, </journal> <volume> 3(3) </volume> <pages> 188-195, </pages> <year> 1974. </year>
Reference-contexts: Leaving r and c set to any and limiting the solutions to trees in this manner moves the focus down the hierarchy from the NDP to the Optimal Communication Spanning Tree Problem (OCSTP) posed by Hu <ref> [23] </ref> (also known as the Simple Network Design Problem in [26]): Optimal Communication Spanning Tree Problem (OCSTP): Given a set of N cities, n 0 ; n 1 ; : : : ; n N , the cost per unit of capacity, C i;j , of a communication link between each <p> For example, with n = 5, a chromosome of <ref> [3; 11; 22; 23; 13] </ref> yields the array 2 6 6 6 6 4 3 7 7 7 7 5 This array is then input to the algorithm in figure 4.11 to produce the tree in figure 4.12. The crossover operator for this encoding presents several possibilities. <p> Once an encoding for trees was designed, it had to be tested. For this, the Optimal Communications Spanning Tree Problem (OCSTP) was chosen. Since its origins with T. C. Hu in 1974 <ref> [23] </ref>, good heuristics for the NP-complete OCSTP have eluded researchers. Although the literature is almost devoid of other than passing references to it, some existing heuristics have been found to perform reasonably well.
Reference: [24] <author> F. K. Hwang. </author> <title> On steiner minimal trees with rectilinear distance. </title> <journal> SIAM Journal of Applied Mathematics, </journal> <volume> 30(1) </volume> <pages> 104-114, </pages> <year> 1976. </year>
Reference-contexts: His results showed that while the genetic algorithm did indeed find valid solutions, it "did not perform as well as other approximation methods." He measured the quality of his genetic algorithm's results against Hwang's <ref> [24] </ref> lower bound which established that no solution to this problem can be shorter than 67% of the length of a minimal rectilinear spanning tree (MRSPT) over the same points.
Reference: [25] <author> F. K. Hwang. </author> <title> An o(n log n) algorithm for suboptimal rectilinear steiner trees. </title> <journal> IEEE Transactions on Circuits and Systems, </journal> <volume> 26(1) </volume> <pages> 75-77, </pages> <year> 1979. </year>
Reference-contexts: Another result from Hwang <ref> [25] </ref> included an algorithm which could find solutions that were 92% as long as a minimal rectilinear spanning tree over the same points.
Reference: [26] <author> D. S. Johnson, J. K. Lenstra, and A. H. G. Rinnooy Kan. </author> <title> The complexity of the network design problem. </title> <journal> Networks, </journal> <volume> 8 </volume> <pages> 279-285, </pages> <year> 1978. </year>
Reference-contexts: The thesis concludes with a summary of the contributions of this work and a discussion of areas for future study. Chapter 2 The OCST Problem 2.1 Background The OCST problem is a member of a hierarchy of problems that begins with the Network Design Problem (NDP) <ref> [26] </ref>. This hierarchy is shown in figure 2.1. In order to better understand the problems in this hierarchy, an explanation should begin with the most general form of these problems. <p> The "single source" problem is a solvable derivation of NDP because in it there is only one source, s, for which equation 2.1 must be minimized. CHAPTER 2. THE OCST PROBLEM 7 CHAPTER 2. THE OCST PROBLEM 8 The work by Johnson et al. <ref> [26] </ref> includes a proof that NDP is NP-complete by demonstrating that the KNAPSACK NP-complete problem [11] is reducible to NDP. If the budget constraint is reduced to B = n 1, all solutions must be tree networks. <p> Leaving r and c set to any and limiting the solutions to trees in this manner moves the focus down the hierarchy from the NDP to the Optimal Communication Spanning Tree Problem (OCSTP) posed by Hu [23] (also known as the Simple Network Design Problem in <ref> [26] </ref>): Optimal Communication Spanning Tree Problem (OCSTP): Given a set of N cities, n 0 ; n 1 ; : : : ; n N , the cost per unit of capacity, C i;j , of a communication link between each pair of cities, and a set of requirements, R i;j
Reference: [27] <author> K. Juliff. </author> <title> A multi-chromosome genetic algorithm for pallet loading. </title> <editor> In S. Forrest, editor, </editor> <booktitle> Proceedings of the Fifth International Conference on Genetic Algorithms, </booktitle> <pages> pages 467-473, </pages> <institution> University of Illinois at Urbana-Champaign, </institution> <address> July 17-21 1993. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: For example, the fitness function that was used in a genetic algorithm used to position cases of beer on pallets and then to order the pallets in delivery trucks <ref> [27] </ref> (yet another combinatorial optimization problem) made use of knowledge of the truck's interior dimensions.
Reference: [28] <author> B. A. Julstrom. </author> <title> A genetic algorithm for the rectilinear steiner problem. </title> <editor> In S. Forrest, editor, </editor> <booktitle> Proceedings of the Fifth International Conference on Genetic Algorithms, </booktitle> <pages> pages 474-479, </pages> <institution> University of Illinois at Urbana-Champaign, </institution> <address> July 17-21 1993. </address> <publisher> Morgan Kaufmann. BIBLIOGRAPHY 122 </publisher>
Reference-contexts: Some other researchers have built genetic algorithms that use these Prufer numbers as their encoding for tree problems, but they too have had limited success. Recently, Julstrom <ref> [28] </ref> used them as the encoding for trees in his genetic algorithm for the rectilinear Steiner problem.
Reference: [29] <author> S. Kirkpatrick, C. D. Gelatt, and M. P. Vecci. </author> <title> Optimization by simulated annealing. </title> <journal> Science, </journal> <volume> 220 </volume> <pages> 671-680, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: In his dissertation [8], Ersoy investigated this problem using the simulated annealing local search technique <ref> [29] </ref>. He approximated the average network delay by CHAPTER 5. EXPERIMENTAL RESULTS 87 limiting his model to delays due to LANs and bridges only.
Reference: [30] <author> S. Lin. </author> <title> Effective use of heuristic algorithms in network design. </title> <booktitle> Proceedings of Symposia in Applied Mathematics, </booktitle> <volume> 26 </volume> <pages> 63-84, </pages> <year> 1982. </year>
Reference-contexts: He did make the observation that a big part of the problem is the selection of the interior nodes. This observation proved to be a key insight toward the development of the approach proposed by this thesis. Dionne and Florian [7] and Lin <ref> [30] </ref> studied the general problem at length and provided heuristic algorithms that required little computation time and that produced solutions that were either optimal or nearly so. However, they made some assumptions that are incompatible with the OCSTP. They used three sets of test networks for their experiments.
Reference: [31] <author> J. W. Moon. </author> <title> Various proofs of Cayley's formula for counting trees. </title> <editor> In F. Harary, editor, </editor> <booktitle> A Seminar on Graph Theory, </booktitle> <pages> pages 70-78. </pages> <publisher> Holt, Rinehart, and Winston, </publisher> <address> New York, NY, </address> <year> 1967. </year>
Reference-contexts: Sometimes the problem specification fixes the identity of the root. Other times its selection is part of the problem. In all cases, it is possible to represent an arbitrary tree as a rooted tree. Rooted tree representations will be used in this thesis. It has been shown by Cayley <ref> [31] </ref> and others [13] that the number of possible trees in a complete graph on n nodes is n (n2) . Since each such tree can correspond to n possible rooted trees, with any node designated as the root, there are n (n1) possible rooted trees. <p> This is also an improvement over the characteristic vector representation. Thus, at least for complete graphs, this representation is significantly better than the characteristic vector. For sparse graphs, such as trees, however, the improvement diminishes. 4.2.3 Prufer numbers A third possible encoding is the Prufer number <ref> [31] </ref> associated with a tree, defined as follows. Let T be a tree on n nodes. The Prufer number, P (T ), is an n 2 digit number, where once again the digits are numbers between 1 and n , n 3, and are CHAPTER 4.
Reference: [32] <author> D. Orvosh and L. Davis. </author> <title> Shall we repair? Genetic algorithms, combinatorial optimization, and feasibility constraints. </title> <editor> In S. Forrest, editor, </editor> <booktitle> Proceedings of the Fifth International Conference on Genetic Algorithms, </booktitle> <pages> page 650, </pages> <institution> University of Illinois at Urbana-Champaign, </institution> <address> July 17-21 1993. </address> <publisher> Morgan Kaufmann. </publisher>
Reference-contexts: Again using the concentrator network design example, a simple crossover operator is shown in figure 3.2. In this example, a random point is chosen between two of the positions, or 3 See comments in chapter 6 about Davis' recent work <ref> [32] </ref> in the area of chromosomal repair. CHAPTER 3. GENETIC ALGORITHM TECHNIQUE 23 genes, of the two parent chromosomes. Each of the chromosomes is cut at that point and the two ends are exchanged. This typically results in two different chromosomes with different characteristics. <p> However, it is not known whether the individual b i , b j , and b ij genes on the chromosome represent the only places where schemata arise. Recent work by Orvosh and Davis <ref> [32] </ref> indicates that when an encoding allows invalid chromosomes to be produced by mating, it isn't always best to "repair" them. They suggest that this reparation process can result in the loss of important genetic material and, thus, reduce the efficiency of the search.
Reference: [33] <author> C. C. Palmer and A. Kershenbaum. </author> <title> Representing trees in genetic algorithms. </title> <booktitle> In Proceedings of the First IEEE Conference on Evolutionary Computation, </booktitle> <address> Or-lando, FL, </address> <month> June 21 - July 2 </month> <year> 1994. </year>
Reference-contexts: CHAPTER 4. REPRESENTING TREES IN GENETIC ALGORITHMS 66 nodes and others should be leaf nodes. With this in mind, the new encoding was designed so that the genetic algorithm would be allowed to search for nodes with these tendencies while looking for solutions to the OCSTP <ref> [33] </ref>. In the first version of this encoding, the chromosome holds a bias value for each node. For example, in a four node problem the chromosome would contain four biases [b 1 b 2 b 3 b 4 ].
Reference: [34] <author> C. C. Palmer and A. Kershenbaum. </author> <title> Two algorithms for finding optimal communications spanning trees. </title> <type> Technical Report RC19394, </type> <institution> IBM T. J. Watson Research Center, </institution> <address> P.O. Box 704, Yorktown Heights, NY, </address> <year> 1994. </year>
Reference-contexts: As shown in figure 5.1, the genetic algorithm using 10; 000 trials consistently found CHAPTER 5. EXPERIMENTAL RESULTS 73 solutions superior to a random search of one million solutions by more than 4 standard deviations. 5.3 Star-Search Heuristic Comparison The first heuristic <ref> [34] </ref> is shown in figure 5.2. It returns the best tree among stars on one node, connected pairs of stars, and trees based upon a minimal spanning tree (MST) with interior nodes reduced.
Reference: [35] <author> R. C. Prim. </author> <title> Shortest connection networks and some generalizations. </title> <journal> Bell Systems Technical Journal, </journal> <volume> 36 </volume> <pages> 1389-1401, </pages> <year> 1957. </year>
Reference-contexts: For some of these, highly efficient algorithms have been developed that solve them exactly. An algorithm for finding the shortest path between a pair of nodes in a graph was designed by Dijkstra [6]. Prim <ref> [35] </ref> designed an algorithm to find the minimal cost spanning tree over the n nodes of a graph. Both of these algorithms can accomplish their goal by doing an amount of work that is on the order of n 2 operations.
Reference: [36] <editor> G. J. E. Rawlins. </editor> <booktitle> Foundations of Genetic Algorithms. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1991. </year>
Reference-contexts: Using parameters that aren't directly relevant will cause the genetic algorithm to be subject to changes in the problem that would not otherwise effect it, thereby making it no more useful than a specialized heuristic. Some knowledge of the search space is, of course, unavoidable. Rawlins <ref> [36] </ref> observed ... if an algorithm is to be more effective than random search, then "prior knowledge" must be included in the choice of encoding.
Reference: [37] <author> N. N. Schraudolph and J. J. Grefenstette. </author> <title> A user's guide to gaucsd 1.4. </title> <type> Technical Report CS92-249, </type> <institution> UC San Diego, CSE Department, UC San Diego, La Jolla, </institution> <address> CA 92093-0114, </address> <year> 1990. </year>
Reference-contexts: As described earlier, some of these experiments ran for minutes and others for up to twenty-five days. The results reported in this thesis are the result of runs totalling more than 90 CPU-days on these workstations. A generally available genetic algorithm experimentation tool, GAucsd 1.4 <ref> [37] </ref>, was ported to the IBM AIX operating system and the above workstation for this research. The original version of this tool is available via anonymous ftp from cs.ucsd.edu (132.239.51.3) in the subdirectory pub/GAucsd/GAucsd14.sh.Z, or requested via email to nici@cs.ucsd.edu.
Reference: [38] <author> D. J. Stockton and Liam Quinn. </author> <title> Identifying economic order quantities using genetic algorithms. </title> <journal> International journal of operations and production management, </journal> <volume> 13(11) </volume> <pages> 92-103, </pages> <year> 1993. </year> <note> BIBLIOGRAPHY 123 </note>
Reference-contexts: In fact, it may be the case that the whole motivation for producing a new heuristic is because the old ones can no longer find good solutions because the problem has changed since they were first written <ref> [38] </ref>. A genetic algorithm that can adapt to changing problem parameters and still produce reliably good groups of solutions would be preferable. There are two general kinds of changes to a problem: changes to the data and changes to the problem goals.
Reference: [39] <author> D. Whitley, T. Starkweather, and D. Shaner. </author> <title> The traveling salesman and sequence scheduling: Quality solutions using genetic edge recombination. </title> <editor> In L. Davis, editor, </editor> <booktitle> Handbook of Genetic Algorithms, </booktitle> <pages> pages 350-372. </pages> <publisher> Van Nostrand Reinhold, </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: Cox et al. [3] used a genetic algorithm to address a combinatorial system control problem of dynamic anticipatory routing in circuit-switched telecommunications networks. Whitley et al. <ref> [39] </ref> applied genetic algorithms to the traveling salesman and sequence scheduling problems. To address the problem of producing language-to-keyboard mappings for East Asian languages, Glover [14] also chose to use a genetic algorithm. Several other examples may be found in [15, 4, 10].
References-found: 39

