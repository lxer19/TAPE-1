URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1992/TR24.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: Design and Specification of Iterators Using the Swapping Paradigm  
Author: Bruce W. Weide Stephen H. Edwards Douglas E. Harms David A. Lamb 
Keyword: Index Terms Formal specification, iterator, program verification, proof of correctness, swapping.  
Note: Copyright 1992 by the authors. All rights reserved.  
Abstract: How should iterators be abstracted and encapsulated in modern imperative languages, e.g., Ada and C++? We consider the combined impact of several factors on this question: the need for a common interface model for user-defined iterator abstractions; the importance of formal methods in specifying such a model; and problems involved in modular correctness proofs of iterator implementations and clients. A series of iterator designs illustrates the advantages of the swapping paradigm over designs based on the traditional copying paradigm. Specifically, swapping-based designs admit more efficient implementations, while offering straightforward formal specifications and the potential for modular reasoning about program behavior. The final proposed design schema defines a common interface model for iterators for a wide variety of generic collection abstractions in languages such as Ada and C++. 
Abstract-found: 1
Intro-found: 1
Reference: [Bishop 90] <author> Bishop, J.M., </author> <title> The effect of data abstraction on loop programming techniques, </title> <journal> IEEE TSE 16, </journal> <month> 4 (Apr. </month> <year> 1990), </year> <pages> 389-402. </pages>
Reference-contexts: The crucial importance of, and difficulties with, modular verification of realistically large software systems are noted by Ernst, et al. [Ernst 91] and Hollingsworth [Hollingsworth 92], among others. Previous work on iteration over the elements of a composite data structure, summarized nicely by Bishop <ref> [Bishop 90] </ref>, has not considered together the importance of efficiency with respect to copying, the need for formal specification of a common interface model, and the importance of modular reasoning about correctness in the design of iterators. <p> Alphard, like other languages with iterator constructs, offers neither. In an attempt to deal with noninterference in user-defined iterator abstractions, Booch [Booch 87] and Bishop <ref> [Bishop 90] </ref> suggest classifying iterators into two categories, which Booch calls active and passive. An active iterator is a module that exports an iterator type and associated operations and permits a client to build iteration loops with standard control constructs, e.g., while loops. <p> Copying should not be inherent in the iterator itself. page 5 Unfortunately, passive iterators suffer from their own serious problems, discussed in detail by many authors <ref> [Booch 87, Bishop 90, Edwards 90] </ref>. From the standpoint of reusability they are far less flexible than active iterators. In the face of formal specification and the need for modular verification, the nature of the action procedures effects and side-effects must be formally specified and proofs modularized. <p> By contrast, Booch [Booch 87] points out that his iterator designs are relatively unprotected from client abuse. Indeed nothing but self-discipline prevents a client from altering a collection during iteration over it. The same is true for Bishops designs <ref> [Bishop 90] </ref>. Several methods for repairing this shortcoming are proposed by Edwards [Edwards 90], but like Booch and Bishop he does not deal explicitly with formal specification or the need for a framework for modular verification. <p> As noted by Harms and Weide [Harms 91], the typical method of avoiding this expense copying only a reference (pointer) to an item, as with the designs recommended by page 6 Booch [Booch 87] and Bishop <ref> [Bishop 90] </ref> creates even more serious problems from the standpoint of our objectives. It is a disaster for formal specification and it completely thwarts modular verification [Ernst 91, Hollingsworth 92]. From the practical standpoint, this makes understanding of and informal reasoning about program behavior much harder than it should be.
Reference: [Booch 87] <author> Booch, G., </author> <title> Software Components with Ada, </title> <publisher> Benjamin Cummings, </publisher> <year> 1987. </year>
Reference-contexts: Alphard, like other languages with iterator constructs, offers neither. In an attempt to deal with noninterference in user-defined iterator abstractions, Booch <ref> [Booch 87] </ref> and Bishop [Bishop 90] suggest classifying iterators into two categories, which Booch calls active and passive. An active iterator is a module that exports an iterator type and associated operations and permits a client to build iteration loops with standard control constructs, e.g., while loops. <p> Copying should not be inherent in the iterator itself. page 5 Unfortunately, passive iterators suffer from their own serious problems, discussed in detail by many authors <ref> [Booch 87, Bishop 90, Edwards 90] </ref>. From the standpoint of reusability they are far less flexible than active iterators. In the face of formal specification and the need for modular verification, the nature of the action procedures effects and side-effects must be formally specified and proofs modularized. <p> That is, like Lamb [Lamb 90] we write our formal specification so noninterference must be observed by a correct client program. A proof obligation involving noninterference is raised in the client that can and must be discharged if the client program is to be considered correct. By contrast, Booch <ref> [Booch 87] </ref> points out that his iterator designs are relatively unprotected from client abuse. Indeed nothing but self-discipline prevents a client from altering a collection during iteration over it. The same is true for Bishops designs [Bishop 90]. <p> As noted by Harms and Weide [Harms 91], the typical method of avoiding this expense copying only a reference (pointer) to an item, as with the designs recommended by page 6 Booch <ref> [Booch 87] </ref> and Bishop [Bishop 90] creates even more serious problems from the standpoint of our objectives. It is a disaster for formal specification and it completely thwarts modular verification [Ernst 91, Hollingsworth 92].
Reference: [Cameron 89] <author> Cameron, R.D., </author> <title> Efficient high-level iteration with accumulators, </title> <journal> ACM TOPLAS 11, </journal> <month> 2 (Apr. </month> <year> 1989), </year> <pages> 194-211. </pages>
Reference-contexts: 1. Introduction An iterator is an abstraction that supports sequential access to the individual items of a collection, without modifying the collection. While some academic languages (most notably Alphard [Shaw 77] and CLU [Liskov 77] ) include special language constructs for iterators, and others have been proposed <ref> [Cameron 89] </ref>, the most widely used modern imperative languages such as Ada and C++ offer no special support for iterators. In these languages and most others, iterators must be designed and encapsulated using the same mechanisms that are used for other user-defined abstractions: procedures, and packages, classes, or modules. <p> Language Features and User-Defined Iterator Abstractions Alphard [Shaw 77] and CLU [Liskov 77] have built-in iterator constructs, and Cameron <ref> [Cameron 89] </ref> proposes some elegant variations. Here we concentrate on designing iterators as user-defined abstractions in languages that do not include special constructs to support iterators, and we do not further consider possible language support for our designs. There are three reasons for this.
Reference: [Edwards 90] <author> Edwards, S., </author> <title> An Approach for Constructing Reusable Software Components in Ada, </title> <type> IDA paper P-2378, </type> <institution> Institute for Defense Analyses, </institution> <address> Alexandria, VA, </address> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: The swapping paradigm is especially valuable when dealing with potentially large and complex composite data structures that represent collections of other items just the situation in which iterators are normally used. In another recent work, Edwards <ref> [Edwards 90] </ref> proposes that the swapping paradigm might be applied to the design and implementation of iterators. His work also addresses a serious problem facing software component designers, i.e., developing interface models that simplify component composition. <p> Copying should not be inherent in the iterator itself. page 5 Unfortunately, passive iterators suffer from their own serious problems, discussed in detail by many authors <ref> [Booch 87, Bishop 90, Edwards 90] </ref>. From the standpoint of reusability they are far less flexible than active iterators. In the face of formal specification and the need for modular verification, the nature of the action procedures effects and side-effects must be formally specified and proofs modularized. <p> Indeed nothing but self-discipline prevents a client from altering a collection during iteration over it. The same is true for Bishops designs [Bishop 90]. Several methods for repairing this shortcoming are proposed by Edwards <ref> [Edwards 90] </ref>, but like Booch and Bishop he does not deal explicitly with formal specification or the need for a framework for modular verification. These objectives drive many of our design decisions and account for the differences between Edwards designs and the ones we propose here. <p> These objectives drive many of our design decisions and account for the differences between Edwards designs and the ones we propose here. Efficiency While noninterference has long been seen as a problem with iterators, Edwards <ref> [Edwards 90] </ref> was the first to recognize the inefficiency inherent in both published iterator abstractions and language constructs. All previously published designs for iterators (i.e., those before Edwards papers [Edwards 90, Edwards 91]) include a function called, e.g., Value_Of. <p> Efficiency While noninterference has long been seen as a problem with iterators, Edwards [Edwards 90] was the first to recognize the inefficiency inherent in both published iterator abstractions and language constructs. All previously published designs for iterators (i.e., those before Edwards papers <ref> [Edwards 90, Edwards 91] </ref>) include a function called, e.g., Value_Of. This returns to the client a copy of the next item from the collection. The execution-time cost of such copying is troubling if the representations of the items in the collection are themselves large, complex data structures. <p> Replacing copying by swapping is both efficient and amenable to tractable formal specification and modular proof rules, and hence to easier understanding of program behavior. This is the reason we prefer the swapping paradigm for our designs. Another efficiency issue is noted by Edwards <ref> [Edwards 90] </ref> and Lamb [Lamb 90]. Achieving optimum performance of an iterator generally requires that the implementer of an iterator have access to the underlying representation of the collection. <p> Achieving optimum performance of an iterator generally requires that the implementer of an iterator have access to the underlying representation of the collection. However, this is not essential solely to obtain the required functionality of an iterator, if the operations on the collection abstraction are sufficiently powerful <ref> [Edwards 90, Harms 91, Weide 91] </ref>. 2.2. Language Features and User-Defined Iterator Abstractions Alphard [Shaw 77] and CLU [Liskov 77] have built-in iterator constructs, and Cameron [Cameron 89] proposes some elegant variations. <p> Now both i and x act as catalyst variables. 4. Variations and Extensions There are several variations and extensions of this approach to iterators that merit discussion. We briefly mention a few of them here. The reader is referred to <ref> [Edwards 90] </ref> for a more detailed treatment. 4.1. Early Exit from Iteration A client program that exits from an iteration loop before the Iterator is empty poses no particular problems; see Appendix A for an example.
Reference: [Edwards 91] <author> Edwards, S.H., </author> <title> Common interface models for components are necessary to support composability, </title> <booktitle> Proc. 4th Ann. Workshop on Softw. Reuse, </booktitle> <address> SPC, Herndon, VA, </address> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: His work also addresses a serious problem facing software component designers, i.e., developing interface models that simplify component composition. Tracz [Tracz 89] discusses an Ada example involving what Edwards <ref> [Edwards 91] </ref> notices is an iterator. Edwards defines a common interface model as a convention, shared by designers of piece-part families and their potential clients, for how the plugs and sockets of plug-compatible software components are supposed to work. <p> Efficiency While noninterference has long been seen as a problem with iterators, Edwards [Edwards 90] was the first to recognize the inefficiency inherent in both published iterator abstractions and language constructs. All previously published designs for iterators (i.e., those before Edwards papers <ref> [Edwards 90, Edwards 91] </ref>) include a function called, e.g., Value_Of. This returns to the client a copy of the next item from the collection. The execution-time cost of such copying is troubling if the representations of the items in the collection are themselves large, complex data structures. <p> Second, even with language support one needs to define formally a common interface model for iterators if a high degree of composability of software components is to be expected <ref> [Edwards 91] </ref>. Finally, none of these language mechanisms satisfactorily addresses the problem of noninterference and the need for modular reasoning about program behavior, or the inefficiency of copying. 2.3.
Reference: [Ernst 91] <author> Ernst, G.W., Hookway, R.J., Menegay, J.A., and Ogden, W.F., </author> <title> Modular verification of Ada generics, </title> <journal> Comp. Lang. </journal> <volume> 16, 3/4 (1991), </volume> <pages> 259-280. </pages>
Reference-contexts: The crucial importance of, and difficulties with, modular verification of realistically large software systems are noted by Ernst, et al. <ref> [Ernst 91] </ref> and Hollingsworth [Hollingsworth 92], among others. <p> Proof rules should permit local verification of an implementation and its client programs, but this cannot be achieved without an assurance of noninterference, either through restriction by language syntax or by the presence of a noninterference proof obligation <ref> [Ernst 91, Hollingsworth 92] </ref>. Alphard, like other languages with iterator constructs, offers neither. In an attempt to deal with noninterference in user-defined iterator abstractions, Booch [Booch 87] and Bishop [Bishop 90] suggest classifying iterators into two categories, which Booch calls active and passive. <p> It is a disaster for formal specification and it completely thwarts modular verification <ref> [Ernst 91, Hollingsworth 92] </ref>. From the practical standpoint, this makes understanding of and informal reasoning about program behavior much harder than it should be. Replacing copying by swapping is both efficient and amenable to tractable formal specification and modular proof rules, and hence to easier understanding of program behavior. <p> They also have been used in proof systems for modular verification of implementations and clients <ref> [Ernst 91] </ref>. 3. Development of an Iterator for a Queue The goal of this section is to develop a design approach that applies to iterators for any type of collection of any type of item. Initially we create an iterator for the generic Queue type of Section 2, then generalize. <p> Its abstract behavior (including the noninterference property) is formally specified. Its implementations and clients can be verified independently (modularly, in the sense of <ref> [Ernst 91] </ref>). It can be considered a schema that can be modified in an obvious way to produce iterator abstractions for other collections, so that all iterator abstractions in a system can share a common interface model.
Reference: [Harms 91] <author> Harms, D.E., and Weide, B.W., </author> <title> Copying and swapping: influences on the design of reusable software components, </title> <journal> IEEE TSE 17, </journal> <month> 5 (May </month> <year> 1991), </year> <pages> 424-435. </pages>
Reference-contexts: This paper discusses why previously published iterator designs are unsatisfactory in several respects, and considers the combined impact of several recent advances on the potential for improvement. One such development is the proposal by Harms and Weide <ref> [Harms 91, Weide 91] </ref> that swapping should replace copying as the primary data movement mechanism in imperative programs. This approach has several advantages for designing and implementing generic reusable software components, including improved efficiency and simplified modular reasoning about program behavior. <p> This returns to the client a copy of the next item from the collection. The execution-time cost of such copying is troubling if the representations of the items in the collection are themselves large, complex data structures. As noted by Harms and Weide <ref> [Harms 91] </ref>, the typical method of avoiding this expense copying only a reference (pointer) to an item, as with the designs recommended by page 6 Booch [Booch 87] and Bishop [Bishop 90] creates even more serious problems from the standpoint of our objectives. <p> Achieving optimum performance of an iterator generally requires that the implementer of an iterator have access to the underlying representation of the collection. However, this is not essential solely to obtain the required functionality of an iterator, if the operations on the collection abstraction are sufficiently powerful <ref> [Edwards 90, Harms 91, Weide 91] </ref>. 2.2. Language Features and User-Defined Iterator Abstractions Alphard [Shaw 77] and CLU [Liskov 77] have built-in iterator constructs, and Cameron [Cameron 89] proposes some elegant variations. <p> Finally, none of these language mechanisms satisfactorily addresses the problem of noninterference and the need for modular reasoning about program behavior, or the inefficiency of copying. 2.3. The Swapping Paradigm The swapping style of software design <ref> [Harms 91, Weide 91] </ref> differs from the conventional copying style in using swapping (and the swap operator :=:) to replace copying (and the standard := operator). It is based on two observations about generic modules, e.g., Ada generic packages. <p> Harms and Weide propose detailed principles to help designers create good reusable software components in the swapping style <ref> [Harms 91, Weide 91] </ref>. For example, when designing operations on collection types such as a Queue, one should define insertion operations such as Enqueue to permit implementations that swap items into the structure. <p> Both fetch and store become secondary operations using this primitive. That is, they can be implemented with an insignificant performance penalty by layering on top of the primary swap-based operation if they are really needed and in most clients they are not <ref> [Harms 91, Weide 91] </ref>. 2.4. Formal Specification The main example we use throughout the rest of this paper is a FIFO queue abstraction. The formal specification of the Queue_Template concept (in a dialect of RESOLVE, adapted from [Harms 91, Weide 91]) is shown in Figure 1. page 8 concept Queue_Template para <p> operation if they are really needed and in most clients they are not <ref> [Harms 91, Weide 91] </ref>. 2.4. Formal Specification The main example we use throughout the rest of this paper is a FIFO queue abstraction. The formal specification of the Queue_Template concept (in a dialect of RESOLVE, adapted from [Harms 91, Weide 91]) is shown in Figure 1. page 8 concept Queue_Template para meters type Item in terf ace type Queue is modeled by STRING (Item) exemplar q in itia lly q = EMPTY operation Enqueue (alters q: Queue, consumes x: Item) e ns u re s q = #q <p> The # prefix is not needed or used in requires clauses (preconditions), where all variables denote values at the start of the operation. The parameter modes are used to simplify specification, and have nothing to do with the mechanism for passing parameters <ref> [Harms 91] </ref>. <p> Enhancement is a kind of specification or interface inheritance [LaLonde 89]. One possible implementation strategy for this enhancement is to layer the Iterator type and operations on top of the Queue_Template <ref> [Muralidharan 90, Harms 91, Weide 91] </ref> so the new code respects the Queue abstraction. Another is to directly implement all the exported types and operations from scratch. <p> Design #1 effectively forces an implementation of Start_Iterator to copy Queue q into Iterator i. The reason is that simply copying a reference to q or references to its Items creates aliases, and hence cannot preserve the independence of the abstract values of q and i <ref> [Harms 91, Hollingsworth 92] </ref>. It is impossible to prove that such an implementation is correct outside the context of a client program. The reason is that the client program might manipulate q or its Items through these aliases. <p> In such designs, the counterpart of Get_Next_Item is a function that returns a copy of the next Item in the collection. Again, a modularly verifiable implementation may not make this copy cheaply by creating an alias to the Item. These problems are intrinsic to the copying paradigm <ref> [Harms 91, Weide 91] </ref>. 3.2. Design #2 Design #1 can be changed to use the swapping paradigm. The reason for doing this is to permit an implementation that does not need to copy either the data structure that represents the Queue or any Items in it. <p> This design relieves the implementer from responsibility for copying the data structure that represents the Queue. Moving arbitrarily large data structures in this way can be accomplished in constant time with swapping <ref> [Harms 91] </ref>. The second idea is to define Get_Next_Item so its implementation does not need to return a copy of the Item to the client, but can swap it out. This is possible if the client is required to pass that Item back in the next call to Get_Next_Item. <p> However, it is important for implementing swapping in a uniformly bounded time, and for codesharing among instances of generics, as noted in <ref> [Harms 91] </ref>. page 17 9 6 90 Start_Iterator (i, q, x) Get_Next_Item (i, x) Get_Next_Item (i, x) Get_Next_Item (i, x) Finish_Iterator (i, q, x) 9 6 90 9 90 9 6 90 concrete representation of i q = 9 6 90 i = ( 9 6 90 , 0, 9 6 <p> The other changes in Design #3 support a general principle of the swapping paradigm: There are advantages in simplified reasoning about program behavior and in the performance of storage management activities if temporary variables in a program act as catalyst variables <ref> [Harms 91] </ref>. A catalyst variable is one that is necessary to carry out a computation but experiences no (net) change in value from the beginning to the end of that computation.
Reference: [Hollingsworth 91] <author> Hollingsworth, J.E., Weide, B.W., and Zweben, S.H., </author> <title> Confessions of some used program clients, </title> <booktitle> Proc. 4th Ann. Workshop on Softw. Reuse, </booktitle> <address> SPC, Herndon, VA, </address> <month> Nov. </month> <year> 1991. </year> <pages> page 27 </pages>
Reference-contexts: In subsequent discussions of efficiency we assume the traditional direct implementation, although layering is advantageous in virtually all other respects <ref> [Hollingsworth 91] </ref>. page 12 Here is a sample of client code for iteration using Design #1: Start_Iterator (i, q) while not Is_Empty (i) do Get_Next_Item (i, x) (* code to process x *) end while Finish_Iterator (i) As is evident from the sample code, Design #1 achieves noninterference by defining it
Reference: [Hollingsworth 92] <author> Hollingsworth, </author> <title> J.E., Software Component Design-for--Reuse: A Language-Independent Discipline Applied to Ada, </title> <type> Ph.D. </type> <institution> diss., Dept. of Comp. and Inf. Sci, Ohio State Univ., Columbus, </institution> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: The crucial importance of, and difficulties with, modular verification of realistically large software systems are noted by Ernst, et al. [Ernst 91] and Hollingsworth <ref> [Hollingsworth 92] </ref>, among others. <p> Proof rules should permit local verification of an implementation and its client programs, but this cannot be achieved without an assurance of noninterference, either through restriction by language syntax or by the presence of a noninterference proof obligation <ref> [Ernst 91, Hollingsworth 92] </ref>. Alphard, like other languages with iterator constructs, offers neither. In an attempt to deal with noninterference in user-defined iterator abstractions, Booch [Booch 87] and Bishop [Bishop 90] suggest classifying iterators into two categories, which Booch calls active and passive. <p> It is a disaster for formal specification and it completely thwarts modular verification <ref> [Ernst 91, Hollingsworth 92] </ref>. From the practical standpoint, this makes understanding of and informal reasoning about program behavior much harder than it should be. Replacing copying by swapping is both efficient and amenable to tractable formal specification and modular proof rules, and hence to easier understanding of program behavior. <p> Design #1 effectively forces an implementation of Start_Iterator to copy Queue q into Iterator i. The reason is that simply copying a reference to q or references to its Items creates aliases, and hence cannot preserve the independence of the abstract values of q and i <ref> [Harms 91, Hollingsworth 92] </ref>. It is impossible to prove that such an implementation is correct outside the context of a client program. The reason is that the client program might manipulate q or its Items through these aliases.
Reference: [LaLonde 89] <author> LaLonde, W.R., </author> <title> Designing families of data types using exemplars, </title> <journal> ACM Trans. on Prog. Lang. and Syst. </journal> <volume> 11, 2 (1989), </volume> <pages> 212-248. </pages>
Reference-contexts: By saying that this new concept enhances the Queue_Template concept, we mean that Queue_Iterator_Template imports and exports all the types and operations of the Queue_Template, plus those explicitly specified in the new concept. Enhancement is a kind of specification or interface inheritance <ref> [LaLonde 89] </ref>. One possible implementation strategy for this enhancement is to layer the Iterator type and operations on top of the Queue_Template [Muralidharan 90, Harms 91, Weide 91] so the new code respects the Queue abstraction. Another is to directly implement all the exported types and operations from scratch.
Reference: [Lamb 90] <author> Lamb, D.A., </author> <title> Specification of iterators, </title> <journal> IEEE TSE 16, </journal> <month> 12 (Dec. </month> <year> 1990), </year> <pages> 1352-1360. </pages>
Reference-contexts: It includes not only parameter profiles of operations, but a shared understanding of the abstract behaviors expected of those operations. A third recent development is the development of formal trace specifications for iterators by Lamb <ref> [Lamb 90] </ref>, and by Pearce and Lamb [Pearce 92]. These papers clearly explain the need for, and difficulties in, formal specification of iterators. <p> Therefore, we follow the above-cited papers in concentrating on designs for active iterators. However, we insist that clients observe the noninterference property and be modularly verifiable, which necessarily makes our designs different from previous ones. That is, like Lamb <ref> [Lamb 90] </ref> we write our formal specification so noninterference must be observed by a correct client program. A proof obligation involving noninterference is raised in the client that can and must be discharged if the client program is to be considered correct. <p> Replacing copying by swapping is both efficient and amenable to tractable formal specification and modular proof rules, and hence to easier understanding of program behavior. This is the reason we prefer the swapping paradigm for our designs. Another efficiency issue is noted by Edwards [Edwards 90] and Lamb <ref> [Lamb 90] </ref>. Achieving optimum performance of an iterator generally requires that the implementer of an iterator have access to the underlying representation of the collection. <p> Finally, mode produces means the arguments value may be changed by the call, but its value at the beginning of the call has no influence on the operations behavior. Lamb <ref> [Lamb 90] </ref>, and Pearce and Lamb [Pearce 92], use trace specifications for iterators. In this paper we use model-oriented specifications like the one above.
Reference: [Liskov 77] <author> Liskov, B, Snyder, A., Atkinson, R., and Schaffert, C., </author> <title> Abstraction mechanisms in CLU, </title> <type> CACM 20, </type> <month> 8 (Aug. </month> <year> 1977), </year> <pages> 564-576. </pages>
Reference-contexts: 1. Introduction An iterator is an abstraction that supports sequential access to the individual items of a collection, without modifying the collection. While some academic languages (most notably Alphard [Shaw 77] and CLU <ref> [Liskov 77] </ref> ) include special language constructs for iterators, and others have been proposed [Cameron 89], the most widely used modern imperative languages such as Ada and C++ offer no special support for iterators. <p> However, this is not essential solely to obtain the required functionality of an iterator, if the operations on the collection abstraction are sufficiently powerful [Edwards 90, Harms 91, Weide 91]. 2.2. Language Features and User-Defined Iterator Abstractions Alphard [Shaw 77] and CLU <ref> [Liskov 77] </ref> have built-in iterator constructs, and Cameron [Cameron 89] proposes some elegant variations. Here we concentrate on designing iterators as user-defined abstractions in languages that do not include special constructs to support iterators, and we do not further consider possible language support for our designs.
Reference: [Muralidharan 90] <author> Muralidharan, S., and Weide, B.W., </author> <title> Should data abstraction be violated to enhance software reuse? Proc. </title> <booktitle> 8th Ann. Natl. Conf. on Ada Tech., </booktitle> <address> ANCOST, </address> <publisher> Inc., </publisher> <address> Atlanta, GA, </address> <month> Feb. </month> <year> 1990, </year> <pages> pp. 515-524. </pages>
Reference-contexts: Enhancement is a kind of specification or interface inheritance [LaLonde 89]. One possible implementation strategy for this enhancement is to layer the Iterator type and operations on top of the Queue_Template <ref> [Muralidharan 90, Harms 91, Weide 91] </ref> so the new code respects the Queue abstraction. Another is to directly implement all the exported types and operations from scratch.
Reference: [Pearce 92] <author> Pearce, T.W., and Lamb, D.A., </author> <title> The property vector specification of a multiset iterator, </title> <booktitle> Proc. 14th Intl. Conf. on Softw. </booktitle> <address> Eng., ACM/IEEE, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: It includes not only parameter profiles of operations, but a shared understanding of the abstract behaviors expected of those operations. A third recent development is the development of formal trace specifications for iterators by Lamb [Lamb 90], and by Pearce and Lamb <ref> [Pearce 92] </ref>. These papers clearly explain the need for, and difficulties in, formal specification of iterators. <p> Finally, mode produces means the arguments value may be changed by the call, but its value at the beginning of the call has no influence on the operations behavior. Lamb [Lamb 90], and Pearce and Lamb <ref> [Pearce 92] </ref>, use trace specifications for iterators. In this paper we use model-oriented specifications like the one above. <p> This variation can lead to improved efficiency in some circumstances, and is most appropriate when there is no natural order of iteration, as with sets and multisets <ref> [Pearce 92] </ref>. 4.3. Other Collections To specify Iterators for collections that are not modeled as mathematical strings, we can use the same approach as suggested above to get different orders of iteration.
Reference: [Shaw 77] <author> Shaw, M., Wulf, </author> <title> W.A., and London, R.L., Abstraction and verification in Alphard: defining and specifying iteration and generators, </title> <type> CACM 20, </type> <month> 8 (Aug. </month> <year> 1977), </year> <pages> 553-564. </pages>
Reference-contexts: 1. Introduction An iterator is an abstraction that supports sequential access to the individual items of a collection, without modifying the collection. While some academic languages (most notably Alphard <ref> [Shaw 77] </ref> and CLU [Liskov 77] ) include special language constructs for iterators, and others have been proposed [Cameron 89], the most widely used modern imperative languages such as Ada and C++ offer no special support for iterators. <p> a client program to iterate over a collection without copying the data structure that represents the collection and without copying the individual items in the collection. 4 Correctness Recognition of the relationship between noninterference and the modular verification of correctness dates back to attempts to verify Alphard programs involving iterators <ref> [Shaw 77] </ref>. Programmers using one of Alphards iterator constructs are advised to consider noninterference to be a restriction on its use, but no formal proof obligation is raised during verification. <p> However, this is not essential solely to obtain the required functionality of an iterator, if the operations on the collection abstraction are sufficiently powerful [Edwards 90, Harms 91, Weide 91]. 2.2. Language Features and User-Defined Iterator Abstractions Alphard <ref> [Shaw 77] </ref> and CLU [Liskov 77] have built-in iterator constructs, and Cameron [Cameron 89] proposes some elegant variations. Here we concentrate on designing iterators as user-defined abstractions in languages that do not include special constructs to support iterators, and we do not further consider possible language support for our designs.
Reference: [Tracz 89] <author> Tracz, W., </author> <title> Parameterization: a case study, Ada Letters 9, </title> <booktitle> 4 (May/June 1989), </booktitle> <pages> 92-102. </pages>
Reference-contexts: In another recent work, Edwards [Edwards 90] proposes that the swapping paradigm might be applied to the design and implementation of iterators. His work also addresses a serious problem facing software component designers, i.e., developing interface models that simplify component composition. Tracz <ref> [Tracz 89] </ref> discusses an Ada example involving what Edwards [Edwards 91] notices is an iterator. Edwards defines a common interface model as a convention, shared by designers of piece-part families and their potential clients, for how the plugs and sockets of plug-compatible software components are supposed to work.
Reference: [Weide 91] <author> Weide, B.W., Ogden, W.F., and Zweben, S.H., </author> <title> Reusable Software Components, </title> <booktitle> in Advances in Computers, </booktitle> <volume> vol. 33, </volume> <editor> M.C. Yovits, ed., </editor> <publisher> Academic Press, </publisher> <year> 1991, </year> <pages> pp. 1-65. </pages>
Reference-contexts: This paper discusses why previously published iterator designs are unsatisfactory in several respects, and considers the combined impact of several recent advances on the potential for improvement. One such development is the proposal by Harms and Weide <ref> [Harms 91, Weide 91] </ref> that swapping should replace copying as the primary data movement mechanism in imperative programs. This approach has several advantages for designing and implementing generic reusable software components, including improved efficiency and simplified modular reasoning about program behavior. <p> Achieving optimum performance of an iterator generally requires that the implementer of an iterator have access to the underlying representation of the collection. However, this is not essential solely to obtain the required functionality of an iterator, if the operations on the collection abstraction are sufficiently powerful <ref> [Edwards 90, Harms 91, Weide 91] </ref>. 2.2. Language Features and User-Defined Iterator Abstractions Alphard [Shaw 77] and CLU [Liskov 77] have built-in iterator constructs, and Cameron [Cameron 89] proposes some elegant variations. <p> Finally, none of these language mechanisms satisfactorily addresses the problem of noninterference and the need for modular reasoning about program behavior, or the inefficiency of copying. 2.3. The Swapping Paradigm The swapping style of software design <ref> [Harms 91, Weide 91] </ref> differs from the conventional copying style in using swapping (and the swap operator :=:) to replace copying (and the standard := operator). It is based on two observations about generic modules, e.g., Ada generic packages. <p> Harms and Weide propose detailed principles to help designers create good reusable software components in the swapping style <ref> [Harms 91, Weide 91] </ref>. For example, when designing operations on collection types such as a Queue, one should define insertion operations such as Enqueue to permit implementations that swap items into the structure. <p> Both fetch and store become secondary operations using this primitive. That is, they can be implemented with an insignificant performance penalty by layering on top of the primary swap-based operation if they are really needed and in most clients they are not <ref> [Harms 91, Weide 91] </ref>. 2.4. Formal Specification The main example we use throughout the rest of this paper is a FIFO queue abstraction. The formal specification of the Queue_Template concept (in a dialect of RESOLVE, adapted from [Harms 91, Weide 91]) is shown in Figure 1. page 8 concept Queue_Template para <p> operation if they are really needed and in most clients they are not <ref> [Harms 91, Weide 91] </ref>. 2.4. Formal Specification The main example we use throughout the rest of this paper is a FIFO queue abstraction. The formal specification of the Queue_Template concept (in a dialect of RESOLVE, adapted from [Harms 91, Weide 91]) is shown in Figure 1. page 8 concept Queue_Template para meters type Item in terf ace type Queue is modeled by STRING (Item) exemplar q in itia lly q = EMPTY operation Enqueue (alters q: Queue, consumes x: Item) e ns u re s q = #q <p> Enhancement is a kind of specification or interface inheritance [LaLonde 89]. One possible implementation strategy for this enhancement is to layer the Iterator type and operations on top of the Queue_Template <ref> [Muralidharan 90, Harms 91, Weide 91] </ref> so the new code respects the Queue abstraction. Another is to directly implement all the exported types and operations from scratch. <p> In such designs, the counterpart of Get_Next_Item is a function that returns a copy of the next Item in the collection. Again, a modularly verifiable implementation may not make this copy cheaply by creating an alias to the Item. These problems are intrinsic to the copying paradigm <ref> [Harms 91, Weide 91] </ref>. 3.2. Design #2 Design #1 can be changed to use the swapping paradigm. The reason for doing this is to permit an implementation that does not need to copy either the data structure that represents the Queue or any Items in it.
Reference: [Wing 90] <author> Wing, J.M. </author> <title> A specifiers introduction to formal methods, </title> <booktitle> Computer 23, </booktitle> <address> 9 (Sept. </address> <year> 1990), </year> <pages> 8-24. page 28 </pages>
Reference-contexts: Model-oriented specifications seem wellsuited to designs based on swapping, have seen relatively widespread use in practice (e.g., Larch and Z), and are rather easily understood even by those not intimately familiar with the wide variety of formal specification techniques currently in use <ref> [Wing 90] </ref>. They also have been used in proof systems for modular verification of implementations and clients [Ernst 91]. 3.
References-found: 18

