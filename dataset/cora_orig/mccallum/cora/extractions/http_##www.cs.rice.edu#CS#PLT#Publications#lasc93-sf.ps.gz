URL: http://www.cs.rice.edu/CS/PLT/Publications/lasc93-sf.ps.gz
Refering-URL: http://www.cs.rice.edu/~cork/311web/Lectures/
Root-URL: 
Email: (sabry@cs.rice.edu)  (matthias@cs.rice.edu)  
Title: Reasoning about Programs in Continuation-Passing Style  
Author: AMR SABRY MATTHIAS FELLEISEN 
Keyword: -calculus, v -calculus, continuation-passing style, CPS transformations, inverse CPS transformations, v -C-calculus, IOCC  
Address: Houston, TX 77251-1892  
Affiliation: Department of Computer Science, Rice University,  
Note: LISP AND SYMBOLIC COMPUTATION: An International Journal, 1993 c 1993 Kluwer Academic Publishers Manufactured in The Netherlands  Contents  
Abstract: Plotkin's v -calculus for call-by-value programs is weaker than the fi-calculus for the same programs in continuation-passing style (CPS). To identify the call-by-value axioms that correspond to fi on CPS terms, we define a new CPS transformation and an inverse mapping, both of which are interesting in their own right. Using the new CPS transformation, we determine the precise language of CPS terms closed under fi-transformations, as well as the call-by-value axioms that correspond to the so-called administrative fi-reductions on CPS terms. Using the inverse mapping, we map the remaining fi and equalities on CPS terms to axioms on call-by-value terms. On the pure (constant free) set of fl-terms, the resulting set of axioms is equivalent to Moggi's computational -calculus. If the call-by-value language includes the control operators abort and call-with-current-continuation, the axioms are equivalent to an extension of Felleisen et al.'s v -C-calculus and to the equational subtheory of Talcott's logic IOCC. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Allison, L. </author> <title> A Practical Introduction to Denotational Semantics. </title> <booktitle> Volume 23 of Cambridge Computer Science Texts, </booktitle> <publisher> Cambridge University Press (1986). </publisher>
Reference-contexts: The second translation relies on Allison's <ref> [1] </ref> CPS translation that keeps the local transfer of control independent of the continuation. 38 SABRY AND FELLEISEN The proof also requires the introduction of the following axiom for conditionals: E [(if M N L)] = (if M E [N ] E [L]) (If lift ) The axiom is introduced by
Reference: 2. <author> Appel, A. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press (1992). </publisher>
Reference-contexts: The CPS intermediate language has the following desirable properties: * The language consists only of basic primitive operations and procedure applications whose semantics is independent of the parameter evaluation technique [39, 41]; many optimizations are therefore se quences of fi- and -reductions <ref> [2, 43, 46] </ref>. * It exposes the control flow of the program; complicated control facilities in the source language, e.g., exception handlers and call-with-current-continuation [40], are translated to simple procedures that manipulate their continuation arguments in non-standard ways [41, 47]. * It constitutes an abstract assembly language whose standard reduction sequence <p> flow of the program; complicated control facilities in the source language, e.g., exception handlers and call-with-current-continuation [40], are translated to simple procedures that manipulate their continuation arguments in non-standard ways [41, 47]. * It constitutes an abstract assembly language whose standard reduction sequence mimics the behavior of typical target machines <ref> [2, 3, 24, 29, 49] </ref>. The CPS transformation is a global transformation that affects every subexpression in a program. It restructures programs to the extent that many of their original aspects are unrecognizable.
Reference: 3. <author> Appel, A. and Jim, T. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Conference Record of the 16th ACM Symposium on Principles of Programming Languages (1989) 293-302. 68 SABRY AND FELLEISEN </booktitle>
Reference-contexts: Compiling with and without Continuations Many compilers for higher-order applicative languages use the continuation-passing style (CPS) transformation [21, 41] to generate an intermediate representation <ref> [3, 30, 43, 46] </ref>. <p> flow of the program; complicated control facilities in the source language, e.g., exception handlers and call-with-current-continuation [40], are translated to simple procedures that manipulate their continuation arguments in non-standard ways [41, 47]. * It constitutes an abstract assembly language whose standard reduction sequence mimics the behavior of typical target machines <ref> [2, 3, 24, 29, 49] </ref>. The CPS transformation is a global transformation that affects every subexpression in a program. It restructures programs to the extent that many of their original aspects are unrecognizable. <p> Values consist of variables and - abstractions, applications are juxtapositions of terms: M ::= V j (M M ) (fl) V ::= x j (x:M ) (Values) x 2 Vars We adopt Barendregt's <ref> [4, chapters 2, 3] </ref> notation and terminology for fl's syntax. Thus, in the abstraction (x:M ), the variable x is bound in M . Variables that are not bound by a -abstraction are free; the set of free variables in a term M is F V (M ). <p> as described in the following diagram: * N 7! v - * . . . . * * * * * * N : K 3 . . . . . . 5 Improved by Robert Harper. 6 The function F 2 eliminates more administrative than other CPS transforma tions <ref> [3, 13, 30, 43, 46] </ref>. For example, applying F2 to (((x:y:x) a) b) yields k:((x:((y:kx) b)) a).
Reference: 4. <author> Barendregt, H. P. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <booktitle> Volume 103 of Studies in Logic and the Foundations of Mathematics, </booktitle> <pages> North-Holland, </pages> <note> revised edition (1984). </note>
Reference-contexts: Values consist of variables and - abstractions, applications are juxtapositions of terms: M ::= V j (M M ) (fl) V ::= x j (x:M ) (Values) x 2 Vars We adopt Barendregt's <ref> [4, chapters 2, 3] </ref> notation and terminology for fl's syntax. Thus, in the abstraction (x:M ), the variable x is bound in M . Variables that are not bound by a -abstraction are free; the set of free variables in a term M is F V (M ). <p> X T ` t 1 = t 2 if and only if X S ` g (t 1 ) = g (t 2 ). The above correspondence is similar to the correspondence between the -calculus and combinatory logic <ref> [4, 10] </ref>. In the third clause, the left-to-right implication refers to the soundness of the calculus X S , and the right-to-left implication refers the completeness of the calculus X S (relative to X T , f , and g). <p> our universe of discourse consists of all terms that contribute to the proofs of equations like: fi ` F [[M ]] = F [[N ]]: 4 In Reynolds's transformation, the continuation is the second argument to a procedure. 12 SABRY AND FELLEISEN Because the notion of reduction fi is CR <ref> [4] </ref>, it suffices to consider equations of the form: fi ` F [[M ]] !! P: Hence, the universe of discourse for CPS terms is the set: fP j 9M 2 fl: fi ` F [[M ]] !! P g: Unfortunately, this set includes a large of terms that have no <p> Proposition 2 The relation F 2 is a total function from fl to fl. 14 SABRY AND FELLEISEN Proof: 5 It is sufficient to show that F [[M ]] has a unique fi-normal form. The fi-reductions starting with F [[M ]] are a special kind of reductions called developments <ref> [4, section 11.2] </ref>. It follows that F [[M ]] has a unique fi-normal form [4, corollary 11.2.24]. Moreover, a fl-term has a fi-normal form if and only it has a fi-normal form [4, corollary 15.1.5]. It follows that F [[M ]] has a unique fi-normal form. <p> The fi-reductions starting with F [[M ]] are a special kind of reductions called developments [4, section 11.2]. It follows that F [[M ]] has a unique fi-normal form <ref> [4, corollary 11.2.24] </ref>. Moreover, a fl-term has a fi-normal form if and only it has a fi-normal form [4, corollary 15.1.5]. It follows that F [[M ]] has a unique fi-normal form. <p> The fi-reductions starting with F [[M ]] are a special kind of reductions called developments [4, section 11.2]. It follows that F [[M ]] has a unique fi-normal form [4, corollary 11.2.24]. Moreover, a fl-term has a fi-normal form if and only it has a fi-normal form <ref> [4, corollary 15.1.5] </ref>. It follows that F [[M ]] has a unique fi-normal form. In other words, the function F 2 specifies a CPS transformation that produces terms without any administrative redexes. 6 The proposition also establishes that administrative reductions can be performed in any order without affecting the result.
Reference: 5. <author> Bartley, D. H. and Jensen, J. C. </author> <title> The implementation of PC Scheme. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1986) 86-93. </booktitle>
Reference-contexts: The transformation might even obscure the analysis of optimizations that rely on execution paths having matching call/return pairs [Private Communication, Hans Boehm, October 1992]. For these reasons and others, a fair number of compilers (usually called direct compilers) do not rely on the CPS intermediate representation <ref> [5, 6, 28, 32] </ref>. The choice of compilation strategy would not be significant if both classes of compilers performed the same optimizations. However for the important class of optimizations that is expressible in the framework of the -calculus, CPS compilers have an advantage.
Reference: 6. <author> Boehm, H.-J. and Demers, A. </author> <title> Implementing Russel. </title> <booktitle> In Proceedings of the ACM Sigplan Symposium on Compiler Construction, Sigplan Notices, </booktitle> <volume> 21, </volume> <month> 7 </month> <year> (1986) </year> <month> 186-195. </month>
Reference-contexts: The transformation might even obscure the analysis of optimizations that rely on execution paths having matching call/return pairs [Private Communication, Hans Boehm, October 1992]. For these reasons and others, a fair number of compilers (usually called direct compilers) do not rely on the CPS intermediate representation <ref> [5, 6, 28, 32] </ref>. The choice of compilation strategy would not be significant if both classes of compilers performed the same optimizations. However for the important class of optimizations that is expressible in the framework of the -calculus, CPS compilers have an advantage.
Reference: 7. <author> Bondorf, A. </author> <title> Improving binding times without explicit CPS-conversion. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1992) 1-10. </booktitle>
Reference-contexts: For example, direct compilers like Chez Scheme [28] or Zinc [32] can benefit by including the reductions CS in their basic repertoire of optimizations. Similarly, partial evaluators that use transformations like fi lift and fi 0 produce residual programs of better quality <ref> [7] </ref>. Finally, the set of axioms CS could be the base of an expression simplifier (for compilers and other tools) extending that of Galbiati and Talcott [25].
Reference: 8. <author> Clinger, W., Friedman, D., and Wand, M. </author> <title> A scheme for a higher-level semantic algebra. </title> <editor> In Reynolds, J. and Nivat, M., editors, </editor> <booktitle> Algebraic Methods in Semantics, </booktitle> <address> Cambridge University Press (1985) 237-250. </address>
Reference-contexts: to another sequence of reductions in the other calculus. 28 SABRY AND FELLEISEN the translation of these values into CPS form and use this translation as their formal semantics. 10 The extensions to C k (or F ) consist of two additional clauses to the function (or F v ) <ref> [8] </ref>: [[callcc]] = (k:u:((u k) d:k)) [[A]] = (k:x:x) The CPS transform of callcc is a procedure that expects a continuation k and an argument u. The non-standard manipulation of the continuation is manifest in the second argument to u, which is a procedural abstraction of the continuation.
Reference: 9. <author> Crank, E. and Felleisen, M. </author> <title> Parameter-passing and the lambda calculus. </title> <booktitle> In Conference Record of the 18th ACM Symposium on Principles of Programming Languages (1991) 233-244. </booktitle>
Reference-contexts: (x; V 1 )g:E [(setref! x V 2 )] = [ f (x; V 2 )g:E [V 2 ] (setref ) 1 : 2 :M = 1 [ 2 :M (ref [ ) The first three sets of axioms are straightforward; the last set specifies the semantics of reference cells <ref> [9, 33] </ref>. The combination of the equational theory fi v XC with the new axioms F results in an inconsistent equational system due to v .
Reference: 10. <author> Curry, H. B. and Feys, R. </author> <title> Combinatory Logic, Volume I. </title> <publisher> North-Holland, </publisher> <address> Amsterdam (1958). </address>
Reference-contexts: X T ` t 1 = t 2 if and only if X S ` g (t 1 ) = g (t 2 ). The above correspondence is similar to the correspondence between the -calculus and combinatory logic <ref> [4, 10] </ref>. In the third clause, the left-to-right implication refers to the soundness of the calculus X S , and the right-to-left implication refers the completeness of the calculus X S (relative to X T , f , and g).
Reference: 11. <author> Danvy, O. </author> <title> Back to direct style. Science of Computer Programming (1993). To appear. Preliminary version in: </title> <booktitle> Proceedings of the 4th Eu-ropean Symposium on Programming, 1992. Lecture Notes in Computer Science, </booktitle> <volume> 582, </volume> <publisher> Springer Verlag. </publisher>
Reference-contexts: The new transformation provides a simple characterization of a CPS language that is closed under fi-reductions. It also identifies a subset A of the call-by-value axioms X . 2. Second, we develop an "inverse" transformation that maps canonical CPS programs back to the original language. As Danvy and Lawall <ref> [11, 14] </ref> convincingly argue, this translation from CPS to di rect terms is useful in its own right. 3. Finally, by studying the connection between the CPS transformation and the inverse mapping, we systematically derive the remaining axioms in the set X.
Reference: 12. <author> Danvy, O. and Filinski, A. </author> <title> Abstracting control. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1990) 151-160. </booktitle>
Reference-contexts: However, we do not include prompt in our language for two reasons. First, current language implementations do not include such facilities. Second, the CPS translation of prompt generates expressions that are no longer independent of the timing of parameter evaluation <ref> [12, 20] </ref>. As a consequence, we can associate two different semantics with the CPS language: a call-by-value semantics which is the classic semantics for control delimiters [13, 15], and a call-by-name semantics which yields a lazy prompt .
Reference: 13. <author> Danvy, O. and Filinski, A. </author> <title> Representing control: A study of the CPS transformation. </title> <booktitle> Mathematical Structures in Computer Science, </booktitle> <volume> 2, </volume> <month> 4 </month> <year> (1992) </year> <month> 361-391. </month>
Reference-contexts: Second, the CPS translation of prompt generates expressions that are no longer independent of the timing of parameter evaluation [12, 20]. As a consequence, we can associate two different semantics with the CPS language: a call-by-value semantics which is the classic semantics for control delimiters <ref> [13, 15] </ref>, and a call-by-name semantics which yields a lazy prompt . <p> as described in the following diagram: * N 7! v - * . . . . * * * * * * N : K 3 . . . . . . 5 Improved by Robert Harper. 6 The function F 2 eliminates more administrative than other CPS transforma tions <ref> [3, 13, 30, 43, 46] </ref>. For example, applying F2 to (((x:y:x) a) b) yields k:((x:((y:kx) b)) a). <p> For example, applying F2 to (((x:y:x) a) b) yields k:((x:((y:kx) b)) a). For the same example, both Steele's Rabbit transformation [46] and the Danvy/Filinski transformation <ref> [13] </ref> yield the term: k:((xk 1 :(k 1 yk 2 :k 2 x)) a (m:mbk)): Even though this term only contains source redexes, we could still optimize it without eliminating source redexes: fi ` k:((xk 1 :(k 1 yk 2 :k 2 x)) a (m:mbk)) = k:((m:mbk) (yk 2 :k 2
Reference: 14. <author> Danvy, O. and Lawall, J. </author> <title> Back to direct style II: First-class continuations. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1992) 299-310. </booktitle>
Reference-contexts: The new transformation provides a simple characterization of a CPS language that is closed under fi-reductions. It also identifies a subset A of the call-by-value axioms X . 2. Second, we develop an "inverse" transformation that maps canonical CPS programs back to the original language. As Danvy and Lawall <ref> [11, 14] </ref> convincingly argue, this translation from CPS to di rect terms is useful in its own right. 3. Finally, by studying the connection between the CPS transformation and the inverse mapping, we systematically derive the remaining axioms in the set X. <p> Second, a binding of a continuation k in the CPS language corresponds to a capture of the continuation k in the source language. Finally, every continuation is explicitly invoked. The last two changes exploit an idea due to Danvy and Lawall <ref> [14] </ref>. 11 The discovery of the call-by-value axioms that correspond to fi-reductions on CPS terms proceeds in the same manner as for the pure language. The resulting axioms consist of the axioms X for the pure language and the control specific axioms in Figure 4. <p> The set of axioms C current ; C elim ; C lift ; C abort and Abort constitute the control-specific axioms of the v -C-calculus [18, 19]. The full theory fi v XC 11 Danvy and Lawall <ref> [14] </ref> perform a counting analysis to determine whether a continuation is used in a non-standard way and include a callcc only when necessary. This analysis is unnecessary for our purposes.
Reference: 15. <author> Felleisen, M. </author> <title> The theory and practice of first-class prompts. </title> <booktitle> In Conference Record of the 15th ACM Symposium on Principles of Programming Languages (1988) 180-190. REASONING ABOUT PROGRAMS IN CONTINUATION-PASSING STYLE 69 </booktitle>
Reference-contexts: 27]. 2 1 For call-by-name languages, the reductions fi are valid in both the source language and the CPS language and the CPS translation does not create any new opportunities for equational reasoning [39, page 153]. 2 The CPS framework can also express a control delimiting facility [44], e.g., prompt <ref> [15] </ref>. However, we do not include prompt in our language for two reasons. First, current language implementations do not include such facilities. Second, the CPS translation of prompt generates expressions that are no longer independent of the timing of parameter evaluation [12, 20]. <p> Second, the CPS translation of prompt generates expressions that are no longer independent of the timing of parameter evaluation [12, 20]. As a consequence, we can associate two different semantics with the CPS language: a call-by-value semantics which is the classic semantics for control delimiters <ref> [13, 15] </ref>, and a call-by-name semantics which yields a lazy prompt .
Reference: 16. <author> Felleisen, M. and Friedman, D. P. </author> <title> Control operators, the SECD-machine, and the -calculus. </title> <editor> In Wirsing, M., editor, </editor> <booktitle> Formal Description of Programming Concepts-III, </booktitle> <publisher> North-Holland (1986) 193-217. </publisher>
Reference-contexts: Typically, eval is defined via an abstract machine that manipulates abstract counterparts to hardware stacks, stores, registers, etc. Examples are the SECD machine [31] and the CEK machine <ref> [16] </ref>. An equivalent method for specifying the semantics is based on the Curry-Feys Standard Reduction Theorem [16, 39]. The Standard Reduction Theorem defines a partial function, 7!, from programs to programs that corresponds to a single evaluation step of an abstract machine for fl. <p> Typically, eval is defined via an abstract machine that manipulates abstract counterparts to hardware stacks, stores, registers, etc. Examples are the SECD machine [31] and the CEK machine [16]. An equivalent method for specifying the semantics is based on the Curry-Feys Standard Reduction Theorem <ref> [16, 39] </ref>. The Standard Reduction Theorem defines a partial function, 7!, from programs to programs that corresponds to a single evaluation step of an abstract machine for fl. <p> The special contexts are evaluation contexts and have the following definition for the call-by-value and call-by-name variants of fl, respectively <ref> [16] </ref>: E v ::= [ ] j (V E v ) j (E v M ) Conceptually, the hole of an evaluation context ([ ]) points to the current instruction, which must be a fi v or fi redex. <p> The decomposition of M into E [(V N )] where (V N ) is a redex means that the current instruction is (V N ) and that the rest of the computation, the continuation, is E <ref> [16] </ref>. <p> C k [[V ]] = (k [[V ]]) [[x]] = x [[callcc]] = k:u:((u k) d:k) [[A]] = k:x:x K k [[E [(V [ ])]]] = ([[V ]] K k [[E]]) 10 Felleisen et al. <ref> [16, 18, 19] </ref> and Talcott [48] use alternative definitions that do not rely on the CPS transformation. REASONING ABOUT PROGRAMS IN CONTINUATION-PASSING STYLE 29 Besides the extensions to callcc and A, the transformation differs from the function in Definition 5 in the following aspect.
Reference: 17. <author> Felleisen, M. and Friedman, D. P. </author> <title> A syntactic theory of sequential state. </title> <journal> Theoretical Computer Science, </journal> <volume> 69, </volume> <month> 3 </month> <year> (1989) </year> <month> 243-287. </month> <title> Preliminary version in: </title> <booktitle> Conference Record of the 14th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1987. </year>
Reference-contexts: For clarity, the redex is surrounded by a box. During the transformation, set! is treated as a free variable. Alternatively, we could use the axioms of the v -S-calculus <ref> [17] </ref>, but for this example, they are superfluous. (define make-coroutine (lambda (f ) (callcc (lambda (maker ) (let ([LCS 'any]) (let ([resume (lambda (dest val ) (callcc (lambda (k ) (set! LCS k ) (dest val ))))]) (f resume (resume maker (lambda (v ) (LCS v )))) (error "fell off end")))))
Reference: 18. <author> Felleisen, M. and Hieb, R. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <booktitle> Theoretical Computer Science, </booktitle> <month> 102 </month> <year> (1992) </year> <month> 235-271. </month> <type> Technical Report 89-100, </type> <institution> Rice University. </institution>
Reference-contexts: While CPS compilers can use the full -calculus reductions to perform optimizations, direct compilers can apparently only rely on weaker calculi like the v -calculus [39] and the v -C-calculus <ref> [18, 19] </ref>. Naturally we ask: what optimizations do CPS compilers perform that are not also performed by direct compilers? Or in technical terms, what set of call-by-value axioms corresponds to fi-reductions on CPS terms. <p> In order to re-establish the cor respondence between the source and CPS calculi, we extend both the CPS transformation and its inverse and proceed in the same way as for the pure language. The resulting calculus includes the reductions of the v -C-calculus <ref> [18, 19] </ref> and is equivalent to the equational subtheory of the logic IOCC (Impredicative theory of Operations, Control abstractions, and Classes) [48]. Finally, since Lisp and similar languages include more facilities than just procedures and control operators, we consider the language Core Scheme, which also includes constants, conditionals, and assignments. <p> C k [[V ]] = (k [[V ]]) [[x]] = x [[callcc]] = k:u:((u k) d:k) [[A]] = k:x:x K k [[E [(V [ ])]]] = ([[V ]] K k [[E]]) 10 Felleisen et al. <ref> [16, 18, 19] </ref> and Talcott [48] use alternative definitions that do not rely on the CPS transformation. REASONING ABOUT PROGRAMS IN CONTINUATION-PASSING STYLE 29 Besides the extensions to callcc and A, the transformation differs from the function in Definition 5 in the following aspect. <p> The set of axioms C current ; C elim ; C lift ; C abort and Abort constitute the control-specific axioms of the v -C-calculus <ref> [18, 19] </ref>. The full theory fi v XC 11 Danvy and Lawall [14] perform a counting analysis to determine whether a continuation is used in a non-standard way and include a callcc only when necessary. This analysis is unnecessary for our purposes.
Reference: 19. <author> Felleisen, M., Friedman, D. P., Kohlbecker, E., and Duba, B. </author> <title> A syntactic theory of sequential control. </title> <journal> Theoretical Computer Science, </journal> <volume> 52, </volume> <month> 3 </month> <year> (1987) </year> <month> 205-237. </month> <title> Preliminary version: Reasoning with Continuations, </title> <booktitle> in Proceedings of the 1st IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1986. </year>
Reference-contexts: While CPS compilers can use the full -calculus reductions to perform optimizations, direct compilers can apparently only rely on weaker calculi like the v -calculus [39] and the v -C-calculus <ref> [18, 19] </ref>. Naturally we ask: what optimizations do CPS compilers perform that are not also performed by direct compilers? Or in technical terms, what set of call-by-value axioms corresponds to fi-reductions on CPS terms. <p> In order to re-establish the cor respondence between the source and CPS calculi, we extend both the CPS transformation and its inverse and proceed in the same way as for the pure language. The resulting calculus includes the reductions of the v -C-calculus <ref> [18, 19] </ref> and is equivalent to the equational subtheory of the logic IOCC (Impredicative theory of Operations, Control abstractions, and Classes) [48]. Finally, since Lisp and similar languages include more facilities than just procedures and control operators, we consider the language Core Scheme, which also includes constants, conditionals, and assignments. <p> C k [[V ]] = (k [[V ]]) [[x]] = x [[callcc]] = k:u:((u k) d:k) [[A]] = k:x:x K k [[E [(V [ ])]]] = ([[V ]] K k [[E]]) 10 Felleisen et al. <ref> [16, 18, 19] </ref> and Talcott [48] use alternative definitions that do not rely on the CPS transformation. REASONING ABOUT PROGRAMS IN CONTINUATION-PASSING STYLE 29 Besides the extensions to callcc and A, the transformation differs from the function in Definition 5 in the following aspect. <p> The set of axioms C current ; C elim ; C lift ; C abort and Abort constitute the control-specific axioms of the v -C-calculus <ref> [18, 19] </ref>. The full theory fi v XC 11 Danvy and Lawall [14] perform a counting analysis to determine whether a continuation is used in a non-standard way and include a callcc only when necessary. This analysis is unnecessary for our purposes.
Reference: 20. <author> Felleisen, M., Wand, M., Friedman, </author> <title> D.P., and Duba, B.F. Abstract continuations: A mathematical semantics for handling full functional jumps. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1988) 52-62. </booktitle>
Reference-contexts: However, we do not include prompt in our language for two reasons. First, current language implementations do not include such facilities. Second, the CPS translation of prompt generates expressions that are no longer independent of the timing of parameter evaluation <ref> [12, 20] </ref>. As a consequence, we can associate two different semantics with the CPS language: a call-by-value semantics which is the classic semantics for control delimiters [13, 15], and a call-by-name semantics which yields a lazy prompt .
Reference: 21. <author> Fischer, M. </author> <title> Lambda calculus schemata. </title> <booktitle> In Proceedings of the ACM Conference on Proving Assertions About Programs, Sigplan Notices, </booktitle> <volume> 7, </volume> <month> 1 </month> <year> (1972) </year> <month> 104-109. </month>
Reference-contexts: Compiling with and without Continuations Many compilers for higher-order applicative languages use the continuation-passing style (CPS) transformation <ref> [21, 41] </ref> to generate an intermediate representation [3, 30, 43, 46]. <p> The first subsection briefly reviews the original encoding of the CPS transformation. In the second subsection, we analyze the universe of CPS terms and the so-called administrative CPS reductions. 3.1. The Original Encoding Fischer <ref> [21] </ref> studied two implementation strategies for fl: a heap-based retention strategy in which all variable bindings are retained until no longer needed, and a stack-based deletion strategy in which variable bindings are destroyed when control leaves the procedure (or block) in which they were created. <p> He concluded that no real power is lost in restricting oneself to a deletion strategy implementation, for any program can be translated into an equivalent one which will work correctly under such an imple mentation <ref> [21, page 104] </ref>. 3 The origin of the concept of "continuation" can be traced back to A. van Wijn-gaarden [45] who defined a source to source transformation that eliminates jumps (goto instructions) from a program in favor of procedures that never return.
Reference: 22. <author> Flanagan, C., Sabry, A., Duba, B. F., and Felleisen, M. </author> <title> The essence of compiling with continuations. </title> <booktitle> In Proceedings of the ACM Sigplan Conference on Programming Language Design and Implementation (1993). To appear. </booktitle>
Reference-contexts: In fact, we have established that the code generators of typical CPS compilers perform an implicit inverse CPS transformation, and that the true intermediate representation of a typical CPS compiler is the subset of source terms in fi lift fi flat -normal form <ref> [22] </ref>. Furthermore, although the literature contains claims that the CPS framework improves the accuracy of data flow analyzers [38], we conjecture that the observed improvements are orthogonal to the "passing of continuations" but are rather side-effects of the axioms CS .
Reference: 23. <author> Friedman, D. P., Haynes, C.T., and Kohlbecker, E. </author> <title> Programming with continuations. </title> <editor> In Pepper, P., editor, </editor> <title> Program Transformations and Programming Environments, </title> <publisher> Springer-Verlag (1985) 263-274. </publisher>
Reference-contexts: To this end, we extend our language with two typical control operators expressible in the CPS framework: abort and call-with-current-continuation. These operators suffice to express a wide variety of control abstractions such as error exits, jumps, intelligent backtracking, coroutines, and exception handling <ref> [23, 27] </ref>. 2 1 For call-by-name languages, the reductions fi are valid in both the source language and the CPS language and the CPS translation does not create any new opportunities for equational reasoning [39, page 153]. 2 The CPS framework can also express a control delimiting facility [44], e.g., prompt
Reference: 24. <author> Friedman, D. P., Wand, M., and Haynes, </author> <title> C.T. Essentials of Programming Languages. </title> <publisher> The MIT Press (1992). </publisher>
Reference-contexts: flow of the program; complicated control facilities in the source language, e.g., exception handlers and call-with-current-continuation [40], are translated to simple procedures that manipulate their continuation arguments in non-standard ways [41, 47]. * It constitutes an abstract assembly language whose standard reduction sequence mimics the behavior of typical target machines <ref> [2, 3, 24, 29, 49] </ref>. The CPS transformation is a global transformation that affects every subexpression in a program. It restructures programs to the extent that many of their original aspects are unrecognizable. <p> The first three cases in the translation of evaluation contexts to continuations have the same intuitive explanation. In the last 7 The CPS transformation C k is, in spirit, similar to the CPS transformation by Fried-man, Wand, and Haynes <ref> [24, chapter 8] </ref>, but differs significantly in its formal part. REASONING ABOUT PROGRAMS IN CONTINUATION-PASSING STYLE 17 case E [([ ] M )], the term in function position is the result of an intermediate computation.
Reference: 25. <author> Galbiati, L. and Talcott, C. L. </author> <title> A simplifier for untyped lambda expressions. </title> <booktitle> In Proceedings Conditional Term Rewriting Systems, Lecture Notes in Computer Science, </booktitle> <month> 516 </month> <year> (1990) </year> <month> 342-353. </month>
Reference-contexts: Similarly, partial evaluators that use transformations like fi lift and fi 0 produce residual programs of better quality [7]. Finally, the set of axioms CS could be the base of an expression simplifier (for compilers and other tools) extending that of Galbiati and Talcott <ref> [25] </ref>. Our result questions the practice of transforming programs to CPS in order to simplify and improve code generators, partial evaluators, data flow analyzers, and other tools.
Reference: 26. <author> Griffin, T.G. </author> <title> A formulae-as-types notion of control. </title> <booktitle> In Conference Record of the 17th ACM Symposium on Principles of Programming Languages (1990) 47-58. 70 SABRY AND FELLEISEN </booktitle>
Reference-contexts: [(V V )] V ::= x j (x:M ) j callcc j A E ::= [ ] j (V E) j (E M ) Instead of providing a formal semantics for callcc and A in terms of standard reductions, we follow the more traditional route and immediately specify 9 Griffin <ref> [26] </ref> established that, in the presence of control operators similar to A and callcc, standard reductions on source terms correspond to standard reductions on CPS terms.
Reference: 27. <author> Haynes, C.T., Friedman, D. P., and Wand, M. </author> <title> Obtaining coroutines from continuations. </title> <journal> Journal of Computer Languages (Pergamon Press), </journal> <volume> 11, </volume> <month> 3/4 </month> <year> (1986) </year> <month> 143-153. </month>
Reference-contexts: To this end, we extend our language with two typical control operators expressible in the CPS framework: abort and call-with-current-continuation. These operators suffice to express a wide variety of control abstractions such as error exits, jumps, intelligent backtracking, coroutines, and exception handling <ref> [23, 27] </ref>. 2 1 For call-by-name languages, the reductions fi are valid in both the source language and the CPS language and the CPS translation does not create any new opportunities for equational reasoning [39, page 153]. 2 The CPS framework can also express a control delimiting facility [44], e.g., prompt <p> (v ) (LCS v )))) (error "fell off end"))))))) (define make-coroutine (lambda (f ) (letrec ([LCS (lambda (x ) (f (lambda (dest val ) (callcc (lambda (k ) (set! LCS k ) (dest val )))) x ) (error "fell off end"))]) (lambda (v ) (LCS v ))))) Friedman, and Wand <ref> [27] </ref>, is the result of clear and well-understood design steps but is far more complicated than necessary. The initialization part of the coroutine is non-trivial: it involves capturing a continuation and an artificial use of the procedure resume that assigns the proper value to the local control state (LCS ). <p> ) M ) where d 62 F V (N ) REASONING ABOUT PROGRAMS IN CONTINUATION-PASSING STYLE 41 (x:M N ) = (x:(begin M N )) (letrec ([x (y:M )]) N ) df (begin (set! x (y:M )) N )) The original definition of coroutines using first-class continuations is the following <ref> [27] </ref>: (define make-coroutine (lambda (f ) (callcc (lambda (maker ) (let ([LCS 'any]) (let ([resume (lambda (dest val ) (callcc (lambda (k ) (set! LCS k ) (dest val ))))]) (f resume (resume maker (lambda (v ) (LCS v )))) (error "fell off end"))))))) Intuitively, the procedure make-coroutine accepts an argument
Reference: 28. <author> Hieb, R., Dybvig, K., and Bruggeman, C. </author> <title> Representing control in the presence of first-class continuations. </title> <booktitle> In Proceedings of the ACM Sig-plan Conference on Programming Language Design and Implementation (1990) 66-77. </booktitle>
Reference-contexts: The transformation might even obscure the analysis of optimizations that rely on execution paths having matching call/return pairs [Private Communication, Hans Boehm, October 1992]. For these reasons and others, a fair number of compilers (usually called direct compilers) do not rely on the CPS intermediate representation <ref> [5, 6, 28, 32] </ref>. The choice of compilation strategy would not be significant if both classes of compilers performed the same optimizations. However for the important class of optimizations that is expressible in the framework of the -calculus, CPS compilers have an advantage. <p> Consequently, any CPS-based programming tool that performs sequences of fi-reductions can be substituted by an equivalent tool that does not require an explicit conversion to CPS. The applications to compilers, partial evaluators, and other transformation systems are numerous. For example, direct compilers like Chez Scheme <ref> [28] </ref> or Zinc [32] can benefit by including the reductions CS in their basic repertoire of optimizations. Similarly, partial evaluators that use transformations like fi lift and fi 0 produce residual programs of better quality [7].
Reference: 29. <author> Kelsey, R. and Hudak, P. </author> <title> Realistic compilation by program transformation. </title> <booktitle> In Conference Record of the 16th ACM Symposium on Principles of Programming Languages (1989) 281-292. </booktitle>
Reference-contexts: flow of the program; complicated control facilities in the source language, e.g., exception handlers and call-with-current-continuation [40], are translated to simple procedures that manipulate their continuation arguments in non-standard ways [41, 47]. * It constitutes an abstract assembly language whose standard reduction sequence mimics the behavior of typical target machines <ref> [2, 3, 24, 29, 49] </ref>. The CPS transformation is a global transformation that affects every subexpression in a program. It restructures programs to the extent that many of their original aspects are unrecognizable.
Reference: 30. <author> Kranz, D., Kelsey, R., Rees, J., Hudak, P., Philbin, J., and Adams, N. </author> <title> Orbit: An optimizing compiler for Scheme. </title> <booktitle> In Proceedings of the ACM Sigplan Symposium on Compiler Construction, Sigplan Notices, </booktitle> <volume> 21, </volume> <month> 7 </month> <year> (1986) </year> <month> 219-233. </month>
Reference-contexts: Compiling with and without Continuations Many compilers for higher-order applicative languages use the continuation-passing style (CPS) transformation [21, 41] to generate an intermediate representation <ref> [3, 30, 43, 46] </ref>. <p> as described in the following diagram: * N 7! v - * . . . . * * * * * * N : K 3 . . . . . . 5 Improved by Robert Harper. 6 The function F 2 eliminates more administrative than other CPS transforma tions <ref> [3, 13, 30, 43, 46] </ref>. For example, applying F2 to (((x:y:x) a) b) yields k:((x:((y:kx) b)) a).
Reference: 31. <author> Landin, P.J. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer Journal, </journal> <volume> 6, </volume> <month> 4 </month> <year> (1964) </year> <month> 308-320. </month>
Reference-contexts: A program is a term with no free variables and, in practical languages, an answer is a member of the syntactic category of values. Typically, eval is defined via an abstract machine that manipulates abstract counterparts to hardware stacks, stores, registers, etc. Examples are the SECD machine <ref> [31] </ref> and the CEK machine [16]. An equivalent method for specifying the semantics is based on the Curry-Feys Standard Reduction Theorem [16, 39]. The Standard Reduction Theorem defines a partial function, 7!, from programs to programs that corresponds to a single evaluation step of an abstract machine for fl.
Reference: 32. <author> Leroy, X. </author> <title> The Zinc Experiment: An Economical Implementation of the ML Language. </title> <type> Technical Report 117, </type> <note> INRIA (1990). </note>
Reference-contexts: The transformation might even obscure the analysis of optimizations that rely on execution paths having matching call/return pairs [Private Communication, Hans Boehm, October 1992]. For these reasons and others, a fair number of compilers (usually called direct compilers) do not rely on the CPS intermediate representation <ref> [5, 6, 28, 32] </ref>. The choice of compilation strategy would not be significant if both classes of compilers performed the same optimizations. However for the important class of optimizations that is expressible in the framework of the -calculus, CPS compilers have an advantage. <p> Consequently, any CPS-based programming tool that performs sequences of fi-reductions can be substituted by an equivalent tool that does not require an explicit conversion to CPS. The applications to compilers, partial evaluators, and other transformation systems are numerous. For example, direct compilers like Chez Scheme [28] or Zinc <ref> [32] </ref> can benefit by including the reductions CS in their basic repertoire of optimizations. Similarly, partial evaluators that use transformations like fi lift and fi 0 produce residual programs of better quality [7].
Reference: 33. <author> Mason, I. and Talcott, C. L. </author> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 1, </volume> <month> 3 (July </month> <year> 1991) </year> <month> 287-327. </month>
Reference-contexts: (x; V 1 )g:E [(setref! x V 2 )] = [ f (x; V 2 )g:E [V 2 ] (setref ) 1 : 2 :M = 1 [ 2 :M (ref [ ) The first three sets of axioms are straightforward; the last set specifies the semantics of reference cells <ref> [9, 33] </ref>. The combination of the equational theory fi v XC with the new axioms F results in an inconsistent equational system due to v .
Reference: 34. <author> Mazurkiewicz, A.W. </author> <title> Proving algorithms by tail functions. </title> <journal> Information and Control, </journal> <month> 18 </month> <year> (1971) </year> <month> 220-226. </month>
Reference-contexts: The resulting calculus is a variant of Moggi's untyped computational -calculus [36]. A complete treatment of the relationship between programs and their CPS transforms must also analyze a language with control operators since these are the language facilities for which continuations were conceived <ref> [34, 37, 41, 47] </ref>. To this end, we extend our language with two typical control operators expressible in the CPS framework: abort and call-with-current-continuation.
Reference: 35. <author> Meyer, A. R. and Wand, M. </author> <title> Continuation semantics in typed lambda-calculi. </title> <booktitle> In Proceedings Workshop Logics of Programs, Lecture Notes in Computer Science, </booktitle> <month> 193 </month> <year> (1985) </year> <month> 219-224. </month>
Reference-contexts: The rightmost column includes a check mark if the correspondence holds for the simply typed variant of the language. For the simply typed languages, our calculi are also "semantically complete" with respect to denotational CPS models <ref> [35] </ref>.
Reference: 36. <author> Moggi, E. </author> <title> Computational lambda-calculus and monads. </title> <note> In Proceedings of the 4th IEEE Symposium on Logic in Computer Science (1989) 14-23. Also appeared as: </note> <institution> LFCS Report ECS-LFCS-88-86, University of Edinburgh, </institution> <year> 1988. </year>
Reference-contexts: Finally, by studying the connection between the CPS transformation and the inverse mapping, we systematically derive the remaining axioms in the set X. The resulting calculus is a variant of Moggi's untyped computational -calculus <ref> [36] </ref>. A complete treatment of the relationship between programs and their CPS transforms must also analyze a language with control operators since these are the language facilities for which continuations were conceived [34, 37, 41, 47]. <p> F V (L) (fi flat ) ((x:x) M ) ! M (fi id ) df = f v ; fi lift ; fi flat ; fi id ; fi g. axioms fi v X corresponds to Moggi's untyped computational -calculus as it appeared in his original Edinburgh LFCS Technical Report <ref> [36] </ref>. 24 SABRY AND FELLEISEN The Completeness Lemma summarizes the connection between the no tions of reductions on cps (fl) and the new reductions. Lemma 12 (Completeness) Let P 2 cps (fl). 1.
Reference: 37. <author> Morris, L. </author> <title> The next 700 formal language descriptions. Lisp and Functional Programming (1993). </title> <note> To appear. </note>
Reference-contexts: The resulting calculus is a variant of Moggi's untyped computational -calculus [36]. A complete treatment of the relationship between programs and their CPS transforms must also analyze a language with control operators since these are the language facilities for which continuations were conceived <ref> [34, 37, 41, 47] </ref>. To this end, we extend our language with two typical control operators expressible in the CPS framework: abort and call-with-current-continuation.
Reference: 38. <author> Nielson, F. </author> <title> A denotational framework for data flow analysis. </title> <journal> Acta Informatica, </journal> <month> 18 </month> <year> (1982) </year> <month> 265-287. </month>
Reference-contexts: Furthermore, although the literature contains claims that the CPS framework improves the accuracy of data flow analyzers <ref> [38] </ref>, we conjecture that the observed improvements are orthogonal to the "passing of continuations" but are rather side-effects of the axioms CS . We are currently investigating the relationship between the CPS transformation and the precision of data flow analysis.
Reference: 39. <author> Plotkin, G.D. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <booktitle> Theoretical Computer Science, </booktitle> <month> 1 </month> <year> (1975) </year> <month> 125-159. </month> <title> REASONING ABOUT PROGRAMS IN CONTINUATION-PASSING STYLE 71 </title>
Reference-contexts: The CPS intermediate language has the following desirable properties: * The language consists only of basic primitive operations and procedure applications whose semantics is independent of the parameter evaluation technique <ref> [39, 41] </ref>; many optimizations are therefore se quences of fi- and -reductions [2, 43, 46]. * It exposes the control flow of the program; complicated control facilities in the source language, e.g., exception handlers and call-with-current-continuation [40], are translated to simple procedures that manipulate their continuation arguments in non-standard ways [41, <p> However for the important class of optimizations that is expressible in the framework of the -calculus, CPS compilers have an advantage. While CPS compilers can use the full -calculus reductions to perform optimizations, direct compilers can apparently only rely on weaker calculi like the v -calculus <ref> [39] </ref> and the v -C-calculus [18, 19]. Naturally we ask: what optimizations do CPS compilers perform that are not also performed by direct compilers? Or in technical terms, what set of call-by-value axioms corresponds to fi-reductions on CPS terms. <p> wide variety of control abstractions such as error exits, jumps, intelligent backtracking, coroutines, and exception handling [23, 27]. 2 1 For call-by-name languages, the reductions fi are valid in both the source language and the CPS language and the CPS translation does not create any new opportunities for equational reasoning <ref> [39, page 153] </ref>. 2 The CPS framework can also express a control delimiting facility [44], e.g., prompt [15]. However, we do not include prompt in our language for two reasons. First, current language implementations do not include such facilities. <p> Typically, eval is defined via an abstract machine that manipulates abstract counterparts to hardware stacks, stores, registers, etc. Examples are the SECD machine [31] and the CEK machine [16]. An equivalent method for specifying the semantics is based on the Curry-Feys Standard Reduction Theorem <ref> [16, 39] </ref>. The Standard Reduction Theorem defines a partial function, 7!, from programs to programs that corresponds to a single evaluation step of an abstract machine for fl. <p> He developed a method to transform an interpreter such that it becomes indifferent to whether the underlying parameter passing technique is call-by-value or call-by-name. His transformation is essentially the same transformation as Fischer's. 4 Plotkin <ref> [39] </ref> later proved Reynolds's ideas correct. Theorem 1 (Plotkin [39]) Let M 2 fl. <p> He developed a method to transform an interpreter such that it becomes indifferent to whether the underlying parameter passing technique is call-by-value or call-by-name. His transformation is essentially the same transformation as Fischer's. 4 Plotkin <ref> [39] </ref> later proved Reynolds's ideas correct. Theorem 1 (Plotkin [39]) Let M 2 fl. <p> The "new" reductions on CPS terms are known as administrative reductions <ref> [39] </ref>. In order to give a precise definition of these new reductions, we modify the Fischer CPS transformation by overlining all -abstractions that are introduced during the translation. The reduction of any of these overlined -abstractions constitutes an administrative reduction. <p> A quick look at their effect on standard reduction sequences is particularly illuminating. According to Plotkin <ref> [39] </ref>, the standard reduction sequence of a source program relates to the standard reduction sequence of its CPS counterpart as described in the following diagram: * N 7! v - * . . . . * * * * * * N : K 3 . . . . . .
Reference: 40. <editor> Rees, J. and Clinger, W. </editor> <title> Revised 3 report on the algorithmic language Scheme. </title> <journal> Sigplan Notices, </journal> <volume> 21, </volume> <month> 12 </month> <year> (1986) </year> <month> 37-79. </month>
Reference-contexts: primitive operations and procedure applications whose semantics is independent of the parameter evaluation technique [39, 41]; many optimizations are therefore se quences of fi- and -reductions [2, 43, 46]. * It exposes the control flow of the program; complicated control facilities in the source language, e.g., exception handlers and call-with-current-continuation <ref> [40] </ref>, are translated to simple procedures that manipulate their continuation arguments in non-standard ways [41, 47]. * It constitutes an abstract assembly language whose standard reduction sequence mimics the behavior of typical target machines [2, 3, 24, 29, 49]. <p> The Original Program For convenience, we use a superset of Core Scheme that includes assignments to variables via set!, and various other syntactic extensions <ref> [40] </ref>: error df (let ([x M ]) N ) = ((x:N ) M ) (begin M N ) df = ((d:N ) M ) where d 62 F V (N ) REASONING ABOUT PROGRAMS IN CONTINUATION-PASSING STYLE 41 (x:M N ) = (x:(begin M N )) (letrec ([x (y:M )]) N
Reference: 41. <author> Reynolds, J. C. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proceedings of the ACM Annual Conference (1972) 717-740. </booktitle>
Reference-contexts: Compiling with and without Continuations Many compilers for higher-order applicative languages use the continuation-passing style (CPS) transformation <ref> [21, 41] </ref> to generate an intermediate representation [3, 30, 43, 46]. <p> The CPS intermediate language has the following desirable properties: * The language consists only of basic primitive operations and procedure applications whose semantics is independent of the parameter evaluation technique <ref> [39, 41] </ref>; many optimizations are therefore se quences of fi- and -reductions [2, 43, 46]. * It exposes the control flow of the program; complicated control facilities in the source language, e.g., exception handlers and call-with-current-continuation [40], are translated to simple procedures that manipulate their continuation arguments in non-standard ways [41, <p> [39, 41]; many optimizations are therefore se quences of fi- and -reductions [2, 43, 46]. * It exposes the control flow of the program; complicated control facilities in the source language, e.g., exception handlers and call-with-current-continuation [40], are translated to simple procedures that manipulate their continuation arguments in non-standard ways <ref> [41, 47] </ref>. * It constitutes an abstract assembly language whose standard reduction sequence mimics the behavior of typical target machines [2, 3, 24, 29, 49]. The CPS transformation is a global transformation that affects every subexpression in a program. <p> The resulting calculus is a variant of Moggi's untyped computational -calculus [36]. A complete treatment of the relationship between programs and their CPS transforms must also analyze a language with control operators since these are the language facilities for which continuations were conceived <ref> [34, 37, 41, 47] </ref>. To this end, we extend our language with two typical control operators expressible in the CPS framework: abort and call-with-current-continuation. <p> F : fl ! fl F [[M N ]] = k:(F [[M ]] (m:(F [[N ]] n:((m k) n)))) F v : Values ! fl F v [[x]] = x Reynolds <ref> [41] </ref> investigated definitional interpreters for higher-order languages. One of his goals was the desire to liberate the definition of a language from the parameter-passing technique of the defining language.
Reference: 42. <author> Sabry, A. and Felleisen, M. </author> <title> Reasoning about programs in continuation-passing style. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1992) 288-298. </booktitle> <institution> Technical Report 92-180, Rice University. </institution>
Reference-contexts: : 10 3.2 The Universe of CPS Terms : : : : : : : : : : : : : : : : : : 11 4 A Compacting CPS Transformation 13 fl This article is a revised and extended version of the conference paper with the same title <ref> [42] </ref>. <p> Values are either variables or abstractions that transform continuations. Continuations are either variables, or the result of the application of a value to a continuation, or an abstraction that trans forms a value to an answer. 8 The earlier version of the paper <ref> [42] </ref> erroneously included an arbitrary term M in place of the variable z. REASONING ABOUT PROGRAMS IN CONTINUATION-PASSING STYLE 19 Definition 8 (CPS grammar, CPS program, cps (fl)) Let K-Vars = fkg be a set of continuation variables such that Vars " K-Vars = ;. <p> For the simply typed languages, our calculi are also "semantically complete" with respect to denotational CPS models [35]. The result is a consequence of the completeness of the -calculus with respect to the full type structure <ref> [42] </ref>. 40 SABRY AND FELLEISEN The Axioms fi k : ((x:P ) W ) = P [x := W ] (fi w ) (x:Kx) = K ( k ) The Axioms F k : (if true P Q) = P (Ifk t ) (if false P Q) = Q (Ifk f
Reference: 43. <author> Shivers, O. </author> <title> Control-Flow Analysis of Higher-Order Languages or Taming Lambda. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University (1991). </institution>
Reference-contexts: Compiling with and without Continuations Many compilers for higher-order applicative languages use the continuation-passing style (CPS) transformation [21, 41] to generate an intermediate representation <ref> [3, 30, 43, 46] </ref>. <p> The CPS intermediate language has the following desirable properties: * The language consists only of basic primitive operations and procedure applications whose semantics is independent of the parameter evaluation technique [39, 41]; many optimizations are therefore se quences of fi- and -reductions <ref> [2, 43, 46] </ref>. * It exposes the control flow of the program; complicated control facilities in the source language, e.g., exception handlers and call-with-current-continuation [40], are translated to simple procedures that manipulate their continuation arguments in non-standard ways [41, 47]. * It constitutes an abstract assembly language whose standard reduction sequence <p> as described in the following diagram: * N 7! v - * . . . . * * * * * * N : K 3 . . . . . . 5 Improved by Robert Harper. 6 The function F 2 eliminates more administrative than other CPS transforma tions <ref> [3, 13, 30, 43, 46] </ref>. For example, applying F2 to (((x:y:x) a) b) yields k:((x:((y:kx) b)) a).
Reference: 44. <author> Sitaram, D. and Felleisen, M. </author> <title> Reasoning with continuations II: Full abstraction for models of control. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming (1990) 161-175. </booktitle>
Reference-contexts: exception handling [23, 27]. 2 1 For call-by-name languages, the reductions fi are valid in both the source language and the CPS language and the CPS translation does not create any new opportunities for equational reasoning [39, page 153]. 2 The CPS framework can also express a control delimiting facility <ref> [44] </ref>, e.g., prompt [15]. However, we do not include prompt in our language for two reasons. First, current language implementations do not include such facilities. Second, the CPS translation of prompt generates expressions that are no longer independent of the timing of parameter evaluation [12, 20].
Reference: 45. <editor> Steel, T.B., editor. </editor> <booktitle> Formal Language Description Languages for Computer Programming. </booktitle> <publisher> North-Holland (1966). </publisher>
Reference-contexts: real power is lost in restricting oneself to a deletion strategy implementation, for any program can be translated into an equivalent one which will work correctly under such an imple mentation [21, page 104]. 3 The origin of the concept of "continuation" can be traced back to A. van Wijn-gaarden <ref> [45] </ref> who defined a source to source transformation that eliminates jumps (goto instructions) from a program in favor of procedures that never return. REASONING ABOUT PROGRAMS IN CONTINUATION-PASSING STYLE 11 The translation he refers to is the Fischer CPS transformation.
Reference: 46. <author> Steele, G. L. Rabbit: </author> <title> A Compiler for Scheme. MIT AI Memo 474, </title> <institution> Massachusetts Institute of Technology (1978). </institution>
Reference-contexts: Compiling with and without Continuations Many compilers for higher-order applicative languages use the continuation-passing style (CPS) transformation [21, 41] to generate an intermediate representation <ref> [3, 30, 43, 46] </ref>. <p> The CPS intermediate language has the following desirable properties: * The language consists only of basic primitive operations and procedure applications whose semantics is independent of the parameter evaluation technique [39, 41]; many optimizations are therefore se quences of fi- and -reductions <ref> [2, 43, 46] </ref>. * It exposes the control flow of the program; complicated control facilities in the source language, e.g., exception handlers and call-with-current-continuation [40], are translated to simple procedures that manipulate their continuation arguments in non-standard ways [41, 47]. * It constitutes an abstract assembly language whose standard reduction sequence <p> as described in the following diagram: * N 7! v - * . . . . * * * * * * N : K 3 . . . . . . 5 Improved by Robert Harper. 6 The function F 2 eliminates more administrative than other CPS transforma tions <ref> [3, 13, 30, 43, 46] </ref>. For example, applying F2 to (((x:y:x) a) b) yields k:((x:((y:kx) b)) a). <p> For example, applying F2 to (((x:y:x) a) b) yields k:((x:((y:kx) b)) a). For the same example, both Steele's Rabbit transformation <ref> [46] </ref> and the Danvy/Filinski transformation [13] yield the term: k:((xk 1 :(k 1 yk 2 :k 2 x)) a (m:mbk)): Even though this term only contains source redexes, we could still optimize it without eliminating source redexes: fi ` k:((xk 1 :(k 1 yk 2 :k 2 x)) a (m:mbk)) = <p> = A ( v 3 ) 13 Alternative translations that do not cause this exponential increase in the size of the code are: C k [[E [(if V M N)]]] = ((k:(if [[V ]] C k [[M]] C k [[N]])) K k [[E]]) The first translation is used by compilers <ref> [46] </ref> but also duplicates the entire evaluation context once we close the language under fi-reductions.
Reference: 47. <author> Strachey, C. and Wadsworth, </author> <title> C.P. Continuations: A Mathematical Semantics for Handling Full Jumps. </title> <type> Technical Monograph PRG-11, </type> <institution> Oxford University Computing Laboratory, Programming Research Group (1974). </institution>
Reference-contexts: [39, 41]; many optimizations are therefore se quences of fi- and -reductions [2, 43, 46]. * It exposes the control flow of the program; complicated control facilities in the source language, e.g., exception handlers and call-with-current-continuation [40], are translated to simple procedures that manipulate their continuation arguments in non-standard ways <ref> [41, 47] </ref>. * It constitutes an abstract assembly language whose standard reduction sequence mimics the behavior of typical target machines [2, 3, 24, 29, 49]. The CPS transformation is a global transformation that affects every subexpression in a program. <p> The resulting calculus is a variant of Moggi's untyped computational -calculus [36]. A complete treatment of the relationship between programs and their CPS transforms must also analyze a language with control operators since these are the language facilities for which continuations were conceived <ref> [34, 37, 41, 47] </ref>. To this end, we extend our language with two typical control operators expressible in the CPS framework: abort and call-with-current-continuation.
Reference: 48. <author> Talcott, C. L. </author> <title> A theory for program and data specification. </title> <booktitle> Theoretical Computer Science, 104 (1992) 129-159. Preliminary version in Proceedings of the International Symposium on Design and Implementation of Symbolic Computation Systems, (Lecture Notes in Computer Science, </booktitle> <volume> 429, </volume> <year> 1990). </year>
Reference-contexts: The resulting calculus includes the reductions of the v -C-calculus [18, 19] and is equivalent to the equational subtheory of the logic IOCC (Impredicative theory of Operations, Control abstractions, and Classes) <ref> [48] </ref>. Finally, since Lisp and similar languages include more facilities than just procedures and control operators, we consider the language Core Scheme, which also includes constants, conditionals, and assignments. We develop a theory for reasoning about Core Scheme that proves all the equations that hold in the CPS framework. <p> C k [[V ]] = (k [[V ]]) [[x]] = x [[callcc]] = k:u:((u k) d:k) [[A]] = k:x:x K k [[E [(V [ ])]]] = ([[V ]] K k [[E]]) 10 Felleisen et al. [16, 18, 19] and Talcott <ref> [48] </ref> use alternative definitions that do not rely on the CPS transformation. REASONING ABOUT PROGRAMS IN CONTINUATION-PASSING STYLE 29 Besides the extensions to callcc and A, the transformation differs from the function in Definition 5 in the following aspect. <p> M) callcc k:C [E [(k M)]] = callcc k:C [(k M)] k 2 F V (C [k]) (C abort ) (callcc k:((x:M) N)) = ((x:(callcc k:M)) N) k 62 F V (N) (C tail ) E [(A M)] = (A M) (Abort) corresponds to the restriction of the theory IOCC <ref> [48] </ref> to the language fl + callcc + A. The relationship of C k to the function C 1 is subject of two lemmas.
Reference: 49. <author> Wand, M. </author> <title> Correctness of procedure representations in higher-order assembly language. </title> <editor> In Brookes, S., editor, </editor> <booktitle> Proceedings of the Conference on the Mathematical Foundations of Programing Semantics, Lecture Notes in Computer Science, </booktitle> <volume> 598, </volume> <publisher> Springer Verlag (1992) 294-311. </publisher>
Reference-contexts: flow of the program; complicated control facilities in the source language, e.g., exception handlers and call-with-current-continuation [40], are translated to simple procedures that manipulate their continuation arguments in non-standard ways [41, 47]. * It constitutes an abstract assembly language whose standard reduction sequence mimics the behavior of typical target machines <ref> [2, 3, 24, 29, 49] </ref>. The CPS transformation is a global transformation that affects every subexpression in a program. It restructures programs to the extent that many of their original aspects are unrecognizable.
References-found: 49

