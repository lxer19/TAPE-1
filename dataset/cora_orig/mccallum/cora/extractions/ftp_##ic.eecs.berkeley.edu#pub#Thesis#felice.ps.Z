URL: ftp://ic.eecs.berkeley.edu/pub/Thesis/felice.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/Respep/Research/Thesis/thesis.html
Root-URL: http://www.cs.berkeley.edu
Title: Iterative Methods for Formal Verification of Digital Systems  
Author: by Felice Balarin 
Degree: M.S. (University of Zagreb) 1989 A dissertation submitted in partial satisfaction of the requirements for the degree of Doctor of Philosophy in Engineering-Electrical Engineering and Computer Sciences in the GRADUATE DIVISION of the UNIVERSITY of CALIFORNIA at BERKELEY Committee in charge: Professor Alberto L. Sangiovanni-Vincentelli, Chair Professor Robert K. Brayton Professor John  
Date: 1985  1994  
Address: Zagreb)  
Affiliation: B.S. (University of  Rice  
Abstract-found: 0
Intro-found: 1
Reference: [AB93] <author> Adnan Aziz and Robert K. Brayton. </author> <title> Verifying interacting finite state machines. </title> <type> Technical Report UCB/ERL M93/52, </type> <institution> Electronics Research Laboratory, College of Engineering, Univer sity of California, Berkeley, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: In this case, the number of states can be exponential in the size of the description, and in fact both CTL model checking and language containment of systems consisting of interacting components are PSPACE-complete <ref> [AB93] </ref>. This is the well known state explosion problem. As we have seen, the problem is even more severe for real-time systems, where adding precise timing information adds another layer of complexity to the system. Attacking the state explosion problem is the focus of a wide range of research.
Reference: [ABB + 94] <author> A. Aziz, F. Balarin, R. K. Brayton, S.-T. Cheng, R. Hojati, S. C. Krish-nan, R. K. Ranjan, A. L. Sangiovanni-Vincentelli, T. R. Shiple, V. Singhal, S. Tasiran, and H.-Y. Wang. HSIS: </author> <title> A BDD-based environment for formal verification. </title> <booktitle> In Proceedings of the 31th ACM/IEEE Design Automation Conference, </booktitle> <year> 1994. </year>
Reference-contexts: The first efficient automatic model checking procedure for any temporal logic was given Clarke, Emerson and Sistla [CES86] for the branching time logic CTL, which still remains the most widely used logic in verification. For example, verification systems SMV [McM93], and HSIS <ref> [ABB + 94] </ref> are based on it. Formulas of linear time temporal logics reason about paths, and the system is verified if the formula is true for all paths from the initial states. <p> Some of these issues have been addressed in the literature <ref> [ABB + 94, BBC + , Kur94] </ref>, but many practical questions have yet to be resolved. Last but not least, a formal verification method can be successful only only if accompanied with elaborate complexity management techniques. <p> INTRODUCTION 6 many practical cases large sets of states have quite small BDD representations, and thus it is possible to manipulate sets of states that are too large to enumerate with existing computing resources. BDD-based algorithms (and verification systems) are available both for model checking [McM93] and language containment <ref> [ABB + 94] </ref> The success of BDD-based approaches have made them almost synonymous to symbolic computation. Still, not all symbolic approaches are BDD-based. For example, in the verification of real-time and hybrid systems, sets of linear inequalities are used to represent convex polyhedra bounded by them [HNSY92, ACHH93]. <p> We will review three such approaches: one suggested by Vardi and Wolper [VW86], one by Kurshan [Kur90] on which the verification tool COSPAN [HK88] is based, and finally one by Hojati and Brayton [HB95] on which the tool HSIS <ref> [ABB + 94] </ref> is based. <p> Usually, the designer knows which timing constraints are critical for a particular property. Not relaxing these constraints initially can dramatically reduce the number of iterations. Therefore, in the verification system HSIS <ref> [ABB + 94, BBC + ] </ref> which includes the implementation of the TLE algorithm we provide an option to the user of "hinting" which timing constraints not to ignore initially. This may increase the size of the initial abstraction, so one must be careful not to list too many constraints.
Reference: [ACD90] <author> Rajeev Alur, Costas Courcoubetis, and David L. Dill. </author> <title> Model-checking for real-time systems. </title> <booktitle> In Proceedings of 5th LICS, </booktitle> <pages> pages 414-425, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In a similar fashion, temporal logics can be extended with real-time operators, and then the infinite-state model checking can be reduced to a finite state one <ref> [ACD90, Alu91, AH92] </ref>. <p> Thus it is not surprising that even though the syntax of the models are quite different, the implementations of the verification algorithms share the same techniques. For example, Alur, Courcoubetis and Dill <ref> [ACD90] </ref> define timed computation tree logic (TCTL), a temporal logic for specifying real-time properties. Models of TCTL are timed graphs, which are finite-state structures similar to timed automata.
Reference: [ACD + 92] <author> Rajeev Alur, Costas Courcoubetis, David L. Dill, Nicholas Halbwachs, and Howard Wong-Toi. </author> <title> An implementation of three algorithms for timing verification based on automata emptiness. </title> <booktitle> In Proceedings of IEEE Real-time Systems Symposium, </booktitle> <year> 1992. </year>
Reference-contexts: language of a TAD as the set of all possible behaviors, and to prove (or disprove) that they are all acceptable, we prove (or disprove) the language emptiness of the composition of the system with a TAD whose language represents all unacceptable behaviors. 4.1.6 Example In the railroad crossing example <ref> [ACD + 92] </ref> shown in Figure 4.1, the system has three components: the train, the gate, and the controller. The train approaches from outside of the crossing. <p> The algorithms differ in the order of splitting and computing reachability information. The algorithms are given in CHAPTER 4. REAL-TIME SYSTEMS 58 terms of abstract operations post (for reachability), pre (for checking stability) and split (for making classes more stable). Alur et al. <ref> [ACD + 92, ACH + 92] </ref> and Yannakakis and Lee [YL93] have specialized these algorithms to timed automata. <p> - jV j times )gj I (s) = 1g; while there exist unmarked S i 2 do step 2: mark S i ; forall I/O values 2 do step 3: :=refine (; post (S i ; T; )); end forall end while step 4: return ; end Alur et al. <ref> [ACD + 92] </ref> have implemented a variant of the algorithm in Figure 4.3 CHAPTER 4. REAL-TIME SYSTEMS 60 that computes A = for some timed automaton. Again, every class of is represented by a single untimed component and by a difference bound matrix. <p> These experiments were performed without hints. In Table 4.3 we compare the results for TLE algorithm with the results from the tool KRONOS [Yov92], and the results obtained by minimization approaches (using both surjective and stable partitions) presented by Alur et al. <ref> [ACD + 92] </ref>. Compared to other available results TLE algorithm is comparable without hints and always better with hints. That is not surprising because the hints rely on the knowledge (and the effort) of the user, while other approaches are completely automatic.
Reference: [ACH + 92] <author> Rajeev Alur, Costas Courcoubetis, Nicholas Halbwachs, David L. Dill, and Howard Wong-Toi. </author> <title> Minimization of timed transition systems. </title> <booktitle> In Proceedings of CONCUR'92, </booktitle> <month> August </month> <year> 1992. </year>
Reference-contexts: The algorithms differ in the order of splitting and computing reachability information. The algorithms are given in CHAPTER 4. REAL-TIME SYSTEMS 58 terms of abstract operations post (for reachability), pre (for checking stability) and split (for making classes more stable). Alur et al. <ref> [ACD + 92, ACH + 92] </ref> and Yannakakis and Lee [YL93] have specialized these algorithms to timed automata.
Reference: [ACHH93] <author> Rajeev Alur, Costas Courcoubetis, Thomas A. Henzinger, and Pei-Hsin Ho. </author> <title> Hybrid automata: an algorithmic approach to the specification and verification of hybrid systems. </title> <editor> In R. L. Grossman, A. Nerode, A. P. Ravn, and H. Rischel, editors, </editor> <booktitle> Hybrid Systems, </booktitle> <address> Lyngby, Denmark, 10-12 Oct. </address> <year> 1991, </year> <booktitle> Proceedings, </booktitle> <pages> pages 209-229. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> BIBLIOGRAPHY 140 </note>
Reference-contexts: Still, not all symbolic approaches are BDD-based. For example, in the verification of real-time and hybrid systems, sets of linear inequalities are used to represent convex polyhedra bounded by them <ref> [HNSY92, ACHH93] </ref>. Recent advancements in symbolic computation techniques have significantly increased the capabilities of automatic formal verification, but simplifications are still necessary to handle most real-life systems. We make a distinction between two kinds of simplifications: exact and conservative. <p> Background tasks Background tasks were left out because they have lower priority and do not influence the behavior of control and event task. Message passing and mutual exclusion can be modeled precisely within a framework of integrator systems <ref> [ACHH93] </ref>, where it is possible to stop, for a while, a timer that measures the run time of a task. Unfortunately, verification of integrator systems is undecidable in general. CHAPTER 5. REAL-TIME OPERATING SYSTEM 97 In this section we present two models of PATHO based on timed automata.
Reference: [AD90] <author> Rajeev Alur and David L. Dill. </author> <title> Automata for modelling real-time systems. In M.S. </title> <editor> Paterson, editor, </editor> <booktitle> ICALP'90 Automata, languages, and programming: 17th international colloquium. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> LNCS vol. 443. </note>
Reference-contexts: This is true even for some straightforward extensions of standard finite-state models (e.g. [AL91]). The problem is that if real-valued time becomes a state component, then the system is no longer finite-state, and the state space cannot be searched exhaustively in finite time. Alur and Dill <ref> [AD90, Dil89] </ref> have proposed timed automata as a model of real-time CHAPTER 1. INTRODUCTION 4 systems, and showed that they have a finite-state representation. They propose adding timing information to automata through a real-valued variables called timers. Timers can be used to bound elapsed time between any two transitions. <p> It is not enough that an alarm sent by a smoke detector gets to a fire station, it must get there in time. Most of the recent developments in formal verification of real-time systems stem from the work of Alur and Dill <ref> [Dil89, AD90] </ref>. They define timed automata, a model where a finite state system is augmented with real-valued time measuring devices called timers, and then show that the verification of such systems can be reduced to the verification of "ordinary" (untimed) finite-state systems. <p> This result of Alur and Dill <ref> [AD90] </ref> enables automatic verification of real-time systems. We present it in two steps. First, we provide an alternative semantics of TAD's, by associating with each TAD A an untimed, infinite-state automaton A 1 , such that L (A) is equal to L (A 1 ). <p> Alur and Dill <ref> [AD90] </ref> have observed that many of these states are equivalent. We describe this equivalence as the intersection of many coarser equivalence relations.
Reference: [AH92] <author> Rajeev Alur and Thomas A. Henzinger. </author> <title> Logics and models of real time: a survey. </title> <editor> In J.W. de Bakker, C. Huizing, W.P de Roever, and G. Rozenberg, editors, </editor> <booktitle> Proc. Real-Time: Theory in Practice, REX Workshop Proceedings, Mook, </booktitle> <address> Netherlands, </address> <month> 3-7 June </month> <year> 1991, </year> <pages> pages 74-106. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: At a higher level of abstraction, constraints are typically more complex. For example, the speed by which a software task progresses might change in time depending on the load of the system. Many formalisms that can capture complex timing constraints have been proposed (e.g. see <ref> [Vyt91, dBHdRR91, AH92] </ref> for a compilation of many approaches), but most are not suitable for automatic verification, because the associated verification problems are undecidable. This is true even for some straightforward extensions of standard finite-state models (e.g. [AL91]). <p> In a similar fashion, temporal logics can be extended with real-time operators, and then the infinite-state model checking can be reduced to a finite state one <ref> [ACD90, Alu91, AH92] </ref>. <p> Again, every class of is represented by a single untimed component and by a difference bound matrix. A similar algorithm is also implemented in another real-time extension of COSPAN by Courcoubetis et al. [CDCT93]. 4.3.3 Other formalisms Several other models have been proposed for real-time systems <ref> [dBHdRR91, Vyt91, AH92] </ref>. Many of these formalisms have undecidable verification problems, and those that are decidable use in some form the equivalence theorem of Alur and Dill.
Reference: [AIKY93] <author> Rajeev Alur, Alon Itai, R. P. Kurshan, and M. Yannakakis. </author> <title> Timing verification by successive approximation. </title> <editor> In G. v. Bochmann and D.K. Probst, editors, </editor> <booktitle> Proceedings of Computer Aided Verification : 4th International Workshop, CAV '92, </booktitle> <address> Montreal, Canada, June 29-July 1, 1992. </address> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> LNCS vol. 663. </note>
Reference-contexts: In section 4.4 we will propose an approach that can hopefully avoid building the full region automaton for most of the systems. But first we review some other approaches in this direction. 4.3.1 Successive approximation Alur et al. <ref> [AIKY93] </ref> have suggested an approach which can be seen as an application of the generic iterative algorithm of section 1.3 to real-time systems. Initially, all timing constraints are relaxed. Then, the verification is attempted. If successful, then the system is verified. <p> Thus, we can apply a standard algorithm to an ever increasing (finite) graph, adding one node at a time, in natural order. If an over-constrained loop exists, it will be found in a finite number of steps. Alur et al. <ref> [AIKY93] </ref> have showed that if a prefix of some bounded length (where that bound depends on the number of timing constraints) can be consistently timed, then so can the infinite run obtained by repeating a portion of the prefix infinitely often.
Reference: [AK86] <author> K.R. Apt and D.C. Kozen. </author> <title> Limits for automatic verification of finite-state concurrent systems. </title> <journal> Information Processing Letters, </journal> <volume> 22(6) </volume> <pages> 307-309, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: fl are enumerated: s 2 ; s 3 ; : : : */ step 4: if s n satisfies C1-C12 for some ff then step 5: modify A such that L (A new ) = L (A old ) [ fO (ff j (s))jj 0g; end if end and Kozen <ref> [AK86] </ref> have shown that in general the verification of iterative systems is undecidable, so researchers have focused on defining restrictive settings which can be completely automated, or defining more general approaches which depend on user interaction.
Reference: [AL91] <author> Martin Abadi and Leslie Lamport. </author> <title> An old-fashioned recipe for real time. </title> <editor> In J. W. de Bakker, C. Huizing, W. P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Real-Time: Theory in Practice, volume 600 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <booktitle> Proceedings of the REX Workshop Mook, </booktitle> <address> The Netherlands. </address>
Reference-contexts: This is true even for some straightforward extensions of standard finite-state models (e.g. <ref> [AL91] </ref>). The problem is that if real-valued time becomes a state component, then the system is no longer finite-state, and the state space cannot be searched exhaustively in finite time. Alur and Dill [AD90, Dil89] have proposed timed automata as a model of real-time CHAPTER 1.
Reference: [ALG + 91] <author> L. M. Augustin, D. C. Luckman, B. A. Gennart, Y. Huh, and A. G. Stan-culescu. </author> <title> Hardware design and simulation in VAL/VHDL. </title> <publisher> Kluver Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: Unfortunately, neither finite-state automata, nor CTL formulas satisfy these conditions. A promising approach to this problem is to develop translators that provides formal interpre CHAPTER 1. INTRODUCTION 5 tation (in terms of automata or temporal logic formulas) of specification methods used by designers, such as HDL annotations <ref> [NJK94, ALG + 91, BBC + ] </ref> or timing diagrams [SD93]. Another issue that has to be addressed before automatic formal verification is widely accepted is the development of a verification based design methodology.
Reference: [Alu91] <author> Rajeev Alur. </author> <title> Techniques for Automatic Verification of Real-time Systems. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1991. </year>
Reference-contexts: In a similar fashion, temporal logics can be extended with real-time operators, and then the infinite-state model checking can be reduced to a finite state one <ref> [ACD90, Alu91, AH92] </ref>. <p> Fortunately, the run times do not increase proportionally. But, verifying property P rop i requires approximately twice as many states and four times as much time as verifying P rop i1 . So, there still exists a fundamental problem of an exponential increase. There are many theoretical results (e.g. <ref> [Alu91] </ref>) suggesting that this complexity is inherent. Nevertheless recent advances have made possible the verification of examples that were previously intractable.
Reference: [ASB + 94] <author> Adnan Aziz, Vigyan Singhal, Felice Balarin, Alberto L. Sangiovanni-Vincentelli, and Robert K. Brayton. </author> <title> Equivalences for fair kripke structures. </title> <booktitle> In Proceedings of ICALP'94, </booktitle> <year> 1994. </year>
Reference-contexts: Finally, in [GL93] an approximation of the quotient is computed directly from the program text. None of the approaches mentioned above can simplify any fairness constraints. Aziz et al. <ref> [ASB + 94] </ref> have defined an equivalence that includes fairness constraints, but they did not provide an efficient algorithm for computing. Another problem is that approaches [CLM89, BFH90, DGG93] compute actually reductions with respect to large sets of properties, so they are not likely to yield significant simplification.
Reference: [ASSSV94] <author> Adnan Aziz, Thomas R. Shiple, Vigyan Singhal, and Alberto L. Sangiovanni-Vincentelli. </author> <title> Formula-dependent equivalence for compositional CTL model checking. </title> <editor> In David L. Dill, editor, </editor> <booktitle> Proceedings of Computer Aided Verification: BIBLIOGRAPHY 141 6th International Conference, </booktitle> <address> CAV'94, Stanford, CA, </address> <month> June </month> <year> 1994, </year> <pages> pages 324-337. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> LNCS vol. 818. </note>
Reference-contexts: In particular, approaches are developed for preserving all CTL formulas [CLM89, CHAPTER 3. NETWORKS OF COMMUNICATING AUTOMATA 44 BFH90], all ACTL formulas [DGG93], a single CTL formula <ref> [SCSVB92, ASSSV94] </ref>, and a single ACTL formula [DGG93]. Computing the quotient of a given system in the simplest form requires traversal of the state space, and thus is as hard as verifying the system. <p> Initially, a quotient is constructed with respect to a very coarse equivalence (that does not necessarily have any preservation properties). The equivalence and the quotient are then iteratively refined until the preservation is achieved. In <ref> [CLM89, CGL92, SCSVB92, ASSSV94] </ref> the quotient is built hierarchically: components are first abstracted, then composed, and then abstracted again to simplify building of even larger blocks. Finally, in [GL93] an approximation of the quotient is computed directly from the program text. <p> Better simplifications are to be expected from property-specific approaches like ours and <ref> [SCSVB92, ASSSV94, DGG93] </ref>. A quite different approach was taken by Halbwachs [Hal93]. Rather than simplifying a system beforehand, the simplifications are made while computing reachable states. Sets of states are computed symbolically, and instead of the exact set of reachable states, a superset with smaller symbolic representation is computed.
Reference: [BBC + ] <author> Felice Balarin, Robert K. Brayton, Szu-Tse Cheng, Desmond A. Kirkpatrick, Alberto L. Sangiovanni-Vincentelli, and Ephrem C. Wu. </author> <title> A methodology for formal verification of real-time systems. </title> <publisher> unpublisehd. </publisher>
Reference-contexts: Unfortunately, neither finite-state automata, nor CTL formulas satisfy these conditions. A promising approach to this problem is to develop translators that provides formal interpre CHAPTER 1. INTRODUCTION 5 tation (in terms of automata or temporal logic formulas) of specification methods used by designers, such as HDL annotations <ref> [NJK94, ALG + 91, BBC + ] </ref> or timing diagrams [SD93]. Another issue that has to be addressed before automatic formal verification is widely accepted is the development of a verification based design methodology. <p> Usually, the designer knows which timing constraints are critical for a particular property. Not relaxing these constraints initially can dramatically reduce the number of iterations. Therefore, in the verification system HSIS <ref> [ABB + 94, BBC + ] </ref> which includes the implementation of the TLE algorithm we provide an option to the user of "hinting" which timing constraints not to ignore initially. This may increase the size of the initial abstraction, so one must be careful not to list too many constraints.
Reference: [BCG89] <author> M.C. Browne, E.M. Clarke, and O. Grumberg. </author> <title> Reasoning about networks with many identical finite state processes. </title> <journal> Information and Computation, </journal> <volume> 81(1) </volume> <pages> 13-31, </pages> <year> 1989. </year>
Reference-contexts: Browne, Clarke and Grumberg <ref> [BCG89] </ref>, and Shtadler and Grumberg [SG90] have studied conditions under which the satisfaction of formulas of certain temporal logics is independent of the size of the system. In [SG90] the conditions seem to be quite restrictive, while in [BCG89] the conditions cannot in general be checked automatically. <p> Browne, Clarke and Grumberg <ref> [BCG89] </ref>, and Shtadler and Grumberg [SG90] have studied conditions under which the satisfaction of formulas of certain temporal logics is independent of the size of the system. In [SG90] the conditions seem to be quite restrictive, while in [BCG89] the conditions cannot in general be checked automatically. Wolper and Lovinfosse [WL90] have studied formal verification of iterative systems generated by interconnecting identical processes in certain regular fashion. They also present some decidability results for related problems.
Reference: [BD94] <author> Jerry R. Burch and David L. Dill. </author> <title> Automatic verification of pipelined microprocessor control. </title> <editor> In David L. Dill, editor, </editor> <booktitle> Proceedings of Computer Aided Verification: 6th International Conference, </booktitle> <address> CAV'94, Stanford, CA, </address> <month> June </month> <year> 1994, </year> <pages> pages 68-80. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> LNCS vol. 818. </note>
Reference-contexts: This naturally leads to application-specific methods, as high-level objects and typical properties are quite different for different application areas, for example microprocessors and communication protocols. We are already witnessing some contributions in this directions (e.g. <ref> [BD94, Bea93, HMAF94, MPS92] </ref>), and we can only expect this trend to grow stronger in the future. There are many other possible approaches to increase the practical value of formal verification. Let us just shortly describe two possibilities that have received virtually no attention in the research community.
Reference: [Bea93] <author> Derek L. Beatty. </author> <title> A Methodology for Formal Hradware Verification with Application to Microprocessors. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> August </month> <year> 1993. </year>
Reference-contexts: This naturally leads to application-specific methods, as high-level objects and typical properties are quite different for different application areas, for example microprocessors and communication protocols. We are already witnessing some contributions in this directions (e.g. <ref> [BD94, Bea93, HMAF94, MPS92] </ref>), and we can only expect this trend to grow stronger in the future. There are many other possible approaches to increase the practical value of formal verification. Let us just shortly describe two possibilities that have received virtually no attention in the research community.
Reference: [BFH90] <author> A. Bouajjani, J-C. Fernandez, and N. Halbwachs. </author> <title> Minimal model generation. </title> <editor> In Edmund M. Clarke and Robert P. Kurshan, editors, </editor> <booktitle> Proceedings of the Workshop on Computer-Aided Verification, volume 531 of LNCS, </booktitle> <pages> pages 197-203. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Computing the quotient of a given system in the simplest form requires traversal of the state space, and thus is as hard as verifying the system. Therefore, in all of the approaches mentioned above procedures are defined that construct a quotient without ever constructing the full system. In <ref> [BFH90] </ref> and [DGG93] the problem is addressed by interleaving of the quotient and equivalence computation. Initially, a quotient is constructed with respect to a very coarse equivalence (that does not necessarily have any preservation properties). The equivalence and the quotient are then iteratively refined until the preservation is achieved. <p> None of the approaches mentioned above can simplify any fairness constraints. Aziz et al. [ASB + 94] have defined an equivalence that includes fairness constraints, but they did not provide an efficient algorithm for computing. Another problem is that approaches <ref> [CLM89, BFH90, DGG93] </ref> compute actually reductions with respect to large sets of properties, so they are not likely to yield significant simplification. <p> In general, given an automaton A and some initial partition , there exists a unique coarsest refinement 0 of which is stable with respect to the transition relation of A. Two algorithms have been proposed by Boujjani, Fernandez and Halbwachs <ref> [BFH90] </ref>, and Lee and Yannakakis [LY92] to compute A 0 given A and . Both algorithms start with A = and then split some of its reachable, but unstable, states into more stable states. This operation is repeated until all reachable states are stabilized.
Reference: [BRB90] <author> Karl S. Brace, Richard L. Rudell, and Randal E. Bryant. </author> <title> Efficient implementation of a BDD package. </title> <booktitle> In Proceedings of the 27th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 40-45, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: By far the most widely used approach to symbolic computation is to represent sets of states with their characteristic functions. If states are encoded with binary variables, then the characteristic function of a set is just a Boolean function, and is typically represented by a binary decision diagram (BDD) <ref> [BRB90] </ref>. This approach is successful because in CHAPTER 1. INTRODUCTION 6 many practical cases large sets of states have quite small BDD representations, and thus it is possible to manipulate sets of states that are too large to enumerate with existing computing resources.
Reference: [BSV93] <author> Felice Balarin and Alberto L. Sangiovanni-Vincentelli. </author> <title> A verification strategy for timing constrained systems. </title> <editor> In G. v. Bochmann and D.K. Probst, editors, </editor> <booktitle> Proceedings of Computer Aided Verification : 4th International Workshop, CAV '92, </booktitle> <address> Montreal, Canada, June 29-July 1, </address> <year> 1992, </year> <pages> pages 151-63. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> LNCS vol. 663. </note>
Reference-contexts: On the other hand, since more information is used in every iteration, the SA algorithm could require fewer iterations. Unfortunately, no experimental results are available for SA to confirm these expectations. An approach somewhat between the successive approximation and the TLE algorithm was suggested by Balarin and Sangiovanni-Vincentelli <ref> [BSV93] </ref>. This approach 5 This expectation is supported by some experimental results [NSY92] CHAPTER 4.
Reference: [Buc60] <author> J.R. Buchi. </author> <title> On a decision method in restricted second order arithmetic. </title> <editor> In E. Nagel, editor, </editor> <booktitle> Proceedings of the 1960 International Congress on Logic, BIBLIOGRAPHY 142 Methodology and Philosophy of Science, </booktitle> <pages> pages 1-12. </pages> <publisher> Stanford University Press, </publisher> <year> 1960. </year>
Reference-contexts: Thus, complementing a deterministic and complete edge-Rabin automaton into an edge-Streett automaton does not require any computation. 2.3.3 Vardi-Wolper approach A Buchi automaton <ref> [Buc60] </ref> is a 4-tuple (S; I; T; F ), where F is some subset of states. A run s 0 ; s 1 ; : : : is fair if inf (s 0 ; s 1 ; : : :) intersects F . Vardi and Wolper [VW86] CHAPTER 2.
Reference: [CDCT93] <author> Costas Courcoubetis, David L. Dill, M. Chatzaki, and Panagiotis Tzounakis. </author> <title> Verification with real-time COSPAN. </title> <editor> In G. v. Bochmann and D.K. Probst, editors, </editor> <booktitle> Proceedings of Computer Aided Verification : 4th International Workshop, CAV '92, </booktitle> <address> Montreal, Canada, June 29-July 1, 1992. </address> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> LNCS vol. 663. </note>
Reference-contexts: REAL-TIME SYSTEMS 60 that computes A = for some timed automaton. Again, every class of is represented by a single untimed component and by a difference bound matrix. A similar algorithm is also implemented in another real-time extension of COSPAN by Courcoubetis et al. <ref> [CDCT93] </ref>. 4.3.3 Other formalisms Several other models have been proposed for real-time systems [dBHdRR91, Vyt91, AH92]. Many of these formalisms have undecidable verification problems, and those that are decidable use in some form the equivalence theorem of Alur and Dill. <p> without hints) to the following examples of timed automata: * a model of the CSMA/CD protocol [NSY92] consisting of two stations and a channel; we have verified that a collision on the channel is always detected within a given time frame, * a model of the FDDI token ring protocol <ref> [CDCT93] </ref> consisting of three stations; we have verified that every station transmits infinitely often (labeled by fddi-l in Table 4.1), and that there is an upper bound on time between two consecutive receptions CHAPTER 4.
Reference: [CDK89] <author> Edmund M. Clarke, I. A. Draghiescu, and R. P. Kurshan. </author> <title> A unified approach for showing language containment and equivalence between various type of !-automata. </title> <type> Technical report, </type> <institution> Carnegie Mellon University, </institution> <year> 1989. </year>
Reference-contexts: The verification problem is thus reduced to checking language emptiness of the intersection of L-processes. This problem is essentially of the same complexity as the language emptiness of the intersection of Street automata <ref> [CDK89] </ref>. We can embed the COSPAN approach into ours. More precisely, we show that for any L-process A = (S; I; T; R; F ) there exists a Street automaton A 0 with 2jSj states and jF j + 1 fairness constraints, that has the same language as A. <p> Since no confusion can arise, we will use the term "automata (on infinite sequences)" to refer to Streett automata as defined in section 2.2.2. For the survey of language containment algorithms between different kinds of automata we refer the reader to <ref> [CDK89] </ref>. 2.4 Operations on automata 2.4.1 Composition In the previous section we have showed that the verification problem reduces to checking the emptiness of the intersection of languages of two automata.
Reference: [CES86] <author> Edmund M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages Systems, </journal> <volume> 2(8) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: A system is verified, if a formula is true of the associated tree. The first efficient automatic model checking procedure for any temporal logic was given Clarke, Emerson and Sistla <ref> [CES86] </ref> for the branching time logic CTL, which still remains the most widely used logic in verification. For example, verification systems SMV [McM93], and HSIS [ABB + 94] are based on it. <p> In our knowledge, this and ours are the only approaches that demonstrate that state minimization is not the only possible simplification objective. 45 Chapter 4 Real-Time Systems Classical formal models abstract quantitative time and retain only the ordering of events (e.g. <ref> [CES86, Kur90] </ref>). However, for many systems it is essential to verify their real-time behavior. It is not enough that an alarm sent by a smoke detector gets to a fire station, it must get there in time.
Reference: [CGH + 93] <author> Massimiliano Chiodo, Paolo Giusto, Harry Hsieh, Attila Jurecska, Luciano Lavagno, and Alberto Sangiovanni-Vincentelli. </author> <title> A formal specification model for hardware/software codesign. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <year> 1993. </year>
Reference-contexts: REAL-TIME SYSTEMS 90 of a token by a station (labeled fddi-s), * a model of the Fischer's mutual exclusion protocol consisting of three, four or five processes (labeled fis3, fis4, and fis5 in Table 4.1), * a model of a seat-belt alarm controller <ref> [CGH + 93] </ref> (labeled belt); we have verified that the alarm is never on for more than twenty time units, * a model of an automated factory [PV94] consisting of a production line, a service station, two boxes, and two robots that move boxes between the service station and the line;
Reference: [CGL92] <author> Edmund M. Clarke, Orna Grumberg, and David E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In Proc. Principles of Programming Languages, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: Many of these approaches can be seen as a two phase process: first an equivalence relation is defined over states of the system, and then a quotient with respect to that equivalence is computed. In some cases the equivalence is given by a user <ref> [CGL92, GL93] </ref>, and in others it is computed such that it preserves certain classes of properties (typically fragments of CTL). In particular, approaches are developed for preserving all CTL formulas [CLM89, CHAPTER 3. <p> Initially, a quotient is constructed with respect to a very coarse equivalence (that does not necessarily have any preservation properties). The equivalence and the quotient are then iteratively refined until the preservation is achieved. In <ref> [CLM89, CGL92, SCSVB92, ASSSV94] </ref> the quotient is built hierarchically: components are first abstracted, then composed, and then abstracted again to simplify building of even larger blocks. Finally, in [GL93] an approximation of the quotient is computed directly from the program text.
Reference: [CLM89] <author> Edmund M. Clarke, David E. Long, and Kenneth L. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In 4th Annual Symposium on Logic in Computer Science, Asilomar, </booktitle> <address> CA, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: In some cases the equivalence is given by a user [CGL92, GL93], and in others it is computed such that it preserves certain classes of properties (typically fragments of CTL). In particular, approaches are developed for preserving all CTL formulas <ref> [CLM89, CHAPTER 3. NETWORKS OF COMMUNICATING AUTOMATA 44 BFH90] </ref>, all ACTL formulas [DGG93], a single CTL formula [SCSVB92, ASSSV94], and a single ACTL formula [DGG93]. <p> Initially, a quotient is constructed with respect to a very coarse equivalence (that does not necessarily have any preservation properties). The equivalence and the quotient are then iteratively refined until the preservation is achieved. In <ref> [CLM89, CGL92, SCSVB92, ASSSV94] </ref> the quotient is built hierarchically: components are first abstracted, then composed, and then abstracted again to simplify building of even larger blocks. Finally, in [GL93] an approximation of the quotient is computed directly from the program text. <p> None of the approaches mentioned above can simplify any fairness constraints. Aziz et al. [ASB + 94] have defined an equivalence that includes fairness constraints, but they did not provide an efficient algorithm for computing. Another problem is that approaches <ref> [CLM89, BFH90, DGG93] </ref> compute actually reductions with respect to large sets of properties, so they are not likely to yield significant simplification.
Reference: [CYF94] <author> B. Chen, M. Yamazaki, and M. Fujita. </author> <title> Bug identification of a real chip design by symbolic model checking. </title> <booktitle> In Proceedings of The European Conference on Design Automation, </booktitle> <address> EDAC-ETC-EUROASIC, Paris, France, </address> <month> 28 Feb.-3 March </month> <year> 1994, </year> <pages> pages 132-136. </pages> <publisher> IEEE Comput. Soc. Press, </publisher> <year> 1994. </year>
Reference-contexts: Presently, simulation is a prevailing method for verifying digital systems. But as technology advances and systems become more complex, verification by simulation is becoming increasingly insufficient. An illustrative example was reported by Chen, Yamazaki and Fujita <ref> [CYF94] </ref>. A data-switching chip (assumed to be correct by the designers) was exhibiting incorrect behavior, but only sporadically, and only after several seconds of operation at 156M H z.
Reference: [dBHdRR91] <editor> J. W. de Bakker, C. Huizing, W. P. de Roever, and G. Rozenberg, editors. </editor> <booktitle> Real-Time: Theory in Practice, volume 600 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <booktitle> Proceedings of the REX Workshop Mook, </booktitle> <address> The Netherlands. BIBLIOGRAPHY 143 </address>
Reference-contexts: At a higher level of abstraction, constraints are typically more complex. For example, the speed by which a software task progresses might change in time depending on the load of the system. Many formalisms that can capture complex timing constraints have been proposed (e.g. see <ref> [Vyt91, dBHdRR91, AH92] </ref> for a compilation of many approaches), but most are not suitable for automatic verification, because the associated verification problems are undecidable. This is true even for some straightforward extensions of standard finite-state models (e.g. [AL91]). <p> Again, every class of is represented by a single untimed component and by a difference bound matrix. A similar algorithm is also implemented in another real-time extension of COSPAN by Courcoubetis et al. [CDCT93]. 4.3.3 Other formalisms Several other models have been proposed for real-time systems <ref> [dBHdRR91, Vyt91, AH92] </ref>. Many of these formalisms have undecidable verification problems, and those that are decidable use in some form the equivalence theorem of Alur and Dill.
Reference: [DGG93] <author> Dennis Dams, Orna Grumberg, and Rob Gerth. </author> <title> Generation of reduced models for checking fragments of CTL. In Costas Courcoubetis, editor, </title> <booktitle> Proceedings of the Conference on Computer-Aided Verification, volume 697 of LNCS, </booktitle> <pages> pages 479-490. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: In particular, approaches are developed for preserving all CTL formulas [CLM89, CHAPTER 3. NETWORKS OF COMMUNICATING AUTOMATA 44 BFH90], all ACTL formulas <ref> [DGG93] </ref>, a single CTL formula [SCSVB92, ASSSV94], and a single ACTL formula [DGG93]. Computing the quotient of a given system in the simplest form requires traversal of the state space, and thus is as hard as verifying the system. <p> In particular, approaches are developed for preserving all CTL formulas [CLM89, CHAPTER 3. NETWORKS OF COMMUNICATING AUTOMATA 44 BFH90], all ACTL formulas <ref> [DGG93] </ref>, a single CTL formula [SCSVB92, ASSSV94], and a single ACTL formula [DGG93]. Computing the quotient of a given system in the simplest form requires traversal of the state space, and thus is as hard as verifying the system. Therefore, in all of the approaches mentioned above procedures are defined that construct a quotient without ever constructing the full system. <p> Therefore, in all of the approaches mentioned above procedures are defined that construct a quotient without ever constructing the full system. In [BFH90] and <ref> [DGG93] </ref> the problem is addressed by interleaving of the quotient and equivalence computation. Initially, a quotient is constructed with respect to a very coarse equivalence (that does not necessarily have any preservation properties). The equivalence and the quotient are then iteratively refined until the preservation is achieved. <p> None of the approaches mentioned above can simplify any fairness constraints. Aziz et al. [ASB + 94] have defined an equivalence that includes fairness constraints, but they did not provide an efficient algorithm for computing. Another problem is that approaches <ref> [CLM89, BFH90, DGG93] </ref> compute actually reductions with respect to large sets of properties, so they are not likely to yield significant simplification. <p> Better simplifications are to be expected from property-specific approaches like ours and <ref> [SCSVB92, ASSSV94, DGG93] </ref>. A quite different approach was taken by Halbwachs [Hal93]. Rather than simplifying a system beforehand, the simplifications are made while computing reachable states. Sets of states are computed symbolically, and instead of the exact set of reachable states, a superset with smaller symbolic representation is computed.
Reference: [Dil89] <author> David L. Dill. </author> <title> Timing assumptions and verification of finite-state concurrent systems. </title> <editor> In Joseph Sifakis, editor, </editor> <title> Automatic Verification Methods for Finite-State Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <note> LNCS vol. 407. </note>
Reference-contexts: This is true even for some straightforward extensions of standard finite-state models (e.g. [AL91]). The problem is that if real-valued time becomes a state component, then the system is no longer finite-state, and the state space cannot be searched exhaustively in finite time. Alur and Dill <ref> [AD90, Dil89] </ref> have proposed timed automata as a model of real-time CHAPTER 1. INTRODUCTION 4 systems, and showed that they have a finite-state representation. They propose adding timing information to automata through a real-valued variables called timers. Timers can be used to bound elapsed time between any two transitions. <p> It is not enough that an alarm sent by a smoke detector gets to a fire station, it must get there in time. Most of the recent developments in formal verification of real-time systems stem from the work of Alur and Dill <ref> [Dil89, AD90] </ref>. They define timed automata, a model where a finite state system is augmented with real-valued time measuring devices called timers, and then show that the verification of such systems can be reduced to the verification of "ordinary" (untimed) finite-state systems. <p> To represent such convex sets Dill <ref> [Dil89] </ref> suggested difference bound matrices, square matrices with jV j+1 rows and columns and entries which are upper bounds.
Reference: [EL86] <author> E. Allan Emerson and C. L. Lei. </author> <title> Efficient model checking in fragments of the propositional mu-calculus (extended abstract). </title> <booktitle> In Proceedings, Symposium on Logic in Computer Science, </booktitle> <pages> pages 267-278, </pages> <address> Cambridge, Massachusetts, 16-18 June 1986. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: Such a path is computed by the debug function. For the infinite case, we present the accept function similar to the algorithm by Hojati and Brayton [HB95], which in turn can be viewed as an implementation of a fixed point formula by Emerson and Lei <ref> [EL86] </ref>. But first we need to introduce the notion of a fair cycle.
Reference: [Eme90] <author> E. Allan Emerson. </author> <title> Temporal and modal logic. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 995-1072. </pages> <publisher> Elsvier Science Publishers B. V., </publisher> <year> 1990. </year>
Reference-contexts: In the model checking approach a system is verified if it represents a model of a given formula in some temporal logic. Most of the logics proposed for specification and verification of finite-state systems can be classified as either branching time or linear time temporal logics (see <ref> [Eme90] </ref> for excellent survey). The precise formulation of the model checking problem is somewhat different for each class. Models of branching time temporal logics are trees, but their subformulas reason about paths in a tree. <p> These are finite structure that can represent possibly infinite sets of sequences of inputs and outputs of a system. There exists a wide body of knowledge concerning automata both on finite (e.g. see [HU79]) and infinite sequences (e.g. <ref> [Tho90, Eme90] </ref>). Here, we present only fragments of the developed theory that are relevant to our research results, and to the implementation of an efficient verification tool based on language containment. CHAPTER 2.
Reference: [GL91] <author> Orna Grumberg and David E. </author> <title> Long. Model checking and modular verification. </title> <booktitle> In CONCUR, </booktitle> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1991. </year> <note> (also submitted to JACM). </note>
Reference-contexts: However, if the logic is restricted to universal path quantifiers (and of course no negation), then conservative simplifications are possible. Roughly speaking, any system with more paths is an abstraction of the original system. For example, Grumberg and Long <ref> [GL91] </ref> have studied such a restriction of CTL (called ACTL), and showed that one system is an abstraction of another, if so-called CHAPTER 1. INTRODUCTION 7 simulation relation holds between them.
Reference: [GL93] <author> S. Graf and C. Loiseaux. </author> <title> A tool for symbolic program verification and abstraction. In Costas Courcoubetis, editor, </title> <booktitle> Computer Aided Verification: 5th International Conference, CAV'93, Elounda, Greece, June/July 1993, Proceedings, </booktitle> <pages> pages 71-84. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> LNCS vol. 697. </note>
Reference-contexts: Many of these approaches can be seen as a two phase process: first an equivalence relation is defined over states of the system, and then a quotient with respect to that equivalence is computed. In some cases the equivalence is given by a user <ref> [CGL92, GL93] </ref>, and in others it is computed such that it preserves certain classes of properties (typically fragments of CTL). In particular, approaches are developed for preserving all CTL formulas [CLM89, CHAPTER 3. <p> The equivalence and the quotient are then iteratively refined until the preservation is achieved. In [CLM89, CGL92, SCSVB92, ASSSV94] the quotient is built hierarchically: components are first abstracted, then composed, and then abstracted again to simplify building of even larger blocks. Finally, in <ref> [GL93] </ref> an approximation of the quotient is computed directly from the program text. None of the approaches mentioned above can simplify any fairness constraints. Aziz et al. [ASB + 94] have defined an equivalence that includes fairness constraints, but they did not provide an efficient algorithm for computing.
Reference: [Hal93] <author> Nicholas Halbwachs. </author> <title> Delay analysis in synchronous programs. In Costas Courcoubetis, editor, </title> <booktitle> Computer Aided Verification: 5th International Conference, CAV'93, Elounda, Greece, June/July 1993, Proceedings, </booktitle> <pages> pages 333-346. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> LNCS vol. 697. </note>
Reference-contexts: Better simplifications are to be expected from property-specific approaches like ours and [SCSVB92, ASSSV94, DGG93]. A quite different approach was taken by Halbwachs <ref> [Hal93] </ref>. Rather than simplifying a system beforehand, the simplifications are made while computing reachable states. Sets of states are computed symbolically, and instead of the exact set of reachable states, a superset with smaller symbolic representation is computed.
Reference: [HB95] <author> Ramin Hojati and Robert K. Brayton. </author> <title> An environment for formal verification based on symbolic computation. Formal Methods in System Design: </title> <journal> An International Journal, </journal> <volume> 5, </volume> <year> 1995. </year> <note> (to appear). BIBLIOGRAPHY 144 </note>
Reference-contexts: We will review three such approaches: one suggested by Vardi and Wolper [VW86], one by Kurshan [Kur90] on which the verification tool COSPAN [HK88] is based, and finally one by Hojati and Brayton <ref> [HB95] </ref> on which the tool HSIS [ABB + 94] is based. <p> A more efficient alternative is to extended the language emptiness algorithm for Streett automata to handle recur edges directly. Therefore, Hojati and Brayton <ref> [HB95] </ref> suggested to use edge-Streett automata to model systems. An edge-Streett automaton is a 5-tuple (S; I; T; R; F ), where R is a set of recur edges, and F is a set of Streett fairness constraints. <p> Such a path is computed by the debug function. For the infinite case, we present the accept function similar to the algorithm by Hojati and Brayton <ref> [HB95] </ref>, which in turn can be viewed as an implementation of a fixed point formula by Emerson and Lei [EL86]. But first we need to introduce the notion of a fair cycle.
Reference: [HBK93] <author> Ramin Hojati, Robert K. Brayton, and R. P. Kurshan. </author> <title> BDD-based debugging of designs using language containment an fair CTL. In Costas Courcoubetis, editor, </title> <booktitle> Computer Aided Verification: 5th International Conference, CAV'93, Elounda, Greece, June/July 1993, Proceedings, </booktitle> <pages> pages 41-58. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> LNCS vol. 697. </note>
Reference-contexts: For example, it is not too hard to guarantee that the verify function always returns the shortest failure report <ref> [HBK93] </ref>. If that is the case, we can claim that the true accepting run will eventually be returned by verify, because there are only finitely many shorter runs, so they can all be eliminated in finitely many iterations of the TLE algorithm.
Reference: [Hen61] <author> Frederick C. Hennie. </author> <title> Iterative Arrays of Logical Circuits. </title> <publisher> MIT Press and John Eiley Sons, Inc., </publisher> <year> 1961. </year>
Reference-contexts: In fact, this result is similar to Theorem 4.3 in [WL90] and Theorem 4 in <ref> [Hen61] </ref>. In all cases, the proofs substantially rely on the ability to distinguish one cell in the network: in our case, it is the environment, in [WL90] the first cell is explicitly distinguished, and in [Hen61] CHAPTER 7. <p> In fact, this result is similar to Theorem 4.3 in [WL90] and Theorem 4 in <ref> [Hen61] </ref>. In all cases, the proofs substantially rely on the ability to distinguish one cell in the network: in our case, it is the environment, in [WL90] the first cell is explicitly distinguished, and in [Hen61] CHAPTER 7. ARRAYS OF IDENTICAL COMPONENTS 124 one cell is distinguished by different boundary condition. Therefore, the decidability of the existence of a finite invariant for open systems is still an open problem. <p> It might be more productive to apply this procedure interactively, i.e. to let the user choose a string and then execute other steps automatically. 7.5 Related work and discussion Although iterative systems have been studied for a long time <ref> [Hen61] </ref>, only re cently there has been a significant interest in the formal verification of such systems. Apt 1 We omit writing s 2 x;y for x &lt; 4, and assume that s 2 x;y = s 1 CHAPTER 7.
Reference: [HK88] <author> Z. Har'El and R. P. Kurshan. </author> <title> Software for analysis of coordination. </title> <booktitle> In Proceedings of the International Conference on System Science, </booktitle> <pages> pages 382-385, </pages> <year> 1988. </year>
Reference-contexts: We will review three such approaches: one suggested by Vardi and Wolper [VW86], one by Kurshan [Kur90] on which the verification tool COSPAN <ref> [HK88] </ref> is based, and finally one by Hojati and Brayton [HB95] on which the tool HSIS [ABB + 94] is based. <p> Building the region automaton: In this step a full region automaton is built for a subset of timers selected in step 1 with the optimized bounds from step 2. This approach has been implemented as an extension of the verification tool COSPAN <ref> [HK88] </ref>. 4.3.2 Minimization We have shown that the semantics of a timed automaton can be defined by an infinite state companion automaton. Alur and Dill construct the region automaton, a finite-state equivalent to the companion automaton, but that is not necessarily the smallest automaton equivalent to the companion automaton.
Reference: [HMAF94] <author> Y.V. Hoskote, J. Moondanos, J.A. Abraham, </author> <title> and D.S. Fussell. Abstraction of data path registers for multilevel verification of large circuits. </title> <booktitle> In Proceedings of Fourth Great Lakes Symposium on VLSI, Design Automation of High Performance VLSI Systems GLSV '94, </booktitle> <pages> pages 11-14. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: This naturally leads to application-specific methods, as high-level objects and typical properties are quite different for different application areas, for example microprocessors and communication protocols. We are already witnessing some contributions in this directions (e.g. <ref> [BD94, Bea93, HMAF94, MPS92] </ref>), and we can only expect this trend to grow stronger in the future. There are many other possible approaches to increase the practical value of formal verification. Let us just shortly describe two possibilities that have received virtually no attention in the research community.
Reference: [HNSY92] <author> Thomas A. Henzinger, Xavier Nicolin, Jospeh Sifakis, and Sergio Yovine. </author> <title> Symbolic model-checking for real-time systems. </title> <booktitle> In Proceedings of 7th Symposium on Logics in Computer Science. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <year> 1992. </year>
Reference-contexts: Still, not all symbolic approaches are BDD-based. For example, in the verification of real-time and hybrid systems, sets of linear inequalities are used to represent convex polyhedra bounded by them <ref> [HNSY92, ACHH93] </ref>. Recent advancements in symbolic computation techniques have significantly increased the capabilities of automatic formal verification, but simplifications are still necessary to handle most real-life systems. We make a distinction between two kinds of simplifications: exact and conservative. <p> Models of TCTL are timed graphs, which are finite-state structures similar to timed automata. They show that one can check whether a given timed graph is a model of a TCTL formula by traversing a finite-state structure similar to a region automaton. Henzinger et al. <ref> [HNSY92] </ref> show how this structure can be traversed symbolically, using predicates on timers and state variables to represent sets of states. That algorithm is implemented in the verification tool KRONOS [NSY92].
Reference: [HU79] <author> J.E. Hopcroft and J.D. Ullman. </author> <title> Introduction to Automata Theory, languages and Computation. </title> <publisher> Addison Wesley, </publisher> <year> 1979. </year>
Reference-contexts: These are finite structure that can represent possibly infinite sets of sequences of inputs and outputs of a system. There exists a wide body of knowledge concerning automata both on finite (e.g. see <ref> [HU79] </ref>) and infinite sequences (e.g. [Tho90, Eme90]). Here, we present only fragments of the developed theory that are relevant to our research results, and to the implementation of an efficient verification tool based on language containment. CHAPTER 2. <p> Also, every transition specifies for each counter whether it is to be incremented or decremented by 1. Two-counter machines can encode Turing machines and therefore their halting problem is undecidable. For more details, see <ref> [HU79, chapters 7, 8] </ref>. CHAPTER 4.
Reference: [KM89] <author> R. P. Kurshan and K. L. McMillan. </author> <title> A structural induction theorem for processes. </title> <booktitle> In Proceedings of the 8th ACM Symp. </booktitle> <address> PODC, </address> <year> 1989. </year>
Reference-contexts: We have used the solution with an encyclopedia <ref> [KM89] </ref> to insure that the system is deadlock and starvation free. All experiments were performed on a 400Mb DEC MIPS 5000 workstation. CHAPTER 3. <p> These restrictions still enable us to model many regular hardware arrays, such as stacks, FIFO buffers, counters and multi-processor busses. Other examples that fit into our framework are a token passing mutual exclusion protocol [WL90] and the ever-so-popular Dining Philosophers Problem (e.g. <ref> [KM89] </ref>). To define an array of identical components, we first define a generic cell as a quadruple (S; I; T; F ), where S is some non-empty set of states. <p> Both Kurshan and McMillan <ref> [KM89] </ref> and Wolper and Lovinfosse [WL90] require, by definition, for an invariant to be inductive. We have adopted a broader definition, motivated by the application to language containment. <p> Wolper and Lovinfosse [WL90] have studied formal verification of iterative systems generated by interconnecting identical processes in certain regular fashion. They also present some decidability results for related problems. Kurshan and McMillan <ref> [KM89] </ref> present slightly more general results which can be applied both to process algebra and automata-based approaches. In both cases, automatic tools are used only to verify that a finite state-system suggested by the user is indeed an invariant. <p> This idea was further developed by Rho and Somenzi [RS92, RS93], who have studied different network topologies and presented several sufficient conditions for the existence of such an invariant. CHAPTER 7. ARRAYS OF IDENTICAL COMPONENTS 135 Our approach builds on results in <ref> [KM89, WL90] </ref> in a sense that it provides automatic support for generating invariants for a larger class of systems than in [RS92, RS93]. This work can be naturally extended in several ways.
Reference: [Kur90] <author> R. P. Kurshan. </author> <title> Analysis of discrete event coordination. </title> <editor> In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, </editor> <booktitle> Stepwise Refinement of Distributed Systems : Models, Formalisms, Correctness, </booktitle> <pages> pages 414-453. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> LNCS vol. 430. </note>
Reference-contexts: Still, a careful use of abstractions can be beneficial. For example, one might check abstractions of (usually small) components, and deduce from that an abstraction of the (usually large) complete system. These and other strategies for simplification of communicating automata were studied by Kurshan <ref> [Kur90, Kur94] </ref>. The problem of checking automatically whether one system is an abstraction of another has received a wide attention in the last decade, but generating abstractions is currently mostly a manual task performed by users of verification systems. <p> Here, we differ slightly from the traditional approach (e.g. <ref> [VW86, Kur90] </ref>) where: 1. the user specify an automaton (say P ) that accepts exactly those strings representing acceptable behavior, i.e. all strings that do not violate the property, 2. the tool check whether the language of the system (henceforth denoted by L (A)) is contained in L (P ). <p> Constructing P 0 is a hard problem in general, but existing tools are restricted to special cases where constructing P 0 requires only simple syntactic modification of P . We will review three such approaches: one suggested by Vardi and Wolper [VW86], one by Kurshan <ref> [Kur90] </ref> on which the verification tool COSPAN [HK88] is based, and finally one by Hojati and Brayton [HB95] on which the tool HSIS [ABB + 94] is based. <p> In the following we assume that all definitions form section 2.2.2 are still valid except that of a fair run. 2.3.1 COSPAN approach An L-process <ref> [Kur90] </ref> is a 5-tuple (S; I; T; R; F ), where S; I; T; are as in previous definitions, R S fi S is some set of transitions called recur edges, and F = fZ 1 ; : : : ; Z jF j g is some set of subsets of <p> FORMAL VERIFICATION OF FINITE-STATE SYSTEMS 19 * inf (s 0 ; s 1 ; : : :) is not contained in any of the cycle sets. An L-automaton <ref> [Kur90] </ref> is syntactically the same as an L-process. <p> Thus, if an L-automaton (S; I; T; R; F ) is deterministic and complete, then its language is the complement of the language of the L-process (S; I; T; R; F ). Kurshan <ref> [Kur90] </ref> proposed to use L-processes to model systems and to use deterministic and complete L-automata to express properties. The language of the property is then complemented at no cost, by interpreting the corresponding deterministic and complete L-automaton as an L-process. <p> However, every !-regular language can be expressed as the intersection of languages of finitely many deterministic L-automata <ref> [Kur90] </ref>. Thus, it is possible to check any !-regular property by finitely many containment checks of L-automata languages. CHAPTER 2. FORMAL VERIFICATION OF FINITE-STATE SYSTEMS 22 cases that have been proposed are of the same complexity as the general problem. <p> In our knowledge, this and ours are the only approaches that demonstrate that state minimization is not the only possible simplification objective. 45 Chapter 4 Real-Time Systems Classical formal models abstract quantitative time and retain only the ordering of events (e.g. <ref> [CES86, Kur90] </ref>). However, for many systems it is essential to verify their real-time behavior. It is not enough that an alarm sent by a smoke detector gets to a fire station, it must get there in time.
Reference: [Kur94] <author> Robert P. Kurshan. </author> <title> Formal Verification of Coordinating Processes: The Automata-Theoretic Approach. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year> <note> To be pudlished. BIBLIOGRAPHY 145 </note>
Reference-contexts: Some of these issues have been addressed in the literature <ref> [ABB + 94, BBC + , Kur94] </ref>, but many practical questions have yet to be resolved. Last but not least, a formal verification method can be successful only only if accompanied with elaborate complexity management techniques. <p> Still, a careful use of abstractions can be beneficial. For example, one might check abstractions of (usually small) components, and deduce from that an abstraction of the (usually large) complete system. These and other strategies for simplification of communicating automata were studied by Kurshan <ref> [Kur90, Kur94] </ref>. The problem of checking automatically whether one system is an abstraction of another has received a wide attention in the last decade, but generating abstractions is currently mostly a manual task performed by users of verification systems. <p> * the set of fairness constraints of A 0 contains a constraint (X f (s; 1)js 2 Sg; 0) and one constraint of the form (1; X (Z i )) for every cycle set Z i 2 F . 2 This construction is easily derived from the node-recurring transform of <ref> [Kur94] </ref>. CHAPTER 2. FORMAL VERIFICATION OF FINITE-STATE SYSTEMS 20 The idea is to create a copy of the transition relation on two levels (0 and 1). Every recur edge leads to level 1 and every non-recur edge leads to level 0.
Reference: [Law76] <author> Eugene L. Lawler. </author> <title> Combinatorial optimization : networks and matroids. </title> <publisher> Holt, Rinehart and Winston, </publisher> <year> 1976. </year>
Reference-contexts: Also, define 0 = 0. Then, every inequality implied by a failure report can be written in a form: i j c ; for some i; j 2 f0; : : :; ng and some bound c. It is well known (e.g. <ref> [Law76] </ref>) that such a system of linear inequalities is feasible if and only if there are no negative weighted loops in the graph constructed as follows: * nodes of the graph are 0; : : : ; n , * for every inequality i j c add an edge from i
Reference: [LY92] <author> D. Lee and M. Yannakakis. </author> <title> Online minimization of transition systems. </title> <booktitle> In Proceedings of the Twenty-Fourth Annual ACM Symposium on the Theory of Computing, </booktitle> <address> Victoria, BC, Canada, </address> <month> 4-6 May </month> <year> 1992, </year> <pages> pages 264-274. </pages> <publisher> ACM, </publisher> <year> 1992. </year>
Reference-contexts: In general, given an automaton A and some initial partition , there exists a unique coarsest refinement 0 of which is stable with respect to the transition relation of A. Two algorithms have been proposed by Boujjani, Fernandez and Halbwachs [BFH90], and Lee and Yannakakis <ref> [LY92] </ref> to compute A 0 given A and . Both algorithms start with A = and then split some of its reachable, but unstable, states into more stable states. This operation is repeated until all reachable states are stabilized.
Reference: [McM93] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: The first efficient automatic model checking procedure for any temporal logic was given Clarke, Emerson and Sistla [CES86] for the branching time logic CTL, which still remains the most widely used logic in verification. For example, verification systems SMV <ref> [McM93] </ref>, and HSIS [ABB + 94] are based on it. Formulas of linear time temporal logics reason about paths, and the system is verified if the formula is true for all paths from the initial states. <p> INTRODUCTION 6 many practical cases large sets of states have quite small BDD representations, and thus it is possible to manipulate sets of states that are too large to enumerate with existing computing resources. BDD-based algorithms (and verification systems) are available both for model checking <ref> [McM93] </ref> and language containment [ABB + 94] The success of BDD-based approaches have made them almost synonymous to symbolic computation. Still, not all symbolic approaches are BDD-based. <p> The number of nodes in the BDD's must be much smaller than the number of reachable states. This condition is often met for system consisting of components communicating a limited amount of information (for detailed analysis see <ref> [McM93] </ref>). 2. The number of recursive calls must also be much smaller than the number of reachable states.
Reference: [MP81] <author> Zohar Manna and Anir Pnueli. </author> <title> Verification of concurrent programs: The temporal framework. </title> <editor> In R. Boyer and J. Moore, editors, </editor> <booktitle> Correctness Problem in Computer Science, </booktitle> <pages> pages 215-273. </pages> <publisher> Academic Press, </publisher> <year> 1981. </year>
Reference-contexts: The use of linear time temporal logics for specification and verification of finite-state systems dates back to late seventies and early eighties when in a trailblazing contribution Pnueli and Manna <ref> [Pnu77, MP81] </ref> use such a logic to specify many interesting properties of computer programs. Linear time temporal logics are still an interesting research topic, but their inherent complexity [SC85] has limited their use in practice. CHAPTER 1.
Reference: [MPS92] <author> Enrico Macii, Bernard Plessier, and Fabio Somenzi. </author> <title> Verification of systems containing counters. </title> <booktitle> In Digest of Technical Papers of the 1992 IEEE International Conference on CAD, </booktitle> <pages> pages 179-182. </pages> <publisher> IEEE Comput. Soc. Press, </publisher> <year> 1992. </year>
Reference-contexts: It is thus not surprising that some researchers have devoted special attention to abstracting the behavior of counters (e.g. <ref> [MPS92] </ref>). 2.6 Language emptiness algorithm The basic steps in checking language emptiness are the same both for automata on finite and infinite sequences. They are outlined in Figure 2.8. <p> This naturally leads to application-specific methods, as high-level objects and typical properties are quite different for different application areas, for example microprocessors and communication protocols. We are already witnessing some contributions in this directions (e.g. <ref> [BD94, Bea93, HMAF94, MPS92] </ref>), and we can only expect this trend to grow stronger in the future. There are many other possible approaches to increase the practical value of formal verification. Let us just shortly describe two possibilities that have received virtually no attention in the research community.
Reference: [MV94] <author> Jennifer McManis and Pravin Varaiya. </author> <title> Suspension automata: A decidable class of hybrid automata. </title> <editor> In David L. Dill, editor, </editor> <booktitle> Proceedings of Computer Aided Verification: 6th International Conference, </booktitle> <address> CAV'94, Stanford, CA, </address> <month> June </month> <year> 1994, </year> <pages> pages 105-117. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> LNCS vol. 818. </note>
Reference-contexts: In this section we present a model of PATHO that takes this effect into account. Assume that ISR requires time units. There are two ways to model the effect of ISR to the execution of a task <ref> [MV94] </ref>: 1. whenever ISR is executed, the value of a timer measuring running time of task (i.e. y i in Figure 5.2) is "frozen" for time units, 2. whenever ISR is executed, the value of y i is decremented by , but y i continues to increase.
Reference: [NJK94] <author> B. E. Nelson, R. B. Jones, and D. A. Kirkpatrick. </author> <title> Simulation event pattern checking with proto. </title> <booktitle> In Proceedings of the SHDL Conference, </booktitle> <year> 1994. </year>
Reference-contexts: Unfortunately, neither finite-state automata, nor CTL formulas satisfy these conditions. A promising approach to this problem is to develop translators that provides formal interpre CHAPTER 1. INTRODUCTION 5 tation (in terms of automata or temporal logic formulas) of specification methods used by designers, such as HDL annotations <ref> [NJK94, ALG + 91, BBC + ] </ref> or timing diagrams [SD93]. Another issue that has to be addressed before automatic formal verification is widely accepted is the development of a verification based design methodology.
Reference: [NSY92] <author> Xavier Nicolin, Jospeh Sifakis, and Sergio Yovine. </author> <title> Compiling real-time specifications into extended automata. </title> <journal> IEEE TSE Special Issue on Real-Time Systems, </journal> <month> September </month> <year> 1992. </year>
Reference-contexts: Henzinger et al. [HNSY92] show how this structure can be traversed symbolically, using predicates on timers and state variables to represent sets of states. That algorithm is implemented in the verification tool KRONOS <ref> [NSY92] </ref>. In the implementation, untimed components of the state are explicitly enumerated, and sets of values of timers are again represented by difference bound matrices. <p> Unfortunately, no experimental results are available for SA to confirm these expectations. An approach somewhat between the successive approximation and the TLE algorithm was suggested by Balarin and Sangiovanni-Vincentelli [BSV93]. This approach 5 This expectation is supported by some experimental results <ref> [NSY92] </ref> CHAPTER 4. <p> Thus, it addresses both untimed state explosion and stiffness problems. 4.7 Experimental results We have applied TLE algorithm (with and without hints) to the following examples of timed automata: * a model of the CSMA/CD protocol <ref> [NSY92] </ref> consisting of two stations and a channel; we have verified that a collision on the channel is always detected within a given time frame, * a model of the FDDI token ring protocol [CDCT93] consisting of three stations; we have verified that every station transmits infinitely often (labeled by fddi-l
Reference: [Pet93] <author> K. Petty. </author> <title> The PATHO Operating System and User's Guide. </title> <type> Technical report, </type> <institution> UC Berkeley, </institution> <year> 1993. </year>
Reference-contexts: In the next chapter, we present a model that uses timer decrements. An extension of the TLE algorithm that could be used to verify such systems is also presented. CHAPTER 5. REAL-TIME OPERATING SYSTEM 94 5.1 PATHO operating system PATHO real-time operating system <ref> [Pet93] </ref> is an example of an embedded system. It is intended for the automatic control of a vehicle [Var93]. To preserve vehicle safety, PATHO must manage a collection of subroutines, called tasks, such that they meet strict real-time requirements imposed by the environment.
Reference: [Pne92] <author> Amir Pneuli. </author> <title> How vital is liveness? In W. </title> <editor> R. Cleaveland, editor, CONCUR'92: </editor> <booktitle> Proc. of the Third International Conference on Concurrency The BIBLIOGRAPHY 146 ory, </booktitle> <address> Stony Brook, NY, USA, </address> <month> August </month> <year> 1992, </year> <pages> pages 162-175. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <note> LNCS vol. 630. </note>
Reference-contexts: Another issue is finite versus infinite sequences. We develop our formalism for automata on finite sequences, mostly for simplicity, but also to stress the fact (argued also in <ref> [Pne92] </ref>) that infinite sequences are more important for untimed than for real-time systems.
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In 18th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 46-57, </pages> <month> October </month> <year> 1977. </year>
Reference-contexts: The use of linear time temporal logics for specification and verification of finite-state systems dates back to late seventies and early eighties when in a trailblazing contribution Pnueli and Manna <ref> [Pnu77, MP81] </ref> use such a logic to specify many interesting properties of computer programs. Linear time temporal logics are still an interesting research topic, but their inherent complexity [SC85] has limited their use in practice. CHAPTER 1.
Reference: [PV94] <author> Anuj Puri and Pravin Varaiya. </author> <title> Verification of hybrid systems using timed abstractions. </title> <booktitle> In Proc. Workshop on Hybrid Systems, </booktitle> <month> October </month> <year> 1994. </year>
Reference-contexts: consisting of three, four or five processes (labeled fis3, fis4, and fis5 in Table 4.1), * a model of a seat-belt alarm controller [CGH + 93] (labeled belt); we have verified that the alarm is never on for more than twenty time units, * a model of an automated factory <ref> [PV94] </ref> consisting of a production line, a service station, two boxes, and two robots that move boxes between the service station and the line; we have verified that robots will always pick up a box before it reaches the end of the line, * both safety (labeled cross-s) and liveness (labeled
Reference: [RM94] <author> T.G. Rokicki and C.J. Myers. </author> <title> Automatic verification of timed circuits. </title> <editor> In David L. Dill, editor, </editor> <booktitle> Proceedings of Computer Aided Verification: 6th International Conference, </booktitle> <address> CAV'94, Stanford, CA, </address> <month> June </month> <year> 1994, </year> <pages> pages 468-480. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> LNCS vol. 818. </note>
Reference-contexts: Another approach is based on timed Petri nets <ref> [YSSC93, RM94] </ref>. The straightforward implementation requires a traversal of (equivalents of) region automata, but in a more careful implementation all the untimed states generated by different orderings of independent events are considered equivalent, and only a single representative is explored.
Reference: [RS92] <author> J.K. Rho and F. Somenzi. </author> <title> Inductive verification of iterative systems. </title> <booktitle> In Proceedings of the 29th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 628-33, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Kurshan and McMillan have hinted that it might be a good idea to check whether a system of some fixed size serves as an invariant. This idea was further developed by Rho and Somenzi <ref> [RS92, RS93] </ref>, who have studied different network topologies and presented several sufficient conditions for the existence of such an invariant. CHAPTER 7. <p> CHAPTER 7. ARRAYS OF IDENTICAL COMPONENTS 135 Our approach builds on results in [KM89, WL90] in a sense that it provides automatic support for generating invariants for a larger class of systems than in <ref> [RS92, RS93] </ref>. This work can be naturally extended in several ways. From the theoretical point of view, the decidability of existence of a finite invariant for open iterative systems needs to be studied. From the practical point of view, it would be useful to generalize the conditions for non-existence.
Reference: [RS93] <author> J.K. Rho and F. Somenzi. </author> <title> Automatic generation of network invariants for the verification of iterative sequential systems. In Costas Courcoubetis, editor, </title> <booktitle> Computer Aided Verification: 5th International Conference, CAV'93, Elounda, Greece, June/July 1993, Proceedings, </booktitle> <pages> pages 123-137. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> LNCS vol. 697. </note>
Reference-contexts: Kurshan and McMillan have hinted that it might be a good idea to check whether a system of some fixed size serves as an invariant. This idea was further developed by Rho and Somenzi <ref> [RS92, RS93] </ref>, who have studied different network topologies and presented several sufficient conditions for the existence of such an invariant. CHAPTER 7. <p> CHAPTER 7. ARRAYS OF IDENTICAL COMPONENTS 135 Our approach builds on results in [KM89, WL90] in a sense that it provides automatic support for generating invariants for a larger class of systems than in <ref> [RS92, RS93] </ref>. This work can be naturally extended in several ways. From the theoretical point of view, the decidability of existence of a finite invariant for open iterative systems needs to be studied. From the practical point of view, it would be useful to generalize the conditions for non-existence.
Reference: [SC85] <author> Aravinda P. Sistla and Edmund M. Clarke. </author> <title> Complexity of propositional linear temporal logics. </title> <journal> Journal of the ACM, </journal> <volume> 32(3) </volume> <pages> 733-749, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: Linear time temporal logics are still an interesting research topic, but their inherent complexity <ref> [SC85] </ref> has limited their use in practice. CHAPTER 1. INTRODUCTION 3 Linear temporal logics are closely related to another popular verification paradigm known as language containment, pioneered among the others by Vardi and Wolper [VW86].
Reference: [SCSVB92] <author> Thomas R. Shiple, Massimiliano Chiodo, Alberto L. Sangiovanni-Vincentelli, and Robert K. Brayton. </author> <title> Automatic reduction in CTL compositional model checking. </title> <booktitle> In Proc. Fourth Workshop on Computer-Aided Verification, </booktitle> <pages> pages 225-238, </pages> <address> Montreal, </address> <month> June </month> <year> 1992. </year> <note> Also appeared in Lecture Notes in Computer Science, vol. 663. </note>
Reference-contexts: In particular, approaches are developed for preserving all CTL formulas [CLM89, CHAPTER 3. NETWORKS OF COMMUNICATING AUTOMATA 44 BFH90], all ACTL formulas [DGG93], a single CTL formula <ref> [SCSVB92, ASSSV94] </ref>, and a single ACTL formula [DGG93]. Computing the quotient of a given system in the simplest form requires traversal of the state space, and thus is as hard as verifying the system. <p> Initially, a quotient is constructed with respect to a very coarse equivalence (that does not necessarily have any preservation properties). The equivalence and the quotient are then iteratively refined until the preservation is achieved. In <ref> [CLM89, CGL92, SCSVB92, ASSSV94] </ref> the quotient is built hierarchically: components are first abstracted, then composed, and then abstracted again to simplify building of even larger blocks. Finally, in [GL93] an approximation of the quotient is computed directly from the program text. <p> Better simplifications are to be expected from property-specific approaches like ours and <ref> [SCSVB92, ASSSV94, DGG93] </ref>. A quite different approach was taken by Halbwachs [Hal93]. Rather than simplifying a system beforehand, the simplifications are made while computing reachable states. Sets of states are computed symbolically, and instead of the exact set of reachable states, a superset with smaller symbolic representation is computed.
Reference: [SD93] <author> R. Schlor and W. Damm. </author> <title> Specification and verification of system level hardware designs using timing diagrams. </title> <booktitle> In Proceedings of The European Conference on Design Automation, </booktitle> <address> Paris, France, </address> <month> February </month> <year> 1993, 1993. </year> <note> BIBLIOGRAPHY 147 </note>
Reference-contexts: A promising approach to this problem is to develop translators that provides formal interpre CHAPTER 1. INTRODUCTION 5 tation (in terms of automata or temporal logic formulas) of specification methods used by designers, such as HDL annotations [NJK94, ALG + 91, BBC + ] or timing diagrams <ref> [SD93] </ref>. Another issue that has to be addressed before automatic formal verification is widely accepted is the development of a verification based design methodology.
Reference: [SG90] <author> Z. Shtadler and O. Grumberg. </author> <title> Network grammars, communication behaviors and automatic verification. </title> <editor> In J. Sifakis, editor, </editor> <title> Automatic Verification Methods for Finite State Systems, </title> <booktitle> International Workshop Proceedings, </booktitle> <address> Grenoble, France, </address> <month> 12-14 June </month> <year> 1989, </year> <pages> pages 151-65. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> LNCS vol. 407. </note>
Reference-contexts: Browne, Clarke and Grumberg [BCG89], and Shtadler and Grumberg <ref> [SG90] </ref> have studied conditions under which the satisfaction of formulas of certain temporal logics is independent of the size of the system. In [SG90] the conditions seem to be quite restrictive, while in [BCG89] the conditions cannot in general be checked automatically. <p> Browne, Clarke and Grumberg [BCG89], and Shtadler and Grumberg <ref> [SG90] </ref> have studied conditions under which the satisfaction of formulas of certain temporal logics is independent of the size of the system. In [SG90] the conditions seem to be quite restrictive, while in [BCG89] the conditions cannot in general be checked automatically. Wolper and Lovinfosse [WL90] have studied formal verification of iterative systems generated by interconnecting identical processes in certain regular fashion. They also present some decidability results for related problems.
Reference: [Str82] <author> R. S. Streett. </author> <title> Propositional dynamic logic of looping and converse is elementarily decidable. </title> <journal> Information and Control, 54(no.1-2):121-141, </journal> <volume> July-Aug. </volume> <year> 1982. </year>
Reference-contexts: In our development we use a version due to Streett <ref> [Str82] </ref>, which we introduce next in detail. We will review other kinds suggested for formal verification in section 2.3.
Reference: [SV89] <author> Shmuel Safra and Moshe Y. Vardi. </author> <title> On !-automata and temporal logic. </title> <booktitle> In Proceedings of the Twenty First Annual ACM Symposium on Theory of Computing, </booktitle> <address> Seattle, WA, USA, </address> <month> 15-17 May </month> <year> 1989, </year> <pages> pages 127-137, </pages> <year> 1989. </year>
Reference-contexts: This construction may incur an exponential blow-up, but that is considered acceptable because linear temporal logic is a very succinct language for expressing properties (it can be shown that it is exponentially more succinct than any kind of automata we consider here <ref> [SV89] </ref>). Any Buchi automaton can be interpreted as a Streett automaton with a single fairness constraint (1; X (F )). Thus, the approach by Vardi and Wolper can easily be embedded into our framework. <p> automata are as expressive as Streett automata, they are exponentially less succinct, i.e. for every n &gt; 0 there exists a language L n which can be described by a Street automaton with O (n) states, but cannot be described by any Buchi automaton with less than 2 n states <ref> [SV89] </ref>. In the rest of this work we will restrict our attention to the emptiness problem for the intersection of languages of Streett automata. As we have shown, this problem is general enough to include all language containment based verification approaches that have been considered.
Reference: [Tar83] <author> Robert Endre Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA, </address> <year> 1983. </year>
Reference-contexts: Finding a negative weighted loop in a graph is a well understood problem for which a polynomial algorithm exists <ref> [Tar83] </ref>. To analyze a failure report we build a graph similar to the one described above, except that we assign to edges not only their weight, but also some additional information to be used later in the failure elimination phase.
Reference: [Tho90] <author> W. Thomas. </author> <title> Automata on infinite objects. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 133-191. </pages> <publisher> Elsvier Science Publishers B. V., </publisher> <year> 1990. </year>
Reference-contexts: These are finite structure that can represent possibly infinite sets of sequences of inputs and outputs of a system. There exists a wide body of knowledge concerning automata both on finite (e.g. see [HU79]) and infinite sequences (e.g. <ref> [Tho90, Eme90] </ref>). Here, we present only fragments of the developed theory that are relevant to our research results, and to the implementation of an efficient verification tool based on language containment. CHAPTER 2.
Reference: [Var93] <author> Pravin Varaiya. </author> <title> Smart cars on smart roads: Problems of control. </title> <journal> IEEE Trans. on Automatic Control, </journal> <volume> 38(2) </volume> <pages> 195-207, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: An extension of the TLE algorithm that could be used to verify such systems is also presented. CHAPTER 5. REAL-TIME OPERATING SYSTEM 94 5.1 PATHO operating system PATHO real-time operating system [Pet93] is an example of an embedded system. It is intended for the automatic control of a vehicle <ref> [Var93] </ref>. To preserve vehicle safety, PATHO must manage a collection of subroutines, called tasks, such that they meet strict real-time requirements imposed by the environment. There are three different types of tasks: background tasks, control tasks, and event tasks.
Reference: [Var94] <author> Moshe Vardi, </author> <year> 1994. </year> <title> A remark during the presentation at Computer Aided Verification: </title> <booktitle> 6th International Conference, </booktitle> <address> CAV'94, Stanford, CA, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: As Vardi <ref> [Var94] </ref> summed it nicely: "Verification is successful only if it fails". From this point of view, conservative simplifications produce an additional burden of verifying that a reported bug is due to original system and not due to over-simplification.
Reference: [VW86] <author> Moshe Y. Vardi and Pierre Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proc. IEEE Symp. on Logic in Computer Science, </booktitle> <pages> pages 332-344, </pages> <address> Boston, </address> <month> July </month> <year> 1986. </year>
Reference-contexts: Linear time temporal logics are still an interesting research topic, but their inherent complexity [SC85] has limited their use in practice. CHAPTER 1. INTRODUCTION 3 Linear temporal logics are closely related to another popular verification paradigm known as language containment, pioneered among the others by Vardi and Wolper <ref> [VW86] </ref>. Here, systems are model as automata, and the language accepted by an automaton is assumed to be its behavior. In other words, the behavior of a finite state system is a set of input-output sequences that can be observed from the outside. <p> That language is specified by another automaton, so the verification problem reduces to checking language containment between two automata. Model checking of linear temporal logics can be reduced to language containment <ref> [VWS83, VW86] </ref>. First, we construct an automaton that accepts all the sequences that satisfy the formula. Then, we check whether the language of that automaton contains the language of the system. 1.2 Real-time systems In all of the approaches mentioned so far time is modeled qualitatively. <p> Here, we differ slightly from the traditional approach (e.g. <ref> [VW86, Kur90] </ref>) where: 1. the user specify an automaton (say P ) that accepts exactly those strings representing acceptable behavior, i.e. all strings that do not violate the property, 2. the tool check whether the language of the system (henceforth denoted by L (A)) is contained in L (P ). <p> Constructing P 0 is a hard problem in general, but existing tools are restricted to special cases where constructing P 0 requires only simple syntactic modification of P . We will review three such approaches: one suggested by Vardi and Wolper <ref> [VW86] </ref>, one by Kurshan [Kur90] on which the verification tool COSPAN [HK88] is based, and finally one by Hojati and Brayton [HB95] on which the tool HSIS [ABB + 94] is based. <p> A run s 0 ; s 1 ; : : : is fair if inf (s 0 ; s 1 ; : : :) intersects F . Vardi and Wolper <ref> [VW86] </ref> CHAPTER 2. FORMAL VERIFICATION OF FINITE-STATE SYSTEMS 21 suggested to model a system as a Buchi automaton (say A), and to model a property as another Buchi automaton (say P ) which accepts all sequences that are models of some linear temporal logic formula .
Reference: [VWS83] <author> Moshe Y. Vardi, Pierre Wolper, and Aravinda P. Sistla. </author> <title> Reasoning about infinite computation paths. </title> <booktitle> In Proceedings of 24th Annual Symposium on Foundations of Computer Science, </booktitle> <address> Tucson, AZ, USA, 7-9 Nov. 1983. </address> <publisher> IEEE Comput. Soc. Press, </publisher> <year> 1983. </year> <note> BIBLIOGRAPHY 148 </note>
Reference-contexts: That language is specified by another automaton, so the verification problem reduces to checking language containment between two automata. Model checking of linear temporal logics can be reduced to language containment <ref> [VWS83, VW86] </ref>. First, we construct an automaton that accepts all the sequences that satisfy the formula. Then, we check whether the language of that automaton contains the language of the system. 1.2 Real-time systems In all of the approaches mentioned so far time is modeled qualitatively.
Reference: [Vyt91] <editor> J. Vytopil, editor. </editor> <booktitle> Formal Techiques in Real-Time and Fault-Tolerant Systems, volume 571 of LNCS. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <booktitle> Proceedings of the Second International Symposium, </booktitle> <address> Nijmegen, The Netherlands. </address>
Reference-contexts: At a higher level of abstraction, constraints are typically more complex. For example, the speed by which a software task progresses might change in time depending on the load of the system. Many formalisms that can capture complex timing constraints have been proposed (e.g. see <ref> [Vyt91, dBHdRR91, AH92] </ref> for a compilation of many approaches), but most are not suitable for automatic verification, because the associated verification problems are undecidable. This is true even for some straightforward extensions of standard finite-state models (e.g. [AL91]). <p> Again, every class of is represented by a single untimed component and by a difference bound matrix. A similar algorithm is also implemented in another real-time extension of COSPAN by Courcoubetis et al. [CDCT93]. 4.3.3 Other formalisms Several other models have been proposed for real-time systems <ref> [dBHdRR91, Vyt91, AH92] </ref>. Many of these formalisms have undecidable verification problems, and those that are decidable use in some form the equivalence theorem of Alur and Dill.
Reference: [WL90] <author> P. Wolper and V. Lovinfosse. </author> <title> Verifying properties of large sets of processes with network invariants. </title> <editor> In J. Sifakis, editor, </editor> <title> Automatic Verification Methods for Finite State Systems, </title> <booktitle> International Workshop Proceedings, </booktitle> <address> Grenoble, France, </address> <month> 12-14 June </month> <year> 1989, </year> <pages> pages 68-80. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year> <note> LNCS vol. 407. </note>
Reference-contexts: Thus, using our approach only safety properties can be verified. These restrictions still enable us to model many regular hardware arrays, such as stacks, FIFO buffers, counters and multi-processor busses. Other examples that fit into our framework are a token passing mutual exclusion protocol <ref> [WL90] </ref> and the ever-so-popular Dining Philosophers Problem (e.g. [KM89]). To define an array of identical components, we first define a generic cell as a quadruple (S; I; T; F ), where S is some non-empty set of states. <p> In fact, this result is similar to Theorem 4.3 in <ref> [WL90] </ref> and Theorem 4 in [Hen61]. In all cases, the proofs substantially rely on the ability to distinguish one cell in the network: in our case, it is the environment, in [WL90] the first cell is explicitly distinguished, and in [Hen61] CHAPTER 7. <p> In fact, this result is similar to Theorem 4.3 in <ref> [WL90] </ref> and Theorem 4 in [Hen61]. In all cases, the proofs substantially rely on the ability to distinguish one cell in the network: in our case, it is the environment, in [WL90] the first cell is explicitly distinguished, and in [Hen61] CHAPTER 7. ARRAYS OF IDENTICAL COMPONENTS 124 one cell is distinguished by different boundary condition. Therefore, the decidability of the existence of a finite invariant for open systems is still an open problem. <p> Both Kurshan and McMillan [KM89] and Wolper and Lovinfosse <ref> [WL90] </ref> require, by definition, for an invariant to be inductive. We have adopted a broader definition, motivated by the application to language containment. Still, Theorem 7.2 provides the only finite procedure known to us, for verifying that a given automaton with non-trivial language is indeed an invariant. <p> Note that Theorem 7.2 provides only one way implication: it is quite possible that an automaton is an invariant, but not an inductive one. In fact, Wolper and Lovin-fosse <ref> [WL90] </ref> have shown that there exists an iterative system fN n jn 1g and an automaton P such that P is an invariant of fN n jn 1g, but there does not exist an inductive invariant of fN n jn 1g whose language is contained in L (P ). <p> In [SG90] the conditions seem to be quite restrictive, while in [BCG89] the conditions cannot in general be checked automatically. Wolper and Lovinfosse <ref> [WL90] </ref> have studied formal verification of iterative systems generated by interconnecting identical processes in certain regular fashion. They also present some decidability results for related problems. Kurshan and McMillan [KM89] present slightly more general results which can be applied both to process algebra and automata-based approaches. <p> This idea was further developed by Rho and Somenzi [RS92, RS93], who have studied different network topologies and presented several sufficient conditions for the existence of such an invariant. CHAPTER 7. ARRAYS OF IDENTICAL COMPONENTS 135 Our approach builds on results in <ref> [KM89, WL90] </ref> in a sense that it provides automatic support for generating invariants for a larger class of systems than in [RS92, RS93]. This work can be naturally extended in several ways.
Reference: [YL93] <author> M. Yannakakis and D. Lee. </author> <title> An efficient algorithm for minimizing real-time transitions systems. In Costas Courcoubetis, editor, </title> <booktitle> Computer Aided Verification: 5th International Conference, CAV'93, Elounda, Greece, June/July 1993, Proceedings, </booktitle> <pages> pages 210-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> LNCS vol. 697. </note>
Reference-contexts: The algorithms are given in CHAPTER 4. REAL-TIME SYSTEMS 58 terms of abstract operations post (for reachability), pre (for checking stability) and split (for making classes more stable). Alur et al. [ACD + 92, ACH + 92] and Yannakakis and Lee <ref> [YL93] </ref> have specialized these algorithms to timed automata.
Reference: [Yov92] <author> Sergio Yovine, </author> <year> 1992. </year> <title> private communication. </title>
Reference-contexts: The time in the preTLE approach grows more than linearly with the cycle time, while with the TLE approach the time stays constant. These experiments were performed without hints. In Table 4.3 we compare the results for TLE algorithm with the results from the tool KRONOS <ref> [Yov92] </ref>, and the results obtained by minimization approaches (using both surjective and stable partitions) presented by Alur et al. [ACD + 92]. Compared to other available results TLE algorithm is comparable without hints and always better with hints.
Reference: [YSSC93] <author> T. Yoneda, A. Shibayama, B.-H. Schlingloff, and E.M. Clarke. </author> <title> Efficient verification of parallel real-time systems. In Costas Courcoubetis, editor, </title> <booktitle> Computer Aided Verification: 5th International Conference, CAV'93, Elounda, Greece, June/July 1993, Proceedings, </booktitle> <pages> pages 321-332. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <note> LNCS vol. 697. </note>
Reference-contexts: Another approach is based on timed Petri nets <ref> [YSSC93, RM94] </ref>. The straightforward implementation requires a traversal of (equivalents of) region automata, but in a more careful implementation all the untimed states generated by different orderings of independent events are considered equivalent, and only a single representative is explored.
References-found: 80

