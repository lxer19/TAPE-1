URL: http://www.cs.wustl.edu/~schmidt/C++-EP.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: http://www.cs.wustl.edu
Email: chris@cs.wustl.edu and schmidt@cs.wustl.edu  
Title: External Polymorphism An Object Structural Pattern for Transparently Extending C++ Concrete Data Types  
Author: Chris Cleeland and Douglas C. Schmidt 
Address: St. Louis, MO 63130, (314) 935-7538  
Affiliation: Department of Computer Science, Washington University  
Abstract: This paper appeared in the September 1998 issue of the C++ Report magazine. An earlier subset of this paper appeared as a chapter in the book Pattern Languages of Program Design 3 ISBN, edited by Robert Martin, Frank Buschmann, and Dirke Riehle published by Addison-Wesley, 1997. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Introduction This paper describes the External Polymorphism pattern, which allows classes that are not related by inheritance and/or have no virtual methods to be treated polymorphi-cally. This pattern combines C++ language features with patterns like Adapter and Decorator <ref> [1] </ref> to give the appearance of polymorphic behavior on otherwise unrelated classes. The External Polymorphism pattern has been used in a number of C++ frameworks such as ACE [2] and the OSE class library. This article is organized as follows. <p> Object DB is an in-memory database Singleton <ref> [1] </ref>, i.e., there's only one copy per-process. To preserve encapsulation, the Object DB::dump all method could access the state information of the SOCK Stream, SOCK Acceptor, and INET Addr objects by calling a dump method defined by these classes. <p> A typical implementation will simply forward the virtual call to the specific request method in the parameterized class. If the signatures of methods in the Concrete class don't match those of the Common it may be necessary to use the Adapter pattern <ref> [1] </ref> to make them con form. Access Method (::dump&lt;&gt;): * The template function forwards requests to the object. In some cases, e.g., where the signature of specific request is consistent, this feature may not be needed. <p> came from usage in the OSE class library, by Graham Dumpleton. 2 In OSE, template functions are used to define collating algorithms for ordered lists, etc. 1.10 Related Patterns The External Polymorphism pattern is similar to the Decorator and Adapter patterns from the Gang of Four (GoF) design patterns catalog <ref> [1] </ref>. The Decorator pattern dynamically extends an object transparently without using subclassing. When a client uses a Decorated object it thinks it's operating on the actual object, when in fact it operates on the Decorator. The Adapter pattern converts the interface of a class into another interface clients expect. <p> This design is similar to the Adapter and Decorator patterns <ref> [1] </ref>. <p> In particular, it is not as broadly applicable as the Singleton or Adapter patterns <ref> [1] </ref>. However, External Polymorphism does solve a very subtle, real-world problem encountered by developers implementing complex software in statically-typed languages like C++. Re-use, and thus integration, typically occurs at source level.
Reference: [2] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: This pattern combines C++ language features with patterns like Adapter and Decorator [1] to give the appearance of polymorphic behavior on otherwise unrelated classes. The External Polymorphism pattern has been used in a number of C++ frameworks such as ACE <ref> [2] </ref> and the OSE class library. This article is organized as follows. <p> SOCK_Stream::SOCK_Stream (void) - REMOVE_OBJECT (SOCK_Stream); - 2.3 Sample Code The following code was adapted 3 from the ACE framework, which is an object-oriented toolkit for developing communication software <ref> [2] </ref>. This code illustrates how to use the External Polymorphism pattern to implement a mechanism that registers all live ACE objects with a central in-memory object database. Applications can dump the state of all live ACE objects, e.g., from within a debugger.
Reference: [3] <author> C. Cleeland, D. C. Schmidt, and T. Harrison, </author> <title> External Poly-morphism An Object Structural Pattern for Transparently Extending Concrete Data Types, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: The External Polymorphism pattern has been used in a number of C++ frameworks such as ACE [2] and the OSE class library. This article is organized as follows. Section 1 describes the External Polymorphism pattern in much greater detail than an earlier version appearing in <ref> [3] </ref>, Section 2 describes an example implementation using C++, and Section 3 presents concluding remarks. 1 The External Polymorphism Pat tern 1.1 Intent Allow classes that are not related by inheritance and/or have no virtual methods to be treated polymorphically. 1.2 Motivation Debugging applications built using reusable class libraries can be
Reference: [4] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: To motivate the External Polymorphism pattern, consider the following code that uses the SOCK Stream, SOCK Acceptor, and INET Addr library classes, which encapsulate the socket network programming interface within type-safe C++ wrappers <ref> [4] </ref>: 1. // In-memory Singleton object database. 2. class Object_DB - /* ... */ -; 3. SOCK_Acceptor acceptor; // Global storage 4. 5. int main (void) - 6. SOCK_Stream stream; // Automatic storage 7. INET_Addr *addr = 8. new INET_Addr; // Dynamic storage. 9. <p> This extra vptr may not be feasible for class libraries that contain concrete data types, such as classes for complex numbers, stacks and queues, and interprocess communication (IPC) interfaces <ref> [4] </ref>. The complicating factor for concrete data types is that they do not contain any virtual methods. Since virtual methods and inheritance are the C++ language mechanisms that support polymorphism, a concrete data type is by definition precluded from using those mechanisms to specialize the dump method.
Reference: [5] <author> Bjarne Stroustrup, </author> <title> The C++ Programming Language, 2 nd Edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: Space efficiency the solution must not constrain the storage layout of existing objects. In particular, classes having no virtual methods, i.e., concrete data types <ref> [5] </ref>, must not be forced to add a virtual table pointer (vptr). 2. Polymorphism all library objects must be accessed in a uniform manner. The remainder of this section describes and evaluates three solutions for implementing the Object DB facility. The first two solutions exhibit several common traps and pitfalls.
Reference: [6] <author> D. Lea, libg++, </author> <title> the GNU C++ Library, </title> <booktitle> in Proceedings of the 1 st C++ Conference, </booktitle> <address> (Denver, </address> <publisher> CO), </publisher> <pages> pp. 243256, </pages> <publisher> USENIX, </publisher> <month> Oct. </month> <year> 1988. </year>
Reference-contexts: Polymorphism pattern to avoid the problems with the first two approaches. 1.3 Common Traps and Pitfalls The limitations with two obvious ways of implementing the functionality of Object DB for statically-typed object-oriented programming languages (such as C++ or Eiffel) are presented below. 1.3.1 Tree-based Class Library Solution Tree-based class libraries <ref> [6] </ref> have a common class, such as class Object, that forms the root of all inheritance hierarchies. For these types of class libraries, the typical polymorphic solution is to add a pure virtual method called dump into the root class. <p> It requires all classes to inherit from a common root class: Conventional wisdom deprecates single root tree-based class library design strategy in languages like C++ <ref> [6, 7] </ref>. For instance, inheriting from a common root object complicates integration with third-party libraries. Moreover, the tree-based approach makes it hard to use subsets of library functionality without including many unnecessary headers and library code modules.
Reference: [7] <author> A. Stepanov and M. Lee, </author> <title> The Standard Template Library, </title> <type> Tech. Rep. </type> <institution> HPL-94-34, Hewlett-Packard Laboratories, </institution> <month> April </month> <year> 1994. </year>
Reference-contexts: Each subclass in the library could then override the dump method to display subclass-specific state, as shown in Figure 1. Using this approach, implementing dump ()fl Dumpablefl ::dump&lt;MyClass&gt;()fl MyClassfl ::dump&lt;MyDerivedClass&gt;()fl MyDerivedClassfl ::dump&lt;LibAClass&gt;()fl LibAClassfl ::dump&lt;LibBClass&gt;()fl LibBClassfl Object_DBfl Object DB::dump all is straightforward: 1 1 Standard Template Library <ref> [7] </ref> classes are used wherever possible in examples, based on information in [8]. void Object_DB::dump_all (void) - struct DumpObject - void operator ()(const Object &obj) - obj-&gt;dump (); - // Dump all the objects in the table. for_each (this-&gt;object_table_.begin (), this-&gt;object_table_.end (), DumpObject ()); - There are several drawbacks to the <p> It requires all classes to inherit from a common root class: Conventional wisdom deprecates single root tree-based class library design strategy in languages like C++ <ref> [6, 7] </ref>. For instance, inheriting from a common root object complicates integration with third-party libraries. Moreover, the tree-based approach makes it hard to use subsets of library functionality without including many unnecessary headers and library code modules. <p> For instance, inheriting from a common root object complicates integration with third-party libraries. Moreover, the tree-based approach makes it hard to use subsets of library functionality without including many unnecessary headers and library code modules. For these reasons, the Standard Template Library <ref> [7] </ref> from the ISO/ANSI C++ draft specifically avoids inheriting from a single root class. 3. It may require changes to storage layout: For C++ libraries, all objects with virtual methods must contain vptrs in their storage layout.
Reference: [8] <author> D. L. Musser and A. Saini, </author> <title> STL Tutorial and Reference Guide: C++ Programming with the Standard Template Library. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Using this approach, implementing dump ()fl Dumpablefl ::dump&lt;MyClass&gt;()fl MyClassfl ::dump&lt;MyDerivedClass&gt;()fl MyDerivedClassfl ::dump&lt;LibAClass&gt;()fl LibAClassfl ::dump&lt;LibBClass&gt;()fl LibBClassfl Object_DBfl Object DB::dump all is straightforward: 1 1 Standard Template Library [7] classes are used wherever possible in examples, based on information in <ref> [8] </ref>. void Object_DB::dump_all (void) - struct DumpObject - void operator ()(const Object &obj) - obj-&gt;dump (); - // Dump all the objects in the table. for_each (this-&gt;object_table_.begin (), this-&gt;object_table_.end (), DumpObject ()); - There are several drawbacks to the tree-based solution, however: 1.
Reference: [9] <author> D. C. Schmidt and T. Harrison, </author> <title> Double-Checked Locking An Object Behavioral Pattern for Initializing and Accessing Thread-safe Objects Efficiently, </title> <booktitle> in The 3 rd Pattern Languages of Programming Conference (Washington University technical report #WUCS-97-07), </booktitle> <month> February </month> <year> 1997. </year>
Reference-contexts: TupleVector object_table_; -; The instance method, along with the private construc tor, enforces the policy that Object DB is a singleton. Note that this implementation does not protect itself against con current access; however, we can easily apply the Double Checked Locking Pattern <ref> [9] </ref> to achieve that.
Reference: [10] <author> H. Hueni, R. Johnson, and R. </author> <title> Engel, A Framework for Network Protocol Software, </title> <booktitle> in Proceedings of OOPSLA '95, </booktitle> <address> (Austin, Texas), </address> <publisher> ACM, </publisher> <month> October </month> <year> 1995. </year> <month> 11 </month>
Reference-contexts: While patterns cannot change fundamental linkage styles of languages or environments from source to binary, the External Polymorphism pattern enforces software integration at a different conceptual level. In particular, it encourages a component-like black-box style of development and integration, as opposed to a white-box approach <ref> [10] </ref>. Therefore, substituting one set of library components for another can be simplified. Likewise, bringing in new, externally-produced libraries is also easier. The following analogy is offered in closing: automobiles are complex interworking systems.
References-found: 10

