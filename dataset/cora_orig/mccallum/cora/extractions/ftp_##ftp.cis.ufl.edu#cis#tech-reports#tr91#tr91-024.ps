URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr91/tr91-024.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr91-abstracts.html
Root-URL: http://www.cis.ufl.edu
Title: Computing Display Conflicts in String Visualization  
Author: Dinesh P. Mehta yz Sartaj Sahni 
Keyword: and Phrases: Strings, visualization, analysis, directed acyclic word graphs.  
Address: Gainesville, FL 32611  Minneapolis, MN 55455  
Affiliation: Dept. of Computer and Information Sciences, University of Florida,  Dept. of Computer Science, University of Minnesota,  
Note: This research was supported in part by the National Science Foundation under grant MIP 86-17374.  
Date: 24  
Pubnum: Technical Report  
Abstract: Strings are used to represent a variety of objects such as DNA sequences, text, and numerical sequences. A model for a system for the visualization and analysis of strings was proposed in [1]. In this paper, we present algorithms which implement some of the queries supported by this model. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Mehta and S. Sahni, </author> <title> "String Visualization," </title> <note> In Preparation, </note> <year> 1991. </year>
Reference-contexts: Research in molecular biology, text analysis, and interpretation of numerical data involves the identification of recurring patterns in data and hypothesizing about their causes and/or effects [2, 3]. Detecting patterns visually in long strings is tedious and prone to error. In <ref> [1] </ref>, a model was proposed to alleviate this problem. The model consists of identifying all recurring patterns in a string and highlighting identical patterns in the same color. We first discuss the notion of maximal patterns. Let abc be a pattern occurring m times in a string S. <p> The information is then fed to a routine which selects a set of occurrences so that the sum of their weights is maximized (algorithms for these are discussed in <ref> [1] </ref>). Semi-Automatic: In a practical environment, the most appropriate method would be a hybrid of the interactive and automatic approaches described above. The user could select some occurrences that he/she wants included in the final display.
Reference: [2] <author> B. Clift, D. Haussler, T.D. Schneider, and G.D. </author> <title> Stormo , "Sequence Landscapes," </title> <journal> Nucleic Acids Research, </journal> <volume> vol. 14, no. 1, </volume> <pages> pp. 141-158, </pages> <year> 1986. </year>
Reference-contexts: Research in molecular biology, text analysis, and interpretation of numerical data involves the identification of recurring patterns in data and hypothesizing about their causes and/or effects <ref> [2, 3] </ref>. Detecting patterns visually in long strings is tedious and prone to error. In [1], a model was proposed to alleviate this problem. The model consists of identifying all recurring patterns in a string and highlighting identical patterns in the same color.
Reference: [3] <author> G.M. </author> <title> Morris , "The Matching of Protein Sequences using Color Intrasequence Homology Displays," </title> <journal> J. Mol. Graphics, </journal> <volume> vol. 6, </volume> <pages> pp. 135-142, </pages> <year> 1988. </year>
Reference-contexts: Research in molecular biology, text analysis, and interpretation of numerical data involves the identification of recurring patterns in data and hypothesizing about their causes and/or effects <ref> [2, 3] </ref>. Detecting patterns visually in long strings is tedious and prone to error. In [1], a model was proposed to alleviate this problem. The model consists of identifying all recurring patterns in a string and highlighting identical patterns in the same color.
Reference: [4] <author> A. Blumer, J. Blumer, D. Haussler, R. McConnell, and A. Ehrenfeucht, </author> <title> "Complete Inverted Files for Efficient Text Retrieval and Analysis," </title> <journal> J. ACM, </journal> <volume> vol. 34, no. 3, </volume> <pages> pp. 578-595, </pages> <year> 1987. </year>
Reference-contexts: Maximal patterns that occur at least twice are known as displayable entities. The problem of identifying all displayable entities and their occurrences in S can be solved from the results in <ref> [4] </ref>. Once all displayable entities and their occurrences are obtained, we are confronted with the problem of color coding them. In the string, S = abczdefydefxabc, abc and def are the only displayable entities. <p> Problems relating to statistical information about conflicts are also identified. Efficient algorithms for these problems are presented. All algorithms make use of the symmetric compact directed acyclic word graph (scdawg) data structure <ref> [4] </ref> and may be thought of as operations or traversals of the scdawg. The scdawg, which is used to represent strings and sets of strings evolved from other string data structures such as position trees, suffix trees, and directed acyclic word graphs [5, 6, 7, 8]. <p> There are no edges corresponding to the other letters of the alphabet as imp (S; abcx) does not exist for x * fa; b; c; e; f g. The space required for SCD (S ) is O (n) and the time needed to construct it is O (n) <ref> [5, 4] </ref>. While we have defined the scdawg data structure for a single string, S , it can be extended to represent a set of strings. 2.3 Computing Occurrences of Displayable Entities de (v) in S . This is based on the outline provided in [4]. <p> While we have defined the scdawg data structure for a single string, S , it can be extended to represent a set of strings. 2.3 Computing Occurrences of Displayable Entities de (v) in S . This is based on the outline provided in <ref> [4] </ref>. <p> Clearly, this is not true. So, S is conflict free. 2 The preceding development leads to algorithm NoConflicts (Figure 5). 9 Theorem 1 Algorithm NoConflicts is both correct and optimal. Proof Correctness is an immediate consequence of Lemma 4. Step 1 takes O (n) time <ref> [4] </ref>. Step 2 takes O (1) time since jV source j &lt; 2jj. Step 3 takes O (1) time since the number of out edges leaving V source is less than 4j 2 j. So, NoConflicts takes O (n) time, which is optimal. <p> Theorem 3 Algorithm C computes all prefix-suffix conflicts of S in O (n + k p ) space and time, which is optimal. Proof Line 1 of Algorithm C takes O (n) time <ref> [4] </ref>. The cost of lines 2 and 3 without including the execution time of NextSuffix (v; v) is O (n).
Reference: [5] <author> A. Blumer, J. Blumer, D. Haussler, A. Ehrenfeucht, M.T. Chen, J. Seiferas, </author> <title> "The Smallest Automaton Recognizing the Subwords of a Text," </title> <journal> Theoretical Computer Science, </journal> <volume> no. 40, </volume> <pages> pp. 31-55, </pages> <year> 1985. </year>
Reference-contexts: The scdawg, which is used to represent strings and sets of strings evolved from other string data structures such as position trees, suffix trees, and directed acyclic word graphs <ref> [5, 6, 7, 8] </ref>. Section 2 contains preliminaries including definitions of displayable entities, conflicts, and scdawgs. Section 3 presents optimal algorithms to determine whether a string has conflicts and to compute subword and prefix suffix conflicts in a string. <p> There are no edges corresponding to the other letters of the alphabet as imp (S; abcx) does not exist for x * fa; b; c; e; f g. The space required for SCD (S ) is O (n) and the time needed to construct it is O (n) <ref> [5, 4] </ref>. While we have defined the scdawg data structure for a single string, S , it can be extended to represent a set of strings. 2.3 Computing Occurrences of Displayable Entities de (v) in S . This is based on the outline provided in [4].
Reference: [6] <author> M. E. Majster and A. Reiser, </author> <title> "Efficient on-line construction and correction of position trees," </title> <journal> SIAM Journal on Computing, </journal> <volume> vol. 9, </volume> <pages> pp. 785-807, </pages> <month> Nov. </month> <year> 1980. </year>
Reference-contexts: The scdawg, which is used to represent strings and sets of strings evolved from other string data structures such as position trees, suffix trees, and directed acyclic word graphs <ref> [5, 6, 7, 8] </ref>. Section 2 contains preliminaries including definitions of displayable entities, conflicts, and scdawgs. Section 3 presents optimal algorithms to determine whether a string has conflicts and to compute subword and prefix suffix conflicts in a string.
Reference: [7] <author> E. McCreight, </author> <title> "A space-economical suffix tree construction algorithm," </title> <journal> Journal of the ACM, </journal> <volume> vol. 23, </volume> <pages> pp. 262-272, </pages> <month> Apr. </month> <year> 1976. </year>
Reference-contexts: The scdawg, which is used to represent strings and sets of strings evolved from other string data structures such as position trees, suffix trees, and directed acyclic word graphs <ref> [5, 6, 7, 8] </ref>. Section 2 contains preliminaries including definitions of displayable entities, conflicts, and scdawgs. Section 3 presents optimal algorithms to determine whether a string has conflicts and to compute subword and prefix suffix conflicts in a string.
Reference: [8] <author> M. T. Chen and Joel Seiferas, </author> <title> "Efficient and elegant subword tree construction," in Combinatorial Algorithms on Words (A. </title> <editor> Apostolico and Z. Galil, eds.), </editor> <booktitle> NATO ASI Series, </booktitle> <volume> Vol. F12, </volume> <pages> pp. 97-107, </pages> <address> Berlin Heidelberg: </address> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The scdawg, which is used to represent strings and sets of strings evolved from other string data structures such as position trees, suffix trees, and directed acyclic word graphs <ref> [5, 6, 7, 8] </ref>. Section 2 contains preliminaries including definitions of displayable entities, conflicts, and scdawgs. Section 3 presents optimal algorithms to determine whether a string has conflicts and to compute subword and prefix suffix conflicts in a string.
Reference: [9] <author> E.Horowitz, S. Sahni, </author> <title> Fundamentals of Data Structures in Pascal, 3'rd Edition. </title> <publisher> Computer Science Press, </publisher> <year> 1990. </year> <month> 33 </month>
Reference-contexts: The remaining elements of x.sublist are computed from the sublist fields of vertices, w, in SG (S; v) such that a right extension edge goes from x to w. Consequently, w.sublist must be computed before x.sublist. This is achieved by traversing SG (S; v) in reverse topological order <ref> [9] </ref>. Lemma 6 x:sublist for vertex, x, in SG (S; v) contains all relative occurrences of de (x) in de (v) on completion of GetSubwords (v).
References-found: 9

