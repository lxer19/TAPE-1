URL: http://www.cs.toronto.edu/~csc2532h/lp.ps.Z
Refering-URL: http://www.cs.toronto.edu/~csc2532h/
Root-URL: http://www.cs.toronto.edu
Title: Rules as Actions: A Situation Calculus Semantics for Logic Programs Semantics of logic programs. Reasoning
Author: Fangzhen Lin and Ray Reiter 
Date: 1994:19, 20:1-679 1  
Note: J. LOGIC PROGRAMMING  Keywords.  
Abstract: We propose a novel semantics for logic programs with negation by viewing the application of a clause in a derivation as an action in the situation calculus. Program clauses are then identified with situation calculus effect axioms as they are understood in axiomatic theories of actions. We then solve the frame problem for these effect axioms using a recent approach of Reiter [21], and identify the resulting collection of axioms with the semantics of the original logic program. An interesting consequence of this approach is that the logic programming negation-as-failure operator inherits its nonmonotonicity from the nonmonotonicity associated with the frame problem. One advantage of our proposal is that like Clark's completion semantics, ours is also formulated explicitly in classical logic. To illustrate the usefulness of our semantics, we prove sufficient conditions for two logic programs to be equivalent, and use this to verify the correctness of the well-known unfolding program transformation operator. We also discuss applications of this framework to formalizing search control operators in logic programming. / 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K. L. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logics and Databases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: Now if G is a goal of the form l 1 & &l n , and st a situation term, then we define G [st] to be the formula l 1 [st] ^ ^ l n [st]: 3.4. Clark's Completion Since we shall often refer to Clark's completion <ref> [1] </ref> in this paper, we briefly review it here.
Reference: 2. <author> M. </author> <title> Fitting. A Kripke-Kleene semantics for logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 2(4) </volume> <pages> 295-312, </pages> <year> 1985. </year>
Reference-contexts: Since our foundational axioms in already include an induction axiom, this result carries over to our semantics as well. Wallace [31] also relates his semantics to some other well-known ones such as (Fitting <ref> [2] </ref>, Kunen [6], Przymusinski [20], and van Gelder and Ross and Schlipf [29]). Many of the results there can be inherited here. Wallace also argues the advantages of having a semantics in first-order logic. The same arguments apply to our 18 semantics as well.
Reference: 3. <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: Section 3 provides the necessary logical preliminaries, and Section 4 defines our situation calculus semantics for logic programs. Section 5 shows some relationships between our semantics and Wallace's [31], and also relates our semantics to the stable model semantics <ref> [3] </ref>. Section 6 formulates conditions for two logic programs to be equivalent and applies this result to verifying the correctness of the unfolding program transformation operator. Section 7 discusses other potential applications of our semantics, while Section 8 provides some concluding remarks. 2. <p> :(9s)(9y)parent (x; y; s) j :(x = J ohn _ x = J oe): In the next section, we shall show that our action theory semantics for logic programs is closely related to a recent semantics proposed by Wallace [31], and is essentially the same as the stable model semantics <ref> [3] </ref> when we consider only Herbrand models. 5. Wallace's Semantics Wallace's basic idea [31] can be summarized as follows: Given a logic program P , first obtain from P another program P 0 , then consider the semantics of P to be the Clark completion of P 0 . <p> Wallace proposes several ways for obtaining the new program P 0 from P . We shall consider the one that is most closely related to our semantics, and that will in turn relate our semantics to the stable model semantics of <ref> [3] </ref>. The following definition is adapted from [31]. Let P be a logic program. The tightened program P 0 of P contains precisely the following clauses: 1.
Reference: 4. <author> C. C. Green. </author> <title> Application of theorem proving to problem solving. </title> <booktitle> In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI-69), </booktitle> <pages> pages 219-239, </pages> <year> 1969. </year>
Reference-contexts: Therefore query answering in logic programs literally becomes planning in the style of (Green <ref> [4] </ref>) in the situation calculus. As we can see from this definition of an answer, we are primarily interested in consequences of the form (9s)G [s]. One nice property about these consequences of action theories is that they commute over conjunctions: Proposition 4.2.
Reference: 5. <author> A. R. Haas. </author> <title> The case for domain-specific frame axioms. </title> <editor> In F. M. Brown, editor, </editor> <booktitle> The Frame Problem in Artificial Intelligence. Proceedings of the 1987 Workshop on Reasoning about Action, </booktitle> <pages> pages 343-348, </pages> <address> San Jose, CA, 1987. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: If possible, we also want a parsimonious representation for these frame axioms (because in their simplest form, there are too many of them). 2.4. A Simple Solution to the Frame Problem By appealing to earlier ideas of Haas <ref> [5] </ref>, Schubert [24] and Pednault [19], Reiter [21] proposes a simple solution to the frame problem, which we illustrate with an example.
Reference: 6. <author> K. Kunen. </author> <title> Negation in logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(4) </volume> <pages> 289-308, </pages> <year> 1987. </year>
Reference-contexts: Since our foundational axioms in already include an induction axiom, this result carries over to our semantics as well. Wallace [31] also relates his semantics to some other well-known ones such as (Fitting [2], Kunen <ref> [6] </ref>, Przymusinski [20], and van Gelder and Ross and Schlipf [29]). Many of the results there can be inherited here. Wallace also argues the advantages of having a semantics in first-order logic. The same arguments apply to our 18 semantics as well.
Reference: 7. <author> H.J. Levesque, R. Reiter, Y. Lesperance, F. Lin and R. Scherl. GOLOG: </author> <title> A logic programming language for dynamic domains. </title> <journal> Journal of Logic Programming, this volume. </journal>
Reference-contexts: With minor differences, it is the same as that of Levesque et al <ref> [7] </ref>. 3 2.2. Axiomatizing Actions and their Effects in the Situation Calculus Actions have preconditions necessary and sufficient conditions that characterize when the action is physically possible.
Reference: 8. <author> V. Lifschitz. </author> <title> Pointwise circumscription. </title> <booktitle> In Proceedings of the Fifth National Conference on Artificial Intelligence (AAAI-86), </booktitle> <pages> pages 406-410, </pages> <address> Philadelphia, PA, </address> <year> 1986. </year>
Reference-contexts: The addition of a new effect axiom to an earlier axiomatization for some domain may invalidate any solution to the frame problem obtained with the earlier axioms. This intuition has led to a large body of research on nonmonotonic solutions to the frame problem (e.g. <ref> [16, 26, 8, 9, 13] </ref>). In view of our situation calculus semantics for logic programming, it will follow that negation-as-failure inherits its nonmonotonicity from the nonmonotonicity associated with the frame problem. 3. Logical Preliminaries 3.1.
Reference: 9. <author> V. Lifschitz. </author> <title> Formal theories of action. </title> <booktitle> In Proceedings of the Tenth International Joint Conference on Artificial Intelligence (IJCAI-87), </booktitle> <pages> pages 966-972, </pages> <year> 1987. </year>
Reference-contexts: The addition of a new effect axiom to an earlier axiomatization for some domain may invalidate any solution to the frame problem obtained with the earlier axioms. This intuition has led to a large body of research on nonmonotonic solutions to the frame problem (e.g. <ref> [16, 26, 8, 9, 13] </ref>). In view of our situation calculus semantics for logic programming, it will follow that negation-as-failure inherits its nonmonotonicity from the nonmonotonicity associated with the frame problem. 3. Logical Preliminaries 3.1.
Reference: 10. <author> F. Lin. </author> <title> A situation calculus semantics for the prolog cut operator. </title> <note> http://www.cs.toronto.edu/~cogrobo/, Draft. </note> <year> 1995. </year>
Reference-contexts: We show that this semantics is well-behaved when the logic program is properly stratified. Furthermore, according to this semantics, the usual implementation of the negation-as-failure operator using cut is provably correct with respect to the stable model semantics. For details see <ref> [10] </ref>. We are also currently exploring the possibility of formalizing the dynamic "assert" and "retract" operators of Prolog within this framework.
Reference: 11. <author> F. Lin and R. Reiter. </author> <title> State constraints revisited. </title> <journal> Journal of Logic and Computation, Special Issue on Actions and Processes, </journal> <volume> 4(5) </volume> <pages> 655-678, </pages> <year> 1994. </year>
Reference-contexts: So technically, there is no real need for this predicate in this paper. We keep it, however, in order to be consistent with the general framework of (Reiter [21] and Lin and Reiter <ref> [11] </ref>). * A binary predicate &lt; over situations. We shall follow convention, and write &lt; in infix form. By s &lt; s 0 we mean that s 0 can be obtained from s by a sequence of executable actions. <p> We also assume a finite number of function symbols of arity object n ! action, n 0, for actions, and a finite number of function symbols of arity object n ! object, n 0. 3.2. Axiomatizing the Situation Calculus We shall need the following foundational axioms (Lin and Reiter <ref> [11] </ref>) for the situation calculus: S 0 6= do (a; s); (8P )[P (S 0 ) ^ (8a; s)(P (s) oe P (do (a; s))) oe (8s)P (s)]; s &lt; do (a; s 0 ) j (P oss (a; s 0 ) ^ s s 0 ): Intuitively, the first two
Reference: 12. <editor> F. Lin and R. Reiter. Forget it! In R. Greiner and D. Subramanian, editors, </editor> <booktitle> Working Notes of AAAI Fall Symposium on Relevance, </booktitle> <pages> pages 154-159. </pages> <booktitle> The American Association for Artificial Intelligence, </booktitle> <address> Menlo Park, CA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: any variable assignment oe, M; oe j= (9s)F (~x; s) iff M 0 ; oe j= (9s)F (~x; s): It turns out that the answer theory of P can be considered to be the result of remembering only (9s)F (~x; s), for every fluent F in D (Lin and Reiter <ref> [12] </ref>). Moreover, according to the results in (Lin and Reiter [12]), the answer theory of P always exists, and can be expressed as a finite second-order theory, but that in general, no first-order answer theory need exist. We now have the following definition: 7 Definition 6.1. <p> iff M 0 ; oe j= (9s)F (~x; s): It turns out that the answer theory of P can be considered to be the result of remembering only (9s)F (~x; s), for every fluent F in D (Lin and Reiter <ref> [12] </ref>). Moreover, according to the results in (Lin and Reiter [12]), the answer theory of P always exists, and can be expressed as a finite second-order theory, but that in general, no first-order answer theory need exist. We now have the following definition: 7 Definition 6.1.
Reference: 13. <author> F. Lin and Y. Shoham. </author> <title> Provably correct theories of action. </title> <journal> Journal of the ACM, </journal> <volume> 42(2) </volume> <pages> 293-320, </pages> <year> 1995. </year>
Reference-contexts: The addition of a new effect axiom to an earlier axiomatization for some domain may invalidate any solution to the frame problem obtained with the earlier axioms. This intuition has led to a large body of research on nonmonotonic solutions to the frame problem (e.g. <ref> [16, 26, 8, 9, 13] </ref>). In view of our situation calculus semantics for logic programming, it will follow that negation-as-failure inherits its nonmonotonicity from the nonmonotonicity associated with the frame problem. 3. Logical Preliminaries 3.1.
Reference: 14. <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: Clark's completion is perhaps the simplest semantics for logic programs. It replaces rules in a logic program by logical axioms in first-order logic. The main problem with it is that it is too weak for logic programs with cycles and recursion (see, for example, <ref> [14] </ref>). Our proposed semantics will be very much in the same style as Clark's comple tion, but it will also handle cycles and recursion correctly. 4.
Reference: 15. <author> J. McCarthy. </author> <title> Situations, actions and causal laws. </title> <editor> In M. Minsky, editor, </editor> <booktitle> Semantic Information Processing, </booktitle> <pages> pages 410-417. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1968. </year>
Reference-contexts: We consider the application of a clause in a derivation to be an action in the situation calculus (McCarthy <ref> [15] </ref>). Executing a clause makes the head of the clause true in the new situation whenever the body of the clause is true in the current situation. Program clauses are then identified with situation calculus effect axioms as they are understood in axiomatic theories of actions. <p> Section 7 discusses other potential applications of our semantics, while Section 8 provides some concluding remarks. 2. An Informal Introduction to the Situation Calculus 1 2.1. Intuitive Ontology for the Situation Calculus The situation calculus (McCarthy <ref> [15] </ref>) is a first order language (with, as we shall see later, some second order features) specifically designed for representing dynamically changing worlds. All changes to the world are the result of named actions.
Reference: 16. <author> J. McCarthy. </author> <title> Applications of circumscription to formalizing commonsense knowledge. </title> <journal> Artificial Intelligence, </journal> <volume> 28 </volume> <pages> 89-118, </pages> <year> 1986. </year>
Reference-contexts: The addition of a new effect axiom to an earlier axiomatization for some domain may invalidate any solution to the frame problem obtained with the earlier axioms. This intuition has led to a large body of research on nonmonotonic solutions to the frame problem (e.g. <ref> [16, 26, 8, 9, 13] </ref>). In view of our situation calculus semantics for logic programming, it will follow that negation-as-failure inherits its nonmonotonicity from the nonmonotonicity associated with the frame problem. 3. Logical Preliminaries 3.1.
Reference: 17. <author> J. McCarthy and P. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence 4, </booktitle> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, Edinburgh, </publisher> <year> 1969. </year>
Reference-contexts: The Frame Problem As first observed by McCarthy and Hayes <ref> [17] </ref>, axiomatizing a dynamic world requires more than just action precondition and effect axioms. So-called frame axioms are also necessary. These specify the action invariants of the domain, namely, those fluents which remain unaffected by a given action.
Reference: 18. <author> E. P. Pednault. </author> <title> Synthesizing plans that contain actions with context-dependent effects. </title> <journal> Computational Intelligence, </journal> <volume> 4 </volume> <pages> 356-372, </pages> <year> 1988. </year>
Reference-contexts: Then F again is a simple state formula, every fluent in it appears positively, and satisfies condition (6.7). * The above procedure of obtaining F can be iterated. Notice that this procedure is closely related to unfolding (see below), and also regression <ref> [30, 18, 21] </ref> in planning.
Reference: 19. <author> E. P. Pednault. </author> <title> ADL: Exploring the middle ground between STRIPS and the situation calculus. </title> <booktitle> In Proceedings of the First International Conference on Princi 31 ples of Knowledge Representation and Reasoning (KR'89), </booktitle> <pages> pages 324-332. </pages> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1989. </year>
Reference-contexts: If possible, we also want a parsimonious representation for these frame axioms (because in their simplest form, there are too many of them). 2.4. A Simple Solution to the Frame Problem By appealing to earlier ideas of Haas [5], Schubert [24] and Pednault <ref> [19] </ref>, Reiter [21] proposes a simple solution to the frame problem, which we illustrate with an example. Suppose that (2.1), (2.2), and (2.3) are all the effect axioms for the fluent broken, i.e. they describe all the ways that an action can change the truth value of broken.
Reference: 20. <author> T. C. Przymusinski. </author> <title> On the declarative semantics of deductive databases and logic programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: Since our foundational axioms in already include an induction axiom, this result carries over to our semantics as well. Wallace [31] also relates his semantics to some other well-known ones such as (Fitting [2], Kunen [6], Przymusinski <ref> [20] </ref>, and van Gelder and Ross and Schlipf [29]). Many of the results there can be inherited here. Wallace also argues the advantages of having a semantics in first-order logic. The same arguments apply to our 18 semantics as well. Admittedly, compared to Wallace's elegant approach, ours seems complicated.
Reference: 21. <author> R. Reiter. </author> <title> The frame problem in the situation calculus: a simple solution (sometimes) and a completeness result for goal regression. </title> <editor> In V. Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 418-420. </pages> <publisher> Academic Press, </publisher> <address> San Diego, CA, </address> <year> 1991. </year>
Reference-contexts: Program clauses are then identified with situation calculus effect axioms as they are understood in axiomatic theories of actions. We then solve the frame problem for these effect axioms using a recent approach of Reiter <ref> [21] </ref>, and identify the resulting collection of axioms with the semantics of the original logic program. This paper is organized as follows. In the next section, we briefly review the situation calculus and the frame problem. <p> If possible, we also want a parsimonious representation for these frame axioms (because in their simplest form, there are too many of them). 2.4. A Simple Solution to the Frame Problem By appealing to earlier ideas of Haas [5], Schubert [24] and Pednault [19], Reiter <ref> [21] </ref> proposes a simple solution to the frame problem, which we illustrate with an example. Suppose that (2.1), (2.2), and (2.3) are all the effect axioms for the fluent broken, i.e. they describe all the ways that an action can change the truth value of broken. <p> The solution to the frame problem of <ref> [21] </ref> rests on a completeness assumption, which is that the causal axioms (2.6) and (2.7) characterize all the conditions under which action a can lead to a fluent F (~x) becoming true (respectively, false) in the successor situation. <p> Therefore, if action a is possible and F (~x)'s truth value changes from false to true as a result of doing a, then fl + F (~x; a; s) must be true and similarly for a change from true to false. Reiter <ref> [21] </ref> shows how to derive a successor state axiom of the following form from the causal axioms (2.6) and (2.7) and the completeness assumption. <p> In this paper we shall assume that actions are always executable, i.e. (8a; s)P oss (a; s). So technically, there is no real need for this predicate in this paper. We keep it, however, in order to be consistent with the general framework of (Reiter <ref> [21] </ref> and Lin and Reiter [11]). * A binary predicate &lt; over situations. We shall follow convention, and write &lt; in infix form. By s &lt; s 0 we mean that s 0 can be obtained from s by a sequence of executable actions. <p> Then F again is a simple state formula, every fluent in it appears positively, and satisfies condition (6.7). * The above procedure of obtaining F can be iterated. Notice that this procedure is closely related to unfolding (see below), and also regression <ref> [30, 18, 21] </ref> in planning.
Reference: 22. <author> R. Reiter. </author> <title> Proving properties of states in the situation calculus. </title> <journal> Artificial Intelligence, </journal> <volume> 64 </volume> <pages> 337-351, </pages> <year> 1993. </year>
Reference-contexts: Notice that according to this definition, the head of a clause must not mention constants and compound terms. This, however, does not restrict the 3 For a detailed discussion of the use of induction in the situation calculus, see (Reiter <ref> [22] </ref>). 7 generality of our notion of clauses.
Reference: 23. <author> Y. Sagiv. </author> <title> Optimizing datalog programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 659-698. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA., </address> <year> 1988. </year>
Reference-contexts: For instance, this condition holds trivially when P is the empty program but G in (6.1) has at least one atom, because when P is empty, its action theory entails :(9s)F (s) for any fluent F . This strategy was first used by Sagiv <ref> [23] </ref> for proving the equivalence of two deductive databases. Yet another way to prove condition (6.1) say, is to query the program P with the goal G, and then query P again with the goal F (~x) for those bindings returned by the first query.
Reference: 24. <author> L. K. Schubert. </author> <title> Monotonic solution to the frame problem in the situation calculus: an efficient method for worlds with fully specified actions. </title> <editor> In H. Kyberg, R. Loui, and G. Carlson, editors, </editor> <booktitle> Knowledge Representation and Defeasible Reasoning, </booktitle> <pages> pages 23-67. </pages> <publisher> Kluwer Academic Press, </publisher> <address> Boston, MA, </address> <year> 1990. </year>
Reference-contexts: If possible, we also want a parsimonious representation for these frame axioms (because in their simplest form, there are too many of them). 2.4. A Simple Solution to the Frame Problem By appealing to earlier ideas of Haas [5], Schubert <ref> [24] </ref> and Pednault [19], Reiter [21] proposes a simple solution to the frame problem, which we illustrate with an example.
Reference: 25. <author> H. Seki. </author> <title> Unfold/fold transformation of general logic programs for the well-founded semantics. </title> <journal> The Journal of Logic Programming, </journal> <volume> 15 </volume> <pages> 5-23, </pages> <year> 1993. </year>
Reference-contexts: So we have (6.9). 6.4. Unfold/Fold Unfold/fold (Tamaki and Sato [27]) are among the best known program transformation operators. Seki <ref> [25] </ref> shows that they preserve the well-founded semantics of (Van Gelder and Ross and Schlipf [29]). Using Theorem 6.2, we can show, rather straightforwardly, that unfold/fold also preserve our situation calculus semantics. We illustrate using unfolding. For ease of presentation, we consider only the propositional case. <p> Using Theorem 6.2, we can show, rather straightforwardly, that unfold/fold also preserve our situation calculus semantics. We illustrate using unfolding. For ease of presentation, we consider only the propositional case. The following definition is adapted from (Seki <ref> [25] </ref>). Let P be a logic program, and C a clause in P of the form: F 1 :- F 2 & G where F 1 and F 2 are distinct atoms.
Reference: 26. <author> Y. Shoham. </author> <title> Chronological ignorance: experiments in nonmonotonic temporal reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 36 </volume> <pages> 279-331, </pages> <year> 1988. </year>
Reference-contexts: The addition of a new effect axiom to an earlier axiomatization for some domain may invalidate any solution to the frame problem obtained with the earlier axioms. This intuition has led to a large body of research on nonmonotonic solutions to the frame problem (e.g. <ref> [16, 26, 8, 9, 13] </ref>). In view of our situation calculus semantics for logic programming, it will follow that negation-as-failure inherits its nonmonotonicity from the nonmonotonicity associated with the frame problem. 3. Logical Preliminaries 3.1.
Reference: 27. <author> H. Tamaki and T. Sato. </author> <title> Unfold/fold transformation of logic programs. </title> <booktitle> In Proceedings of the 2nd International Conference on Logic Programming, </booktitle> <pages> pages 127-138, </pages> <year> 1984. </year>
Reference-contexts: So we have (6.9). 6.4. Unfold/Fold Unfold/fold (Tamaki and Sato <ref> [27] </ref>) are among the best known program transformation operators. Seki [25] shows that they preserve the well-founded semantics of (Van Gelder and Ross and Schlipf [29]). Using Theorem 6.2, we can show, rather straightforwardly, that unfold/fold also preserve our situation calculus semantics. We illustrate using unfolding. <p> Having a classical logical semantics has many advantages, one of which is the relative ease of proving properties of programs. To illustrate this, we have formulated conditions for two logic programs to be equivalent, and used them to prove the correctness of the unfolding transformation of (Tamaki and Sato <ref> [27] </ref>). We have also used this framework to formalize various search control operators, and are working on extending it to the dynamic "assert" and "retract" operators of Prolog.
Reference: 28. <author> A. Van Gelder. </author> <title> Negation as failure using tight derivations for general logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 6(2) </volume> <pages> 109-133, </pages> <year> 1989. </year>
Reference-contexts: Clark completion of the tightened version of P together with appropriate induction axioms for natural numbers, and shows that for any ground atom p, p is entailed by the full completion iff it is in the success set of the tight tree semantics of P as defined in (van Gelder <ref> [28] </ref>), and :p is entailed by the full completion iff p is in the finite failure set of P . Since our foundational axioms in already include an induction axiom, this result carries over to our semantics as well.
Reference: 29. <author> A. Van Gelder, K. A. Ross, and J. S. Schlipf. </author> <title> Unfounded sets and well-founded semantics for general logic programs. </title> <booktitle> In Proc. Seventh ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 221-230, </pages> <year> 1988. </year>
Reference-contexts: Since our foundational axioms in already include an induction axiom, this result carries over to our semantics as well. Wallace [31] also relates his semantics to some other well-known ones such as (Fitting [2], Kunen [6], Przymusinski [20], and van Gelder and Ross and Schlipf <ref> [29] </ref>). Many of the results there can be inherited here. Wallace also argues the advantages of having a semantics in first-order logic. The same arguments apply to our 18 semantics as well. Admittedly, compared to Wallace's elegant approach, ours seems complicated. <p> So we have (6.9). 6.4. Unfold/Fold Unfold/fold (Tamaki and Sato [27]) are among the best known program transformation operators. Seki [25] shows that they preserve the well-founded semantics of (Van Gelder and Ross and Schlipf <ref> [29] </ref>). Using Theorem 6.2, we can show, rather straightforwardly, that unfold/fold also preserve our situation calculus semantics. We illustrate using unfolding. For ease of presentation, we consider only the propositional case. The following definition is adapted from (Seki [25]).
Reference: 30. <author> R. Waldinger. </author> <title> Achieving several goals simultaneously. </title> <editor> In E. Elcock and D. Michie, editors, </editor> <booktitle> Machine Intelligence, </booktitle> <pages> pages 94-136. </pages> <publisher> Ellis Horwood, Edinburgh, </publisher> <address> Scotland, </address> <year> 1977. </year>
Reference-contexts: Then F again is a simple state formula, every fluent in it appears positively, and satisfies condition (6.7). * The above procedure of obtaining F can be iterated. Notice that this procedure is closely related to unfolding (see below), and also regression <ref> [30, 18, 21] </ref> in planning.
Reference: 31. <author> M. G. Wallace. </author> <title> Tight, consistent, and computable completions for unrestricted logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 15 </volume> <pages> 243-273, </pages> <year> 1993. </year>
Reference-contexts: This paper is organized as follows. In the next section, we briefly review the situation calculus and the frame problem. Section 3 provides the necessary logical preliminaries, and Section 4 defines our situation calculus semantics for logic programs. Section 5 shows some relationships between our semantics and Wallace's <ref> [31] </ref>, and also relates our semantics to the stable model semantics [3]. Section 6 formulates conditions for two logic programs to be equivalent and applies this result to verifying the correctness of the unfolding program transformation operator. <p> D 2 j= (8x):(9s)childless (x; s) j :(9s)haschild (x; s) j :(9s)(9y)parent (x; y; s) j :(x = J ohn _ x = J oe): In the next section, we shall show that our action theory semantics for logic programs is closely related to a recent semantics proposed by Wallace <ref> [31] </ref>, and is essentially the same as the stable model semantics [3] when we consider only Herbrand models. 5. Wallace's Semantics Wallace's basic idea [31] can be summarized as follows: Given a logic program P , first obtain from P another program P 0 , then consider the semantics of P <p> oe): In the next section, we shall show that our action theory semantics for logic programs is closely related to a recent semantics proposed by Wallace <ref> [31] </ref>, and is essentially the same as the stable model semantics [3] when we consider only Herbrand models. 5. Wallace's Semantics Wallace's basic idea [31] can be summarized as follows: Given a logic program P , first obtain from P another program P 0 , then consider the semantics of P to be the Clark completion of P 0 . Wallace proposes several ways for obtaining the new program P 0 from P . <p> Wallace proposes several ways for obtaining the new program P 0 from P . We shall consider the one that is most closely related to our semantics, and that will in turn relate our semantics to the stable model semantics of [3]. The following definition is adapted from <ref> [31] </ref>. Let P be a logic program. The tightened program P 0 of P contains precisely the following clauses: 1. <p> For each predicate F (~x) in P , P 0 contains the clause: F (~x) :- F (~x; n) For example, consider the following program adapted from <ref> [31] </ref>: F (x) :- Q (x) & not R (x) R (x) :- R (x) The tightened version of this program is: 16 Q (a; s (n)) :- F (x) :- F (x; n) R (x) :- R (x; n) Notice that the Clark completion of the tightened program yields, for <p> The "(" part of (2) can be proved similarly by doing induction on situations. This completes the proof for the first half of the theorem. The proof of the second half is similar. &gt;From this theorem and Theorem 8 in <ref> [31] </ref> that relates Wallace's semantics to the stable model semantics, we have: Corollary 5.1. Let P be a program, and D its action theory. <p> Since our foundational axioms in already include an induction axiom, this result carries over to our semantics as well. Wallace <ref> [31] </ref> also relates his semantics to some other well-known ones such as (Fitting [2], Kunen [6], Przymusinski [20], and van Gelder and Ross and Schlipf [29]). Many of the results there can be inherited here. Wallace also argues the advantages of having a semantics in first-order logic. <p> These conditions are normally rather complicated and require the ability to talk formally about derivation histories, which our situation calculus-based semantics does provide. We shall say more about this issue in Section 7 below. Technically, this paper also goes beyond that of (Wallace <ref> [31] </ref>) in defining an equivalence relation on logic programs, and proving conditions for two logic pro grams to be equivalent. This is the goal of the next section. 6. Program Transformations One reason for a formal semantics of a programming language is to study sound program transformation techniques. <p> that in the propositional case, our notion of equivalence coincides with that under the stable model semantics. 6 M; oe j= (9s)G [s] means that the formula (9s)G [s] is true under the variable assignment oe in M. 7 We remark here that equivalence between two programs under Wallace's semantics <ref> [31] </ref> can be similarly defined. 20 pletions. The first answer theory is (9s)F (s) j :(9s)Q (s) ^ The second answer theory is (9s)F (s) j :(9s)Q (s) ^ These two theories are not equivalent. <p> Thanks also to G. Neelakantan Kartha, and Vladimir Lifschitz for helpful comments on an earlier draft of this paper. Our special thanks to Vladimir for bringing to our attention the work of Wallace <ref> [31] </ref>. This research was 30 supported by grants from the National Science and Engineering Research Council of Canada, the Institute for Robotics and Intelligent Systems of Canada, and the Information Technology Research Center of Ontario.
References-found: 31

