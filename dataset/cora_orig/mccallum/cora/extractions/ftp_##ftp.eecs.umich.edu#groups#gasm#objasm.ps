URL: ftp://ftp.eecs.umich.edu/groups/gasm/objasm.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: E-mail: fjanneck,kutterg@tik.ee.ethz.ch  
Author: Jorn W. Janneck and Philipp W. Kutter 
Address: CH-8092 Zurich, Switzerland  
Affiliation: State Machines  Computer Engineering and Networks Laboratory (TIK) Swiss Federal Institute of Technology Zurich  
Note: Object-based Abstract  
Abstract: TIK-Report Nr. 47 Abstract. When designing and implementing complex computer systems, powerful description techniques are needed that allow the representation of hardware and software components at various abstraction levels and support refinement during the development process. These techniques should be formal in order to support mathematical reasoning about systems properties while at the same time they should be operational so as to facilitate comprehension and implementation of the system. In this paper we propose Object-based Abstract State Machines (ObASM), an extension of Abstract State Machines (ASM). ASM are an operational formalism that has been successfully applied to the description of hardware and software systems. ObASM are adding a notion of locality of state and the concept of communication between loosely coupled agents. These extensions are designed to be minimal additions to the traditional ASM formulation, preserving their simplicity while at the same time significantly enhancing their modeling power. We give a formal semantics for ObASMs and discuss the properties of the extended formalism.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Anlauff. </author> <title> Aslan programming in abstract state machines. A small stand-alone ASM interpreter written in C, </title> <publisher> ftp://ftp.first.gmd.de/pub/gemmex/Aslan. </publisher>
Reference-contexts: It must be very easy to generate prototypes, both for abstract and more concrete models. 2. The ObASM components must run together with existing, non specified hardware and software components. Prototyping a single object can be done by compiling to executable code <ref> [1] </ref>, or refining to an ASM that corresponds to a simple hardware model, as for instance the RT-formalization in [26], corresponding essentially to a simple form of ASMs. For the communication with other components only the message passing mechanism and the read access must be implemented. <p> One possibility is to have for critical software components both the ObASM specification and an implementation. The reliable, but slow formal model, could be run in parallel with the implementation until one has gained confidence in the implementation. 6 Future Work In Aslan <ref> [1] </ref> the long present concept of hierarchical ASMs is implemented and used to structure single ASMs. Hierarchical ASMs allow to call other ASMs, which corresponds to synchronous message passing, in contrast to asynchronous message passing in ObASMs.
Reference: 2. <author> M. Anlauff, P.W. Kutter, and A. Pierantonio. </author> <title> The montages project web page, </title> <note> 1998. http://www.tik.ee.ethz.ch/~montages. </note>
Reference: 3. <author> Bernard Berthomieu and Michel Diaz. </author> <title> Modeling and verification of time dependent systems using time Petri nets. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(3) </volume> <pages> 259-273, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: Petri nets are a very general formal model, different flavors of which have been successfully applied to the modeling and analysis of a broad range of distributed and concurrent systems <ref> [3, 7, 22, 23, 25, 27] </ref>. They can be given an operational semantics, but writing interpreters for them can be cumbersome, in particular when these interpreters should execute them in a distributed fashion [11, 10, 21, 28, 29].
Reference: 4. <author> E. Borger and I. Durdanovic. </author> <title> Correctness of compiling Occam to Transputer code. </title> <journal> Computer Journal, </journal> <volume> 39(1) </volume> <pages> 52-92, </pages> <year> 1996. </year>
Reference-contexts: Although synchronous message passing can be simulated with asynchronous, and vice versa, an integration of both may be useful. Another point is the introduction of object orientedness in ASMs. While Aslan proposes a simple, pure syntactical method mapping everything to the 5 See <ref> [4] </ref> for verified refinements from Occam code to Transputer code, and [6] for verified hardware refinements of RISC architectures. global state, the use of ObASMs may lead to a more natural model, accounting for distributed loading and linking of classes as well as for garbage collection.
Reference: 5. <author> E. Borger and J. Huggins. </author> <title> Abstract state machines 1988 - 1998: Commented asm bibliography. </title> <editor> In H. Ehrig, </editor> <title> editor, </title> <journal> EATCS Bulletin, Formal Specification Column, </journal> <volume> number 64, </volume> <pages> pages 105 - 127. </pages> <note> EATCS, </note> <month> February </month> <year> 1998. </year>
Reference: 6. <author> W. Borger and S. Mazzanti. </author> <title> A practical method for rigorously controllable hardware design. </title> <editor> In J.P. Bowen, M.G. Hinchey, and D. Till, editors, ZUM'97: </editor> <title> The Z Formal Speification Notation, </title> <booktitle> number 1212 in LNCS, </booktitle> <year> 1997. </year>
Reference-contexts: Another point is the introduction of object orientedness in ASMs. While Aslan proposes a simple, pure syntactical method mapping everything to the 5 See [4] for verified refinements from Occam code to Transputer code, and <ref> [6] </ref> for verified hardware refinements of RISC architectures. global state, the use of ObASMs may lead to a more natural model, accounting for distributed loading and linking of classes as well as for garbage collection.
Reference: 7. <author> Giacomo Bucci and Enrico Vicario. </author> <title> Compositional validation of time-critical systems using communicating time Petri nets. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(12) </volume> <pages> 969-992, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: Petri nets are a very general formal model, different flavors of which have been successfully applied to the modeling and analysis of a broad range of distributed and concurrent systems <ref> [3, 7, 22, 23, 25, 27] </ref>. They can be given an operational semantics, but writing interpreters for them can be cumbersome, in particular when these interpreters should execute them in a distributed fashion [11, 10, 21, 28, 29].
Reference: 8. <author> R.S. Chin and S.T. Chanson. </author> <title> Distributed object based programming systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 23(1):91 - 124, </volume> <month> March </month> <year> 1991. </year>
Reference-contexts: The appropriateness of the object based message passing paradigm to the former is evidenced by the growing body of distributed software component models (at least partly) based on this approach, like e.g. CORBA, DCOM, or JavaBeans, while its suitability for the latter is shown in, for instance <ref> [8] </ref>. In the next section we give an introduction to ASMs, and the definition and semantics of ObASMs. Our definition allows to see the system both operationally using ASMs and denotationally as fix-points of general transition-systems evaluated non-deterministically along a partial ordering following only the causality of messages.
Reference: 9. <author> G. Del Castillo and Wolfram Hardt. </author> <title> Fast dynamic analysis of complex hw/sw-systems based on abstract state machine models. </title> <booktitle> In Sixth International Workshop on Hardware/Software Codesign. IEEE, </booktitle> <year> 1998. </year>
Reference-contexts: The case studies show, that ASMs are an implementation independent formalism, that can account for the peculiarities of both hard and software. In <ref> [9] </ref> it is shown how to analyze such mixed systems and we believe that ASMs are well suited for hardware/software codesign. ObASMs support the design process by allowing to compose the heterogeneous components horizontally.
Reference: 10. <author> Alois Ferscha. </author> <title> Concurrent execution of timed Petri nets. </title> <booktitle> In Proceedings of the 1994 Winter Simulation Conference, </booktitle> <pages> pages 229-236, </pages> <year> 1994. </year>
Reference-contexts: They can be given an operational semantics, but writing interpreters for them can be cumbersome, in particular when these interpreters should execute them in a distributed fashion <ref> [11, 10, 21, 28, 29] </ref>. The distributed execution suggested in the following example parallels the transition firing protocol in [29].
Reference: 11. <author> Alois Ferscha and G. Haring. Forschungsauftrag: </author> <title> ACPC - Parallele Petrinetz-Simulation (Endbericht). </title> <type> Technical report, </type> <institution> University of Vienna, </institution> <year> 1992. </year> <title> (text in English). </title>
Reference-contexts: They can be given an operational semantics, but writing interpreters for them can be cumbersome, in particular when these interpreters should execute them in a distributed fashion <ref> [11, 10, 21, 28, 29] </ref>. The distributed execution suggested in the following example parallels the transition firing protocol in [29].
Reference: 12. <author> P. Glavan and D. Rosenzweig. </author> <title> Communicating evolving algebras. </title> <booktitle> In Selected papers from CSL'92 (Computer Science Logic), number 702 in LNCS, </booktitle> <pages> pages 182 - 215. </pages> <publisher> Springer, </publisher> <year> 1993. </year>
Reference: 13. <author> Y. Gurevich. </author> <booktitle> Logic and the chanllenge of computer science. </booktitle> <editor> In E. Borger, editor, </editor> <booktitle> Thrends in Theoretical Computer Science, </booktitle> <pages> pages 1 - 57. </pages> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference: 14. <author> Y. Gurevich. </author> <title> Evolving algebras 1993: Lipari guide. </title> <editor> In E. Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 9 - 36. </pages> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference: 15. <author> Y. Gurevich. </author> <title> May 1997 draft of the asm guide. </title> <type> Technical Report CSE-TR-336-97, </type> <institution> University of Michigan EECS Department Technical Report, </institution> <year> 1997. </year>
Reference-contexts: Appendix: Denotational Semantics Semantics of ASM rules The formal semantics of a rule R in a state is given by a deterministic denotation Upd (R, ) being a set of updates <ref> [15] </ref>. The interpretation of f in the successor state 0 is defined as follows: Update sets are defined by transition rules. The basic update denotes one update of a function at some point. The new values and the point are given by terms over the signature. <p> : R m then Mes (R; ) = S (Mes 3: conditional rules) if R = if t then R true else R false endif then Mes (R; ) = ( Mes (R true ; ) if eval ;rcv (t) = true Mes (R false ; ) otherwise 6 See <ref> [15] </ref> for a formalization of "completely new" (Mes 4: do forall) if R = do forall e : t R 0 enddo then M es (R; ) = S o:eval e7!o ;rcv (t) Mes (R; e7!o ) (Mes 5: extend) if R = extend E with e R 0 endextend then
Reference: 16. <author> Y. Gurevich and R. Mani. </author> <title> Group membership protocol: Specification and verification. </title> <editor> In E. Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 295 - 328. </pages> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Distributed ASMs [17][12] have addressed the problem of composing subsystems by introducing a number of independently running agents, that communicate via shared memory. There is a priori no locality of states and message passing can be simulated <ref> [16] </ref>, but is not a primitive concept. Montages [24][2] provide a generic version of the composition mechanisms used in the above mentioned case studies in programming languages semantics. The method concentrates on a visual formalism for initializing control data flow links among the components.
Reference: 17. <author> Y. Gurevich and L.S. Moss. </author> <title> Algebraic operational semantics and occam. </title> <booktitle> In CSL'89, 3rd Workshop on Computer Science Logic, number 440 in LNCS, </booktitle> <pages> pages 176 - 192. </pages> <publisher> Springer, </publisher> <year> 1990. </year>
Reference: 18. <author> A. Hall. </author> <title> Taking z seriously. </title> <editor> In J.P. Bowen, M.G. Hinchey, and D. Till, editors, ZUM'97: </editor> <title> The Z Formal Speification Notation, </title> <booktitle> number 1212 in LNCS, </booktitle> <year> 1997. </year>
Reference-contexts: Unfortunately it turned out, that such descriptions are not always simple enough to be used in industrial system development, and even where the methods have been successfully applied [19], it was often not possible to refine the descriptions down to the implementation <ref> [18] </ref>. Gurevich's Abstract State Machines (ASMs) [13][14] are an operational formalism that can be used to model algorithms on different abstraction levels, from an abstract view down to the implementation details.
Reference: 19. <author> M. Hinchey and J. Bowen. </author> <title> Applications of Formal Methods. </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference-contexts: Research proposed many formalisms that are well suited for analysis or even verification. Unfortunately it turned out, that such descriptions are not always simple enough to be used in industrial system development, and even where the methods have been successfully applied <ref> [19] </ref>, it was often not possible to refine the descriptions down to the implementation [18]. Gurevich's Abstract State Machines (ASMs) [13][14] are an operational formalism that can be used to model algorithms on different abstraction levels, from an abstract view down to the implementation details.
Reference: 20. <author> J. Huggins. </author> <title> Abstract State Machines Web Page. </title>
Reference: 21. <author> Jorn W. Janneck. </author> <title> Behavioral prediction of time Petri nets with applications to distributed simulation. </title> <booktitle> In Proceedings of the HPC '98, </booktitle> <year> 1998. </year>
Reference-contexts: They can be given an operational semantics, but writing interpreters for them can be cumbersome, in particular when these interpreters should execute them in a distributed fashion <ref> [11, 10, 21, 28, 29] </ref>. The distributed execution suggested in the following example parallels the transition firing protocol in [29].
Reference: 22. <author> Jorn W. Janneck and Martin Naedele. </author> <title> Modeling a die bonder with petri nets: A case study. </title> <journal> IEEE Transactions on Semiconductor Manufacturing, </journal> <month> August </month> <year> 1998. </year>
Reference-contexts: Petri nets are a very general formal model, different flavors of which have been successfully applied to the modeling and analysis of a broad range of distributed and concurrent systems <ref> [3, 7, 22, 23, 25, 27] </ref>. They can be given an operational semantics, but writing interpreters for them can be cumbersome, in particular when these interpreters should execute them in a distributed fashion [11, 10, 21, 28, 29].
Reference: 23. <author> Kurt Jensen. </author> <title> Coloured Petri Nets: Basic Concepts, Analysis Methods and Practical Use, volume 1: Basic Concepts, </title> <booktitle> of EATCS Monographs in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Petri nets are a very general formal model, different flavors of which have been successfully applied to the modeling and analysis of a broad range of distributed and concurrent systems <ref> [3, 7, 22, 23, 25, 27] </ref>. They can be given an operational semantics, but writing interpreters for them can be cumbersome, in particular when these interpreters should execute them in a distributed fashion [11, 10, 21, 28, 29].
Reference: 24. <author> P.W. Kutter and A. Pierantonio. </author> <title> Montages: Specifications of realistic programming languages. </title> <journal> JUCS, </journal> <volume> 3(5):416 - 442, </volume> <year> 1997. </year>
Reference: 25. <author> Charles A. Lakos. </author> <title> From coloured Petri nets to object Petri nets. </title> <booktitle> In Proceedings of the 15th International Conference on Applications and Theory of Petri Nets, Lecture Notes of Computer Science, </booktitle> <year> 1995. </year>
Reference-contexts: Petri nets are a very general formal model, different flavors of which have been successfully applied to the modeling and analysis of a broad range of distributed and concurrent systems <ref> [3, 7, 22, 23, 25, 27] </ref>. They can be given an operational semantics, but writing interpreters for them can be cumbersome, in particular when these interpreters should execute them in a distributed fashion [11, 10, 21, 28, 29].
Reference: 26. <author> R. Leupers. </author> <title> Retargetable Code Generation for Digital Signal Processors. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1997. </year>
Reference-contexts: The ObASM components must run together with existing, non specified hardware and software components. Prototyping a single object can be done by compiling to executable code [1], or refining to an ASM that corresponds to a simple hardware model, as for instance the RT-formalization in <ref> [26] </ref>, corresponding essentially to a simple form of ASMs. For the communication with other components only the message passing mechanism and the read access must be implemented. The implementation must support all different kinds of subsystem-prototypes and the surrounding existing system components.
Reference: 27. <author> Tadao Murata. </author> <title> Petri nets: Properties, analysis, </title> <booktitle> and applications. Proceedings of the IEEE, </booktitle> <volume> 77(4) </volume> <pages> 541-580, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Petri nets are a very general formal model, different flavors of which have been successfully applied to the modeling and analysis of a broad range of distributed and concurrent systems <ref> [3, 7, 22, 23, 25, 27] </ref>. They can be given an operational semantics, but writing interpreters for them can be cumbersome, in particular when these interpreters should execute them in a distributed fashion [11, 10, 21, 28, 29].
Reference: 28. <author> David M. Nicol and S. Roy. </author> <title> Parallel simulation of timed Petri nets. </title> <booktitle> In Proceeding of the 1991 Winter Simulation Conference, </booktitle> <pages> pages 574-583, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: They can be given an operational semantics, but writing interpreters for them can be cumbersome, in particular when these interpreters should execute them in a distributed fashion <ref> [11, 10, 21, 28, 29] </ref>. The distributed execution suggested in the following example parallels the transition firing protocol in [29].
Reference: 29. <author> Gregory Scott Thomas. </author> <title> Parallel simulation of Petri nets. </title> <type> Master's thesis, </type> <institution> University of Washington, </institution> <year> 1991. </year>
Reference-contexts: They can be given an operational semantics, but writing interpreters for them can be cumbersome, in particular when these interpreters should execute them in a distributed fashion <ref> [11, 10, 21, 28, 29] </ref>. The distributed execution suggested in the following example parallels the transition firing protocol in [29]. <p> They can be given an operational semantics, but writing interpreters for them can be cumbersome, in particular when these interpreters should execute them in a distributed fashion [11, 10, 21, 28, 29]. The distributed execution suggested in the following example parallels the transition firing protocol in <ref> [29] </ref>. Basically, each transition and each place have a process associated with them, and they communicate with each other about the availability of tokens and their movement. w 0 w 0 post 1 pre 1 pre n post m . . . Fig. 1.
References-found: 29

