URL: ftp://ftp.cs.brown.edu/pub/techreports/94/cs94-11.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-94-11.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Hiralal Agrawal, Richard A. DeMillo, and Eugene H. Spafford, </author> <title> ``An Execution-Backtracking Approach to Debugging,'' </title> <journal> IEEE Software, </journal> <pages> pp. </pages> <month> 21-26 (May </month> <year> 1991). </year>
Reference-contexts: Related Work An execution must be traced to provide incremental replay. Enough must be recorded so that during replay sufficient state can be restored for each read from memory to obtain the same value as during the original execution. Below we describe past approaches to this problem <ref> [5, 10, 4, 3, 1] </ref>. These approaches either trace orders of magnitude more than necessary (as shown later), or do not bound the time required to replay up to an arbitrary point of the execution. <p> The Spyder system traces, before each statement (or group of statements), its change set, the values of the variables the statement might modify <ref> [1] </ref>. A debugger can backup execution over a statement by restoring the state from its change set. As an optimization to bound the trace size, only the most recent change set from each statement can be kept.
Reference: [2] <author> Thomas Ball and James R. Larus, </author> <title> ``Optimally Profiling and Tracing Programs,'' </title> <booktitle> Symp. on Principles of Programming Languages, </booktitle> <pages> pp. </pages> <month> 59-70 (January </month> <year> 1992). </year>
Reference-contexts: Our techniques are complementary to Demonic Memory as they provide another way to take the checkpoints, and a hierarchy of different window sizes can be used to compact our trace on-the-y. Checkpointing and tracing strategies have been proposed for problems such as fault tolerance, profiling, and others <ref> [8, 11, 2, 7, 6] </ref>. The incremental replay problem is more difficult than these problems since user replay requests occur often (unlike faults, for example) and they must complete quickly.
Reference: [3] <author> Jong-Deok Choi and Janice M. Stone, </author> <title> ``Balancing Runtime and Replay Costs in a Trace-and-Replay System,'' </title> <booktitle> ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <address> 26-35 Santa Cruz, CA, </address> <month> (May </month> <year> 1991). </year>
Reference-contexts: A difficult part of supporting incremental replay is bounding the replay time while tracing only what is necessary. We achieve both of these objectives. Previous systems that provide incremental replay can trace more than necessary and can incur large delays during replay <ref> [5, 10, 4, 3] </ref>. We guarantee a user-specified bound on the time of any replay by fixing the size of windows and by tracing often enough. Adaptive tracing is becoming not only practical but necessary. <p> Related Work An execution must be traced to provide incremental replay. Enough must be recorded so that during replay sufficient state can be restored for each read from memory to obtain the same value as during the original execution. Below we describe past approaches to this problem <ref> [5, 10, 4, 3, 1] </ref>. These approaches either trace orders of magnitude more than necessary (as shown later), or do not bound the time required to replay up to an arbitrary point of the execution. <p> The PPD system uses compile-time analysis to decide what and when to trace <ref> [10, 4, 3] </ref>. PPD writes a prelog on the entry of each procedure, containing the variables the procedure might possibly read before defining. The prelog allows a procedure to be re-executed in isolation since it contains all variables the procedure might read.
Reference: [4] <author> Jong-Deok Choi, Barton P. Miller, and Robert H. B. Netzer, </author> <title> ``Techniques for Debugging Parallel Programs with Flowback Analysis,'' </title> <journal> ACM Trans. on Programming Languages and Systems 13(4) pp. </journal> <month> 491-530 (October </month> <year> 1991). </year>
Reference-contexts: A difficult part of supporting incremental replay is bounding the replay time while tracing only what is necessary. We achieve both of these objectives. Previous systems that provide incremental replay can trace more than necessary and can incur large delays during replay <ref> [5, 10, 4, 3] </ref>. We guarantee a user-specified bound on the time of any replay by fixing the size of windows and by tracing often enough. Adaptive tracing is becoming not only practical but necessary. <p> Related Work An execution must be traced to provide incremental replay. Enough must be recorded so that during replay sufficient state can be restored for each read from memory to obtain the same value as during the original execution. Below we describe past approaches to this problem <ref> [5, 10, 4, 3, 1] </ref>. These approaches either trace orders of magnitude more than necessary (as shown later), or do not bound the time required to replay up to an arbitrary point of the execution. <p> The PPD system uses compile-time analysis to decide what and when to trace <ref> [10, 4, 3] </ref>. PPD writes a prelog on the entry of each procedure, containing the variables the procedure might possibly read before defining. The prelog allows a procedure to be re-executed in isolation since it contains all variables the procedure might read. <p> In addition, tracing only at procedure entry and exit can sometimes incur high overhead and provide no guarantees on replay time. For example, a 1000-iteration loop that contains a procedure call incurs many needless traces <ref> [4] </ref>, and a very long-running procedure may not be traced often enough to replay any part of it in a reasonable time. As an attempt to alleviate these problems, prelogs and postlogs can optionally be generated for loops, and not generated for some procedures [4], but the basic idea is limited <p> procedure call incurs many needless traces <ref> [4] </ref>, and a very long-running procedure may not be traced often enough to replay any part of it in a reasonable time. As an attempt to alleviate these problems, prelogs and postlogs can optionally be generated for loops, and not generated for some procedures [4], but the basic idea is limited by its static nature. The Spyder system traces, before each statement (or group of statements), its change set, the values of the variables the statement might modify [1]. <p> Second, we compared trace sizes produced by our fixed-window size algorithms to the optimal algorithms. The fixed-window algorithms are effective, producing traces less than 50% larger than optimal. Third, we compared our approaches to the IGOR [5] and PPD <ref> [4, 10] </ref> systems. We trace 1 - 2 orders of magnitude less than IGOR, and usually 4 - 50 times less than PPD when PPD provides quick replay.
Reference: [5] <author> Stuart I. Feldman and Channing B. Brown, </author> <title> ``IGOR: </title>
Reference-contexts: A difficult part of supporting incremental replay is bounding the replay time while tracing only what is necessary. We achieve both of these objectives. Previous systems that provide incremental replay can trace more than necessary and can incur large delays during replay <ref> [5, 10, 4, 3] </ref>. We guarantee a user-specified bound on the time of any replay by fixing the size of windows and by tracing often enough. Adaptive tracing is becoming not only practical but necessary. <p> Related Work An execution must be traced to provide incremental replay. Enough must be recorded so that during replay sufficient state can be restored for each read from memory to obtain the same value as during the original execution. Below we describe past approaches to this problem <ref> [5, 10, 4, 3, 1] </ref>. These approaches either trace orders of magnitude more than necessary (as shown later), or do not bound the time required to replay up to an arbitrary point of the execution. <p> The IGOR system uses the virtual memory system to periodically trace, at fixed time intervals, those pages modified since the last checkpoint <ref> [5] </ref>. To restart the execution from an intermediate point requires scanning the trace to find the most recent checkpoint of each page. Because checkpoints are taken at fixed time intervals, IGOR bounds the amount time required to replay any part of the execution once replay begins. <p> Second, we compared trace sizes produced by our fixed-window size algorithms to the optimal algorithms. The fixed-window algorithms are effective, producing traces less than 50% larger than optimal. Third, we compared our approaches to the IGOR <ref> [5] </ref> and PPD [4, 10] systems. We trace 1 - 2 orders of magnitude less than IGOR, and usually 4 - 50 times less than PPD when PPD provides quick replay.
References-found: 5

