URL: ftp://ftp.cc.gatech.edu/pub/gvu/tr/1992/92-11.ps.Z
Refering-URL: http://www.cs.gatech.edu/gvu/reports/1992/
Root-URL: 
Email: E-mail: fstasko,turnerg@cc.gatech.edu  
Title: Tidy Animations of Tree Algorithms  
Author: John T. Stasko Carlton Reid Turner 
Address: Atlanta, GA 30332-0280  
Affiliation: Graphics, Visualization, and Usability Center College of Computing Georgia Institute of Technology  
Pubnum: Technical Report GIT-GVU-92-11  
Abstract: In software visualization and algorithm animation it is important that advances in system technologies are accompanied by corresponding advances in animation presentations. In this paper we describe methods for animating tree manipulation algorithms, one of the most challenging algorithm animation domains. In particular, we animate operations on pairing heap data structures which are used to implement priority queues. Our animations use tree layout heuristics and and smooth transitions for illustrating intermediate algorithm states to promote viewer understanding. This paper describes the visual techniques and methodologies used to display the pairing heap operations. The paper also details the implementation requirements and how our particular support platform, the XTango system, facilitates meeting these requirements. 
Abstract-found: 1
Intro-found: 1
Reference: [AHU74] <author> Alfred V. Aho, John E. Hopcroft, and Jeffrey D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: We also describe how the animations were implemented using the XTango system, and how XTango's facilities supported the animation design. 2 Problem Domain Priority queues are data structures that manipulate nodes with key values and that support the operations insert, find min, delete min, delete, and decrease key <ref> [AHU74] </ref>. Priority queues are widely used with applications such as job scheduling, minimal spanning tree, shortest path, and graph traversal. By using a simple heap data structure, worst case time bounds of O (log n) are achieved for all operations.
Reference: [BB90] <author> Ronald M. Baecker and J. W. Buchanan. </author> <title> A programmer's interface: A visually enhanced and animated programming environment. </title> <booktitle> In Proceedings of the 23rd 11 Hawaii International Conference on System Sciences, </booktitle> <pages> pages 531-540, </pages> <address> Kailua--Kona, HI, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Algorithm animations [Bro88b] visually depict how algorithms function to promote understanding of the algorithm's methodologies. Usually, the animations contain abstract views of an algorithm's semantics and operations. Recently developed algorithm animation systems <ref> [LD85, Bro88a, BB90, Sta90b, BK91, Bro91] </ref> primarily have advanced the technology exhibited in algorithm animations, but as the area of algorithm animation matures, these technological system advances must be accompanied by advances in the quality of algorithm presentations.
Reference: [BK91] <author> Jon L. Bentley and Brian W. Kernighan. </author> <title> A system for algorithm animation. </title> <journal> Computing Systems, </journal> <volume> 4(1), </volume> <month> Winter </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Algorithm animations [Bro88b] visually depict how algorithms function to promote understanding of the algorithm's methodologies. Usually, the animations contain abstract views of an algorithm's semantics and operations. Recently developed algorithm animation systems <ref> [LD85, Bro88a, BB90, Sta90b, BK91, Bro91] </ref> primarily have advanced the technology exhibited in algorithm animations, but as the area of algorithm animation matures, these technological system advances must be accompanied by advances in the quality of algorithm presentations.
Reference: [Bro88a] <author> Marc H. Brown. </author> <title> Exploring algorithms using Balsa-II. </title> <journal> Computer, </journal> <volume> 21(5) </volume> <pages> 14-36, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Algorithm animations [Bro88b] visually depict how algorithms function to promote understanding of the algorithm's methodologies. Usually, the animations contain abstract views of an algorithm's semantics and operations. Recently developed algorithm animation systems <ref> [LD85, Bro88a, BB90, Sta90b, BK91, Bro91] </ref> primarily have advanced the technology exhibited in algorithm animations, but as the area of algorithm animation matures, these technological system advances must be accompanied by advances in the quality of algorithm presentations.
Reference: [Bro88b] <author> Marc H. Brown. </author> <title> Perspectives on algorithm animation. </title> <booktitle> In Proceedings of the ACM SIGCHI '88 Conference on Human Factors in Computing Systems, </booktitle> <pages> pages 33-38, </pages> <address> Washington D.C., </address> <month> May </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Algorithm animations <ref> [Bro88b] </ref> visually depict how algorithms function to promote understanding of the algorithm's methodologies. Usually, the animations contain abstract views of an algorithm's semantics and operations.
Reference: [Bro91] <author> Marc H. Brown. ZEUS: </author> <title> A system for algorithm animation and multi-view editing. </title> <booktitle> In Proceedings of the 1991 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 4-9, </pages> <address> Kobe Japan, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Algorithm animations [Bro88b] visually depict how algorithms function to promote understanding of the algorithm's methodologies. Usually, the animations contain abstract views of an algorithm's semantics and operations. Recently developed algorithm animation systems <ref> [LD85, Bro88a, BB90, Sta90b, BK91, Bro91] </ref> primarily have advanced the technology exhibited in algorithm animations, but as the area of algorithm animation matures, these technological system advances must be accompanied by advances in the quality of algorithm presentations.
Reference: [FSST86] <author> Michael L. Fredman, Robert Sedgewick, Daniel D. Sleator, and Robert E. Tarjan. </author> <title> The Pairing Heap: A new form of self-adjusting heap. </title> <journal> Algorithmica, </journal> <volume> 1 </volume> <pages> 111-129, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: This paper describes animations that we have developed of pairing heap priority queue algorithms. Pairing heaps are tree data structures that are appealing due to their conceptual clarity and their nearly optimal computational complexity <ref> [FSST86] </ref>. We describe the animation methodology used to animate the heap algorithms that, we believe, provides an effective presentation of the algorithms, promoting and facilitating understanding. <p> Unfortunately, Fibonacci heaps are quite complex and exceptionally difficult to implement. As a result, they are rarely used in practice. Pairing heaps offer an attractive alternative implementation option, nearly achieving the optimal amortized time bounds of Fibonacci heaps <ref> [FSST86, SV87] </ref>, yet providing a more manageable and less contrived data structure to implement. Pairing heaps are implemented as multiway trees with the heap property invariant that the children of a node have key values greater than or equal to the node's key value.
Reference: [FT84] <author> Michael L. Fredman and Robert E. Tarjan. </author> <title> Fibonacci heaps and their uses in improved network optimization algorithms. </title> <booktitle> In Proceedings of the 25th Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 338-344, </pages> <address> West Palm Beach, FL, </address> <month> October </month> <year> 1984. </year>
Reference-contexts: Priority queues are widely used with applications such as job scheduling, minimal spanning tree, shortest path, and graph traversal. By using a simple heap data structure, worst case time bounds of O (log n) are achieved for all operations. Fibonacci heaps <ref> [FT84] </ref>, developed by 2 new first child of the "winner." Fredman and Tarjan, achieve amortized [Tar85] time bounds of O (1) for insert, find min, and decrease key and O (log n) for delete min and delete. <p> Currently, these bounds provide the best running times for a variety of different problems <ref> [FT84] </ref>. Unfortunately, Fibonacci heaps are quite complex and exceptionally difficult to implement. As a result, they are rarely used in practice.
Reference: [JS91] <author> Brian Johnson and Ben Shneiderman. </author> <title> Tree-maps: A space filling approach to the visualization of hierarchical information structures. </title> <booktitle> In Proceedings of the IEEE Visualization '91, </booktitle> <pages> pages 284-291, </pages> <address> San Diego, CA, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Of course, this technique goes only so far. After about three zoom-outs the nodes become too small to discern. To display extremely large trees, other visualization techniques such as tree-maps <ref> [JS91] </ref> are better.
Reference: [Knu71] <author> Donald E. Knuth. </author> <title> Optimum binary search trees. </title> <journal> Acta Informatica, </journal> <volume> 1 </volume> <pages> 14-25, </pages> <year> 1971. </year>
Reference-contexts: The animations we have developed can utilize two possible supporting layout techniques. The first technique (we call it conservative) creates trees whose steady-state appearance looks like those created by Knuth's algorithm that positions each node according to its position in an inorder traversal <ref> [Knu71] </ref>. Figure 3 reflects this technique.
Reference: [LD85] <author> Ralph L. London and Robert A. Duisberg. </author> <title> Animating programs using Smalltalk. </title> <journal> Computer, </journal> <volume> 18(8) </volume> <pages> 61-71, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: 1 Introduction Algorithm animations [Bro88b] visually depict how algorithms function to promote understanding of the algorithm's methodologies. Usually, the animations contain abstract views of an algorithm's semantics and operations. Recently developed algorithm animation systems <ref> [LD85, Bro88a, BB90, Sta90b, BK91, Bro91] </ref> primarily have advanced the technology exhibited in algorithm animations, but as the area of algorithm animation matures, these technological system advances must be accompanied by advances in the quality of algorithm presentations.
Reference: [Moe90] <author> Sven Moen. </author> <title> Drawing dynamic trees. </title> <journal> IEEE Software, </journal> <volume> 7(4) </volume> <pages> 21-28, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Animations with smooth updates showing intermediate states help to preserve viewing context and convey the actual algorithm used to manipulate a tree. 3.2 Layout Techniques The problem of tree layout has been studied extensively <ref> [WS79, Vau80, RT81, WI90, Moe90] </ref> and many node positioning algorithms exist. These algorithms primarily deal with determining optimal positioning for static trees. Animating tree operations during a program's execution is quite different, however, requiring dynamic updates of node positions based on local changes.
Reference: [RT81] <author> Edward M. Reingold and John S. Tilford. </author> <title> Tidier drawings of trees. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7(2):223-228, </volume> <month> March </month> <year> 1981. </year>
Reference-contexts: Animations with smooth updates showing intermediate states help to preserve viewing context and convey the actual algorithm used to manipulate a tree. 3.2 Layout Techniques The problem of tree layout has been studied extensively <ref> [WS79, Vau80, RT81, WI90, Moe90] </ref> and many node positioning algorithms exist. These algorithms primarily deal with determining optimal positioning for static trees. Animating tree operations during a program's execution is quite different, however, requiring dynamic updates of node positions based on local changes.
Reference: [SH90] <author> John Stasko and J. Douglas Hayes. </author> <title> The XTANGO Algorithm Animation System, User Documentation. </title> <institution> GVU Center, College of Computing, Georgia Tech, </institution> <address> Atlanta, GA, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: The animations we describe in this paper reflect the binary tree representation. 3 Animation Methodology In this section, we describe how the pairing heap algorithm animations look and work. The animations are implemented using the XTango system <ref> [SH90] </ref>, a derivative of the Tango algorithm animation system [Sta90b].
Reference: [Sta90a] <author> John T. Stasko. </author> <title> The Path-Transition Paradigm: A practical methodology for adding animation to program interfaces. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 1(3) </volume> <pages> 213-236, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: 4 Tree Animation Algorithms To create an algorithm animation with XTango, a programmer must 1) augment the program being animated with algorithm operations, parameterized event calls that activate sets of animation routines 2) define the animation routines to represent the program operations using the XTango implementation of the path-transition paradigm <ref> [Sta90a] </ref>. The animation paradigm is based on four simple abstract data types (image, location, path, and transition) and their operations. XTango implements the data types in the C programming language using the X11 Window System.
Reference: [Sta90b] <author> John T. Stasko. </author> <title> TANGO: A framework and system for algorithm animation. </title> <journal> Computer, </journal> <volume> 23(9) </volume> <pages> 27-39, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Algorithm animations [Bro88b] visually depict how algorithms function to promote understanding of the algorithm's methodologies. Usually, the animations contain abstract views of an algorithm's semantics and operations. Recently developed algorithm animation systems <ref> [LD85, Bro88a, BB90, Sta90b, BK91, Bro91] </ref> primarily have advanced the technology exhibited in algorithm animations, but as the area of algorithm animation matures, these technological system advances must be accompanied by advances in the quality of algorithm presentations. <p> The animations we describe in this paper reflect the binary tree representation. 3 Animation Methodology In this section, we describe how the pairing heap algorithm animations look and work. The animations are implemented using the XTango system [SH90], a derivative of the Tango algorithm animation system <ref> [Sta90b] </ref>.
Reference: [SV87] <author> John T. Stasko and Jeffrey Scott Vitter. </author> <title> Pairing heaps: Experiments and analysis. </title> <journal> Communications of the ACM, </journal> <volume> 30(3) </volume> <pages> 234-249, </pages> <month> March </month> <year> 1987. </year> <month> 12 </month>
Reference-contexts: Unfortunately, Fibonacci heaps are quite complex and exceptionally difficult to implement. As a result, they are rarely used in practice. Pairing heaps offer an attractive alternative implementation option, nearly achieving the optimal amortized time bounds of Fibonacci heaps <ref> [FSST86, SV87] </ref>, yet providing a more manageable and less contrived data structure to implement. Pairing heaps are implemented as multiway trees with the heap property invariant that the children of a node have key values greater than or equal to the node's key value.
Reference: [Tar85] <author> Robert E. Tarjan. </author> <title> Amortized computational complexity. </title> <journal> SIAM Journal Algo--rithm Disc. Meth., </journal> <volume> 6 </volume> <pages> 306-318, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: By using a simple heap data structure, worst case time bounds of O (log n) are achieved for all operations. Fibonacci heaps [FT84], developed by 2 new first child of the "winner." Fredman and Tarjan, achieve amortized <ref> [Tar85] </ref> time bounds of O (1) for insert, find min, and decrease key and O (log n) for delete min and delete. Currently, these bounds provide the best running times for a variety of different problems [FT84]. Unfortunately, Fibonacci heaps are quite complex and exceptionally difficult to implement.
Reference: [TE88] <author> Roberto Tamassia and Peter Eades. </author> <title> Algorithms for drawing graphs: An annotated bibliography. </title> <type> Technical Report CS 89-09, </type> <institution> Brown University, Providence, RI, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: Animating tree algorithms is particularly difficult because they challenge the two intrinsic aspects of algorithm animation: layout and action. Graph and tree layout are known to be challenging problems with an extensive list of research articles on the topic <ref> [TE88] </ref>. For tree layout algorithms, specifying the placement of tree nodes to avoid edge crossings and to preserve aesthetics is critical. Various methods have been designed for optimally positioning the nodes in a static tree.
Reference: [Vau80] <author> Jean G. Vaucher. </author> <title> Pretty-printing of trees. </title> <journal> Software-Practice and Experience, </journal> <volume> 10 </volume> <pages> 553-561, </pages> <year> 1980. </year>
Reference-contexts: Animations with smooth updates showing intermediate states help to preserve viewing context and convey the actual algorithm used to manipulate a tree. 3.2 Layout Techniques The problem of tree layout has been studied extensively <ref> [WS79, Vau80, RT81, WI90, Moe90] </ref> and many node positioning algorithms exist. These algorithms primarily deal with determining optimal positioning for static trees. Animating tree operations during a program's execution is quite different, however, requiring dynamic updates of node positions based on local changes.
Reference: [WI90] <author> John Q. Walker II. </author> <title> A node positioning algorithm for general trees. </title> <journal> Software-Practice and Experience, </journal> <volume> 20(7) </volume> <pages> 685-705, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Animations with smooth updates showing intermediate states help to preserve viewing context and convey the actual algorithm used to manipulate a tree. 3.2 Layout Techniques The problem of tree layout has been studied extensively <ref> [WS79, Vau80, RT81, WI90, Moe90] </ref> and many node positioning algorithms exist. These algorithms primarily deal with determining optimal positioning for static trees. Animating tree operations during a program's execution is quite different, however, requiring dynamic updates of node positions based on local changes.
Reference: [WS79] <author> Charles Wetherell and Alfred Shannon. </author> <title> Tidy drawings of trees. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5(5):514-520, </volume> <month> September </month> <year> 1979. </year> <title> 13 the natural layout technique. 14 ascended smoothly up as trees in a new forest. 15 trees have been linked together. 16 pass from right-to-left has just occurred. </title> <type> 17 </type>
Reference-contexts: Animations with smooth updates showing intermediate states help to preserve viewing context and convey the actual algorithm used to manipulate a tree. 3.2 Layout Techniques The problem of tree layout has been studied extensively <ref> [WS79, Vau80, RT81, WI90, Moe90] </ref> and many node positioning algorithms exist. These algorithms primarily deal with determining optimal positioning for static trees. Animating tree operations during a program's execution is quite different, however, requiring dynamic updates of node positions based on local changes. <p> The figures at the end of this paper reflect the natural technique. Both layout methods render trees with basic "tidy" properties <ref> [WS79] </ref>: parents are drawn above children; nodes on the same level lie on a horizontal line; left children are drawn to the left of their parent (and vice-versa). To facilitate both layout techniques, local positioning information is encoded using the following strategy: For each node, two successor-width values are defined.
References-found: 22

