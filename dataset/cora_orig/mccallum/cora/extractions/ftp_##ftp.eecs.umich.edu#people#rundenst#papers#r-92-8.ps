URL: ftp://ftp.eecs.umich.edu/people/rundenst/papers/r-92-8.ps
Refering-URL: http://www.eecs.umich.edu/~rundenst/group/papers.html
Root-URL: http://www.cs.umich.edu
Email: rundenst@ics.uci.edu  
Title: MultiView: A Methodology for Supporting Multiple Views in Object-Oriented Databases  
Author: Elke A. Rundensteiner 
Address: Irvine, CA 92717-3425  
Affiliation: Department of Information and Computer Science University of California,  
Abstract: A view in object-oriented databases (OODB) corresponds to virtual schema graph with possibly restructured generalization and decomposition hierarchies. We propose a methodology, called MultiView, for supporting multiple such view schemata. MultiView represents a simple yet powerful approach achieved by breaking view specification into independent tasks: class derivation, global schema integration, view class selection, and view schema generation. Novel features of MultiView include an object algebra for class customization; an algorithm for the integration of virtual classes into the global schema; a view definition language for view class selection, and the automatic generation of a view class hierarchy. In addition, we present algorithms that verify the closure property of a view and, if found to be incomplete, transform it into a closed, yet minimal, view. Lastly, we introduce the fundamental concept of view independence and show MultiView to be view independent. 
Abstract-found: 1
Intro-found: 1
Reference: [Abit91] <author> Abiteboul, S., and Bonner, A., </author> <title> "Objects and Views," </title> <booktitle> in Proc. SIGMOD, </booktitle> <month> May </month> <year> 1991, </year> <pages> pp. 238 - 247. </pages>
Reference-contexts: A subgraph of the global schema which contains only virtual classes is commonly called a virtual schema <ref> [Tana88, Abit91] </ref>. Definition 10. Given a global schema GS=(V,E), then a view schema (VS), or short, a view, is defined to be a schema VS= (VV,VE) with: 1. VS has a unique view identifier &lt; V S &gt;, 2. VV V, and 3. VE transitive-closure (E). <p> By Definition 14, this proves the view independence of MultiView. 9 Related Work Most initial proposals for defining views for OODBs suggest the use of the query language defined for their respective object model to derive a virtual class, e.g., [Kim89], [Heil90], [Kaul90], [Scho91], and <ref> [Abit91] </ref>. Most of them do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as `stand-alone' objects [Heil90] or they are attached directly as subclasses of the schema root [Kim89].
Reference: [Bane87] <author> Banerjee, J., Kim, W., Kim, H. J., and Korth, F., </author> <title> "Semantics and Implementation of Schema Evolution in Object-Oriented Databases," </title> <booktitle> Proc. of SIMOD, </booktitle> <month> May </month> <year> 1987, </year> <pages> pp. </pages> <address> 311- 322. </address>
Reference-contexts: Initial proposals of views on OODBs have emerged that define a view to be a virtual class derived by an object-oriented query [Heil90, Scho91, Kim89]. An object-oriented schema is a complex structure of classes interrelated via various relationships, such as, the generalization and decomposition hierarchies <ref> [Kim89, Bane87] </ref>. An object-oriented view should thus be defined to be a virtual, possibly restructured, subschema graph of the global schema [Tana88]. This raises a number of challenging research issues in terms of how to restructure such view schema graphs and how to relate them with the global schema. <p> Instead, we need to support a number of different, potentially conflicting, view schemata of the same schema. We thus are concerned with the virtual restructuring of the global schema for each view; rather than with permanently changing the global database as is done in schema evolution <ref> [Bane87] </ref>. We solve the third task of MultiView by dividing it into two subtasks: first the explicit selection of view classes from the global schema and second the generation of a view class hierarchy for these selected classes.
Reference: [Date90] <author> Date, C. J., </author> <title> An Introduction to Database Sys tems, Vol. I, Fifth Ed., </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The set content of the virtual class is equal to the set content of the source class. The select operator is a set-manipulating operator that selects a subset of object instances from a given set of objects similar to the select operator of relational algebra <ref> [Date90] </ref>. It has the syntax "&lt;virtual-class&gt; = select from (&lt;source-class&gt;) where (&lt;predicate&gt;)" with &lt;predicate&gt; being some possibly complex function on the source class and its type description. <p> Complexity (CVG) O ( P O ( Ci2V (#arcs (Ci))) = O (min (jV j,jAj)). 8 View Independence Concept The concept of data independence developed for the relational model is defined as the "immunity of applications to change in storage structure and access technique" <ref> [Date90] </ref>. This is achieved by separating the interface to the database (the conceptual data model) from the actual implementation (the physical data model). A system provides logical data independence by supporting a view mechanism that lets the users define their own view schema on top of the common logical schema.
Reference: [Gilb90] <author> Gilbert, J. P., </author> <title> "Supporting User Views", </title> <booktitle> Proc. OODB Task Group Workshop, </booktitle> <address> Canada, </address> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: Furthermore, they approach the problem from the programming language point of view, and thus they do not handle the object instances associated with a class. Lastly, their approach focuses on one class only, and the effects of multiple interfaces on the class generalization hierarchy are not addressed. Gilbert's proposal <ref> [Gilb90] </ref>, similar to [Shil89], is also based on the idea of defining multiple interfaces for a class object. However, while our approach allows for the direct application of the class derivation mechanisms proposed in the literature, the use of general query operators is currently not handled by [Gilb90]. 10 Conclusions In <p> Gilbert's proposal <ref> [Gilb90] </ref>, similar to [Shil89], is also based on the idea of defining multiple interfaces for a class object. However, while our approach allows for the direct application of the class derivation mechanisms proposed in the literature, the use of general query operators is currently not handled by [Gilb90]. 10 Conclusions In this paper, we have presented a simple yet powerful approach for supporting multiple view schemata in OODBs, called MultiView. MultiView allows for the customization of a view schema by virtually restructuring both the generalization and the property decomposition hierarchies of the global schema.
Reference: [Heil90] <author> Heiler, S., and Zdonik, S. B., </author> <title> "Object views: Ex tending the vision", </title> <booktitle> in Proc. IEEE Data Eng. Conf., </booktitle> <month> Feb. </month> <year> 1990, </year> <pages> pp. 86 - 93. </pages>
Reference-contexts: Initial proposals of views on OODBs have emerged that define a view to be a virtual class derived by an object-oriented query <ref> [Heil90, Scho91, Kim89] </ref>. An object-oriented schema is a complex structure of classes interrelated via various relationships, such as, the generalization and decomposition hierarchies [Kim89, Bane87]. An object-oriented view should thus be defined to be a virtual, possibly restructured, subschema graph of the global schema [Tana88]. <p> The view schemata in Figure 1.c and 1.d are derived from GS by selecting a subset of its classes and interconnecting them into a valid schema using view is-a arcs. 2.3 The Closure of the View Property Decomposition Hierarchy This section addresses the consistency of the property decomposition hierarchy <ref> [Tana88, Heil90] </ref>, while the consistency of the generalization hierarchy is handled in [Rund92c]. Let the function Uses (C) represent the set of classes that are used by C's type interface. For example, if p corresponds to an object pointer defined by domain p (C)=C2, then Uses (C) contains C2. <p> Since there is no generally agreed-upon object algebra, we define our own object algebra for this work (and for the first prototype of MultiView) in Section 4. It is similar in flavor to the ones proposed in the literature <ref> [Kim89, Heil90, Scho91] </ref>. MultiView supports the integration of virtual classes into one comprehensive global schema [Rund92d]. This integration takes care of the maintenance of explicit class relationships between stored and derived classes. This is useful for sharing property functions and object instances consistently among classes without unnecessary duplication. <p> By Definition 14, this proves the view independence of MultiView. 9 Related Work Most initial proposals for defining views for OODBs suggest the use of the query language defined for their respective object model to derive a virtual class, e.g., [Kim89], <ref> [Heil90] </ref>, [Kaul90], [Scho91], and [Abit91]. Most of them do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as `stand-alone' objects [Heil90] or they are attached directly as subclasses of the schema root [Kim89]. <p> OODBs suggest the use of the query language defined for their respective object model to derive a virtual class, e.g., [Kim89], <ref> [Heil90] </ref>, [Kaul90], [Scho91], and [Abit91]. Most of them do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as `stand-alone' objects [Heil90] or they are attached directly as subclasses of the schema root [Kim89]. Scholl et al.'s recent work [Scho91] is one of the exceptions; they discuss the classification of virtual classes derived by the query language COOL into one schema.
Reference: [Kaul90] <author> Kaul, M., Drosten, K., and Neuhold, E.J., "ViewSystem: </author> <title> Integrating Heterogeneous Information Bases by Object-Oriented Views", </title> <booktitle> in Proc. IEEE Data Eng. Conf., </booktitle> <month> Feb. </month> <year> 1990, </year> <pages> pp. 2 - 10. </pages>
Reference-contexts: By Definition 14, this proves the view independence of MultiView. 9 Related Work Most initial proposals for defining views for OODBs suggest the use of the query language defined for their respective object model to derive a virtual class, e.g., [Kim89], [Heil90], <ref> [Kaul90] </ref>, [Scho91], and [Abit91]. Most of them do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as `stand-alone' objects [Heil90] or they are attached directly as subclasses of the schema root [Kim89].
Reference: [Kim89] <author> Kim, W., </author> <title> "A model of queries in object-oriented databases," </title> <booktitle> in Proc. Int. Conf. on Very Large Databases, </booktitle> <month> Aug. </month> <year> 1989, </year> <pages> pp. 423 - 432. </pages>
Reference-contexts: Initial proposals of views on OODBs have emerged that define a view to be a virtual class derived by an object-oriented query <ref> [Heil90, Scho91, Kim89] </ref>. An object-oriented schema is a complex structure of classes interrelated via various relationships, such as, the generalization and decomposition hierarchies [Kim89, Bane87]. An object-oriented view should thus be defined to be a virtual, possibly restructured, subschema graph of the global schema [Tana88]. <p> Initial proposals of views on OODBs have emerged that define a view to be a virtual class derived by an object-oriented query [Heil90, Scho91, Kim89]. An object-oriented schema is a complex structure of classes interrelated via various relationships, such as, the generalization and decomposition hierarchies <ref> [Kim89, Bane87] </ref>. An object-oriented view should thus be defined to be a virtual, possibly restructured, subschema graph of the global schema [Tana88]. This raises a number of challenging research issues in terms of how to restructure such view schema graphs and how to relate them with the global schema. <p> Since there is no generally agreed-upon object algebra, we define our own object algebra for this work (and for the first prototype of MultiView) in Section 4. It is similar in flavor to the ones proposed in the literature <ref> [Kim89, Heil90, Scho91] </ref>. MultiView supports the integration of virtual classes into one comprehensive global schema [Rund92d]. This integration takes care of the maintenance of explicit class relationships between stored and derived classes. This is useful for sharing property functions and object instances consistently among classes without unnecessary duplication. <p> By Definition 14, this proves the view independence of MultiView. 9 Related Work Most initial proposals for defining views for OODBs suggest the use of the query language defined for their respective object model to derive a virtual class, e.g., <ref> [Kim89] </ref>, [Heil90], [Kaul90], [Scho91], and [Abit91]. Most of them do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as `stand-alone' objects [Heil90] or they are attached directly as subclasses of the schema root [Kim89]. <p> object model to derive a virtual class, e.g., <ref> [Kim89] </ref>, [Heil90], [Kaul90], [Scho91], and [Abit91]. Most of them do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as `stand-alone' objects [Heil90] or they are attached directly as subclasses of the schema root [Kim89]. Scholl et al.'s recent work [Scho91] is one of the exceptions; they discuss the classification of virtual classes derived by the query language COOL into one schema. They do however not consider the problem of generating multiple view schemata or of enforcing the consistency of the view schema.
Reference: [Rund92a] <author> Rundensteiner, E. A., </author> <title> "MultiView: A Method ology for Supporting Multiple View Schemata in Object-Oriented Databases", </title> <institution> Univ. of Cal., Irvine, </institution> <type> Tech. Rep. </type> <pages> #92-07, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: This would be a correct but not the most informative class arrangement. The above described algorithm is inefficient since it always searches through all classes in the schema graph. This process can be optimized by fine-tuning it for each object algebra operator <ref> [Rund92a] </ref>. For instance, for the refine operator, which produces a virtual class with a new property function p, this algorithm can be reduced to a simple O (1) algorithm requiring no search. The reader is referred to [Rund92d] for more details. <p> In part II, we show that the algorithm actually generates the set of additional classes needed to make VS closed, i.e., CVG-done = MIN. Proofs for part I and part II are beyond the scope of this paper and can be found in <ref> [Rund92a] </ref>. Finally, part I and II together prove Theorem 2. Theorem 3. (Complexity) Given a view schema VS=(VV,VE) defined on GS=(V,E) with PGS=(V,A,L) the property decomposition hierarchy of GS. <p> The complexity of the CVG algorithm for VS is equal to O (min (jV j,jAj)) with jAj the number of prop erty decomposition arcs in PGS. Proof: The detailed proof for Theorem 3 can be found in <ref> [Rund92a] </ref>, while below we outline the key observations. First, we can show that all functions (and thus the two if-statements) used by CVG have constant complexity. <p> Similarly, we define the set membership of a class, denoted by content (C) = fo j o 2 Cg, to be the union of its direct and indirect instances. The proof for Theorem 4 can be found in <ref> [Rund92a] </ref>, while below we give the intuitive reasoning. MultiView determines the type description and the set membership of a view class directly from the global schema. Therefore, we can reduce the problem of view class preservation from the view to the global schema. <p> MultiView preserves the view is-a relationships among the view classes of each view in VS* through the restructuring of GS using the function (Definition 14.b). A proof for Theorem 5 is given in <ref> [Rund92a] </ref>. Mul-tiView derives the is-a relationships of view classes directly from their is-a relationships in GS, i.e., (8 C i ,C j 2 VV) ((C i is-a C j 2 GS) () (C i is-a C j 2 VS)).
Reference: [Rund92b] <author> Rundensteiner, E. A., and Bic, L., </author> <title> "Set Opera tions in Object-Based Data Models", </title> <journal> in IEEE Transaction on Data and Knowledge Eng., </journal> <volume> vol. 4, issue 3, </volume> <month> June </month> <year> 1992. </year>
Reference-contexts: Though MultiView is independent of particulars of the class derivation operators, we define a set of object algebra operators for the purpose of this work <ref> [Rund92b] </ref>. We study in particular the class relationships between the virtual and the source classes, since this is required for solving MultiView's second task. <p> Let T be the set of all types. 1 To determine whether two property functions are identical is equally hard to proving that two programs are equivalent. We therefore ensure uniqueness of properties by associating a unique property identifier with each newly defined property <ref> [Rund92b] </ref>. For t 2 T , properties t corresponds to the set of property functions of t and domain p (t) denotes the domain of p in t. Let C be the set of all classes. <p> However, since there is no agreed-upon standard, we present a representative set of algebra operators. We have shown the distinction between the type and the set aspect of a class to be a valuable tool for characterizing the semantics of query operators on object-based data models <ref> [Rund92b] </ref>. In this vein, we define the semantics of the operators by characterizing their manipulation of the type and the set aspect of the source class. <p> OODBs can be found in <ref> [Rund92b] </ref>. The semantics of the union operator are to return a set of object instances composed of the members of either or both of the source classes. The resulting type description is equal to the lowest common supertype of the two sources classes (Definition 5).
Reference: [Rund92c] <author> Rundensteiner, E. A. and Bic, L., </author> <title> "Automatic View Generation in Object-Oriented Databases", </title> <institution> Univ. of Cal., Irvine, </institution> <type> Tech. Rep. </type> <pages> #92-15, </pages> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: In this paper, we outline the overall approach and present a solution to the first task of MultiView, while solutions to the second and third task are given in [Rund92d] and <ref> [Rund92c] </ref>, respectively. Though MultiView is independent of particulars of the class derivation operators, we define a set of object algebra operators for the purpose of this work [Rund92b]. <p> For the former, we have developed a view definition language that can be used by the view definer to specify the desired view classes. For the latter, we have developed algorithms that automatically generate a consistent view generalization hierarchy <ref> [Rund92c] </ref>. We have developed criteria for the closure of the property decomposition and for the consistency of the generalization hierarchies of a view. In this paper, we present an algorithm for checking the closure property of a view schema. <p> GS by selecting a subset of its classes and interconnecting them into a valid schema using view is-a arcs. 2.3 The Closure of the View Property Decomposition Hierarchy This section addresses the consistency of the property decomposition hierarchy [Tana88, Heil90], while the consistency of the generalization hierarchy is handled in <ref> [Rund92c] </ref>. Let the function Uses (C) represent the set of classes that are used by C's type interface. For example, if p corresponds to an object pointer defined by domain p (C)=C2, then Uses (C) contains C2. Definition 11. <p> Second, it increases the level of support by allowing for the automation of some of the tasks. We present algorithms for automating the second task and the third task in [Rund92d] and in <ref> [Rund92c] </ref>, respectively. The first task of MultiView supports the virtual customization of existing classes by deriving new classes with a modified type description and/or membership content. <p> This automatic generation of view is-a arcs is preferable over their manual entry since it simplifies the task of the view designer and guarantees the consistency of the resulting view schema. Details about the view definition language and the automatic view generation can be found in <ref> [Rund92c] </ref>, while below we introduce the underlying ideas. The view definition language consists of two groups of operators: the first group either initiates or terminates a transaction on a view schema while the second group discussed in the next paragraph modifies a given view schema. <p> The view definers conclude the view definition phase by issuing the SAVE-VIEW command. MultiView then automatically augments the set of classes by the necessary view is-a arcs <ref> [Rund92c] </ref>. The second group of commands modifies the view VS by either adding or deleting view classes. The "ADD-CLASS (&lt;class-name&gt;)" command adds a class &lt;class-name&gt; in GS to VS. <p> Then the three classes of the base schema are added to VS using the command ADD-VIEW-SCHEMA (BS). The selected view classes are shown in Figure 3.d. When VS is saved, the is-a arcs shown in Figure 3.e are derived automatically by Mul-tiView <ref> [Rund92c] </ref>. 7 Automatic Generation of a Closed View Schema 7.1 The Minimality Criterion The closure criterion of a view schema can be verified only after the selection of all view classes, since it is a function of (the relationships among all classes in) the complete schema.
Reference: [Rund92d] <author> Rundensteiner, E. A., </author> <title> "A Class Integration Al gorithm and its Application For Supporting Consistent Object Views," </title> <institution> Univ. of Cal., Irvine, </institution> <type> Tech. Rep. </type> <pages> #92-50, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: In this paper, we outline the overall approach and present a solution to the first task of MultiView, while solutions to the second and third task are given in <ref> [Rund92d] </ref> and [Rund92c], respectively. Though MultiView is independent of particulars of the class derivation operators, we define a set of object algebra operators for the purpose of this work [Rund92b]. <p> Class integration, the second task of Mul-tiView, tackles the problem of how a virtual class relates to, and can be integrated with, the remaining classes in the global schema <ref> [Rund92d] </ref>. In the relational model, where each relation is physically independent from all other relations, the integration of a virtual relation with the global schema corresponds to simply adding it to the list of existing relations. In the context of OODBs, however, this is less straightforward. <p> A class in an object schema is interrelated with other classes via an is-a hierarchy (for property inheritance) and via a property decomposition hierarchy (for forming complex objects). Class integration needs to guaran-tee the consistency of these class relationships when adding new classes <ref> [Rund92d] </ref>. We cannot modify the existing schema so that it suits the requirements of one user. Instead, we need to support a number of different, potentially conflicting, view schemata of the same schema. <p> First, it simplifies view specification, since each of the tasks can be solved independently from the others. Second, it increases the level of support by allowing for the automation of some of the tasks. We present algorithms for automating the second task and the third task in <ref> [Rund92d] </ref> and in [Rund92c], respectively. The first task of MultiView supports the virtual customization of existing classes by deriving new classes with a modified type description and/or membership content. <p> It is similar in flavor to the ones proposed in the literature [Kim89, Heil90, Scho91]. MultiView supports the integration of virtual classes into one comprehensive global schema <ref> [Rund92d] </ref>. This integration takes care of the maintenance of explicit class relationships between stored and derived classes. This is useful for sharing property functions and object instances consistently among classes without unnecessary duplication. Class integration also assures the consistency of all views with the global schema and with one another. <p> In this section we sketch an overall approach for the class integration problem. A detailed treatment of this topic is beyond the scope of this paper and can be found elsewhere <ref> [Rund92d] </ref>. Class integration is concerned with finding the most `appropriate' location in the schema graph G for a virtual class VC in terms of property inheritance and subset relationships between classes. <p> For instance, for the refine operator, which produces a virtual class with a new property function p, this algorithm can be reduced to a simple O (1) algorithm requiring no search. The reader is referred to <ref> [Rund92d] </ref> for more details. We complete this section by demonstrating the classification process on an example. Example 5. In Figure 5, the virtual class Women is derived by the query "Women = select from (People) where Sex=female)".
Reference: [Rund93] <author> Rundensteiner, E. A., Bic, L., Gilbert, J., and Yin, M.-Y., </author> <title> "Set-Restricted Semantic Groupings," </title> <journal> in IEEE Trans. on Data and Knowledge Eng., </journal> <note> to appear in April 1993. </note>
Reference-contexts: Let O be an infinite set of object instances. The collection of objects that belong to a class C is denoted by content (C) = fo j o 2 Cg with the predicate "2" defined based on object identities <ref> [Rund93] </ref>. Definition 1. For two classes C1 and C2 2 C, C1 is called a subset of C2, denoted by C1 C2, if and only if (8 o 2 O) ((o2C1) =) (o2C2)). Definition 2.
Reference: [Schm83] <author> Schmolze, J. G., and Lipkis, T. A., </author> <title> "Classifica tion in the KL-ONE Knowledge Representation System," </title> <booktitle> in The Int. Joint Conf. on Artificial Intelligence, </booktitle> <month> Aug. </month> <year> 1983, </year> <pages> vol.1, pp. 330 - 332. </pages>
Reference: [Scho91] <author> Scholl, M. H., Laasch, C. and Tresch, M., </author> <title> "Up datable Views in Object-Oriented Databases," </title> <booktitle> in Proc. 2nd DOOD Conf., </booktitle> <address> Germany, </address> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: Initial proposals of views on OODBs have emerged that define a view to be a virtual class derived by an object-oriented query <ref> [Heil90, Scho91, Kim89] </ref>. An object-oriented schema is a complex structure of classes interrelated via various relationships, such as, the generalization and decomposition hierarchies [Kim89, Bane87]. An object-oriented view should thus be defined to be a virtual, possibly restructured, subschema graph of the global schema [Tana88]. <p> Since there is no generally agreed-upon object algebra, we define our own object algebra for this work (and for the first prototype of MultiView) in Section 4. It is similar in flavor to the ones proposed in the literature <ref> [Kim89, Heil90, Scho91] </ref>. MultiView supports the integration of virtual classes into one comprehensive global schema [Rund92d]. This integration takes care of the maintenance of explicit class relationships between stored and derived classes. This is useful for sharing property functions and object instances consistently among classes without unnecessary duplication. <p> By Definition 14, this proves the view independence of MultiView. 9 Related Work Most initial proposals for defining views for OODBs suggest the use of the query language defined for their respective object model to derive a virtual class, e.g., [Kim89], [Heil90], [Kaul90], <ref> [Scho91] </ref>, and [Abit91]. Most of them do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as `stand-alone' objects [Heil90] or they are attached directly as subclasses of the schema root [Kim89]. Scholl et al.'s recent work [Scho91] is one of the exceptions; <p> class, e.g., [Kim89], [Heil90], [Kaul90], <ref> [Scho91] </ref>, and [Abit91]. Most of them do not discuss the integration of derived classes into the global schema. Instead, the derived classes are treated as `stand-alone' objects [Heil90] or they are attached directly as subclasses of the schema root [Kim89]. Scholl et al.'s recent work [Scho91] is one of the exceptions; they discuss the classification of virtual classes derived by the query language COOL into one schema. They do however not consider the problem of generating multiple view schemata or of enforcing the consistency of the view schema.
Reference: [Shil89] <author> Shilling, J. J., and Sweeney, P. F., </author> <title> "Three Steps to Views: Extending the Object-Oriented Paradigm," </title> <booktitle> in Proc. OOPSLA, </booktitle> <month> Sep. </month> <year> 1989, </year> <pages> pp. 353 - 361. </pages>
Reference-contexts: They point out that work is needed for developing a definition language for view schemata. In this paper, we have provided a solution for this. In summary, MultiView is a more systematic solution approach compared to their rather ad-hoc proposal. Shilling and Sweeney <ref> [Shil89] </ref> extend the conventional concept of a class from having one type to having multiple interfaces. We accomplish the same goal by using the type refinement capability of the generalization hierarchy. Our work is simpler, since it does not require the extension of the traditional class concept. <p> Lastly, their approach focuses on one class only, and the effects of multiple interfaces on the class generalization hierarchy are not addressed. Gilbert's proposal [Gilb90], similar to <ref> [Shil89] </ref>, is also based on the idea of defining multiple interfaces for a class object.
Reference: [Tana88] <author> Tanaka, K., Yoshikawa, M., and Ishihara, K., </author> <title> "Schema Virtualization in Object-Oriented Databases," </title> <booktitle> in Proc. IEEE Data Eng. Conf., </booktitle> <month> Feb. </month> <year> 1988, </year> <pages> pp. 23 - 30. </pages>
Reference-contexts: An object-oriented schema is a complex structure of classes interrelated via various relationships, such as, the generalization and decomposition hierarchies [Kim89, Bane87]. An object-oriented view should thus be defined to be a virtual, possibly restructured, subschema graph of the global schema <ref> [Tana88] </ref>. This raises a number of challenging research issues in terms of how to restructure such view schema graphs and how to relate them with the global schema. In this paper, we propose a methodology, called MultiView, for supporting multiple view schemata that successfully solves these problems. <p> A subgraph of the global schema which contains only virtual classes is commonly called a virtual schema <ref> [Tana88, Abit91] </ref>. Definition 10. Given a global schema GS=(V,E), then a view schema (VS), or short, a view, is defined to be a schema VS= (VV,VE) with: 1. VS has a unique view identifier &lt; V S &gt;, 2. VV V, and 3. VE transitive-closure (E). <p> The view schemata in Figure 1.c and 1.d are derived from GS by selecting a subset of its classes and interconnecting them into a valid schema using view is-a arcs. 2.3 The Closure of the View Property Decomposition Hierarchy This section addresses the consistency of the property decomposition hierarchy <ref> [Tana88, Heil90] </ref>, while the consistency of the generalization hierarchy is handled in [Rund92c]. Let the function Uses (C) represent the set of classes that are used by C's type interface. For example, if p corresponds to an object pointer defined by domain p (C)=C2, then Uses (C) contains C2. <p> They do however not consider the problem of generating multiple view schemata or of enforcing the consistency of the view schema. Tanaka et al.'s work <ref> [Tana88] </ref> on schema virtual-ization does not distinguish between the task of integrating derived classes into a common schema and the task of generating view schemata.
Reference: [Yu91] <author> Yu and Osborn, </author> <title> "An Evaluation Framework for Algebraic Object-Oriented Query Models," </title> <booktitle> in Proc. IEEE Data Eng. Conf., </booktitle> <month> Feb. </month> <year> 1991. </year>
References-found: 17

