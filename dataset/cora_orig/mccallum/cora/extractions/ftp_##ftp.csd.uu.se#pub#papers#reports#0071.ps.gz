URL: ftp://ftp.csd.uu.se/pub/papers/reports/0071.ps.gz
Refering-URL: http://www.csd.uu.se/papers/reports.html
Root-URL: 
Email: E-mail: jonas@csd.uu.se, hakanm@csd.uu.se  
Phone: Phone: +481818 25 00 Fax: +461851 19 25  
Title: Providing Iteration and Concurrency in Logic Programs through Bounded Quantifications  
Author: Jonas Barklund and H-akan Millroth 
Note: This is a slightly extended version of work presented at the International Conference on Fifth Generation Computer Systems 1992.  
Address: Uppsala University  Box 311, S-751 05 Uppsala, Sweden  
Affiliation: Computing Science Dept.  
Abstract: UPMAIL Technical Report No. 71 29 July, 1994 Abstract Programs operating on inductively defined data structures, such as lists, are naturally defined by recursive programs, while programs operating on `indexable' data structures, such as arrays, are naturally defined by iterative programs. It has recently been shown how many recursive programs can be transformed or compiled to iterative programs operating on arrays. Such transformed programs can be run more efficiently than the original programs, particularly on parallel computers. The present work is aimed at providing means for writing such iterative programs directly, using available language constructs of first order predicate calculus. The paper proposes the introduction of `bounded quantifications' in logic programming languages. These formulas offer a natural way to express programs operating on arrays and other `indexable' data structures. `Bounded quantifications' are similar to `array comprehensions' in functional languages such as Haskell. They are inherently concurrent and can be run efficiently on sequential computers as well as on various classes of parallel computers. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Anderson, S. & Hudak, P., </author> <year> 1990, </year> <title> Compilation of Haskell Array Comprehensions for Scientific the use of the arg predicate in Prolog. 6 KL1 is a concurrent language based on a `flat' version of Guarded Horn Clauses (Ueda, </title> <booktitle> 1986). Computing. In Proc. SIGPLAN '90 Conf. on Programming Language Design and Implementation. </booktitle> <publisher> ACM Press, </publisher> <address> New York, N.Y. </address>
Reference: <author> Barklund, J. & Millroth, H., </author> <year> 1988, </year> <title> Nova Prolog. </title> <type> UPMAIL Tech. Rep. 52. </type> <institution> Computing Science Dept., Uppsala Univ. </institution>
Reference-contexts: Futures (Halstead, 1985) are yet another way of giving names for values which are yet to be fully computed. 14.2 Nova Prolog The ideas presented above can be seen as a generalization and further development of our earlier language Nova Prolog <ref> (Barklund & Millroth, 1988) </ref>. 4 Here, however, it is appropriate to present Nova Prolog as a language embodying a subset of bounded quantifications. The subset is chosen to obtain a language tailored specifically for massively parallel SIMD computers, such as the Connection Machine.
Reference: <author> Blanck, J., </author> <year> 1991, </year> <note> Abstrakt maskin for Nova Pro-log. Internal report in Swedish. </note> <institution> Computing Science Dept., Uppsala Univ. </institution>
Reference-contexts: We can see that in Nova Prolog the `index' I is implicit and is denoted by the constant symbol self in the body . The examples above for array computations can be translated into Nova Prolog. We have recently implemented parts of Nova Prolog in *LISP <ref> (Blanck, 1991) </ref>. 15 CONCLUSION AND FUTURE WORK We have defined bounded quantifications, a new construct for logic programming languages. We have discussed how they can be efficiently implemented on sequential and parallel computers.
Reference: <author> Colmerauer, A., Kanoui, H., Pasero, R. & Rous-sel, P., </author> <year> 1972, </year> <title> Un Systeme de Communication Homme-Machine en Fran~cais. </title> <institution> Groupe de Recherche en Intelligence Artificielle, Univ. </institution> <address> d'Aix-Marseille, Luminy. </address>
Reference-contexts: We assume "Herbrand" equality except for arithmetic expressions and array elements. All examples can be easily translated into Prolog <ref> (Colmerauer, Kanoui, Pasero & Roussel, 1972) </ref> or Godel (Hill & Lloyd, 1991). actually supplied to the program. Such a program can be run efficiently as an iteration on a sequential computer.
Reference: <author> DeGroot, D., </author> <year> 1984, </year> <title> Restricted And-Parallelism. </title> <booktitle> In Proc. Intl. Conf. on Fifth Generation Comp. Systems 1984, </booktitle> <pages> pp. 471-8. </pages> <publisher> North-Holland, Amsterdam. </publisher>
Reference: <author> Halstead, R., </author> <year> 1985, </year> <title> Multilisp|a Language for Concurrent Symbolic Computation. </title> <journal> ACM TOPLAS, </journal> <volume> 2, </volume> <pages> 501-38. </pages>
Reference-contexts: This can be thought of as a degenerated form of concurrency which suspends part of a computation until it is known that it must be performed. We do not think lazy computation is necessary, provided unification with the "logical variable" and a more general form of con-currency. Futures <ref> (Halstead, 1985) </ref> are yet another way of giving names for values which are yet to be fully computed. 14.2 Nova Prolog The ideas presented above can be seen as a generalization and further development of our earlier language Nova Prolog (Barklund & Millroth, 1988). 4 Here, however, it is appropriate to
Reference: <author> Hill, P. M. & Lloyd, J. W., </author> <year> 1991, </year> <title> The Godel Report. </title> <type> Tech. Rep. 91-02. </type> <institution> Computer Science Dept., Univ. of Bristol. </institution>
Reference-contexts: We assume "Herbrand" equality except for arithmetic expressions and array elements. All examples can be easily translated into Prolog (Colmerauer, Kanoui, Pasero & Roussel, 1972) or Godel <ref> (Hill & Lloyd, 1991) </ref>. actually supplied to the program. Such a program can be run efficiently as an iteration on a sequential computer. The latter category uses recursion to compute a disjunction, for example the member program. member (A; [BjX]) A = B. member (A; [BjX]) member (A; X).
Reference: <author> Hudak, P. & Wadler, P., </author> <year> 1990, </year> <title> Report on the Programming Language Haskell. </title> <type> Tech. Rep. </type> <institution> YALEU/DCS/RR-777. Dept. of Computer Science, Yale Univ. </institution>
Reference-contexts: calculation. (The authors were, however, ignorant about Fortran 90 and discovered these FORALL statements only after developing bounded quantifications and the examples above.) 14.1 Array Comprehensions It is obvious that there are similarities between arrays and bounded quantifications on one side, and the array comprehensions proposed for the Haskell language <ref> (Hudak & Wadler, 1990) </ref> on the other. Both concepts aim to express the contents of an array, or the relationship between several arrays, declaratively.
Reference: <author> Knuth, D. E., </author> <year> 1968, </year> <booktitle> The Art of Computer Programming. Volume 1 / Fundamental Algorithms. </booktitle> <address> Reading, Mass. </address>
Reference-contexts: a specified node R such that: each node N 6= R is the initial node of exactly on arc; R is the initial node of no arc; R is a root in the sense that for each node N 6= R there is an oriented path from N to R" <ref> (Knuth, 1968) </ref>. 5 The array G is set up to contain the 2N + 1 values f (a), f (a+w=2), f (a+w), : : : , f (bw), f (bw=2), f (b). These values are used to compute the area for each of the intervals, stored in Z.
Reference: <author> Lloyd, J. W. & Topor, R. W., </author> <year> 1984, </year> <title> Making Prolog more Expressive. </title> <journal> J. Logic Programming, </journal> <volume> 1, </volume> <pages> 225-40. </pages>
Reference: <author> Meier, M., </author> <year> 1991, </year> <title> Recursion vs. Iteration in Prolog. </title> <booktitle> In Proc. 8th Intl. Conf. on Logic Programming (ed. K. Furukawa), </booktitle> <pages> pp. 157-69. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Mass. </address>
Reference: <author> Metcalf, M. & Reid, J., </author> <year> 1990, </year> <title> Fortran 90 Explained. </title> <publisher> Oxford Univ. Press, Oxford. </publisher>
Reference-contexts: Note the similarity between our bounded quantifications, having array reference range formulas, and the FORALL statements of Fortran 90 <ref> (Metcalf & Reid, 1990) </ref>. 5.2 Integer ranges An obviously useful range formula would be one which is true for the first k integers ([0; k 1]).
Reference: <author> Millroth, H., </author> <year> 1990, </year> <title> Reforming Compilation of Logic Programs. </title> <type> Ph.D. thesis. </type> <institution> Uppsala Theses in Computing Science 10. Computing Science Dept., Uppsala Univ. </institution>
Reference: <author> Press, W. H. et al., </author> <year> 1989, </year> <title> Numerical Recipes. </title> <booktitle> The Art of Scientific Computing. </booktitle> <publisher> Cambridge Univ. Press, </publisher> <address> Cambridge, U.K. </address>
Reference: <author> Sato, T. & Tamaki, H., </author> <year> 1989, </year> <title> First Order Compiler: a Deterministic Logic Program Synthesis Algorithm. </title> <journal> J. Symbolic Computation, </journal> <volume> 8, </volume> <pages> 605-27. </pages>
Reference: <author> Shapiro, E., </author> <year> 1983, </year> <title> A Subset of Concurrent Prolog and Its Interpreter. </title> <type> Technical Report TR-003. </type> <institution> ICOT, </institution> <address> Tokyo. </address>
Reference-contexts: We are currently investigating whether automatic generation of synchronization/coroutining code is sufficient or if the programmer should be allowed to annotate the program, for example, through read-only variables <ref> (Shapiro, 1983) </ref>. 14 RELATED WORK We noted above that M. Meier has suggested (1991) how to compile some tail recursive (conjunctive as well as disjunctive) programs to iterative programs on top of WAM.
Reference: <author> Tarnlund, S. A., </author> <year> 1992, </year> <title> Reform. In Massively Parallel Reasoning Systems (ed. </title> <editor> J. A. </editor> <address> Robin-son). </address> <note> To be published by MIT Press, Cam-bridge, Mass. </note>
Reference: <author> Ueda, K., </author> <year> 1986, </year> <title> Guarded Horn Clauses: a Parallel Logic Programming Language with the Con 8 cept of a Guard. </title> <type> Technical Report TR-208. </type> <institution> ICOT, </institution> <address> Tokyo. </address>
Reference: <author> Warren, D. H. D., </author> <year> 1983, </year> <title> An Abstract Prolog Instruction Set. </title> <type> SRI Tech. Note 309. </type> <institution> SRI International, Menlo Park, Calif. </institution> <month> 9 </month>
Reference-contexts: code as allocate_environment; y = deref (l); while (y != NIL) - x = deref (y-&gt;head); code for [x]; y = deref (y-&gt;tail); - deallocate_environment; using a C-style notation. (Note that we ignore the enumeration of the list elements in this example.) Assuming that the implementation is based on WAM <ref> (Warren, 1983) </ref> the "code for [x]" may introduce choice points (and thus be unable to 3 deallocate environments) if there are alternative solutions for [x]. In the important case that the proof for [x] is deterministic, every pass through the loop will begin in the same environment.
References-found: 19

