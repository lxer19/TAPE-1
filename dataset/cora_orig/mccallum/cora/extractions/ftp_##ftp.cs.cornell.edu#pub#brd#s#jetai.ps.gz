URL: ftp://ftp.cs.cornell.edu/pub/brd/s/jetai.ps.gz
Refering-URL: http://www.cs.cornell.edu/Info/People/brd/brd.html
Root-URL: 
Title: Minimalism Distribution Supermodularity  
Author: Bruce Donald Jim Jennings Daniela Rus 
Date: April 18, 1996  
Address: Ithaca, NY 14853 New Orleans, LA 70118  Hanover, NH 03755  
Affiliation: Department of Computer Science Department of Computer Science Cornell University Tulane University  Department of Computer Science Dartmouth College  
Abstract: We have designed and implemented multi-agent strategies for manipulation tasks by distributing mechanically-based sequential algorithms across several autonomous spatially-separated agents, such as mobile robots. Our experience using mobile robots for the manipulation of large objects (couches, boxes, file cabinets, etc.) leads us to recommend a minimalist architecture for multi-agent programming. In particular, our methodology has led us to derive asynchronous distributed strategies that require no direct communication between agents, and very sparse geometric and dynamic models of the objects our robots manipulate. We argue for a design principle called supermodu-larity, which is orthogonal both to the notion of modularity in cognitive AI and also to horizontal decomposition (the non-modularity advocated in the subsump-tion/connectionist literature.) Finally, we discuss a simple mobot-Scheme infrastructure to implement supermodular architectures. In the past few years we have programmed many su-permodular manipulation protocols and tested them extensively on our team of mobile robots. We describe why we think the supermodular infrastructure results in robust, simple, readable, manipulation strategies that can be recycled and reused. 
Abstract-found: 1
Intro-found: 1
Reference: [ABN93] <author> R.C. Arkin, T. Balch, and E. Nitz. </author> <title> Communication of behavioral state in multi-agent retrieval tasks. </title> <booktitle> In Proc. of the 1993 IEEE International Conference on Robotics and Automation, </booktitle> <volume> volume 2, </volume> <pages> pages 588-594, </pages> <address> Atlanta, Ga, </address> <year> 1993. </year>
Reference-contexts: box) and demonstrate a manipulation planner which maintains this contact con figuration. 3 4.2 Cooperating Mobile Robots Other recent work investigates tasks in which multiple mobile robots cooperate, such as: [SB93] (manipulation of pallets by many small robots in simulation); [Mat93] (study of group behaviors such as dispersion and flocking); <ref> [ABN93] </ref> (simulation of foraging agents with and without communication). Work combining cooperation with mobot manipulation includes [Nor93], [Par94], and [DJR93, DJR94a, DJR94b, RDJ95, Jen95].
Reference: [BBD + 95] <author> K. Bohringer, R. Brown, B. Donald, J. Jen-nings, and D. </author> <title> Rus. Distributed robotic manipulation:experiments in minimalism. </title> <booktitle> In Proceedings of the International Symposium on Experimental Robotics, </booktitle> <address> Stanford, CA, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: We have reported on several sets of manipulation strategies (which we call protocols), and also on the methodology which generated them <ref> [Don95, BBD + 95, RDJ95, Jen95] </ref>. Our most interesting protocols are asynchronous and do not require communication between the agents. In this paper we address the architecture and the programming environment we used to develop our protocols. <p> We argued that circuits authored in a supermodular architecture translate into code that is simple, reusable, portable, predictable, parallelizable, and "near-optimal" from the point of view of resource consumption <ref> [BBD + 95] </ref>. We have experimental evidence for these properties| for example the reuse of (align) in the reorientation protocols and the Pusher/Steerer protocols. Similarly, we have performance guarantees.
Reference: [BJ95] <author> R. Brown and J. Jennings. </author> <title> Manipulation by a pusher/steerer. </title> <booktitle> In Proceedings of Intelligent Robot Systems, </booktitle> <address> Pittsburgh, PA, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: The partial order on these circuits with respect to supermodularity is shown in Figure 10. 5.3 MPMD Manipulation Section 5.2 presents an implemented and tested SPMD manipulation protocol. We now present an MPMD protocol called the Pusher/Steerer system. A detailed description and analysis of this system is given in <ref> [BJ95, Bro95] </ref>. The system consists of two robots. Each of the two robots executing this protocol either takes on the role of the Pusher, in which 1.
Reference: [Bro85] <author> R. C. Brost. </author> <title> Planning robot grasping motions in the presence of uncertainty. </title> <institution> Carnegie-Mellon Robotics Institute technical report CMU-RI-TR-85-12, Computer Science Department and The Robotics Institute, </institution> <month> July </month> <year> 1985. </year>
Reference-contexts: Mason's analyses of the mechanics of pushing and grasping have led to many practical manipulation strategies implemented most often on anthropomorphic robot arms with simple two-finger grippers. Similarly, <ref> [Bro85] </ref> and others have analyzed the geometry and mechanics of quasi-static pushing and squeeze-grasping of planar objects with common "parallel jaw" grippers. Some work has been done on large-scale manipulation using a single mobile robot, such as [LM94] and [OY92].
Reference: [Bro90] <author> R. Brooks. </author> <title> The behavior language user's guide. </title> <type> Technical report, Memo 1227, </type> <institution> MIT AI Lab, </institution> <year> 1990. </year>
Reference-contexts: For details see [RD92]. These decisions concern: 1. Why extend a general-purpose programming language instead of using or inventing a special-purpose robot language such as ALPHA [Gat91], or the behavior language <ref> [Bro90] </ref> ? 2. Of the general-purpose languages, why Scheme? We regard robots as computers that can exert forces. In particular, we are interested only in the case these forces are external to the robot system| this excludes devices like clocks from being considered robots.
Reference: [Bro95] <author> R. G. Brown. </author> <title> Algorithms for Mobile Robot Localization and Building Flexible, Robust, Easy to Use Mobile Robots. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <address> Ithaca, NY, </address> <year> 1995. </year> <month> 19 </month>
Reference-contexts: The partial order on these circuits with respect to supermodularity is shown in Figure 10. 5.3 MPMD Manipulation Section 5.2 presents an implemented and tested SPMD manipulation protocol. We now present an MPMD protocol called the Pusher/Steerer system. A detailed description and analysis of this system is given in <ref> [BJ95, Bro95] </ref>. The system consists of two robots. Each of the two robots executing this protocol either takes on the role of the Pusher, in which 1. <p> In these experiments, boxes and similar objects of varying size, mass, mass distribution, and material properties were manipulated along complicated paths up to 50 feet in length. On the basis of these experiments, along with others which are described in <ref> [Bro95] </ref>, we have observed the system to be quite robust in practice. In each case, the code that each robot executed remained the same|there was no recoding or "tuning" for different objects or paths. <p> In the idealized model, the predicate is evaluated continuously in the background. 8 All of our motion control functions follow the same style for any effector (including, e.g., a camera which may pan or tilt <ref> [Bro95] </ref>). Examples of Mobot Scheme code for various modes of translation (forward motion) are in Figure 13. We deviated from typical Scheme style by introducing keyword arguments which modify the effects of the motion.
Reference: [CFKM95] <author> Y. Cao, A. Fukunaga, A. Kahng, and F. Meng. </author> <title> Cooperative mobile robots: Antecedents and directions. </title> <type> Technical report, </type> <institution> UCLA Department of Computer Science, </institution> <year> 1995. </year>
Reference-contexts: While these results are yet to be proved rigorously, we believe that the supermodular framework is the right architecture for addressing performance guarantees. 4 Previous Work There has been much work on cooperative systems of robots. For an excellent review see <ref> [CFKM95] </ref>. Previous work on cooperative manipulation has focused mostly on pushing, usually in the context of box-pushing by multiple mobile robots, e.g., [Par94], [Nor93]. 4.1 Robotic Manipulation [MS85] presents extensive analysis of grasping and pushing operations under a quasi-static model.
Reference: [CR92] <editor> W. Clinger and J. Rees. </editor> <title> Revised 4 report on the algorithmic language scheme. </title> <type> Technical report, </type> <institution> Cornell University Department of Computer Science, </institution> <year> 1992. </year>
Reference-contexts: The entire language definition, including its history, code examples, macro documentation, formal syntax and semantics, and extensive bibliography fits into 55 pages <ref> [CR92] </ref>. Scheme is a modern high-level functional language with automatic memory management, first-class functions, block structure, static scoping, closures, polymorphism, and dynamic typing.
Reference: [DJR93] <author> B. R. Donald, James S. Jennings, and D. </author> <title> Rus. Towards a theory ofinformation invariants for cooperating autonomous mobile robots. </title> <booktitle> In International Symposium on Robotics Research (ISRR), </booktitle> <address> Hidden Valley, PA, </address> <year> 1993. </year>
Reference-contexts: and hence the algorithms must be adapted to rely less extensively on geometrical and dynamical models. (3) A host of difficulties arises when a task must be performed by a distributed team instead of a single agent|and hence the algorithms must compensate by changing their communication, sensing, or knowledge requirements <ref> [Don95, DJR93, DJR94a, RDJ95] </ref>. We have reported on several sets of manipulation strategies (which we call protocols), and also on the methodology which generated them [Don95, BBD + 95, RDJ95, Jen95]. Our most interesting protocols are asynchronous and do not require communication between the agents. <p> Work combining cooperation with mobot manipulation includes [Nor93], [Par94], and <ref> [DJR93, DJR94a, DJR94b, RDJ95, Jen95] </ref>. <p> However, Lynch and Mason ([LM94]) present a simulator and motion planner for single-robot pushing that is based in sound mechanics, and this simulator may yet be extended to multiple-robot manipulation. Also, <ref> [DJR93, DJR94a, DJR94c, DJR94b, Jen95] </ref> present algorithms for two-robot pushing and for multi-robot reorientation. They analyze their protocols with respect to usage of such resources as computation, retained state (e.g., models), sensors, and communication. <p> The robots could exchange the sensed torque at their points of contact to determine the best contact point on the face of the object. A detailed description of this method is presented in <ref> [DJR93, DJR94a] </ref>. 5 Left robot Right robot 0 (0) repeat: push f measure (t) g until (t) 6= 0 if (t) &gt; 0 translate-left else translate-right 0 (0) repeat: push f measure (t) g until (t) 6= 0 if (t) &gt; 0 translate-left else translate-right without communication. manipulation circuit for Protocol <p> a result of this technique. 7 Architecture When the minimalist philosophy is applied to robot manipulation algorithms it yields protocols with surprisingly low resource consumption|that is, the resulting protocols often dispense with a resource (such as sensing, communication, or geometric models) that a naive analysis would have predicted was essential <ref> [DJR93, DJR94a, RDJ95, DJR94b] </ref>. When applied to the programming environment and architectural support for robot manipulation, minimalism results in a development and execution system that is spare and lean|in other words, something more like Scheme and less like C++ (Section 6).
Reference: [DJR94a] <author> B. Donald, J. Jennings, and D. </author> <title> Rus. Information invariants for distributed manipulation. </title> <booktitle> The First Workshop on the Algorithmic Foundations of Robotics, </booktitle> <editor> eds. K. Goldberg, D. Halperin, J.-C. Latombe, and R. </editor> <publisher> Wilson, </publisher> <pages> pages 431-459, </pages> <year> 1994. </year>
Reference-contexts: and hence the algorithms must be adapted to rely less extensively on geometrical and dynamical models. (3) A host of difficulties arises when a task must be performed by a distributed team instead of a single agent|and hence the algorithms must compensate by changing their communication, sensing, or knowledge requirements <ref> [Don95, DJR93, DJR94a, RDJ95] </ref>. We have reported on several sets of manipulation strategies (which we call protocols), and also on the methodology which generated them [Don95, BBD + 95, RDJ95, Jen95]. Our most interesting protocols are asynchronous and do not require communication between the agents. <p> Work combining cooperation with mobot manipulation includes [Nor93], [Par94], and <ref> [DJR93, DJR94a, DJR94b, RDJ95, Jen95] </ref>. <p> However, Lynch and Mason ([LM94]) present a simulator and motion planner for single-robot pushing that is based in sound mechanics, and this simulator may yet be extended to multiple-robot manipulation. Also, <ref> [DJR93, DJR94a, DJR94c, DJR94b, Jen95] </ref> present algorithms for two-robot pushing and for multi-robot reorientation. They analyze their protocols with respect to usage of such resources as computation, retained state (e.g., models), sensors, and communication. <p> The robots could exchange the sensed torque at their points of contact to determine the best contact point on the face of the object. A detailed description of this method is presented in <ref> [DJR93, DJR94a] </ref>. 5 Left robot Right robot 0 (0) repeat: push f measure (t) g until (t) 6= 0 if (t) &gt; 0 translate-left else translate-right 0 (0) repeat: push f measure (t) g until (t) 6= 0 if (t) &gt; 0 translate-left else translate-right without communication. manipulation circuit for Protocol <p> a result of this technique. 7 Architecture When the minimalist philosophy is applied to robot manipulation algorithms it yields protocols with surprisingly low resource consumption|that is, the resulting protocols often dispense with a resource (such as sensing, communication, or geometric models) that a naive analysis would have predicted was essential <ref> [DJR93, DJR94a, RDJ95, DJR94b] </ref>. When applied to the programming environment and architectural support for robot manipulation, minimalism results in a development and execution system that is spare and lean|in other words, something more like Scheme and less like C++ (Section 6).
Reference: [DJR94b] <author> B. R. Donald, James S. Jennings, and D. </author> <title> Rus. Analyzing teams of cooperating mobile robots. </title> <booktitle> In Proceedings of the 1994 IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 1896-1903, </pages> <address> San Diego, CA, </address> <year> 1994. </year>
Reference-contexts: Work combining cooperation with mobot manipulation includes [Nor93], [Par94], and <ref> [DJR93, DJR94a, DJR94b, RDJ95, Jen95] </ref>. <p> However, Lynch and Mason ([LM94]) present a simulator and motion planner for single-robot pushing that is based in sound mechanics, and this simulator may yet be extended to multiple-robot manipulation. Also, <ref> [DJR93, DJR94a, DJR94c, DJR94b, Jen95] </ref> present algorithms for two-robot pushing and for multi-robot reorientation. They analyze their protocols with respect to usage of such resources as computation, retained state (e.g., models), sensors, and communication. <p> a result of this technique. 7 Architecture When the minimalist philosophy is applied to robot manipulation algorithms it yields protocols with surprisingly low resource consumption|that is, the resulting protocols often dispense with a resource (such as sensing, communication, or geometric models) that a naive analysis would have predicted was essential <ref> [DJR93, DJR94a, RDJ95, DJR94b] </ref>. When applied to the programming environment and architectural support for robot manipulation, minimalism results in a development and execution system that is spare and lean|in other words, something more like Scheme and less like C++ (Section 6).
Reference: [DJR94c] <author> B. R. Donald, James S. Jennings, and D. </author> <title> Rus. Information invariants for distributed manipulation. </title> <booktitle> In Proceedings of the 1994 Workshop on the Algorithmic Foundations of Robotics, </booktitle> <address> San Francisco, CA, </address> <year> 1994. </year>
Reference-contexts: However, Lynch and Mason ([LM94]) present a simulator and motion planner for single-robot pushing that is based in sound mechanics, and this simulator may yet be extended to multiple-robot manipulation. Also, <ref> [DJR93, DJR94a, DJR94c, DJR94b, Jen95] </ref> present algorithms for two-robot pushing and for multi-robot reorientation. They analyze their protocols with respect to usage of such resources as computation, retained state (e.g., models), sensors, and communication.
Reference: [Don95] <author> B. Donald. </author> <title> Information invariants in robotics. </title> <journal> Artificial Intelligence, </journal> <volume> 72 </volume> <pages> 217-304, </pages> <year> 1995. </year>
Reference-contexts: and hence the algorithms must be adapted to rely less extensively on geometrical and dynamical models. (3) A host of difficulties arises when a task must be performed by a distributed team instead of a single agent|and hence the algorithms must compensate by changing their communication, sensing, or knowledge requirements <ref> [Don95, DJR93, DJR94a, RDJ95] </ref>. We have reported on several sets of manipulation strategies (which we call protocols), and also on the methodology which generated them [Don95, BBD + 95, RDJ95, Jen95]. Our most interesting protocols are asynchronous and do not require communication between the agents. <p> We have reported on several sets of manipulation strategies (which we call protocols), and also on the methodology which generated them <ref> [Don95, BBD + 95, RDJ95, Jen95] </ref>. Our most interesting protocols are asynchronous and do not require communication between the agents. In this paper we address the architecture and the programming environment we used to develop our protocols. <p> In programming, it is natural to talk about units of organization called subroutines. In mobile robotics| particularly for distributed strategies|we have developed analysis and synthesis tools for units of organization called circuits <ref> [Don95] </ref>. Intuitively, a circuit is a sensori-computational unit consisting of sensors and actuators connected by data paths. We model our circuits as graphs. Vertices correspond to different sensori-computational components. Edges corre spond to the data paths through which the information passes. <p> On the other hand, the forces exerted by the robots in the two-robot Pusher/Steerer system can constrain the object reliably in the presence of greater uncertainties, e.g., in the location of the COF, and under coarser control and sensing. In his monograph on information invariants <ref> [Don95] </ref>, Donald claims that the spatial distribution of resources has a critical effect on the capabilities of a system. The Pusher/Steerer system validates that claim. Consider a single-robot manipulation algorithm such as, [LM94]. <p> The installation and calibration of resources must be specified, and communications pathways across spatially separate locations must be available. (The precise definition of these operations is given in the information invariants theory <ref> [Don95] </ref>.) But for a distributed circuit to achieve the same task, we must demonstrate that the embedded circuits effect the same strategy. For our particular domain of manipulation tasks, we must account for the mechanical interactions between the robots and their environment.
Reference: [DRJ96] <author> B. R. Donald, D. Rus, and J. Jennings. </author> <title> Quantifying supermodularity in dostributed manipulation circuits. </title> <note> In forthcoming paper, </note> <year> 1996. </year>
Reference-contexts: Hence, super-modularity is a partial order on circuits. In this paper we will (informally) use the term "circuit X is often supermodular" to connote that "C (X) is large". This concept may be quantified precisely by measuring the relative volume of C (X) in C <ref> [DRJ96] </ref>. In this paper we describe a partial order on the circuits we describe in detail. Some circuits are completely supermodular for the manipulation tasks we consider, while other circuits are not supermodular at all. <p> In our forthcoming work we will characterize this property algebraically <ref> [DRJ96] </ref>. Here we develop the following partial order on supermodular circuits. We have given examples of circuits that are not supermodular at all (such as (prim-push)), circuits that are often supermodular (such as (push-track)), and circuits that are always supermodular (such as (align) and Async-Online).
Reference: [Erd84] <author> M. Erdmann. </author> <title> On motion planning with uncertainty. </title> <type> Master's thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1984. </year>
Reference-contexts: Termination predicates have been introduced in the pre-image motion planning framework of [LPMT84]. An extensive discussion of the relative power of these termination predicates in the context of motion planning may be found in <ref> [Erd84] </ref>. In the [LPMT84] framework, actions are pairs of the form (v; tp), where v is a velocity vector, and tp is a termination predicate. The motion continues in the direction v until the termination predicate returns true.
Reference: [Gat91] <author> Erann Gatt. </author> <title> Alpha:a language for programming reactive robotics control systems. </title> <booktitle> In Proceedings of the 1991 IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 1116-1121, </pages> <year> 1991. </year>
Reference-contexts: We begin with two architectural decisions that we first reported in our paper "Program mobile robots in Scheme" [RD92]. For details see [RD92]. These decisions concern: 1. Why extend a general-purpose programming language instead of using or inventing a special-purpose robot language such as ALPHA <ref> [Gat91] </ref>, or the behavior language [Bro90] ? 2. Of the general-purpose languages, why Scheme? We regard robots as computers that can exert forces. In particular, we are interested only in the case these forces are external to the robot system| this excludes devices like clocks from being considered robots.
Reference: [Jen95] <author> J. S. Jennings. </author> <title> Distributed Manipulation with Mobile Robots. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1995. </year>
Reference-contexts: We have reported on several sets of manipulation strategies (which we call protocols), and also on the methodology which generated them <ref> [Don95, BBD + 95, RDJ95, Jen95] </ref>. Our most interesting protocols are asynchronous and do not require communication between the agents. In this paper we address the architecture and the programming environment we used to develop our protocols. <p> Work combining cooperation with mobot manipulation includes [Nor93], [Par94], and <ref> [DJR93, DJR94a, DJR94b, RDJ95, Jen95] </ref>. <p> However, Lynch and Mason ([LM94]) present a simulator and motion planner for single-robot pushing that is based in sound mechanics, and this simulator may yet be extended to multiple-robot manipulation. Also, <ref> [DJR93, DJR94a, DJR94c, DJR94b, Jen95] </ref> present algorithms for two-robot pushing and for multi-robot reorientation. They analyze their protocols with respect to usage of such resources as computation, retained state (e.g., models), sensors, and communication.
Reference: [JR93] <author> J. Jennings and D. </author> <title> Rus. Active model acquisition for near-sensorless manipulation with mobile robots. </title> <booktitle> In IASTED International Conference on Robotics and Manufacturing, </booktitle> <pages> pages 179-184, </pages> <address> Oxford, England, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: We have already derived performance guarantees for sequential and single agent circuits. An example is (align) whose analysis is described in <ref> [JR93] </ref> (see Section 5.2). Arguments that rely on geometry and task mechanics can also be made about our other su-permodular circuits. <p> We can adapt the control loop to servo on instead of t because our robots can use their pushbutton bumpers to measure the relative angle between their heading and the orientation of the face of the box <ref> [JR93] </ref>. Actually, the robots first measure 0 (the initial angle between n and p), and subsequently compare this value to the angle (t) measured at time t in order to infer the direction of motion of the box. <p> Hence, graze terminates in (I) reacquiring the object at a contact with a longer moment arm, or (II) missing altogether. (I) is detected with a guarded move. (II) is detected using a sonar-based wall/corner detection algorithm of <ref> [JR93] </ref>. When (II) occurs, the robot executes (spin). The composition of these three circuits constitutes the circuit for a reorienting robot. Asynch-online consists of two reorienting robot circuits. <p> Then, keeping that heading fixed, (prim-push) is invoked. have run hundreds of experiments in which the robots reliably execute (align) asynchronously and in parallel. We believe that reliability and ease of reuse of our virtual orientation sensor come from its performance guarantees. In <ref> [JR93] </ref> we prove that (align) is robust and reliable in that for the geometry of our robots, the sensed angle is always accurate to within three degrees. Our experiments provide empirical evidence that these guarantees transfer when (align) is immersed in different fashions.
Reference: [LM94] <author> Kevin M. Lynch and Matthew T. Mason. </author> <title> Stable pushing: Mechanics, controllability, and planning. </title> <booktitle> In Proceedings of the 1994 Workshop on the Algorithmic Foundations of Robotics, </booktitle> <address> San Francisco, CA, </address> <year> 1994. </year>
Reference-contexts: Similarly, [Bro85] and others have analyzed the geometry and mechanics of quasi-static pushing and squeeze-grasping of planar objects with common "parallel jaw" grippers. Some work has been done on large-scale manipulation using a single mobile robot, such as <ref> [LM94] </ref> and [OY92]. <p> In his monograph on information invariants [Don95], Donald claims that the spatial distribution of resources has a critical effect on the capabilities of a system. The Pusher/Steerer system validates that claim. Consider a single-robot manipulation algorithm such as, <ref> [LM94] </ref>. As implemented on the Cornell mobile robots, the execution system consists of the following resources, each of which can be represented as a circuit: 9 (a) (b) (c) (d) guided through a 90 degree arc by a steering robot (in front, following the arc), and a pushing robot.
Reference: [LPMT84] <author> T. Lozano-Perez, M. T. Mason, and R. H. Taylor. </author> <title> Automatic synthesis of fine-motion strategies for robots. </title> <journal> International Journal of Robotics Research, </journal> <volume> 3(1), </volume> <year> 1984. </year>
Reference-contexts: The processor which detects this situation and shuts down the motors executes a simple feedback loop at a high frequency, and does not garbage collect. Termination predicates have been introduced in the pre-image motion planning framework of <ref> [LPMT84] </ref>. An extensive discussion of the relative power of these termination predicates in the context of motion planning may be found in [Erd84]. In the [LPMT84] framework, actions are pairs of the form (v; tp), where v is a velocity vector, and tp is a termination predicate. <p> Termination predicates have been introduced in the pre-image motion planning framework of <ref> [LPMT84] </ref>. An extensive discussion of the relative power of these termination predicates in the context of motion planning may be found in [Erd84]. In the [LPMT84] framework, actions are pairs of the form (v; tp), where v is a velocity vector, and tp is a termination predicate. The motion continues in the direction v until the termination predicate returns true.
Reference: [Mas95] <author> M. Mason. </author> <title> Manipulator grasping and pushing operations. </title> <journal> International Journal of Robotics Research, </journal> <volume> 5(3) </volume> <pages> 53-71, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction In robotics most manipulation algorithms are designed to execute in a single process on a single computer that takes input from all the sensors and controls all the effectors. To develop distributed manipulation strategies, we began with a sequential but mechanically-based robot algorithm for pushing and grasping (e.g., <ref> [Mas95] </ref>). While quite general in principle, these off-line algorithms are usually designed for robotics devices such as grippers or fingers attached to a traditional robot arm. <p> We have described and analyzed in detail the reorientation task in [RDJ95]. Figure 6 depicts one robot reorienting a large object. A robot can generate a rotation by applying a force that is displaced from the center of friction. This property relates the dynamics and the geometry of reorientations <ref> [Mas95] </ref> and it can be used to effect continuous reorientations with mobile robots. The idea is to compliantly apply a sliding force on the face of the object. 4 We call this action a push-track step.
Reference: [Mat93] <editor> Maja J. Mataric. </editor> <title> Kin recognition, similarity, and group behavior. </title> <booktitle> In Proc. of the Fifteenth Annual Cognitive Science Society Conference, </booktitle> <address> Boulder, Colorado, </address> <year> 1993. </year>
Reference-contexts: a mobile robot with a fixed flat blade pushing a box) and demonstrate a manipulation planner which maintains this contact con figuration. 3 4.2 Cooperating Mobile Robots Other recent work investigates tasks in which multiple mobile robots cooperate, such as: [SB93] (manipulation of pallets by many small robots in simulation); <ref> [Mat93] </ref> (study of group behaviors such as dispersion and flocking); [ABN93] (simulation of foraging agents with and without communication). Work combining cooperation with mobot manipulation includes [Nor93], [Par94], and [DJR93, DJR94a, DJR94b, RDJ95, Jen95].
Reference: [MS85] <author> Matthew T. Mason and J. Kenneth Salisbury. </author> <title> Robot Hands and the Mechanics of Manipulation. </title> <publisher> MIT Press, </publisher> <address> London, England, </address> <year> 1985. </year>
Reference-contexts: For an excellent review see [CFKM95]. Previous work on cooperative manipulation has focused mostly on pushing, usually in the context of box-pushing by multiple mobile robots, e.g., [Par94], [Nor93]. 4.1 Robotic Manipulation <ref> [MS85] </ref> presents extensive analysis of grasping and pushing operations under a quasi-static model. Mason's analyses of the mechanics of pushing and grasping have led to many practical manipulation strategies implemented most often on anthropomorphic robot arms with simple two-finger grippers. <p> With a two-fingered push (see Figure 1a), the box will translate in a straight line so long as the COF (the center of friction) lies between the fingers. (The actual condition for stable straight-line pushing is slightly more complicated. See <ref> [MS85] </ref> for a complete analysis.) An advantage of the two-finger pushing strategy is that the COF can drift around some and yet the robot can keep pushing, since we only need ensure the COF lies in some region between the lines of pushing of the fingers (see Figure 1a), instead of
Reference: [Nor93] <author> Fabrice R. Noreils. </author> <title> Toward a robot architecture integrating cooperation between mobile robots: Application to indoor environment. </title> <journal> International Journal of Robotics Research, </journal> <volume> 12 </volume> <pages> 79-98, </pages> <year> 1993. </year>
Reference-contexts: For an excellent review see [CFKM95]. Previous work on cooperative manipulation has focused mostly on pushing, usually in the context of box-pushing by multiple mobile robots, e.g., [Par94], <ref> [Nor93] </ref>. 4.1 Robotic Manipulation [MS85] presents extensive analysis of grasping and pushing operations under a quasi-static model. Mason's analyses of the mechanics of pushing and grasping have led to many practical manipulation strategies implemented most often on anthropomorphic robot arms with simple two-finger grippers. <p> Work combining cooperation with mobot manipulation includes <ref> [Nor93] </ref>, [Par94], and [DJR93, DJR94a, DJR94b, RDJ95, Jen95]. Each demonstrates the manipulation of a box or other large object using two mobile robots. [Nor93] describes a task in which one robot pushes a box and another robot clears obstacles out of the way. [Par94] builds an architecture designed to achieve fault-tolerant <p> Work combining cooperation with mobot manipulation includes <ref> [Nor93] </ref>, [Par94], and [DJR93, DJR94a, DJR94b, RDJ95, Jen95]. Each demonstrates the manipulation of a box or other large object using two mobile robots. [Nor93] describes a task in which one robot pushes a box and another robot clears obstacles out of the way. [Par94] builds an architecture designed to achieve fault-tolerant cooperation within teams of heterogeneous mobile robots and applies that architecture to a number of tasks (mostly in simulation), including "hazardous waste cleanup,"
Reference: [OY92] <author> Yoshikuni Okawa and Ken Yokoyama. </author> <title> Control of a mobile robot for the push-a-box operation. </title> <booktitle> In Proceedings of the 1992 IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 761-766, </pages> <address> Nice, France, </address> <year> 1992. </year>
Reference-contexts: Similarly, [Bro85] and others have analyzed the geometry and mechanics of quasi-static pushing and squeeze-grasping of planar objects with common "parallel jaw" grippers. Some work has been done on large-scale manipulation using a single mobile robot, such as [LM94] and <ref> [OY92] </ref>.
Reference: [Par94] <author> Lynne E. Parker. </author> <title> Heterogeneous Multi-Robot Cooperation. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1994. </year>
Reference-contexts: For an excellent review see [CFKM95]. Previous work on cooperative manipulation has focused mostly on pushing, usually in the context of box-pushing by multiple mobile robots, e.g., <ref> [Par94] </ref>, [Nor93]. 4.1 Robotic Manipulation [MS85] presents extensive analysis of grasping and pushing operations under a quasi-static model. Mason's analyses of the mechanics of pushing and grasping have led to many practical manipulation strategies implemented most often on anthropomorphic robot arms with simple two-finger grippers. <p> Work combining cooperation with mobot manipulation includes [Nor93], <ref> [Par94] </ref>, and [DJR93, DJR94a, DJR94b, RDJ95, Jen95]. Each demonstrates the manipulation of a box or other large object using two mobile robots. [Nor93] describes a task in which one robot pushes a box and another robot clears obstacles out of the way. [Par94] builds an architecture designed to achieve fault-tolerant cooperation <p> Work combining cooperation with mobot manipulation includes [Nor93], <ref> [Par94] </ref>, and [DJR93, DJR94a, DJR94b, RDJ95, Jen95]. Each demonstrates the manipulation of a box or other large object using two mobile robots. [Nor93] describes a task in which one robot pushes a box and another robot clears obstacles out of the way. [Par94] builds an architecture designed to achieve fault-tolerant cooperation within teams of heterogeneous mobile robots and applies that architecture to a number of tasks (mostly in simulation), including "hazardous waste cleanup," in which several mobots cooperate to pick up a number of small objects and move them near a designated site. <p> One task from <ref> [Par94] </ref> implemented on real (physical) robots is a two-robot, box-pushing task. Each robot pushes its own end of the box by some fixed amount, then waits for the other robot to push its end.
Reference: [RC81] <author> M. Raibert and J. Craig. </author> <title> Hybrid position/force control of manipulators. Journal of Dynamic Systems, Measurement, </title> <journal> and Control, </journal> <volume> 102, </volume> <year> 1981. </year>
Reference-contexts: Assuming that the robots begin in contact with the object, the following algorithm is exe 4 This strategy can be implemented by a force that forms an acute angle on the contacting edge, outside the friction cone. This is similar to hybrid control <ref> [RC81] </ref> which would be used for a dexterous hand [Rus92]. (a) (b) pushing-tracking. (b) A system of two robots reori-enting a couch. The robot motions are shown in an object-centered frame. Each robot executes a pushing-tracking motion.
Reference: [RD92] <author> J. A. Rees and B. R. Donald. </author> <title> Program mobile robots in scheme. </title> <booktitle> In Proc. of the 1992 IEEE International Conference on Robotics and Automation, </booktitle> <address> Nice, France, </address> <year> 1992. </year>
Reference-contexts: Pushing is implemented by a circuit called (prim-push) (described in <ref> [RD92] </ref>). 5.1.1 Supermodularity in Pushing (prim-push) gives us a simple version of pushing: it applies a force at a fixed direction with respect to the surface of the object. (prim-push) is a subcircuit that implements Protocol 2M for cooperative straight-line pushing. In other words, (prim-push) 2M. <p> In this section we discuss our development infrastructure. We begin with two architectural decisions that we first reported in our paper "Program mobile robots in Scheme" <ref> [RD92] </ref>. For details see [RD92]. These decisions concern: 1. Why extend a general-purpose programming language instead of using or inventing a special-purpose robot language such as ALPHA [Gat91], or the behavior language [Bro90] ? 2. Of the general-purpose languages, why Scheme? We regard robots as computers that can exert forces. <p> In this section we discuss our development infrastructure. We begin with two architectural decisions that we first reported in our paper "Program mobile robots in Scheme" <ref> [RD92] </ref>. For details see [RD92]. These decisions concern: 1. Why extend a general-purpose programming language instead of using or inventing a special-purpose robot language such as ALPHA [Gat91], or the behavior language [Bro90] ? 2. Of the general-purpose languages, why Scheme? We regard robots as computers that can exert forces. <p> The programs that implement the strategies for Pushing, Reorientation, and Pusher/Steerer are written in Mobot Scheme, a customized Scheme48 designed by Jonathan Rees for the Cornell Mobile Robots <ref> [RD92] </ref>. Mobot Scheme code for Protocol 2M (Section 5.1) is shown in Figure 12. The most interesting feature from a development standpoint is the distributed nature of the programming environment. <p> In most cases, memory size is fixed, and is often small by workstation standards. As we pointed out in <ref> [RD92] </ref>, with a constant amount of memory needing garbage collection, we can easily calculate an upper bound on how long this process could possibly take. <p> Intermediate layers of the motion control system build more complicated predicates out of these, and pass along the resulting functions to the next lower layer. As described in <ref> [RD92] </ref>, we use higher order function to implement termination predicates. 7 Moreover, robots like the Cornell Mobile Robots, which contain a loosely connected network of 9 or more (on average) processors, have a distinct advantage in that time-critical processes may be o*oaded to a processor which does not garbage collect.
Reference: [RDJ95] <author> D. Rus, B. Donald, and J. Jennings. </author> <title> Moving furniture with mobile robots. </title> <booktitle> In Proceedings of Intelligent Robot Systems, </booktitle> <address> Pittsburgh, PA, </address> <month> August </month> <year> 1995. </year>
Reference-contexts: and hence the algorithms must be adapted to rely less extensively on geometrical and dynamical models. (3) A host of difficulties arises when a task must be performed by a distributed team instead of a single agent|and hence the algorithms must compensate by changing their communication, sensing, or knowledge requirements <ref> [Don95, DJR93, DJR94a, RDJ95] </ref>. We have reported on several sets of manipulation strategies (which we call protocols), and also on the methodology which generated them [Don95, BBD + 95, RDJ95, Jen95]. Our most interesting protocols are asynchronous and do not require communication between the agents. <p> We have reported on several sets of manipulation strategies (which we call protocols), and also on the methodology which generated them <ref> [Don95, BBD + 95, RDJ95, Jen95] </ref>. Our most interesting protocols are asynchronous and do not require communication between the agents. In this paper we address the architecture and the programming environment we used to develop our protocols. <p> Work combining cooperation with mobot manipulation includes [Nor93], [Par94], and <ref> [DJR93, DJR94a, DJR94b, RDJ95, Jen95] </ref>. <p> Consider the task whose goal is to change the orientation of a large object by a given amount. This is called the reorientation task. We have described and analyzed in detail the reorientation task in <ref> [RDJ95] </ref>. Figure 6 depicts one robot reorienting a large object. A robot can generate a rotation by applying a force that is displaced from the center of friction. <p> Let us consider now the circuit Async-online. Async-online consists of (push-track), (spin), and (graze), replicated on two spatially separated robots. Async-online is more supermodular than (push-track): it is guaranteed to reorient the object no matter what the starting configuration of the two robots is <ref> [RDJ95] </ref>. Async-online is thus more supermodular than (push-track) since there are no constraints on where this circuit can be relocated, so long as it is on the body of the object. We can quantify the supermodularity of a circuit by 8 circuit. <p> a result of this technique. 7 Architecture When the minimalist philosophy is applied to robot manipulation algorithms it yields protocols with surprisingly low resource consumption|that is, the resulting protocols often dispense with a resource (such as sensing, communication, or geometric models) that a naive analysis would have predicted was essential <ref> [DJR93, DJR94a, RDJ95, DJR94b] </ref>. When applied to the programming environment and architectural support for robot manipulation, minimalism results in a development and execution system that is spare and lean|in other words, something more like Scheme and less like C++ (Section 6).
Reference: [Rus92] <author> D. </author> <title> Rus. Fine motion planning for dexterous manipulation. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <address> Ithaca, NY, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: This is similar to hybrid control [RC81] which would be used for a dexterous hand <ref> [Rus92] </ref>. (a) (b) pushing-tracking. (b) A system of two robots reori-enting a couch. The robot motions are shown in an object-centered frame. Each robot executes a pushing-tracking motion.
Reference: [SB93] <author> Daniel J. Stilwell and John S. </author> <title> Bay. Toward the development of a material transport system using swarms of antlike robots. </title> <booktitle> In Proceedings of the 1993 IEEE International Conference on Robotics and Automation, </booktitle> <pages> pages 766-771, </pages> <address> At-lanta, GA, </address> <year> 1993. </year> <month> 20 </month>
Reference-contexts: analyze the mechanics of planar pushing with line contact (e.g., a mobile robot with a fixed flat blade pushing a box) and demonstrate a manipulation planner which maintains this contact con figuration. 3 4.2 Cooperating Mobile Robots Other recent work investigates tasks in which multiple mobile robots cooperate, such as: <ref> [SB93] </ref> (manipulation of pallets by many small robots in simulation); [Mat93] (study of group behaviors such as dispersion and flocking); [ABN93] (simulation of foraging agents with and without communication). Work combining cooperation with mobot manipulation includes [Nor93], [Par94], and [DJR93, DJR94a, DJR94b, RDJ95, Jen95].
References-found: 31

