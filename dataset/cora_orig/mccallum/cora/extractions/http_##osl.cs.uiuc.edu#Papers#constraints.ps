URL: http://osl.cs.uiuc.edu/Papers/constraints.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/Language.html
Root-URL: http://www.cs.uiuc.edu
Email: Email: frolund@cs.uiuc.edu  
Title: Inheritance of Synchronization Constraints in Concurrent Object-Oriented Programming Languages  
Author: Svend Frtlund 
Address: 1304 W. Springfield Avenue  Urbana, IL 61801, USA  
Affiliation: Department of Computer Science  University of Illinois at Urbana-Champaign  
Abstract: We analyse how inheritance of synchronization constraints should be supported. The conclusion of our analysis is that inheritance of synchronization constraints should take the form of incrementally more restrictive constraints for derived subclasses. Our conclusion is based on the view that combinations of behavior in object-oriented languages yield subclasses that extend superclass behavior. We give a notation for describing synchronization constraints. In our notation, synchronization constraints can be inherited and aggregated. We present a number of examples that illustrate the fundamental concepts captured by our notation. Synchronization constraints are described as restrictions that apply to invocation of methods. Application of restrictions is pattern-based, which allows the same restriction to apply to multiple methods and multiple restrictions to apply to the same method.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> P. America and F. van der Linden. </author> <title> A Parallel Object-Oriented Language with Inheritance and Subtyping. </title> <booktitle> In OOPSLA '90 Proceedings, </booktitle> <year> 1990. </year>
Reference-contexts: We assume precautions are taken by the controller to control the number of concurrent threads running within an object. Thread control as part of the controller means that all objects employ the same kind of thread control and is the strategy used in Beta, PROCOL [22] and POOL-I <ref> [1] </ref>. In some languages, thread control is user-defined and often described within the constructs that define synchronization constraints for classes of objects. User-defined thread control is possible in Guide [4], Mediators [6] and Synchronizing Actions [13]. We have ignored thread control for reasons of simplicity. <p> The work at OSL is supported by grants from the Office of Naval Research (ONR contract number N00014-90-J-1899), Digital Equipment Corporation, and by joint support from the Defense Advanced Research Projects Agency and the National Science Foundation <ref> (NSF CCR 90-07195) </ref>. The author is grateful to Gul Agha, Chris Houck, Ole Agesen, Christian Callsen, Rune Dahl, Nayeem Islam and Daniel Sturman for inspiring discussions about synchronization constraints and careful reading of this paper.
Reference: 2. <author> G. Bracha and W. Cook. </author> <title> Mixin-based Inheritance. </title> <booktitle> In OOPSLA '90 Proceedings, </booktitle> <year> 1990. </year>
Reference-contexts: The super pseudo variable of Smalltalk gives a more flexible way of combining behaviors, but the semantics of super still supports extension of ancestor methods. For a more in-depth discussion of different ways of combining method behaviors, refer to <ref> [2] </ref>. Execution of a method that extends the behavior of an ancestor method might result in data inconsistency in situations where the ancestor would leave the object in a consistent state. Extension of behavior means that additional actions are executed and each additional action may potentially result in data inconsistency.
Reference: 3. <author> N. Carriero, D. Gelernter, and J. Leichter. </author> <title> Distributed Data Structures in Linda. </title> <booktitle> In POPL '86 Proceedings, </booktitle> <year> 1986. </year>
Reference-contexts: The above way of describing patterns is deliberately made simple to focus on the synchronization aspects. More advanced pattern matching facilities may be desirable in a "real" language, such as the type-based pattern matching found in Linda <ref> [3] </ref>. Another extension would be to make patterns first class values so that patterns may be named and composed. The expression associated with a restriction is called the condition of the restriction.
Reference: 4. <author> D. Decouchant, P. Le Dot, M. Rivelli, C. Roisin, and X. Rousset de Pina. </author> <title> A Synchronization Mechanism for an Object Oriented Distributed System. </title> <booktitle> In Eleventh International Conference on Distributed Computing Systems. IEEE, </booktitle> <year> 1991. </year>
Reference-contexts: Therefore, the synchronization constraints associated with that name may need to change in subclasses. Integration of inheritance and synchronization constraints has been investigated in a number of recent papers [13] <ref> [4] </ref> [16] [12]. However, all of these proposals are insufficient since they do not support incremental modification of synchronization constraints. In all of the proposals, synchronization constraints are specified as activation conditions: a boolean expression associated with each method. <p> In some languages, thread control is user-defined and often described within the constructs that define synchronization constraints for classes of objects. User-defined thread control is possible in Guide <ref> [4] </ref>, Mediators [6] and Synchronizing Actions [13]. We have ignored thread control for reasons of simplicity. However, in the conclusion we argue that user-defined thread control can in fact be smoothly incorporated into our framework. Objects are instantiated from classes. Classes may be hierarchically organized according to an inheritance relation. <p> To keep the framework as simple and general as possible, the issue of serializing method invocations was deliberately ignored. It should be noted, however, that restrictions in concurrent invocations can easily be expressed within the framework. For example, conditions in restrictions could refer to synchronization counters <ref> [4] </ref>. Acknowledgements The author is sponsored by a research fellowship from the Natural Science Faculty of -Arhus University in Denmark and generous support from the Danish Research Academy. The research described in this paper was carried out at the University of Illinois Open Systems Laboratory (OSL).
Reference: 5. <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: A derived method is one whose declaration results in a vertical name collision [8] and is a common phenomena in object-oriented programs. Virtual methods in Beta [9], virtual functions in C++ [18] and methods in Smalltalk <ref> [5] </ref> are all examples of derivable methods. A derived method has an ancestor method: the method in a superclass whose name is shadowed in a subclass.
Reference: 6. <author> J. E. Grass and R. H. Campbell. Mediators: </author> <title> A Synchronization Mechanism. </title> <booktitle> In Sixth International Conference on Distributed Computing Systems. IEEE, </booktitle> <year> 1986. </year>
Reference-contexts: In some languages, thread control is user-defined and often described within the constructs that define synchronization constraints for classes of objects. User-defined thread control is possible in Guide [4], Mediators <ref> [6] </ref> and Synchronizing Actions [13]. We have ignored thread control for reasons of simplicity. However, in the conclusion we argue that user-defined thread control can in fact be smoothly incorporated into our framework. Objects are instantiated from classes. Classes may be hierarchically organized according to an inheritance relation.
Reference: 7. <author> C. Houck. </author> <title> Run-Time Support for Distributed Actor Programs. </title> <type> Master's thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year> <month> Forthcoming. </month>
Reference-contexts: Aggregation of synchronization constraints by explicit inquiry about the legality of given invocations. We believe these two principles constitute an appropriate basis for specification of synchronization constraints in concurrent object-oriented languages. Part of the framework has been implemented in an experimental Actor language <ref> [7] </ref>. The view that synchronization constraints get increasingly more restrictive in subclasses has proven useful in practice. It may seem that our notion of increasingly restrictive synchronization constraints may violate substitutability properties of subclasses.
Reference: 8. <author> J. L. Knudsen. </author> <title> Name Collision in Multiple Classification Hierarchies. </title> <booktitle> In ECOOP'88 European Conference on Object-Oriented Programming. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Derivation of methods is one reason why synchronization constraints may need to be incrementally modified in subclasses. A derived method is one whose declaration results in a vertical name collision <ref> [8] </ref> and is a common phenomena in object-oriented programs. Virtual methods in Beta [9], virtual functions in C++ [18] and methods in Smalltalk [5] are all examples of derivable methods. A derived method has an ancestor method: the method in a superclass whose name is shadowed in a subclass.
Reference: 9. <author> B. B. Kristensen, O. L. Madsen, B. Mtller-Pedersen, and K. Nygaard. </author> <title> The BETA Programming Language. </title> <editor> In B. D. Schriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Derivation of methods is one reason why synchronization constraints may need to be incrementally modified in subclasses. A derived method is one whose declaration results in a vertical name collision [8] and is a common phenomena in object-oriented programs. Virtual methods in Beta <ref> [9] </ref>, virtual functions in C++ [18] and methods in Smalltalk [5] are all examples of derivable methods. A derived method has an ancestor method: the method in a superclass whose name is shadowed in a subclass. <p> In Rosette [20], synchronization constraints are described as enabled sets: data structures that denote the currently enabled methods. Subclasses can incrementally add methods to enabled sets defined in superclasses. As opposed to our framework, synchronization constraints in Rosette get less restrictive in subclasses. Beta <ref> [9] </ref> and the language proposed by Thomsen [19] contain explicit input actions similar to the accept statements of Ada [21]. Subclasses can incrementally add more input actions, which again means that synchronization constraints get less restrictive in subclasses.
Reference: 10. <author> B. B. Kristensen, O. L. Madsen, B. Mtller-Pedersen, and K. Nygaard. </author> <title> Classification of Actions or Inheritance Also for Methods. </title> <booktitle> In ECOOP'87 European Conference on Object-Oriented Programming. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Most object-oriented languages support derivation of methods that extend the behavior of ancestor methods. Extension of behavior is directly supported by the INNER construct used in Beta <ref> [10] </ref>. The super pseudo variable of Smalltalk gives a more flexible way of combining behaviors, but the semantics of super still supports extension of ancestor methods. For a more in-depth discussion of different ways of combining method behaviors, refer to [2].
Reference: 11. <author> S. Matsuoka, K. Wakita, and A. Yonezawa. </author> <title> Analysis of Inheritance Anomaly in Concurrent Object-Oriented Languages. </title> <booktitle> ECOOP/OOPSLA'90 Workshop on Object-Based Concurrent Systems, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: We assume that synchronization constraints are specified as a separate part of class descriptions. In fact, synchronization constraints is the only part of a class that is specified in our notation. Having separate specification of synchronization constraints is generally desirable to avoid the "inheritance anomaly" <ref> [11] </ref> [12]. The anomaly manifests itself as subclasses in which specification of correct synchronization constraints require redefinition of method behavior that would otherwise be reusable. The anomaly may, for example, occur if synchronization constraints are specified as part of method behaviors.
Reference: 12. <author> S. Matsuoka, K. Wakita, and A. Yonezawa. </author> <title> Synchronization Constraints With Inheritance: What is Not Possible | So What is? Technical Report 10, </title> <institution> Department of Information Science, the University of Tokyo, </institution> <year> 1990. </year>
Reference-contexts: Therefore, the synchronization constraints associated with that name may need to change in subclasses. Integration of inheritance and synchronization constraints has been investigated in a number of recent papers [13] [4] [16] <ref> [12] </ref>. However, all of these proposals are insufficient since they do not support incremental modification of synchronization constraints. In all of the proposals, synchronization constraints are specified as activation conditions: a boolean expression associated with each method. <p> We assume that synchronization constraints are specified as a separate part of class descriptions. In fact, synchronization constraints is the only part of a class that is specified in our notation. Having separate specification of synchronization constraints is generally desirable to avoid the "inheritance anomaly" [11] <ref> [12] </ref>. The anomaly manifests itself as subclasses in which specification of correct synchronization constraints require redefinition of method behavior that would otherwise be reusable. The anomaly may, for example, occur if synchronization constraints are specified as part of method behaviors. <p> In that case, superclass synchronization constraints can not be changed in subclasses without also changing the methods of which the synchronization constraints are part. For a more elaborate discussion of the inheritance anomaly and its causes, refer to <ref> [12] </ref>. 3.2 Notation Our notation for describing synchronization constraints is given in Figure 2. Synchronization constraints define restrictions on the acceptance of invocation requests.
Reference: 13. <author> C. Neusius. </author> <title> Synchronizing Actions. </title> <booktitle> In ECOOP'91 European Conference on Object-Oriented Programming. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Therefore, the synchronization constraints associated with that name may need to change in subclasses. Integration of inheritance and synchronization constraints has been investigated in a number of recent papers <ref> [13] </ref> [4] [16] [12]. However, all of these proposals are insufficient since they do not support incremental modification of synchronization constraints. In all of the proposals, synchronization constraints are specified as activation conditions: a boolean expression associated with each method. <p> In some languages, thread control is user-defined and often described within the constructs that define synchronization constraints for classes of objects. User-defined thread control is possible in Guide [4], Mediators [6] and Synchronizing Actions <ref> [13] </ref>. We have ignored thread control for reasons of simplicity. However, in the conclusion we argue that user-defined thread control can in fact be smoothly incorporated into our framework. Objects are instantiated from classes. Classes may be hierarchically organized according to an inheritance relation.
Reference: 14. <author> O. Nierstrasz and M. Papathomas. </author> <title> Towards a Type Theory for Active Objects. </title> <editor> In D. Tsichritzis, editor, </editor> <booktitle> Object Management. </booktitle> <institution> University of Geneva, </institution> <year> 1990. </year>
Reference-contexts: Part of the framework has been implemented in an experimental Actor language [7]. The view that synchronization constraints get increasingly more restrictive in subclasses has proven useful in practice. It may seem that our notion of increasingly restrictive synchronization constraints may violate substitutability properties of subclasses. In [15] and <ref> [14] </ref>, for example, it is argued that subclasses should contain at least the "input offers" of superclasses, implying that synchronization constraints get increasingly less restrictive in subclasses.
Reference: 15. <author> O. Nierstrasz and M. Papathomas. </author> <title> Viewing Objects as Patterns of Communicating Agents. </title> <booktitle> In OOPSLA '90 Proceedings, </booktitle> <year> 1990. </year>
Reference-contexts: Part of the framework has been implemented in an experimental Actor language [7]. The view that synchronization constraints get increasingly more restrictive in subclasses has proven useful in practice. It may seem that our notion of increasingly restrictive synchronization constraints may violate substitutability properties of subclasses. In <ref> [15] </ref> and [14], for example, it is argued that subclasses should contain at least the "input offers" of superclasses, implying that synchronization constraints get increasingly less restrictive in subclasses.
Reference: 16. <author> E. Shibayama. </author> <title> Reuse of Concurrent Object Descriptions. </title> <editor> In A. Yonezawa and T. Ito, editors, </editor> <booktitle> Concurrency: Theory, Language, and Architecture. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1991. </year> <note> LNCS 491. </note>
Reference-contexts: Therefore, the synchronization constraints associated with that name may need to change in subclasses. Integration of inheritance and synchronization constraints has been investigated in a number of recent papers [13] [4] <ref> [16] </ref> [12]. However, all of these proposals are insufficient since they do not support incremental modification of synchronization constraints. In all of the proposals, synchronization constraints are specified as activation conditions: a boolean expression associated with each method.
Reference: 17. <author> A. Silberschatz, J. Peterson, and P. Galvin. </author> <title> Operating Systems Concepts. </title> <publisher> Addison-Wesley, </publisher> <address> third edition, </address> <year> 1991. </year>
Reference-contexts: Any deadlock avoidance algorithm suffice, but, to make the description more concrete, the bankers algorithm <ref> [17] </ref> is used. The methods of different-resources need not be changed in order to derive this subclass. The synchronization constraints, however, need to be made more restrictive.
Reference: 18. <author> B. Stroustrup. </author> <title> An Overview of C++. </title> <journal> Sigplan Notices, </journal> <month> October </month> <year> 1986. </year>
Reference-contexts: Derivation of methods is one reason why synchronization constraints may need to be incrementally modified in subclasses. A derived method is one whose declaration results in a vertical name collision [8] and is a common phenomena in object-oriented programs. Virtual methods in Beta [9], virtual functions in C++ <ref> [18] </ref> and methods in Smalltalk [5] are all examples of derivable methods. A derived method has an ancestor method: the method in a superclass whose name is shadowed in a subclass.
Reference: 19. <author> K. S. Thomsen. </author> <title> Inheritance on Processes, Exemplified on Distributed Termination Detection. </title> <journal> International Journal of Parallel Programming, </journal> <volume> 16(1), </volume> <month> February </month> <year> 1987. </year>
Reference-contexts: Subclasses can incrementally add methods to enabled sets defined in superclasses. As opposed to our framework, synchronization constraints in Rosette get less restrictive in subclasses. Beta [9] and the language proposed by Thomsen <ref> [19] </ref> contain explicit input actions similar to the accept statements of Ada [21]. Subclasses can incrementally add more input actions, which again means that synchronization constraints get less restrictive in subclasses.
Reference: 20. <author> C. Tomlinson and V. Singh. </author> <title> Inheritance and Synchronization with Enabled-Sets. </title> <booktitle> In OOPSLA '89 Proceedings, </booktitle> <year> 1989. </year>
Reference-contexts: Interference between clients in the form of interleaving of service requests may undermine such type-guarantees. Few object-oriented concurrent languages support incremental modification of synchronization constraints. In Rosette <ref> [20] </ref>, synchronization constraints are described as enabled sets: data structures that denote the currently enabled methods. Subclasses can incrementally add methods to enabled sets defined in superclasses. As opposed to our framework, synchronization constraints in Rosette get less restrictive in subclasses.
Reference: 21. <institution> United States Department of Defense. </institution> <note> Reference Manual for the Ada Language, draft, revised mil-std 1815 edition, </note> <month> july </month> <year> 1982. </year>
Reference-contexts: Subclasses can incrementally add methods to enabled sets defined in superclasses. As opposed to our framework, synchronization constraints in Rosette get less restrictive in subclasses. Beta [9] and the language proposed by Thomsen [19] contain explicit input actions similar to the accept statements of Ada <ref> [21] </ref>. Subclasses can incrementally add more input actions, which again means that synchronization constraints get less restrictive in subclasses. The author does not know of any other framework that supports the view that synchronization constraints get increasingly more restrictive in subclasses.
Reference: 22. <author> J. van den Bos and C. Laffra. </author> <title> PROCOL, a Concurrent Object-Oriented Language with Protocols Delegation and Constraints. </title> <journal> Acta Informatica, </journal> <volume> 28:511 - 538, </volume> <year> 1991. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Thread control. We assume precautions are taken by the controller to control the number of concurrent threads running within an object. Thread control as part of the controller means that all objects employ the same kind of thread control and is the strategy used in Beta, PROCOL <ref> [22] </ref> and POOL-I [1]. In some languages, thread control is user-defined and often described within the constructs that define synchronization constraints for classes of objects. User-defined thread control is possible in Guide [4], Mediators [6] and Synchronizing Actions [13]. We have ignored thread control for reasons of simplicity.
References-found: 22

