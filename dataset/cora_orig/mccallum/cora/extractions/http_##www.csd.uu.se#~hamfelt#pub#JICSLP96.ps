URL: http://www.csd.uu.se/~hamfelt/pub/JICSLP96.ps
Refering-URL: http://www.csd.uu.se/~hamfelt/
Root-URL: 
Email: Andreas.Hamfelt@csd.uu.se  jfn@it.dtu.dk  
Title: Declarative Logic Programming with Primitive Recursive Relations on Lists  
Author: Andreas Hamfelt Jtrgen Fischer Nilsson 
Keyword: Recursion operators, Declarative logic programming, Duality theorem, Metalogic programming, Program flow analysis.  
Address: Box 311, S-751 05 Uppsala, Sweden  DK-2800 Lyngby, Denmark  
Affiliation: Computing Science Department Uppsala University  Department of Information Technology Technical University of Denmark  
Abstract: In a previous paper we introduced a system of recursion operators for formulating pure logic programs, dispensing with explicit recursions. The recursion operators, some of which are similar to higher-order functions known from functional programming, take the form of quasi-higher order predicates. In this paper we identify a comprehensive class of logic programs called primitive recursive relations over lists (including primitive recursive functions) using the so called fold recursion operators. We formulate and prove a duality theorem connecting our relational fold operators. We show how correct well-moded procedural interpretations using any fixed computation rule can be obtained from a declarative logic program. This is accomplished in a principled manner by a simplified data flow analysis enabled by the recursion operator formulation and the duality theorem. The recursion operators are handled in ordinary clauses by means of established metalogic programming techniques. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt & S. Etalle. </author> <title> On the Unification Free Prolog Programs. </title> <booktitle> Proc. Conference on Mathematical Foundations of Computer Science, Lecture Notes in Computer Science 711, </booktitle> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: n1 ) ^ : : : ^ natrecrev (P; Q)(X 1 : : : X n nil ; W 1 ) P (X 1 : : : X n nil ; W 2 ; W 1 )^ 3 Data Flow Modes In this paper we consider only well-moded programs, cf. <ref> [1] </ref>, called simple programs in [4], in which all variables present in an invoked clause are to be bound to ground terms upon reducing the clause body to the empty clause during SLD-resolution.
Reference: [2] <author> R. Bird & Ph. Wadler. </author> <title> Introduction to Functional Programming, </title> <publisher> Pren-tice Hall, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction Higher order functions, functionals, are well-established in functional programming methodology, cf. e.g. <ref> [2, 10] </ref>. Their relational counterpart, higher order predicates, however, have so far hardly been exploited within logic programming methodology. As a step towards such a methodology we identified in [5, 8] a set of higher order relational recursion operators. <p> Functional programming methodology provides two well-known higher-order functionals for expressing recurring list recursions: foldright ("reduce") and foldleft ("accumulate") <ref> [2, 10] </ref> both taking as arguments a binary function f and a constant y, and defined as follows: foldr f y nil = y foldr f y x.xs = f x (foldr f y xs) and foldl f y nil = y foldl f y x.xs = foldl f (f x <p> W ) ^ P (X; Y; Z): However, when using these operators for program development one should be aware of a duality relationship connecting foldr and foldl, which is the topic of the next section. 6 Duality Theorem for Relational Fold Operators In functional programming the duality theorem, cf. e.g., <ref> [2] </ref> p. 68, for the functionals foldr and foldl states that foldr (f 1 ; a; xs) = foldl (f 2 ; a; xs), where the argument functions f 1 and f 2 are identical except for having inverse arguments, i.e., f 1 (x; y) = f 2 (y; x).
Reference: [3] <author> J. Boye & J. Maluszynski. </author> <title> Two Aspects of Directional Types. </title> <booktitle> Proc. Twelfth International Conference on Logic Programming, </booktitle> <editor> L. Sterling (ed.), </editor> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: We plan in a forthcoming paper to generalise the above development method to the other recursion operators proposed in [8], comprising a more expressive operator with double recursion (problem-reduction or divide-and-conquer operators, cf. also [6]). We also aim at relaxing the well-modedness requirement (cf. e.g., <ref> [3] </ref>) in order to admit e.g., difference lists.
Reference: [4] <author> W. Drabent. </author> <title> Do Logic Programs Resemble Programs in Conventional Languages? Proc. </title> <booktitle> 1987 Symposium on Logic Programming, </booktitle> <address> San Fran-cisco, </address> <publisher> IEEE Computer Society Press, </publisher> <year> 1987. </year> <pages> pp. 389-396. </pages>
Reference-contexts: : ^ natrecrev (P; Q)(X 1 : : : X n nil ; W 1 ) P (X 1 : : : X n nil ; W 2 ; W 1 )^ 3 Data Flow Modes In this paper we consider only well-moded programs, cf. [1], called simple programs in <ref> [4] </ref>, in which all variables present in an invoked clause are to be bound to ground terms upon reducing the clause body to the empty clause during SLD-resolution.
Reference: [5] <author> J. Fischer Nilsson & A. Hamfelt. </author> <title> Constructing Logic Programs with Higher Order Predicates. </title> <booktitle> Proc. GULP-PRODE'95, the Joint Conference on Declarative Programming 1995, </booktitle> <editor> M. Alpuente and M. I. Sessa, (eds.), Universita Degli Studi di Salerno, </editor> <booktitle> Salerno, </booktitle> <pages> pp. 307-312, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction Higher order functions, functionals, are well-established in functional programming methodology, cf. e.g. [2, 10]. Their relational counterpart, higher order predicates, however, have so far hardly been exploited within logic programming methodology. As a step towards such a methodology we identified in <ref> [5, 8] </ref> a set of higher order relational recursion operators. This set is intended to cover all forms of recursive predicate formulations met in logic programming practice. <p> f and a constant y, and defined as follows: foldr f y nil = y foldr f y x.xs = f x (foldr f y xs) and foldl f y nil = y foldl f y x.xs = foldl f (f x y) xs These higher-order functionals led us in <ref> [5, 8] </ref> to introduce the higher order predicates: foldr (P; Q)(Y; nil ; Z) Q (Y; Z): foldr (P; Q)(Y; XXs; W ) foldr (P; Q)(Y; Xs; Z) ^ P (X; Z; W ): and foldl (P; Q)(Y; nil; Z) Q (Y; Z): foldl (P; Q)(Y; XXs; W ) P (X;
Reference: [6] <author> P. Flener. </author> <title> Logic program Synthesis from Incomplete Specification, </title> <publisher> Kluwer, </publisher> <year> 1995. </year>
Reference-contexts: We plan in a forthcoming paper to generalise the above development method to the other recursion operators proposed in [8], comprising a more expressive operator with double recursion (problem-reduction or divide-and-conquer operators, cf. also <ref> [6] </ref>). We also aim at relaxing the well-modedness requirement (cf. e.g., [3]) in order to admit e.g., difference lists.
Reference: [7] <author> T. S. Gegg-Harrison. </author> <title> Representing Logic Program Schemata in Prolog. </title> <booktitle> Proc. Twelfth International Conference on Logic Programming 1995, </booktitle> <editor> (Sterling, L., ed.), </editor> <publisher> MIT Press, London, </publisher> <pages> pp. 467-481, </pages> <year> 1995. </year>
Reference-contexts: In [8] we proved that these operators suffice together with auxiliary non-recursively defined predicates for defining all primitive recursive functions [9]. A system of recursion operators for logic program development similar to ours is proposed simultaneously and independently in <ref> [7] </ref>, however using prolog instead of metalogic program techniques. <p> Thus applying times 1 Although the metalogic programming technique in [12] also shows how to provide -abstractions obviating auxiliary named predicates, cf. also <ref> [7] </ref>, we prefer separate definitions of named predicates for ease of mode specification and program documentation. with mode (+; +; fl) singles out natrec, while "backwards" use with mode (fl; fl; +) would single out natrecrev .
Reference: [8] <author> A. Hamfelt & J. Fischer Nilsson. </author> <title> Towards a Logic Programming Methodology based on Higher-order Predicates, </title> <note> 1995, submitted for publication. </note>
Reference-contexts: 1 Introduction Higher order functions, functionals, are well-established in functional programming methodology, cf. e.g. [2, 10]. Their relational counterpart, higher order predicates, however, have so far hardly been exploited within logic programming methodology. As a step towards such a methodology we identified in <ref> [5, 8] </ref> a set of higher order relational recursion operators. This set is intended to cover all forms of recursive predicate formulations met in logic programming practice. <p> As a step towards such a methodology we identified in [5, 8] a set of higher order relational recursion operators. This set is intended to cover all forms of recursive predicate formulations met in logic programming practice. In <ref> [8] </ref> the set is also proved theoretically adequate in the sense that it enables expressing logic programs for calculating all general recursive functions, and therefore all computable relations. <p> (Q,Y) natrec (P,Q,X.Xs,W) natrec (P,Q,Xs,V),apply (P,X.Xs,V,W). together with defining clauses for the apply predicate of the principal form apply (p i ; X 1 ; :::; X n ) p i (X 1 ; :::; X n ) expressing predication, that is application of a predicate to its arguments, see <ref> [8, 12] </ref> for details. In [8] we proved that these operators suffice together with auxiliary non-recursively defined predicates for defining all primitive recursive functions [9]. <p> In <ref> [8] </ref> we proved that these operators suffice together with auxiliary non-recursively defined predicates for defining all primitive recursive functions [9]. A system of recursion operators for logic program development similar to ours is proposed simultaneously and independently in [7], however using prolog instead of metalogic program techniques. <p> f and a constant y, and defined as follows: foldr f y nil = y foldr f y x.xs = f x (foldr f y xs) and foldl f y nil = y foldl f y x.xs = foldl f (f x y) xs These higher-order functionals led us in <ref> [5, 8] </ref> to introduce the higher order predicates: foldr (P; Q)(Y; nil ; Z) Q (Y; Z): foldr (P; Q)(Y; XXs; W ) foldr (P; Q)(Y; Xs; Z) ^ P (X; Z; W ): and foldl (P; Q)(Y; nil; Z) Q (Y; Z): foldl (P; Q)(Y; XXs; W ) P (X; <p> Primitive recursive functions come about by composition of basic or primitive recursive functions or through the primitive recursion scheme, which is obtainable through natrec. We define primitive recursive list relations similarly to primitive recursive functions as follows (cf. also the logic program definition of recursive functions in <ref> [8] </ref>): Basic recursive list predicates 1. List construction predicate: cons (X; Y; XY ). 2. Empty list (zero) predicate: isnil (nil ). 3. Identity predicate: id (X; X). <p> It is easy to prove the class of primitive recursive functions on numbers a proper subclass of primitive recursive list relations by representing numbers as lists of empty lists, and by representing n-ary functions as n+1-ary predicates, cf. also <ref> [8] </ref>. Moreover, it is a straightforward exercise to establish the example predicates in the above sect. 5 as being primitive recursive by rewriting of the defining clauses to the formally admissible forms. <p> The considered class of programs covers only the list data type (with natural numbers conceived as a special case) together with the fundamental list recursion operators (i.e. fold). We plan in a forthcoming paper to generalise the above development method to the other recursion operators proposed in <ref> [8] </ref>, comprising a more expressive operator with double recursion (problem-reduction or divide-and-conquer operators, cf. also [6]). We also aim at relaxing the well-modedness requirement (cf. e.g., [3]) in order to admit e.g., difference lists.
Reference: [9] <author> S. C. Kleene. </author> <title> Introduction to Metamathematics, </title> <address> Amsterdam, </address> <year> 1952. </year>
Reference-contexts: In [8] we proved that these operators suffice together with auxiliary non-recursively defined predicates for defining all primitive recursive functions <ref> [9] </ref>. A system of recursion operators for logic program development similar to ours is proposed simultaneously and independently in [7], however using prolog instead of metalogic program techniques. <p> considering that the first and third arguments of foldrrev have been swapped, and likewise the second and third arguments of p (cons ) and the two of q (id ). 7 Primitive Recursive List Relations In this section we generalise the classical notion of primitive recursive functions on natural numbers <ref> [9] </ref> to what we dub primitive recursive relations on lists, as specified below. The definition serves to delineate and make precise the class of programs exemplified in previous sections. Recall the basic recursive functions from the theory of recursive functions [9]: (1) natural number successor, (2) constant 0, and (3) projection <p> the classical notion of primitive recursive functions on natural numbers <ref> [9] </ref> to what we dub primitive recursive relations on lists, as specified below. The definition serves to delineate and make precise the class of programs exemplified in previous sections. Recall the basic recursive functions from the theory of recursive functions [9]: (1) natural number successor, (2) constant 0, and (3) projection functions. Primitive recursive functions come about by composition of basic or primitive recursive functions or through the primitive recursion scheme, which is obtainable through natrec.
Reference: [10] <author> C. Reade. </author> <title> Elements of Functional Programming, </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Higher order functions, functionals, are well-established in functional programming methodology, cf. e.g. <ref> [2, 10] </ref>. Their relational counterpart, higher order predicates, however, have so far hardly been exploited within logic programming methodology. As a step towards such a methodology we identified in [5, 8] a set of higher order relational recursion operators. <p> Functional programming methodology provides two well-known higher-order functionals for expressing recurring list recursions: foldright ("reduce") and foldleft ("accumulate") <ref> [2, 10] </ref> both taking as arguments a binary function f and a constant y, and defined as follows: foldr f y nil = y foldr f y x.xs = f x (foldr f y xs) and foldl f y nil = y foldl f y x.xs = foldl f (f x
Reference: [11] <author> A. Voronkov. </author> <title> Logic Programming with Bounded Quantifiers. Logic Programming, </title> <editor> A. Voronkov (ed.), </editor> <booktitle> Lecture Notes in Artificial Intelligence 592, </booktitle> <publisher> Springer, </publisher> <year> 1992. </year>
Reference-contexts: The higher order constructs are handled in conventional logic programming through a simple metalogic programming technique. Our approach to the elimination of explicit recursion represents an alternative to the use of bounded quantifiers, cf. e.g. <ref> [11] </ref>. As an introductory case, in the next section we begin consider programs dealing with the natural number data type considered as a special case of lists.
Reference: [12] <author> D. H. D. Warren. </author> <title> Higher-order extensions to PROLOG: are they needed? Machine Intelligence 10, </title> <editor> D. Michie (ed.), </editor> <publisher> Ellis Horwood and Edinburgh University Press, </publisher> <pages> pp. 441-454, </pages> <year> 1982. </year>
Reference-contexts: These forms can, however, be conceived as syntactically sugared forms of ordinary first order expressions appealing to the technique originating in <ref> [12] </ref> for handling higher order predicates by way of metalogic programming. <p> (Q,Y) natrec (P,Q,X.Xs,W) natrec (P,Q,Xs,V),apply (P,X.Xs,V,W). together with defining clauses for the apply predicate of the principal form apply (p i ; X 1 ; :::; X n ) p i (X 1 ; :::; X n ) expressing predication, that is application of a predicate to its arguments, see <ref> [8, 12] </ref> for details. In [8] we proved that these operators suffice together with auxiliary non-recursively defined predicates for defining all primitive recursive functions [9]. <p> Now appropriate combination rules for modes serve to enforce use of the proper variant form for the mode demanded procedurally among the declaratively equivalent ones for the recursion operator. Thus applying times 1 Although the metalogic programming technique in <ref> [12] </ref> also shows how to provide -abstractions obviating auxiliary named predicates, cf. also [7], we prefer separate definitions of named predicates for ease of mode specification and program documentation. with mode (+; +; fl) singles out natrec, while "backwards" use with mode (fl; fl; +) would single out natrecrev .
References-found: 12

