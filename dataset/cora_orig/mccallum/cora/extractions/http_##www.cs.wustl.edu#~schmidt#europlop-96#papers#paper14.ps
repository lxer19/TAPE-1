URL: http://www.cs.wustl.edu/~schmidt/europlop-96/papers/paper14.ps
Refering-URL: http://www.cs.wustl.edu/~schmidt/europlop-96/ww1-papers.html
Root-URL: 
Email: kjx@socs.uts.edu.au  
Title: Found Objects A Pattern Language for Finding Objects from within Designs  
Author: James Noble 
Date: June 1, 1996  
Address: Sydney.  
Affiliation: School of Computing Sciences, University of Technology,  
Abstract: To design a program, first find your objects. Unfortunately, the right objects are not easy to find, and as a result most programs are not as well designed as they could be. The patterns in this language describe how objects can found within existing programs. By using these patterns, programs and designs can be made more simple, more general, and more easy to change.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ole Agesen, Lars Bak, Craig Chambers, Bay-Wei Chang, Urs Holzle, John Maloney, Randall B. Smith, David Ungar, and Mario Wolczko. </author> <title> The Self Programmer's Reference Manual. </title> <institution> Sun Microsystems and Stanford University, </institution> <address> 4.0 edition, </address> <year> 1995. </year>
Reference-contexts: The system's users could check the supporting logic to verify that the decisions were being made appropriately. The Self Programmer's Reference Manual describes how Result Objects can be used in Self to return multiple values from messages <ref> [1] </ref>. Result Objects are often used to provide error handling. Representing errors with Result Objects allows the errors to be queued as they occur, and displayed later to the user. These Result Objects can also provide textual descriptions of the errors, and appropriate help information.
Reference: [2] <author> Kent Beck. </author> <note> Result object. http://c2.com/cgi/wiki?ResultObject. 16 </note>
Reference-contexts: Acknowledgements The patterns in this language were inspired by discussions on the patterns-discussion mailing list, and the WikiWikiWeb. In particular, Kent Beck posted a message describing a Parameters Object pattern [3] and also suggested the Result Object pattern <ref> [2] </ref>. Patrick Logan first noticed the similarity between these two patterns. Mike Koss described the use of Result Objects to handle errors. Ward Cun-ningham, this paper's EPLOP "shepherd", provided many pertinent comments and much interesting feedback.
Reference: [3] <author> Kent Beck. </author> <title> Parameters object. Email message sent to the patterns-digest list, </title> <month> March </month> <year> 1995. </year>
Reference-contexts: Comments Smalltalk's Point and Rectangle objects can be seen as Arguments Objects which package up two or four integer arguments to describe points or rectangles <ref> [3] </ref>. Many uses of Protocol Object (6) described above include uses of Arguments Object. You may be able to combine the Arguments Object with the server object | try Curried Object (9). <p> A Virtual Proxy [6] is a Lazy Object which stands in for another object which is created on demand. Acknowledgements The patterns in this language were inspired by discussions on the patterns-discussion mailing list, and the WikiWikiWeb. In particular, Kent Beck posted a message describing a Parameters Object pattern <ref> [3] </ref> and also suggested the Result Object pattern [2]. Patrick Logan first noticed the similarity between these two patterns. Mike Koss described the use of Result Objects to handle errors. Ward Cun-ningham, this paper's EPLOP "shepherd", provided many pertinent comments and much interesting feedback.
Reference: [4] <author> Grady Booch. </author> <title> Object Oriented Analysis and Design with Applications. </title> <note> Ben-jamin Cummings, second edition, </note> <year> 1994. </year>
Reference-contexts: For this reason, many object oriented analysis and design methods begin by identifying a set of candidate objects from the domain, and then refine the set of candidate objects <ref> [17, 4] </ref>. Unfortunately, it is not always clear what objects or abstractions there are in the domain, or how to determine whether a particular program object models a domain object. <p> Iterators are the most common kind of Curried Object, as they are used in many common languages and class libraries <ref> [6, 7, 4] </ref>. An iterator's server is a collection object, and the iterator maintains a slowly varying index into the collection. The Eiffel library does not use curried iterators | iterators are part of the collection objects, with the disadvantages described above [10].
Reference: [5] <author> Ward Cunningham. </author> <title> The CHECKS pattern language of information integrity. In Pattern Languages of Program Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Modelling Independent Abstractions increases cohesion within objects, as all the details of an object should be derived from a single abstraction in the application domain. An object should represent the Whole Value <ref> [5] </ref> of the Independent Abstraction it represents. It should be the Single Place (3) where that abstraction is modelled in the program, and be available to the rest of the program via a Rich Protocol (5). 3 Single Place Some abstractions may be needed in a variety of places.
Reference: [6] <author> Erich Gamma, Richard Helm, Ralph E. Johnson, and John Vlissides. </author> <title> Design Patterns. </title> <publisher> Addison-Wesley, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: Comments This pattern increases interobject communication, and generally interobject coupling. However, this coupling is necessary, because it models a dependence in the application domain. For this reason, the Remote Place pattern is very commonly used together with Single Place (3). A Facade <ref> [6] </ref> is a Remote Place which gives access to a subsystem of objects. A Factory Method [6] is a Remote Place which creates new objects. 5 Rich Protocol Objects may be used in a variety of contexts. Objects in the real world can be used in a variety of contexts. <p> However, this coupling is necessary, because it models a dependence in the application domain. For this reason, the Remote Place pattern is very commonly used together with Single Place (3). A Facade <ref> [6] </ref> is a Remote Place which gives access to a subsystem of objects. A Factory Method [6] is a Remote Place which creates new objects. 5 Rich Protocol Objects may be used in a variety of contexts. Objects in the real world can be used in a variety of contexts. Similarly, objects in a program act as servers for a variety of client objects. <p> Iterators are the most common kind of Curried Object, as they are used in many common languages and class libraries <ref> [6, 7, 4] </ref>. An iterator's server is a collection object, and the iterator maintains a slowly varying index into the collection. The Eiffel library does not use curried iterators | iterators are part of the collection objects, with the disadvantages described above [10]. <p> Curry [8]. The name Curried Object also suggests that this pattern is a little spicy and exotic, and probably not for the beginner. Arguments Object (7) can provide a less radical alternative to Curried Object. The original server can act as an Abstract Factory <ref> [6] </ref> to create the Curried Object. Patterns about Results Many messages ask questions of the objects to which they are sent, and such messages' results are the answers to these questions. <p> A Virtual Proxy <ref> [6] </ref> is a Lazy Object which stands in for another object which is created on demand. Acknowledgements The patterns in this language were inspired by discussions on the patterns-discussion mailing list, and the WikiWikiWeb.
Reference: [7] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Many changes (in particular extensions) to the protocol can be limited to the Protocol Object, and any servers and clients which fundamentally rely on the changed protocol. Smalltalk uses Message objects which record the arguments and name of a message which has caused an error <ref> [7] </ref>. The X Window System's drawing operations use GraphicsContexts to package up a large number of arguments such as the font, colour, line width, and clip region [14]. MacApp uses Event objects to package the arguments sent to widgets in response to user actions [15]. <p> Iterators are the most common kind of Curried Object, as they are used in many common languages and class libraries <ref> [6, 7, 4] </ref>. An iterator's server is a collection object, and the iterator maintains a slowly varying index into the collection. The Eiffel library does not use curried iterators | iterators are part of the collection objects, with the disadvantages described above [10].
Reference: [8] <author> Martin C. Henson. </author> <title> Elements of Functional Programming Languages. </title> <publisher> Blackwell Scientific, </publisher> <year> 1987. </year>
Reference-contexts: This pattern is called Curried Object because the underlying mechanism is partial function application, colloquially known as it currying after the mathematician Haskell B. Curry <ref> [8] </ref>. The name Curried Object also suggests that this pattern is a little spicy and exotic, and probably not for the beginner. Arguments Object (7) can provide a less radical alternative to Curried Object. The original server can act as an Abstract Factory [6] to create the Curried Object.
Reference: [9] <author> Wilf Lalonde. </author> <title> Discovering Smalltalk. </title> <address> Benjamin/Cummings, </address> <year> 1994. </year>
Reference-contexts: The Eiffel library does not use curried iterators | iterators are part of the collection objects, with the disadvantages described above [10]. Many graphics systems use Curried Objects whose servers are views, as in the example above. For example, VisualWorks uses GraphicsContext objects [12] and Smalltalk/V uses Pen objects <ref> [9] </ref>. VisualWorks also includes MessageSend objects, a curried version of the Message Protocol Object (6). MessageSend inherits from Message, and adds an extra variable to store the message's receiver, allowing a message to sent without reference to the ultimate receiver object.
Reference: [10] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: An iterator's server is a collection object, and the iterator maintains a slowly varying index into the collection. The Eiffel library does not use curried iterators | iterators are part of the collection objects, with the disadvantages described above <ref> [10] </ref>. Many graphics systems use Curried Objects whose servers are views, as in the example above. For example, VisualWorks uses GraphicsContext objects [12] and Smalltalk/V uses Pen objects [9]. VisualWorks also includes MessageSend objects, a curried version of the Message Protocol Object (6).
Reference: [11] <author> James Noble, Lindsay Groves, and Robert Biddle. </author> <title> Object oriented program visualisation in Tarraingm. </title> <journal> Australian Computer Journal, </journal> <volume> 27(4), </volume> <month> November </month> <year> 1995. </year>
Reference-contexts: These Watcher objects proved very useful, so the application model of visualisation was revised to include a third component between the Target objects and the View objects, which represented the monitoring strategy <ref> [11] </ref>. Discovering the Found Objects in the program changed the model of the application domain. Comments Objects are the most powerful and flexible parts of the object-oriented paradigm. Because objects contain both data and algorithms, they are ubiquitous | an object can represent any component of a computer program.
Reference: [12] <author> ParcPlace Systems. </author> <title> VisualWorks Smalltalk User's Guide, </title> <address> 2.0 edition, </address> <year> 1994. </year>
Reference-contexts: Selector Objects are often used to build object oriented interfaces to existing file or graphics systems. For example, VisualWorks uses symbols representing file 10 access modes as arguments to messages to manage files <ref> [12] </ref>. Many OO graphics systems, again including VisualWorks, provide Geometric or Graphic objects which combine the Selector Object and Arguments Object patterns. 9 Curried Object Some protocols are extremely complicated. <p> The Eiffel library does not use curried iterators | iterators are part of the collection objects, with the disadvantages described above [10]. Many graphics systems use Curried Objects whose servers are views, as in the example above. For example, VisualWorks uses GraphicsContext objects <ref> [12] </ref> and Smalltalk/V uses Pen objects [9]. VisualWorks also includes MessageSend objects, a curried version of the Message Protocol Object (6). MessageSend inherits from Message, and adds an extra variable to store the message's receiver, allowing a message to sent without reference to the ultimate receiver object. <p> These Result Objects can also provide textual descriptions of the errors, and appropriate help information. For example, VisualWorks includes SystemError objects, Result Objects which package together return codes and identifying arguments from errors occurring outside the system <ref> [12] </ref>. If the question can be answered in parallel, try Future Object (11). If the question can be answered easily now, but the answer may never be needed, try Lazy Object (12). 11 Future Ob ject Some questions can be answered while you think about something else.
Reference: [13] <author> Alan Perlis. </author> <title> Epigrams on programming. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 17(9), </volume> <month> September </month> <year> 1982. </year>
Reference-contexts: To quote Alan Perlis: If you have a procedure with 10 parameters, you probably missed some <ref> [13] </ref>. Large protocols often have one or more common parts which make up a regular structure within the protocol. Several arguments may be used together in many messages, and several messages may differ only in their message names and the operations they invoke, but take exactly the same arguments.
Reference: [14] <author> Robert W. Scheifler and Jim Gettys. </author> <title> The X Window System. </title> <journal> ACM Transactions on Graphics, </journal> <volume> 5(2), </volume> <month> April </month> <year> 1986. </year>
Reference-contexts: Smalltalk uses Message objects which record the arguments and name of a message which has caused an error [7]. The X Window System's drawing operations use GraphicsContexts to package up a large number of arguments such as the font, colour, line width, and clip region <ref> [14] </ref>. MacApp uses Event objects to package the arguments sent to widgets in response to user actions [15]. The following three patterns describe how Protocol Object can be applied 8 in common situations. Arguments Object (7) captures arguments which are often passed together.
Reference: [15] <author> K. Schmucker. MacApp: </author> <title> an application framework. </title> <journal> Byte, </journal> <volume> 11(8), </volume> <year> 1986. </year>
Reference-contexts: The X Window System's drawing operations use GraphicsContexts to package up a large number of arguments such as the font, colour, line width, and clip region [14]. MacApp uses Event objects to package the arguments sent to widgets in response to user actions <ref> [15] </ref>. The following three patterns describe how Protocol Object can be applied 8 in common situations. Arguments Object (7) captures arguments which are often passed together. Selector Object (8) groups messages which differ only in their names.
Reference: [16] <author> Suzanne Skiblics, Edward J. Klimas, and David A. Thomas. </author> <title> Smalltalk with Style. </title> <publisher> Prentice-Hall, </publisher> <year> 1996. </year>
Reference-contexts: Perhaps you need to keep information about how the result was obtained. One way to do this is to use lazy initialisation within the server object that calculates the result <ref> [16] </ref>. The server is given an extra variable into which the result can be cached after it is calculated. When the result is required again, it can be fetched from the cache. More variables can be used to cache multiple objects, or store additional information about the result.
Reference: [17] <author> Rebecca Wirfs-Brock, Brian Wilkerson, and Lauren Wiener. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: For this reason, many object oriented analysis and design methods begin by identifying a set of candidate objects from the domain, and then refine the set of candidate objects <ref> [17, 4] </ref>. Unfortunately, it is not always clear what objects or abstractions there are in the domain, or how to determine whether a particular program object models a domain object.
Reference: [18] <author> Kirk Wolf and Chamond Lui. </author> <title> New clients with old servers: A pattern language for client/server frameworks. In Pattern Languages of Program Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: A Protocol Object (6) or Result Object (10) can represent an important pattern of communication between objects. Many patterns in other pattern languages depend on finding objects, often called reification or objectification <ref> [19, 18] </ref>. 2 Independent Abstraction An object should represent a single, independent abstraction. Objects are the currency of object oriented design.
Reference: [19] <author> Walter Zimmer. </author> <title> Relationships between design patterns. In Pattern Languages of Program Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year> <month> 17 </month>
Reference-contexts: A Protocol Object (6) or Result Object (10) can represent an important pattern of communication between objects. Many patterns in other pattern languages depend on finding objects, often called reification or objectification <ref> [19, 18] </ref>. 2 Independent Abstraction An object should represent a single, independent abstraction. Objects are the currency of object oriented design.
References-found: 19

