URL: http://www.cs.man.ac.uk/~tessaris/DL/docs/misc/tcs96.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~tessaris/DL/papers.html
Root-URL: http://www.cs.man.ac.uk
Email: email: bonatti@di.unito.it  email: eiter@dbai.tuwien.ac.at  
Title: Querying Disjunctive Databases Through Nonmonotonic Logics  
Author: Piero A. Bonatti Thomas Eiter Christian 
Note: M0066-PHY. This work has been carried out while he was visiting the  
Address: Corso Svizzera 185, 10149 Torino, Italy  Paniglgasse 16, A-1040 Wien, Austria  
Affiliation: Dipartimento di Informatica Universita di Torino  Doppler Lab for Expert Systems Institut fur Informationssysteme, TU Wien  Institut fur Informationssysteme, TU Wien.  
Abstract: Query languages for retrieving information from disjunctive databases are an interesting open area of research. In this paper we study the expressive power of major non-monotonic formalisms such as circumscription, default logic, autoepis-temic logic and some logic programming languages used as query languages over disjunctive databases. For this aim, we define the semantics of query expressions formulated in different nonmonotonic logics. The expressive power of the languages that we consider has been explored in the context of relational databases. Here, we extend this study to disjunctive databases; as a result, we obtain a finer-grained characterization of the expressiveness of those languages and interesting fragments thereof. For instance, we show that there exist simple queries that cannot be expressed by any preferential semantics (including the minimal model semantics and the various forms of circumscription), while they can be expressed in default and autoepistemic logic. Secondly, we show that default logic, autoepistemic logic and some of their fragments express the same class of Boolean queries, which turns out to be a strict subclass of the p 2 -recognizable Boolean queries. The latter result is proved by means of a new technique, based on a counting argument. Then we prove that under the assumption that the database consists of clauses whose length is bounded by some constant, default logic and autoepistemic logic express all of the p 2 -recognizable Boolean queries, while preference-based logics cannot. These results hold for brave reasoning; we obtain dual results for cautious reasoning. Our results appear to be interesting both in the area of database theory and in the area of knowledge representation. fl An extended abstract of this paper appeared in the Proceedings of the 5th International Conference on Database Theory (ICDT '95), January 1995, Prague, pp. 68-81, LNCS 893, Springer, 1995. y This author was supported by the Austrian Government through the Lise-Meitner Fellowship 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul, P. Kanellakis, and G. Grahne. </author> <title> On the Representation and Querying of Sets of Possible Worlds. </title> <journal> Theoretical Computer Science, </journal> <volume> 78 </volume> <pages> 159-187, </pages> <year> 1991. </year> <month> 41 </month>
Reference-contexts: These relationships are quite well understood [2, 7]. The study of query languages for disjunctive databases is much less established. Work on querying incomplete databases is related; cf. <ref> [14, 1] </ref> for relations with null values, and [39] for the similar proviso of missing unique names axioms in logical databases. In these works, disjunctive information involving distinct relations as in (2) cannot be directly encoded. <p> In these works, disjunctive information involving distinct relations as in (2) cannot be directly encoded. More importantly, these works consider only monotonic queries (in [39] the answer to a query grows monotonically with the amount of information encoded into the database; in <ref> [14, 1] </ref> queries are monotonic functions over sets of possible worlds). However, many natural queries do not easily fit into these frameworks, e.g. Find all the persons which suffer from a disease that has not yet been precisely identified. <p> In general, the ground instantiation of a database can be exponentially larger than the nonground version. 2 More precisely, <ref> [14, 1] </ref> consider not only what is necessarily true in the result of a query (which returns an incomplete database), but also what is possibly true; this is a first step toward nonmono-tonicity. <p> However, no such combinations of problems are considered in <ref> [14, 1] </ref>.
Reference: [2] <author> S. Abiteboul and V. Vianu. </author> <title> Expressive Power of Query Languages. </title> <editor> In J. Ullman, editor, </editor> <booktitle> Theoretical Studies in Computer Science. </booktitle> <publisher> Academic Press, </publisher> <year> 1992. </year> <note> Festschrift in Honour of Seymour Ginsburg's 64th Birthday. </note>
Reference-contexts: Query languages for retrieving information from disjunctive databases are an open area of research. In the framework of relational databases, many alternative query languages have been proposed; they have been extensively studied in the literature (cf. <ref> [38, 20, 6, 7, 2] </ref> for fundamentals and overviews) and, in particular, they have been compared to each other by characterizing their expressiveness, i.e., the class of queries that they can express. These relationships are quite well understood [2, 7]. <p> These relationships are quite well understood <ref> [2, 7] </ref>. The study of query languages for disjunctive databases is much less established. Work on querying incomplete databases is related; cf. [14, 1] for relations with null values, and [39] for the similar proviso of missing unique names axioms in logical databases. <p> The interested reader is referred to [27] for more details. 3 Query languages for disjunctive databases Query languages for relational databases are a well-studied topic in the theory of relational databases, cf. <ref> [38, 6, 20, 2] </ref>. Informally, a query is a function that maps each relational database onto another relational database, which is considered as the result of evaluating the query. Queries are specified by the expressions of query languages; expressions can be regarded as "programs" for computing queries. <p> Let R and S be relational schemes. A database mapping or query is a recursive function q : D (R) ! D (S) such that U (q (D)) = U (D); moreover, we require q to be invariant under isomorphism (i.e., generic in the sense of <ref> [2] </ref>) and under logical consequence, i.e., q (D) = q (D 0 ) if D and D 0 are logically equivalent. The latter condition insures that queries are not sensitive to the syntactic representation of disjunctive information. <p> E (L) = f q j 9E 2 L : (E) = q g. A query language L is well-balanced if its expressiveness matches its complexity, i.e., it can precisely express the database properties (resp. queries) computable within the bounds of some complexity class C, cf. <ref> [18, 17, 2] </ref>; we say that L captures the class of C-recognizable database properties (resp. queries) in this case. <p> We remark that a C-complete L does not necessarily capture C (cf. below and <ref> [2] </ref>). 4 Nonmonotonic logics as query languages In this section we define the semantics of nonmonotonic logics (in particular, default logic and AEL) as a query language for Boolean database properties over disjunctive databases; a generalization to relational-output queries is straightforward. We take inspiration from DATALOG (cf. [20]). <p> Claim: for every D = (U; OE) 2 D (R) d , T + D has an extension iff P (D) = true. (() If P (D) = true then P r (D r ) = true and hence hCOMP (D r ); <ref> [ 2 ] </ref> U i has an extension E. Define E 0 = Th (E [ f [OE] U g). Then, E 0 is an extension of T + D. ()) Assume that E is an extension of T + D = hf [OE] U g; [ 1 [ 2 ] <p> r ); <ref> [ 2 ] </ref> U i has an extension E. Define E 0 = Th (E [ f [OE] U g). Then, E 0 is an extension of T + D. ()) Assume that E is an extension of T + D = hf [OE] U g; [ 1 [ 2 ] U i, and let E 0 be the restriction of E to all formulas in which no predicate from R occurs. Clearly, E is consistent. <p> It follows that E 0 is an extension of hCOMP (D r ); <ref> [ 2 ] </ref> U i, which means that P r (D r ) = true. Consequently, P (D) = true. This proves the claim. Consequently, the default theory T defines the property P over D (R) d . This proves the theorem. <p> In order to overcome the limitations of DL and AEL, one can look for extensions based on the following two ideas, which have been proposed for similar purposes in the context of relational databases (cf. <ref> [2] </ref>): (1) Allow queries to introduce new constants; and (2) allow the use of predicates with nonfixed arities. However, such extensions remain to be explored. Besides issues on nonmonotonic logics, there are some interesting issues concerning queries over disjunctive databases in general.
Reference: [3] <author> P. Bonatti. </author> <title> Autoepistemic Logics as a Unifying Framework for the Semantics of Logic Programs. </title> <journal> The Journal of Logic Programming, </journal> <volume> 22(2) </volume> <month> 91-149 </month> <year> (1995). </year>
Reference-contexts: Thus, Theorem 5.8 holds for extended disjunctive logic programs, too. 17 Similar results have already been proved for other important semantics of disjunctive logic programs, cf. <ref> [3] </ref>. 6 Expressive power of default logic Default logic can express the property P R , which cannot be expressed by any preference logic. The default theory T R = hW R ; R i, whose formulas and defaults are illustrated in occur among the database predicates R. <p> We can think of many possible extensions of the logic programming paradigm, intermediate between normal programs and full AEL or DL. Some of them have already been considered, e.g. the epistemic semantics introduced in <ref> [3] </ref> , and the nondeterministic choice constructs analyzed in [16] . We immediately know that none of these extensions makes it possible to express queries such as P ev;g . It remains to be seen which of these extensions is well-balanced over bounded databases.
Reference: [4] <author> P. Bonatti. </author> <title> Autoepistemic Logic Programming. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 13 </volume> <month> 35-67 </month> <year> (1994). </year>
Reference-contexts: Konolige proved that every closed autoepistemic theory is equivalent to a closed theory in autoepistemic normal form, in the sense that the two theories have the same stable expansions. We can easily extend the epistemic Gelfond-Lifschitz transformation <ref> [4] </ref> to autoepis-temic theories: Definition 2.6 For all normal autoepistemic theories T and all sets of autoepistemic sentences S define (cf.
Reference: [5] <author> M. Cadoli, T. Eiter, and G. Gottlob. </author> <title> Using Default Logic as a Query Language. </title> <booktitle> In Proceedings Fourth International Conference on Principles of Knowledge Representation and Reasoning (KR-94), </booktitle> <pages> pages 99-108, </pages> <year> 1994. </year>
Reference-contexts: Indeed some query languages are built on well-known nonmonotonic formalisms such as logic programming languages, circumscription and default logic <ref> [35, 8, 5] </ref>. The use of nonmonotonic formalisms as query languages is justified by their expressive power, and by their ability of defining nonmonotonic queries, such as the one illustrated above; see [5] for further motivating examples. <p> The use of nonmonotonic formalisms as query languages is justified by their expressive power, and by their ability of defining nonmonotonic queries, such as the one illustrated above; see <ref> [5] </ref> for further motivating examples. <p> This result can be intuitively grasped through two facts. First, each database from D (R) d can be represented in a relational database over some scheme R 0 . Second, all 2 -recognizable queries over relational databases can be expressed in default logic <ref> [5] </ref>. Recall that we can think of a relational database over R 0 as a database D 2 D (R 0 where the clauses in D (which are facts) correspond to the tuples stored in the database relations. The following lemma rephrases the main result in [5]. <p> expressed in default logic <ref> [5] </ref>. Recall that we can think of a relational database over R 0 as a database D 2 D (R 0 where the clauses in D (which are facts) correspond to the tuples stored in the database relations. The following lemma rephrases the main result in [5]. Lemma 6.13 Let P be a p 2 -recognizable database property over D (R) 1 . <p> On the other hand, it was reported in <ref> [5] </ref> that according to expression as well as combined complexity default logic over relational databases is NEXP NP -complete. Thus, by means of our polynomial transformations, it follows that all query languages in Fig. 3 have NEXP NP -complete expression and combined complexity.
Reference: [6] <author> A. Chandra and D. Harel. </author> <title> Horn Clause Queries and Generalizations. </title> <journal> Journal of Logic Programming, </journal> <volume> 2 </volume> <pages> 1-15, </pages> <year> 1985. </year>
Reference-contexts: Query languages for retrieving information from disjunctive databases are an open area of research. In the framework of relational databases, many alternative query languages have been proposed; they have been extensively studied in the literature (cf. <ref> [38, 20, 6, 7, 2] </ref> for fundamentals and overviews) and, in particular, they have been compared to each other by characterizing their expressiveness, i.e., the class of queries that they can express. These relationships are quite well understood [2, 7]. <p> The interested reader is referred to [27] for more details. 3 Query languages for disjunctive databases Query languages for relational databases are a well-studied topic in the theory of relational databases, cf. <ref> [38, 6, 20, 2] </ref>. Informally, a query is a function that maps each relational database onto another relational database, which is considered as the result of evaluating the query. Queries are specified by the expressions of query languages; expressions can be regarded as "programs" for computing queries.
Reference: [7] <author> A. K. Chandra. </author> <title> Theory of Database Queries. </title> <booktitle> In Proceedings PODS-88, </booktitle> <year> 1988. </year>
Reference-contexts: Query languages for retrieving information from disjunctive databases are an open area of research. In the framework of relational databases, many alternative query languages have been proposed; they have been extensively studied in the literature (cf. <ref> [38, 20, 6, 7, 2] </ref> for fundamentals and overviews) and, in particular, they have been compared to each other by characterizing their expressiveness, i.e., the class of queries that they can express. These relationships are quite well understood [2, 7]. <p> These relationships are quite well understood <ref> [2, 7] </ref>. The study of query languages for disjunctive databases is much less established. Work on querying incomplete databases is related; cf. [14, 1] for relations with null values, and [39] for the similar proviso of missing unique names axioms in logical databases.
Reference: [8] <author> T. Eiter, G. Gottlob, and H. Mannila. </author> <title> Adding Disjunction to Datalog. </title> <booktitle> In Proceedings of the Thirteenth ACM SIGACT SIGMOD-SIGART Symposium on Principles of Database Systems (PODS-94), </booktitle> <pages> pages 267-278, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: Indeed some query languages are built on well-known nonmonotonic formalisms such as logic programming languages, circumscription and default logic <ref> [35, 8, 5] </ref>. The use of nonmonotonic formalisms as query languages is justified by their expressive power, and by their ability of defining nonmonotonic queries, such as the one illustrated above; see [5] for further motivating examples. <p> Section 8). 5 Expressive power of preferential semantics It has been recently shown that the brave version of parallel circumscription captures the 2 -recognizable database properties of relational databases (provided that the language contains equality) <ref> [8] </ref>. We are going to prove that this result cannot be generalized to disjunctive databases. Actually, we will prove a stronger result, namely, that all preferential semantics have the same limitations. For this purpose, consider the following property: Definition 5.1 Let R be an a-ary predicate symbol in R. <p> For instance, in the area of relational databases, DL, AEL, DATALOG under the minimal model semantics and DATALOG under the stable model semantics express exactly the same class of queries (cf. the results of this paper and <ref> [8] </ref>), while in the area of bounded disjunctive databases DL and AEL are strictly more expressive than DATALOG, which expresses P R (or its complement in the cautious version) neither under the minimal model semantics nor under the stable model semantics.
Reference: [9] <author> Etherington, D. W.: </author> <title> Reasoning with Incomplete Information. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> Los Altos, </address> <year> 1988 </year>
Reference-contexts: 1 Introduction Disjunctive databases provide one of the major techniques for representing incomplete information a topic which has been receiving much attention in the areas of databases, logic programming and AI <ref> [14, 26, 11, 9] </ref>.
Reference: [10] <author> R. Fagin and J. D. Ullman. </author> <title> On the Semantics of Updates in Databases. </title> <booktitle> In Proceedings of PODS-83, </booktitle> <pages> pages 352-365, </pages> <year> 1983. </year>
Reference-contexts: man or a woman" can be naturally encoded as follows: disease (John; d 1 ) _ disease (John; d 2 ) _ disease (John; d 3 ) ; (1) man (Nicky) _ woman (Nicky ) : (2) Closely related approaches to the representation of incomplete information can be found in <ref> [10, 40] </ref> , where databases can be unrestricted propositional or first-order theories. In general, disjunctive databases are better suited for implementation; their operational and computational aspects have been extensively investigated (cf. [26, 11]). Query languages for retrieving information from disjunctive databases are an open area of research.
Reference: [11] <author> J. Fernandez and J. Minker. </author> <title> Semantics of Disjunctive Deductive Databases. </title> <booktitle> In Proceedings ICDT-92, </booktitle> <pages> pages 21-50, </pages> <address> Berlin, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Disjunctive databases provide one of the major techniques for representing incomplete information a topic which has been receiving much attention in the areas of databases, logic programming and AI <ref> [14, 26, 11, 9] </ref>. <p> In general, disjunctive databases are better suited for implementation; their operational and computational aspects have been extensively investigated (cf. <ref> [26, 11] </ref>). Query languages for retrieving information from disjunctive databases are an open area of research. <p> The main contributions of this paper are the following: * We define the semantics of query expressions formulated in different nonmono tonic logics. * We prove that the minimal model semantics (and, more generally, circumscription, cf. <ref> [11] </ref>), default logic [34] and autoepistemic logic [30] cannot express all of the PTIME-recognizable properties of positive disjunctive databases; this result is surprising, because in the framework of relational databases these logics can express every p 2 -recognizable query. 3 More surprisingly, the same negative result holds for unrestricted preferential semantics, <p> We obtain similar results for some of the major semantics of disjunctive logic programs, such as the stable model semantics and the perfect model semantics, cf. <ref> [11] </ref>.
Reference: [12] <author> M. Gelfond and V. Lifschitz. </author> <title> Classical negation in logic programs and disjunctive databases. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <month> 365-385 </month> <year> (1991). </year>
Reference-contexts: perfect model semantics [31] (which is, like stable model semantics, not a preferential semantics according to the concept that we follow here; the proof of the negative result is analogous to the proof for stable model semantics) and for extended disjunctive logic programs, under their standard answer set semantics (see <ref> [12] </ref>). The latter can be easily embedded into (nonextended) disjunctive logic programs under the stable semantics, by replacing each negative literal :A with a new atom A fl . <p> Since T R expresses P R , this fact seems to contradict Remark 5.9 , which states that P R cannot be expressed by any extended disjunctive program. This apparent contradiction can be explained by noting that in extended programs, disjunction (denoted by `j') is not interpreted classically (cf. <ref> [12] </ref>); the clauses of the input database should be interpreted as if they had the form A 1 j j A k . This causes T R and the corresponding logic program P to behave in totally different ways.
Reference: [13] <author> G. Gottlob. </author> <title> Complexity Results for Nonmonotonic Logics. </title> <journal> Journal of Logic and Computation, </journal> <volume> 2(3) </volume> <pages> 397-425, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: From the computational side, credulous and skeptical reasoning have been extensively studied in the literature <ref> [21, 13, 36] </ref>. 2.4 Autoepistemic logic (AEL) The language of autoepistemic logic [30] is a modal language with one modal operator L, to be read as "know" or "believe"; for an extensive treatment, cf. [28, 27]. The formulas where L does not occur are called ordinary or objective. <p> Theorem 6.2 The database properties expressible in default logic are p 2 -recognizable. Proof. As shown in <ref> [13] </ref>, deciding whether a propositional default theory has an extension is a p 2 -complete problem. For any fixed default theory T , the size of T + D grows polynomially with the size of D. Hence, the result follows.
Reference: [14] <author> G. Grahne. </author> <title> The Problem of Incomplete Information in Relational Databases, </title> <booktitle> volume 554 of LNCS. </booktitle> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction Disjunctive databases provide one of the major techniques for representing incomplete information a topic which has been receiving much attention in the areas of databases, logic programming and AI <ref> [14, 26, 11, 9] </ref>. <p> These relationships are quite well understood [2, 7]. The study of query languages for disjunctive databases is much less established. Work on querying incomplete databases is related; cf. <ref> [14, 1] </ref> for relations with null values, and [39] for the similar proviso of missing unique names axioms in logical databases. In these works, disjunctive information involving distinct relations as in (2) cannot be directly encoded. <p> In these works, disjunctive information involving distinct relations as in (2) cannot be directly encoded. More importantly, these works consider only monotonic queries (in [39] the answer to a query grows monotonically with the amount of information encoded into the database; in <ref> [14, 1] </ref> queries are monotonic functions over sets of possible worlds). However, many natural queries do not easily fit into these frameworks, e.g. Find all the persons which suffer from a disease that has not yet been precisely identified. <p> In general, the ground instantiation of a database can be exponentially larger than the nonground version. 2 More precisely, <ref> [14, 1] </ref> consider not only what is necessarily true in the result of a query (which returns an incomplete database), but also what is possibly true; this is a first step toward nonmono-tonicity. <p> However, no such combinations of problems are considered in <ref> [14, 1] </ref>. <p> Our results on preferential semantics show that second-order logic is not suitable, just as any other monotonic logic. Finally, there exists an alternative view of databases, related to finite model theory. Relational databases and incomplete databases can be regarded as first-order interpretations and sets thereof, respectively <ref> [20, 14] </ref>. Equivalently, incomplete databases can be regarded as finite S5 Kripke structures. Under this view, the database property expressed by a logical formula OE is the characteristic function of the generalized spectrum of OE, that is, the set of finite models of OE.
Reference: [15] <author> G. Grahne. </author> <title> Updates and Counterfactuals. </title> <booktitle> In Proceedings Second International Conference on Principles of Knowledge Representation and Reasoning (KR-91), </booktitle> <pages> pages 269-276, </pages> <year> 1991. </year>
Reference: [16] <author> S. Greco, D. Sacca and C. Zaniolo. </author> <title> DATALOG Queries with Stratified Negation and Choice. </title> <booktitle> In Proc. 5th International Conference on Database Theory (ICDT'95), </booktitle> <volume> LNCS 893, </volume> <pages> pages 82-96, </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <month> 42 </month>
Reference-contexts: We can think of many possible extensions of the logic programming paradigm, intermediate between normal programs and full AEL or DL. Some of them have already been considered, e.g. the epistemic semantics introduced in [3] , and the nondeterministic choice constructs analyzed in <ref> [16] </ref> . We immediately know that none of these extensions makes it possible to express queries such as P ev;g . It remains to be seen which of these extensions is well-balanced over bounded databases.
Reference: [17] <author> Y. Gurevich. </author> <title> Logic and the Challenge of Computer Science. </title> <editor> In E. Borger, editor, </editor> <booktitle> Trends in Theoretical Computer Science, chapter 1. </booktitle> <publisher> Computer Science Press, </publisher> <year> 1988. </year>
Reference-contexts: Following the approach in <ref> [38, 17] </ref>, we say that a database property is C-recognizable (or, in C) if, given D, deciding whether P (D) = true is in C; a query q is C-recognizable (or, in C) if, given D and a ground clause C, deciding whether C 2 q (D) is in C. <p> E (L) = f q j 9E 2 L : (E) = q g. A query language L is well-balanced if its expressiveness matches its complexity, i.e., it can precisely express the database properties (resp. queries) computable within the bounds of some complexity class C, cf. <ref> [18, 17, 2] </ref>; we say that L captures the class of C-recognizable database properties (resp. queries) in this case. <p> The answer 10 Equivalently wrt to polynomial time computability, we might represent U by enumerating its elements, cf. <ref> [17] </ref>. Note that the standard encoding of relational databases needs always an amount of space which is larger than the cardinality of U . 11 to the query is "yes" if the output propositional letter P is true in M .
Reference: [18] <author> N. Immerman. </author> <title> Languages that Capture Complexity Classes. </title> <journal> SIAM J. Comp., </journal> <volume> 16 </volume> <pages> 760-778, </pages> <year> 1987. </year>
Reference-contexts: E (L) = f q j 9E 2 L : (E) = q g. A query language L is well-balanced if its expressiveness matches its complexity, i.e., it can precisely express the database properties (resp. queries) computable within the bounds of some complexity class C, cf. <ref> [18, 17, 2] </ref>; we say that L captures the class of C-recognizable database properties (resp. queries) in this case.
Reference: [19] <author> D. S. Johnson, M. Yannakakis, and C. H. Papadimitriou. </author> <title> On Generating All Maximal Independent Sets. </title> <journal> Information Processing Letters, </journal> <volume> 27 </volume> <pages> 119-123, </pages> <year> 1988. </year>
Reference-contexts: To avoid this, a notion of complexity can be adopted under which efficiency is relativized to the size of the output (besides that of the input), and a computation is feasible if it is polynomial in the combined size of the input and the output, cf. <ref> [37, 19] </ref>. Our framework might be modified in a similar way.
Reference: [20] <author> P. Kanellakis. </author> <title> Elements of Relational Database Theory. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B, chapter 17. </booktitle> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <year> 1990. </year>
Reference-contexts: Query languages for retrieving information from disjunctive databases are an open area of research. In the framework of relational databases, many alternative query languages have been proposed; they have been extensively studied in the literature (cf. <ref> [38, 20, 6, 7, 2] </ref> for fundamentals and overviews) and, in particular, they have been compared to each other by characterizing their expressiveness, i.e., the class of queries that they can express. These relationships are quite well understood [2, 7]. <p> The interested reader is referred to [27] for more details. 3 Query languages for disjunctive databases Query languages for relational databases are a well-studied topic in the theory of relational databases, cf. <ref> [38, 6, 20, 2] </ref>. Informally, a query is a function that maps each relational database onto another relational database, which is considered as the result of evaluating the query. Queries are specified by the expressions of query languages; expressions can be regarded as "programs" for computing queries. <p> We take inspiration from DATALOG (cf. <ref> [20] </ref>). There, query expressions (which are finite collections of function-free Horn clauses) are "evaluated against a relational database". <p> Our results on preferential semantics show that second-order logic is not suitable, just as any other monotonic logic. Finally, there exists an alternative view of databases, related to finite model theory. Relational databases and incomplete databases can be regarded as first-order interpretations and sets thereof, respectively <ref> [20, 14] </ref>. Equivalently, incomplete databases can be regarded as finite S5 Kripke structures. Under this view, the database property expressed by a logical formula OE is the characteristic function of the generalized spectrum of OE, that is, the set of finite models of OE.
Reference: [21] <author> H. Kautz and B. Selman. </author> <title> Hard Problems for Simple Default Logics. </title> <journal> Artificial Intelligence, </journal> <volume> 49 </volume> <pages> 243-279, </pages> <year> 1991. </year>
Reference-contexts: From the computational side, credulous and skeptical reasoning have been extensively studied in the literature <ref> [21, 13, 36] </ref>. 2.4 Autoepistemic logic (AEL) The language of autoepistemic logic [30] is a modal language with one modal operator L, to be read as "know" or "believe"; for an extensive treatment, cf. [28, 27]. The formulas where L does not occur are called ordinary or objective.
Reference: [22] <author> Kolaitis, P., Vardi, M.: </author> <title> On the Expressive Power of Datalog: Tools and a Case Study. </title> <booktitle> In Proceedings PODS-90, </booktitle> <pages> 61-71, </pages> <year> 1990 </year>
Reference-contexts: We obtain similar results for some of the major semantics of disjunctive logic programs, such as the stable model semantics and the perfect model semantics, cf. [11]. This kind of negative results is usually proved by means of persistency properties, cf. <ref> [22] </ref>; for default logic we use a new technique based on a counting argument. * If we impose a constant bound on the length of database clauses, then default logic and autoepistemic logic can express every p 2 -recognizable query, while model-preference based logics (including circumscription and the minimal model semantics)
Reference: [23] <author> K. Konolige. </author> <title> On the Relationship between Default and Autoepistemic Logic. </title> <journal> Artificial Intelligence, </journal> <volume> 35 </volume> <pages> 343-382, </pages> <year> 1988. </year> + <note> Errata, same journal, 41:115, 1989/90. </note>
Reference-contexts: only sentences of the form: Lff 1 ^ ^ Lff m ^ :Lfi 1 ^ ^ :Lfi n ! OE (4) where m; n 0 and ff 1 ; : : : ; ff m ; fi 1 ; : : : ; fi n ; OE are objective, cf. <ref> [23, 28] </ref>. Konolige proved that every closed autoepistemic theory is equivalent to a closed theory in autoepistemic normal form, in the sense that the two theories have the same stable expansions. <p> Accordingly, we say that a normal autoepistemic theory T is prerequisite-free if all formulas in T have the form (4) with m = 0. A semantical correspondence between prerequisite-free DL and prerequisite-free AEL can be established through Konolige's translation of default theories into AEL <ref> [23] </ref>.
Reference: [24] <author> K. Konolige. </author> <title> On the Relation Between Autoepistemic Logic and Circumscription. </title> <booktitle> In Proceedings IJCAI-89, </booktitle> <year> 1989. </year>
Reference-contexts: Moore's original formulation tackles only the propositional case; extending it to full quantification involves subtle technical difficulties due to the behaviour of quantification through the modal operator; the first proposals in this direction are due to Konolige <ref> [24] </ref> and Levesque [25]. The complications of quantifying-in will not be tackled in this paper. We will restrict our attention to quantifier-free autoepistemic theories; they will be treated as sets of schemata to be instantiated in all possible ways.
Reference: [25] <author> H. Levesque. </author> <title> All I Know: A Study in Autoepistemic Logic. </title> <journal> Artificial Intelligence, </journal> <volume> 42 </volume> <pages> 263-309, </pages> <year> 1990. </year>
Reference-contexts: Moore's original formulation tackles only the propositional case; extending it to full quantification involves subtle technical difficulties due to the behaviour of quantification through the modal operator; the first proposals in this direction are due to Konolige [24] and Levesque <ref> [25] </ref>. The complications of quantifying-in will not be tackled in this paper. We will restrict our attention to quantifier-free autoepistemic theories; they will be treated as sets of schemata to be instantiated in all possible ways.
Reference: [26] <author> Lobo, J., Minker, J., Rajasekar, A.: </author> <title> Foundations of Disjunctive Logic Programming. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1992 </year>
Reference-contexts: 1 Introduction Disjunctive databases provide one of the major techniques for representing incomplete information a topic which has been receiving much attention in the areas of databases, logic programming and AI <ref> [14, 26, 11, 9] </ref>. <p> In general, disjunctive databases are better suited for implementation; their operational and computational aspects have been extensively investigated (cf. <ref> [26, 11] </ref>). Query languages for retrieving information from disjunctive databases are an open area of research.
Reference: [27] <author> W. </author> <title> Lukasiewicz. Non-Monotonic Reasoning. </title> <publisher> Ellis Horwood Limited, </publisher> <address> Chichester, England, </address> <year> 1990. </year>
Reference-contexts: Notice that D (R) 1 corresponds in an obvious 4 Note that U suffices to specify the language of OE, for the set of predicate symbols is fixed by the relational scheme. Therefore a disjunctive database is essentially a theory, i.e. a pair hLanguage; Axiomsi (cf. <ref> [27] </ref>). 5 In the literature on logic programming a positive clause is usually a rule that has no negative literals in the body. <p> for all positive databases D 1 = (U; OE 1 ), OE 1 is logically equivalent to OE iff OE fl = OE fl 1 (up to the ordering of clauses and disjuncts). 2.3 Default logic Default logic [34] is one of the best known formalizations of nonmonotonic reasoning (see <ref> [27, 29] </ref> for extensive studies of the subject). <p> Then, E is an extension of hW; i iff E = Th (W [CONS (GD (; E))). 6 The semantics of open default theories involves technical complications that are not needed in this paper; the interested reader is referred to <ref> [27] </ref> . 7 Reiter's notion of generating default [34] is defined only when S is an extension. <p> From the computational side, credulous and skeptical reasoning have been extensively studied in the literature [21, 13, 36]. 2.4 Autoepistemic logic (AEL) The language of autoepistemic logic [30] is a modal language with one modal operator L, to be read as "know" or "believe"; for an extensive treatment, cf. <ref> [28, 27] </ref>. The formulas where L does not occur are called ordinary or objective. The kernel of a set of formulas S, denoted by S 0 , is the set of all the objective formulas of S. <p> [ :LE 0 (by Lemma 2.7) Thus, by the definition of stable expansion, E 0 is a stable expansion of T . 2.6 Preferential semantics and preference logics Some of the most popular semantics for nonmonotonic reasoning, such as the minimal model semantics and the various forms of circumscription (see <ref> [27] </ref>), are based on preference relations over interpretations; different notions of preference lead to different preference logics. A preference relation OE is typically a strict partial order, i.e. an irreflexive and transitive relation; intuitively, I OE J means that the interpretation I is preferable to J . <p> The interested reader is referred to <ref> [27] </ref> for more details. 3 Query languages for disjunctive databases Query languages for relational databases are a well-studied topic in the theory of relational databases, cf. [38, 6, 20, 2].
Reference: [28] <author> W. Marek and M. Truszczynski. </author> <title> Autoepistemic Logic. </title> <journal> Journal of the ACM, </journal> <volume> 38(3) </volume> <pages> 588-619, </pages> <year> 1991. </year>
Reference-contexts: From the computational side, credulous and skeptical reasoning have been extensively studied in the literature [21, 13, 36]. 2.4 Autoepistemic logic (AEL) The language of autoepistemic logic [30] is a modal language with one modal operator L, to be read as "know" or "believe"; for an extensive treatment, cf. <ref> [28, 27] </ref>. The formulas where L does not occur are called ordinary or objective. The kernel of a set of formulas S, denoted by S 0 , is the set of all the objective formulas of S. <p> only sentences of the form: Lff 1 ^ ^ Lff m ^ :Lfi 1 ^ ^ :Lfi n ! OE (4) where m; n 0 and ff 1 ; : : : ; ff m ; fi 1 ; : : : ; fi n ; OE are objective, cf. <ref> [23, 28] </ref>. Konolige proved that every closed autoepistemic theory is equivalent to a closed theory in autoepistemic normal form, in the sense that the two theories have the same stable expansions. <p> all sets of autoepistemic sentences S T [ LS [ :LS j T S 0 [ LS [ :LS Through the epistemic Gelfond-Lifschitz transformation which yields always an objective theory we can determine the kernels of stable expansions in a non-modal setting 9 (Under different notation, this characterization appears in <ref> [28] </ref>; cf. also Sec tion 11 in [29]): Theorem 2.8 For all normal autoepistemic theories T i) If E is a stable expansion of T then E 0 = Th (T E 0 ) (where E 0 is the kernel of E) ii) Conversely, if E = Th (T E )
Reference: [29] <author> W. Marek and M. Truszczynski. </author> <title> Nonmonotonic Logics - Context-Dependent Reasoning. </title> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: for all positive databases D 1 = (U; OE 1 ), OE 1 is logically equivalent to OE iff OE fl = OE fl 1 (up to the ordering of clauses and disjuncts). 2.3 Default logic Default logic [34] is one of the best known formalizations of nonmonotonic reasoning (see <ref> [27, 29] </ref> for extensive studies of the subject). <p> Then, E = Th (W [ CONS (GD (; E))): The converse is not true in general. However, from the above quasi-inductive characterization of extensions, one can easily obtain the following result, in the spirit of Marek and Truszczynski's characterizations based on well-orderings (cf. <ref> [29] </ref>). Lemma 2.4 Let T = hW; i be a finite closed default theory and let E be a set of sentences. <p> Theorems 3.80,3.81 in <ref> [29, p.89,91] </ref>) Let hW; i be a closed prerequi site-free theory. <p> Here we adopt the more general definition introduced by Marek and Trusczynski <ref> [29] </ref>, which applies to arbitrary contexts S; intuitively, their notion of generating defaults captures all the defaults that are "applicable" in S. 8 By strict partial order we mean an irreflexive and transitive binary relation. 6 In general, a default theory can have one, multiple or no extensions. <p> We can easily extend the epistemic Gelfond-Lifschitz transformation [4] to autoepis-temic theories: Definition 2.6 For all normal autoepistemic theories T and all sets of autoepistemic sentences S define (cf. Definition 11.3 of <ref> [29, p.322] </ref>): T S = fOE j (Lff 1 ^ ^ Lff m ^ :Lfi 1 ^ ^ :Lfi n ! OE) 2 T; ffi 1 ; : : : ; fi n g " S = ;g Note that V V T S are given identical truth values in every <p> [ LS [ :LS j T S 0 [ LS [ :LS Through the epistemic Gelfond-Lifschitz transformation which yields always an objective theory we can determine the kernels of stable expansions in a non-modal setting 9 (Under different notation, this characterization appears in [28]; cf. also Sec tion 11 in <ref> [29] </ref>): Theorem 2.8 For all normal autoepistemic theories T i) If E is a stable expansion of T then E 0 = Th (T E 0 ) (where E 0 is the kernel of E) ii) Conversely, if E = Th (T E ) then E (E) (the unique stable expansion <p> It is well-known that, in general, the extensions of T do not correspond exactly to the stable expansions of tr (T ). But when T is prerequisite-free, we have a one-to-one correspondence. Lemma 7.2 (cf. also Theorems 12.19,12.20 in <ref> [29, p.369,371] </ref>) For all prerequisite-free default theories T = hW; i: i) If E is an extension of T then E (E) (the unique stable expansion of E) is a stable expansion of tr (T ). ii) Conversely, if E is a stable expansion of tr (T ) then E 0 <p> This class is a strict subset of the queries recognizable in p 2 , although it contains some p 2 -hard queries. Moreover, we have explored some relevant subsets of DL and AEL, namely prerequisite-free DL and AEL, and everywhere-consistent AEL. Prerequisite-free DL had already received some attention, cf. <ref> [29] </ref>. It was already known that every propositional default theory can be transformed into an equivalent prerequisite-free one (M.
Reference: [30] <author> R. Moore. </author> <title> Semantical Considerations on Nonmonotonic Logics. </title> <journal> Artificial Intelligence, </journal> <volume> 25 </volume> <pages> 75-94, </pages> <year> 1985. </year>
Reference-contexts: The main contributions of this paper are the following: * We define the semantics of query expressions formulated in different nonmono tonic logics. * We prove that the minimal model semantics (and, more generally, circumscription, cf. [11]), default logic [34] and autoepistemic logic <ref> [30] </ref> cannot express all of the PTIME-recognizable properties of positive disjunctive databases; this result is surprising, because in the framework of relational databases these logics can express every p 2 -recognizable query. 3 More surprisingly, the same negative result holds for unrestricted preferential semantics, some of which are tremendously powerful (not <p> From the computational side, credulous and skeptical reasoning have been extensively studied in the literature [21, 13, 36]. 2.4 Autoepistemic logic (AEL) The language of autoepistemic logic <ref> [30] </ref> is a modal language with one modal operator L, to be read as "know" or "believe"; for an extensive treatment, cf. [28, 27]. The formulas where L does not occur are called ordinary or objective.
Reference: [31] <author> T. Przymusinski. </author> <title> On the Declarative and Procedural Semantics of Stratified Deductive Databases. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <publisher> Morgan Kaufman, </publisher> <address> Washington DC, </address> <year> 1988. </year> <month> 43 </month>
Reference-contexts: Theorem 5.8 The property P R cannot be expressed by any disjunctive logic program under the brave stable semantics. The proof can be found in Appendix A . Remark 5.9 The same negative result holds for disjunctive logic programs under the perfect model semantics <ref> [31] </ref> (which is, like stable model semantics, not a preferential semantics according to the concept that we follow here; the proof of the negative result is analogous to the proof for stable model semantics) and for extended disjunctive logic programs, under their standard answer set semantics (see [12]).
Reference: [32] <author> T. Przymusinski. </author> <title> Stable Semantics for Disjunctive Programs. </title> <journal> New Generation Computing, </journal> <volume> 9 </volume> <pages> 401-424, </pages> <year> 1991. </year>
Reference-contexts: Note that the preference relation must be fixed in advance (and independent of the syntactical form of T ). Intermediate approaches|such as the stable semantics of disjunctive logic programs <ref> [32] </ref> and the perfect model semantics [31]|do not fit into this framework. 12 In fact, S belongs to every minimal model of T + D iff D j= 9x: disease (John; x ) : Note that each database property P over D (R) corresponds to some Boolean query q : D <p> The above results can be extended also to the stable model semantics (see <ref> [32] </ref>) - which is one of the major semantics for disjunctive logic programs although it is not really a preferential semantics, but rather an hybrid between a preferential semantics and the semantics of default logic. <p> To prove this claim, let M be a stable model of P + D , that is, M 2 MM ((P + D) M ) (where (:) M is the Gelfond-Lifschitz transformation w.r.t. M ; see <ref> [32] </ref> ).
Reference: [33] <author> T. Przymusinski. </author> <title> Three-valued Nonmonotonic Formalisms and Semantics of Logic Programming. </title> <journal> Artificial Intelligence, </journal> <volume> 49 </volume> <pages> 309-344, </pages> <year> 1991. </year>
Reference-contexts: Furthermore, we instantiate T with the elements of U in order to cover different forms of universal quantification; free-variables are treated as universally quantified variables under substitutional quantification which is adopted in several logic programming and knowledge representation languages <ref> [33] </ref> while the variables which are universally quantified explicitely are interpreted as usual.
Reference: [34] <author> R. Reiter. </author> <title> A Logic for Default Reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13 </volume> <pages> 81-132, </pages> <year> 1980. </year>
Reference-contexts: The main contributions of this paper are the following: * We define the semantics of query expressions formulated in different nonmono tonic logics. * We prove that the minimal model semantics (and, more generally, circumscription, cf. [11]), default logic <ref> [34] </ref> and autoepistemic logic [30] cannot express all of the PTIME-recognizable properties of positive disjunctive databases; this result is surprising, because in the framework of relational databases these logics can express every p 2 -recognizable query. 3 More surprisingly, the same negative result holds for unrestricted preferential semantics, some of which <p> conjunct of OE iff C is a prime clause of OE. (b) for all positive databases D 1 = (U; OE 1 ), OE 1 is logically equivalent to OE iff OE fl = OE fl 1 (up to the ordering of clauses and disjuncts). 2.3 Default logic Default logic <ref> [34] </ref> is one of the best known formalizations of nonmonotonic reasoning (see [27, 29] for extensive studies of the subject). <p> Then, E is an extension of hW; i iff E = Th (W [CONS (GD (; E))). 6 The semantics of open default theories involves technical complications that are not needed in this paper; the interested reader is referred to [27] . 7 Reiter's notion of generating default <ref> [34] </ref> is defined only when S is an extension.
Reference: [35] <author> J. Schlipf. </author> <title> The Expressive Powers of Logic Programming Semantics. </title> <type> Technical Report CIS-TR-90-3, </type> <institution> Computer Science Department, University of Cincinnati, </institution> <year> 1990. </year> <note> Preliminary version in Proceedings PODS-90, pp. 196-204. To appear in Journal of Computer and System Sciences. </note>
Reference-contexts: Indeed some query languages are built on well-known nonmonotonic formalisms such as logic programming languages, circumscription and default logic <ref> [35, 8, 5] </ref>. The use of nonmonotonic formalisms as query languages is justified by their expressive power, and by their ability of defining nonmonotonic queries, such as the one illustrated above; see [5] for further motivating examples.
Reference: [36] <author> J. Stillman. </author> <title> The Complexity of Propositional Default Logic. </title> <booktitle> In Proceedings AAAI-92, </booktitle> <pages> pages 794-799, </pages> <year> 1992. </year>
Reference-contexts: From the computational side, credulous and skeptical reasoning have been extensively studied in the literature <ref> [21, 13, 36] </ref>. 2.4 Autoepistemic logic (AEL) The language of autoepistemic logic [30] is a modal language with one modal operator L, to be read as "know" or "believe"; for an extensive treatment, cf. [28, 27]. The formulas where L does not occur are called ordinary or objective.
Reference: [37] <author> L. Valiant. </author> <title> The Complexity of Enumeration and Reliability Problems. </title> <journal> SIAM J. Comp., </journal> <volume> 8 </volume> <pages> 410-421, </pages> <year> 1979. </year>
Reference-contexts: To avoid this, a notion of complexity can be adopted under which efficiency is relativized to the size of the output (besides that of the input), and a computation is feasible if it is polynomial in the combined size of the input and the output, cf. <ref> [37, 19] </ref>. Our framework might be modified in a similar way.
Reference: [38] <author> M. Vardi. </author> <title> Complexity of relational query languages. </title> <booktitle> In Proceedings 14th STOC, </booktitle> <pages> pages 137-146, </pages> <year> 1982. </year>
Reference-contexts: Query languages for retrieving information from disjunctive databases are an open area of research. In the framework of relational databases, many alternative query languages have been proposed; they have been extensively studied in the literature (cf. <ref> [38, 20, 6, 7, 2] </ref> for fundamentals and overviews) and, in particular, they have been compared to each other by characterizing their expressiveness, i.e., the class of queries that they can express. These relationships are quite well understood [2, 7]. <p> The interested reader is referred to [27] for more details. 3 Query languages for disjunctive databases Query languages for relational databases are a well-studied topic in the theory of relational databases, cf. <ref> [38, 6, 20, 2] </ref>. Informally, a query is a function that maps each relational database onto another relational database, which is considered as the result of evaluating the query. Queries are specified by the expressions of query languages; expressions can be regarded as "programs" for computing queries. <p> A query language is constituted of a set L of query expressions and a function such that for each expression E 2 L, (E) is a query (cf. <ref> [38] </ref>). The queries which compute relations, i.e. q (D) 2 D (S) 1 for all D, are of natural interest; they deduce only atomic facts from the database. <p> More precisely, for all queries q expressible in L, one considers the Turing machines that compute (an encoding of) q (D) given any (encoded) database D as an input. This view of complexity is called data complexity <ref> [38] </ref>. 10 We adopt an encoding enc () of disjunctive databases such that enc (U; OE) represents the relation symbols and the elements of U by numbers; the encoding lists the clauses of D according to some fixed ordering; U is described by its cardinality written down in unary notation. 10 <p> Following the approach in <ref> [38, 17] </ref>, we say that a database property is C-recognizable (or, in C) if, given D, deciding whether P (D) = true is in C; a query q is C-recognizable (or, in C) if, given D and a ground clause C, deciding whether C 2 q (D) is in C. <p> are constructive; they allow to transform effectively each query expressed in any of those fragments into an equivalent query expressed in any of the other fragments. (It is interesting to note that each transformation can be carried out in polynomial time.) A few comments on expression complexity and combined complexity <ref> [38] </ref> are needed. We recall that the expression (resp. combined) complexity is the complexity of evaluating a varying query over a fixed (resp. varying) database.
Reference: [39] <author> M. Vardi. </author> <title> Querying Logical Databases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 33 </volume> <pages> 142-160, </pages> <year> 1986. </year>
Reference-contexts: These relationships are quite well understood [2, 7]. The study of query languages for disjunctive databases is much less established. Work on querying incomplete databases is related; cf. [14, 1] for relations with null values, and <ref> [39] </ref> for the similar proviso of missing unique names axioms in logical databases. In these works, disjunctive information involving distinct relations as in (2) cannot be directly encoded. More importantly, these works consider only monotonic queries (in [39] the answer to a query grows monotonically with the amount of information encoded <p> incomplete databases is related; cf. [14, 1] for relations with null values, and <ref> [39] </ref> for the similar proviso of missing unique names axioms in logical databases. In these works, disjunctive information involving distinct relations as in (2) cannot be directly encoded. More importantly, these works consider only monotonic queries (in [39] the answer to a query grows monotonically with the amount of information encoded into the database; in [14, 1] queries are monotonic functions over sets of possible worlds). However, many natural queries do not easily fit into these frameworks, e.g.
Reference: [40] <author> M. Winslett. </author> <title> Updating Logical Databases. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: man or a woman" can be naturally encoded as follows: disease (John; d 1 ) _ disease (John; d 2 ) _ disease (John; d 3 ) ; (1) man (Nicky) _ woman (Nicky ) : (2) Closely related approaches to the representation of incomplete information can be found in <ref> [10, 40] </ref> , where databases can be unrestricted propositional or first-order theories. In general, disjunctive databases are better suited for implementation; their operational and computational aspects have been extensively investigated (cf. [26, 11]). Query languages for retrieving information from disjunctive databases are an open area of research.
References-found: 40

