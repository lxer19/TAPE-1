URL: http://osl.cs.uiuc.edu/Papers/dai-chapter98.ps
Refering-URL: http://osl.cs.uiuc.edu/Papers/Agents.html
Root-URL: http://www.cs.uiuc.edu
Title: 12 Concurrent Programming for Distributed Artificial Intelligence To appear in Multiagent Systems: A Modern Approach
Author: DAI, Ed. Gerhard Weiss, MIT Press, . Gul A. Agha and Nadeem Jamali 
Note: There are  
Date: 12.1 Introduction  
Abstract: The increasing performance and decreasing cost of processors and computer networks has continued to fuel an explosion of interest in solving larger problems using concurrent computing. In particular, agent-based programming has emerged as a promising paradigm which may help realize Artificial Intelligence through distributed problem solving. Agents are persistent and goal directed entities that may move between hosts in response to changes in requirements such as security and efficiency, and that would normally be limited in the computational resources they may employ in pursuing their goals. Such resources include processor time, memory, and network bandwidth. A key challenge in concurrent computing is the difficulty of programming parallel and distributed architectures. Many models of concurrency are rather low-level. For example, shared variable models often violate data encapsulation, an essential feature for modular software development. A promising approach to address this difficulty is the use of concurrent objects in a reflective architecture. In particular, actors provide a formal model for building and representing the behavior of concurrent objects and thus serve as a foundation for concurrent object-oriented programming. The definition of actors corresponds to that of agents given in Chapter 1. Actors are autonomous, interacting computing elements, which encapsulate a behavior (data and procedure) as well as a process. Different actors carry out their actions asynchronously and communicate with each other by sending messages. The basic mechanism for communication is also asynchronous and buffered; however, other forms of message passing can be defined in the context of the model. Finally, actors may be dynamically created and reconfigured, which provides considerable flexibility in organizing concurrent activity. Actors are a model for specifying coordination in a distributed system. Because the internal behavior of an actor is encapsulated and cannot be observed directly, the Actor model supports heterogeneous, variable grained objects. Specifically, the behavior of individual actors may be defined using any programming language. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: order to determine available resources and relate such resources to the agents' own state; thus the use of reflection can support evolving resource utilization strategies. 4 Concurrent Programming for Distributed Artificial Intelligence 12.3 Actors Actors are self-contained, interactive, autonomous components of a computing system that communicate by asynchronous message passing <ref> [1, 5] </ref>.
Reference: 2. <author> G. Agha, S. Frtlund, R. Panwar, and D. Sturman. </author> <title> A linguistic framework for dynamic composition of dependability protocols. </title> <booktitle> In Proceedings of the 3rd IFIP Working Conference on Dependable Computing for Critical Applications, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: Mailbox actors buffer incoming messages until they can be processed. Suppose we want to ensure the availability of some agent where its absence may be catastrophic. We may replicate the service to ensure availability when the original server fails. In the following example adapted from <ref> [2] </ref>, we will see how such a replication service may be provided. Example 12.6 Replicated Service We can use meta-actors called dispatchers to trap out-going messages, and mail-queue meta-actors to trap in-coming messages, for every actor.
Reference: 3. <author> G. Agha, C. Houck, and R. Panwar. </author> <title> Distributed execution of actor systems. </title> <editor> In D. Gelernter, T. Gross, A. Nicolau, and D. Padua, editors, </editor> <booktitle> Languages and Compilers for Parallel Computing, </booktitle> <volume> number 589, </volume> <pages> pages 1-17. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A precursor to true migration is the ability to create an actor at a remote site. The Actor programming language Hal <ref> [3] </ref> uses annotations to govern actor placement at creation. Example 12.2 Distributed Filtered Search Consider a variation of the Filtered Search example we saw earlier, where the tree is distributed over many nodes. New actors for searching the subtrees are created at nodes hosting the roots of the respective subtrees. <p> (num-children tree) (list (content tree)) filter)))) (map (lambda (x) (let ((f (newActor FILTERSEARCH ()) @ (host-of x))) (send f jc x))) (children tree)) (ready FILTERSEARCH ()))))) 2 A similar construct, called trojan-multisend, sends new actors to a collection of remote locations, along with the first messages that each will process <ref> [3] </ref>. True migration must allow an actor to migrate to a different node while it is in the middle of its execution. We will describe a specific way of providing this functionality.
Reference: 4. <author> G. Agha, I. A. Mason, S. F. Smith, and C. L. Talcott. </author> <title> A foundation for actor computation. </title> <journal> Journal of Functional Programming, </journal> <note> 1996. to appear. </note>
Reference-contexts: For example, the call-by-value -calculus is extended in <ref> [4] </ref>. Instantaneous snapshots of actor systems are called configurations; actor computation is defined by a transition relation on configurations. <p> ; &lt;v 0 ( v 1 &gt; ffff ff ; m ffff 7! ff ffff 0 ffff 7! ff ; m ffff [(FV (v)Dom (ff)) 12.3.2 Equivalence of Actor Systems Based on a slight variant of the transition system described above, a rigorous theory of actor systems is developed in <ref> [4] </ref>. Specifically, various notions of testing equivalence on actor expressions and configurations are designed and studied. The model provides fairness, namely that any enabled transition eventually fires. Thus fairness implies three things. First, every busy actor eventually makes progress.
Reference: 5. <author> Gul Agha. </author> <title> Concurrent Object-Oriented Programming. </title> <journal> Communications of the ACM, </journal> <volume> 33(9) </volume> <pages> 125-141, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: order to determine available resources and relate such resources to the agents' own state; thus the use of reflection can support evolving resource utilization strategies. 4 Concurrent Programming for Distributed Artificial Intelligence 12.3 Actors Actors are self-contained, interactive, autonomous components of a computing system that communicate by asynchronous message passing <ref> [1, 5] </ref>. <p> Actors thus provide an abstract level at which to program and reason about agents. Synchronous communication and other more complex communication mechanisms can be built on top of the basic asynchronous communication mechanism <ref> [5] </ref>. Moreover, as we will see later in this chapter, high level commit protocols can be used for agent-level synchronization. 12.4 Representing Agents as Actors In developing multi-agent systems, a key issue to be addressed is mobility.
Reference: 6. <author> Gregory R. Andrews. </author> <title> Concurrent Programming: </title> <booktitle> Principles and Practice. </booktitle> <address> Benjamin/Cummings, </address> <year> 1991. </year>
Reference-contexts: A detailed treatment of these can be found in <ref> [6] </ref>. In the shared variable paradigm, processes communicate by writing to and reading from memory locations shared by them. Although the apparent simplicity of this paradigm is appealing, it violates principles of abstraction and encapsulation, making it difficult to implement large systems reliably.
Reference: 7. <author> C. J. Callsen and G. A. Agha. </author> <title> Open Heterogeneous Computing in ActorSpace. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <pages> pages 289-300, </pages> <year> 1994. </year>
Reference-contexts: In other words, we need support for a Yellow Pages service to find addresses of agents of a given type. Traders in object request broker architecture perform a similar function. The ActorSpace model allows an abstract specification of a group of actors <ref> [7] </ref>. An actorspace associates an actor with specific attributes; the sender of a message specifies a destination pattern which is pattern-matched against the attributes of actors in the actorspace. The model may also be seen as providing a distributed version of the blackboard [8] system for broadcast communication.
Reference: 8. <author> L. D. Erman, F. Hayes-Roth, V. R. Lesser, and R. D. Reddy. </author> <title> The hearsay-ii speech understanding system: Integrating knowledge to resolve uncertainty. </title> <journal> ACM Computing Surveys, </journal> <volume> 12(2), </volume> <year> 1980. </year>
Reference-contexts: An actorspace associates an actor with specific attributes; the sender of a message specifies a destination pattern which is pattern-matched against the attributes of actors in the actorspace. The model may also be seen as providing a distributed version of the blackboard <ref> [8] </ref> system for broadcast communication. A simple analogy whose membership may dynamically change. 12.6 Related Work 27 with set theory illustrates the difference between naming in actors and actorspaces.
Reference: 9. <author> Tim Finin, Yannis Labrou, and James Mayfield. </author> <title> Kqml as an agent communication language. </title> <editor> In Jeffrey M. Bradshaw, editor, </editor> <booktitle> Software Agents, </booktitle> <pages> pages 291-316. </pages> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: Facilitators keeping track of capabilities of agents implement a federated system of communication providing a pattern-based 28 Concurrent Programming for Distributed Artificial Intelligence message sending facility. The Knowledge Query and Manipulation Language (KQML) <ref> [9, 21] </ref>, described in detail in Chapter 2, is a message-handling protocol that aims to provide an effective platform for agent communication by addressing fundamental components of (i) a common language, (ii) a common understanding of exchange knowledge, and (iii) an ability to exchange the two.
Reference: 10. <author> S. Frtlund and G. Agha. </author> <title> A language framework for multi-object coordination. </title> <booktitle> In Proceedings of ECOOP 1993, </booktitle> <volume> volume 707. </volume> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: By providing a language abstraction, called synchronizer to express these two types of constraints, we are able to show that the task of distributed programming may be 24 Concurrent Programming for Distributed Artificial Intelligence further simplified <ref> [10] </ref>. Because synchronizers may be superimposed, and may be dynamically added or removed, implementing such a system efficiently proves to be a fairly challenging but is nevertheless feasible. The following example is due to Frolund [11]. Example 12.7 Coordinating Robots Consider two coordinating robots.
Reference: 11. <author> Svend Frtlund. </author> <title> Coordinating Distributed Objects: An Actor-Based Approach to Synchronization. </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: Because synchronizers may be superimposed, and may be dynamically added or removed, implementing such a system efficiently proves to be a fairly challenging but is nevertheless feasible. The following example is due to Frolund <ref> [11] </ref>. Example 12.7 Coordinating Robots Consider two coordinating robots. Each robot has an arm and a hand, and it can grab a widget with its hand, and lift and move it using its arm.
Reference: 12. <author> L. Gasser, C. Braganza, and N. Herman. Mace: </author> <title> A flexible testbed for distributed ai research. </title> <editor> In M. N. Huhns, editor, </editor> <booktitle> Distributed Artificial Intelligence, </booktitle> <pages> pages 119-152. </pages> <publisher> Pitman - Morgan Kaufmann, </publisher> <year> 1987. </year>
Reference-contexts: We will call a system providing such linguistic and system level support an agent architecture. One of the earliest testbeds for building agent architectures was provided by the MACE system <ref> [12] </ref>, which executed in a distributed memory multiprocessing environment. Based on the experience of this research, Les Gasser [13] outlined the avenues of cooperation between the areas of DAI and concurrent programming, and how the two fields can be brought closer to each other.
Reference: 13. <editor> Les Gasser and Jean-Pierre Briot. </editor> <booktitle> Object-based concurrent programming and distributed artificial intelligence. </booktitle> <editor> In Nicholas M. Avouris and Les Gasser, editors, </editor> <booktitle> Distributed Artificial Intelligence: Theory and Praxis, </booktitle> <pages> pages 81-107. </pages> <publisher> Kluwer Academic, </publisher> <year> 1992. </year>
Reference-contexts: We will call a system providing such linguistic and system level support an agent architecture. One of the earliest testbeds for building agent architectures was provided by the MACE system [12], which executed in a distributed memory multiprocessing environment. Based on the experience of this research, Les Gasser <ref> [13] </ref> outlined the avenues of cooperation between the areas of DAI and concurrent programming, and how the two fields can be brought closer to each other. The current proposal draws part of its inspiration from the insights obtained by that research.
Reference: 14. <author> Michael R. Genesereth. </author> <title> An agent-based framework for interoperability. </title> <editor> In Jeffrey M. Bradshaw, editor, </editor> <booktitle> Software Agents, </booktitle> <pages> pages 317-346. </pages> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: The current proposal draws part of its inspiration from the insights obtained by that research. More recently, an actor-based DAI system called InfoSleuth [35] has been developed at MCC. Genesereth <ref> [14] </ref> defines an agent as an entity that is able to communicate correctly in an agent communication language, thereby emphasizing the expressiveness of such a language.
Reference: 15. <author> Robert Gray, David Kotz, Saurab Nog, Daniela Rus, and George Cybenko. </author> <title> Mobile agents for mobile computing. </title> <type> Technical Report PCS-TR96-285, </type> <institution> Department of Computer Science, Dartmouth College, </institution> <address> Hanover, NH 03755, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: A variation of the problem appears when we are dealing with systems where "failure" is the norm, such as distributed systems using wireless communications where the network connectivity is essentially dynamic <ref> [15] </ref>. When introducing mechanisms for fault-tolerance, it is important to separate the fault-tolerance aspects of the code from the application for reasons of modularity and reusability. In this section we will discuss an abstraction over the primitive Actor model called interaction policies.
Reference: 16. <author> Robert S. Gray. </author> <title> A flexible and secure mobile-agent system. </title> <editor> In Mark Diekhans and Mark Roseman, editors, </editor> <booktitle> Proceedings of the Fourth Annual Tcl/Tk Workshop (TCL '96), </booktitle> <address> Monterey, California, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: This platform is based on a remote programming paradigm that uses Mobile Agents (MA) that can migrate from a client to a remote server and execute remotely on behalf of the client. Cybenko's group at Dartmouth <ref> [16] </ref> addresses the issues in implementing mobile agents in an environment consisting of computers, which are often disconnected from the network.
Reference: 17. <author> Crystaliz Inc., </author> <title> General Magic Inc., GMD FOKUS, and IBM Corporation. Mobile 12.9 References 33 Agent Facility Specification. </title> <type> Technical report, </type> <institution> Object Management Group, </institution> <month> June </month> <year> 1997. </year>
Reference-contexts: By providing Actor primitives in the form of a library, the Actor Foundry [20] developed at OSL attempts to put a 12.7 Conclusions 29 discipline for system development in Java. The Mobile Agent Facility Specification by the Object Management Group <ref> [17] </ref> makes a case for standardizing areas of mobile agent technology to promote interoperability. These include agent management, transfer, naming (agent as well as agent system), agent system types and location syntax. Telescript [34] addresses using a public network as a platform on which third-party developers can build their applications.
Reference: 18. <author> W. Kim. Thal: </author> <title> An Actor System for Efficient and Scalable Concurrent Computing. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1997. </year>
Reference-contexts: The system must provide means for agents serving the same interest to cooperate, or otherwise not impede each other's progress. 12.4.1 Mobility of Actors Because Actor semantics is location transparent, systems based on the model (e.g., <ref> [18] </ref>), do not allow actors to reason about their locations. This limits the use of migration to system level decisions where only system level goals such as load balancing can be considered.
Reference: 19. <author> Michael Kolb. </author> <title> A cooperation language. </title> <booktitle> In Proceedings: First International Conference on Multi-Agent Systems, </booktitle> <pages> pages 233-238, </pages> <address> San Francisco, CA, June 1995. </address> <publisher> AAAI, AAAI Press, MIT Press. </publisher>
Reference-contexts: Munindar Singh [28] has developed a theoretical framework for reasoning about intentions, know-how and communications. A multi-level architecture for Multi-Agent Systems is described by Werner [33] where a meta-architecture is defined to formalize users', programmers' or designers' interactions with an open system. Michael Kolb's CooL (Cooperation Language) <ref> [19] </ref> provides a higher level of abstraction with respect to agent design than the actor paradigm, but it gives a knowledge and execution perspective on agents rather than employing mental states.
Reference: 20. <author> Open Systems Laboratory. </author> <title> The actor foundry: A java-based actor programming environment. </title> <note> Available for download at http://www-osl.cs.uiuc.edu/ ~astley/foundry.html. </note>
Reference-contexts: This separation of object and thread also creates a problem for migration. By providing Actor primitives in the form of a library, the Actor Foundry <ref> [20] </ref> developed at OSL attempts to put a 12.7 Conclusions 29 discipline for system development in Java. The Mobile Agent Facility Specification by the Object Management Group [17] makes a case for standardizing areas of mobile agent technology to promote interoperability.
Reference: 21. <author> Yannis Labrou and Tim Finin. </author> <title> A proposal for a new kqml specification. </title> <type> Technical Report CS-97-03, </type> <institution> University of Maryland Baltimore County, </institution> <month> February </month> <year> 1997. </year>
Reference-contexts: Facilitators keeping track of capabilities of agents implement a federated system of communication providing a pattern-based 28 Concurrent Programming for Distributed Artificial Intelligence message sending facility. The Knowledge Query and Manipulation Language (KQML) <ref> [9, 21] </ref>, described in detail in Chapter 2, is a message-handling protocol that aims to provide an effective platform for agent communication by addressing fundamental components of (i) a common language, (ii) a common understanding of exchange knowledge, and (iii) an ability to exchange the two.
Reference: 22. <author> P. Maes. </author> <title> Computational reflection. </title> <type> Technical Report 87-2, </type> <institution> Vrije University. Artificial Intelligence Laboratory, </institution> <year> 1987. </year>
Reference-contexts: Moreover, because an agent may execute in new contexts which do not satisfy its requirements, the agent may need to systematically customize behavior of the underlying execution environment. Such agent requirements include security, rendering software, device drivers, etc. A model of computational reflection <ref> [22] </ref> provides a formal basis for an agent to have a representation of its own behavior. <p> For example, if the agents encoding an 12.5 Agent Ensembles 19 application are assigning their own priorities and schedules, it is not very feasible to schedule them in order to satisfy real-time requirements. Customization of the execution context is accomplished using a technique called reflection <ref> [22] </ref>. Reflection allows an application to monitor the execution of the underlying system and to modify it dynamically (Figure 12.2).
Reference: 23. <author> G. Plotkin. </author> <title> Call-by-name, call-by-value and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference-contexts: The notion of equivalence is defined by adding an observable distinguished event to the set of transitions. This technique is a variant of operational equivalence defined in <ref> [23] </ref>. Two actor expressions may be plugged into a context to see if the event occurs in one or the other case. Two expressions are considered equivalent if they have the same observations over all possible contexts.
Reference: 24. <author> S. Ren and G. Agha. RTSynchronizers: </author> <title> Language support for real-time specifications in distributed systems. </title> <booktitle> In Proceedings of ACM SIGPLAN 1995 Workshop on Languages, Compilers, and Tools for Real-time Systems, </booktitle> <pages> pages 55-64, </pages> <year> 1995. </year>
Reference-contexts: At the system level, such redundant activity could be avoided by using appropriate synchronization constraints to disable requests for an activity following the first one. Example 12.8 Real-Time Constraints RTsynchronizers <ref> [24] </ref> offer one way of implementing real-time constraints using an abstraction similar to that for the declarative coordination constraints discussed earlier. RTsynchronizers are objects that enforce real-time constraints by constraining whether or not messages of a certain type can be delivered to an actor at a certain point in time.
Reference: 25. <author> J. Searle. </author> <title> Speech Acts. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1969. </year>
Reference: 26. <editor> M.J. Shaw and M.S. Fox. </editor> <booktitle> Distributed artificial intelligence for group decision support. Decision Support Systems, </booktitle> <volume> 9 </volume> <pages> 349-367, </pages> <year> 1993. </year>
Reference-contexts: Coordination can be viewed from three different perspectives: the information content, the exercise of control, and the coordination mechanisms <ref> [26] </ref>. The information used for coordination can be data, new facts discovered, partial solution/plan, preferences, or constraints. What one would like to develop are reusable abstractions for coordination which allow agents to play a richer variety of roles.
Reference: 27. <author> Yoav Shoham. </author> <title> An overview of agent-oriented programming. </title> <editor> In Jeffrey M. Bradshaw, editor, </editor> <booktitle> Software Agents, </booktitle> <pages> pages 271-290. </pages> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: The language primitives, called performatives, define actions permissible to agents in communication. There are special agents called facilitators that provide support in identifying agents and services, brokering agreements, etc. The term Agent Oriented Programming has been coined by Shoham <ref> [27] </ref> to refer to a specialization of Object Oriented Programming (as in actor programming), where the state of an actor (now called an agent) contains beliefs, capabilities, choices and similar mental notions, and the computation consists of agents' social interactions with each other, such as informing, offering, accepting, rejecting, competing, assisting,
Reference: 28. <author> Munindar P. Singh. </author> <title> Multiagent Systems. </title> <booktitle> Number 799 in Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: A uniform currency is used to pay for the cost of these resources. The behavior of an actor may be interpreted in a suitable framework for agents, e.g., the belief, desire, intent model <ref> [28] </ref>. In any event, agents are persistent, have relatively long-lived goals describing the functional aspect of what they are doing, and have computational engines which serve as mechanisms for achieving these goals. These computational engines include a resource utilization strategy. <p> The latter idea is derived from speech act literature (e.g.[25]) which categorizes speech in similar ways. Each agent runs a loop in which it first reads the current message, updating its mental state, and then executes the commitments for the current time. Munindar Singh <ref> [28] </ref> has developed a theoretical framework for reasoning about intentions, know-how and communications. A multi-level architecture for Multi-Agent Systems is described by Werner [33] where a meta-architecture is defined to formalize users', programmers' or designers' interactions with an open system.
Reference: 29. <author> D. Sturman and G Agha. </author> <title> A protocol description language for customizing failure semantics. </title> <booktitle> In The 13th Symposium on Reliable Distributed Systems, Dana Point, </booktitle> <address> California. </address> <publisher> IEEE, </publisher> <month> October </month> <year> 1994. </year>
Reference-contexts: Such customization of an individual actor's mail system may be further limited only for the duration of an interaction. Sturman and Agha have developed a language for describing and implementing interaction policies <ref> [29, 30] </ref>; using this language, a protocol abstraction may be instantiated by specifying a particular group of actors and other initialization parameters.
Reference: 30. <author> Daniel C. Sturman. </author> <title> Modular Specification of Interaction Policies in Distributed Computing. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Such customization of an individual actor's mail system may be further limited only for the duration of an interaction. Sturman and Agha have developed a language for describing and implementing interaction policies <ref> [29, 30] </ref>; using this language, a protocol abstraction may be instantiated by specifying a particular group of actors and other initialization parameters.
Reference: 31. <author> C. Tomlinson, W. Kim, M. Schevel, V. Singh, B. Will, and G. Agha. Rosette: </author> <title> An object oriented concurrent system architecture. </title> <journal> Sigplan Notices, </journal> <volume> 24(4) </volume> <pages> 91-93, </pages> <year> 1989. </year>
Reference-contexts: Specifically, this allows use of reflection enabling an agent to have a continuous interaction with the environment to determine available resources and relate it to its own state to provide evolving resource consumption strategies. In Rosette <ref> [31] </ref>, a commercially developed object-oriented implementation of an Actor architecture, the architecture has an interface layer and a system environment.
Reference: 32. <author> N. Venkatasubramanian and C. L. Talcott. </author> <title> Reasoning about Meta Level Activities in Open Distributed Systems. </title> <booktitle> In Principles of Distributed Computing, </booktitle> <year> 1995. </year>
Reference-contexts: Because the Actor model allows the state of the computation to be modeled directly, the computation environment called the meta-level architecture can be represented at an appropriate level of abstraction using the same base language <ref> [32] </ref>. Specifically, this allows use of reflection enabling an agent to have a continuous interaction with the environment to determine available resources and relate it to its own state to provide evolving resource consumption strategies. <p> in accordance with a set of policies. tors has made progress on the problem of reasoning in the presence of meta-actors, specifically, by defining a reasoning system and using it to prove the correctness of a meta-level algorithm for taking a global snapshot of a running distributed system of actors <ref> [32] </ref>. 12.5.3 Coordination Dynamic, virtual organization of agents can be accomplished by using coordination mechanisms to express a wide variety of interactions. Coordination is a key design concern for a multi-agent system.
Reference: 33. <author> Eric Werner. </author> <title> The design of multi-agent systems. </title> <editor> In Eric Werner and Yves Demazeau, editors, </editor> <booktitle> Decentralized A.I. 3. Proceedings of the Third European Workshop on Modelling Autonomous Agents in a Multi- Agent World, </booktitle> <address> Kaiserslautern, Germany, </address> <pages> pages 3-28. </pages> <publisher> North-Holland, </publisher> <month> August </month> <year> 1992. </year>
Reference-contexts: Munindar Singh [28] has developed a theoretical framework for reasoning about intentions, know-how and communications. A multi-level architecture for Multi-Agent Systems is described by Werner <ref> [33] </ref> where a meta-architecture is defined to formalize users', programmers' or designers' interactions with an open system.
Reference: 34. <author> James E. White. </author> <title> Mobile agents. </title> <editor> In Jeffrey M. Bradshaw, editor, </editor> <booktitle> Software Agents, </booktitle> <pages> pages 437-472. </pages> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: The Mobile Agent Facility Specification by the Object Management Group [17] makes a case for standardizing areas of mobile agent technology to promote interoperability. These include agent management, transfer, naming (agent as well as agent system), agent system types and location syntax. Telescript <ref> [34] </ref> addresses using a public network as a platform on which third-party developers can build their applications. This platform is based on a remote programming paradigm that uses Mobile Agents (MA) that can migrate from a client to a remote server and execute remotely on behalf of the client.
Reference: 35. <author> D. Woelk, M. Huhns, and C. Tomlinson. </author> <title> InfoSleuth agents: The next generation of active objects. </title> <journal> Object Magazine, </journal> <month> July/August </month> <year> 1995. </year>
Reference-contexts: The current proposal draws part of its inspiration from the insights obtained by that research. More recently, an actor-based DAI system called InfoSleuth <ref> [35] </ref> has been developed at MCC. Genesereth [14] defines an agent as an entity that is able to communicate correctly in an agent communication language, thereby emphasizing the expressiveness of such a language.
References-found: 35

