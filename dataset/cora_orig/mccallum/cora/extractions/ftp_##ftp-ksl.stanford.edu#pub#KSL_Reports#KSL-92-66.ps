URL: ftp://ftp-ksl.stanford.edu/pub/KSL_Reports/KSL-92-66.ps
Refering-URL: http://ksl-web.stanford.edu/KSL_Abstracts/KSL-92-66.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: levy@research.att.com  (fikes@cs.stanford.edu)  (sagiv@cs.huji.ac.il)  
Title: Speeding Up Inferences in Large Knowledge Bases  
Author: Alon Y. Levy Richard E. Fikes Yehoshua Sagiv 
Address: 600 Mountain Ave., Room 2C-406, Murray Hill, NJ, 07974  701 Welch Road, Bldg. C Palo Alto, California 94304  Jerusalem, Israel  
Affiliation: AT&T Bell Laboratories  KSL, Stanford University  Dept. of Computer Science Hebrew University  
Abstract: Speeding up inferences made from large knowledge bases is a key to scaling up AI systems. The query-tree is a powerful tool for analyzing KBs containing Horn rules which takes into consideration the semantics of interpreted predicates that appear in the rules (e.g., order and sort predicates). It is a finite structure that encodes all derivations of a given set of queries and tells us which rules and ground facts can be used in deriving answers to the queries and which can be ignored. This paper investigates experimentally the impact of several methods of employing the query-tree on speeding up inference. Speedups are obtained by creating specialized indices that point only to relevant facts in the KB and by following only sequences of rule applications that are allowed by the query-tree. The experiments show that significant speedups (often orders of magnitude) are obtained by employing the query-tree. Moreover, we show that the speedups improve as the size of the KB grows, indicating that the methods will scale up to large KBs. Keywords: Empirical results, deduction, algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Maurice Bruynooghe, Danny De-Schreye, and B. Krekels. </author> <title> Compiling control. </title> <journal> Journal of Logic Programming, </journal> <pages> pages (6) 135-162, </pages> <year> 1989. </year>
Reference-contexts: As a result, it tells us which rules and ground facts can be used in deriving answers to the given queries and which rules and ground facts can be ignored. The query-tree is a member of a family of static-analysis tools, that includes compilation graphs <ref> [1] </ref>, problem-state graphs [2], connection graphs [4, 12], definability graphs [15], rule-goal graphs [16] and fold/unfold transformations [14]. <p> In our experiments, the speedups were obtained by creating new indices on the ground facts in the KB. In contrast, previous experimental work (e.g., EBL [9] and compilation graphs <ref> [1] </ref>) focussed on the utility of compressing sequences of rules. The query-tree and specialized indices are built with respect to a specific set of queries, and we have significant flexibility in specifying this set.
Reference: [2] <author> Oren Etzioni. </author> <title> Acquiring search-control knowledge via static analysis. </title> <journal> Artificial Intelligence, </journal> <volume> 62, </volume> <year> 1993. </year>
Reference-contexts: As a result, it tells us which rules and ground facts can be used in deriving answers to the given queries and which rules and ground facts can be ignored. The query-tree is a member of a family of static-analysis tools, that includes compilation graphs [1], problem-state graphs <ref> [2] </ref>, connection graphs [4, 12], definability graphs [15], rule-goal graphs [16] and fold/unfold transformations [14].
Reference: [3] <author> Russell Greiner. </author> <title> Finding optimal derivation strategies in a redundant knowledge base. </title> <journal> Artificial Intelligence, </journal> <volume> 50(1) </volume> <pages> 95-116, </pages> <year> 1991. </year>
Reference-contexts: An interesting direction for future research is to combine the query-tree 12 with other optimization methods. For example, Greiner <ref> [3] </ref> and Smith [13] addressed the issue of finding optimal strategies for rule and goal-ordering. In doing so, they used a tree-like representation of the possible derivations. The query-tree can be used to extend their results to KBs with recursion and to incorporate the semantics of interpreted predicates.
Reference: [4] <author> Robert Kowalski. </author> <title> A proof procedure using connection graphs. </title> <journal> Journal of the ACM, </journal> <pages> pages 22(4): 572-595, </pages> <year> 1975. </year>
Reference-contexts: The query-tree is a member of a family of static-analysis tools, that includes compilation graphs [1], problem-state graphs [2], connection graphs <ref> [4, 12] </ref>, definability graphs [15], rule-goal graphs [16] and fold/unfold transformations [14]. The main characteristic distinguishing the query-tree from other structures is completeness in the presence of recursion (but not function symbols) 1 and some interpreted predicates (e.g., order constraints (&lt;, =, 6= and ) and sort constraints).
Reference: [5] <author> Alon Y. Levy. </author> <title> Irrelevance Reasoning in Knowledge Based Systems. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, </institution> <address> CA, </address> <year> 1993. </year>
Reference-contexts: The details of the construction of the query-tree and the computation of the labels are described in <ref> [7, 5] </ref>. The following is a simple example that illustrates the query-tree. Example 2.1: The base predicates step and bigstep describe links between points in a space. The derived predicate path denotes the paths that can be constructed by composing single links. <p> See <ref> [5] </ref> for details. 6 The sort predicates meat, beef , and dessert are used as constraints (dessert is disjoint from the other two). The relation dish consists of the available dishes and their prices. The query-tree for dessertMeal is shown in Figure 3.
Reference: [6] <author> Alon Y. Levy, Inderpal Singh Mumick, Yehoshua Sagiv, and Oded Shmueli. </author> <title> Equivalence, query-reachability and satisfiability in datalog extensions. </title> <booktitle> In Proceedings of the Twelfth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> Washington D.C., </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Speeding up inferences made from large knowledge bases (KBs) is a key to scaling up artificial intelligence systems. The query-tree [7, 8] is a powerful tool for analyzing KBs containing Horn clause rules as well as more expressive extensions <ref> [6] </ref>. It is a finite AND-OR tree that encodes all derivations of a given set of queries using the rules of the KB.
Reference: [7] <author> Alon Y. Levy and Yehoshua Sagiv. </author> <title> Constraints and redundancy in datalog. </title> <booktitle> In The Proceedings of the Eleventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> San Diego, CA., </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Speeding up inferences made from large knowledge bases (KBs) is a key to scaling up artificial intelligence systems. The query-tree <ref> [7, 8] </ref> is a powerful tool for analyzing KBs containing Horn clause rules as well as more expressive extensions [6]. It is a finite AND-OR tree that encodes all derivations of a given set of queries using the rules of the KB. <p> The details of the construction of the query-tree and the computation of the labels are described in <ref> [7, 5] </ref>. The following is a simple example that illustrates the query-tree. Example 2.1: The base predicates step and bigstep describe links between points in a space. The derived predicate path denotes the paths that can be constructed by composing single links. <p> Property 1 implies 5 the following corollary. 5 Technically, we have to assume that all the nodes of the query tree are reachable from the root; this detail is taken care of in <ref> [7] </ref>. 5 Property 2 A rule is relevant to the given query only if it appears in the query tree. Similarly, a ground fact is relevant only if it matches some goal node of the query tree and also satisfies the constraint label of that node.
Reference: [8] <author> Alon Y. Levy and Yehoshua Sagiv. </author> <title> Exploiting irrelevance reasoning to guide problem solving. </title> <booktitle> In Proceedings of the 13th International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 138-144, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Speeding up inferences made from large knowledge bases (KBs) is a key to scaling up artificial intelligence systems. The query-tree <ref> [7, 8] </ref> is a powerful tool for analyzing KBs containing Horn clause rules as well as more expressive extensions [6]. It is a finite AND-OR tree that encodes all derivations of a given set of queries using the rules of the KB.
Reference: [9] <author> Steve Minton. </author> <title> Quantitative results concerning the utility of explanation based learning. </title> <booktitle> In Proceedings of the Seventh National Conference on Artificial Intelligence, </booktitle> <year> 1988. </year>
Reference-contexts: In our experiments, the speedups were obtained by creating new indices on the ground facts in the KB. In contrast, previous experimental work (e.g., EBL <ref> [9] </ref> and compilation graphs [1]) focussed on the utility of compressing sequences of rules. The query-tree and specialized indices are built with respect to a specific set of queries, and we have significant flexibility in specifying this set.
Reference: [10] <author> Irma S. Rombauer and Marion Rombauer-Becker. </author> <title> Joy of Cooking. </title> <publisher> Bobbs Merrill Company Inc., </publisher> <address> N.Y.C., N.Y, </address> <year> 1975. </year>
Reference-contexts: Examples 1 & 2 use the rules given above in Example 2.1. Examples 3-6 are taken from a travel knowledge base (using real airline data). Examples 7-8 use a KB describing wines and dishes and compatibility between them (gleaned from <ref> [10] </ref>), while the last two examples use a KB describing relationships between students, advisors, and institutions (using a database of Ph.D. grad-the backward chainer of Epikit, and the speedups attained there were even better than those reported here. In the experiments, we tested several rule and goal orderings.
Reference: [11] <author> Stuart Russell. </author> <title> The complete guide to MRS. </title> <type> Technical Report KSL-85-12, </type> <institution> Knowledge Systems Laboratory, Department of Computer Science, Stanford University, </institution> <address> CA, </address> <year> 1985. </year>
Reference-contexts: Experimental Results The impact of the savings achieved by using the query-tree was tested using a depth-first backward chainer on Horn clause rules. 7 Given a knowledge base 7 The performance of the backward chainer used in the experiments compared favorably with that of Epikit (a commercial implementation of MRS <ref> [11] </ref>).
Reference: [12] <author> Susan Sickel. </author> <title> A search technique for clause interconnectivity graphs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-25(8):823-835, </volume> <year> 1976. </year>
Reference-contexts: The query-tree is a member of a family of static-analysis tools, that includes compilation graphs [1], problem-state graphs [2], connection graphs <ref> [4, 12] </ref>, definability graphs [15], rule-goal graphs [16] and fold/unfold transformations [14]. The main characteristic distinguishing the query-tree from other structures is completeness in the presence of recursion (but not function symbols) 1 and some interpreted predicates (e.g., order constraints (&lt;, =, 6= and ) and sort constraints).
Reference: [13] <author> David Smith. </author> <title> Controlling Inference. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, </institution> <address> CA, </address> <year> 1986. </year>
Reference-contexts: An interesting direction for future research is to combine the query-tree 12 with other optimization methods. For example, Greiner [3] and Smith <ref> [13] </ref> addressed the issue of finding optimal strategies for rule and goal-ordering. In doing so, they used a tree-like representation of the possible derivations. The query-tree can be used to extend their results to KBs with recursion and to incorporate the semantics of interpreted predicates.
Reference: [14] <author> Donald A. Smith and Timothy J. Hickey. </author> <title> Partial evaluation of a CLP language. </title> <booktitle> In Proceedings of the International Symposium on Logic Programming, </booktitle> <pages> pages 119-138, </pages> <year> 1990. </year>
Reference-contexts: The query-tree is a member of a family of static-analysis tools, that includes compilation graphs [1], problem-state graphs [2], connection graphs [4, 12], definability graphs [15], rule-goal graphs [16] and fold/unfold transformations <ref> [14] </ref>. The main characteristic distinguishing the query-tree from other structures is completeness in the presence of recursion (but not function symbols) 1 and some interpreted predicates (e.g., order constraints (&lt;, =, 6= and ) and sort constraints).
Reference: [15] <author> Devika Subramanian. </author> <title> A Theory of Justified Reformulations. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, </institution> <address> CA, </address> <year> 1989. </year>
Reference-contexts: The query-tree is a member of a family of static-analysis tools, that includes compilation graphs [1], problem-state graphs [2], connection graphs [4, 12], definability graphs <ref> [15] </ref>, rule-goal graphs [16] and fold/unfold transformations [14]. The main characteristic distinguishing the query-tree from other structures is completeness in the presence of recursion (but not function symbols) 1 and some interpreted predicates (e.g., order constraints (&lt;, =, 6= and ) and sort constraints).
Reference: [16] <author> Jeffery D. Ullman. </author> <title> Principles of Database and Knowledge-base Systems, Volumes I, II. </title> <publisher> Computer Science Press, </publisher> <address> Rockville MD, </address> <year> 1989. </year> <month> 14 </month>
Reference-contexts: The query-tree is a member of a family of static-analysis tools, that includes compilation graphs [1], problem-state graphs [2], connection graphs [4, 12], definability graphs [15], rule-goal graphs <ref> [16] </ref> and fold/unfold transformations [14]. The main characteristic distinguishing the query-tree from other structures is completeness in the presence of recursion (but not function symbols) 1 and some interpreted predicates (e.g., order constraints (&lt;, =, 6= and ) and sort constraints).
References-found: 16

