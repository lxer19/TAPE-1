URL: http://www-cad.eecs.berkeley.edu/HomePages/stcheng/pub/phd.ps.gz
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/stcheng/publish.html
Root-URL: http://www.cs.berkeley.edu
Title: Compilation, Synthesis, and Simulation of Hardware Description Languages The Compositional Models of HDL's  
Author: by Szu-Tsung Cheng B. Sc. M. Sc. 
Degree: A dissertation submitted in partial satisfaction of the requirements for the degree of Doctor of Philosophy in Computer Science in the GRADUATE DIVISION of the UNIVERSITY of CALIFORNIA, BERKELEY Committee in charge: Professor Robert K. Brayton, Chair Professor Alberto Sangiovanni-Vincentelli Professor Dorit S. Hochbaum  
Date: 1994  Spring, 1998  
Address: 1989  Berkeley, California, U.S.A.)  
Affiliation: (National Taiwan University, Taipei, Taiwan)  (University of California,  
Abstract-found: 0
Intro-found: 1
Reference: [ABB + 94] <author> Adnan Aziz, Felice Balarin, Robert K. Brayton, Szu-Tsung Cheng, Ramin Hojati, Sriram C. Krishnan, Rajeev K. Ranjan, Alberto L. Sangiovanni-Vincentelli, Thomas R. Shiple, Timothy Kam Vigyan Singhal, Serdar Tasiran, and Huey-Yih Wang. HSIS: </author> <title> A BDD-based environment for formal verification. </title> <booktitle> In DAC94, </booktitle> <address> San Diego, CA, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: This is a common condition in digital hardware, and all design methodologies, of which we are aware, insist upon it. In the world of synthesis [SSL + 92], formal verification <ref> [ABB + 94, McM94, BHSv + 96a, BHSV + 96b] </ref>, and cycle-based simulation [CMM + 96], finite state machines (FSMs) is the most widely used model. FSMs are the fundamental formalism under "synchronous languages" like BLIF-MV [BCH + 91], SMV [McM94], Esterel [BC84, BdS91], Signal [Hal93], Statecharts [Har87, DH89], etc.
Reference: [ASU85] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Massachusetts, </address> <year> 1985. </year>
Reference-contexts: If latency between islands is a concern, the two or more islands can be clustered together to form one island (at the expense of complicating the design). 1.3.2 Structured Programming Enables Powerful Optimization Another thing that makes software compilers successful is the adoption of powerful optimization techniques <ref> [ASU85, FRJL88] </ref> such as register allocation, loop optimization (e.g., loop invariant identification), copy propagation, dead code elimination, etc. Most of these techniques will not be applicable if the structure of a program is obscure to a compiler. <p> Similar to control flow graphs CHAPTER 3. COMPILATION, SYNTHESIS, AND SIMULATION OF V++ 73 <ref> [ASU85] </ref> in traditional programming language compilers, NCFGs make the transfer of control explicit. Unlike software control flow graphs, in NCFGs, all statements in serial (without intervening wait statement) are executed simultaneously.
Reference: [Bak93] <author> Wendell C. Baker. </author> <title> An application of the synchronous/reactive semantics to the vhdl language. </title> <institution> Memorandum UCB/ERL M93/10, University of California at Berkeley, </institution> <year> 1993. </year>
Reference-contexts: On the other hand, if the second always statement is executed first, then b will first get the current value of c and then a gets b's new value, which is equal to c. This kind of simulator introduced nondeterminism has increased the difficulty of debugging. <ref> [Bak93, BGM94, BFK94, Doh94, Eve94] </ref>, etc. have tried to give semantics to these languages, formally or informally. CHAPTER 1. INTRODUCTION 3 1.1.4 The Model Mismatch Problem In the 80's, VHDL (Very High Speed Integrated Circuit HDL) was created by the U.S.
Reference: [Bak96] <author> Wendell C. Baker. </author> <title> Interfacing System Description Languages to Formal Verification. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, </institution> <year> 1996. </year>
Reference-contexts: This problem also arises when one composes two Mealy machines together. In the terminology of the synchronous languages, these loops are known as causality violations or combinational cycles. The root of this difficulty is the so-called RMC Barrier Theorem <ref> [Bak96] </ref>, which states, in essence, that no semantics can be simultaneously Responsive (i.e., value changes in one module are instantly visible in another), Modular (internals of each module are hidden), and Causal (composition of modules is well-defined). <p> Refer to Figure 1.1 for a graphical illustration of the relationship among objects, ports, variables, and channels. Chapter 2 gives an overview of the V++ language. 1.4.2.1 Communication in V++ Communication via messages in V++ is fundamentally Moore-style: that is, communication through latches. As pointed out in <ref> [Bak96] </ref>, this is sufficient to ensure com-positionality. However, on occasions Mealy-style communication is desired. It is this un-latched communication which is the source of the difficulty in compositionality in previous languages.
Reference: [BBB + 94] <author> B. Barringer, T. Burd, F. Burghardt, A. Burstein, A. Chandrakasan, R. Do-ering, S. Narayanaswamy, T. Pering, B. Richards, T. Truman, J. Rabaey, and R. Brodersen. Infopad: </author> <title> A system design for portable multimedia access. </title> <booktitle> In Proceedings of Calgary Wireless 94 Conference, </booktitle> <year> 1994. </year>
Reference-contexts: We apply the V++ design language to a real design the InfoPad. We use V++ to design several variations of InfoPad to show what the trade-off (design time, area overhead, performance overhead, etc.) is by using V++. 4.1 The InfoPad Project The InfoPad project <ref> [BBB + 94, TPDB98] </ref> is a low power wireless multimedia communication device. InfoPad is not a computer. It is a hand-held, battery operated communication terminal like a multimedia cellular phone. It communicates with a net of closely spaced base stations to provide wireless communication with the backbone networks.
Reference: [BC84] <author> G. Berry and L. Cosserat. </author> <title> The synchronous programming languages esterel and its mathematical semantics. </title> <editor> In S. Brookes and C. Winskel, editors, </editor> <booktitle> Seminar on Concurrency. Springer Verlag Lecture Notes in Computer Science 197, </booktitle> <year> 1984. </year>
Reference-contexts: FSMs are the fundamental formalism under "synchronous languages" like BLIF-MV [BCH + 91], SMV [McM94], Esterel <ref> [BC84, BdS91] </ref>, Signal [Hal93], Statecharts [Har87, DH89], etc. In addition, the synthesizable subsets of Verilog or VHDL CHAPTER 1. INTRODUCTION 5 [syn94, vhd92, CBY + 95] are also essentially FSMs. The powerful algorithms in these CAD tools have automated and sped up the design process. <p> V++ provides constructs to explicitly express parallelism and organize the transitions in sequencers. V++ processes provide designers with a simple yet powerful way to describe multi-cycle operations. Some of these process constructs are inspired by the Esterel <ref> [BC84] </ref> language. 1.5 Organization of The Dissertation The rest of the dissertation is organized as follows. Chapter 2 gives a tour of the major constructs of V++. Compilation and link algorithms are detailed in Chapter 3. <p> In this case, the "redundant logic" created by the V++ compiler/linker is the resolution function (which is a mux with its control glued to constant valid). CHAPTER 3. COMPILATION, SYNTHESIS, AND SIMULATION OF V++ 103 3.5 Related Compilation Techniques Esterel <ref> [BC84, Ber92, Hal93] </ref> is one of the most popular system design languages. It was originally designed for reactive systems (systems that continuously react to their environment at a pre-determined speed). Esterel is an imperative parallel language with event manipulation and very high level control flow constructs.
Reference: [BCH + 91] <author> R. K. Brayton, M. Chiodo, R. Hojati, T. Kam, K. Kodandapani, R. P. Kur-shan, S. Malik, A. Sangiovanni-Vincentelli, E. M. Sentovich, T. Shiple, K. J. BIBLIOGRAPHY 129 Singh, and H.-Y. Wang. BLIF-MV: </author> <title> An interchange format for design verification and synthesis. </title> <institution> Memorandum UCB/ERL M91/97, University of California at Berkeley, </institution> <year> 1991. </year>
Reference-contexts: In the world of synthesis [SSL + 92], formal verification [ABB + 94, McM94, BHSv + 96a, BHSV + 96b], and cycle-based simulation [CMM + 96], finite state machines (FSMs) is the most widely used model. FSMs are the fundamental formalism under "synchronous languages" like BLIF-MV <ref> [BCH + 91] </ref>, SMV [McM94], Esterel [BC84, BdS91], Signal [Hal93], Statecharts [Har87, DH89], etc. In addition, the synthesizable subsets of Verilog or VHDL CHAPTER 1. INTRODUCTION 5 [syn94, vhd92, CBY + 95] are also essentially FSMs.
Reference: [BdS91] <author> F. Boussinot and R. de Sinone. </author> <title> The esterel language. In Another Look at Real Time Programming, </title> <journal> Proceedings of the IEEE, Special Issue. IEEE, </journal> <month> September </month> <year> 1991. </year>
Reference-contexts: FSMs are the fundamental formalism under "synchronous languages" like BLIF-MV [BCH + 91], SMV [McM94], Esterel <ref> [BC84, BdS91] </ref>, Signal [Hal93], Statecharts [Har87, DH89], etc. In addition, the synthesizable subsets of Verilog or VHDL CHAPTER 1. INTRODUCTION 5 [syn94, vhd92, CBY + 95] are also essentially FSMs. The powerful algorithms in these CAD tools have automated and sped up the design process.
Reference: [Ber92] <author> G. Berry. </author> <title> A hardware implementation of pure esterel. </title> <booktitle> In Sadhana, Academy Proceedings in Engineering Sciences. </booktitle> <institution> Indian Academy of Sciences, </institution> <year> 1992. </year>
Reference-contexts: In this case, the "redundant logic" created by the V++ compiler/linker is the resolution function (which is a mux with its control glued to constant valid). CHAPTER 3. COMPILATION, SYNTHESIS, AND SIMULATION OF V++ 103 3.5 Related Compilation Techniques Esterel <ref> [BC84, Ber92, Hal93] </ref> is one of the most popular system design languages. It was originally designed for reactive systems (systems that continuously react to their environment at a pre-determined speed). Esterel is an imperative parallel language with event manipulation and very high level control flow constructs. <p> It is sometimes referred to as synchronous language as it is based on the perfect synchrony hypothesis: computation and communication take zero time. What is similar between the V++ compiler and the Esterel compiler <ref> [Ber92, Ber96] </ref> is that both are based on the syntax directed compilation technique. Both compilers work by first translating the programs into kernel constructs. The kernels are then translated into circuit components/templates and the components are connected according to the syntax structure of the source program.
Reference: [Ber96] <author> G. Berry. </author> <title> The constructive semantics of pure esterel, </title> <note> draft version 2.0. </note> <year> 1996. </year>
Reference-contexts: It is sometimes referred to as synchronous language as it is based on the perfect synchrony hypothesis: computation and communication take zero time. What is similar between the V++ compiler and the Esterel compiler <ref> [Ber92, Ber96] </ref> is that both are based on the syntax directed compilation technique. Both compilers work by first translating the programs into kernel constructs. The kernels are then translated into circuit components/templates and the components are connected according to the syntax structure of the source program.
Reference: [BFK94] <author> Peter T. Breuer, Luis Sanchez Fernandez, and Carlos Delgado Kloos. </author> <title> Proof theory and a validation condition generator for vhdl. </title> <booktitle> In Proceedings of Euro-DAC'94 with Euro'VHDL'94, </booktitle> <year> 1994. </year>
Reference-contexts: On the other hand, if the second always statement is executed first, then b will first get the current value of c and then a gets b's new value, which is equal to c. This kind of simulator introduced nondeterminism has increased the difficulty of debugging. <ref> [Bak93, BGM94, BFK94, Doh94, Eve94] </ref>, etc. have tried to give semantics to these languages, formally or informally. CHAPTER 1. INTRODUCTION 3 1.1.4 The Model Mismatch Problem In the 80's, VHDL (Very High Speed Integrated Circuit HDL) was created by the U.S.
Reference: [BGM94] <author> Egon Borger, Uwe Glasser, and Wolfgang Muller. </author> <title> The semantics of behavioral vhdl'93 descriptions. </title> <booktitle> In Proceedings of Euro-DAC'94 with Euro'VHDL'94, </booktitle> <year> 1994. </year>
Reference-contexts: On the other hand, if the second always statement is executed first, then b will first get the current value of c and then a gets b's new value, which is equal to c. This kind of simulator introduced nondeterminism has increased the difficulty of debugging. <ref> [Bak93, BGM94, BFK94, Doh94, Eve94] </ref>, etc. have tried to give semantics to these languages, formally or informally. CHAPTER 1. INTRODUCTION 3 1.1.4 The Model Mismatch Problem In the 80's, VHDL (Very High Speed Integrated Circuit HDL) was created by the U.S. <p> In effect, these languages are simulator programming languages where designs are programs that control the scheduling of events which model the circuit activities at various levels. Even though much effort has been invested to discover the formal semantics of such languages (or subsets of them) <ref> [Doh94, Eve94, BGM94] </ref>, due to different models of computation, it does not help hardware extraction. Such languages cannot be the contract language between designers and CAD (Computer Aided Design) tools since no tool can derive hardware from an arbitrary description.
Reference: [BHSv + 96a] <author> Robert K. Brayton, Gary D. Hachtel, Alberto Sangiovanni-vincentelli, Fabio Somenzi, Adnan Aziz, Szu-Tsung Cheng, Stephen A. Edwards, Sunil P. Kha-tri, Yuji Kukimoto, Abelardo Pardo, Shaz Quadeer, Rajeev K. Ranjan, Shaker Sarwary, Thomas R. shiple, and Gitanjali Swamy. </author> <title> vis. </title> <booktitle> In FMCAD'96, </booktitle> <year> 1996. </year>
Reference-contexts: This is a common condition in digital hardware, and all design methodologies, of which we are aware, insist upon it. In the world of synthesis [SSL + 92], formal verification <ref> [ABB + 94, McM94, BHSv + 96a, BHSV + 96b] </ref>, and cycle-based simulation [CMM + 96], finite state machines (FSMs) is the most widely used model. FSMs are the fundamental formalism under "synchronous languages" like BLIF-MV [BCH + 91], SMV [McM94], Esterel [BC84, BdS91], Signal [Hal93], Statecharts [Har87, DH89], etc. <p> The SMV files are then translated into blif files via several intermediate format compilers. The generated blif files are then simulated in VIS <ref> [BHSV + 96b, BHSv + 96a] </ref>. We also mapped the blif files to various technology libraries using SIS [Sea92]. CHAPTER 4. EXPERIMENTAL RESULTS 118 The experimental results are summarized in Table 4.1. There is one column for each variation of InfoPad.
Reference: [BHSV + 96b] <author> Robert K. Brayton, Gary D. Hachtel, Alberto Sangiovanni-Vincentelli, Fabio Somenzi, Adnan Aziz, Szu-Tsung Cheng, Stephen Edwards, Sunil Khatri, Yuji Kukimoto, Abelardo pardo, Shaz Qadeer, Rajeev K. Ranjan, Shaker Sarwary, Thomas R. shiple, Gitanjali Swamy, and Tiziano Villa. </author> <title> Vis: A system for verification and synthesis. </title> <booktitle> In Proceedings of the Conference on Computer Aided Verification, </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: This is a common condition in digital hardware, and all design methodologies, of which we are aware, insist upon it. In the world of synthesis [SSL + 92], formal verification <ref> [ABB + 94, McM94, BHSv + 96a, BHSV + 96b] </ref>, and cycle-based simulation [CMM + 96], finite state machines (FSMs) is the most widely used model. FSMs are the fundamental formalism under "synchronous languages" like BLIF-MV [BCH + 91], SMV [McM94], Esterel [BC84, BdS91], Signal [Hal93], Statecharts [Har87, DH89], etc. <p> The SMV files are then translated into blif files via several intermediate format compilers. The generated blif files are then simulated in VIS <ref> [BHSV + 96b, BHSv + 96a] </ref>. We also mapped the blif files to various technology libraries using SIS [Sea92]. CHAPTER 4. EXPERIMENTAL RESULTS 118 The experimental results are summarized in Table 4.1. There is one column for each variation of InfoPad.
Reference: [CB94] <author> Szu-Tsung Cheng and Robert K. Brayton. </author> <title> Compiling verilog into automata. </title> <institution> Memorandum UCB/ERL M94/37, University of California at Berkeley, </institution> <year> 1994. </year>
Reference-contexts: Therefore, these extractors cannot handle the full set of these HDLs. In addition, due to the model mismatch between event-driven languages and hardware, these extractors need to do complex analysis to understand the role and the meaning of a construct in various contexts. By choosing different algorithms, different systems <ref> [syn94, GS96, vhd92, CB94, CBY + 95, CB96, CSM + 97] </ref>, etc. have different capabilities for dealing with different combinations of HDL constructs. Moreover, each of these subsets is a semantic subset rather than syntactic subset, which again leads to several problems. First, without running CHAPTER 1.
Reference: [CB96] <author> Szu-Tsung Cheng and Robert K. Brayton. </author> <title> Synthesizing multi-phase hdl programs. </title> <booktitle> In Proceedings of International Verilog Conference. IEEE, </booktitle> <month> March </month> <year> 1996. </year> <note> BIBLIOGRAPHY 130 </note>
Reference-contexts: Therefore, these extractors cannot handle the full set of these HDLs. In addition, due to the model mismatch between event-driven languages and hardware, these extractors need to do complex analysis to understand the role and the meaning of a construct in various contexts. By choosing different algorithms, different systems <ref> [syn94, GS96, vhd92, CB94, CBY + 95, CB96, CSM + 97] </ref>, etc. have different capabilities for dealing with different combinations of HDL constructs. Moreover, each of these subsets is a semantic subset rather than syntactic subset, which again leads to several problems. First, without running CHAPTER 1. <p> For example, if there exists a logical master clock (which is true for many practical systems), then the techniques introduced in <ref> [CB96] </ref> can be used to synthesize a "message sampler" between clock domains. Basically, the sampler coordinates message flow between sub-systems controlled by different clocks.
Reference: [CBY + 95] <author> Szu-Tsung Cheng, Robert K. Brayton, Gary York, Katherine Yelick, and Alexander Saldanha. </author> <title> Compiling verilog into timed finite state machines. </title> <booktitle> In Proceedings of International Verilog Conference. IEEE, </booktitle> <month> March </month> <year> 1995. </year>
Reference-contexts: Therefore, these extractors cannot handle the full set of these HDLs. In addition, due to the model mismatch between event-driven languages and hardware, these extractors need to do complex analysis to understand the role and the meaning of a construct in various contexts. By choosing different algorithms, different systems <ref> [syn94, GS96, vhd92, CB94, CBY + 95, CB96, CSM + 97] </ref>, etc. have different capabilities for dealing with different combinations of HDL constructs. Moreover, each of these subsets is a semantic subset rather than syntactic subset, which again leads to several problems. First, without running CHAPTER 1. <p> FSMs are the fundamental formalism under "synchronous languages" like BLIF-MV [BCH + 91], SMV [McM94], Esterel [BC84, BdS91], Signal [Hal93], Statecharts [Har87, DH89], etc. In addition, the synthesizable subsets of Verilog or VHDL CHAPTER 1. INTRODUCTION 5 <ref> [syn94, vhd92, CBY + 95] </ref> are also essentially FSMs. The powerful algorithms in these CAD tools have automated and sped up the design process. The only major limiting factor for these tools seems to be the size of the circuits they can handle.
Reference: [CMM + 96] <author> Szu-Tsung Cheng, Patrick G. McGeer, Kennith L McMillan, Alexander Sal-danha, Alberto Sangiovanni-Vincentelli, and Patrick Scaglia. </author> <title> Cycle simulation semanitcs of verilog and smv: Cobra from concept to simulator. </title> <booktitle> In Proceedings of Cadence Technical Conference, </booktitle> <year> 1996. </year>
Reference-contexts: This is a common condition in digital hardware, and all design methodologies, of which we are aware, insist upon it. In the world of synthesis [SSL + 92], formal verification [ABB + 94, McM94, BHSv + 96a, BHSV + 96b], and cycle-based simulation <ref> [CMM + 96] </ref>, finite state machines (FSMs) is the most widely used model. FSMs are the fundamental formalism under "synchronous languages" like BLIF-MV [BCH + 91], SMV [McM94], Esterel [BC84, BdS91], Signal [Hal93], Statecharts [Har87, DH89], etc. In addition, the synthesizable subsets of Verilog or VHDL CHAPTER 1. <p> In this section we show how a V++ design can be simulated. There are several ways to simulate a V++ program. For example, once the logic of the whole design is generated, one can use the techniques in <ref> [MMS + 95, CMM + 96] </ref> to flatten and simulate the whole circuit. For large circuits, these global compilation technique can be prohibitively time-consuming. On the other hand, one can take advantage the structured communication in V++ to decompose the whole simulation task into several smaller sub-tasks.
Reference: [CMM + 97] <author> Szu-Tsung Cheng, Patrick C. McGeer, Mike Meyer, Alberto Sangiovanni-Vincentelli, and Patrick Scaglia. </author> <title> The v++ systems design language. </title> <booktitle> In Proceedings of Cadence Technical Conference, </booktitle> <year> 1997. </year>
Reference-contexts: The lesson is: by making the abstract flow of a program explicit and using conservative analysis, one can get compact and efficient results from large designs with moderate computation. 1.4 V++ A Hardware Design Language In this dissertation, a Hardware Design Language, V++ <ref> [CMM + 97, CMM + 98, CMS + 98, CMSS98] </ref>, is designed to fix the problems mentioned in Section 1.1 and 1.2. Specifically, the goals of V++ are as follows: 1. To be a mechanism for capturing the design, not modeling the design.
Reference: [CMM + 98] <author> Szu-Tsung Cheng, Patrick C. McGeer, Mike Meyer, Tom Truman, Alberto Sangiovanni-Vincentelli, and Patrict Scaglia. </author> <title> The v++ system design language. </title> <booktitle> In The Proceedings of Design, Automation and Test in Europe, </booktitle> <year> 1998. </year>
Reference-contexts: The lesson is: by making the abstract flow of a program explicit and using conservative analysis, one can get compact and efficient results from large designs with moderate computation. 1.4 V++ A Hardware Design Language In this dissertation, a Hardware Design Language, V++ <ref> [CMM + 97, CMM + 98, CMS + 98, CMSS98] </ref>, is designed to fix the problems mentioned in Section 1.1 and 1.2. Specifically, the goals of V++ are as follows: 1. To be a mechanism for capturing the design, not modeling the design.
Reference: [CMS + 98] <author> Szu-Tsung Cheng, Patrick C. McGeer, Patrick Scaglia, Alberto Sangiovanni-Vincentelli, and Robert K. Brayton. </author> <title> Finite state machine communication in v++. </title> <note> Accepted by CTC'98, </note> <year> 1998. </year>
Reference-contexts: The lesson is: by making the abstract flow of a program explicit and using conservative analysis, one can get compact and efficient results from large designs with moderate computation. 1.4 V++ A Hardware Design Language In this dissertation, a Hardware Design Language, V++ <ref> [CMM + 97, CMM + 98, CMS + 98, CMSS98] </ref>, is designed to fix the problems mentioned in Section 1.1 and 1.2. Specifically, the goals of V++ are as follows: 1. To be a mechanism for capturing the design, not modeling the design.
Reference: [CMSS98] <author> Szu-Tsung Cheng, Patrick McGeer, Fabio Somenzi, and Patrick Scaglia. </author> <title> Object-oriented simulation of hardware descriptions: Solving the namespace problem in a pure hardware language. </title> <note> Accepted by CTC'98, </note> <year> 1998. </year>
Reference-contexts: The lesson is: by making the abstract flow of a program explicit and using conservative analysis, one can get compact and efficient results from large designs with moderate computation. 1.4 V++ A Hardware Design Language In this dissertation, a Hardware Design Language, V++ <ref> [CMM + 97, CMM + 98, CMS + 98, CMSS98] </ref>, is designed to fix the problems mentioned in Section 1.1 and 1.2. Specifically, the goals of V++ are as follows: 1. To be a mechanism for capturing the design, not modeling the design.
Reference: [CSM + 97] <author> Szu-Tsung Cheng, Alexander Saldanha, Patrick C. McGeer, Patrick Scaglia, and Robert K. Brayton. </author> <title> A functional interpretation of verilog programs, </title> <year> 1997. </year>
Reference-contexts: Therefore, these extractors cannot handle the full set of these HDLs. In addition, due to the model mismatch between event-driven languages and hardware, these extractors need to do complex analysis to understand the role and the meaning of a construct in various contexts. By choosing different algorithms, different systems <ref> [syn94, GS96, vhd92, CB94, CBY + 95, CB96, CSM + 97] </ref>, etc. have different capabilities for dealing with different combinations of HDL constructs. Moreover, each of these subsets is a semantic subset rather than syntactic subset, which again leads to several problems. First, without running CHAPTER 1.
Reference: [DH89] <author> Doron Drusinsky and David Harel. </author> <title> Using statecharts for hardware description and synthesis. </title> <journal> In IEEE Transactions on Computer-Aided Design. IEEE, </journal> <month> July </month> <year> 1989. </year>
Reference-contexts: FSMs are the fundamental formalism under "synchronous languages" like BLIF-MV [BCH + 91], SMV [McM94], Esterel [BC84, BdS91], Signal [Hal93], Statecharts <ref> [Har87, DH89] </ref>, etc. In addition, the synthesizable subsets of Verilog or VHDL CHAPTER 1. INTRODUCTION 5 [syn94, vhd92, CBY + 95] are also essentially FSMs. The powerful algorithms in these CAD tools have automated and sped up the design process.
Reference: [Doh94] <author> Gert Dohmen. </author> <title> Petri nets as intermediate representation between vhdl and symbolic transition systems. </title> <year> 1994. </year>
Reference-contexts: On the other hand, if the second always statement is executed first, then b will first get the current value of c and then a gets b's new value, which is equal to c. This kind of simulator introduced nondeterminism has increased the difficulty of debugging. <ref> [Bak93, BGM94, BFK94, Doh94, Eve94] </ref>, etc. have tried to give semantics to these languages, formally or informally. CHAPTER 1. INTRODUCTION 3 1.1.4 The Model Mismatch Problem In the 80's, VHDL (Very High Speed Integrated Circuit HDL) was created by the U.S. <p> In effect, these languages are simulator programming languages where designs are programs that control the scheduling of events which model the circuit activities at various levels. Even though much effort has been invested to discover the formal semantics of such languages (or subsets of them) <ref> [Doh94, Eve94, BGM94] </ref>, due to different models of computation, it does not help hardware extraction. Such languages cannot be the contract language between designers and CAD (Computer Aided Design) tools since no tool can derive hardware from an arbitrary description.
Reference: [Eve94] <author> Hans Eveking. </author> <title> (v)hdl-based verification of heterogeneous synchronous/ asynchronous systems. </title> <booktitle> In Proceedings of Euro-DAC'94 with Euro'VHDL'94, </booktitle> <year> 1994. </year> <note> BIBLIOGRAPHY 131 </note>
Reference-contexts: On the other hand, if the second always statement is executed first, then b will first get the current value of c and then a gets b's new value, which is equal to c. This kind of simulator introduced nondeterminism has increased the difficulty of debugging. <ref> [Bak93, BGM94, BFK94, Doh94, Eve94] </ref>, etc. have tried to give semantics to these languages, formally or informally. CHAPTER 1. INTRODUCTION 3 1.1.4 The Model Mismatch Problem In the 80's, VHDL (Very High Speed Integrated Circuit HDL) was created by the U.S. <p> In effect, these languages are simulator programming languages where designs are programs that control the scheduling of events which model the circuit activities at various levels. Even though much effort has been invested to discover the formal semantics of such languages (or subsets of them) <ref> [Doh94, Eve94, BGM94] </ref>, due to different models of computation, it does not help hardware extraction. Such languages cannot be the contract language between designers and CAD (Computer Aided Design) tools since no tool can derive hardware from an arbitrary description.
Reference: [FRJL88] <author> Charles N. Fischer and Jr. Richard J. LeBlanc. </author> <title> Crafting a Compiler. </title> <publisher> The Benjamin/Cummings Publishing Company, </publisher> <address> Menlo Park, California, </address> <year> 1988. </year>
Reference-contexts: If latency between islands is a concern, the two or more islands can be clustered together to form one island (at the expense of complicating the design). 1.3.2 Structured Programming Enables Powerful Optimization Another thing that makes software compilers successful is the adoption of powerful optimization techniques <ref> [ASU85, FRJL88] </ref> such as register allocation, loop optimization (e.g., loop invariant identification), copy propagation, dead code elimination, etc. Most of these techniques will not be applicable if the structure of a program is obscure to a compiler.
Reference: [Gos96] <author> James Gosling. </author> <title> The Java Language Specificatioin. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Menlo Park, CA, </address> <year> 1996. </year>
Reference-contexts: Communication between objects in a design is primarily via messages (or port invocations). Unlike messages in an object-oriented programming language <ref> [Str91, Gos96] </ref> where a message send is equivalent to a method or procedure invocation (which is blocking, i.e, a caller waits until the callee finishes its job before it can regain control), message-passing in V++ is just that: a message is sent to another object, or to itself. <p> What is different from these languages is that a V++ object does not have I/O wires. In V++, communication is done via port invocations. Ports in V++ are similar to member functions/methods <ref> [Str91, Gos96] </ref> in object-oriented languages. Ports define how objects can react to port invocations by modifying variables in the containing objects. They define the services an object provides. CHAPTER 2.
Reference: [GS96] <author> Brent L. Gregory and Russell B. Segal. </author> <title> Method for converting a hardware description of a logic circuit into hardware components. </title> <type> United States Patent, (5530841), </type> <month> June </month> <year> 1996. </year>
Reference-contexts: Therefore, these extractors cannot handle the full set of these HDLs. In addition, due to the model mismatch between event-driven languages and hardware, these extractors need to do complex analysis to understand the role and the meaning of a construct in various contexts. By choosing different algorithms, different systems <ref> [syn94, GS96, vhd92, CB94, CBY + 95, CB96, CSM + 97] </ref>, etc. have different capabilities for dealing with different combinations of HDL constructs. Moreover, each of these subsets is a semantic subset rather than syntactic subset, which again leads to several problems. First, without running CHAPTER 1.
Reference: [Hal93] <author> Nicolas Halbwachs. </author> <title> Synchronous Programming of Reactive Sytems. </title> <publisher> Kluwer Academic Publishers, Norwell, </publisher> <address> MA, </address> <year> 1993. </year>
Reference-contexts: FSMs are the fundamental formalism under "synchronous languages" like BLIF-MV [BCH + 91], SMV [McM94], Esterel [BC84, BdS91], Signal <ref> [Hal93] </ref>, Statecharts [Har87, DH89], etc. In addition, the synthesizable subsets of Verilog or VHDL CHAPTER 1. INTRODUCTION 5 [syn94, vhd92, CBY + 95] are also essentially FSMs. The powerful algorithms in these CAD tools have automated and sped up the design process. <p> First, a few circuit components like finite state machines, buses are designed using V++. The next example is Unger's traffic light controller. The last example is the reflex game <ref> [Hal93] </ref>. It demonstrates the power of processes and preemption constructs. CHAPTER 2. A TOUR OF THE V++ LANGUAGE 52 2.6.1 Finite State Machines In V++, a FSM can be realized by a port which keeps sending itself messages. <p> the message delivery and storage structure, and all the code internal to a V++ object, is directly mapped into gates and latches and the mapping is part of the semantics of V++. 2.6.4 The Reflex Game In this section, V++'s process constructs are used to design a reflex game machine <ref> [Hal93] </ref>. 2.6.4.1 Rules of The Game The reflex game machine consists of two buttons (ready and stop) and one coin slot (when the player inserts a coin, the variable coin is set to 1). <p> In this case, the "redundant logic" created by the V++ compiler/linker is the resolution function (which is a mux with its control glued to constant valid). CHAPTER 3. COMPILATION, SYNTHESIS, AND SIMULATION OF V++ 103 3.5 Related Compilation Techniques Esterel <ref> [BC84, Ber92, Hal93] </ref> is one of the most popular system design languages. It was originally designed for reactive systems (systems that continuously react to their environment at a pre-determined speed). Esterel is an imperative parallel language with event manipulation and very high level control flow constructs.
Reference: [Har87] <author> David Harel. </author> <title> Science of Computer Programming, volume 8, chapter State-charts: A Visual Formalism For Complex Systems. </title> <publisher> Elsevier Science Publishers B.V. (North-Holland), </publisher> <year> 1987. </year>
Reference-contexts: FSMs are the fundamental formalism under "synchronous languages" like BLIF-MV [BCH + 91], SMV [McM94], Esterel [BC84, BdS91], Signal [Hal93], Statecharts <ref> [Har87, DH89] </ref>, etc. In addition, the synthesizable subsets of Verilog or VHDL CHAPTER 1. INTRODUCTION 5 [syn94, vhd92, CBY + 95] are also essentially FSMs. The powerful algorithms in these CAD tools have automated and sped up the design process.
Reference: [HP90] <author> John L. Hennessy and David A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers Inc., </publisher> <year> 1990. </year>
Reference-contexts: Unlike software control flow graphs, in NCFGs, all statements in serial (without intervening wait statement) are executed simultaneously. The syntactic order among these statements does not suggest any data dependency (whether it is true data dependency, anti-dependency, or output dependency <ref> [HP90] </ref>). Dependencies are introduced only by variable references. That is, read from wire variables always refer to the values that have been assigned in the present cycle.
Reference: [Mal93] <author> S. Malik. </author> <title> Analysis of cyclic combinational circuits. </title> <booktitle> In Proceedings of ICCAD, </booktitle> <year> 1993. </year>
Reference-contexts: Removal of combinational cycles is an important step to many CAD algorithms which can only accept inputs without combinational cycles. Detection and removal of causality violations generally requires a global analysis <ref> [Shi96, Mal93] </ref> of the design. While up to now, global analysis has been possible, if somewhat time-consuming, two factors are converging which limit the technique: * The existence of very large designs. Currently, the largest designs are in the range CHAPTER 1.
Reference: [MB91] <author> Patrick C. McGeer and Robert K. Brayton. </author> <title> Integrating Function and Temporal Domains in Logic Design: The False Path Problem and Its Implications. </title> <year> 1991. </year>
Reference-contexts: This limited global analysis provides several advantages. First, for synthesis, the problem size for causality analysis can be limited (to each individual object, instead of the whole design). Second, this provides one way to limit the scope for algorithms like false path analysis <ref> [MB91, McG89] </ref>, etc. In addition, latch walls also make it easy to put pieces together to form various sources. For cycle simulation, having latch walls around islands gives us more freedom in scheduling islands.
Reference: [McG89] <author> Patrick C. McGeer. </author> <title> On the Interaction of Functional and Timing Behavior of Combinational Logic Circuits. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, </institution> <year> 1989. </year>
Reference-contexts: This limited global analysis provides several advantages. First, for synthesis, the problem size for causality analysis can be limited (to each individual object, instead of the whole design). Second, this provides one way to limit the scope for algorithms like false path analysis <ref> [MB91, McG89] </ref>, etc. In addition, latch walls also make it easy to put pieces together to form various sources. For cycle simulation, having latch walls around islands gives us more freedom in scheduling islands.
Reference: [McM94] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: This is a common condition in digital hardware, and all design methodologies, of which we are aware, insist upon it. In the world of synthesis [SSL + 92], formal verification <ref> [ABB + 94, McM94, BHSv + 96a, BHSV + 96b] </ref>, and cycle-based simulation [CMM + 96], finite state machines (FSMs) is the most widely used model. FSMs are the fundamental formalism under "synchronous languages" like BLIF-MV [BCH + 91], SMV [McM94], Esterel [BC84, BdS91], Signal [Hal93], Statecharts [Har87, DH89], etc. <p> FSMs are the fundamental formalism under "synchronous languages" like BLIF-MV [BCH + 91], SMV <ref> [McM94] </ref>, Esterel [BC84, BdS91], Signal [Hal93], Statecharts [Har87, DH89], etc. In addition, the synthesizable subsets of Verilog or VHDL CHAPTER 1. INTRODUCTION 5 [syn94, vhd92, CBY + 95] are also essentially FSMs. The powerful algorithms in these CAD tools have automated and sped up the design process. <p> The restrictions on communication in V++ guarantee that the state is well-defined. Any of the synchronous languages would suffice for our purposes: for reasons of convenience and clarity we chose a language that is pretty close to SMV <ref> [McM94] </ref>. SMV is a purely equational language. Users of synchronous languages may find it helpful to think of a V++ object as an SMV program: the message-sending mechanism implements a means by which SMV programs can communicate.
Reference: [MMS + 95] <author> Patrick C. McGeer, Kenneth L McMillan, Alexander Saldanha, Alberto L. Sangiovanni-Vincentelli, and Patrick Scaglia. </author> <title> Fast discrete function evaluation using decision diagrams. </title> <booktitle> In Proceedings of the 1995 ACM/IEEE International Workshop on Logic Synthesis, </booktitle> <year> 1995. </year> <note> BIBLIOGRAPHY 132 </note>
Reference-contexts: In this section we show how a V++ design can be simulated. There are several ways to simulate a V++ program. For example, once the logic of the whole design is generated, one can use the techniques in <ref> [MMS + 95, CMM + 96] </ref> to flatten and simulate the whole circuit. For large circuits, these global compilation technique can be prohibitively time-consuming. On the other hand, one can take advantage the structured communication in V++ to decompose the whole simulation task into several smaller sub-tasks.
Reference: [Sea92] <author> Ellen M. Sentovich and et. al. </author> <title> Sequential circuit design using synthesis and optimization. </title> <booktitle> In Proceedings of IEEE ICCD. IEEE, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: The SMV files are then translated into blif files via several intermediate format compilers. The generated blif files are then simulated in VIS [BHSV + 96b, BHSv + 96a]. We also mapped the blif files to various technology libraries using SIS <ref> [Sea92] </ref>. CHAPTER 4. EXPERIMENTAL RESULTS 118 The experimental results are summarized in Table 4.1. There is one column for each variation of InfoPad. <p> mapped to a circuit with cost functions that minimize delay using a standard cell technology library (stdcell2_2.genlib), the area of the implementation when it is mapped to a circuit with cost functions that minimize area using a standard cell technology library, the latch count, the literal count (reported from SIS <ref> [Sea92] </ref>), and the time (approximate) we spent on doing each design. The design time is further broken down into Table 4.2. In this table, the circuits are mapped without any logic optimization.
Reference: [Shi96] <author> Thomas Robert Shiple. </author> <title> Formal Analysis of Synchronous Circuits. </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, </institution> <year> 1996. </year>
Reference-contexts: Removal of combinational cycles is an important step to many CAD algorithms which can only accept inputs without combinational cycles. Detection and removal of causality violations generally requires a global analysis <ref> [Shi96, Mal93] </ref> of the design. While up to now, global analysis has been possible, if somewhat time-consuming, two factors are converging which limit the technique: * The existence of very large designs. Currently, the largest designs are in the range CHAPTER 1. <p> V++ addresses the problem of compositionality by enforcing delays on inter-object communication. Therefore, one of the major responsibilities of the V++ linker is to synthesize channels the inter-object communication devices. Esterel, like other synchronous languages, allows zero-delay inter-module communication. Consequently, expensive analysis like causality checking (e.g., <ref> [Shi96] </ref>) may be necessary for the whole design to ensure the behavior of the design is well-defined. What is novel in the V++ compiler is the way it com CHAPTER 3. COMPILATION, SYNTHESIS, AND SIMULATION OF V++ 104 piles safe port invocations.
Reference: [SSL + 92] <author> E. M. Sentovich, K. J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. R. Stephan, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <note> SIS: </note>
Reference-contexts: This is a common condition in digital hardware, and all design methodologies, of which we are aware, insist upon it. In the world of synthesis <ref> [SSL + 92] </ref>, formal verification [ABB + 94, McM94, BHSv + 96a, BHSV + 96b], and cycle-based simulation [CMM + 96], finite state machines (FSMs) is the most widely used model.
References-found: 40

