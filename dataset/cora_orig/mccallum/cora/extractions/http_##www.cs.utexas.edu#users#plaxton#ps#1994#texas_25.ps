URL: http://www.cs.utexas.edu/users/plaxton/ps/1994/texas_25.ps
Refering-URL: http://www.cs.utexas.edu/users/plaxton/html/abc.html
Root-URL: 
Email: Email: dina@cis.njit.edu.  Email: plaxton@cs.utexas.edu.  
Title: An Optimal Hypercube Algorithm for the All Nearest Smaller Values Problem  
Author: Dina Kravets C. Greg Plaxton 
Note: 07102. Supported by NSF Research Initiation Award CCR-9308204 and the New Jersey Institute of Technology SBR under Grant No. 421220.  78712. Supported by the Texas Advanced Research Program under Grant No. 003658-461.  
Address: NJ  Austin, TX  
Affiliation: Department of Computer Science, New Jersey Institute of Technology, University Heights, Newark,  Department of Computer Science, University of Texas,  
Abstract: Given a sequence of n elements, the All Nearest Smaller Values (ANSV) problem is to find, for each element in the sequence, the nearest element to the left (right) that is smaller, or to report that no such element exists. Time and work optimal algorithms for this problem are known on all the PRAM models [4, 6], but the running time of the best previous hypercube algorithm [9] is optimal only when the number of processors p satisfies 1 p n=((lg 3 n)(lg lg n) 2 ). In this paper, we prove that any normal hypercube algorithm requires (n) processors to solve the ANSV problem in O(lg n) time, and we present the first normal hypercube algorithm for the ANSV problem that is optimal for all values of n and p. We use our ANSV algorithm to give the first O(lg n)-time n-processor normal hypercube algorithms for triangulating a monotone polygon and for constructing a Cartesian tree. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aggarwal, B. Chazelle, L. Guibas, C. O'Dunlaing, and C. K. Yap. </author> <title> Parallel computational geometry. </title> <journal> Algorithmica, </journal> <volume> 3(3) </volume> <pages> 293-327, </pages> <year> 1988. </year>
Reference-contexts: A monotone polygon is one-sided if either its upper or lower chain consists of a single edge, called the distinguished edge. Our algorithm for triangulating a monotone polygon follows the approach of Berkman et al. [4], Aggarwal et al. <ref> [1] </ref>, and Goodrich [8]. The algorithm consists of two stages. In the first stage, we decompose the monotone polygon into one-sided monotone polygons. In the second stage, we triangulate the one-sided monotone polygons. We assume a d-dimensional hypercube containing 2 d = n processors, d 1.
Reference: [2] <author> A. Aggarwal, D. Kravets, J. K. Park, and S. Sen. </author> <title> Parallel searching in generalized Monge arrays with applications. </title> <booktitle> In Proceedings of the 2nd Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 259-268, </pages> <year> 1990. </year>
Reference-contexts: Recently, the ANSV problem has been identified as an important sub-problem in the design of efficient parallel algorithms. In particular, a subroutine for the ANSV problem is used by Aggarwal et al. <ref> [2] </ref> in parallel searching of staircase-Monge arrays, and by Berkman et al. [4] in finding a triangulation of a monotone polygon, preprocessing for answering range minimum queries in constant time, reconstructing a binary tree from its inorder and either preorder or postorder labelings, and matching parenthesis.
Reference: [3] <author> M. J. Atallah and D. Z. Chen. </author> <title> Optimal parallel hypercube algorithms for polygon problems. </title> <booktitle> In Proceedings of the 5th IEEE Symposium on Parallel and Distributed Processing, </booktitle> <pages> pages 208-215, </pages> <year> 1993. </year>
Reference-contexts: A recent result of Atallah and Chen <ref> [3] </ref> gives an optimal hypercube algorithm for determining the line with respect to which a given polygon is monotone, if such a line exists.
Reference: [4] <author> O. Berkman, B. Schieber, and U. Vishkin. </author> <title> Optimal doubly logarithmic parallel algorithms based on finding nearest smaller values. </title> <journal> Journal of Algorithms, </journal> <volume> 14(3) </volume> <pages> 344-370, </pages> <year> 1993. </year>
Reference-contexts: Recently, the ANSV problem has been identified as an important sub-problem in the design of efficient parallel algorithms. In particular, a subroutine for the ANSV problem is used by Aggarwal et al. [2] in parallel searching of staircase-Monge arrays, and by Berkman et al. <ref> [4] </ref> in finding a triangulation of a monotone polygon, preprocessing for answering range minimum queries in constant time, reconstructing a binary tree from its inorder and either preorder or postorder labelings, and matching parenthesis. <p> Furthermore, two fundamental problems can be reduced to ANSV: (i) merging two sorted lists [5, 10], and (ii) finding the maximum of n elements [13]. The ANSV problem is easy to solve sequentially in O (n) time using a stack. Berkman, Schieber, and Vishkin <ref> [4] </ref> give the following PRAM algorithms for the ANSV problem: (i) an O (lg n)-time (n= lg n)-processor CREW PRAM algorithm, and (ii) an O (lg lg n)-time (n= lg lg n)-processor CRCW PRAM algorithm. Chen [6] gives an EREW PRAM algorithm that matches the CREW PRAM bounds of [4]. <p> Vishkin <ref> [4] </ref> give the following PRAM algorithms for the ANSV problem: (i) an O (lg n)-time (n= lg n)-processor CREW PRAM algorithm, and (ii) an O (lg lg n)-time (n= lg lg n)-processor CRCW PRAM algorithm. Chen [6] gives an EREW PRAM algorithm that matches the CREW PRAM bounds of [4]. In this paper, we develop the first O (lg n)- time hypercube algorithm for the ANSV problem. <p> The triangulation of a simple polygon has numerous applications in computational 1 geometry [15]. The triangulation of a monotone polygon is a subroutine used in all of the known parallel algorithms for triangulating simple polygons. Berkman et al. <ref> [4] </ref> give CREW and CRCW PRAM algorithms for triangulating a monotone polygon. JaJa and Ryu [9] give a normal hypercube algorithm for this problem with the same asymptotic performance as their ANSV algorithm. <p> The Cartesian tree is used in preprocessing algorithms for answering range minimum queries. Berkman et al. <ref> [4] </ref> show how to find the Cartesian tree in O (lg n) time using an (n= lg n)-processor CREW PRAM. We obtain the first O (lg n)-time n-processor normal hypercube algorithm for this problem. The remainder of this paper is organized as follows. Section 2 defines the model of computation. <p> The SparseANSV algorithm is based on the CREW PRAM algorithm of Berkman et al. <ref> [4] </ref>. Before describing the algorithm, we give some definitions and notations. We assume a d-dimensional hypercube containing 2 d = n processors, d 1. Let d 0 denote the minimum integer such that 2 d 0 d d 0 . <p> Perform the following operations within each subcube C ff;fi . First, merge the sorted sequences S ff;fi and T ff;fi . Then, use prefix operations to determine the right match of each element in S ff;fi . (As proven in <ref> [4] </ref>, the right match of every element of S ff;fi is an element of T ff;fi .) Use additional prefix operations to count, for each element y of T ff;fi , the number of elements x in S ff;fi such that y is the right match of x. (a) At each <p> Running time: O (lg d). Since each step of SparseANSV runs in O (d) time, this algorithm solves any (n= lg n)-input ANSV problem in O (lg n) time using n processors. The central lemma underlying the proof of correctness of algorithm SparseANSV is due to Berkman et al. <ref> [4] </ref>, and is stated below. We omit the proof of correctness of algorithm SparseANSV since it is quite similar to the proof of correctness of the CREW PRAM algorithm of Berkman et al. [4]. Lemma 3.1 ([4]) The right matches for the elements of S ff;fi are among the elements of <p> The central lemma underlying the proof of correctness of algorithm SparseANSV is due to Berkman et al. <ref> [4] </ref>, and is stated below. We omit the proof of correctness of algorithm SparseANSV since it is quite similar to the proof of correctness of the CREW PRAM algorithm of Berkman et al. [4]. Lemma 3.1 ([4]) The right matches for the elements of S ff;fi are among the elements of T ff;fi . 3.2 An n-input n-processor algorithm We will now show how to solve a larger ANSV problem using the same number of processors. <p> The algorithm presented in this section offers two main advantages over the algorithm of Berkman et al. <ref> [4] </ref>: (i) the present algorithm runs efficiently on any hypercubic machine, and (ii) the high-level structure of the present algorithm is somewhat simpler. <p> A monotone polygon is one-sided if either its upper or lower chain consists of a single edge, called the distinguished edge. Our algorithm for triangulating a monotone polygon follows the approach of Berkman et al. <ref> [4] </ref>, Aggarwal et al. [1], and Goodrich [8]. The algorithm consists of two stages. In the first stage, we decompose the monotone polygon into one-sided monotone polygons. In the second stage, we triangulate the one-sided monotone polygons. We assume a d-dimensional hypercube containing 2 d = n processors, d 1. <p> Implementation: Algorithm ANSV run on variable y and segmented according to the variable i 0 . Running time: O (d). Algorithm Triangulate runs in O (lg n) time on an n-processor hypercube. The correctness of the algorithm follows from the work of Berkman et al. <ref> [4] </ref>. Furthermore, Berkman et al. [4] show how to reduce the problem of merging two sorted lists of length n to the problem of 14 triangulating a monotone polygon of size n. <p> Running time: O (d). Algorithm Triangulate runs in O (lg n) time on an n-processor hypercube. The correctness of the algorithm follows from the work of Berkman et al. <ref> [4] </ref>. Furthermore, Berkman et al. [4] show how to reduce the problem of merging two sorted lists of length n to the problem of 14 triangulating a monotone polygon of size n. <p> Thus, our normal hypercube algorithm is processor-optimal as well as time-optimal. 6 Building a Cartesian Tree Let the Cartesian tree of a sequence W = hw i : 0 i &lt; ni be defined as in Section 1. Berkman et al. <ref> [4] </ref> prove that the parent of any element w i in the Cartesian tree is the larger of w i 's left and right matches.
Reference: [5] <author> A. Borodin and J. E. Hopcroft. </author> <title> Routing, merging, and sorting on parallel models of computation. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 30 </volume> <pages> 130-145, </pages> <year> 1985. </year>
Reference-contexts: Furthermore, two fundamental problems can be reduced to ANSV: (i) merging two sorted lists <ref> [5, 10] </ref>, and (ii) finding the maximum of n elements [13]. The ANSV problem is easy to solve sequentially in O (n) time using a stack.
Reference: [6] <author> D. Z. Chen. </author> <title> Efficient geometric algorithms in the EREW-PRAM. </title> <booktitle> In Proceedings of the 28th Annual Allerton Conference on Communication, Control, and Computing, </booktitle> <pages> pages 818-827, </pages> <year> 1990. </year>
Reference-contexts: Berkman, Schieber, and Vishkin [4] give the following PRAM algorithms for the ANSV problem: (i) an O (lg n)-time (n= lg n)-processor CREW PRAM algorithm, and (ii) an O (lg lg n)-time (n= lg lg n)-processor CRCW PRAM algorithm. Chen <ref> [6] </ref> gives an EREW PRAM algorithm that matches the CREW PRAM bounds of [4]. In this paper, we develop the first O (lg n)- time hypercube algorithm for the ANSV problem.
Reference: [7] <author> R. E. Cypher and C. G. Plaxton. </author> <title> Deterministic sorting in nearly logarithmic time on the hypercube and related computers. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 47 </volume> <pages> 501-548, </pages> <year> 1993. </year>
Reference-contexts: n)-time, n-processor algorithm is easily generalized to obtain a p-processor algorithm running in time O ((n=p) lg p + lg n).) For the case n = p, JaJa and Ryu [9] obtain a time bound of O (lg n (lg lg n) 2 ) by making use of the Sharesort <ref> [7] </ref> sorting algorithm as a subroutine. Our O (lg n)-time algorithm, on the other hand, does not make use of a general routing or sorting subroutine; instead, we confine our on-line routing operations to restricted classes of permutations for which optimal-time normal hypercube are known.
Reference: [8] <author> M. T. Goodrich. </author> <title> Triangulating a polygon in parallel. </title> <journal> Journal of Algorithms, </journal> <volume> 10 </volume> <pages> 327-351, </pages> <year> 1989. </year>
Reference-contexts: A monotone polygon is one-sided if either its upper or lower chain consists of a single edge, called the distinguished edge. Our algorithm for triangulating a monotone polygon follows the approach of Berkman et al. [4], Aggarwal et al. [1], and Goodrich <ref> [8] </ref>. The algorithm consists of two stages. In the first stage, we decompose the monotone polygon into one-sided monotone polygons. In the second stage, we triangulate the one-sided monotone polygons. We assume a d-dimensional hypercube containing 2 d = n processors, d 1.
Reference: [9] <author> J. F. JaJa and K. W. Ryu. </author> <title> Optimal algorithms on the pipelined hypercube and related networks. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4 </volume> <pages> 582-591, </pages> <year> 1993. </year>
Reference-contexts: Furthermore, we prove that any normal hypercube algorithm requires (n) processors to solve the ANSV problem in O (lg n) time. Our paper is not the first to consider the complexity of normal hypercube algorithms for the ANSV problem. In particular, JaJa and Ryu <ref> [9] </ref> give a normal hypercube algorithm for the ANSV problem with optimal running time for any number p of processors satisfying 1 p n=((lg 3 n)(lg lg n) 2 ). <p> In contrast, our algorithm is optimal for all values of n and p. (Our O (lg n)-time, n-processor algorithm is easily generalized to obtain a p-processor algorithm running in time O ((n=p) lg p + lg n).) For the case n = p, JaJa and Ryu <ref> [9] </ref> obtain a time bound of O (lg n (lg lg n) 2 ) by making use of the Sharesort [7] sorting algorithm as a subroutine. <p> The triangulation of a monotone polygon is a subroutine used in all of the known parallel algorithms for triangulating simple polygons. Berkman et al. [4] give CREW and CRCW PRAM algorithms for triangulating a monotone polygon. JaJa and Ryu <ref> [9] </ref> give a normal hypercube algorithm for this problem with the same asymptotic performance as their ANSV algorithm. We give the first O (lg n)-time n processor normal hypercube algorithm for monotone polygon triangulation. * Building a Cartesian tree. <p> JaJa and Ryu <ref> [9] </ref> use a separator-based argument to establish the same asymptotic lower bound for the shu*e-exchange and cube-connected cycles. However, the bound they obtain for the hypercube is weaker than ours by a p lg p factor. <p> Our (non-separator-based) argument establishes the same lower bound not only for the hypercube, shu*e-exchange, and cube-connected cycles, but also for any bounded-degree expander network. (The separator-based approach of JaJa and Ryu <ref> [9] </ref> does not give a non-trivial lower bound for bounded-degree expander networks.) The lower bound is proven under the following set of assumptions: L1 Each input key is provided at exactly one processor. 11 L2 In a single time step, a processor can send and receive O (1) messages, and perform
Reference: [10] <author> C. P. Kruskal. </author> <title> Searching, merging, and sorting. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-32(10):942-946, </volume> <year> 1983. </year>
Reference-contexts: Furthermore, two fundamental problems can be reduced to ANSV: (i) merging two sorted lists <ref> [5, 10] </ref>, and (ii) finding the maximum of n elements [13]. The ANSV problem is easy to solve sequentially in O (n) time using a stack.
Reference: [11] <author> F. T. Leighton. </author> <title> Introduction to Parallel Algorithms and Architectures: Arrays, Trees, </title> <booktitle> Hypercubes, </booktitle> <volume> volume 1. </volume> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: Algorithms satisfying conditions (i) and (ii) are often referred to as normal hypercube algorithms <ref> [11, Section 3.1.3] </ref>. Normal algorithms are widely regarded as the most interesting class of hypercube algorithms, since they can be executed with constant-factor slowdown on any of the bounded-degree variants of the hypercube (e.g., butterfly, shu*e-exchange, cube-connected cycles).
Reference: [12] <author> E. W. Mayr and R. Werchner. </author> <title> Optimal routing of parentheses on the hypercube. </title> <booktitle> In Proceedings of the 4th Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 109-117, </pages> <year> 1992. </year>
Reference-contexts: Most importantly, we make use of the the optimal parentheses routing algorithm of Mayr and Werchner <ref> [12] </ref>. We use our ANSV algorithm to obtain more efficient hypercube algorithms for the following two problems: * Triangulating a monotone polygon. A simple polygon is monotone with respect to a line ` if any line orthogonal to ` intersects the polygon in at most two points. <p> We can efficiently exchange information between all pairs of matching subcubes in parallel by making use of the parenthesis routing operation of Mayr and Werchner <ref> [12] </ref>.
Reference: [13] <author> L. G. Valiant. </author> <title> Parallelism in comparison problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 4 </volume> <pages> 348-355, </pages> <year> 1975. </year>
Reference-contexts: Furthermore, two fundamental problems can be reduced to ANSV: (i) merging two sorted lists [5, 10], and (ii) finding the maximum of n elements <ref> [13] </ref>. The ANSV problem is easy to solve sequentially in O (n) time using a stack.
Reference: [14] <author> J. Vuillemin. </author> <title> A unified look at data structures. </title> <journal> Communications of the ACM, </journal> <volume> 23 </volume> <pages> 229-239, </pages> <year> 1980. </year>
Reference-contexts: a binary tree where the root corresponds to the element w k = min 0i&lt;n w i , the left child is the Cartesian tree of hw i : 0 i &lt; ki, and the right child is the Cartesian tree of hw i : k &lt; i &lt; ni <ref> [14] </ref>. The Cartesian tree is used in preprocessing algorithms for answering range minimum queries. Berkman et al. [4] show how to find the Cartesian tree in O (lg n) time using an (n= lg n)-processor CREW PRAM.
Reference: [15] <author> C. Yap. </author> <title> Parallel triangulation of a polygon in two calls to the trapezoidal map. </title> <journal> Algo-rithmica, </journal> <volume> 3 </volume> <pages> 279-288, </pages> <year> 1988. </year> <month> 16 </month>
Reference-contexts: A simple polygon is monotone with respect to a line ` if any line orthogonal to ` intersects the polygon in at most two points. The triangulation of a simple polygon has numerous applications in computational 1 geometry <ref> [15] </ref>. The triangulation of a monotone polygon is a subroutine used in all of the known parallel algorithms for triangulating simple polygons. Berkman et al. [4] give CREW and CRCW PRAM algorithms for triangulating a monotone polygon.
References-found: 15

