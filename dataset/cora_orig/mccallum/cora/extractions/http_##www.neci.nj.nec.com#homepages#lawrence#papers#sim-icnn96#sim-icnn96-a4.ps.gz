URL: http://www.neci.nj.nec.com/homepages/lawrence/papers/sim-icnn96/sim-icnn96-a4.ps.gz
Refering-URL: http://www.neci.nj.nec.com/homepages/lawrence/papers/sim-icnn96/
Root-URL: http://www.neci.nj.nec.com
Email: flawrence,actg@elec.uq.edu.au, giles@research.nj.nec.com  
Phone: 1  2  
Title: Correctness, Efficiency, Extendability and Maintainability in Neural Network Simulation  
Author: Steve Lawrence ;fl Ah Chung Tsoi C. Lee Giles y 
Address: 4 Independence Way, Princeton, NJ 08540  St. Lucia, Australia  
Affiliation: NEC Research Institute,  Electrical and Computer Engineering, University of Queensland,  
Note: Appears in International Conference on Neural Networks, ICNN 96, June 2-6, Washington DC, IEEE Press, pp. 474-479, 1996.  
Abstract: A large number of neural network simulators are publicly available to researchers, many free of charge [11]. However, when a new paradigm is being developed, as is often the case, the advantages of using existing simulators decrease, causing most researchers to write their own software. It has been estimated that 85% of neural network researchers write their own simulators [11]. We present techniques and principles for the implementation of neural network simulators. First and foremost, we discuss methods for ensuring the correctness of results avoiding duplication, automating common tasks, using assertions liberally, implementing reverse algorithms, employing multiple algorithms for the same task, and using extensive visualization. Secondly, we discuss efficiency concerns, including using appropriate granularity object-oriented programming, and pre-computing information whenever possible. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. </author> <title> Arya and D.M. Mount. Algorithms for fast vector quantization. </title> <editor> In J. A. Storer and M. Cohn, editors, </editor> <booktitle> Proceedings of DCC 93: Data Compression Conference, </booktitle> <pages> pages 381390. </pages> <publisher> IEEE Press, </publisher> <year> 1993. </year>
Reference-contexts: The conversion from the pole-zero format to the initial weights can be reversed to help check the correctness of the algorithm. 3.4. Redundant Routines Many routines can be implemented in multiple ways. An example: we might include K-D tree [2] or Approximate Nearest Neighbor <ref> [1] </ref> code for fast lookup of nearest neighbors. When executed in test mode we can also run the simple version of neighbor searching (calculate the distance to all patterns) and compare the results. 3.5.
Reference: [2] <author> J.L. Bentley. </author> <title> Multidimensional binary search trees used for associative searching. </title> <journal> Communications of the ACM, </journal> <volume> 18(9):509 517, </volume> <year> 1975. </year>
Reference-contexts: The conversion from the pole-zero format to the initial weights can be reversed to help check the correctness of the algorithm. 3.4. Redundant Routines Many routines can be implemented in multiple ways. An example: we might include K-D tree <ref> [2] </ref> or Approximate Nearest Neighbor [1] code for fast lookup of nearest neighbors. When executed in test mode we can also run the simple version of neighbor searching (calculate the distance to all patterns) and compare the results. 3.5.
Reference: [3] <author> Grady Booch. </author> <title> Object-Oriented Analysis and Design with Applications. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Software Design The design of efficient, maintainable, and reusable object oriented software is difficult and is not the topic of this paper. An excellent source of instruction on the design of reusable object oriented software is [7]. Classics in software engineering include <ref> [8, 3, 5] </ref>. 7. Summary In summary, we have concentrated on correctness, efficiency, maintainability, and extendability. The following recommendations have been found to be helpful: 1. Avoid duplication. For maintainability, but primarily for correctness. 2. Use object-oriented design to aid reuse of existing code. 3.
Reference: [4] <author> Frederick P. Brooks. </author> <title> The Mythical Man-Month. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The alternative, the Advanced Automation System, is six years late and riddled with bugs [9]. This example shows that, even when using known software engineering principles, designing and implementing large projects can be difficult. A classic on software project management is <ref> [4] </ref>. 3. Ensuring Correctness The desired outcome of a set of neural network simulations is often simply a single value and its confidence interval which represents, for example, the classification error of the system averaged over a number of trials.
Reference: [5] <author> Jim Coplien. </author> <title> Advanced C++ Programming Styles and Idioms. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: Software Design The design of efficient, maintainable, and reusable object oriented software is difficult and is not the topic of this paper. An excellent source of instruction on the design of reusable object oriented software is [7]. Classics in software engineering include <ref> [8, 3, 5] </ref>. 7. Summary In summary, we have concentrated on correctness, efficiency, maintainability, and extendability. The following recommendations have been found to be helpful: 1. Avoid duplication. For maintainability, but primarily for correctness. 2. Use object-oriented design to aid reuse of existing code. 3.
Reference: [6] <author> R. W. Floyd. </author> <title> Assigning meanings to programs. </title> <booktitle> Proceedings of the Symposium on Applied Math, </booktitle> <publisher> American Mathematical Society, </publisher> <address> XIX:1932, </address> <year> 1967. </year>
Reference-contexts: Examples of techniques for avoiding duplication are discussed later. 3.2. Assertions Assertions represent formal constraints on the behavior of software systems and are commonly used in formal verification systems <ref> [6] </ref>. They have also been recognized as a powerful tool for the detection of software faults during runtime [13]. More recently, they have been viewed as a permanent defensive mechanism for runtime fault detection [10].
Reference: [7] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Software Design The design of efficient, maintainable, and reusable object oriented software is difficult and is not the topic of this paper. An excellent source of instruction on the design of reusable object oriented software is <ref> [7] </ref>. Classics in software engineering include [8, 3, 5]. 7. Summary In summary, we have concentrated on correctness, efficiency, maintainability, and extendability. The following recommendations have been found to be helpful: 1. Avoid duplication. For maintainability, but primarily for correctness. 2.
Reference: [8] <author> Ivar Jacobsen, Magnus Christerson, Patrik Jonsson, and G.G. Overgaard. </author> <title> Object-Oriented Software Engineering. </title> <publisher> Addison-Wesley, </publisher> <year> 1992. </year>
Reference-contexts: As an example, the state-of-the-art speech phoneme recognizers trained by Tony Robinson et. al. [12] require many days of processing power for training. 4.1. Object-Oriented Programming Object-oriented programming has many advantages over traditional programming techniques primarily increased maintainability, reusability, and modifiability <ref> [8] </ref>. However, in the interests of efficiency we need to be careful with the granularity at which we define our objects. The extreme case is if we consider each weight to be a separate object. Typically this incurs a major performance hit. <p> Software Design The design of efficient, maintainable, and reusable object oriented software is difficult and is not the topic of this paper. An excellent source of instruction on the design of reusable object oriented software is [7]. Classics in software engineering include <ref> [8, 3, 5] </ref>. 7. Summary In summary, we have concentrated on correctness, efficiency, maintainability, and extendability. The following recommendations have been found to be helpful: 1. Avoid duplication. For maintainability, but primarily for correctness. 2. Use object-oriented design to aid reuse of existing code. 3.
Reference: [9] <author> Alan Joch. </author> <title> How software doesn't work. </title> <journal> Byte, </journal> <volume> 20(12):4960, </volume> <year> 1995. </year>
Reference-contexts: The system has contributed to more than 10 control center failures in the past year. The FAA has been working to replace the system for more than a decade. The alternative, the Advanced Automation System, is six years late and riddled with bugs <ref> [9] </ref>. This example shows that, even when using known software engineering principles, designing and implementing large projects can be difficult. A classic on software project management is [4]. 3.
Reference: [10] <author> B. Meyer. </author> <title> Applying design by contract. </title> <journal> IEEE Computer, </journal> <volume> 25:4051, </volume> <year> 1992. </year>
Reference-contexts: They have also been recognized as a powerful tool for the detection of software faults during runtime [13]. More recently, they have been viewed as a permanent defensive mechanism for runtime fault detection <ref> [10] </ref>. In practice, we find that using assertions liberally drastically cuts down on the time spent correcting errors. Errors are often caught at their source rather than by effects of the errors which show up later in execution. Examples of assertions include simple parameter checks (eg.
Reference: [11] <editor> J.M.J. Murre. Neurosimulators. In Michael A. Arbib, editor, </editor> <booktitle> The Handbook of Brain Theory and Neural Networks, </booktitle> <pages> pages 634639. </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1995. </year>
Reference-contexts: 1. Introduction Hundreds of research groups have developed neural network simulators. Many of these are available to other researchers, often for no charge <ref> [11] </ref>. However, when a new paradigm is being developed, as is often the case in research, the advantages of using existing simulators decrease, leading many researchers to write their own software. Our first priority as neural network researchers is to ensure the correctness of our results.
Reference: [12] <author> A.J. Robinson. </author> <title> An application of recurrent nets to phone probability estimation. </title> <journal> IEEE Transactions on Neural Networks, </journal> <volume> 5(2):298305, </volume> <year> 1994. </year>
Reference-contexts: Efficiency Efficiency can be very important in neural network simulation. While many problems can be done with small networks, arguably more interesting problems require large networks and longer training times. As an example, the state-of-the-art speech phoneme recognizers trained by Tony Robinson et. al. <ref> [12] </ref> require many days of processing power for training. 4.1. Object-Oriented Programming Object-oriented programming has many advantages over traditional programming techniques primarily increased maintainability, reusability, and modifiability [8]. However, in the interests of efficiency we need to be careful with the granularity at which we define our objects.
Reference: [13] <author> David S. Rosenblum. </author> <title> A practical approach to programming with assertions. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(1):1931, </volume> <year> 1995. </year>
Reference-contexts: Examples of techniques for avoiding duplication are discussed later. 3.2. Assertions Assertions represent formal constraints on the behavior of software systems and are commonly used in formal verification systems [6]. They have also been recognized as a powerful tool for the detection of software faults during runtime <ref> [13] </ref>. More recently, they have been viewed as a permanent defensive mechanism for runtime fault detection [10]. In practice, we find that using assertions liberally drastically cuts down on the time spent correcting errors.
References-found: 13

