URL: http://www.cs.indiana.edu/database/Ode/doc/att-db-91-2.ps.Z
Refering-URL: http://www.cs.indiana.edu/database/Ode/doc/
Root-URL: http://www.cs.indiana.edu
Title: Ode as an Active Database: Constraints and Triggers  
Author: N. H. Gehani H. V. Jagadish 
Address: Murray Hill, New Jersey 07974  
Affiliation: AT&T Bell Laboratories  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. Abbott and H. Garcia-Molina, </author> <title> ``Scheduling Real-Time Transactions: A Performance Evaluation'', </title> <booktitle> Proceedings of the 14th Int'l Conf. on Very Large Databases, </booktitle> <address> Los Angeles, CA, </address> <year> 1988, </year> <pages> 1-12. </pages>
Reference-contexts: Executing trigger actions is similar to executing ordinary transactions, and therefore all the problems and solutions of real-time systems apply. Further discussion of these issues is beyond the scope of this paper. See <ref> [1, 18] </ref> for a discussion on real-time execution. 5.1 The Mechanism Ode supports two kinds of triggers: once-only (default) and perpetual (specified using the keyword perpetual). A once-only trigger is automatically deactivated after the trigger has ``fired'', and it must then explicitly be activated again, if desired.
Reference: [2] <author> R. Agrawal and N. H. Gehani, </author> <title> ``Rationale for the Design of Persistence and Query Processing Facilities in the Database Programming Language O++'', </title> <booktitle> 2nd Int'l Workshop on Database Programming Languages, </booktitle> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: 1. INTRODUCTION Ode <ref> [2, 3] </ref> is a database system and environment based on the object paradigm. The database is defined, queried, and manipulated using the database programming language O++, which is an upward-compatible extension of the object-oriented programming language C++ [ Stroustrup 1986 ].
Reference: [3] <author> R. Agrawal and N. H. Gehani, </author> <title> ``Ode (Object Database and Environment): The Language and the Data Model'', </title> <booktitle> Proc. ACM-SIGMOD 1989 Int'l Conf. Management of Data, </booktitle> <address> Portland, Oregon, </address> <month> May-June </month> <year> 1989, </year> <pages> 36-45. </pages>
Reference-contexts: 1. INTRODUCTION Ode <ref> [2, 3] </ref> is a database system and environment based on the object paradigm. The database is defined, queried, and manipulated using the database programming language O++, which is an upward-compatible extension of the object-oriented programming language C++ [ Stroustrup 1986 ].
Reference: [4] <author> T. Andrews and C. Harris, </author> <title> ``Combining Language and Database Advances in an Object-Oriented development Environment'', </title> <booktitle> Proc. OOPSLA '87, </booktitle> <address> Orlando, Florida, </address> <month> Oct. </month> <year> 1987, </year> <pages> 430-440. </pages>
Reference-contexts: Active databases are of use in a variety of application areas such as integrated manufacturing, power distribution network management, and air-traffic control. Many databases now support triggers, e.g., POSTGRES [24], HiPAC [11], Sybase [10], Vbase <ref> [4] </ref>, and OOPS [22]. Ode supports three kinds of triggers: once-only, perpetual, and timed triggers. Triggers, like constraints, are associated with objects. However, they are parameterized, and can have multiple invocations active at the same time. <p> The constraint mechanism is a restricted form of a general exception handling mechanism. It will therefore be reasonably straightforward to integrate these facilities with exception handling facilities such as those proposed for C++ [12]. In Vbase <ref> [4] </ref> triggers can be attached to attributes and to operations. Triggers have often been used to augment creation and deletion member functions.
Reference: [5] <author> M. M. Astrahan, M. W. Blasgen, D. D. Chamberlin, K. P. Eswaran, J. N. Gray, P. P. Griffiths, W. F. King, R. A. Lorie, P. R. McJones, J. W. Mehl, G. F. Putzolu, I. L. Traiger, B. W. Wade and V. Watson, </author> <title> ``System R: Relational Approach to Database Management'', </title> <journal> ACM Trans. Database Syst. </journal> <volume> 1, </volume> <month> 2 (June </month> <year> 1976), </year> <pages> 97-137. </pages>
Reference-contexts: RELATED WORK The idea of having triggers and constraints in a database is not new. Facilities for active databases appeared as early as in CODASYL, in the form of ON conditions. System R provided triggers and constraints as a mechanism for enforcing integrity constraints <ref> [5, 13] </ref>. Simple triggers are now appearing in commercial systems. For example, Sybase [10] provides facilities to specify rules and triggers. Rules are integrity constraints that go beyond those implied by a column's data type. These are a special case of our constraint mechanism, with no actions associated.
Reference: [6] <author> T. Bloom and S. B. Zdonik, </author> <booktitle> ``Issues in the Design of Object-Oriented Database Programming Languages'', Proc. OOPSLA, </booktitle> <address> Orlando, Florida, </address> <month> Oct. </month> <year> 1987, </year> <pages> 441-451. </pages>
Reference-contexts: We want to prevent updates to objects that are acceptable from the purely mechanistic concurrency control, serializability perspective, but that leave the database in an inconsistent state. Constraints are used to ensure this kind of data integrity <ref> [6] </ref>; they go beyond the consistency supported by the type system of a database programming language. Ode provides facilities for constraints that can ensure object consistency on an object update basis (hard constraints) and on a transaction basis (soft constraints). <p> In an object-oriented environment where the operations can be user defined, the system cannot determine automatically which operations will affect the trigger and constraint predicates. Consequently, it must be possible to narrow sufficiently the points at which the predicates have to be checked <ref> [6] </ref>. Constraint violations should be able to abort a transaction, raise an exception, or take any other specified recovery action. In the Event-Condition-Action terminology of [19], immediate, deferred and separate execution modes should all be supported. <p> In Ode, trigger conditions are checked at the end of the execution of member functions. The issue of efficient implementation of triggers in relational databases has been investigated by several researchers, e.g., [9]. But more investigation and experience with trigger implementations is needed in the context of object-oriented databases. <ref> [6] </ref> discuss issues in the design of constraint and trigger facilities for programming languages. Two problems identified by them relate to minimization of trigger condition and constraint checking and the interaction between constraints and exception handling.
Reference: [7] <editor> R. J. Brachman and H. J. Levesque, (ed.), </editor> <booktitle> Readings in Knowledge Representation, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1985. </year>
Reference-contexts: A derived class inherits the constraints of its parent class and new constraints can be added. Consequently, constraints can be used to specialize classes. Such constraint-based specializations are useful in many applications, e.g., in frame-based knowledge representation systems <ref> [7] </ref>. Constraints specified in a class definition can conflict with other constraints in the same class definition or with inherited constraints. For example, one constraint may be the negation of another constraint. In general, it is not possible to automate the detection of such conflicts.
Reference: [8] <author> M. Brodie, </author> <title> ``Specification and Verification of Data Base Semantic Integrity'', </title> <type> Technical Report CSRG-91, </type> <institution> Univ. Toronto, Toronto, </institution> <year> 1978. </year>
Reference-contexts: There is considerable theoretical work <ref> [8, 17] </ref> on detecting such conflicts at compile time, for some limited types of constraints, in general only appropriate programming skill can prevent these problems.
Reference: [9] <author> P. Buneman and E. Clemons, </author> <title> ``Efficiently Monitoring Relational Databases'', </title> <journal> ACM Trans. Database Syst., </journal> <year> 1979. </year>
Reference-contexts: In Ode, trigger conditions are checked at the end of the execution of member functions. The issue of efficient implementation of triggers in relational databases has been investigated by several researchers, e.g., <ref> [9] </ref>. But more investigation and experience with trigger implementations is needed in the context of object-oriented databases. [6] discuss issues in the design of constraint and trigger facilities for programming languages.
Reference: [10] <author> M. Darnovsky and G. Bowman, </author> <title> ``TRANSACT-SQL USER'S GUIDE'', Document 3231-2.1, Sybase, </title> <publisher> Inc., </publisher> <year> 1987. </year>
Reference-contexts: Applications can also be notified (or invoked) automatically when objects change in a specified way. Active databases are of use in a variety of application areas such as integrated manufacturing, power distribution network management, and air-traffic control. Many databases now support triggers, e.g., POSTGRES [24], HiPAC [11], Sybase <ref> [10] </ref>, Vbase [4], and OOPS [22]. Ode supports three kinds of triggers: once-only, perpetual, and timed triggers. Triggers, like constraints, are associated with objects. However, they are parameterized, and can have multiple invocations active at the same time. <p> Facilities for active databases appeared as early as in CODASYL, in the form of ON conditions. System R provided triggers and constraints as a mechanism for enforcing integrity constraints [5, 13]. Simple triggers are now appearing in commercial systems. For example, Sybase <ref> [10] </ref> provides facilities to specify rules and triggers. Rules are integrity constraints that go beyond those implied by a column's data type. These are a special case of our constraint mechanism, with no actions associated.
Reference: [11] <author> U. Dayal, B. Blaustein, A. Buchmann, U. Chakravarthy, M. Hsu, R. Ladin, D. McCarthy, A. Rosenthal and S. Sarin, </author> <title> ``The HiPAC Project: Combining Active Databases and Timing Constraints'', </title> <booktitle> ACM-SIGMOD Record 17, </booktitle> <month> 1 (March </month> <year> 1988), </year> <pages> 51-70. </pages>
Reference-contexts: Applications can also be notified (or invoked) automatically when objects change in a specified way. Active databases are of use in a variety of application areas such as integrated manufacturing, power distribution network management, and air-traffic control. Many databases now support triggers, e.g., POSTGRES [24], HiPAC <ref> [11] </ref>, Sybase [10], Vbase [4], and OOPS [22]. Ode supports three kinds of triggers: once-only, perpetual, and timed triggers. Triggers, like constraints, are associated with objects. However, they are parameterized, and can have multiple invocations active at the same time. <p> Since a constraint action is part of the firing transaction, if the transaction eventually aborts, any updates caused by the constraint action will be rolled back. Thus the trigger action transactions are executed after (but not necessarily immediately after) the triggering transaction, i.e., there is ``weak coupling'' <ref> [11] </ref> between the triggering transaction and the trigger action. Since the action part of a trigger is executed as a separate transaction, it is possible that the condition causing the trigger to fire is no longer true at the time the triggered action is actually executed. <p> If a reasonable optimizer is available, it can alter the choice made by the programmer, by rewriting the program: however, such an optimizer is not assumed in the design of the language or its implementation. HiPac <ref> [11] </ref> proposes the concept of Event-Condition-Action (ECA) rules. These rules, unlike our triggers and constraints are first class objects. When an event occurs, the condition is evaluated and, if the condition, is satisfied, the action is executed.
Reference: [12] <author> M. A. Ellis and B. Stroustrup, </author> <title> The Annotated C++ Reference Manual, </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: The constraint mechanism is a restricted form of a general exception handling mechanism. It will therefore be reasonably straightforward to integrate these facilities with exception handling facilities such as those proposed for C++ <ref> [12] </ref>. In Vbase [4] triggers can be attached to attributes and to operations. Triggers have often been used to augment creation and deletion member functions.
Reference: [13] <author> K. P. Eswaran, J. N. Gray, R. A. Lorie and I. L. Traiger, </author> <title> ``The Notions of Consistency and Predicate Locks in a Database System'', </title> <journal> Commun. ACM 19, </journal> <volume> 11 (Nov. </volume> <year> 1976), </year> <pages> 624-633. </pages>
Reference-contexts: RELATED WORK The idea of having triggers and constraints in a database is not new. Facilities for active databases appeared as early as in CODASYL, in the form of ON conditions. System R provided triggers and constraints as a mechanism for enforcing integrity constraints <ref> [5, 13] </ref>. Simple triggers are now appearing in commercial systems. For example, Sybase [10] provides facilities to specify rules and triggers. Rules are integrity constraints that go beyond those implied by a column's data type. These are a special case of our constraint mechanism, with no actions associated.
Reference: [14] <author> E. N. Hanson, </author> <title> ``An Initial Report on the Design of Ariel: A DBMS with an Integrated Production Rule System'', </title> <booktitle> ACM-SIGMOD Record 18, </booktitle> <month> 3 (September </month> <year> 1989), </year> <pages> 12-29. </pages>
Reference-contexts: All rules always execute as part of the same transaction, potentially leading to very long transactions and hence inefficiency, and also potentially leading to an abort of a triggering update because a semantically independent triggered update is unable to commit. Ariel <ref> [14] </ref> extends the POSTGRES query language, but continues to suffer from the limitations just discussed. An important efficiency issue to be discussed in this regard is whether the system should be ``forward-chaining'' (or ``eager'') or ``backward-chaining'' (or ``lazy'' or ``compute-on-demand''). <p> A major difficulty with production systems is that they are very hard to debug when there are situations in which multiple rules can fire, since each has its conditions satisfied. Priority levels, whether explicitly stated as in <ref> [14, 24] </ref>, or determined by criteria such as specificity [23, 27], we believe are a bad idea, since their use is against the declarative spirit of constraint specification and can decrease the potential for concurrent execution.
Reference: [15] <author> H. V. Jagadish and X. Qian, </author> <title> ``Integrity Maintenance in an Object-Oriented Database'', </title> <booktitle> Proc. of the 18th Int'l Conf. on Very Large Databases, </booktitle> <address> Vancouver, BC, Canada, </address> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: This inter-object constraint is then converted into two complementary intra-object constraints, one to be associated with the employee and the other to be associated with the manager. Similarly, we showed, in the previous section, how intra-object triggers could be used to simulate an inter-object periodic trigger. See <ref> [15] </ref> for a systematic technique to obtain intra-object constraints and triggers - 20 - from inter-object contraints and triggers. Secondly, in terms of the E-C-A (event-condition-action) model [19], in Ode the condition and action are explicitly specified for every constraint and trigger. The event is not explicitly specified.
Reference: [16] <author> S. N. Khoshafian and G. P. Copeland, </author> <title> ``Object Identity'', </title> <booktitle> Proc. OOPSLA '86, </booktitle> <address> Portland, Oregon, </address> <month> Sept. </month> <year> 1986, </year> <pages> 406-416. </pages>
Reference-contexts: Volatile objects are allocated in volatile memory and are the same as those created in ordinary programs. Persistent objects are allocated in persistent store and they continue to exist after the program creating them has terminated. Each persistent object is identified by a unique identifier, called the object identity <ref> [16] </ref>. The object identity is referred to as a pointer to a persistent object. Persistent objects are allocated and deallocated in a manner similar to heap objects. Persistent storage operators pnew and pdelete are used instead of the heap operators new and delete.
Reference: [17] <author> C. Kung, </author> <title> ``On Verification of Database Temporal Constraints'', </title> <booktitle> Proc. of the ACM-SIGMOD Int'l Conf. on the Management of Data, </booktitle> <year> 1985, </year> <pages> 169-179. </pages>
Reference-contexts: There is considerable theoretical work <ref> [8, 17] </ref> on detecting such conflicts at compile time, for some limited types of constraints, in general only appropriate programming skill can prevent these problems.
Reference: [18] <author> C. L. Liu and J. W. Wayland, </author> <title> ``Scheduling Algorithms for Multi-programming in a Hard Real-Time Environment'', </title> <journal> Journal of the ACM 20, </journal> <month> (Jan. </month> <year> 1973), </year> <pages> 46-61. </pages>
Reference-contexts: Executing trigger actions is similar to executing ordinary transactions, and therefore all the problems and solutions of real-time systems apply. Further discussion of these issues is beyond the scope of this paper. See <ref> [1, 18] </ref> for a discussion on real-time execution. 5.1 The Mechanism Ode supports two kinds of triggers: once-only (default) and perpetual (specified using the keyword perpetual). A once-only trigger is automatically deactivated after the trigger has ``fired'', and it must then explicitly be activated again, if desired.
Reference: [19] <author> D. R. McCarthy and U. Dayal, </author> <title> ``The Architecture of An Active Database Management System'', </title> <booktitle> Proc. ACM-SIGMOD 1989 Int'l Conf. Management of Data, </booktitle> <address> Portland, Oregon, </address> <month> May-June </month> <year> 1989, </year> <pages> 215-224. </pages>
Reference-contexts: Consequently, it must be possible to narrow sufficiently the points at which the predicates have to be checked [6]. Constraint violations should be able to abort a transaction, raise an exception, or take any other specified recovery action. In the Event-Condition-Action terminology of <ref> [19] </ref>, immediate, deferred and separate execution modes should all be supported. The mechanisms for triggers and constraints are related because one can think of and implement a constraint as a trigger whose action is executed when the negation of the constraint predicate become true. <p> Similarly, we showed, in the previous section, how intra-object triggers could be used to simulate an inter-object periodic trigger. See [15] for a systematic technique to obtain intra-object constraints and triggers - 20 - from inter-object contraints and triggers. Secondly, in terms of the E-C-A (event-condition-action) model <ref> [19] </ref>, in Ode the condition and action are explicitly specified for every constraint and trigger. The event is not explicitly specified. For an intra-object constraint or trigger, this event can be assumed to be the updating of the associated object, as discussed in Section 6.3. <p> Such reliance is bad because direct updates will not cause evaluation of the trigger condition and an optimizing O++ compiler may not evaluate the trigger condition when components specified in the trigger condition are not updated. 6.3 Coupling Modes In <ref> [19] </ref>, three types of coupling between an event (E) and a condition (C) have been identified: the condition evaluation is immediate (when the object is changed), deferred (as part of the transaction but at the end), and separate (in a separate transaction).
Reference: [20] <author> R. S. Nikhil, </author> <title> ``Functional Databases, Functional Languages'', in Data Types and Persistence, M.P. </title> <editor> Atkinson, P. Buneman and R. Morrison (ed.), </editor> <publisher> Springer Verlag, </publisher> <year> 1988, </year> <pages> 51-67. </pages>
Reference-contexts: CONSTRAINTS Constraints are used to maintain a notion of consistency beyond what is typically expressible using the type system <ref> [20] </ref>. Updates that violate the specified constraints should not be permitted. Interpretations of consistency are usually application specific and may be arbitrarily complex. Constraints, which are Boolean conditions, are associated with class definitions. All objects of a class must satisfy all constraints associated with the class. <p> Our interest here is primarily language constructs for specifying constraints and triggers. Any strategy chosen to implement full referential integrity is beyond the scope of this paper. 5. TRIGGERS Triggers, like integrity constraints, monitor the database for some conditions, except that these conditions do not represent consistency violations <ref> [20] </ref>. A trigger, like a constraint, is specified in the class definition and it consists of two parts: a condition and an action. Triggers apply only to the specific objects with respect to which they are activated. Triggers are parameterized, and can be activated multiple times with different parameter values.
Reference: [21] <author> T. </author> <title> Risch, ``Monitoring Database Objects'', </title> <booktitle> Proc. 15th Int'l Conf. Very Large Data Bases, </booktitle> <address> Amsterdam, The Netherlands, </address> <month> Aug. </month> <year> 1989, </year> <pages> 445-453. </pages>
Reference-contexts: Constraints permit only an undo of the update. Rules are used to enforce integrity constraints and to trigger consequent actions. There is no concept of a transaction. Triggers have also be proposed for the Iris object-oriented database <ref> [21] </ref>. Any Iris query can be monitored by first defining it as a function and then defining a monitor for that function. Iris provides functions for defining monitors, activating them, deactivating them, and deleting them. In contrast, triggers in O++ are specified declaratively and as part of the object definition.
Reference: [22] <author> G. Schlageter, R. Unland, W. Wilkes, R. Zieschang, G. Maul, M. Nagl and R. Meyer, </author> <title> ``OOPS - An Object Oriented Programming System with Integrated Data Management Facility'', </title> <booktitle> Proc. IEEE 4th Int'l Conf. Data Engineering, </booktitle> <address> Los Angeles, California, </address> <month> Feb. </month> <year> 1988, </year> <pages> 118-125. </pages>
Reference-contexts: Active databases are of use in a variety of application areas such as integrated manufacturing, power distribution network management, and air-traffic control. Many databases now support triggers, e.g., POSTGRES [24], HiPAC [11], Sybase [10], Vbase [4], and OOPS <ref> [22] </ref>. Ode supports three kinds of triggers: once-only, perpetual, and timed triggers. Triggers, like constraints, are associated with objects. However, they are parameterized, and can have multiple invocations active at the same time. <p> Since we do not specify the order in which the rules will fire, the programmer is forced to make a conservative assumption, and we believe that this makes programming easier. In an object-oriented context, rules and constraints have been proposed in OOPS <ref> [22] </ref>. Constraints permit only an undo of the update. Rules are used to enforce integrity constraints and to trigger consequent actions. There is no concept of a transaction. Triggers have also be proposed for the Iris object-oriented database [21].
Reference: [23] <author> T. Sellis, C. Lin and L. Raschid, </author> <title> ``Implementing Large Production Systems in a DBMS Environment: </title> <booktitle> Concepts and Algorithms'', Proc. of the ACM-SIGMOD Int'l Conf. on the Management of Data, </booktitle> <address> Chicago, Illinois, </address> <year> 1988. </year> <month> - 30 </month> - 
Reference-contexts: All rules are active all the time. Whenever the conditions for a rule are satisfied, it fires, and executes its action part. Some good work has been done towards designing large production systems in a database context <ref> [23, 27] </ref>. The difference between these systems and ours is that in these systems the rules become ends in themselves: the entire program is written in terms of rules. In O++, procedural descriptions may be used where they are appropriate, and rules where they are. <p> A major difficulty with production systems is that they are very hard to debug when there are situations in which multiple rules can fire, since each has its conditions satisfied. Priority levels, whether explicitly stated as in [14, 24], or determined by criteria such as specificity <ref> [23, 27] </ref>, we believe are a bad idea, since their use is against the declarative spirit of constraint specification and can decrease the potential for concurrent execution.
Reference: [24] <author> M. Stonebraker, E. N. Hanson and S. Potamianos, </author> <title> ``The POSTGRES Rule Manager'', </title> <journal> IEEE Trans. Software Eng. </journal> <volume> 14, </volume> <month> 7 (July </month> <year> 1988), </year> <pages> 897-907. </pages>
Reference-contexts: Applications can also be notified (or invoked) automatically when objects change in a specified way. Active databases are of use in a variety of application areas such as integrated manufacturing, power distribution network management, and air-traffic control. Many databases now support triggers, e.g., POSTGRES <ref> [24] </ref>, HiPAC [11], Sybase [10], Vbase [4], and OOPS [22]. Ode supports three kinds of triggers: once-only, perpetual, and timed triggers. Triggers, like constraints, are associated with objects. However, they are parameterized, and can have multiple invocations active at the same time. <p> A trigger is always associated with an object. The trigger condition could involve one or more attributes of the object it makes no difference. In fact, the condition may even use attribute values from other objects. Rules have been built into the POSTGRES third generation database system <ref> [24] </ref>. We believe that the facilities provided in POSTGRES are mechanistic and at a lower level than the facilities described in this paper. There is no difference between constraints and triggers, all are implemented by the single rules mechanism. <p> A major difficulty with production systems is that they are very hard to debug when there are situations in which multiple rules can fire, since each has its conditions satisfied. Priority levels, whether explicitly stated as in <ref> [14, 24] </ref>, or determined by criteria such as specificity [23, 27], we believe are a bad idea, since their use is against the declarative spirit of constraint specification and can decrease the potential for concurrent execution.
Reference: [25] <author> B. Stroustrup, </author> <title> ``Multiple Inheritance for C++'', </title> <booktitle> Proc. European UNIX User's Group, </booktitle> <address> Helsinki, </address> <month> May </month> <year> 1987, </year> <pages> 189-208. </pages>
Reference-contexts: For example, here is a specification of the class item: class item - Name nm; double wt; //in kg public: item (Name xname, double xwt); Name name () const; double weight_lbs () const; double weight_kg () const; -; _ ____________________________________________________________________________________ C++ supports inheritance, including multiple inheritance <ref> [25] </ref>, which is used for object specialization. The specialized object types inherit the properties of the base object type, i.e., the data members and member functions, of the base object type.
Reference: [26] <author> S. P. Weiser and F. H. </author> <title> Lochovsky, ``OZ+: An Object-Oriented Database System'', in Object-Oriented Concepts and Databases, </title> <editor> W. Kim and F.H. Lochovsky (ed.), </editor> <publisher> Addison-Wesley, </publisher> <year> 1989, </year> <pages> 251-282. </pages>
Reference-contexts: Iris provides functions for defining monitors, activating them, deactivating them, and deleting them. In contrast, triggers in O++ are specified declaratively and as part of the object definition. OZ+ <ref> [26] </ref> supports self-triggering rules which correspond to the perpetual triggers of O++. The self-triggering rules are parameterless and they execute whenever possible. Each such OZ+ rule consists of a condition and an action.

References-found: 26

