URL: http://www-cad.eecs.berkeley.edu/HomePages/shaz/iccad97.redundancy.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/shaz/publications.html
Root-URL: http://www.cs.berkeley.edu
Title: Sequential Optimisation without State Space Exploration  
Author: A Mehrotra S Qadeer V Singhal A Aziz R K Brayton A L Sangiovanni-Vincentelli 
Abstract: We propose an algorithm for area optimisation of sequential circuits through redundancy removal. The algorithm finds compatible redundancies by implying values over nets in the circuit. The potentially exponential cost of state space traversal is avoided and the redundancies found can all be removed at once. The optimised circuit is a safe delayed replacement of the original circuit. The algorithm computes a set of compatible sequential redundancies and simplifies the circuit by propagating them through the circuit. We demonstrate the efficacy of the algorithm even for large circuits through experimental results on benchmark circuits. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. A. Iyer, D. E. Long, and M. Abramovici, </author> <title> Identifying Sequential Redundancies Without Search, </title> <booktitle> in Proc. of the Design Automation Conf., </booktitle> <address> (Las Vegas, NV), </address> <pages> pp. 457462, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: The redundancies we compute are compatible in the sense that they form a set that can be removed simultaneously. Our algorithm works for large circuits and scales better than those algorithms that depend on state space exploration. The starting point of our work is <ref> [1] </ref>, in which a method was described to identify sequential redundancies without exploring the state space. The basic algorithm is that for any net, two cases are considered: the net value is 0 and the net value is 1. <p> For example, consider the trivial circuit shown in Figure 1. For the value n1 = 0 the net n2 is unobservable and for the value n1 = 1, the net n2 is 1. Thus net n2 is stuck-at-1 redundant. However, the redundancies found by the method in <ref> [1] </ref> are not compatible in the sense that they remain redundant even in the fl University of California at Berkeley, Berkeley, CA 94720 Cadence Berkeley Labs, Berkeley, CA 94704 University of Texas at Austin, Austin, TX 78712 presence of each other. <p> We do not assume designated initial states for circuits. For sequential optimisation, we use the notion of c-delay replacement <ref> [1, 5] </ref>. This notion guarantees that every possible input-output behaviour that can be observed in the new circuit after it has been clocked for c cycles after power-up, must have been present in the old circuit. <p> We are concerned about the compatibility of all labellings because otherwise we run the danger of marking nets with labels so that all labels are not consistent. For example, consider the circuit in Figure 1. For the purpose of identifying redundancies, <ref> [1] </ref> would infer the implications (n1 = 1) and (n2 = 1) from the assumption hn 7! 1i. <p> Additionally, the assumption hn 7! 0i implies that (n1 = 0) and (n2 = fl); similarly hn 7! 0i implies that (n2 = 0) and (n1 = fl) (notice that we use the symbol to denote compatible observability as opposed to fl which simply denotes observability). So, <ref> [1] </ref> would rightly claim that both n1 and n2 are stuck-at-1 redundant in isolation; however, for redundancy removal it is easy to see that we cannot This is why we want to make all labelings compatible. <p> Labeling one net with at most one label also obviates the need for the validation step described in <ref> [1] </ref>. The algorithm replaces a net n with the constant v if for some time offset t 0 , it is either labelled with v or is unobservable for all assumptions. With each such replacement, we associate a time k as follows [1]. <p> the need for the validation step described in <ref> [1] </ref>. The algorithm replaces a net n with the constant v if for some time offset t 0 , it is either labelled with v or is unobservable for all assumptions. With each such replacement, we associate a time k as follows [1].
Reference: [2] <author> S. Muroga, Y. Kambayashi, H. C. Lai, and J. N. Culliney, </author> <title> The Transduction Method Design of Logic Networks Based on Permissible Functions, </title> <journal> in IEEE Trans. Computers, </journal> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: Our goal to learn all compatible implications in the circuit in one step and use the compatibility of these implications to remove all the redundancies simultaneously (in this sense our method for finding compatible unobservabilities is related to the work in <ref> [2, 3] </ref> for computing compatible ODC's (observability don't cares). This is our first contribution. Secondly, we generalise the implication procedure by combining it with recursive learning [4] to enhance the capability of the redundancy identification procedure.
Reference: [3] <author> H. Savoj, </author> <title> Don't Cares in Multi-Level Network Optimization. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, Electronics Research Laboratory, College of Engineering, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: Our goal to learn all compatible implications in the circuit in one step and use the compatibility of these implications to remove all the redundancies simultaneously (in this sense our method for finding compatible unobservabilities is related to the work in <ref> [2, 3] </ref> for computing compatible ODC's (observability don't cares). This is our first contribution. Secondly, we generalise the implication procedure by combining it with recursive learning [4] to enhance the capability of the redundancy identification procedure.
Reference: [4] <author> W. Kunz and D. K. Pradhan, </author> <title> Recursive Learning: A New Implication Technique for Efficient Solution to CAD Problems Test, Verification and Optimization, </title> <journal> IEEE Trans. Computer-Aided Design, </journal> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: This is our first contribution. Secondly, we generalise the implication procedure by combining it with recursive learning <ref> [4] </ref> to enhance the capability of the redundancy identification procedure. Recursive learning lets us perform case split on unjustified gates so that it is possible to learn more implications at the expense of computation time. Consider the circuit in Figure 2.
Reference: [5] <author> V. Singhal, C. Pixley, A. Aziz, and R. K. Brayton, </author> <title> Exploiting Power-up Delay for Sequential Optimization, </title> <booktitle> in Proc. European Design Automation Conf., </booktitle> <address> (Brighton, Great Britain), </address> <pages> pp. 5459, </pages> <month> Sept. </month> <year> 1995. </year>
Reference-contexts: We do not assume designated initial states for circuits. For sequential optimisation, we use the notion of c-delay replacement <ref> [1, 5] </ref>. This notion guarantees that every possible input-output behaviour that can be observed in the new circuit after it has been clocked for c cycles after power-up, must have been present in the old circuit. <p> This notion guarantees that every possible input-output behaviour that can be observed in the new circuit after it has been clocked for c cycles after power-up, must have been present in the old circuit. In contrast to the work in <ref> [5, 6] </ref>, the synthesis method presented here does not require state space traversal, and can therefore be applied to large sequential circuits. Recursive learning has been used earlier for optimi-sation, as described in [7], but their method is applied only to combinational circuits and they do not use unobservability conditions. <p> Proof: From Lemma 2.5, we know from that for all 1 i n, n i is k i -cycle stuck-at-v i redundant in the circuit obtained by setting n j = v j for all j 6= i. It has been shown in <ref> [5] </ref> that for any circuits C, D and E, if C is an a-delay replacement for D and D is a b-delay replacement for E then C is (a + b)- delay replacement for E.
Reference: [6] <author> S. Qadeer, V. Singhal, R. K. Brayton, and C. Pixley, </author> <title> Latch Redundancy Removal without Global Reset, </title> <booktitle> in Proc. Intl. Conf. on Computer Design, </booktitle> <address> (Austin, TX), </address> <pages> pp. 432439, </pages> <month> Oct. </month> <year> 1996. </year>
Reference-contexts: This notion guarantees that every possible input-output behaviour that can be observed in the new circuit after it has been clocked for c cycles after power-up, must have been present in the old circuit. In contrast to the work in <ref> [5, 6] </ref>, the synthesis method presented here does not require state space traversal, and can therefore be applied to large sequential circuits. Recursive learning has been used earlier for optimi-sation, as described in [7], but their method is applied only to combinational circuits and they do not use unobservability conditions.
Reference: [7] <author> M. Chatterjee, D. K. Pradhan, and W. Kunz, </author> <title> LOT: Logic Optimization with Testability NewTransforma-tions using Recursive Learning, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <address> (San Jose, CA), </address> <pages> pp. 318325, </pages> <month> Nov. </month> <year> 1995. </year>
Reference-contexts: In contrast to the work in [5, 6], the synthesis method presented here does not require state space traversal, and can therefore be applied to large sequential circuits. Recursive learning has been used earlier for optimi-sation, as described in <ref> [7] </ref>, but their method is applied only to combinational circuits and they do not use unobservability conditions. Another procedure to do redundancy removal is described in [8], but as [9] shows, their notion of replacement is not compositional and may also identify redundancies which destroy the initialisability of the circuit.
Reference: [8] <author> L. Entrena and K.-T. Cheng, </author> <title> Sequential Logic Optimization by Redundancy Addition and Removal, </title> <booktitle> in Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <address> (Santa Clara, CA), </address> <pages> pp. 310315, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Recursive learning has been used earlier for optimi-sation, as described in [7], but their method is applied only to combinational circuits and they do not use unobservability conditions. Another procedure to do redundancy removal is described in <ref> [8] </ref>, but as [9] shows, their notion of replacement is not compositional and may also identify redundancies which destroy the initialisability of the circuit. We have therefore chosen to use the notion of safe delayed replacement which preserves responses to all initializing sequences. <p> C &lt; 10000 for a circuit would require the user to wait for at most 100 s before useful operation can begin. This is not a severe restriction. We are unable to compare sequential redundancy removal results with the previous work of Entrena and Cheng <ref> [8] </ref> be cause as we noted earlier, their notion of sequential replace-ment, which is based on the conservative 0,1,X-valued simulation, is not compositional (unlike the notion of delay replacement that we use). 4 Future Work Our redundancy removal algorithm does not find the complete set of redundancies.
Reference: [9] <author> M. A. Iyer, </author> <title> On Redundancy and Untestability in Sequential Circuits. </title> <type> PhD thesis, </type> <institution> Illinois Institute on Technology, </institution> <year> 1995. </year>
Reference-contexts: Recursive learning has been used earlier for optimi-sation, as described in [7], but their method is applied only to combinational circuits and they do not use unobservability conditions. Another procedure to do redundancy removal is described in [8], but as <ref> [9] </ref> shows, their notion of replacement is not compositional and may also identify redundancies which destroy the initialisability of the circuit. We have therefore chosen to use the notion of safe delayed replacement which preserves responses to all initializing sequences.
Reference: [10] <author> I. Pomeranz and S. M. Reddy, </author> <title> On Removing Redundancies from Synchronous Sequential Circuits with Synchronizing Sequences, </title> <journal> IEEE Trans. Computers, </journal> <volume> vol. 45, </volume> <pages> pp. </pages> <year> 2032, </year> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: We are interested in compositionality because we would like a notion of replacement that is valid without making any assumptions about the environment of the circuit. This is why our replacement notion is safer than that used in <ref> [10] </ref> which identifies sequential redundancies by preserving weak synchronizing sequences. Their work implicitly assumes that the environment of the circuit has total control so that it can supply the arbitrary sequence that the redundancy identification tool has in mind. Our approach does not pose any such restrictions.
Reference: [11] <author> E. M. Sentovich, K. J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. R. Stephan, R. K. Brayton, and A. L. Sangiovanni-Vincentelli, </author> <title> SIS: A System for Sequential Circuit Synthesis, </title> <type> Tech. Rep. </type> <institution> UCB/ERL M92/41, Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: We also show that for most examples, recursive learning gives better results then the simple implication propagation scheme. In fact for many circuits, recursive learning could identify redundancies where the simple implication propagation scheme is unable to find any. This algorithm was implemented in SIS <ref> [11] </ref>. The circuit was first optimised using script.rugged which performs combinational optimisation on the network. The optimised circuit was mapped with a library consisting of 2-input gates and inverters. The sequential redundancy removal algorithm was run on the mapped circuit.
References-found: 11

