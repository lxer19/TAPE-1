URL: http://www.cs.dartmouth.edu/~nicol/papers/ides/mascots-ides.ps
Refering-URL: http://www.cs.dartmouth.edu/~nicol/papers/ides/index.html
Root-URL: http://www.cs.dartmouth.edu
Title: IDES: A Java-based Distributed Simulation Engine  
Author: David M. Nicol Michael M. Johnson Ann S. Yoshimura Michael E. Goldsby 
Note: Science  
Affiliation: Department of Computer  Dartmouth College Sandia National Laboratories  
Abstract: This paper describes the design and performance of IDES, a Java-based distributed simulation engine being developed at Sandia National Laboratories. The feasability of using Java is demonstrated by achieving order of magnitude speedup gains, on a model with three quarters of a million simulated entities, on a off-the-shelf system of 56 PentiumPro processors. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Das, R. Fujimoto, K. Panesar, D. Allison, and M. Hybi-nette. GTW: </author> <title> A Time Warp system for shared memory multiprocessors. </title> <booktitle> In 1994 Winter Simulation Conference Proceedings, </booktitle> <pages> pages 13321339, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: The reclaimed memory is used then to save state in the next synchronization window. Memory control is an important issue in optimistic simulation. The best known parallel simulators, GTW <ref> [1] </ref> and SPEEDES [15] both control memory by initiating garbage collection periodically; essentially a processor garbage collects (also known as computing the global virtual time, or GVT) after every n events processed, where n is a configuration parameter.
Reference: [2] <author> Alois Ferscha and Michael Richter. </author> <title> Java based conservative distributed simulation. </title> <booktitle> In Proceedings of the 1997 Winter Simulation Conference, </booktitle> <pages> pages 381388, </pages> <address> Atlanta, </address> <month> December </month> <year> 1997. </year>
Reference-contexts: However, Page, Moose and Griffin have added functional distribution to simJava using Java's Remote Method Invocation (RMI) methods [10], although no performance or capability assessments are offered. Java-based distributed simulation using conservative synchronization has been reported by Ferscha and Richter in <ref> [2] </ref>. That project also explores the use of Java's RMI features in a simulation context. Capabilities in either problem size or processing speed are not assessed. Java is sparking interest in application to simulation in purely serial contexts as well [7, 5]. 2.
Reference: [3] <author> R. M. Fujimoto. </author> <title> Parallel discrete event simulation. </title> <journal> Communications of the ACM, </journal> <volume> 33(10):3053, </volume> <month> October </month> <year> 1990. </year>
Reference: [4] <author> Fabian Gomes, Brian Unger, John Cleary, and Steve Franks. </author> <title> Multiplexed state saving for bounded rollback. </title> <booktitle> In Proceedings of the 1997 Winter Simulation Conference, </booktitle> <pages> pages 460 467, </pages> <address> Atlanta, </address> <month> December </month> <year> 1997. </year>
Reference-contexts: The problem of reducing state-saving costs is another widely studied area in PADS (see the bibliography of <ref> [4] </ref>). At present IDES uses so-called copy saving, which means that prior to executing a wakeup at time t the variable portion of an entity's state is checkpointed in its entirety. In the future IDES will use more sophisticated incremental state-saving techniques.
Reference: [5] <author> Kevin Healy and Richard Kilgore. </author> <title> Silk : A Java-based process simulation language. </title> <booktitle> In Proceedings of the 1997 Winter Simulation Conference, </booktitle> <pages> pages 475482, </pages> <address> Atlanta, </address> <month> December </month> <year> 1997. </year>
Reference-contexts: That project also explores the use of Java's RMI features in a simulation context. Capabilities in either problem size or processing speed are not assessed. Java is sparking interest in application to simulation in purely serial contexts as well <ref> [7, 5] </ref>. 2. Distributed Simulation A distributed simulator like IDES is comprised of a collection of processors, each of which is assigned a group of entities to simulate.
Reference: [6] <author> G. Horton, R. Kulkarni, D. Nicol, and K. Trivedi. </author> <title> Fluid stochastic petri nets: Theory, application, and solution. </title> <journal> Eu-ropean Journal on Operations Research. </journal> <note> To appear. </note>
Reference-contexts: In that class, the calculation an entity performs to determine its next wakeup time is the numerical integration of a differential equation. An example of such in communications modeling is when one uses a Fluid Stochastic Petri Net (FSPN) to model the network <ref> [6] </ref>. Differential models describe fluid flow; in an IDES implementation of FSPN one might integrate to determine when, in the absence of further changes in the inflow behavior, the fluid level at a fluid place reaches a critical threshold; that time becomes its next wakeup time.
Reference: [7] <author> Wolfgang Kreutzer, Jane Hopkins, and Marcel van Mierlo. </author> <title> SimJavaa framework for modeling queueing networks in Java. </title> <booktitle> In Proceedings of the 1997 Winter Simulation Conference, </booktitle> <pages> pages 483488, </pages> <address> Atlanta, </address> <month> December </month> <year> 1997. </year>
Reference-contexts: That project also explores the use of Java's RMI features in a simulation context. Capabilities in either problem size or processing speed are not assessed. Java is sparking interest in application to simulation in purely serial contexts as well <ref> [7, 5] </ref>. 2. Distributed Simulation A distributed simulator like IDES is comprised of a collection of processors, each of which is assigned a group of entities to simulate.
Reference: [8] <author> D. M. Nicol and R. M. Fujimoto. </author> <title> Parallel simulation today. </title> <journal> Annals of Operations Research, </journal> <volume> 53:249286, </volume> <month> December </month> <year> 1994. </year>
Reference: [9] <author> David Nicol, Michael Johnson, Ann Yoshimura, and Michael Goldsby. </author> <title> Performance modeling of the ides framework. </title> <booktitle> In Proceedings of the 1997 Workshop on Parallel and Distributed Simulation, </booktitle> <pages> pages 3845, </pages> <address> Lockenhaus, Austria, </address> <month> June </month> <year> 1997. </year>
Reference-contexts: As a consequence, IDES global event horizons are larger, so more simulation work is accomplished per synchronization window. Another contribution made by the IDES project was in describ 1 All the literature on BTB defines the event horizon more restrictively. We comment on this later. ing the pre-emptive min-reduction <ref> [9] </ref>, yet another in not-ing and studying when it makes sense to alter the BTB message passing scheme.
Reference: [10] <author> Ernest Page, Robert Moose Jr., and Sean Griffin. </author> <title> Web-based simulation in simJava using remote method invocation. </title> <booktitle> In Proceedings of the 1997 Winter Simulation Conference, </booktitle> <pages> pages 468474, </pages> <address> Atlanta, </address> <month> December </month> <year> 1997. </year>
Reference-contexts: It provides a process-oriented modeling environment, complete with animation classes. However, simJava is unsuitable for our purposes as it neither supports distributed simulation, and its construction makes it performance-challenged. However, Page, Moose and Griffin have added functional distribution to simJava using Java's Remote Method Invocation (RMI) methods <ref> [10] </ref>, although no performance or capability assessments are offered. Java-based distributed simulation using conservative synchronization has been reported by Ferscha and Richter in [2]. That project also explores the use of Java's RMI features in a simulation context. Capabilities in either problem size or processing speed are not assessed.
Reference: [11] <author> William Pugh. </author> <title> Skip lists: A probabilistic alternative to balanced trees. </title> <booktitle> In Proceedings of the Workshop on Algorithms and Data Structures, </booktitle> <address> Ottawa, Canada, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: The requirements of a central event queue can be determined from these operations we've described. Insertions, deletions, and searches must all be handled efficiently. There are a number of suitable data-structures, almost all of them are complex. The simplest of the group is the Skiplist <ref> [11] </ref>, a randomized data structure that supports each operation in logarithmic time, with high probability. The IDES central event list is a Skiplist, chosen largely because of its simplicity.
Reference: [12] <author> Robert Ronngren and Rasul Ayani. </author> <title> A comparative study of parallel and sequential priority queue algorithms. </title> <booktitle> ACM Transactions on Modeling and Computer Simulation, </booktitle> <address> 7(2):157209, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: The IDES central event list is a Skiplist, chosen largely because of its simplicity. There remains a great deal of interest in identifying the best event-list algorithm (e.g., see <ref> [12] </ref>), however, the cost of event-list management pales against the computational overhead we expect for IDES applications, so our only concern is that the algorithm used be efficient and scalable. The Skiplist satisfies that requirement nicely. 4.
Reference: [13] <author> J. Steinman. </author> <title> Discrete-event simulation and the event horizon. </title> <booktitle> In Proceedings of the 1994 Workshop on Parallel and Distributed Simulation, </booktitle> <pages> pages 3949, </pages> <address> Edinburgh, Scotland, </address> <year> 1994. </year> <booktitle> The Society of Computer Simulation. </booktitle>
Reference-contexts: All off-processor messages generated by executing events in [t; g (t)) are known then to be correct, and can be incorporated into the simulation's state for evaluation in future synchronization windows. There are a number of papers concerning BTB and modifications to its implementation <ref> [15, 13, 14] </ref>. IDES has made additional ones. First, the original notion of event horizon (and all the literature describing it) is in terms of entity local event horizons; from our perspective it is as though every entity executes on its own processor. <p> The last requirement is that the data-structure efficiently support rollback and reconstruction. Jeff Steinman, the inventor of BTB, has written about data structures used in his tool <ref> [13, 14] </ref>. Without going into details, we observe that our definition of the event horizon is different than hishis BTB window is defined as the least receive-time among all messages generated, ours is defined as the least receive-time among all off-processor messages.
Reference: [14] <author> J. Steinman. </author> <title> Discrete-event simulation and the event horizon part 2: Event list management. </title> <booktitle> In Proceedings of the 1996 Workshop on Parallel and Distributed Simulation, </booktitle> <pages> pages 170178, </pages> <address> Philadelphia, 1996. </address> <publisher> IEEE Press. </publisher>
Reference-contexts: All off-processor messages generated by executing events in [t; g (t)) are known then to be correct, and can be incorporated into the simulation's state for evaluation in future synchronization windows. There are a number of papers concerning BTB and modifications to its implementation <ref> [15, 13, 14] </ref>. IDES has made additional ones. First, the original notion of event horizon (and all the literature describing it) is in terms of entity local event horizons; from our perspective it is as though every entity executes on its own processor. <p> The last requirement is that the data-structure efficiently support rollback and reconstruction. Jeff Steinman, the inventor of BTB, has written about data structures used in his tool <ref> [13, 14] </ref>. Without going into details, we observe that our definition of the event horizon is different than hishis BTB window is defined as the least receive-time among all messages generated, ours is defined as the least receive-time among all off-processor messages.
Reference: [15] <author> J.S. Steinman. SPEEDES: </author> <title> Synchronous parallel environment for emulation and discrete event simulation. </title> <booktitle> In Advances in Parallel and Distributed Simulation, </booktitle> <volume> volume 23, </volume> <pages> pages 95103. </pages> <booktitle> SCS Simulation Series, </booktitle> <month> Jan. </month> <year> 1991. </year>
Reference-contexts: All off-processor messages generated by executing events in [t; g (t)) are known then to be correct, and can be incorporated into the simulation's state for evaluation in future synchronization windows. There are a number of papers concerning BTB and modifications to its implementation <ref> [15, 13, 14] </ref>. IDES has made additional ones. First, the original notion of event horizon (and all the literature describing it) is in terms of entity local event horizons; from our perspective it is as though every entity executes on its own processor. <p> The reclaimed memory is used then to save state in the next synchronization window. Memory control is an important issue in optimistic simulation. The best known parallel simulators, GTW [1] and SPEEDES <ref> [15] </ref> both control memory by initiating garbage collection periodically; essentially a processor garbage collects (also known as computing the global virtual time, or GVT) after every n events processed, where n is a configuration parameter.
References-found: 15

