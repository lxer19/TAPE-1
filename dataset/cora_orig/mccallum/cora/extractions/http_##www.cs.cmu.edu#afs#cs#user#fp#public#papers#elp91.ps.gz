URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/papers/elp91.ps.gz
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/fp/public/papers/
Root-URL: 
Title: Natural Semantics and Some of its Meta-Theory in Elf  
Author: Spiro Michaylov and Frank Pfenning 
Date: 20, 1991  
Note: August  
Address: Pittsburgh, Pennsylvania 15123-3890  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: Appearing as Technical Report MPI-I-91-211 Max-Planck-Institute for Computer Science Im Stadtwald W 6600 Saarbrucken Germany Abstract Operational semantics provide a simple, high-level and elegant means of specifying interpreters for programming languages. In natural semantics, a form of operational semantics, programs are traditionally represented as first-order tree structures and reasoned about using natural deduction-like methods. Hannan and Miller combined these methods with higher-order representations using Prolog. In this paper we go one step further and investigate the use of the logic programming language Elf to represent natural semantics. Because Elf is based on the LF Logical Framework with dependent types, it is possible to write programs that reason about their own partial correctness. We illustrate these techniques by giving type checking rules and operational semantics for Mini-ML, a small functional language based on a simply typed -calculus with polymor-phism, constants, products, conditionals, and recursive function definitions. We also partially internalize proofs for some meta-theoretic properties of Mini-ML, the most difficult of which is subject reduction. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Rod Burstall and Furio Honsell. </author> <title> A natural deduction treatment of operational semantics. </title> <editor> In K. V. Nori and S. Kumar, editors, </editor> <booktitle> 8th Conference on Foundations of Software Technology and Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> December </month> <year> 1988. </year>
Reference-contexts: Natural semantics was inspired by the work of Plotkin [19] on operational semantics and extended by G. Kahn [12] and others. Programs are traditionally represented as first-order tree structures and reasoned about using natural deduction-like methods. This method was extended and refined by Burstall and Honsell <ref> [1] </ref> and Hannan and Miller [6, 7]. Using higher-order abstract syntax, programs are represented by simply-typed -terms and schema variables in inference rules become higher-order variables.
Reference: [2] <author> Alonzo Church. </author> <title> A formulation of the simple theory of types. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 5 </volume> <pages> 56-68, </pages> <year> 1940. </year>
Reference-contexts: This approach was inspired by Church <ref> [2] </ref> and Martin-Lof [15] and is used pervasively in many applications of Prolog and Elf. In each case, a -calculus-based meta-language (here Elf) is used to represent expressions of the object language (here Mini-ML).
Reference: [3] <author> Dominique Clement, Joelle Despeyroux, Thierry Despeyroux, and Gilles Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In Proceedings of the 1986 Conference on LISP and Functional Programming. </booktitle> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: Prolog was a particularly appropriate tool because its embedded implication mechanism is suitable for expressing hypothetical judgments in natural deduction, and it's higher-order features make it suitable for representing programs in terms of higher-order abstract syntax. Mini-ML was introduced by Clement et al. <ref> [3] </ref> as a small programming language based on the simply typed -calculus with products, conditionals, and recursive function definitions. In this paper we use Elf [16, 17], a logic programming language based on the LF Logical Framework [10], as an implementation language for natural semantics. <p> The most complicated example in this class is the subject reduction property for our language. Complete listings of the Elf code discussed are given in the appendices. 2 The Mini-ML Language Mini-ML <ref> [3] </ref> is a functional programming language based on a simply typed -calculus with poly-morphism, constants, products, conditionals, and recursive function definitions. The language we define here is a slight variation because patterns are replaced with explicit projections to simplify the presentation.
Reference: [4] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212. </pages> <note> ACM REFERENCES 52 SIGPLAN/SIGACT, </note> <year> 1982. </year>
Reference-contexts: Furthermore, we say that (x) = t if the rightmost occurrence of x in is assigned t . Type assignment in an environment is written as x : t . Harper [9] studied several formulations for the Damas-Milner fragment of ML <ref> [4] </ref>, with a view toward their formalization in LF, and discussed their suitability for direct execution. We use a simpler encoding that is sufficient for our purposes.
Reference: [5] <author> Scott Dietzen and Frank Pfenning. </author> <title> A declarative alternative to assert in logic programming. </title> <editor> In Vijay Saraswat, editor, </editor> <booktitle> International Logic Programming Symposium. </booktitle> <publisher> MIT Press, </publisher> <month> October </month> <year> 1991. </year> <note> To appear. Available as Ergo Report 90-094. </note>
Reference-contexts: However, these free variables cannot be statically predetermined. Thus, if Mini-ML type unification is to be represented by Elf unification, such abstraction cannot be represented in Elf. Dietzen and Pfenning <ref> [5] </ref> show how this problem can be overcome for Prolog by adding a special construct called rule to the language, and a similar extension to Elf seems to be possible.
Reference: [6] <author> John Hannan. </author> <title> Investigating a Proof-Theoretic Meta-Language for Functional Programs. </title> <type> PhD thesis, </type> <institution> University of Pennsylvania, </institution> <year> 1990. </year>
Reference-contexts: Kahn [12] and others. Programs are traditionally represented as first-order tree structures and reasoned about using natural deduction-like methods. This method was extended and refined by Burstall and Honsell [1] and Hannan and Miller <ref> [6, 7] </ref>. Using higher-order abstract syntax, programs are represented by simply-typed -terms and schema variables in inference rules become higher-order variables. Further, they applied methods for introducing and discharging assumptions (for expressing hypothetical judgments) and parameters (for expressing generic or universal judgments) to this setting of natural semantics. <p> Again we will consider the alternative later. Embodied in these rules is the decision that we would like to implement a call-by-value semantics for Mini-ML. It would be a simple matter to rewrite the rules to implement a call-by-name discipline instead <ref> [6] </ref>. Next we will look at a sample evaluation expressed both as a derivation in our formal system and as an Elf deduction.
Reference: [7] <author> John Hannan and Dale Miller. </author> <title> Enriching a meta-language with higher-order features. </title> <editor> In John Lloyd, editor, </editor> <booktitle> Proceedings of the Workshop on Meta-Programming in Logic Programming, </booktitle> <address> Bristol, England, </address> <month> June </month> <year> 1988. </year> <institution> University of Bristol. </institution>
Reference-contexts: Kahn [12] and others. Programs are traditionally represented as first-order tree structures and reasoned about using natural deduction-like methods. This method was extended and refined by Burstall and Honsell [1] and Hannan and Miller <ref> [6, 7] </ref>. Using higher-order abstract syntax, programs are represented by simply-typed -terms and schema variables in inference rules become higher-order variables. Further, they applied methods for introducing and discharging assumptions (for expressing hypothetical judgments) and parameters (for expressing generic or universal judgments) to this setting of natural semantics. <p> Harper [9] studied several formulations for the Damas-Milner fragment of ML [4], with a view toward their formalization in LF, and discussed their suitability for direct execution. We use a simpler encoding that is sufficient for our purposes. The idea for this also goes back to Hannan and Miller <ref> [7] </ref>. 2 THE MINI-ML LANGUAGE 6 of t ` true 2 Bool of f ` false 2 Bool of if ` e 1 2 Bool ` e 2 2 t ` e 3 2 t ` if e 1 then e 2 else e 3 2 t of z of s <p> Again we will leave the full listing to Appendix C, and describe some highlights here. The semantics we describe here is a call-by-value semantics. This could easily be modified to describe call-by-name instead (see <ref> [7] </ref>). We begin with the declaration of the evaluation predicate neval: neval : exp -&gt; exp -&gt; type. The first argument is a Mini-ML expression, and the second argument is the value of that Mini-ML expression.
Reference: [8] <author> John Hannan and Dale Miller. </author> <title> From operational semantics to abstract machines: Preliminary results. </title> <editor> In M. Wand, editor, </editor> <booktitle> ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 323-332. </pages> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference-contexts: In doing so, we have extended the now well-known methodology for representing operational semantics. All the examples in the paper have been tested with the current prototype implementation of Elf. Many tasks remain to be done to complete this line of research. In <ref> [8] </ref>, Hannan and Miller systematically transform a high-level description of a language related to Mini-ML in terms of inference rules into two low-level abstract machines. We believe that most, if not all of these transformations should be representable in Elf as judgments on deductions, and this should be investigated.
Reference: [9] <author> Robert Harper. </author> <title> Systems of polymorphic type assignment in LF. </title> <type> Technical Report CMU-CS-90-144, </type> <institution> Carnegie Mellon University, Pittsburgh, Pennsylvania, </institution> <month> June </month> <year> 1990. </year>
Reference-contexts: Furthermore, we say that (x) = t if the rightmost occurrence of x in is assigned t . Type assignment in an environment is written as x : t . Harper <ref> [9] </ref> studied several formulations for the Damas-Milner fragment of ML [4], with a view toward their formalization in LF, and discussed their suitability for direct execution. We use a simpler encoding that is sufficient for our purposes. <p> For a number of variants of declarative presentations of the type system with explicit type schemas, see <ref> [9] </ref>. 4.3 Natural Operational Semantics Sometimes the most "natural" semantics for a programming language is "nondeterministic" in the sense that its execution would require backtracking in our chosen implementation language. However, the corresponding "deterministic" version is usually more efficient, and probably corresponds more closely to practical applications.
Reference: [10] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <journal> Journal of the ACM, </journal> <note> To appear. A preliminary version appeared in Symposium on Logic in Computer Science, pages 194-204, </note> <month> June </month> <year> 1987. </year>
Reference-contexts: Mini-ML was introduced by Clement et al. [3] as a small programming language based on the simply typed -calculus with products, conditionals, and recursive function definitions. In this paper we use Elf [16, 17], a logic programming language based on the LF Logical Framework <ref> [10] </ref>, as an implementation language for natural semantics. Elf embodies the same features that make Prolog so suitable for implementing natural semantics. <p> The interested reader is referred to <ref> [10] </ref> for more formal versions of propositions like the above. These refer to the existence of compositional bijections, which are basically those where variables in the object language are represented by variables in the meta-language.
Reference: [11] <author> Robert Harper and Frank Pfenning. </author> <title> Modularity in the LF logical framework. Talk given at the Second Workshop on Logical Frameworks, </title> <publisher> Edinburgh, </publisher> <address> Scotland, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: More fundamental is the question how to achieve the complete formalization of the meta-theoretic properties of languages implemented in Elf. We have begun to investigate such possibilities based on the preliminary design of a module system for Elf <ref> [11] </ref>. Acknowledgements We are grateful to Bob Harper for commenting on some preliminary drafts. Thanks also to the Max-Planck-Institute for Computer Science in Saarbrucken, where the second author completed the paper during an extended visit.
Reference: [12] <author> G. Kahn. </author> <title> Natural semantics. </title> <booktitle> In Proceedings of the Symposium on Theoretical Aspects of Computer Science, </booktitle> <pages> pages 22-39. </pages> <publisher> Springer-Verlag LNCS 247, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Operational semantics provide a simple, high-level and elegant means of specifying interpreters for programming languages. Natural semantics was inspired by the work of Plotkin [19] on operational semantics and extended by G. Kahn <ref> [12] </ref> and others. Programs are traditionally represented as first-order tree structures and reasoned about using natural deduction-like methods. This method was extended and refined by Burstall and Honsell [1] and Hannan and Miller [6, 7].
Reference: [13] <author> Dale Miller. </author> <title> Unification of simply typed lambda-terms as logic programming. </title> <booktitle> In Proceedings of the Eigth International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <month> July </month> <year> 1991. </year>
Reference-contexts: All other cases are mere congruence cases, descending into the subcomponents where the necessary substitutions might eventually be performed. An exposition of this general technique can be found in <ref> [13] </ref> in the context of the simply-typed -calculus. These ideas can be applied here, too. We discuss a couple of cases. sbst_t : sbst ([x] [d] of_t) P of_t. In the base case, the assumption d is not used, and we simply return the deduction of t unchanged.
Reference: [14] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <volume> Volume 1, </volume> <pages> pages 810-827, </pages> <address> Cambridge, Massachusetts, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Further, they applied methods for introducing and discharging assumptions (for expressing hypothetical judgments) and parameters (for expressing generic or universal judgments) to this setting of natural semantics. Thus it was natural that Hannan and Miller's implementation language was Prolog <ref> [14] </ref>. Prolog was a particularly appropriate tool because its embedded implication mechanism is suitable for expressing hypothetical judgments in natural deduction, and it's higher-order features make it suitable for representing programs in terms of higher-order abstract syntax.
Reference: [15] <author> Bengt Norstrom, Kent Petersson, and Jan M. Smith. </author> <title> Programming in Martin-Lof 's Type Theory: An Introduction, </title> <booktitle> volume 7 of International Series of Monographs on Computer Science. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1990. </year>
Reference-contexts: This approach was inspired by Church [2] and Martin-Lof <ref> [15] </ref> and is used pervasively in many applications of Prolog and Elf. In each case, a -calculus-based meta-language (here Elf) is used to represent expressions of the object language (here Mini-ML). This enables variable binding in the object language to be represented with the help of -abstraction in the meta-language.
Reference: [16] <author> Frank Pfenning. </author> <title> Elf: A language for logic definition and verified meta-programming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 313-322. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1989. </year> <note> Also available as Ergo Report 89-067, </note> <institution> School of Computer Science, Carnegie Mellon University, Pittsburgh. </institution>
Reference-contexts: Mini-ML was introduced by Clement et al. [3] as a small programming language based on the simply typed -calculus with products, conditionals, and recursive function definitions. In this paper we use Elf <ref> [16, 17] </ref>, a logic programming language based on the LF Logical Framework [10], as an implementation language for natural semantics. Elf embodies the same features that make Prolog so suitable for implementing natural semantics. <p> A formal discussion of the language can be found in <ref> [16, 17] </ref>, but here we take a more pragmatic approach. As our running example we will use parts of the abstract syntax and type inference and semantics for a higher-order formulation of Mini-ML, based on the syntax and rules in Section 2.
Reference: [17] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gor-don D. Plotkin, editors, </editor> <title> Logical Frameworks. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year> <note> To appear. REFERENCES 53 </note>
Reference-contexts: Mini-ML was introduced by Clement et al. [3] as a small programming language based on the simply typed -calculus with products, conditionals, and recursive function definitions. In this paper we use Elf <ref> [16, 17] </ref>, a logic programming language based on the LF Logical Framework [10], as an implementation language for natural semantics. Elf embodies the same features that make Prolog so suitable for implementing natural semantics. <p> A formal discussion of the language can be found in <ref> [16, 17] </ref>, but here we take a more pragmatic approach. As our running example we will use parts of the abstract syntax and type inference and semantics for a higher-order formulation of Mini-ML, based on the syntax and rules in Section 2. <p> Using Elf's module system, one can explicitly distinguish the various roles of declarations. For the purposes of this paper, we will only use the Elf core language and give interpretations informally. Further discussion on this subject can be found in Section 8 and <ref> [17] </ref>. 3.1 Type and Type Family Declarations The first kind of declaration is that of a constant type or type family.
Reference: [18] <author> Frank Pfenning and Conal Elliott. </author> <title> Higher-order abstract syntax. </title> <booktitle> In Proceedings of the SIG-PLAN '88 Symposium on Language Design and Implementation, Atlanta, Georgia, </booktitle> <pages> pages 199-208. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1988. </year> <note> Available as Ergo Report 88-036, </note> <institution> School of Computer Science, Carnegie Mellon University, Pittsburgh. </institution>
Reference-contexts: This introduces two abstractions whereas the concrete syntax contains only one. This means that we might have to ff-convert one to the other in order to obtain the concrete Mini-ML syntax for a letrec expression. For a more general solution in the presence of meta-language pairing, see <ref> [18] </ref>.
Reference: [19] <author> Gordon D. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, Aarhus, Denmark, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: 1 Introduction Operational semantics provide a simple, high-level and elegant means of specifying interpreters for programming languages. Natural semantics was inspired by the work of Plotkin <ref> [19] </ref> on operational semantics and extended by G. Kahn [12] and others. Programs are traditionally represented as first-order tree structures and reasoned about using natural deduction-like methods. This method was extended and refined by Burstall and Honsell [1] and Hannan and Miller [6, 7].
References-found: 19

