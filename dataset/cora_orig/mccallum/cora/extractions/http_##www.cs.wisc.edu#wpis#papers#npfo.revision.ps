URL: http://www.cs.wisc.edu/wpis/papers/npfo.revision.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: New Programs From Old  
Author: G. RAMALINGAM and THOMAS REPS 
Affiliation: University of Wisconsin-Madison  
Abstract: This paper studies operations for creating new variants of a program that relate, in a well-defined way, to existing variants of the program. We formalize a program modification as a (special kind of) function from programs to programs, and study the algebra of these program modifications. We make use of the algebraic structure to formalize several intuitive concepts, such as that of compatibility among program modifications, and establish several new results concerning the problems of program merging and separating consecutive edits. We also identify a category in which the objects are programs and the morphisms are program modifications, and show how program integration relates to the pushout in this category. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Asperti, A. and Longo, G., </author> <title> Categories, Types, and Structures: An Introduction to Category Theory for the Working Computer Scientist, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA (1991). </address>
Reference-contexts: A preliminary version of this work appeared in the Proceedings of the Second International Conference on Algebraic Methodology and Software Technology (AMAST), <ref> (Iowa City, Iowa, May 22-25, 1991) </ref> [10]. Authors' address: Computer Sciences Department, University of Wisconsin-Madison, 1210 W. Dayton St., Madison, WI 53706. <p> Hence, D (a,b) . . &lt;a,a &gt; - &lt;b,b &gt;. That is, D (a,b) m . - &lt;b,b &gt; D (a,b). Hence, the result follows. ` A morphism m from an object b to an object a is said to be a principal morphism (see <ref> [1] </ref>, for instance) if for every morphism m 1 from b to a there exists a morphism m 2 from b to itself such that m 1 = m b m 2 . (See Figure 5.5 (a).) We now show that in category CC the morphism from program b to a
Reference: 2. <author> Berzins, V., </author> <title> On merging software extensions, </title> <note> Acta Informatica 23 pp. </note> <month> 607-619 </month> <year> (1986). </year>
Reference-contexts: Propagating changes through multiple versions Suppose a tree or dag of related versions of a program exists. The goal is to make the same enhancement or bug-fix to all of them. Several other papers <ref> [2, 6, 15] </ref> have investigated such operations at the concrete level (i.e., by defining algorithms for them that work on particular concrete representations of programs). In this paper, we investigate such operations at an abstract level. <p> As explained in the Introduction, the two-variant program-integration problem is only one of many situations that might arise during the program-development process. A less general version of the problem is the problem of merging software extensions, addressed by Berzins <ref> [2] </ref>, where there is no base programmerely two programs that need to be merged. A more general version of the problem is the integration of n variants of a base program, instead of just two variants.
Reference: 3. <author> Ferrante, J., Ottenstein, K., and Warren, J., </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 9(3) pp. </pages> <month> 319-349 (July </month> <year> 1987). </year> <month> - 44 </month> - 
Reference-contexts: We now describe a concrete example of a Brouwerian algebra of programs. The HPR integration algorithm makes use of a program representation called a program dependence graph <ref> [3, 7] </ref>. Let s be a vertex of a program dependence graph G. The slice of G with respect to s, denoted by G/s, is a graph induced by all vertices on which s has a transitive flow or control dependence.
Reference: 4. <author> Fraser, C.W., </author> <title> Maintaining program variants by merging editor scripts, </title> <journal> SoftwarePractice and Experience 10 pp. </journal> <month> 817-821 </month> <year> (1980). </year>
Reference-contexts: The program diff (with the option -e) implements D , while the editor ed implements apply. The integration operation that results if we define the operator + to be file concatenation is essentially the UNIX utility diff3. However, other definitions of the operator + are possible too. Fraser <ref> [4] </ref>, for instance, outlines a method for merging two editor command scripts into a single equivalent one that leads to a different integration algorithm.
Reference: 5. <author> Goldblatt, R., </author> <title> Topoi: The Categorical Analysis of Logic, </title> <booktitle> Studies in Logic and the Foundations of Mathematics, </booktitle> <volume> Vol. 98, </volume> <publisher> North-Holland, </publisher> <address> Amsterdam (1979, </address> <note> Revised Edition: </note> <year> 1984). </year>
Reference-contexts: Thus, the two inner squares are pushouts. The Pushout Lemma of category theory says that, under these conditions, the outer rectangle (diagram 8.13 (e)) must itself be a pushout. (See <ref> [5] </ref>, for instance.) In particular, this means that b [[base]]base must be equal to b [[a]](a [[base]]base), for all base, base, a and b. But this is not true.
Reference: 6. <author> Horwitz, S., Prins, J., and Reps, T., </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(3) pp. </pages> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: Propagating changes through multiple versions Suppose a tree or dag of related versions of a program exists. The goal is to make the same enhancement or bug-fix to all of them. Several other papers <ref> [2, 6, 15] </ref> have investigated such operations at the concrete level (i.e., by defining algorithms for them that work on particular concrete representations of programs). In this paper, we investigate such operations at an abstract level. <p> A program consists of one or more program components. Hence, a program may be viewed as a set of program components. However, not every set or collection of program components is a program. The integration algorithm described by Horwitz et al. <ref> [6] </ref>, referred to as the HPR algorithm hereafter, decomposes a program into its constituent components, compares two programs a and base and determines what components were added to base and what components of base were preserved in developing program a from base. <p> However, the above approach is not the only one to the problem of separating consecutive edits. Other solutions have been previously proposed for this problem. The very first solution proposed was the re-rooting solution <ref> [6] </ref>: here, c [[a]]base is taken to be the desired program. A second solution previously proposed [13] was that the program we seek is a solution x (called a compatible integrand with respect to base, a and c) to the equation a [[base ]]x = c.
Reference: 7. <author> Kuck, D.J., Kuhn, R.H., Leasure, B., Padua, D.A., and Wolfe, M., </author> <title> Dependence graphs and compiler optimizations, pp. </title> <booktitle> 207-218 in Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Williamsburg, VA, </address> <month> January 26-28, </month> <year> 1981), </year> <booktitle> ACM, </booktitle> <address> New York, NY (1981). </address>
Reference-contexts: We now describe a concrete example of a Brouwerian algebra of programs. The HPR integration algorithm makes use of a program representation called a program dependence graph <ref> [3, 7] </ref>. Let s be a vertex of a program dependence graph G. The slice of G with respect to s, denoted by G/s, is a graph induced by all vertices on which s has a transitive flow or control dependence.
Reference: 8. <author> McKinsey, J.C.C. and Tarski, A., </author> <title> On closed elements in closure algebras, </title> <note> Annals of Mathematics 47(1) pp. </note> <month> 122-162 (January </month> <year> 1946). </year>
Reference-contexts: The integration algorithm integrates variants a and b of base by putting together the program components in a . base, - 4 - . base and a cddc base cddc b, obtaining (a . base) ciic (a cddc base cddc b) ciic (b . base). Definition 2.1. <ref> [8] </ref> A Brouwerian algebra is an algebra (P, ciic , cddc , . - , dcd ) where (i) (P, ciic , cddc ) is a lattice (with ciic denoting the join operator, and cddc denoting the meet operator) with greatest element dcd . <p> It can be shown that a Brouwerian algebra has a least element, given by dcd . - dcd , which will be denoted by ^. Definition 2.2. <ref> [8] </ref> A double Brouwerian algebra is an algebra (P, ciic , cddc , . . .- , dcd ) where both (P, ciic , cddc , . - , dcd ) and (P, cddc , ciic , . - dcd ) are Brouwerian algebras. <p> Note that the deletion from a of the final use of y does not get overridden. ` The appendix contains a list of the more important laws that hold in double Brouwerian algebras. The reader is referred to <ref> [8, 11, 13, 14] </ref> for a more comprehensive discussion of the algebraic laws that hold in Brouwerian algebras and double Brouwerian algebras. <p> The material presented here is meant to make this paper self contained; proofs of the following propositions and further information about Brouwerian algebras can be found in <ref> [8, 11, 14] </ref>.
Reference: 9. <author> Ramalingam, G. and Reps, T., </author> <title> A theory of program modifications, pp. </title> <booktitle> 137-152 in Proceedings of the Colloquium on Combining Paradigms for Software Development, </booktitle> <address> (Brighton, UK, </address> <month> April 8-12, </month> <year> 1991), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 494, </volume> <editor> ed. S. Abramsky and T.S.E. Maibaum,Springer-Verlag, </editor> <address> New York, NY (1991). </address>
Reference-contexts: A preliminary version of this work appeared in the Proceedings of the Second International Conference on Algebraic Methodology and Software Technology (AMAST), <ref> (Iowa City, Iowa, May 22-25, 1991) </ref> [10]. Authors' address: Computer Sciences Department, University of Wisconsin-Madison, 1210 W. Dayton St., Madison, WI 53706. <p> Towards An Algebra Of Program Modifications 3.1. The fm-algebraic framework The goal of program-integration is to merge or combine changes made to some program. The concept of a change made to a program or a program-modification was formalized in <ref> [9] </ref> - 7 - and made use of in providing an alternative definition of integration. We briefly review this formalism below. Definition 3.1. <p> These two definitions yield the same ternary operator. Theorem 6.1. <ref> [9] </ref> a [[base]]b = a [base]b.
Reference: 10. <author> Ramalingam, G. and Reps, T., </author> <title> Modification algebras, </title> <booktitle> in Proceedings of the Second International Conference on Algebraic Methodology and Software Technology (AMAST), </booktitle> <address> (Iowa City, Iowa, </address> <month> May 22-25, </month> <year> 1991), </year> <editor> ed. C. Rat-tray and T. </editor> <month> Rus,Springer-Verlag </month> <year> (1992). </year>
Reference-contexts: A preliminary version of this work appeared in the Proceedings of the Second International Conference on Algebraic Methodology and Software Technology (AMAST), (Iowa City, Iowa, May 22-25, 1991) <ref> [10] </ref>. Authors' address: Computer Sciences Department, University of Wisconsin-Madison, 1210 W. Dayton St., Madison, WI 53706. E-mail: -ramali, reps-@cs.wisc.edu - 2 - an undesirable semantic interaction, and if they do not, create a program that incor porates the two changes (as well as what is common to all three programs).
Reference: 11. <author> Rasiowa, H. and Sikorski, R., </author> <title> The Mathematics of Metamathematics, </title> <publisher> Polish Scientific Publishers, </publisher> <address> Warsaw (1963). </address>
Reference-contexts: Note that the deletion from a of the final use of y does not get overridden. ` The appendix contains a list of the more important laws that hold in double Brouwerian algebras. The reader is referred to <ref> [8, 11, 13, 14] </ref> for a more comprehensive discussion of the algebraic laws that hold in Brouwerian algebras and double Brouwerian algebras. <p> The material presented here is meant to make this paper self contained; proofs of the following propositions and further information about Brouwerian algebras can be found in <ref> [8, 11, 14] </ref>.
Reference: 12. <author> Reps, T. and Yang, W., </author> <title> The semantics of program slicing and program integration, pp. </title> <booktitle> 360-374 in Proceedings of the Colloquium on Current Issues in Programming Languages, </booktitle> <address> (Barcelona, Spain, March 13-17, </address> <year> 1989), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 352, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, NY (1989). </address>
Reference-contexts: The integrated program is essentially constructed from the single-point slices - 5 - occurring in the base program and the variants. The semantic justification of the algorithm follows from the results of <ref> [12] </ref>, which relates the semantics of a slice of a program to the semantics of the program itself. A subset A of G 1 is said to be a downwards-closed set if for every x A and y i cdidi i x, y A.
Reference: 13. <author> Reps, T., </author> <title> Algebraic properties of program integration, pp. </title> <booktitle> 326-340 in Proceedings of the Third European Symposium on Programming, </booktitle> <address> (Copenhagen, Denmark, </address> <month> May 15-18, </month> <year> 1990), </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 432, </volume> <editor> ed. N. Jones,Springer-Verlag, </editor> <address> New York, NY (1990). </address>
Reference-contexts: Note that the deletion from a of the final use of y does not get overridden. ` The appendix contains a list of the more important laws that hold in double Brouwerian algebras. The reader is referred to <ref> [8, 11, 13, 14] </ref> for a more comprehensive discussion of the algebraic laws that hold in Brouwerian algebras and double Brouwerian algebras. <p> Other solutions have been previously proposed for this problem. The very first solution proposed was the re-rooting solution [6]: here, c [[a]]base is taken to be the desired program. A second solution previously proposed <ref> [13] </ref> was that the program we seek is a solution x (called a compatible integrand with respect to base, a and c) to the equation a [[base ]]x = c. The solution we have proposed above is to redo the second modification on the original program. <p> But this is not true. For instance, choose base and a to be two different programs, and choose base to be a and b to be base. Reps <ref> [13] </ref> shows that the Brouwerian program integration operation satisfies the following two properties: (1) x [[x]]y = y = y [[x]]x and (2) y [[x ]]y = y. Consequently, b [[base]]base = base [[base]]a (by choice of b and base ) = a (by (1)).
Reference: 14. <author> Reps, T., </author> <title> Algebraic properties of program integration, </title> <booktitle> Science of Computer Programming 17 pp. </booktitle> <month> 139-215 </month> <year> (1991). </year>
Reference-contexts: associativity means: If three variants of a given base are to be integrated by a pair of two-variant integrations, the same result is produced no matter which two variants are integrated first.) This paper is a follow-on to an earlier study of the algebraic properties of program integration by Reps <ref> [14] </ref>. However, whereas Reps's work concerns a homogeneous algebra of programs, the work reported in this paper concerns a heterogeneous algebra of programs and program modifications. <p> In Section 8, we consider the question of how program integration relates to the pushout in the category defined in Section 3. 2. Previous Work: An Algebra Of Programs In this section, we briefly review the Brouwerian algebraic framework for program integration developed in <ref> [14] </ref>. The idea behind this approach may be informally described as follows. A program consists of one or more program components. Hence, a program may be viewed as a set of program components. However, not every set or collection of program components is a program. <p> The operator . of a double Brouwerian algebra will be referred to as the pseudo difference operator, while the operator . .- will be referred to as the quotient operator. Definition 2.3. <ref> [14] </ref> A ternary operator _ [ _ ] _, called the integration operator, of a Brouwerian algebra is defined as follows: a [base ]b = def (a . base) ciic (a cddc base cddc b) ciic (b . base). <p> Theorem 2.4. (Reps <ref> [14] </ref>) (DCS, , , . . .- , dcd ) is a double Brouwerian algebra. <p> Note that the deletion from a of the final use of y does not get overridden. ` The appendix contains a list of the more important laws that hold in double Brouwerian algebras. The reader is referred to <ref> [8, 11, 13, 14] </ref> for a more comprehensive discussion of the algebraic laws that hold in Brouwerian algebras and double Brouwerian algebras. <p> base) (using the definition of + , and some simplification) = (a base) ciic (a cddc base cddc b) ciic (b . base) (using the identity (x . .- y) cddc y = x cddc y) = a [base ]b ` The above theorem, in conjunction with the results in <ref> [14] </ref>, which relate the Brouwerian integration operator _ [ _ ] _ to a variant of the HPR integration algorithm, establishes that the fm-algebra (P,M, D , + ) models the HPR integration algorithm. Figure 3.1 illustrates various values in this fm-algebra. <p> The material presented here is meant to make this paper self contained; proofs of the following propositions and further information about Brouwerian algebras can be found in <ref> [8, 11, 14] </ref>.
Reference: 15. <author> Yang, W., Horwitz, S., and Reps, T., </author> <title> A program integration algorithm that accommodates semantics-preserving transformations, </title> <note> To appear in ACM Trans. </note> <institution> Software Engineering and Methodology, </institution> <year> (1992). </year> <month> - 45 </month> - 
Reference-contexts: Propagating changes through multiple versions Suppose a tree or dag of related versions of a program exists. The goal is to make the same enhancement or bug-fix to all of them. Several other papers <ref> [2, 6, 15] </ref> have investigated such operations at the concrete level (i.e., by defining algorithms for them that work on particular concrete representations of programs). In this paper, we investigate such operations at an abstract level.
References-found: 15

