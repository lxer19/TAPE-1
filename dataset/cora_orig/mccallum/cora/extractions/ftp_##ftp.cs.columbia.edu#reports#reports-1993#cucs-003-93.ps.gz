URL: ftp://ftp.cs.columbia.edu/reports/reports-1993/cucs-003-93.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1993.html
Root-URL: http://www.cs.columbia.edu
Title: Extending Attribute Grammars to Support Programming-in-the-Large  
Author: Josephine Micallef Gail E. Kaiser Gail E. Kaiser 
Keyword: attribute evaluation, attribute grammar, include files, programming-in-the-large, separate compilation.  
Note: Copyright 1993 Bellcore and  
Address: 445 South Street 500 West 120th Street Morristown, NJ 07960 New York, NY 10027  
Affiliation: Bellcore Columbia University MRE 2D-388 Department of Computer Science  
Pubnum: CUCS-003-93  
Email: micallef@bellcore.com kaiser@cs.columbia.edu  
Phone: (201) 829-4227 (212) 939-7081  
Date: 30 March 1993  
Abstract: Attribute grammars add specification of static semantic properties to context-free grammars, which in turn describe the syntactic structure of program units. However, context-free grammars cannot express programming-in-the-large features common in modern programming languages, including unordered collections of units, included units and sharing of included units. We present extensions to context-free grammars, and corresponding extensions to attribute grammars, suitable for defining such features. We explain how batch and incremental attribute evaluation algorithms can be adapted to support these extensions, resulting in a uniform approach to intra-unit and inter-unit static semantic analysis and translation of multi-unit programs. An Ada-specific extended abstract of this paper appeared as ``Extending the Mercury System to Support Teams of Ada Programmers'' in 1st International Symposium on Environments and Tools for Ada, Redondo Beach CA, April 1990, pages 1-12. Special issue of Ada Letters, 11(3), Spring 1991. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> AdaTEC the SIGPLAN Technical Committee on Ada. Reference Manual for the Ada Programming Language United States Department of Defense, </institution> <year> 1982. </year> <note> Draft Revised MIL-STD 1815. </note>
Reference-contexts: Ada Example In an Ada program, a segment corresponds to an Ada compilation unit as defined in the Ada reference manual <ref> [1] </ref>. We identify three classes of compilation units, and define a different segment type to represent each class. The three segment types are specification segments, implementation segments, and subunit segments.
Reference: [2] <author> Henk Alblas. </author> <title> Concurrent Incremental Attribute Evaluation. </title> <editor> In P. Deransart and M. Jourdan (editors), </editor> <booktitle> Lecture Notes in Computer Science. Number 461: International Workshop on Attribute Grammars and their Applications, </booktitle> <pages> pages 343-358. </pages> <publisher> Springer-Verlag, </publisher> <address> Paris, France, </address> <year> 1990. </year>
Reference-contexts: Alblas extended this algorithm to support incremental attribute evaluation <ref> [2] </ref>, using an approach 34 to asynchronous changes described by Kaplan and Kaiser. Unlike Boehm and Zwaenepoel, however, Alblas does not actually distribute the regions across a network. Instead, he associates them with distinct threads of control.
Reference: [3] <author> Gregor V. Bochmann. </author> <title> Semantic Evaluation from Left to Right. </title> <journal> Communications of the ACM 19(2) </journal> <pages> 55-62, </pages> <month> February, </month> <year> 1976. </year> <month> 36 </month>
Reference-contexts: is in Bochmann normal form if for any production p, the input attributes of p consist of the inherited attributes of the left symbol of p (i.e., I (X )), and the synthesized attributes of the 0 right side symbols of p (i.e., S (X ) S (X ) ) <ref> [3] </ref>; that is, no attribute defined in p can be 1 n used to define another attribute in p. In this paper, we assume that attribute grammars are in Bochmann normal form.
Reference: [4] <author> Hans-Juergen Boehm and Willy Zwaenepoel. </author> <title> Parallel Attribute Grammar Evaluation. </title> <booktitle> In 7th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 347-354. </pages> <publisher> IEEE Computer Society, </publisher> <address> Berlin, West Germany, </address> <month> September, </month> <year> 1987. </year>
Reference-contexts: The scaled up Gandalf system would still use action routines for semantics processing. In the attribute grammar literature, segmentation or division of the derivation tree has been proposed for other purposes. Boehm and Zwaenepoel describe a distributed algorithm for attribute evaluation, exploiting parallelism to speed up the compilation process <ref> [4] </ref>. The derivation tree is divided into regions, which are evaluated in parallel on different machines. Annotations on the attribute grammar specify at which nonterminals the derivation tree may be split, and the minimum size of a region to be evaluated separately.
Reference: [5] <author> Frank DeRemer and Hans H. Kron. </author> <title> Programming-in-the-Large Versus Programming-in-the-Small. </title> <journal> IEEE Transactions on Software Engineering SE-2(2):80-86, </journal> <month> June, </month> <year> 1976. </year>
Reference-contexts: Attribute grammars written for languages with programming-in-the-large facilities, such as Ada, define only the intra-module semantics [38]. Normal English prose is typically used to describe inter-module semantics, preventing automatic generation of inter-module analysis tools. Module interconnection languages (e.g., <ref> [5, 36, 10, 41, 32] </ref>) have been developed to specify inter-module connections and implement interface checking. It is not clear, however, whether such approaches can be seamlessly integrated with the analyzers generated from attribute grammars.
Reference: [6] <editor> H. Ehrig, M. Nagl, G. Rozenberg and A. Rosenfeld (editor). </editor> <booktitle> Lecture Notes in Computer Science. Volume 291: Graph-Grammars and Their Application to Computer Science 3rd International Workshop . Springer-Verlag, </booktitle> <address> Warrenton VA, </address> <year> 1986. </year>
Reference-contexts: This is in contrast to the general case of attributed graph grammars, where attribute evaluation is considerably more complex, even for monolithic programs <ref> [6] </ref>. Our result is a uniform approach to formal specification of both intra-unit and inter-unit static semantic properties, that is, both within and between segments, with the ability to use attribute evaluation algorithms to carry out a complete static semantic analysis or translation of a multi-unit program.
Reference: [7] <author> Rodney Farrow. </author> <title> Generating a Production Compiler from an Attribute Grammar. </title> <booktitle> IEEE Software 1(4) </booktitle> <pages> 77-93, </pages> <month> October, </month> <year> 1984. </year>
Reference-contexts: 1. Introduction The attribute grammar formalism for specifying the static semantics of monolithic programs is well-understood, and has been used extensively as the basis for generating static semantic analyzers and translators (e.g., <ref> [9, 34, 40, 7, 17] </ref>). However, attribute grammars cannot express the inter-module semantics of programs that are composed of a number of modules, such as Ada library and secondary units or C source and header files. <p> More efficient algorithms for performing attribute evaluation have been developed for use in practical compiler-compilers <ref> [9, 22, 7] </ref>. These algorithms perform most of the work at grammar-analysis time, once for each AG as opposed to once for each program analysis, thus improving the performance of the evaluator.
Reference: [8] <author> S.I. Feldman. </author> <title> Make A Program for Maintaining Computer Programs. </title> <journal> Software Practice & Experience 9(4) </journal> <pages> 255-265, </pages> <month> April, </month> <year> 1979. </year>
Reference-contexts: The start symbol of the grammar, S, derives the top-level segment in the segmented derivation tree representation of the program. In the typical case where a program is implicitly constructed from an unstructured collection of modules, this top-level segment may correspond to the ``makefile'' <ref> [8] </ref> rather than a language construct. The other components of an SCFG are defined as follows: D is a finite set of nonterminal property declarations.
Reference: [9] <author> Harald Ganzinger, Knut Ripken and Reinhard Wilhelm. </author> <title> Automatic Generation of Optimizing Multipass Compilers. </title> <booktitle> In Information Processing 77, </booktitle> <pages> pages 535-540. </pages> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: 1. Introduction The attribute grammar formalism for specifying the static semantics of monolithic programs is well-understood, and has been used extensively as the basis for generating static semantic analyzers and translators (e.g., <ref> [9, 34, 40, 7, 17] </ref>). However, attribute grammars cannot express the inter-module semantics of programs that are composed of a number of modules, such as Ada library and secondary units or C source and header files. <p> More efficient algorithms for performing attribute evaluation have been developed for use in practical compiler-compilers <ref> [9, 22, 7] </ref>. These algorithms perform most of the work at grammar-analysis time, once for each AG as opposed to once for each program analysis, thus improving the performance of the evaluator.
Reference: [10] <author> A. Nico Habermann and Dewayne E. Perry. </author> <title> System Composition and Version Control for Ada. Software Engineering Environments. </title> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1981, </year> <pages> pages 331-343. </pages>
Reference-contexts: Attribute grammars written for languages with programming-in-the-large facilities, such as Ada, define only the intra-module semantics [38]. Normal English prose is typically used to describe inter-module semantics, preventing automatic generation of inter-module analysis tools. Module interconnection languages (e.g., <ref> [5, 36, 10, 41, 32] </ref>) have been developed to specify inter-module connections and implement interface checking. It is not clear, however, whether such approaches can be seamlessly integrated with the analyzers generated from attribute grammars.
Reference: [11] <author> A.N. Habermann and D. Notkin. </author> <title> Gandalf: Software Development Environments. </title> <journal> IEEE Transactions on Software Engineering SE-12(12):1117-1127, </journal> <month> December, </month> <year> 1986. </year>
Reference-contexts: This style of representation is currently used in the Inscape implementation constructed using the Gandalf system <ref> [11] </ref>, where action routines rather than attribute grammars are used to express semantics processing. More recent work on the Gandalf project sketches an approach to scaling up to large software databases and multiple users [27].
Reference: [12] <author> Roger Hoover and Tim Teitelbaum. </author> <title> Efficient Incremental Evaluation of Aggregate Values in Attribute Grammars. </title> <booktitle> In SIGPLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 39-50. </pages> <address> Palo Alto CA, </address> <month> June, </month> <year> 1986. </year> <journal> Special issue of SIGPLAN Notices, </journal> <volume> 21(7), </volume> <month> July </month> <year> 1986. </year>
Reference-contexts: Thus when a component changes in value, the change can be propagated to just those segments that actually use that component. Our approach extends previous work by Hoover and Teitelbaum on aggregate attributes for monolithic semantic trees <ref> [12] </ref>, and is described in detail elsewhere [28]. 5.1. Segment Linkage Segment linkage is performed by the global evaluator to determine which segment instances are connected to each other.
Reference: [13] <author> Scott E. Hudson and Roger King. Cactis: </author> <title> A Self-Adaptive, Concurrent Implementation of an Object-Oriented Database Management System. </title> <journal> ACM Transactions on Database Systems 14(3) </journal> <pages> 291-321, </pages> <month> September, </month> <year> 1989. </year>
Reference-contexts: However, other applications might require arbitrary dynamic segmentation. One example would be to improve load balancing for Boehm and Zwaenepoel's parallel compilation. Another might be efficient propagation of triggers in an object-oriented database modeled as a semantic tree, as proposed by Hudson and King <ref> [13] </ref>, but segmented according to multi-user browsing focus introducing the possibility of overlapping segments. In fact, we anticipate that many of the most promising avenues for extended attribute grammars will arise in such non-traditional domains.
Reference: [14] <author> M. Jazayeri, W.F. Ogden and W.C. </author> <title> Rounds. The Intrinsically Exponential Complexity of the Circularity Problem for Attribute Grammars. </title> <journal> Communications of the ACM 18(12) </journal> <pages> 697-706, </pages> <month> December, </month> <year> 1975. </year>
Reference: [15] <author> Kathleen Jensen and Niklaus Wirth. </author> <title> Pascal User Manual and Report. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1974. </year> <month> 37 </month>
Reference-contexts: Pascal Example The SCFG for a Pascal program is shown in figure 6. (Nonterminals shown in italics are defined in the Pascal report <ref> [15] </ref>.) It specifies that each procedure or function definition in the outermost scope of a Pascal program is a separate segment. (This requires that nested procedures or functions be defined using another nonterminal symbol, not shown in figure 6.) The segments representing outer-level procedures and functions form an ordered collection (or
Reference: [16] <author> Martin Jourdan and Didier Parigot. </author> <title> The FNC-2 System User's Guide and Reference Manual INRIA, </title> <address> France, </address> <year> 1989. </year>
Reference-contexts: Since this can be achieved by means of local attributes <ref> [16, 35] </ref> attributes associated with a production rather than with nonterminal symbols we keep the definition of SAGs simple by having only interface attributes associated with distributable nonterminal symbols. 14 A new class of attributes, called conglomerate attributes, is provided for nonterminal symbols deriving one or more unordered collections.
Reference: [17] <author> Martin Jourdan, Didier Parigot, Catherine Julie, Olivier Durin and Carole le Bellec. </author> <title> Design, Implementation and Evaluation of the FNC-2 Attribute Grammar System. </title> <booktitle> In ACM SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 209-222. </pages> <month> June, </month> <year> 1990. </year> <journal> Special issue of SIGPLAN Notices, </journal> <volume> 25(6), </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: 1. Introduction The attribute grammar formalism for specifying the static semantics of monolithic programs is well-understood, and has been used extensively as the basis for generating static semantic analyzers and translators (e.g., <ref> [9, 34, 40, 7, 17] </ref>). However, attribute grammars cannot express the inter-module semantics of programs that are composed of a number of modules, such as Ada library and secondary units or C source and header files.
Reference: [18] <author> Gail E. Kaiser, Simon M. Kaplan and Josephine Micallef. </author> <title> Multiuser, Distributed Language-Based Environments. </title> <booktitle> IEEE Software 4(6) </booktitle> <pages> 58-67, </pages> <month> November, </month> <year> 1987. </year>
Reference-contexts: They left open the problem of specifying the segmentation, and their later work assumed a simple two-level derivation tree consisting of a root with an unordered collection of segments <ref> [18, 19] </ref>. As far as we know, no other researchers have considered extending context-free grammars and attribute grammars to express complex inter-unit syntactic and semantic connections. Perry's Inscape system also unifies the specification of inter-unit and intra-unit semantics [33].
Reference: [19] <author> Gail E. Kaiser and Simon M. Kaplan. </author> <title> Parallel and Distributed Incremental Attribute Evaluation Algorithms for Multi-User Software Development Environments. </title> <journal> ACM Transactions on Software Engineering and Methodology 2(1) </journal> <pages> 47-92, </pages> <month> January, </month> <year> 1993. </year>
Reference-contexts: Local evaluation is then initiated in all affected segments. Changes to a segment's input attributes may arrive at a segment asynchronously, with a new one arriving before an evaluation triggered by a previous change has completed <ref> [19] </ref>. In the case of batch local evaluation, it might be desirable to terminate prematurely and then restart considering the new input. For incremental local evaluation, the local evaluator should merge the evaluation processes to avoid unnecessary multiple evaluations of the same attributes [31]. <p> They left open the problem of specifying the segmentation, and their later work assumed a simple two-level derivation tree consisting of a root with an unordered collection of segments <ref> [18, 19] </ref>. As far as we know, no other researchers have considered extending context-free grammars and attribute grammars to express complex inter-unit syntactic and semantic connections. Perry's Inscape system also unifies the specification of inter-unit and intra-unit semantics [33].
Reference: [20] <author> Simon M. Kaplan and Gail E. Kaiser. </author> <title> Incremental Attribute Evaluation in Distributed Language-Based Environments. </title> <booktitle> In 5th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 121-130. </pages> <address> Calgary Alberta, Canada, </address> <month> August, </month> <year> 1986. </year>
Reference-contexts: Related Work Kaplan and Kaiser introduced the concept of attribute evaluation for multi-segment programs, and devised the first algorithms for incremental evaluation across segments <ref> [20] </ref>. They left open the problem of specifying the segmentation, and their later work assumed a simple two-level derivation tree consisting of a root with an unordered collection of segments [18, 19].
Reference: [21] <author> Uwe Kastens. </author> <title> Ordered Attribute Grammars. </title> <journal> Acta Informatica 13 </journal> <pages> 229-256, </pages> <year> 1980. </year>
Reference: [22] <author> U. Kastens, B. Hutt and E. Zimmermann. </author> <booktitle> Lecture Notes in Computer Science. </booktitle> <volume> Volume 141: </volume> <month> GAG: </month> <title> A Practical Compiler Generator. </title> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, FRG, </address> <year> 1982. </year>
Reference-contexts: More efficient algorithms for performing attribute evaluation have been developed for use in practical compiler-compilers <ref> [9, 22, 7] </ref>. These algorithms perform most of the work at grammar-analysis time, once for each AG as opposed to once for each program analysis, thus improving the performance of the evaluator.
Reference: [23] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language Second edition, </title> <address> Englewood Cliffs NJ, </address> <year> 1988. </year>
Reference-contexts: Production p7 associates with each body stub an interface to the corresponding subunit segment. All occurrences of body-stub that appear on the right side of productions in the syntax given in the Ada reference manual should be replaced by the nonterminal subunit-body-stub. 10 3.2. C Example reference manual <ref> [23] </ref>.) A C program is composed of an unordered collection of source files, as specified in production p1. We define a source file as consisting of a list of function definitions, data definitions, and include statements.
Reference: [24] <author> Alexander Klaiber and Maya Gokhale. </author> <title> Parallel Evaluation of Attribute Grammars. </title> <journal> In IEEE Transactions on Parallel and Distributed Systems, </journal> <pages> pages 206-220. </pages> <month> March, </month> <year> 1992. </year>
Reference-contexts: Instead, he associates them with distinct threads of control. In effect, Alblas's algorithm parallelizes evaluation within a single segment, and does not address propagation among multiple segments. Klaiber and Gokhale describe parallel but non-incremental evaluators for attribute grammars for execution on a multiprocessor <ref> [24] </ref>.
Reference: [25] <author> Donald E. Knuth. </author> <title> Semantics of Context-Free Languages. </title> <booktitle> Mathematical Systems Theory 2(2) </booktitle> <pages> 127-145, </pages> <month> June, </month> <year> 1968. </year>
Reference-contexts: Section 7 discusses related work. We conclude by summarizing our contributions and briefly suggesting areas for future work. 4 2. Attribute Grammars Attribute grammars were introduced by Knuth to describe the context-sensitive properties (static semantics) of programming languages <ref> [25] </ref>. An attribute grammar (AG) is based on a context-free grammar (CFG) that describes the language's syntax. <p> Batch evaluation is typically used in compiler-compilers, while incremental evaluation is used in interactive language-based editors. Knuth describes a simple batch attribute evaluation algorithm <ref> [25] </ref>. The algorithm makes use of the dependency graph of the semantic tree. The vertices of the dependency graph, which correspond to attribute instances in the semantic tree, are first topologically sorted. Then, the attribute instances are evaluated according to their topological order. <p> In principle, it is always possible to rewrite the attribute grammar to avoid such dependencies across segments by using only synthesized attributes; attribute grammars that employ both inherited and synthesized attributes are no more powerful than those that use only synthesized attributes <ref> [25] </ref>. However, writing an equivalent attribute grammar without inherited attributes is often considerably harder, and the resulting grammar is more complicated thus more difficult to understand and change. 27 We define a subclass of the SAGs, called summarizable SAGs, which do not exhibit anomalous behavior.
Reference: [26] <author> Donald E. Knuth. </author> <title> Semantics of Context-Free Languages: Correction. </title> <booktitle> Mathematical Systems Theory 5(1) </booktitle> <pages> 95-96, </pages> <month> March, </month> <year> 1971. </year>
Reference-contexts: The vertices of the dependency graph, which correspond to attribute instances in the semantic tree, are first topologically sorted. Then, the attribute instances are evaluated according to their topological order. This algorithm only works if the dependency graph is acyclic <ref> [26] </ref>.
Reference: [27] <author> Charles W. Krueger and Annalisa Bogliolo. </author> <title> Scaling Up: Segmentation and Concurrency in Large Software Databases. </title> <type> Technical Report CMU-CS-87-178, </type> <institution> Carnegie Mellon University Department of Computer Science, </institution> <month> February, </month> <year> 1988. </year> <month> 38 </month>
Reference-contexts: More recent work on the Gandalf project sketches an approach to scaling up to large software databases and multiple users <ref> [27] </ref>. Multiple (context-free) grammars are used to describe the database organization, with segmentation of the database at grammar boundaries.
Reference: [28] <author> Josephine Micallef and Gail E. Kaiser. </author> <title> Version and Configuration Control in Distributed Language-Based Environments. </title> <editor> In Jurgen F.H. Winkler (editor), </editor> <booktitle> International Workshop on Software Version and Configuration Control, </booktitle> <pages> pages 119-143. </pages> <address> B.G. </address> <publisher> Teubner, </publisher> <address> Grassau, West Germany, </address> <month> January, </month> <year> 1988. </year>
Reference-contexts: Thus when a component changes in value, the change can be propagated to just those segments that actually use that component. Our approach extends previous work by Hoover and Teitelbaum on aggregate attributes for monolithic semantic trees [12], and is described in detail elsewhere <ref> [28] </ref>. 5.1. Segment Linkage Segment linkage is performed by the global evaluator to determine which segment instances are connected to each other.
Reference: [29] <author> Josephine Micallef and Gail E. Kaiser. </author> <title> Extending the Mercury System to Support Teams of Ada Programmers. </title> <booktitle> In 1st International Symposium on Environments and Tools for Ada, </booktitle> <pages> pages 49-60. </pages> <publisher> ACM Press, </publisher> <address> Redondo Beach CA, </address> <month> April, </month> <year> 1990. </year> <journal> Special issue of Ada Letters, </journal> <volume> 11(3), </volume> <month> Spring </month> <year> 1991. </year>
Reference-contexts: If an Ada program contains a body stub for a package in the compilation unit, but there is no subunit defining the body of the package, this semantic equation would cause an error to be reported. 4 In <ref> [29] </ref>, we present an SAG specification for performing inter-module semantic analysis for Ada, including (1) determining which contexts are accessible to a compilation unit and propagating context information accordingly; (2) detecting compilation units with duplicate names where unique names are required, and detecting missing bodies when they are required by specifications;
Reference: [30] <author> Josephine Micallef. </author> <title> Incremental Attribute Evaluation for Multi-User Semantics-Based Editors. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <month> May, </month> <year> 1991. </year> <note> Technical Report CUCS-023-91. </note>
Reference-contexts: The attribute grammar writer need only specify the simple segmentation scheme shown in figure 6; the user of the attribute grammar-based system can invoke a tool to restructure the program according to the new SCFG resulting from the transformation. The transformation algorithm is presented elsewhere <ref> [30] </ref>. 4. Segmentable Attribute Grammars We define the class of segmentable attribute grammars (SAGs) to consist of the following components: + 1. An underlying segmentable context-free grammar, G , which describes the + structure of the segmented derivation trees of sentences in the language L (G ). 2. <p> Although this pattern cannot be detected automatically it requires knowledge of the meaning of a semantic function a human can easily identify instances. In the following two sections, we give example SAGs before and after the appropriate transformations have been applied. The detailed algorithms are presented elsewhere <ref> [30] </ref>. 6.1. Transformation involving Direct Dependencies The first pattern is exemplified by the SAG for procedures in a Pascal-like language shown in figure 15. Each top-level procedure in the program is defined in a distinct segment.
Reference: [31] <author> Josephine Micallef and Gail E. Kaiser. </author> <title> Support Algorithms for Incremental Attribute Evaluation of Asynchronous Subtree Replacements. </title> <journal> IEEE Transactions on Software Engineering , 1993. </journal> <note> In press. </note>
Reference-contexts: In the case of batch local evaluation, it might be desirable to terminate prematurely and then restart considering the new input. For incremental local evaluation, the local evaluator should merge the evaluation processes to avoid unnecessary multiple evaluations of the same attributes <ref> [31] </ref>. Further discussion of these intra-segment evaluation issues is outside the scope of this paper. We consider several issues in inter-segment evaluation: Before any attributes can be propagated among segments, the global evaluator must determine which segments are connected to each other, i.e., perform segment linkage.
Reference: [32] <author> K. Narayanaswamy and Walt Scacchi. </author> <title> Maintaining Configurations of Evolving Software Systems. </title> <journal> IEEE Transactions on Software Engineering SE-13(3):324-334, </journal> <month> March, </month> <year> 1987. </year>
Reference-contexts: Attribute grammars written for languages with programming-in-the-large facilities, such as Ada, define only the intra-module semantics [38]. Normal English prose is typically used to describe inter-module semantics, preventing automatic generation of inter-module analysis tools. Module interconnection languages (e.g., <ref> [5, 36, 10, 41, 32] </ref>) have been developed to specify inter-module connections and implement interface checking. It is not clear, however, whether such approaches can be seamlessly integrated with the analyzers generated from attribute grammars.
Reference: [33] <author> Dewayne E. Perry. </author> <title> The Inscape Environment. </title> <booktitle> In 11th International Conference on Software Engineering, </booktitle> <pages> pages 2-9. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Pittsburgh PA, </address> <month> May, </month> <year> 1989. </year>
Reference-contexts: As far as we know, no other researchers have considered extending context-free grammars and attribute grammars to express complex inter-unit syntactic and semantic connections. Perry's Inscape system also unifies the specification of inter-unit and intra-unit semantics <ref> [33] </ref>. A set of preconditions, postconditions and obligations is associated with every statement in a subroutine, with each subroutine, and with each unit (specified as a list of exported subroutines). A set of invariants are associated with every global variable and type definition.
Reference: [34] <author> Thomas Reps. </author> <title> Generating Language-Based Environments. </title> <publisher> The MIT Press, </publisher> <address> Cambridge MA, </address> <year> 1984. </year> <type> PhD Thesis, </type> <institution> Cornell University, </institution> <type> Technical Report 82-514. </type>
Reference-contexts: 1. Introduction The attribute grammar formalism for specifying the static semantics of monolithic programs is well-understood, and has been used extensively as the basis for generating static semantic analyzers and translators (e.g., <ref> [9, 34, 40, 7, 17] </ref>). However, attribute grammars cannot express the inter-module semantics of programs that are composed of a number of modules, such as Ada library and secondary units or C source and header files. <p> The disadvantage of these evaluators, which are called static or semi-static evaluators depending on how much work is done at run-time, is that they do not work for all noncircular AGs but only for certain subclasses. Reps devised an optimal incremental attribute evaluation algorithm for the noncircular AGs <ref> [34] </ref>. Program edits are treated as subtree replacements. After each subtree replacement, a scheduling graph is generated reflecting the dependencies among the inconsistent attributes, which initially are those at the root of the replacement subtree. <p> Attributes whose values actually change during the process are said to be affected by the edit. This is a dynamic algorithm; static incremental algorithms have also been devised for subclasses of the noncircular AGs <ref> [42, 34] </ref>. When the program is composed of multiple units, an intermediate position between the incremental and batch methods arises, corresponding to separate compilation.
Reference: [35] <author> Thomas W. Reps and Tim Teitelbaum. </author> <title> Texts and Monographs in Computer Science: The Synthesizer Generator Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: Since this can be achieved by means of local attributes <ref> [16, 35] </ref> attributes associated with a production rather than with nonterminal symbols we keep the definition of SAGs simple by having only interface attributes associated with distributable nonterminal symbols. 14 A new class of attributes, called conglomerate attributes, is provided for nonterminal symbols deriving one or more unordered collections.
Reference: [36] <author> Walter F. Tichy. </author> <title> Software Development Control Based on Module Interconnection. </title> <booktitle> In 4th International Conference on Software Engineering. </booktitle> <month> September, </month> <year> 1979. </year>
Reference-contexts: Attribute grammars written for languages with programming-in-the-large facilities, such as Ada, define only the intra-module semantics [38]. Normal English prose is typically used to describe inter-module semantics, preventing automatic generation of inter-module analysis tools. Module interconnection languages (e.g., <ref> [5, 36, 10, 41, 32] </ref>) have been developed to specify inter-module connections and implement interface checking. It is not clear, however, whether such approaches can be seamlessly integrated with the analyzers generated from attribute grammars.
Reference: [37] <author> Walter F. Tichy. </author> <title> Smart Recompilation. </title> <journal> ACM Transactions on Programming Languages and Systems 8(3) </journal> <pages> 273-291, </pages> <month> July, </month> <year> 1986. </year> <month> 39 </month>
Reference-contexts: The sensible evaluation strategies are indicated by Yes in table 1. In the sequel we discuss both separate and incremental attribute evaluation for segmented semantic trees. Both separate and incremental evaluation correspond to a ``smart recompilation'' strategy <ref> [37] </ref>, since the attributes in a segment are reevaluated in either case only when an input attribute actually changes in value.
Reference: [38] <author> J. Uhl, S. Drossopoulou, G. Persch, G. Goos, M. Dausmann, G. Winterstein and W. Kirchgassner. </author> <title> Lecture Notes in Computer Science. Number 139: An Attribute Grammar for the Semantic Analysis of Ada. </title> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, FRG, </address> <year> 1982. </year>
Reference-contexts: However, attribute grammars cannot express the inter-module semantics of programs that are composed of a number of modules, such as Ada library and secondary units or C source and header files. Attribute grammars written for languages with programming-in-the-large facilities, such as Ada, define only the intra-module semantics <ref> [38] </ref>. Normal English prose is typically used to describe inter-module semantics, preventing automatic generation of inter-module analysis tools. Module interconnection languages (e.g., [5, 36, 10, 41, 32]) have been developed to specify inter-module connections and implement interface checking.
Reference: [39] <author> H.H. Vogt, S.D. Swierstra and M.F. Kuiper. </author> <title> Higher Order Attribute Grammars. </title> <booktitle> In SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 131-145. </pages> <address> Portland OR, </address> <month> June, </month> <year> 1989. </year> <journal> Special issue of SIGPLAN Notices, </journal> <volume> 24(7), </volume> <month> July </month> <year> 1989. </year>
Reference-contexts: Higher order attribute grammars, where the attribute grammar can specify updates to the derivation tree as well as to the attributes, would permit the logical clauses to be presented to the user for editing <ref> [39] </ref>. This style of representation is currently used in the Inscape implementation constructed using the Gandalf system [11], where action routines rather than attribute grammars are used to express semantics processing.
Reference: [40] <author> William M. Waite and Gerhard Goos. </author> <booktitle> Text and Monographs in Computer Science: Compiler Construction. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: 1. Introduction The attribute grammar formalism for specifying the static semantics of monolithic programs is well-understood, and has been used extensively as the basis for generating static semantic analyzers and translators (e.g., <ref> [9, 34, 40, 7, 17] </ref>). However, attribute grammars cannot express the inter-module semantics of programs that are composed of a number of modules, such as Ada library and secondary units or C source and header files.
Reference: [41] <author> Alexander L. Wolf, Lori A. Clarke and Jack C. Wileden. </author> <title> Ada-Based Support for Programming-in-the-Large. </title> <booktitle> IEEE Software 2(2) </booktitle> <pages> 58-71, </pages> <month> March, </month> <year> 1985. </year>
Reference-contexts: Attribute grammars written for languages with programming-in-the-large facilities, such as Ada, define only the intra-module semantics [38]. Normal English prose is typically used to describe inter-module semantics, preventing automatic generation of inter-module analysis tools. Module interconnection languages (e.g., <ref> [5, 36, 10, 41, 32] </ref>) have been developed to specify inter-module connections and implement interface checking. It is not clear, however, whether such approaches can be seamlessly integrated with the analyzers generated from attribute grammars.

References-found: 41

