URL: http://charm.cs.uiuc.edu/version2/papers/DaggerSyncIPPS94.ps
Refering-URL: http://charm.cs.uiuc.edu/version2/papers/DaggerSyncIPPS94.html
Root-URL: http://www.cs.uiuc.edu
Email: email: gursoy@cs.uiuc.edu email: kale@cs.uiuc.edu  
Title: Dagger: Combining Benefits of Synchronous and Asynchronous Communication Styles  
Author: Attila Gursoy Laxmikant V. Kale 
Address: Urbana IL  
Affiliation: Department of Computer Science Department of Computer Science University of Illinois, Urbana IL University of Illinois,  
Abstract: Communication using blocking receives is the commonly used mechanism in parallel programming today. Message driven execution is an alternate mechanism which does not use receive style statements at all. The message driven execution style promotes the overlap of computation and communication. Programs written in this style exhibit increased latency tolerance: their performance does not degrade significantly with latency. It also induces compositionality: multiple independently developed modules can be combined correctly without loss of efficiency. However, as the flow of control is not explicit in such programs, they are often difficult to develop and debug. We present a coordination language called Dagger to alleviate this problem. The language has been implemented in the Charm parallel programming system, and runs programs portably on a variety of parallel machines. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G.Agha, </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press. </publisher> <year> 1986. </year>
Reference-contexts: by overlapping the computation and communication (the initial increase up to 16 processors is due to the maximum branching factor of the spanning tree employed by Charm which increases from 1 to 4 and stops at 4 beyond 16 processors). 7 Related work The original Actor model as described in <ref> [1] </ref> is purely message driven. The issue of synchronization within an actor was addressed in [9] which proposed the enable set construct. Using this, one may specify which messages may be processed in the new state.
Reference: [2] <author> W.Dally, and et al. </author> <title> "The J-Machine: A Fine-Grain Concurrent Computer", </title> <booktitle> In IFIP Congress, </booktitle> <year> 1989. </year>
Reference: [3] <author> S.Frolund, G.Agha, </author> <title> "Activation of Concurrent Objects by Message Sets", </title> <type> Internal Report, </type> <institution> University of Illinois at Urbana-Champaign. </institution>
Reference-contexts: Thus, this construct is analogous to our expect statement. However, there is no analogue of a when-block, viz. a computation block, that can be executed only when a specific group of messages have arrived. A more recent paper <ref> [3] </ref> supports a much more complex model which subsumes synchronization of multiple actors depending on message sets. It should be noted that Dagger/Charm provides a programming model that differs from Actors in many ways. The discussion above focuses only on how they deal with message driven execution.
Reference: [4] <author> T.von Eicken, D.E.Culler, S.C.Goldstein, K.E. Schauser, </author> <title> "Active Messages: a Mechanism for Integrated Communication and Computation", </title> <booktitle> Proc. of the 19 th Int'l Symp. on Computer Architecture, </booktitle> <address> Australia, </address> <month> May </month> <year> 1992, </year> <month> pp256-266. </month>
Reference-contexts: The computation continues in this manner until the solution is reached. Figure 5 dag BranchOffice jacobi f ChareNumType mycid; PeNumType neighbour <ref> [4] </ref>; CONDVAR SEND; entry init : (message MSGINIT *msg); entry NORTH: (message BOUNDARY *north); entry SOUTH: (message BOUNDARY *south); entry WEST : (message BOUNDARY *west); entry EAST : (message BOUNDARY *east); entry CONVERGENCE : (message CONV *conv); when init : f initialize (); ready (SEND);g when SEND : f BOUNDARY *m; <p> It should be noted that Dagger/Charm provides a programming model that differs from Actors in many ways. The discussion above focuses only on how they deal with message driven execution. Recent work on Active Messages <ref> [4] </ref> also deals with message driven execution and split phase transactions. The split-C language based on Active Messages employs polling for arrival of messages. However the TAM compiler built on Active messages has some similarities to Dagger.
Reference: [5] <author> A.Gursoy, </author> <title> Message Driven Execution and its Impact on the Performance of CFD and other Applications, </title> <type> Ph.D Thesis in preparation, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> Jan </month> <year> 1993. </year>
Reference-contexts: means that writer of a module issuing a blocking receive must know about all other modules that may be waiting for a message at that moment, and must design mechanisms to recognize and hand over messages belonging to other modules (for a more detailed comparison of these two paradigms see <ref> [5] </ref>). Although it imparts these benefits, message driven execution often extracts a price in the form of apparent program complexity. The split-phase or continuation-passing style of programming that it requires is sometimes non-intuitive, and obfuscates the flow of control.
Reference: [6] <author> A.S.Grimshaw, </author> <title> Mentat : An Object Oriented Macro Data Flow System, UIUCDCS-R-88-1440, </title> <type> Ph.D Thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Counters and flags for synchronizing on arrival of multiple messages are explicitly maintained. However, TAM is meant as the back end for a data flow compiler as opposed to a language meant for the application programmer. So these inconveniences may not be of much consequence. Macro data flow <ref> [6] </ref> approaches share with us the objective of message driven execution and local synchronization. However, much of the past work in this area was aimed at special purpose hardware. Also, these approaches are often meant to be used as a back-end for compilers.
Reference: [7] <author> L.V.Kale, </author> <title> "The Chare Kernel parallel programming language and system", </title> <booktitle> Proceedings of the International Conference on Parallel Processing, </booktitle> <volume> Vol II, </volume> <month> Aug </month> <year> 1990, </year> <month> pp17-25. </month>
Reference-contexts: The Dagger runtime system buffers messages until they can be processed, and automatically maintains all the flags and counters needed to ensure that the partial order is adhered to. 2 The Charm language Charm is a machine independent parallel programming system <ref> [7] </ref>. Programs written using this system will run unchanged on MIMD machines with or without a shared memory. The programs are written in C with a few syntactic extensions.
Reference: [8] <author> E.Kornkven, </author> <title> "Overlapping Computation and Communication in an Implementation of A Data Parallel Language", </title> <type> Report 92-4, </type> <institution> Parallel Programming Laboratory, Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> Oct </month> <year> 1992. </year>
Reference-contexts: Thus the inconvenience of maintaining counters and buffers explicitly is not considered significant. These approaches thus are comparable to Charm itself rather than Dagger. Our experience with using Dagger as back-end for a compiler for a data parallel language <ref> [8] </ref> indicates that Dagger might provide a more convenient intermediate language than macro data flow. 8 Conclusion We presented a coordination language called Dagger which combines the efficiency of message driven execution with the conceptual simplicity of blocking-receives.
Reference: [9] <author> C.Tomlinson, V.Singh, </author> <title> "Inheritance and Synchronization with Enabled-Sets", </title> <booktitle> ACM OOPSLA 1989 , pp103-112. </booktitle>
Reference-contexts: The issue of synchronization within an actor was addressed in <ref> [9] </ref> which proposed the enable set construct. Using this, one may specify which messages may be processed in the new state. Any other messages that are received by an actor are buffered until the current enable set includes them. Thus, this construct is analogous to our expect statement.
Reference: [10] <institution> The CHARM(4.0) programming language manual, Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, IL, </institution> <year> 1993. </year>
Reference-contexts: The information sharing abstractions supported include read only variables, monotonic variables, writeonce variables, accumulators and distributed tables. Charm also provides a sophisticated module system that facilitates reuse, and large-scale programming for parallel software. Details about these features can be found in <ref> [10] </ref>. 2.1 An example in Charm Consider an algorithm for matrix multiplication that is dynamically load balanced. Such a formulation may be useful on a machine where different processors operate at different speeds, for example.
References-found: 10

