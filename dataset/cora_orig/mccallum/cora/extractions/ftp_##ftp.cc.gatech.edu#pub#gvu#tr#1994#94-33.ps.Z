URL: ftp://ftp.cc.gatech.edu/pub/gvu/tr/1994/94-33.ps.Z
Refering-URL: http://www.cs.gatech.edu/gvu/reports/1994/
Root-URL: 
Email: E-mail: fdfj,staskog@cc.gatech.edu  
Title: Using Visualization to Foster Object-Oriented Program Understanding  
Author: Dean F. Jerding and John T. Stasko 
Keyword: program visualization, program comprehension.  
Address: Atlanta, GA 30332-0280  
Affiliation: Graphics, Visualization, and Usability Center College of Computing Georgia Institute of Technology  
Abstract: Technical Report GIT-GVU-94-33 July 1994 Abstract Software development and maintenance tasks rely on and can benefit from an increased level of program understanding. Object-oriented programming languages provide features which facilitate software maintenance, yet the same features often make object-oriented programs more difficult to understand. We support the use of program visualization techniques to foster object-oriented program comprehension. This paper identifies ways that visualization can increase program understanding, and presents a means for characterizing both static and dynamic aspects of an object-oriented program. We then describe the implementation of a prototypical tool for visualizing the execution of C++ programs. Based on this work, we define a framework for the visualization of object-oriented software which requires little or no programmer intervention and provides a mechanism which allows users to focus quickly on particular aspects of the program. 
Abstract-found: 1
Intro-found: 1
Reference: [BC89] <author> Kent Beck and Ward Cunningham. </author> <title> A laboratory for teaching object-oriented thinking. </title> <booktitle> In Proceedings of the ACM OOPSLA '89 Conference, </booktitle> <pages> pages 1-6, </pages> <address> New Orleans, LA, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: There has been a good deal of research on graphical presentation of object-oriented programs. Much of the research to date has focused on graphics used as a design aid in building object-oriented systems. The work of Booch [Boo91], Rumbaugh [RBP + 91], et. al., 11 Beck and Cunningham <ref> [BC89] </ref>, Harel [Har88], Coleman, Hayes, and Bear [CHB92] all fits within this notion. The static diagramming techniques developed through this work can be quite helpful as a specification aid, but they are not appropriate for visualizing dynamic executions of programs, particularly those of very large programs.
Reference: [BGL93] <author> B. Bruegge, T. Gottschalk, and Bin Luo. </author> <title> A framework for dynamic program analyzers. </title> <booktitle> In SIGPLAN Notices: Proceedings of the 8th Annual ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <volume> volume 28, </volume> <pages> pages 65-82, </pages> <address> Sept.-Oct. </address> <year> 1993. </year>
Reference: [BH90] <author> Heinz-Dieter Bocker and Jurgen Herczeg. </author> <title> What tracers are made of. </title> <booktitle> In Proceedings of the ECOOP/OOPSLA '90 Conference, </booktitle> <pages> pages 89-99, </pages> <address> Ottawa, On-tario, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Their GraphTrace tool illustrates structural and behavioral views of object-oriented systems by recording message traffic for subsequent replay. The tool's displays mainly involve graph diagrams consisting of nodes and arcs. Animation, however, is restricted to simply highlighting and annotating graph nodes. Bocker and Herczeg <ref> [BH90] </ref> provide more extensive animation of Smalltalk-80 traces with the Track system. Track allows programmers to visually specify message tracing as a debugging aid. At execution time, the system presents an animation of the messages sent between objects.
Reference: [BM82] <author> V.R. Basili and H.D. Mills. </author> <title> Understanding and documenting programs. </title> <booktitle> IEEE Computer, </booktitle> <month> Oct </month> <year> 1982. </year>
Reference-contexts: There are many theories as to how program comprehension is performed. Brooks originally proposed the idea that comprehension is essentially a maintainer reconstructing the mappings that the programmer originally created [Bro83]. The program understanding process may proceed in a bottom-up <ref> [BM82, Bro83, Pen87] </ref> or top-down [SAE88] manner, or a combination of both [Let86, vMV93], depending on the available cues, the type of maintenance [vMV93], and the maintainer's syntactic and semantic knowledge base [YB93].
Reference: [Boo91] <author> Grady Booch. </author> <title> Object Oriented Design with Applications. </title> <publisher> Benjamin Cummings, </publisher> <year> 1991. </year>
Reference-contexts: There has been a good deal of research on graphical presentation of object-oriented programs. Much of the research to date has focused on graphics used as a design aid in building object-oriented systems. The work of Booch <ref> [Boo91] </ref>, Rumbaugh [RBP + 91], et. al., 11 Beck and Cunningham [BC89], Harel [Har88], Coleman, Hayes, and Bear [CHB92] all fits within this notion.
Reference: [Bro83] <author> R. Brooks. </author> <title> Towards a theory of the comprehension of computer programs. </title> <journal> International Journal of Man-Machine Studies, </journal> <volume> 18 </volume> <pages> 543-54, </pages> <year> 1983. </year>
Reference-contexts: The problem of program understanding thus becomes one of the most important tasks in software re-use and maintenance. There are many theories as to how program comprehension is performed. Brooks originally proposed the idea that comprehension is essentially a maintainer reconstructing the mappings that the programmer originally created <ref> [Bro83] </ref>. The program understanding process may proceed in a bottom-up [BM82, Bro83, Pen87] or top-down [SAE88] manner, or a combination of both [Let86, vMV93], depending on the available cues, the type of maintenance [vMV93], and the maintainer's syntactic and semantic knowledge base [YB93]. <p> There are many theories as to how program comprehension is performed. Brooks originally proposed the idea that comprehension is essentially a maintainer reconstructing the mappings that the programmer originally created [Bro83]. The program understanding process may proceed in a bottom-up <ref> [BM82, Bro83, Pen87] </ref> or top-down [SAE88] manner, or a combination of both [Let86, vMV93], depending on the available cues, the type of maintenance [vMV93], and the maintainer's syntactic and semantic knowledge base [YB93].
Reference: [CHB92] <author> Derek Coleman, Fiona Hayes, and Stephen Bear. </author> <title> Introducing objectcharts or how to use statecharts in object-oriented design. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(1) </volume> <pages> 9-18, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Much of the research to date has focused on graphics used as a design aid in building object-oriented systems. The work of Booch [Boo91], Rumbaugh [RBP + 91], et. al., 11 Beck and Cunningham [BC89], Harel [Har88], Coleman, Hayes, and Bear <ref> [CHB92] </ref> all fits within this notion. The static diagramming techniques developed through this work can be quite helpful as a specification aid, but they are not appropriate for visualizing dynamic executions of programs, particularly those of very large programs. Some work on visualizing executions has been conducted.
Reference: [DPHKV93] <author> Wim De Pauw, Richard Helm, Doug Kimelman, and John Vlissides. </author> <title> Visualizing the behavior of object-oriented systems. </title> <booktitle> In Proceedings of the ACM OOPSLA '93 Conference, </booktitle> <pages> pages 326-37, </pages> <address> Washington, D.C., </address> <month> October </month> <year> 1993. </year>
Reference-contexts: function Hand icon Instance Itself Full color, bold outline Its class Light color, bold outline Classes it inherits from Light color Visible instances Double, broken outline Subordinate instances close proximity Function Itself Full size, bold outline Table 2: Graphical encoding of relationships to a current focus program entity. tracked by <ref> [DPHKV93] </ref>, as both sets of events seek to characterize object-oriented program execution at a conceptual level. <p> Such a hierarchy provides for structured inter-view communication and facilitates the addition of new views. Corresponding to each visualization model would be a window displaying the particular view of that visualization. This hierarchy of visualization models and views is similar to that found in <ref> [DPHKV93] </ref>, except that in our framework there is a one-to-one mapping from visualization model to view, while the IBM system can have a many-to-one mapping of models to views. <p> Two recent research thrusts are most similar to what we seek to accomplish in this work. De Pauw, Helm, Kimelman, and Vlissides at IBM have developed visualization techniques and a system for presenting attributes of object-oriented systems, more specifically, C++ programs <ref> [DPHKV93] </ref>. The authors developed instrumentation techniques that are portable and can extract the needed summary information about a program's execution. They also developed views, most of which are chart-like, that present summary information about the execution.
Reference: [DPKV94] <author> Wim De Pauw, Doug Kimelman, and John Vlissides. </author> <title> Modeling object-oriented program execution. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming `94, </booktitle> <year> 1994. </year>
Reference-contexts: The process might also be systematic-an attempt to understand the entire program, or as-needed , where only the parts of a program necessary to carry out a particular task are investigated [LPLS86]. Another view holds that program understanding takes place in a feedback loop <ref> [DPKV94] </ref> where the program implementation is compared to the maintainer's conceptual model of how the program should solve the problem. Research in the area of program comprehension has been focused on providing tools which make this feedback loop more effective.
Reference: [FB89] <author> S.I. Feldman and C.B. Brown. IGOR: </author> <title> A system for program debugging via reversible execution. </title> <booktitle> In ACM SIGPLAN and SIGOPS Workshop on Parallel and Distributed Debugging, </booktitle> <volume> volume 24, </volume> <pages> pages 112-123, </pages> <month> Jan </month> <year> 1989. </year>
Reference-contexts: This is especially useful when the user is only interested in specific events, such as object deletion. The problem of supporting backtracking through the event stream can be likened to the problem of reverse execution <ref> [FB89] </ref>. In order to support what we call reverse visualization we need to 1) restore pre-existing program state models and visualization models, and 2) update the views to reflect the new models.
Reference: [Har88] <author> David Harel. </author> <title> On visual formalisms. </title> <journal> Communications of the ACM, </journal> <volume> 31(5) </volume> <pages> 514-530, </pages> <month> May </month> <year> 1988. </year> <month> 13 </month>
Reference-contexts: Much of the research to date has focused on graphics used as a design aid in building object-oriented systems. The work of Booch [Boo91], Rumbaugh [RBP + 91], et. al., 11 Beck and Cunningham [BC89], Harel <ref> [Har88] </ref>, Coleman, Hayes, and Bear [CHB92] all fits within this notion. The static diagramming techniques developed through this work can be quite helpful as a specification aid, but they are not appropriate for visualizing dynamic executions of programs, particularly those of very large programs.
Reference: [KG88] <author> Michael F. Kleyn and Paul C. Gingrich. </author> <title> GraphTrace understanding object--oriented systems using concurrently animated views. </title> <booktitle> In Proceedings of the ACM OOPSLA '88 Conference, </booktitle> <pages> pages 191-205, </pages> <address> San Diego, CA, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: The static diagramming techniques developed through this work can be quite helpful as a specification aid, but they are not appropriate for visualizing dynamic executions of programs, particularly those of very large programs. Some work on visualizing executions has been conducted. Kleyn and Gingrich <ref> [KG88] </ref> sought to go beyond static displays by examining the dynamic behavior of object-oriented systems written in a Common Lisp-style language. Their GraphTrace tool illustrates structural and behavioral views of object-oriented systems by recording message traffic for subsequent replay.
Reference: [Koi93] <author> Hideki Koike. </author> <title> The role of another spatial dimension in software visualization. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 11(3) </volume> <pages> 266-286, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: The information they capture, however, is mostly postmortem summary information, whereas we seek to portray more of the run-time dynamics of a system. We also focus on providing effective navigation techniques between views and visualization events. Koike is also exploring the use of 3D graphics to illustrate object-oriented systems <ref> [Koi93] </ref>. His techniques portray message traffic in a system with respect to the class hierarchy and the method list.
Reference: [LA93] <author> Panos E. Livadas and Scott D. Alden. </author> <title> A toolset for program understanding. </title> <booktitle> In Proceedings of the 2nd Workshop on Program Comprehension, </booktitle> <pages> pages 110-118, </pages> <address> Capri, Italy, </address> <month> July 8-9 </month> <year> 1993. </year>
Reference-contexts: Two main approaches have been followed here: 1) to allow maintainers access to knowledge about the design of the program, as described by Younger and Bennett [YB93], or 2) to provide an analysis of the many inter-dependencies existing in a program, including data-flow and control-flow, as in <ref> [LA93] </ref>. Both of these approaches are often based upon creating some internal representation of a program from which information can be extracted and presented to the user. Some tools have begun to present this information graphically, such as the CARE environment [LAD + 93] and FIELD [Rei90].
Reference: [LAD + 93] <author> Panagiotis Linos, Philippe Aubet, Laurent Dumas, Yan Helleboid, Patricia Lejeune, and Phillippe Tulula. </author> <title> Facilitating the comprehension of c programs: An experimental study. </title> <booktitle> In Proceedings of the 2nd Workshop on Program Comprehension, </booktitle> <pages> pages 55-63, </pages> <address> Capri, Italy, </address> <month> July 8-9 </month> <year> 1993. </year>
Reference-contexts: Both of these approaches are often based upon creating some internal representation of a program from which information can be extracted and presented to the user. Some tools have begun to present this information graphically, such as the CARE environment <ref> [LAD + 93] </ref> and FIELD [Rei90]. We support a different approach to program understanding: program visualization. Program visualization is a sub-set of the area known as software visualization-the use of graphics and animation to visually describe and illustrate software and its function [PBS93, SP92].
Reference: [Let86] <author> S. Letovsky. </author> <title> Cognitive processes in program comprehension. </title> <editor> In E. Solloway and S. Iyengar, editors, </editor> <booktitle> Empirical Studies of Programmers, </booktitle> <pages> pages 58-79, </pages> <address> Nor-wood, NJ, </address> <year> 1986. </year>
Reference-contexts: Brooks originally proposed the idea that comprehension is essentially a maintainer reconstructing the mappings that the programmer originally created [Bro83]. The program understanding process may proceed in a bottom-up [BM82, Bro83, Pen87] or top-down [SAE88] manner, or a combination of both <ref> [Let86, vMV93] </ref>, depending on the available cues, the type of maintenance [vMV93], and the maintainer's syntactic and semantic knowledge base [YB93].
Reference: [LMR92] <author> Moises Lejter, Scott Meyers, and Steven Reiss. </author> <title> Support for maintaining object-oriented programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(12) </volume> <pages> 1045-1052, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Maintenance of software systems is often complicated by the transiency of programmers in software development organizations. It is often difficult for a new programmer to understand the complex relationships between objects present in large object-oriented systems <ref> [LMR92] </ref>. Again, program understanding is complicated by dynamic binding and inheritance hierarchies. One suggestion for increasing understanding might be a graphical view of the inheritance hierarchy [WH92], or a graphical visualization of the communication between objects in the system. <p> With respect to object-oriented systems in particular, more recent work includes Reiss' FIELD system [Rei90]. FIELD contains an extensive set of tools for developing and maintaining C++ programs. These tools include graphical aids such as class browsers <ref> [LMR92] </ref> and flow graphs, but the recent thrust of the work has been on 3-D display views [Rei93]. The BEE++[BGL93] object-oriented application framework supports dynamic analysis of distributed programs. It provides a platform for event monitoring, visualization, and graphical debugging.
Reference: [LPLS86] <author> D.C. Littman, J. Pinto, S. Letovsky, and E. Soloway. </author> <title> Mental models and software maintenance. </title> <editor> In E. Solloway and S. Iyengar, editors, </editor> <booktitle> Empirical Studies of Programmers, </booktitle> <pages> pages 80-98, </pages> <address> Norwood, NJ, </address> <year> 1986. </year>
Reference-contexts: The process might also be systematic-an attempt to understand the entire program, or as-needed , where only the parts of a program necessary to carry out a particular task are investigated <ref> [LPLS86] </ref>. Another view holds that program understanding takes place in a feedback loop [DPKV94] where the program implementation is compared to the maintainer's conceptual model of how the program should solve the problem.
Reference: [Mey90] <author> Scott Meyers. </author> <title> Working with object-oriented programs: The view from the trenches is not always pretty. </title> <booktitle> In Proceedings of the Symposium on Object-Oriented Programming Emphasizing Practical Applications (SOOPPA), </booktitle> <pages> pages 51-65, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Class descriptions are often distributed among several files, and function overloading is common. Additionally, static code traces cannot fully describe the execution of object-oriented programs. Meyers gives a detailed example of a common, "representative" problem often encountered in object-oriented programming and debugging <ref> [Mey90] </ref>. The task involves locating the function body that would be invoked from a particular function call in a C++ application. In a traditional procedural language, this might simply involve looking for the corresponding function declaration in successive enclosing scopes.
Reference: [Moh88] <author> Thomas G. Moher. </author> <title> PROVIDE: A process visualization and debugging environment. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(6) </volume> <pages> 849-57, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Because the Event Manager can store and retrieve events, such an implementation would be possible. In the past, event driven visualization systems typically have not allowed such backtracking, although programming environments such as PROVIDE <ref> [Moh88] </ref> have state-saving capabilities. 6.2.3 Views As mentioned in Section 2, tools which support object-oriented program visualization will help in the following areas: understanding high-level aspects of a system, tracing dynamic message binding, analyzing dependencies between classes, locating system functionality, and resolving polymorphism [WH92]. <p> We envision that all four of these types of views will be useful, although discovering the content and presentation of useful views is a future question for our research. 7 Related Work Several programming environments have been developed which include visualization capabilities. PECAN [Rei85] and PROVIDE <ref> [Moh88] </ref> are early program development systems that utilized graphical views such as data structure displays, a call-graph, and the call stack. With respect to object-oriented systems in particular, more recent work includes Reiss' FIELD system [Rei90]. FIELD contains an extensive set of tools for developing and maintaining C++ programs.
Reference: [PBS93] <author> Blaine A. Price, Ronald M. Baecker, and Ian S. </author> <title> Small. A principled taxonomy of software visualization. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 4(3) </volume> <pages> 211-266, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: We support a different approach to program understanding: program visualization. Program visualization is a sub-set of the area known as software visualization-the use of graphics and animation to visually describe and illustrate software and its function <ref> [PBS93, SP92] </ref>. In program visualization, the medium being visualized is a computer program. The basic premise of visualization is that users can better understand and investigate the inner-workings of their software by seeing it portrayed visually.
Reference: [Pen87] <author> N. Pennington. </author> <title> Comprehension strategies in programming. </title> <editor> In G.M. Olsen, S. Sheppard, and E. Solloway, editors, </editor> <title> Empirical Studies of Programmers: </title> <booktitle> Second Workshop, </booktitle> <pages> pages 100-13, </pages> <address> Norwood, NJ, </address> <year> 1987. </year>
Reference-contexts: There are many theories as to how program comprehension is performed. Brooks originally proposed the idea that comprehension is essentially a maintainer reconstructing the mappings that the programmer originally created [Bro83]. The program understanding process may proceed in a bottom-up <ref> [BM82, Bro83, Pen87] </ref> or top-down [SAE88] manner, or a combination of both [Let86, vMV93], depending on the available cues, the type of maintenance [vMV93], and the maintainer's syntactic and semantic knowledge base [YB93].
Reference: [RBP + 91] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: There has been a good deal of research on graphical presentation of object-oriented programs. Much of the research to date has focused on graphics used as a design aid in building object-oriented systems. The work of Booch [Boo91], Rumbaugh <ref> [RBP + 91] </ref>, et. al., 11 Beck and Cunningham [BC89], Harel [Har88], Coleman, Hayes, and Bear [CHB92] all fits within this notion.
Reference: [Rei85] <author> Steven P. Reiss. </author> <title> PECAN: Program development systems that support multiple views. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(3):276-85, </volume> <month> March </month> <year> 1985. </year>
Reference-contexts: We envision that all four of these types of views will be useful, although discovering the content and presentation of useful views is a future question for our research. 7 Related Work Several programming environments have been developed which include visualization capabilities. PECAN <ref> [Rei85] </ref> and PROVIDE [Moh88] are early program development systems that utilized graphical views such as data structure displays, a call-graph, and the call stack. With respect to object-oriented systems in particular, more recent work includes Reiss' FIELD system [Rei90].
Reference: [Rei90] <author> Steven P. Reiss. </author> <title> Interacting with the FIELD environment. </title> <journal> Software|Practice & Experience, </journal> <volume> 20(S-1), </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: Both of these approaches are often based upon creating some internal representation of a program from which information can be extracted and presented to the user. Some tools have begun to present this information graphically, such as the CARE environment [LAD + 93] and FIELD <ref> [Rei90] </ref>. We support a different approach to program understanding: program visualization. Program visualization is a sub-set of the area known as software visualization-the use of graphics and animation to visually describe and illustrate software and its function [PBS93, SP92]. In program visualization, the medium being visualized is a computer program. <p> PECAN [Rei85] and PROVIDE [Moh88] are early program development systems that utilized graphical views such as data structure displays, a call-graph, and the call stack. With respect to object-oriented systems in particular, more recent work includes Reiss' FIELD system <ref> [Rei90] </ref>. FIELD contains an extensive set of tools for developing and maintaining C++ programs. These tools include graphical aids such as class browsers [LMR92] and flow graphs, but the recent thrust of the work has been on 3-D display views [Rei93].
Reference: [Rei93] <author> Steven P. Reiss. </author> <title> A framework for abstract 3D visualization. </title> <booktitle> In Proceedings of the 1993 IEEE Symposium on Visual Languages, </booktitle> <pages> pages 108-115, </pages> <address> Bergen, Norway, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: FIELD contains an extensive set of tools for developing and maintaining C++ programs. These tools include graphical aids such as class browsers [LMR92] and flow graphs, but the recent thrust of the work has been on 3-D display views <ref> [Rei93] </ref>. The BEE++[BGL93] object-oriented application framework supports dynamic analysis of distributed programs. It provides a platform for event monitoring, visualization, and graphical debugging. The analysis tools can be distributed across nodes, providing significant performance gains during visualization.
Reference: [SAE88] <author> Elliot Soloway, Beth Adelson, and Kate Ehrlich. </author> <title> Knowledge and processes in the comprehension of computer programs. </title> <editor> In M. Chi, R. Glaser, and M. Farr, editors, </editor> <booktitle> The Nature of Expertise, </booktitle> <pages> pages 129-152. </pages> <publisher> Lawrence Erlbaum Associates, </publisher> <year> 1988. </year>
Reference-contexts: There are many theories as to how program comprehension is performed. Brooks originally proposed the idea that comprehension is essentially a maintainer reconstructing the mappings that the programmer originally created [Bro83]. The program understanding process may proceed in a bottom-up [BM82, Bro83, Pen87] or top-down <ref> [SAE88] </ref> manner, or a combination of both [Let86, vMV93], depending on the available cues, the type of maintenance [vMV93], and the maintainer's syntactic and semantic knowledge base [YB93].
Reference: [SP92] <author> John T. Stasko and Charles Patterson. </author> <title> Understanding and characterizing software visualization systems. </title> <booktitle> In Proceedings of the 1992 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 3-10, </pages> <address> Seattle, WA, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: We support a different approach to program understanding: program visualization. Program visualization is a sub-set of the area known as software visualization-the use of graphics and animation to visually describe and illustrate software and its function <ref> [PBS93, SP92] </ref>. In program visualization, the medium being visualized is a computer program. The basic premise of visualization is that users can better understand and investigate the inner-workings of their software by seeing it portrayed visually.
Reference: [SS92] <author> John J. Shilling and John T. Stasko. </author> <title> Using animation to design, document and trace object-oriented systems. </title> <type> Technical Report GIT-GVU-92-12, </type> <institution> Graphics, Visualization, and Usability Center, Georgia Institute of Technology, </institution> <address> Atlanta, GA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Previous work by Shilling and Stasko involved constructing the GROOVE visual design tool <ref> [SS92] </ref>. The GROOVE tool is designed to help programmers visually specify both the static structure and the dynamic protocols of an object-oriented program. GROOVE's visual paradigm employs shape, color, and animation to portray objects and relationships. For example, classes are represented as upside-down triangles.
Reference: [TGP89] <author> David Taenzer, Murthy Ganti, and Sunil Podar. </author> <title> Object-oriented software reuse: The yo-yo problem. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 2 </volume> <pages> 30-35, </pages> <address> Sept.-Oct. </address> <year> 1989. </year>
Reference-contexts: If class dependency information were available, this process could be performed more efficiently. Another phenomenon related to dynamic binding occurs when method calls are circularly made to different classes in a single object's inheritance hierarchy. This occurrence was recognized by Taenzer, Ganti, and Podar as the yo-yo effect <ref> [TGP89] </ref>. If a programmer had access to a visualization of the method binding, such a phenomenon could be easily identified. Maintenance of software systems is often complicated by the transiency of programmers in software development organizations.
Reference: [vMV93] <author> A. von Mayrhauser and A.M. Vans. </author> <title> From program comprehension to tool requirements for an industrial environment. </title> <booktitle> In Proceedings of the 2nd Workshop on Program Comprehension, </booktitle> <pages> pages 78-86, </pages> <address> Capri, Italy, </address> <month> July 8-9 </month> <year> 1993. </year>
Reference-contexts: Brooks originally proposed the idea that comprehension is essentially a maintainer reconstructing the mappings that the programmer originally created [Bro83]. The program understanding process may proceed in a bottom-up [BM82, Bro83, Pen87] or top-down [SAE88] manner, or a combination of both <ref> [Let86, vMV93] </ref>, depending on the available cues, the type of maintenance [vMV93], and the maintainer's syntactic and semantic knowledge base [YB93]. <p> The program understanding process may proceed in a bottom-up [BM82, Bro83, Pen87] or top-down [SAE88] manner, or a combination of both [Let86, vMV93], depending on the available cues, the type of maintenance <ref> [vMV93] </ref>, and the maintainer's syntactic and semantic knowledge base [YB93]. The process might also be systematic-an attempt to understand the entire program, or as-needed , where only the parts of a program necessary to carry out a particular task are investigated [LPLS86].
Reference: [WH92] <author> Norman Wilde and Ross Huitt. </author> <title> Maintenance support for object-oriented programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(12) </volume> <pages> 1038-1044, </pages> <month> De-cember </month> <year> 1992. </year>
Reference-contexts: Wilde and Huitt have identified several areas in which tool support is needed: tracing dynamic message binding, analyzing dependencies between classes, understanding high-level aspects of a system, locating system functionality, and resolving polymorphism <ref> [WH92] </ref>. A tool that tracks the dynamic message handling by objects during program execution 2 would be able to provide users with dynamic binding information. Method invocation during message handling is an example of a more global aspect of object-oriented programs: object dependencies. <p> Such dependencies might be class-to-class, class-to-method, or method-to-message. Classes whose methods are invoked often are clearly candidates for optimization. Analyzing these dependencies can be complicated by dynamic binding and polymorphism. Additionally, displaying the multi-dimensional nature of the dependencies would be difficult with purely textual screens <ref> [WH92] </ref>. In the object-oriented software development process, the inheritance hierarchy is often a dynamic entity that evolves over time. Part of this evolution involves moving class methods up or down in the hierarchy, to meet implementation constraints. If class dependency information were available, this process could be performed more efficiently. <p> It is often difficult for a new programmer to understand the complex relationships between objects present in large object-oriented systems [LMR92]. Again, program understanding is complicated by dynamic binding and inheritance hierarchies. One suggestion for increasing understanding might be a graphical view of the inheritance hierarchy <ref> [WH92] </ref>, or a graphical visualization of the communication between objects in the system. Another maintenance problem arises when the naming of messages does not correspond consistently to the action taken by objects receiving the messages. <p> Another maintenance problem arises when the naming of messages does not correspond consistently to the action taken by objects receiving the messages. This problem is particularly important in object-oriented systems, where function overloading is both permissible and common <ref> [WH92] </ref>. Wilde and Huitt go on to point out that, "graphic displays of object relationships would seem to be very useful." (page 1043) It is clear that the object-oriented approach to software development includes pitfalls for program developers and maintainers. <p> backtracking, although programming environments such as PROVIDE [Moh88] have state-saving capabilities. 6.2.3 Views As mentioned in Section 2, tools which support object-oriented program visualization will help in the following areas: understanding high-level aspects of a system, tracing dynamic message binding, analyzing dependencies between classes, locating system functionality, and resolving polymorphism <ref> [WH92] </ref>. Our visualization framework is intended to support views in each of the aforementioned problems, with the specific goal of handling real-world sized applications.
Reference: [YB93] <author> E.J. Younger and K.H. Bennett. </author> <title> Model-based tools to record program understanding. </title> <booktitle> In Proceedings of the 2nd Workshop on Program Comprehension, </booktitle> <pages> pages 87-95, </pages> <address> Capri, Italy, </address> <month> July 8-9 </month> <year> 1993. </year> <month> 15 </month>
Reference-contexts: The program understanding process may proceed in a bottom-up [BM82, Bro83, Pen87] or top-down [SAE88] manner, or a combination of both [Let86, vMV93], depending on the available cues, the type of maintenance [vMV93], and the maintainer's syntactic and semantic knowledge base <ref> [YB93] </ref>. The process might also be systematic-an attempt to understand the entire program, or as-needed , where only the parts of a program necessary to carry out a particular task are investigated [LPLS86]. <p> Research in the area of program comprehension has been focused on providing tools which make this feedback loop more effective. Two main approaches have been followed here: 1) to allow maintainers access to knowledge about the design of the program, as described by Younger and Bennett <ref> [YB93] </ref>, or 2) to provide an analysis of the many inter-dependencies existing in a program, including data-flow and control-flow, as in [LA93]. Both of these approaches are often based upon creating some internal representation of a program from which information can be extracted and presented to the user.
References-found: 33

