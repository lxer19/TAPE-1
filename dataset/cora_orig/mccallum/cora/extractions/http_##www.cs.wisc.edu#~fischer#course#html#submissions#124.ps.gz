URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/124.ps.gz
Refering-URL: http://www.cs.wisc.edu/~fischer/course/html/submissions/
Root-URL: http://www.cs.wisc.edu
Email: fnaoi,naohisag@slab.ntt.jp  
Phone: phone +81 422 59 2908 facsimile +81 422 59 2699  
Title: Detection of infeasible paths using Presburger arithmetic  
Author: Kuniaki NAOI Naohisa TAKAHASHI 
Date: 2 2 2 pn  
Note: within deterministic time  
Address: 3-9-11, Midoricho, Musashino-shi, Tokyo 180, JAPAN.  
Affiliation: NTT Software Laboratories  
Abstract: for some constant p &gt; 1. Our preliminary experiment using a prototype system achieved an exponential increase in computation time, when an identical variable repeatedly appeared in the same atom in a P-sentence. Here, the number of appearances in the atom corresponds to a coefficient of a variable in a path condition used for detecting an IFP. In the proposed method, a matrix denoting coefficients of the variables is converted to a triangular matrix based on the method proposed by D. C. Cooper. Next, if the rank of the matrix is lower than the degree of the matrix, it is triangulated by using a method for solving one linear equation with three or more unknowns, so that the matrix can be back-substituted. Then, the values of each variable for the P-sentence to be satisfied are calculated in order by a back-substitution process. This paper also reports that implementation of this method shows a lower increase in computation time than the previous method and reduces computation time by up to 3,000,000 times.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aho, A.V., Sethi, R., and Ullman, J.D.: </author> <booktitle> "Compilers: Principles, Techniques, and Tools," </booktitle> <publisher> Addison-Wesley (1986). </publisher>
Reference: [2] <author> Clarke, L.A.: </author> <title> "A system to generate test data and symbolically execute programs," </title> <journal> IEEE Transactions on software engineering, </journal> <volume> Vol. SE-2, No. 3, </volume> <pages> pp. </pages> <month> 215-222 (Sept. </month> <year> 1976). </year>
Reference-contexts: 1 Introduction Finding a calculation path that is never executed for any inputs is called infeasible path (IFP) detection <ref> [10, 2, 3, 13, 7, 9] </ref>. This will make various kinds of program analyses more accurate and these program analyses will be accomplished by analyzing each path [15]. <p> One of the most important problems in IFP detection is to decide the satisfiability of a formula, called a path condition (PC). The PC for a path indicates whether the path is executable <ref> [2] </ref>. Several theorem provers have been proposed which directly decide PC satisfiability [10, 7, 9]. Although these provide accurate decisions when they terminate, the PC satisfiability is undecidable in general. <p> All the variables in the expression are bounded by existential quantifiers. The bounded expression is a P-sentence. If and only if the P-sentence is FALSE, the expression is unsatisfiable. Therefore, satisfiability of the P-sentence can be determined by conservative approximation. Although many methods have been proposed <ref> [2, 3, 7, 9, 10] </ref> for determining satisfia-bility, either they are not so accurate or they do not work automatically. 3.3 Decision of a P-sentence in IFP Detection A P-sentence used in IFP detection is a prenex normal form in which all variables are bounded by existential quantifiers.
Reference: [3] <author> Clarke, L.A. and Richardson, </author> <title> D.J.: "Applications of symbolic evaluation," </title> <journal> Journal of Systems and Software, </journal> <volume> Vol. 5, No. 1, </volume> <pages> pp. </pages> <month> 15-35 </month> <year> (1985). </year>
Reference-contexts: 1 Introduction Finding a calculation path that is never executed for any inputs is called infeasible path (IFP) detection <ref> [10, 2, 3, 13, 7, 9] </ref>. This will make various kinds of program analyses more accurate and these program analyses will be accomplished by analyzing each path [15]. <p> All the variables in the expression are bounded by existential quantifiers. The bounded expression is a P-sentence. If and only if the P-sentence is FALSE, the expression is unsatisfiable. Therefore, satisfiability of the P-sentence can be determined by conservative approximation. Although many methods have been proposed <ref> [2, 3, 7, 9, 10] </ref> for determining satisfia-bility, either they are not so accurate or they do not work automatically. 3.3 Decision of a P-sentence in IFP Detection A P-sentence used in IFP detection is a prenex normal form in which all variables are bounded by existential quantifiers.
Reference: [4] <author> Clarkson, K.L.: </author> <title> "Las Vegas algorithms for linear and integer programming when the dimension is small," </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> Vol. 42, No. 2, </volume> <pages> pp. </pages> <month> 488-499 (March </month> <year> 1995). </year>
Reference-contexts: Cooper. The procedure is quantifier elimination which, given a formula of L + of the form 9xF (x) where F (x) is quantifier free, returns a formula F 0 of L + which is equivalent to 9xF (x) but which contains no quantifiers and no variable x. Refer to <ref> [4] </ref> for the elimination algorithm. For deciding the truth of any P-sentence A, replace any expression 8x with the equivalent expression :9x9. Next, apply quantifier elimination to the innermost quantified subformulas of A, replacing subformulas of the form 9xF (x) with equivalent subformulas without quantifiers. <p> a P-sentence in the above case, efficiently decides the truth of expression (1), that is, efficiently computes sets of values to satisfy a conjunction form of all atoms in expression (1). 4.1 Cooper's Suggestion Cooper suggested the following method to compute the sets of values to satisfy expression (1) in <ref> [4] </ref>. A matrix ( jk ) which denotes coefficients of variables in expression (2), i.e. a coefficient matrix, is converted to a triangular matrix by a method similar to Gaussian elimination. Then, all the solutions for expression (1) are obtained by a back-substitution process. <p> Although integer programming is an NP-Complete problem, Lenstra [12] showed that integer programming can be solved in polynomial time when the number of variables is fixed. Clarkson <ref> [4] </ref> proposed an algorithm faster than Lenstra's, when nd holds where n is the number of constraints and d is the number of variables. However, no program for the polynomial time algorithm is available.
Reference: [5] <author> Cooper, </author> <title> D.C.: "Theorem proving in arithmetic without multiplication," </title> <journal> Machine Intelligence, </journal> <volume> No. 7, </volume> <pages> pp. </pages> <month> 91-99 </month> <year> (1972). </year>
Reference-contexts: These led us to use the decision procedure for a Presburger sentence (P-sentence) [13] in order to decide the PC satisfia bility. Presburger arithmetic <ref> [5] </ref> contains symbols such as (, ), ^, _, :, 8, 9, =, &lt;, +, 0, and 1. A P-sentence is a formula in Presburger arithmetic that has no free variables, is decidable, and the procedure for deciding is known. <p> Then, if and only if the P-sentence is FALSE, the PC is said to 1 be unsatisfiable. However, the truth of any P-sentence of length n is decided within deterministic time 2 2 2 pn for some constant p &gt; 1 <ref> [5] </ref>. Our preliminary experiments using a prototype system for deciding the truth of the P-sentences have also shown an exponential increase in computation time, when an identical variable appears more often in the same atom in a P-sentence. <p> Then, the value of each variable for deciding the truth of the P-sentence is calculated by a back-substitution process, and this calculation is performed for all vari ables in order. Although this method is based on a method suggested by D. C. Cooper <ref> [5] </ref>, it is different from his method in that the linear equation is solved when the rank is lower than the degree. Cooper pointed out that the triangulation with the number theory can be applied to decide the truth of the P-sentence that we are considering. <p> As a result, computation is reduced when some coefficients become larger. In this way, an implementation of the method has reduced computation time by up to 3,000,000 times. 2 Presburger Arithmetic There is a class of decidable formulas called Pres-burger sentences (or P-sentences) <ref> [5, 8] </ref> defined in Presburger arithmetic as a subclass of formulas in a first-order predicate calculus. 2.1 Definition First we will define the language of Presburger arithmetic, L + . <p> On the other 3 hand, such a method for deciding the P-sentence has been proposed by D. C. Cooper in which all the substitution is delayed until all the quantifiers have been eliminated <ref> [5] </ref> as follows. This is because W ffi i=1 , which is created when an existential quantifier is eliminated, and other existential quantifiers are commutative. <p> Note that the matrix ( 0 jk ) can be back-substituted. A method is shown in <ref> [5] </ref> to compute sets of values to satisfy expression (5) within the bound shown in expression (2). 5 Detection Examples of an IFP Two examples are given below to detect an IFP in a program. 5.1 Example without Lower Rank Matrix An example is shown to detect IFPs in a sample
Reference: [6] <author> Dickson, L.E: </author> <title> "History of the theory of numbers," Vol. II, </title> <institution> Carnegie Institution of Washington (1952). </institution>
Reference-contexts: Here, a theorem in the number theory is used to make an element in the matrix 0. If the rank of the matrix is lower than the degree of the matrix, it is triangulated by using a method for solving one linear equation with three or more unknowns <ref> [6] </ref>, so that the matrix can be back-substituted. Then, the value of each variable for deciding the truth of the P-sentence is calculated by a back-substitution process, and this calculation is performed for all vari ables in order. Although this method is based on a method suggested by D. C. <p> We introduce a procedure for triangulating the matrix, which uses the method for solving a linear equation with three or more unknowns <ref> [6] </ref>, so that a lower rank matrix can be back-substituted. 4.2.1 Triangulation by using a Theorem in Number Theory A triangulation procedure for the coefficient matrix is described. By applying this procedure, lower triangular elements should be converted to 0 in the same order as Gaussian elimination.
Reference: [7] <author> Goldberg, A., Wang, T.C., and Zimmerman, D.: </author> <title> "Application of feasible path analysis to program testing," </title> <booktitle> Proceedings of the 1994 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pp. </pages> <month> 80-94 (Aug. </month> <year> 1994). </year>
Reference-contexts: 1 Introduction Finding a calculation path that is never executed for any inputs is called infeasible path (IFP) detection <ref> [10, 2, 3, 13, 7, 9] </ref>. This will make various kinds of program analyses more accurate and these program analyses will be accomplished by analyzing each path [15]. <p> One of the most important problems in IFP detection is to decide the satisfiability of a formula, called a path condition (PC). The PC for a path indicates whether the path is executable [2]. Several theorem provers have been proposed which directly decide PC satisfiability <ref> [10, 7, 9] </ref>. Although these provide accurate decisions when they terminate, the PC satisfiability is undecidable in general. Therefore, we have focused on conservative approximation of PC satisfiability, in which a PC is converted into another formula whose satisfiability is always decidable. <p> Variables with data type other than integer can be easily converted integer variables as shown in <ref> [7] </ref>. Additionally, we proposed a method in which the same terms with operators other than Presburger arithmetic are converted to unique integer variables [13], so the converted expression becomes an expression on Presburger arithmetic. <p> All the variables in the expression are bounded by existential quantifiers. The bounded expression is a P-sentence. If and only if the P-sentence is FALSE, the expression is unsatisfiable. Therefore, satisfiability of the P-sentence can be determined by conservative approximation. Although many methods have been proposed <ref> [2, 3, 7, 9, 10] </ref> for determining satisfia-bility, either they are not so accurate or they do not work automatically. 3.3 Decision of a P-sentence in IFP Detection A P-sentence used in IFP detection is a prenex normal form in which all variables are bounded by existential quantifiers.
Reference: [8] <author> Higashino, T., Kitamichi, J., and Taniguchi, K.: </author> <title> "Presburger Arithmetic and its Application to Program Developments," </title> <journal> Computer Software, </journal> <volume> Vol. 9, No. 6, </volume> <pages> pp. </pages> <month> 31-39 (Jun. </month> <note> 1992) (In Japanese). </note>
Reference-contexts: As a result, computation is reduced when some coefficients become larger. In this way, an implementation of the method has reduced computation time by up to 3,000,000 times. 2 Presburger Arithmetic There is a class of decidable formulas called Pres-burger sentences (or P-sentences) <ref> [5, 8] </ref> defined in Presburger arithmetic as a subclass of formulas in a first-order predicate calculus. 2.1 Definition First we will define the language of Presburger arithmetic, L + . <p> substitute variables (i Y ; i X ) by 21fi4998 sets of values in expression (8). 6.2 Efficiency of Our Method The decision procedure for a prenex normal form P-sentence bounded only by existential quantifiers is widely applied to automated correctness proof for specifications in various kinds of design fields <ref> [8] </ref>, such as hardware [11], communication protocol [21], and programs [22, 23]. In these applications, the number of identical variables in the same atom is often 1. Even if this is not so, the number is always small.
Reference: [9] <author> Jasper, R., Brennan, M., Williamson, K., Currier, B., and Zimmerman, D.: </author> <title> "Test data generation and feasible path analysis," </title> <booktitle> Proceedings of the 1994 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pp. </pages> <month> 95-107 (Aug. </month> <year> 1994). </year>
Reference-contexts: 1 Introduction Finding a calculation path that is never executed for any inputs is called infeasible path (IFP) detection <ref> [10, 2, 3, 13, 7, 9] </ref>. This will make various kinds of program analyses more accurate and these program analyses will be accomplished by analyzing each path [15]. <p> One of the most important problems in IFP detection is to decide the satisfiability of a formula, called a path condition (PC). The PC for a path indicates whether the path is executable [2]. Several theorem provers have been proposed which directly decide PC satisfiability <ref> [10, 7, 9] </ref>. Although these provide accurate decisions when they terminate, the PC satisfiability is undecidable in general. Therefore, we have focused on conservative approximation of PC satisfiability, in which a PC is converted into another formula whose satisfiability is always decidable. <p> All the variables in the expression are bounded by existential quantifiers. The bounded expression is a P-sentence. If and only if the P-sentence is FALSE, the expression is unsatisfiable. Therefore, satisfiability of the P-sentence can be determined by conservative approximation. Although many methods have been proposed <ref> [2, 3, 7, 9, 10] </ref> for determining satisfia-bility, either they are not so accurate or they do not work automatically. 3.3 Decision of a P-sentence in IFP Detection A P-sentence used in IFP detection is a prenex normal form in which all variables are bounded by existential quantifiers.
Reference: [10] <author> King, </author> <title> J.C.: "Symbolic execution and program testing," </title> <journal> Communications of the ACM, </journal> <volume> Vol. 19, No. 7, </volume> <pages> pp. </pages> <month> 385-394 (July </month> <year> 1976). </year>
Reference-contexts: 1 Introduction Finding a calculation path that is never executed for any inputs is called infeasible path (IFP) detection <ref> [10, 2, 3, 13, 7, 9] </ref>. This will make various kinds of program analyses more accurate and these program analyses will be accomplished by analyzing each path [15]. <p> One of the most important problems in IFP detection is to decide the satisfiability of a formula, called a path condition (PC). The PC for a path indicates whether the path is executable [2]. Several theorem provers have been proposed which directly decide PC satisfiability <ref> [10, 7, 9] </ref>. Although these provide accurate decisions when they terminate, the PC satisfiability is undecidable in general. Therefore, we have focused on conservative approximation of PC satisfiability, in which a PC is converted into another formula whose satisfiability is always decidable. <p> All the variables in the expression are bounded by existential quantifiers. The bounded expression is a P-sentence. If and only if the P-sentence is FALSE, the expression is unsatisfiable. Therefore, satisfiability of the P-sentence can be determined by conservative approximation. Although many methods have been proposed <ref> [2, 3, 7, 9, 10] </ref> for determining satisfia-bility, either they are not so accurate or they do not work automatically. 3.3 Decision of a P-sentence in IFP Detection A P-sentence used in IFP detection is a prenex normal form in which all variables are bounded by existential quantifiers.
Reference: [11] <author> Kitamichi, J., Morioka, S., Higashino, T., and Taniguchi, K.: </author> <title> "Automatic correctness proof of the implementation of synchronous sequential circuits using an algebraic approach," </title> <booktitle> Proceedings of the 2nd International Conference on Theorem Provers in Circuit Design (TPCD '94) (Kropf, </booktitle> <editor> T. and Kumar, R. Eds.), </editor> <volume> Vol. </volume> <booktitle> 901 of Lecture Notes in Computer Science, </booktitle> <pages> pp. 165-184, </pages> <publisher> Springer Verlag (1995). </publisher>
Reference-contexts: ; i X ) by 21fi4998 sets of values in expression (8). 6.2 Efficiency of Our Method The decision procedure for a prenex normal form P-sentence bounded only by existential quantifiers is widely applied to automated correctness proof for specifications in various kinds of design fields [8], such as hardware <ref> [11] </ref>, communication protocol [21], and programs [22, 23]. In these applications, the number of identical variables in the same atom is often 1. Even if this is not so, the number is always small. Therefore, the number of each ffi j , where 1jn, in expression (2) is quite small.
Reference: [12] <author> Lenstra, H.W. Jr.: </author> <title> "Integer programming with a fixed number of variables," </title> <journal> Mathematics of Operations Research, </journal> <volume> Vol. 8, No. 4, </volume> <pages> pp. </pages> <month> 538-548 (Nov. </month> <year> 1983). </year>
Reference-contexts: Although integer programming is an NP-Complete problem, Lenstra <ref> [12] </ref> showed that integer programming can be solved in polynomial time when the number of variables is fixed. Clarkson [4] proposed an algorithm faster than Lenstra's, when nd holds where n is the number of constraints and d is the number of variables.
Reference: [13] <author> Naoi, K. and Takahashi, N.: </author> <title> "Detection of Unfeasible Paths with a Path Dependence Flow Graph," </title> <journal> Systems and Computers in Japan, </journal> <volume> Vol. 25, No. 10, </volume> <pages> pp. </pages> <month> 1-14 </month> <year> (1994). </year>
Reference-contexts: 1 Introduction Finding a calculation path that is never executed for any inputs is called infeasible path (IFP) detection <ref> [10, 2, 3, 13, 7, 9] </ref>. This will make various kinds of program analyses more accurate and these program analyses will be accomplished by analyzing each path [15]. <p> Our goals in the research of IFP detection are to develop a conservative approximation method that provides as many unsatisfiable formulas as possible and to reduce the computation time of the method. These led us to use the decision procedure for a Presburger sentence (P-sentence) <ref> [13] </ref> in order to decide the PC satisfia bility. Presburger arithmetic [5] contains symbols such as (, ), ^, _, :, 8, 9, =, &lt;, +, 0, and 1. <p> A P-sentence is a formula in Presburger arithmetic that has no free variables, is decidable, and the procedure for deciding is known. Such a conservative approximation method can be developed as some of the PCs which are not formulas in Pres-burger arithmetic are decided to be unsatisfiable <ref> [13] </ref>. However, this paper will concentrate on a simple conservative approximation method for the simplicity of discussion. Our method decides a PC to be unsatisfiable, only if the PC is a formula in Presburger arithmetic and the formula is decided to be unsatisfiable. <p> When the PC is not satisfiable, the path is determined to be an IFP. 3.1 Computation of a PC We proposed a method for computing PCs by demand-driven execution <ref> [13] </ref> for a path dependence flow graph (PDFG) [17, 18], which is a directed graph representation for an imperative program. This is efficient because it computes only the requisite expressions for the PC and because it iteratively uses the partial computation results in computing PCs. <p> Additionally, when a program involves loops, the PC computation process may not also be terminated in a similar way to procedure calls. We proposed a method in which a loop is converted to a procedure call <ref> [13] </ref>. Because the process always terminates with procedure calls, the process with loops terminates. 3.2 Satisfiability Problem for the PC The PC may involve function application forms, operators, and various data type variables that are not allowed in a Presburger arithmetic. <p> Variables with data type other than integer can be easily converted integer variables as shown in [7]. Additionally, we proposed a method in which the same terms with operators other than Presburger arithmetic are converted to unique integer variables <ref> [13] </ref>, so the converted expression becomes an expression on Presburger arithmetic. For example, a term f (a)+b and another term f (a)+c can be converted to x+b and x+c respectively, if the scopes of both variables a are the same, where f (a) is a function application form.
Reference: [14] <author> Naoi, K. and Takahashi, N.: </author> <title> "Program Analysis with a Path Dependence Flow Graph," </title> <journal> NTT R&D, </journal> <volume> Vol. 42, No. 8, </volume> <pages> pp. </pages> <month> 1007-1016 (Aug. </month> <note> 1993) (In Japanese). </note>
Reference-contexts: Detection therefore allows accurate computation of various kinds of program slices [17, 18], and accurate detection of se mantic errors that may occur when two variants of a program are merged <ref> [14] </ref>. One of the most important problems in IFP detection is to decide the satisfiability of a formula, called a path condition (PC). The PC for a path indicates whether the path is executable [2]. Several theorem provers have been proposed which directly decide PC satisfiability [10, 7, 9].
Reference: [15] <author> Naoi, K. and Takahashi, N.: </author> <title> "A program Analysis System with a Path Dependence Flow Graph," </title> <booktitle> Proceedings of the 47th Annual Convention IPS Japan, </booktitle> <address> 5D-9 (Nov. </address> <note> 1993) (In Japanese). </note>
Reference-contexts: 1 Introduction Finding a calculation path that is never executed for any inputs is called infeasible path (IFP) detection [10, 2, 3, 13, 7, 9]. This will make various kinds of program analyses more accurate and these program analyses will be accomplished by analyzing each path <ref> [15] </ref>. Detection therefore allows accurate computation of various kinds of program slices [17, 18], and accurate detection of se mantic errors that may occur when two variants of a program are merged [14].
Reference: [16] <author> Naoi, K. and Takahashi, N.: </author> <title> "Computation reduction in infeasible path detection that uses a path dependence flow graph," </title> <booktitle> Proceedings of the 48th Annual Convention IPS Japan, </booktitle> <month> 6G-2 (Mar. </month> <note> 1994) (In Japanese). </note>
Reference-contexts: Therefore, the amount of computation for deciding a P-sentence increases exponentially. As a result, the PC satisfiability may not be decided for a realistic program within a practical time <ref> [16] </ref>. This paper proposes a method which efficiently decides the truth of a prenex normal form P-sentence bounded only by existential quantifiers in order to solve the above mentioned problem. In this method, the P-sentence is first converted to a conjunction form of divisibility relations.
Reference: [17] <author> Naoi, K. and Takahashi, N.: </author> <title> "Program slicing using a path dependence flow graph," </title> <journal> The transactions of the institute of electronic, information and communication engineers D-I, </journal> <volume> Vol. J78-D-I, No. 7, </volume> <pages> pp. </pages> <note> 607-621 (July 1995) (In Japanese). </note>
Reference-contexts: This will make various kinds of program analyses more accurate and these program analyses will be accomplished by analyzing each path [15]. Detection therefore allows accurate computation of various kinds of program slices <ref> [17, 18] </ref>, and accurate detection of se mantic errors that may occur when two variants of a program are merged [14]. One of the most important problems in IFP detection is to decide the satisfiability of a formula, called a path condition (PC). <p> When the PC is not satisfiable, the path is determined to be an IFP. 3.1 Computation of a PC We proposed a method for computing PCs by demand-driven execution [13] for a path dependence flow graph (PDFG) <ref> [17, 18] </ref>, which is a directed graph representation for an imperative program. This is efficient because it computes only the requisite expressions for the PC and because it iteratively uses the partial computation results in computing PCs.
Reference: [18] <author> Naoi, K. and Takahashi, N.: </author> <title> "Program slicing using a path dependence flow graph," </title> <journal> Systems and Computers in Japan, </journal> <note> (1996) (to appear). </note>
Reference-contexts: This will make various kinds of program analyses more accurate and these program analyses will be accomplished by analyzing each path [15]. Detection therefore allows accurate computation of various kinds of program slices <ref> [17, 18] </ref>, and accurate detection of se mantic errors that may occur when two variants of a program are merged [14]. One of the most important problems in IFP detection is to decide the satisfiability of a formula, called a path condition (PC). <p> When the PC is not satisfiable, the path is determined to be an IFP. 3.1 Computation of a PC We proposed a method for computing PCs by demand-driven execution [13] for a path dependence flow graph (PDFG) <ref> [17, 18] </ref>, which is a directed graph representation for an imperative program. This is efficient because it computes only the requisite expressions for the PC and because it iteratively uses the partial computation results in computing PCs.
Reference: [19] <author> Naoi, K. and Takahashi, N.: </author> <title> "Technique for reducing computation for detecting infeasible paths using Presburger arithmetic," </title> <journal> Technical report of the institute of electronic, information and communication engineers, </journal> <note> SS95-19, (July 1995) (In Japanese). </note>
Reference-contexts: In addition, r is the rank of the coefficient matrix ( 0 jk ), where 1rn. Note that all elements of the lth row are 0 for arbitrary l (r&lt;ln). A procedure to make the elements 0 by using Theorem 1 is described in <ref> [19] </ref>, which is different from Gaussian elimination. 4.2.2 Triangulation for a Lower Rank Ma trix The triangulated matrix cannot be back-substituted if and only if it is a lower rank matrix in which an element of the kth row and jth column a kj is not 0 and the diagonal element
Reference: [20] <author> Oppen, </author> <title> D.C.: "A 2 2 2 pn upper bound on the complexity of Presburger arithmetic," </title> <journal> Journal of computer and system sciences, </journal> <volume> No. 16, </volume> <pages> pp. </pages> <month> 322 332 </month> <year> (1978). </year>
Reference: [21] <author> Li, X.D., Higashino, T., and Taniguchi, K.: </author> <title> "An automatic Derivation of Test Cases for LOTOS Expressions with Data Parameters," </title> <journal> The transactions of the institute of electronic, information and communication engineers B-I, </journal> <volume> Vol. J75-B-I, No. 11, </volume> <pages> pp. </pages> <month> 734-743 (Nov. </month> <note> 1992) (In Japanese). </note>
Reference-contexts: ) by 21fi4998 sets of values in expression (8). 6.2 Efficiency of Our Method The decision procedure for a prenex normal form P-sentence bounded only by existential quantifiers is widely applied to automated correctness proof for specifications in various kinds of design fields [8], such as hardware [11], communication protocol <ref> [21] </ref>, and programs [22, 23]. In these applications, the number of identical variables in the same atom is often 1. Even if this is not so, the number is always small. Therefore, the number of each ffi j , where 1jn, in expression (2) is quite small.
Reference: [22] <author> Morioka, S., Okano, K., Higashino, T., and Taniguchi, K.: </author> <title> "Semi-automatic proof of correctness of refinements of abstract state machine style description using decision procedure for Presburger sentences," </title> <booktitle> 11th Conference Proceedings, Japan Society for Software Science and Technology, E7-4, </booktitle> <pages> pp. </pages> <month> 361-364 (Oct. </month> <note> 1994) (In Japanese). </note>
Reference-contexts: sets of values in expression (8). 6.2 Efficiency of Our Method The decision procedure for a prenex normal form P-sentence bounded only by existential quantifiers is widely applied to automated correctness proof for specifications in various kinds of design fields [8], such as hardware [11], communication protocol [21], and programs <ref> [22, 23] </ref>. In these applications, the number of identical variables in the same atom is often 1. Even if this is not so, the number is always small. Therefore, the number of each ffi j , where 1jn, in expression (2) is quite small.
Reference: [23] <author> Morioka, S., Okano, K., Higashino, T., and Taniguchi, K.: </author> <title> "Hierarchical Design of Stock Management Program using Relational Algebra and Its Correctness Proof," </title> <journal> Transactions of Information Processing Society of Japan, </journal> <volume> Vol. 36, No. 5, </volume> <pages> pp. </pages> <note> 1091-1103 (May 1995) (In Japanese). </note>
Reference-contexts: sets of values in expression (8). 6.2 Efficiency of Our Method The decision procedure for a prenex normal form P-sentence bounded only by existential quantifiers is widely applied to automated correctness proof for specifications in various kinds of design fields [8], such as hardware [11], communication protocol [21], and programs <ref> [22, 23] </ref>. In these applications, the number of identical variables in the same atom is often 1. Even if this is not so, the number is always small. Therefore, the number of each ffi j , where 1jn, in expression (2) is quite small.
Reference: [24] <author> Pugh, W.: </author> <title> "A practical algorithm for exact array dependence analysis," </title> <journal> Communications of the ACM, </journal> <volume> Vol. 35, No. 8, </volume> <pages> pp. </pages> <month> 102-114 (Aug. </month> <year> 1992). </year>
Reference-contexts: Clarkson [4] proposed an algorithm faster than Lenstra's, when nd holds where n is the number of constraints and d is the number of variables. However, no program for the polynomial time algorithm is available. The Omega test proposed by Pugh <ref> [24] </ref> is an efficient method in practice, for determining whether there exists a feasible solution to integer programming. This method is applied to array data dependence testing. <p> This method is applied to array data dependence testing. An implementation of this method can be obtained via ftp, and this determines the existence of a solution in less than 0.5 msec. on a 12-MIPS workstation when the number of both constraints and variables is small <ref> [24] </ref>. However, the computation time increases more rapidly as the numbers of constraints and variables increase, because the Omega test has exponential worst-case time complexity.
References-found: 24

