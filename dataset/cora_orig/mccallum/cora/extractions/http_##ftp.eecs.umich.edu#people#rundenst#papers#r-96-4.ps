URL: http://ftp.eecs.umich.edu/people/rundenst/papers/r-96-4.ps
Refering-URL: http://ftp.eecs.umich.edu/people/rundenst/papers/
Root-URL: http://www.eecs.umich.edu
Email: e-mail: kuno@umich.edu, rundenst@eecs.umich.edu  
Phone: fax: (313) 763-1503 phone: (313) 936-2971  
Title: The MultiView OODB View System: Design and Implementation  
Author: Harumi A. Kuno and Elke A. Rundensteiner 
Address: 1301 Beal Avenue Ann Arbor, MI 48109-2122  
Affiliation: Dept. of Elect. Engineering and Computer Science Software Systems Research Laboratory The University of Michigan,  
Abstract: Views are an established technique for restructuring and repartitioning the format of data, classes, and schemata so that applications can customize shared data objects without affecting other applications' perceptions of the data. The MultiView system is one of the first OODB systems to support dynamic and updatable materialized object-oriented database views. MultiView is fully functional and is being used for a number of projects. In this paper, we describe our system's architecture, the services it provides, and the decisions we made during our implementation. Although the GemStone system we chose for our implementation base offers many features that greatly aided our implementation, it does not support several key object-model properties that are critical for the realization of our design principles. These fundamental properties include multiple classification, dynamic object-restructuring, and the ability to make dynamic changes to the schema. We hence adopted a flexible and powerful technique known as object-slicing to construct the MultiView object model. This object-slicing architecture successfully addresses our requirements. The MultiView system is distinguished by a number of unique features, including the incorporation of virtual classes into the global schema as first-class database citizens, support for capacity-augmenting views (virtual classes that add new extrinsic properties or behavior), view materialization strategies that take advantage of object-oriented modeling features, and a graphical interface that is tailored to provide easy access to the MultiView system. The resulting system preserves all of the capabilities of the underlying GemStone OODB while providing support for dynamic and updatable materialized object-oriented views. fl This work was supported in part by the NSF RIA grant #IRI-9309076, NSF NYI grant #IRI 94-57609, and the University of Michigan Faculty Award Program. We would also like to thank our industrial sponsors, in particular, AT&T, Illustra, and Intel. Harumi Kuno is grateful for support from the NASA Graduate Student Researchers Program. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul and A. Bonner. </author> <title> Objects and views. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 238-247, </pages> <year> 1991. </year>
Reference-contexts: In fact, this provides us with a basis for the arbitrary restructuring of an object's look and feel without compromising its identity. Object-Oriented View Approaches. In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 6, 15, 29, 40, 43] </ref>. Readers may benefit from Kim and Kelley's overview chapter on OODB view support in [21]. Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation. <p> Finally, the last approach completely ignores the issue of classification, thus resulting in a flat class structure. Most of the current proposals for view management systems have not yet been implemented. O2 Views [29] [39], based on the work of Abiteboul and Bonner <ref> [1] </ref>, is the first and only commercial implementation of an object-oriented view management system, realized.
Reference: [2] <author> R. Agrawal and H. V. Jagadish. </author> <title> Materialization and incremental update of path information. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 374-383, </pages> <year> 1989. </year>
Reference-contexts: This would allow a MultiViewer user to view pictures or use tools custom-built for another user's class without having to build or install any software packages. 7 Related Work Relational Versus Object-Oriented Views. View mechanisms have been extensively studied for the relational model <ref> [7, 12, 2, 16] </ref>. Our research on view materialization in OODBs borrows several techniques from the relational arena. Blakeley et al. test modified tuples to see if they fulfill view predicates, thereby detecting irrelevant and autonomously computable updates [7, 8].
Reference: [3] <author> T. Atwood, R. Cattell, J. Duhl, G. Ferran, and D. Wade. </author> <title> The ODMG object model. </title> <journal> Journal of Object Oriented Programming, </journal> <pages> pages 64-69, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: J. Kim [19]. Furthermore, the proposed ODMG standard <ref> [3] </ref> recently formulated by several key OODB vendors also follows this approach. Object Model of MultiView 5 % Person compileAccessingMethodsFor: #( #birthyear #name). % BaseClass createSubclass: #Person supers: #[ Root ] instVarNames: #( #birthyear #name ) constraints: #[ #[birthyear, Integer], #[name, String] ] methods for name and birthyear.
Reference: [4] <author> T. Barsalou, N. Siambela, A. M. Keller, and G. Wiederhold. </author> <title> Updating relational databases through object-based views. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 248-257, </pages> <year> 1991. </year>
Reference: [5] <author> E. Bertino. </author> <title> Integration of heterogeneous data repositories by using object-oriented views. </title> <booktitle> International Workshop on Interoperability in Multidatabase Systems, </booktitle> <pages> pages 22-29, </pages> <month> April </month> <year> 1991. </year>
Reference: [6] <author> E. Bertino. </author> <title> A view mechanism for object-oriented databases. </title> <booktitle> In 3rd International Conference on Extending Database Technology, </booktitle> <pages> pages 136-151, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: We associate both types and extents with our classes because this information must be maintained in any case in order to correctly populate virtual classes. (For example, consider a hide class that is derived from a select class.) In addition, MultiView supports capacity-augmenting virtual classes. First introduced by Bertino <ref> [6] </ref>, a capacity-augmenting virtual class is a virtual class that extends existing data with instance variables that are not derived from the source classes of the virtual class. <p> In fact, this provides us with a basis for the arbitrary restructuring of an object's look and feel without compromising its identity. Object-Oriented View Approaches. In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 6, 15, 29, 40, 43] </ref>. Readers may benefit from Kim and Kelley's overview chapter on OODB view support in [21]. Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation. <p> Related Work 30 subclass/superclass relationship [40]; or (3) simply relate a virtual class with its source class via a derived--from relationship <ref> [6] </ref>, or (4) with the root of the schema [15, 20]. The first approach is vulnerable to potential consistency problems, since the users might introduce an inconsistency in the schema graph by inserting is-a arcs between two classes not related by a subclass relationship.
Reference: [7] <author> J. Blakeley, P. Larson, and F. Tompa. </author> <title> Efficiently updating materialized views. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 61-71, </pages> <year> 1986. </year>
Reference-contexts: This would allow a MultiViewer user to view pictures or use tools custom-built for another user's class without having to build or install any software packages. 7 Related Work Relational Versus Object-Oriented Views. View mechanisms have been extensively studied for the relational model <ref> [7, 12, 2, 16] </ref>. Our research on view materialization in OODBs borrows several techniques from the relational arena. Blakeley et al. test modified tuples to see if they fulfill view predicates, thereby detecting irrelevant and autonomously computable updates [7, 8]. <p> View mechanisms have been extensively studied for the relational model [7, 12, 2, 16]. Our research on view materialization in OODBs borrows several techniques from the relational arena. Blakeley et al. test modified tuples to see if they fulfill view predicates, thereby detecting irrelevant and autonomously computable updates <ref> [7, 8] </ref>. This resembles our solution of filtering irrelevant updates by exploiting the generalization hierarchy and the derivation structure. The system provided by [9] performs incremental view maintenance using production rules that are triggered by update operations. Similarly, we override generic-update operations with type-specific update operators for virtual classes.
Reference: [8] <author> J. A. Blakeley, N. Coburn, and P-A Larson. </author> <title> Updating derived relations: Detecting irrelevant and autonomously computable updates. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(3) </volume> <pages> 369-400, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: View mechanisms have been extensively studied for the relational model [7, 12, 2, 16]. Our research on view materialization in OODBs borrows several techniques from the relational arena. Blakeley et al. test modified tuples to see if they fulfill view predicates, thereby detecting irrelevant and autonomously computable updates <ref> [7, 8] </ref>. This resembles our solution of filtering irrelevant updates by exploiting the generalization hierarchy and the derivation structure. The system provided by [9] performs incremental view maintenance using production rules that are triggered by update operations. Similarly, we override generic-update operations with type-specific update operators for virtual classes.
Reference: [9] <author> S. Ceri and J. Widom. </author> <title> Deriving production rules for incremental view maintenance. </title> <booktitle> In International Conference on Very Large Data Bases, </booktitle> <pages> pages 577-589, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: Blakeley et al. test modified tuples to see if they fulfill view predicates, thereby detecting irrelevant and autonomously computable updates [7, 8]. This resembles our solution of filtering irrelevant updates by exploiting the generalization hierarchy and the derivation structure. The system provided by <ref> [9] </ref> performs incremental view maintenance using production rules that are triggered by update operations. Similarly, we override generic-update operations with type-specific update operators for virtual classes.
Reference: [10] <author> D.H. Fishman. </author> <title> Iris: An object oriented database management system. </title> <journal> In ACM Transactions on Office Information Systems, </journal> <volume> volume 5, </volume> <pages> pages 48-69, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: This is no longer sufficient for capacity-augmenting views. To the best of our knowledge, current OODB systems do not support multiple classification | with the exception of IRIS <ref> [10] </ref>, which is a functional database system that uses a relational database as a storage system, to store data from one object across many relations 3 . Inspired by this approach we have developed an object-slicing technique to address these advanced features in the context of the OODB technology [32]. <p> The Iris functional database system resembles our system in that, being built on top of a relational engine, it distributes data over several relational tables <ref> [10] </ref>. Iris does not support view mechanisms, and does not address issues of classification, inheritance for virtual classes, etc. We can compare the implementation objects of our object-slicing strategy to the oids Kifer et al. generate for complex objects returned by Related Work 31 queries [18].
Reference: [11] <author> G. Gottlob, M. Schrefl, and B. Rock. </author> <title> Extending object-oriented systems with roles. </title> <type> manuscript, </type> <year> 1993. </year>
Reference-contexts: Evaluation of Object-Slicing's Impact on Performance Extending an existing DBMS with object-slicing techniques necessarily involves the overhead of additional data structures, maintenance costs, and processing time. Although object-slicing is a known technique that is being utilized for view systems [26], schema evolution [33], and role systems <ref> [11] </ref>, to our knowledge no other work has been done evaluating the costs of object-slicing. Consequently, we were motivated to perform some initial experiments evaluating the relative costs and benefits of adopting the object-slicing techniques. The complete results of these experiments are presented in [23]. <p> These requirements include multiple classification and dynamic object migration. The flexibility offered by the object-slicing approach naturally lends itself to implementing role systems: object-slicing's implementation objects can easily be adapted to represent the various roles of objects in a role system <ref> [11] </ref>. Although our object-slicing techniques can be compared to mechanisms used in role modeling approaches [11, 30], no other research in the literature discusses the application of the object-slicing paradigm regarding the support of object-oriented views. <p> The flexibility offered by the object-slicing approach naturally lends itself to implementing role systems: object-slicing's implementation objects can easily be adapted to represent the various roles of objects in a role system [11]. Although our object-slicing techniques can be compared to mechanisms used in role modeling approaches <ref> [11, 30] </ref>, no other research in the literature discusses the application of the object-slicing paradigm regarding the support of object-oriented views. In role modeling systems, objects dynamically gain and lose multiple interfaces (a.k.a. roles) throughout their lifetimes. <p> This achieves an efficient and uniform inheritance Related Work 32 scheme. Also, unlike many role systems, in our implementation conceptual objects can be associated with at most one implementation object of a given type <ref> [11] </ref>. Role systems generally do not deal with the issues of virtual class derivation, classification, nor with method promotion. The role system proposed by Gottlob et al. was implemented using techniques similar to object-slicing [11]. This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. <p> implementation conceptual objects can be associated with at most one implementation object of a given type <ref> [11] </ref>. Role systems generally do not deal with the issues of virtual class derivation, classification, nor with method promotion. The role system proposed by Gottlob et al. was implemented using techniques similar to object-slicing [11]. This system, like ours, is implemented in Smalltalk by overriding the doesNotUnderstand: method. Since they target role support, their system does not provide any support for views, and thus does not address issues related to view management.
Reference: [12] <author> E. N. Hanson. </author> <title> A performance analysis of view materialization strategies. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 440-453, </pages> <year> 1987. </year>
Reference-contexts: This would allow a MultiViewer user to view pictures or use tools custom-built for another user's class without having to build or install any software packages. 7 Related Work Relational Versus Object-Oriented Views. View mechanisms have been extensively studied for the relational model <ref> [7, 12, 2, 16] </ref>. Our research on view materialization in OODBs borrows several techniques from the relational arena. Blakeley et al. test modified tuples to see if they fulfill view predicates, thereby detecting irrelevant and autonomously computable updates [7, 8].
Reference: [13] <author> M. Hardwick and B. R. Downie. </author> <title> On object-oriented databases, materialized views, </title> <booktitle> and concurrent engineering. In Proceedings of the 1991 ASME International Computers for Engineering Conference and Exposition. Engineering Databases: An Engineering Resource, </booktitle> <year> 1991. </year>
Reference-contexts: Only a few published papers address issues of view materialization in OODBs. Hardwick and Downie provide a view materialization model in which updates are propagated by use of change files, representing histories of design sessions <ref> [13] </ref>. However, they duplicate objects (including identifiers) for virtual classes rather than merely storing references to objects [13]. Konomi et al. address maintaining consistency for a particular type of join class formed along an existing path in the aggregation graph [22]. <p> Hardwick and Downie provide a view materialization model in which updates are propagated by use of change files, representing histories of design sessions <ref> [13] </ref>. However, they duplicate objects (including identifiers) for virtual classes rather than merely storing references to objects [13]. Konomi et al. address maintaining consistency for a particular type of join class formed along an existing path in the aggregation graph [22]. Our work instead focuses on the exploitation of the structure of the schema hierarchy and derivation dependency graph in order to reduce update propagation.
Reference: [14] <author> W. Harrison, H. Ossher, and H. Mili. </author> <booktitle> Subjectivity in object-oriented systems workshop summary. In OOPSLA Workshop, </booktitle> <year> 1995. </year>
Reference-contexts: Finally, MultiView supports optimized incremental materialized view maintenance algorithms that exploit the integrated class hierarchy structure. Subjectivity. Although MultiView is a view system, its capabilities can be compared to those required by recent subjectivity technology. A subject is a collection of related classes that form a subjective viewpoint <ref> [14] </ref>. MultiView's view schemata could be used to implement such collections. In addition, we can compare MultiView's support for customized interfaces for objects via virtual class types to subjective systems' multiple interfaces to objects. MultiView also facilitates the sharing of data objects amongst diverse applications.
Reference: [15] <author> S. Heiler and S. B. Zdonik. </author> <title> Object views: Extending the vision. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 86-93, </pages> <year> 1990. </year>
Reference-contexts: In fact, this provides us with a basis for the arbitrary restructuring of an object's look and feel without compromising its identity. Object-Oriented View Approaches. In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 6, 15, 29, 40, 43] </ref>. Readers may benefit from Kim and Kelley's overview chapter on OODB view support in [21]. Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation. <p> Related Work 30 subclass/superclass relationship [40]; or (3) simply relate a virtual class with its source class via a derived--from relationship [6], or (4) with the root of the schema <ref> [15, 20] </ref>. The first approach is vulnerable to potential consistency problems, since the users might introduce an inconsistency in the schema graph by inserting is-a arcs between two classes not related by a subclass relationship.
Reference: [16] <author> H. Jakobsson. </author> <title> On materializing views and on-line queries. </title> <booktitle> In ICDT, </booktitle> <pages> pages 407-420, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: This would allow a MultiViewer user to view pictures or use tools custom-built for another user's class without having to build or install any software packages. 7 Related Work Relational Versus Object-Oriented Views. View mechanisms have been extensively studied for the relational model <ref> [7, 12, 2, 16] </ref>. Our research on view materialization in OODBs borrows several techniques from the relational arena. Blakeley et al. test modified tuples to see if they fulfill view predicates, thereby detecting irrelevant and autonomously computable updates [7, 8].
Reference: [17] <author> M. Kaul, K. Drosten, and E. J. Neuhold. Viewsystem: </author> <title> Integrating heterogeneous information bases by object-oriented views. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 2-10, </pages> <month> February </month> <year> 1990. </year>
Reference: [18] <author> M. Kifer, W. Kim, and Y. Sagiv. </author> <title> Querying object-oriented databases. </title> <booktitle> SIGMOD, </booktitle> <pages> pages 393-402, </pages> <year> 1992. </year> <note> Acknowledgements and Thanks 35 </note>
Reference-contexts: Iris does not support view mechanisms, and does not address issues of classification, inheritance for virtual classes, etc. We can compare the implementation objects of our object-slicing strategy to the oids Kifer et al. generate for complex objects returned by Related Work 31 queries <ref> [18] </ref>. Kifer et al. provide an id-function that provides a correspondence between objects in the base set and the objects returned by the queries.
Reference: [19] <author> H. J. Kim. </author> <title> Issues in Object-Oriented Database Systems. </title> <type> PhD thesis, </type> <institution> University of Texas at Austin, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: Although there is no general agreement on whether or not classes in OODBs should incorporate their own extents rather than requiring users to maintain their own collections of class-instances, several systems follow this philosophy, including Orion and the system proposed by H. J. Kim <ref> [19] </ref>. Furthermore, the proposed ODMG standard [3] recently formulated by several key OODB vendors also follows this approach. <p> Note that our approach of providing for the integration of virtual classes into a single unified global schema is distinct from others found in the literature. Existing approaches either: (1) require the user to specify explicitly the relationship between a virtual class and existing base classes <ref> [19, 45] </ref>; or (2) relate a virtual class only with its direct source class via a 9 Note that some materialized RDB views may be implemented using techniques such as view indices that resemble membership materialization. <p> Others define view schemata through the manipulation of the object schema graph rather than solely by query languages. Tanaka et al. [45] propose that view schemata be defined by manually manipulating the edges in the global schema graph. Kim also uses DAG rearrangement for view schema definition <ref> [19] </ref>. Such DAG manipulation approaches must deal with the issues of (1) possibly introducing inconsistencies into the view schema due to human error and of (2) unintentionally modifying the semantics of a virtual class due to side effects of graph manipulation.
Reference: [20] <author> W. Kim. </author> <title> A model of queries in object-oriented databases. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 423-432, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Related Work 30 subclass/superclass relationship [40]; or (3) simply relate a virtual class with its source class via a derived--from relationship [6], or (4) with the root of the schema <ref> [15, 20] </ref>. The first approach is vulnerable to potential consistency problems, since the users might introduce an inconsistency in the schema graph by inserting is-a arcs between two classes not related by a subclass relationship.
Reference: [21] <author> W. Kim. </author> <title> Modern Database Systems: the Object Model, Interoperability, and Beyond. </title> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: Object-Oriented View Approaches. In recent years, several proposals for object-oriented view systems have appeared in the literature [1, 6, 15, 29, 40, 43]. Readers may benefit from Kim and Kelley's overview chapter on OODB view support in <ref> [21] </ref>. Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation. Note that our approach of providing for the integration of virtual classes into a single unified global schema is distinct from others found in the literature.
Reference: [22] <author> S. Konomi, T. Furukawa, and Y. Kambayashi. </author> <title> Super-key classes for updating materialized derived classes in object bases. </title> <booktitle> In International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 310-326, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: However, they duplicate objects (including identifiers) for virtual classes rather than merely storing references to objects [13]. Konomi et al. address maintaining consistency for a particular type of join class formed along an existing path in the aggregation graph <ref> [22] </ref>. Our work instead focuses on the exploitation of the structure of the schema hierarchy and derivation dependency graph in order to reduce update propagation. Role Modeling Systems. MultiView uses an object-slicing mechanism to address the object model requirements underlying the support of object-oriented views.
Reference: [23] <author> H. A. Kuno, Y. G. Ra, and E. A. Rundensteiner. </author> <title> The object-slicing technique: A flexible object representation and its evaluation. </title> <type> Technical Report CSE-TR-241-95, </type> <institution> University of Michigan, </institution> <year> 1995. </year>
Reference-contexts: Consequently, we were motivated to perform some initial experiments evaluating the relative costs and benefits of adopting the object-slicing techniques. The complete results of these experiments are presented in <ref> [23] </ref>. In evaluating the performance of databases, I/O operation time typically dominates CPU operation time. Consequently, an evaluation of object-slicing must consider the effect of object-slicing on I/O time. <p> We have designed and carried out an extensive Object-Slicing Architecture 20 experimental study evaluating clustering techniques to ameliorate this cost <ref> [23] </ref>. 5 MultiView View System M u l t i V i e w O PA L I n t e r f a c e O b j e c t Slicing R e p r e s e n t a t i o n G r a p <p> To the best of our knowledge no existing commercial OODB supports all of these properties. Our implementation of the MultiView system uses the object-slicing representational technique <ref> [23] </ref> to provide these necessary object model properties, which include multiple classification, object migration, and dynamic re-classification. The current version of MultiView uses the 4.0.1 version of GemStone and was developed using the OPAL interface. <p> In a related paper, we explore the use of clustering to ameliorate the overhead of the object-slicing technique employed by our implementation <ref> [23] </ref>. Because it is one of the only implemented view systems to date, MultiView is currently being used in a number of projects at the University of Michigan.
Reference: [24] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Implementation experience with building an object-oriented view management system. </title> <type> Technical Report CSE-TR-191-93, </type> <institution> University of Michigan, </institution> <address> Ann Arbor, </address> <year> 1993. </year>
Reference: [25] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Incremental update propagation algorithms for materialized object-oriented views in MultiView. </title> <type> Technical Report CSE-TR-246-95, </type> <institution> University of Michigan, </institution> <address> Ann Arbor, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: A detailed performance evaluation confirming the benefit of these and other optimization strategies for view materialization can be found elsewhere <ref> [25] </ref>. <p> The code used to implement object-slicing makes up about 5% of the total code. The graphic interface was implemented separately, using Tcl/Tk. We have performed several studies to evaluate the MultiView system and its embedded algorithms. Our experiments demonstrate the benefit of techniques used by our update propagation algorithms <ref> [25, 27] </ref>. Namely, we show that the potential problems of self-cancelling propagation and of early branch condition termination are indeed handled by our solution and result in significant performance gains.
Reference: [26] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Materialized object-oriented views in MultiView. </title> <booktitle> In ACM Research Issues in Data Engineering Workshop, </booktitle> <pages> pages 78-85, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Evaluation of Object-Slicing's Impact on Performance Extending an existing DBMS with object-slicing techniques necessarily involves the overhead of additional data structures, maintenance costs, and processing time. Although object-slicing is a known technique that is being utilized for view systems <ref> [26] </ref>, schema evolution [33], and role systems [11], to our knowledge no other work has been done evaluating the costs of object-slicing. Consequently, we were motivated to perform some initial experiments evaluating the relative costs and benefits of adopting the object-slicing techniques. <p> Section 6 presents examples of MultiView's query functionalities as captured by the MultiView graphic interface, called the MultiViewer. 5.4 Data Manipulation and Associated View Maintenance MultiView supports a suite of update operations, as well as the underlying view update propagation strategies necessary to keep materialized classes consistent <ref> [26, 27] </ref>. The update operators MultiView supports include creation, deletion, addition of a type, removal of a type, and modification of an instance variable. Since MultiView maintains materialized views, the effects of updates must be propagated to all classes affected by it. <p> We identify specific techniques by which we can exploit unique features of the object-oriented paradigm to optimize updatable materialized views <ref> [26, 27] </ref>. Our update algorithms are incremental, and perform selective notification to the set of classes determined to be directly-affected by a given update.
Reference: [27] <author> H. A. Kuno and E. A. Rundensteiner. </author> <title> Using object-oriented principles to optimize update propagation to materialized views. </title> <note> In To be published in ICDE'96, </note> <year> 1996. </year>
Reference-contexts: Section 6 presents examples of MultiView's query functionalities as captured by the MultiView graphic interface, called the MultiViewer. 5.4 Data Manipulation and Associated View Maintenance MultiView supports a suite of update operations, as well as the underlying view update propagation strategies necessary to keep materialized classes consistent <ref> [26, 27] </ref>. The update operators MultiView supports include creation, deletion, addition of a type, removal of a type, and modification of an instance variable. Since MultiView maintains materialized views, the effects of updates must be propagated to all classes affected by it. <p> We identify specific techniques by which we can exploit unique features of the object-oriented paradigm to optimize updatable materialized views <ref> [26, 27] </ref>. Our update algorithms are incremental, and perform selective notification to the set of classes determined to be directly-affected by a given update. <p> The code used to implement object-slicing makes up about 5% of the total code. The graphic interface was implemented separately, using Tcl/Tk. We have performed several studies to evaluate the MultiView system and its embedded algorithms. Our experiments demonstrate the benefit of techniques used by our update propagation algorithms <ref> [25, 27] </ref>. Namely, we show that the potential problems of self-cancelling propagation and of early branch condition termination are indeed handled by our solution and result in significant performance gains.
Reference: [28] <author> J. Martin and J. Odell. </author> <title> Object-Oriented Analysis and Design. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1992. </year>
Reference-contexts: In object-slicing, a real-world object corresponds to a hierarchy of implementation objects (one for each class whose type the object possesses) linked to a conceptual object (used to represent the object-itself) rather than associating one implementation with each conceptual object as is commonly assumed in OODB systems <ref> [28] </ref>. For example, Figure 13 depicts a schema composed of two base classes, Cat and HouseCat, and two virtual classes, HeavyCat (derived from a selection query upon the Cat class) and DietingHeavyCat (derived by refining HeavyCat to add a new instance variable, diet).
Reference: [29] <author> O2 Technology. </author> <title> O2 Views User Manual, </title> <note> version 1 edition, </note> <month> December </month> <year> 1993. </year>
Reference-contexts: In fact, this provides us with a basis for the arbitrary restructuring of an object's look and feel without compromising its identity. Object-Oriented View Approaches. In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 6, 15, 29, 40, 43] </ref>. Readers may benefit from Kim and Kelley's overview chapter on OODB view support in [21]. Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation. <p> Finally, the last approach completely ignores the issue of classification, thus resulting in a flat class structure. Most of the current proposals for view management systems have not yet been implemented. O2 Views <ref> [29] </ref> [39], based on the work of Abiteboul and Bonner [1], is the first and only commercial implementation of an object-oriented view management system, realized.
Reference: [30] <author> M. P. Papazoglou. </author> <title> Roles: A methodology for representing multifaceted objects. </title> <booktitle> In International Conference on Database and Expert Systems Applications, </booktitle> <pages> pages 7-12. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: The flexibility offered by the object-slicing approach naturally lends itself to implementing role systems: object-slicing's implementation objects can easily be adapted to represent the various roles of objects in a role system [11]. Although our object-slicing techniques can be compared to mechanisms used in role modeling approaches <ref> [11, 30] </ref>, no other research in the literature discusses the application of the object-slicing paradigm regarding the support of object-oriented views. In role modeling systems, objects dynamically gain and lose multiple interfaces (a.k.a. roles) throughout their lifetimes.
Reference: [31] <author> Z. Peng and Y. Kambayashi. </author> <title> Deputy mechanisms for object-oriented databases. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 333-340, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: The Deputy Mechanisms proposed by Peng and Kambayashi unify the concepts of object views, roles, and migration in the form of deputy objects and deputy classes <ref> [31] </ref>. In the deputy mechanism paradigm, view objects are treated as roles of database objects. The deputy mechanism object model is probably the work most closely related to MultiView. In particular, similarities of the two systems include: Both support capacity-augmenting views, dynamic classification, and multiple classification.
Reference: [32] <author> Y. G. Ra, H. A. Kuno, and E. A. Rundensteiner. </author> <title> A flexible object-oriented database model and implementation for capacity-augmenting views. </title> <type> Technical Report CSE-TR-215-94, </type> <institution> University of Michigan, </institution> <year> 1994. </year>
Reference-contexts: Inspired by this approach we have developed an object-slicing technique to address these advanced features in the context of the OODB technology <ref> [32] </ref>.
Reference: [33] <author> Y. G. Ra and E. A. Rundensteiner. </author> <title> A transparent object-oriented schema change approach using view schema evolution. </title> <booktitle> In IEEE International Conference on Data Engineering, </booktitle> <pages> pages 165-172, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Evaluation of Object-Slicing's Impact on Performance Extending an existing DBMS with object-slicing techniques necessarily involves the overhead of additional data structures, maintenance costs, and processing time. Although object-slicing is a known technique that is being utilized for view systems [26], schema evolution <ref> [33] </ref>, and role systems [11], to our knowledge no other work has been done evaluating the costs of object-slicing. Consequently, we were motivated to perform some initial experiments evaluating the relative costs and benefits of adopting the object-slicing techniques. The complete results of these experiments are presented in [23]. <p> For example, the Transparent Schema Evolution project, funded by an NSF Young Investigator Award, uses MultiView as an implementation base to develop a suite of schema evolution tools for interoperability of diverse applications via a shared, yet evolving object repository by preserving existing database interfaces through schema change <ref> [33, 34] </ref>. In the future, we plan to extend our current work to examine the area of distributed views. We also want to study issues related to the support of deferred updates and multiple (batched) updates for materialized views.
Reference: [34] <author> Y. G. Ra and E. A. Rundensteiner. </author> <title> A transparent schema evolution system based on object-oriented view technology. </title> <note> To be accepted in IEEE Transactions on Knowledge and Data Engineering, </note> <year> 1995. </year>
Reference-contexts: For example, the Transparent Schema Evolution project, funded by an NSF Young Investigator Award, uses MultiView as an implementation base to develop a suite of schema evolution tools for interoperability of diverse applications via a shared, yet evolving object repository by preserving existing database interfaces through schema change <ref> [33, 34] </ref>. In the future, we plan to extend our current work to examine the area of distributed views. We also want to study issues related to the support of deferred updates and multiple (batched) updates for materialized views.
Reference: [35] <author> E. A. Rundensteiner. </author> <title> MultiView: A methodology for supporting multiple views in object-oriented databases. </title> <booktitle> In 18th VLDB Conference, </booktitle> <pages> pages 187-198, </pages> <year> 1992. </year>
Reference-contexts: Figure 7 displays the view-forming queries currently supported by our model. If a complex query is specified by nesting algebra operators, then each intermediate algebra operator generates a separate virtual class <ref> [35] </ref>. hide syntax &lt;virtual-class&gt;) := (&lt;source-class&gt;) createHideClass: [&lt;new-class-name&gt;] hideMethods: [&lt;prop-functions&gt;]) semantics type (&lt;virtual-class&gt;) := fp 2 P j p2properties (&lt;source-class&gt;) ^ p62&lt;prop-functions&gt;g extent (&lt;virtual-class&gt;) := extent (&lt;source-class&gt;) class rels &lt;source-class&gt; &lt;virtual-class&gt; &lt;source-class&gt; &lt;virtual-class&gt; &lt;source-class&gt; is-a &lt;virtual-class&gt; refine syntax &lt;virtual-class&gt; := (&lt;source-class&gt;) createRefineClass: [&lt;new-class-name&gt;] withProperties: [&lt;prop-function-defs&gt;] semantics type (&lt;virtual-class&gt;) := fp2P j <p> For example, the system must be able to make dynamic changes to the class hierarchy, possibly inserting a new class between two existing classes without affecting the types or extents of previously-existing classes in the hierarchy. We have proposed elsewhere <ref> [38, 35] </ref> algorithms and techniques by which the global class hierarchy can be maintained. Object Model of MultiView 10 % YoungCultureView addVC: YoungPerson withName: #GenerationXer % addVC: Student withName: #Student run YoungCultureView YoungCulture virtual schema. set of classes organized into a schema by MultiView.
Reference: [36] <author> E. A. Rundensteiner. </author> <title> Tools for view generation in OODBs. </title> <booktitle> In International Conference on Information and Knowledge Management, </booktitle> <pages> pages 635-644, </pages> <month> November </month> <year> 1993. </year>
Reference-contexts: We have shown elsewhere that the resulting global schema incorporates the virtual class in a consistent and most efficient manner [37]. 5.2 View Schemata As proven in <ref> [36] </ref>, once the global schema integration has been achieved, the tasks of specifying and constructing view schemata can be reduced to simple graph algorithms. MultiView provides a simple graphical interface for the definition of view schemata (See Section 6.
Reference: [37] <author> E. A. Rundensteiner. </author> <title> A classification algorithm for supporting object-oriented views. </title> <booktitle> In International Conference on Information and Knowledge Management, </booktitle> <pages> pages 18-25, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: As detailed in <ref> [37] </ref>, this integration requires both multiple classification and multiple inheritance. <p> C i is-a C k , C j is-a C k , and p l 2 properties (C k ). This property follows from our classification algorithm, which places each newly-created virtual class into the global class hierarchy in a consistent and correct way <ref> [37] </ref>. Proposition 1 Only two classes will be involved in any property migration caused by virtual class integration. Proof. <p> Both the classification algorithm and its proof of correctness are presented in <ref> [37] </ref>. Classification in MultiView is automatic and compulsory. That is to say, every time a class is added to a MultiView database, the system automatically integrates it into the inheritance hierarchy. <p> The MultiView view creation process includes the invocation of methods which use deterministic algorithms to perform the automatic integration of virtual classes into the global schema. In <ref> [37] </ref> we described the problem of how sometimes there may be no correct location for the placement of a new virtual class in an existent global schema graph in order to allow for both the full inheritance invariant as well as subsumption. <p> The current implementation of the MultiView system includes this classifier, further described in <ref> [37] </ref>, which generates one or more intermediate classes in order to guarantee these properties. This solution is both necessary and sufficient to guarantee the closure of the resulting class hierarchy. <p> We have shown elsewhere that the resulting global schema incorporates the virtual class in a consistent and most efficient manner <ref> [37] </ref>. 5.2 View Schemata As proven in [36], once the global schema integration has been achieved, the tasks of specifying and constructing view schemata can be reduced to simple graph algorithms. MultiView provides a simple graphical interface for the definition of view schemata (See Section 6.
Reference: [38] <author> E. A. Rundensteiner and L. Bic. </author> <title> Set operations in new generation data models. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 4 </volume> <pages> 382-398, </pages> <month> August </month> <year> 1992. </year>
Reference-contexts: For example, the system must be able to make dynamic changes to the class hierarchy, possibly inserting a new class between two existing classes without affecting the types or extents of previously-existing classes in the hierarchy. We have proposed elsewhere <ref> [38, 35] </ref> algorithms and techniques by which the global class hierarchy can be maintained. Object Model of MultiView 10 % YoungCultureView addVC: YoungPerson withName: #GenerationXer % addVC: Student withName: #Student run YoungCultureView YoungCulture virtual schema. set of classes organized into a schema by MultiView.
Reference: [39] <author> C. Souza dos Santos, S. Abiteboul, and C. Delobel. </author> <title> Virtual schemas and bases. </title> <booktitle> In International Conference on Extending Database Technology (EDBT), </booktitle> <year> 1994. </year>
Reference-contexts: Finally, the last approach completely ignores the issue of classification, thus resulting in a flat class structure. Most of the current proposals for view management systems have not yet been implemented. O2 Views [29] <ref> [39] </ref>, based on the work of Abiteboul and Bonner [1], is the first and only commercial implementation of an object-oriented view management system, realized.
Reference: [40] <author> M. H. Scholl, C. Laasch, and M. Tresch. </author> <title> Updatable views in object-oriented databases. </title> <booktitle> In Proceedings of the Second DOOD Conference, </booktitle> <month> December </month> <year> 1991. </year> <note> REFERENCES 36 </note>
Reference-contexts: In fact, this provides us with a basis for the arbitrary restructuring of an object's look and feel without compromising its identity. Object-Oriented View Approaches. In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 6, 15, 29, 40, 43] </ref>. Readers may benefit from Kim and Kelley's overview chapter on OODB view support in [21]. Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation. <p> Related Work 30 subclass/superclass relationship <ref> [40] </ref>; or (3) simply relate a virtual class with its source class via a derived--from relationship [6], or (4) with the root of the schema [15, 20]. <p> The O2 Views approach does include the integration of view classes into a view schema, but rather than supporting a global class hierarchy and migrating properties, it instead daisy-chains views and "bases." Scholl et al. <ref> [40, 41] </ref> have developed an object-preserving algebra to define virtual classes and thus achieve updatable views. Their system, named Cocoon, has been implemented on top of a nested relational model. The MultiView object-algebra is similar in flavor to Cocoon's.
Reference: [41] <author> M. H. Scholl and H. J. Schek. </author> <title> Survey of the cocoon project. </title> <institution> Objektbanken fur Experten, </institution> <month> October </month> <year> 1992. </year>
Reference-contexts: The O2 Views approach does include the integration of view classes into a view schema, but rather than supporting a global class hierarchy and migrating properties, it instead daisy-chains views and "bases." Scholl et al. <ref> [40, 41] </ref> have developed an object-preserving algebra to define virtual classes and thus achieve updatable views. Their system, named Cocoon, has been implemented on top of a nested relational model. The MultiView object-algebra is similar in flavor to Cocoon's.
Reference: [42] <author> E. Sciore. </author> <title> Object specialization. </title> <journal> ACM Transactions on Information Systems, </journal> <pages> pages 103-122, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Such changes are done explicitly by user request, and on an object-by-object basis. View systems, on the other hand, enable users to restructure the types and class membership of complete classes|based on content-based queries. In <ref> [42] </ref>, Sciore proposed an object specialization approach, in which a real world entity is modeled by multiple objects arranged in an object hierarchy. These object hierarchy objects inherit from each other, enabling each individual entity object to decide its own inheritance hierarchy. <p> This single-point-of-inheritance allows us to optimize view update propagation. Unlike many role systems, which allow object hierarchies to exist independently from class hierarchies <ref> [42] </ref>, objects in our model always conform to the existing global class hierarchy. In short, if an object possesses an implementation object of a given class's type, it must also possess an implementation object for every class that is a superclass of that given type.
Reference: [43] <author> J. Shilling and P. Sweeney. </author> <title> Three steps to views: Extending the object-oriented paradigm. </title> <booktitle> In OOPSLA, </booktitle> <pages> pages 353 - 361, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: In fact, this provides us with a basis for the arbitrary restructuring of an object's look and feel without compromising its identity. Object-Oriented View Approaches. In recent years, several proposals for object-oriented view systems have appeared in the literature <ref> [1, 6, 15, 29, 40, 43] </ref>. Readers may benefit from Kim and Kelley's overview chapter on OODB view support in [21]. Most previous work regarding view systems for OODBs focuses on view formation to the exclusion of view incorporation.
Reference: [44] <author> K. Sugiyama, S. Tagawa, and M. </author> <title> Toda. Methods for visual understanding of hierarchical system structures. </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, </journal> <pages> pages 109-125, </pages> <month> February </month> <year> 1981. </year>
Reference-contexts: The graph layout is determined by an algorithm designed to minimize the number of edge crossings <ref> [44] </ref>. This results in a clean-looking directed graph that simplifies visualization of the generalization relationships by grouping similar classes together on the display.
Reference: [45] <author> K. Tanaka, M. Yoshikawa, and K. Ishihara. </author> <title> Schema virtualization in object-oriented databases. </title> <booktitle> IEEE International Conference on Data Engineering, </booktitle> <month> February </month> <year> 1988. </year> <note> REFERENCES 37 </note>
Reference-contexts: Note that our approach of providing for the integration of virtual classes into a single unified global schema is distinct from others found in the literature. Existing approaches either: (1) require the user to specify explicitly the relationship between a virtual class and existing base classes <ref> [19, 45] </ref>; or (2) relate a virtual class only with its direct source class via a 9 Note that some materialized RDB views may be implemented using techniques such as view indices that resemble membership materialization. <p> However, Cocoon does not support the automatic generation of complete view schemata, the implementation of capacity-augmenting views, nor the incremental support of materialized views. Others define view schemata through the manipulation of the object schema graph rather than solely by query languages. Tanaka et al. <ref> [45] </ref> propose that view schemata be defined by manually manipulating the edges in the global schema graph. Kim also uses DAG rearrangement for view schema definition [19].
References-found: 45

