URL: http://www.ri.cmu.edu/afs/cs/project/able/ftp/unification.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/able/www/paper_abstracts/unification.html
Root-URL: 
Email: -ralph,garlan-@cs.cmu.edu  
Phone: Phone: (412) 268-7673 Fax: (412) 268-5576  
Title: Architectural Unification  
Author: Ralph Melton and David Garlan 
Note: Submitted For Publication,  
Date: 31 January 1997  January 1997  
Address: Pittsburgh PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: Many software designs are produced by combining and elaborating existing architectural design fragments. These fragments may be design patterns, partially thought-out ideas, or portions of some previously-developed system design. To provide mechanized support for this activity it is necessary to have a precise characterization of when and how two or more architectural fragments can be combined. In this paper we describe extensions to notations for software architecture to represent incomplete design frag ments, and algorithms for combining fragments in a process analogous to unification in logic.
Abstract-found: 1
Intro-found: 1
Reference: [AG94] <author> Robert Allen and David Garlan. </author> <title> Formalizing architectural connection. </title> <booktitle> In Proceedings of the 16th In ternational Conference on Software Engineering, </booktitle> <pages> pages 7180, </pages> <address> Sorrento, Italy, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: These support reuse of implementations, primarily by page 3 exploiting shared implementation structures for some class or domain of systems. However, unlike our work they are less concerned with general mechanisms for reuse of architectures themselves. Style: Some systems (such as Aesop [GAO94] and Wright <ref> [AG94] </ref>) support the definition of families of architecture that adopt a common set of design constraints - sometimes called an architecture style. For systems within such a family it is often possible to provide (and thereby reuse) specialized analysis tools, code generators, and design guidance.
Reference: [BJ94] <author> Kent Beck and Ralph Johnson. </author> <title> Patterns generate architectures. </title> <booktitle> In Proceedings of ECOOP94, </booktitle> <year> 1994. </year> <note> [BMR + 96] Frank Buschmann, </note> <author> Regine Meunier, Hans Rohnert, Peter Sommerlad, and Michael Stal. </author> <title> Pattern Ori ented Software Architecture: A System of Patterns. </title> <publisher> John Wiley & Sons, </publisher> <year> 1996. </year>
Reference-contexts: One of the central benefits of architectural design is support for design reuse. Many systems are built by combining and elaborating existing architectural design fragments <ref> [BJ94, BMR + 96] </ref>. These fragments may be design patterns, partially thought-out ideas, or portions of some previously-developed system design. Currently the practice of reusing architectural fragments has a weak engineering basis.
Reference: [BO92] <author> Don Batory and Sean OMalley. </author> <title> The design and implementation of hierarchical software systems with page 14 reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(4):355398, </volume> <month> October </month> <year> 1992. </year>
Reference-contexts: Architecture-based Reuse Research in software architecture has focused primarily on two aspects of reuse. Code: A number of systems (such as GenVoca <ref> [BO92] </ref> and UniCon [SDK + 95] provide high-level compil ers for certain classes of software architecture. These support reuse of implementations, primarily by page 3 exploiting shared implementation structures for some class or domain of systems.
Reference: [Bus93] <author> Frank Buschmann. </author> <title> Rational architectures for object-oriented systems. </title> <journal> Journal of Object-Oriented Programming, </journal> <month> September </month> <year> 1993. </year>
Reference: [GAO94] <author> David Garlan, Robert Allen, and John Ockerbloom. </author> <title> Exploiting style in architectural design environments. </title> <booktitle> In Proceedings of SIGSOFT94: The Second ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 179185. </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1994. </year>
Reference-contexts: A number of architectural description languages have been developed, together with tools for manipulating those descriptions, formally analyzing them, and storing reusable architectural elements <ref> [GAO94, MORT96, LAK + + AG94] </ref>. While the ability to formally represent architectural designs is a necessary first step, notations and tools for architectural representation do not by themselves solve the problems of combining architectural design fragments. <p> These support reuse of implementations, primarily by page 3 exploiting shared implementation structures for some class or domain of systems. However, unlike our work they are less concerned with general mechanisms for reuse of architectures themselves. Style: Some systems (such as Aesop <ref> [GAO94] </ref> and Wright [AG94]) support the definition of families of architecture that adopt a common set of design constraints - sometimes called an architecture style. For systems within such a family it is often possible to provide (and thereby reuse) specialized analysis tools, code generators, and design guidance. <p> To complete the architectural design for the system, an actual user interface design must be provided to sat *. For expository purposes, in this example we illustrate only a simplified top-level view. The actual design includes considerably more representational detail, and associated properties. See <ref> [GAO94] </ref> for a detailed description of the system. <p> This arises because many architectural designs are developed in the context of a set of restrictions on how design elements can be used and modified. For example, in the Aesop system <ref> [GAO94] </ref> the Pipe-and-Filter style supplies a component of type filter. A filter is subject to the restriction that it may only have reader ports and writer ports; no other type of port may be added to a filter.
Reference: [GHJV95] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference: [GMW95] <author> David Garlan, Bob Monroe, and David Wile. ACME: </author> <title> An interchange language for software architecture. </title> <type> Technical Report CMU-CS-95-219, </type> <institution> Carnegie Mellon University, </institution> <year> 1995. </year> <note> In preparation. </note>
Reference-contexts: Architectures characterized in terms of this vocabulary are representable in any number of architecture description languages. For concreteness, Appendix 1 shows a textual specification for Figure 1a in the ACME architecture description language <ref> [GMW95] </ref>. However, it is our intent not to focus here on the details of a particular concrete notation; the techniques that we present should be applicable to all architecture description languages that use a similar set of concepts. 5.
Reference: [GP95] <author> David Garlan and Dewayne Perry. </author> <title> Introduction to the special issue on software architecture. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4), </volume> <month> April </month> <year> 1995. </year>
Reference-contexts: 1. Introduction Software architecture is increasingly recognized as an important level of design for software systems. At this design level systems are usually represented as a set of coarse-grained interacting components such as databases, clients, servers, filters, blackboards <ref> [GP95, GS93, PW92] </ref>. Architectural design describes complex systems at a sufficiently high level of abstraction that their conceptual integrity and other key system properties can be clearly understood early in the design cycle. One of the central benefits of architectural design is support for design reuse. <p> We will take as our starting point the structuring concepts more or less uniformly adopted by the software architecture research community. Specifically, in software architecture, designs are typically described in terms of the following generic vocabulary of architectural design elements <ref> [GP95] </ref>: A component is a locus of computation or a data store. (Examples include databases, filters, abstract data types, etc.) A connector is an interaction between two or more components. (Examples include procedure call, event broadcast, pipes, and interactions involving more complex protocols such as a client-server protocol.) A port is
Reference: [GS93] <author> David Garlan and Mary Shaw. </author> <title> An introduction to software architecture. </title> <editor> In V. Ambriola and G. Tortora, editors, </editor> <booktitle> Advances in Software Engineering and Knowledge Engineering, </booktitle> <pages> pages 139, </pages> <address> Sin-gapore, </address> <year> 1993. </year> <title> World Scientific Publishing Company. </title> <note> Also appears as SCS and SEI technical reports: CMU-CS-94-166, CMU/SEI-94-TR-21, ESC-TR-94-021. </note>
Reference-contexts: 1. Introduction Software architecture is increasingly recognized as an important level of design for software systems. At this design level systems are usually represented as a set of coarse-grained interacting components such as databases, clients, servers, filters, blackboards <ref> [GP95, GS93, PW92] </ref>. Architectural design describes complex systems at a sufficiently high level of abstraction that their conceptual integrity and other key system properties can be clearly understood early in the design cycle. One of the central benefits of architectural design is support for design reuse.
Reference: [Kay79] <author> Martin Kay. </author> <title> Functional grammar. </title> <booktitle> In 5th Annual Meeting of the Berkeley Linguistic Society, </booktitle> <year> 1979. </year>
Reference-contexts: For our first adaptation of the canonical unification algorithm, we adopt the approach of using unification over feature structures, as introduced in <ref> [Kay79] </ref>. Instead of using function applications and their positional arguments to structure terms, feature structures identify substructures by symbolic names. Feature structures are thus similar to attribute-value lists.
Reference: [Kni89] <author> Kevin Knight. </author> <title> Unification: A multidisciplinary survey. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(1):93124, </volume> <month> March </month> <year> 1989. </year> <note> [LAK + 95] David C Luckham, </note> <author> Lary M. Augustin, John J. Kenney, James Veera, Doug Bryan, and Walter Mann. </author> <title> Specification and analysis of system architecture using Rapide. </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Software Architecture, </journal> <volume> 21(4):336355, </volume> <month> April </month> <year> 1995. </year>
Reference-contexts: Our work complements this by looking at formal representation schemes and algorithms for deciding whether the use of a pattern is valid in a given context. 2.3. Unification Unification in logic has been an area of formal study for many years <ref> [Kni89] </ref>. In this paper we build on those results, extending and adapting them where necessary to fit the problems at hand. Our research is not intended to make novel contributions to this area, but rather to adapt what already exists to the domain software architecture. 3. <p> The term that matches both descriptions is obtained by applying the resulting substitution to either of the original arguments. 7. Architectural Unification Unification solves the following problem: Given two descriptions x and y, can we find an object z that fits both descriptions? <ref> [Kni89] </ref>. As noted above, in the domain of logic these descriptions are expressions that may contain variables. We can apply this idea to software architecture; corresponding to expressions and variables in logic are architectural descriptions and placeholder elements (respectively). <p> The following algorithm is based on the approach described in <ref> [Kni89] </ref>.
Reference: [MG96] <author> Robert T. Monroe and David Garlan. </author> <title> Style-based reuse for software architectures. </title> <booktitle> In Proceedings of the Fourth International Conference on Software Reuse, </booktitle> <month> April </month> <year> 1996. </year>
Reference-contexts: To attempt to unify two elements, the user drags one element over another element of the same architectural type, and the system automatically attempts to unify them, or reports that they cannot be unified. Fragments can be stored in the reuse repository <ref> [MG96] </ref>, where they may be retrieved and unified with other fragments or an existing design. The Aesop system also provides by default many of the feature-specific unification hooks that were discussed in Section 7.3. In particular, it provides built in resolution for element names, ports, roles and representations.
Reference: [MORT96] <author> Nenad Medvidovic, Peyman Oreizy, Jason E. Robbins, and Richard N. Taylor. </author> <title> Using object-oriented typing to support architectural design in the C2 style. </title> <booktitle> In SIGSOFT96: Proceedings of the Fourth ACM Symposium on the Foundations of Software Engineering. </booktitle> <publisher> ACM Press, </publisher> <month> October </month> <year> 1996. </year>
Reference-contexts: A number of architectural description languages have been developed, together with tools for manipulating those descriptions, formally analyzing them, and storing reusable architectural elements <ref> [GAO94, MORT96, LAK + + AG94] </ref>. While the ability to formally represent architectural designs is a necessary first step, notations and tools for architectural representation do not by themselves solve the problems of combining architectural design fragments.
Reference: [MQR95] <author> M. Moriconi, X. Qian, and R. Riemenschneider. </author> <title> Correct architecture refinement. </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Software Architecture, </journal> <volume> 21(4):356372, </volume> <month> April </month> <year> 1995. </year>
Reference: [PW92] <author> Dewayne E. Perry and Alexander L. Wolf. </author> <title> Foundations for the study of software architecture. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <address> 17(4):4052, </address> <month> October </month> <year> 1992. </year> <note> [SDK + 95] Mary Shaw, </note> <author> Robert DeLine, Daniel V. Klein, Theodore L. Ross, David M. Young, and Gregory Ze-lesnik. </author> <title> Abstractions for software architecture and tools to support them. </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Software Architecture, </journal> <volume> 21(4):314335, </volume> <month> April </month> <year> 1995. </year> <pages> page 15 </pages>
Reference-contexts: 1. Introduction Software architecture is increasingly recognized as an important level of design for software systems. At this design level systems are usually represented as a set of coarse-grained interacting components such as databases, clients, servers, filters, blackboards <ref> [GP95, GS93, PW92] </ref>. Architectural design describes complex systems at a sufficiently high level of abstraction that their conceptual integrity and other key system properties can be clearly understood early in the design cycle. One of the central benefits of architectural design is support for design reuse.
References-found: 15

