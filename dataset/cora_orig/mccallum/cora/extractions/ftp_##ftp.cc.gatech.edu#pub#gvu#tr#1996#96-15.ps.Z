URL: ftp://ftp.cc.gatech.edu/pub/gvu/tr/1996/96-15.ps.Z
Refering-URL: http://www.cs.gatech.edu/gvu/reports/1996/
Root-URL: 
Email: fdfj,staskog@cc.gatech.edu tball@research.att.com  
Title: Visualizing Message Patterns in Object-Oriented Program Executions  
Author: Dean F. Jerding John T. Stasko and Thomas Ball 
Keyword: software visualization, object-oriented programs, program understanding, software reengineering  
Address: Atlanta, GA 30332-0280 Naperville, IL 60566  
Affiliation: 1 Graphics, Visualization, and Usability Center 2 Software Production Research Georgia Institute of Technology Bell Laboratories  
Abstract: Technical Report GIT-GVU-96-15 May 1996 Abstract The dynamic behavior of object-oriented programs is difficult to design, implement, and modify. Understanding the interactions between classes and objects is necessary to create efficient designs and make safe modifications. This work seeks to identify, visualize, and analyze recurring message patterns in object-oriented program executions as a means for understanding and examining dynamic behavior. Our visualizations focus on supporting design recovery, validation, and reengineering tasks. 
Abstract-found: 1
Intro-found: 1
Reference: [AIS + 77] <author> Christopher Alexander, Sara Ishikawa, Murray Silverstein, Max Jacobson, and Ingrid Fiksdahl-King. </author> <title> A Pattern Language. </title> <publisher> Oxford University Press, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: third section describes related work, and the last section discusses the impact and future work. 1 To meet this need, several research efforts have investigated language support for associations [Kri94, DBFPD95]. 2 Note that our use of the word "pattern" is different than that of design patterns or pattern languages <ref> [AIS + 77, GHJV95, CS95] </ref>, yet the two are related. <p> Some of the more recent efforts in these areas are mentioned here and related to our work. The notion of a pattern as a solution to a problem in a particular context provides a literary form through which experience with software can be documented to be reused by others <ref> [AIS + 77, GHJV95, CS95] </ref>. Patterns in the software domain range across many levels of abstraction, from the organization, to the design, architecture, implementation, and programming language.
Reference: [BH90] <author> Heinz-Dieter Bocker and Jurgen Herczeg. </author> <title> What tracers are made of. </title> <booktitle> In Proceedings of the ECOOP/OOPSLA '90 Conference, </booktitle> <pages> pages 89-99, </pages> <address> Ottawa, Ontario, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: Furthermore, there is a data explosion problem: finding interesting information from the mass of data in the trace is not easy. Some trace-based tools animate the call graph to show the trace on the fly (without storing it) <ref> [BH90] </ref>, or compute statistical summary information from the trace [DPKV94]. Both of these techniques deal with the space problem by ignoring or summarizing a large amount of dynamic information, as is done with the call graph. tation of the call tree from Fig ure 4b.
Reference: [CAB + 94] <author> D. Coleman, P. Arnold, S. Bodoff, C. Dollin, H. Gilchrist, F. Hayes, and P. Jeremaes. </author> <title> Object-Oriented Development: The Fusion Method. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1994. </year>
Reference-contexts: Not only is it difficult to design these dynamic relationships, standard languages do not provide implementation support for interactions as first-class entities. 1 The communication dialog between classes and objects is typically designed using graphical notations such as event trace diagrams or interaction diagrams <ref> [RBP + 91, CAB + 94] </ref>. Depending on the size and complexity of the system being developed, these design documents may be used sparingly or often. Under-utilization of these development techniques may occur because it is difficult to map these diagrams into the implementation.
Reference: [CS95] <author> James O. Coplien and Douglas C. Schmidt, </author> <title> editors. Pattern Languages of Program Design. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: third section describes related work, and the last section discusses the impact and future work. 1 To meet this need, several research efforts have investigated language support for associations [Kri94, DBFPD95]. 2 Note that our use of the word "pattern" is different than that of design patterns or pattern languages <ref> [AIS + 77, GHJV95, CS95] </ref>, yet the two are related. <p> Some of the more recent efforts in these areas are mentioned here and related to our work. The notion of a pattern as a solution to a problem in a particular context provides a literary form through which experience with software can be documented to be reused by others <ref> [AIS + 77, GHJV95, CS95] </ref>. Patterns in the software domain range across many levels of abstraction, from the organization, to the design, architecture, implementation, and programming language.
Reference: [DBFPD95] <author> S. Ducasse, M. Blay-Fornarino, and A. M. Pinna-Dery. </author> <title> A reflective model for first class dependencies. </title> <booktitle> In Proceedings of ACM OOPSLA '95, </booktitle> <pages> pages 265-280, </pages> <year> 1995. </year>
Reference-contexts: Section 2 describes visualizations we have created, how message patterns are identified, and an example usage scenario. The third section describes related work, and the last section discusses the impact and future work. 1 To meet this need, several research efforts have investigated language support for associations <ref> [Kri94, DBFPD95] </ref>. 2 Note that our use of the word "pattern" is different than that of design patterns or pattern languages [AIS + 77, GHJV95, CS95], yet the two are related.
Reference: [Dev92] <author> P. Devanbu. </author> <title> A language and front-end independent code analyzer. </title> <booktitle> In Proceedings of the International Conference on Software Engineering, </booktitle> <address> Australia, </address> <month> May </month> <year> 1992. </year>
Reference: [DPHKV93] <author> Wim De Pauw, Richard Helm, Doug Kimelman, and John Vlissides. </author> <title> Visualizing the behavior of object-oriented systems. </title> <booktitle> In Proceedings of the ACM OOPSLA '93 Conference, </booktitle> <pages> pages 326-37, </pages> <address> Washington, D.C., </address> <month> October </month> <year> 1993. </year>
Reference-contexts: Thus, we chose to focus on views that showed the progression of time inherently as one of the dimensions. We also narrowed our focus to the sequence of object interactions, while others published work focused on cumulative dynamics <ref> [DPHKV93, DPKV94] </ref>. Scalability became the number one issue in creating useful visualizations to aid the understanding processes during implementation and maintenance of real-world sized systems. The Execution Mural view of Figures 2 - 3 shows a class level event trace diagram of a particular program execution. <p> HotWired is a visual debugger for C++ and Smalltalk that provides both standard object views and a scripting language to create simple program visualizations [LM94]. Views show instances of classes (similar to <ref> [DPHKV93] </ref>), message passing between individual instances, and instance attribute values. It is possible to "record" particular message traces to be replayed. Their recording strip view shows instance activation over time, and could benefit from our Information Mural technique. <p> Because these scripts must be manually written, this facility seems most useful for situations that recur often, such as explaining some program behavior. Debugging tasks are usually performed once or repeated until the problem is solved. De Pauw, Helm, Kimelman, and Vlissides <ref> [DPHKV93, DPKV94] </ref> have developed visualization techniques and a tool for presenting attributes of object-oriented systems, more specifically, C++ programs. The authors use portable instrumentation techniques to extract the required information about a program's execution. They also developed views, most of which are chart-like, that present summary information about the execution.
Reference: [DPKV94] <author> Wim De Pauw, Doug Kimelman, and John Vlissides. </author> <title> Modeling object-oriented program execution. </title> <booktitle> In Proceedings of the European Conference on Object-Oriented Programming `94, </booktitle> <year> 1994. </year>
Reference-contexts: Thus, we chose to focus on views that showed the progression of time inherently as one of the dimensions. We also narrowed our focus to the sequence of object interactions, while others published work focused on cumulative dynamics <ref> [DPHKV93, DPKV94] </ref>. Scalability became the number one issue in creating useful visualizations to aid the understanding processes during implementation and maintenance of real-world sized systems. The Execution Mural view of Figures 2 - 3 shows a class level event trace diagram of a particular program execution. <p> Furthermore, there is a data explosion problem: finding interesting information from the mass of data in the trace is not easy. Some trace-based tools animate the call graph to show the trace on the fly (without storing it) [BH90], or compute statistical summary information from the trace <ref> [DPKV94] </ref>. Both of these techniques deal with the space problem by ignoring or summarizing a large amount of dynamic information, as is done with the call graph. tation of the call tree from Fig ure 4b. <p> Because these scripts must be manually written, this facility seems most useful for situations that recur often, such as explaining some program behavior. Debugging tasks are usually performed once or repeated until the problem is solved. De Pauw, Helm, Kimelman, and Vlissides <ref> [DPHKV93, DPKV94] </ref> have developed visualization techniques and a tool for presenting attributes of object-oriented systems, more specifically, C++ programs. The authors use portable instrumentation techniques to extract the required information about a program's execution. They also developed views, most of which are chart-like, that present summary information about the execution.
Reference: [GHJV95] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Pattterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: third section describes related work, and the last section discusses the impact and future work. 1 To meet this need, several research efforts have investigated language support for associations [Kri94, DBFPD95]. 2 Note that our use of the word "pattern" is different than that of design patterns or pattern languages <ref> [AIS + 77, GHJV95, CS95] </ref>, yet the two are related. <p> The prototype allows us to create views of a particular program execution based on static information about the program and a trace file of interesting events (function calls and returns). The views are Observers <ref> [GHJV95] </ref> of a single program model which contains both static and dynamic information, and they co-exist in a single Viewspace window which acts as a Controller [Gol83] to handle user input. A Composite [GHJV95] class hierarchy defines views as visual objects themselves. 6 Interaction occurs through pointing and using pop-up menus <p> The views are Observers <ref> [GHJV95] </ref> of a single program model which contains both static and dynamic information, and they co-exist in a single Viewspace window which acts as a Controller [Gol83] to handle user input. A Composite [GHJV95] class hierarchy defines views as visual objects themselves. 6 Interaction occurs through pointing and using pop-up menus which are associated with the various views. Usage Scenario. Here we use our tool to examine the Polka program animation toolkit mentioned in Section 2.1. <p> Some of the more recent efforts in these areas are mentioned here and related to our work. The notion of a pattern as a solution to a problem in a particular context provides a literary form through which experience with software can be documented to be reused by others <ref> [AIS + 77, GHJV95, CS95] </ref>. Patterns in the software domain range across many levels of abstraction, from the organization, to the design, architecture, implementation, and programming language.
Reference: [GKM83] <author> S. L. Graham, P. B. Kessler, and M. K. McKusick. </author> <title> An execution profiler for modular programs. </title> <journal> Software Practice and Experience, </journal> <volume> 13 </volume> <pages> 671-685, </pages> <year> 1983. </year>
Reference-contexts: Such problems manifest themselves in a number of software tools that use the call graph to summarize dynamic program properties. For example, the inaccuracy of program profilers such as gprof <ref> [GKM83] </ref> and qpt [LB92] can be traced to their use of the call graph to summarize context-dependent profile information in a context-independent manner.
Reference: [Gol83] <author> Adele Goldberg. </author> <title> Smalltalk-80, The Interactive Programming Environment. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, PA, </address> <year> 1983. </year>
Reference-contexts: The views are Observers [GHJV95] of a single program model which contains both static and dynamic information, and they co-exist in a single Viewspace window which acts as a Controller <ref> [Gol83] </ref> to handle user input. A Composite [GHJV95] class hierarchy defines views as visual objects themselves. 6 Interaction occurs through pointing and using pop-up menus which are associated with the various views. Usage Scenario. Here we use our tool to examine the Polka program animation toolkit mentioned in Section 2.1.
Reference: [JS94] <author> Dean F. Jerding and John T. Stasko. </author> <title> Using visualization to foster object-oriented program understanding. </title> <type> Technical Report GIT-GVU-94-33, </type> <institution> Georgia Institute of Technology, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: The visualization was based on trace files generated from C++ source code annotated by hand. Only small, toy programs were visualized. The next generation of visualization used multiple views to show the call stack, inheritance hierarchy, instances, and message passing <ref> [JS94] </ref>.
Reference: [JS95a] <author> Dean F. Jerding and John T. Stasko. </author> <title> The Information Mural: A technique for displaying and navigating large information spaces. </title> <booktitle> In Proceedings of the IEEE Visualization `95 Symposium on Information Visualization, </booktitle> <pages> pages 43-50, </pages> <address> Atlanta, GA, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: The technique utilizes grayscale and color shading along with anti-aliasing techniques to create a miniature representation of an entire large information space. Such a view is called an Information Mural; the technique is described in <ref> [JS95a, JS95b] </ref>. What these message "murals" have allowed us to do is notice visual patterns in entire message traces, and then lower-level patterns as we zoom in on sub-sequences of the execution. <p> are different from the previous generation described in Section 2.1; they have been rotated to look more like interaction diagrams, with the 40 classes in the program on the horizontal axis and the almost 64,000 messages drawn as horizontal lines down the vertical axis using the Information Mural compression technique <ref> [JS95a] </ref>. Areas that are brighter in the mural are more dense with information, conveying the same visual patterns that would be apparent if a huge event trace diagram of the entire program was observed from a distance.
Reference: [JS95b] <author> Dean F. Jerding and John T. Stasko. </author> <title> Using Information Murals in visualization applications. </title> <booktitle> In Proceedings of the 1995 Symposium on User Interface Software and Technology (Demonstration), </booktitle> <pages> pages 73-74, </pages> <address> Pittsburgh, PA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: The technique utilizes grayscale and color shading along with anti-aliasing techniques to create a miniature representation of an entire large information space. Such a view is called an Information Mural; the technique is described in <ref> [JS95a, JS95b] </ref>. What these message "murals" have allowed us to do is notice visual patterns in entire message traces, and then lower-level patterns as we zoom in on sub-sequences of the execution.
Reference: [Kri94] <author> Bent Bruun Kristensen. </author> <title> Complex associations: Abstractions in object-oriented modeling. </title> <booktitle> In Proceedings of ACM OOPSLA '94, </booktitle> <pages> pages 272-283, </pages> <address> Portland, OR, </address> <month> Oct </month> <year> 1994. </year> <month> 15 </month>
Reference-contexts: Section 2 describes visualizations we have created, how message patterns are identified, and an example usage scenario. The third section describes related work, and the last section discusses the impact and future work. 1 To meet this need, several research efforts have investigated language support for associations <ref> [Kri94, DBFPD95] </ref>. 2 Note that our use of the word "pattern" is different than that of design patterns or pattern languages [AIS + 77, GHJV95, CS95], yet the two are related.
Reference: [LB92] <author> James R. Larus and Thomas Ball. </author> <title> Rewriting executable files to measure program behavior. </title> <type> Technical Report Computer Sciences Technical Report 1083, </type> <institution> University of Wisconsin-Madison, </institution> <year> 1992. </year>
Reference-contexts: Such problems manifest themselves in a number of software tools that use the call graph to summarize dynamic program properties. For example, the inaccuracy of program profilers such as gprof [GKM83] and qpt <ref> [LB92] </ref> can be traced to their use of the call graph to summarize context-dependent profile information in a context-independent manner.
Reference: [LC94] <author> Panagiotis K. Linos and Vincent Courtois. </author> <title> A tool for understanding object-oriented program dependencies. </title> <booktitle> In Proceedings of the Workshop on Program Comprehension, </booktitle> <pages> pages 20-27, </pages> <month> Nov </month> <year> 1994. </year>
Reference-contexts: The authors made this compromise when they decided not to store incremental information about the execution in favor of storing more cumulative information. Thus, the actual message trace cannot be reconstructed based on their database. The OO!CARE tool is the C++ version of the CARE program understanding environment <ref> [LC94] </ref>. The idea of the OO!CARE system is to extract and visualize dependencies between classes, objects, and methods in the program, as well as the control and data flow. The system includes a code analyzer, a dependencies database, and a display manager.
Reference: [LM94] <author> Chris Laffra and Ashok Malhotra. </author> <title> Hotwire a visual debugger for C++. </title> <booktitle> In Proceedings of the USENIX 6th C++ Technical Conference, </booktitle> <month> April </month> <year> 1994. </year>
Reference-contexts: Again, though, it seems that the user must know the pattern and have an idea where that pattern occurs to exploit the visualizations. HotWired is a visual debugger for C++ and Smalltalk that provides both standard object views and a scripting language to create simple program visualizations <ref> [LM94] </ref>. Views show instances of classes (similar to [DPHKV93]), message passing between individual instances, and instance attribute values. It is possible to "record" particular message traces to be replayed. Their recording strip view shows instance activation over time, and could benefit from our Information Mural technique.
Reference: [LN95a] <author> Danny B. Lange and Yuichi Nakamura. </author> <title> Interactive visualization of design patterns can help in framework understanding. </title> <booktitle> In Proceedings of ACM OOPSLA '95, </booktitle> <pages> pages 342-357, </pages> <year> 1995. </year>
Reference-contexts: In this way, identifying 12 message patterns can be seen as a form of "pattern mining." The Program Explorer <ref> [LN95b, LN95a] </ref> is a C++ program understanding tool that is focused on class and object centered views. The authors have developed a robust, class-wise tracing system for tracking function invocation, object instantiation, and attribute access. <p> It seems that the system is designed to execute the program for a while, and then focus on particular classes or objects. It's not intended as a global understanding tool, so the user must know what (or where in the execution) they are interested in beforehand. In <ref> [LN95a] </ref> examples of using the system to uncover design patterns in real-world sized systems are given. Again, though, it seems that the user must know the pattern and have an idea where that pattern occurs to exploit the visualizations.
Reference: [LN95b] <author> Danny B. Lange and Yuichi Nakamura. </author> <title> Program Explorer: A program visualizer for C++. </title> <booktitle> In Proceedings of the USENIX Conference on Object-Oriented Technologies, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: In this way, identifying 12 message patterns can be seen as a form of "pattern mining." The Program Explorer <ref> [LN95b, LN95a] </ref> is a C++ program understanding tool that is focused on class and object centered views. The authors have developed a robust, class-wise tracing system for tracking function invocation, object instantiation, and attribute access.
Reference: [MCL95] <author> Ruth Malan, Derek Coleman, and Reed Letsinger. </author> <title> Lessons from the experiences of leading-edge object technology projects in Hewlett-Packard. </title> <booktitle> In Proceedings of ACM OOPSLA '95, </booktitle> <pages> pages 33-46, </pages> <year> 1995. </year>
Reference-contexts: A CASE tool with such a feature could help keep dynamic models up to date with respect to modifications of the implementation, a common problem in practice <ref> [MCL95] </ref>. Providing the capability for interatively creating interaction diagrams and other pattern views will also give the user a means for constructing a model of behavior for an unfamiliar design.
Reference: [MNS95] <author> Gail C. Murphy, David Notkin, and Kevin Sullivan. </author> <title> Software Reflexion Models: Bridging the gap between source and high-level models. </title> <booktitle> In Proceedings of the Foundations of Software Engineering, page ??, 1995. </booktitle>
Reference-contexts: Murphy, et al. have developed an approach that allows software engineers specify high-level 13 models of a system and how the source code maps into that model <ref> [MNS95] </ref>. Then a reflexion model is computed which uses call graph and data referencing information to determine where the model agrees and disagrees with the actual implementation. A box-and-arrow type diagram is used to depict the specified models and their differences.
Reference: [Moh88] <author> Thomas G. Moher. </author> <title> PROVIDE: A process visualization and debugging environment. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(6) </volume> <pages> 849-57, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Extracting the call trace may incur high run-time overhead and storing the trace may not be feasible for long running programs <ref> [Moh88] </ref>. Furthermore, there is a data explosion problem: finding interesting information from the mass of data in the trace is not easy. Some trace-based tools animate the call graph to show the trace on the fly (without storing it) [BH90], or compute statistical summary information from the trace [DPKV94].
Reference: [O'R88] <author> Marign J. O'Riordan. </author> <title> Debugging and instrumentation of c++ programs. </title> <booktitle> In Proceedings of the USENIX C++ Conference, </booktitle> <pages> pages 227-242, </pages> <address> Denver, CO, </address> <month> Oct </month> <year> 1988. </year>
Reference-contexts: The information used to create these views was obtained from a static analysis of the source code using gen++[Dev92] and a trace file produced from source which was automatically annotated by a Perl script which places tracing objects in the code as described by O'Riordan <ref> [O'R88] </ref>. The major visual innovation in the Execution Mural is the ability to create a global overview of a message trace containing hundreds of thousands of messages. The technique utilizes grayscale and color shading along with anti-aliasing techniques to create a miniature representation of an entire large information space.
Reference: [RBP + 91] <author> James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, and William Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> New York, NY, </address> <year> 1991. </year>
Reference-contexts: Not only is it difficult to design these dynamic relationships, standard languages do not provide implementation support for interactions as first-class entities. 1 The communication dialog between classes and objects is typically designed using graphical notations such as event trace diagrams or interaction diagrams <ref> [RBP + 91, CAB + 94] </ref>. Depending on the size and complexity of the system being developed, these design documents may be used sparingly or often. Under-utilization of these development techniques may occur because it is difficult to map these diagrams into the implementation.
Reference: [RCM + 94] <author> Scott P. Robertson, John M. Carroll, Robert L. Mack, Mary Beth Rosson, Sherman R. Alpert, and Jurgen Koenemann-Belliveau. </author> <title> ODE: A self-guided, scenario-based learning environment for object-oriented design principles. </title> <booktitle> In Proceedings of ACM OOPSLA '94, </booktitle> <pages> pages 51-64, </pages> <address> Portland, OR, </address> <month> Oct </month> <year> 1994. </year>
Reference-contexts: Due to the power and complexity of the OO paradigm, many efforts have developed to teach OO design and programming. While most of these efforts are lecture-driven courses, Robertson, et. al., have designed an interactive, scenario-based learning environment to teach OO principles <ref> [RCM + 94] </ref>. Users of the system are guided through the OO design process by analyzing scenarios for a given problem domain. The goal is to develop an object model based on the dynamic scenarios. <p> Additionally, being able to visualize dynamic interactions is useful as a means for uncovering inefficient designs or implementations, and can be used help teach good OO design practices, as proposed by <ref> [RCM + 94] </ref>.
Reference: [SK93] <author> John T. Stasko and Eileen Kraemer. </author> <title> A methodology for building application-specific visualizations of parallel programs. </title> <journal> Journal of Parallel and Distributed Computing, </journal> <volume> 18(2) </volume> <pages> 258-264, </pages> <month> June </month> <year> 1993. </year> <month> 16 </month>
Reference-contexts: Note that both function invocations and function returns are treated as messages. Sample Execution Murals from a Polka <ref> [SK93] </ref> 3 bubble-sort algorithm animation are shown in Figures 2 and 3.
References-found: 27

