URL: http://www.dfki.uni-kl.de/~vega/relfun+/semanticsb.ps
Refering-URL: http://www.dfki.uni-kl.de/~vega/relfun.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: boley@informatik.uni-kl.de  
Title: A Direct Semantic Characterization of RELFUN  
Author: Harold Boley 
Date: March 25, 1998  
Address: Box 2080, 67608 Kaiserslautern, Germany  
Affiliation: Deutsches Forschungszentrum fur Kunstliche Intelligenz  
Abstract: This is an attempt at a direct semantic formalization of first-order relational-functional languages (the characteristic RELFUN subset) in terms of a generalized model concept. Function-defining conditional equations (or, footed clauses) and active call-by-value expressions (in clause premises) are integrated into first-order theories. Herbrand models are accomodated to relational-functional programs by not only containing ground atoms but also ground molecules, i.e. specific function applications paired with values. Extending SLD-resolution toward innermost conditional narrowing of relational-functional clauses, SLV-resolution is introduced, which, e.g., flattens active expressions. The T P -operator is generalized analogously, e.g. by unnesting ground-clause premises. Soundness and completeness proofs for SLV-resolution naturally extend the corresponding results in logic programming. 
Abstract-found: 1
Intro-found: 1
Reference: [BGM88] <author> P.G. Bosco, E. Giovannetti, and C. Moiso. </author> <title> Narrowing vs. </title> <journal> SLD-resolution. Theoretical Computer Science, </journal> <volume> 59 </volume> <pages> 3-23, </pages> <year> 1988. </year>
Reference-contexts: But it also simplifies transferring foundation theorems of logic programming (as found, e.g., in J. W. Lloyd's book) to eager, non-ground, non-deterministic first-order functional programming and to unified relational-functional programming. It is thus attempted to complement the `function-translating' characterization of innermost narrowing in <ref> [BGM88] </ref> by a `function-modeling' characterization. Since our model notion reflects call-by-value flattening, also our notion of completeness will differ from the general one in [Han94], as illustrated by example 9.
Reference: [BL86] <author> M. Bellia and G. Levi. </author> <title> The relation between logic and functional languages: A survey. </title> <journal> Journal of Logic Programming, </journal> <volume> 3 </volume> <pages> 217-236, </pages> <year> 1986. </year>
Reference-contexts: functional call-by-value expressions enrich (and complicate) the semantics of relational languages?" or "How will the relational meaning of non-ground arguments carry over to the functional meaning of arguments and returned values?" Another important 3 motivation of the present work is to make the many alternative relational-functional integra-tion proposals (see, e.g., <ref> [BL86] </ref> and [DL86]) comparable on a common ground, revealing their deeper, non-syntactic differences.
Reference: [Bol90] <author> Harold Boley. </author> <title> A relational/functional language and its compilation into the WAM. </title> <type> Technical Report SEKI SR-90-05, </type> <institution> University of Kaiserslautern, Department of Computer Science, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: ; . . . ; unnest P (V n ) * ; unnest P (t .= E) * & t. ("f:::g * " denotes the sequence of elements of "f...g".) The corresponding non-ground clause can be obtained by transforming the original program P via static flattening and denotative normalization (see <ref> [Bol90] </ref>). Therefore, each application of T C P can be regarded as a condensed form of the application of a less powerful operator indexed by the more lengthy transformed program (T P 's extension would be confined to clauses with atomic and flat-setter bodies and term foots).
Reference: [Bol92] <author> Harold Boley. </author> <title> Extended Logic-plus-Functional Programming. </title> <booktitle> In Workshop on Extensions of Logic Programming, </booktitle> <address> ELP '91, Stockholm1991, </address> <publisher> LNAI. Springer, </publisher> <year> 1992. </year>
Reference-contexts: A comprehensive overview of RELFUN and related work as well as pointers to its applications and to its original operational (interpretative), LISP-implemented semantics can be found in <ref> [Bol92] </ref>. Among the tools of the RELFUN implementation there is a term-rewriting algorithm relationalize for transforming footed and hornish clauses into Horn clauses, thus indirectly characterizing their model-theoretic semantics. <p> Then, these will be restricted to Herbrand-like interpretations of RELFUN's clause programs. Since the kernel RELFUN formalized here does not contain a negation construct, we will neglect RELFUN's three-valued open-world semantics and its differentiation of the truth values false and unknown (see <ref> [Bol92] </ref>). Definition 11 A pre-interpretation J of a first-order relational-functional language L consists of: 1. A non-empty set D, called the domain of the pre-interpretation. 2. For each constant in L, the assignment of an element in D. 3. <p> While the above bijection, call it b LAST , introduces the new parameter in position n + 1, there is another bijection, b F IRST , introducing it in position 1, as actually done by RELFUN's relationalize algorithm (see <ref> [Bol92] </ref>). <p> :& psif (a). omegaf () :& chif (psif (a)). 12 The binding 7 = fX1=ag from the relational subderivation G 2 ; . . . ; G 15 is applied here. 13 In higher-order RELFUN, this can be obtained from the computed answers of an operator-variable, varying arity goal (see <ref> [Bol92] </ref>) such as :& Op (jArgs). 19 5 Soundness of SLV-Resolution While the following result addresses relational goals, only the first of the five SLV-resolution rules to be considered corresponds to the classical case of logic programming as proved by K. L. Clark.
Reference: [Bol94] <author> Harold Boley. </author> <title> Finite Domains and Exclusions as First-Class Citizens. </title> <editor> In Roy Dyckhoff, editor, </editor> <booktitle> Proceedings of the 4th International Workshop on Extensions of Logic Programming, </booktitle> <address> ELP '93, St. Andrews, Scotland, </address> <year> 1993, </year> <title> volume 798 of LNAI. </title> <publisher> Springer, </publisher> <year> 1994. </year>
Reference-contexts: H. D. Warren [War82]. While these two extensions have long existed in the implemented RELFUN system, further extensions such as finite domains and, particularly, finite exclusions (see <ref> [Bol94] </ref>) will first require their own operational test phase before we can think of including them in the formal semantics. Finally, some aspects of our RELFUN extensions of SLD-resolution, Herbrand models, and T P -operators will probably be transferable to other languages.
Reference: [Bol96] <author> Harold Boley. </author> <title> Functional-Logic Integration via Minimal Extensions. </title> <editor> In Silvia Breitinger, Henner Kroger, and Rita Loogen, editors, </editor> <booktitle> Proceedings of the 5th International Workshop on Functional and Logic Programming, </booktitle> <address> Rauischholzhausen, Germany. Philipps-Univ. </address> <institution> Marburg and Justus-Liebig Univ. Giessen, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: Other, not integration-relevant but uniformity-preserving extensions such as finite domains are relegated to outer RELFUN shells. Both relational essentials, non-ground, non-deterministic operators (R1, R2), and one of the functional essentials, application values (F1), of <ref> [Bol96] </ref> are semantically incorporated into the kernel. The other functional essential, higher-order operators (F2), is incorporated only syntactically.
Reference: [Der95] <author> Nachum Dershowitz. </author> <title> Goal Solving as Operational Semantics. </title> <editor> In John Lloyd, editor, </editor> <booktitle> Proceedings of the International Symposium on Logic Programming, </booktitle> <pages> pages 3-17, </pages> <address> Cambridge, December 1995. </address> <publisher> MIT Press. </publisher>
Reference-contexts: But our RELFUN experience suggests that the simpler eager evaluation strategy may be superior in practice. Presumed advantages of laziness may turn out to be reproducible eagerly, as in the proposal to replace lazy streams by free length-counting logic variables <ref> [Der95] </ref>. This issue should be further studied by systematically comparing eager and lazy versions of declarative programs. Another open discussion is deterministic vs. non-deterministic functions.
Reference: [DL86] <editor> D. DeGroot and G. Lindstrom, editors. </editor> <title> Logic Programming: Functions, Relations, and Equations. </title> <publisher> Prentice-Hall, </publisher> <year> 1986. </year>
Reference-contexts: expressions enrich (and complicate) the semantics of relational languages?" or "How will the relational meaning of non-ground arguments carry over to the functional meaning of arguments and returned values?" Another important 3 motivation of the present work is to make the many alternative relational-functional integra-tion proposals (see, e.g., [BL86] and <ref> [DL86] </ref>) comparable on a common ground, revealing their deeper, non-syntactic differences.
Reference: [Fri84] <author> Laurent Fribourg. </author> <title> Oriented equational clauses as a programming language. </title> <journal> J. Logic Programming, </journal> <volume> 1(2) </volume> <pages> 165-177, </pages> <year> 1984. </year>
Reference-contexts: Simultaneously, the underlying Herbrand (base) models, containing ground atoms (flat relationships), are extended to Herbrand cross models, containing ground molecules (flat function applications asymmetrically ":&"-paired with terms). Instead of all ground term equations in the Herbrand base for models of logics with (e.g., symmetry-axiomatized) equality <ref> [Fri84] </ref>, the Herbrand base for cross models thus contains all ground `innermost' defined-function applications associated with all ground terms, denoting their ultimate computation values (just as the usual Herbrand base contains all ground relation applications, denoting their ultimate truth).
Reference: [Fri85] <author> Laurent Fribourg. SLOG: </author> <title> A logic programming language interpreter based on clausal superposition and rewriting. </title> <booktitle> In 1985 Symposium on Logic Programming, </booktitle> <pages> pages 172-184. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1985. </year>
Reference-contexts: The extended resolution method, similar to innermost conditional narrowing <ref> [Fri85] </ref>, will be called SLV-resolution (SL-resolution for "Valued clauses" i.e., RELFUN's definite-clause extension). It provides the set of inference rules of a first-order relational-functional theory; their application conditions specify a partial derivation order. The detailed example 8 at the end of this section will illustrate most SLV-resolution concepts.
Reference: [GLMP91] <author> E. Giovannetti, G. Levi, C. Moiso, and C. Palamidessi. Kernel-LEAF: </author> <title> A logic plus functional language. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 42 </volume> <pages> 139-185, </pages> <year> 1991. </year>
Reference-contexts: These semantic extensions are less complicated than the semantics of lazy expressions (outermost reduction) as a relational-functional integration concept, as introduced by other recent proposals (e.g., K-LEAF <ref> [GLMP91] </ref> and BABEL [MNRA92]): eagerness keeps the semantics strict and simple, whereas laziness accepts the non-strictness overhead to give a meaning to unifications involving non-terminating expressions.
Reference: [GMHGRA97] <author> J.C. Gonzalez-Moreno, M.T. Hortala-Gonzalez, and M. Rodrguez-Artalejo. </author> <title> A Higher Order Rewriting Logic for Functional Logic Programming. </title> <booktitle> In The Fourteenth International Conference on Logic Programming, </booktitle> <address> ICLP'97. </address>
Reference-contexts: The other functional essential, higher-order operators (F2), is incorporated only syntactically. While this considerably simplified the model theory, there remains the challenge of adapting Henkin models [Llo94], Hoare powerdomains <ref> [GMHGRA97] </ref>, or some other higher-order semantics for the first-order relational-functional essentials (R1, R2, F1): Except from the (presumably, rare) cases where its full expressive power is needed, this adaptation should preserve the simplicity of our current higher-order notation (F2), compatible with Herbrand models. <p> However, here we opted for allowing the more general non-deterministic case even in the RELFUN kernel: thus assimilating functions to (per se non-deterministic) relations, our tight relational-functional integration is actually simplified. Future work should profit from detailed comparisons with the rewriting logic of <ref> [GMHGRA97] </ref>, since, like RELFUN, it uses non-deterministic functions and, unlike RELFUN, lazy narrowing, as well as into the standardization proposal Curry [Han97], since, unlike REL-FUN, it uses deterministic functions and needed narrowing. 28
Reference: [Han94] <author> Michael Hanus. </author> <title> The Integration of Functions into Logic Programming: From Theory to Practice. </title> <journal> Journal of Logic Programming, </journal> <volume> 19,20:583-628, </volume> <year> 1994. </year>
Reference-contexts: It is thus attempted to complement the `function-translating' characterization of innermost narrowing in [BGM88] by a `function-modeling' characterization. Since our model notion reflects call-by-value flattening, also our notion of completeness will differ from the general one in <ref> [Han94] </ref>, as illustrated by example 9. We think that a fundament for functional programming should be `grounded' on a level as deep as the (Herbrand-)model-theoretic fundament of relational programming.
Reference: [Han97] <author> Michael Hanus. </author> <title> A Unified Computation Model for Functional and Logic Programming. </title> <booktitle> In POPL'97, Paris 1997. </booktitle> <pages> 29 </pages>
Reference-contexts: Future work should profit from detailed comparisons with the rewriting logic of [GMHGRA97], since, like RELFUN, it uses non-deterministic functions and, unlike RELFUN, lazy narrowing, as well as into the standardization proposal Curry <ref> [Han97] </ref>, since, unlike REL-FUN, it uses deterministic functions and needed narrowing. 28
Reference: [HLW92] <author> Werner Hans, Rita Loogen, and Stephan Winkler. </author> <title> On the Interaction of Lazy Evaluation and Backtracking. </title> <booktitle> In Proceedings of the Symposium on Programming Language Implementation and Logic Programming, PLILP '92, </booktitle> <publisher> LNCS. Springer, </publisher> <year> 1992. </year>
Reference-contexts: We could not go here into the topic of eagerness vs. laziness <ref> [HLW92] </ref>, which we feel is still an open issue for declarative integrations. But our RELFUN experience suggests that the simpler eager evaluation strategy may be superior in practice.
Reference: [Llo87] <author> John W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1987. </year>
Reference-contexts: Altogether, RELFUN subsumes hornish and footed clauses as valued clauses, which tightly integrate relational and functional characteristics. 2 The following functional version of J. W. Lloyd's relational slowsort example <ref> [Llo87] </ref> shows the use of non-ground and non-deterministic subfunction calls for defining a deterministic main function. <p> Finally, some aspects of our RELFUN extensions of SLD-resolution, Herbrand models, and T P -operators will probably be transferable to other languages. Our basic semantic treatment draws heavily on chapters 1 and 2 of J. W. Lloyd's book <ref> [Llo87] </ref>, construing a parallel between Horn-clause relations and first-order functions, enabled by suitably generalizing the latter in a non-ground, non-deterministic fashion. This relational-functional parallel in the formal definitions given here derived from considerations in language design such as expressive power, orthogonality, and uniformity of constructs. <p> On the basis of the unified pure-RELFUN constructs, the impure relational-functional features can also be introduced in a uniform manner. For instance, after proving results corresponding to the "independence of the computation rule" in <ref> [Llo87] </ref>, we could proceed from `and-parallel' to `and-sequential' relational-functional premise evaluation, which is the operational semantics actually implemented for RELFUN (just as for PROLOG). Similarly, the resolution/model-theoretic `or-parallelism' of relational-functional clauses could be weakened toward the operational (but implementation-incomplete!) `or-sequentialism' of backtracking. <p> constructs; however, adapting our model-theoretic approach to such optional determinism specifications may be difficult because of the semantic problems with cut-like notions. 2 Extending First-Order Theories to First-Order Relational Functional Theories We now begin with the formal development of first-order relational-functional programming by `functionally' extending the "Foundations of Logic Programming" <ref> [Llo87] </ref>, which should also be consulted for references to classical work. A first-order relational-functional theory consists of: 1. An alphabet. 2. <p> Such a notion of expressions is essential in functional programming, but lacks in non-extended logic programming (in <ref> [Llo87] </ref>, "expression" is given a different, peripheral meaning). Definition 4 A (well-formed) formula is defined inductively: 1. <p> This functionally extended truth concept directly transfers to the classical definitions of, e.g., model, validity, and logical consequence, for which we refer to <ref> [Llo87] </ref>. Example 4 Consider the formula 8x (x .= f (g (x); g (x))) and the following interpretation I. <p> We concentrate the further development on relational-functional Herbrand crossbase models, which, however, constitute disjoint unions of Herbrand cross models and Herbrand (base) models. The "model intersection" proposition 6.1 of <ref> [Llo87] </ref> obviously also holds for the crossbase extension. 12 Proposition 1 (Model intersection property) Let P be a relational-functional program and fM i g i2I be a non-empty set of Herbrand crossbase models for P . Then T Herbrand crossbase model for P . <p> Clearly, T X P is monotonic on the complete lattice 2 X P under the partial order "". Like T P in <ref> [Llo87] </ref>, it can be shown to be continuous. Proposition 5 Let P be a relational-functional program. Then the mapping T X P is continuous. <p> H. van Emden and R. Kowalski to a characterization of the least Herbrand crossbase model of relational-functional programs (for the """-notation see <ref> [Llo87] </ref>). Theorem 2 (Fixpoint characterization of the least Herbrand crossbase model) Let P be a relational-functional program. Then M P = lf p (T X P ) = T X P " !. <p> Proof M P = glbfI j I is an Herbrand crossbase model f or P g = glbfI j T X P (I) Ig; by proposition 6 = lf p (T X P ); by proposition 5:1 in <ref> [Llo87] </ref> = T X P " !; by proposition 5:4 in [Llo87] and proposition 5 Example 13 The 8-element least Herbrand crossbase model of the program P 2 of example 8 (in section 4) can be computed bottom-up by the following T X P 2 iterations (details of the last step <p> Proof M P = glbfI j I is an Herbrand crossbase model f or P g = glbfI j T X P (I) Ig; by proposition 6 = lf p (T X P ); by proposition 5:1 in <ref> [Llo87] </ref> = T X P " !; by proposition 5:4 in [Llo87] and proposition 5 Example 13 The 8-element least Herbrand crossbase model of the program P 2 of example 8 (in section 4) can be computed bottom-up by the following T X P 2 iterations (details of the last step were shown in example 10): T X P 2 " 0 <p> Proof The induction proof is as for lemma 8.1 in <ref> [Llo87] </ref> except that unifiers and mgu's need not derive from (body) resolution but can derive from the other rules of SLV-resolution (flattening in unrestricted SLV-refutations, like in SLV-refutations, produces identity substitutions). Lemma 4 (Lifting lemma) Let P be a relational-functional program, G r a relational goal, and a substitution. <p> 0 1 ; . . . ; 0 n are the mgu's from the SLV-refutation of P [ fG r g, then there exists a substitution fl such that 1 . . . n G r 1 . . . 0 Proof The proof is as for lemma 8.2 in <ref> [Llo87] </ref> with the qualification already noted for lemma 3, which is crucially applied here. The converse of corrollary 2 extends the logic-programming completeness result of K. R. Apt and M. H. van Emden to relational-functional programming. <p> has an unrestricted refutation and we can apply the mgu lemma to obtain a refutation of P [ f :- t .= f g. 26 For proving that every correct (relational or functional) answer is an instance of a computed (relational or functional) answer we first transfer lemma 8.5 from <ref> [Llo87] </ref>. Lemma 5 Let P be a relational-functional program and F a relationship or setter. Suppose that 8 (F ) is a logical consequence of P . Then there exists an SLV-refutation of P [ f :- F g with the identity substitution as the computed answer. <p> Now, K. L. Clark's completeness result can be extended from logic to relational-functional programming. For relational goals we can adapt the formulation for definite goals in <ref> [Llo87] </ref>. Theorem 4 (Completeness of relational SLV-resolution) Let P be a relational-functional program and G r a relational goal. For every correct answer for P [ fG r g there exists a computed answer for P [ fG r g and a substitution fl such that = fl.
Reference: [Llo94] <author> John W. Lloyd. </author> <booktitle> Combining Functional and Logic Programming Languages. In 1994 International Logic Programming Symposium, </booktitle> <address> ILPS'94. </address>
Reference-contexts: The other functional essential, higher-order operators (F2), is incorporated only syntactically. While this considerably simplified the model theory, there remains the challenge of adapting Henkin models <ref> [Llo94] </ref>, Hoare powerdomains [GMHGRA97], or some other higher-order semantics for the first-order relational-functional essentials (R1, R2, F1): Except from the (presumably, rare) cases where its full expressive power is needed, this adaptation should preserve the simplicity of our current higher-order notation (F2), compatible with Herbrand models.
Reference: [MNRA92] <author> J.J. Moreno-Navarro and M. Rodriguez-Artalejo. </author> <title> Logic programming with functions and predicates: The language BABEL. </title> <journal> Journal of Logic Programming, </journal> <volume> 12 </volume> <pages> 191-223, </pages> <year> 1992. </year>
Reference-contexts: These semantic extensions are less complicated than the semantics of lazy expressions (outermost reduction) as a relational-functional integration concept, as introduced by other recent proposals (e.g., K-LEAF [GLMP91] and BABEL <ref> [MNRA92] </ref>): eagerness keeps the semantics strict and simple, whereas laziness accepts the non-strictness overhead to give a meaning to unifications involving non-terminating expressions.
Reference: [O'D85] <author> M. J. O'Donnell. </author> <title> Equational Logic as a Programming Language. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1985. </year>
Reference-contexts: If W is a formula and x is a variable, then (9xW ) and (8xW ) are formulas. The restriction of e being a flat application in items 3. and 4. reflects the "constructor discipline" <ref> [O'D85] </ref> of RELFUN's footed clauses. It could be dropped in a more general equational treatment of first-order relational-functional languages.
Reference: [War82] <author> David H. D. Warren. </author> <title> Higher-order extensions to PROLOG: </title> <journal> Are they needed? Machine Intelligence, </journal> <volume> 10 </volume> <pages> 441-454, </pages> <year> 1982. </year> <month> 30 </month>
Reference-contexts: Similarly, RELFUN's higher-order operations should not be too difficult to add, as they are restricted to those reducible to first-order operations using an apply dummy as introduced for corresponding PROLOG extensions by D. H. D. Warren <ref> [War82] </ref>. While these two extensions have long existed in the implemented RELFUN system, further extensions such as finite domains and, particularly, finite exclusions (see [Bol94]) will first require their own operational test phase before we can think of including them in the formal semantics.
References-found: 20

