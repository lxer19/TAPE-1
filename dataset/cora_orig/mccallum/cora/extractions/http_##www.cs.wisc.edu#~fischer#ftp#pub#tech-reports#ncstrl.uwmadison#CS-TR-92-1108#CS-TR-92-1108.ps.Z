URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1108/CS-TR-92-1108.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-92-1108/
Root-URL: http://www.cs.wisc.edu
Email: tom@cs.wisc.edu  
Title: What's in a Region? or Computing Control Dependence Regions in Linear Time and Space  
Author: THOMAS BALL 
Date: September 18, 1992  
Address: 1210 West Dayton Street Madison, Wisconsin 53706 USA  
Affiliation: Computer Sciences Department University of Wisconsin Madison  
Pubnum: 608-262-6612  
Abstract: Regions of control dependence identify the instructions in a program that execute under the same control conditions. They have a variety of applications in parallelizing and optimizing compilers. Two vertices in a control flow graph (which may represent instructions or basic blocks in a program) are in the same region if they have the same set of control dependence predecessors. The best known algorithm for computing regions takes O(VE) time, where V and E are the number of vertices and edges in the control flow graph, respectively. We present algorithms for finding regions in O (V +E) time and O (V +E) space, without using control dependence. These algorithms are based on alternative definitions of regions, which are easier to reason with than the definitions based on control dependence.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aho, R. Sethi, and J. Ullman, </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: Any vertices that are in the same strong region are necessarily in the same weak region. For acyclic control flow graphs, weak regions and strong regions are equivalent. However, for cyclic control flow graphs, two vertices may be in the same weak region but in hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh begin <ref> [1] </ref> compute postdominator and dominator trees; [2] region_num := 1; [3] WTAIL (region_num) := EXIT; [4] WNEXT (EXIT) := nil; [5] DFS (EXIT, 1); end DFS (v : vertex , num : integer ) begin [6] WREGION (v), WPREV (v) := num, nil; [7] for each vertex w in PDOM (v).children <p> Each vertex w has an associated set of backedge sources back-srcs (w) = - v | v fi w is a backedge -. A vertex h is a loop-entry if back-srcs (h) . Natural loops identify loops and loop nesting in the control flow graph <ref> [1] </ref>. The natural loop associated with loop-entry h is: nat-loop (h) = -h- - v | there is an h-free path from v to a vertex in back-srcs (h) - In reducible control flow graphs, a loop-entry h dominates every vertex in nat-loop (h) (except h itself). <p> This can be accomplished using T 1 and T 2 transformations, for example <ref> [1] </ref>. Figure 5 shows the control flow graph from Figure 4 after nat loop (a) has been reduced. We make the following observations about the loop analysis process: g Let W and F be the number of vertices and the number of edges in the subgraph induced by nat-loop (h).
Reference: 2. <author> D. Bernstein and M. Rodeh, </author> <title> Global Instruction Scheduling for Superscalar Machines, </title> <booktitle> Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation (SIG-PLAN Notices) 26(6) pp. </booktitle> <month> 241-255 (June </month> <year> 1991). </year>
Reference-contexts: They have a variety of applications in parallelizing and optimizing compilers [3, 5] and other systems [8]. For example, regions can be used for identifying code that can be executed in parallel, and for global instruction scheduling by identifying code that may be moved between basic blocks <ref> [2] </ref>. Two vertices in a control flow graph (which may represent instructions or basic blocks in a program) are in the same region if they have the same set of control dependence predecessors. <p> Therefore, c pd b. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 2 This differs slightly from the usual definition of dominance, which is reflexive. 3 This definition is identical to Bernstein and Rodeh's notion of equivalent vertices <ref> [2] </ref>. <p> For acyclic control flow graphs, weak regions and strong regions are equivalent. However, for cyclic control flow graphs, two vertices may be in the same weak region but in hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh begin [1] compute postdominator and dominator trees; <ref> [2] </ref> region_num := 1; [3] WTAIL (region_num) := EXIT; [4] WNEXT (EXIT) := nil; [5] DFS (EXIT, 1); end DFS (v : vertex , num : integer ) begin [6] WREGION (v), WPREV (v) := num, nil; [7] for each vertex w in PDOM (v).children do [8] if DOM (v).parent =
Reference: 3. <author> R. Cytron, J. Ferrante, and V. Sarkar, </author> <title> Experiences Using Control Dependence in PTRAN, </title> <booktitle> Proceedings of the Second Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> (August </month> <year> 1989). </year>
Reference-contexts: 1. INTRODUCTION Regions of control dependence identify the instructions in a program that execute under the same control conditions. They have a variety of applications in parallelizing and optimizing compilers <ref> [3, 5] </ref> and other systems [8]. For example, regions can be used for identifying code that can be executed in parallel, and for global instruction scheduling by identifying code that may be moved between basic blocks [2]. <p> Weak regions are equivalent to the control depen dence regions that arise from forward (loop-independent) control dependences <ref> [3] </ref>. g Vertices v and w are in the same strong region iff v and w occur the same number of times in any complete control flow path. Strong regions are equivalent to the control dependence regions that ar ise from full control dependences. <p> The depth-first search is done on the postdominator tree (although because of symmetry, it could just as easily be done on the dominator tree). EXIT is the tail of the first weak region (lines <ref> [3] </ref> and [4]). The procedure DFS finds chains in the postdominator tree that are the reverse of chains in the dominator tree. <p> For acyclic control flow graphs, weak regions and strong regions are equivalent. However, for cyclic control flow graphs, two vertices may be in the same weak region but in hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh begin [1] compute postdominator and dominator trees; [2] region_num := 1; <ref> [3] </ref> WTAIL (region_num) := EXIT; [4] WNEXT (EXIT) := nil; [5] DFS (EXIT, 1); end DFS (v : vertex , num : integer ) begin [6] WREGION (v), WPREV (v) := num, nil; [7] for each vertex w in PDOM (v).children do [8] if DOM (v).parent = w then [9] WPREV
Reference: 4. <author> R. Cytron, J. Ferrante, and V. Sarkar, </author> <title> Compact Representations for Control Dependence, </title> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation (SIGPLAN Notices) 25(6)(June 20-22, </booktitle> <year> 1990). </year>
Reference-contexts: The best known algorithm for computing (the partitioning induced by) regions takes O (VE) time, where V and E are the number of vertices and edges in the control flow graph, respectively <ref> [4] </ref>. This is because the algorithm examines each control dependence once, and there can be O (VE) control dependences in the worst-case, even for acyclic control flow graphs. This algorithm uses O (V+E) space. This paper presents algorithms for finding regions in linear time and space, without using control dependence. <p> Therefore, v i +1 idom v i . ` As in <ref> [4] </ref>, we use the following data structures to represent regions: - 6 - WREGION (v) the weak region number associated with vertex v WHEAD (R) the first vertex in weak region R (i.e., lowest in postdominator tree) WTAIL (R) the last vertex in weak region R (i.e., highest in postdominator tree) <p> The depth-first search is done on the postdominator tree (although because of symmetry, it could just as easily be done on the dominator tree). EXIT is the tail of the first weak region (lines [3] and <ref> [4] </ref>). The procedure DFS finds chains in the postdominator tree that are the reverse of chains in the dominator tree. When examining a child w of vertex v in the postdominator tree (line [7]), the algorithm checks if w is the parent of v in the dominator tree (line [8]). <p> For acyclic control flow graphs, weak regions and strong regions are equivalent. However, for cyclic control flow graphs, two vertices may be in the same weak region but in hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh begin [1] compute postdominator and dominator trees; [2] region_num := 1; [3] WTAIL (region_num) := EXIT; <ref> [4] </ref> WNEXT (EXIT) := nil; [5] DFS (EXIT, 1); end DFS (v : vertex , num : integer ) begin [6] WREGION (v), WPREV (v) := num, nil; [7] for each vertex w in PDOM (v).children do [8] if DOM (v).parent = w then [9] WPREV (v), WNEXT (w) := w, <p> These regions are equivalent to strong regions. Figure 8 (b) presents the forward control dependence graph, which contains those control dependences that are not loop-carried. Regions of forward control dependence are equivalent to weak regions. ` In <ref> [4] </ref>, the authors showed how regions can be computed by examining the control dependence successors of each vertex. Using the control flow graph and postdominator tree, the control dependences successors of a vertex can be enumerated in time proportional to the number of such successors [4]. <p> to weak regions. ` In <ref> [4] </ref>, the authors showed how regions can be computed by examining the control dependence successors of each vertex. Using the control flow graph and postdominator tree, the control dependences successors of a vertex can be enumerated in time proportional to the number of such successors [4]. Thus, the control dependence graph need not be explicitly constructed to perform region analysis (yielding an O (V +E) bound on space). Unfortunately, there can be O (VE) control dependences because each vertex can have O (E) control dependence predecessors in the worst case.
Reference: 5. <author> J. Ferrante, K. Ottenstein, and J. Warren, </author> <title> The program dependence graph and its use in optimization, </title> <journal> ACM Transactions on Programming Languages and Systems 9(5) pp. </journal> <month> 319-349 (July </month> <year> 1987). </year>
Reference-contexts: 1. INTRODUCTION Regions of control dependence identify the instructions in a program that execute under the same control conditions. They have a variety of applications in parallelizing and optimizing compilers <ref> [3, 5] </ref> and other systems [8]. For example, regions can be used for identifying code that can be executed in parallel, and for global instruction scheduling by identifying code that may be moved between basic blocks [2]. <p> However, for cyclic control flow graphs, two vertices may be in the same weak region but in hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh begin [1] compute postdominator and dominator trees; [2] region_num := 1; [3] WTAIL (region_num) := EXIT; [4] WNEXT (EXIT) := nil; <ref> [5] </ref> DFS (EXIT, 1); end DFS (v : vertex , num : integer ) begin [6] WREGION (v), WPREV (v) := num, nil; [7] for each vertex w in PDOM (v).children do [8] if DOM (v).parent = w then [9] WPREV (v), WNEXT (w) := w, v; [10] DFS (w,num); else
Reference: 6. <author> R. Gupta, </author> <title> Generalized Dominators and Post-dominators, pp. </title> <booktitle> 246-257 in Conference Record of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> (Albuquerque, NM, </address> <month> January 19-22, </month> <year> 1992), </year> <booktitle> ACM, </booktitle> <address> New York (1992). </address>
Reference-contexts: flow graphs, two vertices may be in the same weak region but in hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh begin [1] compute postdominator and dominator trees; [2] region_num := 1; [3] WTAIL (region_num) := EXIT; [4] WNEXT (EXIT) := nil; [5] DFS (EXIT, 1); end DFS (v : vertex , num : integer ) begin <ref> [6] </ref> WREGION (v), WPREV (v) := num, nil; [7] for each vertex w in PDOM (v).children do [8] if DOM (v).parent = w then [9] WPREV (v), WNEXT (w) := w, v; [10] DFS (w,num); else [11] WHEAD (num) := v; [12] region_num := region_num+1; [13] WTAIL (region_num), WNEXT (w) := <p> Graph H is transformed as follows: add a new vertex TMP; for each vertex v back-srcs (h) exits (h), add an edge v fi TMP. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 5 Gupta generalized postdominance so that a set of vertices could postdominate a vertex <ref> [6] </ref>.
Reference: 7. <author> D. Harel, </author> <title> A Linear Time Algorithm for Finding Dominators in Flow Graphs and Related Problems, </title> <booktitle> Proceedings of the 17th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pp. </pages> <month> 185-194 </month> <year> (1985). </year>
Reference-contexts: Figure 2 presents the dominator and postdominator trees for the example control flow graph. Dominator and postdominator trees can be computed in O (E) time <ref> [7] </ref>. Each tree requires O (V) space. 3. WEAK REGIONS Vertices v and w are in the same weak region of a control flow graph G iff for any complete path in G, v and w are both in the path or are both absent from the path. <p> EXIT is the tail of the first weak region (lines [3] and [4]). The procedure DFS finds chains in the postdominator tree that are the reverse of chains in the dominator tree. When examining a child w of vertex v in the postdominator tree (line <ref> [7] </ref>), the algorithm checks if w is the parent of v in the dominator tree (line [8]). If so, then v and w are in the same weak region (lines [9-10]). If not, then vertices v and w cannot occupy the same weak region (lines [11-14]). <p> same weak region but in hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh begin [1] compute postdominator and dominator trees; [2] region_num := 1; [3] WTAIL (region_num) := EXIT; [4] WNEXT (EXIT) := nil; [5] DFS (EXIT, 1); end DFS (v : vertex , num : integer ) begin [6] WREGION (v), WPREV (v) := num, nil; <ref> [7] </ref> for each vertex w in PDOM (v).children do [8] if DOM (v).parent = w then [9] WPREV (v), WNEXT (w) := w, v; [10] DFS (w,num); else [11] WHEAD (num) := v; [12] region_num := region_num+1; [13] WTAIL (region_num), WNEXT (w) := w, nil; [14] DFS (w,region_num); fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
Reference: 8. <author> S. Horwitz, J. Prins, and T. Reps, </author> <title> Integrating non-interfering versions of programs, </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <pages> 11(3) pp. </pages> <month> 345-387 (July </month> <year> 1989). </year>
Reference-contexts: 1. INTRODUCTION Regions of control dependence identify the instructions in a program that execute under the same control conditions. They have a variety of applications in parallelizing and optimizing compilers [3, 5] and other systems <ref> [8] </ref>. For example, regions can be used for identifying code that can be executed in parallel, and for global instruction scheduling by identifying code that may be moved between basic blocks [2]. <p> The procedure DFS finds chains in the postdominator tree that are the reverse of chains in the dominator tree. When examining a child w of vertex v in the postdominator tree (line [7]), the algorithm checks if w is the parent of v in the dominator tree (line <ref> [8] </ref>). If so, then v and w are in the same weak region (lines [9-10]). If not, then vertices v and w cannot occupy the same weak region (lines [11-14]). <p> postdominator and dominator trees; [2] region_num := 1; [3] WTAIL (region_num) := EXIT; [4] WNEXT (EXIT) := nil; [5] DFS (EXIT, 1); end DFS (v : vertex , num : integer ) begin [6] WREGION (v), WPREV (v) := num, nil; [7] for each vertex w in PDOM (v).children do <ref> [8] </ref> if DOM (v).parent = w then [9] WPREV (v), WNEXT (w) := w, v; [10] DFS (w,num); else [11] WHEAD (num) := v; [12] region_num := region_num+1; [13] WTAIL (region_num), WNEXT (w) := w, nil; [14] DFS (w,region_num); fi end hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh dren in the postdominator tree and DOM (v).parent is
References-found: 8

