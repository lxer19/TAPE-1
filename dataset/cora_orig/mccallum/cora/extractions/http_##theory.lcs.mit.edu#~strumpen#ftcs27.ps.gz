URL: http://theory.lcs.mit.edu/~strumpen/ftcs27.ps.gz
Refering-URL: http://theory.lcs.mit.edu/~porch/release-1.0/ug/html/node1.html
Root-URL: 
Email: ramkumar@eng.uiowa.edu strumpen@theory.lcs.mit.edu  
Phone: Phone: 319-335-5957 Phone: 617-253-1531  
Title: Portable Checkpointing for Heterogeneous Architectures  
Author: Balkrishna Ramkumar Volker Strumpen 
Address: Iowa City, IA 52242 Cambridge, MA 02139  
Affiliation: Dept. of Electrical and Computer Engineering Laboratory for Computer Science University of Iowa Massachusetts Institute of Technology  
Abstract: Current approaches for checkpointing assume system homogeneity, where checkpointing and recovery are both performed on the same processor architecture and operating system configuration. Sometimes it is desirable or necessary to recover a failed computation on a different processor architecture. For such situations checkpointing and recovery must be portable. In this paper, we argue that source-to-source compilation is an appropriate concept for this purpose. We describe the compilation techniques that we developed for the design of the c2ftc prototype. The c2ftc compiler enables machine-independent checkpoints by automatic generation of checkpointing and recovery code. Sequential C programs are compiled into fault tolerant C programs, whose checkpoints can be migrated across heterogeneous networks, and restarted on binary incompatible architectures. Experimental results on several systems provide evidence that the performance penalty of portable checkpointing is negligible for realistic checkpointing frequencies. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alvisi L., Hoppe B., Marzullo K. </author> <title> Nonblocking and Orphan-Free Message Logging Protocols. </title> <booktitle> In 23rd Fault Tolerant Computing Symposium, </booktitle> <pages> pages 145-154, </pages> <address> Toulouse, France, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: may execute in one of four modes. 1 An optimized version would only save the live variables determined by data-flow analysis. extern int checkpoint (); main (int argc, char *argv []) - chkpt_main (argc, argv); - chkpt_main (int argc, char *argv []) - int n, result; n = atoi (argv <ref> [1] </ref>); result = fib (n); - if (n &gt; 2) return (fib (n-1) + fib (n-2)); else - checkpoint (); return 1; - Checkpoint Algorithm. This mode of execution is kept in the global state variable SL chkptmode. <p> At this time, a pointer to p's address on the shadow stack X ps is pushed on the pointer stack. Next, the frame of chkpt_main is pushed onto the shadow stack. In Figure 6, the target address of p is the array element a <ref> [1] </ref>, marked X, and its shadow X s . During the restore phase, the frame of chkpt_main is restored before the frame of function1. Before restoring array a, the pointer stack is checked for a reference into a on the stack. <p> Note that a shadow stack pop operation affects an entire object. Array a is restored as a whole, not element-wise. In order to recover forward pointers | here p to a <ref> [1] </ref> | 2 Determining X s requires some additional offset computation, details can be found in [9]. call-by-reference. the address of each object's element on the runtime stack is stored in its location on the shadow stack after the value of the element has been restored on the runtime stack; cf. <p> This mapping is needed, when function1 is restored. The frame of function1 contains the offset to a <ref> [1] </ref> in address X ps . Recovering pointer p involves the transformation of the offset into the pointer. This requires the lookup operation: p= fi fl . <p> We expect the programmer to clean up the code, if c2ftc detects such a situation. The following represent c2ftc specific limitations: * We did not address file I/O and interprocess communication for c2ftc yet. We expect to provide portability based on the approach of logging message determinants <ref> [1] </ref>, which is applicable to both file I/O and interprocess communication. * Our current runtime support is targeted at Unix dialects.
Reference: [2] <author> Elnozahy E.N., Johnson D. B., Zwaenepoel W. </author> <title> The performance of consistent checkpointing. </title> <booktitle> In IEEE Symposium on Reliable and Distributed Systems, </booktitle> <pages> pages 39-47, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In Section 5, we present experimental results showing that the performance penalty for portability is negligible. Finally, we discuss limitations of compiler support for portable checkpointing in Section 6. 2 Related Work Elnozahy et al. <ref> [2] </ref> and Plank et al. [6] have proposed efficient implementation techniques to minimize the overhead of checkpointing to few percent of the execution time. The techniques developed in [2, 6] rely on efficient page-based bulk copying and hardware support to identify memory pages modified since the last checkpoint. <p> Finally, we discuss limitations of compiler support for portable checkpointing in Section 6. 2 Related Work Elnozahy et al. [2] and Plank et al. [6] have proposed efficient implementation techniques to minimize the overhead of checkpointing to few percent of the execution time. The techniques developed in <ref> [2, 6] </ref> rely on efficient page-based bulk copying and hardware support to identify memory pages modified since the last checkpoint. Unfortunately, these optimizations are restricted to binary compatible hardware and operating systems. <p> However, it remains to be seen whether compile- time analysis is powerful enough to reduce checkpoint- ing overheads to the degree that page-based techniques as proposed by Elnozahy et al. <ref> [2] </ref> improve performance. Source-to-source compilation does furthermore permit the use of system-level optimizations like copy-on- write or communication latency-hiding [8] during the transfer of a checkpoint to stable storage.
Reference: [3] <author> Franz M. </author> <title> Code Generation on the Fly: A Key to Portable Softare. </title> <type> PhD thesis, </type> <institution> Institute for Computer Systems, ETH Zurich, </institution> <year> 1994. </year>
Reference-contexts: Unfortunately, these optimizations are restricted to binary compatible hardware and operating systems. However, the remarkably low overhead afforded by these optimizations suggests that it is possible to achieve checkpoint portability at only marginally higher cost. The issue of portability across heterogeneous architectures has been addressed in the language community <ref> [3, 4] </ref>. Languages like Java [4] provide an interpreter-based approach to portability where the program byte code is first "migrated" to the client platform for local interpretation. Unfortunately, such schemes severely compromise performance since they run at least an order of magnitude slower than comparable C programs. <p> Unfortunately, such schemes severely compromise performance since they run at least an order of magnitude slower than comparable C programs. Another possibility is "compilation on the fly" <ref> [3] </ref> which provides portability by compiling the source code on the desired target machine immediately prior to execution. This technique requires the construction of a complex language environment. Moreover, to date neither interpreter-based systems nor compilation on the fly are explicitly designed to support fault tolerance.
Reference: [4] <author> Gosling J. </author> <title> The Java Language Environment. </title> <type> Technical report, </type> <institution> Sun Microsystems, Mountain View, California, </institution> <year> 1995. </year> <note> White Paper. </note>
Reference-contexts: Unfortunately, these optimizations are restricted to binary compatible hardware and operating systems. However, the remarkably low overhead afforded by these optimizations suggests that it is possible to achieve checkpoint portability at only marginally higher cost. The issue of portability across heterogeneous architectures has been addressed in the language community <ref> [3, 4] </ref>. Languages like Java [4] provide an interpreter-based approach to portability where the program byte code is first "migrated" to the client platform for local interpretation. Unfortunately, such schemes severely compromise performance since they run at least an order of magnitude slower than comparable C programs. <p> However, the remarkably low overhead afforded by these optimizations suggests that it is possible to achieve checkpoint portability at only marginally higher cost. The issue of portability across heterogeneous architectures has been addressed in the language community [3, 4]. Languages like Java <ref> [4] </ref> provide an interpreter-based approach to portability where the program byte code is first "migrated" to the client platform for local interpretation. Unfortunately, such schemes severely compromise performance since they run at least an order of magnitude slower than comparable C programs. <p> Once the entire runtime stack has been restored, the computed displacements in the pointer stack are then written into the corresponding locations in the shadow stack, thereby overwriting the pointer target addresses with portable offsets. extern int checkpoint (); chkpt_main () function1 (long *p) - long a <ref> [4] </ref>; p += 1; checkpoint (); function1 (a); *p = 2; - Checkpoint Algorithm with call-by-reference; cf. Fig- ure 6. As an example, consider the code fragment in Fig- ure 5 and the illustration in Figure 6.
Reference: [5] <author> Li C-C. J., Stewart E.M., </author> <title> Fuchs W.K. Compiler Assisted Full Checkpointing. </title> <journal> Software - Practice and Experience, </journal> <volume> 24 no. 10 </volume> <pages> 871-8861, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: This technique requires the construction of a complex language environment. Moreover, to date neither interpreter-based systems nor compilation on the fly are explicitly designed to support fault tolerance. Li and Fuchs <ref> [5] </ref> were among the first to demonstrate the use of compilers for automatically inserting potential checkpoint locations into programs. At run- time, heuristics are used to determine which of these checkpoints will be activated, with the goal to minimize the checkpointing overhead. This work does not address portability.
Reference: [6] <author> Plank J.S., Beck M., Kingsley G., Li K. Libckpt: </author> <title> Transparent Checkpointing under Unix. </title> <booktitle> In Proceedings of the Usenix Winter Technical Conference, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: In Section 5, we present experimental results showing that the performance penalty for portability is negligible. Finally, we discuss limitations of compiler support for portable checkpointing in Section 6. 2 Related Work Elnozahy et al. [2] and Plank et al. <ref> [6] </ref> have proposed efficient implementation techniques to minimize the overhead of checkpointing to few percent of the execution time. The techniques developed in [2, 6] rely on efficient page-based bulk copying and hardware support to identify memory pages modified since the last checkpoint. <p> Finally, we discuss limitations of compiler support for portable checkpointing in Section 6. 2 Related Work Elnozahy et al. [2] and Plank et al. [6] have proposed efficient implementation techniques to minimize the overhead of checkpointing to few percent of the execution time. The techniques developed in <ref> [2, 6] </ref> rely on efficient page-based bulk copying and hardware support to identify memory pages modified since the last checkpoint. Unfortunately, these optimizations are restricted to binary compatible hardware and operating systems. <p> The stack must then be restored by executing the original function call sequence again. c2ftc generates code to access each local variable by name rather than block-copying the stack. This eliminates problems caused by non- portable implementations based on setjmp/longjmp pairs, as for example used in libckpt <ref> [6] </ref>. In order to preserve the program's state while checkpointing, none of the program's statements may be executed. Therefore, the program must be instrumented with function calls and returns to visit the each stack frame during checkpointing without affecting the semantics of normal execution.
Reference: [7] <author> Seligman E., Beguelin A. </author> <title> High-Level Fault Tolerance in Distributed Programs. </title> <type> Technical Report CMU-CS-94-223, </type> <institution> Carnegie-Mellon University, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: Although the authors defend this scheme in the context of dynamically allocated shared memory, such an organization is clearly impractical for the runtime stack, which has to be converted too when saving a checkpoint. Seligman and Beguelin <ref> [7] </ref> have developed check- pointing and restart algorithms in the context of the Dome C++ environment. Dome's checkpointing is designed for portability, but requires that the program be written in the form of a main loop that computes and checkpoints alternately. This obviates the need to store the runtime stack.
Reference: [8] <author> Strumpen V. </author> <title> Software-Based Communication Latency Hiding for Commodity Networks. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <month> August </month> <year> 1996. </year>
Reference-contexts: However, it remains to be seen whether compile- time analysis is powerful enough to reduce checkpoint- ing overheads to the degree that page-based techniques as proposed by Elnozahy et al. [2] improve performance. Source-to-source compilation does furthermore permit the use of system-level optimizations like copy-on- write or communication latency-hiding <ref> [8] </ref> during the transfer of a checkpoint to stable storage. This benefit is significant, since this transfer represents the most time-consuming part of checkpointing, given today's relatively low network and disk performance. 4 Shadow Checkpointing c2ftc applies fault tolerance transformations to the abstract syntax tree of a C program.
Reference: [9] <author> Strumpen V., Ramkumar B. </author> <title> Portable Checkpointing and Recovery in Heterogeneous Environments. </title> <type> Technical Report 96-6-1, </type> <institution> Dept. of Electrical and Computer Engineering, University of Iowa, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: Other aspects such as data representation conversion, and runtime support are not covered in this article, but can be found in <ref> [9] </ref>. We have developed c2ftc, a source-to-source compiler that translates C programs into fault tolerant C programs. This prototype generates code for saving and recovering portable checkpoints to enable fault tolerance across heterogeneous architectures. <p> A discussion may be found in <ref> [9] </ref>. 4.1 Checkpointing the Stack We begin by first considering only non-pointer variables on the runtime stack. The algorithm is then extended in Section 4.2 to support pointer variables. <p> Note that a shadow stack pop operation affects an entire object. Array a is restored as a whole, not element-wise. In order to recover forward pointers | here p to a [1] | 2 Determining X s requires some additional offset computation, details can be found in <ref> [9] </ref>. call-by-reference. the address of each object's element on the runtime stack is stored in its location on the shadow stack after the value of the element has been restored on the runtime stack; cf. broken lines in Figure 7. This mapping is needed, when function1 is restored. <p> For more experimental analysis, the reader is refered to <ref> [9] </ref>. 5.1 Code Instrumentation Penalty The transformation of the Fibonacci program in in a good test case for the runtime overhead due to code instrumentation.
Reference: [10] <author> Theimer M.M., Hayes B. </author> <title> Heterogeneous Process Migration by Recompilation. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 18-25, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: At run- time, heuristics are used to determine which of these checkpoints will be activated, with the goal to minimize the checkpointing overhead. This work does not address portability. Theimer and Hayes <ref> [10] </ref> present a recompilation- based approach to heterogeneous process migration. The idea to utilize compilation for that purpose is similar to our approach. However, the compilation technique proposed is very different. Their idea is to, upon migration, translate the state of a program into a machine independent state.
Reference: [11] <author> Zhou S., Stumm M., Li K., Wortman D. </author> <title> Heterogeneous Distributed Shared Memory. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 3 no. 5 </volume> <pages> 540-554, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Rather than compiling a migration program each time that a checkpoint is to be taken, we instrument the original program with code that barely affects the run- time during normal execution, avoids the overhead of compiling a migration program, and is conceptually much simpler. Zhou et al. <ref> [11] </ref> describe the Mermaid system for distributed shared memory on heterogeneous systems. This system is not fault tolerant, but generates data representation conversion routines automatically for all shared memory objects. This paper provides a detailed treatment on conversion.
References-found: 11

