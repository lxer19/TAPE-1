URL: ftp://ftp.cs.brown.edu/pub/techreports/94/cs94-05.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-94-05.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Harold Abelson, Gerald Jay Sussman, and Julie Sussman. </author> <title> Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1985. </year>
Reference-contexts: Queries which are beyond the state of the art are harder to understand, and the additional complexity would obscure the presentation of our techniques. The optimization that we would like to perform is as follows: The first time that the path expression is traversed, compute a memoizing function <ref> [1] </ref> that incrementally creates a path index or cluster that associates the head-object of the shared subpath with the tail-object, allowing users of the memo structure to quickly jump from beginning to end. Subsequent traversals of the path expression will read from the memo structure and be sped up.
Reference: [2] <author> Walid Abu-Sufah, David J. Kuck, and Duncan H. Lawrie. </author> <title> On the performance enhancement of paging systems through program analysis and transformations. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-30(5):341-356, </volume> <month> May </month> <year> 1981. </year>
Reference-contexts: Code generation systems based on Bottom Up Rewrite Systems (BURS), like IBURG [33] also use tree pattern matching, but restrict its expressiveness in the interest of efficiency. A little work has been done to try to manage virtual memory <ref> [2] </ref> or processor cache memory [15, 16] at code generation time. The work on virtual memory management was done in the context of FORTRAN, and concentrated on distributing the control of multiple loops and reordering loop indices when performing array operations.
Reference: [3] <author> Lalit Agrawal, Sean Cutts, Jennifer Goree, Marc Hamilton, Eric Lam, Neal Pawar, Adam Stauffer, and Rodrigo Vanegas. </author> <title> ?????POPS design document. CS191 Final Project Report, </title> <institution> Brown University, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: Our goal for an implementation is to provide a plan generation region that could be incorporated into the EPOQ prototype to generate executable plans. These plans will then be passed to a query evaluation system based on the Persistent Object Package System (POPS) <ref> [3] </ref>, developed at Brown.
Reference: [4] <author> Alfred V. Aho, Mahadevan Ganapathi, and Steven W. K. Tjiang. </author> <title> Code generation using tree matching and dynamic programming. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 491-516, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Compiler researchers have used tree pattern matching to help build portable and efficient code generators. The Twig system <ref> [4] </ref> uses a tree matching language and a dynamic programming algorithm to generate code generators. Their tree language is fairly simple in comparison to our tree query language, but it allows them to specify code generation and improvement in terms of tree creation and tree transformation.
Reference: [5] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, Massachusetts, </address> <year> 1986. </year> <month> 47 </month>
Reference-contexts: If information about the dependency relationships between the two path expressions was available, it could be used to make a better decision about whether a path should be P or P1. In compilers <ref> [5, 32] </ref>, attribute grammars are used to declaratively compute and propagate information up and down abstract syntax trees. This information is then available for use during optimization and code generation.
Reference: [6] <editor> Peter M.G. Apers and Gio Wiederhold, editors. </editor> <booktitle> Proceedings of the Fifteenth Very Large Databases Conference, </booktitle> <address> Amsterdam, The Netherlands, 1989. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference: [7] <author> Catriel Beeri, </author> <title> editor. </title> <booktitle> Proceedings of the The Fourth International Workshop on Database Programming Languages, </booktitle> <address> New York, New York, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference: [8] <author> Veronique Benzaken and Claude Delobel. </author> <title> Enhancing performance in a persistent object store: Clustering strategies in O2. </title> <editor> In Dearle et al. </editor> <volume> [27], </volume> <pages> pages 403-412. </pages>
Reference-contexts: There have been many proposals for single and multi-page clusters [14, 11, 77], as well as performance studies of the impact of clustering [49]. There has also been extensive work on methods for deciding which objects to place in a cluster <ref> [8, 85, 86] </ref>. Support for clustering is essential for good performance in object-oriented systems. 3 Approach Ultimately, the query must be evaluated by using specific algorithms to access specific data structures on secondary storage.
Reference: [9] <author> Elisa Bertino. </author> <title> An indexing technique for object-oriented databases. </title> <booktitle> In Proceedings of the Seventh International Conference on Data Engineering [48], </booktitle> <pages> pages 160-170. </pages>
Reference-contexts: Indices make use of a search data structure like b-tree to reduce the amount of data that must be 11 searched in order to find the answer to a query. There have been a number of proposals for indices in object-oriented databases <ref> [68, 10, 9, 93, 54, 55] </ref>, each with their own strengths and weaknesses.
Reference: [10] <author> Elisa Bertino and Won Kim. </author> <title> Indexing techniques for queries on nested objects. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(2) </volume> <pages> 196-214, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Indices make use of a search data structure like b-tree to reduce the amount of data that must be 11 searched in order to find the answer to a query. There have been a number of proposals for indices in object-oriented databases <ref> [68, 10, 9, 93, 54, 55] </ref>, each with their own strengths and weaknesses.
Reference: [11] <author> Jia bing R. Cheng and A. R. Hurson. </author> <title> Effective clustering of complex objects in object-oriented databases. </title> <booktitle> In Clifford and King [18], </booktitle> <pages> pages 22-31. </pages>
Reference-contexts: There have been many proposals for single and multi-page clusters <ref> [14, 11, 77] </ref>, as well as performance studies of the impact of clustering [49]. There has also been extensive work on methods for deciding which objects to place in a cluster [8, 85, 86].
Reference: [12] <author> Jose A. Blakeley, William J. McKenna, and Goetz Graefe. </author> <title> Experiences building the open OODB query optimizer. </title> <editor> In Peter Buneman and Sushil Jajodia, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 287-296, </pages> <address> Washington D.C., </address> <month> May </month> <year> 1993. </year> <booktitle> ACM Special Interest Group on Management of Data, </booktitle> <publisher> ACM Press. </publisher>
Reference-contexts: Rexall allows the recognition of situations where the same physical operator is used to compute different logical operators. The two instances of the physical operator can be combined, eliminating the "algorithm" common subexpression. The TI Open OODB <ref> [12] </ref> project has also contributed in the area of plan languages 5 by introducing a materialize operator which can be used to represent navigational object access. Kemper, et al.[54, 55, 53] have focused on extending the notion of indexing to object-oriented systems. <p> Logical and physical expressions are now clearly distinguished in the representation. The TI Open OODB project <ref> [12] </ref> has implemented its query optimizer with the Volcano optimizer generator. One lesson learned from their experience is that it is desirable to be able to manipulate the predicate part of an operator, but they found this hard to do in the Volcano optimizer generator.
Reference: [13] <author> Chee Yong Chan, Beng Chin Ooi, and Hongjun Lu. </author> <title> Extensible buffer management of indexes. </title> <booktitle> In Yuan [92], </booktitle> <pages> pages 444-454. </pages>
Reference-contexts: These hints are used to control buffer page replacement. This kind of hinting has also been applied to indexing structures <ref> [13] </ref>. Cornell and Yu [24] integrate buffer management with the query optimization process including by buffer residency and contention for buffers as a part of the optimization problem.
Reference: [14] <author> Ellis E. Chang and Randy H. Katz. </author> <title> Expliting inheritance and structure semantics for effective clustering and buffering in an object-oriented dbms. </title> <editor> In Clifford et al. </editor> <volume> [19], </volume> <pages> pages 348-357. </pages>
Reference-contexts: There have been many proposals for single and multi-page clusters <ref> [14, 11, 77] </ref>, as well as performance studies of the impact of clustering [49]. There has also been extensive work on methods for deciding which objects to place in a cluster [8, 85, 86].
Reference: [15] <author> Hoichi Cheong and Alexander V. Veidenbaum. </author> <title> Compiler-directed cache management in multiprocessors. </title> <journal> IEEE Computer, </journal> <volume> 23(6) </volume> <pages> 39-47, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Code generation systems based on Bottom Up Rewrite Systems (BURS), like IBURG [33] also use tree pattern matching, but restrict its expressiveness in the interest of efficiency. A little work has been done to try to manage virtual memory [2] or processor cache memory <ref> [15, 16] </ref> at code generation time. The work on virtual memory management was done in the context of FORTRAN, and concentrated on distributing the control of multiple loops and reordering loop indices when performing array operations. The reported speedups are close to an order of magnitude.
Reference: [16] <author> Chi-Hung Chi and Hank Dietz. </author> <title> Unified management of registers and cache using liveness and cache bypass. </title> <booktitle> In SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 344-355, </pages> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year> <journal> ACM Special Interest Group on Programming Languages, ACM Press. Also appears as SIGPLAN Notices Vol. </journal> <volume> 24 No. 7, </volume> <month> July </month> <year> 1989. </year>
Reference-contexts: Code generation systems based on Bottom Up Rewrite Systems (BURS), like IBURG [33] also use tree pattern matching, but restrict its expressiveness in the interest of efficiency. A little work has been done to try to manage virtual memory [2] or processor cache memory <ref> [15, 16] </ref> at code generation time. The work on virtual memory management was done in the context of FORTRAN, and concentrated on distributing the control of multiple loops and reordering loop indices when performing array operations. The reported speedups are close to an order of magnitude.
Reference: [17] <author> Hong-Tai Chou and David J. DeWitt. </author> <title> An evaluation of buffer management strategies for relational database systems. </title> <editor> In A. Pirotte and Y. Vassiliou, editors, </editor> <booktitle> Proceedings of the Eleventh Very Large Databases Conference, </booktitle> <pages> pages 127-141, </pages> <address> Stockholm, </address> <month> August </month> <year> 1985. </year> <title> VLDB, </title> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: Most work on buffer management and query optimization has focused on finding ways to give the buffer manager hints about the way that buffer pages will be used <ref> [74, 75, 17, 71, 30] </ref>. These hints are used to control buffer page replacement. This kind of hinting has also been applied to indexing structures [13].
Reference: [18] <editor> James Clifford and Roger King, editors. </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <address> Denver, Colorado, </address> <month> May </month> <year> 1991. </year> <booktitle> ACM Special Interest Group on Management of Data, </booktitle> <publisher> ACM Press. </publisher>
Reference: [19] <author> James Clifford, Bruce Lindsay, and David Maier, </author> <title> editors. </title> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <address> Portland, Oregon, </address> <month> June </month> <year> 1989. </year> <booktitle> ACM Special Interest Group on Management of Data, </booktitle> <publisher> ACM Press. </publisher> <pages> 48 </pages>
Reference: [20] <author> Sophie Cluet and Claude Delobel. </author> <title> Towards a unification of rewrite based optimization tech-niques for object-oriented queries. Got from GMS, </title> <month> February </month> <year> 1991. </year>
Reference-contexts: Thus, these are really physical level optimizations. There are many more opportunities for common subexpressions to appear in an object oriented query. Therefore recognition and elimination of these common subexpressions is an important optimization. Some work has been done at the source level by Cluet and Delobel <ref> [20] </ref>, but they give no description of how their work impacts the plan generation stage. Lanzelotte, et al. [58, 59, 38, 60] are able to recognize common subexpressions by mapping queries onto the physical schema.
Reference: [21] <author> Sophie Cluet and Guido Moerkotte. </author> <title> Nested queries in object bases. </title> <booktitle> In Beeri [7], </booktitle> <pages> pages </pages> -. 
Reference-contexts: In the database world, Lieuwen [63] has found that performing compiler style analyses on database programming language loops allows those loops to be turned into joins. Cluet & Mo-erkotte <ref> [21] </ref>, in their work on nested queries have found dependency information to be very useful. These parallels make us confident that our techniques will prove useful. 10 2.6 Buffer Management Buffer management has always been a factor that affects the performance of database systems [29].
Reference: [22] <author> Douglas Comer. </author> <title> The ubiquitous B-Tree. </title> <journal> ACM Computing Surveys, </journal> <volume> 11(2) </volume> <pages> 121-137, </pages> <month> June </month> <year> 1979. </year>
Reference-contexts: This can happen when the query optimizer is trying to order the pieces of the query in order to control buffer usage. The Revelation and Volcano optimizers do not attempt to perform such ordering. 2.7.2 Indexing Indexing has been a major data structure used to improve database query performance <ref> [22, 67] </ref>. Indices make use of a search data structure like b-tree to reduce the amount of data that must be 11 searched in order to find the answer to a query.
Reference: [23] <author> Thomas A. Cooper and Nancy Wogrin. </author> <title> Rule-based Programming with OPS5. </title> <publisher> Morgan Kauf-mann Publishers, Inc., </publisher> <address> Los Altos, California, </address> <year> 1988. </year>
Reference: [24] <author> Douglas W. Cornell and Philip S. Yu. </author> <title> Integration of buffer management and query optimization in relational database environment. </title> <booktitle> In Apers and Wiederhold [6], </booktitle> <pages> pages 247-255. </pages>
Reference-contexts: These hints are used to control buffer page replacement. This kind of hinting has also been applied to indexing structures [13]. Cornell and Yu <ref> [24] </ref> integrate buffer management with the query optimization process including by buffer residency and contention for buffers as a part of the optimization problem.
Reference: [25] <author> Scott Daniels, Goetz Graefe, Thomas Keller, David Maier, Duri Schmidt, and Bennet Vance. </author> <title> Query optimization in Revelation, an overview. </title> <journal> Quarterly Bulletin of the IEEE Computer Society technical committee on Data Engineering, </journal> <volume> 14(2) </volume> <pages> 58-62, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: There is a single implementation for each operator, and all variations in plans essentially come via permutations of arguments. As part of the Revelation <ref> [45, 25, 87] </ref>, Bennet Vance has developed Rexall [88], a functional plan language with support for objects. Rexall allows the recognition of situations where the same physical operator is used to compute different logical operators. The two instances of the physical operator can be combined, eliminating the "algorithm" common subexpression.
Reference: [26] <editor> Umeshwar Dayal and Irv Traiger, editors. </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <address> San Francisco, California, </address> <month> May </month> <year> 1987. </year> <journal> ACM Special Interest Group on Management of Data, </journal> <note> ACM Press. Also Appears as SIGMOD Record, Vol. 16 No. 3, </note> <month> December </month> <year> 1987. </year>
Reference: [27] <editor> Alan Dearle, Gail M. Shaw, and Stanley B. Zdonik, editors. </editor> <booktitle> Proceedings of the Fourth International Workshop on Persistent Object Systems Implementing Persistent Object Bases:Principles and Practice, </booktitle> <address> Martha's Vineyard, MA, </address> <month> September </month> <year> 1990. </year>
Reference: [28] <editor> C. Delobel, M. Kifer, and Y. Matsunaga, editors. </editor> <booktitle> Proceedings of the The Second International Conference on Deductive and Object-Oriented Databases, number 566 in Lecture Notes in Computer Science, </booktitle> <address> Munich, Germany, </address> <month> December </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference: [29] <author> Wolfgang Effelsberg and Theo Haerder. </author> <title> Principles of database buffer management. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(4) </volume> <pages> 560-595, </pages> <month> December </month> <year> 1984. </year>
Reference-contexts: Cluet & Mo-erkotte [21], in their work on nested queries have found dependency information to be very useful. These parallels make us confident that our techniques will prove useful. 10 2.6 Buffer Management Buffer management has always been a factor that affects the performance of database systems <ref> [29] </ref>. Most work on buffer management and query optimization has focused on finding ways to give the buffer manager hints about the way that buffer pages will be used [74, 75, 17, 71, 30]. These hints are used to control buffer page replacement.
Reference: [30] <author> Christos Faloutso, Raymond Ng, and Timos Sellis. </author> <title> Predictive load control for flexible buffer allocation. </title> <editor> In Lohman et al. </editor> <volume> [65], </volume> <pages> pages 265-274. </pages>
Reference-contexts: Most work on buffer management and query optimization has focused on finding ways to give the buffer manager hints about the way that buffer pages will be used <ref> [74, 75, 17, 71, 30] </ref>. These hints are used to control buffer page replacement. This kind of hinting has also been applied to indexing structures [13].
Reference: [31] <author> Leonidas Fegaras, David Maier, and Tim Sheard. </author> <title> Specifying rule-based query optimizers in a reflective framework. </title> <booktitle> In Proceedings of the The Third International Conference on Deductive and Object-Oriented Databases, </booktitle> <address> Scottsdale, Arizona, </address> <month> December </month> <year> 1993. </year>
Reference: [32] <author> Charles N. Fischer and Jr Richard J. LeBlanc. </author> <title> Crafting a Compiler in C. </title> <publisher> Benjamin Cummings Publishing Company, Inc, </publisher> <address> Menlo Park, California, </address> <year> 1991. </year>
Reference-contexts: If information about the dependency relationships between the two path expressions was available, it could be used to make a better decision about whether a path should be P or P1. In compilers <ref> [5, 32] </ref>, attribute grammars are used to declaratively compute and propagate information up and down abstract syntax trees. This information is then available for use during optimization and code generation.
Reference: [33] <author> Christopher W. Fraser, David R. Hanson, and Todd A. Proebsting. </author> <title> Engineering a simple, efficient code-generator generator. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(3) </volume> <pages> 213-226, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Their tree language is fairly simple in comparison to our tree query language, but it allows them to specify code generation and improvement in terms of tree creation and tree transformation. Code generation systems based on Bottom Up Rewrite Systems (BURS), like IBURG <ref> [33] </ref> also use tree pattern matching, but restrict its expressiveness in the interest of efficiency. A little work has been done to try to manage virtual memory [2] or processor cache memory [15, 16] at code generation time.
Reference: [34] <author> Johann Christoph Freytag. </author> <title> A rule-based view of query optimization. </title> <booktitle> In Dayal and Traiger [26], </booktitle> <pages> pages 173-180. </pages> <note> Also Appears as SIGMOD Record, Vol. 16 No. 3, </note> <month> December </month> <year> 1987. </year> <month> 49 </month>
Reference-contexts: The key components in a rule based optimizer are the language for describing rules, the search strategy, and the rules themselves. Rule based optimization was first suggested by Freytag <ref> [34, 36, 35] </ref>. His initial proposal calls for two layers, where the first layer rewrites the Lisp-like intermediate representation of the query. The rewriting phase does not distinguish between source and physical rules, although it possesses both. The second layer translates the intermediate representation into an iterative program.
Reference: [35] <author> Johann Christoph Freytag and Nathan Goodman. </author> <title> Translating aggregate queries into iterative programs. </title> <editor> In Wesley Chu, Georges Gadarin, Setsuo Ohsuga, and Yahko Kambayashi, editors, </editor> <booktitle> Proceedings of the Twelfth Very Large Databases Conference, </booktitle> <pages> pages 138-146, </pages> <address> Kyoto, Japan, </address> <month> August </month> <year> 1986. </year> <title> VLDB, </title> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: The key components in a rule based optimizer are the language for describing rules, the search strategy, and the rules themselves. Rule based optimization was first suggested by Freytag <ref> [34, 36, 35] </ref>. His initial proposal calls for two layers, where the first layer rewrites the Lisp-like intermediate representation of the query. The rewriting phase does not distinguish between source and physical rules, although it possesses both. The second layer translates the intermediate representation into an iterative program.
Reference: [36] <author> Johann Christoph Freytag and Nathan Goodman. </author> <title> On the translation of relational queries into iterative programs. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(1) </volume> <pages> 1-27, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: The key components in a rule based optimizer are the language for describing rules, the search strategy, and the rules themselves. Rule based optimization was first suggested by Freytag <ref> [34, 36, 35] </ref>. His initial proposal calls for two layers, where the first layer rewrites the Lisp-like intermediate representation of the query. The rewriting phase does not distinguish between source and physical rules, although it possesses both. The second layer translates the intermediate representation into an iterative program.
Reference: [37] <editor> Hector Garcia-Molina and H.V. Jagadish, editors. </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <address> Atlantic City, New Jersey, </address> <month> May </month> <year> 1990. </year> <booktitle> ACM Special Interest Group on Management of Data, </booktitle> <publisher> ACM Press. </publisher>
Reference: [38] <author> Georges Gardarin and Rosana S. G. Lanzelotte. </author> <title> Optimizing object-oriented database queries using cost-controlled rewriting. </title> <editor> In A. Pirotte, C. Delobel, and G. Gottlob, editors, </editor> <booktitle> Proceedings of the Third International Conference on Extending Database Technology, number 580 in Lecture Notes in Computer Science, </booktitle> <pages> pages 534-549, </pages> <address> Vienna, Austria, March 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Therefore recognition and elimination of these common subexpressions is an important optimization. Some work has been done at the source level by Cluet and Delobel [20], but they give no description of how their work impacts the plan generation stage. Lanzelotte, et al. <ref> [58, 59, 38, 60] </ref> are able to recognize common subexpressions by mapping queries onto the physical schema. Common subexpressions in path expressions appear in the class connection graph, a result of this mapping process. <p> Common subexpressions in path expressions appear in the class connection graph, a result of this mapping process. As previously mentioned, Kemper et al.[55] can eliminate common subexpressions that appear via access support relations, and Rexall [88] can be used to recognize "algorithmic" common subexpressions. Lanzelotte, et al. <ref> [58, 59, 38, 60] </ref> took the first step towards rewriting at the physical level by mapping their queries onto the schema. This is done using two data structures, the class connection graph and the physical schema graph.
Reference: [39] <author> Goetz Graefe. </author> <title> Rule-Based Query Optimization in Extensbile Database Systems. </title> <type> PhD thesis, </type> <institution> Computer Sciences Department, University of Wisconsin-Madison, Madison, WI 53706, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: The rewriting phase does not distinguish between source and physical rules, although it possesses both. The second layer translates the intermediate representation into an iterative program. The next advance in rule based optimization came with the Exodus optimizer generator <ref> [41, 39] </ref>. This system allows a database system implementor to generate a query optimizer from a set of grammar like rewrite rules. The rule language is grammar like, with the addition that rules may 7 have an associated condition that determines whether or not the rule is applicable.
Reference: [40] <author> Goetz Graefe. </author> <title> Query evaluation techniques for large databases. </title> <journal> ACM Computing Surveys, </journal> <pages> pages 73-170, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: There is also room at the physical level for algebraic common subexpressions [88]. Many algebra operators can be implemented by using the same algorithm with different parameters <ref> [40, 88] </ref>, or as combinations of basic building block algorithms. An example illustrated in the Rexall paper [88] is the expression sum (A " B) sum (A B). This expression can be optimized if we note that that intersection and difference can both implemented using hash join.
Reference: [41] <author> Goetz Graefe and David J. DeWitt. </author> <title> The EXODUS optimizer generator. </title> <booktitle> In Dayal and Traiger [26], </booktitle> <pages> pages 160-172. </pages> <note> Also Appears as SIGMOD Record, Vol. 16 No. 3, </note> <month> December </month> <year> 1987. </year>
Reference-contexts: The rewriting phase does not distinguish between source and physical rules, although it possesses both. The second layer translates the intermediate representation into an iterative program. The next advance in rule based optimization came with the Exodus optimizer generator <ref> [41, 39] </ref>. This system allows a database system implementor to generate a query optimizer from a set of grammar like rewrite rules. The rule language is grammar like, with the addition that rules may 7 have an associated condition that determines whether or not the rule is applicable. <p> Rules are classified as transformation (source to source) or implementation (source to physical) rules, but no physical to physical rules are used. The rule language does not allow the predicate to be manipulated. The Volcano optimizer generator [43, 42] is the successor to the Exodus optimizer generator <ref> [41] </ref>. The major features introduced in Volcano are improvement of the search strategy, implementation of cost as an abstract data type, ability to memoize the results of previous optimizations, and the use of enforcers and physical property vectors to force the plan generator to make particular choices. <p> The source to physical rules are guided by information from the database catalogs. Some of that information can be used to compute cost measures. This process is shown in figure 1. The rule languages for the source to source and source to physical rules are usually the same <ref> [41, 42] </ref>, 12 with Starburst [47] being a notable exception. Each rule language requires its own rule evaluation engine. Our approach to plan generation extends the process and adds an additional step to this process.
Reference: [42] <author> Goetz Graefe and Willam J. McKenna. </author> <title> The Volcano optimizer generator: Extensibility and efficient search. </title> <booktitle> In Proceedings of the Ningth International Conference on Data Engineering, </booktitle> <pages> pages 209-218, </pages> <address> Vienna, Austria, April 1993. </address> <publisher> IEEE, IEEE Computer Society Press. </publisher>
Reference-contexts: The physical schema graph makes the indexing and clustering relationships between actual files in the database explicit. 6 Once these data structures have been created, the query is optimized by generating plans from the data structures. Both Volcano <ref> [43, 42] </ref> and Starburst [46] try to give the buffer manager hints about the way the queries will access buffer pages. <p> Rules are classified as transformation (source to source) or implementation (source to physical) rules, but no physical to physical rules are used. The rule language does not allow the predicate to be manipulated. The Volcano optimizer generator <ref> [43, 42] </ref> is the successor to the Exodus optimizer generator [41]. <p> The source to physical rules are guided by information from the database catalogs. Some of that information can be used to compute cost measures. This process is shown in figure 1. The rule languages for the source to source and source to physical rules are usually the same <ref> [41, 42] </ref>, 12 with Starburst [47] being a notable exception. Each rule language requires its own rule evaluation engine. Our approach to plan generation extends the process and adds an additional step to this process.
Reference: [43] <author> Goetz Graefe and William McKenna. </author> <title> The Volcano optimizer generator. </title> <type> Technical Report 563, </type> <institution> University of Colorado at Boulder, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: The physical schema graph makes the indexing and clustering relationships between actual files in the database explicit. 6 Once these data structures have been created, the query is optimized by generating plans from the data structures. Both Volcano <ref> [43, 42] </ref> and Starburst [46] try to give the buffer manager hints about the way the queries will access buffer pages. <p> Rules are classified as transformation (source to source) or implementation (source to physical) rules, but no physical to physical rules are used. The rule language does not allow the predicate to be manipulated. The Volcano optimizer generator <ref> [43, 42] </ref> is the successor to the Exodus optimizer generator [41].
Reference: [44] <author> Goetz Graefe and Karen Ward. </author> <title> Dynamic query evaluation plans. </title> <editor> In Clifford et al. </editor> <volume> [19], </volume> <pages> pages 358-366. </pages>
Reference-contexts: The current language is a compromise. The partition operator allows some but not all of the control allowed by the assembly language, but the current quasi-functional language makes rule pattern matching more reasonable. It should be easy to adapt other plan language level proposals like dynamic query plans <ref> [44] </ref> and object assembly [51] fit into this framework.
Reference: [45] <author> Goetz Grafe, David Maier, Scott Daniels, and Tom Keller. </author> <title> A software architecture for efficient query processing in object-oriented database systems with encapsulated behavior. </title> <note> Got via FTP. </note>
Reference-contexts: There is a single implementation for each operator, and all variations in plans essentially come via permutations of arguments. As part of the Revelation <ref> [45, 25, 87] </ref>, Bennet Vance has developed Rexall [88], a functional plan language with support for objects. Rexall allows the recognition of situations where the same physical operator is used to compute different logical operators. The two instances of the physical operator can be combined, eliminating the "algorithm" common subexpression.
Reference: [46] <author> Laura M. Haas, Walter Chang, Guy M. Lohman, John McPherson, Paul F. Wilms, George Lapis, Bruce Lindsay, Hamid Pirahesh, Michael J. Carey, and Eugene Shekita. </author> <title> Starburst mid-flight: As the dust clears. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 143-160, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: The physical schema graph makes the indexing and clustering relationships between actual files in the database explicit. 6 Once these data structures have been created, the query is optimized by generating plans from the data structures. Both Volcano [43, 42] and Starburst <ref> [46] </ref> try to give the buffer manager hints about the way the queries will access buffer pages. <p> One lesson learned from their experience is that it is desirable to be able to manipulate the predicate part of an operator, but they found this hard to do in the Volcano optimizer generator. The Starburst <ref> [46, 47, 73, 64, 61] </ref> extensible database system separates query optimization into two levels, query rewrite and plan optimization. The system uses a different rule language for describing the processing at each level.
Reference: [47] <author> Laura M. Haas, J. C. Freytag, G. M. Lohman, and H. Pirahesh. </author> <title> Extensible query processing in Starburst. </title> <editor> In Clifford et al. </editor> <volume> [19], </volume> <pages> pages 377-388. </pages>
Reference-contexts: One lesson learned from their experience is that it is desirable to be able to manipulate the predicate part of an operator, but they found this hard to do in the Volcano optimizer generator. The Starburst <ref> [46, 47, 73, 64, 61] </ref> extensible database system separates query optimization into two levels, query rewrite and plan optimization. The system uses a different rule language for describing the processing at each level. <p> Some of that information can be used to compute cost measures. This process is shown in figure 1. The rule languages for the source to source and source to physical rules are usually the same [41, 42], 12 with Starburst <ref> [47] </ref> being a notable exception. Each rule language requires its own rule evaluation engine. Our approach to plan generation extends the process and adds an additional step to this process. Since our work is a part of the EPOQ [69] project, the source to source transformation is performed by regions.
Reference: [48] <editor> IEEE. </editor> <booktitle> Proceedings of the Seventh International Conference on Data Engineering, </booktitle> <address> Kobe, Japan, April 1991. </address> <publisher> IEEE Computer Society Press. </publisher> <pages> 50 </pages>
Reference: [49] <author> Anant Jhingran and Michael Stonebraker. </author> <title> Alternatives in complex object representation: A performance perspective. </title> <booktitle> In Proceedings of the Sixth International Conference on Data Engineering, </booktitle> <pages> pages 94-102, </pages> <address> Los Angeles, California, </address> <month> February </month> <year> 1990. </year> <title> IEEE, </title> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: There have been many proposals for single and multi-page clusters [14, 11, 77], as well as performance studies of the impact of clustering <ref> [49] </ref>. There has also been extensive work on methods for deciding which objects to place in a cluster [8, 85, 86].
Reference: [50] <author> Paris Kanellakis and Joachim W. Schmidt, </author> <title> editors. Bulk Types & Persistent Data: </title> <booktitle> The Third International Workshop on Database Programming Languages, </booktitle> <address> Nafplion, Greece, August 1991. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference: [51] <author> Tim Keller, Goetz Graefe, and David Maier. </author> <title> Efficient assembly of complex objects. </title> <booktitle> In Clifford and King [18], </booktitle> <pages> pages 148-157. </pages>
Reference-contexts: Their techniques were developed in the context of the relational model and focus primarily on improving the performance of joins. 2.7 OODB Access Structures 2.7.1 Assembly Object assembly <ref> [51, 52] </ref> is an operator which is used to retrieve objects in a set-oriented manner | that is | other than one at a time. <p> The partition operator allows some but not all of the control allowed by the assembly language, but the current quasi-functional language makes rule pattern matching more reasonable. It should be easy to adapt other plan language level proposals like dynamic query plans [44] and object assembly <ref> [51] </ref> fit into this framework.
Reference: [52] <author> Tom Keller and Goetz Graefe. </author> <title> The one-to-one match operator of the Volcano query processing system. </title> <type> Technical Report CS/E 89-009, </type> <institution> Oregon Graduate Institute of Science and Technology, </institution> <month> June </month> <year> 1989. </year>
Reference-contexts: Their techniques were developed in the context of the relational model and focus primarily on improving the performance of joins. 2.7 OODB Access Structures 2.7.1 Assembly Object assembly <ref> [51, 52] </ref> is an operator which is used to retrieve objects in a set-oriented manner | that is | other than one at a time.
Reference: [53] <author> Alfons Kemper, Christoph Kilger, and Guido Moerkotte. </author> <title> Function materialization in object bases. </title> <booktitle> In Clifford and King [18], </booktitle> <pages> pages 258-267. </pages>
Reference: [54] <author> Alfons Kemper and Guido Moerkotte. </author> <title> Access support in object bases. </title> <booktitle> In Garcia-Molina and Jagadish [37], </booktitle> <pages> pages 364-376. </pages>
Reference-contexts: Indices make use of a search data structure like b-tree to reduce the amount of data that must be 11 searched in order to find the answer to a query. There have been a number of proposals for indices in object-oriented databases <ref> [68, 10, 9, 93, 54, 55] </ref>, each with their own strengths and weaknesses.
Reference: [55] <author> Alfons Kemper and Guido Moerkotte. </author> <title> Advanced query processing in object bases using access support relations. </title> <editor> In Dennis McLeod, Ron Sacks-Davis, and Hans Schek, editors, </editor> <booktitle> Proceedings of the 16th International Conference on Very Large Data Bases, </booktitle> <pages> pages 290-301, </pages> <address> Brisbane, Australia, August 1990. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: Indices make use of a search data structure like b-tree to reduce the amount of data that must be 11 searched in order to find the answer to a query. There have been a number of proposals for indices in object-oriented databases <ref> [68, 10, 9, 93, 54, 55] </ref>, each with their own strengths and weaknesses.
Reference: [56] <author> Alfons Kemper, Guido Moerkotte, and Klaus Peithner. </author> <title> A blackboard architecture for query optimization in object bases. </title> <editor> In Rakesh Agrawal, Sean Baker, and David Bell, editors, </editor> <booktitle> Proceedings of the 19th International Conference on Very Large Data Bases, </booktitle> <pages> pages 543-554, </pages> <address> Dublin, Ireland, August 1993. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference: [57] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Weinreb. </author> <title> The ObjectStore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Relational plan generation is the choice of access path and algorithm. Some have claimed that the problem is simpler in object-oriented databases. The ObjectStore system <ref> [57, 72] </ref> selects from one of two query evaluation strategies based on whether or not an index is available. The system designers claim that the presence of paths and indexes on paths make optimization of joins much less important, but this is only true for pointer-based joins [78].
Reference: [58] <author> R. S. G. Lanzelotte, P. Valduriez, M. Ziane, and J.-P. Cheiney. </author> <title> Optimization of nonrecursive queries in OODBs. </title> <editor> In Delobel et al. </editor> <volume> [28], </volume> <pages> pages 1-21. </pages>
Reference-contexts: Therefore recognition and elimination of these common subexpressions is an important optimization. Some work has been done at the source level by Cluet and Delobel [20], but they give no description of how their work impacts the plan generation stage. Lanzelotte, et al. <ref> [58, 59, 38, 60] </ref> are able to recognize common subexpressions by mapping queries onto the physical schema. Common subexpressions in path expressions appear in the class connection graph, a result of this mapping process. <p> Common subexpressions in path expressions appear in the class connection graph, a result of this mapping process. As previously mentioned, Kemper et al.[55] can eliminate common subexpressions that appear via access support relations, and Rexall [88] can be used to recognize "algorithmic" common subexpressions. Lanzelotte, et al. <ref> [58, 59, 38, 60] </ref> took the first step towards rewriting at the physical level by mapping their queries onto the schema. This is done using two data structures, the class connection graph and the physical schema graph.
Reference: [59] <author> Rosana S. G. Lanzelotte and Jean-Pierre Cheiney. </author> <title> Adapting relational optimization technology to object-oriented and deductive database languages. </title> <booktitle> In Kanellakis and Schmidt [50], </booktitle> <pages> pages 322-336. </pages>
Reference-contexts: Ingres [80] 4 uses a very unsophisticated plan generator which handles one variable queries only. The Ingres optimization algorithm [91] decomposes multi-variable queries into single variable queries. 2.2 Plan Generation in Object-Oriented Systems Plan generators for object-oriented databases have continued where relational systems left off. Lanzelotte and her colleagues <ref> [59] </ref> state, "database query optimization is finding an optimal join permutation, together with the choice of an access path for each relation and an algorithm for each join and selection operator". Relational plan generation is the choice of access path and algorithm. <p> Therefore recognition and elimination of these common subexpressions is an important optimization. Some work has been done at the source level by Cluet and Delobel [20], but they give no description of how their work impacts the plan generation stage. Lanzelotte, et al. <ref> [58, 59, 38, 60] </ref> are able to recognize common subexpressions by mapping queries onto the physical schema. Common subexpressions in path expressions appear in the class connection graph, a result of this mapping process. <p> Common subexpressions in path expressions appear in the class connection graph, a result of this mapping process. As previously mentioned, Kemper et al.[55] can eliminate common subexpressions that appear via access support relations, and Rexall [88] can be used to recognize "algorithmic" common subexpressions. Lanzelotte, et al. <ref> [58, 59, 38, 60] </ref> took the first step towards rewriting at the physical level by mapping their queries onto the schema. This is done using two data structures, the class connection graph and the physical schema graph.
Reference: [60] <author> Rosana S. G. Lanzelotte, Patrick Valduriez, and Mohamed Zait. </author> <title> Optimization of object-oriented recursive queries using cost-controlled strategies. </title> <booktitle> In Stonebraker [79], </booktitle> <pages> pages 256-257. </pages>
Reference-contexts: Therefore recognition and elimination of these common subexpressions is an important optimization. Some work has been done at the source level by Cluet and Delobel [20], but they give no description of how their work impacts the plan generation stage. Lanzelotte, et al. <ref> [58, 59, 38, 60] </ref> are able to recognize common subexpressions by mapping queries onto the physical schema. Common subexpressions in path expressions appear in the class connection graph, a result of this mapping process. <p> Common subexpressions in path expressions appear in the class connection graph, a result of this mapping process. As previously mentioned, Kemper et al.[55] can eliminate common subexpressions that appear via access support relations, and Rexall [88] can be used to recognize "algorithmic" common subexpressions. Lanzelotte, et al. <ref> [58, 59, 38, 60] </ref> took the first step towards rewriting at the physical level by mapping their queries onto the schema. This is done using two data structures, the class connection graph and the physical schema graph.
Reference: [61] <author> Mavis K. Lee, Johann Cristoph Freytag, and Guy M. Lohman. </author> <title> Implementing an interpreter for functional rules in a query optimizer. </title> <editor> In Francois Bancilhon and David J. DeWitt, editors, </editor> <booktitle> Proceedings of the Fourteenth Very Large Databases Conference, </booktitle> <pages> pages 218-229, </pages> <address> Los Angeles, California, </address> <month> August </month> <year> 1988. </year> <title> VLDB Endowment, </title> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: One lesson learned from their experience is that it is desirable to be able to manipulate the predicate part of an operator, but they found this hard to do in the Volcano optimizer generator. The Starburst <ref> [46, 47, 73, 64, 61] </ref> extensible database system separates query optimization into two levels, query rewrite and plan optimization. The system uses a different rule language for describing the processing at each level.
Reference: [62] <author> Theodore W. Leung, Gail Mitchell, Bharathi Subramanian, Bennet Vance, Scott L. Vanden-berg, and Stanley B. Zdonik. </author> <title> The AQUA data model and algebra. </title> <booktitle> In Beeri [7]. </booktitle> <pages> 51 </pages>
Reference-contexts: The EREQ project has developed an object-oriented query algebra, AQUA, <ref> [62] </ref>, which is the input language for the EPOQ [69] optimizer being developed at Brown. The output of the source level optimization component of EPOQ is the input to our plan generation system.
Reference: [63] <author> Daniel F. Lieuwen and David J. DeWitt. </author> <title> Optimizing loops in database programming languages. </title> <booktitle> In Kanellakis and Schmidt [50], </booktitle> <pages> pages 287-305. </pages>
Reference-contexts: The reported speedups are close to an order of magnitude. Compiler directed cache management views the cache as an extension of the register set and attempts to apply generalized register management techniques to manage the cache. In the database world, Lieuwen <ref> [63] </ref> has found that performing compiler style analyses on database programming language loops allows those loops to be turned into joins. Cluet & Mo-erkotte [21], in their work on nested queries have found dependency information to be very useful.
Reference: [64] <author> Guy H. Lohman. </author> <title> Grammar-like functional rules for representing query optimization alternatives. </title> <editor> In Haran Boral and Per ake Larson, editors, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 18-27, </pages> <address> Chicago, Illinois, </address> <month> June </month> <year> 1988. </year> <journal> ACM Special Interest Group on Management of Data, </journal> <note> ACM Press. Also appears as SIGMOD Record Vol. 17 No. 3, </note> <month> September </month> <year> 1988. </year>
Reference-contexts: One lesson learned from their experience is that it is desirable to be able to manipulate the predicate part of an operator, but they found this hard to do in the Volcano optimizer generator. The Starburst <ref> [46, 47, 73, 64, 61] </ref> extensible database system separates query optimization into two levels, query rewrite and plan optimization. The system uses a different rule language for describing the processing at each level.
Reference: [65] <editor> Guy M. Lohman, Amilcar Sernadas, and Rafael Camps, editors. </editor> <booktitle> Proceedings of the 17th International Conference on Very Large Data Bases, </booktitle> <address> Barcelona (Catalonia, Spain), August 1991. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference: [66] <author> Andrew C.T. MacKeith. </author> <title> Ereq query representation and cost model. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, Brown University, </institution> <address> Providence, Rhode Island 02912-1910, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: The algebra includes a treatment of user defined equality. Predicates can invoke methods on elements of a set. The choose operator nondeterministically selects one element from a set. The EPOQ optimizer delivers the query to the plan generator in an intermediate form, the EPOQ query rep (hereafter query rep) <ref> [69, 66] </ref>. This representation is used to represent the query both in source form, and in physical plan form. The query rep is a tree-like data structure, where operators or functions are represented as function nodes which take data nodes as their inputs and produce data nodes as their outputs.
Reference: [67] <author> Lothar F. Mackert and Guy M. Lohman. </author> <title> R* optimizer validation and performance evaluation for local queries. </title> <editor> In Carlo Zaniolo, editor, </editor> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 84-95, </pages> <address> Washington, D.C., </address> <month> June </month> <year> 1986. </year> <journal> ACM Special Interest Group on Management of Data, </journal> <note> ACM Press. Also Appears as SIGMOD Record, Vol. 15 No. 2, </note> <month> June </month> <year> 1986. </year>
Reference-contexts: This can happen when the query optimizer is trying to order the pieces of the query in order to control buffer usage. The Revelation and Volcano optimizers do not attempt to perform such ordering. 2.7.2 Indexing Indexing has been a major data structure used to improve database query performance <ref> [22, 67] </ref>. Indices make use of a search data structure like b-tree to reduce the amount of data that must be 11 searched in order to find the answer to a query.
Reference: [68] <author> David Maier and Jacob Stein. </author> <title> Indexing in an object-oriented database. </title> <booktitle> In Proceedings of the International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 171-182, </pages> <address> Pacific Grove, California, </address> <month> September </month> <year> 1986. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: Indices make use of a search data structure like b-tree to reduce the amount of data that must be 11 searched in order to find the answer to a query. There have been a number of proposals for indices in object-oriented databases <ref> [68, 10, 9, 93, 54, 55] </ref>, each with their own strengths and weaknesses.
Reference: [69] <author> Gail Mitchell. </author> <title> Extensible Query Processing in an Object-Oriented Database. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Brown University, </institution> <address> Providence, Rhode Island 02912-1910, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Also, ML's pattern matching is not as expressive as our tree query language. 2.4 Other Extensible optimizers Extensible optimizers which are not based on rules have also been proposed. The EPOQ optimizer <ref> [69, 70] </ref> modularizes the set of optimizations available to the optimizer. These modules are called regions, with each region providing a specific optimization service to the optimizer. A region is viewed as a black box which responds to a protocol and which operates on an annotated common representation for queries. <p> Each rule language requires its own rule evaluation engine. Our approach to plan generation extends the process and adds an additional step to this process. Since our work is a part of the EPOQ <ref> [69] </ref> project, the source to source transformation is performed by regions. Some of the regions may be implemented in a rule-based fashion, but others may not be. <p> The EREQ project has developed an object-oriented query algebra, AQUA, [62], which is the input language for the EPOQ <ref> [69] </ref> optimizer being developed at Brown. The output of the source level optimization component of EPOQ is the input to our plan generation system. In this section, we present the parts of AQUA necessary to understand the examples presented in the rest of the paper. <p> The algebra includes a treatment of user defined equality. Predicates can invoke methods on elements of a set. The choose operator nondeterministically selects one element from a set. The EPOQ optimizer delivers the query to the plan generator in an intermediate form, the EPOQ query rep (hereafter query rep) <ref> [69, 66] </ref>. This representation is used to represent the query both in source form, and in physical plan form. The query rep is a tree-like data structure, where operators or functions are represented as function nodes which take data nodes as their inputs and produce data nodes as their outputs.
Reference: [70] <author> Gail Mitchell, Stanley B. Zdonik, and Umeshwar Dayal. </author> <title> An architecture for query processing in persistent object stores. </title> <booktitle> In Proceedings of the Twenty-Fifth Annual Hawaii International Conference on System Sciences. </booktitle> <publisher> IEEE, IEEE Computer Society Press, </publisher> <month> January </month> <year> 1991. </year>
Reference-contexts: Also, ML's pattern matching is not as expressive as our tree query language. 2.4 Other Extensible optimizers Extensible optimizers which are not based on rules have also been proposed. The EPOQ optimizer <ref> [69, 70] </ref> modularizes the set of optimizations available to the optimizer. These modules are called regions, with each region providing a specific optimization service to the optimizer. A region is viewed as a black box which responds to a protocol and which operates on an annotated common representation for queries.
Reference: [71] <author> Raymond Ng, Christos Faloutsos, and Timos Sellis. </author> <title> Flexible buffer allocation based on marginal gains. </title> <booktitle> In Clifford and King [18], </booktitle> <pages> pages 387-396. </pages>
Reference-contexts: Most work on buffer management and query optimization has focused on finding ways to give the buffer manager hints about the way that buffer pages will be used <ref> [74, 75, 17, 71, 30] </ref>. These hints are used to control buffer page replacement. This kind of hinting has also been applied to indexing structures [13].
Reference: [72] <author> Jack Orenstein, Sam Haradhvala, Benson Margulies, and Don Sakahara. </author> <title> Query processing in the ObjectStore database system. </title> <booktitle> In Stonebraker [79], </booktitle> <pages> pages 403-412. </pages>
Reference-contexts: Relational plan generation is the choice of access path and algorithm. Some have claimed that the problem is simpler in object-oriented databases. The ObjectStore system <ref> [57, 72] </ref> selects from one of two query evaluation strategies based on whether or not an index is available. The system designers claim that the presence of paths and indexes on paths make optimization of joins much less important, but this is only true for pointer-based joins [78].
Reference: [73] <author> Hamid Pirahesh, Joseph M. Hellerstein, and Waqar Hasan. </author> <title> Extensible/rule based query rewrite optimization in Starburst. </title> <booktitle> In Stonebraker [79], </booktitle> <pages> pages 39-48. </pages>
Reference-contexts: One lesson learned from their experience is that it is desirable to be able to manipulate the predicate part of an operator, but they found this hard to do in the Volcano optimizer generator. The Starburst <ref> [46, 47, 73, 64, 61] </ref> extensible database system separates query optimization into two levels, query rewrite and plan optimization. The system uses a different rule language for describing the processing at each level.
Reference: [74] <author> Giovanni Maria Sacco and Mario Schkolnick. </author> <title> A mechanism for managing the buffer pool in a relational database system using the hot set model. </title> <booktitle> In Proceedings of the Eighth International Conference on Very Large Databases, </booktitle> <pages> pages 257-262, </pages> <address> Mexico City, Mexico, </address> <month> September </month> <year> 1982. </year> <title> VLDB, </title> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference-contexts: Most work on buffer management and query optimization has focused on finding ways to give the buffer manager hints about the way that buffer pages will be used <ref> [74, 75, 17, 71, 30] </ref>. These hints are used to control buffer page replacement. This kind of hinting has also been applied to indexing structures [13].
Reference: [75] <author> Giovanni Maria Sacco and Mario Schkolnick. </author> <title> Buffer management in relational database systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 11(4) </volume> <pages> 473-498, </pages> <month> December </month> <year> 1986. </year> <month> 52 </month>
Reference-contexts: Most work on buffer management and query optimization has focused on finding ways to give the buffer manager hints about the way that buffer pages will be used <ref> [74, 75, 17, 71, 30] </ref>. These hints are used to control buffer page replacement. This kind of hinting has also been applied to indexing structures [13].
Reference: [76] <author> P. Griffiths Selinger, M. M. Astrahan, D. D. Chamberlin, R. A. Lorie, and T. G. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 23-34. </pages> <booktitle> ACM Special Interest Group on Management of Data, </booktitle> <publisher> ACM Press, </publisher> <year> 1979. </year>
Reference-contexts: This approach was first described in System R <ref> [76] </ref>. Ingres [80] 4 uses a very unsophisticated plan generator which handles one variable queries only. The Ingres optimization algorithm [91] decomposes multi-variable queries into single variable queries. 2.2 Plan Generation in Object-Oriented Systems Plan generators for object-oriented databases have continued where relational systems left off.
Reference: [77] <author> Karen Shannon and Richard Snodgrass. </author> <title> Semantic clustering. </title> <editor> In Dearle et al. </editor> <volume> [27], </volume> <pages> pages 389-402. </pages>
Reference-contexts: There have been many proposals for single and multi-page clusters <ref> [14, 11, 77] </ref>, as well as performance studies of the impact of clustering [49]. There has also been extensive work on methods for deciding which objects to place in a cluster [8, 85, 86].
Reference: [78] <author> Eugene J. Shekita and Michael J. Carey. </author> <title> A performance evaluation of pointer-based joins. </title> <booktitle> In Garcia-Molina and Jagadish [37], </booktitle> <pages> pages 300-311. </pages>
Reference-contexts: The system designers claim that the presence of paths and indexes on paths make optimization of joins much less important, but this is only true for pointer-based joins <ref> [78] </ref>. One of the points of departure for object-oriented systems has been experimentation with different plan languages and representations. This has occurred because there are additional concepts to be modeled at the physical level.
Reference: [79] <author> Michael Stonebraker, </author> <title> editor. </title> <booktitle> Proceedings of the SIGMOD International Conference on Management of Data, </booktitle> <address> San Diego, California, </address> <month> June </month> <year> 1992. </year> <booktitle> ACM Special Interest Group on Management of Data, </booktitle> <publisher> ACM Press. </publisher>
Reference: [80] <author> Michael Stonebraker, Eugene Wong, Peter Greps, and Gerald Held. </author> <title> The design and implementation of Ingres. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(3) </volume> <pages> 180-222, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: This approach was first described in System R [76]. Ingres <ref> [80] </ref> 4 uses a very unsophisticated plan generator which handles one variable queries only. The Ingres optimization algorithm [91] decomposes multi-variable queries into single variable queries. 2.2 Plan Generation in Object-Oriented Systems Plan generators for object-oriented databases have continued where relational systems left off.
Reference: [81] <author> Dave D. Straube and M. Tamer Ozsu. </author> <title> Execution plan generation for an object-oriented data model. </title> <editor> In Delobel et al. </editor> <volume> [28], </volume> <pages> pages 43-67. </pages>
Reference-contexts: One of the points of departure for object-oriented systems has been experimentation with different plan languages and representations. This has occurred because there are additional concepts to be modeled at the physical level. Straube and Ozsu <ref> [82, 83, 81] </ref> use a "processing template" operating on streams of tuples of object identifiers to represent their plans. Each processing template represents a set of alternative plans.
Reference: [82] <author> David D. Straube. </author> <title> Queries and Query Processing in Object-Oriented Database Systems. </title> <type> PhD thesis, </type> <institution> Univeristy of Alberta, </institution> <month> December </month> <year> 1990. </year>
Reference-contexts: One of the points of departure for object-oriented systems has been experimentation with different plan languages and representations. This has occurred because there are additional concepts to be modeled at the physical level. Straube and Ozsu <ref> [82, 83, 81] </ref> use a "processing template" operating on streams of tuples of object identifiers to represent their plans. Each processing template represents a set of alternative plans.
Reference: [83] <author> David D. Straube and M. Tamer Ozsu. </author> <title> Queries and query processing in object-oriented database systems. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 8(4) </volume> <pages> 387-430, </pages> <month> Octo-ber </month> <year> 1990. </year>
Reference-contexts: One of the points of departure for object-oriented systems has been experimentation with different plan languages and representations. This has occurred because there are additional concepts to be modeled at the physical level. Straube and Ozsu <ref> [82, 83, 81] </ref> use a "processing template" operating on streams of tuples of object identifiers to represent their plans. Each processing template represents a set of alternative plans.
Reference: [84] <author> Bharathi Subramanian, Stanley B. Zdonik, Theodore W. Leung, and Scott L. Vandenberg. </author> <title> Ordered types in the AQUA data model. </title> <note> In Beeri [7]. </note>
Reference-contexts: As part of the EREQ project, a query language for trees and lists has been developed <ref> [84, 89] </ref>. Our rule language adapts and extends that work, allowing us to use the query language to specify 20 pattern matches in the tree representation of queries, and also allows us to use queries in computing the actions to be taken when a rule is to fire.
Reference: [85] <author> Manolis M. Tsangaris and Jeffrey F. Naughton. </author> <title> A stochastic approach for clustering in object bases. </title> <booktitle> In Clifford and King [18], </booktitle> <pages> pages 12-21. </pages>
Reference-contexts: There have been many proposals for single and multi-page clusters [14, 11, 77], as well as performance studies of the impact of clustering [49]. There has also been extensive work on methods for deciding which objects to place in a cluster <ref> [8, 85, 86] </ref>. Support for clustering is essential for good performance in object-oriented systems. 3 Approach Ultimately, the query must be evaluated by using specific algorithms to access specific data structures on secondary storage.
Reference: [86] <author> Manolis M. Tsangaris and Jeffrey F. Naughton. </author> <title> On the performance of object clustering techniques. </title> <booktitle> In Stonebraker [79], </booktitle> <pages> pages 144-153. </pages>
Reference-contexts: There have been many proposals for single and multi-page clusters [14, 11, 77], as well as performance studies of the impact of clustering [49]. There has also been extensive work on methods for deciding which objects to place in a cluster <ref> [8, 85, 86] </ref>. Support for clustering is essential for good performance in object-oriented systems. 3 Approach Ultimately, the query must be evaluated by using specific algorithms to access specific data structures on secondary storage.
Reference: [87] <author> Bennet Vance. </author> <title> Towards an object-oriented query algebra. </title> <type> Technical Report CS/E-91-008, </type> <institution> Oregon Graduate Institute of Science and Technology, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: There is a single implementation for each operator, and all variations in plans essentially come via permutations of arguments. As part of the Revelation <ref> [45, 25, 87] </ref>, Bennet Vance has developed Rexall [88], a functional plan language with support for objects. Rexall allows the recognition of situations where the same physical operator is used to compute different logical operators. The two instances of the physical operator can be combined, eliminating the "algorithm" common subexpression.
Reference: [88] <author> Bennet Vance. </author> <title> An abstract object-oriented query execution language. </title> <booktitle> In Beeri [7], </booktitle> <pages> pages </pages> -. 
Reference-contexts: There is a single implementation for each operator, and all variations in plans essentially come via permutations of arguments. As part of the Revelation [45, 25, 87], Bennet Vance has developed Rexall <ref> [88] </ref>, a functional plan language with support for objects. Rexall allows the recognition of situations where the same physical operator is used to compute different logical operators. The two instances of the physical operator can be combined, eliminating the "algorithm" common subexpression. <p> Common subexpressions in path expressions appear in the class connection graph, a result of this mapping process. As previously mentioned, Kemper et al.[55] can eliminate common subexpressions that appear via access support relations, and Rexall <ref> [88] </ref> can be used to recognize "algorithmic" common subexpressions. Lanzelotte, et al. [58, 59, 38, 60] took the first step towards rewriting at the physical level by mapping their queries onto the schema. This is done using two data structures, the class connection graph and the physical schema graph. <p> There is also room at the physical level for algebraic common subexpressions <ref> [88] </ref>. Many algebra operators can be implemented by using the same algorithm with different parameters [40, 88], or as combinations of basic building block algorithms. An example illustrated in the Rexall paper [88] is the expression sum (A " B) sum (A B). <p> There is also room at the physical level for algebraic common subexpressions [88]. Many algebra operators can be implemented by using the same algorithm with different parameters <ref> [40, 88] </ref>, or as combinations of basic building block algorithms. An example illustrated in the Rexall paper [88] is the expression sum (A " B) sum (A B). This expression can be optimized if we note that that intersection and difference can both implemented using hash join. <p> There is also room at the physical level for algebraic common subexpressions <ref> [88] </ref>. Many algebra operators can be implemented by using the same algorithm with different parameters [40, 88], or as combinations of basic building block algorithms. An example illustrated in the Rexall paper [88] is the expression sum (A " B) sum (A B). This expression can be optimized if we note that that intersection and difference can both implemented using hash join. When two operators are implemented solely in terms of a single lower level algorithm, this strategy works nicely.
Reference: [89] <author> Scott L. Vandenberg. </author> <title> Algebras for Object-Oriented Query Languages. </title> <type> PhD thesis, </type> <institution> Computer Sciences Department, University of Wisconsin-Madison, Madison, WI 53706, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: As part of the EREQ project, a query language for trees and lists has been developed <ref> [84, 89] </ref>. Our rule language adapts and extends that work, allowing us to use the query language to specify 20 pattern matches in the tree representation of queries, and also allows us to use queries in computing the actions to be taken when a rule is to fire.
Reference: [90] <author> Mary Jane Willshire. </author> <title> How spacey can they get? space overhead for storage and indexing with object-oriented databases. </title> <booktitle> In Proceedings of the Seventh International Conference on Data Engineering [48], </booktitle> <pages> pages 14-22. </pages>
Reference: [91] <author> Eugene Wong and Karel Youssefi. </author> <title> Decomposition a strategy for query processing. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(2) </volume> <pages> 223-241, </pages> <month> September </month> <year> 1976. </year> <month> 53 </month>
Reference-contexts: This approach was first described in System R [76]. Ingres [80] 4 uses a very unsophisticated plan generator which handles one variable queries only. The Ingres optimization algorithm <ref> [91] </ref> decomposes multi-variable queries into single variable queries. 2.2 Plan Generation in Object-Oriented Systems Plan generators for object-oriented databases have continued where relational systems left off.
Reference: [92] <editor> Li-Yan Yuan, editor. </editor> <booktitle> Proceedings of the 18th International Conference on Very Large Data Bases, </booktitle> <address> Vancouver, Canada, August 1992. </address> <publisher> Morgan Kaufmann Publishers, Inc. </publisher>
Reference: [93] <author> Stanley B. Zdonik. </author> <title> Query optimization in object oriented databases. </title> <booktitle> In Proceedings of the Twenty-Second Annual Hawaii International Conference on System Sciences, </booktitle> <pages> pages 19-25. </pages> <publisher> IEEE, IEEE Computer Society Press, </publisher> <month> January </month> <year> 1989. </year> <month> 54 </month>
Reference-contexts: Indices make use of a search data structure like b-tree to reduce the amount of data that must be 11 searched in order to find the answer to a query. There have been a number of proposals for indices in object-oriented databases <ref> [68, 10, 9, 93, 54, 55] </ref>, each with their own strengths and weaknesses.
References-found: 93

