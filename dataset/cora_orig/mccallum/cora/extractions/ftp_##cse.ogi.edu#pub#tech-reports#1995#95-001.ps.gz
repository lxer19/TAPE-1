URL: ftp://cse.ogi.edu/pub/tech-reports/1995/95-001.ps.gz
Refering-URL: ftp://cse.ogi.edu/pub/tech-reports/README.html
Root-URL: http://www.cse.ogi.edu
Email: (synthetix-request@cse.ogi.edu)  
Title: Incremental Specialization in a Commercial Operating System  
Author: Andrew Black, Charles Consel, Calton Pu, Jonathan Walpole, Crispin Cowan, Tito Autrey, Jon Inouye, Lakshmi Kethana and Ke Zhang 
Date: March 24, 1995  
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Note: Dream and Reality:  This research is partially supported by ARPA grant N00014-94-1-0845 and grants from the Hewlett-Packard Company.  
Pubnum: Technical Report 95-001  
Abstract: A revised version of this paper appears in SOSP-15, Copper Mountain Resort, CO, December 1995. Abstract Conventional operating system code is written to deal with all possible system states, and performs considerable interpretation to determine the current system state before taking action. A consequence of this approach is that kernel calls which perform little actual work take a long time to execute. To address this problem, we use specialized operating system code that reduces interpretation, but still behaves correctly in the fully general case. We show that specialized operating system code can be generated and bound incrementally as the information on which it depends becomes available. We extend our specialization techniques to include the notion of optimistic incremental specialization: a technique for generating specialized kernel code optimistically for system states that are likely, but not certain, to occur. The ideas outlined in this paper allow the conventional kernel design tenet of "optimizing for the common case" to be extended to the domain of adaptive operating systems. We also show that aggressive use of specialization can produce in-kernel implementations of operating system functionality with performance comparable to user-level implementations. We demonstrate that these ideas are applicable in real-world operating systems by describing a re-implementation of the HP-UX file system. Our specialized read system call reduces the cost of a single byte read by 50%, and an 8 KB read by 20%, while preserving the semantics of the HP-UX read call. By relaxing the semantics of the HP-UX read we were able to cut the cost of a single byte read system call by more than an order of magnitude. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Thomas B. Alexander, Kenneth G. Robertson, Dean T. Lindsey, Donald L. Rogers, John R. Obermeyer, John R. Keller, Keith Y. Oka, and Marlin M. Jones II. </author> <title> Corporate Business Servers: An Alternative to Mainframes for Business Computing. </title> <journal> Hewlett-Packard Journal, </journal> <volume> 45(3) </volume> <pages> 8-30, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: The use of specialization to optimize the device I/O path and make better use of the buffer cache is the subject of a separate study currently underway in our group. The experimental environment for the benchmarks was a Hewlett-Packard 9000 series 800 G70 (9000/887) <ref> [1] </ref> dual-processor server running in single-user mode. This server is configured with 128 MB of RAM.
Reference: [2] <author> Thomas E. Anderson, Brian N. Bershad, Edward D. Lazowska, and Henry M. Levy. </author> <title> Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: This result is encouraging because it shows the feasibility of implementing operating system functionality at kernel level with performance similar to user-level libraries. Aggressive specialization may render unnecessary the popular trend of duplicating operating system functionality at user level <ref> [2, 11] </ref> for performance reasons. Another commonly cited reason for moving operating system functionality to user level is to give applications more control over policy decisions and operating system implementations. We believe that these benefits can also be gained without duplicating operating system functionality at user level.
Reference: [3] <author> Arindam Banerji and David L. Cohn. </author> <title> An Infrastructure for Application-Specific Customization. </title> <booktitle> In Proceedings of the ACM European SIGOPS Workshop, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: Flex needs to implement a production quality Mach microkernel. Synthetix is developing tools and methodology that apply to a wide range of environments, including HP-UX and Mach as primary demonstration systems. A third significant OS project aiming at adaptiveness is the Substrate Object Model <ref> [3] </ref> at University of Notre Dame. They propose to use customizable objects to implement extensible and flexible kernel services. Substrates are currently being used to extend the AiX operating system.
Reference: [4] <author> Brian N. Bershad, Craig Chambers, Susan Eggers, Chris Maeda, Dylan McNamee, Przemyslaw Pardyak, Stefan Savage, and Emin Gun Sirer. </author> <title> SPIN An Extensible Microkernel for Application-specific Operating System Services. </title> <type> Technical Report 94-03-03, </type> <institution> Department of Computer Science, University of Washington, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: In the operating systems area, the SPIN kernel <ref> [4] </ref> at the University of Washington is a good example. SPIN allows applications to dynamically load executable modules, called spindles, into the kernel. These spindles are written in a type-safe programming language to ensure that they do not affect adversely kernel operations.
Reference: [5] <author> John B. Carter, Bryan Ford, Mike Hibler, Ravindra Kuramkote, Jeffrey Law, Lay Lepreau, Douglas B. Orr, Leigh Stoller, and Mark Swanson. </author> <title> FLEX: A Tool for Building Efficient and Flexible Systems. </title> <booktitle> In Proceedings of the Fourth Workshop on Workstation Operating Systems, </booktitle> <pages> pages 198-202, </pages> <address> Napa, CA, </address> <month> October </month> <year> 1993. </year> <month> 14 </month>
Reference-contexts: SPIN allows applications to extend the OS kernel interface in a custom fashion through co-existence, while incremental specialization extends kernel interfaces only through meta interfaces, keeping the applications at the user level. The Flex project <ref> [5] </ref> at University of Utah is building the Mach 4 microkernel using specialization techniques. Synthetix and Flex are complementary in their goals. Flex needs to implement a production quality Mach microkernel.
Reference: [6] <author> Frederick W. Clegg, Gary Shiu-Fan Ho, Steven R. Kusmer, and John R. Sontag. </author> <title> The HP-UX Operating System on HP Precision Architecture Computers. </title> <journal> Hewlett-Packard Journal, </journal> <volume> 37(12) </volume> <pages> 4-22, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: The work described in this paper examines the benefits of specialization more directly, in the context of a commercial Unix operating system (HP-UX) <ref> [6] </ref> and the C programming language. The experiments described here focus on the specialization of the read system call, which retains the standard Unix semantics. We further extend the work done in Synthesis [15] by showing how specialization can be done incrementally and optimistically.
Reference: [7] <author> C. Consel and O. Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 493-501, </pages> <year> 1993. </year>
Reference-contexts: Section 5 compares the dream with reality and discusses the key areas for future research. Related work is discussed in section 6. Section 7 concludes the paper. 2 What is Specialization? Specialization has its conceptual roots in the field of partial evaluation (PE) <ref> [7, 19] </ref>. In general, PE takes a program and a list of bindings for some (but not all) of the free variables, and produces a restricted program in which the values for those variables are referenced directly, as constants.
Reference: [8] <author> C. Consel, C. Pu, and J. Walpole. </author> <title> Incremental specialization: The key to high performance, modularity and portability in operating systems. </title> <booktitle> In Proceedings of ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: We call this repeated application of an on-line partial evaluator incremental specialization <ref> [8] </ref>. The discussion so far has considered generating specialized code only on the basis of known invariants, i.e., bindings that are known to be constant. In an operating system, there are many things that are likely to be constant for long periods of time, but may occasionally vary.
Reference: [9] <author> Eric DeLano, Will Walker, and Mark Forsyth. </author> <title> A High Speed Superscalar PA-RISC Processor. </title> <booktitle> In COMPCON 92, </booktitle> <pages> pages 116-121, </pages> <address> San Francisco, CA, </address> <month> February 24-28 </month> <year> 1992. </year>
Reference-contexts: The experimental environment for the benchmarks was a Hewlett-Packard 9000 series 800 G70 (9000/887) [1] dual-processor server running in single-user mode. This server is configured with 128 MB of RAM. The two PA7100 <ref> [9] </ref> processors run at 96 MHz and each contains one MB of instruction cache and one MB of data cache. 4.1 Performance of the read Fast Path The first microbenchmark is designed to measure best case read performance.
Reference: [10] <author> A. Gheith, B. Mukherjee, D. Silva, and K. Schwan. KTK: </author> <title> Kernel support for configuration objects and invocations. </title> <type> Technical Report GIT-CC-94/11, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: Up to now, Apertos has not used specialization to improve its performance. Other examples of related systems include: the Chorus/MiX commercial operating system [18], which has specialized execution paths, and the Kernel ToolKit project at Georgia Tech <ref> [10] </ref> which supports online and off line object reconfiguration, and of course, Synthesis [17, 15], which was discussed in the Introduction. 13 7 Conclusions This paper has introduced the concepts of incremental and optimistic specialization.
Reference: [11] <author> Kieran Harty and David R. Cheriton. </author> <title> Application-controlled physical memory using external page-cache management. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <pages> pages 187-197, </pages> <address> Boston, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: This result is encouraging because it shows the feasibility of implementing operating system functionality at kernel level with performance similar to user-level libraries. Aggressive specialization may render unnecessary the popular trend of duplicating operating system functionality at user level <ref> [2, 11] </ref> for performance reasons. Another commonly cited reason for moving operating system functionality to user level is to give applications more control over policy decisions and operating system implementations. We believe that these benefits can also be gained without duplicating operating system functionality at user level.
Reference: [12] <author> Hewlett-Packard. </author> <title> PA-RISC 1.1 Architecture and Instruction Set Reference Manual, </title> <note> second edition, </note> <month> September </month> <year> 1992. </year>
Reference-contexts: The program consists of a tight loop that opens the file, gets a timestamp, reads N bytes, gets a timestamp, and closes the file. Timestamps are obtained by reading the PA-RISC's interval timer, a processor control register that is incremented every processor cycle <ref> [12] </ref>.
Reference: [13] <author> Gregor Kiczales. </author> <title> Towards a new model of abstraction in software engineering. </title> <booktitle> In Proc. of the IMSA'92 Workshop on Reflection and Meta-level Architectures, </booktitle> <year> 1992. </year> <note> See http://www.xerox.com/PARC/spl/eca/oi.html for updates. </note>
Reference-contexts: Another commonly cited reason for moving operating system functionality to user level is to give applications more control over policy decisions and operating system implementations. We believe that these benefits can also be gained without duplicating operating system functionality at user level. Following an open-implementation (OI) philosophy <ref> [13] </ref>, operating system functionality can remain in the kernel, with customization of the implementation supported in a controlled manner via meta interface calls [14]. A strong lesson from our work and from other work in the OI community [13] is that abstractly specified interfaces, i.e., those that do not constrain implementation <p> Following an open-implementation (OI) philosophy <ref> [13] </ref>, operating system functionality can remain in the kernel, with customization of the implementation supported in a controlled manner via meta interface calls [14]. A strong lesson from our work and from other work in the OI community [13] is that abstractly specified interfaces, i.e., those that do not constrain implementation choices unnecessarily, are key to the gaining the most benefit from techniques such as specialization. 6 Related Work There are several other projects and approaches that are "adaptive" in some sense.
Reference: [14] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: We believe that these benefits can also be gained without duplicating operating system functionality at user level. Following an open-implementation (OI) philosophy [13], operating system functionality can remain in the kernel, with customization of the implementation supported in a controlled manner via meta interface calls <ref> [14] </ref>.
Reference: [15] <author> H. Massalin and C. Pu. </author> <title> Threads and input/output in the Synthesis kernel. </title> <booktitle> In Proceedings of the Twelfth Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201, </pages> <address> Arizona, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: A consequence of this requirement is that operating system code tends to be "generic", performing extensive interpretation and checking of the current environment before taking action. One of the lessons of the Synthesis operating system <ref> [15] </ref> is that significant gains in efficiency can be made by replacing this generic code with specialized code. The specialized code performs correctly only in a restricted environment, but it is chosen so that this restricted environment is the common case. <p> Through extensive use of this kind of specialization Synthesis achieved improvement in kernel call performance ranging from a factor of 3 to a factor of 56 <ref> [15] </ref> for a subset of the Unix system call interface. <p> The experiments described here focus on the specialization of the read system call, which retains the standard Unix semantics. We further extend the work done in Synthesis <ref> [15] </ref> by showing how specialization can be done incrementally and optimistically. The remainder of the paper is organized as follows. Section 2 elaborates on the notion of specialization, and defines incremental and optimistic specialization. Section 3 describes the application of specialization to the HP-UX read system call. <p> Other examples of related systems include: the Chorus/MiX commercial operating system [18], which has specialized execution paths, and the Kernel ToolKit project at Georgia Tech [10] which supports online and off line object reconfiguration, and of course, Synthesis <ref> [17, 15] </ref>, which was discussed in the Introduction. 13 7 Conclusions This paper has introduced the concepts of incremental and optimistic specialization. These concepts refine previous work on kernel optimization using dynamic code generation in Synthesis [17, 15], and can be applied to commercial operating system kernels. <p> Tech [10] which supports online and off line object reconfiguration, and of course, Synthesis <ref> [17, 15] </ref>, which was discussed in the Introduction. 13 7 Conclusions This paper has introduced the concepts of incremental and optimistic specialization. These concepts refine previous work on kernel optimization using dynamic code generation in Synthesis [17, 15], and can be applied to commercial operating system kernels. We have demonstrated incremental and optimistic specialization in an experiment on the Unix File System of HP-UX, a commercial operating system.
Reference: [16] <author> Marshall K. McKusick, William N. Joy, Samuel J. Le*er, and Robert S. Fabry. </author> <title> A Fast File System for UNIX. </title> <journal> Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 181-197, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Assuming that the read is from a normal file and that its data is in the buffer cache, the basic steps are as follows <ref> [16] </ref>. 1. System call startup: privileged promotion, switch to kernel stack, and update user structure. 2. Identify the file and file system type: translate the file descriptor number into a file descriptor, then into a vnode number, and finally into an inode number. 3. Lock the inode. 4.
Reference: [17] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <month> Winter </month> <year> 1988. </year>
Reference-contexts: Given a list of invariants, which may be learned either statically or at run-time, a combination of on-line and off-line PE should be capable of generating the required specialized code. For example, the Synthesis kernel <ref> [17] </ref> performed the (conceptual) PE step just once, at runtime during open. <p> Other examples of related systems include: the Chorus/MiX commercial operating system [18], which has specialized execution paths, and the Kernel ToolKit project at Georgia Tech [10] which supports online and off line object reconfiguration, and of course, Synthesis <ref> [17, 15] </ref>, which was discussed in the Introduction. 13 7 Conclusions This paper has introduced the concepts of incremental and optimistic specialization. These concepts refine previous work on kernel optimization using dynamic code generation in Synthesis [17, 15], and can be applied to commercial operating system kernels. <p> Tech [10] which supports online and off line object reconfiguration, and of course, Synthesis <ref> [17, 15] </ref>, which was discussed in the Introduction. 13 7 Conclusions This paper has introduced the concepts of incremental and optimistic specialization. These concepts refine previous work on kernel optimization using dynamic code generation in Synthesis [17, 15], and can be applied to commercial operating system kernels. We have demonstrated incremental and optimistic specialization in an experiment on the Unix File System of HP-UX, a commercial operating system.
Reference: [18] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrman, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> Overview of the Chorus distributed operating system. </title> <booktitle> In Proceedings of the Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 39-69, </pages> <address> Seattle, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Apertos supports dynamic reconfiguration by moving an object into a new meta-space. An object's behavior can be modified by its meta objects, including kernel objects. Up to now, Apertos has not used specialization to improve its performance. Other examples of related systems include: the Chorus/MiX commercial operating system <ref> [18] </ref>, which has specialized execution paths, and the Kernel ToolKit project at Georgia Tech [10] which supports online and off line object reconfiguration, and of course, Synthesis [17, 15], which was discussed in the Introduction. 13 7 Conclusions This paper has introduced the concepts of incremental and optimistic specialization.
Reference: [19] <author> P. Sestoft and A. V. Zamulin. </author> <title> Annotated bibliography on partial evaluation and mixed computation. </title> <editor> In D. Bjtrner, A. P. Ershov, and N. D. Jones, editors, </editor> <title> Partial Evaluation and Mixed Computation. </title> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Section 5 compares the dream with reality and discusses the key areas for future research. Related work is discussed in section 6. Section 7 concludes the paper. 2 What is Specialization? Specialization has its conceptual roots in the field of partial evaluation (PE) <ref> [7, 19] </ref>. In general, PE takes a program and a list of bindings for some (but not all) of the free variables, and produces a restricted program in which the values for those variables are referenced directly, as constants.
Reference: [20] <author> Yasuhiko Yokote. </author> <title> The Apertos Reflective Operating System: The Concept and Its Implementation. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA), </booktitle> <pages> pages 414-434, </pages> <address> Vancouver, BC, </address> <month> October </month> <year> 1992. </year> <month> 15 </month>
Reference-contexts: Substrates are currently being used to extend the AiX operating system. They use a combination of substrates, efficient cross-domain RPC based on shared virtual memory, and extended the AiX dynamic loader to load subclasses into the kernel. The Apertos operating system <ref> [20] </ref> supports objects and meta-objects explicitly. Apertos supports dynamic reconfiguration by moving an object into a new meta-space. An object's behavior can be modified by its meta objects, including kernel objects. Up to now, Apertos has not used specialization to improve its performance.
References-found: 20

