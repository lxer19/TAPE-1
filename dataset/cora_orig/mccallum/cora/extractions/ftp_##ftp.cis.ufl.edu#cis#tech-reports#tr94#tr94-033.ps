URL: ftp://ftp.cis.ufl.edu/cis/tech-reports/tr94/tr94-033.ps
Refering-URL: http://www.cis.ufl.edu/tech-reports/tech-reports/tr94-abstracts.html
Root-URL: http://www.cis.ufl.edu
Email: hanson@cis.ufl.edu  
Title: Flexible and Recoverable Interaction Between Applications and Active Databases  
Author: Eric N. Hanson I-Cheng Chen Roxana Dastur Kurt Engel Vijay Ramaswamy Chun Xu 
Date: September 28, 1994  (revised November 15, 1994)  
Address: Gainseville, FL 32611  
Affiliation: CIS Department University of Florida  
Pubnum: CIS-TR-94-033  
Abstract: The need for active database rules to be able to interact with running application programs has been recognized for some time. In addition, technology that supports recoverable, transaction-consistent flow of requests from client applications to the database server and of responses from the server back to the client is maturing. The work described here unifies a flexible mechanism for interaction between applications and an active DBMS with recoverable messaging services. The resulting system, an extension of the Ariel active DBMS, allows messages to be transmitted by an active rule action to one or more applications. These messages can be made persistent, via a recoverable queue, so they will not be lost due to server, client, or communication failure. In addition, messages transmitted by rules to applications can be delayed until transaction commit to prevent applications from taking action on the results of an uncommitted transaction. This paper describes the design and implementation of the system, including the system architecture, application/server communication facilities, event processing mechanisms, and security and authorization techniques.
Abstract-found: 1
Intro-found: 1
Reference: [ASK92] <institution> ASK Computer Systems. </institution> <note> INGRES/SQL Reference Manual, 1992. Version 6.4, pages 6-67 to 6-79. </note>
Reference-contexts: The emergence of active databases has added a new dimension to interaction between applications and database servers. The action of a rule can invoke an operation in a running application program <ref> [MD89, ASK92] </ref>. This is a very useful facility because it allows any action desired to be taken based on the firing of a database rule. <p> However, a simple design of such a system is vulnerable to errors due to transaction, 3 client, and server failures. Simple mechanisms to allow rules to signal applications have been developed for HiPAC [MD89] as well as the commercial INGRES system, versions 6.4 and higher <ref> [ASK92] </ref>, and the Borland Interbase product [Das94]. The HiPAC mechanism was implemented as a main-memory prototype, and served more to validate the concept that a rule could signal an application than as a tool for application development.
Reference: [ATT94] <institution> ATT Global Information Solutions. TOP END Recoverable Transaction Queuing, </institution> <month> April </month> <year> 1994. </year> <month> DTP #93-386. </month>
Reference-contexts: A number of commercial systems support this type of processing, including, to name a few, IMS/DC and CICS from IBM, Tandem's Guardian 90, Digital's DECdta, and the TOP END TP-monitor from AT&T GIS <ref> [GR93, Ber91, ATT94] </ref>. The emergence of active databases has added a new dimension to interaction between applications and database servers. The action of a rule can invoke an operation in a running application program [MD89, ASK92].
Reference: [Ber91] <author> Philip A. Bernstein. </author> <title> DECdta - Digital's distributed transaction processing architecture. </title> <journal> Digital Technical Journal, </journal> <volume> 3(1) </volume> <pages> 10-17, </pages> <month> Winter </month> <year> 1991. </year>
Reference-contexts: A number of commercial systems support this type of processing, including, to name a few, IMS/DC and CICS from IBM, Tandem's Guardian 90, Digital's DECdta, and the TOP END TP-monitor from AT&T GIS <ref> [GR93, Ber91, ATT94] </ref>. The emergence of active databases has added a new dimension to interaction between applications and database servers. The action of a rule can invoke an operation in a running application program [MD89, ASK92].
Reference: [BHM90] <author> Philip A. Bernstein, Meichun Hsu, and Bruce Mann. </author> <title> Implementing recoverable requests using queues. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 112-122, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: The extended version of Ariel being developed avoids this problem by allowing event transmission to depend on commit of the transaction raising the event. As part of the solution to these problems, recoverable queues <ref> [BHM90] </ref> are used to help communicate events from servers back to clients. Of course, the primary way applications will interact with an active database server is to send the server requests and get back responses. This style of interaction must be well supported. <p> The stable storage used for message transmission is sometimes managed by a recoverable queue mechanism <ref> [BHM90] </ref> tailored to support this type of asynchronous transaction processing. A number of commercial systems support this type of processing, including, to name a few, IMS/DC and CICS from IBM, Tandem's Guardian 90, Digital's DECdta, and the TOP END TP-monitor from AT&T GIS [GR93, Ber91, ATT94]. <p> Of course, when a server asynchronously sends an event notification to a client through a recoverable queue, it doesn't correspond to any request, so request/reply matching isn't necessary. Our recoverable queue mechanism is similar to the one described by Bernstein et al. <ref> [BHM90] </ref>. However, we believe that the use of recoverable queues to transmit event notifications to clients is new. The model of how clients interact with servers for non-interactive requests and queued event notifications is shown in figure 4. <p> The value of ckpt is the state of the client related to all event notifications processed so far, including the one being marked "completed" now. The functional interface described here is similar to the one given by Bernstein <ref> [BHM90] </ref>, with the addition of the function CommitReceive for normal request and reply processing and ReceiveQueuedEvent, ReReceiveQueuedEvent, and CommitReceiveQueuedEvent for queued event processing. The CommitReceive function allows an application to explicitly acknowledge that it is done processing the last Receive. <p> the client needs to make sure that it only processes a reply or event notification once because processing it more than once is not acceptable (e.g. it is not idempotent), then the application needs to be able to test its local environment to determine whether it actually processed the reply <ref> [BHM90] </ref>. If a client's state is small, it can use the checkpoint parameter of the Receive, Com-mitReceive, ReceivedQueueEvent and CommitReceiveQueuedEvent operations to save it's state to help it initialize itself after it connects. <p> An alternative design would have been to allow state to be checkpointed separately for different event names, but this was felt to be too complex, especially since the total event-related state for all event names will usually be small. See <ref> [BHM90] </ref> for a more detailed discussion of issues related to exactly-once message processing, and use of a client state checkpointing mechanism. The queues are implemented as persistent C++ (E language) [RCS89] objects.
Reference: [Das93] <author> Roxana K. Dastur. </author> <title> Using recoverable queues for reliable event communication between applications and active databases. </title> <type> Master's thesis, </type> <institution> University of Florida, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: If they are the same, and LastCommittedRID is different from LastReceivedRID, and the client wants to ensure at-least-once reply processing, the client should do a ReReceive and reprocess the reply. If the LastReceivedEID and LastCommittedEID are the same, then the 1 This operation was called CommitClient in <ref> [Das93] </ref>. 13 14 client can to a ReceiveQueuedEvent immediately. If they are different, the client should do a ReReceiveQueuedEvent and process the event to make sure it is processed at least once.
Reference: [Das94] <author> Roxana K. Dastur. </author> <title> Correspondence regarding borland interbase. </title> <type> (personal communication), </type> <month> September </month> <year> 1994. </year>
Reference-contexts: Simple mechanisms to allow rules to signal applications have been developed for HiPAC [MD89] as well as the commercial INGRES system, versions 6.4 and higher [ASK92], and the Borland Interbase product <ref> [Das94] </ref>. The HiPAC mechanism was implemented as a main-memory prototype, and served more to validate the concept that a rule could signal an application than as a tool for application development. The INGRES mechanism allows an application program to create events and register for events.
Reference: [Gla93] <author> Graham Glass. </author> <title> UNIX for Programmers and Users: A Complete Guide. </title> <publisher> Prentice-Hall, </publisher> <year> 1993. </year>
Reference-contexts: While the rule action is run, the effective userid (from Ariel's perspective) is temporarily switched to the userid of the rule owner. This setuid mechanism is analogous to the setuid capability for executable programs in UNIX <ref> [Gla93] </ref>. This setuid feature can also allow a rule to raise an event for which the current user does not have raise privilege.
Reference: [GR93] <author> Jim Gray and Andreas Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: The application submits requests and receives responses, normally in a synchronous, conversational fashion. Many commercial systems also support asynchronous transaction processing, where request messages from applications are placed in stable storage, the server processes them and saves the reply on stable storage, and later the application retrieves the reply <ref> [GR93] </ref>. The stable storage used for message transmission is sometimes managed by a recoverable queue mechanism [BHM90] tailored to support this type of asynchronous transaction processing. <p> A number of commercial systems support this type of processing, including, to name a few, IMS/DC and CICS from IBM, Tandem's Guardian 90, Digital's DECdta, and the TOP END TP-monitor from AT&T GIS <ref> [GR93, Ber91, ATT94] </ref>. The emergence of active databases has added a new dimension to interaction between applications and database servers. The action of a rule can invoke an operation in a running application program [MD89, ASK92]. <p> For this reason the DC server thread has the highest priority and executes the minimum required code so that it becomes available to other clients at the very earliest. The process architecture described here is a variation of the "many servers, one scheduler" architecture <ref> [GR93] </ref>, where the DC is the scheduler and the Ariel processes and QM are the servers. This architecture was chosen for simplicity, though in extreme cases, the DC could become a bottleneck, and failure of the DC process could bring down the whole system until the DC can be restarted. <p> Since the focus of this work is on client-server interaction via the event mechanism, it was not felt to be worthwhile to complicate the design by using the more general "many servers, many schedulers" architecture <ref> [GR93] </ref>. 5 Recoverable Message Queuing Queued transactions are provided for application environments where an immediate response to a request is not essential, and messages must be able to flow reliably between clients and servers even if client, server, or network failures occur.
Reference: [Han92] <author> Eric N. Hanson. </author> <title> Rule condition testing and action execution in Ariel. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 49-58, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction This paper describes the design of a facility that supports reliable interaction between application programs and the Ariel active database system. Ariel is an active database system based on a production system model <ref> [HCKW90, Han92] </ref>. A new command called raise event is introduced. This command can be called from the action of a rule or can be submitted directly by a user or application. A companion of raise event is register for event. <p> Client application programs can be written in a high-level language (C or C++) with embedded query language statements written in Ariel's version of POSTQUEL <ref> [SR86, Han92] </ref>. A client application establishes communication with server processes through a multi-threaded data communications (DC) process. When a client will have multiple interactions with a server, a session is established between them and the client is given a server handle to identify the server temporarily dedicated to the client. <p> A detailed discussion of rule condition-action binding is given in a previous paper on Ariel <ref> [Han92] </ref>. Essentially, the tuple variables that appear in both the rule condition and the rule action range over the set of new tuples that have just matched the rule condition.
Reference: [HCKW90] <author> Eric N. Hanson, Moez Chaabouni, Chang-ho Kim, and Yu-wang Wang. </author> <title> A predicate matching algorithm for database rule systems. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 271-280, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: 1 Introduction This paper describes the design of a facility that supports reliable interaction between application programs and the Ariel active database system. Ariel is an active database system based on a production system model <ref> [HCKW90, Han92] </ref>. A new command called raise event is introduced. This command can be called from the action of a rule or can be submitted directly by a user or application. A companion of raise event is register for event.
Reference: [Koh88] <author> John T. Kohl. </author> <title> The evolution of the kerberos authentication service. </title> <booktitle> In Spring 1991 EurOpen Conference, </booktitle> <month> December </month> <year> 1988. </year> <month> 23 </month>
Reference-contexts: To significantly improve security beyond what is described here, so that vulnerability to problems like rogue "root" users creating their own machine names and usernames is eliminated, an additional mechanism is required. These vulnerabilities can be handled using an encryption-based authentication service such as Kerberos <ref> [SNS88, Koh88, NS78] </ref>.
Reference: [MD89] <author> Dennis R. McCarthy and Umeshwar Dayal. </author> <title> The architecture of an active data base management system. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 215-224, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: The emergence of active databases has added a new dimension to interaction between applications and database servers. The action of a rule can invoke an operation in a running application program <ref> [MD89, ASK92] </ref>. This is a very useful facility because it allows any action desired to be taken based on the firing of a database rule. <p> Providing a facility to let rules communicate with a running application is clearly a good idea. However, a simple design of such a system is vulnerable to errors due to transaction, 3 client, and server failures. Simple mechanisms to allow rules to signal applications have been developed for HiPAC <ref> [MD89] </ref> as well as the commercial INGRES system, versions 6.4 and higher [ASK92], and the Borland Interbase product [Das94]. The HiPAC mechanism was implemented as a main-memory prototype, and served more to validate the concept that a rule could signal an application than as a tool for application development.
Reference: [NS78] <author> Roger M. Needham and Michael D. Schroeder. </author> <title> Using encryption for authentication in large networks of computers. </title> <journal> Communications of the ACM, </journal> <volume> 21(12) </volume> <pages> 993-999, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: To significantly improve security beyond what is described here, so that vulnerability to problems like rogue "root" users creating their own machine names and usernames is eliminated, an additional mechanism is required. These vulnerabilities can be handled using an encryption-based authentication service such as Kerberos <ref> [SNS88, Koh88, NS78] </ref>.
Reference: [Ram93] <author> Vijay Ramaswamy. </author> <title> Data communication in the ariel client/server active dbms. </title> <type> Master's thesis, </type> <institution> University of Florida, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: This design limits the interaction between the client and the DC or the client and the Ariel server to a single RPC and return in most cases, keeping down communication costs. The multi-threaded DC process <ref> [Ram93] </ref> acts as both a server and a client.
Reference: [RCS89] <author> Joel E. Richardson, Michael J. Carey, and Daniel T. Schuh. </author> <title> The design of the E programming language. </title> <type> Technical report, </type> <institution> University of Wisconsin, </institution> <year> 1989. </year> <note> To appear, ACM TOPLAS. </note>
Reference-contexts: See [BHM90] for a more detailed discussion of issues related to exactly-once message processing, and use of a client state checkpointing mechanism. The queues are implemented as persistent C++ (E language) <ref> [RCS89] </ref> objects. The Queue Manager, Direct Ariel, and Queued Ariel processes are all allowed to access the queues directly, and perform queue operations as separate transactions or parts of other transactions as needed. The Queue Manager is the real owner of the queues.
Reference: [SNS88] <author> Jennifer G. Steiner, B. C. Neuman, and J. I. Schiller. </author> <title> Kerberos: An authentication service for open network systems. </title> <booktitle> In Usenix Conference Proceeedings, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: To significantly improve security beyond what is described here, so that vulnerability to problems like rogue "root" users creating their own machine names and usernames is eliminated, an additional mechanism is required. These vulnerabilities can be handled using an encryption-based authentication service such as Kerberos <ref> [SNS88, Koh88, NS78] </ref>.
Reference: [SR86] <author> M. Stonebraker and L. Rowe. </author> <title> The design of POSTGRES. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1986. </year>
Reference-contexts: Client application programs can be written in a high-level language (C or C++) with embedded query language statements written in Ariel's version of POSTQUEL <ref> [SR86, Han92] </ref>. A client application establishes communication with server processes through a multi-threaded data communications (DC) process. When a client will have multiple interactions with a server, a session is established between them and the client is given a server handle to identify the server temporarily dedicated to the client.
References-found: 17

