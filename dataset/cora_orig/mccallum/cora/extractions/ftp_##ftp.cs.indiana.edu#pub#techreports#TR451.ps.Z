URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR451.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Email: Email: fdalkilic,mjain,vguchtg@cs.indiana.edu  Email: anurag@parc.xerox.com  
Title: Design and Implementation of Reflective SQL (Extended Abstract)  
Author: Mehmet M. Dalkilic Manoj Jain Dirk Van Gucht Anurag Mendhekar 
Address: Bloomington, IN 47405, USA.  3333 Coyote Hill Road, Palo Alto, CA 94304, USA.  
Affiliation: Computer Science Dept., Indiana University,  Xerox Palo Alto Research Center,  
Abstract: One weakness of SQL has been its inability to express certain classes of queries, e.g., iterative queries and database schema-independent queries. Fixes to this problem generally involve embedding SQL in a more expressive language. Reflection|the ability of a language to encode arbitrary programs and evaluate these encodings during execution|can provide a seamless, natural solution. In database query languages reflection has been generally confined to a procedural setting, where one paper in particular, Van den Bussche et al, has given us much of our inspiration; however, exactly how to pragmatically incorporate reflection into a query language like SQL has remained elusive. This paper presents the design and implementation of a Reflective SQL (RSQL): an extension of SQL wherein programs themselves can create (i.e., reify), manipulate and evaluate programs. Ordinary SQL tables serve to encode these programs; these tables look and feel much like the programs they encode and, furthermore, retain SQL's declarative nature. The implementation itself is comprised of an RSQL interface and a relational database server. This work establishes, in a practical setting, a means of enhancing SQL, opening new avenues to solutions of database problems that have been hitherto inaccessible through SQL alone. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Aho, A., and Ullman, J. </author> <title> Universality of data retrieval languages. </title> <booktitle> In Sixth Annual ACM Symposium on Principles of Programming Languages, Williamsburg (1979), </booktitle> <pages> pp. 110-117. </pages>
Reference-contexts: Among these are (1) embedding query languages in a general purpose programming language; (2) adding various constructs such as transitive closure, fixpoint operators, and iteration to the query languages <ref> [1, 2, 5, 19] </ref>; (3) defining new models and languages that can express database schema-independent queries by allowing table and column names themselves to be treated as data [9, 10, 7].
Reference: [2] <author> Chandra, A., and Harel, D. </author> <title> Structure and complexity of relational queries. </title> <journal> J. Comput. Syst. Sci. </journal> <volume> 25, 1 (1982), </volume> <pages> 99-128. </pages>
Reference-contexts: Among these are (1) embedding query languages in a general purpose programming language; (2) adding various constructs such as transitive closure, fixpoint operators, and iteration to the query languages <ref> [1, 2, 5, 19] </ref>; (3) defining new models and languages that can express database schema-independent queries by allowing table and column names themselves to be treated as data [9, 10, 7].
Reference: [3] <author> Codd, E. </author> <title> A relational model for large shared data banks. </title> <journal> Commun. ACM 6, </journal> <month> 13 (June </month> <year> 1970), </year> <pages> 377-387. </pages>
Reference-contexts: 1 Introduction The relational data model with its query languages (relational algebra and relational calculus) introduced by Codd <ref> [3, 4] </ref> has been extensively used both as the theoretical and practical basis for designing commercial database systems.
Reference: [4] <author> Codd, E. </author> <title> Relational completeness of database sublanguages. In Database Systems, </title> <editor> R. Rustin, Ed. </editor> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1972. </year>
Reference-contexts: 1 Introduction The relational data model with its query languages (relational algebra and relational calculus) introduced by Codd <ref> [3, 4] </ref> has been extensively used both as the theoretical and practical basis for designing commercial database systems.
Reference: [5] <author> Immerman, N. </author> <title> Relational queries computable in polynomial time. </title> <booktitle> Information and Control 68 (1986), </booktitle> <pages> 86-104. </pages>
Reference-contexts: Among these are (1) embedding query languages in a general purpose programming language; (2) adding various constructs such as transitive closure, fixpoint operators, and iteration to the query languages <ref> [1, 2, 5, 19] </ref>; (3) defining new models and languages that can express database schema-independent queries by allowing table and column names themselves to be treated as data [9, 10, 7].
Reference: [6] <author> Jain, M. </author> <note> Unpublished manuscript. Available from the author. </note>
Reference-contexts: Adding reflection not only gives the ability to express the certain class of queries mentioned above, but also has numerous applications, such as procedural data, query optimization, polymorphism, inheritance, etc., (see <ref> [18, 6] </ref>). An important point to note is that extending a relational query language with reflection mechanisms is upwardly compatible to relational query languages with iterative constructs. <p> Another aspect that can benefit from reflective mechanisms is transaction processing where we envision a rule as a dynamic-eval that gets triggered upon updates. Additional future work lies in implementing other applications of reflection in databases <ref> [18, 6] </ref>. 13
Reference: [7] <author> Jain, M., Mendhekar, A., and Van Gucht, D. </author> <title> The uniform data model for relational data and meta-data query processing. </title> <booktitle> In Proceedings of the Seventh International Conference on Management of Data (December 1995), </booktitle> <pages> pp. 146-165. </pages>
Reference-contexts: in a general purpose programming language; (2) adding various constructs such as transitive closure, fixpoint operators, and iteration to the query languages [1, 2, 5, 19]; (3) defining new models and languages that can express database schema-independent queries by allowing table and column names themselves to be treated as data <ref> [9, 10, 7] </ref>. These are palliative solutions, however, in that they target themselves to symptomatic weaknesses in the relational model: though the symptom is cured, either some other problems remain or, worse, they relinquish other properties of the relational model.
Reference: [8] <author> Kent Dybvig, R. </author> <title> The SCHEME Programming Language. </title> <publisher> Prentice Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1987. </year>
Reference-contexts: The arrows provide the flow of events. The interface|an interactive RSQL environment|is written in the Scheme programming language <ref> [8] </ref>, since it is particularly well-suited for rapid prototyping. In keeping with the spirit of the language, we slightly adapted the syntax of RSQL by substituting lists for comma delimited expressions and by using prefix notation in place of infix.
Reference: [9] <author> Krishnamurthy, R., Litwin, W., and Kent, W. </author> <title> Language features for interoperability of databases with schematic discrepancies. </title> <booktitle> In Proceedings of the 1991 ACM SIGMOD International Conference on Management of Data (May 1991), </booktitle> <pages> pp. 40-49. </pages>
Reference-contexts: in a general purpose programming language; (2) adding various constructs such as transitive closure, fixpoint operators, and iteration to the query languages [1, 2, 5, 19]; (3) defining new models and languages that can express database schema-independent queries by allowing table and column names themselves to be treated as data <ref> [9, 10, 7] </ref>. These are palliative solutions, however, in that they target themselves to symptomatic weaknesses in the relational model: though the symptom is cured, either some other problems remain or, worse, they relinquish other properties of the relational model.
Reference: [10] <author> Lakshmanan, L., Sadri, F., and Subramanian, I. </author> <title> On the logical foundations of schema integration and evolution in heterogeneous database systems. </title> <booktitle> In Proceedings of the 3rd International Conference on Deductive and Object-Oriented Databases (December 1993), </booktitle> <pages> pp. 81-100. </pages>
Reference-contexts: in a general purpose programming language; (2) adding various constructs such as transitive closure, fixpoint operators, and iteration to the query languages [1, 2, 5, 19]; (3) defining new models and languages that can express database schema-independent queries by allowing table and column names themselves to be treated as data <ref> [9, 10, 7] </ref>. These are palliative solutions, however, in that they target themselves to symptomatic weaknesses in the relational model: though the symptom is cured, either some other problems remain or, worse, they relinquish other properties of the relational model.
Reference: [11] <author> Melton, J., and R. Simon, A. </author> <title> SQL: A Complete Guide. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, </address> <year> 1993. </year>
Reference-contexts: then provide us with our answer. (The complete solution using RSQL is presented in Section 3.) 2.1 The Fragment of SQL The fragment of SQL (see Fig. 1) we have chosen to reflect is included in the core of SQL, the portion often referred to as the data manipulation language <ref> [11] </ref>. This portion allows the user to manage existing tables by both querying and modifying data. As is well known [17], this fragment is Codd-complete, since all relational algebra expressions can be formulated in it.
Reference: [12] <author> Smith, B. C. </author> <title> Reflection and semantics in a procedural language. </title> <type> Tech. Rep. </type> <address> MIT-LCS-TR-272, </address> <publisher> MIT, </publisher> <address> Cambridge, </address> <year> 1982. </year>
Reference-contexts: Lastly, in approach (3) how to integrate the new models and query languages with a relational system is unclear. A novel approach that effectively addresses inexpressiveness, schema-independence, etc., studied by Van den Bussche, Van Gucht, and Vossen [18], involves extending the query language with reflection mechanisms <ref> [12, 13, 14] </ref>: reification, the association of data with the meaning of a program, and evaluation, the association of the meaning of a program with data.
Reference: [13] <author> Smith, B. C. </author> <title> Reflection and semantics in lisp. </title> <booktitle> In Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Salt Lake City (Jan. </address> <year> 1984), </year> <pages> pp. 23-35. </pages>
Reference-contexts: Lastly, in approach (3) how to integrate the new models and query languages with a relational system is unclear. A novel approach that effectively addresses inexpressiveness, schema-independence, etc., studied by Van den Bussche, Van Gucht, and Vossen [18], involves extending the query language with reflection mechanisms <ref> [12, 13, 14] </ref>: reification, the association of data with the meaning of a program, and evaluation, the association of the meaning of a program with data.
Reference: [14] <author> Stemple, D., et al. </author> <title> Type-safe linguistic reflection: a generator technology. </title> <institution> Research Report CS/92/6, University of St Andrews, Department of Mathematical and Computational Sciences, </institution> <year> 1992. </year>
Reference-contexts: Lastly, in approach (3) how to integrate the new models and query languages with a relational system is unclear. A novel approach that effectively addresses inexpressiveness, schema-independence, etc., studied by Van den Bussche, Van Gucht, and Vossen [18], involves extending the query language with reflection mechanisms <ref> [12, 13, 14] </ref>: reification, the association of data with the meaning of a program, and evaluation, the association of the meaning of a program with data.
Reference: [15] <author> Stonebraker, M., Anderson, E., Hanson, E., and Rubenstein, B. </author> <title> QUEL as a data type. </title> <booktitle> In Proceedings of ACM-SIGMOD 1984 International Conference on Management of Data, Boston (1984), </booktitle> <editor> B. Yormark, Ed., </editor> <volume> vol. </volume> <booktitle> 14:2 of SIGMOD Record, </booktitle> <publisher> ACM Press, </publisher> <pages> pp. 208-214. </pages>
Reference-contexts: Moreover, the representation of queries is chosen so that it may be manipulated without introducing new data structures to SQL. In the field of databases, storing programs as data was initially investigated by Stonebraker et al <ref> [15, 16] </ref> where they proposed a system that allowed programs to be stored as strings in tuple components and executed dynamically. Van den Bussche et al [18] took this one step further by not only encoding programs as data, but also allowing manipulation of these encodings before evaluation.
Reference: [16] <author> Stonebraker, M., Anton, J., and Hanson, E. </author> <title> Extending a database system with procedures. </title> <journal> ACM Trans. Database Syst. </journal> <volume> 12, </volume> <month> 3 (Sept. </month> <year> 1987), </year> <pages> 350-376. </pages>
Reference-contexts: Moreover, the representation of queries is chosen so that it may be manipulated without introducing new data structures to SQL. In the field of databases, storing programs as data was initially investigated by Stonebraker et al <ref> [15, 16] </ref> where they proposed a system that allowed programs to be stored as strings in tuple components and executed dynamically. Van den Bussche et al [18] took this one step further by not only encoding programs as data, but also allowing manipulation of these encodings before evaluation.
Reference: [17] <author> Ullman, J. D. </author> <title> Principles of Database Systems, 2 ed. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1982. </year>
Reference-contexts: This portion allows the user to manage existing tables by both querying and modifying data. As is well known <ref> [17] </ref>, this fragment is Codd-complete, since all relational algebra expressions can be formulated in it. Fixing on some notation, we reserve the word "operator" to refer to SQL keywords like SELECT, INTO, and WHERE.
Reference: [18] <author> Van den Bussche, J., Van Gucht, D., and Vossen, G. </author> <title> Reflective programming in the relational algebra. </title> <booktitle> In Proceedings of the Twelfth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> Washington, D.C. </address> <month> (May </month> <year> 1993), </year> <pages> pp. 17-25. </pages>
Reference-contexts: Approach (2), although retains the closure property, it cannot express schema-independent queries. Lastly, in approach (3) how to integrate the new models and query languages with a relational system is unclear. A novel approach that effectively addresses inexpressiveness, schema-independence, etc., studied by Van den Bussche, Van Gucht, and Vossen <ref> [18] </ref>, involves extending the query language with reflection mechanisms [12, 13, 14]: reification, the association of data with the meaning of a program, and evaluation, the association of the meaning of a program with data. <p> In the field of databases, storing programs as data was initially investigated by Stonebraker et al [15, 16] where they proposed a system that allowed programs to be stored as strings in tuple components and executed dynamically. Van den Bussche et al <ref> [18] </ref> took this one step further by not only encoding programs as data, but also allowing manipulation of these encodings before evaluation. <p> The true power of reflection 2 comes from this manipulation of the encodings that gives a program the ability to examine its own state and modify its own behavior depending upon this state. In <ref> [18] </ref>, Van den Bussche et al presented a reflective relational algebra RA that attained reflection by (1) establishing a means of encoding relational algebra programs as relations and (2) adding an operator to evaluate these encodings. <p> In a typical RA-program, one dynamically constructs relational algebra queries with reification tools and subsequently evaluates these queries. The crucial observation in <ref> [18] </ref> was that, while an RA-program itself is static, the relational algebra queries it constructs are dynamic in that they utilize, i.e., take as input, the current state of the database. <p> Adding reflection not only gives the ability to express the certain class of queries mentioned above, but also has numerous applications, such as procedural data, query optimization, polymorphism, inheritance, etc., (see <ref> [18, 6] </ref>). An important point to note is that extending a relational query language with reflection mechanisms is upwardly compatible to relational query languages with iterative constructs. <p> Another aspect that can benefit from reflective mechanisms is transaction processing where we envision a rule as a dynamic-eval that gets triggered upon updates. Additional future work lies in implementing other applications of reflection in databases <ref> [18, 6] </ref>. 13
Reference: [19] <author> Vardi, M. </author> <title> Complexity and relational query languages. </title> <booktitle> In Proceedings of the Fourteenth Annual Symposium on Theory of Computing, </booktitle> <address> San Francisco (1982), </address> <pages> pp. 137-146. 14 </pages>
Reference-contexts: Among these are (1) embedding query languages in a general purpose programming language; (2) adding various constructs such as transitive closure, fixpoint operators, and iteration to the query languages <ref> [1, 2, 5, 19] </ref>; (3) defining new models and languages that can express database schema-independent queries by allowing table and column names themselves to be treated as data [9, 10, 7].
References-found: 19

