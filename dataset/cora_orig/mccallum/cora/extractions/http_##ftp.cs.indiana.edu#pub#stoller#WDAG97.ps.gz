URL: http://ftp.cs.indiana.edu/pub/stoller/WDAG97.ps.gz
Refering-URL: http://www.cs.indiana.edu/hyplan/stoller.html
Root-URL: http://www.cs.indiana.edu
Title: Detecting Global Predicates in Distributed Systems with Clocks  
Author: Scott D. Stoller 
Keyword: global predicate detection, consistent global states, partially-synchronous systems, distributed debugging, real-time monitoring  
Address: Bloomington, IN 47405, USA  
Affiliation: Dept. of Computer Science, Indiana University,  
Abstract: This paper proposes a framework for predicate detection in systems of processes with approximately-synchronized real-time clocks. Timestamps from these clocks are used to define two orderings on events: "definitely occurred before" and "possibly occurred before". These or-derings lead naturally to definitions of 3 distinct detection modalities, i.e., 3 meanings of "predicate held during a computation", namely: Poss T (" possibly held"), Def T (" definitely held"), and Inst (" definitely held at a specific instant"). This paper defines these modalities and gives efficient algorithms for detecting them; the algorithms are based on algorithms of Cooper and Marzullo, Garg and Waldecker, and Fromentin and Raynal. 
Abstract-found: 1
Intro-found: 1
Reference: [BM93] <author> O. Babaoglu and K. Marzullo. </author> <title> Consistent global states of distributed systems: Fundamental concepts and mechanisms. In Sape Mullender, editor, </title> <journal> Distributed Systems, ch. </journal> <volume> 5, </volume> <pages> pages 97-145. </pages> <publisher> Addison Wesley, </publisher> <editor> 2nd ed., </editor> <year> 1993. </year>
Reference-contexts: with an immediately succeeding event e 0 on the same process, C 1 (e) C 1 (e 0 ) and C 2 (e) C 2 (e 0 ). 3 Generic Theory of Consistent Global States Predicate detection in asynchronous systems is based on the notion of consistent global states (CGSs) <ref> [BM93] </ref>. Informally, a global state is consistent if it could have occurred during the computation. Recall that an ideal of a partial order hS; OEi is a set I S such that (8x 2 I : 8y 2 S : y OE x ) y 2 I). <p> Ideals of hEv (c); ! hb i are usually called consistent cuts. Recall that for any partial order, the set of its ideals ordered by inclusion () forms a lattice [DJR93]. Furthermore, the lattice of CGSs ordered by G is isomorphic to the lattice of consistent cuts <ref> [SM94, BM93] </ref>. This isomorphism has an important consequence for detection algorithms; specifically, it implies that a minimal increase with respect to G corresponds to advancing one process by one event, and hence that the lattice of CGSs can be explored by repeatedly advancing one process by one event. <p> Proof. This is true for the same reasons as in the standard theory based on happened-before <ref> [SM94, BM93, DJR93] </ref>. The proof is straightforward. ut The following corollary underlies the detection algorithms in Sections 4 and 5. Corollary 2. <p> A detection algorithm based on happened-before could be used instead, if the system can be modified to maintain vector clocks (or is unusual and maintains them already). However, if the coherence protocol uses timers|for example, if leases are used instead of locks|then time acts as a hidden channel <ref> [BM93] </ref> (i.e., a means of communication other than messages), so detection based on happened-before might yield less precise results.
Reference: [CBDGF95] <author> B. Charron-Bost, C. Delporte-Gallet, and H. Fauconnier. </author> <title> Local and temporal predicates in distributed systems. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 17(1) </volume> <pages> 157-179, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: Web: http://www.cs.indiana.edu/~stoller/ 2 In this paper, all partial orderings are irreflexive unless specified otherwise. Cooper and Marzullo's definitions of these modalities established an im-portant conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [DJR93, GW94, CBDGF95, JMN95, SS95, GW96] </ref>. In practice, though, detection of Poss or Def suffers from two significant burdens.
Reference: [CLR90] <author> T. Cormen, C. Leiserson, and R. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press and McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: Recall that the operations on a priority queue p include getMin (p), which returns a record hk; di with key k and satellite data d such that k is the minimal value of the key, and extractMin (p), which removes and returns such a record <ref> [CLR90] </ref>. We also use priority queues with operations based on maximal key values. Thus, (7) is equivalent to key (getMin (p 2 )) key (getMax (p 1 )); (8) where key (hk; di) = k.
Reference: [CM91] <author> R. Cooper and K. Marzullo. </author> <title> Consistent detection of global predicates. </title> <booktitle> In Proc. ACM/ONR Workshop on Parallel and Distributed Debugging, 1991. Appeared as ACM SIGPLAN Notices 26(12) </booktitle> <pages> 167-174, </pages> <month> December </month> <year> 1991. </year>
Reference-contexts: Therefore, no process can determine unambiguously the sequence of global states through which the system passed. This leads to an obvious difficulty for detecting whether a global state predicate (hereafter simply called a "predicate"). Cooper and Marzullo proposed a solution for asynchronous distributed systems <ref> [CM91] </ref>. Their solution involves two modalities, which we denote by Poss (read "possibly") and Def (read "definitely"). These modalities are based on logical time [Lam78] as embodied in the happened-before relation e ! hb , a partial ordering 2 of events that reflects causal dependencies. <p> We obtain algorithms for detecting Poss T and Def T by adapting (and, as we do so, optimizing) algorithms of Cooper and Marzullo <ref> [CM91] </ref> and Garg and Waldecker [GW94, GW96]. Modalities based on e ! are quite different, because e ! (unlike e e i) is not a partial ordering. In fact, e ! yields a degenerate case, in which the analogues of Poss and Def are equivalent. <p> This principle underlies detection algorithms of Cooper and Marzullo <ref> [CM91] </ref> and Garg and Waldecker [GW94, GW96]. <p> We consider first general algorithms for Poss T and Def T and then more efficient algorithms that work only for predicates of a certain form. 4.1 General Algorithms for Poss T and Def T The algorithms in <ref> [CM91, MN91] </ref> can be adapted to explore lattice hCGS e by (roughly) replacing each condition of the form e e ! hb e 0 with e e ie 0 . Following [CM91, MN91], we give algorithms in which the monitor constructs one level of the lattice of CGSs at a time. <p> only for predicates of a certain form. 4.1 General Algorithms for Poss T and Def T The algorithms in <ref> [CM91, MN91] </ref> can be adapted to explore lattice hCGS e by (roughly) replacing each condition of the form e e ! hb e 0 with e e ie 0 . Following [CM91, MN91], we give algorithms in which the monitor constructs one level of the lattice of CGSs at a time. The level of a global state g is P N Level ` of the lattice of CGSs contains the CGSs with level `.
Reference: [DJR93] <author> C. Diehl, C. Jard, and J.-X. Rampon. </author> <title> Reachability analysis on distributed executions. </title> <editor> In J.-P. Jouannaud and M.-C. Gaudel, editors, </editor> <booktitle> TAPSOFT '93: Theory and Practice of Software Development, vol. 668 of Lecture Notes in Computer Science, </booktitle> <pages> pages 629-643. </pages> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: Web: http://www.cs.indiana.edu/~stoller/ 2 In this paper, all partial orderings are irreflexive unless specified otherwise. Cooper and Marzullo's definitions of these modalities established an im-portant conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [DJR93, GW94, CBDGF95, JMN95, SS95, GW96] </ref>. In practice, though, detection of Poss or Def suffers from two significant burdens. <p> Ideals of hEv (c); ! hb i are usually called consistent cuts. Recall that for any partial order, the set of its ideals ordered by inclusion () forms a lattice <ref> [DJR93] </ref>. Furthermore, the lattice of CGSs ordered by G is isomorphic to the lattice of consistent cuts [SM94, BM93]. <p> Proof. This is true for the same reasons as in the standard theory based on happened-before <ref> [SM94, BM93, DJR93] </ref>. The proof is straightforward. ut The following corollary underlies the detection algorithms in Sections 4 and 5. Corollary 2.
Reference: [FR94] <author> E. Fromentin and M. Raynal. </author> <title> Inevitable global states: a concept to detect unstable properties of distributed computations in an observer independent way. </title> <booktitle> In Proc. 6th IEEE Symposium on Parallel and Distributed Processing, </booktitle> <year> 1994. </year>
Reference-contexts: In fact, e ! yields a degenerate case, in which the analogues of Poss and Def are equivalent. We show that this single modality, which we denote by Inst, is closely related to Fromentin and Raynal's concept of Properly <ref> [FR94, FR95] </ref>, and we adapt for detecting Inst an algorithm of theirs for detecting Properly. Our detection framework is applicable to a wide range of systems, since it does not require that clocks be synchronized to within a fixed bound. <p> Consequently, the algorithms in Section 4 cannot be easily adapted to detect Inst. Our algorithm for detecting Inst is based on Fromentin and Raynal's algorithm for detecting Properly (read "properly") in asynchronous systems <ref> [FR94, FR95] </ref>. The definition of Properly, generalized to an arbitrary ordering on events, is: Properly: A computation c satisfies Properly e ,! iff there is a global state satisfying and contained in every path of hCGS e Theorem 6. Properly e i is equivalent to Inst. Proof.
Reference: [FR95] <author> E. Fromentin and M. Raynal. </author> <title> Characterizing and detecting the set of global states seen by all observers of a distributed computation. </title> <booktitle> In Proc. IEEE 15th Int'l. Conference on Distributed Computing Systems, </booktitle> <year> 1995. </year>
Reference-contexts: In fact, e ! yields a degenerate case, in which the analogues of Poss and Def are equivalent. We show that this single modality, which we denote by Inst, is closely related to Fromentin and Raynal's concept of Properly <ref> [FR94, FR95] </ref>, and we adapt for detecting Inst an algorithm of theirs for detecting Properly. Our detection framework is applicable to a wide range of systems, since it does not require that clocks be synchronized to within a fixed bound. <p> Consequently, the algorithms in Section 4 cannot be easily adapted to detect Inst. Our algorithm for detecting Inst is based on Fromentin and Raynal's algorithm for detecting Properly (read "properly") in asynchronous systems <ref> [FR94, FR95] </ref>. The definition of Properly, generalized to an arbitrary ordering on events, is: Properly: A computation c satisfies Properly e ,! iff there is a global state satisfying and contained in every path of hCGS e Theorem 6. Properly e i is equivalent to Inst. Proof.
Reference: [GW94] <author> V. K. Garg and B. Waldecker. </author> <title> Detection of weak unstable predicates in distributed programs. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 5(3) </volume> <pages> 299-307, </pages> <year> 1994. </year> <title> 6 Our framework accommodates the granularity of digital clocks by using instead of &lt; in SC1 and SC2. </title>
Reference-contexts: Web: http://www.cs.indiana.edu/~stoller/ 2 In this paper, all partial orderings are irreflexive unless specified otherwise. Cooper and Marzullo's definitions of these modalities established an im-portant conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [DJR93, GW94, CBDGF95, JMN95, SS95, GW96] </ref>. In practice, though, detection of Poss or Def suffers from two significant burdens. <p> We obtain algorithms for detecting Poss T and Def T by adapting (and, as we do so, optimizing) algorithms of Cooper and Marzullo [CM91] and Garg and Waldecker <ref> [GW94, GW96] </ref>. Modalities based on e ! are quite different, because e ! (unlike e e i) is not a partial ordering. In fact, e ! yields a degenerate case, in which the analogues of Poss and Def are equivalent. <p> This principle underlies detection algorithms of Cooper and Marzullo [CM91] and Garg and Waldecker <ref> [GW94, GW96] </ref>. <p> both cases, the worst-case time complexity is linear in E, which is normally much larger than N ; in contrast, the worst-case time complexity of general algorithms for detecting Poss and Def is (E N ). 4.2 Algorithms for Poss T and Def T for Restricted Predicates Garg and Waldecker <ref> [GW94, GW96] </ref> have developed efficient algorithms for detecting Poss and Def for conjunctive predicates . A predicate is conjunctive if it is a conjunction of predicates that each depend on the local state of one process.
Reference: [GW96] <author> V. K. Garg and B. Waldecker. </author> <title> Detection of strong unstable predicates in distributed programs. </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 7(12) </volume> <pages> 1323-1333, </pages> <year> 1996. </year>
Reference-contexts: Web: http://www.cs.indiana.edu/~stoller/ 2 In this paper, all partial orderings are irreflexive unless specified otherwise. Cooper and Marzullo's definitions of these modalities established an im-portant conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [DJR93, GW94, CBDGF95, JMN95, SS95, GW96] </ref>. In practice, though, detection of Poss or Def suffers from two significant burdens. <p> We obtain algorithms for detecting Poss T and Def T by adapting (and, as we do so, optimizing) algorithms of Cooper and Marzullo [CM91] and Garg and Waldecker <ref> [GW94, GW96] </ref>. Modalities based on e ! are quite different, because e ! (unlike e e i) is not a partial ordering. In fact, e ! yields a degenerate case, in which the analogues of Poss and Def are equivalent. <p> This principle underlies detection algorithms of Cooper and Marzullo [CM91] and Garg and Waldecker <ref> [GW94, GW96] </ref>. <p> both cases, the worst-case time complexity is linear in E, which is normally much larger than N ; in contrast, the worst-case time complexity of general algorithms for detecting Poss and Def is (E N ). 4.2 Algorithms for Poss T and Def T for Restricted Predicates Garg and Waldecker <ref> [GW94, GW96] </ref> have developed efficient algorithms for detecting Poss and Def for conjunctive predicates . A predicate is conjunctive if it is a conjunction of predicates that each depend on the local state of one process. <p> Note that the time complexity is independent of the rate of events and the quality of clock synchronization. The algorithm in <ref> [GW96] </ref> for detecting Def for conjunctive can be adapted in a similar way to detect Def T for such predicates.
Reference: [JMN95] <author> R. Jegou, R. Medina, and L. Nourine. </author> <title> Linear space algorithm for on-line detection of global predicates. </title> <editor> In J. Desel, editor, </editor> <booktitle> Proc. Int'l. Workshop on Structures in Concurrency Theory (STRICT '95). </booktitle> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: Web: http://www.cs.indiana.edu/~stoller/ 2 In this paper, all partial orderings are irreflexive unless specified otherwise. Cooper and Marzullo's definitions of these modalities established an im-portant conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [DJR93, GW94, CBDGF95, JMN95, SS95, GW96] </ref>. In practice, though, detection of Poss or Def suffers from two significant burdens.
Reference: [Lam78] <author> L. Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 558-564, </pages> <year> 1978. </year>
Reference-contexts: Cooper and Marzullo proposed a solution for asynchronous distributed systems [CM91]. Their solution involves two modalities, which we denote by Poss (read "possibly") and Def (read "definitely"). These modalities are based on logical time <ref> [Lam78] </ref> as embodied in the happened-before relation e ! hb , a partial ordering 2 of events that reflects causal dependencies. Happened-before is not a total order, so it does not uniquely determine the history, but it does restrict the possibilities.
Reference: [Mil91] <author> D. L. Mills. </author> <title> Internet time synchronization: the Network Time Protocol. </title> <journal> IEEE Trans. Communications, </journal> <volume> 39(10) </volume> <pages> 1482-1493, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: In most local-area distributed systems, protocols like NTP can efficiently maintain synchronization of clocks to within a few milliseconds [Mil95]. Even in extremely wide-area distributed systems like the Internet, clock synchronization can usually be maintained to within a few tens of milliseconds <ref> [Mil91] </ref>.
Reference: [Mil95] <author> D. L. Mills. </author> <title> Improved algorithms for synchronizing computer network clocks. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 3(3) </volume> <pages> 245-254, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Implementing such timestamps is straightforward assuming the underlying clock synchronization mechanism provides bounds on the offsets between clocks (the offset between two clocks (at some instant) is the difference in their values). For example, such information can be obtained from NTP <ref> [Mil95] </ref> or the Distributed Time Service in OSF DCE [Tan95]. The quality of clock synchronization affects e e ! and therefore affects the results of detection. For example, consider Inst . <p> We expect the above condition on the bounds on the offsets to hold in many systems. In most local-area distributed systems, protocols like NTP can efficiently maintain synchronization of clocks to within a few milliseconds <ref> [Mil95] </ref>. Even in extremely wide-area distributed systems like the Internet, clock synchronization can usually be maintained to within a few tens of milliseconds [Mil91].
Reference: [MN91] <author> K. Marzullo and G. Neiger. </author> <title> Detection of global state predicates. </title> <booktitle> In Proc. 5th Int'l. Workshop on Distributed Algorithms (WDAG '91), vol. 579 of Lecture Notes in Computer Science, </booktitle> <pages> pages 254-272. </pages> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: We consider first general algorithms for Poss T and Def T and then more efficient algorithms that work only for predicates of a certain form. 4.1 General Algorithms for Poss T and Def T The algorithms in <ref> [CM91, MN91] </ref> can be adapted to explore lattice hCGS e by (roughly) replacing each condition of the form e e ! hb e 0 with e e ie 0 . Following [CM91, MN91], we give algorithms in which the monitor constructs one level of the lattice of CGSs at a time. <p> only for predicates of a certain form. 4.1 General Algorithms for Poss T and Def T The algorithms in <ref> [CM91, MN91] </ref> can be adapted to explore lattice hCGS e by (roughly) replacing each condition of the form e e ! hb e 0 with e e ie 0 . Following [CM91, MN91], we give algorithms in which the monitor constructs one level of the lattice of CGSs at a time. The level of a global state g is P N Level ` of the lattice of CGSs contains the CGSs with level `. <p> Another approach (described in <ref> [MN91] </ref>) requires knowledge of a bound on message latency: the monitor can use its own local clock and this bound to determine a lower bound on the ending time of the last local state it received from a process. <p> For example, expiration of a lease and granting of another lease to a different machine need not be related by happened-before, so Poss :cohrnt may be detected, even though coherence was maintained and Poss T :cohrnt would not be detected. 7 Related and Future Work Marzullo and Neiger <ref> [MN91] </ref> define two detection modalities for partially-syn chronous systems. <p> In the notation of this paper, those modalities are Poss e and Def ! MN , where e ! MN e 0 e e Combining logical and real-time orderings in this way exploits more information about the computation but requires that the system maintain vector clocks. In <ref> [MN91] </ref>, there is no discussion of an event ordering analogous to e ! or a modality analogous to Inst. Also, [MN91] considers only systems in which all clocks are always synchronized within a fixed offset *, while our framework accommodates varying quality of synchronization. <p> In <ref> [MN91] </ref>, there is no discussion of an event ordering analogous to e ! or a modality analogous to Inst. Also, [MN91] considers only systems in which all clocks are always synchronized within a fixed offset *, while our framework accommodates varying quality of synchronization.
Reference: [SM94] <author> R. Schwarz and F. Mattern. </author> <title> Detecting causal relationships in distributed computations: In search of the holy grail. </title> <journal> Distributed Computing, </journal> <volume> 7(3) </volume> <pages> 149-174, </pages> <year> 1994. </year>
Reference-contexts: Ideals of hEv (c); ! hb i are usually called consistent cuts. Recall that for any partial order, the set of its ideals ordered by inclusion () forms a lattice [DJR93]. Furthermore, the lattice of CGSs ordered by G is isomorphic to the lattice of consistent cuts <ref> [SM94, BM93] </ref>. This isomorphism has an important consequence for detection algorithms; specifically, it implies that a minimal increase with respect to G corresponds to advancing one process by one event, and hence that the lattice of CGSs can be explored by repeatedly advancing one process by one event. <p> Proof. This is true for the same reasons as in the standard theory based on happened-before <ref> [SM94, BM93, DJR93] </ref>. The proof is straightforward. ut The following corollary underlies the detection algorithms in Sections 4 and 5. Corollary 2.
Reference: [SS95] <author> S. D. Stoller and F. B. Schneider. </author> <title> Faster possibility detection by combining two approaches. </title> <editor> In J.-M. Helary and M. Raynal, editors, </editor> <booktitle> Proc. 9th Int'l. Workshop on Distributed Algorithms (WDAG '95), vol. 972 of Lecture Notes in Computer Science, </booktitle> <pages> pages 318-332. </pages> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: Web: http://www.cs.indiana.edu/~stoller/ 2 In this paper, all partial orderings are irreflexive unless specified otherwise. Cooper and Marzullo's definitions of these modalities established an im-portant conceptual framework for predicate detection in asynchronous systems, which has been the basis for considerable research <ref> [DJR93, GW94, CBDGF95, JMN95, SS95, GW96] </ref>. In practice, though, detection of Poss or Def suffers from two significant burdens.
Reference: [Tan95] <author> A. S. Tanenbaum. </author> <title> Distributed Operating Systems. </title> <publisher> Prentice-Hall, </publisher> <year> 1995. </year>
Reference-contexts: For example, such information can be obtained from NTP [Mil95] or the Distributed Time Service in OSF DCE <ref> [Tan95] </ref>. The quality of clock synchronization affects e e ! and therefore affects the results of detection. For example, consider Inst .
Reference: [Ver93] <author> P. Verissimo. </author> <title> Real-time communication. In Sape Mullender, editor, </title> <journal> Distributed Systems, ch. </journal> <volume> 17, </volume> <pages> pages 447-490. </pages> <publisher> Addison Wesley, </publisher> <editor> 2nd ed., </editor> <year> 1993. </year>
Reference-contexts: In [MN91], there is no discussion of an event ordering analogous to e ! or a modality analogous to Inst. Also, [MN91] considers only systems in which all clocks are always synchronized within a fixed offset *, while our framework accommodates varying quality of synchronization. Verissimo <ref> [Ver93] </ref> discusses the uncertainty in event orderings caused by the granularity 6 and imperfect synchronization of digital real-time clocks, analyzes the conditions under which this uncertainty is significant for an application, and describes a synchronization technique, suitable for certain applications, that masks this uncertainty. However, [Ver93] does not aim for a <p> Verissimo <ref> [Ver93] </ref> discusses the uncertainty in event orderings caused by the granularity 6 and imperfect synchronization of digital real-time clocks, analyzes the conditions under which this uncertainty is significant for an application, and describes a synchronization technique, suitable for certain applications, that masks this uncertainty. However, [Ver93] does not aim for a general approach to detecting global predicates in the presence of this uncertainty. This paper proposes a foundation for detection of global predicate in systems with approximately-synchronized real-time clocks. One direction for future work is to implement and gain experience with the detection algorithms.
References-found: 18

