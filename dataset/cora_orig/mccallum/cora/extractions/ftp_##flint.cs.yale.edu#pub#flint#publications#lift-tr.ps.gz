URL: ftp://flint.cs.yale.edu/pub/flint/publications/lift-tr.ps.gz
Refering-URL: http://daffy.cs.yale.edu/users/shao-zhong/papers.html
Root-URL: http://www.cs.yale.edu
Title: Optimal Type Lifting  
Author: Bratin Saha Zhong Shao 
Date: August 24, 1998  
Address: YALEU/DCS/TR-1159  
Affiliation: Yale University Department of Computer Science  Dept. of Computer Science Yale University  
Abstract: This research was sponsored in part by the DARPA ITO under the title "Software Evolution using HOT Language Technology", DARPA Order No. D888, issued under Contract No. F30602-96-2-0232, and in part by an NSF CAREER Award CCR-9501624, and NSF Grant CCR-9633390. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Defense Advanced Research Projects Agency or the U.S. Government. A preliminary version of this paper appeared in the second International Workshop on Types in Compilation, March 1998. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Executing the function doit results in three type applications arising from the Array.sub function, pair, and f. In each iteration, sub and pair are applied to types ff fl ff and ff respectively. A clever compiler may do a loop-invariant removal <ref> [1] </ref> to avoid the repeated type construction (e.g., ff fl ff) and application (e.g., pair [ff]). <p> Peyton Jones [21, 19, 20] also described a number of optimizations which are similar in spirit but have totally different aims. Appel [2] describes let hoisting in the context of ML. In general, using correctness preserving transformations as a compiler optimization <ref> [1, 2] </ref> is a well established technique, and has received quite a bit of attention in the functional programming area.
Reference: [2] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Minamide's [15] method, in fact, is a refinement of Tolmach's method to eliminate runtime construction of type parameters. Peyton Jones [21, 19, 20] also described a number of optimizations which are similar in spirit but have totally different aims. Appel <ref> [2] </ref> describes let hoisting in the context of ML. In general, using correctness preserving transformations as a compiler optimization [1, 2] is a well established technique, and has received quite a bit of attention in the functional programming area. <p> Peyton Jones [21, 19, 20] also described a number of optimizations which are similar in spirit but have totally different aims. Appel [2] describes let hoisting in the context of ML. In general, using correctness preserving transformations as a compiler optimization <ref> [1, 2] </ref> is a well established technique, and has received quite a bit of attention in the functional programming area.
Reference: [3] <author> A. Birrell, G. Nelson, S. Owicki, and E. Wobber. </author> <title> Network objects. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <year> 1993. </year>
Reference-contexts: Intensional type analysis [7, 28, 23], which is used by some compilers [28, 24] to support efficient data representation, also requires the propagation of type information into the target code. Run-time type information is also crucial to the implementation of tag-less garbage collection [29], pickling and marshalling <ref> [3] </ref>, and type dynamic [13]. However, the advantages of runtime type passing do not come for free.
Reference: [4] <author> C. Flanagan, A. Sabry, B. F. Duba, and M. Felleisen. </author> <title> The essence of compiling with continuations. </title> <booktitle> In Proc. ACM SIGPLAN '93 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 237-247, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Throughout the paper we take a few liberties with the syntax: we allow ourselves infix operators, multiple definitions in a single let expression to abbreviate a sequence of nested let expressions, and term applications that are at times not in A-Normal form <ref> [4] </ref>. <p> The details of the translation are given in [26]. FLINT is based upon a predicative variant of the Girard-Reynolds polymorphic -calculus [5, 22], with the term language written in A-normal form <ref> [4] </ref>. The monotypes are generated from variables, from Int, and through the ! constructor. Types in Core-FLINT include the monotypes, and are closed under function spaces and polymorphic quantification. We use T () to denote the type corresponding to the constructor .
Reference: [5] <author> J. Y. Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieur. </title> <type> PhD thesis, </type> <institution> University of Paris VII, </institution> <year> 1972. </year>
Reference-contexts: 1 Introduction Recent compilers for ML-like polymorphic languages [25, 27] have begun to use variants of the Girard-Reynolds polymorphic -calculus <ref> [5, 22] </ref> as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters [29, 28, 24] at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application. <p> The details of the translation are given in [26]. FLINT is based upon a predicative variant of the Girard-Reynolds polymorphic -calculus <ref> [5, 22] </ref>, with the term language written in A-normal form [4]. The monotypes are generated from variables, from Int, and through the ! constructor. Types in Core-FLINT include the monotypes, and are closed under function spaces and polymorphic quantification.
Reference: [6] <author> R. Harper and J. C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: We provide the implementation results at the end of this paper. 2 The Lifting Algorithm for Core-ML This section presents our optimal type lifting algorithm. We use an explicitly typed variant of the Core-ML calculus <ref> [6] </ref> (Figure 1) as the source and target languages. The type lifting algorithm (Figure 2) is expressed as a type-directed program transformation that lifts all type applications to the top-level. 2.1 The language We use an explicitly typed variant of the Core-ML calculus [6] as our source and target languages. <p> explicitly typed variant of the Core-ML calculus <ref> [6] </ref> (Figure 1) as the source and target languages. The type lifting algorithm (Figure 2) is expressed as a type-directed program transformation that lifts all type applications to the top-level. 2.1 The language We use an explicitly typed variant of the Core-ML calculus [6] as our source and target languages. The syntax is shown in Figure 1. <p> In general, using correctness preserving transformations as a compiler optimization [1, 2] is a well established technique, and has received quite a bit of attention in the functional programming area. In their study of the type theory of Standard ML, Harper and Mitchell <ref> [6] </ref> argued that an explicitly typed 18 interpretation of ML polymorphism has better semantic properties and scales more easily to cover the full language. The idea of passing types to polymorphic functions is exploited by Morrison et al. [16] in the implementation of Napier.
Reference: [7] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 130-141, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Maintaining type information in this manner helps to ensure the correctness of a compiler. More importantly, it also enables many interesting optimizations and applications. For example, both pretty-printing and debugging on polymorphic values require complete type information at runtime. Intensional type analysis <ref> [7, 28, 23] </ref>, which is used by some compilers [28, 24] to support efficient data representation, also requires the propagation of type information into the target code. Run-time type information is also crucial to the implementation of tag-less garbage collection [29], pickling and marshalling [3], and type dynamic [13]. <p> The work of Ohori on compiling record operations [17] is similarly based on a type passing interpretation of polymorphism. Jones [12] has proposed evidence passing|a general framework for passing data, derived from types, to "qualified" polymorphic operations. Harper and Morisett <ref> [7] </ref> proposed an alternative approach for compiling polymorphism where types are passed as arguments to polymorphic routines in order to determine the representation of an object.
Reference: [8] <author> P. Hudak, S. P. Jones, and P. W. et al. </author> <title> Report on the programming language Haskell, a non-strict, purely functional language version 1.2. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(5), </volume> <month> May </month> <year> 1992. </year> <month> 19 </month>
Reference-contexts: On the other hand, we have implemented our algorithm on the entire SML'97 language with higher-order modules. Jones [11] has also worked on a similar problem related to the implementation of type classes in Haskell <ref> [8] </ref> and Gofer [11]. Type classes in these languages are implemented by dictionary passing and if done naively, can lead to the same dictionaries being created repeatedly. We will briefly compare our approach with his optimisations on dictionary passing. <p> We will briefly compare our approach with his optimisations on dictionary passing. Since the type systems and the implementation of dictionaries differs slightly in Haskell and Gofer, we will consider the two separately. Haskell <ref> [8] </ref> performs context reduction and simplifies the set of constraints in a type.
Reference: [9] <author> R. Hughes. </author> <title> The design and implementation of programming languages. </title> <type> PhD thesis, </type> <institution> Programming Research Group, Oxford University, Oxford, UK, </institution> <year> 1983. </year>
Reference-contexts: In our case, type abstractions are never introduced. The lifting of type applications is similar in spirit to the hoisting of loop invariant expressions. It could be considered as a special case of a fully lazy transformation <ref> [9, 20] </ref> with the maximal free subexpressions restricted to be type applications. However, the fully-lazy transformation as described in Peyton Jones [20] will not lift all type applications to the top level.
Reference: [10] <author> T. Johnsson. </author> <title> Lambda Lifting: Transforming Programs to Recursive Equations. </title> <booktitle> In The Second International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 190-203, </pages> <address> New York, </address> <month> September </month> <year> 1985. </year> <note> Springer-Verlag. </note>
Reference-contexts: One is the lifting of type applications and the other is the lifting of polymorphic function definitions. At first glance, the lifting of function definitions may seem similar to lambda lifting <ref> [10] </ref>. However the lifting in the two cases is different. Lambda lifting converts a program with local function definitions into a program consisting only of global function definitions whereas the lifting shown here preserves the nesting structure of the program. <p> Consider the program fragment given below. (assuming f is externally defined) flfffifl.x 1 . let y 2 = flt 3 .x 3 . @(y 1 [fi*t 3 ])x 3 ... in @(y 3 [fi*fl])x 1 Johnsson-style lambda-lifting <ref> [10] </ref> converts this into: y 1 = flfft 1 .x 2 . @(f [t 1 *ff])x 2 ... y 2 = flfffit 3 .x 3 . @(y 1 [ff][fi*t 3 ])x 3 ... y 3 = flfffiflt 5 .x 4 . @(y 2 [ff][fi][fl*t 3 ])x 4 ... expr = flfffifl.x
Reference: [11] <author> M. P. Jones. </author> <title> Qualified Types: Theory and Practice. </title> <type> PhD thesis, </type> <institution> Oxford University Computing Laboratory, Oxford, </institution> <month> july </month> <year> 1992. </year> <note> Technical Monograph PRG-106. </note>
Reference-contexts: Finally, Minamide's algorithm deals only with the Core-ML calculus and does not mention how his method may be extended to ML-style modules. On the other hand, we have implemented our algorithm on the entire SML'97 language with higher-order modules. Jones <ref> [11] </ref> has also worked on a similar problem related to the implementation of type classes in Haskell [8] and Gofer [11]. Type classes in these languages are implemented by dictionary passing and if done naively, can lead to the same dictionaries being created repeatedly. <p> On the other hand, we have implemented our algorithm on the entire SML'97 language with higher-order modules. Jones <ref> [11] </ref> has also worked on a similar problem related to the implementation of type classes in Haskell [8] and Gofer [11]. Type classes in these languages are implemented by dictionary passing and if done naively, can lead to the same dictionaries being created repeatedly. We will briefly compare our approach with his optimisations on dictionary passing. <p> He repeats this for all overloaded functions so that all dictionaries are created statically. But this approach does not work with separately compiled modules since the type of f being exported to other modules does not specify the dictionaries that are constructed inside it. In Gofer <ref> [11] </ref>, however, instance declarations are not used to simplify the context. Therefore the type of f in the above example would still be Eq [a] =&gt; a ! a ! Bool. Jones' optimisation can now be performed even in the presence of separately compiled modules.
Reference: [12] <author> M. P. Jones. </author> <title> A theory of qualified types. </title> <booktitle> In The 4th European Symposium on Programming, </booktitle> <pages> pages 287-306, </pages> <address> Berlin, </address> <month> February </month> <year> 1992. </year> <pages> Spinger-Verlag. </pages>
Reference-contexts: However, the disadvantage is that he can no longer type-check his transformation with the existing type system; instead, he 17 has to use an auxiliary type system based on the qualified type system of Jones <ref> [12] </ref>, and the implementation calculus for the compilation of polymorphic records of Ohori [17]. Our algorithm on the other hand is a source-to-source transformation. Finally, Minamide's algorithm deals only with the Core-ML calculus and does not mention how his method may be extended to ML-style modules. <p> The idea of passing types to polymorphic functions is exploited by Morrison et al. [16] in the implementation of Napier. The work of Ohori on compiling record operations [17] is similarly based on a type passing interpretation of polymorphism. Jones <ref> [12] </ref> has proposed evidence passing|a general framework for passing data, derived from types, to "qualified" polymorphic operations. Harper and Morisett [7] proposed an alternative approach for compiling polymorphism where types are passed as arguments to polymorphic routines in order to determine the representation of an object.
Reference: [13] <author> X. Leroy and M. Mauny. </author> <title> Dynamics in ML. </title> <booktitle> In The Fifth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 406-426, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: Run-time type information is also crucial to the implementation of tag-less garbage collection [29], pickling and marshalling [3], and type dynamic <ref> [13] </ref>. However, the advantages of runtime type passing do not come for free.
Reference: [14] <author> R. Milner, M. Tofte, R. Harper, and D. MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: The tapp rule also assumes that the type application is not curried and therefore the newly introduced variable v (bound to the lifted type application) is monomorphic and is not instantiated by further type application. Finally, following SML <ref> [14] </ref>, polymorphic functions are not initialization and module linkage (e.g., functor application) in a ML-style module language. 3 recursive. 2 This restriction is crucial to proving that all type applications can be lifted to the top level. <p> But what happens when we take into account the SML module language <ref> [14] </ref> as well? To handle the Full-ML langauge, we compile the source code into the FLINT intermediate language 3. The details of the translation are given in [26].
Reference: [15] <author> Y. Minamide. </author> <title> Full lifting of type parameters. </title> <type> Technical report, </type> <institution> RIMS, Kyoto University, </institution> <year> 1997. </year>
Reference-contexts: For example, Tolmach [29] implemented a tag-free garbage collector via explicit type passing; he reported that the memory allocated for type information sometimes exceeded the memory saved by the tag-free approach. Clearly, it is desirable to optimize the run-time type passing in polymorphic code <ref> [15] </ref>. In fact, a better goal would be to guarantee that explicit type passing never blows up the execution cost of a program. Consider the sample code below we took some liberties with the syntax by using an explicitly typed variant of the Core-ML. <p> at the beginning of this subsection. flfffifl. let u = fi*fl let let u 1 = f [t 1 *ff] y 2 = flt 3 . in x 3 . @u 2 x 3 ... let u 3 = y 2 [fl*t 5 ] in @(y 3 [u])x 1 Minamide <ref> [15] </ref> has also worked on the same problem but uses an entirely different approach from ours. Instead of constructing types inside functions, he constructs them at the call sites and passes them in as parameters. This transformation is recursively propagated to the call sites at the top level. <p> So the method used by Jones for optimising dictionary passing does not extend to the Full-ML language. Tolmach [29] has worked on a similar problem and proposed a method based on the lazy substitution on types. He used the method in the implementation of the tag-free garbage collector. Minamide's <ref> [15] </ref> method, in fact, is a refinement of Tolmach's method to eliminate runtime construction of type parameters. Peyton Jones [21, 19, 20] also described a number of optimizations which are similar in spirit but have totally different aims. Appel [2] describes let hoisting in the context of ML.
Reference: [16] <author> R. Morrison, A. Dearle, R. C. H. Connor, and A. L. Brown. </author> <title> An ad hoc approach to the implementation of polymorphism. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 13(3), </volume> <month> July </month> <year> 1991. </year>
Reference-contexts: The idea of passing types to polymorphic functions is exploited by Morrison et al. <ref> [16] </ref> in the implementation of Napier. The work of Ohori on compiling record operations [17] is similarly based on a type passing interpretation of polymorphism. Jones [12] has proposed evidence passing|a general framework for passing data, derived from types, to "qualified" polymorphic operations.
Reference: [17] <author> A. Ohori. </author> <title> A compilation method for ML-style polymorphic record calculi. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <address> New York, Jan 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: However, the disadvantage is that he can no longer type-check his transformation with the existing type system; instead, he 17 has to use an auxiliary type system based on the qualified type system of Jones [12], and the implementation calculus for the compilation of polymorphic records of Ohori <ref> [17] </ref>. Our algorithm on the other hand is a source-to-source transformation. Finally, Minamide's algorithm deals only with the Core-ML calculus and does not mention how his method may be extended to ML-style modules. On the other hand, we have implemented our algorithm on the entire SML'97 language with higher-order modules. <p> The idea of passing types to polymorphic functions is exploited by Morrison et al. [16] in the implementation of Napier. The work of Ohori on compiling record operations <ref> [17] </ref> is similarly based on a type passing interpretation of polymorphism. Jones [12] has proposed evidence passing|a general framework for passing data, derived from types, to "qualified" polymorphic operations.
Reference: [18] <author> S. Peyton Jones. </author> <title> Implementing lazy functional languages on stock hardware: </title> <journal> the Spineless Tagless G-machine. Journal of Functional Programming, </journal> <volume> 2(2) </volume> <pages> 127-202, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Harper and Morisett [7] proposed an alternative approach for compiling polymorphism where types are passed as arguments to polymorphic routines in order to determine the representation of an object. Many modern compilers like the FLINT/ML compiler [24], TIL [28] and the Glasgow Haskell compiler <ref> [18] </ref> use an explicitly typed language as the intermediate language in the compilation. 6 Conclusions We have proposed a method for minimizing the cost of runtime type passing. Our algorithm lifts all type applications out of functions and therefore eliminates the runtime construction of types inside functions.
Reference: [19] <author> S. Peyton Jones. </author> <title> Compiling haskell by program transformation: a report from trenches. </title> <booktitle> In Proceedings of the European Symposium on Programming, </booktitle> <address> Linkoping, </address> <month> April </month> <year> 1996. </year>
Reference-contexts: He used the method in the implementation of the tag-free garbage collector. Minamide's [15] method, in fact, is a refinement of Tolmach's method to eliminate runtime construction of type parameters. Peyton Jones <ref> [21, 19, 20] </ref> also described a number of optimizations which are similar in spirit but have totally different aims. Appel [2] describes let hoisting in the context of ML.
Reference: [20] <author> S. Peyton Jones and D. Lester. </author> <title> A modular fully-lazy lambda lifter in haskell. </title> <journal> Software Practice and Experience, </journal> <volume> 21 </volume> <pages> 479-506, </pages> <year> 1991. </year>
Reference-contexts: In our case, type abstractions are never introduced. The lifting of type applications is similar in spirit to the hoisting of loop invariant expressions. It could be considered as a special case of a fully lazy transformation <ref> [9, 20] </ref> with the maximal free subexpressions restricted to be type applications. However, the fully-lazy transformation as described in Peyton Jones [20] will not lift all type applications to the top level. <p> It could be considered as a special case of a fully lazy transformation [9, 20] with the maximal free subexpressions restricted to be type applications. However, the fully-lazy transformation as described in Peyton Jones <ref> [20] </ref> will not lift all type applications to the top level. Specifically, type applications of a polymorphic function defined inside other functions, will not be lifted to the top level. Our algorithm though, is guaranteed to lift all type applications to depth zero. <p> He used the method in the implementation of the tag-free garbage collector. Minamide's [15] method, in fact, is a refinement of Tolmach's method to eliminate runtime construction of type parameters. Peyton Jones <ref> [21, 19, 20] </ref> also described a number of optimizations which are similar in spirit but have totally different aims. Appel [2] describes let hoisting in the context of ML.
Reference: [21] <author> S. Peyton Jones, W. Partain, and A. Santos. Let-floating: </author> <title> moving bindings to give faster programs. </title> <booktitle> In Proc. International Conference on Functional Programming (ICFP'96), </booktitle> <address> New York, June 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: He used the method in the implementation of the tag-free garbage collector. Minamide's [15] method, in fact, is a refinement of Tolmach's method to eliminate runtime construction of type parameters. Peyton Jones <ref> [21, 19, 20] </ref> also described a number of optimizations which are similar in spirit but have totally different aims. Appel [2] describes let hoisting in the context of ML.
Reference: [22] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings, Colloque sur la Programmation, Lecture Notes in Computer Science, </booktitle> <volume> volume 19, </volume> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1974. </year>
Reference-contexts: 1 Introduction Recent compilers for ML-like polymorphic languages [25, 27] have begun to use variants of the Girard-Reynolds polymorphic -calculus <ref> [5, 22] </ref> as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters [29, 28, 24] at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application. <p> The details of the translation are given in [26]. FLINT is based upon a predicative variant of the Girard-Reynolds polymorphic -calculus <ref> [5, 22] </ref>, with the term language written in A-normal form [4]. The monotypes are generated from variables, from Int, and through the ! constructor. Types in Core-FLINT include the monotypes, and are closed under function spaces and polymorphic quantification.
Reference: [23] <author> Z. Shao. </author> <title> Flexible representation analysis. </title> <booktitle> In Proc. 1997 ACM SIGPLAN International Conference on Functional Programming (ICFP'97), </booktitle> <pages> pages 85-98. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: Maintaining type information in this manner helps to ensure the correctness of a compiler. More importantly, it also enables many interesting optimizations and applications. For example, both pretty-printing and debugging on polymorphic values require complete type information at runtime. Intensional type analysis <ref> [7, 28, 23] </ref>, which is used by some compilers [28, 24] to support efficient data representation, also requires the propagation of type information into the target code. Run-time type information is also crucial to the implementation of tag-less garbage collection [29], pickling and marshalling [3], and type dynamic [13].
Reference: [24] <author> Z. Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In Proc. 1997 ACM SIGPLAN Workshop on Types in Compilation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Recent compilers for ML-like polymorphic languages [25, 27] have begun to use variants of the Girard-Reynolds polymorphic -calculus [5, 22] as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters <ref> [29, 28, 24] </ref> at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application. Maintaining type information in this manner helps to ensure the correctness of a compiler. More importantly, it also enables many interesting optimizations and applications. <p> More importantly, it also enables many interesting optimizations and applications. For example, both pretty-printing and debugging on polymorphic values require complete type information at runtime. Intensional type analysis [7, 28, 23], which is used by some compilers <ref> [28, 24] </ref> to support efficient data representation, also requires the propagation of type information into the target code. Run-time type information is also crucial to the implementation of tag-less garbage collection [29], pickling and marshalling [3], and type dynamic [13]. <p> This will allow us to use a more sophisticated runtime type representation and make greater use of type information at runtime. We describe the algorithm in later sections and also prove that it is both type-preserving and semantically sound. We have implemented it in the FLINT/ML compiler <ref> [24] </ref> and tested it on a few benchmarks. We provide the implementation results at the end of this paper. 2 The Lifting Algorithm for Core-ML This section presents our optimal type lifting algorithm. <p> Harper and Morisett [7] proposed an alternative approach for compiling polymorphism where types are passed as arguments to polymorphic routines in order to determine the representation of an object. Many modern compilers like the FLINT/ML compiler <ref> [24] </ref>, TIL [28] and the Glasgow Haskell compiler [18] use an explicitly typed language as the intermediate language in the compilation. 6 Conclusions We have proposed a method for minimizing the cost of runtime type passing.
Reference: [25] <author> Z. Shao. </author> <title> Typed common intermediate format. </title> <booktitle> In Proc. 1997 USENIX Conference on Domain Specific Languages, </booktitle> <pages> pages 89-102, </pages> <month> October </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Recent compilers for ML-like polymorphic languages <ref> [25, 27] </ref> have begun to use variants of the Girard-Reynolds polymorphic -calculus [5, 22] as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters [29, 28, 24] at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application.
Reference: [26] <author> Z. Shao. </author> <title> Typed cross-module compilation. </title> <booktitle> In Proc. 1998 ACM SIGPLAN International Conference on Functional Programming (ICFP'98). </booktitle> <publisher> ACM Press, </publisher> <year> 1998. </year>
Reference-contexts: But what happens when we take into account the SML module language [14] as well? To handle the Full-ML langauge, we compile the source code into the FLINT intermediate language 3. The details of the translation are given in <ref> [26] </ref>. FLINT is based upon a predicative variant of the Girard-Reynolds polymorphic -calculus [5, 22], with the term language written in A-normal form [4]. The monotypes are generated from variables, from Int, and through the ! constructor. <p> Polymorphic functions may now escape as part of structures and get instantiated later at a functor application site. In the FLINT translation <ref> [26] </ref>, functors are represented as a combined type and value abstraction (fct = flt i :: k i : m x : :e). The variable x in the functor definition is polymorphic since the parameterised structure may contain polymorphic components. <p> The variable x in the functor definition is polymorphic since the parameterised structure may contain polymorphic components. In the functor body e, the polymorphic components of x may be instantiated by type application. Functor application itself consists of a type application and a term application <ref> [26] </ref>, with the type application instantiating the type parameters (t 0 i s). Though abstractions model both functors and functions, the translation allows us to distinguish between them. In the FLINT calculus, c x : T ():e denotes functions, whereas m x : :e denotes functors.
Reference: [27] <author> D. Tarditi. </author> <title> Design and Implementation of Code Optimizations for a Type-Directed Compiler for Standard ML. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1996. </year> <note> Tech Report CMU-CS-97-108. </note>
Reference-contexts: 1 Introduction Recent compilers for ML-like polymorphic languages <ref> [25, 27] </ref> have begun to use variants of the Girard-Reynolds polymorphic -calculus [5, 22] as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters [29, 28, 24] at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application.
Reference: [28] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 181-192. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction Recent compilers for ML-like polymorphic languages [25, 27] have begun to use variants of the Girard-Reynolds polymorphic -calculus [5, 22] as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters <ref> [29, 28, 24] </ref> at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application. Maintaining type information in this manner helps to ensure the correctness of a compiler. More importantly, it also enables many interesting optimizations and applications. <p> Maintaining type information in this manner helps to ensure the correctness of a compiler. More importantly, it also enables many interesting optimizations and applications. For example, both pretty-printing and debugging on polymorphic values require complete type information at runtime. Intensional type analysis <ref> [7, 28, 23] </ref>, which is used by some compilers [28, 24] to support efficient data representation, also requires the propagation of type information into the target code. Run-time type information is also crucial to the implementation of tag-less garbage collection [29], pickling and marshalling [3], and type dynamic [13]. <p> More importantly, it also enables many interesting optimizations and applications. For example, both pretty-printing and debugging on polymorphic values require complete type information at runtime. Intensional type analysis [7, 28, 23], which is used by some compilers <ref> [28, 24] </ref> to support efficient data representation, also requires the propagation of type information into the target code. Run-time type information is also crucial to the implementation of tag-less garbage collection [29], pickling and marshalling [3], and type dynamic [13]. <p> Harper and Morisett [7] proposed an alternative approach for compiling polymorphism where types are passed as arguments to polymorphic routines in order to determine the representation of an object. Many modern compilers like the FLINT/ML compiler [24], TIL <ref> [28] </ref> and the Glasgow Haskell compiler [18] use an explicitly typed language as the intermediate language in the compilation. 6 Conclusions We have proposed a method for minimizing the cost of runtime type passing.
Reference: [29] <author> A. Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. 1994 ACM Conf. on Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction Recent compilers for ML-like polymorphic languages [25, 27] have begun to use variants of the Girard-Reynolds polymorphic -calculus [5, 22] as their intermediate language (IL). Implementation of these ILs often involves passing types explicitly as parameters <ref> [29, 28, 24] </ref> at runtime: each polymorphic type variable gets instantiated to the actual type through run-time type application. Maintaining type information in this manner helps to ensure the correctness of a compiler. More importantly, it also enables many interesting optimizations and applications. <p> Intensional type analysis [7, 28, 23], which is used by some compilers [28, 24] to support efficient data representation, also requires the propagation of type information into the target code. Run-time type information is also crucial to the implementation of tag-less garbage collection <ref> [29] </ref>, pickling and marshalling [3], and type dynamic [13]. However, the advantages of runtime type passing do not come for free. <p> Government. A preliminary version of this paper appeared in the second International Workshop on Types in Compilation, March 1998. a program. For example, Tolmach <ref> [29] </ref> implemented a tag-free garbage collector via explicit type passing; he reported that the memory allocated for type information sometimes exceeded the memory saved by the tag-free approach. Clearly, it is desirable to optimize the run-time type passing in polymorphic code [15]. <p> Previously, we could pass either f or g as parameters. But now, since the two functions have different types, we cannot use them in the same context. So the method used by Jones for optimising dictionary passing does not extend to the Full-ML language. Tolmach <ref> [29] </ref> has worked on a similar problem and proposed a method based on the lazy substitution on types. He used the method in the implementation of the tag-free garbage collector. Minamide's [15] method, in fact, is a refinement of Tolmach's method to eliminate runtime construction of type parameters.
Reference: [30] <author> A. K. Wright. </author> <title> Polymorphism for imperative languages without imperative types. </title> <type> Technical Report Tech Report TR 93-200, </type> <institution> Dept. of Computer Science, Rice University, Houston, Texas, </institution> <month> February </month> <year> 1993. </year> <month> 20 </month>
Reference-contexts: The vterms (e v ) denote values terms that are free of side-effects. There are several aspects of this calculus that are worth noting. First, we restrict polymorphic definitions to value expressions (e v ) only, so that moving type applications and polymorphic definitions is semantically sound <ref> [30] </ref>. Variables introduced by normal -abstraction are always monomorphic, and polymorphic functions are introduced only by the let construct. In our calculus, type applications of polymorphic functions are never curried which implies that polymorphic functions do not escape.
References-found: 30

