URL: http://www.cs.ucsd.edu/users/mihir/papers/tcr-hash.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/mihir/papers/tcr-hash.html
Root-URL: http://www.cs.ucsd.edu
Email: E-Mail: mihir@cs.ucsd.edu.  E-mail: rogaway@cs.ucdavis.edu.  
Title: Collision-Resistant Hashing: Towards Making UOWHFs Practical  
Author: Mihir Bellare Phillip Rogaway 
Web: URL: http://www-cse.ucsd.edu/users/mihir.  URL: http://wwwcsif.cs.ucdavis.edu/~rogaway.  
Address: San Diego, 9500 Gilman Drive, La Jolla, California 92093, USA.  CA 95616, USA.  
Affiliation: Dept. of Computer Science Engineering, University of California at  Science and Engineering. Dept. of Computer Science, Engineering II Bldg., University of California at Davis, Davis,  
Date: July 17, 1997  
Note: Lecture Notes in Computer Science Vol. B. Kaliski ed., Springer-Verlag, 1997. This is the full version.  Supported in part by NSF CAREER Award CCR-9624439 and a 1996 Packard Foundation Fellowship in  Supported in part by NSF CAREER Award CCR-9624560.  
Abstract: An extended abstract of this paper appears in Advances in Cryptology - Crypto 97 Proceedings, Abstract Recent attacks on the cryptographic hash functions MD4 and MD5 make it clear that (strong) collision-resistance is a hard-to-achieve goal. We look towards a weaker notion, the universal one-way hash functions (UOWHFs) of Naor and Yung, and investigate their practical potential. The goal is to build UOWHFs not based on number theoretic assumptions, but from the primitives underlying current cryptographic hash functions like MD5 and SHA-1. Pursuing this goal leads us to new questions. The main one is how to extend a compression function to a full-fledged hash function in this new setting. We show that the classic Merkle-Damg-ard method used in the standard setting fails for these weaker kinds of hash functions, and we present some new methods that work. Our main construction is the "XOR tree." We also consider the problem of input length-variability and present a general solution. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Bellare, R. Canetti and H. Krawczyk, </author> <title> Keying hash functions for message authentication. </title> <booktitle> Advances in Cryptology - Crypto 96 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 1109, </volume> <editor> N. Koblitz ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The general approach to concrete, quantitative security that we are following began with [3]. A good deal of work has gone into keying hash functions for message authentication <ref> [1, 30, 19, 24] </ref>. In particular, HMAC is a popular solution to this problem [1, 20]. <p> The general approach to concrete, quantitative security that we are following began with [3]. A good deal of work has gone into keying hash functions for message authentication [1, 30, 19, 24]. In particular, HMAC is a popular solution to this problem <ref> [1, 20] </ref>. <p> Bellare, Canetti and Krawczyk [2] considered keyed compression functions as pseudorandom functions, and showed that applying the MD construction then yields a pseudorandom function. Again, the difference is that the notion of pseudorandomness relies on the secrecy of the key. A weaker-than-standard notion of hashing is considered in <ref> [1] </ref>. However their notion is based on a hidden key and hash functions meeting their notion, although useful in the message authentication setting, don't suffice for digital signatures, where the computation of the hash function must be public to enable signature verification. <p> do Level fl [j 1] Level [j 1] K (d lj ) Level [j] P H d lj (K; Level fl [j 1]) return Level [l] In other words, a d l block message M = Level [0] is hashed in l stages, resulting in strings Level [0] 1 Level <ref> [1] </ref> 2 l ! Level [l]. The last of these is the hash of M . Each stage cuts the message size by a factor of d. Stage j begins by XORing to Level [j 1] a sufficient number of copies of K j .
Reference: [2] <author> M. Bellare, R. Canetti and H. Krawczyk, </author> <title> Pseudorandom functions revisited: the cascade construction and its concrete security. </title> <booktitle> Proceedings of the 37th Symposium on Foundations of Computer Science, IEEE, </booktitle> <year> 1996. </year>
Reference-contexts: Bellare, Canetti and Krawczyk <ref> [2] </ref> considered keyed compression functions as pseudorandom functions, and showed that applying the MD construction then yields a pseudorandom function. Again, the difference is that the notion of pseudorandomness relies on the secrecy of the key. A weaker-than-standard notion of hashing is considered in [1].
Reference: [3] <author> M. Bellare, J. Kilian and P. Rogaway, </author> <title> The security of cipher block chaining. </title> <booktitle> Advances in Cryptology - Crypto 94 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 839, </volume> <editor> Y. Desmedt ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The general approach to concrete, quantitative security that we are following began with <ref> [3] </ref>. A good deal of work has gone into keying hash functions for message authentication [1, 30, 19, 24]. In particular, HMAC is a popular solution to this problem [1, 20].
Reference: [4] <author> M. Bellare and P. Rogaway, </author> <title> Collision-Resistant Hashing: Towards Making UOWHFs Practical. </title> <booktitle> Advances in Cryptology | Proceedings of CRYPTO '97, Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <note> Earlier version of this paper. </note>
Reference-contexts: However their notion is based on a hidden key and hash functions meeting their notion, although useful in the message authentication setting, don't suffice for digital signatures, where the computation of the hash function must be public to enable signature verification. A preliminary version of this paper appeared as <ref> [4] </ref>. This is the full version. 2 Notions of Hashing Hash functions like MD5 or SHA-1 have no explicit key. But no notion of collision-freeness has been offered for such a keyless setting.
Reference: [5] <author> M. Bellare and P. Rogaway. </author> <title> The exact security of digital signatures: How to sign with RSA and Rabin. </title> <booktitle> Advances in Cryptology - Eurocrypt 96 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 1070, </volume> <editor> U. Maurer ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: In the current work we are only concerned with reducing lengths, not in covering up algebraic properties of the underlying primitive. Thus we will assume that we already have in hand a secure signature scheme. Examples of such schemes are <ref> [5, 15, 7] </ref>. (The first requires ideal hash functions, aka random oracles, in addition to the assumption that RSA is one-way, while the second and third require only the assumption that RSA is one-way, but are less efficient. <p> We write interchangeably Sign sk (M ) and Sign (sk; M ). Security of signature schemes. Definitions for the security of signatures in an asymptotic setting were provided by Goldwasser, Micali and Rivest [16]. Concrete security definitions were provided in <ref> [5] </ref>. We follow the latter. A forgery finder FF takes as input a public key pk, and FF tries to forge a signature with respect to pk. To do this it is allowed a chosen message attack.
Reference: [6] <author> T. Cormen, C. Leiserson and R. Rivest, </author> <title> Introduction to Algorithms. </title> <publisher> McGraw-Hill, </publisher> <year> 1992. </year>
Reference-contexts: There are two notions of security. We will define both below. First some technicalities. Programs and timing. We fix some RAM (random access machine) model of computation, including pointers, as in any algorithms text (eg. <ref> [6] </ref>), and we measure execution time of a program with respect to that model. An adversary is a program for our model, written in some fixed programming language.
Reference: [7] <author> R. Cramer and I. Damg -ard, </author> <title> New generation of secure and practical RSA based signatures. </title> <booktitle> Advances in Cryptology - Crypto 96 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 1109, </volume> <editor> N. Koblitz ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: In the current work we are only concerned with reducing lengths, not in covering up algebraic properties of the underlying primitive. Thus we will assume that we already have in hand a secure signature scheme. Examples of such schemes are <ref> [5, 15, 7] </ref>. (The first requires ideal hash functions, aka random oracles, in addition to the assumption that RSA is one-way, while the second and third require only the assumption that RSA is one-way, but are less efficient.
Reference: [8] <author> I. Damg -ard, </author> <title> Collision Free Hash Functions and Public Key Signature Schemes. </title> <booktitle> Advances in Cryptology - Eurocrypt 87 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 304, </volume> <editor> D. Chaum ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <month> 29 </month>
Reference-contexts: No collisions have been found for the compression functions of SHA-1 and RIPEMD-160, and these may well be stronger. Keying. In the popular hash functions mentioned above there is no explicit key. But Damg-ard <ref> [8, 9] </ref> defines ACR via keyed functions, and it is in this setting that he proves the MD construction correct [9]. Keying hash functions seems essential for a meaningful formalization of security. <p> the above two results which effectively justify our restricting our attention to hash functions that resist equal-length collisions for some set of convenient input lengths. 6 1.6 Related Work We have already described the most closely related work, which is due to Naor and Yung [22], Merkle [21], and Damg-ard <ref> [8, 9] </ref>. The general approach to concrete, quantitative security that we are following began with [3]. A good deal of work has gone into keying hash functions for message authentication [1, 30, 19, 24]. In particular, HMAC is a popular solution to this problem [1, 20]. <p> In the keyed setting, it can be formalized like this (cf. <ref> [8, 9] </ref>). An adversary CF, called a collision-finder, is given K chosen at random from k and is said to succeed if it outputs a collision M; M 0 for F K .
Reference: [9] <author> I. Damg -ard, </author> <title> A Design Principle for Hash Functions. </title> <booktitle> Advances in Cryptology - Crypto 89 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 435, </volume> <editor> G. Brassard ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: We take a different approach. We integrate the notion with current hashing technology, looking to build UOWHFs out of MD5 and SHA-1 type primitives. The main technical issue we investigate is how to extend the classic Merkle-Damg-ard paradigm <ref> [21, 9] </ref> to the UOWHF setting. In other words, how to build "extended" UOWHFs out of UOW compression functions. We address practical issues like key sizes and input-length variability. <p> Still informally, f is said to be "any collision-resistant" (ACR) if it is computationally hard to find a collision. The MD method. The Merkle-Damg-ard construction <ref> [21, 9] </ref> takes a function f : c+m ! c and extends it to a function M Df : fl ! c . Assume for simplicity that M = M 1 M n is a sequence of exactly n blocks, each block of m bits. <p> No collisions have been found for the compression functions of SHA-1 and RIPEMD-160, and these may well be stronger. Keying. In the popular hash functions mentioned above there is no explicit key. But Damg-ard <ref> [8, 9] </ref> defines ACR via keyed functions, and it is in this setting that he proves the MD construction correct [9]. Keying hash functions seems essential for a meaningful formalization of security. <p> Keying. In the popular hash functions mentioned above there is no explicit key. But Damg-ard [8, 9] defines ACR via keyed functions, and it is in this setting that he proves the MD construction correct <ref> [9] </ref>. Keying hash functions seems essential for a meaningful formalization of security. When one treats things carefully, then, a hash function F should not have the signature described above: it must take two arguments| one for the key K and one for the message M . <p> the above two results which effectively justify our restricting our attention to hash functions that resist equal-length collisions for some set of convenient input lengths. 6 1.6 Related Work We have already described the most closely related work, which is due to Naor and Yung [22], Merkle [21], and Damg-ard <ref> [8, 9] </ref>. The general approach to concrete, quantitative security that we are following began with [3]. A good deal of work has gone into keying hash functions for message authentication [1, 30, 19, 24]. In particular, HMAC is a popular solution to this problem [1, 20]. <p> In the keyed setting, it can be formalized like this (cf. <ref> [8, 9] </ref>). An adversary CF, called a collision-finder, is given K chosen at random from k and is said to succeed if it outputs a collision M; M 0 for F K . <p> We then define M DH according to: Algorithm M DH n (K; M ) C 0 IV C i H (K; C i1 k M i ) return C n For a picture, see Figure 2. Damg-ard <ref> [9] </ref> shows that if H is ACR then so is M DH n . It would be nice if this worked for TCR too. But it does not. The reason is a little subtle.
Reference: [10] <author> B. den Boer and A. Bosselaers, </author> <title> An attack on the last two rounds of MD4. </title> <booktitle> Advances in Cryptology - Crypto 91 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 576, </volume> <editor> J. Feigen-baum ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Cryptographic hash functions are much used, most importantly for digital signatures, and cheap constructions are highly desirable. But in recent years we have seen a spate of attacks <ref> [10, 11, 12, 13] </ref> bring down our most popular constructions, MD4 and MD5 [26, 27]. The conclusion is that the design of collision-resistant hash functions may be harder than we had thought. What can we do? One approach is to design new hash functions. <p> Most of the popular hash functions (MD4, MD5, SHA-1 and RIPEMD-160) use the MD construction. Thus the crucial component of each algorithm is the underlying compression function, and we want it to be ACR. But the compression function of MD4 is not: following den Boer and Bosselaers <ref> [10] </ref>, collisions were found by Dobbertin [12]. Later, collisions were found for the compression function of MD5, again by den Boer and Bosselaers [11], and in a stronger form by Dobbertin [13].
Reference: [11] <author> B. den Boer and A. Bosselaers, </author> <title> Collisions for the compression function of MD5. </title> <booktitle> Advances in Cryptology - Eurocrypt 93 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 765, </volume> <editor> T. Helleseth ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Cryptographic hash functions are much used, most importantly for digital signatures, and cheap constructions are highly desirable. But in recent years we have seen a spate of attacks <ref> [10, 11, 12, 13] </ref> bring down our most popular constructions, MD4 and MD5 [26, 27]. The conclusion is that the design of collision-resistant hash functions may be harder than we had thought. What can we do? One approach is to design new hash functions. <p> But the compression function of MD4 is not: following den Boer and Bosselaers [10], collisions were found by Dobbertin [12]. Later, collisions were found for the compression function of MD5, again by den Boer and Bosselaers <ref> [11] </ref>, and in a stronger form by Dobbertin [13]. These attacks are enough to give up on MD4 and MD5 from the point of view 3 of ACR. No collisions have been found for the compression functions of SHA-1 and RIPEMD-160, and these may well be stronger. Keying.
Reference: [12] <author> H. Dobbertin, </author> <title> Cryptanalysis of MD4. </title> <booktitle> Fast Software Encryption|Cambridge Workshop, Lecture Notes in Computer Science, </booktitle> <volume> vol. 1039, </volume> <editor> D. Gollman, ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Cryptographic hash functions are much used, most importantly for digital signatures, and cheap constructions are highly desirable. But in recent years we have seen a spate of attacks <ref> [10, 11, 12, 13] </ref> bring down our most popular constructions, MD4 and MD5 [26, 27]. The conclusion is that the design of collision-resistant hash functions may be harder than we had thought. What can we do? One approach is to design new hash functions. <p> Thus the crucial component of each algorithm is the underlying compression function, and we want it to be ACR. But the compression function of MD4 is not: following den Boer and Bosselaers [10], collisions were found by Dobbertin <ref> [12] </ref>. Later, collisions were found for the compression function of MD5, again by den Boer and Bosselaers [11], and in a stronger form by Dobbertin [13]. These attacks are enough to give up on MD4 and MD5 from the point of view 3 of ACR.
Reference: [13] <author> H. Dobbertin, </author> <title> Cryptanalysis of MD5. </title> <note> Rump Session of Eurocrypt 96, May 1996, http://www.iacr.org/conferences/ec96/rump/index.html. </note>
Reference-contexts: Cryptographic hash functions are much used, most importantly for digital signatures, and cheap constructions are highly desirable. But in recent years we have seen a spate of attacks <ref> [10, 11, 12, 13] </ref> bring down our most popular constructions, MD4 and MD5 [26, 27]. The conclusion is that the design of collision-resistant hash functions may be harder than we had thought. What can we do? One approach is to design new hash functions. <p> But the compression function of MD4 is not: following den Boer and Bosselaers [10], collisions were found by Dobbertin [12]. Later, collisions were found for the compression function of MD5, again by den Boer and Bosselaers [11], and in a stronger form by Dobbertin <ref> [13] </ref>. These attacks are enough to give up on MD4 and MD5 from the point of view 3 of ACR. No collisions have been found for the compression functions of SHA-1 and RIPEMD-160, and these may well be stronger. Keying. <p> It seems unlikely that this task would be harder than finding collisions in MD5 itself. It could even be easier! Alternatively, suppose one tries to use the well-known "envelope" method, setting MD5 flfl K (M ) = MD5 (KkM kK). It seems likely that any extension of Dobbertin's attack <ref> [13] </ref> which finds collisions in MD5 would also defeat MD5 flfl .
Reference: [14] <author> H. Dobbertin, A. Bosselaers and B. Preneel, RIPEMD-160: </author> <title> A strengthened version of RIPEMD, Fast Software Encryption, </title> <booktitle> Lecture Notes in Computer Science 1039, </booktitle> <editor> D. Gollmann, ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The conclusion is that the design of collision-resistant hash functions may be harder than we had thought. What can we do? One approach is to design new hash functions. This is being done, with SHA-1 [23] and RIPEMD-160 <ref> [14] </ref> being new designs which are more conservative then their predecessors. In this paper we suggest a complementary approach: weaken the goal, and then make do with hash functions meeting this weakened goal.
Reference: [15] <author> C. Dwork and M. Naor, </author> <title> An efficient existentially unforgeable signature scheme and its applications. </title> <booktitle> Advances in Cryptology - Crypto 94 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 839, </volume> <editor> Y. Desmedt ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In the current work we are only concerned with reducing lengths, not in covering up algebraic properties of the underlying primitive. Thus we will assume that we already have in hand a secure signature scheme. Examples of such schemes are <ref> [5, 15, 7] </ref>. (The first requires ideal hash functions, aka random oracles, in addition to the assumption that RSA is one-way, while the second and third require only the assumption that RSA is one-way, but are less efficient.
Reference: [16] <author> S. Goldwasser, S. Micali and R. Rivest, </author> <title> A digital signature scheme secure against adaptive chosen-message attacks. </title> <journal> SIAM Journal of Computing, </journal> <volume> Vol. 17, No. 2, </volume> <pages> pp. 281-308, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: We write interchangeably Sign sk (M ) and Sign (sk; M ). Security of signature schemes. Definitions for the security of signatures in an asymptotic setting were provided by Goldwasser, Micali and Rivest <ref> [16] </ref>. Concrete security definitions were provided in [5]. We follow the latter. A forgery finder FF takes as input a public key pk, and FF tries to forge a signature with respect to pk. To do this it is allowed a chosen message attack.
Reference: [17] <author> R. Impagliazzo and M. Naor, </author> <title> Efficient cryptographic schemes provably as secure as subset sum. </title> <journal> Journal of Cryptology, </journal> <volume> Vol. 9, No. 4, </volume> <month> Autumn </month> <year> 1996. </year>
Reference-contexts: Ask less of a hash function and it is less likely to disappoint! Luckily, a suitable weaker notion already exists: universal one-way hash functions (UOWHF), as defined by Naor and Yung [22]. But existing constructions, based on general or algebraic assumptions <ref> [22, 29, 17] </ref>, are not too efficient. We take a different approach. We integrate the notion with current hashing technology, looking to build UOWHFs out of MD5 and SHA-1 type primitives. <p> Our main motivation has been building TCR hash functions from primitives underlying popular cryptographic hash functions. But XOR trees can also be used to reduce key sizes for TCR hash functions built from combinatorial or algebraic primitives. For example, the subset sum based construction of <ref> [17] </ref> uses a key of size Ls bits to hash L bits to s bits, where s is a security parameter which controls subset sum instance sizes. (Think of s as a few hundred.) So the size of the key is even longer than the size of the data. <p> For example, when d = 2, c = 64, the resulting key length of k + 128 lg n is significantly smaller than for the basic tree scheme in the case where the key size of the compression function is quite big, as happens for examples in the constructions of <ref> [17] </ref>. We now proceed with the analysis. Suppose ff 2 f0; : : : ; l 1g is a level of the tree. There are d lff nodes at this level, divided into d lff1 groups of d.
Reference: [18] <author> E. Petrank and C. Rackoff. </author> <title> CBC MAC for real time data sources. </title> <type> DIMACS Technical Report 97-26, </type> <year> 1997. </year>
Reference-contexts: The second hashing typically requires just one extra application of the compression function, since we are hashing a small, fixed length message. If the hash functions used are secure against equal-length target collisions, the result is secure against variable-length target collisions. See Petrank and Rackoff <ref> [18] </ref> for a related way to address length variability in another context, namely the CBC MAC. Theorem 6.1 Fix m &gt; 0 and let Msgs 1 be a set of strings each of length less than 2 m .
Reference: [19] <author> B. Kaliski and M. Robshaw, </author> <title> Message Authentication with MD5. </title> <journal> RSA Labs' CryptoBytes, </journal> <volume> Vol. 1 No. 1, </volume> <month> Spring </month> <year> 1995. </year>
Reference-contexts: The general approach to concrete, quantitative security that we are following began with [3]. A good deal of work has gone into keying hash functions for message authentication <ref> [1, 30, 19, 24] </ref>. In particular, HMAC is a popular solution to this problem [1, 20].
Reference: [20] <author> H. Krawczyk, M. Bellare and R. Canetti, HMAC: </author> <title> Keyed-Hashing for Message Authentication, Internet RFC 2104, </title> <month> February </month> <year> 1997. </year>
Reference-contexts: The general approach to concrete, quantitative security that we are following began with [3]. A good deal of work has gone into keying hash functions for message authentication [1, 30, 19, 24]. In particular, HMAC is a popular solution to this problem <ref> [1, 20] </ref>.
Reference: [21] <author> R. Merkle, </author> <title> One way hash functions and DES. </title> <booktitle> Advances in Cryptology - Crypto 89 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 435, </volume> <editor> G. Brassard ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1989 </year>
Reference-contexts: We take a different approach. We integrate the notion with current hashing technology, looking to build UOWHFs out of MD5 and SHA-1 type primitives. The main technical issue we investigate is how to extend the classic Merkle-Damg-ard paradigm <ref> [21, 9] </ref> to the UOWHF setting. In other words, how to build "extended" UOWHFs out of UOW compression functions. We address practical issues like key sizes and input-length variability. <p> Still informally, f is said to be "any collision-resistant" (ACR) if it is computationally hard to find a collision. The MD method. The Merkle-Damg-ard construction <ref> [21, 9] </ref> takes a function f : c+m ! c and extends it to a function M Df : fl ! c . Assume for simplicity that M = M 1 M n is a sequence of exactly n blocks, each block of m bits. <p> It is the above two results which effectively justify our restricting our attention to hash functions that resist equal-length collisions for some set of convenient input lengths. 6 1.6 Related Work We have already described the most closely related work, which is due to Naor and Yung [22], Merkle <ref> [21] </ref>, and Damg-ard [8, 9]. The general approach to concrete, quantitative security that we are following began with [3]. A good deal of work has gone into keying hash functions for message authentication [1, 30, 19, 24]. In particular, HMAC is a popular solution to this problem [1, 20].
Reference: [22] <author> M. Naor and M. Yung, </author> <title> Universal one-way hash functions and their cryptographic applications. </title> <booktitle> Proceedings of the 21st Annual Symposium on Theory of Computing, ACM, </booktitle> <year> 1989. </year>
Reference-contexts: Ask less of a hash function and it is less likely to disappoint! Luckily, a suitable weaker notion already exists: universal one-way hash functions (UOWHF), as defined by Naor and Yung <ref> [22] </ref>. But existing constructions, based on general or algebraic assumptions [22, 29, 17], are not too efficient. We take a different approach. We integrate the notion with current hashing technology, looking to build UOWHFs out of MD5 and SHA-1 type primitives. <p> Ask less of a hash function and it is less likely to disappoint! Luckily, a suitable weaker notion already exists: universal one-way hash functions (UOWHF), as defined by Naor and Yung [22]. But existing constructions, based on general or algebraic assumptions <ref> [22, 29, 17] </ref>, are not too efficient. We take a different approach. We integrate the notion with current hashing technology, looking to build UOWHFs out of MD5 and SHA-1 type primitives. <p> The points M and M 0 may depend arbitrarily on K; any pair of distinct points will do. In the notion of Naor and Yung <ref> [22] </ref> the adversary no longer wins by finding just any collision. <p> We call this weakened notion of security target collision-resistance (TCR). (In the terminology of <ref> [22] </ref> it is universal one-wayness.) Naor and Yung [22] formalize this via the standard "polynomial-time adversaries achieve negligible success probability" approach of asymptotic cryptography. In order to get results which are more directly meaningful for practice, our formalization is non-asymptotic. See Section 2. No birthdays. <p> We call this weakened notion of security target collision-resistance (TCR). (In the terminology of <ref> [22] </ref> it is universal one-wayness.) Naor and Yung [22] formalize this via the standard "polynomial-time adversaries achieve negligible success probability" approach of asymptotic cryptography. In order to get results which are more directly meaningful for practice, our formalization is non-asymptotic. See Section 2. No birthdays. <p> The problem is that our keys are public (they are available to the adversary) and pseudorandom generators are of no apparent use in such a context. 5 same method <ref> [22, Section 2.3] </ref>. We recall this basic tree construction in Section 5.4 and provide a concrete analysis of its security. Then we look at key sizes. <p> It is the above two results which effectively justify our restricting our attention to hash functions that resist equal-length collisions for some set of convenient input lengths. 6 1.6 Related Work We have already described the most closely related work, which is due to Naor and Yung <ref> [22] </ref>, Merkle [21], and Damg-ard [8, 9]. The general approach to concrete, quantitative security that we are following began with [3]. A good deal of work has gone into keying hash functions for message authentication [1, 30, 19, 24]. <p> In this case we omit from the notation above. Informally, we say that F is "any collision-resistant" (ACR) if for every collision-finder who (t; *)- breaks F , the ratio t=* is large. 2.2 Target Collision-Resistance | TCR In the notion of <ref> [22] </ref> the adversary does not get credit for finding any old collision. The adversary must still find a collision M; M 0 , but now M is not allowed to depend on the key: the adversary must choose it before the key K is known. <p> We call M 0 the sibling message. The sibling message can depend on the key, but the target message can not. 8 The formalization of <ref> [22] </ref> was asymptotic. Here we provide a concrete one, and call this version of the notion target collision-resistance (TCR). We begin with some special cases. <p> This is not true for the alternative notion. 3 Composition Lemmas It is useful to hash a long string in stages, first cutting down its length via one hash function, then applying another to this output to cut it down further. Naor and Yung <ref> [22] </ref> considered this kind of composition in the context of TCR hash functions. We first state a concrete version of their lemma and then extend it to an equal-length collision analogue which is in fact what we will use. <p> From the proof of Naor and Yung's composition lemma <ref> [22] </ref> we extract the concrete security parameters to get the following. For completeness a proof is provided in Appendix A. <p> We are slightly more general than <ref> [22] </ref>, considering d-ary trees for d 2, and also allowing the message to be hashed to have a number of blocks less than the maximum, as opposed to mandating that all messages have the maximum number of blocks. <p> Suppose N 1. Then P H N : k fi ( c [ N dc ) ! N c is (t; *)-resistant to equal-length target collisions, where * = N * 0 and t = t 0 fi (N dc). Proof: We extend and "concretize" the proof sketch in <ref> [22, Section 2.3] </ref>. Suppose CF = (CF-I; CF-II) is an equal length target collision finder which (t; *)-breaks P H N .
Reference: [23] <institution> National Institute of Standards, </institution> <type> FIPS 180-1, Secure hash standard. </type> <month> April </month> <year> 1995. </year>
Reference-contexts: The conclusion is that the design of collision-resistant hash functions may be harder than we had thought. What can we do? One approach is to design new hash functions. This is being done, with SHA-1 <ref> [23] </ref> and RIPEMD-160 [14] being new designs which are more conservative then their predecessors. In this paper we suggest a complementary approach: weaken the goal, and then make do with hash functions meeting this weakened goal.
Reference: [24] <author> B. Preneel and P. van Oorschot, </author> <title> MD-x MAC and building fast MACs from hash functions. </title> <booktitle> Advances in Cryptology - Crypto 95 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 963, </volume> <editor> D. Coppersmith ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <month> 30 </month>
Reference-contexts: The general approach to concrete, quantitative security that we are following began with [3]. A good deal of work has gone into keying hash functions for message authentication <ref> [1, 30, 19, 24] </ref>. In particular, HMAC is a popular solution to this problem [1, 20].
Reference: [25] <author> RIPE Consortium, </author> <title> Ripe Integrity primitives | Final report of RACE integrity primitives evaluation (R1040). </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 1007, </volume> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference: [26] <author> R. Rivest, </author> <title> The MD4 message-digest algorithm, </title> <booktitle> Advances in Cryptology - Crypto 90 Proceedings, Lecture Notes in Computer Science Vol. </booktitle> <volume> 537, </volume> <editor> A. J. Menezes and S. Vanstone ed., </editor> <publisher> Springer-Verlag, </publisher> <year> 1990, </year> <pages> pp. 303-311. </pages> <note> Also IETF RFC 1320 (April 1992). </note>
Reference-contexts: Cryptographic hash functions are much used, most importantly for digital signatures, and cheap constructions are highly desirable. But in recent years we have seen a spate of attacks [10, 11, 12, 13] bring down our most popular constructions, MD4 and MD5 <ref> [26, 27] </ref>. The conclusion is that the design of collision-resistant hash functions may be harder than we had thought. What can we do? One approach is to design new hash functions. <p> minimal number of zeros so that the length becomes 64 bits shy of a multiple of 512 bits, and then append jM j 64 | the length of M , encoded as a 64-bit binary number (assuming jM j &lt; 2 64 ). (This is the padding method used in <ref> [26] </ref> and many other hash function.) Let Pad () denote such a padding function. If H is secure against equal-length target collisions is H ffi Pad secure against variable-length target collisions? Not necessarily. And the same applies to ACR. It is easy to construct such examples.
Reference: [27] <author> R. Rivest, </author> <title> The MD5 message-digest algorithm. </title> <note> IETF RFC 1321 (April 1992). </note>
Reference-contexts: Cryptographic hash functions are much used, most importantly for digital signatures, and cheap constructions are highly desirable. But in recent years we have seen a spate of attacks [10, 11, 12, 13] bring down our most popular constructions, MD4 and MD5 <ref> [26, 27] </ref>. The conclusion is that the design of collision-resistant hash functions may be harder than we had thought. What can we do? One approach is to design new hash functions.
Reference: [28] <author> R. Rivest, A. Shamir and L. Adleman, </author> <title> "A method for obtaining digital signatures and public key cryptosystems," </title> <note> CACM 21 (1978). </note>
Reference-contexts: It remains to look at the running time of adversary CF. This is just t + 2T pad , from which the theorem follows. 7 Signing with a TCR Hash Function Consider the RSA signature primitive <ref> [28] </ref>, where one signs the number x 2 Z N by SignRSA d;N (x) = x d mod N , for appropriately chosen numbers d; N .
Reference: [29] <author> J. Rompel, </author> <title> One-way functions are necessary and sufficient for digital signatures. </title> <booktitle> Proceedings of the 22nd Annual Symposium on Theory of Computing, ACM, </booktitle> <year> 1990. </year>
Reference-contexts: Ask less of a hash function and it is less likely to disappoint! Luckily, a suitable weaker notion already exists: universal one-way hash functions (UOWHF), as defined by Naor and Yung [22]. But existing constructions, based on general or algebraic assumptions <ref> [22, 29, 17] </ref>, are not too efficient. We take a different approach. We integrate the notion with current hashing technology, looking to build UOWHFs out of MD5 and SHA-1 type primitives.
Reference: [30] <author> G. Tsudik, </author> <title> Message authentication with one-way hash functions, </title> <booktitle> Proceedings of Infocom 92, </booktitle> <publisher> IEEE Press, </publisher> <year> 1992. </year>
Reference-contexts: The general approach to concrete, quantitative security that we are following began with [3]. A good deal of work has gone into keying hash functions for message authentication <ref> [1, 30, 19, 24] </ref>. In particular, HMAC is a popular solution to this problem [1, 20].
Reference: [31] <author> S. Vaudenay, </author> <title> On the need for multipermutations: cryptanalysis of MD4 and SAFER. Fast Software Encryption | Leuven Workshop, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> vol. 1008, </volume> <publisher> Springer-Verlag, </publisher> <year> 1995, </year> <pages> 286-297. </pages>
Reference: [32] <author> Wegman and Carter, </author> <title> New hash functions and their use in authentication and set equality, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> Vol. 22, </volume> <year> 1981, </year> <pages> pp. 265-279. </pages>
Reference-contexts: The basic tree hash. To get major reductions in key size we turn to trees. Wegman and Carter <ref> [32] </ref> give a tree-based construction of universal hash functions that reduces key sizes, and Naor and Yung have already pointed out that key lengths for UOWHFs can be reduced by the 1 It may be worth remarking that the obvious idea for reducing key size is to let the key be
Reference: [33] <author> H. Williams, </author> <title> "A modification of the RSA public key encryption procedure," </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> Vol. IT-26, No. 6, </volume> <month> November </month> <year> 1980. </year>
Reference-contexts: The usual practice, dating back to <ref> [33] </ref>, is to compute the signature s of a string M according to s = SignRSA d;N (h (M )), where h is some sort of hash function. When signing as above there are actually two unrelated reasons for using the hash function h.
References-found: 33

