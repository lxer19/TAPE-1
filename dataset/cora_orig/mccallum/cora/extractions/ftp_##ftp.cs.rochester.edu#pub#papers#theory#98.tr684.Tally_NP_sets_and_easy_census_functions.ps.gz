URL: ftp://ftp.cs.rochester.edu/pub/papers/theory/98.tr684.Tally_NP_sets_and_easy_census_functions.ps.gz
Refering-URL: http://www.cs.rochester.edu/trs/theory-trs.html
Root-URL: 
Email: goldsmit@cs.engr.uky.edu  ogihara@cs.rochester.edu  rothe@informatik.uni-jena.de  
Title: Tally NP Sets and Easy Census Functions  
Author: Judy Goldsmith Mitsunori Ogihara Jorg Rothe 
Note: 1 Supported in part by NSF grant CCR-9315354. 2 Supported in part by NSF CAREER Award CCR-9701911.  
Date: March 19, 1998  
Address: Lexington, KY 40506, USA  Rochester, NY 14627, USA  07740 Jena, Germany  
Affiliation: Department of Computer Science University of Kentucky  Department of Computer Science University of Rochester  Institut fur Informatik Friedrich-Schiller-Universitat Jena  
Abstract: 3 Supported in part by grants NSF-INT-9513368/DAAD-315-PRO-fo-ab and NSF-CCR-9322513 and by a NATO Postdoctoral Science Fellowship from the Deutscher Akademischer Austausch-dienst ("Gemeinsames Hochschulsonderprogramm III von Bund und Landern"). Current address: Department of Computer Science, University of Rochester, Rochester, NY 14627, USA. Work done in part while visiting the University of Kentucky and the University of Rochester. 
Abstract-found: 1
Intro-found: 1
Reference: [Adl78] <author> L. Adleman. </author> <title> Two theorems on random polynomial time. </title> <booktitle> In Proceedings of the 19th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 75-83, </pages> <year> 1978. </year> <month> 19 </month>
Reference-contexts: Since L is in MOD k P=poly with polynomial-time computable advice, it follows that L 2 MOD k P. Hence, PH MOD k P. In order to prove the second part, notice that BPP is in P=poly <ref> [Adl78] </ref> with an advice computable in (the function analog of) PH [Sip83,Lau83], and that PH P #P [1] by Toda's Theorem [Tod91]. An argument similar to the above shows that P = BPP.
Reference: [All91] <author> E. Allender. </author> <title> Limitations of the upward separation technique. </title> <journal> Mathematical Systems Theory, </journal> <volume> 24(1) </volume> <pages> 53-67, </pages> <year> 1991. </year>
Reference: [AR88] <author> E. Allender and R. Rubinstein. </author> <title> P-printable sets. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17(6) </volume> <pages> 1193-1202, </pages> <year> 1988. </year>
Reference-contexts: easy to compute ranking function [GS91,HR90], whether every P set is P-isomorphic to some rankable set [GH96], whether every sparse set in P is P-printable [HY84,AR88,RRW94], whether every infinite set in P has an infinite P-printable subset [AR88,HRW97a], whether every P-printable set is P-isomorphic to some tally set in P <ref> [AR88] </ref>, and whether every P set admits easy certificate schemes [HRW97a,HRW97b], to name just a few. Some of those questions arise in the field of data compression and are related to Kolmogorov complexity, some are linked to the question of whether one-way functions exist.
Reference: [BBS86] <author> J. Balcazar, R. Book, and U. Schoning. </author> <title> The polynomial-time hierarchy and sparse oracles. </title> <journal> Journal of the ACM, </journal> <volume> 33(3) </volume> <pages> 603-617, </pages> <year> 1986. </year>
Reference-contexts: Corollary 5.2 There exists an oracle D such that all sets in P D have a census function computable in FP D , yet there exists some set in P D that is not rankable by any function in FP D . Proof of Theorem 5.1. Balcazar et al. <ref> [BBS86] </ref> and Long and Selman [LS86] proved that the polynomial hierarchy does not collapse if and only if it does not collapse relative to every sparse oracle.
Reference: [BC93] <author> D. Bovet and P. Crescenzi. </author> <title> Introduction to the Theory of Complexity. </title> <publisher> Prentice Hall, </publisher> <year> 1993. </year>
Reference: [BG92] <author> R. Beigel and J. Gill. </author> <title> Counting classes: Thresholds, parity, </title> <journal> mods, and fewness. Theoretical Computer Science, </journal> <volume> 103(1) </volume> <pages> 3-23, </pages> <year> 1992. </year>
Reference: [BH77] <author> L. Berman and J. Hartmanis. </author> <title> On isomorphisms and density of NP and other complete sets. </title> <journal> SIAM Journal on Computing, </journal> <volume> 6(2) </volume> <pages> 305-322, </pages> <year> 1977. </year>
Reference: [Boo74] <author> R. </author> <title> Book. Tally languages and complexity classes. </title> <journal> Information and Control, </journal> <volume> 26 </volume> <pages> 186-193, </pages> <year> 1974. </year>
Reference-contexts: The equivalence of (2) and (3) can be proven by means of standard translation|this is essentially the function analog of Book's result that every tally NP set is in P if and only if NE = E <ref> [Boo74] </ref> (see [Har83,HIS85] for the extension of this result to sparse sets). The equivalence of (2) and (4) is straightforward. It is easy to see that (2) implies (5).
Reference: [CH89] <author> J. Cai and L. Hemachandra. </author> <title> Enumerative counting is hard. </title> <journal> Information and Computation, </journal> <volume> 82(1) </volume> <pages> 34-44, </pages> <year> 1989. </year>
Reference-contexts: Cai and Hemaspaandra <ref> [CH89] </ref> introduced the notion of enumerative counting as a way of approximating the value of a #P function deterministically in polynomial time. 2 Hemaspaandra and Rudich [HR90] show that every P set is k-enumeratively rankable for some fixed k in polynomial time if and only if #P = FP. <p> By Lemma 3.11, our assumption implies that T 2 UP, and thus T 2 SPP. Since P SPP = SPP, S 2 SPP. The result now follows from the self-lowness of SPP [FFK94]. 4 Enumerative Approximation of Census Functions Cai and Hemaspaandra <ref> [CH89] </ref> introduced the notion of enumerative counting as a way of approximating the value of a #P function deterministically in polynomial time. Definition 4.1 [CH89] Let f : fl ! fl and g : N ! N be two functions. <p> The result now follows from the self-lowness of SPP [FFK94]. 4 Enumerative Approximation of Census Functions Cai and Hemaspaandra <ref> [CH89] </ref> introduced the notion of enumerative counting as a way of approximating the value of a #P function deterministically in polynomial time. Definition 4.1 [CH89] Let f : fl ! fl and g : N ! N be two functions. A Turing transducer E is a g (n)-enumerator of f if for all n 2 N and x 2 n , 1.
Reference: [CH90] <author> J. Cai and L. Hemachandra. </author> <title> On the power of parity polynomial time. </title> <journal> Mathematical Systems Theory, </journal> <volume> 23(2) </volume> <pages> 95-106, </pages> <year> 1990. </year>
Reference: [CH91] <author> J. Cai and L. Hemachandra. </author> <title> A note on enumerative counting. </title> <journal> Information Processing Letters, </journal> <volume> 38(4) </volume> <pages> 215-219, </pages> <year> 1991. </year>
Reference-contexts: Theorem 4.2 Let ff; fi &gt; 0 be constants. If every #P 1 function is n ff -enumerable in time n fi , then #P 1 FP. Proof. Cai and Hemaspaandra <ref> [CH91] </ref> show that for any fixed k, if #SAT (the function mapping any boolean formula f to the number of satisfying assignments of f ) is n k - enumerable, then #P FP.
Reference: [FFK94] <author> S. Fenner, L. Fortnow, and S. Kurtz. </author> <title> Gap-definable counting classes. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 48(1) </volume> <pages> 116-148, </pages> <year> 1994. </year>
Reference-contexts: Clearly, S polynomial-time truth-table reduces to some tally NP set T . By Lemma 3.11, our assumption implies that T 2 UP, and thus T 2 SPP. Since P SPP = SPP, S 2 SPP. The result now follows from the self-lowness of SPP <ref> [FFK94] </ref>. 4 Enumerative Approximation of Census Functions Cai and Hemaspaandra [CH89] introduced the notion of enumerative counting as a way of approximating the value of a #P function deterministically in polynomial time. Definition 4.1 [CH89] Let f : fl ! fl and g : N ! N be two functions.
Reference: [FSS84] <author> M. Furst, J. Saxe, and M. Sipser. </author> <title> Parity, circuits, and the polynomial-time hierarchy. </title> <journal> Mathematical Systems Theory, </journal> <volume> 17 </volume> <pages> 13-27, </pages> <year> 1984. </year>
Reference-contexts: Fix an oracle A such that PH A does not collapse (such oracles were constructed by Yao [Yao85], H-astad [H-as89], and Ko [Ko89] who built on the work of Furst et al. <ref> [FSS84] </ref>). Then, by Claim 5.3 above, for every sparse set S, PH AS does not collapse. So, in particular, P AS 6= NP AS for every sparse set S.
Reference: [GH96] <author> J. Goldsmith and S. Homer. </author> <title> Scalability and the isomorphism problem. </title> <journal> Information Processing Letters, </journal> <volume> 57 </volume> <pages> 137-143, </pages> <year> 1996. </year>
Reference-contexts: Among the questions that were previously studied are the question of whether or not every P set has an easy to compute ranking function [GS91,HR90], whether every P set is P-isomorphic to some rankable set <ref> [GH96] </ref>, whether every sparse set in P is P-printable [HY84,AR88,RRW94], whether every infinite set in P has an infinite P-printable subset [AR88,HRW97a], whether every P-printable set is P-isomorphic to some tally set in P [AR88], and whether every P set admits easy certificate schemes [HRW97a,HRW97b], to name just a few. <p> We also relate a set's property of having an easy census function to other well-studied properties of sets, such as rankability [GS91] and scalability <ref> [GH96] </ref>. In particular, though each rankable set has an easy census function, we show that (even when restricted to the sets in P) the converse is not true unless P = PP. <p> A language A is rankable if its ranking function is computable in polynomial time. Goldsmith and Homer <ref> [GH96] </ref> introduced the property of scalability, a more flexible notion than rankability in which the rank of some given element within the set is not necessarily determined with respect to the lexicographic order of fl , but rather with respect to any well-ordering of fl that can be "scaled" by a <p> Equivalently, the scalable sets are precisely those that are P-isomorphic to some rankable set. The definition below is based on this characterization. Definition 2.5 <ref> [GH96] </ref> A language A is scalable if it is P-isomorphic to a rankable set. <p> Proof. This is a simple interweaving of two diagonalizations. The only question is how to construct a non-scalable set. It is known from the work of Goldsmith and Homer <ref> [GH96] </ref> that any sparse set is scalable if and only if it is rankable, and this holds if and only if it is P-printable. 5 D will be sparse, with at most 2 strings at each length. <p> One might hope to prove (S) by exploiting again the fact that scalability, rankability, and P-printability are equivalent properties on the sparse sets <ref> [GH96] </ref>, which was useful in the proofs of Theorems 5.5 and 5.6.
Reference: [Gil77] <author> J. Gill. </author> <title> Computational complexity of probabilistic Turing machines. </title> <journal> SIAM Journal on Computing, </journal> <volume> 6(4) </volume> <pages> 675-695, </pages> <year> 1977. </year>
Reference-contexts: M is a spanP machineg. 4. spanP 1 df = fspan M j M is a tally spanP machineg. 5. #E = facc M j M is an NE machineg. 6. [MS72,Sto77] The polynomial hierarchy is inductively defined as follows: p df k = NP p df S p 7. <ref> [Gil77] </ref> PP is the class of languages L for which there exist a set A in P and a polynomial p such that for all strings x 2 fl , x 2 L () j fy j jyj = p (jxj) and hx; yi 2 Ag j 2 p (jxj)1 : <p> is the class of languages L for which there exist a set A in P and a polynomial p such that for all strings x 2 fl , x 2 L () j fy j jyj = p (jxj) and hx; yi 2 Ag j 2 p (jxj)1 : 8. <ref> [Gil77] </ref> BPP is the class of languages L for which there exist a set A in P and a polynomial p such that for all strings x 2 fl , x 2 L =) j fy j jyj = p (jxj) and hx; yi 62 Ag j 2 p (jxj)2 ;
Reference: [GP86] <author> L. Goldschlager and I. Parberry. </author> <title> On the construction of parallel computers from various bases of boolean functions. </title> <journal> Theoretical Computer Science, </journal> <volume> 43 </volume> <pages> 43-58, </pages> <year> 1986. </year>
Reference: [GS91] <author> A. Goldberg and M. Sipser. </author> <title> Compression and ranking. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(3) </volume> <pages> 524-536, </pages> <year> 1991. </year>
Reference-contexts: We also relate a set's property of having an easy census function to other well-studied properties of sets, such as rankability <ref> [GS91] </ref> and scalability [GH96]. In particular, though each rankable set has an easy census function, we show that (even when restricted to the sets in P) the converse is not true unless P = PP. <p> A P-isomorphism mapping set A fl to set B fl is order-preserving if for any two strings x and y satisfying either x; y 2 A or x; y 62 A, if x y, then (x) (y). Definition 2.4 <ref> [GS91] </ref> The ranking function of a language A fl is the function r : fl ! N that maps each x 2 fl to j fy x j y 2 Ag j. A language A is rankable if its ranking function is computable in polynomial time.
Reference: [Har83] <author> J. Hartmanis. </author> <title> On sparse sets in NPP. </title> <journal> Information Processing Letters, </journal> <volume> 16 </volume> <pages> 55-60, </pages> <year> 1983. </year>
Reference: [H-as89] <author> J. H-astad. </author> <title> Almost optimal lower bounds for small depth circuits. </title> <editor> In S. Micali, editor, </editor> <booktitle> Randomness and Computation, volume 5 of Advances in Computing Research, </booktitle> <pages> pages 143-170. </pages> <publisher> JAI Press, </publisher> <address> Greenwich, </address> <year> 1989. </year>
Reference-contexts: Fix an oracle A such that PH A does not collapse (such oracles were constructed by Yao [Yao85], H-astad <ref> [H-as89] </ref>, and Ko [Ko89] who built on the work of Furst et al. [FSS84]). Then, by Claim 5.3 above, for every sparse set S, PH AS does not collapse. So, in particular, P AS 6= NP AS for every sparse set S.
Reference: [Hem89] <author> L. Hemachandra. </author> <title> The strong exponential hierarchy collapses. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 39(3) </volume> <pages> 299-322, </pages> <year> 1989. </year>
Reference-contexts: densities and the results on P-printability [HY84, AR88,RRW94,GH96], the upward separation technique (e.g., [Har83,HIS85,All91,RRW94, HJ95], see [HHH] for more recent advances that are not based on census functions), the results on positive relativization and relativization to sparse oracles (e.g., [Lon85,LS86, 1 BBS86]), the unexpected collapse of the strong exponential-time hierarchy <ref> [Hem89] </ref>, and applications to extended lowness [HJRW]. Valiant, in his seminal papers [Val79a,Val79b], introduced #P, the class of functions that count the solutions of NP problems, and its tally version #P 1 for which the inputs are given in unary.
Reference: [Her90] <author> U. Hertrampf. </author> <title> Relations among MOD-classes. </title> <journal> Theoretical Computer Science, </journal> <volume> 74(3) </volume> <pages> 325-328, </pages> <year> 1990. </year>
Reference: [HHH] <author> E. Hemaspaandra, L. Hemaspaandra, and H. Hempel. </author> <title> A downward collapse within the polynomial hierarchy. </title> <journal> SIAM Journal on Computing. </journal> <note> To appear. </note>
Reference-contexts: and many other papers), the work on the existence of Turing-hard sparse sets (or of polynomial-size circuits) for various complexity classes (e.g., [KL80,KS85,BBS86,HR97]), the results relating the computation times for NP sets to their densities and the results on P-printability [HY84, AR88,RRW94,GH96], the upward separation technique (e.g., [Har83,HIS85,All91,RRW94, HJ95], see <ref> [HHH] </ref> for more recent advances that are not based on census functions), the results on positive relativization and relativization to sparse oracles (e.g., [Lon85,LS86, 1 BBS86]), the unexpected collapse of the strong exponential-time hierarchy [Hem89], and applications to extended lowness [HJRW].
Reference: [HIS85] <author> J. Hartmanis, N. Immerman, and V. Sewelson. </author> <title> Sparse sets in NPP: EXPTIME versus NEXPTIME. </title> <journal> Information and Control, </journal> 65(2/3):159-181, 1985. 
Reference-contexts: In fact, Hartmanis, Immerman, and Sewelson <ref> [HIS85] </ref> show that in some relativized world, NE = E and yet the (weak) exponential-time hierarchy does not collapse.
Reference: [HJ95] <author> L. Hemaspaandra and S. Jha. </author> <title> Defying upward and downward separation. </title> <journal> Information and Computation, </journal> <volume> 121 </volume> <pages> 1-13, </pages> <year> 1995. </year>
Reference-contexts: Hartmanis (e.g., [BH77,Mah82], and many other papers), the work on the existence of Turing-hard sparse sets (or of polynomial-size circuits) for various complexity classes (e.g., [KL80,KS85,BBS86,HR97]), the results relating the computation times for NP sets to their densities and the results on P-printability [HY84, AR88,RRW94,GH96], the upward separation technique (e.g., <ref> [Har83,HIS85,All91,RRW94, HJ95] </ref>, see [HHH] for more recent advances that are not based on census functions), the results on positive relativization and relativization to sparse oracles (e.g., [Lon85,LS86, 1 BBS86]), the unexpected collapse of the strong exponential-time hierarchy [Hem89], and applications to extended lowness [HJRW].
Reference: [HJRW] <author> L. Hemaspaandra, Z. Jiang, J. Rothe, and O. Watanabe. </author> <title> Boolean operations, joins, and the extended low hierarchy. </title> <note> Theoretical Computer Science. To appear. </note>
Reference-contexts: [HY84, AR88,RRW94,GH96], the upward separation technique (e.g., [Har83,HIS85,All91,RRW94, HJ95], see [HHH] for more recent advances that are not based on census functions), the results on positive relativization and relativization to sparse oracles (e.g., [Lon85,LS86, 1 BBS86]), the unexpected collapse of the strong exponential-time hierarchy [Hem89], and applications to extended lowness <ref> [HJRW] </ref>. Valiant, in his seminal papers [Val79a,Val79b], introduced #P, the class of functions that count the solutions of NP problems, and its tally version #P 1 for which the inputs are given in unary.
Reference: [HR90] <author> L. Hemachandra and S. Rudich. </author> <title> On the complexity of ranking. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41(2) </volume> <pages> 251-271, </pages> <year> 1990. </year>
Reference-contexts: This expands the result of Hemaspaandra and Rudich that every P set is rankable if and only if P = PP <ref> [HR90] </ref> by showing that P = PP is already implied by the apparently weaker hypothesis that every P set with an easy census function is rankable. <p> Cai and Hemaspaandra [CH89] introduced the notion of enumerative counting as a way of approximating the value of a #P function deterministically in polynomial time. 2 Hemaspaandra and Rudich <ref> [HR90] </ref> show that every P set is k-enumeratively rankable for some fixed k in polynomial time if and only if #P = FP. <p> Theorem 3.2 All P sets with an easy census function are rankable if and only if P = PP. Proof. Hemaspaandra and Rudich show that P = PP (which is equivalent to P #P = P) implies that every P set is rankable <ref> [HR90] </ref>. <p> Recall from the introduction Hemaspaandra and Rudich's result that every P set is k-enumeratively rankable for some fixed k (and indeed, even O (n 1=2* )-enumeratively rankable for some * &gt; 0) in polynomial time if and only if #P = FP <ref> [HR90] </ref>. They conclude that it is no more likely that one can enumeratively rank all sets in P than that one can exactly compute their ranking functions in polynomial time. <p> Theorem 5.1 There exists an oracle D such that #P D 1 FP D 6= #P D . From the relativized versions of Theorem 3.4 and of Hemaspaandra and Rudich's result in <ref> [HR90] </ref> that every P set is rankable if and only if P #P = P (which is equivalent with FP = #P, and this equivalence itself also relativizes), we immediately obtain the following corollary.
Reference: [HR97] <author> L. Hemaspaandra and J. </author> <title> Rothe. Unambiguous computation: Boolean hierarchies and sparse Turing-complete sets. </title> <journal> SIAM Journal on Computing, </journal> <volume> 26(3) </volume> <pages> 634-653, </pages> <month> June </month> <year> 1997. </year>
Reference: [HRW97a] <author> L. Hemaspaandra, J. Rothe, and G. Wechsung. </author> <title> Easy sets and hard certificate schemes. </title> <journal> Acta Informatica, </journal> <volume> 34(11) </volume> <pages> 859-879, </pages> <year> 1997. </year>
Reference: [HRW97b] <author> L. Hemaspaandra, J. Rothe, and G. Wechsung. </author> <title> On sets with easy certificates and the existence of one-way permutations. </title> <booktitle> In Proceedings of the Third Italian Conference on Algorithms and Complexity, </booktitle> <pages> pages 264-275. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #1203, </note> <month> March </month> <year> 1997. </year>
Reference: [HU79] <author> J. Hopcroft and J. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference: [HY84] <author> J. Hartmanis and Y. Yesha. </author> <title> Computation times of NP sets of different densities. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 17-32, </pages> <year> 1984. </year>
Reference-contexts: to the isomorphism conjecture of Berman and Hartmanis (e.g., [BH77,Mah82], and many other papers), the work on the existence of Turing-hard sparse sets (or of polynomial-size circuits) for various complexity classes (e.g., [KL80,KS85,BBS86,HR97]), the results relating the computation times for NP sets to their densities and the results on P-printability <ref> [HY84, AR88,RRW94,GH96] </ref>, the upward separation technique (e.g., [Har83,HIS85,All91,RRW94, HJ95], see [HHH] for more recent advances that are not based on census functions), the results on positive relativization and relativization to sparse oracles (e.g., [Lon85,LS86, 1 BBS86]), the unexpected collapse of the strong exponential-time hierarchy [Hem89], and applications to extended lowness [HJRW]. <p> By our choice of n, this does not decide D =m for any m n, so we can then put in the appropriate number of strings of length n for the diagonalization. 5 A set is P-printable <ref> [HY84] </ref> if there exists a polynomial-time transducer T such that for each length n, T on input 1 n prints a list of all elements of the set up to length n. 18 At stage 2i + 1 we guarantee that T D i (1 n ) does not compute the
Reference: [KL80] <author> R. Karp and R. Lipton. </author> <title> Some connections between nonuniform and uniform complexity classes. </title> <booktitle> In Proceedings of the 12th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 302-309, </pages> <month> April </month> <year> 1980. </year> <note> An extended version has also appeared as: Turing machines that take advice, </note> <editor> L'Enseignement Mathematique, </editor> <booktitle> 2nd series 28, </booktitle> <year> 1982, </year> <pages> pages 191-209. </pages>
Reference-contexts: languages L for which there exist a set A in P and a polynomial p such that for all strings x 2 fl , x 2 L =) j fy j jyj = p (jxj) and hx; yi 2 Ag j = 2 p (jxj)1 + 1; and 4 11. <ref> [KL80] </ref> For any language class C, let C=poly be the class of all languages L for which there exist a set A 2 C, a polynomial p, and an advice function h : fl ! fl such that for each length n, jh (1 n )j = p (n), and for
Reference: [Ko89] <author> K. Ko. </author> <title> Relativized polynomial time hierarchies having exactly k levels. </title> <journal> SIAM Journal on Computing, </journal> <volume> 18(2) </volume> <pages> 392-408, </pages> <year> 1989. </year> <month> 21 </month>
Reference-contexts: Fix an oracle A such that PH A does not collapse (such oracles were constructed by Yao [Yao85], H-astad [H-as89], and Ko <ref> [Ko89] </ref> who built on the work of Furst et al. [FSS84]). Then, by Claim 5.3 above, for every sparse set S, PH AS does not collapse. So, in particular, P AS 6= NP AS for every sparse set S.
Reference: [KS85] <author> K. Ko and U. Schoning. </author> <title> On circuit-size complexity and the low hierarchy in NP. </title> <journal> SIAM Journal on Computing, </journal> <volume> 14(1) </volume> <pages> 41-51, </pages> <year> 1985. </year>
Reference-contexts: A set S is said to be C-low for some class C if C S = C (see, e.g., [Sch83,KS85,Sch87,KSTT92] for a number of important lowness results). In particular, it is known that every sparse NP set is low for P NP <ref> [KS85] </ref> and for PP [KSTT92], but it is not known whether all sparse NP sets are low for SPP.
Reference: [KST89] <author> J. Kobler, U. Schoning, and J. Toran. </author> <title> On counting and approximation. </title> <journal> Acta Informatica, </journal> <volume> 26 </volume> <pages> 363-379, </pages> <year> 1989. </year>
Reference-contexts: For any nondeterministic Turing machine M and any input x 2 fl , let acc M (x) denote the number of accepting paths of M (x). A spanP machine <ref> [KST89] </ref> is an NP machine that has a special output device on which some output is printed for each accepting path. <p> Definition 2.1 1. [Val79a,Val79b] #P df = facc M j M is an NP machineg. 2. [Val79b] #P 1 = facc M j M is a tally NP machineg. 3. <ref> [KST89] </ref> spanP df = fspan M j M is a spanP machineg. 4. spanP 1 df = fspan M j M is a tally spanP machineg. 5. #E = facc M j M is an NE machineg. 6. [MS72,Sto77] The polynomial hierarchy is inductively defined as follows: p df k = <p> Corollary 3.9 together with the equivalences of Theorems 3.4 and 3.5 gives the following. Corollary 3.10 Every P set has an easy census function if and only if every set in PH has an easy census function. Kobler et al. <ref> [KST89] </ref> proved that spanP = #P if and only if NP = UP. Their proof also establishes the analogous result for tally sets: Lemma 3.11 (implicit in [KST89]) spanP 1 = #P 1 if and only if every tally NP set is in UP. <p> Kobler et al. <ref> [KST89] </ref> proved that spanP = #P if and only if NP = UP. Their proof also establishes the analogous result for tally sets: Lemma 3.11 (implicit in [KST89]) spanP 1 = #P 1 if and only if every tally NP set is in UP. Using Lemma 3.11, we show that spanP 1 and #P 1 are different classes unless NE = UE, or unless every sparse set in NP is low for SPP.
Reference: [KSTT92] <author> J. Kobler, U. Schoning, S. Toda, and J. Toran. </author> <title> Turing machines with few accepting computations and low sets for PP. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 44(2) </volume> <pages> 272-286, </pages> <year> 1992. </year>
Reference-contexts: A set S is said to be C-low for some class C if C S = C (see, e.g., [Sch83,KS85,Sch87,KSTT92] for a number of important lowness results). In particular, it is known that every sparse NP set is low for P NP [KS85] and for PP <ref> [KSTT92] </ref>, but it is not known whether all sparse NP sets are low for SPP.
Reference: [Lau83] <author> C. Lautemann. </author> <title> BPP and the polynomial hierarchy. </title> <journal> Information Processing Letters, </journal> <volume> 14 </volume> <pages> 215-217, </pages> <year> 1983. </year>
Reference: [Lon85] <author> T. </author> <title> Long. On restricting the size of oracles compared with restricting access to oracles. </title> <journal> SIAM Journal on Computing, </journal> <volume> 14(3) </volume> <pages> 585-597, </pages> <year> 1985. </year> <note> Erratum appears in the same journal, 17(3):628. </note>
Reference: [LS86] <author> T. Long and A. Selman. </author> <title> Relativizing complexity classes with sparse oracles. </title> <journal> Journal of the ACM, </journal> <volume> 33(3) </volume> <pages> 618-627, </pages> <year> 1986. </year>
Reference-contexts: Proof of Theorem 5.1. Balcazar et al. [BBS86] and Long and Selman <ref> [LS86] </ref> proved that the polynomial hierarchy does not collapse if and only if it does not collapse relative to every sparse oracle.
Reference: [Mah82] <author> S. Mahaney. </author> <title> Sparse complete sets for NP: Solution of a conjecture of Berman and Hartmanis. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(2) </volume> <pages> 130-143, </pages> <year> 1982. </year>
Reference: [MS72] <author> A. Meyer and L. Stockmeyer. </author> <title> The equivalence problem for regular expressions with squaring requires exponential space. </title> <booktitle> In Proceedings of the 13th IEEE Symposium on Switching and Automata Theory, </booktitle> <pages> pages 125-129, </pages> <year> 1972. </year>
Reference: [OH93] <author> M. Ogiwara and L. Hemachandra. </author> <title> A complexity theory for closure properties. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 46(3) </volume> <pages> 295-325, </pages> <year> 1993. </year>
Reference: [Pap94] <author> C. Papadimitriou. </author> <title> Computational Complexity. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference: [PZ83] <author> C. Papadimitriou and S. Zachos. </author> <title> Two remarks on the power of counting. </title> <booktitle> In Proceedings 6th GI Conference on Theoretical Computer Science, </booktitle> <pages> pages 269-276. </pages> <note> Springer-Verlag Lecture Notes in Computer Science #145, </note> <year> 1983. </year>
Reference: [RRW94] <author> R. Rao, J. Rothe, and O. Watanabe. </author> <title> Upward separation for FewP and related classes. </title> <journal> Information Processing Letters, </journal> <volume> 52 </volume> <pages> 175-180, </pages> <year> 1994. </year>
Reference: [Sch83] <author> U. Schoning. </author> <title> A low and a high hierarchy within NP. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 27 </volume> <pages> 14-28, </pages> <year> 1983. </year>
Reference: [Sch87] <author> U. Schoning. </author> <title> Graph isomorphism is in the low hierarchy. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 37 </volume> <pages> 312-323, </pages> <year> 1987. </year>
Reference: [Sip83] <author> M. Sipser. </author> <title> A complexity theoretic approach to randomness. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 330-335, </pages> <year> 1983. </year>
Reference: [Sto77] <author> L. Stockmeyer. </author> <title> The polynomial-time hierarchy. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 1-22, </pages> <year> 1977. </year>
Reference: [TO92] <author> S. Toda and M. Ogiwara. </author> <title> Counting classes are at least as hard as the polynomial--time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21(2) </volume> <pages> 316-328, </pages> <year> 1992. </year>
Reference-contexts: Theorem 3.6 If #P 1 FP, then the following holds: 1. For any fixed k 2, PH MOD k P, and 2. P = BPP. Proof. For the first part, notice that Toda and Ogihara <ref> [TO92] </ref> show that for each k 2 and any set L, if L 2 PH, then L 2 MOD k P=poly with an advice computable in (the function analog of the language class) PH MOD k P . <p> The proof of Theorem 3.7 in fact establishes a more general claim. Since P PH =poly = P=poly <ref> [TO92] </ref>, Theorem 3.7 and its corollaries can be stated even with PH replaced by P PH (note that P PH = BPP P by Toda's result [Tod91]). However, we focus on the PH case, as this is a more natural and more central class. Proof of Theorem 3.7. <p> By Toda and Ogihara's result that PH P=poly <ref> [TO92] </ref>, there exist a set A 2 P, an advice function h : fl ! fl , and a polynomial q such that for each length m and each x of length m, jh (1 m )j = q (m), and x 2 L if and only if hx; h (1
Reference: [Tod91] <author> S. </author> <title> Toda. PP is as hard as the polynomial-time hierarchy. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(5) </volume> <pages> 865-877, </pages> <year> 1991. </year>
Reference-contexts: Hence, PH MOD k P. In order to prove the second part, notice that BPP is in P=poly [Adl78] with an advice computable in (the function analog of) PH [Sip83,Lau83], and that PH P #P [1] by Toda's Theorem <ref> [Tod91] </ref>. An argument similar to the above shows that P = BPP. Now we show that the conditions of Theorem 3.4 in fact are equivalent to the two conditions stated in either part of Theorem 3.5. <p> To this end, we establish the following theorem, which is interesting in its own right. Theorem 3.7 is the main technical contribution in this section. Theorem 3.7 #P PH 1 FP #P #P 1 Remark 3.8 1. Note that Toda's result PH P #P [1] <ref> [Tod91] </ref> immediately gives that #P PH #P #P [1] and #P PH #P [1] 1 . Observe that the oracle is a #P function. <p> The proof of Theorem 3.7 in fact establishes a more general claim. Since P PH =poly = P=poly [TO92], Theorem 3.7 and its corollaries can be stated even with PH replaced by P PH (note that P PH = BPP P by Toda's result <ref> [Tod91] </ref>). However, we focus on the PH case, as this is a more natural and more central class. Proof of Theorem 3.7. Let f be any function in #P PH 1 . Note that #P PH 1 = # 1 PH, since PH is closed under Turing reductions. <p> Let M be a machine witnessing that A 2 P, i.e., for every string z, z 2 A if and only if acc M (z) is odd. Toda <ref> [Tod91] </ref> defined inductively the following sequence of polynomials: For j 2 N, let s 0 (j) = j, and for each j 2 N and i &gt; 0, let s i (j) = 3 (s i1 (j)) 4 + 4 (s i1 (j)) 3 : One very useful property of this <p> property of this sequence of polynomials is that for all i; j 2 N, s i (j) = c2 2 i for some c 2 N if j is even, and s i (j) = d 2 2 i 1 for some d 2 N if j is odd (see <ref> [Tod91] </ref> for the induction proof). We describe a polynomial-time oracle transducer T that, on input 1 n , invokes its #P #P 1 function oracle g and then prints in binary the number f (1 n ). Fix the input 1 n . <p> Then, (s ` n (j y )) 2 is a polynomial of degree 2 2` n +1 , which is polynomial in n. Also, the coefficients of this polynomial are deterministically computable in time polynomial in n (see <ref> [Tod91] </ref>). Since acc M 2 #P and #P is closed under addition and multiplication, the function mapping h1 n #y; a n i to (s ` n (j y )) 2 is in #P. Let ~ G be an NP machine witnessing that this function is in #P.
Reference: [Tor88] <author> J. Toran. </author> <title> Structural Properties of the Counting Hierarchies. </title> <type> PhD thesis, </type> <institution> Universitat Politecnica de Catalunya, </institution> <address> Barcelona, Spain, </address> <year> 1988. </year>
Reference-contexts: Toran's result that in some relativized world there exists some sparse NP set that is not contained in P <ref> [Tor88] </ref>, and thus not in SPP, may be taken as some evidence that not all sparse NP sets are SPP-low. Since Corollary 3.12 relativizes, spanP 1 6= #P 1 holds relative to the same oracle. Corollary 3.12 If spanP 1 = #P 1 , then 1.
Reference: [Val76] <author> L. Valiant. </author> <title> The relative complexity of checking and evaluating. </title> <journal> Information Processing Letters, </journal> <volume> 5 </volume> <pages> 20-23, </pages> <year> 1976. </year>
Reference-contexts: We also note that we let census L map strings 1 n (as opposed to numbers n in binary notation) to j L =n j to emphasize that the input to the transducer computing census L is given in unary. 3 accepting path. UP <ref> [Val76] </ref> (respectively, UE) is the class of all languages accepted by some unambiguous Turing machine running in polynomial time (respectively, in time 2 cn for some constant c).
Reference: [Val79a] <author> L. Valiant. </author> <title> The complexity of computing the permanent. </title> <journal> Theoretical Computer Science, </journal> <volume> 8 </volume> <pages> 189-201, </pages> <year> 1979. </year>
Reference-contexts: Now working backwards again, we can recover perm (A) modulo p. If we do this for polynomially (in the encoding length of A) many distinct primes, then by the Chinese Remainder Theorem, we can recover the exact value of perm (A). Valiant <ref> [Val79a] </ref> showed that the permanent of matrices whose entries are from the set f1; 0; 1; 2g is complete for #P.
Reference: [Val79b] <author> L. Valiant. </author> <title> The complexity of enumeration and reliability problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 8(3) </volume> <pages> 410-421, </pages> <year> 1979. </year>
Reference-contexts: Self-Avoiding Walk is a well-known classical problem of statistical physics and polymer chemistry, and it is an intriguing open question whether Self-Avoiding Walk is #P 1 -complete (see [Wel93]). Known problems complete for #P 1 <ref> [Val79b] </ref> have the form: Given an integer n in unary, compute the number of graphs having n vertices and satisfying a fixed graph property . <p> A tally NP machine (respectively, a tally spanP machine) is an NP (respectively, a spanP) machine with a unary input alphabet. Definition 2.1 1. [Val79a,Val79b] #P df = facc M j M is an NP machineg. 2. <ref> [Val79b] </ref> #P 1 = facc M j M is a tally NP machineg. 3. [KST89] spanP df = fspan M j M is a spanP machineg. 4. spanP 1 df = fspan M j M is a tally spanP machineg. 5. #E = facc M j M is an NE machineg. <p> The equivalence of (2) and (4) is straightforward. It is easy to see that (2) implies (5). In order to prove that (5) implies (2), note that computing the number of satisfying assignments for monotone 2CNF formulas is complete for #P <ref> [Val79b] </ref> under logspace reductions. <p> By (1) above, implicit in 4 See <ref> [Val79b] </ref> for natural #P 1 -complete functions. 17 the definition of f and f 1 is the definition of A, so it suffices to construct the isomorphism. The construction of f and f 1 is in stages.
Reference: [Wel93] <author> D. Welsh. </author> <title> Complexity: Knots, Colourings and Counting. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: Although #P 1 has not become as prominent as #P, it contains a number of quite interesting and important problems such as the problem Self-Avoiding Walk (see <ref> [Wel93] </ref>): Given an integer n in unary, compute the number of self-avoiding walks on the square lattice having length n and rooted at the origin. <p> Self-Avoiding Walk is a well-known classical problem of statistical physics and polymer chemistry, and it is an intriguing open question whether Self-Avoiding Walk is #P 1 -complete (see <ref> [Wel93] </ref>). Known problems complete for #P 1 [Val79b] have the form: Given an integer n in unary, compute the number of graphs having n vertices and satisfying a fixed graph property .
Reference: [Yao85] <author> A. Yao. </author> <title> Separating the polynomial-time hierarchy by oracles. </title> <booktitle> In Proceedings of the 26th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 1-10, </pages> <year> 1985. </year>
Reference-contexts: Fix an oracle A such that PH A does not collapse (such oracles were constructed by Yao <ref> [Yao85] </ref>, H-astad [H-as89], and Ko [Ko89] who built on the work of Furst et al. [FSS84]). Then, by Claim 5.3 above, for every sparse set S, PH AS does not collapse. So, in particular, P AS 6= NP AS for every sparse set S.
References-found: 57

