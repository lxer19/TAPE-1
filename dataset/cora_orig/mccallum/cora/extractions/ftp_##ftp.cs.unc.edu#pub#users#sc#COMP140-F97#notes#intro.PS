URL: ftp://ftp.cs.unc.edu/pub/users/sc/COMP140-F97/notes/intro.PS
Refering-URL: http://www.cs.unc.edu/~sc/140/lectures.html
Root-URL: http://www.cs.unc.edu
Note: COMP 140: Compilers  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java T M Language Specification. The Java T M Series. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1996. </year>
Reference-contexts: The matter is best demonstrated by example. When we create a Java class foo in the file foo.java, we expect the methods we have defined to accept certain inputs and produce certain outputs. (What it should do is spelled out in great and gory detail in <ref> [1] </ref>.) When that class is compiled to produce Java bytecode in the file foo.class, we still expect that the bytecode, when interpreted by the Java Virtual Machine, will accept those same inputs and produce the same outputs as the original high-level program. (How the JVM responds to interpreting bytecodes is spelled
Reference: [2] <author> T. Lindholm and F. Yellin. </author> <title> The Java T M Virtual Machine. The Java T M Series. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1996. </year>
Reference-contexts: Java bytecode in the file foo.class, we still expect that the bytecode, when interpreted by the Java Virtual Machine, will accept those same inputs and produce the same outputs as the original high-level program. (How the JVM responds to interpreting bytecodes is spelled out in great and gory detail in <ref> [2] </ref>.) It is the job of the Java compiler to maintain this correspondence. This notion of equivalence is called input-output equivalence. For computer languages, where one can (at least in principle) define formal semantics, the correctness of the translation process can be ascertained or certified.
References-found: 2

