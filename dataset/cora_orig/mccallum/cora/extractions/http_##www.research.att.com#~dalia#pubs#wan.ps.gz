URL: http://www.research.att.com/~dalia/pubs/wan.ps.gz
Refering-URL: http://www.research.att.com/~dalia/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fdalia,mischug@research.att.com tern@cs.huji.ac.il  
Title: Secure Reliable Multicast Protocols in a WAN  
Author: Dahlia Malkhi Michael Merritt Ohad Rodeh 
Address: Murray Hill, New Jersey  Jerusalem  
Affiliation: AT&T Labs,  The Hebrew University of  
Abstract: A secure reliable multicast protocol enables a process to send a message to a group of recipients such that all honest destinations receive the same message, despite the malicious efforts of fewer than a third of them, including the sender. This has been shown to be a useful tool in building secure distributed services, albeit with a cost that typically grows linearly with the size of the system. For very large networks, for which such a cost may be too prohibitive, we present two approaches for bringing the cost down: First, we show a protocol whose cost is on the order of the number of tolerated failures. Secondly, we show how relaxing the consistency requirement to a selected probability level of guarantee can bring down the associated cost to a constant. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Danny Dolev and Dalia Malki. </author> <title> The Transis Approach to High Availability Cluster Communication. </title> <journal> Communications of the ACM, </journal> <volume> 39 </volume> <pages> 64-70, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: When t t b (n 1)=3c, this significantly reduces the failure-overhead of n signatures and message exchanges incurred in the simple active t protocol. 6 Conclusions Our experience in constructing robust distributed systems <ref> [1, 6] </ref> shows that (secure) reliable broadcast is an important tool for distributed applications. Implementing reliable broadcast in an insecure environment with arbitrary failures incurs inevitable overhead required for maintaining consistency. However, a price that may be acceptable in a small network becomes intolerable for a very large system.
Reference: [2] <author> M. Fischer, N. Lynch, and M. Paterson. </author> <title> Impossibility of Distributed Consensus with One Faulty Process. </title> <journal> J. ACM, </journal> <volume> 32 </volume> <pages> 374-382, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: same message, i.e., payload (m) = payload (m'). (Probability is taken assuming uniform choice of seq (m), and taken at the limit as seq (m) goes to infinity.) The problem statement above is strictly weaker than the Byzantine agreement problem [5], which is known to be unsolvable in asynchronous systems <ref> [2] </ref>. This statement holds even if we use the unconditional Agreement requirement. The reason is that only messages from honest processes are required to be delivered, and thus messages from corrupt processes can "hang" forever.
Reference: [3] <author> S. Haber and W.S. Stornetta. </author> <title> How to Time-Stamp a Digital Document. </title> <journal> Journal of Cryptology, </journal> <volume> 3(2) </volume> <pages> 99-111, </pages> <year> 1991. </year>
Reference-contexts: Relatively small values of k are sufficient for this to be negligable. (As with the size of cryptographic keys, k is effectively a constant.) This idea of forming distributed trust in a cooperation-resilient way borrows from the time-stamping mechanism of Haber et al. <ref> [3] </ref>. The motivation for this protocol is to choose witness sets significantly smaller than 3t + 1. As a result, assuring both safety and availability is a problem: Since t of the witnesses could be faulty, for availability one might want to wait for only k t replies.
Reference: [4] <author> J. B. Lacy, D. P. Mitchell, and W. M. </author> <title> Schell. </title> <booktitle> Cryp-toLib: Cryptography in Software. In Proceedings of the 4th USENIX Security Workshop, </booktitle> <pages> pages 1-17, </pages> <month> October </month> <year> 1993. </year>
Reference: [5] <author> L. Lamport, R. Shostak, and M. Pease. </author> <title> The Byzantine Generals Problem. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 328-401, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: very high probability) p i and p j delivered the same message, i.e., payload (m) = payload (m'). (Probability is taken assuming uniform choice of seq (m), and taken at the limit as seq (m) goes to infinity.) The problem statement above is strictly weaker than the Byzantine agreement problem <ref> [5] </ref>, which is known to be unsolvable in asynchronous systems [2]. This statement holds even if we use the unconditional Agreement requirement. The reason is that only messages from honest processes are required to be delivered, and thus messages from corrupt processes can "hang" forever.
Reference: [6] <author> D. Malkhi and M. Reiter. </author> <title> A high-throughput secure reliable multicast protocol. Journal of Computer Security, to appear. </title> <booktitle> Also in Proceedings of the 9th IEEE Computer Security Foundations Workshop, </booktitle> <pages> pages 9-17, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Reiter improved this message complexity in the ECHO protocol of the Rampart system [9] through the usage of digital signatures. The ECHO protocol incurs O (n) signed message exchanges, and thus, message complexity is improved at the expense of increased computation cost. Malkhi and Reiter <ref> [6] </ref> extended this approach to amortize the cost of computing digital signatures over multiple messages through a technique called acknowledgment chaining , where a signed acknowledgment directly verifies the message it acknowledges and idirectly, every message it acknowledges. <p> When t t b (n 1)=3c, this significantly reduces the failure-overhead of n signatures and message exchanges incurred in the simple active t protocol. 6 Conclusions Our experience in constructing robust distributed systems <ref> [1, 6] </ref> shows that (secure) reliable broadcast is an important tool for distributed applications. Implementing reliable broadcast in an insecure environment with arbitrary failures incurs inevitable overhead required for maintaining consistency. However, a price that may be acceptable in a small network becomes intolerable for a very large system.
Reference: [MR97] <author> D. Malkhi and M. Reiter. </author> <title> Byzantine quorum systems. </title> <booktitle> In Proceedings of the 29th ACM Symposium on Theory of Computing (STOC), </booktitle> <month> May </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Witness sets are chosen so that any pair of them intersect at an honest process, and such that some witness set is always accessible despite failures. More precisely, witness sets satisfy the Consistency and Availability requirements of Byzan-tine dissemination quorum systems (cf. <ref> [MR97] </ref>), as follows: Definition 1.1 A dissemination quorum system is a set of subsets, called quorums, satisfying: 1 For every set B of corrupt processes, and every two quorums Q 1 ; Q 2 , Q 1 " Q 2 6 B (Consistency).
Reference: [7] <author> P. M. Melliar-Smith, L. E. Moser, and V. Agrawala. </author> <title> Broadcast Protocols for Distributed Systems. </title> <journal> IEEE Trans. Parallel & Distributed Syst., </journal> <volume> 1(1) </volume> <pages> 17-25, </pages> <month> Jan </month> <year> 1990. </year>
Reference: [8] <author> L. E. Moser and P. M. Melliar-Smith. </author> <title> Total Ordering Algorithms for Asynchronous Byzantine Systems. </title> <booktitle> In Proceedings of the 9th International Workshop on Distributed Algorithms. </booktitle> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1995. </year>
Reference-contexts: Note that there is no ordering requirement among different messages, and thus the problem statement is weaker than the totally ordered reliable broadcast problem, which can be solved only probabilistically <ref> [8] </ref>. The reliable multicast problem is solvable in our environment, as is demonstrated by the E protocol depicted in Figure 1 (which borrows from the Rampart ECHO multicast protocol [9]). It is easy to verify that the echo protocol satisfies Integrity, Self-delivery, Reliability and Agreement.
Reference: [9] <author> Mike Reiter. </author> <title> Secure Agreement Protocols: Reliable and Atomic Group Multicast in Rampart. </title> <booktitle> In 2nd ACM Conf. on Computer and Communications Security, </booktitle> <pages> pages 68-80, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Reiter improved this message complexity in the ECHO protocol of the Rampart system <ref> [9] </ref> through the usage of digital signatures. The ECHO protocol incurs O (n) signed message exchanges, and thus, message complexity is improved at the expense of increased computation cost. <p> In this paper, we assume a static set of communicating processes. It is possible, however, to use known techniques (e.g., <ref> [9] </ref>) to extend our protocol to operate in a dynamic environment in which processes may leave or join the set of destination processes and in which processes may fail and recover. <p> The reliable multicast problem is solvable in our environment, as is demonstrated by the E protocol depicted in Figure 1 (which borrows from the Rampart ECHO multicast protocol <ref> [9] </ref>). It is easy to verify that the echo protocol satisfies Integrity, Self-delivery, Reliability and Agreement. This protocol is resorted to when the active t protocol below fails to guarantee Reliability. However, it is inefficient in faultless runs, and incurs an intolerable overhead for very large groups.
Reference: [10] <author> R. Rivest. </author> <title> The MD5 Message Digest Algorithm. </title> <type> RFC 1321, </type> <institution> SRI Network Information Center, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: We assume that every process in the system may obtain the public keys of all of the other processes, such that it can verify the authenticity of signatures. Our protocols also make use of a cryptographically secure hash function H (such as MD5 <ref> [10] </ref>). (In the following, we make the crypto-graphic assumption that H (m) = H (m 0 ) implies that m = m 0 ).
Reference: [11] <author> R. L. Rivest, A. Shamir, and L. </author> <note> Adleman. </note>
Reference-contexts: We assume that every process possesses a private key, known only to itself, that may be used for signing data using a known public key cryptographic method (such as <ref> [11] </ref>). Let d be any data block. We denote K i (d) the signature of p i on the data block d by means of p i 's private key.
References-found: 12

