URL: http://www.cs.kuleuven.ac.be/~kristof/papers/temprer.ps
Refering-URL: http://www.cs.kuleuven.ac.be/~kristof/publications.html
Root-URL: 
Email: e-mail fkristof, marcd, dannydg@cs.kuleuven.ac.be  
Title: The Abductive Event Calculus as a General Framework for Temporal Databases  
Author: Kristof Van Belleghem Marc Denecker Danny De Schreye 
Address: Celestijnenlaan 200A, B-3001 Heverlee, Belgium.  
Affiliation: Department of Computer Science, K.U.Leuven,  
Abstract: In earlier work, we have shown that the formalism of ab-ductive logic programs with FOL integrity constraints provides, under a completion semantics, the same declarative expressivity for representing incomplete information as full first order logic. We have shown how the combination of this formalism with a variant of the Event Calculus of Kowalski and Sergot results in a correct and very expressive framework for temporal reasoning and representation. In this paper we demonstrate how this Abductive Event Calculus formalism provides a general framework for the representation and use of temporal databases. On the declarative level, it is particularly convenient for the representation of incomplete knowledge. Complementary, on the procedural level, we are able to provide a number of simple algorithms using abduction and deduction to test the consistency of the base, answer queries, update the database, handle complex formulas and resolve inconsistency. Furthermore, the use of the database for general temporal problem solving is possible using the known Event Calculus and Logic Programming methods. In particular we show how planning is possible in this kind of temporal database. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. F. Allen. </author> <title> Maintaining Knowledge About Temporal Intervals. </title> <journal> CACM, </journal> <volume> 26(11) </volume> <pages> 832-843, </pages> <year> 1983. </year>
Reference-contexts: On the other hand, we already find interesting ideas in the literature. For example, in [22] we find an algorithm for resolving inconsistency in a network of interval relations, based on the work in <ref> [1] </ref>. There, for each pair of intervals a list of possible relations between these intervals is maintained. If ever no possible relations are left between any two intervals, the data are inconsistent. Weigel and Bleisinger have modified and extended this procedure to efficiently derive solutions for the inconsistency.
Reference: 2. <author> J. F. Allen. </author> <title> Towards a General Theory of Action and Time. </title> <booktitle> Artifical Intelligence, </booktitle> <address> 23(11):123, </address> <year> 1984. </year>
Reference-contexts: The possible relations between time points and intervals are represented by the following formulas. (In the case of intervals, we distinguish thirteen possible relations, based on those defined in <ref> [2] </ref>, though some names may differ.) - T 1 = T 2 : T 1 and T 2 are the same time point. - T 1 &lt;< T 2 : T 1 is chronologically before T 2 . equal (i 1 ; i 2 ) : i 1 and i 2 <p> The system can be mapped to ours, however, and some of its proposed algorithms may be useful to us. A possible extension for temporal databases is the introduction of a notion of belief. The representation of belief in a theory of time was addressed in <ref> [2] </ref>. One proposal to incorporate this notion in a temporal database is described in [21]. To incorporate a similar extension in our system, further research will be necessary.
Reference: 3. <author> K. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and databases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <year> 1978. </year>
Reference-contexts: Examples can be found in [8], [19], [17] and [11]. In our proposal we use the SLDNFA procedure described in [6] and [7]. This procedure, an extension of the SLDNF resolution of Logic Programming ([12], <ref> [3] </ref>) that can deal with abductive predicates, can handle deduction as well as abduction and allows for a correct treatment of non-ground abducible atoms, which is necessary in our applications. Its soundness and completeness with respect to Console completion semantics are proven in [6].
Reference: 4. <author> L. Console, D. Theseider Dupre, and P. Torasso. </author> <title> On the relationship between abduction and deduction. </title> <journal> Journal of Logic and Computation, </journal> <volume> 1(5) </volume> <pages> 661-690, </pages> <year> 1991. </year>
Reference: 5. <author> M. Denecker. </author> <title> Knowledge Representation and Reasoning in Incomplete Logic Programming. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, K.U.Leuven, </institution> <year> 1993. </year>
Reference-contexts: Though abduction is clearly a useful computational paradigm, it was not recognized earlier that the formalism of abductive logic programs with first order logic constraints provides the same declarative expressivity for representing incomplete information as full first order logic (FOL). This was shown in <ref> [5] </ref>, where it was exploited to provide an implementation of the A language of [10] in the Situation Calculus formulated as an abductive logic program.
Reference: 6. <author> M. Denecker and D. De Schreye. </author> <title> SLDNFA; an abductive procedure for normal abductive programs. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proceedings of the International Joint Conference and Symposium on Logic Programming, </booktitle> <address> Washington, </address> <year> 1992. </year>
Reference-contexts: Examples can be found in [8], [19], [17] and [11]. In our proposal we use the SLDNFA procedure described in <ref> [6] </ref> and [7]. This procedure, an extension of the SLDNF resolution of Logic Programming ([12], [3]) that can deal with abductive predicates, can handle deduction as well as abduction and allows for a correct treatment of non-ground abducible atoms, which is necessary in our applications. <p> Its soundness and completeness with respect to Console completion semantics are proven in <ref> [6] </ref>. The implementation of SLDNFA we are using has a number of features making it more fit for planning in the Event Calculus and for general temporal reasoning.
Reference: 7. <author> M. Denecker, L. Missiaen, and M. Bruynooghe. </author> <title> Temporal reasoning with abduc-tive event calculus. </title> <booktitle> In Proceedings of ECAI 92, </booktitle> <address> Vienna, </address> <year> 1992. </year>
Reference-contexts: In the context of the Event Calculus, [8], [19] and [17] have introduced abduction to solve planning problems and <ref> [7] </ref> showed how abduction can be used to solve general temporal postdiction problems in the presence of incomplete information. <p> We try to find the sequence of actions necessary to prove the goal, which is the desired end state. In a similar way postdiction (diagnosis) and indeterminism can be modeled, as demonstrated in <ref> [7] </ref>. We return to the topic of planning later, in the context of a temporal database. 3.1 The SLDNFA proof procedure There have been several attempts to build an abductive proof procedure and to use it in the context of temporal reasoning. <p> Examples can be found in [8], [19], [17] and [11]. In our proposal we use the SLDNFA procedure described in [6] and <ref> [7] </ref>. This procedure, an extension of the SLDNF resolution of Logic Programming ([12], [3]) that can deal with abductive predicates, can handle deduction as well as abduction and allows for a correct treatment of non-ground abducible atoms, which is necessary in our applications.
Reference: 8. <author> K. Eshghi. </author> <title> Abductive planning with event calculus. </title> <editor> In R. Kowalski and K. Bowen, editors, </editor> <booktitle> Proceedings of the 5th ICLP, </booktitle> <year> 1988. </year>
Reference-contexts: The Event Calculus has been modified in several ways, for example in [20], [9], [17] and [13], mainly to simplify the ontology and to eliminate problems occurring because of bidirectional persistence of properties (forward as well as backward in time). In the context of the Event Calculus, <ref> [8] </ref>, [19] and [17] have introduced abduction to solve planning problems and [7] showed how abduction can be used to solve general temporal postdiction problems in the presence of incomplete information. <p> We return to the topic of planning later, in the context of a temporal database. 3.1 The SLDNFA proof procedure There have been several attempts to build an abductive proof procedure and to use it in the context of temporal reasoning. Examples can be found in <ref> [8] </ref>, [19], [17] and [11]. In our proposal we use the SLDNFA procedure described in [6] and [7].
Reference: 9. <author> C. Evans. </author> <title> The Macro-Event Calculus: Representing Temporal Granularity. </title> <booktitle> In Proceedings of PRICAI, </booktitle> <address> Tokyo, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction The Event Calculus (see [14]) is a well-known formalism for temporal representation and reasoning. The basic concepts of the formalism are events and properties: events initiate and terminate periods of time during which properties hold. The Event Calculus has been modified in several ways, for example in [20], <ref> [9] </ref>, [17] and [13], mainly to simplify the ontology and to eliminate problems occurring because of bidirectional persistence of properties (forward as well as backward in time).
Reference: 10. <author> M. Gelfond and V. Lifschitz. </author> <title> Describing Action and Change by Logic Programs. </title> <booktitle> In Proc. of the 9th Int. Joint Conf. and Symp. on Logic Programming, </booktitle> <year> 1992. </year>
Reference-contexts: This was shown in [5], where it was exploited to provide an implementation of the A language of <ref> [10] </ref> in the Situation Calculus formulated as an abductive logic program.
Reference: 11. <author> A. Kakas and P. Mancarella. </author> <title> Constructive abduction in logic programming. </title> <type> Technical report, </type> <institution> Dipartimento di Informatica, University of Pisa, </institution> <year> 1993. </year>
Reference-contexts: Examples can be found in [8], [19], [17] and <ref> [11] </ref>. In our proposal we use the SLDNFA procedure described in [6] and [7].
Reference: 12. <author> R. A. Kowalski. </author> <title> Logic for problem solving. </title> <publisher> Elsevier Science Publisher, </publisher> <year> 1976. </year>
Reference: 13. <author> R. A. Kowalski. </author> <title> Database updates in the event calculus. </title> <journal> Journal of Logic Programming, </journal> <year> 1992, 1992. </year>
Reference-contexts: The basic concepts of the formalism are events and properties: events initiate and terminate periods of time during which properties hold. The Event Calculus has been modified in several ways, for example in [20], [9], [17] and <ref> [13] </ref>, mainly to simplify the ontology and to eliminate problems occurring because of bidirectional persistence of properties (forward as well as backward in time).
Reference: 14. <author> R. A. Kowalski and M. Sergot. </author> <title> A logic-based calculus of events. </title> <journal> New Generation Computing, </journal> <volume> 4(4) </volume> <pages> 319-340, </pages> <year> 1986. </year>
Reference-contexts: 1 Introduction The Event Calculus (see <ref> [14] </ref>) is a well-known formalism for temporal representation and reasoning. The basic concepts of the formalism are events and properties: events initiate and terminate periods of time during which properties hold.
Reference: 15. <author> J. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference: 16. <author> J. Lloyd and R. Topor. </author> <title> Making prolog more expressive. </title> <journal> Journal of logic programming, </journal> <volume> 1(3) </volume> <pages> 225-240, </pages> <year> 1984. </year>
Reference-contexts: However, in the case of complex queries and data a preceding transformation step is required. This transformation step is based on the Lloyd-Topor transformation described in <ref> [16] </ref>. The transformation provides a method to transform a program containing non-Horn clauses and complex goals, an extended program, to a program containing only Horn clauses augmented with negation as failure. <p> Similar rules exist for each operator and its negation. A complete list can be found in <ref> [16] </ref>.
Reference: 17. <author> L. Missiaen. </author> <title> Localized abductive planning with the event calculus. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, K.U.Leuven, </institution> <year> 1991. </year>
Reference-contexts: The basic concepts of the formalism are events and properties: events initiate and terminate periods of time during which properties hold. The Event Calculus has been modified in several ways, for example in [20], [9], <ref> [17] </ref> and [13], mainly to simplify the ontology and to eliminate problems occurring because of bidirectional persistence of properties (forward as well as backward in time). In the context of the Event Calculus, [8], [19] and [17] have introduced abduction to solve planning problems and [7] showed how abduction can be <p> The Event Calculus has been modified in several ways, for example in [20], [9], <ref> [17] </ref> and [13], mainly to simplify the ontology and to eliminate problems occurring because of bidirectional persistence of properties (forward as well as backward in time). In the context of the Event Calculus, [8], [19] and [17] have introduced abduction to solve planning problems and [7] showed how abduction can be used to solve general temporal postdiction problems in the presence of incomplete information. <p> We return to the topic of planning later, in the context of a temporal database. 3.1 The SLDNFA proof procedure There have been several attempts to build an abductive proof procedure and to use it in the context of temporal reasoning. Examples can be found in [8], [19], <ref> [17] </ref> and [11]. In our proposal we use the SLDNFA procedure described in [6] and [7].
Reference: 18. <author> A. Porto and C. Ribeiro. </author> <title> Temporal inference with a point-based interval algebra. </title> <booktitle> In Proceedings of ECAI 92, Vienna, </booktitle> <pages> pages 374-378, </pages> <year> 1992. </year>
Reference-contexts: Their solutions show some similarity to our approach, but work only on interval relations instead of general data. This allows for more efficient algorithms, especially if an incremental consistency checker is used. Another approach to the representation of temporal databases can be found in <ref> [18] </ref>. A database is considered a collection of maximal intervals throughout which certain properties hold. For each property a list of such intervals is maintained. Incomplete knowledge can be represented by skolemizing the end points of an interval, and constraints on these end points can be expressed.
Reference: 19. <author> M. Shanahan. </author> <title> Prediction is deduction but explanation is abduction. </title> <booktitle> In Proceedings of IJCAI 89, </booktitle> <pages> page 1055, </pages> <year> 1989. </year>
Reference-contexts: The Event Calculus has been modified in several ways, for example in [20], [9], [17] and [13], mainly to simplify the ontology and to eliminate problems occurring because of bidirectional persistence of properties (forward as well as backward in time). In the context of the Event Calculus, [8], <ref> [19] </ref> and [17] have introduced abduction to solve planning problems and [7] showed how abduction can be used to solve general temporal postdiction problems in the presence of incomplete information. <p> We return to the topic of planning later, in the context of a temporal database. 3.1 The SLDNFA proof procedure There have been several attempts to build an abductive proof procedure and to use it in the context of temporal reasoning. Examples can be found in [8], <ref> [19] </ref>, [17] and [11]. In our proposal we use the SLDNFA procedure described in [6] and [7].
Reference: 20. <author> M. Shanahan. </author> <title> Representing continuous change in the event calculus. </title> <booktitle> In Proceedings of the 9th ECAI, </booktitle> <pages> page 598, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction The Event Calculus (see [14]) is a well-known formalism for temporal representation and reasoning. The basic concepts of the formalism are events and properties: events initiate and terminate periods of time during which properties hold. The Event Calculus has been modified in several ways, for example in <ref> [20] </ref>, [9], [17] and [13], mainly to simplify the ontology and to eliminate problems occurring because of bidirectional persistence of properties (forward as well as backward in time).
Reference: 21. <author> S. Sripada. </author> <title> A metalogical programming approach to reasoning about time in knowledge bases. </title> <booktitle> In Proceedings of IJCAI 93, </booktitle> <year> 1993. </year>
Reference-contexts: A possible extension for temporal databases is the introduction of a notion of belief. The representation of belief in a theory of time was addressed in [2]. One proposal to incorporate this notion in a temporal database is described in <ref> [21] </ref>. To incorporate a similar extension in our system, further research will be necessary. The most important aspect of our framework is probably that it allows for the data in the base to be in the same language as the applications working with them.
Reference: 22. <author> A. Weigel and R. Bleisinger. </author> <title> Support for resolving Contradictions in Time Interval Networks. </title> <booktitle> In Proceedings of ECAI 92, Vienna, </booktitle> <pages> pages 379-383, </pages> <year> 1992. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: On one hand, we hope to obtain this greater efficiency by incorporating CLP techniques and tabulation. On the other hand, we already find interesting ideas in the literature. For example, in <ref> [22] </ref> we find an algorithm for resolving inconsistency in a network of interval relations, based on the work in [1]. There, for each pair of intervals a list of possible relations between these intervals is maintained.
References-found: 22

