URL: http://www.cs.ucsb.edu/~murat/CACM93.ps
Refering-URL: http://www.cs.ucsb.edu/~murat/
Root-URL: http://www.cs.ucsb.edu
Email: Email: murat@cs.ucsb.edu, bruno@cs.ucsb.edu  
Title: Introducing Concurrency to a Sequential Object-Oriented Language  
Author: Murat Karaorman John Bruno 
Address: Santa Barbara, CA 93106  
Affiliation: Department of Computer Science University of California  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Agha, </author> <title> G.H. ACTORS: A Model of Concurrent Computation in Distributed Systems, </title> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: C++ [8] , CEif-fel [18] ; 3. extension to the syntax and semantics of the language to support a general concur-rency paradigm such as the Actor model <ref> [1] </ref> - e.g. ACT++ [15], Actalk [7]. Our concurrency mechanism, and Colin and Geib's [12] Eiffel Classes, fall in the library approach. The approach of introducing concurrency via a class definition of Process is also used in the Choices operating system [10] where they use the C++ language.
Reference: [2] <author> Agha, G. </author> <title> Concurrent Object-Oriented Programming. </title> <journal> Communications of the ACM. </journal> <note> 33(9) (Septem-ber 1990) 125. </note>
Reference-contexts: Design a new concurrent object-oriented lan guage. 2. Extend an existing object-oriented language. 3. Design a Concurrency Library. Use an existing object-oriented language and provide concurrency abstractions through external li braries. Page 1 Many references and comparative discussions about concurrent object-oriented languages can be found in <ref> [2] </ref> [23], and for brevity we won't discuss specific features of these languages here. Most of the earlier systems fall into the first approach: design a new object-oriented language with built-in concurrency. Some examples are: Hybrid [21], POOL [4] (and its variants), SR [5], ABCL/1 [25].
Reference: [3] <author> Agha, G., Wegner, P., Yonezawa, A. </author> <booktitle> ACM SIG-PLAN Workshop on Object-Based Concurrent Programming. ACM, </booktitle> <month> April </month> <year> 1989. </year> <journal> ACM SIGPLAN Notices, Vol.24, </journal> <volume> No.4. </volume> <pages> Page 17 </pages>
Reference: [4] <author> America, P., POOL-T: </author> <title> A Parallel Object-Oriented Language., Object-Oriented Concurrent Programming, </title> <editor> ed. M. Tokoro, A. </editor> <booktitle> Yonezawa, </booktitle> <pages> pp. 199-220, </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Mass. </address> <year> 1987. </year>
Reference-contexts: Most of the earlier systems fall into the first approach: design a new object-oriented language with built-in concurrency. Some examples are: Hybrid [21], POOL <ref> [4] </ref> (and its variants), SR [5], ABCL/1 [25]. These new languages provide powerful concurrency abstractions and general-purpose programming capabilities. Most of the extensions introduce concurrency to their respective languages using some combination of the following techniques: 1. inheritance from special concurrency classes that the modified compiler recognizes - e.g. <p> Some other languages that belong to this classification are POOL-T <ref> [4] </ref>, ABCL/1 [25], and Eiffel// [11]. The basic mechanism in our method to access results of asynchronous calls, i.e. using the FUTURE type objects returned by remote invocations, are similar to the ConcurrentSmalltalk's CBoxes [24] and ABCL/1's future type messages [25].
Reference: [5] <author> Andrews, </author> <title> G.R., et.al. An Overview of the SR Language and implementation. </title> <note> ACM Transactions on Programming Languages and Systems.10 (January 1988) 51. </note>
Reference-contexts: Most of the earlier systems fall into the first approach: design a new object-oriented language with built-in concurrency. Some examples are: Hybrid [21], POOL [4] (and its variants), SR <ref> [5] </ref>, ABCL/1 [25]. These new languages provide powerful concurrency abstractions and general-purpose programming capabilities. Most of the extensions introduce concurrency to their respective languages using some combination of the following techniques: 1. inheritance from special concurrency classes that the modified compiler recognizes - e.g.
Reference: [6] <author> Bershad, </author> <title> B.N., et.al. PRESTO: A System for Object-Oriented Parallel Programming. </title> <journal> Software-Practice and Experience. </journal> <month> 18 (August </month> <year> 1988) </year> <month> 713. </month>
Reference-contexts: These new languages provide powerful concurrency abstractions and general-purpose programming capabilities. Most of the extensions introduce concurrency to their respective languages using some combination of the following techniques: 1. inheritance from special concurrency classes that the modified compiler recognizes - e.g. Eiffel// [11] , PRESTO <ref> [6] </ref> ; 2. special keywords, modifiers or preprocessing techniques to modify or extend the language syntax and semantics - e.g. C++ [8] , CEif-fel [18] ; 3. extension to the syntax and semantics of the language to support a general concur-rency paradigm such as the Actor model [1] - e.g.
Reference: [7] <author> Briot, J-. P. Actalk: </author> <title> A testbed for classifying and designing actor languages in Smalltalk-80 environment. </title> <booktitle> In Proceedings of the Third ECOOP Conference '89.(July 10-4 1989, </booktitle> <address> Nottingham), </address> <publisher> Cambridge University Press, </publisher> <year> 1989, </year> <month> pp.109-129. </month>
Reference-contexts: C++ [8] , CEif-fel [18] ; 3. extension to the syntax and semantics of the language to support a general concur-rency paradigm such as the Actor model [1] - e.g. ACT++ [15], Actalk <ref> [7] </ref>. Our concurrency mechanism, and Colin and Geib's [12] Eiffel Classes, fall in the library approach. The approach of introducing concurrency via a class definition of Process is also used in the Choices operating system [10] where they use the C++ language.
Reference: [8] <author> Buhr, </author> <title> P.A., et.al. C++: Concurrency in the Object-oriented Language C++. </title> <note> Software-Practice and Experience.22(2) (February 1992) 137. </note>
Reference-contexts: Eiffel// [11] , PRESTO [6] ; 2. special keywords, modifiers or preprocessing techniques to modify or extend the language syntax and semantics - e.g. C++ <ref> [8] </ref> , CEif-fel [18] ; 3. extension to the syntax and semantics of the language to support a general concur-rency paradigm such as the Actor model [1] - e.g. ACT++ [15], Actalk [7]. Our concurrency mechanism, and Colin and Geib's [12] Eiffel Classes, fall in the library approach.
Reference: [9] <author> Buhr, P.A., Ditchfield, G. </author> <title> Adding concurrency to a programming language. </title> <booktitle> In Proceedings of USENIX C++ Technical Conference (August 10-13, 1992, </booktitle> <address> Portland Or.) </address> <publisher> USENIX Association, </publisher> <address> Berkeley, </address> <year> 1992, </year> <pages> pp. 207-223. </pages>
Reference-contexts: We address this issues in the context of our design method in the section where we present the bounded buffer example and in the conclusion. Some of these issues are also addressed by Buhr in <ref> [9] </ref>. The order in which we have presented the three approaches also follows a chronological order. Most of the earlier concurrent object-oriented languages were new languages. As object-oriented thinking matured and sequential object-oriented languages started to become popular, numerous proposals were made to extend these sequential languages for concurrent programming. <p> Some of these difficulties are related with mutual exclusion of the execution of an objects's methods, and non-reentrant system calls. Some of these issues have been mentioned in <ref> [9] </ref>. A concurrency mechanism with multi threaded active objects must satisfactorily address the interference problem with respect to data encapsulation, procedural abstraction and reusability issues, that emerge due to the potential arbitrary interleavings of an object's methods.
Reference: [10] <author> Campbell, R., Islam, N., Madany, P. </author> <title> Choices, Frameworks and Refinement. </title> <booktitle> Computing Systems, </booktitle> <month> 5(3) </month> <year> (1992) </year> <month> 217-257. </month>
Reference-contexts: ACT++ [15], Actalk [7]. Our concurrency mechanism, and Colin and Geib's [12] Eiffel Classes, fall in the library approach. The approach of introducing concurrency via a class definition of Process is also used in the Choices operating system <ref> [10] </ref> where they use the C++ language. The library based solutions are attractive since they do not replace the existing software development platform. However, the sequential execution semantics of the host language may impose restrictions on providing type-safety and intra-object concurrency.
Reference: [11] <author> Caromel, D. </author> <title> Concurrency and Reusability: From Sequential to Parallel. </title> <note> Journal of Object-Oriented Programming,3(3) ( September 1990) 34. </note>
Reference-contexts: These new languages provide powerful concurrency abstractions and general-purpose programming capabilities. Most of the extensions introduce concurrency to their respective languages using some combination of the following techniques: 1. inheritance from special concurrency classes that the modified compiler recognizes - e.g. Eiffel// <ref> [11] </ref> , PRESTO [6] ; 2. special keywords, modifiers or preprocessing techniques to modify or extend the language syntax and semantics - e.g. <p> The type, T, of return value is the actual type returned by obj's method feature. This is a data-driven synchronization scheme, based on asynchronous message passing, and is referred to as the wait-by-necessity by Caromel <ref> [11] </ref> . The CONCURRENCY class provides two methods to access the result of a remote method invocation. Both of the methods take a single argument, a call id, which is returned by the corresponding remote invocation as a handle to obtain the actual result in the future. <p> Some other languages that belong to this classification are POOL-T [4], ABCL/1 [25], and Eiffel// <ref> [11] </ref>. The basic mechanism in our method to access results of asynchronous calls, i.e. using the FUTURE type objects returned by remote invocations, are similar to the ConcurrentSmalltalk's CBoxes [24] and ABCL/1's future type messages [25]. There are several other proposals for concurrent programming with Eiffel: Eiffel// [11], Meyer's proposal [20], <p> [25], and Eiffel// <ref> [11] </ref>. The basic mechanism in our method to access results of asynchronous calls, i.e. using the FUTURE type objects returned by remote invocations, are similar to the ConcurrentSmalltalk's CBoxes [24] and ABCL/1's future type messages [25]. There are several other proposals for concurrent programming with Eiffel: Eiffel// [11], Meyer's proposal [20], CEiffel [18], and Colin and Geib's Concurrency Classes [12]. Our mechanism is most similar to Caromel's Eiffel//. Unlike Eiffel// however, we do not modify the Eiffel compiler or extend the language.
Reference: [12] <author> Colin, J-.F., Geib, J-.M. </author> <title> Eiffel Classes for concurrent programming.In Proceedings of TOOLS-4 '91 Conference. </title> <publisher> Prentice Hall 1991, pp.23-34. </publisher>
Reference-contexts: C++ [8] , CEif-fel [18] ; 3. extension to the syntax and semantics of the language to support a general concur-rency paradigm such as the Actor model [1] - e.g. ACT++ [15], Actalk [7]. Our concurrency mechanism, and Colin and Geib's <ref> [12] </ref> Eiffel Classes, fall in the library approach. The approach of introducing concurrency via a class definition of Process is also used in the Choices operating system [10] where they use the C++ language. The library based solutions are attractive since they do not replace the existing software development platform. <p> There are several other proposals for concurrent programming with Eiffel: Eiffel// [11], Meyer's proposal [20], CEiffel [18], and Colin and Geib's Concurrency Classes <ref> [12] </ref>. Our mechanism is most similar to Caromel's Eiffel//. Unlike Eiffel// however, we do not modify the Eiffel compiler or extend the language. Our model provides additional support for coping with local delays, by letting the scheduler inspect the actual arguments of all pending requests before accepting one for service.
Reference: [13] <author> Cox, B. </author> <title> Object Oriented Programming an evolutionary approach. </title> <publisher> Addison Wesley, </publisher> <address> Reading Mass. </address> <year> 1986 </year>
Reference-contexts: We present our concurrency abstractions as encapsulated behavior of Eiffel objects, that can be inherited from the Concurrency Class. Although the design described here is specific to the Eiffel language, most of these abstractions are generally applicable to other object-oriented languages such as C++ [14], and Objective-C <ref> [13] </ref>. The main concurrency abstractions provided by our mechanism are objects as processes active objects and an asynchronous remote method invocation with data-driven synchronization.
Reference: [14] <author> Ellis, M., Stroustrup, B. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading Mass., </address> <year> 1990. </year>
Reference-contexts: We present our concurrency abstractions as encapsulated behavior of Eiffel objects, that can be inherited from the Concurrency Class. Although the design described here is specific to the Eiffel language, most of these abstractions are generally applicable to other object-oriented languages such as C++ <ref> [14] </ref>, and Objective-C [13]. The main concurrency abstractions provided by our mechanism are objects as processes active objects and an asynchronous remote method invocation with data-driven synchronization.
Reference: [15] <author> Kafura, D.G., Lee, K.H. </author> <title> Inheritance in ACtor based concurrent object-oriented languages. </title> <booktitle> In Proceedings of ECOOP '89(July 10-14, </booktitle> <address> Nottingham). </address> <publisher> Cambridge University Press, </publisher> <year> 1989, </year> <month> pp.131-145. </month>
Reference-contexts: C++ [8] , CEif-fel [18] ; 3. extension to the syntax and semantics of the language to support a general concur-rency paradigm such as the Actor model [1] - e.g. ACT++ <ref> [15] </ref>, Actalk [7]. Our concurrency mechanism, and Colin and Geib's [12] Eiffel Classes, fall in the library approach. The approach of introducing concurrency via a class definition of Process is also used in the Choices operating system [10] where they use the C++ language.
Reference: [16] <author> Karaorman, M., and Bruno, J. </author> <title> A concurrency mechanism for sequential Eiffel. </title> <booktitle> In Proceedings of TOOLS USA '92 Conference(Aug. </booktitle> <pages> 3-6, </pages> <address> Santa Bar-bara, Calif.). </address> <publisher> Prentice Hall 1992, pp.63-77. </publisher>
Reference: [17] <author> Liskov, B., Herlihy, M., Gilbert, L. </author> <title> Limitations of synchronous communication with static process structure in languages for distributed computing. Concurrent Programming, </title> <editor> ed. Gehani and McGet-trick, </editor> <publisher> Addison-Wesley 1988. </publisher>
Reference-contexts: Message acceptance is asynchronous and explicit. Also accepting a message is separated from actually, serving the request. Thus the model provides a powerful mechanism for dealing with local delays, which is deemed essential in Liskov et al.'s <ref> [17] </ref> formulation of concurrency requirements for developing client/server type distributed programs. Messages delivered to the communication buffer, but not yet accepted into the request queue are called pending requests. A queue of request messages, called request queue contains all the accepted requests of the client objects. <p> The active server object can choose the type of requests to respond to and in what order. This is a powerful mechanism addressing the problem of dealing with local delays <ref> [17] </ref>. The design presented here does not assume a shared-memory model and supports distribution of the active objects over a network.
Reference: [18] <author> Lohr, K.-P. </author> <title> Concurrency Annotations improve reusability. </title> <booktitle> In Proceedings of TOOLS USA '92 Conference(Aug. </booktitle> <pages> 3-6, </pages> <address> Santa Barbara, Calif.). </address> <publisher> Prentice Hall 1992, pp.53-62. </publisher>
Reference-contexts: Eiffel// [11] , PRESTO [6] ; 2. special keywords, modifiers or preprocessing techniques to modify or extend the language syntax and semantics - e.g. C++ [8] , CEif-fel <ref> [18] </ref> ; 3. extension to the syntax and semantics of the language to support a general concur-rency paradigm such as the Actor model [1] - e.g. ACT++ [15], Actalk [7]. Our concurrency mechanism, and Colin and Geib's [12] Eiffel Classes, fall in the library approach. <p> The library approach is more recent, and has been influenced by most of the earlier work on concurrency. Latest trends for object-based concurrency emphasize and address issues such as reusability and compatibility with object-oriented software engineering techniques as fundamental requirements <ref> [18] </ref>, [22]. A major focus of our work has been to address the issues of reusability and compatibility with the object-oriented paradigm. A discussion of these issues is presented after we describe our concurrency mechanism and the method. <p> There are several other proposals for concurrent programming with Eiffel: Eiffel// [11], Meyer's proposal [20], CEiffel <ref> [18] </ref>, and Colin and Geib's Concurrency Classes [12]. Our mechanism is most similar to Caromel's Eiffel//. Unlike Eiffel// however, we do not modify the Eiffel compiler or extend the language.
Reference: [19] <author> Meyer, B., </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Introduction The work described in this paper introduces concurrency to the object-oriented language Eiffel by providing a set of Class Libraries and an associated concurrent programming design method. The concurrency mechanism we provide is well-suited for client/server style distributed applications. Since no changes are made to the Eiffel Language <ref> [19] </ref>, or its runtime system, the essential principles of sequential object-oriented programming offered by Eiffel are not sacrificed. We present our concurrency abstractions as encapsulated behavior of Eiffel objects, that can be inherited from the Concurrency Class. <p> On the other hand, the result ready method does a simple non-blocking search of result queue, to test whether a particular result is delivered yet. Implementation Status The described system is implemented using version 2.2 Eiffel of ISE <ref> [19] </ref>, running on Sun's UNIX based Sun OS 3.0. It is written largely in Eif-fel, with the low level operating system and inter-process-communication (IPC) routines written in C language as external Eiffel routines. The asynchronous communication is implemented using Internet domain sockets, and (UDP) datagram messages. <p> Reusability issues An important aspect of our method is its support for software composition and reuse. This support is due to the fact that our concurrency mechanism is compatible with the key object oriented principles used for providing reusability. These principles are: data encapsulation, data abstraction, inheritance and genericity <ref> [19] </ref>. Data encapsulation property of objects in sequential Eiffel is respected by our method. Active objects have a protected internal state which can only be accessed or modified by invoking a method specified in its interface.
Reference: [20] <author> Meyer, B., </author> <title> Sequential and Concurrent Object-Oriented Programming. </title> <booktitle> In Proceedings of TOOLS 2 Conference(SOL/Angkor, </booktitle> <address> Paris, </address> <month> June </month> <year> 1990). </year> <pages> pp. 17-28, </pages> <year> 1990. </year>
Reference-contexts: The basic mechanism in our method to access results of asynchronous calls, i.e. using the FUTURE type objects returned by remote invocations, are similar to the ConcurrentSmalltalk's CBoxes [24] and ABCL/1's future type messages [25]. There are several other proposals for concurrent programming with Eiffel: Eiffel// [11], Meyer's proposal <ref> [20] </ref>, CEiffel [18], and Colin and Geib's Concurrency Classes [12]. Our mechanism is most similar to Caromel's Eiffel//. Unlike Eiffel// however, we do not modify the Eiffel compiler or extend the language.
Reference: [21] <author> Nierstrasz, O.M. </author> <title> Active Objects in Hybrid. </title> <journal> ACM SIGPLAN Notices. </journal> <month> 22 (December </month> <year> 1987) </year> <month> 243. </month>
Reference-contexts: Most of the earlier systems fall into the first approach: design a new object-oriented language with built-in concurrency. Some examples are: Hybrid <ref> [21] </ref>, POOL [4] (and its variants), SR [5], ABCL/1 [25]. These new languages provide powerful concurrency abstractions and general-purpose programming capabilities.
Reference: [22] <author> Nierstrasz, O.M. </author> <title> Next 700 concurrent object-oriented languages Reflections on the future of object-based concurrency. In Object Composition, </title> <editor> ed. </editor> <address> D.C. </address> <institution> Tsichritzis, pp.165-187, Centre Universitaire d'Informatique, University of Geneva, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: The library approach is more recent, and has been influenced by most of the earlier work on concurrency. Latest trends for object-based concurrency emphasize and address issues such as reusability and compatibility with object-oriented software engineering techniques as fundamental requirements [18], <ref> [22] </ref>. A major focus of our work has been to address the issues of reusability and compatibility with the object-oriented paradigm. A discussion of these issues is presented after we describe our concurrency mechanism and the method. <p> Reply scheduling is the control the client has over the delivery of the reply and request scheduling is the control the active object object server has over the acceptance and service of the requests <ref> [22] </ref>. Reply scheduling is addressed by the remote invoke, claim result and result ready methods as presented in the previous section. This section describes the request scheduling methods: get request, pending request exists, send result, and the scheduler.
Reference: [23] <author> Papathomas, M. </author> <title> Concurrency Issues in Object-Oriented Languages.Object Oriented Development Technical Report, </title> <institution> Centre Universitaire Informatique, University of Geneva, ed. </institution> <address> D. </address> <publisher> Tsichritzis, </publisher> <pages> pp. 207-245, </pages> <year> 1989. </year>
Reference-contexts: Design a new concurrent object-oriented lan guage. 2. Extend an existing object-oriented language. 3. Design a Concurrency Library. Use an existing object-oriented language and provide concurrency abstractions through external li braries. Page 1 Many references and comparative discussions about concurrent object-oriented languages can be found in [2] <ref> [23] </ref>, and for brevity we won't discuss specific features of these languages here. Most of the earlier systems fall into the first approach: design a new object-oriented language with built-in concurrency. Some examples are: Hybrid [21], POOL [4] (and its variants), SR [5], ABCL/1 [25]. <p> Data item is needed i Data item ?= box.data ; wait here until data is available h Consume Data Item i end; loop end; - scheduler end class CONSUMER Comparison with Other Approaches Our concurrency mechanism fits into the nonuniform, and non-orthogonal category of Pap-athomas' classification of object-oriented concur-rency approaches <ref> [23] </ref>, since we allow both active and non-active objects to co-exist and have single threaded active objects. Some other languages that belong to this classification are POOL-T [4], ABCL/1 [25], and Eiffel// [11].
Reference: [24] <author> Yokote, Y., and Tokoro, M. </author> <title> Concurrent Programming in ConcurrentSmalltalk. </title> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pp. 129-158, </pages> <publisher> MIT Press, </publisher> <address> Cam-bridge, Mass. </address> <year> 1987. </year>
Reference-contexts: Explicit invocation of claim result, and result available is also eliminated by the utilization of the FUTURE type. The FUTURE type objects returned by the proxy object are similar to the ConcurrentSmalltalk's CBoxes <ref> [24] </ref> and ABCL/1's future type messages [25] . future: FUTURE; return value : T; future := act obj.method (arg1, arg2 ... ); . . . concurrent execution with obj return value ?= future.data; implicit claim result from act obj Page 4 Scheduling Two types of scheduling are supported by our concurrency <p> Some other languages that belong to this classification are POOL-T [4], ABCL/1 [25], and Eiffel// [11]. The basic mechanism in our method to access results of asynchronous calls, i.e. using the FUTURE type objects returned by remote invocations, are similar to the ConcurrentSmalltalk's CBoxes <ref> [24] </ref> and ABCL/1's future type messages [25]. There are several other proposals for concurrent programming with Eiffel: Eiffel// [11], Meyer's proposal [20], CEiffel [18], and Colin and Geib's Concurrency Classes [12]. Our mechanism is most similar to Caromel's Eiffel//.
Reference: [25] <author> Yonezawa, A., et.al., </author> <title> Modelling and Programming in an Object-Oriented Concurrent Language ABCL/1. </title> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pp. 55-89, </pages> <publisher> MIT Press, </publisher> <address> Cambridge, Mass. </address> <year> 1987. </year> <pages> Page 18 </pages>
Reference-contexts: Most of the earlier systems fall into the first approach: design a new object-oriented language with built-in concurrency. Some examples are: Hybrid [21], POOL [4] (and its variants), SR [5], ABCL/1 <ref> [25] </ref>. These new languages provide powerful concurrency abstractions and general-purpose programming capabilities. Most of the extensions introduce concurrency to their respective languages using some combination of the following techniques: 1. inheritance from special concurrency classes that the modified compiler recognizes - e.g. <p> Explicit invocation of claim result, and result available is also eliminated by the utilization of the FUTURE type. The FUTURE type objects returned by the proxy object are similar to the ConcurrentSmalltalk's CBoxes [24] and ABCL/1's future type messages <ref> [25] </ref> . future: FUTURE; return value : T; future := act obj.method (arg1, arg2 ... ); . . . concurrent execution with obj return value ?= future.data; implicit claim result from act obj Page 4 Scheduling Two types of scheduling are supported by our concurrency mechanism: reply scheduling and request scheduling. <p> Some other languages that belong to this classification are POOL-T [4], ABCL/1 <ref> [25] </ref>, and Eiffel// [11]. The basic mechanism in our method to access results of asynchronous calls, i.e. using the FUTURE type objects returned by remote invocations, are similar to the ConcurrentSmalltalk's CBoxes [24] and ABCL/1's future type messages [25]. <p> Some other languages that belong to this classification are POOL-T [4], ABCL/1 <ref> [25] </ref>, and Eiffel// [11]. The basic mechanism in our method to access results of asynchronous calls, i.e. using the FUTURE type objects returned by remote invocations, are similar to the ConcurrentSmalltalk's CBoxes [24] and ABCL/1's future type messages [25]. There are several other proposals for concurrent programming with Eiffel: Eiffel// [11], Meyer's proposal [20], CEiffel [18], and Colin and Geib's Concurrency Classes [12]. Our mechanism is most similar to Caromel's Eiffel//. Unlike Eiffel// however, we do not modify the Eiffel compiler or extend the language.
References-found: 25

