URL: http://www.cs.brown.edu/research/oodb/papers/dbpl-93-ordered.ps
Refering-URL: http://www.cs.brown.edu/research/oodb/
Root-URL: http://www.cs.brown.edu
Title: Ordered Types in the AQUA Data Model  
Author: Bharathi Subramanian Stanley B. Zdonik Theodore W. Leung Scott L. Vandenberg 
Date: 1993  
Note: To appear in Proc. 4th Intl. Workshop on Database Programming Languages,  
Address: Providence, RI, USA  Providence, RI, USA  Providence, RI, USA  Amherst, MA, USA  
Affiliation: Brown University  Brown University  Brown University  University of Massachusetts  
Abstract: We present a query algebra that supports ordering among the data elements. Order is defined as a relationship between various data elements of an instance. This relationship can be a total or partial order among the elements or among equivalence classes where each equivalence class consists of one or more elements. In terms of data structures, ordered types can be viewed as graphs, trees, or lists. Lately there has been a lot of interest in bulk types like lists, trees, and graphs that are not supported by traditional data models and query algebras. This interest is fueled by the fact that much of the data in the scientific domain is inherently ordered. Therefore, scientific applications that involve genome sequences, satellite data, scientific data, etc. require database support for ordered data structures like lists, trees, and graphs. In this paper, we discuss an extension to the AQUA query algebra to handle ordered types and their operators. We show how these operators can fit into a framework for query optimization.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Catriel Beeri and Yoram Kornatzky, </author> <title> "Algebraic Optimization of Object-Oriented Query Languages," </title> <booktitle> Proceedings of the International Conference on Database Theory (1990), </booktitle> <pages> 72-83. </pages>
Reference-contexts: With cells, we could have the same object represented as two different nodes, as the identity of the cells provides the uniqueness. 3 Related Work Much of the previous work with ordering deals with order as in sequences or arrays. Beeri and Kornatzky <ref> [1] </ref> discuss trees in their paper. However, there is no known work with directed acyclic graphs or graphs, in the domain of database applications. <p> In this approach, lists, arrays, and trees can all be defined, and a subset of the useful operations on such structures is described in the paper. These operations include a "pump" function, which is similar to AQUA's fold operation. Since the operations described in <ref> [1] </ref> are intended to be applicable to any bulk type, not just to lists and trees, they are too general for our purposes we wish to distinguish between ordered and unordered types, and provide a richer set of operations. Furthermore, many of the operations listed in [1] are not described precisely, <p> the operations described in <ref> [1] </ref> are intended to be applicable to any bulk type, not just to lists and trees, they are too general for our purposes we wish to distinguish between ordered and unordered types, and provide a richer set of operations. Furthermore, many of the operations listed in [1] are not described precisely, and their existence is assumed. Here we remove that assumption. Graphs are not discussed in [1], and it is not clear how (or if) they would fit into the paradigm presented there. <p> Furthermore, many of the operations listed in <ref> [1] </ref> are not described precisely, and their existence is assumed. Here we remove that assumption. Graphs are not discussed in [1], and it is not clear how (or if) they would fit into the paradigm presented there. MDM [10] talks about a query algebra to support lists in an object-oriented data model. Operators from a discrete, linear-time temporal logic provide the basis for the algebra.
Reference: [2] <author> James C. French, Anita K. Jones, and John L. Pfaltz, </author> <title> "Summary of the Final Report of the NSF Workshop on Scientific Database Mgmt.," </title> <booktitle> SIG-MOD Record 19 (1990), </booktitle> <pages> 32-40. </pages>
Reference: [3] <author> Karen A. Frenkel, </author> <title> "The Human Genome Project and Informatics," </title> <booktitle> Communications of the ACM 34 (1991), </booktitle> <pages> 41-51. </pages>
Reference: [4] <author> Johann C. Freytag, </author> <title> "Tree Acceptors and Some of their Applications," </title> <journal> Journal of Computer and System Sciences 4 (1970), </journal> <pages> 406-451. </pages>
Reference: [5] <author> Seymour Ginsburg and Xiaoyang Wang, </author> <title> "Pattern Matching by Rs-Operations: Towards a Unified Approach to Querying Sequenced Data," </title> <booktitle> Proceedings of the 11th ACM Principles of Database Systems (1992), </booktitle> <pages> 293-300. </pages>
Reference-contexts: As a result, most of the operators are not commutative. Duplicates are allowed in lists, however union and intersection eliminate duplicates from the result set. A tree-like structure in a document (paragraphs under sections) is handled by treating it as a nested sequence of sequences. Rs-operations <ref> [5] </ref> are sequence operations that are based on pattern matching. Along with these operations, sequence logic (SL), which is a first-order logic, is also introduced. Ginsburg and Wang define a set of powerful operations based on regular expressions, which act as a kind of template for the operation.
Reference: [6] <author> Ralf Harmut Guting, Roberto Zicari, and David M. Choy, </author> <title> "An Algebra for Structured Office Documents," </title> <journal> ACM Transactions on Office Information Systems 7 (1989), </journal> <pages> 123-157. </pages>
Reference-contexts: Union and difference are similar to the corresponding operators in EXTRA/EXCESS [12]. However, the MDM algebra does not provide for operations on trees or graphs. The NST algebra <ref> [6] </ref> is specifically designed for structured office documents and is an extension of relational algebra. The data model is based on nested sequences of tuples. It tries to maintain the order of the input lists whenever possible, with a higher preference for the order of the first input list.
Reference: [7] <author> R. Karp, R. Miller, and A. Rosenberg, </author> <title> "Rapid Identification of Repeated Patterns in Strings, Trees, and Arrays," </title> <booktitle> Proc. 4th Annual ACM Symposium on Theory of Computing (1972), </booktitle> <pages> 125-136. </pages>
Reference-contexts: In other words, ? represents a tree with one node, whose contents are unknown. An important special case of tree patterns are those in which we are only interested in the structure of the tree <ref> [7] </ref>, not in the contents of the nodes. The ? symbol makes such patterns easy to express in our notation. To represent the most general tree pattern, which will match any tree at all, we need an analog to the "? fl " of regular expressions.
Reference: [8] <author> Eric S. Lander, Robert Langridge, and Damien M. Saccocio, </author> <title> "Mapping and Interpreting Biological Information," </title> <booktitle> Communications of the ACM 34 (1991), </booktitle> <pages> 33-39. </pages>
Reference: [9] <author> Theodore W. Leung, Gail Mitchell, Bharathi Subramanian, Bennet Vance, Scott L. Vandenberg, and Stanley B. Zdonik, </author> <title> "The AQUA Data Model and Algebra," </title> <booktitle> Proc. 4th Intl. Workshop on Database Programming Languages (1993). </booktitle>
Reference-contexts: While there has been some recent work on extending query languages to other bulk types like sequences [5,10], additional research is needed. This paper presents an extension to the AQUA (A QUery Algebra) query algebra <ref> [9] </ref> to include ordered types like graphs, lists, and trees. N-dimensional arrays are a topic for future work. We begin by defining algebraic operations over graphs. Graphs are used as the fundamental building block out of which the operations for the other types are derived. <p> This is followed by a discussion of the specific operators that we support for graphs, trees, and lists. We close with a few examples of how these operators are used and some suggestions for future research. 2 AQUA Model The AQUA query algebra <ref> [9] </ref> is based on an object-oriented data model. All objects have identity, and these identities allow us to distinguish between objects using identity-based equalities. Equality is essential to the definition of operators like union, intersection and other comparison-based operators. <p> Lists and trees do not participate in subtyping. 5 Operators In this section, we describe in detail the various operations on graphs, trees and lists. The functionality of most operators is similar across all the ordered types. The syntax of the operations is similar to that used in AQUA <ref> [9] </ref>, and is based on lambda calculus. Predicates are functions with boolean return type, and are composed using AQUA's built-in operators and its term language (which is based on lambda calculus). Predicates are passed as parameters to operators like select. <p> This formalism is based on regular expressions, but could be extended to more expressive pattern languages such as context-free grammars. Current and future research includes investigation of additional operators on ordered bulk types (e.g. LFP, as described in <ref> [9] </ref>) and implementation techniques for indexing over ordered bulk types. We are presently looking at ways to extend our tree pattern language to work with DAGs. Indexable ordered types in AQUA (such as N-dimensional arrays) will be discussed in a future paper.
Reference: [10] <author> Joel Richardson, </author> <title> "Supporting Lists in a Data Model (A Timely Approach)," </title> <booktitle> Proceedings of the 18th VLDB Conference (1992). </booktitle>
Reference-contexts: Furthermore, many of the operations listed in [1] are not described precisely, and their existence is assumed. Here we remove that assumption. Graphs are not discussed in [1], and it is not clear how (or if) they would fit into the paradigm presented there. MDM <ref> [10] </ref> talks about a query algebra to support lists in an object-oriented data model. Operators from a discrete, linear-time temporal logic provide the basis for the algebra.
Reference: [11] <author> J. W. Thatcher and J. B. Wright, </author> <title> "Generalized Finite Automata Theory with an Application to a Decision Problem of Second-Order Logic," </title> <booktitle> Mathematical Systems Theory 2 (1968), </booktitle> <pages> 57-81. </pages>
Reference: [12] <author> Scott L. Vandenberg and David J. DeWitt, </author> <title> "Algebraic Support for Com--plex Objects with Arrays, Identity, and Inheritance," </title> <booktitle> Proceedings of the SIGMOD Intl. Conference on Management of Data (1991), </booktitle> <pages> 158-167. </pages>
Reference-contexts: The salient feature of the algebra is the extension of the predicate language to allow position-dependent queries, which adds a lot more flexibility to the kind of queries that can be posed to the database. Union and difference are similar to the corresponding operators in EXTRA/EXCESS <ref> [12] </ref>. However, the MDM algebra does not provide for operations on trees or graphs. The NST algebra [6] is specifically designed for structured office documents and is an extension of relational algebra. The data model is based on nested sequences of tuples. <p> However, the paper does not mention how these operations can be extended to trees. Also, the authors do not specify how these operations fit into a query optimization scheme. The EXTRA/EXCESS system <ref> [12] </ref> contains an array type constructor; ar rays can be fixed- or variable-length and can contain entities of any EXTRA type. The elements of an array are accessed using their array indices, but there is no ability to traverse from one element to another in these arrays.
References-found: 12

