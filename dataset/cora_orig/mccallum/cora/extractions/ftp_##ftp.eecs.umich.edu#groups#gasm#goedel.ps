URL: ftp://ftp.eecs.umich.edu/groups/gasm/goedel.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: boerger@di.unipi.it  riccobene@mathct.cineca.it  
Title: Logic Control revisited: an abstract interpreter for Godel programs  
Author: Egon Borger Elvinia Riccobene 
Address: C.so Italia 40, I-56100 PISA  V.le Andrea Doria 6, I-95125 CATANIA  
Affiliation: Dip. di Informatica  Dip. di Matematica  
Abstract: 1 We develop a simple interpreter for programs of the new logic 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Apt, K. </author> <year> (1990). </year> <note> Logic Programing. Handbook of Theoretical Computer Science (ed. </note> <editor> J.van Leeuwen). </editor> <publisher> Elsevier, vol.B, </publisher> <pages> 493-574. </pages>
Reference: 2. <author> Beierle, C. and Borger, E. </author> <year> (1992). </year> <title> Correctness Proof for the WAM with types. </title> <booktitle> CSL'91, 5th Workshop on Computer Science Logic (eds. </booktitle> <address> E.Borger, H.Kleine Buning, G.Jaeger, M.M.Richter). </address> <publisher> Springer LNCS 626, </publisher> <pages> pp. 15-34. </pages>
Reference-contexts: 1 Introduction J.W.Lloyd and P.Hill <ref> (1992) </ref> have proposed the new general-purpose logic programming language Godel, with particular emphasis on improving the declarative semantics compared with Prolog. <p> implementation point of view, non determinism reflects the intended flexibility of Godel's computational rule and the desire "to give implementors the option" of not relying upon (some generalization of) SLDNF-resolution but "of using other theorem proving techniques to implement the language, e.g. ones which avoid floundering or are more complete" <ref> (Lloyd 1992) </ref>. We develop here, by stepwise refinement, a mathematically precise but simple procedural formalisation of the language which describes the full (control flow) behaviour of Godel programs on the basis of abstract| machine and resolution independent|search spaces. <p> Other system features in Godel (for constraints, number manipulation etc.) can be dealt with in this model by adapting the methodology developed in (Borger 1990b, 1992; Borger and Rosenzweig 1993a; Borger and Schmitt 1991) for the formalization of their (sometimes quite different) Prolog homonyms; see also <ref> (Beierle and Borger 1992) </ref> for a treatment of polymorphic types for an extension of Prolog. <p> We indicate the effect of depth-first search on this abstract specification and briefly discuss how to obtain from it a concurrent model of Godel. 2 Evolving Algebras We expect from the reader basic knowledge of logic programming (Apt 1990; Lloyd 1987) or Godel <ref> (Hill and Lloyd 1992) </ref> and rudimentary knowledge of the language of first order logic. Our model comes in the form of evolving algebras. <p> Therefore Godel Algebras have as basic universe a set Node representing all possible Godel computation states, containing a distinguished element (0-ary function) currnode representing the current computation state. 2 See <ref> (Beierle and Borger 1992) </ref> for a formal specification, using the methodology of evolving algebras, of polymorphic types present at runtime for an extension of Prolog. 6 An abstract interpreter for Godel programs One aspect of Godel's non determinism is that the computation can leave what it is doing at any part <p> The implementation just has to implement correctly the declarative meaning. However, these are the likely restrictions implementations will make in the near future. Cited from (Lloyd 1993) Egon Borger and Elvinia Riccobene 9 (and therefore of act). Following <ref> (Hill and Lloyd 1992) </ref> the DELAY declaration delaydecl (l,P) for a predicate (literal) l in a program P has form DELAY Atom 1 UNTIL Cond 1 : : : Atom n UNTIL Cond n with conditions built up from predicates NONVAR, GROUND, TRUE using conjunction and disjunction, and atoms pairwise without <p> These children which either will be or have been created and are not on the path must never be selected. Thus we abandon those children that exist and prevent the remaining clauses in cands (n) from creating new children. Using the wording of <ref> (Hill and Lloyd 1992) </ref> we access these nodes and candidate clauses, which may have to be abandoned and deleted respectively, by abstract functions children 1st kind : Node fi Integer ! Node fl [ fnilg and cands 1st kind : Node fi Integer ! Clause fl (It would be easy to <p> It happens when act becomes neg beg neg end (n) in call mode, for some node n. If mode = call & act = neg beg neg end (n) then mode (n):= abandoned To disable pruning inside a negated call <ref> (Hill and Lloyd 1992, p.77) </ref>, it suffices to refine the pruning update by putting it under the (easily formalizable) guard: If act is not in the scope of neg-brackets neg beg neg end (n) Then. 5.4 The computation of conditionals In (Hill and Lloyd 1992) two forms of conditionals IF Condition <p> (n):= abandoned To disable pruning inside a negated call (Hill and Lloyd 1992, p.77), it suffices to refine the pruning update by putting it under the (easily formalizable) guard: If act is not in the scope of neg-brackets neg beg neg end (n) Then. 5.4 The computation of conditionals In <ref> (Hill and Lloyd 1992) </ref> two forms of conditionals IF Condition THEN For-mula1 ELSE Formula2 are distinguished, depending on whether Condition and Formula1 share (local) variables. <p> See FIG.2. Egon Borger and Elvinia Riccobene 19 To prevent the system from stepping, by backtracking at node n, into the ELSE rules, we set additionally a mark then case (n) to 1. The idea in <ref> (Hill and Lloyd 1992) </ref> seems to be that once the guard of a conditional is satisfied, computation first proceeds with the THEN-part and only upon failure tries to resatisfy the guard. <p> This corresponds to what has been experienced by us in our formalization of the two forms of parallel logic programming represented by PARLOG (Borger and Riccobene 1993) and CONCURRENT PROLOG <ref> (Borger and Riccobene 1992) </ref>. 7 Conclusion and Outlook The abstract interpreter for Godel programs which has been developed in this paper|refining the core for user-defined predicates by introducing stepwise delay, pruning, negation, conditionals and their implementation under the depth-first strategy|constitutes a mathematical object of manageable complexity. <p> where each refinement step comes with a mathematical correctness proof; very much along the lines of what has been achieved for PROLOG with respect to the Warren Abstract Machine (Borger and Rosenzweig 1993b) and for its typed extension PROTOS-L (Beierle et al. 1991) with respect to the Protos Abstract Machine <ref> (Beierle and Borger 1992) </ref>. This may actually provide some methodological help for implementing Godel. 8 Acknowledgements The authors wish to express their warm thanks to John Lloyd and Pat Hill for careful study and fruitful discussion of many previous versions of this paper. <p> Their criticism and illuminating comments helped us considerably in our attempt to faithfully model their basic intuitions of the Godel programming language. The work was started when the second author was visiting <ref> (March-June 1992) </ref> at the Computer Science Department, University of Bristol (UK); it has been partially supported by "Progetto Finalizzato Sistemi Informatici e Calcolo Parallelo" of CNR, under Grant n.90.00671.69.
Reference: 3. <author> Beierle, C. and Meyer, G. and Semle, H. </author> <year> (1991). </year> <title> Extending the Warren Abstract Machine to Polymorphic Order-Sorted Resolution. </title> <booktitle> Logic Programming: Proceedings of the 1991 International Symposium (eds. V.Saraswat, K.Ueda), </booktitle> <pages> pp. 272-288. </pages> <publisher> MIT Press. </publisher>
Reference: 4. <author> Blakley, B. </author> <year> (1992). </year> <title> A Smalltalk Evolving Algebra And Its Uses. </title> <type> Ph. D. Thesis, </type> <institution> University of Michigan. </institution>
Reference: 5. <author> Borger, E. </author> <year> (1990a). </year> <title> A Logical Operational Semantics for Full Prolog. Part I: Selection Core and Control. </title> <booktitle> CSL'89, 3rd Workshop on Computer Science Logic (eds. </booktitle> <editor> E. Borger, H.Kleine Buning, M.M.Richter), </editor> <publisher> Springer LNCS 440, </publisher> <pages> pp. 36-64. </pages>
Reference: 6. <author> Borger, E. </author> <year> (1990b). </year> <title> A Logical Operational Semantics for Full Prolog. Part II: Built-in Predicates for Database Manipulations. </title> <booktitle> Proc. of Mathematical Foundations of Computer Science (ed. </booktitle> <address> B.Rovan), </address> <publisher> Springer LNCS 452, </publisher> <pages> pp. 1-14. </pages> <note> Egon Borger and Elvinia Riccobene 23 </note>
Reference: 7. <author> Borger, E. </author> <year> (1992). </year> <title> A Logical Operational Semantics of Full Prolog: Part </title>
Reference-contexts: It happens when act becomes neg beg neg end (n) in call mode, for some node n. If mode = call & act = neg beg neg end (n) then mode (n):= abandoned To disable pruning inside a negated call <ref> (Hill and Lloyd 1992, p.77) </ref>, it suffices to refine the pruning update by putting it under the (easily formalizable) guard: If act is not in the scope of neg-brackets neg beg neg end (n) Then. 5.4 The computation of conditionals In (Hill and Lloyd 1992) two forms of conditionals IF Condition
Reference: 3. <editor> Built-in Predicates for Files, </editor> <title> Terms, Arithmetic and Input-Output. Logic from Computer Science (ed. </title> <publisher> Y.N.Moschovakis). MSRI Publications vol.21. Springer Verlag, </publisher> <pages> pp. 17-50. </pages>
Reference: 8. <author> Borger, E. and Lopez-Fraguas, F.J. and Rodr iguez-Artalejo, M. </author> <year> (1993). </year> <title> Towards a Mathematical Specification of a Graph-Narrowing Machine. </title> <type> Manuscript (submitted). </type>
Reference: 9. <author> Borger, E. and Riccobene, E. </author> <year> (1993). </year> <title> A formal specification of PARLOG. Semantics of Programming Languages and Model Theory (eds. </title> <journal> M.Droste & Y.Gurevich). </journal> <note> Gordon and Breach (to appear). </note>
Reference-contexts: The implementation just has to implement correctly the declarative meaning. However, these are the likely restrictions implementations will make in the near future. Cited from <ref> (Lloyd 1993) </ref> Egon Borger and Elvinia Riccobene 9 (and therefore of act). <p> Then G' correctly implements G under the strategy of depth-first search. Now to the question of what is needed to build a parallel implementation of the Godel language. The recent work of Glavan and Rosenzweig <ref> (1993) </ref> defines a notion of concurrent runs within the framework of evolving algebras, which is based upon a notion of independence of rules and runs. <p> This corresponds to what has been experienced by us in our formalization of the two forms of parallel logic programming represented by PARLOG <ref> (Borger and Riccobene 1993) </ref> and CONCURRENT PROLOG (Borger and Riccobene 1992). 7 Conclusion and Outlook The abstract interpreter for Godel programs which has been developed in this paper|refining the core for user-defined predicates by introducing stepwise delay, pruning, negation, conditionals and their implementation under the depth-first strategy|constitutes a mathematical object of
Reference: 10. <author> Borger, E. and Riccobene, E. </author> <year> (1992). </year> <title> A Mathematical Model of Concurrent Prolog. </title> <type> CSTR-92-15, </type> <institution> Dept. of Computer Science, University of Bristol. </institution>
Reference: 11. <author> Borger, E. and Rosenzweig, D. </author> <year> (1991a). </year> <title> Prolog Tree Algebras. A formal specification of Prolog. </title> <booktitle> Proceedings ITI'91 (13th International Conference on "Information Technology Interface), Zagreb, </booktitle> <pages> pp. 513-518. </pages>
Reference: 12. <author> Borger, E. and Rosenzweig, D. </author> <title> (1991b) From Prolog Algebras Towards WAM A Mathematical Study of Implementation. </title> <booktitle> Computer Science Logic (eds. </booktitle> <address> E.Borger, H.Kleine Buning, M.M.Richter, W.Schonfeld). </address> <publisher> Springer LNCS 533, </publisher> <pages> pp. 31-66. </pages>
Reference: 13. <author> Borger, E. and Rosenzweig, D. </author> <title> (1991c) WAM Algebras A Mathematical Study of Implementation. Part II. Logic Programming (ed. </title> <publisher> A.Voronkov). Springer LNCS 592, </publisher> <pages> pp. 35-54. </pages>
Reference: 14. <author> Borger, E. and Rosenzweig, D. </author> <year> (1993a). </year> <title> A Mathematical Definition of Full Prolog. </title> <note> Science of Computer Programming (to appear). Preliminary version: TR 33/92, </note> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <note> pp. 23. </note>
Reference: 15. <author> Borger, E. and Rosenzweig, D. </author> <year> (1993b). </year> <title> The WAM|Definition and Compiler Correctness. Logic Programming: Formal Methods and Practical Applications (eds. </title> <journal> C.Beierle & L.Plumer). Studies in Computer Science and Artificial Intelligence, </journal> <note> North-Holland (to appear). Preliminary version: TR 14/92, </note> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <note> pp. 57. </note>
Reference: 16. <author> Borger, E. and Schmitt, P. </author> <year> (1991). </year> <title> A formal operational semantics for languages of type Prolog III. </title> <booktitle> Computer Science Logic (eds. </booktitle> <address> E.Borger, H.Kleine Buning, M.Richter, W.Schonfeld). </address> <publisher> Springer LNCS 533, </publisher> <pages> pp. 67-79. </pages>
Reference: 17. <author> Glavan, P. and Rosenzweig, D. </author> <title> (1993) Communicating Evolving Algebras. Computer Science Logic (eds. </title> <editor> E. Borger, S. Martini, G.Jager, H.Kleine Buning, M. M. Richter). </editor> <publisher> Springer LNCS 702, </publisher> <pages> pp. 182-215. </pages>
Reference: 18. <author> Gottlob. G. and Kappell, G. and Schrefl, M. </author> <year> (1991). </year> <title> Semantics of Object-Oriented Data Models The Evolving Algebra Approach. Next 24 An abstract interpreter for Godel programs Generation Information System Technology (eds. </title> <editor> J. W. Schmidt & A. A. Stogny). </editor> <publisher> Springer LNCS 504, </publisher> <pages> pp. 144-160. </pages>
Reference: 19. <author> Gurevich, Y. </author> <year> (1988). </year> <title> Logic and the challenge of Computer Science. </title> <booktitle> Trends in Theoretical Computer Science (ed. </booktitle> <address> E.Borger). </address> <publisher> Computer Science Press, </publisher> <address> Rockville MA, </address> <pages> pp. 1-57. </pages>
Reference-contexts: Gurevich's concept of external functions (Gurevich 1991) in evolving algebras <ref> (Gurevich 1988) </ref> gave us the technical instrument to express in an ex Egon Borger and Elvinia Riccobene 3 plicit and transparent way the role of these three (pairwise orthogonal) non deterministic control components for the semantics of Godel (and in general logic) programs. <p> Our model comes in the form of evolving algebras. This concept has been introduced by Gurevich <ref> (1988) </ref> and has since then been applied successfully for the specification of languages covering all the major programming paradigms; see (Gurevich and Morris 1988; Borger 1990a,b,1992; Gurevich and Moss 1990; Borger and Schmitt 1991; Gurevich and Huggins 1993; Borger and Rosenzweig 1993a; Beierle and Borger 1992; Borger and Ric-cobene 1993; Borger <p> meaning that U ( ~ j) is executed for all values of parameters (which satisfy guard ( ~ j)). (Typically j will be used to range over nodes on a segment of a path in a tree.) Note that such updates are not considered in the original definition given by <ref> (Gurevich 1988) </ref>.
Reference: 20. <author> Gurevich, Y. </author> <year> (1991). </year> <title> Evolving Algebras. A Tutorial Introduction. </title> <journal> EATCS Bulletin, </journal> <volume> 43, </volume> <month> February </month> <year> 1991. </year>
Reference: 21. <author> Gurevich, Y. and Huggins, J.K. </author> <year> (1993). </year> <title> The Semantics of the C Programming Language. </title> <booktitle> Computer Science Logic (eds. </booktitle> <address> E.+Borger, S.Martini, G.Jager, H.Kleine Buning, M.M.Richter). </address> <publisher> Springer LNCS 702, </publisher> <pages> pp. 274-308. </pages>
Reference: 22. <author> Gurevich, Y. and Morris, J. </author> <year> (1988). </year> <title> Algebraic operational semantics and Modula-2. </title> <booktitle> CSL'87, 1st Workshop on Computer Science Logic (eds. </booktitle> <address> E.Borger, H.Kleine Buning, M.M.Richter). </address> <publisher> Springer LNCS 329, </publisher> <pages> pp. 81-101. </pages>
Reference: 23. <author> Gurevich, Y. and Moss, L. </author> <year> (1990). </year> <title> Algebraic Operational Semantics and Occam. </title> <booktitle> CSL'89, 3d Workshop on Computer Science Logic (eds. </booktitle> <address> E.Borger, H.Kleine Buning, M.M.Richter). </address> <publisher> Springer LNCS 440, </publisher> <pages> pp. 176-192. </pages>
Reference: 24. <author> Hill, P.M. and Lloyd, J.W. </author> <title> (October 1992) The Godel Programming Language. </title> <institution> CSTR-92-27, University of Bristol. </institution>
Reference: 25. <author> Hill, P.M. and Lloyd, J.W. and Shepherdson, J.C. </author> <year> (1990). </year> <title> Properties of a pruning operator. </title> <journal> Journal of Logic Programming, vol.1 - n.1, </journal> <pages> pp. 99-143. </pages>
Reference: 26. <author> Lloyd, J.W. </author> <year> (1987). </year> <booktitle> Foundations of Logic Programming (2nd edn). </booktitle> <publisher> Springer Verlag. </publisher>
Reference: 27. <author> Lloyd, J.W. </author> <year> (1992). </year> <type> Private communication, </type> <institution> e-mail of 3-Nov-1992. </institution>
Reference: 28. <author> Lloyd, J.W. </author> <year> (1993). </year> <type> Private communication, </type> <institution> e-mail of 5-April-1993. </institution>
References-found: 29

