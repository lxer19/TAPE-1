URL: ftp://ftp.cs.virginia.edu/pub/isotach/ieee97.ps
Refering-URL: http://www.cs.virginia.edu/~isotach/pubs.html
Root-URL: http://www.cs.virginia.edu
Title: Isotach Networks  
Author: Paul F. Reynolds, Jr. Craig Williams Raymond R. Wagner, Jr. 
Abstract: We introduce a class of networks called isotach networks designed to reduce the cost of synchronization in parallel computations. Isotach networks maintain an invariant that allows each process to control the logical times at which its messages are received and consequently executed. This control allows processes to pipeline operations without sacrificing sequential consistency and to send isochrons, groups of operations that appear to be received and executed as an indivisible unit. Isochrons allow processes to execute atomic actions without locks. Other uses of isotach networks include ensuring causal message delivery and consistency among replicated data. Isotach networks are characterized by this invariant, not by their topology. They can be implemented in a wide variety of configurations, including NUMA (non-uniform memory access) multiprocessors. Empirical and analytic studies of isotach synchronization techniques show that they outperform conventional techniques, in some cases by an order of magnitude or more. Results presented here assume fault-free systems; we are exploring extension to selected failure models. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Amir, L. E. Moser, P. M. Melliar-Smith, D. A. Agarwal and P. Ciarfella, </author> <title> ``The Totem Single-Ring Ordering and Membership Protocol'', </title> <journal> ACM Transactions on Computer Systems 13, </journal> <month> 4 (November </month> <year> 1995), </year> <pages> 311-342. </pages>
Reference-contexts: Existing TOM algorithms introduce some element to obtain the total ordering that makes them unsuitable for use in SMM computations. Most use a serialization point, either in the network itself or in a communication pattern superimposed on the computation, e.g., <ref> [1, 11, 20] </ref>, to order multicasts. These algorithms scale poorly. Multicasts for hierarchically structured networks or for applications with a hierarchical communication pattern scale more successfully, but still have a potential bottleneck at the root.
Reference: [2] <author> T. E. Anderson, </author> <title> ``The Performance of Spin Lock Alternatives for Shared-Memory Multiprocessors'', </title> <journal> IEEE Transactions on Parallel and Distributed Systems 1, </journal> <month> 1 (January </month> <year> 1990), </year> <pages> 6-16. </pages>
Reference-contexts: These studies compared iso-tach systems to conventional systems that enforce sequential consistency by restricting pipelin-ing and enforce atomicity by locking the variables accessed in each atomic action. Improving 21 the performance of locking in shared memory systems has been the subject of several studies in recent years (e.g. <ref> [2] </ref>, [29], [30]). Although we did not implement caches, and thus could not implement cache-based locks, we implemented a highly efficient locking protocol, described below, that avoids spinning on locks in an alternative way.
Reference: [3] <author> B. Awerbuch, </author> <title> ``Complexity of Network Synchronization'', </title> <journal> J. ACM 32, </journal> <month> 4 (October </month> <year> 1985), </year> <pages> 804-823. </pages>
Reference-contexts: Several networks have been proposed that can, in retrospect, be classified as isotach networks. The alpha-synchronizer network proposed by Awer-buch to execute SIMD graph algorithms on asynchronous networks <ref> [3] </ref> and a network proposed to support barrier synchronization [5, 17] can be viewed as isotach networks that maintain a logical time system in which each logical time consists of the pulse component only.
Reference: [4] <author> H. E. Bal and A. S. Tanenbaum, </author> <title> ``Distributed Programming with Shared Data'', </title> <booktitle> Proc. of the IEEE CS 1988 Int. Conf. on Computer Languages, </booktitle> <address> Miami, Florida, </address> <month> October 9-13, </month> <year> 1988, </year> <pages> 82-91. </pages>
Reference-contexts: Isochrons and Totally Ordered Multicasts. Algorithms for totally ordered multicasts (TOMs) ensure total ordering without the benefit of the assumption of fault-freedom. TOMs have been used to maintain consistency among replicated copies of objects in distributed systems, e.g., <ref> [4] </ref>, and could theoretically be used to execute flat atomic actions in SMM computations on multiprocessors, and as a basis for techniques to execute structured atomic actions, but we are not aware of any proposals to use TOMs in this way.
Reference: [5] <author> Y. Birk, P. B. Gibbons, J. L. C. Sanz and D. Soroker, </author> <title> ``A Simple Mechanism for Efficient Barrier Synchronization in MIMD Machines'', </title> <type> Tech. Rep. RJ 7078, </type> <institution> IBM, </institution> <month> October </month> <year> 1989. </year>
Reference-contexts: Several networks have been proposed that can, in retrospect, be classified as isotach networks. The alpha-synchronizer network proposed by Awer-buch to execute SIMD graph algorithms on asynchronous networks [3] and a network proposed to support barrier synchronization <ref> [5, 17] </ref> can be viewed as isotach networks that maintain a logical time system in which each logical time consists of the pulse component only.
Reference: [6] <author> K. P. Birman and T. A. Joseph, </author> <title> ``Reliable Communication in the Presence of Failures'', </title> <journal> ACM Trans. Computer Systems 5, </journal> <volume> 1 (February, </volume> <year> 1987), </year> <pages> 47-76. </pages>
Reference-contexts: Even if we leave out the fault-tolerant aspects, concentrating only on those aspects of TOM implementations designed to ensure that multicasts are received in a consistent order, we find existing TOM implementations are not scalable or are unsuitable for SMM computations for other reasons. Several messaging layers, e.g., <ref> [6, 7, 34] </ref>, use a logical time system in obtaining an ordering property among multicasts called causal ordering, but the logical time systems these messaging layers use does not offer an efficient scalable way to obtain total ordering. <p> These algorithms scale poorly. Multicasts for hierarchically structured networks or for applications with a hierarchical communication pattern scale more successfully, but still have a potential bottleneck at the root. The few TOM algorithms that do not use a centralized serialization point <ref> [6, 13, 14, 18] </ref>, are based on worst case assumptions or require multiple 18 message rounds. Many TOM implementations, e.g., [7, 15, 34], are group based.
Reference: [7] <author> K. P. Birman, A. Schiper and P. Stephenson, </author> <title> ``Lightweight Causal and Atomic Group Multicast'', </title> <journal> ACM TOCS, </journal> <month> August </month> <year> 1991, </year> <pages> 272-314. </pages>
Reference-contexts: Logical time systems have been proposed that extend Lamport's system by adding the constraint t (a) &lt; t (b) fi a fi b. For a recent survey see [37]. ISIS <ref> [7] </ref> is a messaging layer that incorporates this extension to Lamport's logical time system. Isotach logical time also extends Lamport's time system, but in a different way. <p> Even if we leave out the fault-tolerant aspects, concentrating only on those aspects of TOM implementations designed to ensure that multicasts are received in a consistent order, we find existing TOM implementations are not scalable or are unsuitable for SMM computations for other reasons. Several messaging layers, e.g., <ref> [6, 7, 34] </ref>, use a logical time system in obtaining an ordering property among multicasts called causal ordering, but the logical time systems these messaging layers use does not offer an efficient scalable way to obtain total ordering. <p> The few TOM algorithms that do not use a centralized serialization point [6, 13, 14, 18], are based on worst case assumptions or require multiple 18 message rounds. Many TOM implementations, e.g., <ref> [7, 15, 34] </ref>, are group based. They send each multicast to the full membership of a process group and use the fact that every process sees every message sent to its group in obtaining the total ordering.
Reference: [8] <author> K. Birman, </author> <title> ``A Response to Cheriton and Skeen's Criticism of Causal and Totally Ordered Communication'', OS Review 28, </title> <month> 1 (January </month> <year> 1994), </year> <pages> 11-21. </pages>
Reference: [9] <author> N. J. Boden, D. Cohen, R. E. Felderman, A. E. Kulawik, C. L. Seitz, J. N. Seizovic and W. Su, </author> <title> ``Myrinet A Gigabit-per-Second Local-Area Network'', </title> <booktitle> IEEE Micro 15, </booktitle> <month> 1 (February </month> <year> 1995), </year> <pages> 29-36. </pages>
Reference-contexts: Our target platform for the prototype is a non-equidistant cluster of personal computers (PC's) interconnected with Myrinet <ref> [9] </ref>. 30
Reference: [10] <author> K. Chandy and J. Misra, </author> <title> ``Distributed Simulation: A Case Study in Design and Verification of Distributed Programs'', </title> <journal> IEEE TRANS on Software Engineering 5, </journal> <month> 5 (September </month> <year> 1979), </year> <pages> 440-452. </pages>
Reference-contexts: The principal cost of the isonet algorithm is the additional waiting implied by the requirement that messages be routed in pid-rank order. One way to reduce this cost is to use ghosts. When a switch sends an operation on one output it sends a ghost [36] or null message <ref> [10] </ref> with the same pid-rank tag on each of its other output (s).
Reference: [11] <author> J. Chang and N. F. Maxemchuk, </author> <title> ``Reliable Broadcast Protocols'', </title> <journal> ACM Trans. Computer Systems 2, </journal> <month> 3 (August </month> <year> 1984), </year> <pages> 251-273. </pages>
Reference-contexts: Existing TOM algorithms introduce some element to obtain the total ordering that makes them unsuitable for use in SMM computations. Most use a serialization point, either in the network itself or in a communication pattern superimposed on the computation, e.g., <ref> [1, 11, 20] </ref>, to order multicasts. These algorithms scale poorly. Multicasts for hierarchically structured networks or for applications with a hierarchical communication pattern scale more successfully, but still have a potential bottleneck at the root.
Reference: [12] <author> D. R. Cheriton and D. Skeen, </author> <title> ``Understanding the Limitations of Causally and Totally Ordered Communication'', OS Review, </title> <booktitle> 14th ACM Symp. on OS Principles, </booktitle> <month> December </month> <year> 1993, </year> <pages> 44-57. </pages>
Reference: [13] <author> F. Cristian, </author> <title> ``Synchronous Atomic Broadcast for Redundant Broadcast Channels'', </title> <type> Tech. Rep. RJ 7203 (67682), </type> <institution> IBM, </institution> <month> December, </month> <year> 1989. </year>
Reference-contexts: These algorithms scale poorly. Multicasts for hierarchically structured networks or for applications with a hierarchical communication pattern scale more successfully, but still have a potential bottleneck at the root. The few TOM algorithms that do not use a centralized serialization point <ref> [6, 13, 14, 18] </ref>, are based on worst case assumptions or require multiple 18 message rounds. Many TOM implementations, e.g., [7, 15, 34], are group based.
Reference: [14] <author> M. Dasser, ``TOMP: </author> <title> A Total Ordering Multicast Protocol'', </title> <booktitle> Operating Systems Review 26, </booktitle> <month> 1 (January </month> <year> 1992). </year>
Reference-contexts: These algorithms scale poorly. Multicasts for hierarchically structured networks or for applications with a hierarchical communication pattern scale more successfully, but still have a potential bottleneck at the root. The few TOM algorithms that do not use a centralized serialization point <ref> [6, 13, 14, 18] </ref>, are based on worst case assumptions or require multiple 18 message rounds. Many TOM implementations, e.g., [7, 15, 34], are group based.
Reference: [15] <author> H. Garcia-Molina and A. Spauster, </author> <title> ``Ordered and Reliable Multicast Communication'', </title> <type> TOCS 9, </type> <month> 3 (August </month> <year> 1991), </year> <pages> 242-271. </pages>
Reference-contexts: The few TOM algorithms that do not use a centralized serialization point [6, 13, 14, 18], are based on worst case assumptions or require multiple 18 message rounds. Many TOM implementations, e.g., <ref> [7, 15, 34] </ref>, are group based. They send each multicast to the full membership of a process group and use the fact that every process sees every message sent to its group in obtaining the total ordering.
Reference: [16] <author> K. Gharachorloo, et al., </author> <title> ``Performance Evaluation of Memory Consistency Models for Shared-Memory Multiprocessors'', </title> <booktitle> 4th ASPLOS, </booktitle> <month> April, </month> <year> 1991, </year> <pages> 245-257. </pages>
Reference-contexts: However pipelining is an important way to decrease effective memory latency, so this solution is expensive. The high cost of enforcing sequential consistency has led to extensive exploration of weaker memory consistency models, e.g., <ref> [16, 43] </ref>. These weaker models are harder to reason about and still impose significant restrictions on pipelining, but make sense given the cost of maintaining sequential consistency in a conventional system. In an isotach sys 13 tem, processes can pipeline memory operations without violating sequential consistency. 3.2.
Reference: [17] <author> P. B. Gibbons, </author> <title> ``The Asynchronous PRAM: A Semi-Synchronous Model for Shared Memory MIMD Machines'', </title> <type> 89-062, ICSI, </type> <institution> Berkeley, California, </institution> <month> December, </month> <year> 1989. </year> <month> 31 </month>
Reference-contexts: Several networks have been proposed that can, in retrospect, be classified as isotach networks. The alpha-synchronizer network proposed by Awer-buch to execute SIMD graph algorithms on asynchronous networks [3] and a network proposed to support barrier synchronization <ref> [5, 17] </ref> can be viewed as isotach networks that maintain a logical time system in which each logical time consists of the pulse component only.
Reference: [18] <author> K. J. Goldman, </author> <title> ``Highly Concurrent Logically Synchronous Multicast'', in Distributed Computing, </title> <publisher> Springer-Verlag, </publisher> <address> Berlin-Heidelburg-New York, </address> <year> 1989, </year> <pages> 94-108. </pages>
Reference-contexts: These algorithms scale poorly. Multicasts for hierarchically structured networks or for applications with a hierarchical communication pattern scale more successfully, but still have a potential bottleneck at the root. The few TOM algorithms that do not use a centralized serialization point <ref> [6, 13, 14, 18] </ref>, are based on worst case assumptions or require multiple 18 message rounds. Many TOM implementations, e.g., [7, 15, 34], are group based.
Reference: [19] <author> Y. Jenq, </author> <title> ``Performance Analysis of a Packet Switch Based on Single-Buffered Banyan Network'', </title> <journal> IEEE Journal on Selected Areas in Communications 1, </journal> <month> 6 (December </month> <year> 1983), </year> <pages> 1014-1021. </pages>
Reference-contexts: That work led to the discovery of novel modeling methods that will be presented in a future paper. We outline the approach and results we obtained here. A detailed presentation appears in [46] We extended a mean value analysis technique first presented by Jenq <ref> [19] </ref> for banyan-like MINs. Our extensions enabled the modeling of 1) routing dependencies, 2) a measure of bandwidth we have called information flow, and 3) message types.
Reference: [20] <author> M. F. Kaashoek, A. S. Tanenbaum, S. F. Hummell and H. E. Bal, </author> <title> ``An Efficient Reliable Broadcast Protocol'', </title> <booktitle> Operating Systems Review 23, </booktitle> <month> 4 (October </month> <year> 1989), </year> <pages> 5-19. </pages>
Reference-contexts: Existing TOM algorithms introduce some element to obtain the total ordering that makes them unsuitable for use in SMM computations. Most use a serialization point, either in the network itself or in a communication pattern superimposed on the computation, e.g., <ref> [1, 11, 20] </ref>, to order multicasts. These algorithms scale poorly. Multicasts for hierarchically structured networks or for applications with a hierarchical communication pattern scale more successfully, but still have a potential bottleneck at the root.
Reference: [21] <author> M. J. Karol, M. G. Hluchyj and S. P. Morgan, </author> <title> ``Input Versus Output Queueing on a Space-Division Packet Switch'', </title> <journal> IEEE Transactions on Communications 35, </journal> <month> 12 (December </month> <year> 1987), </year> <pages> 1347-1356. </pages>
Reference-contexts: Switch Designs. (a) Simple switch. (b) Switch with internal buffers. 9 input queue blocks subsequent messages arriving on the same input, a phenomenon known as head of line (HOL) blocking. Buffers placed internally, as shown in Fig. 3 (b), reduce HOL blocking <ref> [21, 24] </ref>. Our simulation study of isotach networks shows that internal buffers are of significantly more benefit in isotach networks than in conventional networks.
Reference: [22] <author> D. E. Knuth, </author> <title> in Fundamental Algorithms, vol. 3, Sorting and Searching , Addison-Wesley, </title> <booktitle> 1973, </booktitle> <pages> 397. </pages>
Reference-contexts: A warm-spot model has several warm variables instead of a single hot variable and is more realistic than either the uniform or hot-spot traffic models. The warm-traffic model we used was based on the standard 80/20 rule (see e.g. <ref> [22] </ref>), modified to lessen contention for the warmest variables [40]. Atomic actions were assumed to be flat and independent, i.e., there were no data dependences among or within atomic actions. I1 and I2 enforced atomicity by issuing all operations from the same atomic action in the same pulse.
Reference: [23] <author> C. P. Kruskal, L. Rudolph and M. Snir, </author> <title> ``Efficient Synchronization on Multiprocessors with Shared Memory'', </title> <journal> ACM Trans. Prog. Lang. and Systems 10, </journal> <month> 4 (October </month> <year> 1988), </year> <pages> 579-601. </pages>
Reference-contexts: processes to pipeline memory accesses without sacrificing sequential consistency, and allow processes to read and write multiple shared cache blocks atomically without obtaining exclusive rights to the accessed blocks. g Combining Combining is a technique for maintaining good performance in the presence of multiple concurrent accesses to the same variable <ref> [23] </ref>.
Reference: [24] <author> M. Kumar and J. R. </author> <title> Jump, ``Performance Enhancement of Buffered Delta Networks Using Crossbar Switches and Multiple Links'', </title> <journal> Journal of Parallel and Distributed Computing 1 (1984), </journal> <pages> 81-103. </pages>
Reference-contexts: Switch Designs. (a) Simple switch. (b) Switch with internal buffers. 9 input queue blocks subsequent messages arriving on the same input, a phenomenon known as head of line (HOL) blocking. Buffers placed internally, as shown in Fig. 3 (b), reduce HOL blocking <ref> [21, 24] </ref>. Our simulation study of isotach networks shows that internal buffers are of significantly more benefit in isotach networks than in conventional networks.
Reference: [25] <author> L. Lamport, </author> <title> ``Time, Clocks, and the Ordering of Events in a Distributed System'', </title> <journal> Comm. ACM 21, </journal> <month> 7 (July </month> <year> 1978), </year> <pages> 558-565. </pages>
Reference-contexts: Isotach logical time is an extension of the logical time system defined by Lamport in his classic paper on ordering events in distributed systems <ref> [25] </ref>. We begin by describing Lamport's system. We then define isotach logical time and give an algorithm for implementing isotach logical time using network switches and interfaces. In Lamport's system, the events of interest are the sending and receiving of messages. <p> Since each variable is accessed by the same operations in the same order in both executions, the executions are equivalent. In discussing a similar pair of diagrams, Lamport provides an alternative way to view the equivalence among the executions in the figure <ref> [25] </ref>: Without introducing the concept of time into the system (which would require introducing physical clocks), there is no way to decide which of these pictures is the better representation.
Reference: [26] <author> L. Lamport, </author> <title> ``How to Make a Multiprocessor Computer That Correctly Executes Multiprocessor Programs'', </title> <journal> IEEE Trans. on Computers 28 (1979), </journal> <pages> 690-691. </pages>
Reference-contexts: An execution is sequentially consistent if operations specified by the program to be executed in a specific order appear to be executed in the order specified <ref> [26] </ref> and is isochronous if operations specified by the program to be executed at the same time appear to be executed at the same time. <p> A violation of sequential consistency. order specified by each individual process's sequential program <ref> [26] </ref>. This property is so basic it is easily taken for granted, but it is expensive to enforce in non-bus-based systems because stochastic delays within the network can reorder operations. A violation of sequential consistency is shown in Fig. 4.
Reference: [27] <author> L. Lamport, </author> <title> ``On Interprocess Communication'', </title> <booktitle> Distributed Computing 1, </booktitle> <month> 2 (April </month> <year> 1986), </year> <pages> 77-101. </pages>
Reference-contexts: Isochrons and atomic actions differ in two ways: g An atomic action, in many contexts, is a unit of recovery from hardware failure. Where a fault-free system is assumed or fault-freedom is not a major concern, atomicity is synonymous with indivisible execution <ref> [27, 32] </ref>. As stated previously, we assume a fault-free system. 11 g An atomic action can have internal dependences preventing the operations in the atomic action from being issued as a batch. An atomic action with such dependences, e.g., A = B, is a structured atomic action.
Reference: [28] <author> D. B. Lomet, </author> <title> ``Process Structuring, Synchronization, and Recovery Using Atomic Actions'', </title> <journal> SIGPLAN Notices 12, </journal> <month> 3 (March </month> <year> 1977), </year> <pages> 128-137. </pages>
Reference-contexts: An execution is isochronous if every isochron appears to be executed indivisibly. Isochrons and isochronicity are closely related to atomic actions and atomicity. An atomic action is a group of operations that is to be executed indivisibly <ref> [28, 31] </ref>. An execution is atomic if the operations in each atomic action appear to be executed indivisibly. Isochrons and atomic actions differ in two ways: g An atomic action, in many contexts, is a unit of recovery from hardware failure.
Reference: [29] <author> J. M. Mellor-Crummey and M. L. Scott, </author> <title> ``Algorithms for Scalable Synchronization on Shared-Memory Multiprocessors'', </title> <journal> ACM Transactions on Computer Systems 9, </journal> <month> 1 (February </month> <year> 1991), </year> <pages> 21-65. </pages>
Reference-contexts: These studies compared iso-tach systems to conventional systems that enforce sequential consistency by restricting pipelin-ing and enforce atomicity by locking the variables accessed in each atomic action. Improving 21 the performance of locking in shared memory systems has been the subject of several studies in recent years (e.g. [2], <ref> [29] </ref>, [30]). Although we did not implement caches, and thus could not implement cache-based locks, we implemented a highly efficient locking protocol, described below, that avoids spinning on locks in an alternative way.
Reference: [30] <author> M. M. Michael and M. L. Scott, </author> <title> ``Scalability of Atomic Primitives on Distributed Shared Memory Multprocessors'', </title> <type> Tech. Rep. 528, </type> <institution> University of Rochester Computer Science Department, </institution> <month> July </month> <year> 1994. </year>
Reference-contexts: Improving 21 the performance of locking in shared memory systems has been the subject of several studies in recent years (e.g. [2], [29], <ref> [30] </ref>). Although we did not implement caches, and thus could not implement cache-based locks, we implemented a highly efficient locking protocol, described below, that avoids spinning on locks in an alternative way.
Reference: [31] <author> S. Owicki and D. Gries, </author> <title> ``An Axiomatic Proof Technique for Parallel Programs I'', </title> <journal> Acta Informatica 6 (1976), </journal> <pages> 319-340. </pages>
Reference-contexts: An execution is isochronous if every isochron appears to be executed indivisibly. Isochrons and isochronicity are closely related to atomic actions and atomicity. An atomic action is a group of operations that is to be executed indivisibly <ref> [28, 31] </ref>. An execution is atomic if the operations in each atomic action appear to be executed indivisibly. Isochrons and atomic actions differ in two ways: g An atomic action, in many contexts, is a unit of recovery from hardware failure.
Reference: [32] <author> S. Owicki and L. Lamport, </author> <title> ``Proving Liveness Properties of Concurrent Programs'', </title> <journal> ACM Trans. Prog. Lang. and Systems 4, </journal> <month> 3 (July </month> <year> 1982), </year> <pages> 455-495. </pages>
Reference-contexts: Isochrons and atomic actions differ in two ways: g An atomic action, in many contexts, is a unit of recovery from hardware failure. Where a fault-free system is assumed or fault-freedom is not a major concern, atomicity is synonymous with indivisible execution <ref> [27, 32] </ref>. As stated previously, we assume a fault-free system. 11 g An atomic action can have internal dependences preventing the operations in the atomic action from being issued as a batch. An atomic action with such dependences, e.g., A = B, is a structured atomic action.
Reference: [33] <author> C. Papadimitriou, </author> <title> Database Concurrency Control, </title> <publisher> Computer Science Press, </publisher> <year> 1986. </year>
Reference-contexts: As a result, each isochron will appear to be executed without interleaving with other operations. The correctness proof for the send order rules is similar to serializability proofs of database schedulers, see e.g. <ref> [33] </ref>. We show that for any execution on an isotach system that conforms to the send order rules, there is an equivalent serial execution that is isochronous and sequentially consistent.
Reference: [34] <author> L. L. Peterson, N. C. Bucholz and R. D. Schlichting, </author> <title> ``Preserving and Using Context Information in Interprocess Communication'', </title> <journal> ACM Trans. Computer Systems 7, </journal> <month> 3 (August </month> <year> 1989), </year> <pages> 217-246. </pages>
Reference-contexts: Even if we leave out the fault-tolerant aspects, concentrating only on those aspects of TOM implementations designed to ensure that multicasts are received in a consistent order, we find existing TOM implementations are not scalable or are unsuitable for SMM computations for other reasons. Several messaging layers, e.g., <ref> [6, 7, 34] </ref>, use a logical time system in obtaining an ordering property among multicasts called causal ordering, but the logical time systems these messaging layers use does not offer an efficient scalable way to obtain total ordering. <p> The few TOM algorithms that do not use a centralized serialization point [6, 13, 14, 18], are based on worst case assumptions or require multiple 18 message rounds. Many TOM implementations, e.g., <ref> [7, 15, 34] </ref>, are group based. They send each multicast to the full membership of a process group and use the fact that every process sees every message sent to its group in obtaining the total ordering.
Reference: [35] <author> A. G. Ranade, S. N. Bhatt and S. L. Johnsson, </author> <title> ``The Fluent Abstract Machine'', </title> <type> Tech. Rep. 573, </type> <institution> Yale University, Dept. of Computer Science, </institution> <month> January, </month> <year> 1988. </year> <month> 32 </month>
Reference-contexts: A network proposed by Ranade <ref> [35, 36] </ref> as the basis for an efficient concurrent-read, concurrent-write (CRCW) PRAM emulation can be viewed as realizing the more general and powerful n-tuple isotach logical time system. We give an algorithm, the isonet algorithm, for implementing iso-tach logical time on networks of arbitrary topology.
Reference: [36] <author> A. Ranade and A. G. Ranade, </author> <title> ``How to Emulate Shared Memory'', </title> <booktitle> IEEE Annual Symp. on Foundations of Computer Science, </booktitle> <address> Los Angeles, </address> <year> 1987, </year> <pages> 185-194. </pages>
Reference-contexts: A network proposed by Ranade <ref> [35, 36] </ref> as the basis for an efficient concurrent-read, concurrent-write (CRCW) PRAM emulation can be viewed as realizing the more general and powerful n-tuple isotach logical time system. We give an algorithm, the isonet algorithm, for implementing iso-tach logical time on networks of arbitrary topology. <p> Latency and Throughput. The principal cost of the isonet algorithm is the additional waiting implied by the requirement that messages be routed in pid-rank order. One way to reduce this cost is to use ghosts. When a switch sends an operation on one output it sends a ghost <ref> [36] </ref> or null message [10] with the same pid-rank tag on each of its other output (s).
Reference: [37] <author> M. Raynal and M. Singhal, </author> <title> ``Logical Time: Capturing Causality in Distributed Systems'', </title> <booktitle> Computer 29, </booktitle> <month> 2 (February </month> <year> 1996), </year> <pages> 49-56. </pages>
Reference-contexts: Logical time systems have been proposed that extend Lamport's system by adding the constraint t (a) &lt; t (b) fi a fi b. For a recent survey see <ref> [37] </ref>. ISIS [7] is a messaging layer that incorporates this extension to Lamport's logical time system. Isotach logical time also extends Lamport's time system, but in a different way.
Reference: [38] <author> D. Reed, </author> <title> ``Implementing Atomic Actions on Decentralized Data'', </title> <journal> ACM Trans. Computer Systems 1, </journal> <volume> 1 (February, </volume> <year> 1983), </year> <pages> 3-23. </pages>
Reference-contexts: We have proposed variations on the technique for atomic actions with data dependent access sets [48]. Isotach techniques for executing structured atomic actions are similar to techniques used in multiversion concurrency control <ref> [38] </ref> except that isochrons streamline these techniques, eliminating roll-back and permitting an efficient in-cache implementation of variable histories. The resulting techniques are sufficiently lightweight that they can be used in SMM computations. g Cache Coherence Isotach based techniques for enforcing atomicity and sequential consistency extend to systems with caches.
Reference: [39] <author> R. Renesse, </author> <title> ``Why Bother With CATOCS?'', OS Review 28, </title> <month> 1 (January </month> <year> 1994), </year> <pages> 22-27. </pages>
Reference: [40] <author> P. F. Reynolds, Jr., C. Williams and R. R. Wagner, Jr., </author> <title> ``Empirical Analysis of Isotach Networks'', </title> <type> Tech. Rep. 92-19, </type> <institution> University of Virginia, Dept. of Computer Science, </institution> <month> June, </month> <year> 1992. </year>
Reference-contexts: Important special applications include parallel and distributed databases and production systems [41, 48]. 4. PERFORMANCE We studied the performance of equidistant isotach networks using both simulation <ref> [40] </ref> and analytic modeling [46]. The following is a synopsis; the interested reader is referred to the noted references for more details. 4.1. <p> A warm-spot model has several warm variables instead of a single hot variable and is more realistic than either the uniform or hot-spot traffic models. The warm-traffic model we used was based on the standard 80/20 rule (see e.g. [22]), modified to lessen contention for the warmest variables <ref> [40] </ref>. Atomic actions were assumed to be flat and independent, i.e., there were no data dependences among or within atomic actions. I1 and I2 enforced atomicity by issuing all operations from the same atomic action in the same pulse.
Reference: [41] <author> P. F. Reynolds, Jr. and C. Williams, </author> <title> ``Asynchronous Rule-Based Systems in CGF'', </title> <booktitle> 5th Conference on Computer Generated Forces and Behavioral Representation, </booktitle> <address> Orlando, FL, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: Important special applications include parallel and distributed databases and production systems <ref> [41, 48] </ref>. 4. PERFORMANCE We studied the performance of equidistant isotach networks using both simulation [40] and analytic modeling [46]. The following is a synopsis; the interested reader is referred to the noted references for more details. 4.1.
Reference: [42] <author> J. H. Saltzer, D. P. Reed and D. D. Clark, </author> <title> ``End-To-End Arguments in System Design'', </title> <journal> ACM TOCS 2, </journal> <month> 4 (November </month> <year> 1984), </year> <pages> 277-288. </pages>
Reference-contexts: We defined a new class of networks called isotach networks that implement isotach logical time. Implementing isotach logical time, of course, is not free and we are well aware of controversy ([8, 12, 39]) over implementing synchronization services at a low level in end-to-end systems <ref> [42] </ref>. Isotach networks are justifiable on a cost/benefit basis the guarantees they offer can be implemented cheaply, yet are sufficiently powerful to enforce fundamental synchronization properties. We reported the results of analytic and empirical studies that show that isotach synchronization techniques are far more efficient than conventional techniques. On-going work.
Reference: [43] <author> C. Scheurich and M. Dubois, </author> <title> ``Correct Memory Operation of Cache-Based Multiprocessors'', </title> <booktitle> Proc. 14th ISCA, </booktitle> <month> June </month> <year> 1987, </year> <pages> 234-243. </pages>
Reference-contexts: However pipelining is an important way to decrease effective memory latency, so this solution is expensive. The high cost of enforcing sequential consistency has led to extensive exploration of weaker memory consistency models, e.g., <ref> [16, 43] </ref>. These weaker models are harder to reason about and still impose significant restrictions on pipelining, but make sense given the cost of maintaining sequential consistency in a conventional system. In an isotach sys 13 tem, processes can pipeline memory operations without violating sequential consistency. 3.2.
Reference: [44] <author> B. R. Supinski, C. Williams and P. F. Reynolds, Jr., </author> <title> ``Performance Evaluation of the Late Delta Cache Coherence Protocol'', </title> <type> Tech. Rep. </type> <institution> CS-96-05, University of Virginia, Dept. of Computer Science, </institution> <month> March 13, </month> <year> 1996. </year>
Reference-contexts: The resulting techniques are sufficiently lightweight that they can be used in SMM computations. g Cache Coherence Isotach based techniques for enforcing atomicity and sequential consistency extend to systems with caches. The resulting cache coherence protocols <ref> [44, 47, 48] </ref> are more concurrent than existing protocols for non-bus-based systems in that they support multiple concurrent reads and writes of the same block, allow processes to pipeline memory accesses without sacrificing sequential consistency, and allow processes to read and write multiple shared cache blocks atomically without obtaining exclusive rights
Reference: [45] <author> K. Verstoep, K. Langendoen and H. E. Bal, </author> <title> ``Efficient Reliable Multicast on Myrinet'', </title> <type> Tech. </type> <institution> Rep.-IR-399, Vrije Universiteit, </institution> <address> Amsterdam, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Preliminary explorations show that isotach networks can function under a number of different failure models. One result for fail-stop models appears in [46]. Our approach to ensuring a reliable implementation of the isochron on the prototype system will be similar to the approach reported in <ref> [45] </ref>, except that we intend to use a distributed protocol in place of a centralized credit manager for flow control.
Reference: [46] <author> R. R. Wagner, Jr., </author> <title> ``On the Implementation of Local Synchrony'', </title> <institution> CS-93-33, University of Virginia, Dept. of Computer Science, </institution> <month> June 1, </month> <year> 1993. </year>
Reference-contexts: We have proven deadlock free routing schemes for equidistant networks using one buffer per switch per physical channel and for arbitrary topologies using O (d) buffers and virtual channels per switch per physical channel, where d is the network diameter <ref> [46] </ref>. The isonet algorithm, as modified, is scalable and efficient: it is completely distributed; the bandwidth attributable to maintaining isotach logical time is one bit per message; and the addi 10 tional work required at each SIU and switch is one tag comparison per message. <p> Important special applications include parallel and distributed databases and production systems [41, 48]. 4. PERFORMANCE We studied the performance of equidistant isotach networks using both simulation [40] and analytic modeling <ref> [46] </ref>. The following is a synopsis; the interested reader is referred to the noted references for more details. 4.1. Simulation Studies Isotach networks do more work than conventional networks they route messages and deliver them in an order consistent with the isotach invariant and the fi relation. <p> Analytic Model Analytic models were developed for networks C1, C2, I1 and I2. That work led to the discovery of novel modeling methods that will be presented in a future paper. We outline the approach and results we obtained here. A detailed presentation appears in <ref> [46] </ref> We extended a mean value analysis technique first presented by Jenq [19] for banyan-like MINs. Our extensions enabled the modeling of 1) routing dependencies, 2) a measure of bandwidth we have called information flow, and 3) message types. <p> One of our goals in building the prototype is to demonstrate that isotach techniques can work in distributed systems and can tolerate some types of faults. Preliminary explorations show that isotach networks can function under a number of different failure models. One result for fail-stop models appears in <ref> [46] </ref>. Our approach to ensuring a reliable implementation of the isochron on the prototype system will be similar to the approach reported in [45], except that we intend to use a distributed protocol in place of a centralized credit manager for flow control.
Reference: [47] <author> C. Williams and P. F. Reynolds, Jr., </author> <title> ``Delta-Cache Protocols: A New Class of Cache Coherence Protocols'', </title> <type> Tech. Rep. 90-34, </type> <institution> University of Virginia, Department of Computer Science, </institution> <month> December, </month> <year> 1990. </year>
Reference-contexts: The resulting techniques are sufficiently lightweight that they can be used in SMM computations. g Cache Coherence Isotach based techniques for enforcing atomicity and sequential consistency extend to systems with caches. The resulting cache coherence protocols <ref> [44, 47, 48] </ref> are more concurrent than existing protocols for non-bus-based systems in that they support multiple concurrent reads and writes of the same block, allow processes to pipeline memory accesses without sacrificing sequential consistency, and allow processes to read and write multiple shared cache blocks atomically without obtaining exclusive rights <p> When the workload has two or more of these characteristics, an isotach network performs markedly better than a conventional network. These results indicate that isotach based synchronization techniques warrant further study. We have extended our simulation to include isotach based cache coherence protocols <ref> [47] </ref>. 4.2. Analytic Model Analytic models were developed for networks C1, C2, I1 and I2. That work led to the discovery of novel modeling methods that will be presented in a future paper. We outline the approach and results we obtained here.
Reference: [48] <author> C. C. Williams, </author> <title> ``Concurrency Control in Asynchronous Computations'', </title> <type> Ph.D. Thesis, No. 9301, </type> <institution> University of Virginia, </institution> <year> 1993. </year>
Reference-contexts: Structured atomic actions cannot be executed using isochrons consisting of ordinary reads and writes because internal dependences prevent issuing all of the operations in a batch, but they can be executed using isochrons consisting of split operations <ref> [48] </ref>. A split operation, in brief, is half of a read or write. Split operations are used in executing reads and writes in two steps, where the first step schedules the access and the second transfers a value. <p> This technique works when the access set, the set of variables accessed by the atomic action, can be determined prior to execution of the atomic action. We have proposed variations on the technique for atomic actions with data dependent access sets <ref> [48] </ref>. Isotach techniques for executing structured atomic actions are similar to techniques used in multiversion concurrency control [38] except that isochrons streamline these techniques, eliminating roll-back and permitting an efficient in-cache implementation of variable histories. <p> The resulting techniques are sufficiently lightweight that they can be used in SMM computations. g Cache Coherence Isotach based techniques for enforcing atomicity and sequential consistency extend to systems with caches. The resulting cache coherence protocols <ref> [44, 47, 48] </ref> are more concurrent than existing protocols for non-bus-based systems in that they support multiple concurrent reads and writes of the same block, allow processes to pipeline memory accesses without sacrificing sequential consistency, and allow processes to read and write multiple shared cache blocks atomically without obtaining exclusive rights <p> Important special applications include parallel and distributed databases and production systems <ref> [41, 48] </ref>. 4. PERFORMANCE We studied the performance of equidistant isotach networks using both simulation [40] and analytic modeling [46]. The following is a synopsis; the interested reader is referred to the noted references for more details. 4.1.
Reference: [49] <author> C. C. Williams and P. F. Reynolds, Jr., </author> <title> ``Combining Atomic Actions'', </title> <journal> Journal of Parallel and Distributed Computing, </journal> <month> Feb </month> <year> 1995, </year> <pages> 152-163. 33 </pages>
Reference-contexts: An isotach network need not implement combining, but if it does, it can combine operations not combinable in other networks, resulting in improved concurrency in accessing shared memory <ref> [49] </ref>. 20 Other applications include support for causal message delivery, causal and totally ordered multicasting, migration mechanisms, checkpointing, wait-free communication primitives, and highly concurrent access to linked data structures. Important special applications include parallel and distributed databases and production systems [41, 48]. 4.
References-found: 49

