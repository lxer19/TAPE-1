URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3653/3653.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: Email: randeep@cs.umd.edu.  E-mail samir@cs.umd.edu.  
Phone: 3  
Title: The Loading Time Scheduling Problem  
Author: Randeep Bhatia Samir Khuller Joseph (Seffi) Naor 
Note: 20742. Research supported by an NSF Research Initiation Award CCR-9307462 and an NSF CAREER Award CCR-9501355.  
Address: College Park, MD 20742 and LCC Inc., 2300 Clarendon Blvd, Suite 800, Arlington, VA 22201.  College Park, MD  
Affiliation: 2 Computer Science Department, University of Maryland,  Computer Science Department and Institute for Advanced Computer Studies, University of Maryland,  
Abstract: 1 An extended abstract of this paper appeared in the Proceedings of the 36th IEEE Conference on Foun dations of Computer Science, Milwaukee, Wisconsin, (1995), pp. 72-81. 4 Department of Computer Science, Technion, Haifa 32000, Israel. Research supported in part by Grant No. 92-00225 from the United States-Israel Binational Science Foundation (BSF), Jerusalem. Research also supported by the Technion V.P.R. fund No. 120-882. Israel. E-mail : naor@cs.technion.ac.il. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Y. Azar. </author> <type> personal communication (1995). </type>
Reference-contexts: This concept was recently suggested by Yishay Mansour [12] in the context of randomized approximation algorithms which can be shown to achieve an expected approximation factor of 1. The difficulty with this approach is that it may generate a universal sequence of exponential length. Yossi Azar <ref> [1] </ref> suggested a way to make it deterministic, but this increased the approximation ratio by a factor of 2. Here we show how to get a approximation in polynomial time deterministically. We describe a deterministic approximation algorithm that also generates a universal sequence.
Reference: [2] <author> P. Bonizzoni, M. Duella and G. Mauri. </author> <title> Approximation complexity of longest common subsequence and shortest common supersequence over fixed alphabet. </title> <type> Technical Report 117/94, </type> <institution> Universita degli Studi di Milano, </institution> <year> (1994). </year>
Reference-contexts: Recently, it has been show to be MAX SNP-hard over a binary alphabet as well <ref> [2] </ref>. Theorem 19 LTSP is NP-complete and MAX SNP-hard for 4. Proof: It is easy to see that the problem is in NP since we can verify a given partitioning of V easily. We will prove that it is NP-hard by a reduction from the Shortest Common Supersequence problem (SCS). <p> We would like to thank Yossi Azar and Yishay Mansour for letting us include their suggestions regarding universal sequences (Subsection 3.2). We thank Amos Fiat and Uzi Vishkin for helpful discussions. We thank Tao Jiang and Ming Li for pointers to references <ref> [2, 14] </ref>.
Reference: [3] <author> D. Das, S. Gupta and D. Nau. </author> <title> Reducing setup cost by automated generation of redesign suggestions. </title> <booktitle> Proc. ASME Computers in Engineering Conference, </booktitle> <pages> pages 159-170, </pages> <year> (1994). </year>
Reference-contexts: The goal is to minimize P k p=1 `(V p ), where `(V p ) = min m k 2M (V p ) `(m k ). In many manufacturing applications <ref> [8, 3] </ref>, typically, jM (i)j = 1. The tasks, for example, could be drilling, end-milling, etc. Let the term job denote the block of metal mentioned earlier. The following simple heuristic is commonly used in such applications.
Reference: [4] <author> J. Ferannte, K. Ottenstein and J. Warren. </author> <title> The program dependence graph and its uses in optimization. </title> <journal> ACM Transactions of Programming Languages and Systems, </journal> <pages> pages 319-349, </pages> <year> (1987). </year>
Reference: [5] <author> D. Foulser, M. Li and Q. Yang. </author> <title> Theory and algorithms for plan merging. </title> <booktitle> Artificial Intelligence Vol 57 </booktitle> <pages> 143-181, </pages> <year> (1992). </year>
Reference-contexts: We handle the special case when the switching cost is the sum of the loading and unloading costs. An extensive survey of "operator overlap" problems in Artificial Intelligence appears in the work by Foulser, Li and Yang <ref> [5] </ref>. In particular, they discuss a variety of heuristics, with an average case analysis for them, as well as empirical results. Other applications of overlapping operators arise in databases when we try to do multiple query optimization [16].
Reference: [6] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and intractability: a guide to the theory of NP-completeness, </title> <publisher> Freeman, </publisher> <address> San Francisco, </address> <year> (1979). </year>
Reference-contexts: Other applications of overlapping operators arise in databases when we try to do multiple query optimization [16]. A problem related to the Loading Time Scheduling Problem is the Shortest Common Superse-quence problem <ref> [6, problem SR8] </ref>. Here, a collection of sequences over a fixed alphabet is given, and the goal is to find a shortest common supersequence (SCS), such that all given sequences appear as a subsequence in the common supersequence. <p> spread high cost vertices between several blocks, instead of grouping them in the same one. 3 1.3 Our Results It is easy to show that the Loading Time Scheduling Problem is NP-complete for arbitrary M (i), even when there are no precedence constraints, by a reduction from the set-cover problem <ref> [6] </ref>. (The elements correspond to tasks, and each subset corresponds to a machine. <p> A task can be done on a machine if the corresponding element belongs to the set corresponding to the machine.) When jM (i)j = 1, and 4, the problem can be shown to be NP-complete (and MAX SNP-hard) by a reduction from the shortest common supersequence problem <ref> [6, problem SR8] </ref>. Moreover, the reduction proves the hardness results even for the case of unit loading times. A recent result of [13] implies that LTSP is NP-complete for = 3. <p> Therefore (for large m) Sarkar's algorithm gives a (log n) approximation. 6 NP-completeness Proof We prove that the Loading Time Scheduling Problem is NP-complete even for the case of a constant number of machines, and M (i) = 1, by a polynomial time reduction from the Shortest Common Supersequence problem <ref> [6, problem SR8] </ref>). Shortest Common Supersequence: Given a finite alphabet , finite set R of sequences from fl , and a positive integer K.
Reference: [7] <author> S. Gupta. </author> <type> personal communication. </type>
Reference-contexts: the practical point of view, an approximation factor of is much better than an approximation factor that is a function of n, since is typically very small (4 or 5), compared to the size of the task graph that can have, for example, over 1000 features for an engine block <ref> [7] </ref>. We also give a second approach that gives a simpler approximation for LTSP. However, we believe that the previous method will produce better solutions in practice. In any case, both approaches are described as they use very different techniques.
Reference: [8] <author> C. C. Hayes. </author> <title> A model of planning for plan efficiency: Taking advantage of operator overlap. </title> <booktitle> Proc. of the 11th International Joint Conference of Artificial Intelligence, </booktitle> <pages> pages 949-953 (1989). 18 </pages>
Reference-contexts: Every time the next task in the sequence is executed on a different machine than the current one, the loading time of the new machine is incurred. We call this basic problem the Loading Time Scheduling Problem (LTSP). A special case of this problem was first mentioned by Hayes <ref> [8] </ref> in the context of machining metal parts. The objective is to start with a block of metal, and to use a numerically controlled machining center to cut a variety of features into the block. <p> When we are able to overlap the machining operations, we do not incur the loading time delay for the machine repeatedly. (For example, when we do two drilling operations consecutively, we only have to load the block of metal on the drilling machine once.) According to Hayes <ref> [8] </ref>, this set-up time is a large fraction of the time for each operation, sometimes as much as 90% of the time is spent in setting up for one machining operation. All other times are relatively small compared to the set-up time. A second motivation given by Hayes [8] is shown <p> to Hayes <ref> [8] </ref>, this set-up time is a large fraction of the time for each operation, sometimes as much as 90% of the time is spent in setting up for one machining operation. All other times are relatively small compared to the set-up time. A second motivation given by Hayes [8] is shown in Fig. 1. (We are not solving the same problem, but this explains some of the intuition behind the loading time scheduling problem.) Suppose we have to run a few errands. <p> The goal is to minimize P k p=1 `(V p ), where `(V p ) = min m k 2M (V p ) `(m k ). In many manufacturing applications <ref> [8, 3] </ref>, typically, jM (i)j = 1. The tasks, for example, could be drilling, end-milling, etc. Let the term job denote the block of metal mentioned earlier. The following simple heuristic is commonly used in such applications.
Reference: [9] <author> T. Jiang and M. Li. </author> <title> On the approximation of shortest common supersequences and longest com-mon subsequences. </title> <booktitle> Proc. of 21st International Colloq. on Automata Langs. and Programming, </booktitle> <pages> pages 191-202, </pages> <year> (1994). </year>
Reference-contexts: Here, a collection of sequences over a fixed alphabet is given, and the goal is to find a shortest common supersequence (SCS), such that all given sequences appear as a subsequence in the common supersequence. The previous results shown for the SCS problem by Jiang and Li <ref> [9] </ref> are hardness results for 1 get cash (grocery store) (post-office) (grocery store) (home) (grocery store) get coupon (post-office) recycle bags buy ice-cream buy stamps post letters approximation, and a -approximation algorithm, where is the size of the alphabet. Let n denote the number of sequences. Specifically, Jiang and Li [9] <p> <ref> [9] </ref> are hardness results for 1 get cash (grocery store) (post-office) (grocery store) (home) (grocery store) get coupon (post-office) recycle bags buy ice-cream buy stamps post letters approximation, and a -approximation algorithm, where is the size of the alphabet. Let n denote the number of sequences. Specifically, Jiang and Li [9] show that (i) SCS does not have a polynomial time constant factor approximation algorithm, unless P = N P ; (ii) there exists a constant ffi such that if SCS has a polynomial time approximation algorithm with ratio log ffi n then N P DT IM E (2 poly log <p> They also give algorithms that produce solutions close to the optimal when the supersequences are random (see <ref> [9] </ref> for more details). A generalization is the weighted shortest common supersequence (WSCS), where each letter of the alphabet has a weight, and the weight of the supersequence is the sum of the weights of its constituent letters. <p> The main idea is to take an instance X of a restricted version of the SCS problem, and to convert it into a "large" instance of the LTSP problem. This is done by modifying the construction in <ref> [9] </ref>. Using an approximation algorithm for the LTSP problem, we are able to obtain a c-approximation algorithm for the restricted SCS problem, for any c. <p> The following definitions from <ref> [9] </ref> are extended to LDAG's. Definition 4 Let and 0 be two alphabets. Let a 2 and b 2 0 be two letters.
Reference: [10] <author> E. Lawler, J. Lenstra, A. Rinnooy-Kan, D. Shmoys. </author> <title> Sequencing and scheduling: algorithms and complexity. </title> <booktitle> Handbooks in Operations Research and Management Science, </booktitle> <volume> Vol 4: </volume> <booktitle> Logistics of Production and Inventory, </booktitle> <editor> (Eds: S. C. Graves, A. H. G. Rinnooy Kan and P. </editor> <publisher> Zipkin). </publisher>
Reference-contexts: As an application of our results we show that we can obtain a - approximation algorithm for the WSCS problem. The literature concerning scheduling problems is very extensive (see e.g., <ref> [10] </ref>). However, it appears that the specific constraints on the Loading Time Scheduling Problem are very different from the kinds of problems that have been previously considered in the scheduling literature.
Reference: [11] <author> D. Maier. </author> <title> The complexity of some problems on subsequences and supersequences. </title> <journal> Journal of the ACM, </journal> <volume> Vol 25 </volume> <pages> 322-336, </pages> <year> (1978). </year>
Reference-contexts: R is a subsequence of X, i.e., X = x 0 s i 1 x 1 s i p x p where each x j 2 fl and S i = s i 1 s i p ? This problem is known to be NP-complete even when jj = 5 <ref> [11] </ref> as well as when jj = 2 [14]. Recently, it has been show to be MAX SNP-hard over a binary alphabet as well [2]. Theorem 19 LTSP is NP-complete and MAX SNP-hard for 4.
Reference: [12] <author> Y. Mansour. </author> <type> personal communication (1995). </type>
Reference-contexts: This concept was recently suggested by Yishay Mansour <ref> [12] </ref> in the context of randomized approximation algorithms which can be shown to achieve an expected approximation factor of 1. The difficulty with this approach is that it may generate a universal sequence of exponential length.
Reference: [13] <author> M. Middendorf. Supersequences, </author> <title> Runs, and CD Grammar Systems. </title> <booktitle> Developments in Theoretical Computer Science, </booktitle> <pages> 101-114, </pages> <booktitle> Topics in Computer Science, </booktitle> <volume> Vol. 6, </volume> <editor> (Eds: J. Dassow, A. </editor> <publisher> Kelemenova). </publisher>
Reference-contexts: Moreover, the reduction proves the hardness results even for the case of unit loading times. A recent result of <ref> [13] </ref> implies that LTSP is NP-complete for = 3. Hardness Results: Furthermore, we show that when is a constant, then there exists an ff such that no polynomial time approximation algorithm with a factor ff is possible unless P = N P . <p> Therefore jX 0 j K and jX 00 j K. Thus, L = jX 0 j + jX 00 j 2K. The following theorem is obvious. 17 Theorem 20 The Loading Time Scheduling Problem can be solved in polynomial time for = 2. A recent result of <ref> [13] </ref> implies that LTSP is NP-complete for = 3. 7 Weighted Shortest Common Supersequence problem As an application of our result we give a approximation algorithm for the WSCS problem.
Reference: [14] <author> K. J. Raiha and E. Ukkonen. </author> <title> The shortest common supersequence problem over a binary alphabet is NP-complete. </title> <booktitle> Theoretical Computer Science Vol 16(2) </booktitle> <pages> 187-198, </pages> <year> (1981). </year>
Reference-contexts: = x 0 s i 1 x 1 s i p x p where each x j 2 fl and S i = s i 1 s i p ? This problem is known to be NP-complete even when jj = 5 [11] as well as when jj = 2 <ref> [14] </ref>. Recently, it has been show to be MAX SNP-hard over a binary alphabet as well [2]. Theorem 19 LTSP is NP-complete and MAX SNP-hard for 4. Proof: It is easy to see that the problem is in NP since we can verify a given partitioning of V easily. <p> We would like to thank Yossi Azar and Yishay Mansour for letting us include their suggestions regarding universal sequences (Subsection 3.2). We thank Amos Fiat and Uzi Vishkin for helpful discussions. We thank Tao Jiang and Ming Li for pointers to references <ref> [2, 14] </ref>.
Reference: [15] <author> V. Sarkar. </author> <title> Instruction reordering for fork-join parallelism. </title> <booktitle> Proc. of ACM SIGPLAN-PLDI Conf., </booktitle> <pages> pages 322-336 (1990). </pages>
Reference-contexts: The objective is to generate fork-join parallel code for the DAG, with minimum overall execution time. It is assumed that the parallel code would be executed on a machine with unbounded number of processors and no communication overhead. Sarkar <ref> [15] </ref> investigated this problem of generating maximally parallel code using only fork and join operations to correctly satisfy all the control and data dependences in the program. <p> Finally, we discuss a natural linear programming approach to LTSP and show that the integrality gap of the integer program derived is (1)=4, meaning that this approach is not useful for obtaining improved approximation factors. Fork-Join Problem: Sarkar <ref> [15] </ref> presents a heuristic for solving the fork-join problem, with no analysis, and conjectures that his heuristic has a constant worst case guarantee. We have been able to construct an example for which Sarkar's algorithm has a performance of (log n) times the optimal cost, disproving his conjecture.
Reference: [16] <author> T. Sellis. </author> <title> Multiple-query optimization. </title> <journal> Transactions on Database Systems, </journal> <volume> Vol 13(1): </volume> <pages> 23-52, </pages> <year> (1988). </year>
Reference-contexts: In particular, they discuss a variety of heuristics, with an average case analysis for them, as well as empirical results. Other applications of overlapping operators arise in databases when we try to do multiple query optimization <ref> [16] </ref>. A problem related to the Loading Time Scheduling Problem is the Shortest Common Superse-quence problem [6, problem SR8].
References-found: 16

