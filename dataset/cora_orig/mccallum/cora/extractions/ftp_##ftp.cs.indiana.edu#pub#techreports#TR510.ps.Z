URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR510.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Title: HARDWARE VERIFICATION USING COINDUCTIVE ASSERTIONS  
Author: Paul S. Miner 
Degree: Submitted to the faculty of the Graduate School in partial fulfillment of the requirements for the degree Doctor of Philosophy in the  
Date: June 1998  
Affiliation: Department of Computer Science Indiana University  
Abstract-found: 0
Intro-found: 1
Reference: [Acz88] <author> Peter Aczel. </author> <title> Non-Well-Founded Sets. </title> <booktitle> Number 14 in CSLI Lecture Notes. </booktitle> <publisher> CSLI Publications, </publisher> <year> 1988. </year>
Reference-contexts: There are a number of foundational treatments in the literature. One such basis is Aczel's Special Final Coalgebra Theo- rem <ref> [Acz88] </ref>. Another is Barwise and Moss' Corecursion Theorem [BM96]. Recently, Moss and Danner have further explored foundational issues and have suggested that 2. Related Research 22 corecursion may by justified by reduction to recursion [MD97]. Research in constructive type theory has also addressed the notion of types of infinite objects.
Reference: [Ari96] <institution> Ariane 5 flight 501 failure: </institution> <note> Report by the inquiry board, July 19, 1996. http://www.esrin.esa.it/htdocs/tidc/Press/Press96/ariane5rep.html. </note>
Reference: [BCL + 94] <author> J. R. Burch, E. M. Clarke, D. E. Long, K. L. McMillan, and D. L. Dill. </author> <title> Symbolic model checking for sequential circuit verification. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, </journal> <volume> 13(4) </volume> <pages> 401-424, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Frequently, these systems require human interaction to produce machine checked proofs. At another extreme are a collection of fully automatic tools that can be applied to specialized verification problems. These tools include tautology checking using Binary Decision Diagrams [Bry86] and, more recently, model checking techniques for state machine verification <ref> [CES86, BCM + 92, BCL + 94] </ref>. Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors [Hun92, SM95], dedicated hardware for fault-tolerance [BY90, SB91], and many efforts in floating-point verification [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95].
Reference: [BCM + 92] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-170, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Frequently, these systems require human interaction to produce machine checked proofs. At another extreme are a collection of fully automatic tools that can be applied to specialized verification problems. These tools include tautology checking using Binary Decision Diagrams [Bry86] and, more recently, model checking techniques for state machine verification <ref> [CES86, BCM + 92, BCL + 94] </ref>. Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors [Hun92, SM95], dedicated hardware for fault-tolerance [BY90, SB91], and many efforts in floating-point verification [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95].
Reference: [BDL96] <author> Clark Barrett, David Dill, and Jeremy Levitt. </author> <title> Validity checking for combi-nations of theories with equality. </title> <editor> In Mandayam Srivas and Albert Camilleri, editors, </editor> <booktitle> Formal Methods in Computer-Aided Design, FMCAD '96, volume 1166 of Lecture Notes in Computer Science, </booktitle> <pages> pages 187-201, </pages> <address> Palo Alto, CA, </address> <month> November </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: This could eliminate the overhead of generating the PVS theories for justifying the replacement. Also, it may be possible to discharge some of the combinational replacement conditions using a tool such as the Stanford Validity Checker <ref> [BDL96] </ref>. For the replacements that require more interaction, failed proof attempts often suggest appropriate invariants. A coinductive verifier might be improved by adding some of the recent techniques for semi-automatic generation of invariants [GS96].
Reference: [BJ93] <author> Bhaskar Bose and Steven D. Johnson. DDD-FM9001: </author> <title> Derivation of a verified microprocessor. An exercise in integrating verification with for-mal derivation. </title> <booktitle> In Proceedings of IFIP Conference on Correct Hardware Design and Verification Methods. </booktitle> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: This abstraction defines the input signals for the circuit. The circuit's output is a subset of the streams named in the system of equations. 2. Related Research 13 Several significant hardware designs have been developed using DDD. In particular, Bose has formally derived the DDD-FM9001 <ref> [Bos94, BJ93] </ref> processor from Hunt's formal specification of the mechanically verified FM9001 microprocessor [Hun92]. An- other significant derivation is the development of a Scheme Machine, which consists of a garbage-collecting memory system and a CPU that executes high-level Scheme primitives [Bur94].
Reference: [BKM96] <author> Bishop Brock, Matt Kaufmann, and J Strother Moore. </author> <title> ACL2 theo-rems about commercial microprocessors. </title> <editor> In Mandayam Srivas and Albert Camilleri, editors, </editor> <booktitle> Formal Methods in Computer-Aided Design, FMCAD '96, volume 1166 of Lecture Notes in Computer Science, </booktitle> <pages> pages 275-293, </pages> <address> Palo Alto, CA, </address> <month> November </month> <year> 1996. </year> <note> Springer-Verlag. 129 BIBLIOGRAPHY 130 </note>
Reference-contexts: Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors [Hun92, SM95], dedicated hardware for fault-tolerance [BY90, SB91], and many efforts in floating-point verification <ref> [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95] </ref>. Theorem prover based verifications are not always robust in the face of changes. A small change in the design may invalidate much of the correctness proof [Wil97]. A notable effort is Hunt's verification of the FM9001 processor using nqthm [Hun92]. 2. <p> Related Research 18 Hunt's verification strategy consists of a simulation model that animates designs expressed in a hardware description language. The verified design was subsequently fabricated in a VLSI implementation. The verification approach has subsequently been used successfully on commercial hardware devices <ref> [BKM96] </ref>. Another significant effort is the verification of the microcode of a set of instructions of the Rockwell-Collins AAMP5 microprocessor in PVS [SM95]. The AAMP5 is a modern microprocessor designed for aerospace applications. <p> This 2. Related Research 19 provides the entry point for the derivation activities presented in Chapter 6. Re- cently, the microcode for the floating point division and square root algorithms of the AMD5 K 86 T M microprocessor has been mechanically verified using the ACL2 theorem prover <ref> [BKM96] </ref>. Within a general purpose theorem proving system, there are several ways to represent hardware artifacts. One of the most common is the relational style advocated by Gordon [Gor86]. Signals are represented as functions from discrete points in time to the signal type.
Reference: [BM96] <author> Jon Barwise and Lawrence Moss. </author> <title> Vicious circles: </title> <booktitle> On the Mathematics of Non-Wellfounded Phenomena. Number 60 in CSLI Lecture Notes. </booktitle> <publisher> CSLI Publications, </publisher> <year> 1996. </year>
Reference-contexts: There are a number of foundational treatments in the literature. One such basis is Aczel's Special Final Coalgebra Theo- rem [Acz88]. Another is Barwise and Moss' Corecursion Theorem <ref> [BM96] </ref>. Recently, Moss and Danner have further explored foundational issues and have suggested that 2. Related Research 22 corecursion may by justified by reduction to recursion [MD97]. Research in constructive type theory has also addressed the notion of types of infinite objects. <p> An elegant model of streams is found in the universe of non-well-founded sets, where it is possible to define cs (a; x) = ha; xi <ref> [BM96] </ref>. A trivial consequence of the fact that A 1 = S fZjZ CS A (Z)g is the following proof principle: Coinduction Principle: To show that x 2 A 1 , exhibit a Z such that x 2 Z and Z CS A (Z). <p> A proof of this principle in the universe of non-well-founded sets is on page 84 of <ref> [BM96] </ref>. Jacobs and Rutten use the fact that streams are a final coalgebra to justify this principle [JR97]. Here we directly show that two streams in a stream bisimulation are indistinguishable. <p> This template is followed for all stream definitions within the PVS streams library. For a more complicated example of stream definition using the corecursion com- binator, consider equation (3.9) from section 3.1. The challenge (from Barwise and Moss <ref> [BM96] </ref>) is to show that there is a function zip:A 1 fi A 1 ! A 1 that satisfies the equation: zip (X,Y) = cs (hd (X), cs (hd (Y), zip (tl (X), tl (Y)))) At first glance, it does not appear that zip can be defined using corec.
Reference: [Bos91] <author> Bhaskar Bose. </author> <title> DDD ATransformation System for Digital Design Derivation. </title> <type> Technical Report 331, </type> <institution> Computer Science Dept. Indiana University, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: 1. Introduction 10 derivation with coinductive verification strategies. This provides an opportunity to verify aggressive optimizations that exploit the semantics of the implemented func <br>- tion. 2 Related Research 2.1 Overview of Design Derivation The design derivation tools DDD <ref> [Bos91, Bos94] </ref> and DRS [BTC96] implement a formal design algebra for developing correct digital circuit descriptions. The designer interactively transforms high level behavioral specifications into a description suitable for entry into hardware synthesis tools.
Reference: [Bos94] <author> Bhaskar Bose. DDD-FM9001: </author> <title> Derivation of a verified microprocessor. </title> <type> PhD thesis, </type> <institution> Computer Science Department, Indiana University, USA, </institution> <year> 1994. </year>
Reference-contexts: 1. Introduction 10 derivation with coinductive verification strategies. This provides an opportunity to verify aggressive optimizations that exploit the semantics of the implemented func <br>- tion. 2 Related Research 2.1 Overview of Design Derivation The design derivation tools DDD <ref> [Bos91, Bos94] </ref> and DRS [BTC96] implement a formal design algebra for developing correct digital circuit descriptions. The designer interactively transforms high level behavioral specifications into a description suitable for entry into hardware synthesis tools. <p> This abstraction defines the input signals for the circuit. The circuit's output is a subset of the streams named in the system of equations. 2. Related Research 13 Several significant hardware designs have been developed using DDD. In particular, Bose has formally derived the DDD-FM9001 <ref> [Bos94, BJ93] </ref> processor from Hunt's formal specification of the mechanically verified FM9001 microprocessor [Hun92]. An- other significant derivation is the development of a Scheme Machine, which consists of a garbage-collecting memory system and a CPU that executes high-level Scheme primitives [Bur94].
Reference: [Bry86] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8), </volume> <year> 1986. </year>
Reference-contexts: Frequently, these systems require human interaction to produce machine checked proofs. At another extreme are a collection of fully automatic tools that can be applied to specialized verification problems. These tools include tautology checking using Binary Decision Diagrams <ref> [Bry86] </ref> and, more recently, model checking techniques for state machine verification [CES86, BCM + 92, BCL + 94]. Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature.
Reference: [BT90] <author> Alexandre Bronstein and Carolyn L. Talcott. </author> <title> Formal verification of pipelines based on string-functional semantics. </title> <editor> In L. J. M. Claesen, edi-tor, </editor> <title> Formal VLSI Correctness Verification: </title> <booktitle> VLSI Design Methods-I, </booktitle> <pages> pages 349-366. </pages> <publisher> North Holland, </publisher> <year> 1990. </year>
Reference-contexts: Signals are represented as functions from discrete points in time to the signal type. Circuit components are defined as relations between signals; hardware structure is defined by relation composition. Bronstein and Talcott present a string-functional semantics for reasoning about hardware using nqthm <ref> [BT90] </ref>. This supports describing hardware structure using a functional style similar to that used in DRS. Paulin-Mohring has used a coinductive representation of streams in Coq to explore their application in hardware verification [Pau95]. She illustrated the approach using Gordon's multiplier circuit [Gor86]. <p> Another use for temporal abstractions is to relate circuits operating at different clock rates. Bronstein and Talcott <ref> [BT90] </ref> use the stuttering counter depicted in show that a temporal abstraction of the stuttering counter is equivalent to a simple counter (Figure 4.5). The simple counter is just iter (inc, i).
Reference: [BTC96] <author> Bhaskar Bose, M. Esen Tuna, and Venkatesh. Choppella. </author> <title> A tutorial on digital design derivation using DRS. </title> <editor> In Mandayam Srivas and Albert Camilleri, editors, </editor> <booktitle> Formal Methods in Computer-Aided Design, FMCAD '96, volume 1166 of Lecture Notes in Computer Science, </booktitle> <pages> pages 270-274, </pages> <address> Palo Alto, CA, </address> <month> November </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: 1. Introduction 10 derivation with coinductive verification strategies. This provides an opportunity to verify aggressive optimizations that exploit the semantics of the implemented func <br>- tion. 2 Related Research 2.1 Overview of Design Derivation The design derivation tools DDD [Bos91, Bos94] and DRS <ref> [BTC96] </ref> implement a formal design algebra for developing correct digital circuit descriptions. The designer interactively transforms high level behavioral specifications into a description suitable for entry into hardware synthesis tools.
Reference: [Bur94] <author> Robert G. Burger. </author> <title> The Scheme machine. </title> <type> Technical Report 413, </type> <institution> Indiana University, Computer Science Department, </institution> <month> August </month> <year> 1994. </year> <pages> 59 pages. </pages>
Reference-contexts: In particular, Bose has formally derived the DDD-FM9001 [Bos94, BJ93] processor from Hunt's formal specification of the mechanically verified FM9001 microprocessor [Hun92]. An- other significant derivation is the development of a Scheme Machine, which consists of a garbage-collecting memory system and a CPU that executes high-level Scheme primitives <ref> [Bur94] </ref>. During the above projects, it was recognized that a combination of design derivation with mechanized proof support would be superior to either approach individually [JWB89].
Reference: [BY90] <author> William R. Bevier and William D. Young. </author> <title> Machine checked proofs of the design and implementation of a fault-tolerant circuit. </title> <type> Contractor Report 182099, </type> <institution> NASA, </institution> <month> November </month> <year> 1990. </year> <title> Authors' affiliation: Computational Logic, </title> <publisher> Inc., </publisher> <address> Austin, TX. </address>
Reference-contexts: Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors [Hun92, SM95], dedicated hardware for fault-tolerance <ref> [BY90, SB91] </ref>, and many efforts in floating-point verification [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95]. Theorem prover based verifications are not always robust in the face of changes. A small change in the design may invalidate much of the correctness proof [Wil97].
Reference: [CES86] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2), </volume> <year> 1986. </year>
Reference-contexts: Frequently, these systems require human interaction to produce machine checked proofs. At another extreme are a collection of fully automatic tools that can be applied to specialized verification problems. These tools include tautology checking using Binary Decision Diagrams [Bry86] and, more recently, model checking techniques for state machine verification <ref> [CES86, BCM + 92, BCL + 94] </ref>. Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors [Hun92, SM95], dedicated hardware for fault-tolerance [BY90, SB91], and many efforts in floating-point verification [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95].
Reference: [CGZ96] <author> E. M. Clarke, S. M. German, and X. Zhao. </author> <title> Verifying the SRT division al-gorithm using theorem proving techniques. </title> <editor> In Rajeev Alur and Thomas A. Henzinger, editors, </editor> <booktitle> Computer-Aided Verification, CAV '96, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 111-122. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year> <note> BIBLIOGRAPHY 131 </note>
Reference-contexts: Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors [Hun92, SM95], dedicated hardware for fault-tolerance [BY90, SB91], and many efforts in floating-point verification <ref> [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95] </ref>. Theorem prover based verifications are not always robust in the face of changes. A small change in the design may invalidate much of the correctness proof [Wil97]. A notable effort is Hunt's verification of the FM9001 processor using nqthm [Hun92]. 2. <p> In response to the flaw in the Pentium, several researchers investigated theorem prover based verifications of SRT division hardware. Clarke, German, and Zhao used the Analytica theorem prover to verify Taylor's [Tay81] radix-4 SRT division circuit <ref> [CGZ96] </ref>. Their verification includes an abstract representation of the lookup table and a proof that it defines all necessary values for the quotient selection logic. Rue, Srivas, and Shankar [RSS96] generalize this work using PVS. <p> The signal and function names introduced for the remainder of this derivation were selected to correspond to signal names in the Clarke, German, Zhao verification of Taylor's circuit <ref> [CGZ96] </ref>. The subtraction feeding the register pr is replaced with a full precision alu (dalu), 6. Floating Point Division 107 controlled by the sign bit of the selected quotient digit.
Reference: [CJ96] <author> Solange Coupet-Grimal and Line Jakubiec. </author> <title> Coq and hardware verifica-tion: A case study. </title> <editor> In J. Von Wright, J. Grundy, and J. Harrison, editors, </editor> <title> Theorem Proving in Higher Order Logics, </title> <booktitle> 9th International Conference, TPHOLs '96, volume 1125 of Lecture Notes in Computer Science, </booktitle> <pages> pages 125-140, </pages> <year> 1996. </year>
Reference-contexts: She illustrated the approach using Gordon's multiplier circuit [Gor86]. She did not explore use of bisimulations for showing circuit equivalence, but suggested it as an interesting possibility. Coupet- Grimal and Jakubiec have exploited the constructive nature of Coq to extract circuits from proofs <ref> [CJ96] </ref>. In particular, they follow the example of Hanna, Daeche, and Longley's Veritas + system [HDL89] and use dependent types to construct parameterized circuit modules. Algebraic Approaches A number of algebraic approaches have been proposed for formal reasoning about digital hardware design.
Reference: [CLS96] <author> David Cyrluk, Patrick Lincoln, and N. Shankar. </author> <title> On Shostak's decision procedure for combinations of theories. </title> <editor> In M. A. McRobbie and J. K. Slaney, editors, </editor> <booktitle> Automated Deduction|CADE-13, volume 1104 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 463-477, </pages> <address> New Brunswick, NJ, July/August 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: PVS does not yet have a corresponding mechanism for corecursive datatypes. PVS provides an interactive theorem proving environment using a Gentzen style sequent calculus presentation of the proof goals. At the core of PVS's prover is a collection of decision procedures combined using a technique developed by Shostak <ref> [Sho78, Sho84, CLS96] </ref>. This eases some of the more burdensome aspects of interacting with a mechanical theorem prover. Most simple arithmetic results are discharged by invoking the decision procedures. The user rarely needs to direct the prover when faced with simple facts of arithmetic. PVS has a powerful conditional rewriter.
Reference: [Coq93] <author> Thierry Coquand. </author> <title> Infinite objects in type theory. </title> <editor> In Henk Barendregt and Tobias Nipkow, editors, </editor> <title> Types for Proofs and Programs, </title> <booktitle> International Workshop TYPES '93, volume 806 of Lecture Notes in Computer Science, </booktitle> <pages> pages 62-78, </pages> <year> 1993. </year>
Reference: [EL94] <author> Milos D. Ercegovac and Tomas Lang. </author> <title> Division and Square Root: DigitRecurrence Algorithms and Implementations. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1994. </year>
Reference-contexts: By carefully relaxing the precision in selecting each quotient digit, it is possible to develop algorithms with more efficient hardware realizations. Errors introduced by the imprecision are corrected by subsequent iterations of the algorithm. Ercegovac and Lang present several interrelated factors that affect the design of subtractive division algorithms <ref> [EL94] </ref>. These include: 6. Floating Point Division 97 1. Radix r|If b is the radix of the underlying floating-point number system, the division radix is chosen so that r = b k for some positive integer k. 2. <p> After the final quotient digit is received, the absolute value of the accumulated negative digits is subtracted from the accumulated positive digits. A more recent strategy, on-the-fly conversion <ref> [EL94] </ref>, maintains a decremented copy of the accumulated quotient, so that the correct quotient is computed using a shift-append operation. Each of these optimizations is verified using coinduction. Redundant Representation The first technique for improving the performance of the quotient accumulation sub-circuit was presented in Taylor [Tay81]. <p> The next approach computes the accumulated quotient as each quotient digit arrives, and completely eliminates the need for a carry-propagate adder in the quotient accumulation logic. 6. Floating Point Division 117 On-the-fly Quotient Accumulation This approach for quotient accumulation is due to Ercegovac and Lang <ref> [EL94] </ref>. The idea is to maintain two registers, one containing the current value of the accumulated quotient, qa, and the other containing qa 1.
Reference: [Gim95] <author> Eduardo Gimenez. </author> <title> An application of co-inductive types in coq: Verification of the alternating bit protocol. </title> <editor> In Stefano Berardi and Mario Coppo, editors, </editor> <title> Types for Proofs and Programs, </title> <booktitle> International Workshop TYPES '95, volume 1158 of Lecture Notes in Computer Science, </booktitle> <pages> pages 135-152, </pages> <year> 1995. </year>
Reference-contexts: Park appears to be among the first to explore the use of greatest fixed points as a verification strategy [Par80, Par81]. Other applications include programming language semantics [MT91, Pit94]. Gimenez used coinductive types in Coq for the verification of an alternating bit protocol <ref> [Gim95] </ref>. Recently, Jacobs has explored coinductive verification techniques for class refinement in an object-oriented setting [Jac97]. There have been a number of recent efforts seeking to provide mechanized reasoning support for coinductive verification techniques. Paulson built up a framework for inductive and coinductive datatypes in Isabelle-HOL [Pau97].
Reference: [GKP89] <author> Ronald L. Graham, Donald E. Knuth, and Oren Patashnik. </author> <title> Concrete Mathematics: A Foundation for Computer Science. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: cfn = (F +1) + (NF ) % The optimized circuit (Figure 5.6) is described by these stream equations: hold = reg (?, f1 ^ :hold) carry-in = hold ^ :nf opt = reg (?; mux (f1, val, (opt + [carry-in]))) In these equations, I adopt a notational convention from <ref> [GKP89] </ref>. For a boolean valued expression ', ['] ^= if ' then 1 else 0 endif. 5. Fault-Tolerant Synchronization 87 We wish to prove that opt = cfn, given some assumptions about the input streams f1, nf, and val.
Reference: [Gor86] <author> M. J. C. Gordon. </author> <title> Why higher order logic is a good formalism for spec-ifying and verifying hardware. </title> <editor> In G.J. Milne and P.A. Subrahmanyam, editors, </editor> <booktitle> Formal Aspects of VLSI Design: Proceedings of the 1985 Edinburgh Conference on VLSI, </booktitle> <pages> pages 153-177. </pages> <publisher> North Holland, </publisher> <year> 1986. </year>
Reference-contexts: Within a general purpose theorem proving system, there are several ways to represent hardware artifacts. One of the most common is the relational style advocated by Gordon <ref> [Gor86] </ref>. Signals are represented as functions from discrete points in time to the signal type. Circuit components are defined as relations between signals; hardware structure is defined by relation composition. Bronstein and Talcott present a string-functional semantics for reasoning about hardware using nqthm [BT90]. <p> This supports describing hardware structure using a functional style similar to that used in DRS. Paulin-Mohring has used a coinductive representation of streams in Coq to explore their application in hardware verification [Pau95]. She illustrated the approach using Gordon's multiplier circuit <ref> [Gor86] </ref>. She did not explore use of bisimulations for showing circuit equivalence, but suggested it as an interesting possibility. Coupet- Grimal and Jakubiec have exploited the constructive nature of Coq to extract circuits from proofs [CJ96].
Reference: [GS96] <author> Susanne Graf and Hassen Sa idi. </author> <title> Verifying invariants using theorem prov-ing. </title> <editor> In Rajeev Alur and Thomas A. Henzinger, editors, </editor> <booktitle> Computer-Aided Verification, CAV '96, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 196-207. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: For the replacements that require more interaction, failed proof attempts often suggest appropriate invariants. A coinductive verifier might be improved by adding some of the recent techniques for semi-automatic generation of invariants <ref> [GS96] </ref>. This dissertation focused on structural level refinements and how theorem proving support can augment derivational design at the structural level. More work needs to be done to link behavioral level descriptions to verified algorithms. This requires development of appropriate representation for reactive systems.
Reference: [Har95] <author> John Harrison. </author> <title> Floating point verification in HOL. </title> <editor> In E.T. Schubert, P.J. Windley, and J. Alves-Foss, editors, </editor> <booktitle> Proceedings 8th International BIBLIOGRAPHY 132 Workshop on Higher Order Logic Theorem Proving and its Applications, volume 971 of Lecture Notes in Computer Science, </booktitle> <pages> pages 186-199, </pages> <address> Aspen Grove, UT, USA, September 1995. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors [Hun92, SM95], dedicated hardware for fault-tolerance [BY90, SB91], and many efforts in floating-point verification <ref> [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95] </ref>. Theorem prover based verifications are not always robust in the face of changes. A small change in the design may invalidate much of the correctness proof [Wil97]. A notable effort is Hunt's verification of the FM9001 processor using nqthm [Hun92]. 2.
Reference: [HCRP91] <author> N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud. </author> <title> The syn-chronous dataflow programming language Lustre. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9) </volume> <pages> 1305-1320, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: RubyZF enables mechanical verification of all T-Ruby transformations, and provides integrated reasoning support for verifying proof obligations generated by T-Ruby. The synchronous data-flow language Lustre has been used effectively in the design and verification of synchronous hardware <ref> [HCRP91, TP90] </ref>. The language was originally developed for the specification and verification of real-time systems and was inspired by the dataflow language Lucid [WA85]. Lustre is a declarative language where expressions represent sequences of values. Systems are specified using a collection of equations.
Reference: [HD92] <author> F. K. Hanna and N. Daeche. </author> <title> Dependent types and formal synthesis. In C.A.R. </title> <editor> Hoare and M.J.C. Gordon, editors, </editor> <booktitle> Mechanized Reasoning in Hardware Design, </booktitle> <pages> pages 121-135. </pages> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: Dependent types are also quite useful in hardware verification, where many functions have regular structures that are parameterized by the width of the data word. Hanna was the first to advocate dependent types for this purpose <ref> [HD92] </ref>. PVS allows parameterized type declarations, inspired by the Veritas + system [HDL89]. The PVS prelude includes the following parameterized type declaration: below (i): TYPE = -s: nat | s &lt; i <p>- Using this type, we can declare a bit to have type below (2).
Reference: [HDL89] <author> F. K. Hanna, N. Daeche, and M. Longley. </author> <title> Veritas + : A specification language based on type theory. </title> <editor> In M. Lesser and G. Brown, editors, </editor> <booktitle> Proceedings of the MSI Workshop on Hardware Specification, Verification and Synthesis: Mathematical Aspects, Cornell University, volume 408 of Lecture Notes in Computer Science, </booktitle> <pages> pages 358-379. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: Dependent types are also quite useful in hardware verification, where many functions have regular structures that are parameterized by the width of the data word. Hanna was the first to advocate dependent types for this purpose [HD92]. PVS allows parameterized type declarations, inspired by the Veritas + system <ref> [HDL89] </ref>. The PVS prelude includes the following parameterized type declaration: below (i): TYPE = -s: nat | s &lt; i <p>- Using this type, we can declare a bit to have type below (2). The type of n-bit words 2. <p> She did not explore use of bisimulations for showing circuit equivalence, but suggested it as an interesting possibility. Coupet- Grimal and Jakubiec have exploited the constructive nature of Coq to extract circuits from proofs [CJ96]. In particular, they follow the example of Hanna, Daeche, and Longley's Veritas + system <ref> [HDL89] </ref> and use dependent types to construct parameterized circuit modules. Algebraic Approaches A number of algebraic approaches have been proposed for formal reasoning about digital hardware design.
Reference: [HJ97a] <author> Ulrich Hensel and Bart Jacobs. </author> <title> Coalgebraic theories of sequences in PVS. </title> <type> Technical Report CSI-R9708, </type> <institution> Computing Science Institute, Catholic University of Nijmegen, </institution> <month> July </month> <year> 1997. </year> <note> An electronic version may be retreived from http://www.cs.kun.nl/~bart/sequences.html. </note>
Reference-contexts: Leclerc and Paulin-Mohring have explored coinductive types using the Coq system [LP93]. Recently, Hensel and Jacobs have provided mechanized support for coinductive reasoning in PVS by developing a theory of final coalge- bras <ref> [HJ97a, HJ97b] </ref>. 3 Reasoning about Streams Many approaches to formal verification of hardware represent signals as streams, i.e. functions from time to value, where time ranges over the natural numbers. <p> More work needs to be done to link behavioral level descriptions to verified algorithms. This requires development of appropriate representation for reactive systems. Perhaps the theory developed by Jacobs and Hensel will enable more useful models of reactive systems within PVS <ref> [HJ97a, HJ97b] </ref>. At the end of chapter 4, I suggested one way to assert a fairness constraint on a boolean valued stream. More research is needed to determine how to express and verify other properties on streams. More case studies are needed to determine what properties arise in practice. 7.
Reference: [HJ97b] <author> Ulrich Hensel and Bart Jacobs. </author> <title> Proof principles for datatypes with iter-ated recursion. </title> <type> Technical Report CSI-R9703, </type> <institution> Computing Science Institute, Catholic University of Nijmegen, </institution> <month> March </month> <year> 1997. </year> <note> To appear in LNCS proceedings of Category Theory and Computer Science 1997. </note>
Reference-contexts: Leclerc and Paulin-Mohring have explored coinductive types using the Coq system [LP93]. Recently, Hensel and Jacobs have provided mechanized support for coinductive reasoning in PVS by developing a theory of final coalge- bras <ref> [HJ97a, HJ97b] </ref>. 3 Reasoning about Streams Many approaches to formal verification of hardware represent signals as streams, i.e. functions from time to value, where time ranges over the natural numbers. <p> More work needs to be done to link behavioral level descriptions to verified algorithms. This requires development of appropriate representation for reactive systems. Perhaps the theory developed by Jacobs and Hensel will enable more useful models of reactive systems within PVS <ref> [HJ97a, HJ97b] </ref>. At the end of chapter 4, I suggested one way to assert a fairness constraint on a boolean valued stream. More research is needed to determine how to express and verify other properties on streams. More case studies are needed to determine what properties arise in practice. 7.
Reference: [HT96] <author> N. A. Harman and J. V. Tucker. </author> <title> Algebraic models of microprocessors: Architecture and organization. </title> <journal> Acta Informatica, </journal> <volume> 33(5) </volume> <pages> 421-456, </pages> <year> 1996. </year>
Reference-contexts: Algebraic Approaches A number of algebraic approaches have been proposed for formal reasoning about digital hardware design. In addition to the design derivation tools discussed above, there is the Ruby design algebra [She88] and the work of Harman and Tucker <ref> [HT96] </ref> 2. Related Research 20 Harman and Tucker present an algebraic model of synchronous digital hardware. The general hardware representation is by iterated maps.
Reference: [Huf54] <author> D.A. Huffman. </author> <title> The synthesis of sequential switching circuits. </title> <journal> Journal of the Franklin Institute, </journal> <volume> 257(3) </volume> <pages> 161-190, </pages> <year> 1954. </year>
Reference-contexts: An output function that maps the input and current state to the output, and a next-state function that maps the input and current state to the next state. This standard model of sequential systems is often referred to as the Huffman model <ref> [Huf54] </ref> 1 and is depicted in Figure 4.1.
Reference: [Hun92] <author> Warren A. Hunt. </author> <title> A formal hdl and its use in the FM9001 verification. In C.A.R. </title> <editor> Hoare and M.J.C. Gordon, editors, </editor> <title> Mechanized Reasoning in Hardware Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: The circuit's output is a subset of the streams named in the system of equations. 2. Related Research 13 Several significant hardware designs have been developed using DDD. In particular, Bose has formally derived the DDD-FM9001 [Bos94, BJ93] processor from Hunt's formal specification of the mechanically verified FM9001 microprocessor <ref> [Hun92] </ref>. An- other significant derivation is the development of a Scheme Machine, which consists of a garbage-collecting memory system and a CPU that executes high-level Scheme primitives [Bur94]. <p> These tools include tautology checking using Binary Decision Diagrams [Bry86] and, more recently, model checking techniques for state machine verification [CES86, BCM + 92, BCL + 94]. Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors <ref> [Hun92, SM95] </ref>, dedicated hardware for fault-tolerance [BY90, SB91], and many efforts in floating-point verification [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95]. Theorem prover based verifications are not always robust in the face of changes. A small change in the design may invalidate much of the correctness proof [Wil97]. <p> Theorem prover based verifications are not always robust in the face of changes. A small change in the design may invalidate much of the correctness proof [Wil97]. A notable effort is Hunt's verification of the FM9001 processor using nqthm <ref> [Hun92] </ref>. 2. Related Research 18 Hunt's verification strategy consists of a simulation model that animates designs expressed in a hardware description language. The verified design was subsequently fabricated in a VLSI implementation. The verification approach has subsequently been used successfully on commercial hardware devices [BKM96].
Reference: [IEE85] <institution> Standard for Binary Floating-Point Arithmetic, </institution> <year> 1985. </year> <note> ANSI/IEEE Std 754-1985. </note>
Reference-contexts: standards require support for addition, subtraction, multiplication, division, and square root with the requirement that each operation shall be performed as if it first produced an intermediate result correct to infinite precision and with unbounded range, and then that result rounded according to one of the modes . . . <ref> [IEE85, IEE87] </ref> This formalization has been extended to include a verification of a standard algorithm for providing IEEE compliant rounding [ML96].
Reference: [IEE87] <institution> Standard for Radix-Independent Floating-Point Arithmetic, </institution> <year> 1987. </year> <note> ANSI/IEEE Std 854-1987. BIBLIOGRAPHY 133 </note>
Reference-contexts: The other optimizations are verified using coinduction. Two different approaches are illustrated on the final optimization. 95 6. Floating Point Division 96 6.1 IEEE Floating-Point Arithmetic The top level in this development is a formalization of the IEEE-854 Standard for Radix-Independent Floating-Point Arithmetic using PVS <ref> [IEE87, Min95] </ref>. This formalization encompasses most of the standard, including definition of the four rounding modes. <p> standards require support for addition, subtraction, multiplication, division, and square root with the requirement that each operation shall be performed as if it first produced an intermediate result correct to infinite precision and with unbounded range, and then that result rounded according to one of the modes . . . <ref> [IEE85, IEE87] </ref> This formalization has been extended to include a verification of a standard algorithm for providing IEEE compliant rounding [ML96].
Reference: [Jac97] <author> Bart Jacobs. </author> <title> Behaviour-refinement of coalgebraic specifications with coinductive correctness proofs. </title> <booktitle> In TAPSOFT '97: Theory and Practice of Software Development, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Other applications include programming language semantics [MT91, Pit94]. Gimenez used coinductive types in Coq for the verification of an alternating bit protocol [Gim95]. Recently, Jacobs has explored coinductive verification techniques for class refinement in an object-oriented setting <ref> [Jac97] </ref>. There have been a number of recent efforts seeking to provide mechanized reasoning support for coinductive verification techniques. Paulson built up a framework for inductive and coinductive datatypes in Isabelle-HOL [Pau97]. Inductive types are expressed as least fixed points and coinductive types are expressed as greatest fixed points.
Reference: [Joh84] <author> Steven D. Johnson. </author> <title> Synthesis of Digital Design from Recursion Equations. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, </address> <year> 1984. </year> <note> ACM Distinguished Dissertation. </note>
Reference-contexts: When sharp is given a constant stream, it behaves as the identity function. 4 Streams as a representation of Hardware A system of stream equations provides a concise formal description of synchronous digital hardware <ref> [Joh84] </ref>. The key observation is that the stream constructor cs models the standard unit delay (or D-type flipflop) used in digital system design. The first argument to cs denotes the current contents of the register and the second argument is its input stream. <p> This standard model of sequential systems is often referred to as the Huffman model [Huf54] 1 and is depicted in Figure 4.1. Using the specification style developed by Johnson <ref> [Joh84] </ref>, this standard system is described by the equations S = cs (a; NS (I; S)) Where functions NS and OUT are the next-state and output functions lifted to streams using a two argument version of map. 1 Huffman's paper describes asynchronous sequential systems decomposed into combinational logic and delay elements. <p> Subsequent examples illustrate how to use corecursion and coinduction to represent and reason about some standard abstractions in hardware verification. Factorial A system of stream equations describing a hardware architecture to compute the factorial function is <ref> [Joh84] </ref>: X = cs (x; DCR (X)) READY = ZERO?(X) VALUE = Y 4. Streams as a representation of Hardware 56 At the first instant that READY is asserted, the VALUE signal contains x!. We use map to lift the decrement, multiply, and zero? functions to streams.
Reference: [JR97] <author> Bart Jacobs and Jan Rutten. </author> <title> A tutorial on (co)algebras and (co)induction. </title> <journal> EATCS Bulletin, </journal> <note> 1997. To appear, Available electronically from http://www.cs.kun.nl/~bart/PAPERS/JR.ps.Z. </note>
Reference-contexts: A proof of this principle in the universe of non-well-founded sets is on page 84 of [BM96]. Jacobs and Rutten use the fact that streams are a final coalgebra to justify this principle <ref> [JR97] </ref>. Here we directly show that two streams in a stream bisimulation are indistinguishable. Theorem 2 For n 2 N if x; y 2 A 1 and x R y for some bisimulation R, then hd (tl n (x)) = hd (tl n (y)). 3.
Reference: [JS90] <author> Geraint Jones and Mary Sheeran. </author> <title> Circuit design in Ruby. </title> <editor> In Jtrgen Staunstrup, editor, </editor> <booktitle> Formal Methods for VLSI Design, </booktitle> <pages> pages 13-70. </pages> <publisher> Elsevier Science Publishers B.V., </publisher> <year> 1990. </year>
Reference-contexts: Circuit components are defined as relations between signals; systems are built up via relational composition. The primary difference with other representations is that time is infinite in both directions, eliminating the distraction of an irrelevant initial state. The language was introduced by Jones and Sheeran <ref> [JS90] </ref>, and is particularly well suited to refining 2. Related Research 21 circuits with a regular structure. The Ruby design philosophy is similar to the underlying design philosophy for DRS, in that it supports a transformational approach to circuit design.
Reference: [JWB89] <author> Steven D. Johnson, R.M. Wehrmeister, and B. Bose. </author> <title> On the interplay of synthesis and verification: Experiments with the FM8501 processor description. </title> <editor> In Claesen, editor, </editor> <booktitle> Applied Formal Methods for Correct VLSI Design, </booktitle> <pages> pages 385-404. </pages> <publisher> Elsevier, </publisher> <year> 1989. </year> <month> IMEC </month> <year> 1989. </year>
Reference-contexts: During the above projects, it was recognized that a combination of design derivation with mechanized proof support would be superior to either approach individually <ref> [JWB89] </ref>. In the current study, hardware design using DRS is augmented using the PVS theorem proving system. 2.2 Overview of PVS PVS is a general purpose specification and verification system developed at SRI International [ORS92, ORSv95]. The PVS specification language is based on higher- order logic.
Reference: [Keu96] <author> Kurt Keutzer. </author> <title> The need for formal methods for integrated circuit design. </title> <editor> In Mandayam Srivas and Albert Camilleri, editors, </editor> <booktitle> Formal Methods in Computer-Aided Design, FMCAD '96, volume 1166 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-18, </pages> <address> Palo Alto, CA, </address> <month> November </month> <year> 1996. </year> <month> SpringerVerlag. </month>
Reference: [LO95] <author> M. Leeser and J. O'Leary. </author> <title> Verification of a subtractive radix-2 square root algorithm and implementation. </title> <booktitle> In Proceedings International Conference on Computer Design 1995 (ICCD '95), </booktitle> <pages> pages 526-531, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors [Hun92, SM95], dedicated hardware for fault-tolerance [BY90, SB91], and many efforts in floating-point verification <ref> [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95] </ref>. Theorem prover based verifications are not always robust in the face of changes. A small change in the design may invalidate much of the correctness proof [Wil97]. A notable effort is Hunt's verification of the FM9001 processor using nqthm [Hun92]. 2. <p> The first efforts targeted verified implementations of binary non-restoring algorithms. Leeser, O'Leary, et al. present a verification, using Nuprl, of a binary non-restoring square root algorithm and its implementation <ref> [OLHA94, LO95] </ref>. Verkest, et al. present a similar verification, using nqthm, of a binary non-restoring division algorithm [VCD94]. In response to the flaw in the Pentium, several researchers investigated theorem prover based verifications of SRT division hardware.
Reference: [LP93] <author> Fran~cois Leclerc and Christine Paulin-Mohring. </author> <title> Programming with streams in coq|a case study: The sieve of Eratosthenes. </title> <editor> In Henk Barendregt and Tobias Nipkow, editors, </editor> <title> Types for Proofs and Programs, </title> <booktitle> International Workshop TYPES '93, volume 806 of Lecture Notes in Computer Science, </booktitle> <pages> pages 191-212, </pages> <year> 1993. </year>
Reference-contexts: Related Research 22 corecursion may by justified by reduction to recursion [MD97]. Research in constructive type theory has also addressed the notion of types of infinite objects. The first treatments were by Mendler et al. [MPC86, Men87], with subsequent investigations by Coquand [Coq93]and Leclerc and Paulin-Mohring <ref> [LP93] </ref>. Applications of coinduction to verification have their root in process calculi such as CCS [Mil89]. Park appears to be among the first to explore the use of greatest fixed points as a verification strategy [Par80, Par81]. Other applications include programming language semantics [MT91, Pit94]. <p> Paulson built up a framework for inductive and coinductive datatypes in Isabelle-HOL [Pau97]. Inductive types are expressed as least fixed points and coinductive types are expressed as greatest fixed points. Leclerc and Paulin-Mohring have explored coinductive types using the Coq system <ref> [LP93] </ref>.
Reference: [LS91] <author> Charles E. Leiserson and James B. Saxe. </author> <title> Retiming synchronous circuitry. </title> <journal> Algorithmica, </journal> <volume> 6(1) </volume> <pages> 5-35, </pages> <year> 1991. </year>
Reference-contexts: A shorter maximum critical path in a design means that the maximum cycle time for the circuit is less, thus allowing a faster clock rate. Such transformations have been extensively studied <ref> [LS91] </ref>, and have made their way into practice. We use them here to illustrate the utility and general nature of coinductive proofs. This example moves a unary combinational function f through a multiplexor and a register where the register output is fed back into the mux.
Reference: [MD97] <author> Lawrence S. Moss and Norman Danner. </author> <title> On the foundations of corecursion. </title> <journal> Logic Journal of the IGPL, </journal> <volume> 5(2) </volume> <pages> 231-257, </pages> <year> 1997. </year> <note> BIBLIOGRAPHY 134 </note>
Reference-contexts: One such basis is Aczel's Special Final Coalgebra Theo- rem [Acz88]. Another is Barwise and Moss' Corecursion Theorem [BM96]. Recently, Moss and Danner have further explored foundational issues and have suggested that 2. Related Research 22 corecursion may by justified by reduction to recursion <ref> [MD97] </ref>. Research in constructive type theory has also addressed the notion of types of infinite objects. The first treatments were by Mendler et al. [MPC86, Men87], with subsequent investigations by Coquand [Coq93]and Leclerc and Paulin-Mohring [LP93].
Reference: [Mea55] <author> G. H. Mealy. </author> <title> A method for synthesizing sequential circuits. </title> <journal> Bell System Technical Journal, </journal> <volume> 34 </volume> <pages> 1045-1079, </pages> <month> September </month> <year> 1955. </year>
Reference-contexts: By restricting the input and state to finite types, these equations define a Mealy machine <ref> [Mea55] </ref>. By further restricting this model so that function out only depends on the state, these equations define a Moore machine [Moo56]. However, we are 4. Streams as a representation of Hardware 55 generally interested in countably infinite types such as the integers, rationals, and abstract data types.
Reference: [Mel88] <author> T. Melham. </author> <title> Abstraction mechanisms for hardware verification. </title> <editor> In Graham Birtwistle and P. A. Subramanyam, editors, </editor> <booktitle> VLSI Specification, Verification and Synthesis, </booktitle> <pages> pages 267-292. </pages> <publisher> Kluwer Academic Publishers, </publisher> <year> 1988. </year>
Reference-contexts: READY = ZERO?(X), VALUE = Y IN Y = cs (y, Z) & READY = ZERO?(X) & VALUE = Y Once again, the strategy (co-induct-and-simplify) was sufficient to prove that each of the streams X, Y, and Z satisfy the corresponding recursive stream equations. 4.2 Coinductive Proofs about Hardware Melham <ref> [Mel88] </ref> defines four basic abstractions used in hardware verification. Structural abstraction occurs when we hide the internal structure of a device and only reason about its black-box behavior. Behavioral abstraction occurs when we only partially specify a device's behavior.
Reference: [Men87] <author> N. P. Mendler. </author> <title> Recursive types and type constraints in second-order lambda calculus. </title> <booktitle> In Proceedings of the Second Symposium on Logic in Computer Science, </booktitle> <pages> pages 30-36, </pages> <year> 1987. </year>
Reference-contexts: Recently, Moss and Danner have further explored foundational issues and have suggested that 2. Related Research 22 corecursion may by justified by reduction to recursion [MD97]. Research in constructive type theory has also addressed the notion of types of infinite objects. The first treatments were by Mendler et al. <ref> [MPC86, Men87] </ref>, with subsequent investigations by Coquand [Coq93]and Leclerc and Paulin-Mohring [LP93]. Applications of coinduction to verification have their root in process calculi such as CCS [Mil89]. Park appears to be among the first to explore the use of greatest fixed points as a verification strategy [Par80, Par81].
Reference: [Mil89] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <booktitle> Series in Computer Science. Prentice/Hall International, </booktitle> <year> 1989. </year>
Reference-contexts: Research in constructive type theory has also addressed the notion of types of infinite objects. The first treatments were by Mendler et al. [MPC86, Men87], with subsequent investigations by Coquand [Coq93]and Leclerc and Paulin-Mohring [LP93]. Applications of coinduction to verification have their root in process calculi such as CCS <ref> [Mil89] </ref>. Park appears to be among the first to explore the use of greatest fixed points as a verification strategy [Par80, Par81]. Other applications include programming language semantics [MT91, Pit94]. Gimenez used coinductive types in Coq for the verification of an alternating bit protocol [Gim95].
Reference: [Min93] <author> Paul S. Miner. </author> <title> Verification of fault-tolerant clock synchronization systems. </title> <type> Technical Paper 3349, </type> <institution> NASA, Langley Research Center, Hampton, VA, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: Clock synchronization consists of periodically exchanging values and executing an averaging function so that the above properties are guaranteed. 5.2 The Verified Algorithm Schneider [Sch87] demonstrates that many fault-tolerant clock synchronization algorithms can be treated as refinements of a general paradigm. Shankar [Sha92] and Miner <ref> [Min93] </ref> have provided mechanically checked proofs of Schneider's paradigm. Miner's verification is the top-level specification for the circuit developed here. 5. <p> The fault-tolerant midpoint convergence function, cfn MID () = (F +1) + (NF ) % where (m) = the mth largest value in collection employed in the Welch and Lynch [WL88] clock synchronization algorithm, possesses the required properties of a convergence function <ref> [Min93] </ref>. 5.3 Behavioral Specification An abstract view of the behavioral specification is given in Figure 5.1 using the ASM chart notation from [PW87] . This corresponds to a top-level DRS specification. It establishes the control of the machine and identifies some of the registers, but leaves architectural components abstractly specified.
Reference: [Min95] <author> Paul S. Miner. </author> <title> Defining the IEEE-854 floating-point standard in PVS. </title> <type> Technical Memorandum 110167, </type> <institution> NASA, Langley Research Center, Hampton, VA, </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: The other optimizations are verified using coinduction. Two different approaches are illustrated on the final optimization. 95 6. Floating Point Division 96 6.1 IEEE Floating-Point Arithmetic The top level in this development is a formalization of the IEEE-854 Standard for Radix-Independent Floating-Point Arithmetic using PVS <ref> [IEE87, Min95] </ref>. This formalization encompasses most of the standard, including definition of the four rounding modes.
Reference: [MJ96] <author> Paul S. Miner and Steven D. Johnson. </author> <title> Verification of an optimized fault-tolerant clock synchronization circuit. </title> <editor> In Mary Sheeran and Satnam Singh, editors, </editor> <title> Designing Correct Circuits, Electronic Workshops in Computing. </title> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1996. </year> <note> http://www.springer.co.uk/ewic/workshops/DCC96. </note>
Reference-contexts: The optimization trades time for space in a clever manner. Verifi- cation of this optimization was previously presented in <ref> [MJ96] </ref>. Figure 5.5 illustrates the core circuit computing the convergence function from Section 5.4. The signal val is the output of a counter. The signals f1 and nf are boolean valued signals that 5. Fault-Tolerant Synchronization 83 5.
Reference: [ML96] <author> Paul S. Miner and James F. Leathrum, Jr. </author> <title> Verification of IEEE com-pliant subtractive division algorithms. </title> <editor> In Mandayam Srivas and Albert Camilleri, editors, </editor> <booktitle> Formal Methods in Computer-Aided Design, FMCAD '96, volume 1166 of Lecture Notes in Computer Science, </booktitle> <pages> pages 64-78, </pages> <address> Palo Alto, CA, </address> <month> November </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: Included in their work is a technique to verify a concrete representation of the lookup table. Miner and Leathrum provide a further generalization to the class of subtractive division algorithms and relate this class of algorithms to a floating-point standard <ref> [ML96] </ref>. This 2. Related Research 19 provides the entry point for the derivation activities presented in Chapter 6. Re- cently, the microcode for the floating point division and square root algorithms of the AMD5 K 86 T M microprocessor has been mechanically verified using the ACL2 theorem prover [BKM96]. <p> as if it first produced an intermediate result correct to infinite precision and with unbounded range, and then that result rounded according to one of the modes . . . [IEE85, IEE87] This formalization has been extended to include a verification of a standard algorithm for providing IEEE compliant rounding <ref> [ML96] </ref>. The next section presents a generalized subtractive division algorithm which, when composed with the rounding algorithm, provides IEEE compliant division. 6.2 The Verified Algorithm The class of subtractive division algorithms consists of several generalizations of the long division algorithm taught in elementary school.
Reference: [Moo56] <author> E. F. Moore. </author> <title> Gedanken-experiments on sequential machines. </title> <editor> In Claude Shannon and John McCarthy, editors, </editor> <booktitle> Automata Studies, number 34 in Annals of mathematics studies, </booktitle> <pages> pages 129-153. </pages> <publisher> Princeton University Press, </publisher> <year> 1956. </year>
Reference-contexts: (0; a; w) = a: F 1 (t + 1; a; w) = next state (F 1 (t; a; w); w (t)); F 2 (t; a; w) = out (F 1 (t; a; w)): When the set of states A is finite, this is a description of a Moore machine <ref> [Moo56] </ref>. It provides a rigorous mathematical description of synchronous hardware, and lends itself to inductive verification. However, this representation has the complication that the current state is represented as a function of the initial state and past history of the input stream. <p> By restricting the input and state to finite types, these equations define a Mealy machine [Mea55]. By further restricting this model so that function out only depends on the state, these equations define a Moore machine <ref> [Moo56] </ref>. However, we are 4. Streams as a representation of Hardware 55 generally interested in countably infinite types such as the integers, rationals, and abstract data types. This allows use of standard properties of these abstract types in refining the digital system architectures.
Reference: [MPC86] <author> N. P. Mendler, P. Panangaden, and R. L. Constable. </author> <title> Infinite objects in type theory. </title> <booktitle> In Proceedings of the First Symposium on Logic in Computer Science, </booktitle> <pages> pages 249-255, </pages> <year> 1986. </year> <note> BIBLIOGRAPHY 135 </note>
Reference-contexts: Recently, Moss and Danner have further explored foundational issues and have suggested that 2. Related Research 22 corecursion may by justified by reduction to recursion [MD97]. Research in constructive type theory has also addressed the notion of types of infinite objects. The first treatments were by Mendler et al. <ref> [MPC86, Men87] </ref>, with subsequent investigations by Coquand [Coq93]and Leclerc and Paulin-Mohring [LP93]. Applications of coinduction to verification have their root in process calculi such as CCS [Mil89]. Park appears to be among the first to explore the use of greatest fixed points as a verification strategy [Par80, Par81].
Reference: [MPJ94] <author> Paul S. Miner, Shyamsundar Pullela, and Steven D. Johnson. </author> <title> Interaction of formal design systems in the development of a fault-tolerant clock synchronization circuit. </title> <booktitle> In Proceedings 13th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 128-137, </pages> <publisher> Dana Point, </publisher> <address> CA, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: My experiences in proving hardware using this representation is that it distracts from the main verification goal. This structure is similar to that used in the PVS proofs of the clock synchronization circuit presented in <ref> [MPJ94] </ref>. In that verification effort, more time was spent dealing with quirks of the model than in verifying the refinement. The verification presented in [MPJ94] has been redone using coinduction and is presented in Chapter 5. Ruby is a relational algebra for digital hardware design. <p> This structure is similar to that used in the PVS proofs of the clock synchronization circuit presented in <ref> [MPJ94] </ref>. In that verification effort, more time was spent dealing with quirks of the model than in verifying the refinement. The verification presented in [MPJ94] has been redone using coinduction and is presented in Chapter 5. Ruby is a relational algebra for digital hardware design. Circuit components are defined as relations between signals; systems are built up via relational composition. <p> Traditionally, streams over A have been represented by [N ! A]. The initial efforts to reason about streams in PVS <ref> [MPJ94] </ref> used this representation. However, this choice of representation led to emphasis on proofs by induction, even though we were modeling objects that were defined (within DDD) using stream equations. As shown in the previous section, corecursive stream equations naturally lead to proofs using coinduction. <p> should be possible to simplify proof efforts that require synchronization between filter and sharp. 5 Fault-Tolerant Synchronization In the early explorations of the design framework depicted in Figure 1.1 (page 3), we developed a hardware design of a verified fault-tolerant clock synchronization algorithm using a combination of formal design techniques <ref> [MPJ94] </ref>. These techniques included using standard DDD transformations, an ad hoc refinement verified using PVS, and BDD-based tautology checking. The resulting hardware description was suitable for realization using a field-programmable gate-array. However, for the PVS verification of the ad hoc refinement presented in [MPJ94], the streams library had not yet been <p> using a combination of formal design techniques <ref> [MPJ94] </ref>. These techniques included using standard DDD transformations, an ad hoc refinement verified using PVS, and BDD-based tautology checking. The resulting hardware description was suitable for realization using a field-programmable gate-array. However, for the PVS verification of the ad hoc refinement presented in [MPJ94], the streams library had not yet been developed. Signals were represented by functions from time to the signal carrier type. The proofs were by induction, and were cluttered with several irrelevant proof obligations.
Reference: [MT91] <author> R. Milner and M. Tofte. </author> <title> Co-induction in relational semantics. </title> <journal> Theoretical Computer Science, </journal> <volume> 87 </volume> <pages> 209-220, </pages> <year> 1991. </year>
Reference-contexts: Applications of coinduction to verification have their root in process calculi such as CCS [Mil89]. Park appears to be among the first to explore the use of greatest fixed points as a verification strategy [Par80, Par81]. Other applications include programming language semantics <ref> [MT91, Pit94] </ref>. Gimenez used coinductive types in Coq for the verification of an alternating bit protocol [Gim95]. Recently, Jacobs has explored coinductive verification techniques for class refinement in an object-oriented setting [Jac97]. There have been a number of recent efforts seeking to provide mechanized reasoning support for coinductive verification techniques.
Reference: [OLHA94] <author> J. O'Leary, M. Leeser, J. Hickey, and M. Aagaard. </author> <title> Non-restoring in-teger square root: A case study in design by principled optimization. </title> <editor> In T. Kropf and R. Kumar, editors, </editor> <booktitle> Proc. 2nd International Conference on Theorem Provers in Circuit Design (TPCD94), volume 901 of Lecture Notes in Computer Science, </booktitle> <pages> pages 52-71, </pages> <address> Bad Herrenalb, Germany, </address> <month> September </month> <year> 1994. </year> <note> Springer Verlag. published 1995. </note>
Reference-contexts: Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors [Hun92, SM95], dedicated hardware for fault-tolerance [BY90, SB91], and many efforts in floating-point verification <ref> [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95] </ref>. Theorem prover based verifications are not always robust in the face of changes. A small change in the design may invalidate much of the correctness proof [Wil97]. A notable effort is Hunt's verification of the FM9001 processor using nqthm [Hun92]. 2. <p> The first efforts targeted verified implementations of binary non-restoring algorithms. Leeser, O'Leary, et al. present a verification, using Nuprl, of a binary non-restoring square root algorithm and its implementation <ref> [OLHA94, LO95] </ref>. Verkest, et al. present a similar verification, using nqthm, of a binary non-restoring division algorithm [VCD94]. In response to the flaw in the Pentium, several researchers investigated theorem prover based verifications of SRT division hardware.
Reference: [ORS92] <author> S. Owre, J. M. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification system. </title> <editor> In Deepak Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction (CADE), volume 607 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 748-752, </pages> <address> Saratoga, NY, June 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In the current study, hardware design using DRS is augmented using the PVS theorem proving system. 2.2 Overview of PVS PVS is a general purpose specification and verification system developed at SRI International <ref> [ORS92, ORSv95] </ref>. The PVS specification language is based on higher- order logic. Specifications consist of collections of theories that may be parameterized by types and constants. Theory parameters may be constrained by conditions. PVS has predicate subtyping and dependent types.
Reference: [ORS97] <author> Sam Owre, John Rushby, and N. Shankar. </author> <title> Integration in PVS: Tables, types, and model checking. </title> <editor> In Ed Brinksma, editor, </editor> <booktitle> Tools and Algorithms for the Construction and Analysis of Systems TACAS '97, volume 1217 of Lecture Notes in Computer Science, </booktitle> <pages> pages 366-383, </pages> <address> Enschede, The Netherlands, April 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Included in the analysis is an enumeration of all axioms used by the proof chain. There have been a number of exercises integrating various styles of reasoning within PVS. The most recent presentation of these efforts is reported in <ref> [ORS97] </ref>. 2.3 Research in Hardware Verification There are several competing approaches for formalizing the design process. At one end of the spectrum are general purpose mechanical theorem proving systems with expressive languages. Frequently, these systems require human interaction to produce machine checked proofs.
Reference: [ORSv95] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2):107125, </volume> <month> February </month> <year> 1995. </year>
Reference-contexts: In the current study, hardware design using DRS is augmented using the PVS theorem proving system. 2.2 Overview of PVS PVS is a general purpose specification and verification system developed at SRI International <ref> [ORS92, ORSv95] </ref>. The PVS specification language is based on higher- order logic. Specifications consist of collections of theories that may be parameterized by types and constants. Theory parameters may be constrained by conditions. PVS has predicate subtyping and dependent types.
Reference: [OS93] <author> Sam Owre and Natarajan Shankar. </author> <title> Abstract datatypes in PVS. </title> <type> Technical Report SRI-CSL-93-9R, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> Menlo Park, CA, </address> <month> December </month> <year> 1993. </year> <note> Extensively revised June 1997. </note>
Reference-contexts: can be declared as: word (n) : TYPE = [below (n) -&gt; bit] Use of this parameterized type is illustrated by the following declaration for byte: byte: TYPE = word (8) PVS also has a mechanism for defining recursive abstract datatypes that are freely generated by a set of constructors <ref> [OS93] </ref>. The abstract data mechanism generates a theory which declares an uninterpreted type constrained by a number of axioms. These axioms correspond to the properties that would arise from the least solution to the recursive type equations. PVS does not yet have a corresponding mechanism for corecursive datatypes. <p> As shown in the previous section, corecursive stream equations naturally lead to proofs using coinduction. The PVS streams library is modeled after the PVS abstract datatype mechanism <ref> [OS93] </ref>. The principal definition of the stream codatatype is parameterized by nonempty type ff. The type of streams over ff is defined as an uninterpreted nonempty type. As in the PVS abstract datatype mechanism, the type is constrained by axioms about uninterpreted constructor and accessor functions.
Reference: [Par80] <author> David Park. </author> <title> On the semantics of fair parallelism. In Bjtrner, editor, Abstract Software Specifications, </title> <booktitle> volume 86 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: Applications of coinduction to verification have their root in process calculi such as CCS [Mil89]. Park appears to be among the first to explore the use of greatest fixed points as a verification strategy <ref> [Par80, Par81] </ref>. Other applications include programming language semantics [MT91, Pit94]. Gimenez used coinductive types in Coq for the verification of an alternating bit protocol [Gim95]. Recently, Jacobs has explored coinductive verification techniques for class refinement in an object-oriented setting [Jac97].
Reference: [Par81] <author> David Park. </author> <title> Concurrency and automata on infinite sequnces. </title> <booktitle> In Proceedings of the 5th GI Conference, volume 104 of Lecture Notes in Computer Science, </booktitle> <pages> pages 167-183. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year> <note> BIBLIOGRAPHY 136 </note>
Reference-contexts: Applications of coinduction to verification have their root in process calculi such as CCS [Mil89]. Park appears to be among the first to explore the use of greatest fixed points as a verification strategy <ref> [Par80, Par81] </ref>. Other applications include programming language semantics [MT91, Pit94]. Gimenez used coinductive types in Coq for the verification of an alternating bit protocol [Gim95]. Recently, Jacobs has explored coinductive verification techniques for class refinement in an object-oriented setting [Jac97].
Reference: [Pau95] <author> Christine Paulin-Mohring. </author> <title> Circuits as streams in coq: Verification of a sequential multiplier. </title> <editor> In Stefano Berardi and Mario Coppo, editors, </editor> <title> Types for Proofs and Programs, </title> <booktitle> International Workshop TYPES '95, volume 1158 of Lecture Notes in Computer Science, </booktitle> <pages> pages 216-230, </pages> <year> 1995. </year>
Reference-contexts: Bronstein and Talcott present a string-functional semantics for reasoning about hardware using nqthm [BT90]. This supports describing hardware structure using a functional style similar to that used in DRS. Paulin-Mohring has used a coinductive representation of streams in Coq to explore their application in hardware verification <ref> [Pau95] </ref>. She illustrated the approach using Gordon's multiplier circuit [Gor86]. She did not explore use of bisimulations for showing circuit equivalence, but suggested it as an interesting possibility. Coupet- Grimal and Jakubiec have exploited the constructive nature of Coq to extract circuits from proofs [CJ96].
Reference: [Pau97] <author> Lawrence C. Paulson. </author> <title> Mechanizing coinduction and corecursion in higherorder logic. </title> <journal> Journal of Logic and Computation, </journal> <volume> 7 </volume> <pages> 175-204, </pages> <year> 1997. </year>
Reference-contexts: Recently, Jacobs has explored coinductive verification techniques for class refinement in an object-oriented setting [Jac97]. There have been a number of recent efforts seeking to provide mechanized reasoning support for coinductive verification techniques. Paulson built up a framework for inductive and coinductive datatypes in Isabelle-HOL <ref> [Pau97] </ref>. Inductive types are expressed as least fixed points and coinductive types are expressed as greatest fixed points. Leclerc and Paulin-Mohring have explored coinductive types using the Coq system [LP93].
Reference: [Pit94] <author> A.W. Pitts. </author> <title> A co-induction principle for recursively defined domains. </title> <journal> Theoretical Computer Science, </journal> <volume> 124(02) </volume> <pages> 195-220, </pages> <year> 1994. </year>
Reference-contexts: Applications of coinduction to verification have their root in process calculi such as CCS [Mil89]. Park appears to be among the first to explore the use of greatest fixed points as a verification strategy [Par80, Par81]. Other applications include programming language semantics <ref> [MT91, Pit94] </ref>. Gimenez used coinductive types in Coq for the verification of an alternating bit protocol [Gim95]. Recently, Jacobs has explored coinductive verification techniques for class refinement in an object-oriented setting [Jac97]. There have been a number of recent efforts seeking to provide mechanized reasoning support for coinductive verification techniques.
Reference: [Pra95] <author> Vaughn Pratt. </author> <title> Anatomy of the Pentium bug. </title> <editor> In P.D. Mosses, M. Nielsen, and M.I. Schwartzbach, editors, </editor> <booktitle> TAPSOFT '95: Theory and Practice of Software Development, volume 915 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-107, </pages> <address> Aarhus, Denmark, May 1995. </address> <publisher> Springer Verlag. </publisher>
Reference: [PW87] <author> Franklin P. Prosser and David E. Winkel. </author> <title> The Art of Digital Design. </title> <publisher> Prentice-Hall Inc., </publisher> <address> second edition, </address> <year> 1987. </year>
Reference-contexts: % where (m) = the mth largest value in collection employed in the Welch and Lynch [WL88] clock synchronization algorithm, possesses the required properties of a convergence function [Min93]. 5.3 Behavioral Specification An abstract view of the behavioral specification is given in Figure 5.1 using the ASM chart notation from <ref> [PW87] </ref> . This corresponds to a top-level DRS specification. It establishes the control of the machine and identifies some of the registers, but leaves architectural components abstractly specified. In particular, there is not an explicit representation for either or cfn.
Reference: [Ras96] <author> Ole Rasmussen. </author> <title> Ensuring correctness of Ruby transformations. </title> <editor> In Mary Sheeran and Satnam Singh, editors, </editor> <title> Designing Correct Circuits, Electronic Workshops in Computing. </title> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1996. </year> <note> http://www.springer.co.uk/ewic/workshops/DCC96. </note>
Reference-contexts: It is based upon Pure Ruby [Ros90], which consists of four basic constructs. In T-Ruby, all circuits and combinators are built up from the pure core. Rasmussen has developed a proof system called RubyZF using the Isabelle theorem prover <ref> [Ras96] </ref>. RubyZF enables mechanical verification of all T-Ruby transformations, and provides integrated reasoning support for verifying proof obligations generated by T-Ruby. The synchronous data-flow language Lustre has been used effectively in the design and verification of synchronous hardware [HCRP91, TP90].
Reference: [Ros90] <author> Lars Rossen. </author> <title> Ruby algebra. </title> <editor> In Geraint Jones and Mary Sheeran, editors, </editor> <booktitle> Designing Correct Circuits, </booktitle> <pages> pages 297-312. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: It has been demonstrated on a number of circuit designs, including a pipelined systolic correlator [She88]. Recently, Sharp and Rasmussen developed a strongly typed version called T-Ruby [SR97]. It is based upon Pure Ruby <ref> [Ros90] </ref>, which consists of four basic constructs. In T-Ruby, all circuits and combinators are built up from the pure core. Rasmussen has developed a proof system called RubyZF using the Isabelle theorem prover [Ras96].
Reference: [RSS96] <author> H. Rue, N. Shankar, and M. K. Srivas. </author> <title> Modular verification of SRT division. </title> <editor> In Rajeev Alur and Thomas A. Henzinger, editors, </editor> <booktitle> ComputerAided Verification, CAV '96, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 123-134. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors [Hun92, SM95], dedicated hardware for fault-tolerance [BY90, SB91], and many efforts in floating-point verification <ref> [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95] </ref>. Theorem prover based verifications are not always robust in the face of changes. A small change in the design may invalidate much of the correctness proof [Wil97]. A notable effort is Hunt's verification of the FM9001 processor using nqthm [Hun92]. 2. <p> Clarke, German, and Zhao used the Analytica theorem prover to verify Taylor's [Tay81] radix-4 SRT division circuit [CGZ96]. Their verification includes an abstract representation of the lookup table and a proof that it defines all necessary values for the quotient selection logic. Rue, Srivas, and Shankar <ref> [RSS96] </ref> generalize this work using PVS. They present a general verification of arbitrary radix SRT division algorithms, instantiate their theory with Taylor's radix-4 SRT division circuit, and verify a description of the hardware. Included in their work is a technique to verify a concrete representation of the lookup table.
Reference: [SB91] <author> Mandayam Srivas and Mark Bickford. </author> <title> Verification of the FtCayuga faulttolerant microprocessor system: Volume 1: A case study in theorem prover-based verification. </title> <type> Contractor Report 4381, </type> <institution> NASA, </institution> <month> July </month> <year> 1991. </year> <institution> Authors' affiliation: ORA Corporation, </institution> <address> Ithaca, NY. </address>
Reference-contexts: Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors [Hun92, SM95], dedicated hardware for fault-tolerance <ref> [BY90, SB91] </ref>, and many efforts in floating-point verification [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95]. Theorem prover based verifications are not always robust in the face of changes. A small change in the design may invalidate much of the correctness proof [Wil97].
Reference: [Sch87] <author> Fred B. Schneider. </author> <title> Understanding protocols for Byzantine clock synchro-nization. </title> <type> Technical Report 87-859, </type> <institution> Department of Computer Science, Cornell University, </institution> <address> Ithaca, NY, </address> <month> August </month> <year> 1987. </year>
Reference-contexts: Clock synchronization consists of periodically exchanging values and executing an averaging function so that the above properties are guaranteed. 5.2 The Verified Algorithm Schneider <ref> [Sch87] </ref> demonstrates that many fault-tolerant clock synchronization algorithms can be treated as refinements of a general paradigm. Shankar [Sha92] and Miner [Min93] have provided mechanically checked proofs of Schneider's paradigm. Miner's verification is the top-level specification for the circuit developed here. 5. <p> For many of the published convergence functions, it is unnecessary to alter the mechanism for capturing readings of remote clocks in a sorted list. Any of the following convergence functions could be used instead of the fault-tolerant midpoint (the names are from Schneider <ref> [Sch87] </ref>): Egocentric Average, Fast Convergence Algorithm, or Fault- tolerant Average. Other algorithms, such as that by Srikanth and Toueg [ST87], do not fit as cleanly into this specification. Other portions of the algorithm depend upon the choice of convergence function.
Reference: [SD96] <author> Pierre Sparaco and Michael Dornheim. </author> <title> Ariane probe seeks cause of sudden pitch and yaw. </title> <booktitle> Aviation Week & Space Technology, </booktitle> <volume> 144(24) </volume> <pages> 18-21, </pages> <month> June 10, </month> <year> 1996. </year> <note> BIBLIOGRAPHY 137 </note>
Reference: [SGGH93] <author> James B. Saxe, Stephen J. Garland, John V. Guttag, and James J. Horning. </author> <title> Using transformations and verification in circuit design. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 3(3) </volume> <pages> 181-210, </pages> <year> 1993. </year>
Reference: [Sha92] <author> Natarajan Shankar. </author> <title> Mechanical verification of a generalized protocol for Byzantine fault-tolerant clock synchronization. In Second International Symposium on Formal Techniques in Real Time and Fault Tolerant Systems, </title> <booktitle> volume 571 of Lecture Notes in Computer Science, </booktitle> <pages> pages 217-236. </pages> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: Clock synchronization consists of periodically exchanging values and executing an averaging function so that the above properties are guaranteed. 5.2 The Verified Algorithm Schneider [Sch87] demonstrates that many fault-tolerant clock synchronization algorithms can be treated as refinements of a general paradigm. Shankar <ref> [Sha92] </ref> and Miner [Min93] have provided mechanically checked proofs of Schneider's paradigm. Miner's verification is the top-level specification for the circuit developed here. 5.
Reference: [She88] <editor> Mary Sheeran. Retiming and slowdown in Ruby. In George J. Milne, editor, </editor> <booktitle> The Fusion of Hardware Design and Verification, </booktitle> <pages> pages 289-308. </pages> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Algebraic Approaches A number of algebraic approaches have been proposed for formal reasoning about digital hardware design. In addition to the design derivation tools discussed above, there is the Ruby design algebra <ref> [She88] </ref> and the work of Harman and Tucker [HT96] 2. Related Research 20 Harman and Tucker present an algebraic model of synchronous digital hardware. The general hardware representation is by iterated maps. <p> Related Research 21 circuits with a regular structure. The Ruby design philosophy is similar to the underlying design philosophy for DRS, in that it supports a transformational approach to circuit design. It has been demonstrated on a number of circuit designs, including a pipelined systolic correlator <ref> [She88] </ref>. Recently, Sharp and Rasmussen developed a strongly typed version called T-Ruby [SR97]. It is based upon Pure Ruby [Ros90], which consists of four basic constructs. In T-Ruby, all circuits and combinators are built up from the pure core.
Reference: [Sho78] <author> Robert E. Shostak. </author> <title> An algorithm for reasoning about equality. </title> <journal> Communications of the ACM, </journal> <volume> 21(7) </volume> <pages> 583-585, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: PVS does not yet have a corresponding mechanism for corecursive datatypes. PVS provides an interactive theorem proving environment using a Gentzen style sequent calculus presentation of the proof goals. At the core of PVS's prover is a collection of decision procedures combined using a technique developed by Shostak <ref> [Sho78, Sho84, CLS96] </ref>. This eases some of the more burdensome aspects of interacting with a mechanical theorem prover. Most simple arithmetic results are discharged by invoking the decision procedures. The user rarely needs to direct the prover when faced with simple facts of arithmetic. PVS has a powerful conditional rewriter.
Reference: [Sho84] <author> Robert E. Shostak. </author> <title> Deciding combinations of theories. </title> <journal> Journal of the ACM, </journal> <volume> 31(1) </volume> <pages> 1-12, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: PVS does not yet have a corresponding mechanism for corecursive datatypes. PVS provides an interactive theorem proving environment using a Gentzen style sequent calculus presentation of the proof goals. At the core of PVS's prover is a collection of decision procedures combined using a technique developed by Shostak <ref> [Sho78, Sho84, CLS96] </ref>. This eases some of the more burdensome aspects of interacting with a mechanical theorem prover. Most simple arithmetic results are discharged by invoking the decision procedures. The user rarely needs to direct the prover when faced with simple facts of arithmetic. PVS has a powerful conditional rewriter.
Reference: [SM95] <author> Mandayam K. Srivas and Steven P. Miller. </author> <title> Applying formal verification to a commercial microprocessor. </title> <editor> In Steven D. Johnson, editor, </editor> <booktitle> CHDL '95: 12th Conference on Computer Hardware Description Languages and their Applications, </booktitle> <pages> pages 493-502, </pages> <address> Chiba, Japan, </address> <month> August </month> <year> 1995. </year> <note> Proceedings published in a single volume jointly with ASP-DAC '95, CHDL '95, and VLSI '95, IEEE Catalog no. 95TH8102. </note>
Reference-contexts: These tools include tautology checking using Binary Decision Diagrams [Bry86] and, more recently, model checking techniques for state machine verification [CES86, BCM + 92, BCL + 94]. Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors <ref> [Hun92, SM95] </ref>, dedicated hardware for fault-tolerance [BY90, SB91], and many efforts in floating-point verification [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95]. Theorem prover based verifications are not always robust in the face of changes. A small change in the design may invalidate much of the correctness proof [Wil97]. <p> The verified design was subsequently fabricated in a VLSI implementation. The verification approach has subsequently been used successfully on commercial hardware devices [BKM96]. Another significant effort is the verification of the microcode of a set of instructions of the Rockwell-Collins AAMP5 microprocessor in PVS <ref> [SM95] </ref>. The AAMP5 is a modern microprocessor designed for aerospace applications. The verification activity uncovered some errors that had been seeded in the microcode to test the effectiveness of theorem proving techniques.
Reference: [SR97] <author> Robin Sharp and Ole Rasmussen. </author> <title> The T-Ruby design system. Formal Methods in System Design, </title> <note> 1997. In press, contact osr@id.dtu.dk. </note>
Reference-contexts: It has been demonstrated on a number of circuit designs, including a pipelined systolic correlator [She88]. Recently, Sharp and Rasmussen developed a strongly typed version called T-Ruby <ref> [SR97] </ref>. It is based upon Pure Ruby [Ros90], which consists of four basic constructs. In T-Ruby, all circuits and combinators are built up from the pure core. Rasmussen has developed a proof system called RubyZF using the Isabelle theorem prover [Ras96].
Reference: [ST87] <author> T.K. Srikanth and S. Toueg. </author> <title> Optimal clock synchronization. </title> <journal> Journal of the ACM, </journal> <volume> 34(3) </volume> <pages> 626-645, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Any of the following convergence functions could be used instead of the fault-tolerant midpoint (the names are from Schneider [Sch87]): Egocentric Average, Fast Convergence Algorithm, or Fault- tolerant Average. Other algorithms, such as that by Srikanth and Toueg <ref> [ST87] </ref>, do not fit as cleanly into this specification. Other portions of the algorithm depend upon the choice of convergence function. For the fault-tolerant midpoint convergence function, there are enough readings to compute the convergence function whenever there have been signals from at least N F other clocks.
Reference: [Tay81] <author> George S. Taylor. </author> <title> Compatible hardware for division and square root. </title> <booktitle> In Proceedings 5th Symposium on Computer Arithmetic, </booktitle> <pages> pages 127-134, </pages> <year> 1981. </year>
Reference-contexts: Verkest, et al. present a similar verification, using nqthm, of a binary non-restoring division algorithm [VCD94]. In response to the flaw in the Pentium, several researchers investigated theorem prover based verifications of SRT division hardware. Clarke, German, and Zhao used the Analytica theorem prover to verify Taylor's <ref> [Tay81] </ref> radix-4 SRT division circuit [CGZ96]. Their verification includes an abstract representation of the lookup table and a proof that it defines all necessary values for the quotient selection logic. Rue, Srivas, and Shankar [RSS96] generalize this work using PVS. <p> Each of these optimizations is verified using coinduction. Redundant Representation The first technique for improving the performance of the quotient accumulation sub-circuit was presented in Taylor <ref> [Tay81] </ref>. The quotient digits are represented using a sign and magnitude representation. For a radix-r algorithm, jqj &lt; r. Depending upon the sign of the quotient digit, the magnitude is appended to either a positive or negative shift register.
Reference: [TP90] <author> Ghislaine Thuau and Daniel Pilaud. </author> <title> Using the declarative language LUSTRE for circuit verification. </title> <editor> In Geraint Jones and Mary Sheeran, editors, </editor> <booktitle> Designing Correct Circuits, </booktitle> <pages> pages 313-331. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: RubyZF enables mechanical verification of all T-Ruby transformations, and provides integrated reasoning support for verifying proof obligations generated by T-Ruby. The synchronous data-flow language Lustre has been used effectively in the design and verification of synchronous hardware <ref> [HCRP91, TP90] </ref>. The language was originally developed for the specification and verification of real-time systems and was inspired by the dataflow language Lucid [WA85]. Lustre is a declarative language where expressions represent sequences of values. Systems are specified using a collection of equations.
Reference: [TP93] <author> Wilfredo Torres-Pomales. </author> <title> A hardware implementation of a provably cor-rect design of a fault-tolerant clock synchronization circuit. </title> <type> Technical BIBLIOGRAPHY 138 Memorandum 109001, </type> <institution> NASA, Langley Research Center, Hampton, VA, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: The circuit performed as expected on all test cases. 5. Fault-Tolerant Synchronization 94 The second phase of testing consisted of incorporating the design in Torres- Pomales' four node synchronization system. Three of the nodes were Torres-Pomales' original design <ref> [TP93] </ref>, the fourth was the VLSI implementation described in this chapter. The system ran at 10Mhz. We ran the same suite of tests as Torres-Pomales had performed on his implementation of the optimized synchronization circuit [TP95].
Reference: [TP95] <author> Wilfredo Torres-Pomales. </author> <title> An optimized implementation of a fault-tolerant clock synchronization circuit. </title> <type> Technical Memorandum 109176, </type> <institution> NASA, Langley Research Center, Hampton, VA, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: (ctl; false; (cnt (N F )); (cnt (N F )))) (NF ) = reg (?; mux (nf; val; (NF ) )) $ 2 sel-cfn = sel (ctl; ?; ?; cfn) A circuit diagram corresponding to this system of stream equations is given in Fig- ure 5.4. 5.5 An Optimization Torres-Pomales <ref> [TP95] </ref> discovered a more efficient realization of the core synchronization circuit. The optimization trades time for space in a clever manner. Verifi- cation of this optimization was previously presented in [MJ96]. Figure 5.5 illustrates the core circuit computing the convergence function from Section 5.4. <p> Three of the nodes were Torres-Pomales' original design [TP93], the fourth was the VLSI implementation described in this chapter. The system ran at 10Mhz. We ran the same suite of tests as Torres-Pomales had performed on his implementation of the optimized synchronization circuit <ref> [TP95] </ref>. There are three main test cases: initialization, recovery from a single transient fault, and recovery from massively correlated transient faults. The VLSI implementation performed perfectly on all tests.
Reference: [VCD94] <author> D. Verkest, L. Claesen, and H. De Man. </author> <title> A proof of the nonrestoring division algorithm and its implementation on an ALU. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 4 </volume> <pages> 5-31, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Theorem-Prover based System Verification There are several significant examples of theorem-prover based verifications in the literature. Examples include microprocessors [Hun92, SM95], dedicated hardware for fault-tolerance [BY90, SB91], and many efforts in floating-point verification <ref> [BKM96, CGZ96, RSS96, OLHA94, LO95, VCD94, Har95] </ref>. Theorem prover based verifications are not always robust in the face of changes. A small change in the design may invalidate much of the correctness proof [Wil97]. A notable effort is Hunt's verification of the FM9001 processor using nqthm [Hun92]. 2. <p> The first efforts targeted verified implementations of binary non-restoring algorithms. Leeser, O'Leary, et al. present a verification, using Nuprl, of a binary non-restoring square root algorithm and its implementation [OLHA94, LO95]. Verkest, et al. present a similar verification, using nqthm, of a binary non-restoring division algorithm <ref> [VCD94] </ref>. In response to the flaw in the Pentium, several researchers investigated theorem prover based verifications of SRT division hardware. Clarke, German, and Zhao used the Analytica theorem prover to verify Taylor's [Tay81] radix-4 SRT division circuit [CGZ96].
Reference: [WA85] <author> William W. Wadge and Edward A. Ashcroft. </author> <title> Lucid, The Dataflow Programming Language. </title> <publisher> Academic Press, </publisher> <year> 1985. </year>
Reference-contexts: The synchronous data-flow language Lustre has been used effectively in the design and verification of synchronous hardware [HCRP91, TP90]. The language was originally developed for the specification and verification of real-time systems and was inspired by the dataflow language Lucid <ref> [WA85] </ref>. Lustre is a declarative language where expressions represent sequences of values. Systems are specified using a collection of equations.
Reference: [WC91] <author> Robert M. Wehrmeister and Ingo Cyliax. </author> <title> Logic Engine User Manual. </title> <institution> Indiana Univeristy Computer Science Department, Bloomington, Indiana, </institution> <month> June </month> <year> 1991. </year> <note> URL http://www.cs.indiana.edu/classes/c421/man. </note>
Reference-contexts: The resulting circuit, depicted in There were two phases of testing. The initial tests were conducted using a Logic Engine (LE) as the the test environment <ref> [WC91] </ref>. Test signals were generated using a Scheme interface to the LE written by M. Esen Tuna. The test cases varied the length of the synchronization interval, varied the arrival times of signals from remote clocks, and exercised the full ranges of the counters on the chip.
Reference: [Wil97] <author> Matthew M. Wilding. </author> <title> Robust computer system proofs in PVS. </title> <editor> In C. Michael Holloway and Kelly J. Hayhurst, editors, </editor> <booktitle> Fourth NASA Langley Formal Methods Workshop, </booktitle> <pages> pages 177-184, </pages> <month> September </month> <year> 1997. </year> <note> NASA Conference Publication 3356. </note>
Reference-contexts: Theorem prover based verifications are not always robust in the face of changes. A small change in the design may invalidate much of the correctness proof <ref> [Wil97] </ref>. A notable effort is Hunt's verification of the FM9001 processor using nqthm [Hun92]. 2. Related Research 18 Hunt's verification strategy consists of a simulation model that animates designs expressed in a hardware description language. The verified design was subsequently fabricated in a VLSI implementation.
Reference: [WL88] <author> J. Lundelius Welch and N. Lynch. </author> <title> A new fault-tolerant algorithm for clock synchronization. </title> <journal> Information and Computation, </journal> <volume> 77(1) </volume> <pages> 1-36, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: The fault-tolerant midpoint convergence function, cfn MID () = (F +1) + (NF ) % where (m) = the mth largest value in collection employed in the Welch and Lynch <ref> [WL88] </ref> clock synchronization algorithm, possesses the required properties of a convergence function [Min93]. 5.3 Behavioral Specification An abstract view of the behavioral specification is given in Figure 5.1 using the ASM chart notation from [PW87] . This corresponds to a top-level DRS specification.

References-found: 93

