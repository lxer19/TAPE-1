URL: http://www.cs.wustl.edu/~schmidt/C++-report-doc-perf.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: http://www.cs.wustl.edu
Email: harrison@cs.wustl.edu and schmidt@cs.wustl.edu  
Phone: (314) 935-7538  
Title: Evaluating the Performance of OO Network Programming Toolkits  
Author: Timothy H. Harrison and Douglas C. Schmidt 
Address: St. Louis, MO 63130  
Affiliation: Department of Computer Science Washington University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Object Management Group, </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <editor> 2.0 ed., </editor> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Introduction For the past several years, the C++ Report has published many articles on the Common Object Request Broker Architecture (CORBA) <ref> [1] </ref>, which is an open standard for distributed object computing (DOC). These articles have focused on the features and components in CORBA that automate common networking tasks such as parameter marshalling, object location, and object activation. <p> This article concentrates on performance issues related to using CORBA and other IPC mechanisms to transfer large amounts of data over low-speed and high-speed networks. DOC frameworks such as CORBA <ref> [1] </ref>, OODCE [2], and OLE/COM [3] are well-suited for applications that exchange richly typed data via request/response or oneway communication. However, current implementations of DOC frameworks are less suitable for an important class of performance-sensitive applications that stream data over high-speed networks.
Reference: [2] <author> J. Dilley, OODCE: </author> <title> A C++ Framework for the OSF Distributed Computing Environment, </title> <booktitle> in Proceedings of the Winter Usenix Conference, USENIX Association, </booktitle> <month> January </month> <year> 1995. </year>
Reference-contexts: This article concentrates on performance issues related to using CORBA and other IPC mechanisms to transfer large amounts of data over low-speed and high-speed networks. DOC frameworks such as CORBA [1], OODCE <ref> [2] </ref>, and OLE/COM [3] are well-suited for applications that exchange richly typed data via request/response or oneway communication. However, current implementations of DOC frameworks are less suitable for an important class of performance-sensitive applications that stream data over high-speed networks.
Reference: [3] <institution> Microsoft Press, Redmond, WA, </institution> <note> Object Linking and Embedding Version 2 (OLE2) Programmer's Reference, Volumes 1 and 2, </note> <year> 1993. </year>
Reference-contexts: This article concentrates on performance issues related to using CORBA and other IPC mechanisms to transfer large amounts of data over low-speed and high-speed networks. DOC frameworks such as CORBA [1], OODCE [2], and OLE/COM <ref> [3] </ref> are well-suited for applications that exchange richly typed data via request/response or oneway communication. However, current implementations of DOC frameworks are less suitable for an important class of performance-sensitive applications that stream data over high-speed networks.
Reference: [4] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: These lower-level interfaces are efficient since they omit unnecessary functionality (such as presentation layer conversions for ASCII data). They also allow fine-grained control of memory management, protocol buffering, demultiplexing, and flow control. However, conventional low-level network programming interfaces are also non-portable and error-prone <ref> [4] </ref>. This complicates programming and permits subtle run-time errors. For instance, communication endpoints in the socket interface are identified by weakly-typed integer handles (also known as socket descriptors). Weak type-checking increases the potential for run-time errors since compilers cannot detect or prevent improper use of handles. <p> Our solution has been to integrate higher-level DOC frameworks with high-performance object-oriented encapsulations of lower-level network programming interfaces (such as the ACE C++ wrappers for sockets described in <ref> [4] </ref>). We've built a framework that combines CORBA and the ACE C++ wrappers and used it for a production high-speed tel-eradiology system that transfers large, multi-Mbyte medical images over ATM [6]. In this system, CORBA is used as a signaling mechanism to identify endpoints of communication in a location-independent manner.
Reference: [5] <author> G. Blaine, M. Boyd, and S. Crider, </author> <title> Project Spectrum: Scalable Bandwidth for the BJC Health System, </title> <journal> HIMSS, Health Care Communications, </journal> <pages> pp. 71-81, </pages> <year> 1994. </year>
Reference-contexts: The network programming mechanisms compared below include C sockets, ACE C++ wrappers for sockets, and two implementations of CORBA. The benchmark tests are modeled after performance-sensitive applications written by the authors for an enterprise-wide medical imaging system that transports multi-megabyte radiology images across high-speed ATM LANs and WANs <ref> [5, 6] </ref>. 2 Performance Experiments 2.1 Test Platform and Benchmarks The performance results in this section were collected using a Bay Networks LattisCell 10114 ATM switch connected to a cluster of uni-processor SPARCstation 20 Model 5Os (shown in Figure 1). The LattisCell 10114 is a 16 Port, OC3 155Mbs/port switch.
Reference: [6] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> in Proceedings of the 2 nd Conference on Object-Oriented Technologies and Systems, </booktitle> <institution> (Toronto, Canada), USENIX, </institution> <month> June </month> <year> 1996. </year>
Reference-contexts: The network programming mechanisms compared below include C sockets, ACE C++ wrappers for sockets, and two implementations of CORBA. The benchmark tests are modeled after performance-sensitive applications written by the authors for an enterprise-wide medical imaging system that transports multi-megabyte radiology images across high-speed ATM LANs and WANs <ref> [5, 6] </ref>. 2 Performance Experiments 2.1 Test Platform and Benchmarks The performance results in this section were collected using a Bay Networks LattisCell 10114 ATM switch connected to a cluster of uni-processor SPARCstation 20 Model 5Os (shown in Figure 1). The LattisCell 10114 is a 16 Port, OC3 155Mbs/port switch. <p> The need for hooks also surfaces when trying to integrate multiple event loops. ORB event loops must be accessible if developers are to use CORBA for large-scale projects that involve other tools (such as GUI event loops, which typically use their own event loops <ref> [6] </ref>). Thus, ORB event loops must either be able to surrender control to another event loop or assume control of event loops running in the same process space. The most stubborn event loop typically wins. <p> We've built a framework that combines CORBA and the ACE C++ wrappers and used it for a production high-speed tel-eradiology system that transfers large, multi-Mbyte medical images over ATM <ref> [6] </ref>. In this system, CORBA is used as a signaling mechanism to identify endpoints of communication in a location-independent manner. The ACE C++ wrappers are then used to establish point-to-point TCP connections and transmit bulk data efficiently across the connections.
Reference: [7] <author> D. Ritchie, </author> <title> A Stream Input-Output System, </title> <journal> AT&T Bell Labs Technical Journal, </journal> <volume> vol. 63, </volume> <pages> pp. 311-324, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: The SunOS 5.4 TCP/IP protocol stack is implemented using the STREAMS communication framework <ref> [7] </ref>. Each SPARCstation 20 has 64 Mbytes of RAM and an ENI-155s-MF ATM adaptor card, which supports 155 Megabits per-sec (Mbps) SONET mul-timode fiber. The Maximum Transmission Unit (MTU) on the ENI ATM adaptor is 9,180 bytes.
Reference: [8] <author> USNA, TTCP: </author> <title> a test of TCP and UDP Performance, </title> <month> Dec </month> <year> 1984. </year>
Reference-contexts: This allows up to 8 connections per card. Data for the experiments was produced and consumed by an extended version of the widely available ttcp <ref> [8] </ref> protocol benchmarking tool. This tool measures end-to-end data transfer throughput in Mbps from a transmitter process to a remote receiver process. The flow of user data is unidirectional, with the transmitter flooding the receiver with a user-specified number of data buffers.
Reference: [9] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: It uses C socket calls to transfer and receive data via TCP/IP. * ACE C++ version this version replaces all C socket calls in ttcp with the C++ wrappers for sockets provided by the ACE network programming components (version 3.2) <ref> [9] </ref>.
Reference: [10] <author> A. Gokhale and D. C. Schmidt, </author> <title> Measuring the Performance of Communication Middleware on High-Speed Networks, </title> <booktitle> in Proceedingsof SIGCOMM '96, </booktitle> <address> (Stanford, CA), </address> <publisher> ACM, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: Figure 7 3 When when transfering richly-typed data instead of the untyped-data used in the ttcp tests, CORBA implementations incur much higher overhead, achieving only around 30 percent of the performance of hand-crafted C and C++ marshalling <ref> [10] </ref>. 5 lists the functions where the most time was spent sending and receiving 64 Mbytes using 128 K data buffers and 64 K socket queues. <p> Hopefully, this will encourage vendors to optimize their ORBs for streaming performance-sensitive applications running over high-speed networks. Key areas of optimization include data copying and data inspection, presentation layer conversions, memory management, and receiver-side demultiplexing and dispatching <ref> [10] </ref>. In particular, implementations must reduce the number of times that large data buffers are copied in the endsystems. However, users can take steps to increase the performance of their ORBs.
Reference: [11] <author> J. R. Cox, W. D. Richard, K. Krieger, and B. Gottlieb, </author> <title> The Washington University Multimedia System, </title> <booktitle> in ACM Multimedia System, </booktitle> <pages> pp. 120-131, </pages> <publisher> Springer-Verlag, </publisher> <month> Jan. </month> <year> 1993. </year> <month> 8 </month>
Reference-contexts: If that's still not enough, and you don't need reliability or portability, bypass TCP/IP and program directly to the high-speed data link layer (e.g., ATM or FDDI) and/or get hardware support for your data streams. This approach is often used in high-speed video-on-demand systems <ref> [11] </ref>. On the other hand, if your requirements call for flexibility, maintainability, and reusability, you should consider a higher-level DOC framework such as CORBA or Network OLE.
References-found: 11

