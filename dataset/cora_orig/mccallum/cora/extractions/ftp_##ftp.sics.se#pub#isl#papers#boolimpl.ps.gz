URL: ftp://ftp.sics.se/pub/isl/papers/boolimpl.ps.gz
Refering-URL: http://www.sics.se/isl/sicstus2.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Boolean Constraints in SICStus Prolog  
Abstract: Mats Carlsson Swedish Institute of Computer Science Box 1263, S-164 28, KISTA, Sweden SICS technical report T91:09 November 1, 1994 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. B. Akers. </author> <title> Binary decision diagrams. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-27:509-516, </volume> <month> June </month> <year> 1978. </year>
Reference-contexts: Furthermore all isomorphic subgraphs have been merged. BDDs have been described at length in the literature <ref> [1, 5, 4, 3, 9] </ref>. <p> A solution to this problem, suggested in <ref> [1] </ref> and [9] and elsewhere, consists in typing the edges as positive or negative in the BDDs. Unless restrictions are placed on where negated edges can be placed, the representation is not canonical any more, however.
Reference: [2] <author> Karen Appleby, Mats Carlsson, Seif Haridi, and Dan Sahlin. </author> <title> Garbage Collection for Prolog Based on WAM. </title> <journal> Communications of the ACM, </journal> <volume> 31(6) </volume> <pages> 719-741, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Similarly to the unique-table, the computed-table manager is notified when garbage collections and stack shifts occur and takes backtracking into account. When a garbage collection has occurred, the part of the computed-table that corresponds to the segment of the heap that was subject to garbage collection <ref> [2] </ref> is erased.
Reference: [3] <author> Jean P. Billon. </author> <title> Perfect normal forms for discrete functions. BULL Research Report No. </title> <type> 87019, </type> <institution> Bull Research Center, </institution> <month> June </month> <year> 1987. </year>
Reference-contexts: Furthermore all isomorphic subgraphs have been merged. BDDs have been described at length in the literature <ref> [1, 5, 4, 3, 9] </ref>. <p> Otherwise, T and E are the BDDs representing the negated cofactors f I and f I . In either case, T is restricted to be tagged positive or to be the constant 1, to guarantee canonicity. The same rule is used in <ref> [3] </ref> and elsewhere. Thus, we are actually not typing the edges of the graph but the nodes themselves. Although we do not get the space reduction that genuine typed edges would achieve, we can still achieve constant-time negation and antivalence.
Reference: [4] <author> K. S. Brace, R. L. Rudell, and R. E. Bryant. </author> <title> Efficient implementation of a bdd package. </title> <booktitle> In Proceedings of the 27th Design Automation Conference, </booktitle> <pages> pages 40-45. </pages> <address> ACM/IEEE, </address> <year> 1990. </year>
Reference-contexts: Furthermore all isomorphic subgraphs have been merged. BDDs have been described at length in the literature <ref> [1, 5, 4, 3, 9] </ref>. <p> The efficiency of this highly recursive function can be vastly improved by a number of techniques <ref> [4] </ref>. These techniques are described below. 5.1.1 Ite Function Memory The most significant device is a function memory for Ite which maps the three argument nodes F , G, H to the result node Ite (F; G; H) once this result has been computed. <p> When a garbage collection has occurred, the part of the computed-table that corresponds to the segment of the heap that was subject to garbage collection [2] is erased. With the computed-table we can formulate Ite as in <ref> [4] </ref>: Ite (F; G; H) if (Z = base case) return Z; else if (Z = computed-table (fF; G; H g) return Z; else f let v = TopVar (fF; G; Hg); let T = Ite (F v ; G v ; H v ); f let Z = T ; <p> The complexity of the above formulation is shown in <ref> [4] </ref> to be O (jF j jGj jH j) but is claimed by the authors to be closer to the size of the resulting function. 5.1.2 Standard Triples For given parameters F 1 ; F 2 ; F 3 there exist in general a large number of triples G 1 ; <p> To improve the hit rate of the computed-table and to reduce its redundancy the authors of <ref> [4] </ref> define define a set of rewrite rules on Ite calls that transforms them to a standard form. The rewrite conceptually takes place at entry to the Ite function. In the function body, the rewritten arguments are used instead of the original ones. <p> Ite (F; F ; F ) ! 0 6 Ite (F; G; 0) ! Ite (G; F; 0); F &gt; G Ite (F; G; F ) ! Ite (F; G; 0) Ite (F; G; G) ! Ite (G; F; F ); F &gt; G The rules below were used in <ref> [4] </ref>. We chose not to use them, since preliminary measurements indicated that the decrease in computed-table growth was outweighed by an increase in the number of nodes created. This is probably due to our lack of genuine typed edges. <p> This is probably due to our lack of genuine typed edges. Ite (F; G; H) ! Ite (F; G; H) Finally, the rules below prevent a lot of shallow recursion and so save space in the computed-table. A special case of the first rule was quoted in <ref> [4] </ref>. <p> Notice that in the absence of universally quantified variables, there would be scope for significant optimizations of this algorithm, using a variant of the Ite function specialized to return 0 or 1 only <ref> [4] </ref>. 7.3 Generating Particular Solutions The constraint solver never commits itself to any particular solution of the accumulated constraints.
Reference: [5] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Furthermore all isomorphic subgraphs have been merged. BDDs have been described at length in the literature <ref> [1, 5, 4, 3, 9] </ref>. <p> The abstract formulation appeared in [13]: 2 The proper terminology for the BDDs we are using is Reduced Ordered Binary Decision Diagrams (ROBDDs) <ref> [5] </ref>, but in this report, we call them BDDs for short. 2 If g contains no propositional variables, it must be 0, otherwise no unifier exists. <p> formula f (also called the consensus operator) can be computed as (8v)f = f v fl f v substitution The substitution of a variable v by an expression w (not containing v) in a formula f can be computed as f [v=w] = (9v)[(v w) fl f ] Bryant in <ref> [5] </ref> introduces the Compose function for the substitution operation. <p> Finding a particular solutions then consists in a depth-first search of the BDD. In the absence of universally quantified variables, such a search would find the first particular solution in time linear in n <ref> [5] </ref>. If universally quantified variables appear in the BDD, however, the search could require exponential time due to arbitrary amounts of backtracking. For this reason, and because it was feared that the memory requirements of this approach would be prohibitive, another solution was chosen.
Reference: [6] <author> W. Buttner and H. Simonis. </author> <title> Embedding boolean expressions into logic programming. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 4 </volume> <pages> 191-205, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: Lowenheim's method constructs an mgu from a set of particular solutions instead of working from a given formula. In this report we shall only treat Boole's method and its variants. See [11] for a fuller exposition. Buttner and Simonis prove in <ref> [6] </ref> that the mgu of two expressions is unique, if it exists. They also extract a version of Boole's method from the proof.
Reference: [7] <author> Mats Carlsson. </author> <title> Freeze, indexing and other implementation issues in the wam. </title> <booktitle> In Fourth International Conference on Logic Programming, </booktitle> <pages> pages 40-58. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: To add the new constraint to the system, the formula in each right-hand side of the mgu is stored under its corresponding left-hand-side X i , and will be retrieved again if and when X i occurs in a new constraint. Each formula is stored as the frozen <ref> [7] </ref> goal boolvalue (X i ; G; M ), where G is the "skeleton" of the formula, and M is its "binding environment" which maps BDD variable indexes to Prolog terms.
Reference: [8] <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, and F. Berthier. </author> <title> The Constraint Logic Programming Language CHIP. </title> <booktitle> In Proceedings on the International Conference on Fifth Generation Computer Systems FGCS-88, </booktitle> <address> Tokyo, Japan, </address> <month> December </month> <year> 1988. </year>
Reference-contexts: The answer constraints are computed by existentially quantifying in the accumulated set of constraints all variables not occurring in the user query. The simplified set of constraints constitutes the answer constraints. As in the CHIP implementation <ref> [8] </ref>, Boolean formulas are internally represented as directed acyclic graphs (DAGs). In our implementation, the DAGs are ordinary terms constructed on the Prolog heap. Certain global data structures have been added to support the various operations on them, as well as extensions to the garbage collector and memory manager.
Reference: [9] <author> Jean C. Madre, Olivier Coudert, Jean P. Billon, and Christian Berthet. </author> <title> Formal verification and diagnosis of digital circuits using a propositional theorem prover. </title> <booktitle> In Proceedings of the IFIP TC10 WG10.2 Working Conference on CAD Systems using AI Techniques, </booktitle> <pages> pages 107-114. </pages> <address> Tokyo, </address> <year> 1989. </year>
Reference-contexts: Furthermore all isomorphic subgraphs have been merged. BDDs have been described at length in the literature <ref> [1, 5, 4, 3, 9] </ref>. <p> A solution to this problem, suggested in [1] and <ref> [9] </ref> and elsewhere, consists in typing the edges as positive or negative in the BDDs. Unless restrictions are placed on where negated edges can be placed, the representation is not canonical any more, however. <p> It is also up to twice as compact as the untyped BDD representation. When we speak about BDDs in the rest of this report, we mean the typed representation. In <ref> [9] </ref> a similar representation called Typed Decision Graphs (TDG) is used. TDGs are not reduced to canonical form (DAGs with maximally shared subtrees), however. The authors claim large performance gains by avoiding the reduction to canonical form.
Reference: [10] <author> Ursula Martin and Tobias Nipkow. </author> <title> Unification in boolean rings. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 4 </volume> <pages> 381-396, </pages> <year> 1988. </year>
Reference-contexts: The variables p 1 ; p 2 : : : p n are said to have been eliminated by Boolean unification. 3.2 Algorithms There are two major Boolean Unification algorithms: Boole's method and Lowenheim's method <ref> [10, 11] </ref>. Boole's method is recursive and is based on the Shannon expansion of a given formula. Lowenheim's method constructs an mgu from a set of particular solutions instead of working from a given formula. In this report we shall only treat Boole's method and its variants.
Reference: [11] <author> Ursula Martin and Tobias Nipkow. </author> <title> Boolean unification|the story so far. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 7 </volume> <pages> 275-293, </pages> <year> 1989. </year>
Reference-contexts: The variables p 1 ; p 2 : : : p n are said to have been eliminated by Boolean unification. 3.2 Algorithms There are two major Boolean Unification algorithms: Boole's method and Lowenheim's method <ref> [10, 11] </ref>. Boole's method is recursive and is based on the Shannon expansion of a given formula. Lowenheim's method constructs an mgu from a set of particular solutions instead of working from a given formula. In this report we shall only treat Boole's method and its variants. <p> Boole's method is recursive and is based on the Shannon expansion of a given formula. Lowenheim's method constructs an mgu from a set of particular solutions instead of working from a given formula. In this report we shall only treat Boole's method and its variants. See <ref> [11] </ref> for a fuller exposition. Buttner and Simonis prove in [6] that the mgu of two expressions is unique, if it exists. They also extract a version of Boole's method from the proof.
Reference: [12] <author> C. E. Shannon. </author> <title> A symbolic analysis of relay and switching circuits. </title> <journal> Trans. AIEE, </journal> <volume> 57 </volume> <pages> 713-723, </pages> <year> 1938. </year>
Reference-contexts: The cofactors of a function f with respect to a variable v, written f v and f v , are the functions resulting from replacing v by the constants 1 and 0 in f , respectively. Cofactors are used in Shannon's decomposition theorem <ref> [12] </ref> which states that any non-constant function can be expressed in terms of a unique pair of functions: f (v 1 ; v 2 : : : v n ) = v 1 fl f v 1 (v 2 : : : v n ) + v 1 fl f v
Reference: [13] <editor> Pascal Van Hentenryck. </editor> <booktitle> Tutorial on constraint logic programming. In Proceedings of the North American Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <month> October </month> <year> 1990. </year>
Reference-contexts: Notice that if g contains universally quantified variables, it might be insoluble even if it is distinct from the constant 1. 3.2.1 Boole's Algorithm Two formulations will be given here: an "abstract" one and a procedural one. The abstract formulation appeared in <ref> [13] </ref>: 2 The proper terminology for the BDDs we are using is Reduced Ordered Binary Decision Diagrams (ROBDDs) [5], but in this report, we call them BDDs for short. 2 If g contains no propositional variables, it must be 0, otherwise no unifier exists.
Reference: [14] <author> Pascal Van Hentenryck and Yves Deville. </author> <title> The cardinality operator: A new logical connective for constraint logic programming. </title> <type> Technical Report No. </type> <institution> CS-90-24, Brown University, </institution> <month> October </month> <year> 1990. </year> <month> 21 </month>
Reference-contexts: The interpretation of this operator is the constraint that the number of true formulas in F is a member of I. This is a trivial generalization of the cardinality operator as defined in <ref> [14] </ref>. An implementation has to face the problem of translating a cardinality formula to a BDD. A straightforward approach would be to expand the formula to disjunctive normal form.
References-found: 14

