URL: http://www.csc.ncsu.edu/faculty/mpsingh/papers/mas/compliance.ps
Refering-URL: http://www.csc.ncsu.edu/faculty/mpsingh/papers/mas/
Root-URL: http://www.csc.ncsu.edu
Email: mvenkat@eos.ncsu.edu, singh@ncsu.edu  
Title: Verifying Compliance with Commitment Protocols  
Author: Mahadevan Venkatraman and Munindar P. Singh 
Note: TR 98-13  
Address: Raleigh, NC 27695, USA  
Affiliation: Department of Computer Science, North Carolina State University,  
Abstract: Interaction protocols are specific, often standard, constraints on the behaviors of the autonomous agents in a multiagent system. Protocols are essential to the functioning of open systems, such as those that arise in most interesting web applications. A variety of common protocols in negotiation and electronic commerce are best treated as commitment protocols, which are defined, or at least analyzed, in terms of the creation, satisfaction, or manipulation of the commitments of the various agents to one another. When protocols are employed in open environments, such as the Internet, they must be executed by agents that behave more or less autonomously and whose internal designs are not known. In such settings, therefore, there is a risk that the participating agents may fail to comply with the protocol. Without a rigorous means to verify compliance, the very idea of protocols for interoperation is subverted. We develop a novel approach for testing the compliance of agents with respect to a commitment protocol. Our approach requires the specification of commitment protocols in temporal logic, and involves a novel way of synthesizing and applying ideas from distributed computing and logics of program. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Gul A. Agha and Nadeem Jamali. </author> <booktitle> Concurrent programming for distributed artificial intelligence. In [21], chapter 12, </booktitle> <pages> pages 505534. </pages> <year> 1998. </year>
Reference-contexts: Both of these have received much attention in the literature. In the middle is the multiagent execution architecture, which has not been as intensively studied within the community. An execution architecture must ultimately be based on distributed computing ideas albeit with an open flavor, e.g., <ref> [1, 5, 11] </ref>. A well-defined execution functionality can be given a principled design, and thus facilitate the construction of robust and reusable systems. Some recent work within multiagent systems has begun to address this level, e.g., Ciancarini et al. [8, 9] and Singh [17].
Reference: [2] <author> Massimo Benerecetti, Fausto Giunchiglia, and Luciano Serafini. </author> <title> Model checking multiagent systems. </title> <journal> Journal of Logic and Computation, </journal> <volume> 8(3):401423, </volume> <month> June </month> <year> 1998. </year>
Reference-contexts: Such representations can capture only the lowest levels of a multiagent interaction, and their monolithicity does not accord well with distributed execution and compliance testing. Model checking has recently drawn much attention in the multiagent community, e.g., <ref> [2, 16] </ref>. However, these approaches consider knowledge and related concepts and are thus not directly applicable for behavior-based compliance. The present approach highlights the synergies between distributed computing and mul-tiagent systems.
Reference: [3] <author> Kenneth P. Birman. </author> <title> The process group approach to reliable distributed computing. </title> <journal> Communications of the ACM, </journal> <volume> 36(12):3653, </volume> <month> December </month> <year> 1993. </year>
Reference-contexts: Potential causality is most often applied in distributed systems to ensure that the messages being sent in a system satisfy causal ordering <ref> [3] </ref>. Causality motivates vector clocks and vector timestamps on messages, which help ensure correct ordering by having the messaging subsystem reorder and retransmit messages as needed. This application of causality can be important, but is controversial [4, 6], because its overhead may not always be justifiable.
Reference: [4] <author> Kenneth P. Birman. </author> <title> A response to Cheriton and Skeen's criticism of causal and totally ordered communication. Operating Systems Review, </title> <address> 28(1):1121, </address> <year> 1994. </year>
Reference-contexts: Causality motivates vector clocks and vector timestamps on messages, which help ensure correct ordering by having the messaging subsystem reorder and retransmit messages as needed. This application of causality can be important, but is controversial <ref> [4, 6] </ref>, because its overhead may not always be justifiable. By contrast, in our approach, the delivery of messages may be noncausal. However, causality serves the important purpose of yielding accurate models of the observations of each agent.
Reference: [5] <author> Nicholas Carriero and David Gelernter. </author> <title> Coordination languages and their significance. </title> <journal> Communications of the ACM, </journal> <volume> 35(2):97107, </volume> <month> February </month> <year> 1992. </year>
Reference-contexts: Both of these have received much attention in the literature. In the middle is the multiagent execution architecture, which has not been as intensively studied within the community. An execution architecture must ultimately be based on distributed computing ideas albeit with an open flavor, e.g., <ref> [1, 5, 11] </ref>. A well-defined execution functionality can be given a principled design, and thus facilitate the construction of robust and reusable systems. Some recent work within multiagent systems has begun to address this level, e.g., Ciancarini et al. [8, 9] and Singh [17].
Reference: [6] <author> David R. Cheriton and Dale Skeen. </author> <title> Understanding the limitations of causally and totally ordered communication. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating System Principles (SOSP), </booktitle> <pages> pages 4457. </pages> <publisher> ACM Press, </publisher> <month> December </month> <year> 1993. </year>
Reference-contexts: Causality motivates vector clocks and vector timestamps on messages, which help ensure correct ordering by having the messaging subsystem reorder and retransmit messages as needed. This application of causality can be important, but is controversial <ref> [4, 6] </ref>, because its overhead may not always be justifiable. By contrast, in our approach, the delivery of messages may be noncausal. However, causality serves the important purpose of yielding accurate models of the observations of each agent.
Reference: [7] <author> Leonardo Chiariglione. </author> <title> Foundation for intelligent physical agents (FIPA) scope, </title> <note> 1998. http://drogo.cselt.stet.it/fipa/fipa scope.htm. </note>
Reference-contexts: Viewed in this light, every communication protocol is a commitment protocol. Formulating and testing compliance of autonomous and heterogeneous agents is a key prerequisite for the effective application of multiagent systems in open environments. As asserted by Chiariglione, minimal specifications based on external behavior will maximize interoperability <ref> [7] </ref>. The research community has not paid sufficient attention to this issue. A glaring shortcoming of the present semantics for agent communication languages is their fundamental inability to allow testing for the compliance of an agent [20, 22]. The present approach shows how that might be carried out.
Reference: [8] <author> Paolo Ciancarini, Andreas Knoche, Robert Tolksdorf, and Fabio Vitali. PageSpace: </author> <title> An architecture to coordinate distributed applications on the web. Computer Networks and ISDN System, </title> <address> 28(711):941952, </address> <year> 1996. </year>
Reference-contexts: A well-defined execution functionality can be given a principled design, and thus facilitate the construction of robust and reusable systems. Some recent work within multiagent systems has begun to address this level, e.g., Ciancarini et al. <ref> [8, 9] </ref> and Singh [17]. Much of the work on this broad theme, however, focuses primarily on coordination, which we think of as the lowest level of interaction. Coordination deals with how autonomous agents may align their activities in terms of what they do and when they do it. <p> However, the synthesis and application of these techniques on multiagent commitment protocols is a novel contribution of this paper. Interaction (rightly) continues to draw much attention from researchers. However, most current approaches do not consider an explicit execution architecture as in <ref> [8, 9, 17] </ref>. Other approaches lack a formal underpinning; still others focus primarily on monolithic finite-state machine representations for protocols. Such representations can capture only the lowest levels of a multiagent interaction, and their monolithicity does not accord well with distributed execution and compliance testing.
Reference: [9] <author> Paolo Ciancarini, Robert Tolksdorf, Fabio Vitali, Davide Rossi, and Andreas Knoche. </author> <title> Coordinating multiagent applications on the WWW: A reference architecture. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 24(5):362375, </volume> <month> May </month> <year> 1998. </year>
Reference-contexts: A well-defined execution functionality can be given a principled design, and thus facilitate the construction of robust and reusable systems. Some recent work within multiagent systems has begun to address this level, e.g., Ciancarini et al. <ref> [8, 9] </ref> and Singh [17]. Much of the work on this broad theme, however, focuses primarily on coordination, which we think of as the lowest level of interaction. Coordination deals with how autonomous agents may align their activities in terms of what they do and when they do it. <p> However, the synthesis and application of these techniques on multiagent commitment protocols is a novel contribution of this paper. Interaction (rightly) continues to draw much attention from researchers. However, most current approaches do not consider an explicit execution architecture as in <ref> [8, 9, 17] </ref>. Other approaches lack a formal underpinning; still others focus primarily on monolithic finite-state machine representations for protocols. Such representations can capture only the lowest levels of a multiagent interaction, and their monolithicity does not accord well with distributed execution and compliance testing.
Reference: [10] <author> E. Allen Emerson. </author> <title> Temporal and modal logic. </title> <editor> In Jan van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> vol. B, </volume> <pages> pages 9951072. </pages> <publisher> North-Holland, </publisher> <address> Amster-dam, </address> <year> 1990. </year> <month> 16 </month>
Reference-contexts: Because of their naturalness in expressing properties of systems that may evolve in more than one possible way and for the efficiency of reasoning that they support, the branching-time logics have been especially popular in this regard <ref> [10] </ref>. Of these, the best known is Computation Tree Logic (CTL), which we adapt here in our formal language L. Conventionally, a model of CTL is expressed as a tree. <p> However, applying them in combination and in the particular manner suggested here is novel to this paper. Temporal logic model checking is usually applied for design-time reasoning <ref> [10, pp. 10421046] </ref>. We are given a specification and an implementation, i.e., program, that is supposed to meet it. A model is generated from the program. A model checking algorithm determines whether the specification is true in the generated model.
Reference: [11] <author> Nissim Francez and Ira R. Forman. </author> <title> Interacting Processes: A Multiparty Approach to Coordinated Distributed Programming. </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1996. </year>
Reference-contexts: Both of these have received much attention in the literature. In the middle is the multiagent execution architecture, which has not been as intensively studied within the community. An execution architecture must ultimately be based on distributed computing ideas albeit with an open flavor, e.g., <ref> [1, 5, 11] </ref>. A well-defined execution functionality can be given a principled design, and thus facilitate the construction of robust and reusable systems. Some recent work within multiagent systems has begun to address this level, e.g., Ciancarini et al. [8, 9] and Singh [17].
Reference: [12] <author> Jim Gray and Andreas Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, </address> <year> 1993. </year>
Reference-contexts: They are far more flexible and general than commitment protocols in distributed computing and databases, such as two-phase commit <ref> [12, pp. 562573] </ref>. This is because our underlying notion of commitment is flexible, whereas traditional commitments are rigid and irrevocable. However, because multiagent systems are distributed systems, and commitment protocols are protocols, it is natural that techniques developed in classical computer science will apply here.
Reference: [13] <author> Leslie Lamport. </author> <title> Time, clocks, and the ordering of events in a distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 21(7):558565, </volume> <month> July </month> <year> 1978. </year>
Reference-contexts: Accordingly, our technical framework integrates approaches from distributed computing, logics of program, and distributed artificial intelligence. 2.1 Potential Causality The key idea behind potential causality is that the ordering of events in a distributed system can be determined only with respect to an observer <ref> [13] </ref>. If event e precedes event f with respect to an observer, then e may potentially cause f .
Reference: [14] <author> Juan A. Rodrjguez-Aguilar, Francisco J. Martjn, Pablo Noriega, Pere Garcia, and Carles Sierra. </author> <title> Towards a test-bed for trading agents in electronic auction markets. </title> <journal> AI Communications, </journal> <volume> 11(1):519, </volume> <year> 1998. </year>
Reference-contexts: All that matters is that a standard imposes some restrictions on the agents. Consider the fish-market protocol as an example of such a standard protocol <ref> [14] </ref>. Example 1 In the fish-market protocol, we are given agents of two roles: a single auctioneer and one or more potential bidders. The fish-market protocol is designed to sell fish. The seller or auctioneer announces the availability of a bucket of fish at a certain price.
Reference: [15] <author> Reinhard Schwarz and Friedemann Mattern. </author> <title> Detecting causal relationships in distributed computations: In search of the holy grail. </title> <journal> Distributed Computing, </journal> <volume> 7(3):149 174, </volume> <year> 1994. </year>
Reference-contexts: Each agent starts at ~ 0. It increments its entry in that vector whenever it performs a local event <ref> [15] </ref>. It attaches the entire vector as a timestamp to any message it sends out. When an agent receives a message, it updates its vector clock to be the element-wise max of its previous vector and the vector timestamp of the message it received. <p> Alternatively, we might offer an assistance to designers by synthesizing skeletons of agents who participate properly in commitment protocols. Lastly, it is well-known that there can be far more potential causes than real causes <ref> [15] </ref>.
Reference: [16] <author> Munindar P. Singh. </author> <title> Applying the mu-calculus in planning and reasoning about action. </title> <journal> Journal of Logic and Computation, </journal> <volume> 8(3):425445, </volume> <month> June </month> <year> 1998. </year>
Reference-contexts: Such representations can capture only the lowest levels of a multiagent interaction, and their monolithicity does not accord well with distributed execution and compliance testing. Model checking has recently drawn much attention in the multiagent community, e.g., <ref> [2, 16] </ref>. However, these approaches consider knowledge and related concepts and are thus not directly applicable for behavior-based compliance. The present approach highlights the synergies between distributed computing and mul-tiagent systems.
Reference: [17] <author> Munindar P. Singh. </author> <title> A customizable coordination service for autonomous agents. </title> <booktitle> In Intelligent Agents IV: Proceedings of the 4th International Workshop on Agent Theories, Architectures, and Languages (ATAL-97), </booktitle> <pages> pages 93106. </pages> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: A well-defined execution functionality can be given a principled design, and thus facilitate the construction of robust and reusable systems. Some recent work within multiagent systems has begun to address this level, e.g., Ciancarini et al. [8, 9] and Singh <ref> [17] </ref>. Much of the work on this broad theme, however, focuses primarily on coordination, which we think of as the lowest level of interaction. Coordination deals with how autonomous agents may align their activities in terms of what they do and when they do it. <p> Proof. By inspection of the message patterns constructed for the various operations on commitments. 10 3.2 Specifying Protocols We first consider the coordination and then the commitment aspects of compliance. A skeleton is a coarse description of how an agent may behave <ref> [17] </ref>. A skeleton would be associated with each role in the given multiagent system to specify how an agent playing that role may behave in order to coordinate with others. Coordination includes the simpler aspects of interaction, e.g., turn-taking. Coordination is required so that agents' commitments make sense. <p> However, the synthesis and application of these techniques on multiagent commitment protocols is a novel contribution of this paper. Interaction (rightly) continues to draw much attention from researchers. However, most current approaches do not consider an explicit execution architecture as in <ref> [8, 9, 17] </ref>. Other approaches lack a formal underpinning; still others focus primarily on monolithic finite-state machine representations for protocols. Such representations can capture only the lowest levels of a multiagent interaction, and their monolithicity does not accord well with distributed execution and compliance testing.
Reference: [18] <author> Munindar P. Singh. </author> <title> Developing formal specifications to coordinate heterogeneous autonomous agents. </title> <booktitle> In Proceedings of the 3rd International Conference on Multiagent Systems (ICMAS), </booktitle> <pages> pages 261268. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> July </month> <year> 1998. </year>
Reference-contexts: Coordination is required so that agents' commitments make sense. For instance, a bidder shouldn't make a bid prior to the advertisement, or the commitment content of the bid won't be fully defined. The skeletons may be constructed by introspection or through the use of a suitable methodology <ref> [18] </ref>. No matter how they are created, the skeletons are the first line of compliance testing, because an agent that doesn't comply with the skeleton for its role is automatically in violation.
Reference: [19] <author> Munindar P. Singh. </author> <title> An ontology for commitments in multiagent systems: Toward a unification of normative concepts. </title> <journal> Artificial Intelligence and Law, </journal> <note> 1998. In press. </note>
Reference-contexts: Specifically, interaction must include some consideration of the commitments that the agents enter into with each other. The commitments of the agents are not only base-level commitments dealing with what actions they must or must not perform, but also meta-commitments dealing with how they will adjust their base-level commitments <ref> [19] </ref>. Commitments provide a layer of coherence to the agents' interactions with each other. They are especially important in environments where we need to model any kind of contractual relationships among the agents. <p> Some subtleties are discussed next. As remarked above, commitments give the real meaning of a protocol. Our approach builds on a flexible and powerful variety of social commitments, which are the commitments of one agent to another <ref> [19] </ref>. These commitments are defined relative to a context, which is typically the multiagent system itself. The debtor refers to the agent that makes a commitment, and the creditor to the agent who receives the commitment. Thus we have the following logical form.
Reference: [20] <author> Munindar P. Singh. </author> <title> Principles of agent communication. </title> <journal> IEEE Computer, </journal> <note> 1998. In press. </note>
Reference-contexts: Accordingly, we use it as our main example in this paper. Because of the autonomy and heterogeneity requirements of open systems, compliance testing can neither be based on the internal designs of the agents nor on concepts such as beliefs, desires, and intentions that map to internal representations <ref> [20] </ref>. The only way in which compliance can be tested is based on the behavior of the participating agentsthis may be by a central authority or any of the participating agents. However, the requirements 1 for behavior in multiagent systems can be quite subtle. <p> This leads to two subtle issues. One, although we talk in terms of behavior, we must still consider the high-level abstractions that differentiate agents from other active objects. The focus on behavior renders approaches based on mental concepts ineffective <ref> [20] </ref>. However, well-framed social constructs can be used. Two, we must clearly delineate the role of the observer who assesses compliance. 1.3 Contributions The approach developed here functions under some fairly flexible assumptions. It allows a fully distributed system on which the agents exist. <p> As asserted by Chiariglione, minimal specifications based on external behavior will maximize interoperability [7]. The research community has not paid sufficient attention to this issue. A glaring shortcoming of the present semantics for agent communication languages is their fundamental inability to allow testing for the compliance of an agent <ref> [20, 22] </ref>. The present approach shows how that might be carried out. Some of the important strands of research of relevance to commitment protocols have been carried out before. However, the synthesis and application of these techniques on multiagent commitment protocols is a novel contribution of this paper.
Reference: [21] <author> Gerhard Wei, </author> <title> editor. Multiagent Systems: A Modern Approach to Distributed Artificial Intelligence. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1998. </year>
Reference: [22] <author> Michael J. Wooldridge. </author> <title> Verifiable semantics for agent communication languages. </title> <booktitle> In Proceedings of the 3rd International Conference on Multiagent Systems (ICMAS), </booktitle> <pages> pages 349356. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> July </month> <year> 1998. </year> <month> 17 </month>
Reference-contexts: As asserted by Chiariglione, minimal specifications based on external behavior will maximize interoperability [7]. The research community has not paid sufficient attention to this issue. A glaring shortcoming of the present semantics for agent communication languages is their fundamental inability to allow testing for the compliance of an agent <ref> [20, 22] </ref>. The present approach shows how that might be carried out. Some of the important strands of research of relevance to commitment protocols have been carried out before. However, the synthesis and application of these techniques on multiagent commitment protocols is a novel contribution of this paper.
References-found: 22

