URL: http://www.eecs.umich.edu/Rio/papers/failStop.ps
Refering-URL: http://www.eecs.umich.edu/Rio/papers.html
Root-URL: http://www.eecs.umich.edu
Title: Abstract  
Abstract: Most fault-tolerant systems are designed to stop faulty programs before they write permanent data or communicate with other processes. This property (halt-on-failure) forms the core of the fail-stop model. Unfortunately, little experimental data exists on whether or not program failures follow the fail-stop model. This paper describes a tool, based on the SimOS complete-machine simulator, that can trace how faults propagate through memory, disk, and functions. Using this tool on the Postgres database system, we conduct a controlled experiment to measure how often faulty programs violate the fail-stop model. We find that a significant number of faults (7%) violate the fail-stop model by writing incorrect data to stable storage before halting. We then apply Postgres transaction mechanism to undo recent changes before a crash and find that transactions reduce fail-stop violations by a factor of 3. 
Abstract-found: 1
Intro-found: 1
Reference: [Avizienis85] <author> Algirdas Avizienis. </author> <title> The N-Version Approach to Fault-Tolerant Software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(12):14911501, </volume> <month> December </month> <year> 1985. </year>
Reference-contexts: Unfortunately, software bugs are currently the dominant cause of failures, accounting for 60-90% of all failures [Gray91]. There are two major ways to make programs fail-stop in the presence of software bugs, both of which use replication. The first technique is N-version programming <ref> [Avizienis85] </ref>, which uses N independent versions of the same program. Ideally, these versions fail independently because they are written by different groups. In practice, these versions are correlated because independent groups make similar errors.
Reference: [Barton90] <author> James H. Barton, Edward W. Czeck, Zary Z. Se-gall, and Daniel P. Siewiorek. </author> <title> Fault injection experiments using FIAT. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(4):575582, </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: Our primary goal in designing these faults is to generate a wide variety of database crashes. Our models are derived from studies of commercial databases and operating systems [Sullivan92, Sullivan91, Lee93] and from prior models used in fault-injection studies <ref> [Barton90, Kao93, Kanawati95, Chen96, Ng97] </ref>. The faults we inject range from low-level hardware faults such Table 1: Propagation of fault through Postgres functions. Each snapshot lists the functions whose behavior has been corrupted at that point in the run. <p> Unless otherwise stated, we inject 5 faults for each run to increase the chances that a fault will be triggered. We only consider runs in which a fault was activated. The first category of faults ips random bits in the databases address space <ref> [Barton90, Kanawati95] </ref>. We target the heap and stack areas of the databases address space. These faults are easy to inject, and they cause a variety of different crashes. They are the least realistic of our bugs, however.
Reference: [Birman91] <author> Kenneth Birman, Andre Schiper, and Pat Stephenson. </author> <title> Lightweight Causal and Atomic Group Multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3):272314, </volume> <month> August </month> <year> 1991. </year>
Reference-contexts: This property is known as halt-on-failure [Schneider84] and forms the core of the fail-stop model. Many fault-tolerant systems assume that faulty application programs follow this model <ref> [Strom85, Johnson87, Birman91, Costa96] </ref>. General mechanisms exist to make systems fail-stop. For example, Schneider describes a system where each program runs on multiple processors [Schneider84]. The processors vote before writing to stable storage and halt if their results disagree.
Reference: [Chen96] <author> Peter M. Chen, Wee Teck Ng, Subhachandra Chandra, Christopher M. Aycock, Gurushankar Rajamani, and David Lowell. </author> <title> The Rio File Cache: Surviving Operating System Crashes. </title> <booktitle> In Proceedings of the 1996 International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS), </booktitle> <pages> pages 7483, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: Our primary goal in designing these faults is to generate a wide variety of database crashes. Our models are derived from studies of commercial databases and operating systems [Sullivan92, Sullivan91, Lee93] and from prior models used in fault-injection studies <ref> [Barton90, Kao93, Kanawati95, Chen96, Ng97] </ref>. The faults we inject range from low-level hardware faults such Table 1: Propagation of fault through Postgres functions. Each snapshot lists the functions whose behavior has been corrupted at that point in the run.
Reference: [Costa96] <author> Manuel Costa, Paulo Guedes, Manuel Sequeira, Nuno Neves, and Miguel Castro. </author> <title> Lightweight Logging for Lazy Release Consistent Distributed Shared Memory. </title> <booktitle> Operating Systems Design and Implementation (OSDI), </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: This property is known as halt-on-failure [Schneider84] and forms the core of the fail-stop model. Many fault-tolerant systems assume that faulty application programs follow this model <ref> [Strom85, Johnson87, Birman91, Costa96] </ref>. General mechanisms exist to make systems fail-stop. For example, Schneider describes a system where each program runs on multiple processors [Schneider84]. The processors vote before writing to stable storage and halt if their results disagree.
Reference: [Gray86] <author> Jim Gray. </author> <title> Why do computers stop and what can be done about it? In Proceedings of the 1986 Symposium on Reliability in Distributed Software and Database Systems, </title> <booktitle> pages 312, </booktitle> <month> January </month> <year> 1986. </year>
Reference-contexts: When one recovery block fails an error check, the state of the system is rolled back to the beginning of the recovery block and another version of the recovery block is used. Process pairs <ref> [Gray86] </ref> are similar to recovery blocks. Whereas recovery blocks invoke a different version of the code, process pairs re-invoke the same code (possibly on a different computer) and hope the bug does not repeat itself on the second try.
Reference: [Gray91] <author> Jim Gray and Daniel P. </author> <type> Siewiorek. </type> <institution> High-Availability Computer Systems. IEEE Computer, 24(9):3948, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: The processors vote before writing to stable storage and halt if their results disagree. These types of mechanisms are used primarily to tolerate independent hardware faults. Unfortunately, software bugs are currently the dominant cause of failures, accounting for 60-90% of all failures <ref> [Gray91] </ref>. There are two major ways to make programs fail-stop in the presence of software bugs, both of which use replication. The first technique is N-version programming [Avizienis85], which uses N independent versions of the same program. Ideally, these versions fail independently because they are written by different groups.
Reference: [Gray93] <author> Jim Gray and Andreas Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1993. </year>
Reference-contexts: Chen Computer Science and Engineering Division Department of Electrical Engineering and Computer Science University of Michigan -schandra,pmchen-@eecs.umich.edu http://www.eecs.umich.edu/Rio 28th International Symposium on Fault-Tolerant Computing, June 1998 work well in practice because most bugs are non-deter-ministic (i.e. Heisenbugs). Both recovery blocks and process pairs use atomic transactions <ref> [Gray93] </ref> to roll the state of the system back to the beginning of the block of code. Transactions help make the program fail-stop by undoing recent changes to stable storage (Figure 1).
Reference: [Iyer95] <author> Ravishankar K. Iyer. </author> <title> Experimental Evaluation. </title> <booktitle> In Proceedings of the 1995 International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 115 132, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Using transactions prevents fail-stop violations in most cases. Fail-stop violations with transactions occur only for very long latency faults in which the program continues beyond the transaction that wrote corrupted data. 5. Related work Many prior studies have used software fault injection; see <ref> [Iyer95] </ref> for an excellent introduction to the overall area and a summary of past fault injection techniques. Most fault injection studies focus on the final effect of the error (e.g. fault latency).
Reference: [Johnson87] <author> David B. Johnson and Willy Zwaenepoel. </author> <title> Sender-Based Message Logging. </title> <booktitle> In Proceedings of the 1987 International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 1419, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: This property is known as halt-on-failure [Schneider84] and forms the core of the fail-stop model. Many fault-tolerant systems assume that faulty application programs follow this model <ref> [Strom85, Johnson87, Birman91, Costa96] </ref>. General mechanisms exist to make systems fail-stop. For example, Schneider describes a system where each program runs on multiple processors [Schneider84]. The processors vote before writing to stable storage and halt if their results disagree.
Reference: [Kanawati95] <author> Ghani A. Kanawati, Nasser A. Kanawati, and Jacob A. Abraham. FERRARI: </author> <title> A Flexible Software-Based Fault and Error Injection System. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 44(2):248 260, </volume> <month> February </month> <year> 1995. </year>
Reference-contexts: Our primary goal in designing these faults is to generate a wide variety of database crashes. Our models are derived from studies of commercial databases and operating systems [Sullivan92, Sullivan91, Lee93] and from prior models used in fault-injection studies <ref> [Barton90, Kao93, Kanawati95, Chen96, Ng97] </ref>. The faults we inject range from low-level hardware faults such Table 1: Propagation of fault through Postgres functions. Each snapshot lists the functions whose behavior has been corrupted at that point in the run. <p> Unless otherwise stated, we inject 5 faults for each run to increase the chances that a fault will be triggered. We only consider runs in which a fault was activated. The first category of faults ips random bits in the databases address space <ref> [Barton90, Kanawati95] </ref>. We target the heap and stack areas of the databases address space. These faults are easy to inject, and they cause a variety of different crashes. They are the least realistic of our bugs, however.
Reference: [Kao93] <author> Wei-Lun Kao, Ravishankar K. Iyer, and Dong Tang. </author> <title> FINE: A Fault Injection and Monitoring Environment for Tracing the UNIX System Behavior under Faults. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(11):11051118, </volume> <month> November </month> <year> 1993. </year>
Reference-contexts: Our primary goal in designing these faults is to generate a wide variety of database crashes. Our models are derived from studies of commercial databases and operating systems [Sullivan92, Sullivan91, Lee93] and from prior models used in fault-injection studies <ref> [Barton90, Kao93, Kanawati95, Chen96, Ng97] </ref>. The faults we inject range from low-level hardware faults such Table 1: Propagation of fault through Postgres functions. Each snapshot lists the functions whose behavior has been corrupted at that point in the run. <p> The second category of fault changes individual instructions in the database text segment. These faults are intended to approximate the assembly-level manifestation of real C-level programming errors <ref> [Kao93] </ref>. We corrupt assignment statements by changing the source or destination register. We corrupt conditional constructs by deleting branches. We also delete random instructions (both branch and non-branch) by replacing them with NOPs. The last and most extensive category of faults imitate specific programming errors in the database [Sullivan91]. <p> The last and most extensive category of faults imitate specific programming errors in the database [Sullivan91]. These are targeted more at specific programming errors than the previous fault category. We inject an initialization fault by deleting instructions responsible for initializing a variable at the start of a procedure <ref> [Kao93, Lee93] </ref>. We inject pointer corruption by 1) finding a register that is used as a base register of a load or store and 2) deleting the most recent instruction before the load/store that modifies the base register [Sullivan91, Lee93]. <p> More work is clearly needed in this area, especially in light of how many fault-tolerant systems are based on the fail-stop model. The most relevant work to this paper is the FINE fault injector and monitoring environment <ref> [Kao93] </ref>. FINE uses software to emulate hardware and software bugs into the Unix operating system and monitors how the fault propagates through the kernel. To trace fault propagation, a violations are circled.
Reference: [Lee93] <author> Inhwan Lee and Ravishankar K. Iyer. </author> <title> Faults, Symptoms, and Software Fault Tolerance in the Tandem GUARDIAN Operating System. </title> <booktitle> In International Symposium on Fault-Tolerant Computing (FTCS), pages 2029, </booktitle> <year> 1993. </year>
Reference-contexts: Faults injected into Postgres form the second part of the workload. Our primary goal in designing these faults is to generate a wide variety of database crashes. Our models are derived from studies of commercial databases and operating systems <ref> [Sullivan92, Sullivan91, Lee93] </ref> and from prior models used in fault-injection studies [Barton90, Kao93, Kanawati95, Chen96, Ng97]. The faults we inject range from low-level hardware faults such Table 1: Propagation of fault through Postgres functions. Each snapshot lists the functions whose behavior has been corrupted at that point in the run. <p> The last and most extensive category of faults imitate specific programming errors in the database [Sullivan91]. These are targeted more at specific programming errors than the previous fault category. We inject an initialization fault by deleting instructions responsible for initializing a variable at the start of a procedure <ref> [Kao93, Lee93] </ref>. We inject pointer corruption by 1) finding a register that is used as a base register of a load or store and 2) deleting the most recent instruction before the load/store that modifies the base register [Sullivan91, Lee93]. <p> We inject pointer corruption by 1) finding a register that is used as a base register of a load or store and 2) deleting the most recent instruction before the load/store that modifies the base register <ref> [Sullivan91, Lee93] </ref>. We do not corrupt the stack pointer register, as this is used to access local variables instead of as a pointer variable. We inject an allocation management fault by modifying the databases malloc procedure to occasionally free the previously allocated block of memory.
Reference: [Lowell97] <author> David E. Lowell and Peter M. Chen. </author> <title> Free Transactions with Rio Vista. </title> <booktitle> In Proceedings of the 1997 Symposium on Operating Systems Principles, </booktitle> <month> October </month> <year> 1997. </year>
Reference: [Ng97] <author> Wee Teck Ng and Peter M. Chen. </author> <title> Integrating Reliable Memory in Databases. </title> <booktitle> In Proceedings of the 1997 International Conference on Very Large Data Bases (VLDB), </booktitle> <pages> pages 7685, </pages> <month> August </month> <year> 1997. </year>
Reference-contexts: Our primary goal in designing these faults is to generate a wide variety of database crashes. Our models are derived from studies of commercial databases and operating systems [Sullivan92, Sullivan91, Lee93] and from prior models used in fault-injection studies <ref> [Barton90, Kao93, Kanawati95, Chen96, Ng97] </ref>. The faults we inject range from low-level hardware faults such Table 1: Propagation of fault through Postgres functions. Each snapshot lists the functions whose behavior has been corrupted at that point in the run. <p> A prior paper from the Rio project measures database corruption by running a pre-determined workload, monitoring the progress of the workload, and comparing the results after a crash with the pre-determined, correct answers at the point of the crash <ref> [Ng97] </ref>. The prior study compares the transactional state of the data (after changes from in-progress transactions are undone), so these results correspond to the right-most column of Table 3 (fail-stop violations with transactions). Our results match those in the prior study: 2% of crashes violate fail-stop when transactions are used. <p> The method used in the prior study works only when correct answers can be pre-determined for each point in the computation. We also compare results with and without transactions to determine how effectively transactions hide fail-stop violations, something that could not be easily done in <ref> [Ng97] </ref>. 6. Conclusions and future work While many systems depend on programs being fail-stop, no prior study has measured how often programs actually stop before corrupting permanent data. We have described a tool that can trace how faults propagate through memory, disk, and functions.
Reference: [Randell75] <author> Brian Randell. </author> <title> System Structure for Software Fault Tolerance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(2):220232, </volume> <month> June </month> <year> 1975. </year>
Reference-contexts: For example, a program may verify a messages checksum after receiving the message. Recovery blocks are a fault-tolerant scheme that uses error checking at the end of each block of code (a recovery block) <ref> [Randell75] </ref>. When one recovery block fails an error check, the state of the system is rolled back to the beginning of the recovery block and another version of the recovery block is used. Process pairs [Gray86] are similar to recovery blocks.
Reference: [Rosenblum95] <author> Mendel Rosenblum, Stephen A. Herrod, Emmett Witchel, and Anoop Gupta. </author> <title> Complete computer system simulation: the SimOS approach. </title> <journal> IEEE Parallel & Distributed Technology: Systems & Applications, </journal> <volume> 3(4):3443, </volume> <month> January </month> <year> 1995. </year>
Reference-contexts: Some past simulators have been too slow to run large software programs; other simulators achieved high speed but did not simulate the machine in enough detail to run system software. Our tool is based on SimOS, a complete-machine simulator developed at Stanford University <ref> [Rosenblum95] </ref>. SimOS (Digital Alpha version) simulates an entire Digital Alpha workstation at enough detail to run unmodified application programs and a slightly modified Digital Unix kernel. The modifications are limited to low-level device drivers, such as disk drivers and the system console.
Reference: [Schneider84] <author> Fred B. Schneider. </author> <title> Byzantine Generals in Action: Implementing Fail-Stop Processors. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(2):145154, </volume> <month> May </month> <year> 1984. </year>
Reference-contexts: To ease the task of building fault-tolerant systems, most designers try to ensure that a malfunctioning program halts before it writes erroneous data to stable storage or sends incorrect information to other processes. This property is known as halt-on-failure <ref> [Schneider84] </ref> and forms the core of the fail-stop model. Many fault-tolerant systems assume that faulty application programs follow this model [Strom85, Johnson87, Birman91, Costa96]. General mechanisms exist to make systems fail-stop. For example, Schneider describes a system where each program runs on multiple processors [Schneider84]. <p> This property is known as halt-on-failure <ref> [Schneider84] </ref> and forms the core of the fail-stop model. Many fault-tolerant systems assume that faulty application programs follow this model [Strom85, Johnson87, Birman91, Costa96]. General mechanisms exist to make systems fail-stop. For example, Schneider describes a system where each program runs on multiple processors [Schneider84]. The processors vote before writing to stable storage and halt if their results disagree. These types of mechanisms are used primarily to tolerate independent hardware faults. Unfortunately, software bugs are currently the dominant cause of failures, accounting for 60-90% of all failures [Gray91].
Reference: [Stonebraker87] <author> M. Stonebraker. </author> <title> The design of the POSTGRES storage system. </title> <booktitle> In Proceedings of the 1987 International Conference on Very Large Data Bases, </booktitle> <pages> pages 289300, </pages> <month> September </month> <year> 1987. </year>
Reference-contexts: Because of this rollback process, runs that violate fail-stop with transactions are usually a subset of the runs that violate fail-stop without transactions. 3. Workload and fault models We use the Postgres95 database management system developed at U.C. Berkeley as the software system in our experiments <ref> [Stonebraker87] </ref>. While our results are specific to the software system being tested, we believe Post-gres is a good example of a large software system with abundant error checking. As with all databases, Postgres can abort the transactions in progress at the time of the crash.
Reference: [Strom85] <author> Robert E. Strom and Shaula Yemini. </author> <title> Optimistic Recovery in Distributed Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(3):204226, </volume> <month> August </month> <year> 1985. </year>
Reference-contexts: This property is known as halt-on-failure [Schneider84] and forms the core of the fail-stop model. Many fault-tolerant systems assume that faulty application programs follow this model <ref> [Strom85, Johnson87, Birman91, Costa96] </ref>. General mechanisms exist to make systems fail-stop. For example, Schneider describes a system where each program runs on multiple processors [Schneider84]. The processors vote before writing to stable storage and halt if their results disagree.
Reference: [Sullivan91] <author> Mark Sullivan and R. Chillarege. </author> <title> Software Defects and Their Impact on System AvailabilityA Study of Field Failures in Operating Systems. </title> <booktitle> In Proceedings of the 1991 International Symposium on Fault-Tolerant Computing, </booktitle> <month> June </month> <year> 1991. </year>
Reference-contexts: Faults injected into Postgres form the second part of the workload. Our primary goal in designing these faults is to generate a wide variety of database crashes. Our models are derived from studies of commercial databases and operating systems <ref> [Sullivan92, Sullivan91, Lee93] </ref> and from prior models used in fault-injection studies [Barton90, Kao93, Kanawati95, Chen96, Ng97]. The faults we inject range from low-level hardware faults such Table 1: Propagation of fault through Postgres functions. Each snapshot lists the functions whose behavior has been corrupted at that point in the run. <p> We corrupt assignment statements by changing the source or destination register. We corrupt conditional constructs by deleting branches. We also delete random instructions (both branch and non-branch) by replacing them with NOPs. The last and most extensive category of faults imitate specific programming errors in the database <ref> [Sullivan91] </ref>. These are targeted more at specific programming errors than the previous fault category. We inject an initialization fault by deleting instructions responsible for initializing a variable at the start of a procedure [Kao93, Lee93]. <p> We inject pointer corruption by 1) finding a register that is used as a base register of a load or store and 2) deleting the most recent instruction before the load/store that modifies the base register <ref> [Sullivan91, Lee93] </ref>. We do not corrupt the stack pointer register, as this is used to access local variables instead of as a pointer variable. We inject an allocation management fault by modifying the databases malloc procedure to occasionally free the previously allocated block of memory. <p> The length of the overrun was distributed as follows: 50% corrupt one byte; 44% corrupt 2-1024 bytes; 6% corrupt 2-4 KB. This distribution was chosen by starting with the data gathered in <ref> [Sullivan91] </ref> and modifying it somewhat according to our specific platform and experience. bcopy is set to inject this error every 0-5000 times it is called. We inject off-by-one errors by changing conditions such as &gt; to &gt;=, &lt; to &lt;=, and so on.
Reference: [Sullivan92] <author> Mark Sullivan and Ram Chillarege. </author> <title> A Comparison of Software Defects in Database Management Systems and Operating Systems. </title> <booktitle> In Proceedings of the 1992 International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 475 484, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Faults injected into Postgres form the second part of the workload. Our primary goal in designing these faults is to generate a wide variety of database crashes. Our models are derived from studies of commercial databases and operating systems <ref> [Sullivan92, Sullivan91, Lee93] </ref> and from prior models used in fault-injection studies [Barton90, Kao93, Kanawati95, Chen96, Ng97]. The faults we inject range from low-level hardware faults such Table 1: Propagation of fault through Postgres functions. Each snapshot lists the functions whose behavior has been corrupted at that point in the run.
Reference: [TPC90] <editor> TPC Benchmark B Standard Specification. </editor> <title> Technical report, Transaction Processing Performance Council, </title> <month> August </month> <year> 1990. </year>
Reference-contexts: As with all databases, Postgres can abort the transactions in progress at the time of the crash. We use this feature to measure how many fail-stop violations are masked by the transaction mechanism. We drive Postgres with a transaction workload based on TPC-B <ref> [TPC90] </ref>. The default configuration of Postgres prints a warning but does not stop if it detects minor errors. To make Postgres more fail-stop, we halt the program immediately after any warning message. Faults injected into Postgres form the second part of the workload.
References-found: 23

