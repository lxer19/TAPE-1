URL: http://www.cs.berkeley.edu/~marcel/papers/rtree-vldb95.ps
Refering-URL: http://www.cs.berkeley.edu/~marcel/
Root-URL: 
Email: kornacke@dbis1.informatik.uni-hamburg.de  dbanks@cs.berkeley.edu  
Title: High-Concurrency Locking in R-Trees  
Author: Marcel Kornacker Douglas Banks 
Address: 22527 Hamburg, Germany  Berkeley, CA 94720-1776, U.S.A  
Affiliation: Universitat Hamburg  University of California at Berkeley  
Abstract: In this paper we present a solution to the problem of concurrent operations in the R-tree, a dynamic access structure capable of storing multidimensional and spatial data. We describe the R-link tree, a variant of the R-tree that adds sibling pointers to nodes, a technique first deployed in B-link trees, to compensatefor concurrent structure modifications. The main obstacle to the use of sibling pointers is the lack of linear ordering among the keys in an R-tree; we overcome this by assigning sequence numbers to nodes that let us reconstruct the lineage of a node at any point in time. The search, insert and delete algorithms for R-link trees are designed to completely avoid holding locks during I/O operations and to allow concurrent modifications of the tree structure. In addition, we further describe how to achieve degree 3 consistency with an inexpensive predicate locking mechanism and demonstrate how to make R-link trees recoverable in a write-ahead logging environment. Experiments verify the performance advantage of R-link trees over simpler locking protocols. 
Abstract-found: 1
Intro-found: 1
Reference: [BaMc72] <author> R. Bayer and E. McCreight, </author> <title> Organization and Maintenance of Large Ordered Indexes, </title> <journal> Acta Informatica, </journal> <volume> Vol. 1, No. 3, </volume> <pages> pp. 173-189, </pages> <year> 1972. </year>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. Proceedings of the 21st VLDB Conference Z urich, Switzerland 1995 access method, the B-tree <ref> [BaMc72] </ref>, does not handle multidimensional data very well. [Gutt84] proposed a spatial access method designed to handle multidimensional point and spatial data.
Reference: [BaSc77] <author> R. Bayer and M. Schkolnick, </author> <title> Concurrency of Operations on B-Trees, </title> <journal> Acta Inf., </journal> <volume> Vol. 9(1977), </volume> <pages> pp. 1-21. </pages>
Reference-contexts: Simple solutions to this problem have the insertion process lock the entire tree or the subtree that needs to be modified due to anticipated splits. Variations thereof lock the upper levels of the subtree so that only readers can still access it <ref> [BaSc77] </ref>. In essence all of these methods employ top-down lock-coupling: when descending the tree a lock on a parent node can only be released after the lock on the child node is granted. <p> Because an insertion never performs a split itself, there is no need for concurrent search processes to do lock-coupling. The highest-concurrency algorithm is modeled after one presented in <ref> [BaSc77] </ref> for B-trees. Readers do top-down lock-coupling when descending the tree in order to avoid having to deal with splitting pages.
Reference: [Bent75] <author> J. L. Bentley, </author> <title> Multidimensional Binary Search Trees Used for Associative Searching, </title> <journal> CACM, September 1975, </journal> <volume> Vol. 18, No. 9, </volume> <pages> pp. 509-517. </pages>
Reference-contexts: Proceedings of the 21st VLDB Conference Z urich, Switzerland 1995 access method, the B-tree [BaMc72], does not handle multidimensional data very well. [Gutt84] proposed a spatial access method designed to handle multidimensional point and spatial data. Unlike other spatial access methods <ref> [Bent75, Niev84, Robi81, LoSa90] </ref>, R-trees are not restricted to storing multidimensional points, but can directly store multidimensional spatial objects, which are represented by their minimal bounding box. R-trees have not benefited greatly from the many refinements and optimizations of concurrency mechanisms that have been designed for B-trees.
Reference: [BKS94] <author> D. Banks, M. Kornacker, M. Stonebraker, </author> <note> High-Concurrency Locking in R-Trees, Sequoia 2000 Technical Report 94/56, </note> <month> June </month> <year> 1994. </year>
Reference-contexts: Unfortunately, the B-link tree technique expects the underlying key space to have a linear order and therefore cannot be directly applied to R-trees. In this paper we present R-link trees <ref> [BKS94] </ref>, an extension of R-trees motivated by Lehman and Yao's work that shows similiar locking behavior and therefore offers the same high degree of concurrency as B-link trees.
Reference: [BKSS90] <author> N. Beckmann, H.-P. Kriegel, R. Schneider and B. Seeger, </author> <title> The R*-tree: An Efficient and Robust Access Method for Points and Rectangles, </title> <booktitle> Proc. 1990 ACM SIGMOD Conf., </booktitle> <pages> pp. 322-331. </pages>
Reference-contexts: The strategy for placing entries on leaf nodes should therefore create an efficient index structure that optimizes retrieval performance. The literature has identified a variety of parameters for the layout of keys on nodes that affect retrieval performance <ref> [BKSS90, SRF87] </ref>. These parameters are: minimal node area, minimal overlap between nodes, minimal node margins or maximized node utilization. It is impossible to optimize all of these parameters simultaneously. <p> These parameters are: minimal node area, minimal overlap between nodes, minimal node margins or maximized node utilization. It is impossible to optimize all of these parameters simultaneously. For instance, the original R-tree proposal [Gutt84] minimizes overlap between nodes; the R*-tree variation <ref> [BKSS90] </ref> minimizes overlap for internal nodes and minimizes the covered area for leaf nodes. When a new key has to be inserted in an R-tree, we attempt to descend to the geometrically optimal leaf by picking at each level the subtree with the optimal bounding rectangle.
Reference: [EGLT76] <author> K. Eswaren, J. Gray, R. Lorie and I. Traiger, </author> <title> On the Notions of Consistency and Predicate Locks in a Database System, </title> <journal> Comm. ACM, November 1976, </journal> <volume> Vol. 19, No. 11, </volume> <pages> pp. 624-633. 11 </pages>
Reference-contexts: A searcher descending the tree can now collide with an inserter propagating changes up the tree. A more effective solution to the phantom problem is to use a simplified form of predicate locks <ref> [EGLT76] </ref>, where exclusive predicates consist of a single key value and shared predicates consist of a query rectangle and scan operation such as inclusion or overlap. A new scan request would check the still-active insertions and suspend itself if its query rectangle collides with any of the uncommitted new keys.
Reference: [Gray78] <author> J. Gray, </author> <title> Notes on Data Base Operation Sys--tems, Operating Systems, </title> <editor> R. Bayer et al. (Eds.), </editor> <volume> LNCS Volume 60, </volume> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: During the entire node deletion process, we only have to keep two nodes locked at a time: the node to be deleted and its parent node. 4 Consistency A common requirement for concurrent access in database systems is degree 3 consistency, or repeatable read (RR) <ref> [Gray78] </ref>. A simple solution employed for B-trees is to keep all leaf pages that were read by an index scan locked until the end of the transaction.
Reference: [Gutt84] <author> A. Guttman, R-Trees: </author> <title> A Dynamic Index Structure for Spatial Searching, </title> <booktitle> Proc. 1984 ACM SIG-MOD Conf., </booktitle> <pages> pp. 47-57. </pages>
Reference-contexts: To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. Proceedings of the 21st VLDB Conference Z urich, Switzerland 1995 access method, the B-tree [BaMc72], does not handle multidimensional data very well. <ref> [Gutt84] </ref> proposed a spatial access method designed to handle multidimensional point and spatial data. Unlike other spatial access methods [Bent75, Niev84, Robi81, LoSa90], R-trees are not restricted to storing multidimensional points, but can directly store multidimensional spatial objects, which are represented by their minimal bounding box. <p> These parameters are: minimal node area, minimal overlap between nodes, minimal node margins or maximized node utilization. It is impossible to optimize all of these parameters simultaneously. For instance, the original R-tree proposal <ref> [Gutt84] </ref> minimizes overlap between nodes; the R*-tree variation [BKSS90] minimizes overlap for internal nodes and minimizes the covered area for leaf nodes.
Reference: [Illu94] <institution> Illustra Information Technologies, Inc., </institution> <note> Illustra User's Guide, Illustra Server Release 2.1, </note> <month> June </month> <year> 1994. </year>
Reference-contexts: deadlock we can also use cheap latches [MoLe89] instead of locks when locking the tree nodes for physical consistency. 6 Performance Measurements To asses the performance of R-link trees relative to non-link style R-tree concurrency mechanisms, we implemented R-link trees as a new access method for the Illustra database engine <ref> [Illu94] </ref> and compared it to the existing R-tree implementation. The performance numbers were obtained from concurrent client processes accessing a fully-functional database system, as opposed to simulation results or calls to a stand-alone access method implementation. The existing R-tree implementation employs a variation of Bayer-Schkolnick-style lock-coupling for concurrent insertions.
Reference: [JoSh93] <author> T. Johnson and D. Shasha, </author> <title> The Performance of Current B-Tree Algorithms, </title> <journal> ACM TODS, </journal> <volume> Vol. 18, No. 1, </volume> <pages> pp. 51-101, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: This technique avoids holding locks during I/O operations and has recently been shown to offer the highest degree of concurrency among locking protocols for B-trees <ref> [SrCa91, JoSh93] </ref>. Unfortunately, the B-link tree technique expects the underlying key space to have a linear order and therefore cannot be directly applied to R-trees.
Reference: [LaSh86] <author> V. Lanin and D. Shasha, </author> <title> A Symmetric Concurrent B-Tree Algorithm, </title> <booktitle> 1986 Fall Joint Computer Conference (Dallas, Tex., </booktitle> <month> Nov. </month> <year> 1986), </year> <pages> pp. 380-389. </pages>
Reference-contexts: Likewise, an insertion process does not have to employ lock-coupling when descending the tree to the correct leaf. If the leaf has to be split, it is also possible to avoid lock-coupling when installing a new entry in the parent, as is shown in <ref> [LaSh86] </ref> and [Sagi86]. <p> This is problematic when the remaining inserters have to change the bounding rectangle of what they believe is the root or if the root has to be split a second time. A solution can be found in <ref> [LaSh86] </ref> and [Sagi86]; both suggest using an anchor page to make root splits visible to other insertion processes and allow for compensating actions. There is one restriction to consider when installing a new child entry in a parent node, which might not be immediately obvious.
Reference: [LeYa81] <author> P. Lehman and S. Yao, </author> <title> Efficient Locking for Concurrent Operations on B-Trees, </title> <journal> ACM TODS, </journal> <volume> Vol 6, No. 4, </volume> <month> December </month> <year> 1981. </year>
Reference-contexts: R-trees have not benefited greatly from the many refinements and optimizations of concurrency mechanisms that have been designed for B-trees. A particular modification of B-trees, the B-link tree <ref> [LeYa81] </ref>, connects the siblings on each level via rightward-pointing links and compensates for unfinished splits by moving across these links. This technique avoids holding locks during I/O operations and has recently been shown to offer the highest degree of concurrency among locking protocols for B-trees [SrCa91, JoSh93]. <p> For R-trees, it also takes place in order to propagate a changed bounding rectangle. The latter can be expected to occur far more frequently and unpredictably than node splits or deletions. A radically different approach was proposed in <ref> [LeYa81] </ref>. Instead of avoiding possible conflicts by lock-coupling, the tree structure is modified so that the search process has the opportunity to compensate for a missed split. <p> processes only need to hold one node locked at a time. 3 R-Link Trees We would like to achieve high concurrency for operations on R-trees, and given the similarities in structure and functionality between B-trees and R-trees, it would seem natural to try to apply the ideas and algorithms of <ref> [LeYa81] </ref> to create an R-link tree. This is not a trivial matter, however, because R-trees differ from B-trees on a number of important points and the B-link tree strategy itself is insufficient. The source of this problem is the lack of ordering on R-tree keys.
Reference: [LoSa90] <author> D. Lomet and B. Salzberg, </author> <title> The hB-Tree: A Mul-tiattribute Indexing Method with Good Guaranteed Performance, </title> <journal> ACM TODS, </journal> <volume> Vol 15, No. 4, </volume> <pages> pp. 625-685, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Proceedings of the 21st VLDB Conference Z urich, Switzerland 1995 access method, the B-tree [BaMc72], does not handle multidimensional data very well. [Gutt84] proposed a spatial access method designed to handle multidimensional point and spatial data. Unlike other spatial access methods <ref> [Bent75, Niev84, Robi81, LoSa90] </ref>, R-trees are not restricted to storing multidimensional points, but can directly store multidimensional spatial objects, which are represented by their minimal bounding box. R-trees have not benefited greatly from the many refinements and optimizations of concurrency mechanisms that have been designed for B-trees. <p> To avoid the phantom problem when doing record-level locking, a scan also sets a shared lock on the next-highest key past its scan range. Again, this is not applicable in R-trees because the notion of a next-highest key does not exist. The -tree presented in <ref> [LoSa90] </ref> is a generalization of a B-link tree where nodes can have multiple parents, which turns the tree structure into a DAG. The nodes of a -tree partition the key space, thus making it possible for descending operations to detect splits solely by key comparisons.
Reference: [LoSa92] <author> D. Lomet and B. Salzberg, </author> <title> Access Method Con-currency with Recovery, </title> <booktitle> Proc. 1992 ACM SIG-MOD Conf., </booktitle> <pages> pp. 351-360. </pages>
Reference-contexts: Key values and query rectangles can be organized into an in-memory spatial data structure to speed up checking for lock conflicts. 5 Recovery The main ideas of the recovery method we present for R-link trees are drawn from [MoLe89] and <ref> [LoSa92] </ref>. Like these two papers, we also split an update operation into its contents-changing and its structure-modifying part. <p> This is necessary so that structure modifications can be made visible immediately after their completion and do not have to be locked until the initiating transaction commits. Like [MoLe89] and <ref> [LoSa92] </ref>, we assume that write-ahead logging (WAL) is used for recovery purposes. In addition, we also assume that logical undo is supported. This is a necessity for the R-link tree, which is explained shortly. <p> This ensures that these leaf changes can always be undone if the transaction aborts and redone if it commits. Structural modifications, on the other hand, are treated as separate recoverable units (atomic actions in <ref> [LoSa92] </ref> and nested top actions in [MoLe89]). For example, a node split is an atomic action, which is caused by a transaction trying to insert a key on a full leaf node. The atomic action is logged and recovered separately from the surrounding transaction. <p> We might also have to adjust the bounding rectangles and therefore perform a complete insertion operation. Like <ref> [LoSa92] </ref>, we break up entire structure modifications such as node split or delete propagation into several atomic actions that operate on at most two levels of the tree and are executed serially. <p> The highest-concurrency algorithm is modeled after one presented in [BaSc77] for B-trees. Readers do top-down lock-coupling when descending the tree in order to avoid having to deal with splitting pages. Insertions lock the entire subtree that needs modification on their way to the leaf. [Moha89, MoLe89] and <ref> [LoSa92] </ref> discuss recoverable access structures in a write-ahead logging environment; the former paper also present a solution for guaranteeing degree 3 consistency with row-level locking.
Reference: [Moha89] <author> C. Mohan, ARIES/KVL: </author> <title> A Key-Value Locking Method for Concurrency Control of Multiaction Transactions Operating on B-Tree Indexes, </title> <institution> IBM Research Report RJ7008, </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: The highest-concurrency algorithm is modeled after one presented in [BaSc77] for B-trees. Readers do top-down lock-coupling when descending the tree in order to avoid having to deal with splitting pages. Insertions lock the entire subtree that needs modification on their way to the leaf. <ref> [Moha89, MoLe89] </ref> and [LoSa92] discuss recoverable access structures in a write-ahead logging environment; the former paper also present a solution for guaranteeing degree 3 consistency with row-level locking.
Reference: [MoLe89] <author> C. Mohan and F. Levine, ARIES/IM: </author> <title> An Efficient and High Concurrency Index Management Method Using Write-Ahead Logging, </title> <institution> IBM Research Report RJ6846, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: Key values and query rectangles can be organized into an in-memory spatial data structure to speed up checking for lock conflicts. 5 Recovery The main ideas of the recovery method we present for R-link trees are drawn from <ref> [MoLe89] </ref> and [LoSa92]. Like these two papers, we also split an update operation into its contents-changing and its structure-modifying part. <p> This is necessary so that structure modifications can be made visible immediately after their completion and do not have to be locked until the initiating transaction commits. Like <ref> [MoLe89] </ref> and [LoSa92], we assume that write-ahead logging (WAL) is used for recovery purposes. In addition, we also assume that logical undo is supported. This is a necessity for the R-link tree, which is explained shortly. <p> This ensures that these leaf changes can always be undone if the transaction aborts and redone if it commits. Structural modifications, on the other hand, are treated as separate recoverable units (atomic actions in [LoSa92] and nested top actions in <ref> [MoLe89] </ref>). For example, a node split is an atomic action, which is caused by a transaction trying to insert a key on a full leaf node. The atomic action is logged and recovered separately from the surrounding transaction. <p> The consequence of the latter is that there cannot be a deadlock between a predicate lock and a node lock. Because of this freedom from deadlock we can also use cheap latches <ref> [MoLe89] </ref> instead of locks when locking the tree nodes for physical consistency. 6 Performance Measurements To asses the performance of R-link trees relative to non-link style R-tree concurrency mechanisms, we implemented R-link trees as a new access method for the Illustra database engine [Illu94] and compared it to the existing R-tree <p> The highest-concurrency algorithm is modeled after one presented in [BaSc77] for B-trees. Readers do top-down lock-coupling when descending the tree in order to avoid having to deal with splitting pages. Insertions lock the entire subtree that needs modification on their way to the leaf. <ref> [Moha89, MoLe89] </ref> and [LoSa92] discuss recoverable access structures in a write-ahead logging environment; the former paper also present a solution for guaranteeing degree 3 consistency with row-level locking.
Reference: [NgKa93] <author> V. Ng and T. Kameda, </author> <title> Concurrent Accesses to R-Trees, </title> <booktitle> Proceedings of Symposium on Large Spatial Databases, </booktitle> <pages> pp. 142-61, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin 1993. </address>
Reference-contexts: None of the algorithms known to us attempt to adapt the B-link tree strategy to R-trees in order to achieve higher concurrency. Ng and Kameda <ref> [NgKa93] </ref> present three algorithms varying in complexity and possible concurrency. The simplest of the three algorithms locks the entire tree so that an insertion would exclude all searchers. The second algorithm postpones page splits by adding buffer space to each node to accommodate overflows.
Reference: [Niev84] <author> J. Nievergelt, H. Hinterberger and K. C. Sevcik, </author> <title> The Grid File: An Adaptable, Symmetric Mul-tikey File Structure, </title> <journal> ACM TODS, </journal> <volume> Vol. 9, No. 1, </volume> <month> March </month> <year> 1984. </year>
Reference-contexts: Proceedings of the 21st VLDB Conference Z urich, Switzerland 1995 access method, the B-tree [BaMc72], does not handle multidimensional data very well. [Gutt84] proposed a spatial access method designed to handle multidimensional point and spatial data. Unlike other spatial access methods <ref> [Bent75, Niev84, Robi81, LoSa90] </ref>, R-trees are not restricted to storing multidimensional points, but can directly store multidimensional spatial objects, which are represented by their minimal bounding box. R-trees have not benefited greatly from the many refinements and optimizations of concurrency mechanisms that have been designed for B-trees.
Reference: [Robi81] <author> J. T. Robinson, </author> <title> The K-D-B-Tree: A Search Structure for Large Multidimensional Dynamic Indexes, </title> <booktitle> Proc. 1981 ACM SIGMOD Conf., </booktitle> <pages> pp. 10-18. </pages>
Reference-contexts: Proceedings of the 21st VLDB Conference Z urich, Switzerland 1995 access method, the B-tree [BaMc72], does not handle multidimensional data very well. [Gutt84] proposed a spatial access method designed to handle multidimensional point and spatial data. Unlike other spatial access methods <ref> [Bent75, Niev84, Robi81, LoSa90] </ref>, R-trees are not restricted to storing multidimensional points, but can directly store multidimensional spatial objects, which are represented by their minimal bounding box. R-trees have not benefited greatly from the many refinements and optimizations of concurrency mechanisms that have been designed for B-trees.
Reference: [Sagi86] <author> Y. Sagiv, </author> <title> Concurrent Operations on B*-Trees with Overtaking, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> Vol. 33, No. 2, </volume> <pages> pp. 275-296, </pages> <year> 1986. </year>
Reference-contexts: Likewise, an insertion process does not have to employ lock-coupling when descending the tree to the correct leaf. If the leaf has to be split, it is also possible to avoid lock-coupling when installing a new entry in the parent, as is shown in [LaSh86] and <ref> [Sagi86] </ref>. <p> This is problematic when the remaining inserters have to change the bounding rectangle of what they believe is the root or if the root has to be split a second time. A solution can be found in [LaSh86] and <ref> [Sagi86] </ref>; both suggest using an anchor page to make root splits visible to other insertion processes and allow for compensating actions. There is one restriction to consider when installing a new child entry in a parent node, which might not be immediately obvious.
Reference: [SrCa91] <author> V. Srinivasan and M. Carey, </author> <title> Performance of B-Tree Concurrency Control Algorithms, </title> <booktitle> Proc. 1991 ACM SIGMOD conf., </booktitle> <pages> pp. 416-425. </pages>
Reference-contexts: This technique avoids holding locks during I/O operations and has recently been shown to offer the highest degree of concurrency among locking protocols for B-trees <ref> [SrCa91, JoSh93] </ref>. Unfortunately, the B-link tree technique expects the underlying key space to have a linear order and therefore cannot be directly applied to R-trees. <p> Also the deletion algorithm was not implemented as described in section 3.4, because index reorganization is performed off-line. We investigated the throughput and response time of search and insert operations on the index. Analogous to <ref> [SrCa91] </ref>, we defined three different workloads: the low-contention workload consists of a varying number of searchers and a single inserter, the moderate-contention workload of inserters only and the high-contention workload of an equal number of searchers and inserters.
Reference: [SRF87] <author> T. Sellis, N. Roussopoulos, and C. Faloutsos, </author> <title> The R+-tree: A Dynamic Index for Multidimensional Objects, </title> <booktitle> Proc. 13th Int'l Conf. on Very Large Databases (VLDB), </booktitle> <month> Sep. </month> <year> 1987, </year> <pages> pp. 507-518. </pages>
Reference-contexts: The strategy for placing entries on leaf nodes should therefore create an efficient index structure that optimizes retrieval performance. The literature has identified a variety of parameters for the layout of keys on nodes that affect retrieval performance <ref> [BKSS90, SRF87] </ref>. These parameters are: minimal node area, minimal overlap between nodes, minimal node margins or maximized node utilization. It is impossible to optimize all of these parameters simultaneously.
Reference: [Ston87] <author> M. Stonebraker, </author> <title> The Design of the Postgres Storage System, </title> <booktitle> Proc. 13th Int'l Conf. on Very Large Databases (VLDB), </booktitle> <month> Sep. </month> <year> 1987. </year> <month> 12 </month>
Reference-contexts: Both R-link and R-trees employed the same page splitting strategy, a simplified version of Guttman's original quadratic split algorithm. We did not implement all of the recovery strategy outlined in section 5, because the no-overwrite storage manager <ref> [Ston87] </ref> of the Illustra database server does not undo the changes of aborted transactions. Also the deletion algorithm was not implemented as described in section 3.4, because index reorganization is performed off-line. We investigated the throughput and response time of search and insert operations on the index.
References-found: 23

