URL: http://www.cs.princeton.edu/courses/archive/fall97/cs595/lilli-excerpt.ps
Refering-URL: http://www.cs.princeton.edu/courses/archive/fall97/cs595/reading.html
Root-URL: http://www.cs.princeton.edu
Title: Translucent Sums: A Foundation for Higher-Order Module Systems  
Author: Mark Lillibridge 
Degree: Submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy. Thesis Committee: Robert Harper, Chair Peter Lee John Reynolds Luca Cardelli, DEC SRC  
Note: Copyright c fl1997 Mark Lillibridge This research was sponsored by the Air Force Materiel Command (AFMC) and the Defense Advanced Research Projects Agency (DARPA) under contract number, F19628-95-C-0050. The U.S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation thereon. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies or endorsements, either expressed or implied, of the U.S. Government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: May, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In J. Maluszynski and M. Wirsing, editors, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference: [2] <author> Henk P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> revised edition, </address> <year> 1984. </year>
Reference: [3] <author> Richard J. </author> <title> Beach. Experience with the Cedar programming environment for computer graphics research. </title> <type> Technical Report CSL-84-6, </type> <institution> Xerox Corporation, Palo Alto, </institution> <month> July </month> <year> 1985. </year>
Reference: [4] <author> Edoardo Biagioni. </author> <title> A structured TCP in Standard ML. </title> <booktitle> In Sigcomm '94, </booktitle> <address> London, England, </address> <month> August/September </month> <year> 1994. </year>
Reference-contexts: Nonetheless, I am now going to present two examples that I feel convey some of the flavor of how higher-order modules systems are used in practice. My first example comes from Carnegie Mellon's Fox Project's implementation of the TCP/IP protocol suite, the FoxNet <ref> [6, 5, 4] </ref>, in SML. The TCP/IP protocol suite is organized modularly in the form of a protocol stack (see Figure 1.1). The leftmost stack in this figure shows the organization of normal TCP/IP.
Reference: [5] <author> Edoardo Biagioni, Robert Harper, and Peter Lee. </author> <title> Standard ML signatures for a protocol stack. </title> <type> Technical Report CMU-CS-93-170, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> July </month> <year> 1993. </year> <note> (Also published as Fox Memorandum CMU-CS-FOX-93-01). </note>
Reference-contexts: Nonetheless, I am now going to present two examples that I feel convey some of the flavor of how higher-order modules systems are used in practice. My first example comes from Carnegie Mellon's Fox Project's implementation of the TCP/IP protocol suite, the FoxNet <ref> [6, 5, 4] </ref>, in SML. The TCP/IP protocol suite is organized modularly in the form of a protocol stack (see Figure 1.1). The leftmost stack in this figure shows the organization of normal TCP/IP.
Reference: [6] <author> Edoardo Biagioni, Robert Harper, Peter Lee, and Brian G. Milnes. </author> <title> Signatures for a network protocol stack: A systems application of Standard ML. </title> <booktitle> In ACM Conference on LISP and Functional Programming, </booktitle> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Nonetheless, I am now going to present two examples that I feel convey some of the flavor of how higher-order modules systems are used in practice. My first example comes from Carnegie Mellon's Fox Project's implementation of the TCP/IP protocol suite, the FoxNet <ref> [6, 5, 4] </ref>, in SML. The TCP/IP protocol suite is organized modularly in the form of a protocol stack (see Figure 1.1). The leftmost stack in this figure shows the organization of normal TCP/IP.
Reference: [7] <author> Hans-Jurgen Bohm, Alan Demers, and James Donahue. </author> <title> An informal description of Russell. </title> <type> Technical Report 80-430, </type> <institution> Computer Science Department, Cornell University, </institution> <address> Ithaca, New York, </address> <year> 1980. </year>
Reference: [8] <author> Rod Burstall and Butler Lampson. </author> <title> A kernel language for abstract data types and modules. </title> <editor> In Kahn et al. </editor> <volume> [28], </volume> <pages> pages 1-50. 337 338 BIBLIOGRAPHY </pages>
Reference: [9] <author> Luca Cardelli. </author> <title> Structural subtyping and the notion of power type. </title> <booktitle> In Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California, 1988. </address> <publisher> ACM. </publisher>
Reference: [10] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <type> Technical Report 45, </type> <institution> DEC Systems Research Center, </institution> <year> 1989. </year>
Reference-contexts: Examples of programming languages which take this approach are John Mitchell and Gordon Plotkin's SOL [43] and Luca Cardelli's Quest <ref> [10] </ref>. This approach provides data 11 12 CHAPTER 2. PREVIOUS APPROACHES abstraction at the module level, as we have just seen.
Reference: [11] <author> Luca Cardelli and Xavier Leroy. </author> <title> Abstract types and the dot notation. </title> <type> Technical Report 56, </type> <institution> DEC Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: may be bound to different types at runtime, making it unsafe to refer to it by a single static name outside the scope of the open statement.) Having to write out an open statement each time you want to use a weak sum can be inconvenient; in a 1990 paper <ref> [11] </ref>, Luca Cardelli and Xavier Leroy introduced a shortcut they called the dot notation. The basic idea is to allow the programmer to directly write x.T for the type component of and x.v for the value component of the weak sum denoted by the variable x.
Reference: [12] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <year> 1982. </year>
Reference: [13] <author> Charles M. Geschke, James H. Morris Jr., and Edwin H. Satterthwaite. </author> <title> Early experience with Mesa. </title> <type> Technical Report CSL-76-6, </type> <institution> Xerox Corporation, Palo Alto, </institution> <month> October </month> <year> 1976. </year>
Reference: [14] <author> Herman Geuvers. </author> <title> The Church-Rosser property for fi-reduuction in typed -calculi. </title> <booktitle> In Seventh Symposium on Logic in Computer Science, </booktitle> <pages> pages 453-460, </pages> <address> Santa Cruz, California, </address> <month> June </month> <year> 1992. </year>
Reference: [15] <author> Jean-Yves Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieure. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: This choice yields a simple and uniform design. My "recipe" for building translucent higher-module systems is as follows: * Start with a base -calculus (to model the core language); I use Girard's F ! <ref> [15] </ref> in my Kernel system * Add translucent sums (to module modules) * Add dependent functions (to model functors); dependent functions are needed be cause the result type of a functor can depend on its argument * Add a notion of subtyping (to model implementation-interface matching) The key component here is
Reference: [16] <author> Robert Harper. </author> <type> Personal communication, </type> <year> 1993. </year>
Reference: [17] <author> Robert Harper. </author> <note> A propsoal for ML2000 (draft of december 16, 1994). (Unpublished), </note> <month> December </month> <year> 1994. </year>
Reference: [18] <author> Robert Harper, Peter Lee, Frank Pfenning, and Eugene Rollins. </author> <title> Incremental recompilation for Standard ML of New Jersey. </title> <type> Technical Report CMU-CS-94-116, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> February </month> <year> 1994. </year> <note> (Also published as Fox Memorandum CMU-CS-FOX-94-02; to appear Workshop on ML, Orlando, FL, June, 1994.). </note>
Reference: [19] <author> Robert Harper and Mark Lillibridge. </author> <title> Explicit polymorphism and CPS conversion. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 206-219, </pages> <address> Charleston, SC, </address> <month> January </month> <year> 1993. </year> <note> ACM, ACM. </note>
Reference: [20] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Twenty-first ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 123-137, </pages> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year> <note> BIBLIOGRAPHY 339 </note>
Reference: [21] <author> Robert Harper, Robin Milner, and Mads Tofte. </author> <title> The definition of Standard ML (version 3). </title> <type> Technical Report ECS-LFCS-89-81, </type> <institution> Laboratory for the Foundations of Computer Science, Edinburgh University, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Program organization is crucial to ensuring that large programs are easy to develop, understand, and maintain. The most well-known programming language with a higher-order module system is Standard ML (SML) <ref> [21] </ref>. SML provides functors and submodules, but treats modules as 1.3. BENEFITS OF HIGHER-ORDER MODULE SYSTEMS 7 normal: mobile: local: TCP TCP MOBILE-IP TCP IP IP glue ETH ETH ETH second-class values. The extensive experience of the SML community with functors and submodules has established their value as program-organization tools.
Reference: [22] <author> Robert Harper, John C. Mitchell, and Eugenio Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: its implementation and then reducing the resulting expression: IntStack.T = (module type T=ref (list (int)); ... end).T = ref (list (int)) Examples of programming languages that take this approach are David MacQueen's DL [37]; Robert Harper and John Mitchell's XML [41]; and Robert Harper, John Mitchell, and Eugenio Moggi's ML <ref> [22] </ref>. As we have just seen, the transparent approach does not provide data abstraction at the module level. <p> TECHNICAL MACHINERY 4.5 The Phase Distinction One desirable property of a programming language is that it have a phase distinction <ref> [22] </ref>. A programming language is said to have a phase distinction if programs in it can be type checked without evaluating general program expressions (terms).
Reference: [23] <author> Robert Harper and Greg Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1995. </year>
Reference: [24] <author> Robert Harper and Chris Stone. </author> <title> A type-theoretic account of Standard ML 1996 (version 2). </title> <type> Technical Report CMU-CS-96-136R, </type> <institution> Carnegie Mellon University, </institution> <address> Pitts-burgh, PA, </address> <year> 1996. </year>
Reference: [25] <author> James G. Hook. </author> <title> Understanding Russell: A first attempt. </title> <editor> In Kahn et al. </editor> <volume> [28], </volume> <pages> pages 69-85. </pages>
Reference: [26] <author> K. Jensen. </author> <title> Pascal User Manual and Report. </title> <publisher> Springer-Verlag, </publisher> <year> 1978. </year> <note> (2nd edition). </note>
Reference: [27] <author> Mark P. Jones. </author> <title> Using parameterized signatures to express modular structure. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 21-24, </pages> <address> St. Petersburg Beach, FL, </address> <month> January </month> <year> 1996. </year> <note> ACM Press. </note>
Reference: [28] <editor> Gilles Kahn, David MacQueen, and Gordon Plotkin, editors. </editor> <booktitle> Semantics of Data Types, volume 173 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1984. </year>
Reference: [29] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-hall, Inc., </publisher> <year> 1978. </year>
Reference-contexts: First-order module systems have only the trivial module facilities discussed so far: module creation, module naming, and module-component extraction (M.x). Most traditional module systems are of this type. Examples include Ada [52], CLU [36], C <ref> [29] </ref>, C++ [53], and Modula-2 [56]. Higher-order module systems, by contrast, have non-trivial module manipulation facilities. I shall be concerned in this dissertation primarily with three such facilities: functors, submodules, and modules as first-class values. Functors are functions mapping modules to modules.
Reference: [30] <author> Butler W. Lampson. </author> <title> A description of the Cedar language: A Cedar language reference manual. </title> <type> Technical Report CSL-83-15, </type> <institution> Xerox Corporation, Palo Alto, </institution> <month> December </month> <year> 1983. </year>
Reference: [31] <author> Xavier Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In Proceedings of the Twenty-first Annual ACM Symposium on Principles of Programming Languages, Portland, </booktitle> <pages> pages 109-122. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: -&gt; int; end If we compare this interface to the original opaque ORDERED interface (repeated below), we see that the new interface differs only in the addition of the type identity T=string: interface type T; val cmp: T*T -&gt; int; end By using a shorthand notation due to Xavier Leroy <ref> [31] </ref>, we can take advantage of this fact to express the new interface as ORDERED with T=string. Leroy's with notation is a purely syntactic shorthand that expresses the result of adding information about type identities to an existing interface. <p> In additional to being useful as a starting point for building extended systems, my kernel system is likely to be useful as a reduction target because of these proven properties; for example, I expect that the soundness of Xavier Leroy's system <ref> [31] </ref> can be established in this way far more easily than if it was proved directly. The negative results about soundness under certain extensions, the decidability of subtyping (and hence type checking), and the existence of principle types if implicit subsumption is permitted are also contributions of my dissertation.
Reference: [32] <author> Xavier Leroy. </author> <title> Applicative functors and fully transparent higher-order modules. </title> <booktitle> In Conference Record of POPL '95: ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 142-153, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1995. </year> <note> 340 BIBLIOGRAPHY </note>
Reference: [33] <author> Xavier Leroy. </author> <title> A modular module system. </title> <type> Research report 2866, </type> <institution> INRIA, </institution> <month> April </month> <year> 1996. </year>
Reference: [34] <author> Xavier Leroy. </author> <title> A syntactic theory of type generativity and sharing. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(5) </volume> <pages> 667-698, </pages> <year> 1996. </year>
Reference-contexts: I shall give an example of how this can occur later in Section 3.7. Code that does not involve using modules as first-class values, higher-order functors (functors that take or return other functors as arguments), or type coercions will be given a fully transparent interface <ref> [34] </ref>. This category includes the majority of code written in SML. 1 In particular, the type checker makes no attempt to determine the run-time branching of conditionals, instead assuming that they could branch either way at any time. 3.3.
Reference: [35] <author> Mark Lillibridge, Zhong Shao, and Robert Harper. </author> <booktitle> Minutes of the ML2000 meeting at Portland, Oregon on January 16, </booktitle> <year> 1994. </year> <note> Unpublished, </note> <year> 1994. </year>
Reference: [36] <author> Barbara Liskov, Russell Atkinson, et al. </author> <title> CLU Reference Manual, </title> <booktitle> volume 114 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: I classify module systems into two types, depending on what sort of facilities they have. First-order module systems have only the trivial module facilities discussed so far: module creation, module naming, and module-component extraction (M.x). Most traditional module systems are of this type. Examples include Ada [52], CLU <ref> [36] </ref>, C [29], C++ [53], and Modula-2 [56]. Higher-order module systems, by contrast, have non-trivial module manipulation facilities. I shall be concerned in this dissertation primarily with three such facilities: functors, submodules, and modules as first-class values. Functors are functions mapping modules to modules.
Reference: [37] <author> David MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In Thirteenth ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1986. </year>
Reference-contexts: Also, we cannot extend ADTs by adding a few new operations to an existing ADT. 1 Another consequence is that many of the more useful idioms using higher-order features are inexpressible. Indeed, David MacQueen argued in a 1986 paper <ref> [37] </ref> that this problem is severe enough that the opaque approach should be abandoned in favor of a transparent one. 2.2 The Transparent Approach Unlike in the opaque approach, under the transparent approach, module and functor boundaries are transparent, allowing all information about the identities of type components to pass through <p> The identity of IntStack.T is computed by substituting in its implementation and then reducing the resulting expression: IntStack.T = (module type T=ref (list (int)); ... end).T = ref (list (int)) Examples of programming languages that take this approach are David MacQueen's DL <ref> [37] </ref>; Robert Harper and John Mitchell's XML [41]; and Robert Harper, John Mitchell, and Eugenio Moggi's ML [22]. As we have just seen, the transparent approach does not provide data abstraction at the module level.
Reference: [38] <author> David B. MacQueen and Mads Tofte. </author> <title> A semantics for higher-order functors. </title> <editor> In D. Sannella, editor, </editor> <booktitle> Programming Languages and Systems | ESOP '94, volume 788 of Lecture Notes in Computer Science, </booktitle> <pages> pages 409-423. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [39] <author> David C. J. Matthews. </author> <type> POLY report. Technical Report 28, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <year> 1982. </year>
Reference: [40] <author> James G. Mitchell, William Maybury, and Richard Sweet. </author> <title> Mesa language manual. </title> <type> Technical Report CSL-78-1, </type> <institution> Xerox Corporation, Palo Alto, </institution> <month> February </month> <year> 1978. </year>
Reference: [41] <author> John Mitchell and Robert Harper. </author> <title> The essence of ML. </title> <booktitle> In Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: The identity of IntStack.T is computed by substituting in its implementation and then reducing the resulting expression: IntStack.T = (module type T=ref (list (int)); ... end).T = ref (list (int)) Examples of programming languages that take this approach are David MacQueen's DL [37]; Robert Harper and John Mitchell's XML <ref> [41] </ref>; and Robert Harper, John Mitchell, and Eugenio Moggi's ML [22]. As we have just seen, the transparent approach does not provide data abstraction at the module level.
Reference: [42] <author> John Mitchell, Sigurd Meldal, and Neel Madhav. </author> <title> An extension of Standard ML modules with subtyping and inheritance. </title> <booktitle> In Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1991. </year>
Reference: [43] <author> John C. Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <booktitle> In Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1985. </year>
Reference-contexts: Examples of programming languages which take this approach are John Mitchell and Gordon Plotkin's SOL <ref> [43] </ref> and Luca Cardelli's Quest [10]. This approach provides data 11 12 CHAPTER 2. PREVIOUS APPROACHES abstraction at the module level, as we have just seen.
Reference: [44] <author> John Gregory Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1995. </year> <note> (Available as Carnegie Mellon University School of Computer Science technical report CMU-CS-95-226.). </note>
Reference: [45] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference: [46] <author> John Ophel. </author> <title> A polymorphic language with first-class modules. </title> <journal> Australian Computer Science Communications, </journal> <volume> 17(1) </volume> <pages> 422-430, </pages> <month> February </month> <year> 1995. </year> <note> BIBLIOGRAPHY 341 </note>
Reference: [47] <author> Amit Patel and Chris Stone. </author> <booktitle> Minutes of the ML2000 meeting at King's Beach, </booktitle> <address> CA. (Unpublished), </address> <month> August </month> <year> 1996. </year>
Reference: [48] <author> Frank Pfenning. </author> <title> Partial polymorphic type inference and higher-order unification. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 153-163, </pages> <address> Snowbird, Utah, July 1988. </address> <publisher> ACM Press. </publisher>
Reference: [49] <author> Frank Pfenning and Peter Lee. </author> <title> LEAP: A language with eval and polymorphism. </title> <booktitle> In TAPSOFT '89, Proceedings of the International Joint Conference on Theory and Practice in Software Development, Barcelona, Spain, </booktitle> <pages> pages 345-359. </pages> <publisher> Springer-Verlag LNCS 352, </publisher> <month> March </month> <year> 1989. </year>
Reference: [50] <author> Benjamin Pierce. </author> <title> Bounded quantification is undecidable. </title> <booktitle> In Proceedings of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, Al-buquerque. ACM, </booktitle> <month> January </month> <year> 1992. </year>
Reference: [51] <author> Benjamin C. Pierce. </author> <title> Programming with Intersection Types and Bounded Polymor-phism. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pitts-burgh, PA, </address> <month> December </month> <year> 1991. </year>
Reference: [52] <author> I. C. Pyle. </author> <booktitle> The Ada Programming Language. Prentice-Hall International, </booktitle> <year> 1981. </year>
Reference-contexts: I classify module systems into two types, depending on what sort of facilities they have. First-order module systems have only the trivial module facilities discussed so far: module creation, module naming, and module-component extraction (M.x). Most traditional module systems are of this type. Examples include Ada <ref> [52] </ref>, CLU [36], C [29], C++ [53], and Modula-2 [56]. Higher-order module systems, by contrast, have non-trivial module manipulation facilities. I shall be concerned in this dissertation primarily with three such facilities: functors, submodules, and modules as first-class values. Functors are functions mapping modules to modules.
Reference: [53] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: First-order module systems have only the trivial module facilities discussed so far: module creation, module naming, and module-component extraction (M.x). Most traditional module systems are of this type. Examples include Ada [52], CLU [36], C [29], C++ <ref> [53] </ref>, and Modula-2 [56]. Higher-order module systems, by contrast, have non-trivial module manipulation facilities. I shall be concerned in this dissertation primarily with three such facilities: functors, submodules, and modules as first-class values. Functors are functions mapping modules to modules.
Reference: [54] <author> Daniel C. Swinehart, Polle T. Zellweger, Richard J. Beach, and Robert B. Hagmann. </author> <title> A structural view of the Cedar programming environment. </title> <type> Technical Report CSL-86-1, </type> <institution> Xerox Corporation, Palo Alto, </institution> <month> June </month> <year> 1986. </year>
Reference: [55] <author> Warren Teitelman. </author> <title> The Cedar programming environment: A midterm report and examination. </title> <type> Technical Report CSL-83-11, </type> <institution> Xerox Corporation, Palo Alto, </institution> <month> June </month> <year> 1984. </year>
Reference: [56] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: The approach promises a substantially more powerful module system than those built with previous approaches, while at the same time eliminating the problems associated with the previous approaches. Traditional module systems, such as the one provided by Modula-2 <ref> [56] </ref>, are first-order, allowing only trivial manipulations of modules. Some newer programming languages provide higher-order module systems. Higher-order module systems, unlike first-order ones, permit the non-trivial manipulation of modules within the language. <p> First-order module systems have only the trivial module facilities discussed so far: module creation, module naming, and module-component extraction (M.x). Most traditional module systems are of this type. Examples include Ada [52], CLU [36], C [29], C++ [53], and Modula-2 <ref> [56] </ref>. Higher-order module systems, by contrast, have non-trivial module manipulation facilities. I shall be concerned in this dissertation primarily with three such facilities: functors, submodules, and modules as first-class values. Functors are functions mapping modules to modules.
References-found: 56

