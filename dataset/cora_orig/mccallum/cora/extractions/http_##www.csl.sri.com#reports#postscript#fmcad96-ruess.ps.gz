URL: http://www.csl.sri.com/reports/postscript/fmcad96-ruess.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Email: ruess@informatik.uni-ulm.de  
Title: Hierarchical Verification of Two-Dimensional High-Speed Multiplication in PVS: A Case Study  
Author: Harald Rue 
Address: D-89069 Ulm, Germany  
Affiliation: Universitat Ulm, Fakultat fur Informatik  
Abstract: It is shown how to use the PVS specification language and proof checker to present a hierarchical formalization of a two-dimensional, high-speed integer multiplier on the gate level. We first give an informal description of iterative array multiplier circuits together with a natural refinement into vertical and horizontal stages, and then show how the various features of PVS can be used to obtain a readable, high-level specification. The verification exploits the tight integration between rewriting, arithmetic decision procedures, and equality that is present in PVS. Altogether, this case study demonstrates that the resources of an expressive specification language and of a general-purpose theorem prover permit highly automated verification in this domain, and can contribute to clarity, generality, and reuse.
Abstract-found: 1
Intro-found: 1
Reference: [AH96] <editor> R. Alur and T.A. Henzinger, editors. </editor> <booktitle> Computer-Aided Verification, CAV '96, volume 1102 of Lecture Notes in Computer Science, </booktitle> <address> New Brunswick, NJ, July/August 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference: [AS95] <author> M.D. Aagaard and C.J.H. Seger. </author> <title> The Formal Verification of a Pipelined Double-Precision IEEE Floating-Point Multiplier. </title> <booktitle> In Proc. of ICCAD'95, </booktitle> <pages> pages 7-10. </pages> <publisher> IEEE Computer Science Press, </publisher> <year> 1995. </year>
Reference-contexts: defined types CSA [N] and CPA [N] the parameterized theory iam in 11 is rewritten in a very concise way as shown in 13 . 13 8 Related Work The well-publized FDIV error of initial releases of the Pentium floating-point divider sparked renewed interest in the verification of arithmetic circuits <ref> [Bry95, CB96, KS96, RSS96, ML96, CGZ96, LO95, AS95, KS96] </ref>. For the large number of recent publications in this area, we restrict ourselves to a comparison to work that we think is most closely related to this paper.
Reference: [BC94] <author> R.E. Bryant and Y.A. Chen. </author> <title> Verification of Arithmetic Circuits with Binary Moment Diagrams. </title> <type> Technical Report CMU-CS-94-160, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1994. </year>
Reference-contexts: For the large number of recent publications in this area, we restrict ourselves to a comparison to work that we think is most closely related to this paper. Chen and Bryant <ref> [BC94, CB96] </ref> use Binary Moment Diagrams (BMDs) to verify iterative multipliers for word sizes up to 256 in a hierarchical fashion. At the lower levels, a set of component modules are described at both the bit-level (as combinational circuits) and at the word-level (as algebraic expressions).
Reference: [Bry94] <author> R.E. Bryant. </author> <title> Verification of Arithmetic Functions with Binary Moment Diagrams. </title> <type> Technical Report CMU-CS-94-160, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA 15213, </address> <year> 1994. </year>
Reference-contexts: Almost all automated approaches to hardware-verification, such as model-checking, rely on binary decision diagrams (BDDs) or some variant of these as the underlying representation form. BDD representations of arithmetic circuits such as multiplication or division, however, have been shown to grow exponentially with the word size <ref> [Bry94] </ref>. Consequently, it is not feasible to directly apply BDD-based methods to prove the overall correctness of many interesting arithmetic fl To appear in Formal Methods in Computer Aided Design (FMCAD '96), M. Srivas (Ed.), Palo Alto, November 1996. 1 circuits with wide data paths.
Reference: [Bry95] <author> R.E. Bryant. </author> <title> Bit-Level Analysis of an SRT Divider Circuit. </title> <type> Technical Report CMU-CS-95-140, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA 15213, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: defined types CSA [N] and CPA [N] the parameterized theory iam in 11 is rewritten in a very concise way as shown in 13 . 13 8 Related Work The well-publized FDIV error of initial releases of the Pentium floating-point divider sparked renewed interest in the verification of arithmetic circuits <ref> [Bry95, CB96, KS96, RSS96, ML96, CGZ96, LO95, AS95, KS96] </ref>. For the large number of recent publications in this area, we restrict ourselves to a comparison to work that we think is most closely related to this paper.
Reference: [CB96] <author> Y.A. Chen and R.E. Bryant. ACV: </author> <title> An Arithmetic Circuit Verifier. </title> <booktitle> In IEEE/ACM International Conference on Computer Aided Design (ICCAD-96), </booktitle> <address> San Jose, CA, </address> <month> nov </month> <year> 1996. </year> <note> to appear. </note>
Reference-contexts: defined types CSA [N] and CPA [N] the parameterized theory iam in 11 is rewritten in a very concise way as shown in 13 . 13 8 Related Work The well-publized FDIV error of initial releases of the Pentium floating-point divider sparked renewed interest in the verification of arithmetic circuits <ref> [Bry95, CB96, KS96, RSS96, ML96, CGZ96, LO95, AS95, KS96] </ref>. For the large number of recent publications in this area, we restrict ourselves to a comparison to work that we think is most closely related to this paper. <p> For the large number of recent publications in this area, we restrict ourselves to a comparison to work that we think is most closely related to this paper. Chen and Bryant <ref> [BC94, CB96] </ref> use Binary Moment Diagrams (BMDs) to verify iterative multipliers for word sizes up to 256 in a hierarchical fashion. At the lower levels, a set of component modules are described at both the bit-level (as combinational circuits) and at the word-level (as algebraic expressions).
Reference: [CGZ96] <author> E. M. Clarke, S. M. German, and X. Zhao. </author> <title> Verifying the SRT division al gorithm using theorem proving techniques. </title> <booktitle> In Alur and Henzinger [AH96], </booktitle> <pages> pages 111-122. </pages>
Reference-contexts: defined types CSA [N] and CPA [N] the parameterized theory iam in 11 is rewritten in a very concise way as shown in 13 . 13 8 Related Work The well-publized FDIV error of initial releases of the Pentium floating-point divider sparked renewed interest in the verification of arithmetic circuits <ref> [Bry95, CB96, KS96, RSS96, ML96, CGZ96, LO95, AS95, KS96] </ref>. For the large number of recent publications in this area, we restrict ourselves to a comparison to work that we think is most closely related to this paper.
Reference: [Chi92] <author> S.K. Chin. </author> <title> Verified Functions for Generating Signed-Binary Arithmetic Hardware. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 11(2) </volume> <pages> 1529-1558, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: RLL by developing a common top-level specification that abstracts multiplication in terms of a component that computes the partial sums and another that adds these partial sums to compute the final product; a similar decomposition of multipliers that mimic the usual process of longhand multiplication also been been proposed by <ref> [Chi92] </ref>. The top-level specification in terms of conditional equations is parameterized over circuit-specific details such as the number of partial sums computed in each stage and the adder interconnection. Kapur and Subrahmaniam "instantiate" this top-level scheme with various multipliers such as Wallace tree and an array multiplier.
Reference: [CRSS94] <author> D. Cyrluk, S. Rajan, N. Shankar, and M. Srivas. </author> <title> Effective Theorem Prov ing for Hardware Verification. </title> <editor> In R. Kumar and Th. Kropf, editors, </editor> <title> Theorem Provers in Circuit Design, </title> <booktitle> number 901 in Lecture Notes in Computer Science, </booktitle> <pages> pages 203-222, </pages> <year> 1994. </year>
Reference-contexts: It takes about 15 seconds to complete the proof on a Sun Sparcstation 10. 8 Correctness proofs for N-bit carry-propagate adders have been presented for many different logics and proving systems. Cyrluk et al. <ref> [CRSS94] </ref>, for example, define a specialized proof strategy for proving a slight variant of the above carry-propagate adder and other hardware theorems. An alternative approach of synthesizing word-level properties of iteratively generated circuits from properties of the functional units has been proposed in [HDL90].
Reference: [HDL90] <author> F.K. Hanna, N. Daeche, and M. Longley. </author> <title> Specification and Verification Using Dependent Types. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(9) </volume> <pages> 949-964, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: Cyrluk et al. [CRSS94], for example, define a specialized proof strategy for proving a slight variant of the above carry-propagate adder and other hardware theorems. An alternative approach of synthesizing word-level properties of iteratively generated circuits from properties of the functional units has been proposed in <ref> [HDL90] </ref>. As shown above, however, the improved general-purpose induction strategies of the PVS prover already suffice to automatically prove the correctness of inductively generated carry-propagate adders. <p> It is a straightforward transliteration of the block diagram of the carry-save step in (and verification) has already been noted in <ref> [HDL90] </ref>.
Reference: [Kor93] <author> I. Koren. </author> <title> Computer Arithmetic Algorithms. </title> <publisher> Prentice-Hall, </publisher> <year> 1993. </year>
Reference-contexts: This merging speeds up the multiplication, since the overhead that is due to the separate controls is avoided. Such multipliers, which consist of identical cells, each capable of forming a new partial product and adding it to the previously accumulated partial product, are called iterative array multipliers <ref> [Kor93] </ref>. To illustrate the operation of an iterative array multiplier for unsigned numbers, examine the 4 fi 5 parallelogram shown in Figure 1. This circuit multiplies two N = 5 wide operands, say av and xv.
Reference: [KS96] <author> D. Kapur and M. Subramaniam. </author> <title> Mechanically verifying a family of mul tiplier circuits. </title> <booktitle> In Alur and Henzinger [AH96], </booktitle> <pages> pages 135-146. </pages>
Reference-contexts: defined types CSA [N] and CPA [N] the parameterized theory iam in 11 is rewritten in a very concise way as shown in 13 . 13 8 Related Work The well-publized FDIV error of initial releases of the Pentium floating-point divider sparked renewed interest in the verification of arithmetic circuits <ref> [Bry95, CB96, KS96, RSS96, ML96, CGZ96, LO95, AS95, KS96] </ref>. For the large number of recent publications in this area, we restrict ourselves to a comparison to work that we think is most closely related to this paper. <p> Moreover, circuit descriptions in their specification language ACV are still rather low-level, since this language does not allow to express parameterized designs and sequencing features. Kapur and Subrahmaniam <ref> [KS96] </ref> mechanically verify multiplier circuits in RLL by developing a common top-level specification that abstracts multiplication in terms of a component that computes the partial sums and another that adds these partial sums to compute the final product; a similar decomposition of multipliers that mimic the usual process of longhand multiplication <p> Kapur and Subrahmaniam "instantiate" this top-level scheme with various multipliers such as Wallace tree and an array multiplier. Bit-vectors are encoded in <ref> [KS96] </ref> as linear lists. One consequence of this encoding are side conditions about the length of bit-vector representation in their specifications. This complication is avoided in our approach by using bit-vectors of fixed-sized length, since, in this case, illicit expressions are already detected by the type-checker. <p> Moreover, the specifications in this paper reflect the structure of the underlying circuit and the sizes of the data-path more closely than the ones given in <ref> [KS96] </ref>; one reason for this is the represention of right-shifts in [KS96] by appending trailing zeros 14 to the bit-vectors. Also, the functional representation of the array multiplier in this paper allows one to generate verified gate-level implementations. The construction of the correctness proofs in [KS96] requires a minimum of user <p> Moreover, the specifications in this paper reflect the structure of the underlying circuit and the sizes of the data-path more closely than the ones given in <ref> [KS96] </ref>; one reason for this is the represention of right-shifts in [KS96] by appending trailing zeros 14 to the bit-vectors. Also, the functional representation of the array multiplier in this paper allows one to generate verified gate-level implementations. The construction of the correctness proofs in [KS96] requires a minimum of user interactions (such as manual orientation of some equations) and are very <p> than the ones given in <ref> [KS96] </ref>; one reason for this is the represention of right-shifts in [KS96] by appending trailing zeros 14 to the bit-vectors. Also, the functional representation of the array multiplier in this paper allows one to generate verified gate-level implementations. The construction of the correctness proofs in [KS96] requires a minimum of user interactions (such as manual orientation of some equations) and are very fast; this is mainly due to efficient rewriting and the discovery of appropriate induction schemes by cover set induction.
Reference: [LO95] <author> M. Leeser and J. O'Leary. </author> <title> Verification of a Subtractive Radix-2 Square Root Algorithm and Implementation. </title> <booktitle> In Proc. of ICCD'95, </booktitle> <pages> pages 526-531. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1995. </year> <month> 16 </month>
Reference-contexts: defined types CSA [N] and CPA [N] the parameterized theory iam in 11 is rewritten in a very concise way as shown in 13 . 13 8 Related Work The well-publized FDIV error of initial releases of the Pentium floating-point divider sparked renewed interest in the verification of arithmetic circuits <ref> [Bry95, CB96, KS96, RSS96, ML96, CGZ96, LO95, AS95, KS96] </ref>. For the large number of recent publications in this area, we restrict ourselves to a comparison to work that we think is most closely related to this paper.
Reference: [ML96] <author> P.S. Miner and J.F. Leathrum, Jr. </author> <title> Verification of IEEE compliant sub tractive division algorithms. </title> <editor> In M. Srivas, editor, </editor> <booktitle> Formal Methods in Computer-Aided Design (FMCAD '96), </booktitle> <address> Palo Alto, CA, </address> <month> November </month> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: defined types CSA [N] and CPA [N] the parameterized theory iam in 11 is rewritten in a very concise way as shown in 13 . 13 8 Related Work The well-publized FDIV error of initial releases of the Pentium floating-point divider sparked renewed interest in the verification of arithmetic circuits <ref> [Bry95, CB96, KS96, RSS96, ML96, CGZ96, LO95, AS95, KS96] </ref>. For the large number of recent publications in this area, we restrict ourselves to a comparison to work that we think is most closely related to this paper.
Reference: [ORSvH95] <author> S. Owre, J. Rushby, N. Shankar, and F. von Henke. </author> <title> Formal Verification for Fault-Tolerant Architectures: Prolegomena to the Design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: An Overview of PVS The PVS system combines an expressive specification language with a productive, interactive proof checker that has a reasonable amount of theorem proving capabilities, and has been used for reasoning in domains as diverse as micropro 2 cessor verification, protocol verification, and algorithm and architectures concerning fault-tolerance <ref> [ORSvH95] </ref>. The PVS specification language builds on classical typed higher-order logic with the usual base types bool, nat, rational, real, . . . and the function type constructor [A -&gt; B]. The type system of PVS is augmented with dependent types and abstract data types.
Reference: [RSS96] <author> H. Rue, N. Shankar, and M. K. Srivas. </author> <title> Modular verification of SRT division. In Alur and Henzinger [AH96], pages 123-134. Acknowledgments This case study has been conducted while visiting the formal verification group at SRI International, </title> <address> Menlo Park. </address> <note> I would like to thank S. </note> <author> Owre, J. Rushby, N. Shankar, and M. </author> <title> Srivas for all the support and useful feedback, </title> <editor> and H. </editor> <booktitle> Pfeifer for proof-reading. </booktitle> <pages> 17 </pages>
Reference-contexts: defined types CSA [N] and CPA [N] the parameterized theory iam in 11 is rewritten in a very concise way as shown in 13 . 13 8 Related Work The well-publized FDIV error of initial releases of the Pentium floating-point divider sparked renewed interest in the verification of arithmetic circuits <ref> [Bry95, CB96, KS96, RSS96, ML96, CGZ96, LO95, AS95, KS96] </ref>. For the large number of recent publications in this area, we restrict ourselves to a comparison to work that we think is most closely related to this paper.
References-found: 16

