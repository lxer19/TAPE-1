URL: http://www.cs.kuleuven.ac.be/~lucdr/filp-papers/seitzer.ps
Refering-URL: http://www.cs.kuleuven.ac.be/~lucdr/filp.html
Root-URL: 
Title: Stable ILP Exploring the Added Expressivity of Negation in the Background Knowledge  
Author: Jennifer Seitzer 
Address: USA  
Affiliation: The College of Mount St. Joseph, Mathematics and Computer Science,  
Abstract: We present stable ILP, a cross-disciplinary concept straddling machine learning and nonmonotonic reasoning. Stable models give meaning to logic programs containing negative assertions. In stable ILP, we employ stable models to represent the current state specified by (possibly) negative EDB and IDB rules. The state then serves as the background knowledge for a top-down ILP learner. We present a framework and implementation (system INDED) of one realization of stable ILP. 
Abstract-found: 1
Intro-found: 1
Reference: [ Bratko and Muggleton, 1995 ] <author> Ivan Bratko and Stephen Muggleton. </author> <title> Applications of inductive logic programming. </title> <journal> Communications of the ACM, </journal> <volume> 38(11), </volume> <month> Novem-ber </month> <year> 1995. </year> <title> Presents three indepth examples of applications of ILP. Distinguishes ILP from attribute learning by observeing the capability of ILP to represent structural components of an entity. Finite element (3-D) mesh design has been used in several ILP applications such as GOLEM and FOIL, and has enjoyed some success. ILP has been applied to determining the mutagencity of chemcal compounds and has actually discovered some relationships that scientists were unable to determine using the standard techniques of regression. </title>
Reference: [ Doyle, 1979 ] <author> J. Doyle. </author> <title> A truth maintenance system. </title> <journal> Artificial Intelligence, </journal> <volume> 12 </volume> <pages> 231-272, </pages> <year> 1979. </year> <title> The notion of a "Justification Based Truth Maintenance System" (JTMS) is presented. The fundamental element of a JTMS is a node which is not true nor false, but rather, in or out. The system maintains the sets of in-nodes and out-nodes. </title>
Reference-contexts: The deduction engine computes the current state which is a stable model of the current ground instantiation using the algorithms in [ Seitzer and Schlipf, 1997 ] and [ Seitzer, 1997 ] . This deduction engine is, in essence, a justification truth maintenance system <ref> [ Doyle, 1979 ] </ref> which accomodates nonmonotonic updates in the forms of positive or negative facts. It also accomodates manually entered augmentations in the form of intensional and extensional rules.
Reference: [ Fine, 1989 ] <author> Kit Fine. </author> <title> The justification of negation as failure. </title> <editor> In J.E. Fenstad et. al., editor, </editor> <booktitle> Logic, Methodology and Philosophy of Science VIII, </booktitle> <pages> pages 263-301. </pages> <publisher> Elseview Science Publishers, </publisher> <year> 1989. </year>
Reference-contexts: As is traditional in logic programming research, we restrict our attention to Herbrand models of logic programs. Definition 3.10 (Negation as Failure) The notion of negation as failure states that a statement can be denyed on the grounds that a certain attempt to prove it has failed <ref> [ Fine, 1989 ] </ref> . More formally: If an atomic statement cannot be proved interpret the statement to be false. For example: if some variable a never appears as the head of a rule, it is impossible for a to be proved. Therefore, a is assigned false by negation-as-failure.
Reference: [ Gelfond and Lifschitz, 1990 ] <author> Michael Gelfond and Vladimir Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Proceedings of the Fifth Logic Programming Symposium, </booktitle> <year> 1990. </year>
Reference-contexts: One semantics handling negation which is gaining much attention in the logic programming community is stable semantics because of its accurate depiction of many sorts of human reasoning not captured by classical logic. The stable semantics is defined in <ref> [ Gelfond and Lifschitz, 1990 ] </ref> . In [ Apt and Bol, 1994 ] , the intuition of a stable model is presented as being conceived of its negative literals. It deals with the negations first, and then transitively applies modus ponens to determine the provables. <p> More formally: If an atomic statement cannot be proved interpret the statement to be false. For example: if some variable a never appears as the head of a rule, it is impossible for a to be proved. Therefore, a is assigned false by negation-as-failure. Definition 3.11 (Gelfond-Lifshitz Transform) <ref> [ Gelfond and Lifschitz, 1990 ] </ref> Given normal logic P, the Gelfond-Lifshitz transform denoted GLT P is the definite logic program constructed by this algorithm: Input: logic program P, and two-valued interpretation I Output: definite logic program GLT P BEGIN ALGORITHM 1. Copy each rule from Pto GLT P 2.
Reference: [ Giraud-Carrier and Martinez, 1995 ] <author> C. Giraud-Carrier and T. Martinez. </author> <title> An integrated framework for learning and reasoning. </title> <journal> Journal of Artificial Intelligence Research, </journal> <volume> 3 </volume> <pages> 147-185, </pages> <year> 1995. </year> <title> The system FLARE which combines induction and reasoning is presented. </title>
Reference-contexts: Top-Down Empirical ILP Learner JTMS Nonmonotonic Reasoning System Background Knowledge B = B + [ B Negative Examples E Positive Examples E + Learned Target Predicate - - INDUCTIVE ENGINE DEDUCTIVE ENGINE Architecture of System INDED Recently, there has been other research combining induction and deduction <ref> [ Giraud-Carrier and Martinez, 1995 ] </ref> [ Giraud-Carrier, 1996 ] , but the employment of negation in the intensional domain knowledge and the generation of negative facts by the deduction engine is new. 6 Examples of the proposed Framework One of the challenges of this research is to identify classes of
Reference: [ Giraud-Carrier, 1996 ] <author> C. Giraud-Carrier. Flare: </author> <title> Induction with prior knowledge. </title> <booktitle> Proceedings of Expert Systems'96, </booktitle> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: ILP Learner JTMS Nonmonotonic Reasoning System Background Knowledge B = B + [ B Negative Examples E Positive Examples E + Learned Target Predicate - - INDUCTIVE ENGINE DEDUCTIVE ENGINE Architecture of System INDED Recently, there has been other research combining induction and deduction [ Giraud-Carrier and Martinez, 1995 ] <ref> [ Giraud-Carrier, 1996 ] </ref> , but the employment of negation in the intensional domain knowledge and the generation of negative facts by the deduction engine is new. 6 Examples of the proposed Framework One of the challenges of this research is to identify classes of problems for which explicit negation and
Reference: [ Grobelnik, 1992 ] <author> M. Grobelnik. </author> <title> An optimized model inference system. </title> <booktitle> In Proceedings of the Workshop on Logical Approaches to Machine Learning. Tenth Euro-pean Conference on Artificial Intelligence, </booktitle> <year> 1992. </year>
Reference-contexts: Some of these systems include: FOIL [ Quind-lan, 1990 ] , mFOIL [ Lavrac and Dzeroski, 1994 ] , GOLEM [ Muggleton and Feng, 1992 ] , LINUS [ Lavrac and Dze-roski, 1994 ] , and MARKUS <ref> [ Grobelnik, 1992 ] </ref> . On the other hand, iterative ILP systems are interactive sys-tems that learn multiple predicates simultaneously and process one example at a time. These systems are also referred to as theory revisers.
Reference: [ Kietz and Dzeroski, 1994 ] <author> Jorg-Uwe Kietz and Saso Dzeroski. </author> <title> Inductive logic programming and learnabil-ity. </title> <journal> SIGART Bulletin, A publication of the AI special interest group of the ACM, </journal> <volume> 5(1) </volume> <pages> 22-32, </pages> <year> 1994. </year> <title> A formal definition of an ILP learnable problem is given as a four-tuple: h `,LB, LE, LH i . The notions of learnability through identification in the limit and PAC-learnability are examined and applied to ILP learnable problems. </title>
Reference-contexts: Each of these sets is comprised of first order logic formulas written in their own (possibly identical) languages. To emphasize the fact that B, E, and Hmay be written in different first order languages, Kietz and Lavrac denote the ILP problem h`,LB, LE, LHi <ref> [ Kietz and Dzeroski, 1994 ] </ref> . The current work extends the language of the background knowledge B to include rules with explicit negation, cycles, and contradictory rules. The first two of these extensions are handled by the stable and well-founded semantics, the last is handled by the well-founded semantics. <p> * application of the negation-as-failure stable and/or well-founded semantics to this enriched B * incorporation of the stable semantics in the internal hypothesis construction algorithm through the enhanced entailment notion of stable coverage (which is defined shortly) 2.3 Related Work of Other Researchers Because the general ILP problem is undecidable <ref> [ Kietz and Dzeroski, 1994 ] </ref> , a main topic of ILP research is identifying efficiently learnable subclasses of first-order logic. The examples E = E + [ E , by definition, are restricted to ground atoms. <p> The examples E = E + [ E , by definition, are restricted to ground atoms. ILP learnable first-order logic subclasses, therefore, are realized by constraints and restrictions imposed on the languages of B and H, and on the provability relation <ref> [ Kietz and Dzeroski, 1994 ] </ref> . Much of the work that has been done in ILP seems to fall into two camps: empirical and iterative (or incremental) ILP [ Lavrac and Dzeroski, 1994 ] .
Reference: [ Lavrac and Dzeroski, 1994 ] <author> Nada Lavrac and Saso Dze-roski. </author> <title> Inductive Logic Programming. </title> <publisher> Ellis Horwood, Inc., </publisher> <year> 1994. </year> <title> A comprehensive survey of the basic principles of inductive logic programming. It includes an exposition of fundamental techniques employed as well as descriptions of implementations of these techniques. </title>
Reference-contexts: Some of the areas to which ILP has been applied are data mining, knowledge acquisition, and scientific discovery <ref> [ Lavrac and Dzeroski, 1994 ] </ref> . The goal of an inductive logic programming system is to output a rule which covers an entire set of positive observations, or examples, and excludes or does not cover a set of negative examples [ Muggleton, 1992 ] . <p> Definition 2.1 (coverage) Given background knowledge B , hypothesis H, and example set E , hypothesis H covers example e 2 E with respect to B if B [H j= e. <ref> [ Lavrac and Dzeroski, 1994 ] </ref> Definition 2.2 (Empirical ILP) Given a set of training examples E , consisting of true E + and false E ground facts of an unknown (target) predicate T , a description language L, specifying syntactic restrictions on the definition of predicate T , and background <p> may be used in the definition of T and which provide additional information about the arguments of the examples of predicate T , find a definition H for T , expressed in L, such that H is complete and consistent with respect to the examples E and background knowledge B. <ref> [ Lavrac and Dzeroski, 1994 ] </ref> We see from this definition that there are four sets of interest. B is a set of rules and facts. <p> Much of the work that has been done in ILP seems to fall into two camps: empirical and iterative (or incremental) ILP <ref> [ Lavrac and Dzeroski, 1994 ] </ref> . Empirical ILP systems operate in batch mode, processing all examples at once, learning one predicate at a time. Empirical ILP systems have shown promise in applications [ Bratko and Muggle-ton, 1995 ] . <p> Empirical ILP systems operate in batch mode, processing all examples at once, learning one predicate at a time. Empirical ILP systems have shown promise in applications [ Bratko and Muggle-ton, 1995 ] . Some of these systems include: FOIL [ Quind-lan, 1990 ] , mFOIL <ref> [ Lavrac and Dzeroski, 1994 ] </ref> , GOLEM [ Muggleton and Feng, 1992 ] , LINUS [ Lavrac and Dze-roski, 1994 ] , and MARKUS [ Grobelnik, 1992 ] . <p> Algorithm 4.1 (Hypothesis Construction) This generic top-down algorithm has been assumed for the included ILP examples in this work and has been implemented in the system INDED. The algorithm is from <ref> [ Lavrac and Dzeroski, 1994 ] </ref> and forms the underpinnings of FOIL and GOLEM, among other top-down ILP systems.
Reference: [ Lloyd, 1984 ] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year> <note> Presents a theoretical exposition of logic programming. This is an excellent source for the theoretical underpinnings of logic programming. </note>
Reference-contexts: A logic program P is a (usually finite) set of normal rules. If each subgoal fi i is an atomic formula (a non-negative literal), then the rule is said to be definite or Horn. A definite logic program P0 contains only definite rules <ref> [ Lloyd, 1984 ] </ref> . Definition 3.5 (ground terms and formulas) A term is ground if it contains no variables (only constant and/or function symbols). <p> ; : : : ; fi n ) is a quantifier-free formula of the form ff fi 1 ; : : : ; fi n where each variable X 1 : : : X k appearing in ff and/or in each fi i has been replaced with a ground term <ref> [ Lloyd, 1984 ] </ref> . Definition 3.6 (Herbrand universe) The Herbrand universe U P of a logic program P is the set of all ground terms of P. The Herbrand base B P of P is the set of all ground positive literals of P [ Lloyd, 1984 ] . <p> replaced with a ground term <ref> [ Lloyd, 1984 ] </ref> . Definition 3.6 (Herbrand universe) The Herbrand universe U P of a logic program P is the set of all ground terms of P. The Herbrand base B P of P is the set of all ground positive literals of P [ Lloyd, 1984 ] . Definition 3.7 (ground instantiation) The ground instantiation of a logic program P is the set of all possible ground instances of the rules of P. <p> P <ref> [ Lloyd, 1984 ] </ref> . Definition 3.7 (ground instantiation) The ground instantiation of a logic program P is the set of all possible ground instances of the rules of P. This is formed by performing all possible substitutions of elements of the Herbrand universe on the rules of P. [ Lloyd, 1984 ] Definition 3.8 (model of a logic program) An interpretation I is a model of a logic program P if it assigns each rule in P 8X 1 ; : : : ; X k (ff fi 1 ; : : : ; fi n ) the truth <p> A positive subgoal a is false in I if a 62 I. A negative subgoal :a is false in I if a 2 I. Definition 3.9 (Herbrand Model) An Herbrand model of P is an Herbrand interpretation of P which is a model of P <ref> [ Lloyd, 1984 ] </ref> [ Lloyd, 1984 ] . As is traditional in logic programming research, we restrict our attention to Herbrand models of logic programs. <p> A positive subgoal a is false in I if a 62 I. A negative subgoal :a is false in I if a 2 I. Definition 3.9 (Herbrand Model) An Herbrand model of P is an Herbrand interpretation of P which is a model of P <ref> [ Lloyd, 1984 ] </ref> [ Lloyd, 1984 ] . As is traditional in logic programming research, we restrict our attention to Herbrand models of logic programs.
Reference: [ Muggleton and Feng, 1992 ] <author> S. Muggleton and C. Feng. </author> <title> Efficient induction of logic programs. In Inductive Logic Programming. </title> <publisher> Academic Press, Inc, </publisher> <year> 1992. </year> <title> The system GOLEM is introduced. GOLEM uses a ground background knowledge and i-j determinacy bias in the hypothesis language. It is a bottom-up empirical ILP system which uses h-easy relative least general generalizations for clause construction. </title>
Reference-contexts: Empirical ILP systems have shown promise in applications [ Bratko and Muggle-ton, 1995 ] . Some of these systems include: FOIL [ Quind-lan, 1990 ] , mFOIL [ Lavrac and Dzeroski, 1994 ] , GOLEM <ref> [ Muggleton and Feng, 1992 ] </ref> , LINUS [ Lavrac and Dze-roski, 1994 ] , and MARKUS [ Grobelnik, 1992 ] . On the other hand, iterative ILP systems are interactive sys-tems that learn multiple predicates simultaneously and process one example at a time.
Reference: [ Muggleton, 1992 ] <author> Stephen Muggleton, </author> <title> editor. Inductive Logic Programming. </title> <publisher> Academic Press, Inc, </publisher> <year> 1992. </year> <title> A collection of the seminal papers in the discipline of inductive logic programming. </title>
Reference-contexts: The goal of an inductive logic programming system is to output a rule which covers an entire set of positive observations, or examples, and excludes or does not cover a set of negative examples <ref> [ Muggleton, 1992 ] </ref> . This rule is constructed using a set of known facts and rules, knowledge, called domain or background knowledge. In essence, the ILP objective is to synthesize a logic program, or at least part of a logic program using examples, background knowledge, and an entailment relation.
Reference: [ Quindlan, 1990 ] <author> R. Quindlan. </author> <title> Learning logical definitions from relations. </title> <journal> Machine Learning, </journal> <volume> 5 </volume> <pages> 239-266, </pages> <year> 1990. </year> <title> The top-down ILP system FOIL is introduced. FOIL transforms intensional B to ground facts and generates E by CWA. FOIL generates a hypothesis Hwhich is function-free (including no constants) and possibly normal (allowing explicit negation). </title>
Reference: [ Sammut and Banerji, 1986 ] <author> C. Sammut and R. Banerji. </author> <title> Learning concepts by asking questions. </title> <booktitle> In Machine Learning: An Artificial Approach, </booktitle> <volume> Vol II, </volume> <pages> pages 167-191. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1986. </year> <title> Interactive ILP system MARVIN is introduced. </title>
Reference-contexts: On the other hand, iterative ILP systems are interactive sys-tems that learn multiple predicates simultaneously and process one example at a time. These systems are also referred to as theory revisers. Some of these systems include MIS [ Shaprio, 1983 ] and MARVIN <ref> [ Sammut and Banerji, 1986 ] </ref> . Most of these systems require extensional background knowledge. All of these systems employ background knowledge devoid of explicit negation and cycles. Many do, however, allow negation in generated hypotheses.
Reference: [ Schulze-Kremer, 1996 ] <author> Steffen Schulze-Kremer. </author> <title> Molecular Bioinformatics; Algorithms and Applications. </title> <publisher> Walter de Gruyter, </publisher> <year> 1996. </year> <title> A work emphasizing the interdisciplinary nature of DNA sequence analysis bridging the theory of computer science with biology. </title>
Reference-contexts: We are currently investigating the efficacy of utilizing explicit negation in the representation of the secondary structure of proteins as discussed in [ Bratko and King, 1994 ] and <ref> [ Schulze-Kremer, 1996 ] </ref> . We are currently experimenting with INDED in this domain. Anther real-world problem that we are studying is the diagnosis of Lyme Disease because of its seemingly contradictory symptom sets.
Reference: [ Seitzer and Schlipf, 1997 ] <author> Jennifer Seitzer and John Schlipf. </author> <title> Affordable classes of normal logic programs. </title> <booktitle> In Lecture Notes in Artificial Intelligence: Logic Programming and Nonmonotonic Reasoning Fourth International Conference Proceedings. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <title> (To appear.) The classes of normal logic programs called unit uni-rule and uni-appearance are presented. Algorithms for computing their stable models in linear time are stated. The class uni-rule is introduced and it is shown that finding a stable model for an element of this class is NP-hard. </title>
Reference-contexts: It is comprised of two main computation engines. The deduction engine computes the current state which is a stable model of the current ground instantiation using the algorithms in <ref> [ Seitzer and Schlipf, 1997 ] </ref> and [ Seitzer, 1997 ] . This deduction engine is, in essence, a justification truth maintenance system [ Doyle, 1979 ] which accomodates nonmonotonic updates in the forms of positive or negative facts.
Reference: [ Seitzer, 1997 ] <author> Jennifer Seitzer. Inded: </author> <title> A symbiotic system of induction and deduction. </title> <booktitle> In Lecture Notes in Artificial Intelligence: Proceedings of Logic Programming and Knowledge Representation (LPKR'97) in conjunction with ILPS'97. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <title> (Currently in submission.) A system description of an implementation of Stable-ILP is presented. The notion of negation as failure-to-learn is introduced. A real world source of negatively recursive rules is presented by explicating scenarios that foster induction of such rules. </title>
Reference-contexts: It is comprised of two main computation engines. The deduction engine computes the current state which is a stable model of the current ground instantiation using the algorithms in [ Seitzer and Schlipf, 1997 ] and <ref> [ Seitzer, 1997 ] </ref> . This deduction engine is, in essence, a justification truth maintenance system [ Doyle, 1979 ] which accomodates nonmonotonic updates in the forms of positive or negative facts. It also accomodates manually entered augmentations in the form of intensional and extensional rules.
Reference: [ Shaprio, 1983 ] <author> E. Shaprio. </author> <title> Algorithmic Program Debugging. </title> <publisher> MIT Press, </publisher> <year> 1983. </year> <title> The seminal ILP system, MIS, is introduced. MIS is an interactive ILP system employing both intensional and extensional background knowledge. </title>
Reference-contexts: On the other hand, iterative ILP systems are interactive sys-tems that learn multiple predicates simultaneously and process one example at a time. These systems are also referred to as theory revisers. Some of these systems include MIS <ref> [ Shaprio, 1983 ] </ref> and MARVIN [ Sammut and Banerji, 1986 ] . Most of these systems require extensional background knowledge. All of these systems employ background knowledge devoid of explicit negation and cycles. Many do, however, allow negation in generated hypotheses.
Reference: [ VanGelder et al., 1991 ] <author> A. VanGelder, K. Ross, and J. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> Journal of the ACM, </journal> <volume> 38(3), </volume> <month> July </month> <year> 1991. </year> <title> Presents the classical well-founded semantics as the result of the consequence relation union the negation of the greatest unfounded set. Computation of the semantics is presented as an iterative constructin of the complement of the greatest unfounded set. Characterizations of rules including strongly falsified, weakly falsified, and satisfied, are presented. Observations connecting the well-founded semantics to these characterizations are presented. </title>
Reference-contexts: It deals with the negations first, and then transitively applies modus ponens to determine the provables. The well-founded semantics is a three-valued version of the stable semantics <ref> [ VanGelder et al., 1991 ] </ref> . That is, instead of only assigning propositions true or false , it also allows for a value representing ignorance. <p> The winner is the one who has the last valid move. The IDB part of this example is a standard example amongst stable model researchers and is borrowed from <ref> [ VanGelder et al., 1991 ] </ref> . The author extends it to learn the predicate losing (X). Input to deduction engine..IDB: --------------------------- winning (X) &lt;-- move (X,Y), ~winning (Y) . Input to deduction engine..EDB: --------------------------- move (a,b) &lt;-- . move (b,a) &lt;-- . 1.
References-found: 19

