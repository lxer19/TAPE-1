URL: http://tigereye.cs.brandeis.edu/~tim/narrow_multiply/paper.ps
Refering-URL: http://tigereye.cs.brandeis.edu/~tim/smath.html
Root-URL: http://www.cs.brandeis.edu
Email: ftim,qung@cs.brandeis.edu  
Title: Efficient Implementation of Interval Arithmetic Narrowing Using IEEE Arithmetic  
Author: Timothy J. Hickey and Qun Ju 
Web: http://www.cs.brandeis.edu/ tim  
Address: Waltham, MA, USA, 02254  
Affiliation: Computer Science Department Brandeis University  
Abstract: We present and analyze several implementations of the interval arithmetic narrowing function for multiplication. Starting from the Cleary algorithm for narrowing multiplication we describe two optimizations which produce code that is 10-15 times faster on the average. Finally, we propose a few simple RISC instructions which would allow efficient execution of interval arithmetic and narrowing routines. These new instructions require a new rounding mode which extends the "round-toward-infinity" mode of the IEEE 754 floating point standard. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> Benhamou, F. and Older, W., </editor> <title> Applying interval arithmetic to real, integer, and boolean constraints. </title> <journal> Journal of Logic Programming. </journal>
Reference-contexts: This convention allows us to make use of the fact that 1=(0) = 1 and 1=0 = +1 to more easily compute quotients of IEEE intervals. We represent the empty interval, EMPTY, by the pair <ref> [1; 1] </ref>. <p> (a; b; c) 2 (X; Y; Z) : a fl b = cg) Similarly, the narrowing function for addition is defined by: N + (X; Y; Z) = ff 3 (f (a; b; c) 2 (X; Y; Z) : a + b = cg) For example, N fl ([1; 5]; <ref> [1; 1] </ref>; [2; 10]) = ([2; 5]; [0:4; 1]; [2; 5]). It is quite easy to evaluate the narrowing function N + on IEEE intervals. The following theorem shows that this can be done using the add hi/lo and sub hi/lo functions. <p> : a fl b = cg) Similarly, the narrowing function for addition is defined by: N + (X; Y; Z) = ff 3 (f (a; b; c) 2 (X; Y; Z) : a + b = cg) For example, N fl ([1; 5]; [1; 1]; [2; 10]) = ([2; 5]; <ref> [0:4; 1] </ref>; [2; 5]). It is quite easy to evaluate the narrowing function N + on IEEE intervals. The following theorem shows that this can be done using the add hi/lo and sub hi/lo functions. <p> = fa=b : a 2 A; b 2 B f0gg To properly define narrowing of multiplication we need the following modified division operator A ff B which can be thought of extending the A=B operator by treating 0=0 as an undefined quantity that could take any value in the range <ref> [1; 1] </ref>. Definition 1.4 For any sets A,B of real numbers, we define the modified quotient A ff B by ( [1; 1] else These definitions allow us to express the multiplicative narrowing function using three simpler functions, as follows. <p> division operator A ff B which can be thought of extending the A=B operator by treating 0=0 as an undefined quantity that could take any value in the range <ref> [1; 1] </ref>. Definition 1.4 For any sets A,B of real numbers, we define the modified quotient A ff B by ( [1; 1] else These definitions allow us to express the multiplicative narrowing function using three simpler functions, as follows. <p> Say that Y <ref> [0; 1] </ref> so that neg (Y ) pos (Y ) = Y . <p> Thus, either Z is split or Y is split. If Z contains zero, then odiv (Z; X) = <ref> [1; 1] </ref> so Y 0 = Y . If Y is split and Z doesn't contain zero and X 0 is still split, then there are positive and negative solutions to x fl y = z and so Y 0 = Y . <p> If Z contains 0, then G (X; Y; Z) = X. On the other hand, if e &gt; 0 then G (X; Y; Z) = union (([a; b] " <ref> [1; div hi (e; c))); ([a; b] </ref> " (div lo (e; d); 1])) where the critical point to notice is that [a; b] is being intersected with an open interval in both cases, so it is impossible for either of these intersections to be [0; 0]. <p> Similarly, if f &lt; 0 then G (X; Y; Z) = union (([a; b] " <ref> [1; div hi (f; d))); ([a; b] </ref> " (div lo (f; c); 1])) Proof: This follows directly from the definitions. <p> For the modified division X ff Y , if X and Y both contain zero, then the result is <ref> [1; 1] </ref>. If Y = [0; 0] and X doesn't contain zero, then the result is the EMPTY interval. Otherwise, for both multiplication and division there are three cases for X and three for Y as follows: P:a 0, N:b 0, S:a &lt; 0 &lt; b. <p> analysis for the non-exceptional cases are as follows; case : mul ([a; b]; [c; d]) odiv ([a; b]; [c; d]) P P : [mul lo (a; c); mul hi (b; d)] [div lo (a; d); div hi (b; c)] P S : [mul lo (b; c); mul hi (b; d)] <ref> [1; 1] </ref> N N : [mul lo (b; d); mul hi (a; c)] [div lo (b; d); div hi (a; c)] SP : [mul lo (a; d); mul hi (b; d)] [div lo (a; c); div hi (b; c)] SS : [min (mul lo (a; d); mul lo (b; c)); [1; <p> : [mul lo (b; c); mul hi (b; d)] [1; 1] N N : [mul lo (b; d); mul hi (a; c)] [div lo (b; d); div hi (a; c)] SP : [mul lo (a; d); mul hi (b; d)] [div lo (a; c); div hi (b; c)] SS : <ref> [min (mul lo (a; d); mul lo (b; c)); [1; 1] </ref> In all of these cases, IEEE rounded arithmetic yields the correct results even for infinite and signed zero values because the case analysis eliminates all NaN cases of 0 fl 1, 0=0, etc. <p> <ref> [1; 1] </ref> N N : [mul lo (b; d); mul hi (a; c)] [div lo (b; d); div hi (a; c)] SP : [mul lo (a; d); mul hi (b; d)] [div lo (a; c); div hi (b; c)] SS : [min (mul lo (a; d); mul lo (b; c)); [1; 1] In all of these cases, IEEE rounded arithmetic yields the correct results even for infinite and signed zero values because the case analysis eliminates all NaN cases of 0 fl 1, 0=0, etc. <p> Notice that the case in mul (X; Y ) where X or Y is zero must be handled separately, as otherwise [0; 0] fl <ref> [0; 1] </ref> would result in a NaN value 0 fl 1, as must the odiv (X; [0; 0]) case. 4.3 The Enhanced Modes Method There is another way to compute the product which eliminates the case analysis. <p> The remaining cases are defined as follows where fi (x; y) denotes the interval [mul loE (x; y); mul hiE (x; y)]: fi (0; 1) = fi ((0); 1) = fi (1; 0) = fi (1; (0)) = <ref> [0; 1] </ref> We call these the exceptional cases for the enhanced rounding modes for multiplication. <p> extensions of div lo and div hi where the values on the exceptional cases for division are given by the following, where ffi (x; y) = [div loE (x; y); div hiE (x; y)]: ffi (0; (0)) = ffi ((0); 0) = ffi (1; 1) = ffi (1; 1) = <ref> [1; 0] </ref> With these enhanced modes we can now compute the product and modified quotient of two IEEE intervals with much less case analysis: Theorem 4.5 Let X = [a; b] and Y = [c; d] be non-empty IEEE intervals. <p> QED Theorem 4.6 Let X = [a; b] and Y = [c; d] be non-empty IEEE intervals. If Y is zero, then odiv (X; Y ) is either <ref> [1; 1] </ref> if X contains zero, or is empty. Otherwise, if both X and Y contain zero then odiv (X; Y ) = [1; 1]. <p> If Y is zero, then odiv (X; Y ) is either <ref> [1; 1] </ref> if X contains zero, or is empty. Otherwise, if both X and Y contain zero then odiv (X; Y ) = [1; 1].
Reference: [2] <author> John C. Cleary, </author> <title> Logical Arithmetic, </title> <journal> Future Computing Systems, </journal> <volume> 2(2), </volume> <year> 1987, </year> <pages> pp. 125-149. </pages>
Reference-contexts: c) 2 (X; Y; Z) : a fl b = cg) Similarly, the narrowing function for addition is defined by: N + (X; Y; Z) = ff 3 (f (a; b; c) 2 (X; Y; Z) : a + b = cg) For example, N fl ([1; 5]; [1; 1]; <ref> [2; 10] </ref>) = ([2; 5]; [0:4; 1]; [2; 5]). It is quite easy to evaluate the narrowing function N + on IEEE intervals. The following theorem shows that this can be done using the add hi/lo and sub hi/lo functions. <p> fl b = cg) Similarly, the narrowing function for addition is defined by: N + (X; Y; Z) = ff 3 (f (a; b; c) 2 (X; Y; Z) : a + b = cg) For example, N fl ([1; 5]; [1; 1]; [2; 10]) = (<ref> [2; 5] </ref>; [0:4; 1]; [2; 5]). It is quite easy to evaluate the narrowing function N + on IEEE intervals. The following theorem shows that this can be done using the add hi/lo and sub hi/lo functions. <p> QED 2 The Partition Algorithm The simplest algorithm we consider for narrowing the multiplication relation is based on narrowing algorithms (for more general classes of intervals) described by Cleary <ref> [2] </ref> and Hyvonen [8], and implemented in Scheme by Cleary et. al. as part of a CLP (interval) interpreter [3].
Reference: [3] <author> John C. Cleary, Alan Dewar, </author> <title> Vinit Kaushik and Sue Rempel Scheme Prolog 1.2 http://www.cs.indiana.edu/scheme-repository/code.lang.html </title>
Reference-contexts: QED 2 The Partition Algorithm The simplest algorithm we consider for narrowing the multiplication relation is based on narrowing algorithms (for more general classes of intervals) described by Cleary [2] and Hyvonen [8], and implemented in Scheme by Cleary et. al. as part of a CLP (interval) interpreter <ref> [3] </ref>.
Reference: [4] <author> Patrick Cousot, and Radhia Cousot, </author> <title> Abstract Interpretation: A Unified Lattice Model for Static Analysis of Programs by Construction or Approximation of Fixed Points 4th Symposium on Principles of Programming Languages, </title> <month> January </month> <year> 1977, </year> <pages> pp. 238-252. </pages>
Reference-contexts: (mul lo (X.hi,Y.lo),mul lo (X.lo,Y.hi))) The algorithm given in the next section uses the framework of abstract interpretation to make this type of optimization in a principled way. 3 The Abstract Domain Algorithm The idea behind the Abstract Domain algorithm derived in this section is to use abstract interpretation techniques <ref> [4] </ref> to classify the possible inputs into special cases which can be narrowed using routines optimized for those cases. This method leads to our most efficient narrowing algorithm for multiplication, but other abstract domains may lead to even better algorithms. This is an area which deserves further study.
Reference: [5] <author> Goldberg, D. </author> <title> What Every Computer Scientist Should Know About Floating-Point Arithmetic ACM Computing Surveys, </title> <journal> Vol. </journal> <volume> 23, No. 1, </volume> <year> 1991. </year>
Reference-contexts: A nice overview of the standard can be found in Goldberg's survey article <ref> [5] </ref>. The IEEE 754 standard provides a precise definition of how floating point numbers are represented as bit strings and how the arithmetic operations (+,-,*,/,sqrt) are implemented. <p> fl b = cg) Similarly, the narrowing function for addition is defined by: N + (X; Y; Z) = ff 3 (f (a; b; c) 2 (X; Y; Z) : a + b = cg) For example, N fl ([1; 5]; [1; 1]; [2; 10]) = (<ref> [2; 5] </ref>; [0:4; 1]; [2; 5]). It is quite easy to evaluate the narrowing function N + on IEEE intervals. The following theorem shows that this can be done using the add hi/lo and sub hi/lo functions.
Reference: [6] <author> Hickey, T. </author> <title> CLP(F) and Constrained ODEs ECRC Technical report Proceedings of the Workshop and Constraints and Modelling Ithica, </title> <address> NY, </address> <year> 1994 </year>
Reference: [7] <editor> Hickey, T. </editor> <address> Smath library. http://www.cs.brandeis.edu/ ~ tim/smath.html </address>
Reference-contexts: The EM and PA implementations are nearly equivalent for unoptimized code. EM is about twice as fast as PA when optimized, but is still 2-3 times slower than the IA. The code used for these experiments can be found in <ref> [7] </ref>. We have found that many of the standard optimizing C compilers generate code that does not respect the rounding modes, and hence when our narrowing procedures are compiled with optimization switches set, they often produce incorrect results. When the optimization is turned off then, correct code is generated.
Reference: [8] <author> Eero Hyvonen. </author> <title> Constraint reasoning based on interval arithmetic: </title> <booktitle> the tolerance propogation approach Artificial Intelligence, 58 (1992), </booktitle> <pages> pp. 71-112. </pages>
Reference-contexts: QED 2 The Partition Algorithm The simplest algorithm we consider for narrowing the multiplication relation is based on narrowing algorithms (for more general classes of intervals) described by Cleary [2] and Hyvonen <ref> [8] </ref>, and implemented in Scheme by Cleary et. al. as part of a CLP (interval) interpreter [3].
Reference: [9] <institution> IEEE Standard for Binary Floating-Point Arithmetic, ANSI/IEEE Std 754-1985. Institute of Electrical and Electronics Engineers, Inc., </institution> <address> 345 East 47th St, NY, NY, 10017, USA. </address>
Reference-contexts: of the standard operators and commonly used mathematical functions (e.g., y = cos (x), z = x y , etc.). 1.1 IEEE 754 arithmetic Throughout the paper, unless explicitly stated otherwise, we will assume that floating point arithmetic is implemented according to the IEEE 754-1985 Standard on Floating Point Arithmetic <ref> [9] </ref>. A nice overview of the standard can be found in Goldberg's survey article [5]. The IEEE 754 standard provides a precise definition of how floating point numbers are represented as bit strings and how the arithmetic operations (+,-,*,/,sqrt) are implemented.
Reference: [10] <author> Older, W. and Vellino, A., </author> <title> Constraint Arithmetic on Real Intervals, in Constraint Logic Programming: Selected Research Colmerauer, </title> <editor> A. and Benhamou, F. (eds), </editor> <publisher> MIT Press 1993. </publisher>
Reference-contexts: c) 2 (X; Y; Z) : a fl b = cg) Similarly, the narrowing function for addition is defined by: N + (X; Y; Z) = ff 3 (f (a; b; c) 2 (X; Y; Z) : a + b = cg) For example, N fl ([1; 5]; [1; 1]; <ref> [2; 10] </ref>) = ([2; 5]; [0:4; 1]; [2; 5]). It is quite easy to evaluate the narrowing function N + on IEEE intervals. The following theorem shows that this can be done using the add hi/lo and sub hi/lo functions.
Reference: [11] <author> Pascal van Hentenryck, and Laurent Michel. </author> <title> Newton: Constraint Programming over Nonlinear Constraints Brown University CS Dept. </title> <type> Tech. report, </type> <year> 1996. </year>
References-found: 11

