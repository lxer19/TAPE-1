URL: http://www.tns.lcs.mit.edu/~djw/library/osdi96/seltzer.ps.gz
Refering-URL: http://www.tns.lcs.mit.edu/~djw/library/osdi96/index.html
Root-URL: 
Email: Email: office@usenix.org  
Title: Dealing With Disaster: Surviving Misbehaved Kernel Extensions  
Phone: 1. Phone: 510 528-8649 2. FAX: 510 548-5738 3.  4.  
Author: Margo I. Seltzer, Yasuhiro Endo, Christopher Small, Keith A. Smith 
Affiliation: Harvard University  
Web: WWW URL: http://www.usenix.org  
Date: October 1996  
Note: The following paper was originally published in the Proceedings of the USENIX 2nd Symposium on Operating Systems Design and Implementation Seattle, Washington,  For more information about USENIX Association contact:  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Accetta, M., Baron, R., Bolosky, W., Golub, D., Rashid, R., Tevanian, A., and Young, M., </author> <title> Mach: A New Kernel Foundation for UNIX Development, </title> <booktitle> Proc. Summer 1986 USENIX Conf., </booktitle> <address> Atlanta, GA, </address> <month> July </month> <year> 1986, </year> <month> 93112. </month>
Reference-contexts: This problem has been addressed by the use of safe languages such as Modula-3 [11], as used by SPIN, software fault isolation [20], as used by VINO, or virtual memory address domains, as used by Mach <ref> [1] </ref>. Second, the kernel must ensure that grafts do not consume resources to the extent that they jeopardize the acceptable performance of the kernel and other applications. This problem has been less well researched and is the topic of this paper.
Reference: [2] <author> Appel, A., Li, K., </author> <title> Virtual Memory Primitives for User Programs, </title> <booktitle> Proc. ASPLOS IV, </booktitle> <address> Santa Clara, CA, </address> <month> April </month> <year> 1991, </year> <month> 96107. </month>
Reference: [3] <author> Baker, M., Hartman, J., Kupfer, M., Shirriff, K., Ousterhout, J., </author> <title> Measurements of a Distributed File System, </title> <booktitle> Proc. 13th SOSP, </booktitle> <address> Pacific Grove, CA, </address> <month> Oct. </month> <year> 1991, 198212. </year>
Reference-contexts: A typical file read-ahead policy operates on the assumption that most applications perform sequential I/O. When the system detects sequential access to a file, it asynchronously prefetches some additional amount of file data with each read request. Because most file accesses are sequential <ref> [3] </ref>, this policy usually improves performance. There are several cases, however, where this general policy does not improve (and can even degrade) application perfor-mance [12]. At first glance, it may seem that user-level threads are the simple and obvious solution to application-directed prefetching.
Reference: [4] <author> Bershad, B., Savage, S., Pardyak, P., Sirer, E. G., Fiuczynski, M., Becker, D., Eggers, S., Chambers, C., </author> <title> Extensibility, Safety, and Performance in the SPIN Operating System, </title> <booktitle> Proc. 15th SOSP, </booktitle> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995, </year> <month> 267284. </month>
Reference-contexts: By targeting a particular kernel for a particular workload, Scout can take advantage of advanced compiler optimization techniques, efficient kernel code paths, and a smaller system footprint. The extensible systems, such as SPIN <ref> [4] </ref> and VINO [15] allow applications to download code into the kernel to provide improved functionality and performance. Synthetix [13] provides improved exibility and functionality by iden tifying commonly executed paths and producing optimized versions of them, but does not allow applications to modify or extend the kernel. <p> However, an application may want to drop an entire service into the kernel, such as an HTTP server <ref> [4] </ref>, an NFS server, or a database server. Our event graft model is based on the idea that these services are typically, if not always, designed to respond to a stream of incoming external events. Each of these servers receives a request, processes it, and sends a response. <p> It is most similar to the SPIN system <ref> [4] </ref>. In SPIN, extensions are written in a typesafe language (Modula-3) and downloaded into the kernel where they initiate a thread. Once installed, the thread can install handlers for any kernel events for which it has appropriate permission and in which it is interested.
Reference: [5] <author> Cao, P., Felten, E., and Li, K., </author> <title> Application-Controlled File Caching Policies, </title> <booktitle> Proc. 1994 Summer USENIX Conf., </booktitle> <address> Boston, MA, </address> <month> June </month> <year> 1994, </year> <month> 171182. </month>
Reference-contexts: We find this model of behavior acceptable, applying Cao's principle for defining an acceptable allocation policy: the selection of an application specific policy should not adversely affect other applications <ref> [5] </ref>. The task of the kernel is to prevent grafts from damaging the integrity of the kernel. <p> The VAS-specific function can accept the victim page or suggest another page as a replacement (similar to Caos replacement strategy <ref> [5] </ref>). The global algorithm then verifies that the selected page belongs to the specific VAS and is not wired. If either of these checks fails the system ignores the request and evicts the original victim.
Reference: [6] <author> Engler, D., Kaashoek, F., and OToole, J., Exokernel: </author> <title> An Operating System Architecture for Application-Level Resource Management, </title> <booktitle> Proc. 15th SOSP, </booktitle> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995, </year> <month> 251266. </month>
Reference-contexts: Where the function graft model (discussed in section 3.4) is appropriate for simple, fine-grained graft points that correspond to single functions, event graft points provide better support for the addition of new services to the kernel. The Exokernel project <ref> [6] </ref> is an extreme example of an extensible system. The goal of the Exokernel project is to remove abstractions from the kernel and export a low-level machine interface directly to applications.
Reference: [7] <author> Haskin, R., Malachi, Y., Sawdon, W., and Chan, G., </author> <title> Recovery Management in QuickSilver, </title> <journal> ACM TOCS 6, </journal> <volume> 1, </volume> <month> Feb. </month> <year> 1988, </year> <month> 82108. </month>
Reference-contexts: When a nested transaction commits, its undo call stack and locks are merged with those of its parent. Although different in implementation, graft transactions are similar in concept to the volatile transactions used in the Quicksilver system <ref> [7] </ref>. 3.2 When to Abort Graft Transactions Transactions provide the mechanism by which we can abort resource intensive grafts, but we still need a policy to determine when to abort a graft. Grafts are allowed to run so long as they do not interfere with the behavior of other processes.
Reference: [8] <author> Illustra Information Technologies, </author> <title> Introduction to Illustra, Part No. ILL0795-01Ill, Illustra Web DataBlade Users Guide, Release 2.1 Beta. </title> <month> Sep. </month> <year> 1995. </year> <title> Part No. </title> <publisher> WEB-00-12-UG. </publisher>
Reference-contexts: Such extensibility is useful in a wide range of systems. Database clients might extend their server by loading code into it to support new data types <ref> [8] </ref>. In a traditional operating system, user applications can exploit extensibility to customize the policies and functionality implemented by the kernel (e.g., the eviction policy for the file cache, or the delivery order for signals and other asynchronous events).
Reference: [9] <author> Montz, A., Mosberger, D., O'Malley, S., Peterson, L., Proebsting, T., Hartman, J., </author> <title> Scout: A Communications-Oriented Operating System, </title> <institution> Department of Computer Science, University of Arizona, </institution> <type> Technical Report 94-20, </type> <month> June </month> <year> 1994. </year>
Reference-contexts: 1 Introduction Many of todays research operating systems share the goal of providing applications with a richer and more powerful interface to kernel functionality. There are several approaches undergoing exploration and analysis today. The Scout system <ref> [9] </ref> supports static specialization: Scout administrators can run a kernel that has been specialized for a particular workload on a particular machine. By targeting a particular kernel for a particular workload, Scout can take advantage of advanced compiler optimization techniques, efficient kernel code paths, and a smaller system footprint.
Reference: [10] <institution> Microsoft Corp., How Software Publishers Can Use Authenticode Technology, </institution> <address> http://www.microsoft.com/ intdev/signcode. </address>
Reference-contexts: When VINO loads a graft it recomputes the checksum and compares it with the saved copy. If the two do not match the graft is not loaded. Tools that perform this type of code signing are commercially available <ref> [10] </ref>. 3.4 Function Graft Example Once a graft has been compiled, processed by MiSFIT, and assembled, it is ready to be grafted into the running system. To install a graft, an application must first obtain a handle for the graft point.
Reference: [11] <author> Nelson, G., </author> <title> Systems Programming with Modula-3, </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: First, the kernel must guarantee that grafts do not misuse memory by reading inappropriate data (e.g., device registers or another users data), writing inappropriate data, or executing bad instructions. This problem has been addressed by the use of safe languages such as Modula-3 <ref> [11] </ref>, as used by SPIN, software fault isolation [20], as used by VINO, or virtual memory address domains, as used by Mach [1]. Second, the kernel must ensure that grafts do not consume resources to the extent that they jeopardize the acceptable performance of the kernel and other applications.
Reference: [12] <author> Patterson, R. H., Gibson, G. A., Ginting, E., Stodolsky, D., and Zelenka, J., </author> <title> Informed Prefetching and Caching, </title> <booktitle> Proc. 15th SOSP, </booktitle> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995, </year> <pages> 79 91. </pages>
Reference-contexts: Because most file accesses are sequential [3], this policy usually improves performance. There are several cases, however, where this general policy does not improve (and can even degrade) application perfor-mance <ref> [12] </ref>. At first glance, it may seem that user-level threads are the simple and obvious solution to application-directed prefetching. However, without kernel support, a strictly user-level prefetching implementation is unable to exploit kernel-level information about the on-disk layout of the file data.
Reference: [13] <author> Pu, C., Autrey. T., Black. A., Consel, C., Cowan, C., Inouye, J., Kethana, L., Walpole, J., and Zhang, K., </author> <title> Optimistic Incremental Specialization: Streamlining a Commercial Operating System, </title> <booktitle> Proc. 15th SOSP, </booktitle> <address> Copper Mountain, CO, </address> <month> Dec. </month> <year> 1995, </year> <month> 314324. </month>
Reference-contexts: The extensible systems, such as SPIN [4] and VINO [15] allow applications to download code into the kernel to provide improved functionality and performance. Synthetix <ref> [13] </ref> provides improved exibility and functionality by iden tifying commonly executed paths and producing optimized versions of them, but does not allow applications to modify or extend the kernel. In this paper, we concentrate on the class of extensible systems. <p> By providing a specialized component that removes branches and the normal code to map file descriptors to kernel structures, the performance of the normal case can be greatly improved <ref> [13] </ref>. The only additional cost comes in the form of checks that distinguish between the normal path and the specialized path and allow the system to execute the correct one at the correct time.
Reference: [14] <author> Rashid, R., Tevanian, A., Young, M., Golub, D., Baron, R., Black, D., Bolosky, W., and Chew, J., </author> <title> Machine-Independent Virtual Memory Management for Paged Uniprocessor and Multiprocessor Architectures, </title> <booktitle> Proc. ASPLOS II, </booktitle> <address> Palo Alto CA, </address> <month> Oct. </month> <year> 1987, </year> <month> 3139. </month>
Reference-contexts: Third, the graft cannot permit the application to use more physical memory than would be allowed if the same application ran without a page eviction graft. 4.2.1 VINO VM Page Eviction The VINO virtual memory system is based loosely on the Mach VM system <ref> [14] </ref>. A virtual address space (VAS) consists of a collection of memory objects mapped to virtual address ranges. A memory object represents a contiguous piece of data that may be backed by a variety of objects such as a device, a network connection, or a file.
Reference: [15] <author> Seltzer, M., Endo, Y., Small, C., Smith, K., </author> <title> An Introduction to the Architecture of the VINO Kernel, </title> <institution> Harvard University Computer Science Technical Report 34-94, </institution> <year> 1994. </year>
Reference-contexts: By targeting a particular kernel for a particular workload, Scout can take advantage of advanced compiler optimization techniques, efficient kernel code paths, and a smaller system footprint. The extensible systems, such as SPIN [4] and VINO <ref> [15] </ref> allow applications to download code into the kernel to provide improved functionality and performance. Synthetix [13] provides improved exibility and functionality by iden tifying commonly executed paths and producing optimized versions of them, but does not allow applications to modify or extend the kernel.
Reference: [16] <author> Small, C., Seltzer, M., </author> <title> A Comparison of OS Extension Technologies, </title> <booktitle> Proc. 1996 USENIX Conf., </booktitle> <address> San Diego, CA, </address> <month> Jan. </month> <year> 1996, </year> <month> 4154. </month>
Reference-contexts: by malicious grafts to only those applications that use those grafts and ensures that the kernel can make forward process, even in the presence of a malicious graft (Rules 8 and 9). 4 The Cost of Graft Protection In previous work we presented a taxonomy of types of kernel extensions <ref> [16] </ref>, and we use that taxonomy here to evaluate the overhead of graft maintenance in VINO. We identified three basic graft structures, each of which encompasses a broad class of kernel graft points. <p> Another approach to extensibility is to provide an interpretive environment in the kernel in which kernel extensions can be run. The interpreter can ensure safety by preventing extensions from wreaking havoc in the main kernel, but often incurs a significant runtime overhead <ref> [16] </ref>. The adaptable systems, such as Synthetix [19], take a different approach from the extensible systems. Rather than having applications explicitly modify the kernels behavior, Synthetix is designed so that commonly executed paths through the operating system can be specialized.
Reference: [17] <author> Small, C., MiSFIT: </author> <title> A Minimal i386 Software Fault Isolation Tool,, </title> <institution> Harvard University Computer Science Technical Report TR-07-96, </institution> <year> 1996. </year>
Reference-contexts: The overhead of software fault isolation has been shown to range from 5% to 200%, depending on the application. We developed an SFI tool, MiSFIT, for this purpose <ref> [17] </ref>. At compilation time MiSFIT inserts instructions to protect loads and stores. Code is added to force the target address to fall within the range of memory allocated to the graft. The cost of this protection is two to five cycles per load or store.
Reference: [18] <author> Stonebraker, M., </author> <title> Operating Support for Database Management, </title> <journal> CACM 24, </journal> <volume> 7, </volume> <month> July </month> <year> 1981, </year> <month> 412418. </month>
Reference: [19] <author> Volanschi, E., Muller, G., Consel, C., </author> <title> Safe Operating System Specialization: the RPC Case Study, </title> <booktitle> Proc. 1st Workshop on Compiler Support for System Software, </booktitle> <address> Tuscon, AZ, </address> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: Another approach to extensibility is to provide an interpretive environment in the kernel in which kernel extensions can be run. The interpreter can ensure safety by preventing extensions from wreaking havoc in the main kernel, but often incurs a significant runtime overhead [16]. The adaptable systems, such as Synthetix <ref> [19] </ref>, take a different approach from the extensible systems. Rather than having applications explicitly modify the kernels behavior, Synthetix is designed so that commonly executed paths through the operating system can be specialized.
Reference: [20] <author> Wahbe, R., Lucco, S., Anderson, T., Graham, S., </author> <title> Efficient Software-Based Fault Isolation, </title> <booktitle> Proc. 14th SOSP, </booktitle> <address> Asheville, NC, </address> <month> Dec. </month> <year> 1993, </year> <month> 175188. </month>
Reference-contexts: This problem has been addressed by the use of safe languages such as Modula-3 [11], as used by SPIN, software fault isolation <ref> [20] </ref>, as used by VINO, or virtual memory address domains, as used by Mach [1]. Second, the kernel must ensure that grafts do not consume resources to the extent that they jeopardize the acceptable performance of the kernel and other applications. <p> Thus, the same mechanisms that prevent processes from exceeding resource limits are automatically applied to grafts. When the process would normally be denied requests for new resources, the grafts requests also fail. 3.3 Graft Code Safety As stated above, grafts are protected through the use of software fault isolation <ref> [20] </ref>. The overhead of software fault isolation has been shown to range from 5% to 200%, depending on the application. We developed an SFI tool, MiSFIT, for this purpose [17]. At compilation time MiSFIT inserts instructions to protect loads and stores.
Reference: [21] <author> Waldspurger, C., Weihl, W., </author> <title> Lottery Scheduling: Flexible Proportional-Share Resource Management, </title> <booktitle> Proc. 1st OSDI, </booktitle> <address> Monterey, CA, </address> <month> Nov. </month> <year> 1994, </year> <month> 111. </month>
Reference-contexts: If multiple processes wish to pool resources (e.g., a collection of database clients and servers may wish to pool their wired memory resources to create a shared buffer pool), they can each delegate their resource rights to the graft, in a manner analogous to ticket delegation in lottery scheduling <ref> [21] </ref>. When a thread invokes a grafted function in the kernel, the threads resource limits are replaced by those associated with the graft. Thus, the same mechanisms that prevent processes from exceeding resource limits are automatically applied to grafts.
References-found: 21

