URL: ftp://ftp.irisa.fr/local/lande/rgpfdlm-esop96.ps.gz
Refering-URL: http://www.irisa.fr/lande/fradet/Fradet.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: [fradet,gaugne,lemetayer]@irisa.fr  
Title: Static Detection of Pointer Errors: an Axiomatisation and a Checking Algorithm  
Author: Pascal Fradet, Ronan Gaugne and Daniel Le Metayer Irisa/Inria 
Address: 35042 Rennes, France  
Affiliation: Campus de Beaulieu,  
Abstract: The incorrect use of pointers is one of the most common source of bugs. As a consequence, any kind of static code checking capable of detecting potential bugs at compile time is welcome. This paper presents a static analysis for the detection of incorrect accesses to memory (dereferences of invalid pointers). A pointer may be invalid because it has not been initialised or because it refers to a memory location which has been deallocated. The analyser is derived from an axiomatisation of alias and connectivity properties which is shown to be sound with respect to the natural semantics of the language. It deals with dynamically allocated data structures and it is accurate enough to handle circular structures. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aho, R. Sethi and J. D. Ullman, </author> <booktitle> Compilers: Principles, Techniques and Tools, </booktitle> <publisher> Addison-Wesley publishing company, </publisher> <year> 1988. </year>
Reference-contexts: The rule for if avoids the need for the weakening rule. The post-condition is the disjunction of the post-conditions of the alternatives. The rule for while implements an iterative algorithm akin to traditional data-flow algorithms <ref> [1] </ref>. The iteration must converge because the sequence Q i is strictly increasing: Q i1 j) Q i Q i 6j) Q i1 and the set of properties under consideration is finite. The rule for assignment statements is by far the most complex.
Reference: 2. <author> R. Altucher and W. Landi, </author> <title> An extended form of must-alias analysis for dynamic allocation, </title> <booktitle> in 22 nd Annual ACM Symp. on Principles of Programming Languages POPL'95, </booktitle> <month> Jan. </month> <year> 1995, </year> <month> pp.74-85. </month>
Reference-contexts: accurate may-alias information (because numerical coefficients are used to record precise positions in a structure); on the other hand, our properties include both may-alias and must-alias information which allows us to gain accuracy in certain situations (the significance of must-alias properties to get more accurate may-alias properties is stressed in <ref> [2] </ref>). This extra level of precision is required to the analysis of correctness-related properties. Axiomatisation of pointer and alias relations has been studied for Pascal (see e.g. [6, 7, 21]). Most contributions in this area focus on generality and completeness issues and do not consider automatisation.
Reference: 3. <author> L. Andersen, </author> <title> Program analysis and specialisation for the C programming language, </title> <type> Ph.D Thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <month> May </month> <year> 1994. </year>
Reference-contexts: They are variations of definitions appearing in <ref> [3] </ref>. We use the exception value illegal to denote the result of a computation involving the dereference of an invalid pointer. The set of valid pointers of the store S D is D.
Reference: 4. <author> J.-P. Ban^atre, C. Bryce, D. Le Metayer, </author> <title> Compile-time detection of information flow in sequential programs, </title> <booktitle> proc. European Symposium on Research in Computer Security, </booktitle> <publisher> Springer Verlag, LNCS 875, </publisher> <pages> pp. 55-74. </pages>
Reference-contexts: Using (standard) types to filter properties which cannot be true. Exploiting this extra information usually reduces dramatically the size of the properties manipulated by the algorithm. We are also studying the use of the pointer analysis described here to enhance the information flow analysis proposed in <ref> [4] </ref>. Other applications of this analysis include the detection of unsafe programming styles (which rely on specific implementation choices like the order of evaluation of subexpressions) or memory leaks.
Reference: 5. <author> J.F. Bergeretti and B. Carre, </author> <title> Information-flow and data-flow analysis of while-programs, </title> <journal> in ACM Transactions on Programming Languages and Systems,Vol. </journal> <volume> 7, No. 1, </volume> <month> Jan. </month> <pages> 85, pp. 37-61. </pages>
Reference-contexts: We sketch related work in each of these areas in turn. There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions <ref> [5, 12, 15, 23] </ref> and tools [19] can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures. Other techniques like [14, 18] perform different kinds of analyses (like aspects, program slicing) which are complementary to the work described here.
Reference: 6. <author> A. Bijlsma, </author> <title> Calculating with pointers, </title> <booktitle> in Science of Computer Programming 12 (1989) 191--205, </booktitle> <publisher> North-Holland. </publisher>
Reference-contexts: This extra level of precision is required to the analysis of correctness-related properties. Axiomatisation of pointer and alias relations has been studied for Pascal (see e.g. <ref> [6, 7, 21] </ref>). Most contributions in this area focus on generality and completeness issues and do not consider automatisation. An exception is the work by Luckham and Suzuki [20] which presents an axiom-based verifier for Pascal programs.
Reference: 7. <author> R. Cartwright and D. Oppen, </author> <title> The logic of aliasing, </title> <journal> in Acta Informatica 15, 365-384, 1981 ACM TOPLAS, </journal> <volume> Vol. 7, </volume> <year> 1985, </year> <pages> pp. 299-310. </pages>
Reference-contexts: This extra level of precision is required to the analysis of correctness-related properties. Axiomatisation of pointer and alias relations has been studied for Pascal (see e.g. <ref> [6, 7, 21] </ref>). Most contributions in this area focus on generality and completeness issues and do not consider automatisation. An exception is the work by Luckham and Suzuki [20] which presents an axiom-based verifier for Pascal programs.
Reference: 8. <author> P. Cousot and R. Cousot, </author> <title> Systematic design of program analysis frameworks, </title> <booktitle> in 6 th Annual ACM Symp. on Principles of Programming Languages POPL'79, </booktitle> <month> Jan. </month> <pages> 79, pp. 269-282. </pages>
Reference-contexts: Again, the most difficult rule is the assignment. It is not clear whether the overall effort would be less important but the formulation in terms of abstract interpretation would make it easier to show the optimality of the analyser (in terms of precision) <ref> [8] </ref>. Also, the approximation techniques studied in this framework can be applied to get more efficient analysers.
Reference: 9. <author> A. Deutsch, </author> <title> A storeless model of aliasing and its abstraction using finite representations of right-regular equivalence relations, </title> <booktitle> in Proc. of the IEEE 1992 Conf. on Computer Languages, Apr. </booktitle> <volume> 92, </volume> <pages> pp. 2-13. </pages>
Reference-contexts: Instead of a correctness proof of the analyser with respect to the axiomatics as suggested here, the soundness of the analysis would then be shown as a consequence of the soundness of the abstract interpretation of the basic rules with respect to the operational semantics (see <ref> [9] </ref> for an illustration of this approach). Again, the most difficult rule is the assignment.
Reference: 10. <author> A. Deutsch, </author> <title> Interprocedural may-alias analysis for pointers: Beyond k-limiting, </title> <booktitle> in SIG-PLAN'94 Conf. on Programming Language Design and Implementation PLDI'94, </booktitle> <month> Jun. </month> <year> 1994, </year> <pages> pp. 230-241. </pages>
Reference-contexts: Other techniques like [14, 18] perform different kinds of analyses (like aspects, program slicing) which are complementary to the work described here. There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations <ref> [10, 11] </ref>. The alias pairs (x; y) of [10] correspond to &x = &y here and the x points-to y relationship of [11] is equivalent to x = &y. One of the most precise published alias analysis is the framework described in [10]. <p> There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations [10, 11]. The alias pairs (x; y) of <ref> [10] </ref> correspond to &x = &y here and the x points-to y relationship of [11] is equivalent to x = &y. One of the most precise published alias analysis is the framework described in [10]. <p> The alias pairs (x; y) of <ref> [10] </ref> correspond to &x = &y here and the x points-to y relationship of [11] is equivalent to x = &y. One of the most precise published alias analysis is the framework described in [10]. Our analysis is not directly comparable to this one in terms of precision: on one hand, the symbolic access paths used in [10] provide a much more accurate may-alias information (because numerical coefficients are used to record precise positions in a structure); on the other hand, our properties include both <p> One of the most precise published alias analysis is the framework described in <ref> [10] </ref>. Our analysis is not directly comparable to this one in terms of precision: on one hand, the symbolic access paths used in [10] provide a much more accurate may-alias information (because numerical coefficients are used to record precise positions in a structure); on the other hand, our properties include both may-alias and must-alias information which allows us to gain accuracy in certain situations (the significance of must-alias properties to get more accurate may-alias
Reference: 11. <author> M. Emami, R. Ghiya and L. Hendren, </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers, </title> <booktitle> in SIGPLAN'94 Conf. on Programming Language Design and Implementation PLDI'94, </booktitle> <month> Jun. </month> <year> 1994, </year> <pages> pp. 242-256. </pages>
Reference-contexts: Other techniques like [14, 18] perform different kinds of analyses (like aspects, program slicing) which are complementary to the work described here. There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations <ref> [10, 11] </ref>. The alias pairs (x; y) of [10] correspond to &x = &y here and the x points-to y relationship of [11] is equivalent to x = &y. One of the most precise published alias analysis is the framework described in [10]. <p> There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations [10, 11]. The alias pairs (x; y) of [10] correspond to &x = &y here and the x points-to y relationship of <ref> [11] </ref> is equivalent to x = &y. One of the most precise published alias analysis is the framework described in [10].
Reference: 12. <author> D. Evans, </author> <title> Using specifications to check source code, </title> <type> in Technical Report, </type> <institution> MIT Lab for computer science, </institution> <month> Jun. </month> <year> 1994. </year>
Reference-contexts: We sketch related work in each of these areas in turn. There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions <ref> [5, 12, 15, 23] </ref> and tools [19] can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures. Other techniques like [14, 18] perform different kinds of analyses (like aspects, program slicing) which are complementary to the work described here.
Reference: 13. <author> P. Fradet, R. Gaugne and D. Le Metayer, </author> <title> An inference algorithm for the static verification of pointer manipulation, </title> <type> IRISA Research Report 980, </type> <year> 1996. </year>
Reference-contexts: The set of valid pointers of the store S D is D. The effect of alloc (resp. free) is to add an address in (resp. to remove an address from) D. This paper is concerned with the analysis of blocks of instructions excluding procedure calls and gotos (see <ref> [13] </ref> for extensions). This allows us to focus on the essential issues of pointer analysis and to keep the presentation simpler. We also ignore arithmetic operations on pointers and we assume that only one field of a record can be of type pointer. <p> The correctness of the dereference case (flid) follows from the lemma: Lemma 5. C V (:(flv = undef); E ; S D ) ) Val (v; E ; S D ) 2 D More details about the proofs of properties stated in this paper can be found in <ref> [13] </ref>. 3 A Checking Algorithm As a first stage to get an effective algorithm from the previous logic, we restrict the set of properties which may appear as pre/post-conditions. <p> Theorem 7 shows that the atomic disjunctive normal form representation is invariant which is crucial to prove the soundness of the algorithm. The proof of theorem 8 is made by induction on the structure of proof of the premise <ref> [13] </ref>. The difficult part is the rule for assignment which follows from the lemma: Lemma 9. <p> A different perspective of this work could be its use as a specialised interactive theorem prover for a restricted form of Hoare logic. Due to space limitations, we considered only a kernel programming language in this paper. The interested reader can find in <ref> [13] </ref> the treatment of a number of extensions (procedures, goto, pointer variable declarations) and the presentation of a reasonably complex program involving the construction and destruction of a circular list.
Reference: 14. <author> J. Field, G. Ramalingam and F. </author> <title> Tip, Parametric program slicing, </title> <booktitle> in 22 th Annual ACM Symp. on Principles of Programming Languages POPL'95, </booktitle> <month> Jan. </month> <pages> 95, pp. 379-392. </pages>
Reference-contexts: There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions [5, 12, 15, 23] and tools [19] can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures. Other techniques like <ref> [14, 18] </ref> perform different kinds of analyses (like aspects, program slicing) which are complementary to the work described here. There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations [10, 11].
Reference: 15. <author> L. Fosdick and L. Osterweil, </author> <title> Data flow analysis in software reliability, </title> <journal> ACM Computing surveys, </journal> <volume> 8(3), </volume> <month> Sept. </month> <year> 1976. </year>
Reference-contexts: We sketch related work in each of these areas in turn. There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions <ref> [5, 12, 15, 23] </ref> and tools [19] can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures. Other techniques like [14, 18] perform different kinds of analyses (like aspects, program slicing) which are complementary to the work described here.
Reference: 16. <author> C. L. Hankin, D. Le Metayer, </author> <title> Deriving algorithms from type inference systems: Application to strictness analysis, </title> <booktitle> proc. ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1994, </year> <pages> pp. 202-212, </pages> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: One solution leads to a representation of properties as matrices of a three values domain (instead of sets of matrices of a boolean domain as suggested in this paper). Computing only the necessary part of each property using a form of lazy type inference <ref> [16] </ref>. Using (standard) types to filter properties which cannot be true. Exploiting this extra information usually reduces dramatically the size of the properties manipulated by the algorithm. We are also studying the use of the pointer analysis described here to enhance the information flow analysis proposed in [4].
Reference: 17. <author> L. Hendren and A. Nicolau, </author> <title> Parallelizing programs with recursive data structures, </title> <journal> in IEEE Transactions on Parallel and Distributed Systems, Jan. </journal> <volume> 90, Vol. 1(1), </volume> <pages> pp. 35-47. </pages>
Reference-contexts: The abstract domain is the disjunctive completion of a lattice of matrices (associating each pair (v 1 ; v 2 ) with truth values of the basic relations = and 7!). This domain has some similarities with the path matrices used in <ref> [17] </ref> for the analysis of a restricted form of regular acyclic structures. The abstraction and concretisation functions follow directly from the correspondence relation of Fig. 1.
Reference: 18. <author> D. Jackson, </author> <title> Aspect: an economical bug-detector, </title> <booktitle> in Proceedings of 13 th International Conference on Software Engineering, </booktitle> <month> May </month> <year> 1994, </year> <pages> pp. 13-22. </pages>
Reference-contexts: There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions [5, 12, 15, 23] and tools [19] can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures. Other techniques like <ref> [14, 18] </ref> perform different kinds of analyses (like aspects, program slicing) which are complementary to the work described here. There is an extensive body of literature on alias analysis but most of the contributions are concerned with may-alias analysis and are targeted towards compiler optimisations [10, 11].
Reference: 19. <author> S. Johnson, </author> <title> Lint, a C program checker, </title> <institution> Computer Science technical report, Bell Laboratories, </institution> <address> Murray Hill, NH, </address> <month> July </month> <year> 1978. </year>
Reference-contexts: We sketch related work in each of these areas in turn. There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions [5, 12, 15, 23] and tools <ref> [19] </ref> can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures. Other techniques like [14, 18] perform different kinds of analyses (like aspects, program slicing) which are complementary to the work described here.
Reference: 20. <author> D. Luckham and N. Suzuki, </author> <title> Verification of array, record, and pointer operations in Pascal, </title> <journal> in ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 1, </volume> <pages> No.2, </pages> <month> Oct. </month> <year> 1979, </year> <pages> pp. 226-244. </pages>
Reference-contexts: Axiomatisation of pointer and alias relations has been studied for Pascal (see e.g. [6, 7, 21]). Most contributions in this area focus on generality and completeness issues and do not consider automatisation. An exception is the work by Luckham and Suzuki <ref> [20] </ref> which presents an axiom-based verifier for Pascal programs. The language of properties encompasses ours but is too rich to make the analysis fully automatic. The verifier (actually a theorem prover) depends heavily on user-supplied properties such as loop invariants.
Reference: 21. <author> J. Morris, </author> <title> A general axiom of assignment and Assignment and linked data structures, </title> <booktitle> in Theoretical Foundations of Programming Methodology, </booktitle> <editor> M. Broy and G. Schmidt (eds), </editor> <booktitle> pp. </booktitle> <pages> 25-41, </pages> <year> 1982. </year>
Reference-contexts: This extra level of precision is required to the analysis of correctness-related properties. Axiomatisation of pointer and alias relations has been studied for Pascal (see e.g. <ref> [6, 7, 21] </ref>). Most contributions in this area focus on generality and completeness issues and do not consider automatisation. An exception is the work by Luckham and Suzuki [20] which presents an axiom-based verifier for Pascal programs.
Reference: 22. <author> S. Sagiv, N. Francez, M. Rodeh and R. Wilhelm, </author> <title> A logic-based approach to data flow analysis problems, </title> <booktitle> in Programming Language Implementation and Logic Programming PLILP'90, </booktitle> <volume> LNCS 456, </volume> <pages> pp. 277-292, </pages> <year> 1990. </year>
Reference-contexts: The language of properties encompasses ours but is too rich to make the analysis fully automatic. The verifier (actually a theorem prover) depends heavily on user-supplied properties such as loop invariants. The work whose spirit is the closest to our approach is the analysis framework presented in <ref> [22] </ref>. Environments are described as sets of assertions specified as Horn clauses. They define optimal analyses which exploit all the information available.
Reference: 23. <author> R. Strom and D. Yellin, </author> <title> Extending typestate checking using conditional liveness analysis, </title> <journal> in IEEE Transactions on Software Engineering, </journal> <volume> Vol. 19, No 5, </volume> <month> May. </month> <pages> 93, pp. 478-485. </pages>
Reference-contexts: We sketch related work in each of these areas in turn. There are relatively few papers about the design of program analysers to help in the program development process. Most related contributions <ref> [5, 12, 15, 23] </ref> and tools [19] can provide information about uninitialised variables but are unable to track illegal accesses in recursive data structures. Other techniques like [14, 18] perform different kinds of analyses (like aspects, program slicing) which are complementary to the work described here.
References-found: 23

