URL: http://www.cs.rutgers.edu/~minsky/583/agha.ps
Refering-URL: http://www.cs.rutgers.edu/~minsky/583/coord.html
Root-URL: http://www.cs.rutgers.edu
Email: Email: f frolund j agha g@cs.uiuc.edu  
Title: A Language Framework for Multi-Object Coordination  
Author: Svend Frtlund and Gul Agha 
Address: 1304 W. Springfield Avenue  Urbana, IL 61801, USA  
Affiliation: Department of Computer Science  University of Illinois at Urbana-Champaign  
Abstract: We have developed language support for the expression of multi-object coordination. In our language, coordination patterns can be specified abstractly, independent of the protocols needed to implement them. Coordination patterns are expressed in the form of constraints that restrict invocation of a group of objects. Constraints are defined in terms of the interface of the objects being invoked rather than their internal representation. Invocation constraints enforce properties, such as temporal ordering and atomicity, that hold when invoking objects in a group. A constraint can permanently control access to a group of objects, thereby expressing an inherent access restriction associated with the group. Furthermore, a constraint can temporarily enforce access restrictions during the activity of individual clients. In that way, constraints can express specialized access schemes required by a group of clients.
Abstract-found: 1
Intro-found: 1
Reference: [AB92] <author> M. Aksit and L. Bergmans. </author> <title> Obstacles in Object-Oriented Software Development. </title> <booktitle> In Proceedings OOPSLA 92. ACM, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: Objects may be reused independent of how they are coordinated; conversely, multi-object coordination patterns may be reused on different groups of objects. In particular, it is possible to abstract over coordination patterns and factor out generic coordination structures. As noted in <ref> [AB92] </ref>, separation also gives a more natural way of expressing the coordination schemes found in many problem domains. Multi-object constraints are described in the form of synchronizers.
Reference: [AC93] <author> G. Agha and C.J. Callsen. ActorSpace: </author> <title> An Open Distributed Programming Paradigm. </title> <booktitle> In 1993 ACM Conference on Principles and Practice of Parallel Programming (PPOPP), </booktitle> <year> 1993. </year> <note> (To be published). </note>
Reference-contexts: However, it is possible to employ other models of locality for constraint enforcement. For example, objects could be required to have certain capabilities in order to enforce constraints on other objects. Furthermore, constraints could be specified for groups of objects that are defined using patterns rather than identities <ref> [AC93] </ref>. A synchronizer is a special kind of object that observes and limits invocation of other objects: a synchronizer cannot be accessed directly using message-based communication. 1 The invocations observed and limited by a synchronizer are iden 1 There is nothing inherent in the synchronizer concept that prevents direct communication.
Reference: [AFPS93] <author> G. Agha, S. Frtlund, R. Panwar, and D. Sturman. </author> <title> A Linguistic Framework for Dynamic Composition of Dependability Protocols. In Dependable Computing for Critical Applications III. </title> <booktitle> International Federation of Information Processing Societies (IFIP), </booktitle> <publisher> Elsevier Scienc Publisher, </publisher> <year> 1993. </year> <note> (To be published). </note>
Reference-contexts: Therefore, it may be necessary to extend the language so that the choice of implementation is guided to a certain extent by the application programmer. One possible model for customization of implementation is to use reflection along the lines pointed out in <ref> [YMFT91, AFPS93] </ref>. Synchronizers make it feasible to customize the implementation of multi-object coordination since the coordination protocols are no longer hard-wired into applications but specified separately.
Reference: [Agh86] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Section 5 gives an overview of related work and Section 6 concludes with a discussion of our approach. 2 Basic Concepts and Notation For simplicity we assume that synchronizers are integrated with an object-oriented concurrent language that adheres to the Actor <ref> [Agh86] </ref> model of computation. Specifically this implies that message-passing is asynchronous so that sending objects are not blocked by enforced synchronizers. Although our development is based on Actors, we believe the concepts behind synchronizers can be integrated with most concurrent object-oriented languages.
Reference: [AGMB91] <author> C. Atkinson, S. Goldsack, A. D. Maio, and R. Bayan. </author> <title> Object-Oriented Con-currency and Distribution in DRAGOON. </title> <journal> Journal of Object-Oriented Programming, </journal> <month> March/April </month> <year> 1991. </year>
Reference-contexts: Utilizing a high-level specification of multi-object constraints it is possible to map the same multi-object constraint to different implementations. In object-based concurrent computing it has become commonplace to describe per object coordination in the form of synchronization constraints <ref> [Nie87, TS89, Neu91, AGMB91, MWBD91, Frt92] </ref>. Both synchronizers and synchronization constraints are based on conditions which are verified prior to the processing of invocations. The conditions of synchronization constraints are expressed in terms of the encapsulated state of individual objects, e.g. in the form of boolean predicates. <p> The coordination behavior is realized by traditional means such as explicit message passing between the objects. In contrast to the above approaches, synchronizers are executable specifications of multi-object coordination. In the Dragoon language <ref> [RdPG91, AGMB91] </ref>, synchronization constraints are specified external to the constrained objects. Constraints are general specifications that can be mixed-in with class definitions yielding a class with synchronization constraints.
Reference: [Ara91] <author> C. Arapis. </author> <title> Specifying Object Interactions. </title> <editor> In D. Tsichritzis, editor, </editor> <title> Object Composition. </title> <institution> University of Geneva, </institution> <year> 1991. </year>
Reference-contexts: The constraints of Procol [vdBL91] and Rapide [LVB + 92] provide triggering of activities based on observation of events. The constraints of Procol and Rapide can only observe, not limit invocations. Several attempts have been made at documenting multi-object coordination at an abstract level. In <ref> [Ara91] </ref>, a temporal logic framework is used for assertions about the message passing behavior of objects. The notion of a contract is proposed in [HHG90, Hol92]. Contracts extend the notion of type to capture the message passing obligations fulfilled by objects.
Reference: [BJ87] <author> K. P. Birman and T. A. Joseph. </author> <title> Communication Support for Reliable Distributed Computing. In Fault-tolerant Distributed Computing. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <note> LNCS. </note>
Reference-contexts: It should be emphasized that we do not perceive synchronizers as a substitute for transaction systems: we think of synchronizers as a structuring tool that can supplement transactions in an orthogonal and non-interfering way. A number of systems provide broadcasts with different delivery guarantees. Examples are ISIS <ref> [BJ87] </ref>, Consul [MPS91] and the notion of Interface Groups proposed in [OOW91]. In such systems, it is possible to ensure certain properties for the re-ception of broadcast messages. None of the broadcast systems deal with objects that have local synchronization constraints: the guarantees provided are relative to delivery, not acceptance.
Reference: [CI92] <author> R. H. Campbell and N. Islam. </author> <title> A Technique for Documenting the Framework of an Object-Oriented System. </title> <booktitle> In Proceedings of the Second International Workshop on Object Orientation in Operating Systems, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: In [Ara91], a temporal logic framework is used for assertions about the message passing behavior of objects. The notion of a contract is proposed in [HHG90, Hol92]. Contracts extend the notion of type to capture the message passing obligations fulfilled by objects. In <ref> [CI92] </ref> a mix of path-expressions, data-flow and control-flow is used to capture coordination between objects comprising a sub system. The above approaches to multi-object interactions describe rather than prescribe multi-object coordination. The expression of multi-object coordination serves to document and verify the coordination behavior of a set of interacting objects.
Reference: [DHW88] <author> D. L. Detlefs, M. P. Herlihy, and J. M. Wing. </author> <title> Inheritance of Synchronization and Recovery Properties in Avalon/C++. </title> <journal> IEEE Computer, </journal> <volume> 21(12) </volume> <pages> 57-69, </pages> <month> De-cember </month> <year> 1988. </year>
Reference-contexts: The temporal constraints of synchronizers are more abstract and expressive than the temporal constraints expressible by synchronous communication. Transactions provide atom-icity in a number of systems <ref> [LS82, WL88, DHW88, KHPW90, GCLR92, WY91] </ref>. As we have already mentioned, transactions cannot be combined with temporal constraints. Furthermore, the atomicity provided by the atomic operator is cheaper to implement.
Reference: [FBB92] <author> Bjorn N. Freeman-Benson and Alan Borning. </author> <title> Integrating Constraints with an Object-Oriented Language. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Proceedings ECOOP '92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 268-286, </pages> <address> Utrecht, The Netherlands, July 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Neither synchronous communication, transactions or broadcast protocols can be used to describe constraints permanently associated with object groups. In all three cases, the constraints expressible are associated with individual clients. The constraints of Kaleidoscope <ref> [FBB92] </ref> capture numerical relations between instance variables of multiple objects. Kaleidoscope emphasizes state-consistency by propagating updates. In contrast, synchronizers express invocation consistency by request scheduling. Synchronizers and the constraints of kaleidoscope capture fundamentally different aspects of multi-object consistency.
Reference: [Frt92] <author> Svend Frtlund. </author> <title> Inheritance of Synchronization Constraints in Concurrent Object-Oriented Programming Languages. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Proceedings ECOOP '92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 185-196, </pages> <address> Utrecht, The Netherlands, July 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Utilizing a high-level specification of multi-object constraints it is possible to map the same multi-object constraint to different implementations. In object-based concurrent computing it has become commonplace to describe per object coordination in the form of synchronization constraints <ref> [Nie87, TS89, Neu91, AGMB91, MWBD91, Frt92] </ref>. Both synchronizers and synchronization constraints are based on conditions which are verified prior to the processing of invocations. The conditions of synchronization constraints are expressed in terms of the encapsulated state of individual objects, e.g. in the form of boolean predicates.
Reference: [GCLR92] <author> Rachid Guerraoui, Riccardo Capobianchi, Agnes Lanusse, and Pierre Roux. </author> <title> Nesting Actions through Asynchronous Message Passing: the ACS Protocol. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Proceedings ECOOP '92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 170-184, </pages> <address> Utrecht, The Netherlands, July 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The temporal constraints of synchronizers are more abstract and expressive than the temporal constraints expressible by synchronous communication. Transactions provide atom-icity in a number of systems <ref> [LS82, WL88, DHW88, KHPW90, GCLR92, WY91] </ref>. As we have already mentioned, transactions cannot be combined with temporal constraints. Furthermore, the atomicity provided by the atomic operator is cheaper to implement.
Reference: [HHG90] <author> Richard Helm, Ian M. Holland, and Dipayan Gangopadhyay. </author> <title> Contracts: Specifying Behavioural Compositions in Object-Oriented Systems. </title> <booktitle> In Proceedings OOPSLA/ECOOP '90, </booktitle> <pages> pages 169-180, </pages> <month> October </month> <year> 1990. </year> <journal> Published as ACM SIG-PLAN Notices, </journal> <volume> volume 25, number 10. </volume>
Reference-contexts: Several attempts have been made at documenting multi-object coordination at an abstract level. In [Ara91], a temporal logic framework is used for assertions about the message passing behavior of objects. The notion of a contract is proposed in <ref> [HHG90, Hol92] </ref>. Contracts extend the notion of type to capture the message passing obligations fulfilled by objects. In [CI92] a mix of path-expressions, data-flow and control-flow is used to capture coordination between objects comprising a sub system. The above approaches to multi-object interactions describe rather than prescribe multi-object coordination.
Reference: [Hol92] <author> Ian M. Holland. </author> <title> Specifying Reusable Components Using Contracts. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Proceedings ECOOP '92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 287-308, </pages> <address> Utrecht, The Netherlands, July 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Several attempts have been made at documenting multi-object coordination at an abstract level. In [Ara91], a temporal logic framework is used for assertions about the message passing behavior of objects. The notion of a contract is proposed in <ref> [HHG90, Hol92] </ref>. Contracts extend the notion of type to capture the message passing obligations fulfilled by objects. In [CI92] a mix of path-expressions, data-flow and control-flow is used to capture coordination between objects comprising a sub system. The above approaches to multi-object interactions describe rather than prescribe multi-object coordination.
Reference: [KHPW90] <author> G. E. Kaiser, W. Hseush, S. S. Popovich, and S. F. Wu. </author> <title> Multiple Concurrency Control Policies in an Object-Oriented Programming System. </title> <booktitle> In Proceedings of the Second Symposium on Parallel and Distributed Processing, </booktitle> <address> Dallas Texas. </address> <publisher> IEEE, </publisher> <month> December </month> <year> 1990. </year>
Reference-contexts: The temporal constraints of synchronizers are more abstract and expressive than the temporal constraints expressible by synchronous communication. Transactions provide atom-icity in a number of systems <ref> [LS82, WL88, DHW88, KHPW90, GCLR92, WY91] </ref>. As we have already mentioned, transactions cannot be combined with temporal constraints. Furthermore, the atomicity provided by the atomic operator is cheaper to implement.
Reference: [LS82] <author> Barbara Liskov and Robert Scheifler. </author> <title> Guardians and Actions: Linguistic Support for Robust, Distributed Programs. </title> <booktitle> In Conference Record of the Ninth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 7-19, </pages> <address> Albuquerque, New Mexico, </address> <month> January </month> <year> 1982. </year> <note> ACM. </note>
Reference-contexts: The temporal constraints of synchronizers are more abstract and expressive than the temporal constraints expressible by synchronous communication. Transactions provide atom-icity in a number of systems <ref> [LS82, WL88, DHW88, KHPW90, GCLR92, WY91] </ref>. As we have already mentioned, transactions cannot be combined with temporal constraints. Furthermore, the atomicity provided by the atomic operator is cheaper to implement.
Reference: [LVB + 92] <author> D. C. Luckham, J. Vera, D. Bryan, L. Augustin, and F. Belz. </author> <title> Partial Order-ings of Event Sets and Their Application to Prototyping Concurrent Timed Systems. </title> <booktitle> In Proceedings of the 1992 DARPA Software Technology Conference, </booktitle> <month> April </month> <year> 1992. </year>
Reference-contexts: The constraints of Kaleidoscope [FBB92] capture numerical relations between instance variables of multiple objects. Kaleidoscope emphasizes state-consistency by propagating updates. In contrast, synchronizers express invocation consistency by request scheduling. Synchronizers and the constraints of kaleidoscope capture fundamentally different aspects of multi-object consistency. The constraints of Procol [vdBL91] and Rapide <ref> [LVB + 92] </ref> provide triggering of activities based on observation of events. The constraints of Procol and Rapide can only observe, not limit invocations. Several attempts have been made at documenting multi-object coordination at an abstract level.
Reference: [MPS91] <author> S. Mishra, L. L. Peterson, and R. D. Schlichting. </author> <title> Consul: A Communication Substrate for Fault-Tolerant Distributed Programs. </title> <type> Technical report, </type> <institution> University of Arizona, Tucson, </institution> <year> 1991. </year>
Reference-contexts: It should be emphasized that we do not perceive synchronizers as a substitute for transaction systems: we think of synchronizers as a structuring tool that can supplement transactions in an orthogonal and non-interfering way. A number of systems provide broadcasts with different delivery guarantees. Examples are ISIS [BJ87], Consul <ref> [MPS91] </ref> and the notion of Interface Groups proposed in [OOW91]. In such systems, it is possible to ensure certain properties for the re-ception of broadcast messages. None of the broadcast systems deal with objects that have local synchronization constraints: the guarantees provided are relative to delivery, not acceptance.
Reference: [MWBD91] <author> C. McHale, B. Walsh, S. Baker, and A. Donnelly. </author> <title> Scheduling Predicates. </title> <editor> In M. Tokoro, O. Nierstrasz, and P. Wegner, editors, </editor> <booktitle> Object-Based Concurrent Computing, </booktitle> <pages> pages 177 - 193. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1991. </year> <note> LNCS 612. </note>
Reference-contexts: Utilizing a high-level specification of multi-object constraints it is possible to map the same multi-object constraint to different implementations. In object-based concurrent computing it has become commonplace to describe per object coordination in the form of synchronization constraints <ref> [Nie87, TS89, Neu91, AGMB91, MWBD91, Frt92] </ref>. Both synchronizers and synchronization constraints are based on conditions which are verified prior to the processing of invocations. The conditions of synchronization constraints are expressed in terms of the encapsulated state of individual objects, e.g. in the form of boolean predicates.
Reference: [Neu91] <author> Christian Neusius. </author> <title> Synchronizing Actions. </title> <editor> In P. America, editor, </editor> <booktitle> Proceedings ECOOP '91, </booktitle> <volume> LNCS 512, </volume> <pages> pages 118-132, </pages> <address> Geneva, Switzerland, July 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Utilizing a high-level specification of multi-object constraints it is possible to map the same multi-object constraint to different implementations. In object-based concurrent computing it has become commonplace to describe per object coordination in the form of synchronization constraints <ref> [Nie87, TS89, Neu91, AGMB91, MWBD91, Frt92] </ref>. Both synchronizers and synchronization constraints are based on conditions which are verified prior to the processing of invocations. The conditions of synchronization constraints are expressed in terms of the encapsulated state of individual objects, e.g. in the form of boolean predicates.
Reference: [Nie87] <author> Oscar Nierstrasz. </author> <title> Active Objects in Hybrid. </title> <booktitle> In Proceedings OOPSLA '87, </booktitle> <pages> pages 243-253, </pages> <month> December </month> <year> 1987. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 22, number 12. </volume>
Reference-contexts: Utilizing a high-level specification of multi-object constraints it is possible to map the same multi-object constraint to different implementations. In object-based concurrent computing it has become commonplace to describe per object coordination in the form of synchronization constraints <ref> [Nie87, TS89, Neu91, AGMB91, MWBD91, Frt92] </ref>. Both synchronizers and synchronization constraints are based on conditions which are verified prior to the processing of invocations. The conditions of synchronization constraints are expressed in terms of the encapsulated state of individual objects, e.g. in the form of boolean predicates.
Reference: [OOW91] <author> M. H. Olsen, E. Oskiewicz, and J. P. Warne. </author> <title> A Model for Interface Groups. </title> <booktitle> In Tenth Symposium on Reliable Distributed Systems, </booktitle> <address> Pisa, Italy, 1991. </address> <publisher> IEEE. </publisher>
Reference-contexts: A number of systems provide broadcasts with different delivery guarantees. Examples are ISIS [BJ87], Consul [MPS91] and the notion of Interface Groups proposed in <ref> [OOW91] </ref>. In such systems, it is possible to ensure certain properties for the re-ception of broadcast messages. None of the broadcast systems deal with objects that have local synchronization constraints: the guarantees provided are relative to delivery, not acceptance.
Reference: [RdPG91] <author> Stefano Crespi Reghizzi, Guido Galli de Paratesi, and Stefano Genolini. </author> <title> Definition of Reusable Concurrent Software Components. </title> <editor> In P. America, editor, </editor> <booktitle> Proceedings ECOOP '91, </booktitle> <volume> LNCS 512, </volume> <pages> pages 148-166, </pages> <address> Geneva, Switzerland, July 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The coordination behavior is realized by traditional means such as explicit message passing between the objects. In contrast to the above approaches, synchronizers are executable specifications of multi-object coordination. In the Dragoon language <ref> [RdPG91, AGMB91] </ref>, synchronization constraints are specified external to the constrained objects. Constraints are general specifications that can be mixed-in with class definitions yielding a class with synchronization constraints.
Reference: [TS89] <author> Chris Tomlinson and Vineet Singh. </author> <title> Inheritance and Synchronization with Enabled Sets. </title> <booktitle> In Proceedings OOPSLA '89, </booktitle> <pages> pages 103-112, </pages> <month> October </month> <year> 1989. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 24, number 10. </volume>
Reference-contexts: Utilizing a high-level specification of multi-object constraints it is possible to map the same multi-object constraint to different implementations. In object-based concurrent computing it has become commonplace to describe per object coordination in the form of synchronization constraints <ref> [Nie87, TS89, Neu91, AGMB91, MWBD91, Frt92] </ref>. Both synchronizers and synchronization constraints are based on conditions which are verified prior to the processing of invocations. The conditions of synchronization constraints are expressed in terms of the encapsulated state of individual objects, e.g. in the form of boolean predicates.
Reference: [vdBL91] <author> J. van den Bos and C. Laffra. </author> <title> PROCOL, a Concurrent Object-Oriented Language with Protocols Delegation and Constraints. </title> <journal> Acta Informatica, </journal> <volume> 28:511 - 538, </volume> <year> 1991. </year>
Reference-contexts: The constraints of Kaleidoscope [FBB92] capture numerical relations between instance variables of multiple objects. Kaleidoscope emphasizes state-consistency by propagating updates. In contrast, synchronizers express invocation consistency by request scheduling. Synchronizers and the constraints of kaleidoscope capture fundamentally different aspects of multi-object consistency. The constraints of Procol <ref> [vdBL91] </ref> and Rapide [LVB + 92] provide triggering of activities based on observation of events. The constraints of Procol and Rapide can only observe, not limit invocations. Several attempts have been made at documenting multi-object coordination at an abstract level.
Reference: [WL88] <author> C. T. Wilkes and R. J. LeBlanc. </author> <title> Distributed Locking: A Mechanism for Constructing Highly Available Objects. </title> <booktitle> In Seventh Symposium on Reliable Distributed Systems, </booktitle> <institution> Ohio State University, Columbus, Ohio, </institution> <year> 1988. </year> <note> IEEE. </note>
Reference-contexts: The temporal constraints of synchronizers are more abstract and expressive than the temporal constraints expressible by synchronous communication. Transactions provide atom-icity in a number of systems <ref> [LS82, WL88, DHW88, KHPW90, GCLR92, WY91] </ref>. As we have already mentioned, transactions cannot be combined with temporal constraints. Furthermore, the atomicity provided by the atomic operator is cheaper to implement.
Reference: [WY91] <author> K. Wakita and A. Yonezawa. </author> <title> Linguistic Supports for Development of Distributed Organizational Information Systems in Object-Oriented Concurrent Computation Frameworks. </title> <booktitle> In Proceedings of the First Conference on Organizational Computing Systems, </booktitle> <address> Atlanta Georgia. </address> <publisher> ACM, </publisher> <month> September </month> <year> 1991. </year>
Reference-contexts: The temporal constraints of synchronizers are more abstract and expressive than the temporal constraints expressible by synchronous communication. Transactions provide atom-icity in a number of systems <ref> [LS82, WL88, DHW88, KHPW90, GCLR92, WY91] </ref>. As we have already mentioned, transactions cannot be combined with temporal constraints. Furthermore, the atomicity provided by the atomic operator is cheaper to implement.
Reference: [YMFT91] <author> Y. Yokote, A. Mitsuzawa, N. Fujinami, and M. Tokoro. </author> <title> Reflective Object Management in the Muse Operating System. </title> <booktitle> In Proceedings of the 1991 International Workshop on Object Orientation in Operating Systems, </booktitle> <address> Palo Alto, Cali-fornia, </address> <month> October </month> <year> 1991. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: Therefore, it may be necessary to extend the language so that the choice of implementation is guided to a certain extent by the application programmer. One possible model for customization of implementation is to use reflection along the lines pointed out in <ref> [YMFT91, AFPS93] </ref>. Synchronizers make it feasible to customize the implementation of multi-object coordination since the coordination protocols are no longer hard-wired into applications but specified separately.
References-found: 28

