URL: ftp://ftp.cs.columbia.edu/reports/reports-1994/cucs-014-94.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1994.html
Root-URL: http://www.cs.columbia.edu
Email: li@cs.columbia.edu kar@cs.columbia.edu  
Title: A New Client-Server Architecture for Distributed Query Processing  
Author: Zhe Li Kenneth A. Ross 
Address: New York, NY 10027 New York, NY 10027  
Affiliation: Computer Science Department Computer Science Department Columbia University Columbia University  
Abstract: Technical Report No. CUCS-014-94 April 10, 1994 Abstract This paper presents the idea of "tuple bit-vectors" for distributed query processing. Using tuple bit-vectors, a new two-way semijoin operator called 2SJ++ that enhances the semijoin with an essentially "free" backward reduction capability is proposed. We explore in detail the benefits and costs of 2SJ++ compared with other semijoin variants, and its effect on distributed query processing performance. We then focus on one particular distributed query processing algorithm, called the "one-shot" algorithm. We modify the one-shot algorithm by using 2SJ++ and demonstrate the improvements achieved in network transmission cost compared with the original one-shot technique. We use this improvement to demonstrate that equipped with the 2SJ++ technique, one can improve the performance of distributed query processing algorithms significantly without adding much complexity to the algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [AHY83] <author> P.M.G. Apers, A.R. Hevner, and S.B. Yao. </author> <title> Optimization algorithm for distributed queries. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-9:57-68, </volume> <year> 1983. </year> <title> 3 Even if we send the tuple ordering indexes of the set bits in the tuple bit vector as a means of compression, the size of the ordering indexes is bounded by log( Join Projection Size). So a 4 byte address can represent 4GB join projection. On the other hand, physical TIDs are usually constrained to be a multiple of the machine word size. </title> <type> 16 </type>
Reference-contexts: 1 Introduction Much work had been done on optimizing the cost of distributed query processing (henceforth abbreviated as DQP) under various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most DQP algorithms rely on some variants of the semijoin technique [BC81, BG81], and concentrate on reducing the cost of inter-site data movement. A distributed query is typically processed in the following stages [YC84]: 1.
Reference: [Bab79] <author> E. Babb. </author> <title> Implementing a relational database by means of specialized hardware. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 4(1) </volume> <pages> 1-29, </pages> <year> 1979. </year>
Reference-contexts: Storing the access method used should use very little space. Note that only one pass of the data is needed to apply the "backward" semijoin. 2.2 Improving Hash Filters with Tuple Bit-Vectors Hash filters <ref> [Blo70, Bab79] </ref> can be used in a fashion similar to semijoin projections. Rather than transmitting the values for the join attribute, one hashes the values into a hash table and transmits the table.
Reference: [BC81] <author> P.A. Bernstein and D.M. Chiu. </author> <title> Using semi-joins to solve relational queries. </title> <journal> J.ACM, </journal> <volume> 28(1) </volume> <pages> 25-40, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction Much work had been done on optimizing the cost of distributed query processing (henceforth abbreviated as DQP) under various cost models [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93]. Most DQP algorithms rely on some variants of the semijoin technique <ref> [BC81, BG81] </ref>, and concentrate on reducing the cost of inter-site data movement. A distributed query is typically processed in the following stages [YC84]: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2. <p> Semijoin based algorithms will not work since cyclic queries do not have full-reducer semijoin programs <ref> [BC81] </ref>. The tuple bit vectors sent back to each joining relation encode the complete join reduction information collected after constructing the full join result tuple connector. Thus our algorithm does not depend on the acyclic query property. <p> In contrast, using our architecture, we pay the overhead of sending the join projections and their tuple bit vectors, but receive optimal number of relation tuples back at the assembling site because we utilize the whole join reduction information. 2 The class of cyclic join queries doesn't have a full-reducer <ref> [BC81] </ref>. For this class of queries, semijoin based algorithms would fail to perform effective network cost reduction and little optimization could be done to reduce the total query processing and response time.
Reference: [BG81] <author> P.A. Bernstein and N. Goodman. </author> <title> The power of natural joins. </title> <journal> SIAM J. Computi., </journal> <volume> 10 </volume> <pages> 751-771, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction Much work had been done on optimizing the cost of distributed query processing (henceforth abbreviated as DQP) under various cost models [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93]. Most DQP algorithms rely on some variants of the semijoin technique <ref> [BC81, BG81] </ref>, and concentrate on reducing the cost of inter-site data movement. A distributed query is typically processed in the following stages [YC84]: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2.
Reference: [BGW + 81] <author> Philip Bernstein, Nathan Goodman, Eugene Wong, Christopher L. Reeve, and James B. Rothie. </author> <title> Query processing in a system for distruibuted databases(sdd-1). </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(4) </volume> <pages> 602-625, </pages> <year> 1981. </year>
Reference-contexts: First, the optimality of the query plans generated by the corresponding algorithms all depend on the accuracy of semijoin selectivity and intermediate join result size estimations. The semijoin selectivity estimation techniques adopted in the past are simply inherited or derived from the model in <ref> [Yao77, BGW + 81] </ref>, which makes simplistic assumptions about the data such as uniform distribution of values. Due to the severe estimation error propagation effects [IC91], the optimal strategies produced are sometimes no superior than a randomly chosen plan.
Reference: [Blo70] <author> Burton H. Bloom. </author> <title> Space/time trade-offs in hash coding with allowable errors. </title> <journal> Communications of the ACM, </journal> <volume> 13(7) </volume> <pages> 422-426, </pages> <year> 1970. </year>
Reference-contexts: Storing the access method used should use very little space. Note that only one pass of the data is needed to apply the "backward" semijoin. 2.2 Improving Hash Filters with Tuple Bit-Vectors Hash filters <ref> [Blo70, Bab79] </ref> can be used in a fashion similar to semijoin projections. Rather than transmitting the values for the join attribute, one hashes the values into a hash table and transmits the table.
Reference: [CLYY92] <author> M.-S. Chen, M.-L. Lo, P.S. Yu, and Y.C. Young. </author> <title> Using segmented right-deep trees for the execution of pipelined hash joins. </title> <booktitle> In Proceedings of the 18th International Conference on Very Large Data bases, </booktitle> <pages> pages 15-26, </pages> <year> 1992. </year>
Reference-contexts: The second scheme is to construct a dataflow pipeline using hybrid-hash join algorithms. This scheme, defined as the scheduling problem among left-deep, right-deep and bushy query tree formats used to execute the N-way join query, has been an active research topic <ref> [SD90, WA91, LCRY93, CLYY92] </ref>. We give an example to show how the first round projection join can be parallelized using this scheme. <p> This "thrashing" of hash partitions might involve significant disk I/O overhead which could defeat all the benefits of parallelism. Previous research <ref> [SD90, WA91, LCRY93, CLYY92] </ref> usually focused on a multiprocessor environment. <p> Parallelism issue is not addressed in [RK91]. In <ref> [SD90, WA91, LCRY93, CLYY92] </ref>, the problem of pipelined hash-based processing of N-way join queries in a tightly coupled, shared-nothing multiprocessor database environment is investigated.
Reference: [CY93] <author> Ming-Syan Chen and Philip S. Yu. </author> <title> Combining join and semi-join operations for distributed query procesing. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(3) </volume> <pages> 534-542, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction Much work had been done on optimizing the cost of distributed query processing (henceforth abbreviated as DQP) under various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most DQP algorithms rely on some variants of the semijoin technique [BC81, BG81], and concentrate on reducing the cost of inter-site data movement. A distributed query is typically processed in the following stages [YC84]: 1.
Reference: [Dan82] <author> D Daniels. </author> <title> Query compilation in a distributed database system. </title> <institution> IBM Res. </institution> <type> Rep. RJ 3423, </type> <institution> IBM, </institution> <year> 1982. </year>
Reference-contexts: A two-way semijoin aims to simultaneously reduce both R and S so that they each contain only tuples that match the other relation. The two-way semijoin (henceforth referred to as 2SJ) was introduced in <ref> [Dan82] </ref> and later promoted in [Seg86].
Reference: [DMFV90] <author> David J. DeWitt, David Maier, Philippe Futtersack, and Fernando Velez. </author> <title> A study of three alternative workstation-server architectures for object oriented database systems. </title> <booktitle> In Proceedings of the 16th VLDB conference, </booktitle> <pages> pages 107-121, </pages> <year> 1990. </year>
Reference-contexts: No error propagation in the estimation is incurred. In addition, maximum site autonomy is maintained. Our architecture treats each remote database system as page servers <ref> [DMFV90] </ref>, and is relatively insensitive to heterogeneous administration policy and data models at the remote sites. Remote DBMS are only required to provide the services of filtered relation scan for this architecture to work.
Reference: [ESW78] <author> R. Epstein, M. Stonebraker, and E. Wong. </author> <title> Distributed query processing in a relational database system. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 169-180, </pages> <year> 1978. </year>
Reference-contexts: 1 Introduction Much work had been done on optimizing the cost of distributed query processing (henceforth abbreviated as DQP) under various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most DQP algorithms rely on some variants of the semijoin technique [BC81, BG81], and concentrate on reducing the cost of inter-site data movement. A distributed query is typically processed in the following stages [YC84]: 1. <p> The master and slaves are interconnected via a fast local-area network. 4.1 Parallelizing the Projection Join Given the configuration of our architecture, there are two schemes applicable to parallelize the first round N-way projection join. One was presented in the FR algorithm <ref> [ESW78] </ref> and the Symmetric FR algorithm [SY93]. They basically unicast the whole of the largest relation and multicast the whole of the remaining N 1 relations to each participating slave site. Since each slave only receives a disjoint portion of the work, they can proceed in parallel without inter-slave synchronization.
Reference: [HY79] <author> A.R. Hevner and S.B. Yao. </author> <title> Query processing in distributed database system. </title> <journal> IEEE Trans. Software Eng., </journal> <volume> SE-5(3), </volume> <year> 1979. </year>
Reference-contexts: 1 Introduction Much work had been done on optimizing the cost of distributed query processing (henceforth abbreviated as DQP) under various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most DQP algorithms rely on some variants of the semijoin technique [BC81, BG81], and concentrate on reducing the cost of inter-site data movement. A distributed query is typically processed in the following stages [YC84]: 1.
Reference: [IC91] <author> Y. Ioannnidis and S. Christodoulakis. </author> <title> On the propagation of errors in the size of join results. </title> <booktitle> In Proceedings of the ACM-SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 268-277, </pages> <year> 1991. </year>
Reference-contexts: The semijoin selectivity estimation techniques adopted in the past are simply inherited or derived from the model in [Yao77, BGW + 81], which makes simplistic assumptions about the data such as uniform distribution of values. Due to the severe estimation error propagation effects <ref> [IC91] </ref>, the optimal strategies produced are sometimes no superior than a randomly chosen plan. Second, this architecture also makes the assumption that the optimizer can dispatch the workloads to any participating sites, e.g., site autonomy is not preserved at all. <p> The optimal execution plans generated by semijoin based algorithms rely heavily on the correct estimation of intermediate join result sizes, therefore are not robust to estimation errors <ref> [IC91] </ref>. Because our architecture does not depend on the semijoin technique, the importance of correctly estimating the sizes of intermediate relations resulting from a join or semijoin is significantly reduced. No error propagation in the estimation is incurred. In addition, maximum site autonomy is maintained.
Reference: [LCRY93] <author> Ming-Ling Lo, Ming-Syan Chen, C. V. Ravishankar, and Philip S. Yu. </author> <title> On optimal processor allocation to support pipelined hash joins. </title> <booktitle> In Proceedings of the 1993 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 69-78, </pages> <year> 1993. </year>
Reference-contexts: The second scheme is to construct a dataflow pipeline using hybrid-hash join algorithms. This scheme, defined as the scheduling problem among left-deep, right-deep and bushy query tree formats used to execute the N-way join query, has been an active research topic <ref> [SD90, WA91, LCRY93, CLYY92] </ref>. We give an example to show how the first round projection join can be parallelized using this scheme. <p> This "thrashing" of hash partitions might involve significant disk I/O overhead which could defeat all the benefits of parallelism. Previous research <ref> [SD90, WA91, LCRY93, CLYY92] </ref> usually focused on a multiprocessor environment. <p> Parallelism issue is not addressed in [RK91]. In <ref> [SD90, WA91, LCRY93, CLYY92] </ref>, the problem of pipelined hash-based processing of N-way join queries in a tightly coupled, shared-nothing multiprocessor database environment is investigated. <p> In a multiprocessor environment the interconnection network typically has a very high bandwidth. Data distribution is relatively cheap, and efficiently utilizing the memory is usually the chief optimization criterion. For instance in <ref> [LCRY93] </ref>, only hash table building and join probing costs are considered which primarily consist of CPU costs only. In our scheme the calculation of hash table building costs would have to explicitly take into account the relation scanning time and network transmission cost.
Reference: [LR94] <author> Zhe Li and Ken Ross. </author> <title> Better semijoins using tuple bit-vectors. </title> <type> Technical Report CUCS-010-94, </type> <institution> Columbia University, </institution> <address> New York, NY 10027, </address> <year> 1994. </year>
Reference-contexts: W (X ) width of the attribute (s) X (in bytes). V i the tuple bit vector for R i . 2 Tuple Bit Vectors In this section we describe the use of tuple-bit-vectors, as proposed in <ref> [LR94] </ref>. 2.1 Improving Two-Way Semijoins with Tuple Bit-Vectors A one-way semijoin aims to reduce a relation R to contain only those tuples that match with tuples from another relation S. <p> In [RK91], an improved technique for two-way semijoins was proposed. We refer to this technique as "2SJ+." In the backward reduction phase, the set of matching values, or the set of nonmatching values if this set is smaller, is sent back to reduce the other relation. In <ref> [LR94] </ref>, this technique was further improved using tuple bit-vectors, as illustrated below. This new technique we call "2SJ++." Definition 2.1: Let R be a relation whose tuples are ordered in some fashion. A tuple bit vector V R of relation R is an array of jRj bits. <p> Given the original hash table and T , the table H can be reconstructed. The savings will be particularly high if the table H is sparse (which is usually the case in order to minimize collisions <ref> [LR94] </ref>). Thus we also consider a two way semijoin based on hash filters that uses tuple bit vectors for the backward reduction as an example of 2SJ++. <p> The tuple bit vector would always be a set of bits that filters out a subset of the original relation tuples. In <ref> [LR94] </ref> we show that the network overhead incurred by tuple bit vectors is very small compared with other semijoin variants. 3.1 Advantages of this Architecture One important aspect of this architecture is that we can handle cyclic join queries. <p> We now analyze the cost (i.e., response time, counting just the network transmission time in bytes) of the one-shot algorithm on this example. As described in [WCS92], the one-shot algorithm uses hash filters to compress the semijoin information in order to reduce the network overhead. In <ref> [LR94] </ref>, we argue that the number of bits used in the hash filters, i.e., the size of the hash table, should be at least equal to the cardinality of the larger joining relation, in order to reduce the effect of hash collisions. <p> An improved semijoin variant denoted as 2SJ+ <ref> [LR94] </ref> is combined with caching to obtain a pipelined N-way join algorithm. Because all nonjoining attributes are not included in the tuple connectors during the semijoin (or join) reduction stage, they are typically a lot smaller than their corresponding relations, thus incurring less network overhead. <p> Our work differs from [RK91] in that we use an even better primitive based on the idea of the tuple bit-vector <ref> [LR94] </ref>. Instead of sending back the matched (or unmatched if the number is smaller) join attribute values during the backward reduction phase, we send a much more compact bit vector with bits corresponding to matched (or unmatched) tuples set to 1 to deliver the same reduction information.
Reference: [Moh92] <author> C. Mohan. </author> <title> Interactions between query optimization and concurrency control. </title> <booktitle> In Second International Workshop on Research Issues on Data Engineering: Transaction Processing and Query Processing, </booktitle> <pages> pages 26-35, </pages> <year> 1992. </year>
Reference-contexts: Since remote DBMS should be full-fledged database systems capable of handling concurrency control and recovery, their query engines may not be very efficient due to these maintenance overhead (such as acquiring locks, blocking for locks etc. <ref> [Moh92] </ref>). In our architecture, the query originating site is the only site required to have query processing capabilities.
Reference: [RK91] <author> Nick Roussopoulos and Hyunchul Kang. </author> <title> A pipeline n-way join algorithm based on the 2-way semijoin program. </title> <journal> IEEE Transactions on Knowledge And Data Engineering, </journal> <volume> 3(4) </volume> <pages> 486-495, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Much work had been done on optimizing the cost of distributed query processing (henceforth abbreviated as DQP) under various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most DQP algorithms rely on some variants of the semijoin technique [BC81, BG81], and concentrate on reducing the cost of inter-site data movement. A distributed query is typically processed in the following stages [YC84]: 1. <p> A tuple connector is defined as as a projection of relation R on all the joining attributes and the corresponding tuple identifiers (TID) <ref> [RK91] </ref>. Each row in the tuple connector uniquely identifies a whole tuple in the corresponding relation. <p> We refer to steps (a) and (b) as the "forward reduction" phase, and to step (c) as the "backward reduction" phase. In <ref> [RK91] </ref>, an improved technique for two-way semijoins was proposed. We refer to this technique as "2SJ+." In the backward reduction phase, the set of matching values, or the set of nonmatching values if this set is smaller, is sent back to reduce the other relation. <p> Knowing the final join connector is empty, we don't need to send back the tuple bit vectors at all. The overhead we pay in this example is only the network cost of join projections instead of the whole tuple values. 2 6 Survey of Related Work In <ref> [RK91] </ref> the concept of tuple connector is used to construct a pipeline to handle an N-way join query. An improved semijoin variant denoted as 2SJ+ [LR94] is combined with caching to obtain a pipelined N-way join algorithm. <p> The main goal of the algorithm is to eliminate the need of shipping, storing, and retrieving foreign relations and/or intermediate results on the local disks of the remote and the query site during the processing of the N-way join. Our work differs from <ref> [RK91] </ref> in that we use an even better primitive based on the idea of the tuple bit-vector [LR94]. <p> Thus we pay much less network overhead during the forward transmission phase of join projections. After constructing the join result tuple connector, <ref> [RK91] </ref> sends back the actual TIDs for the matched tuples. <p> Parallelism issue is not addressed in <ref> [RK91] </ref>. In [SD90, WA91, LCRY93, CLYY92], the problem of pipelined hash-based processing of N-way join queries in a tightly coupled, shared-nothing multiprocessor database environment is investigated.
Reference: [SALP79] <author> P. Griffiths Selinger, M. M. Astrahan, R.A. Lorie, and T. G. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proceedings of the 1979 SIGMOD Conference, </booktitle> <pages> pages 23-34, </pages> <year> 1979. </year>
Reference-contexts: Note that no indexes will be shipped with the reduced relations to the final assembly site. It is likely that the join operation would be executed using the more costly versions of join algorithms <ref> [SALP79] </ref>. In the case of a low join selectivity, i.e., the query result is a near cartesian product, the final assembly join operation would be very expensive, representing a dominant cost factor in the overall query processing time. There are a number of disadvantages for this architecture.
Reference: [SD90] <author> D. A. Schneider and D. J. DeWitt. </author> <title> Tradeoffs in processing complex join queries via hashing in multiprocessor database machines. </title> <booktitle> In Proceedings of the 16th VLDB conference, </booktitle> <pages> pages 469-480, </pages> <year> 1990. </year>
Reference-contexts: The second scheme is to construct a dataflow pipeline using hybrid-hash join algorithms. This scheme, defined as the scheduling problem among left-deep, right-deep and bushy query tree formats used to execute the N-way join query, has been an active research topic <ref> [SD90, WA91, LCRY93, CLYY92] </ref>. We give an example to show how the first round projection join can be parallelized using this scheme. <p> This "thrashing" of hash partitions might involve significant disk I/O overhead which could defeat all the benefits of parallelism. Previous research <ref> [SD90, WA91, LCRY93, CLYY92] </ref> usually focused on a multiprocessor environment. <p> Parallelism issue is not addressed in [RK91]. In <ref> [SD90, WA91, LCRY93, CLYY92] </ref>, the problem of pipelined hash-based processing of N-way join queries in a tightly coupled, shared-nothing multiprocessor database environment is investigated.
Reference: [Seg86] <author> Arie Segev. </author> <title> Optimization of join operations in horizontally partitioned database systems. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 11(1) </volume> <pages> 48-80, </pages> <year> 1986. </year>
Reference-contexts: A two-way semijoin aims to simultaneously reduce both R and S so that they each contain only tuples that match the other relation. The two-way semijoin (henceforth referred to as 2SJ) was introduced in [Dan82] and later promoted in <ref> [Seg86] </ref>.
Reference: [SY93] <author> James W. Stamos and Honesty C. Young. </author> <title> A symmetric fragment and replicate algorithm for distributed joins. </title> <journal> IEEE Transactions on Parallel And Distributed Systems, </journal> <volume> 4(12) </volume> <pages> 1345-1354, </pages> <year> 1993. </year>
Reference-contexts: The master and slaves are interconnected via a fast local-area network. 4.1 Parallelizing the Projection Join Given the configuration of our architecture, there are two schemes applicable to parallelize the first round N-way projection join. One was presented in the FR algorithm [ESW78] and the Symmetric FR algorithm <ref> [SY93] </ref>. They basically unicast the whole of the largest relation and multicast the whole of the remaining N 1 relations to each participating slave site. Since each slave only receives a disjoint portion of the work, they can proceed in parallel without inter-slave synchronization.
Reference: [Ull89] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge Base Systems. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year> <title> (Two volumes). </title>
Reference-contexts: Thus we pay much less network overhead during the forward transmission phase of join projections. After constructing the join result tuple connector, [RK91] sends back the actual TIDs for the matched tuples. In contrast, we send back a tuple bit vector 2 This example is based on one from <ref> [Ull89] </ref>. 15 which is usually cheaper in network cost. 3 Also our pipeline model to construct the join result tuple connector is more sophisticated and employs parallelism aggressively. Parallelism issue is not addressed in [RK91].
Reference: [WA91] <author> A. Wilschut and P. Apers. </author> <title> Dataflow query execution in parallel main-memory environment. </title> <booktitle> In Proceedings of 1st conference on parallel and distributed information systems, </booktitle> <pages> pages 68-97, </pages> <year> 1991. </year>
Reference-contexts: The second scheme is to construct a dataflow pipeline using hybrid-hash join algorithms. This scheme, defined as the scheduling problem among left-deep, right-deep and bushy query tree formats used to execute the N-way join query, has been an active research topic <ref> [SD90, WA91, LCRY93, CLYY92] </ref>. We give an example to show how the first round projection join can be parallelized using this scheme. <p> This "thrashing" of hash partitions might involve significant disk I/O overhead which could defeat all the benefits of parallelism. Previous research <ref> [SD90, WA91, LCRY93, CLYY92] </ref> usually focused on a multiprocessor environment. <p> Parallelism issue is not addressed in [RK91]. In <ref> [SD90, WA91, LCRY93, CLYY92] </ref>, the problem of pipelined hash-based processing of N-way join queries in a tightly coupled, shared-nothing multiprocessor database environment is investigated.
Reference: [WCS92] <author> Chihping Wang, Arbee L.P. Chen, and Shiow-Chen Shyu. </author> <title> A parallel execution method for minimizing distributed query response time. </title> <journal> IEEE Transactions on Parallel And Distributed Systems, </journal> <volume> 3(3) </volume> <pages> 325-333, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Much work had been done on optimizing the cost of distributed query processing (henceforth abbreviated as DQP) under various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most DQP algorithms rely on some variants of the semijoin technique [BC81, BG81], and concentrate on reducing the cost of inter-site data movement. A distributed query is typically processed in the following stages [YC84]: 1. <p> Nevertheless, there are situations in which our architecture outperforms some of these proposals. This architecture can be a winner compared with the traditional semijoin based three-stage architecture to process N-way join, for instance, compared with the "One-Shot" algorithm presented in <ref> [WCS92] </ref>. In our architecture, we construct the full join in the tuple connector form. We then send back the tuple bit vectors, which effectively eliminates all the unmatched tuples at each remote site. In contrast, semijoin based approaches may eliminate only a subset of the unmatched tuples. <p> Despite the semijoin, the reduction effect is far from optimal. We now analyze the cost (i.e., response time, counting just the network transmission time in bytes) of the one-shot algorithm on this example. As described in <ref> [WCS92] </ref>, the one-shot algorithm uses hash filters to compress the semijoin information in order to reduce the network overhead. <p> By adopting the tuple bit vector idea rather than the commonly used semijoin technique, the network overhead is more effectively reduced. We compared our tuple bit vector based DQP algorithm within this architecture with other semijoin based DQP algorithms. Using the "one-shot" algorithm <ref> [WCS92] </ref> as a representative of parallel semijoin based DQP algorithms, we demonstrated that our algorithm can lead to better performance for both commonly encountered chain queries and cyclic queries than conventional DQP algorithms.
Reference: [Won77] <author> E. Wong. </author> <title> Retrieving dispersed data from sdd-1: A system for distributed databases. </title> <booktitle> In Proceedings of the 2nd Berkeley Workshop on Distributed Data Management and Computer Networks, </booktitle> <year> 1977. </year>
Reference-contexts: 1 Introduction Much work had been done on optimizing the cost of distributed query processing (henceforth abbreviated as DQP) under various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most DQP algorithms rely on some variants of the semijoin technique [BC81, BG81], and concentrate on reducing the cost of inter-site data movement. A distributed query is typically processed in the following stages [YC84]: 1.
Reference: [Yao77] <author> S.B. Yao. </author> <title> Approximating block accesses in database organizations. </title> <journal> Communications of the ACM, </journal> <volume> 20(4) </volume> <pages> 260-261, </pages> <year> 1977. </year>
Reference-contexts: First, the optimality of the query plans generated by the corresponding algorithms all depend on the accuracy of semijoin selectivity and intermediate join result size estimations. The semijoin selectivity estimation techniques adopted in the past are simply inherited or derived from the model in <ref> [Yao77, BGW + 81] </ref>, which makes simplistic assumptions about the data such as uniform distribution of values. Due to the severe estimation error propagation effects [IC91], the optimal strategies produced are sometimes no superior than a randomly chosen plan.
Reference: [YC84] <author> C.T. Yu and C. C. Chang. </author> <title> Distributed query processing. </title> <booktitle> ACM Computing Surverys, </booktitle> <pages> pages 399-433, </pages> <year> 1984. </year> <month> 18 </month>
Reference-contexts: 1 Introduction Much work had been done on optimizing the cost of distributed query processing (henceforth abbreviated as DQP) under various cost models <ref> [ESW78, HY79, AHY83, Won77, YC84, RK91, WCS92, CY93] </ref>. Most DQP algorithms rely on some variants of the semijoin technique [BC81, BG81], and concentrate on reducing the cost of inter-site data movement. A distributed query is typically processed in the following stages [YC84]: 1. <p> Most DQP algorithms rely on some variants of the semijoin technique [BC81, BG81], and concentrate on reducing the cost of inter-site data movement. A distributed query is typically processed in the following stages <ref> [YC84] </ref>: 1. Initial local processing: All local selection, projection and local join operations are performed first. 2. Semijoin reduction: After the preprocessing by the first step, the only operations left are remote joins between different sites.
References-found: 27

