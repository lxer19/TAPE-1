URL: ftp://ftp.cse.ogi.edu/pub/pacsoft/2final_report/pi3.ps
Refering-URL: http://www.cse.ogi.edu/PacSoft/projects/SDRR/p2_report.html
Root-URL: http://www.cse.ogi.edu
Email: email: apt@cs.pdx.edu  email: oliva@cse.ogi.edu  
Title: From ML to Ada: Strongly-typed Language Interoperability via Source Translation  
Author: ANDREW TOLMACH DINO P. OLIVA 
Address: P.O. Box 751, Portland, OR, 97207-0751, USA  20000 N.W. Walker Road, P.O. Box 91000, Portland, OR 97291-1000, USA  
Affiliation: Pacific Software Research Center Department of Computer Science, Portland State University,  Pacific Software Research Center Department of Computer Science and Engineering, Oregon Graduate Institute,  
Date: 1 (1): 1-000, January 1993  
Note: J. Functional Programming  c 1993 Cambridge University Press 1  
Abstract: We describe a system that supports source-level integration of ML-like functional language code with ANSI C or Ada83 code. The system works by translating the functional code into type-correct, "vanilla" C or Ada; it offers simple, efficient, type-safe inter-operation between new functional code components and "legacy" third-generation-language components. Our translator represents a novel synthesis of techniques including user-parameterized specification of primitive types and operators; removal of polymor-phism by code specialization; removal of higher-order functions using closure datatypes and interpretation; and aggressive optimization of the resulting first-order code, which can be viewed as encoding the result of a closure analysis. Programs remain fully typed at every stage of the translation process, using only simple, standard type systems. Target code runs at speeds comparable to the output of current optimizing ML compilers, even though handicapped by a conservative garbage collector.
Abstract-found: 1
Intro-found: 1
Reference: <author> Appel, A. W. </author> <year> (1992). </year> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press. </publisher>
Reference: <author> Appel, A. W. and Jim, T. </author> <year> (1989). </year> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Sixteenth ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <address> New York. </address> <publisher> ACM Press. </publisher>
Reference-contexts: We therefore must convert higher-order programs into equivalent first-order programs without nested functions, i.e., perform closure conversion. For simplicity, we wish to express the first-order programs in a strict subset of the original language, as in "closure-passing style" <ref> (Appel and Jim, 1989) </ref>, where closures are represented as ordinary records, and are constructed and accessed using ordinary record operators. In particular, this would allow us to optimize closure manipulation operations using ordinary record optimizations.
Reference: <author> Appel, A. W. and Jim, T. </author> <year> (1998). </year> <title> Shrinking lambda expressions in linear time. </title> <journal> Journal of Functional Programming. </journal> <note> (to appear). </note>
Reference: <author> Baker, H. G. </author> <year> (1990). </year> <title> Unify and conquer (garbage collection, updating, aliasing, </title> : : :) <booktitle> in functional languages. In Proc. 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 218-226. </pages>
Reference: <author> Bell, J. M. </author> <year> (1994). </year> <title> An implementation of Reynold's defunctionalization method for a modern functional language. </title> <type> Master's thesis, </type> <institution> Oregon Graduate Institute. </institution>
Reference: <author> Bell, J. M., Bellegarde, F., and Hook, J. </author> <year> (1997). </year> <title> Type-driven defunctionalization. </title> <booktitle> In Proc. 2nd International Conference on Functional Programming, </booktitle> <pages> pages 25-37. </pages> <note> From ML to Ada 45 Bellegarde, </note> <author> F. and Hook, J. </author> <year> (1994). </year> <title> Substitution: A formal methods case study using monads and transformations. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 23(2-3):287-311. </address>
Reference-contexts: Bell, Bellegarde and Hook <ref> (Bell et al., 1997) </ref> have specified a more elaborate algorithm for polymorphic source programs that performs type specialization and higher-order removal simultaneously, and may leave parts of the program polymorphic where that is possible.
Reference: <author> Boehm, H.-J. and Weiser, M. </author> <year> (1988). </year> <title> Garbage collection in an uncooperative environment. </title> <journal> Software|Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-20. </pages>
Reference-contexts: Memory management is one area in which we have not innovated. Our C back end incorporates the Boehm-Demers-Weiser conservative collector <ref> (Boehm and Weiser, 1988) </ref>. Heap allocation in C is the one spot where we must perform casting, in order to allocate storage for values of different types from a common heap; of course, this is standard practice in C. <p> Row smlnj represents the behavior of Standard ML of New Jersey. The other rows represent the behavior of our compiler generating C under a variety of compilation settings; the resulting C was then compiled gcc and (unless otherwise noted) linked with the Boehm-Demers-Weiser conservative garbage collector <ref> (Boehm and Weiser, 1988) </ref>. Row standard represents the standard configuration of our compiler. In particular, flat (non-heap) datatype representations are used for all non-recursive closure types. Execution times for our compiler are within a small factor of those of SML/NJ, and substantially better in some cases.
Reference: <author> Bondorf, A. </author> <year> (1990). </year> <title> Automatic autoprojection of higher order recursive equations. </title> <booktitle> Science of Computer Programming, </booktitle> <address> 17(1-3):3-34. </address>
Reference: <author> Bondorf, A. and Jtrgensen, J. </author> <year> (1993). </year> <title> Efficient analyses for realistic off-line partial evaluation. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(3) </volume> <pages> 315-346. </pages>
Reference: <author> Cardelli, L. </author> <year> (1984). </year> <title> Compiling a functional language. </title> <booktitle> In Proc. 1984 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 208-217. </pages>
Reference: <author> Cardelli, L. </author> <year> (1987). </year> <title> Basic polymorphic typechecking. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 147-172. </pages>
Reference: <author> Chailloux, E. </author> <year> (1992). </year> <title> An efficient way of compiling ML to C. </title> <booktitle> In Proc. ACM Workshop on ML and its Applications, </booktitle> <pages> pages 37-51. </pages>
Reference: <author> Chin, W.-N. and Darlington, J. </author> <year> (1996). </year> <title> A higher order removal method. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 9(4) </volume> <pages> 287-322. </pages>
Reference-contexts: This effect is illustrated by the code in Figure 15, which shows the closure-converted version of our running example. In contrast with higher-order removal techniques based on code specialization <ref> (Chin and Darlington, 1996) </ref>, our algorithm can handle programs in which the number of generated closures cannot be statically bounded. Figure 16 gives an example, based on the well-known encoding of an integer set as a characteristic function of type int-&gt;bool.
Reference: <author> Cridlig, R. </author> <year> (1992). </year> <title> An optimizing ML to C compiler. </title> <booktitle> In Proc. ACM Workshop on ML and its Applications, </booktitle> <pages> pages 28-36. </pages>
Reference: <author> Damas, L. </author> <year> (1984). </year> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> University of Edinburgh. </institution>
Reference: <author> Flanagan, C., Sabry, A., Duba, B. F., and Felleisen, M. </author> <year> (1993). </year> <title> The essence of compiling with continuations. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(6) </volume> <pages> 237-247. </pages> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The annotated code is then translated to monomorphic form (Section 6). * The monomorphic RML code is transformed to a more restrictive language, called SIL (for "Sequentialized Intermediate Language"), which is a variant of A-normal form <ref> (Flanagan et al., 1993) </ref>, closely related to continuation-passing style (Steele, 1978; Kranz et al., 1986; Appel, 1992). In SIL (Figure 12), all arguments to functions and primitives are required to be named variables or constants. <p> SIL adopts a relatively permissive approach to the location of let-bindings: it permits the result of a case to be let-bound, unlike A-normal form <ref> (Flanagan et al., 1993) </ref>, and even permits the result of a let expression to be let-bound, unlike both A-normal form and Til's B-form (Tarditi, 1996).
Reference: <author> Hindley, R. </author> <year> (1969). </year> <title> The principal type-scheme of an object in combinatory logic. </title> <journal> Trans. Amer. Math. Soc., </journal> <volume> 146 </volume> <pages> 29-60. </pages>
Reference: <author> Huelsbergen, L. </author> <year> (1996). </year> <title> A portable C interface for Standard ML of New Jersey. </title> <note> Available at http://cm.bell-labs.com/who/lorenz/papers/smlnj-c.ps. </note>
Reference: <author> Jagannathan, S. and Wright, A. K. </author> <year> (1996). </year> <title> Flow-directed inlining. </title> <booktitle> In Proceedings of the ACM Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 193-205. </pages>
Reference-contexts: A singleton set of constructors is ideal: the optimizer knows precisely which function will be called, and can arrange to call it directly or (if it small enough) inline it <ref> (Jagannathan and Wright, 1996) </ref>. Inlining is also possible (with some risk of code blow-up) for sets with just a few constructors, although we have not implemented this.
Reference: <author> Jones, M. P. </author> <year> (1993). </year> <title> Partial evaluation for dictionary-free overloading. </title> <type> Technical Report YALEU/DCS/RR-959, </type> <institution> Yale University Dept. of Computer Science. </institution>
Reference-contexts: Templates are specified using a specialized definition language; see Section 4. * Our system removes polymorphism from RML programs by cloning polymorphic functions and datatype declarations, making a separate monomorphic version for each distinct set of instantiating type variables; see Section 6. Although this approach has been suggested before <ref> (Jones, 1993) </ref>, and similar effects have sometimes been achieved by accident (Tarditi et al., 1996), we are unaware of any previous practical, intentional realizations. <p> practice, as most polymorphic functions tend to be small; this is probably because the more polymorphic a function is, the fewer useful things it can do (Wadler, 1989)! The idea of removing parametric polymorphism by specialization has received much informal discussion, and a small experiment has been attempted for Gofer <ref> (Jones, 1993) </ref>, but we are not aware of any previous practical compiler based on this approach.
Reference: <author> Kelsey, R. A. </author> <year> (1995). </year> <title> A correspondence between continuation passing style and static single assignment form. </title> <booktitle> In Proc. ACM SIGPLAN Workshop on Intermediate Representations, </booktitle> <pages> pages 13-22. </pages>
Reference-contexts: In SIL (Figure 12), all arguments to functions and primitives are required to be named variables or constants. Thus, the translation from RML to SIL (Section 7) effectively fixes the order of evaluation of all primitives. SIL also supports "jump points," i.e., locally scoped continuation functions <ref> (Kelsey, 1995) </ref>, though the initial translation to SIL doesn't use these. * The SIL code is optimized (Section 8) by repeated application of rewrite rules that encode "partial-evaluation style" improvements: value and variable propagation, simplification of case expressions over known values, elimination of dead code and unused datatypes, and conservative function <p> To make it possible to express calls as jumps, SIL includes a facility for defining labeled jump points and corresponding gotos within a function <ref> (Kelsey, 1995) </ref>. Jump points are declared similarly to let-bound functions, with a label name, formal parameters, defining expression, and body; gotos are similar to function applications, with a target jump point label and actual parameters.
Reference: <author> Kieburtz, R. B., Bellegarde, F., Bell, J., Hook, J., Lewis, J., Oliva, D., Sheard, T., Walton, L., and Zhou, T. </author> <year> (1995). </year> <title> Calculating software generators from solution specifications. </title> <booktitle> In TAPSOFT'95, volume 915 of LNCS, </booktitle> <pages> pages 546-560. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Our system has been developed as the back end of a larger application generator system that produces integrable components from high-level specifications <ref> (Kieburtz et al., 1995) </ref>; we first generate RML code from the specifications using semantics-directed techniques, and then translate that code to Ada83 using the scheme described in this paper. 1 However, the system is quite general; it can accommodate hand-written or generated RML code from any source, and may be useful <p> the factorial function; the former is in direct style and the latter in continuation-passing style; they are taken from Bondorf (1990). sieve is a list-based version of the sieve of Eratosthenes. mess parses and reformats simple bit-based messages; the RML code was generated by our Message Specification Language application generator <ref> (Kieburtz et al., 1995) </ref>. Row smlnj represents the behavior of Standard ML of New Jersey.
Reference: <author> Koch, M. and Olesen, T. H. </author> <year> (1996). </year> <title> Compiling a higher-order call-by-value functional programming language to a RISC using a stack of regions. </title> <type> Master's thesis, </type> <institution> University of Copenhagen. DIKU Dissertation 96-10-5. </institution>
Reference-contexts: Existing implementations of this so-called closure analysis use abstract interpretation involving a fixpoint calculation (Sestoft, 1988; Shivers, 1991), a constraint-based mechanism (Bondorf and Jtrgensen, 1993; Palsberg, 1995), or region inference <ref> (Koch and Olesen, 1996) </ref>. Surprisingly, no existing system appears to take advantage of the fact that simple typing provides a good first cut at the analysis "for free." Also, existing closure analysis algorithms do not express their results within the language itself, and so cannot feed subsequent general-purpose optimizations.
Reference: <author> Kranz, D., Kelsey, R., Rees, J., Hudak, P., Philbin, J., and Adams, N. </author> <year> (1986). </year> <title> Orbit: An optimizing compiler for Scheme. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(7) </volume> <pages> 219-233. </pages> <booktitle> Proceedings of the ACM SIGPLAN '86 Symposium on Compiler Construction. </booktitle>
Reference: <author> Lawall, J. L. and Danvy, O. </author> <year> (1993). </year> <title> Separating stages in the continuation-passing style transformation. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 124-136, </pages> <address> Charleston, South Carolina. </address>
Reference: <author> Leroy, X. </author> <year> (1991). </year> <title> The ZINC experiment: an economical implementation of the ML language. </title> <type> Technical Report 117, </type> <note> INRIA. </note> <author> 46 A. Tolmach and D. Oliva Leroy, X. </author> <year> (1992). </year> <title> Unboxed object and polymorphic typing. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 177-188. </pages>
Reference: <author> Leroy, X. </author> <year> (1997). </year> <title> The Objective Caml System: Documentation and User's Manual, </title> <note> Version 1.07. INRIA. </note>
Reference: <author> Milner, R. </author> <year> (1978). </year> <title> A theory of type polymorphism in programming. </title> <journal> J. Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375. </pages>
Reference: <author> Milner, R., Tofte, M., Harper, R., and MacQueen, D. </author> <year> (1997). </year> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA. </address>
Reference-contexts: Plain RML, without primitives, is essentially similar to the pure subset of core Standard ML (SML '97) <ref> (Milner et al., From ML to Ada 11 1997) </ref>, without nested patterns or many derived forms, but with the addition of true multi-argument functions and data constructors.
Reference: <author> Minamide, Y., Morrisett, G., and Harper, R. </author> <year> (1996). </year> <title> Typed closure conversion. </title> <booktitle> In Conference Record of POPL '96: 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 271-283. </pages>
Reference-contexts: The resulting code does not even require function pointers (which Ada83 lacks). Unlike previous treatments of typed closure-conversion <ref> (Minamide et al., 1996) </ref>, we do not need to introduce new language primitives or fancy type systems to maintain typability, although our method does again require access to the whole program, which must be monomorphic. * Our system optimizes the closure-converted code, using simple, standard "partial evaluation-style" transformations; although optimizing at
Reference: <author> Morrisett, G. </author> <year> (1995). </year> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University. </institution> <note> Available as TR CMU-CS-95-226. </note>
Reference-contexts: The first pass replaces any occurrences of free type variables by an arbitrary trivial type; this is safe because the computation never examines values whose types involve free type variables <ref> (Morrisett et al., 1995) </ref>. The second pass computes a mapping from each polymorphic variable and algebraic type constructor to its corresponding set of instantiations. The third pass uses this mapping to perform the actual specialization.
Reference: <author> Morrisett, G., Felleisen, M., and Harper, R. </author> <year> (1995). </year> <title> Abstract models of memory management. </title> <booktitle> In FPCA '95 SIGPLAN-SIGARCH-WG2.8 Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 66-77. </pages>
Reference-contexts: The first pass replaces any occurrences of free type variables by an arbitrary trivial type; this is safe because the computation never examines values whose types involve free type variables <ref> (Morrisett et al., 1995) </ref>. The second pass computes a mapping from each polymorphic variable and algebraic type constructor to its corresponding set of instantiations. The third pass uses this mapping to perform the actual specialization.
Reference: <author> Palsberg, J. </author> <year> (1995). </year> <title> Closure analysis in constraint form. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(1) </volume> <pages> 47-62. </pages>
Reference: <author> Peyton Jones, S. L. </author> <year> (1992). </year> <title> Implementing lazy functional languages on stock hardware: </title> <journal> the Spineless Tagless G-machine. Journal of Functional Programming, </journal> <pages> pages 127-202. </pages>
Reference: <author> Peyton Jones, S. L. </author> <year> (1996). </year> <title> Compilation by transformation: A report from the trenches. </title> <booktitle> In European Symposium on Programming (ESOP'96), volume 1058 of LNCS, </booktitle> <pages> pages 18-40. </pages>
Reference: <author> Peyton Jones, S. L., Hall, C., Hammond, K., Partain, W., and Wadler, P. </author> <year> (1993). </year> <title> The Glasgow Haskell compiler: a technical overview. </title> <booktitle> In Proc. UK Joint Framework for Information Technology (JFIT) Technical Conference, </booktitle> <publisher> Keele. </publisher>
Reference: <author> Peyton Jones, S. L., Nordin, T., and Reid, A. </author> <year> (1997). </year> <title> Green Card: A foreign language interface for Haskell. </title> <booktitle> In Proc. ACM SIGLAN Haskell Workshop. </booktitle>
Reference: <author> Reade, C. </author> <year> (1989). </year> <title> Elements of Functional Programming. </title> <publisher> Addison-Wesley. </publisher>
Reference: <author> Reynolds, J. C. </author> <year> (1972). </year> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In ACM National Conference, </booktitle> <pages> pages 717-740. </pages> <publisher> ACM. </publisher>
Reference: <author> Sestoft, P. </author> <year> (1988). </year> <title> Replacing function parameters by global variables. </title> <type> Master's thesis, </type> <institution> University of Copenhagen. </institution> <type> DIKU Master's thesis no. 254. </type>
Reference: <author> Shivers, O. </author> <year> (1991). </year> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <address> Pittsburgh, PA. CMU-CS-91-145. </address>
Reference: <author> Steele, G. L. </author> <year> (1978). </year> <title> Rabbit: a compiler for Scheme. </title> <type> Technical Report AI-TR-474, </type> <institution> MIT, </institution> <address> Cambridge, MA. </address>
Reference: <author> Talpin, J.-P. and Jouvelot, P. </author> <year> (1992). </year> <title> Polymorphic type, region, and effect inference. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3) </volume> <pages> 245-272. </pages>
Reference: <author> Tarditi, D. </author> <year> (1996). </year> <title> Design and Implementation of Code Optimizations for a Type-Directed Compiler for Standard ML. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University. </institution> <note> Technical Report CMU-CS-97-108. </note>
Reference-contexts: Although this approach has been suggested before (Jones, 1993), and similar effects have sometimes been achieved by accident <ref> (Tarditi et al., 1996) </ref>, we are unaware of any previous practical, intentional realizations. <p> There has been much recent interest in using typed intermediate representations in compilers (Peyton Jones et al., 1993; Morrisett, 1995), but in most cases types are abandoned well before code generation. The TIL compiler <ref> (Tarditi et al., 1996) </ref> does keep type information until a late stage in the compilation process when code has reached a low level form more primitive than 3GL code, but its type system is substantially more complex than the C or Ada-style typing we use. <p> Analysis of benchmarks run on the Til compiler <ref> (Tarditi et al., 1996) </ref> indicates that the compiler removes essentially all polymorphism as the result of aggressive function inlining, thus offering independent evidence that specialization need not lead to excessive code explosion. <p> SIL adopts a relatively permissive approach to the location of let-bindings: it permits the result of a case to be let-bound, unlike A-normal form (Flanagan et al., 1993), and even permits the result of a let expression to be let-bound, unlike both A-normal form and Til's B-form <ref> (Tarditi, 1996) </ref>.
Reference: <author> Tarditi, D., Lee, P., and Acharya, A. </author> <year> (1992). </year> <title> No assembly required: Compiling Standard ML to C. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(2) </volume> <pages> 161-177. </pages>
Reference: <author> Tarditi, D., Morrisett, G., Cheng, P., Stone, C., Harper, R., and Lee, P. </author> <year> (1996). </year> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 181-192. </pages>
Reference-contexts: Although this approach has been suggested before (Jones, 1993), and similar effects have sometimes been achieved by accident <ref> (Tarditi et al., 1996) </ref>, we are unaware of any previous practical, intentional realizations. <p> There has been much recent interest in using typed intermediate representations in compilers (Peyton Jones et al., 1993; Morrisett, 1995), but in most cases types are abandoned well before code generation. The TIL compiler <ref> (Tarditi et al., 1996) </ref> does keep type information until a late stage in the compilation process when code has reached a low level form more primitive than 3GL code, but its type system is substantially more complex than the C or Ada-style typing we use. <p> Analysis of benchmarks run on the Til compiler <ref> (Tarditi et al., 1996) </ref> indicates that the compiler removes essentially all polymorphism as the result of aggressive function inlining, thus offering independent evidence that specialization need not lead to excessive code explosion. <p> SIL adopts a relatively permissive approach to the location of let-bindings: it permits the result of a case to be let-bound, unlike A-normal form (Flanagan et al., 1993), and even permits the result of a let expression to be let-bound, unlike both A-normal form and Til's B-form <ref> (Tarditi, 1996) </ref>.
Reference: <author> Tofte, M., Birkedal, L., Elsman, M., Hallenberg, N., Olesen, T. H., Sestoft, P., and Ber-telsen, P. </author> <year> (1997). </year> <title> Programming with regions in the ML Kit. </title> <type> Technical Report DIKU-TR-97/12, </type> <institution> University of Copenhagen Department of Computer Science (DIKU). </institution> <note> From ML to Ada 47 Tofte, </note> <author> M. and Talpin, J.-P. </author> <year> (1997). </year> <title> Region-based memory management. </title> <journal> Information and Computation, </journal> <volume> 132(2) </volume> <pages> 109-176. </pages>
Reference-contexts: It produces essentially the same analysis as the constraint-based approach described by Bondorf and Jtrgensen (1993) and further analyzed by Palsberg (1995). Koch and Olesen (1996) have implemented a closure analysis for the ML Kit compiler based on (potentially polymorphic) region annotations <ref> (Tofte and Talpin, 1997) </ref>; functions allocated to the same region are placed in the same closure-analysis equivalence class.
Reference: <author> Tolmach, A. </author> <year> (1997). </year> <title> Combining closure conversion with closure analysis using algebraic types. </title> <booktitle> In Workshop on Types in Compilation TIC97. </booktitle> <institution> Boston College Computer Science Technical Report BCCS-97-03. </institution>
Reference-contexts: Our algorithm also depends on having the full source program available; this restriction can be lifted if we permit extensible datatype declarations, i.e., datatypes for which the data constructor declarations can be scattered throughout the program, even in separate compilation units <ref> (Tolmach, 1997) </ref>.
Reference: <author> Volpano, D. and Kieburtz, R. B. </author> <year> (1985). </year> <title> Software templates. </title> <booktitle> In Proceedings of the Eighth International Conference on Software Engineering, </booktitle> <pages> pages 55-60. </pages> <publisher> IEEE Computer Society. </publisher>
Reference: <author> Volpano, D. and Kieburtz, R. B. </author> <year> (1989). </year> <title> The templates approach to software reuse. </title> <editor> In Biggersstaff, T. J. and Perlis, A. J., editors, </editor> <booktitle> Software Reusability, </booktitle> <pages> pages 247-255. </pages> <publisher> ACM Press. </publisher>
Reference: <author> Wadler, P. </author> <year> (1989). </year> <booktitle> Theorems for free! In Proceedings 4th Int. Conf. on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 347-359. </pages>
Reference-contexts: However, we 22 A. Tolmach and D. Oliva have not found code explosion to be a serious problem in practice, as most polymorphic functions tend to be small; this is probably because the more polymorphic a function is, the fewer useful things it can do <ref> (Wadler, 1989) </ref>! The idea of removing parametric polymorphism by specialization has received much informal discussion, and a small experiment has been attempted for Gofer (Jones, 1993), but we are not aware of any previous practical compiler based on this approach.
Reference: <author> Warren, D. </author> <year> (1982). </year> <title> Higher-order extensions to PROLOG: are they needed? In Hayes, </title> <editor> J., Michie, D., and Pao, Y.-H., editors, </editor> <booktitle> Machine Intelligence 10, </booktitle> <pages> pages 441-454. </pages> <publisher> Edinburgh University Press. </publisher>
Reference: <author> Wright, A. K. </author> <year> (1995). </year> <title> Simple imperative polymorphism. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 8(4) </volume> <pages> 343-356. </pages>
Reference-contexts: Like SML '97, RML adheres to the value restriction on polymorphic bindings <ref> (Wright, 1995) </ref>, requires recursive bindings to be explicit function abstractions, and prohibits polymorphic recursion among functions. Unlike SML '97, RML also prohibits polymorphic recursion in datatype definitions. 3 Also, unlike SML, RML lacks records or tuples per se, but these can be built as datatypes with a single constructor.
References-found: 53

