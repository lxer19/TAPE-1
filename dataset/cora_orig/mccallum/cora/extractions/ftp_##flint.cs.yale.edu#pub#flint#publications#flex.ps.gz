URL: ftp://flint.cs.yale.edu/pub/flint/publications/flex.ps.gz
Refering-URL: http://daffy.cs.yale.edu/users/shao-zhong/papers.html
Root-URL: http://www.cs.yale.edu
Email: shao-zhong@cs.yale.edu  
Title: Flexible Representation Analysis  
Author: Zhong Shao 
Address: New Haven, CT 06520-8285  
Affiliation: Dept. of Computer Science Yale University  
Abstract: This paper presents a new flexible representation analysis technique that combines the best of both approaches. Our new scheme supports unboxed representations for recursive and mutable types, yet it only requires little runtime type analysis. In fact, we show that there is a continuum of possibilities between the coercion-based approach and the type-passing approach. By varying the amount of boxing and the type information passed at runtime, a compiler can freely explore any point in the continuum|choosing from a wide range of representation strategies based on practical concerns. Finally, our new scheme also easily extends to handle type abstractions across ML-like higher-order modules. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: form) Given a constructor definition for Wrap in TGT, we say it is in the valid canonical boxed form if it commutes with substitution and the following constructor equivalence rules can be derived in TGT: Wrap [] Wrap [Wrap []] Wrap [fi ( 1 ; 2 )] Wrap [fi (Wrap <ref> [ 1 ] </ref>; Wrap [ 2 ])] Wrap [! ( 1 ; 2 )] Wrap [! (Wrap [ 1 ]; Wrap [ 2 ])] More generally, if SRC contains more coercible constructors such as with arity k (k &gt; 0), and 0 is its counterpart in IL and TGT, then Wrap <p> boxed form if it commutes with substitution and the following constructor equivalence rules can be derived in TGT: Wrap [] Wrap [Wrap []] Wrap [fi ( 1 ; 2 )] Wrap [fi (Wrap <ref> [ 1 ] </ref>; Wrap [ 2 ])] Wrap [! ( 1 ; 2 )] Wrap [! (Wrap [ 1 ]; Wrap [ 2 ])] More generally, if SRC contains more coercible constructors such as with arity k (k &gt; 0), and 0 is its counterpart in IL and TGT, then Wrap [ 0 ( 1 ; : : : ; k )] must be equivalent to Wrap [ <p> Wrap [ 2 ])] More generally, if SRC contains more coercible constructors such as with arity k (k &gt; 0), and 0 is its counterpart in IL and TGT, then Wrap [ 0 ( 1 ; : : : ; k )] must be equivalent to Wrap [ 0 (Wrap <ref> [ 1 ] </ref>; : : : ; Wrap [ k ])]. Proposition 3.3 If Wrap is in the valid canonical boxed form, then both u and u commute with substitution. <p> boxing is defined as follows (here we use the pattern-match clauses to express the Typerec form): Wrap [] = Boxed (Uncv []) Uncv [Int] = Int Uncv [Real] = Real Uncv [Pack ()] = Pack () Uncv [Boxed ()] = Uncv [fi ( 1 ; 2 )] = fi (Uncv <ref> [ 1 ] </ref>; Uncv [ 2 ]) Uncv [! ( 1 ; 2 )] = ! (Uncv [ 1 ]; Uncv [ 2 ]) Definition 3.8 (partial boxing) The constructor Wrap for partial boxing is defined in the same way as simple boxing, except that the rule for Uncv [! ( <p> [] = Boxed (Uncv []) Uncv [Int] = Int Uncv [Real] = Real Uncv [Pack ()] = Pack () Uncv [Boxed ()] = Uncv [fi ( 1 ; 2 )] = fi (Uncv <ref> [ 1 ] </ref>; Uncv [ 2 ]) Uncv [! ( 1 ; 2 )] = ! (Uncv [ 1 ]; Uncv [ 2 ]) Definition 3.8 (partial boxing) The constructor Wrap for partial boxing is defined in the same way as simple boxing, except that the rule for Uncv [! ( 1 ; 2 )] is replaced by the following: Uncv [! ( 1 ; 2 )] =! <p> Uncv [ 2 ]) Definition 3.8 (partial boxing) The constructor Wrap for partial boxing is defined in the same way as simple boxing, except that the rule for Uncv [! ( 1 ; 2 )] is replaced by the following: Uncv [! ( 1 ; 2 )] =! (Boxed (Uncv <ref> [ 1 ] </ref>); Boxed (Uncv [ 2 ])) Definition 3.9 (full boxing) The constructor Wrap for full boxing is defined in the same way as partial boxing, except that the rule for Uncv [fi ( 1 ; 2 )] is replaced by the following: Uncv [fi ( 1 ; 2 )] <p> [ 2 ])) Definition 3.9 (full boxing) The constructor Wrap for full boxing is defined in the same way as partial boxing, except that the rule for Uncv [fi ( 1 ; 2 )] is replaced by the following: Uncv [fi ( 1 ; 2 )] = fi (Boxed (Uncv <ref> [ 1 ] </ref>); Boxed (Uncv [ 2 ])) Proposition 3.10 The simple-boxing constructor Wrap is in the valid canonical boxed form. <p> Second, we prove Wrap [] Wrap [Wrap []]. From the definition of Uncv, we have Uncv [Boxed ()] for any , therefore: Wrap [Wrap []] Boxed (Uncv [Boxed (Uncv [])]) Boxed (Uncv []) Wrap []. To prove Wrap [fi ( 1 ; 2 )] Wrap [fi (Wrap <ref> [ 1 ] </ref>; Wrap [ 2 ])], we notice that Uncv [Wrap []] Uncv [Boxed (Uncv [])] Uncv [] holds for any constructor , thus Wrap [fi (Wrap [ 1 ]; Wrap [ 2 ])] Boxed (Uncv [fi (Wrap [ 1 ]; Wrap [ 2 ])]) Boxed (fi (Uncv [Wrap [ <p> To prove Wrap [fi ( 1 ; 2 )] Wrap [fi (Wrap <ref> [ 1 ] </ref>; Wrap [ 2 ])], we notice that Uncv [Wrap []] Uncv [Boxed (Uncv [])] Uncv [] holds for any constructor , thus Wrap [fi (Wrap [ 1 ]; Wrap [ 2 ])] Boxed (Uncv [fi (Wrap [ 1 ]; Wrap [ 2 ])]) Boxed (fi (Uncv [Wrap [ 1 ]]; Uncv [Wrap [ 2 ]])) Boxed (fi (Uncv [ 1 ]; Uncv [ 2 ])) Boxed (Uncv [fi ( 1 ; 2 )]) Wrap [fi ( <p> prove Wrap [fi ( 1 ; 2 )] Wrap [fi (Wrap <ref> [ 1 ] </ref>; Wrap [ 2 ])], we notice that Uncv [Wrap []] Uncv [Boxed (Uncv [])] Uncv [] holds for any constructor , thus Wrap [fi (Wrap [ 1 ]; Wrap [ 2 ])] Boxed (Uncv [fi (Wrap [ 1 ]; Wrap [ 2 ])]) Boxed (fi (Uncv [Wrap [ 1 ]]; Uncv [Wrap [ 2 ]])) Boxed (fi (Uncv [ 1 ]; Uncv [ 2 ])) Boxed (Uncv [fi ( 1 ; 2 )]) Wrap [fi ( 1 ; 2 )]. <p> <ref> [ 1 ] </ref>; Wrap [ 2 ])], we notice that Uncv [Wrap []] Uncv [Boxed (Uncv [])] Uncv [] holds for any constructor , thus Wrap [fi (Wrap [ 1 ]; Wrap [ 2 ])] Boxed (Uncv [fi (Wrap [ 1 ]; Wrap [ 2 ])]) Boxed (fi (Uncv [Wrap [ 1 ]]; Uncv [Wrap [ 2 ]])) Boxed (fi (Uncv [ 1 ]; Uncv [ 2 ])) Boxed (Uncv [fi ( 1 ; 2 )]) Wrap [fi ( 1 ; 2 )]. Finally, Wrap [! ( 1 ; 2 )] Wrap [! (Wrap [ 1 ]; Wrap [ 2 ])] <p> [Wrap []] Uncv [Boxed (Uncv [])] Uncv [] holds for any constructor , thus Wrap [fi (Wrap <ref> [ 1 ] </ref>; Wrap [ 2 ])] Boxed (Uncv [fi (Wrap [ 1 ]; Wrap [ 2 ])]) Boxed (fi (Uncv [Wrap [ 1 ]]; Uncv [Wrap [ 2 ]])) Boxed (fi (Uncv [ 1 ]; Uncv [ 2 ])) Boxed (Uncv [fi ( 1 ; 2 )]) Wrap [fi ( 1 ; 2 )]. Finally, Wrap [! ( 1 ; 2 )] Wrap [! (Wrap [ 1 ]; Wrap [ 2 ])] can be proved in the same way. QED. <p> 2 ])]) Boxed (fi (Uncv [Wrap <ref> [ 1 ] </ref>]; Uncv [Wrap [ 2 ]])) Boxed (fi (Uncv [ 1 ]; Uncv [ 2 ])) Boxed (Uncv [fi ( 1 ; 2 )]) Wrap [fi ( 1 ; 2 )]. Finally, Wrap [! ( 1 ; 2 )] Wrap [! (Wrap [ 1 ]; Wrap [ 2 ])] can be proved in the same way. QED. Proposition 3.11 The partial-boxing constructor Wrap is in the valid canonical boxed form. Proposition 3.12 The full-boxing constructor Wrap is in the valid canonical boxed form. <p> give the definitions of the coercion primitives (wrap and unwrap) for simple boxing: (1) wrap [] = box [Uncv []] ffi uncv [] (2) unwrap [] = cover [] ffi unbox [Uncv []] (3) uncv [Boxed ()] = unbox [] (4) uncv [fi ( 1 ; 2 )] = uncv <ref> [ 1 ] </ref> fi uncv [ 2 ] (5) uncv [! ( 1 ; 2 )] = cover [ 1 ] ! uncv [ 2 ] (6) uncv [] = identity [] (7) cover [Boxed ()] = box [] (8) cover [fi ( 1 ; 2 )] = cover [ 1 <p> [Uncv []] ffi uncv [] (2) unwrap [] = cover [] ffi unbox [Uncv []] (3) uncv [Boxed ()] = unbox [] (4) uncv [fi ( 1 ; 2 )] = uncv <ref> [ 1 ] </ref> fi uncv [ 2 ] (5) uncv [! ( 1 ; 2 )] = cover [ 1 ] ! uncv [ 2 ] (6) uncv [] = identity [] (7) cover [Boxed ()] = box [] (8) cover [fi ( 1 ; 2 )] = cover [ 1 ] fi cover [ 2 ] (9) cover [! ( 1 ; 2 )] = uncv [ 1 <p> uncv <ref> [ 1 ] </ref> fi uncv [ 2 ] (5) uncv [! ( 1 ; 2 )] = cover [ 1 ] ! uncv [ 2 ] (6) uncv [] = identity [] (7) cover [Boxed ()] = box [] (8) cover [fi ( 1 ; 2 )] = cover [ 1 ] fi cover [ 2 ] (9) cover [! ( 1 ; 2 )] = uncv [ 1 ] ! cover [ 2 ] (10) cover [] = identity [] Here, the pattern-match syntax is representing the the term-level typerec form; also, ffi denotes function composition, identity is the <p> cover <ref> [ 1 ] </ref> ! uncv [ 2 ] (6) uncv [] = identity [] (7) cover [Boxed ()] = box [] (8) cover [fi ( 1 ; 2 )] = cover [ 1 ] fi cover [ 2 ] (9) cover [! ( 1 ; 2 )] = uncv [ 1 ] ! cover [ 2 ] (10) cover [] = identity [] Here, the pattern-match syntax is representing the the term-level typerec form; also, ffi denotes function composition, identity is the polymorphic identity function, and product and function spaces are extended to functions in the usual way. <p> The coercion primitives for partial boxing and full boxing can be defined in the same way. For example, the definition for partial boxing can be obtained by replacing rule (5) and (9) with the following: (5') uncv [! ( 1 ; 2 )] = (cover <ref> [ 1 ] </ref> ffi unbox [Uncv [ 1 ]]) ! (box [Uncv [ 2 ]] ffi uncv [ 2 ]) (9') cover [! ( 1 ; 2 )] = (box [Uncv [ 1 ]] ffi uncv [ 1 ]) ! (cover [ 2 ] ffi unbox [Uncv [ 2 ]]) Notice <p> For example, the definition for partial boxing can be obtained by replacing rule (5) and (9) with the following: (5') uncv [! ( 1 ; 2 )] = (cover <ref> [ 1 ] </ref> ffi unbox [Uncv [ 1 ]]) ! (box [Uncv [ 2 ]] ffi uncv [ 2 ]) (9') cover [! ( 1 ; 2 )] = (box [Uncv [ 1 ]] ffi uncv [ 1 ]) ! (cover [ 2 ] ffi unbox [Uncv [ 2 ]]) Notice under partial boxing, the uncv and <p> by replacing rule (5) and (9) with the following: (5') uncv [! ( 1 ; 2 )] = (cover <ref> [ 1 ] </ref> ffi unbox [Uncv [ 1 ]]) ! (box [Uncv [ 2 ]] ffi uncv [ 2 ]) (9') cover [! ( 1 ; 2 )] = (box [Uncv [ 1 ]] ffi uncv [ 1 ]) ! (cover [ 2 ] ffi unbox [Uncv [ 2 ]]) Notice under partial boxing, the uncv and cover primitives are equivalent to the identity function on constructors such as ! (Boxed ( 1 ); Boxed ( 2 )). 4 Extensions In this <p> (9) with the following: (5') uncv [! ( 1 ; 2 )] = (cover <ref> [ 1 ] </ref> ffi unbox [Uncv [ 1 ]]) ! (box [Uncv [ 2 ]] ffi uncv [ 2 ]) (9') cover [! ( 1 ; 2 )] = (box [Uncv [ 1 ]] ffi uncv [ 1 ]) ! (cover [ 2 ] ffi unbox [Uncv [ 2 ]]) Notice under partial boxing, the uncv and cover primitives are equivalent to the identity function on constructors such as ! (Boxed ( 1 ); Boxed ( 2 )). 4 Extensions In this section, we present several extensions <p> The only operations that require runtime type analysis are the coercion primitives (i.e., wrap and unwrap), the array primitives, and several conrep primitives (used to determine representations for concrete datatypes, with similar spirits to Appel <ref> [1, section 4.1] </ref>). We compare the new technique with Leroy's standard coercion-based approach. Here, Old is the type-based compiler described in Shao and Appel [33, 29]); New is the new compiler that implements the flexible representation analysis described in this paper.
Reference: [2] <author> A. W. Appel. </author> <title> A critque of Standard ML. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(4) </volume> <pages> 391-429, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: for IL, kinds (), constructors (), types (), and terms (e), are defined as follows: (kinds) ::= j 1 ! 2 (con's) ::= t j Int j Real j Pack () j! ( 1 ; 2 ) j fi ( 1 ; 2 ) j t :: : j 1 <ref> [ 2 ] </ref> (types) ::= T () j 1 ! 2 j 1 fi 2 j 8t :: : (terms) e ::= x j i j f j Pk j Upk j he 1 ; e 2 i j 1 e j 2 e j x : :e j @e 1 <p> definition for Wrap in TGT, we say it is in the valid canonical boxed form if it commutes with substitution and the following constructor equivalence rules can be derived in TGT: Wrap [] Wrap [Wrap []] Wrap [fi ( 1 ; 2 )] Wrap [fi (Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>)] Wrap [! ( 1 ; 2 )] Wrap [! (Wrap [ 1 ]; Wrap [ 2 ])] More generally, if SRC contains more coercible constructors such as with arity k (k &gt; 0), and 0 is its counterpart in IL and TGT, then Wrap [ 0 ( 1 <p> commutes with substitution and the following constructor equivalence rules can be derived in TGT: Wrap [] Wrap [Wrap []] Wrap [fi ( 1 ; 2 )] Wrap [fi (Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>)] Wrap [! ( 1 ; 2 )] Wrap [! (Wrap [ 1 ]; Wrap [ 2 ])] More generally, if SRC contains more coercible constructors such as with arity k (k &gt; 0), and 0 is its counterpart in IL and TGT, then Wrap [ 0 ( 1 ; : : : ; k )] must be equivalent to Wrap [ 0 (Wrap [ 1 <p> follows (here we use the pattern-match clauses to express the Typerec form): Wrap [] = Boxed (Uncv []) Uncv [Int] = Int Uncv [Real] = Real Uncv [Pack ()] = Pack () Uncv [Boxed ()] = Uncv [fi ( 1 ; 2 )] = fi (Uncv [ 1 ]; Uncv <ref> [ 2 ] </ref>) Uncv [! ( 1 ; 2 )] = ! (Uncv [ 1 ]; Uncv [ 2 ]) Definition 3.8 (partial boxing) The constructor Wrap for partial boxing is defined in the same way as simple boxing, except that the rule for Uncv [! ( 1 ; 2 )] <p> []) Uncv [Int] = Int Uncv [Real] = Real Uncv [Pack ()] = Pack () Uncv [Boxed ()] = Uncv [fi ( 1 ; 2 )] = fi (Uncv [ 1 ]; Uncv <ref> [ 2 ] </ref>) Uncv [! ( 1 ; 2 )] = ! (Uncv [ 1 ]; Uncv [ 2 ]) Definition 3.8 (partial boxing) The constructor Wrap for partial boxing is defined in the same way as simple boxing, except that the rule for Uncv [! ( 1 ; 2 )] is replaced by the following: Uncv [! ( 1 ; 2 )] =! (Boxed (Uncv [ 1 <p> 3.8 (partial boxing) The constructor Wrap for partial boxing is defined in the same way as simple boxing, except that the rule for Uncv [! ( 1 ; 2 )] is replaced by the following: Uncv [! ( 1 ; 2 )] =! (Boxed (Uncv [ 1 ]); Boxed (Uncv <ref> [ 2 ] </ref>)) Definition 3.9 (full boxing) The constructor Wrap for full boxing is defined in the same way as partial boxing, except that the rule for Uncv [fi ( 1 ; 2 )] is replaced by the following: Uncv [fi ( 1 ; 2 )] = fi (Boxed (Uncv [ <p> (full boxing) The constructor Wrap for full boxing is defined in the same way as partial boxing, except that the rule for Uncv [fi ( 1 ; 2 )] is replaced by the following: Uncv [fi ( 1 ; 2 )] = fi (Boxed (Uncv [ 1 ]); Boxed (Uncv <ref> [ 2 ] </ref>)) Proposition 3.10 The simple-boxing constructor Wrap is in the valid canonical boxed form. <p> From the definition of Uncv, we have Uncv [Boxed ()] for any , therefore: Wrap [Wrap []] Boxed (Uncv [Boxed (Uncv [])]) Boxed (Uncv []) Wrap []. To prove Wrap [fi ( 1 ; 2 )] Wrap [fi (Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>)], we notice that Uncv [Wrap []] Uncv [Boxed (Uncv [])] Uncv [] holds for any constructor , thus Wrap [fi (Wrap [ 1 ]; Wrap [ 2 ])] Boxed (Uncv [fi (Wrap [ 1 ]; Wrap [ 2 ])]) Boxed (fi (Uncv [Wrap [ 1 ]]; Uncv [Wrap <p> To prove Wrap [fi ( 1 ; 2 )] Wrap [fi (Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>)], we notice that Uncv [Wrap []] Uncv [Boxed (Uncv [])] Uncv [] holds for any constructor , thus Wrap [fi (Wrap [ 1 ]; Wrap [ 2 ])] Boxed (Uncv [fi (Wrap [ 1 ]; Wrap [ 2 ])]) Boxed (fi (Uncv [Wrap [ 1 ]]; Uncv [Wrap [ 2 ]])) Boxed (fi (Uncv [ 1 ]; Uncv [ 2 ])) Boxed (Uncv [fi ( 1 ; 2 )]) Wrap [fi ( 1 ; 2 )]. <p> 1 ; 2 )] Wrap [fi (Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>)], we notice that Uncv [Wrap []] Uncv [Boxed (Uncv [])] Uncv [] holds for any constructor , thus Wrap [fi (Wrap [ 1 ]; Wrap [ 2 ])] Boxed (Uncv [fi (Wrap [ 1 ]; Wrap [ 2 ])]) Boxed (fi (Uncv [Wrap [ 1 ]]; Uncv [Wrap [ 2 ]])) Boxed (fi (Uncv [ 1 ]; Uncv [ 2 ])) Boxed (Uncv [fi ( 1 ; 2 )]) Wrap [fi ( 1 ; 2 )]. <p> 2 ])], we notice that Uncv [Wrap []] Uncv [Boxed (Uncv [])] Uncv [] holds for any constructor , thus Wrap [fi (Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>)] Boxed (Uncv [fi (Wrap [ 1 ]; Wrap [ 2 ])]) Boxed (fi (Uncv [Wrap [ 1 ]]; Uncv [Wrap [ 2 ]])) Boxed (fi (Uncv [ 1 ]; Uncv [ 2 ])) Boxed (Uncv [fi ( 1 ; 2 )]) Wrap [fi ( 1 ; 2 )]. Finally, Wrap [! ( 1 ; 2 )] Wrap [! (Wrap [ 1 ]; Wrap [ 2 ])] can be proved in the <p> (Uncv [])] Uncv [] holds for any constructor , thus Wrap [fi (Wrap [ 1 ]; Wrap <ref> [ 2 ] </ref>)] Boxed (Uncv [fi (Wrap [ 1 ]; Wrap [ 2 ])]) Boxed (fi (Uncv [Wrap [ 1 ]]; Uncv [Wrap [ 2 ]])) Boxed (fi (Uncv [ 1 ]; Uncv [ 2 ])) Boxed (Uncv [fi ( 1 ; 2 )]) Wrap [fi ( 1 ; 2 )]. Finally, Wrap [! ( 1 ; 2 )] Wrap [! (Wrap [ 1 ]; Wrap [ 2 ])] can be proved in the same way. QED. <p> (Uncv [Wrap [ 1 ]]; Uncv [Wrap <ref> [ 2 ] </ref>])) Boxed (fi (Uncv [ 1 ]; Uncv [ 2 ])) Boxed (Uncv [fi ( 1 ; 2 )]) Wrap [fi ( 1 ; 2 )]. Finally, Wrap [! ( 1 ; 2 )] Wrap [! (Wrap [ 1 ]; Wrap [ 2 ])] can be proved in the same way. QED. Proposition 3.11 The partial-boxing constructor Wrap is in the valid canonical boxed form. Proposition 3.12 The full-boxing constructor Wrap is in the valid canonical boxed form. <p> coercion primitives (wrap and unwrap) for simple boxing: (1) wrap [] = box [Uncv []] ffi uncv [] (2) unwrap [] = cover [] ffi unbox [Uncv []] (3) uncv [Boxed ()] = unbox [] (4) uncv [fi ( 1 ; 2 )] = uncv [ 1 ] fi uncv <ref> [ 2 ] </ref> (5) uncv [! ( 1 ; 2 )] = cover [ 1 ] ! uncv [ 2 ] (6) uncv [] = identity [] (7) cover [Boxed ()] = box [] (8) cover [fi ( 1 ; 2 )] = cover [ 1 ] fi cover [ 2 <p> (2) unwrap [] = cover [] ffi unbox [Uncv []] (3) uncv [Boxed ()] = unbox [] (4) uncv [fi ( 1 ; 2 )] = uncv [ 1 ] fi uncv <ref> [ 2 ] </ref> (5) uncv [! ( 1 ; 2 )] = cover [ 1 ] ! uncv [ 2 ] (6) uncv [] = identity [] (7) cover [Boxed ()] = box [] (8) cover [fi ( 1 ; 2 )] = cover [ 1 ] fi cover [ 2 ] (9) cover [! ( 1 ; 2 )] = uncv [ 1 ] ! cover [ 2 <p> uncv <ref> [ 2 ] </ref> (5) uncv [! ( 1 ; 2 )] = cover [ 1 ] ! uncv [ 2 ] (6) uncv [] = identity [] (7) cover [Boxed ()] = box [] (8) cover [fi ( 1 ; 2 )] = cover [ 1 ] fi cover [ 2 ] (9) cover [! ( 1 ; 2 )] = uncv [ 1 ] ! cover [ 2 ] (10) cover [] = identity [] Here, the pattern-match syntax is representing the the term-level typerec form; also, ffi denotes function composition, identity is the polymorphic identity function, and product <p> uncv <ref> [ 2 ] </ref> (6) uncv [] = identity [] (7) cover [Boxed ()] = box [] (8) cover [fi ( 1 ; 2 )] = cover [ 1 ] fi cover [ 2 ] (9) cover [! ( 1 ; 2 )] = uncv [ 1 ] ! cover [ 2 ] (10) cover [] = identity [] Here, the pattern-match syntax is representing the the term-level typerec form; also, ffi denotes function composition, identity is the polymorphic identity function, and product and function spaces are extended to functions in the usual way. <p> For example, the definition for partial boxing can be obtained by replacing rule (5) and (9) with the following: (5') uncv [! ( 1 ; 2 )] = (cover [ 1 ] ffi unbox [Uncv [ 1 ]]) ! (box [Uncv <ref> [ 2 ] </ref>] ffi uncv [ 2 ]) (9') cover [! ( 1 ; 2 )] = (box [Uncv [ 1 ]] ffi uncv [ 1 ]) ! (cover [ 2 ] ffi unbox [Uncv [ 2 ]]) Notice under partial boxing, the uncv and cover primitives are equivalent to the <p> For example, the definition for partial boxing can be obtained by replacing rule (5) and (9) with the following: (5') uncv [! ( 1 ; 2 )] = (cover [ 1 ] ffi unbox [Uncv [ 1 ]]) ! (box [Uncv <ref> [ 2 ] </ref>] ffi uncv [ 2 ]) (9') cover [! ( 1 ; 2 )] = (box [Uncv [ 1 ]] ffi uncv [ 1 ]) ! (cover [ 2 ] ffi unbox [Uncv [ 2 ]]) Notice under partial boxing, the uncv and cover primitives are equivalent to the identity function on constructors such <p> uncv [! ( 1 ; 2 )] = (cover [ 1 ] ffi unbox [Uncv [ 1 ]]) ! (box [Uncv <ref> [ 2 ] </ref>] ffi uncv [ 2 ]) (9') cover [! ( 1 ; 2 )] = (box [Uncv [ 1 ]] ffi uncv [ 1 ]) ! (cover [ 2 ] ffi unbox [Uncv [ 2 ]]) Notice under partial boxing, the uncv and cover primitives are equivalent to the identity function on constructors such as ! (Boxed ( 1 ); Boxed ( 2 )). 4 Extensions In this section, we present several extensions and variations of our flexible <p> )] = (cover [ 1 ] ffi unbox [Uncv [ 1 ]]) ! (box [Uncv <ref> [ 2 ] </ref>] ffi uncv [ 2 ]) (9') cover [! ( 1 ; 2 )] = (box [Uncv [ 1 ]] ffi uncv [ 1 ]) ! (cover [ 2 ] ffi unbox [Uncv [ 2 ]]) Notice under partial boxing, the uncv and cover primitives are equivalent to the identity function on constructors such as ! (Boxed ( 1 ); Boxed ( 2 )). 4 Extensions In this section, we present several extensions and variations of our flexible representation analysis algorithm. 4.1 Modules and <p> f would first be wrapped into canonical boxed form; later, after the functor application is done, the r field in the result must be unwrapped back to unboxed form. 4.2 Concrete vs. abstract datatypes Consistent datatype representations across functor boundary has long been a tricky problem for ML compiler writers <ref> [2] </ref>. Flexible representation analysis offers a nice solution. <p> This wrapping ensures that all values carried by the datatype (concrete or abstract) will have consistent data representations (i.e., they are all in the canonical boxed form). The technique described above can also be used to solve the classical list representation problem <ref> [2] </ref>. This problem occurs when we apply the following functor G to structure S: functor G (B : sig type s datatype t = FCONS of s | FNIL end) = struct ... end 11 Most existing compilers represent the cons cell as an un-tagged record with no indirections.
Reference: [3] <author> A. W. Appel and D. B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In M. Wirsing, editor, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: across ML-like higher-order modules [22, 21, 11, 20]. * We show that with a simple twist based on the para metricity property, most runtime type manipulations in our scheme can be eliminated. * We have implemented our scheme (with partially boxed representations) in an experimental version of the SML/NJ compiler <ref> [3, 33] </ref>. Preliminary measurements show that code involving recursive and mutable types gets significant speedup while normal polymor phic code remains almost as efficient as before. In the rest of this paper, we first give an informal presentation of the main idea. <p> The precise relationship between the two is out of the scope of the current paper. 5 Implementation We have implemented the flexible representation analysis technique outlined above in an experimental version of the Standard ML of New Jersey compiler (v109.25m) <ref> [3, 33, 31] </ref>. To simplify the implementation, we avoid the vararg problem by using partial boxing as the canonical boxed form. We used the standard technique of minimal typing derivations [33, 6] to eliminate local and unnecessary polymor-phisms.
Reference: [4] <author> J. Auslander, M. Philipose, C. Chambers, S. Eggers, and B. Bershad. </author> <title> Fast, effective dynamic compilation. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 149-159. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: Actually, modern compilers often use even more elaborate calling conventions [5, 17]|making the above simulation virtually impossible. Of course, one could always resort to runtime code generation <ref> [18, 4, 9] </ref> or simply use a very restricted set of calling conventions [24], but then, either the cost is too expensive or the interoperability suffers. This paper presents a new flexible representation analysis technique that combines the best of both the coercion-based and the type-passing approaches.
Reference: [5] <author> M. W. Bailey and J. W. Davidson. </author> <title> A formal model of procedure calling convention. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 298-310, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: For machines with k argument registers (including FP registers), this would require 2 k cases (e.g., entrant code, coercions) to deal with all the possible calling conventions [24]. Actually, modern compilers often use even more elaborate calling conventions <ref> [5, 17] </ref>|making the above simulation virtually impossible. Of course, one could always resort to runtime code generation [18, 4, 9] or simply use a very restricted set of calling conventions [24], but then, either the cost is too expensive or the interoperability suffers.
Reference: [6] <author> N. S. </author> <title> Bjorner. Minimal typing derivations. </title> <booktitle> In ACM SIG-PLAN Workshop on ML and its Applications, </booktitle> <pages> pages 120-126, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: To simplify the implementation, we avoid the vararg problem by using partial boxing as the canonical boxed form. We used the standard technique of minimal typing derivations <ref> [33, 6] </ref> to eliminate local and unnecessary polymor-phisms. We did not exploit the parametricity property (discussed in Section 4.3) in the current implementation. <p> Henglein and Jorgensen [15] present a term-rewriting method that translates a program with many coercions into one that contains a "formally optimal" set of coercions. Shao and Appel [33] extended Leroy's scheme to the entire SML module language and also used minimum typing derivations <ref> [6] </ref> to decrease the degree of polymorphism thus eliminate coercions. All these techniques still apply to our flexible approaches because the top-level S and G transformations in our scheme are almost identical to Leroy's original ones.
Reference: [7] <author> D. Clement, J. Despeyroux, T. Despeyroux, and G. Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In 1986 ACM Conference on Lisp and Functional Programming, </booktitle> <address> New York, June 1986. </address> <publisher> ACM Press. </publisher>
Reference-contexts: type correctness and the semantic correctness of our translation, and then give a set of axioms that characterize the valid canonical boxing schemes; finally, we formally define simple boxing and partial boxing, and show why they all satisfy these axioms. 3.1 Source language: SRC We use a variant of Mini-ML <ref> [7] </ref> as our source language (SRC). <p> Values (v) are a subset of terms and include identifiers, constants, pair of values, abstractions, and packed values. The static and dynamic semantics for SRC are all standard and same as those for Mini-ML (see <ref> [7, 14, 24] </ref>). The type inference rule (given later as part of the translation from SRC to IL in Figure 6) is in the form of 4; ` e : t where 4 is a set of free type variables, and is a type environment mapping identifiers to polytypes.
Reference: [8] <author> L. Damas and R. Milner. </author> <title> Principal type-schemes for functional programs. </title> <booktitle> In Ninth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 207-212, </pages> <address> New York, Jan 1982. </address> <publisher> ACM Press. </publisher>
Reference-contexts: 1 Introduction Statically typed languages with Hindley-Milner polymor-phism <ref> [8] </ref> have long been compiled using inefficient and fully boxed data representations. Under these implementations, all program variables, function closures, function parameters, and record fields are uniformly represented in exactly one word. <p> Representation analysis is then expressed as a type-directed program transformation that automatically inserts coercions and translates IL programs into the target implementation calculus (TGT|also known as ML i [14]). The benefit of doing it this way is to show that our analysis works not only on the ML-like polymorphism <ref> [8] </ref> but on the more general higher-order polymorphism as well.
Reference: [9] <author> D. R. Engler. </author> <title> VCODE: A retargetable, extensible, very fast dynamic code generation system. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 160-170. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: Actually, modern compilers often use even more elaborate calling conventions [5, 17]|making the above simulation virtually impossible. Of course, one could always resort to runtime code generation <ref> [18, 4, 9] </ref> or simply use a very restricted set of calling conventions [24], but then, either the cost is too expensive or the interoperability suffers. This paper presents a new flexible representation analysis technique that combines the best of both the coercion-based and the type-passing approaches.
Reference: [10] <author> J. Y. Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieur. </title> <type> PhD thesis, </type> <institution> University of Paris VII, </institution> <year> 1972. </year>
Reference-contexts: and a set of axioms that precisely characterize this trade-off. * By choosing partially boxed representations (e.g., Fig ure 1d) as the canonical boxed form, our scheme can completely eliminate the nasty vararg problem. * We extend Leroy's representation analysis to a predica-tive variant of the polymorphic -calculus F ! <ref> [10, 28] </ref>. <p> Instead of performing the analysis directly on the ML source language (SRC), we use a predicative variant of the polymorphic - calculus F ! <ref> [10, 28, 14] </ref> as the intermediate language (IL). Representation analysis is then expressed as a type-directed program transformation that automatically inserts coercions and translates IL programs into the target implementation calculus (TGT|also known as ML i [14]). <p> To simplify the presentation, we use pack to serve as a representative for incoercible tycons; however, all techniques described here easily carry to other incoercible tycons. 3.2 Intermediate language: IL We use a predicative variant [12, 14] of the polymorphic - calculus F ! <ref> [10, 28] </ref> as our intermediate language.
Reference: [11] <author> R. Harper and M. Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Twenty-first Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 123-137, </pages> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: We show that our technique works for both the ML style polymorphism and the F ! -like higher-order poly morphism. * We show how easily our scheme can be extended to handle type abstractions across ML-like higher-order modules <ref> [22, 21, 11, 20] </ref>. * We show that with a simple twist based on the para metricity property, most runtime type manipulations in our scheme can be eliminated. * We have implemented our scheme (with partially boxed representations) in an experimental version of the SML/NJ compiler [3, 33].
Reference: [12] <author> R. Harper and J. C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: To simplify the presentation, we use pack to serve as a representative for incoercible tycons; however, all techniques described here easily carry to other incoercible tycons. 3.2 Intermediate language: IL We use a predicative variant <ref> [12, 14] </ref> of the polymorphic - calculus F ! [10, 28] as our intermediate language. <p> Because IL is very much like Harper and Mitchell's ML <ref> [12] </ref>, we can show in the similar way that type-checking for IL is decidable, and furthermore, its typing rules are consistent with the operation semantics. 3.3 Translation from SRC to IL In Figure 6, we give a type-directed embedding of SRC into IL. <p> This is very similar to the translation from Core-ML to XML, given by Harper and Mitchell <ref> [12] </ref>.
Reference: [13] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <type> Technical Report CMU-CS-94-185, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> September </month> <year> 1994. </year> <month> 13 </month>
Reference-contexts: Morrison, et al. [25] described an implementation of Napier that passed types at runtime to determine the behavior of polymorphic operations. The type-passing approach was later formalized using ML i by Harper and Mor-risett <ref> [14, 13, 24] </ref>; the intensional type analysis framework they proposed is one of the main inspirations for the present work. Very recently, Tarditi and Morrisett, et al. [34, 24] have implemented the type-passing approach in their TIL compiler.
Reference: [14] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 130-141, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Leroy's technique, unfortunately, does not handle recursive datatypes and mutable types well. Coercions on large data structures are impractical because the cost of the copying often outweighs the benefits of unboxed representations <ref> [19, 14] </ref>. More seriously, mutable data structures such as arrays cannot be copied or coerced; if we make a copy of the value to box the components, then updates to the copy will not be reflected in the original array and vice versa. <p> As a result, values such as lists and arrays must still use fully boxed representations, even when they are not inside polymorphic contexts. Harper and Morrisett <ref> [14, 24] </ref> later solved this problem on recursive and mutable types using a type-passing approach. Under their scheme, data objects (including lists and arrays) are kept "unboxed" all the time, even inside polymorphic contexts. Polymorphism is not implemented through coercions, but by using runtime type analysis and code manipulations. <p> The main contributions of this paper are: * Among all the known coercion-based approaches [19, 26, 27, 15, 33, 36], our scheme is the first to successfully solve the open problem on recursive and mutable types. * Unlike the type-passing approaches <ref> [25, 14, 24, 34] </ref>, our 2 S S r r list S S r r * - - - B C 0 - = BN CW . . . . .. . . . . . . . . . . . . . . . . .. . 0 z <p> The "uncover" operation does not have to be done recursively because by invariant, fi is already in the simply boxed form. Uncovering does require the use of runtime type information (the actual type of fi); this is realized in the same way as in the type-passing approach <ref> [14] </ref>. One important insight we get here is that a boxing scheme can serve as a valid canonical boxed form only if it commutes with the type instantiation relations. <p> Instead of performing the analysis directly on the ML source language (SRC), we use a predicative variant of the polymorphic - calculus F ! <ref> [10, 28, 14] </ref> as the intermediate language (IL). Representation analysis is then expressed as a type-directed program transformation that automatically inserts coercions and translates IL programs into the target implementation calculus (TGT|also known as ML i [14]). <p> Representation analysis is then expressed as a type-directed program transformation that automatically inserts coercions and translates IL programs into the target implementation calculus (TGT|also known as ML i <ref> [14] </ref>). The benefit of doing it this way is to show that our analysis works not only on the ML-like polymorphism [8] but on the more general higher-order polymorphism as well. <p> Values (v) are a subset of terms and include identifiers, constants, pair of values, abstractions, and packed values. The static and dynamic semantics for SRC are all standard and same as those for Mini-ML (see <ref> [7, 14, 24] </ref>). The type inference rule (given later as part of the translation from SRC to IL in Figure 6) is in the form of 4; ` e : t where 4 is a set of free type variables, and is a type environment mapping identifiers to polytypes. <p> To simplify the presentation, we use pack to serve as a representative for incoercible tycons; however, all techniques described here easily carry to other incoercible tycons. 3.2 Intermediate language: IL We use a predicative variant <ref> [12, 14] </ref> of the polymorphic - calculus F ! [10, 28] as our intermediate language. <p> The application and abstraction constructors correspond to the function kind 1 ! 2 . Types in IL include the monotypes, and are closed under products, function spaces, and polymorphic quantification. Like Harper and Morrisett <ref> [14] </ref>, we use T () to denote the type corresponding to the constructor . The terms are an explicitly typed -calculus with explicit constructor abstraction and application forms. <p> The term formation rules are in the form of 4; ` e : where 4 is a kind environment mapping type variables to kinds, and is the type environment. Apart from the standard language constructs <ref> [14] </ref>, the packing primitives have the following types: Pk : 8t :: :T (t) ! T (Pack (t)) Upk : 8t :: :T (Pack (t)) ! T (t) The natural (call-by-value) dynamic semantics for IL, also given in Figure 5, is defined as a set of axioms in the form of <p> : : : ; flt n :: :e 0 A semantic correctness theorem about this embedding can also be stated and proved using the standard logical-relations technique [24, 19]. 3.4 Target language: TGT The target language (TGT) for our representation analysis is very similar to Harper and Morrisett's ML i <ref> [14] </ref>. In fact, because our IL is much like ML , TGT is essentially the previously defined IL plus Harper and Morrisett's typerec forms [14]. <p> standard logical-relations technique [24, 19]. 3.4 Target language: TGT The target language (TGT) for our representation analysis is very similar to Harper and Morrisett's ML i <ref> [14] </ref>. In fact, because our IL is much like ML , TGT is essentially the previously defined IL plus Harper and Morrisett's typerec forms [14]. The four syntactic classes for TGT, kinds (), constructors (), types (), and terms (e), are defined as follows: (kinds) ::= ... same as in IL ... (con's) ::= ... <p> IL values ... j box j unbox j BX (v) Here, the Typerec and typerec forms are the keys for intensional type analysis <ref> [14] </ref>. They provide the ability to define new constructors and terms by structural induction on monotypes. <p> The static semantics for TGT is almost identical to those for IL in details); the additional rules for Typerec and typerec are same as those in Harper and Morrisett <ref> [14] </ref>. The operational semantics for TGT, written as e ,! t v, is similar to those for IL also. Harper and Morrisett [14, 24] have shown that type checking for ML i is decidable, and furthermore, its typing rules are consistent with the operation semantics. <p> The operational semantics for TGT, written as e ,! t v, is similar to those for IL also. Harper and Morrisett <ref> [14, 24] </ref> have shown that type checking for ML i is decidable, and furthermore, its typing rules are consistent with the operation semantics. <p> Wrap [] = Boxed (Uncv []), and both Boxed and Uncv commute with substitutions; Boxed is a primitive constructor, and Uncv is a simple Typerec-form constructor (which can be shown to commute with substitutions using structural inductions, following from the constructor equivalence rules on Typerec defined in Harper and Morrisett <ref> [14, 24] </ref>). Second, we prove Wrap [] Wrap [Wrap []]. From the definition of Uncv, we have Uncv [Boxed ()] for any , therefore: Wrap [Wrap []] Boxed (Uncv [Boxed (Uncv [])]) Boxed (Uncv []) Wrap []. <p> Previous coercion-based approaches [19, 26, 27, 15, 33, 36] do not take advantage of runtime type information, so they can only use full boxing as its canonical boxed form. On the other hand, previous type-passing approaches <ref> [25, 14, 24, 34] </ref> do not box polymorphic objects, so they require extensive runtime type analysis and code manipulations. Most previous work on coercion-based approaches concentrate on how to use compile-time analysis to eliminate unnecessary coercions. <p> Morrison, et al. [25] described an implementation of Napier that passed types at runtime to determine the behavior of polymorphic operations. The type-passing approach was later formalized using ML i by Harper and Mor-risett <ref> [14, 13, 24] </ref>; the intensional type analysis framework they proposed is one of the main inspirations for the present work. Very recently, Tarditi and Morrisett, et al. [34, 24] have implemented the type-passing approach in their TIL compiler.
Reference: [15] <author> F. Henglein and J. Jorgensen. </author> <title> Formally optimal boxing. </title> <booktitle> In Proc. 21st Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 213-226. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: For example, using the partially boxed representation shown in Figure 1d, we can completely eliminate the vararg problem in the type-passing approach (see later sections for more details). The main contributions of this paper are: * Among all the known coercion-based approaches <ref> [19, 26, 27, 15, 33, 36] </ref>, our scheme is the first to successfully solve the open problem on recursive and mutable types. * Unlike the type-passing approaches [25, 14, 24, 34], our 2 S S r r list S S r r * - - - B C 0 - = <p> Previous coercion-based approaches <ref> [19, 26, 27, 15, 33, 36] </ref> do not take advantage of runtime type information, so they can only use full boxing as its canonical boxed form. <p> Most previous work on coercion-based approaches concentrate on how to use compile-time analysis to eliminate unnecessary coercions. Both Peyton Jones [26] and Poulsen [27] extend the type system to tag monomorphic types with a boxity annotation, and then statically determine when to use boxed representations. Henglein and Jorgensen <ref> [15] </ref> present a term-rewriting method that translates a program with many coercions into one that contains a "formally optimal" set of coercions.
Reference: [16] <author> M. P. Jones. </author> <title> Dictionary-free overloading by partial evaluation. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 107-117. </pages> <institution> University of Melbourne TR 94/9, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: It is unrealistic to specialize all polymorphic functions and functors in realistic applications (e.g., theorem provers, ML-kit compilers, SML/NJ Compilation Manager); many C++ templates users should have similar experience. Even Mark Jones's experiment <ref> [16] </ref> only eliminates the use of type classes but not all the polymorphic functions. new scheme supports unboxed representations for recursive and mutable types, yet it only requires little runtime type analysis.
Reference: [17] <author> G. Kane and J. Heinrich, </author> <title> editors. MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: For machines with k argument registers (including FP registers), this would require 2 k cases (e.g., entrant code, coercions) to deal with all the possible calling conventions [24]. Actually, modern compilers often use even more elaborate calling conventions <ref> [5, 17] </ref>|making the above simulation virtually impossible. Of course, one could always resort to runtime code generation [18, 4, 9] or simply use a very restricted set of calling conventions [24], but then, either the cost is too expensive or the interoperability suffers.
Reference: [18] <author> P. Lee and M. Leone. </author> <title> Optimizing ML with run-time code generation. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 137-148. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: Actually, modern compilers often use even more elaborate calling conventions [5, 17]|making the above simulation virtually impossible. Of course, one could always resort to runtime code generation <ref> [18, 4, 9] </ref> or simply use a very restricted set of calling conventions [24], but then, either the cost is too expensive or the interoperability suffers. This paper presents a new flexible representation analysis technique that combines the best of both the coercion-based and the type-passing approaches.
Reference: [19] <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 177-188, </pages> <address> New York, </address> <month> Jan </month> <year> 1992. </year> <note> ACM Press. Longer version available as INRIA Tech Report. </note>
Reference-contexts: Xavier Leroy <ref> [19] </ref> recently presented a representation analysis technique that does not always require variables be boxed in one word. <p> Leroy's technique, unfortunately, does not handle recursive datatypes and mutable types well. Coercions on large data structures are impractical because the cost of the copying often outweighs the benefits of unboxed representations <ref> [19, 14] </ref>. More seriously, mutable data structures such as arrays cannot be copied or coerced; if we make a copy of the value to box the components, then updates to the copy will not be reflected in the original array and vice versa. <p> Our new scheme supports unboxed representations for recursive and mutable types, yet it only requires little runtime type analysis. Our idea is simple: we avoid the heavy-weight runtime type manipulations by boxing all polymorphic values; however, instead of doing full boxing as in the coercion-based approach <ref> [19] </ref>, we use the simply boxed representation (see Figure 1c) or other partially boxed representations (see Figure 1d). Intuitively, a simply boxed object just boxes the top layer of the data structure so that the entire object can be referenced as a single-word pointer. <p> For example, using the partially boxed representation shown in Figure 1d, we can completely eliminate the vararg problem in the type-passing approach (see later sections for more details). The main contributions of this paper are: * Among all the known coercion-based approaches <ref> [19, 26, 27, 15, 33, 36] </ref>, our scheme is the first to successfully solve the open problem on recursive and mutable types. * Unlike the type-passing approaches [25, 14, 24, 34], our 2 S S r r list S S r r * - - - B C 0 - = <p> Coercions for more complicated types can be inductively defined based on these two primitive coercions (see Section 3.5 or Leroy <ref> [19] </ref> for more details). <p> Unfortunately, many commonly used objects are incoercible. Coercions on large data structures are impractical because the cost of the copying often outweighs the benefits of unboxed representations <ref> [19] </ref>. More seriously, mutable data structures such as arrays cannot be copied or coerced; if we make a copy of the value to box the components, then updates to the copy will not be reflected in the original array and vice versa. <p> ; : : : ; t n g; ` v : t 0 ) e 0 2 p 2 )(flt 1 :: ; : : : ; flt n :: :e 0 A semantic correctness theorem about this embedding can also be stated and proved using the standard logical-relations technique <ref> [24, 19] </ref>. 3.4 Target language: TGT The target language (TGT) for our representation analysis is very similar to Harper and Morrisett's ML i [14]. In fact, because our IL is much like ML , TGT is essentially the previously defined IL plus Harper and Morrisett's typerec forms [14]. <p> The type preservation theorem can be proved by structural inductions on the translation rules, using Proposition 3.3-3.5. A semantic correctness theorem about the translation can also be stated and proved using the same logical relations technique used in Morrisett [24] and Leroy <ref> [19] </ref>. 3.6 Valid canonical boxing schemes A boxing scheme is valid if its underlying constructor Wrap is in the valid canonical boxed form. Intuitively, the set of axioms in the Definition 3.2 guarantees that coercions based on the Wrap will commute with the type instantiation relations. <p> Previous coercion-based approaches <ref> [19, 26, 27, 15, 33, 36] </ref> do not take advantage of runtime type information, so they can only use full boxing as its canonical boxed form.
Reference: [20] <author> X. Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In Twenty-first Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 109-122, </pages> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: We show that our technique works for both the ML style polymorphism and the F ! -like higher-order poly morphism. * We show how easily our scheme can be extended to handle type abstractions across ML-like higher-order modules <ref> [22, 21, 11, 20] </ref>. * We show that with a simple twist based on the para metricity property, most runtime type manipulations in our scheme can be eliminated. * We have implemented our scheme (with partially boxed representations) in an experimental version of the SML/NJ compiler [3, 33].
Reference: [21] <author> D. MacQueen and M. Tofte. </author> <title> A semantics for higher order functors. </title> <booktitle> In The 5th European Symposium on Programming, </booktitle> <pages> pages 409-423, </pages> <address> Berlin, </address> <month> April </month> <year> 1994. </year> <pages> Spinger-Verlag. </pages>
Reference-contexts: We show that our technique works for both the ML style polymorphism and the F ! -like higher-order poly morphism. * We show how easily our scheme can be extended to handle type abstractions across ML-like higher-order modules <ref> [22, 21, 11, 20] </ref>. * We show that with a simple twist based on the para metricity property, most runtime type manipulations in our scheme can be eliminated. * We have implemented our scheme (with partially boxed representations) in an experimental version of the SML/NJ compiler [3, 33]. <p> ); Boxed ( 2 )). 4 Extensions In this section, we present several extensions and variations of our flexible representation analysis algorithm. 4.1 Modules and type abstractions The algorithm and framework in Section 3 can be extended to handle the entire SML language [23] plus the MacQueen-Tofte style higher-order modules <ref> [21] </ref>. In a companion paper [32], we show that both the SML simple modules and the transparent higher-order modules can all be translated into our intermediate language IL defined in Section 3.2 (extended with product kinds).
Reference: [22] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: We show that our technique works for both the ML style polymorphism and the F ! -like higher-order poly morphism. * We show how easily our scheme can be extended to handle type abstractions across ML-like higher-order modules <ref> [22, 21, 11, 20] </ref>. * We show that with a simple twist based on the para metricity property, most runtime type manipulations in our scheme can be eliminated. * We have implemented our scheme (with partially boxed representations) in an experimental version of the SML/NJ compiler [3, 33]. <p> In the rest of this paper, we first give an informal presentation of the main idea. We then formalize the presentation and give several major theorems about our flexible approach. We also show how to extend our scheme to handle the entire ML language <ref> [22] </ref>.
Reference: [23] <author> R. Milner, M. Tofte, R. Harper, and D. MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: constructors such as ! (Boxed ( 1 ); Boxed ( 2 )). 4 Extensions In this section, we present several extensions and variations of our flexible representation analysis algorithm. 4.1 Modules and type abstractions The algorithm and framework in Section 3 can be extended to handle the entire SML language <ref> [23] </ref> plus the MacQueen-Tofte style higher-order modules [21]. In a companion paper [32], we show that both the SML simple modules and the transparent higher-order modules can all be translated into our intermediate language IL defined in Section 3.2 (extended with product kinds).
Reference: [24] <author> G. Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1995. </year> <note> Tech Report CMU-CS-95-226. </note>
Reference-contexts: As a result, values such as lists and arrays must still use fully boxed representations, even when they are not inside polymorphic contexts. Harper and Morrisett <ref> [14, 24] </ref> later solved this problem on recursive and mutable types using a type-passing approach. Under their scheme, data objects (including lists and arrays) are kept "unboxed" all the time, even inside polymorphic contexts. Polymorphism is not implemented through coercions, but by using runtime type analysis and code manipulations. <p> In fact, all primitive operations inside polymorphic contexts are no longer primitive: simple function calls (or returns) and record operations (e.g., creation, selection, list cons) now become either indirect procedure calls or large typerec switches <ref> [24] </ref>. <p> Compiler optimizations such as type specialization may eliminate part of these overheads, but they can lead to code ex plosions or excessively long compile time. * A more severe problem, also called the vararg problem (see <ref> [24, page 216 and 175] </ref> for details), is the implementation of function definitions and function calls with arguments of unknown types (e.g., the application of f inside quad). <p> For machines with k argument registers (including FP registers), this would require 2 k cases (e.g., entrant code, coercions) to deal with all the possible calling conventions <ref> [24] </ref>. Actually, modern compilers often use even more elaborate calling conventions [5, 17]|making the above simulation virtually impossible. Of course, one could always resort to runtime code generation [18, 4, 9] or simply use a very restricted set of calling conventions [24], but then, either the cost is too expensive or <p> coercions) to deal with all the possible calling conventions <ref> [24] </ref>. Actually, modern compilers often use even more elaborate calling conventions [5, 17]|making the above simulation virtually impossible. Of course, one could always resort to runtime code generation [18, 4, 9] or simply use a very restricted set of calling conventions [24], but then, either the cost is too expensive or the interoperability suffers. This paper presents a new flexible representation analysis technique that combines the best of both the coercion-based and the type-passing approaches. <p> The main contributions of this paper are: * Among all the known coercion-based approaches [19, 26, 27, 15, 33, 36], our scheme is the first to successfully solve the open problem on recursive and mutable types. * Unlike the type-passing approaches <ref> [25, 14, 24, 34] </ref>, our 2 S S r r list S S r r * - - - B C 0 - = BN CW . . . . .. . . . . . . . . . . . . . . . . .. . 0 z <p> Values (v) are a subset of terms and include identifiers, constants, pair of values, abstractions, and packed values. The static and dynamic semantics for SRC are all standard and same as those for Mini-ML (see <ref> [7, 14, 24] </ref>). The type inference rule (given later as part of the translation from SRC to IL in Figure 6) is in the form of 4; ` e : t where 4 is a set of free type variables, and is a type environment mapping identifiers to polytypes. <p> ; : : : ; t n g; ` v : t 0 ) e 0 2 p 2 )(flt 1 :: ; : : : ; flt n :: :e 0 A semantic correctness theorem about this embedding can also be stated and proved using the standard logical-relations technique <ref> [24, 19] </ref>. 3.4 Target language: TGT The target language (TGT) for our representation analysis is very similar to Harper and Morrisett's ML i [14]. In fact, because our IL is much like ML , TGT is essentially the previously defined IL plus Harper and Morrisett's typerec forms [14]. <p> The operational semantics for TGT, written as e ,! t v, is similar to those for IL also. Harper and Morrisett <ref> [14, 24] </ref> have shown that type checking for ML i is decidable, and furthermore, its typing rules are consistent with the operation semantics. <p> The type preservation theorem can be proved by structural inductions on the translation rules, using Proposition 3.3-3.5. A semantic correctness theorem about the translation can also be stated and proved using the same logical relations technique used in Morrisett <ref> [24] </ref> and Leroy [19]. 3.6 Valid canonical boxing schemes A boxing scheme is valid if its underlying constructor Wrap is in the valid canonical boxed form. Intuitively, the set of axioms in the Definition 3.2 guarantees that coercions based on the Wrap will commute with the type instantiation relations. <p> Wrap [] = Boxed (Uncv []), and both Boxed and Uncv commute with substitutions; Boxed is a primitive constructor, and Uncv is a simple Typerec-form constructor (which can be shown to commute with substitutions using structural inductions, following from the constructor equivalence rules on Typerec defined in Harper and Morrisett <ref> [14, 24] </ref>). Second, we prove Wrap [] Wrap [Wrap []]. From the definition of Uncv, we have Uncv [Boxed ()] for any , therefore: Wrap [Wrap []] Boxed (Uncv [Boxed (Uncv [])]) Boxed (Uncv []) Wrap []. <p> Previous coercion-based approaches [19, 26, 27, 15, 33, 36] do not take advantage of runtime type information, so they can only use full boxing as its canonical boxed form. On the other hand, previous type-passing approaches <ref> [25, 14, 24, 34] </ref> do not box polymorphic objects, so they require extensive runtime type analysis and code manipulations. Most previous work on coercion-based approaches concentrate on how to use compile-time analysis to eliminate unnecessary coercions. <p> Morrison, et al. [25] described an implementation of Napier that passed types at runtime to determine the behavior of polymorphic operations. The type-passing approach was later formalized using ML i by Harper and Mor-risett <ref> [14, 13, 24] </ref>; the intensional type analysis framework they proposed is one of the main inspirations for the present work. Very recently, Tarditi and Morrisett, et al. [34, 24] have implemented the type-passing approach in their TIL compiler. <p> The type-passing approach was later formalized using ML i by Harper and Mor-risett [14, 13, 24]; the intensional type analysis framework they proposed is one of the main inspirations for the present work. Very recently, Tarditi and Morrisett, et al. <ref> [34, 24] </ref> have implemented the type-passing approach in their TIL compiler. Their preliminary measurements showed that using unboxed representations for recursive and mutable data structures can dramatically improves the performance of most of their (monomorphic) benchmarks.
Reference: [25] <author> R. Morrison, A. Dearle, R. C. H. Connor, and A. L. Brown. </author> <title> An ad hoc approach to the implementation of polymorphism. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 13(3), </volume> <month> July </month> <year> 1991. </year>
Reference-contexts: The main contributions of this paper are: * Among all the known coercion-based approaches [19, 26, 27, 15, 33, 36], our scheme is the first to successfully solve the open problem on recursive and mutable types. * Unlike the type-passing approaches <ref> [25, 14, 24, 34] </ref>, our 2 S S r r list S S r r * - - - B C 0 - = BN CW . . . . .. . . . . . . . . . . . . . . . . .. . 0 z <p> Previous coercion-based approaches [19, 26, 27, 15, 33, 36] do not take advantage of runtime type information, so they can only use full boxing as its canonical boxed form. On the other hand, previous type-passing approaches <ref> [25, 14, 24, 34] </ref> do not box polymorphic objects, so they require extensive runtime type analysis and code manipulations. Most previous work on coercion-based approaches concentrate on how to use compile-time analysis to eliminate unnecessary coercions. <p> All these techniques still apply to our flexible approaches because the top-level S and G transformations in our scheme are almost identical to Leroy's original ones. What changed in our scheme is the interpretation of the primitive coercions wrap [t ] and unwrap [t ]. Morrison, et al. <ref> [25] </ref> described an implementation of Napier that passed types at runtime to determine the behavior of polymorphic operations.
Reference: [26] <author> S. L. Peyton Jones and J. Launchbury. </author> <title> Unboxed values as first class citizens in a non-strict functional language. </title> <booktitle> In The Fifth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 636-666, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> ACM Press. </note>
Reference-contexts: For example, using the partially boxed representation shown in Figure 1d, we can completely eliminate the vararg problem in the type-passing approach (see later sections for more details). The main contributions of this paper are: * Among all the known coercion-based approaches <ref> [19, 26, 27, 15, 33, 36] </ref>, our scheme is the first to successfully solve the open problem on recursive and mutable types. * Unlike the type-passing approaches [25, 14, 24, 34], our 2 S S r r list S S r r * - - - B C 0 - = <p> Previous coercion-based approaches <ref> [19, 26, 27, 15, 33, 36] </ref> do not take advantage of runtime type information, so they can only use full boxing as its canonical boxed form. <p> On the other hand, previous type-passing approaches [25, 14, 24, 34] do not box polymorphic objects, so they require extensive runtime type analysis and code manipulations. Most previous work on coercion-based approaches concentrate on how to use compile-time analysis to eliminate unnecessary coercions. Both Peyton Jones <ref> [26] </ref> and Poulsen [27] extend the type system to tag monomorphic types with a boxity annotation, and then statically determine when to use boxed representations. Henglein and Jorgensen [15] present a term-rewriting method that translates a program with many coercions into one that contains a "formally optimal" set of coercions.
Reference: [27] <author> E. Poulsen. </author> <title> Representation analysis for efficient implementation of polymorphism. </title> <type> Master's thesis, </type> <institution> DIKU, University of Copenhagen, </institution> <year> 1993. </year>
Reference-contexts: For example, using the partially boxed representation shown in Figure 1d, we can completely eliminate the vararg problem in the type-passing approach (see later sections for more details). The main contributions of this paper are: * Among all the known coercion-based approaches <ref> [19, 26, 27, 15, 33, 36] </ref>, our scheme is the first to successfully solve the open problem on recursive and mutable types. * Unlike the type-passing approaches [25, 14, 24, 34], our 2 S S r r list S S r r * - - - B C 0 - = <p> Previous coercion-based approaches <ref> [19, 26, 27, 15, 33, 36] </ref> do not take advantage of runtime type information, so they can only use full boxing as its canonical boxed form. <p> On the other hand, previous type-passing approaches [25, 14, 24, 34] do not box polymorphic objects, so they require extensive runtime type analysis and code manipulations. Most previous work on coercion-based approaches concentrate on how to use compile-time analysis to eliminate unnecessary coercions. Both Peyton Jones [26] and Poulsen <ref> [27] </ref> extend the type system to tag monomorphic types with a boxity annotation, and then statically determine when to use boxed representations. Henglein and Jorgensen [15] present a term-rewriting method that translates a program with many coercions into one that contains a "formally optimal" set of coercions.
Reference: [28] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings, Colloque sur la Programmation, Lecture Notes in Computer Science, </booktitle> <volume> volume 19, </volume> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1974. </year>
Reference-contexts: and a set of axioms that precisely characterize this trade-off. * By choosing partially boxed representations (e.g., Fig ure 1d) as the canonical boxed form, our scheme can completely eliminate the nasty vararg problem. * We extend Leroy's representation analysis to a predica-tive variant of the polymorphic -calculus F ! <ref> [10, 28] </ref>. <p> Instead of performing the analysis directly on the ML source language (SRC), we use a predicative variant of the polymorphic - calculus F ! <ref> [10, 28, 14] </ref> as the intermediate language (IL). Representation analysis is then expressed as a type-directed program transformation that automatically inserts coercions and translates IL programs into the target implementation calculus (TGT|also known as ML i [14]). <p> To simplify the presentation, we use pack to serve as a representative for incoercible tycons; however, all techniques described here easily carry to other incoercible tycons. 3.2 Intermediate language: IL We use a predicative variant [12, 14] of the polymorphic - calculus F ! <ref> [10, 28] </ref> as our intermediate language.
Reference: [29] <author> Z. Shao. </author> <title> Compiling Standard ML for Efficient Execution on Modern Machines. </title> <type> PhD thesis, </type> <institution> Princeton University, Prince-ton, NJ, </institution> <month> November </month> <year> 1994. </year> <note> Tech Report CS-TR-475-94. </note>
Reference-contexts: We compare the new technique with Leroy's standard coercion-based approach. Here, Old is the type-based compiler described in Shao and Appel <ref> [33, 29] </ref>); New is the new compiler that implements the flexible representation analysis described in this paper. In Figure 9, we give the measurement results (in seconds) of running the Old and New compilers on twelve ML benchmarks on a Sun Sparc20 station with 128 Mbytes memory.
Reference: [30] <author> Z. Shao. </author> <title> Flexible representation analysis. </title> <type> Technical Report YALEU/DCS/RR-1125, </type> <institution> Dept. of Computer Science, Yale University, </institution> <address> New Haven, CT, </address> <month> April </month> <year> 1997. </year>
Reference: [31] <author> Z. Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In Proc. 1997 ACM SIGPLAN Workshop on Types in Compilation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: The precise relationship between the two is out of the scope of the current paper. 5 Implementation We have implemented the flexible representation analysis technique outlined above in an experimental version of the Standard ML of New Jersey compiler (v109.25m) <ref> [3, 33, 31] </ref>. To simplify the implementation, we avoid the vararg problem by using partial boxing as the canonical boxed form. We used the standard technique of minimal typing derivations [33, 6] to eliminate local and unnecessary polymor-phisms.
Reference: [32] <author> Z. Shao. </author> <title> Typed cross-module compilation. </title> <type> Technical Report YALEU/DCS/RR-1126, </type> <institution> Dept. of Computer Science, Yale University, </institution> <address> New Haven, CT, </address> <month> May </month> <year> 1997. </year>
Reference-contexts: In a companion paper <ref> [32] </ref>, we show that both the SML simple modules and the transparent higher-order modules can all be translated into our intermediate language IL defined in Section 3.2 (extended with product kinds). Therefore, representation analysis on the module languages is reduced to calling the same algorithm described in Section 3.5.
Reference: [33] <author> Z. Shao and A. W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In Proc. ACM SIGPLAN '95 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 116-129. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: For example, using the partially boxed representation shown in Figure 1d, we can completely eliminate the vararg problem in the type-passing approach (see later sections for more details). The main contributions of this paper are: * Among all the known coercion-based approaches <ref> [19, 26, 27, 15, 33, 36] </ref>, our scheme is the first to successfully solve the open problem on recursive and mutable types. * Unlike the type-passing approaches [25, 14, 24, 34], our 2 S S r r list S S r r * - - - B C 0 - = <p> across ML-like higher-order modules [22, 21, 11, 20]. * We show that with a simple twist based on the para metricity property, most runtime type manipulations in our scheme can be eliminated. * We have implemented our scheme (with partially boxed representations) in an experimental version of the SML/NJ compiler <ref> [3, 33] </ref>. Preliminary measurements show that code involving recursive and mutable types gets significant speedup while normal polymor phic code remains almost as efficient as before. In the rest of this paper, we first give an informal presentation of the main idea. <p> The precise relationship between the two is out of the scope of the current paper. 5 Implementation We have implemented the flexible representation analysis technique outlined above in an experimental version of the Standard ML of New Jersey compiler (v109.25m) <ref> [3, 33, 31] </ref>. To simplify the implementation, we avoid the vararg problem by using partial boxing as the canonical boxed form. We used the standard technique of minimal typing derivations [33, 6] to eliminate local and unnecessary polymor-phisms. <p> To simplify the implementation, we avoid the vararg problem by using partial boxing as the canonical boxed form. We used the standard technique of minimal typing derivations <ref> [33, 6] </ref> to eliminate local and unnecessary polymor-phisms. We did not exploit the parametricity property (discussed in Section 4.3) in the current implementation. <p> We compare the new technique with Leroy's standard coercion-based approach. Here, Old is the type-based compiler described in Shao and Appel <ref> [33, 29] </ref>); New is the new compiler that implements the flexible representation analysis described in this paper. In Figure 9, we give the measurement results (in seconds) of running the Old and New compilers on twelve ML benchmarks on a Sun Sparc20 station with 128 Mbytes memory. <p> Previous coercion-based approaches <ref> [19, 26, 27, 15, 33, 36] </ref> do not take advantage of runtime type information, so they can only use full boxing as its canonical boxed form. <p> Henglein and Jorgensen [15] present a term-rewriting method that translates a program with many coercions into one that contains a "formally optimal" set of coercions. Shao and Appel <ref> [33] </ref> extended Leroy's scheme to the entire SML module language and also used minimum typing derivations [6] to decrease the degree of polymorphism thus eliminate coercions.
Reference: [34] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 181-192. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: The main contributions of this paper are: * Among all the known coercion-based approaches [19, 26, 27, 15, 33, 36], our scheme is the first to successfully solve the open problem on recursive and mutable types. * Unlike the type-passing approaches <ref> [25, 14, 24, 34] </ref>, our 2 S S r r list S S r r * - - - B C 0 - = BN CW . . . . .. . . . . . . . . . . . . . . . . .. . 0 z <p> Since many polymorphic functions do not involve arrays, most runtime type manipulations can be eliminated. Finally, the parametricity property discussed here may not hold for compilers that use tag-free garbage collections <ref> [34] </ref>. The precise relationship between the two is out of the scope of the current paper. 5 Implementation We have implemented the flexible representation analysis technique outlined above in an experimental version of the Standard ML of New Jersey compiler (v109.25m) [3, 33, 31]. <p> In the future, we plan to use more aggressive type specializations [35] and to exploit the parametricity described in Section 4.3 to to eliminate these overheads. 12 It is worth pointing out that the speedup we got here is likely similar to those found in the pure-type-passing compilers (e.g., TIL <ref> [34] </ref>). The strength of our flexible framework lies, however, on the fact that we can achieve the speedup without paying heavy cost on the polymorphic code. <p> Previous coercion-based approaches [19, 26, 27, 15, 33, 36] do not take advantage of runtime type information, so they can only use full boxing as its canonical boxed form. On the other hand, previous type-passing approaches <ref> [25, 14, 24, 34] </ref> do not box polymorphic objects, so they require extensive runtime type analysis and code manipulations. Most previous work on coercion-based approaches concentrate on how to use compile-time analysis to eliminate unnecessary coercions. <p> The type-passing approach was later formalized using ML i by Harper and Mor-risett [14, 13, 24]; the intensional type analysis framework they proposed is one of the main inspirations for the present work. Very recently, Tarditi and Morrisett, et al. <ref> [34, 24] </ref> have implemented the type-passing approach in their TIL compiler. Their preliminary measurements showed that using unboxed representations for recursive and mutable data structures can dramatically improves the performance of most of their (monomorphic) benchmarks.
Reference: [35] <author> D. R. Tarditi. </author> <title> Design and Implementation of Code Optimizations for a Type-Directed Compiler for Standard ML. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1996. </year> <note> Tech Report CMU-CS-97-108. </note>
Reference-contexts: Because of the extra coercions on each element, the New compiler runs nearly twice slower than the Old compiler. In the future, we plan to use more aggressive type specializations <ref> [35] </ref> and to exploit the parametricity described in Section 4.3 to to eliminate these overheads. 12 It is worth pointing out that the speedup we got here is likely similar to those found in the pure-type-passing compilers (e.g., TIL [34]).
Reference: [36] <author> P. J. Thiemann. </author> <title> Unboxed values and polymorphic typing revisited. </title> <booktitle> In The Seventh International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 24-35, </pages> <address> New York, </address> <month> June </month> <year> 1995. </year> <pages> Spinger-Verlag. </pages>
Reference-contexts: For example, using the partially boxed representation shown in Figure 1d, we can completely eliminate the vararg problem in the type-passing approach (see later sections for more details). The main contributions of this paper are: * Among all the known coercion-based approaches <ref> [19, 26, 27, 15, 33, 36] </ref>, our scheme is the first to successfully solve the open problem on recursive and mutable types. * Unlike the type-passing approaches [25, 14, 24, 34], our 2 S S r r list S S r r * - - - B C 0 - = <p> Previous coercion-based approaches <ref> [19, 26, 27, 15, 33, 36] </ref> do not take advantage of runtime type information, so they can only use full boxing as its canonical boxed form.
Reference: [37] <author> A. K. Wright. </author> <title> Polymorphism for imperative languages without imperative types. </title> <type> Technical Report Tech Report TR 93-200, </type> <institution> Dept. of Computer Science, Rice University, Houston, Texas, </institution> <month> February </month> <year> 1993. </year> <month> 14 </month>
Reference-contexts: We also restrict the let-bound expressions to values <ref> [37] </ref> so that type abstractions can be made explicit in the translation. The natural (call-by-value) dynamic semantics for SRC can be defined as e ,! s v where e is a closed expression and v is a closed value.
References-found: 37

