URL: http://www.cs.uoregon.edu/~sabry/papers/monadic-state.ps
Refering-URL: http://www.cs.uoregon.edu/~sabry/papers/index.html
Root-URL: http://www.cs.uoregon.edu
Email: jl@cse.ogi.edu sabry@cs.uoregon.edu  
Title: Monadic State: Axiomatization and Type Safety  
Author: John Launchbury Amr Sabry 
Address: P.O. Box 91000  Portland, OR 97291-1000 Eugene, OR 97403  
Affiliation: Oregon Graduate Institute Department of Computer Science  University of Oregon  
Abstract: Type safety of imperative programs is an area fraught with difficulty and requiring great care. The SML solution to the problem, originally involving imperative type variables, has been recently simplified to the syntactic-value restriction. In Haskell, the problem is addressed in a rather different way using explicit monadic state. We present an operational semantics for state in Haskell and the first full proof of type safety. We demonstrate that the semantic notion of value provided by the explicit monadic types is able to avoid any problems with generalization. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ariola, Z. M., and Felleisen, M. </author> <title> The call-by-need lambda calculus. </title> <note> To appear in the Journal of Functional Programming, </note> <year> 1996. </year>
Reference: [2] <author> Ariola, Z. M., Felleisen, M., Maraist, J., Odersky, M., and Wadler, P. </author> <title> A call-by-need lambda calculus. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1995), </booktitle> <pages> pp. 233-246. </pages>
Reference-contexts: In other words, the compiler's intermediate language is not purely functional and hence must be optimized with care. Not only can fi steps in the compiler cause severe performance problems, for example by duplicating expensive computations <ref> [2] </ref>, but more drastically, they are unsound. Fortunately, even before the monadic extensions, most Haskell compilers were careful not to duplicate work and hence refrained from using fi steps for performance reasons.
Reference: [3] <author> Boehm, H.-J. </author> <title> Side effects and aliasing can have simple axiomatic descriptions. </title> <journal> ACM Transactions on Programming Languages and Systems 7, </journal> <month> 4 (Oct. </month> <year> 1985), </year> <pages> 637-655. </pages>
Reference: [4] <author> Chen, K., and Odersky, M. </author> <title> A type system for a lambda calculus with assignment. </title> <booktitle> In Theoretical Aspects of Computer Software (1994), </booktitle> <publisher> Springer Verlag, LNCS 789. </publisher>
Reference-contexts: Of course this would be prohibitively expensive in practice, and it seems impossible to generalize to lazy state. As an alternative, a type system was proposed which statically ensured that the state threads were pure <ref> [4] </ref>. Like early versions of ML, the type system had two sorts of type 10 variables (applicative and imperative). In addition, the typ-ing judgment for pure demanded that only applicative types appeared in the type environment and in the result type| much more restrictive than the Haskell solution.
Reference: [5] <author> Crank, E., and Felleisen, M. </author> <title> Parameter-passing and the lambda calculus. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1991), </booktitle> <pages> pp. 233-244. </pages>
Reference: [6] <author> Damas, L. M. </author> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1985. </year>
Reference-contexts: Of course, the fact that type systems can figure out the lifetimes of references has been known for some time <ref> [6] </ref>. What distinguishes our solution based on runST is that it requires such minor changes to the language.
Reference: [7] <author> Felleisen, M., and Friedman, D. </author> <title> A calculus for assignments in higher-order languages. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1987), </booktitle> <pages> pp. 314-325. </pages>
Reference: [8] <author> Felleisen, M., and Hieb, R. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <booktitle> Theoretical Computer Science 102 (1992), </booktitle> <month> 235-271. </month> <type> Technical Report 89-100, </type> <institution> Rice University. </institution>
Reference: [9] <author> Hoare, C., Hayes, I., Jifeng, H., Morgan, C., Roscoe, A., Sanders, J., Sorensen, I., Spivey, J., and Sufrin, B. </author> <title> Laws of programming. </title> <journal> Communications of the ACM 30, </journal> <volume> 8 (1987), </volume> <pages> 672-686. </pages>
Reference: [10] <author> Launchbury, J. </author> <title> Lazy imperative programming. </title> <type> Technical Report, </type> <institution> Yale University, </institution> <year> 1993. </year> <booktitle> ACM SIGPLAN Workshop on State in Programming Languages. </booktitle>
Reference-contexts: internally to achieve efficiency, yet show a guaranteed pure face to the outside world, without having to do any expensive run-time checks. 10.1 Typechecked Segmentation Given the spread of run-time mechanisms used for checking locality of references, from operating system segmentation checks to mechanisms for encapsulating effects in functional languages <ref> [10, 21, 22] </ref> it is perhaps surprising to discover that the type system is quite strong enough to do it statically. Of course, the fact that type systems can figure out the lifetimes of references has been known for some time [6].
Reference: [11] <author> Launchbury, J., and Peyton Jones, S. L. </author> <title> Lazy functional state threads. </title> <booktitle> In ACM SIGPLAN Conference on Programming Language Design and Implementation (1994), </booktitle> <pages> pp. 24-35. </pages>
Reference: [12] <author> Launchbury, J., and Peyton Jones, S. L. </author> <title> State in Haskell. </title> <booktitle> Lisp and Symbolic Computation 8 (1995), </booktitle> <pages> 193-341. </pages>
Reference-contexts: But the side condition on sto states that ff ffi is not a free type variable in : a contradiction. In other words, type-checking fails if there is any possibility of a "segmentation fault" across state threads. 8 7 Other State Operations The State in Haskell paper <ref> [12] </ref> presented two other operations on the state. The first eqVar tests for equality of locations; it has the type: eqVar :: MutVar ff ffi t ! MutVar ff ffi t ! Bool It introduces no difficulties to the foregoing material. The second, fixST, does. <p> This is fine so long as either we refrain from performing arbitrary call-by-name transformations on the code, or we give up on destructive update. Part of the motivation for this current work was the desire to be able to retain both. In more detail, the common implementation strategy <ref> [12] </ref> for Haskell's extension with built-in monads is to: 1. translate the source programs by expressing and in-lining returnST, &gt;>=, and runST in the intermediate language of the compiler, 2. apply full compiler optimizations to the resulting in termediate programs, and 3. instruct the code generator not to generate any code
Reference: [13] <author> Mason, I., and Talcott, C. L. </author> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming 1, </journal> <month> 3 (July </month> <year> 1991), </year> <pages> 287-327. </pages>
Reference: [14] <author> Milner, R. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences 17 (1978). </journal>
Reference: [15] <author> Milner, R., Tofte, M., Harper, R., and MacQueen, D. </author> <title> The Definition of Standard ML, </title> <note> Revised 1996. Forthcoming, </note> <year> 1996. </year>
Reference: [16] <author> Odersky, M. </author> <title> A syntactic theory of local names. </title> <type> Technical Report YALEU/DCS/RR-965, </type> <institution> Yale University, </institution> <year> 1993. </year>
Reference: [17] <author> Odersky, M., Rabin, D., and Hudak, P. </author> <title> Call by name, assignment, and the lambda calculus. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (Jan. </booktitle> <year> 1993), </year> <pages> pp. 43-56. </pages>
Reference-contexts: Fortunately, even before the monadic extensions, most Haskell compilers were careful not to duplicate work and hence refrained from using fi steps for performance reasons. Consequently, the addition of assignments to the back end did not cause any problems for such compilers. 9 Related Work The var system <ref> [17] </ref> is very similar in spirit to state in Haskell, and hence to the work presented here. A pure construct was introduced that played the role of runST in that it encapsulated imperative computations, guaranteeing their external purely functional behavior. Two methods were presented by which this can be achieved.
Reference: [18] <author> O'Hearn, P. W., and Tennent, R. D. </author> <title> Relational para-metricity and local variables. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1993). </booktitle>
Reference-contexts: Could such a thing be done in ML? One method might be through something like effects annotations [25] or, indeed, through a region inference system, but there are many details to be worked out. Finally, the parametric models of local variables have strong semantic similarities to the work here <ref> [18] </ref>. A deno-tational semantics has to generate new local variables every time a new block is entered. By using parametricity, these variables can be hidden from the outside world.
Reference: [19] <author> Peterson, John, et al. </author> <title> Report on the programming language Haskell (version 1.3). </title> <type> Technical Report YALEU/DCS/RR-1106, </type> <institution> Yale University, </institution> <year> 1996. </year>
Reference: [20] <author> Rabin, D. </author> <title> Calculi for Functional Programming Languages with Assignments. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <year> 1996. </year> <note> Technical Report YALEU/DCS/RR-1107. </note>
Reference-contexts: Reductions may change the set of free variables in a term, so the purity condition, which only restricts the types of free variables, can be circumvented. As a consequence, subject reduction fails. The problem was corrected by adapting the Haskell solution <ref> [20] </ref>. The work on region inference is also remarkably similar [27]. Our sto construct is essentially creating a new region and initializing it. However, in contrast to the region language, an expression in our language cannot access variables in several regions.
Reference: [21] <author> Riecke, J. G. </author> <title> Delimiting the scope of effects. </title> <booktitle> In Conference on Functional Programming and Computer Architecture (1993), </booktitle> <pages> pp. 146-155. </pages>
Reference-contexts: internally to achieve efficiency, yet show a guaranteed pure face to the outside world, without having to do any expensive run-time checks. 10.1 Typechecked Segmentation Given the spread of run-time mechanisms used for checking locality of references, from operating system segmentation checks to mechanisms for encapsulating effects in functional languages <ref> [10, 21, 22] </ref> it is perhaps surprising to discover that the type system is quite strong enough to do it statically. Of course, the fact that type systems can figure out the lifetimes of references has been known for some time [6].
Reference: [22] <author> Riecke, J. G., and Viswanathan, R. </author> <title> Isolating side effects in sequential languages. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1995), </booktitle> <pages> pp. 1-12. </pages>
Reference-contexts: internally to achieve efficiency, yet show a guaranteed pure face to the outside world, without having to do any expensive run-time checks. 10.1 Typechecked Segmentation Given the spread of run-time mechanisms used for checking locality of references, from operating system segmentation checks to mechanisms for encapsulating effects in functional languages <ref> [10, 21, 22] </ref> it is perhaps surprising to discover that the type system is quite strong enough to do it statically. Of course, the fact that type systems can figure out the lifetimes of references has been known for some time [6].
Reference: [23] <author> Sabry, A., and Field, J. </author> <title> Reasoning about explicit and implicit representations of state. </title> <type> Technical Report YALEU/DCS/RR-968, </type> <institution> Yale University, </institution> <year> 1993. </year> <booktitle> ACM SIG-PLAN Workshop on State in Programming Languages, </booktitle> <pages> pages 17-30. </pages>
Reference: [24] <author> Swarup, V., Reddy, U., and Ireland, E. </author> <title> Assignments for applicative languages. </title> <booktitle> In Conference on Functional Programming and Computer Architecture (1991), </booktitle> <pages> pp. 192-214. </pages>
Reference: [25] <author> Talpin, J., and Jouvelot, P. </author> <title> The type and effect discipline. </title> <booktitle> In IEEE Symposium on Logic in Computer Science (June 1992), </booktitle> <pages> pp. 162-173. </pages>
Reference-contexts: The type-based encapsulation works well in Haskell because the explicit use of the state monad (and others) provided a ready home for the extra type variable. Could such a thing be done in ML? One method might be through something like effects annotations <ref> [25] </ref> or, indeed, through a region inference system, but there are many details to be worked out. Finally, the parametric models of local variables have strong semantic similarities to the work here [18]. A deno-tational semantics has to generate new local variables every time a new block is entered.
Reference: [26] <author> Tofte, M. </author> <title> Type inference for polymorphic references. </title> <booktitle> Information and Computation 89, </booktitle> <month> 1 (November </month> <year> 1990), </year> <pages> 1-34. </pages>
Reference: [27] <author> Tofte, M., and Talpin, J. </author> <title> Implementing the call-by-value calculus using a stack of regions. </title> <booktitle> In ACM Symposium on Principles of Programming Languages (1994), </booktitle> <pages> pp. 188-201. </pages>
Reference-contexts: As a consequence, subject reduction fails. The problem was corrected by adapting the Haskell solution [20]. The work on region inference is also remarkably similar <ref> [27] </ref>. Our sto construct is essentially creating a new region and initializing it. However, in contrast to the region language, an expression in our language cannot access variables in several regions.
Reference: [28] <author> Wadler, P. </author> <title> Comprehending monads. </title> <booktitle> In ACM Conference on Lisp and Functional Programming (1990), </booktitle> <pages> pp. 61-78. </pages>
Reference: [29] <author> Wright, A. K., and Felleisen, M. </author> <title> A syntactic approach to type soundness. </title> <type> Technical Report 91-160, </type> <institution> Rice University, </institution> <month> April </month> <year> 1991. </year> <note> Final version in Information and Computation 115 (1), </note> <year> 1994, </year> <pages> 38-94. </pages>
References-found: 29

