URL: http://pertsserver.cs.uiuc.edu/papers/HaLi93.ps
Refering-URL: http://pertsserver.cs.uiuc.edu/papers/
Root-URL: http://www.cs.uiuc.edu
Title: Validating Timing Constraints in Multiprocessor and Distributed Real-Time Systems  
Author: Rhan Ha and Jane W. S. Liu 
Address: Urbana, Illinois 61801  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R. L. Graham. </author> <title> Bounds on multiprocessing timing anomalies. </title> <journal> SIAM Journal of Applied Mathematics, </journal> <volume> 17(2) </volume> <pages> 416-429, </pages> <month> March </month> <year> 1969. </year>
Reference-contexts: Graham has shown that the completion time of a set of nonpreemptive jobs with identical release times can be later when more processors are used to execute them and when they have shorter execution times and fewer dependencies <ref> [1] </ref>. When jobs have arbitrary release times and share nonpreemptable resources, scheduling anomalies can occur even when there is only one processor and the jobs are preemptable.
Reference: [2] <author> B. Sprunt, L. Sha, and J. P. Lehoczky. </author> <title> Aperiodic task scheduling for hard-real-time systems. </title> <journal> The Journal of Real-Time Systems, </journal> <volume> 1 </volume> <pages> 27-60, </pages> <year> 1989. </year>
Reference-contexts: Jobs on each processor are scheduled according to a uniprocessor scheduling algorithm and synchronized according to a resource access-control protocol that leads of bounded durations of priority inversion (for example, the ones in <ref> [2, 3] </ref>). (A priority inversion is said to occur when a lower-priority job executes or a processor is left idle while some higher-priority job is ready and waiting for execution. In Figure 1 (b) and (c), priority inversion occurs after the completion of J 1 . <p> Some tasks are (periodic) servers <ref> [2] </ref>. A periodic server is created to handle the execution of a stream of jobs whose release times and execution times are random variables. Jobs handled by each server are placed in a priority queue.
Reference: [3] <author> J. P. Lehoczky, L. Sha, and Y. Ding. </author> <title> The rate monotone scheduling algorithm: Exact characterization and average case behavior. </title> <booktitle> In Proceedings of IEEE 10th Real-Time Systems Symposium, </booktitle> <pages> pages 166-171, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Jobs on each processor are scheduled according to a uniprocessor scheduling algorithm and synchronized according to a resource access-control protocol that leads of bounded durations of priority inversion (for example, the ones in <ref> [2, 3] </ref>). (A priority inversion is said to occur when a lower-priority job executes or a processor is left idle while some higher-priority job is ready and waiting for execution. In Figure 1 (b) and (c), priority inversion occurs after the completion of J 1 . <p> An algorithm that makes use of the known parameters p i and e + i can give a more accurate prediction of the worst 11 case response times. Such algorithms are used in PERTS [10]. They are based on a more exact characterization <ref> [3] </ref> of the rate-monotonically scheduled periodic tasks.
Reference: [4] <author> L. Sha, R. Rajkumar, and J. P. Lehoczky. </author> <title> Priority inheritance protocols: An approach to real-time synchronization. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(9) </volume> <pages> 1175-1185, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: In this way, we can ignore precedence constraints and treat all jobs as if they are independent. 10 In our notation, most of the jobs are P/N/J jobs; they are scheduled preemptively (and are not migratable). Their resource accesses are controlled by a protocol (such as the ones in <ref> [4, 5] </ref>) that ensures the blocking time of every job in T i due to resource conflicts with all jobs in the system is never more than b i . <p> For example, when there is only one processor and ffi i = p i , and if the jobs are scheduled on the rate-monotonic basis (that is, the shorter the period, the higher the priority) and synchronized according to the priority-ceiling protocol <ref> [6, 4] </ref>, all jobs in T i always complete by their deadlines as long as i X u k + b i =p i i (2 1=i 1): (1) Here we index the tasks so that p 1 &lt; p 2 &lt; &lt; p n .
Reference: [5] <author> T. P. Baker. </author> <title> A stack-based allocation policy for real-time processes. </title> <booktitle> In Proceedings of IEEE 11th Real-Time Systems Symposium, </booktitle> <pages> pages 191-200, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: In this way, we can ignore precedence constraints and treat all jobs as if they are independent. 10 In our notation, most of the jobs are P/N/J jobs; they are scheduled preemptively (and are not migratable). Their resource accesses are controlled by a protocol (such as the ones in <ref> [4, 5] </ref>) that ensures the blocking time of every job in T i due to resource conflicts with all jobs in the system is never more than b i . <p> Bounds also exist for the earliest-deadline-first algorithm, when there is only one processor and a protocol such as the stack-based protocol <ref> [5] </ref> is used. It is straightforward to generalize the conditions to account for the effects of nonpreemption if some jobs are not preemptable [7, 8].
Reference: [6] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> Journal of the Association for Computing Machinery, </journal> <volume> 20(1) </volume> <pages> 46-61, </pages> <month> January </month> <year> 1973. </year>
Reference-contexts: For example, when there is only one processor and ffi i = p i , and if the jobs are scheduled on the rate-monotonic basis (that is, the shorter the period, the higher the priority) and synchronized according to the priority-ceiling protocol <ref> [6, 4] </ref>, all jobs in T i always complete by their deadlines as long as i X u k + b i =p i i (2 1=i 1): (1) Here we index the tasks so that p 1 &lt; p 2 &lt; &lt; p n .
Reference: [7] <author> M. H. Klein, T. Ralya, B. Pollak, R. Obenza, and M. G. Harbour. </author> <title> A Practitioner's Handbook for Real-Time Analysis: Guide to Rate Monotonic Analysis for Real-Time Systems. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Bounds also exist for the earliest-deadline-first algorithm, when there is only one processor and a protocol such as the stack-based protocol [5] is used. It is straightforward to generalize the conditions to account for the effects of nonpreemption if some jobs are not preemptable <ref> [7, 8] </ref>. It is also straightforward to use these conditions to bound the worst-case completion times of jobs in periodic job-shops and flow-shops where each job consists of subjobs which execute in turn on two or more processors and have end-to-end deadlines [8, 9].
Reference: [8] <author> L. Sha and S. S. Sathaye. </author> <title> A systematic approach to designing distributed real-time systems. </title> <journal> IEEE Computer, </journal> <volume> 26(9) </volume> <pages> 68-78, </pages> <month> September </month> <year> 1993. </year> <month> 35 </month>
Reference-contexts: Bounds also exist for the earliest-deadline-first algorithm, when there is only one processor and a protocol such as the stack-based protocol [5] is used. It is straightforward to generalize the conditions to account for the effects of nonpreemption if some jobs are not preemptable <ref> [7, 8] </ref>. It is also straightforward to use these conditions to bound the worst-case completion times of jobs in periodic job-shops and flow-shops where each job consists of subjobs which execute in turn on two or more processors and have end-to-end deadlines [8, 9]. <p> It is also straightforward to use these conditions to bound the worst-case completion times of jobs in periodic job-shops and flow-shops where each job consists of subjobs which execute in turn on two or more processors and have end-to-end deadlines <ref> [8, 9] </ref>. The known sufficient conditions, such as (1), are particularly robust. Specifically, the values of the periods and worst-case execution times of jobs in tasks T 1 ; T 2 ; : : : ; T i do not appear in the left-handed side of (1), only their utilizations.
Reference: [9] <author> R. Bettati. </author> <title> End-to-End Scheduling to Meet Deadlines. </title> <type> PhD thesis, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1994. </year>
Reference-contexts: It is also straightforward to use these conditions to bound the worst-case completion times of jobs in periodic job-shops and flow-shops where each job consists of subjobs which execute in turn on two or more processors and have end-to-end deadlines <ref> [8, 9] </ref>. The known sufficient conditions, such as (1), are particularly robust. Specifically, the values of the periods and worst-case execution times of jobs in tasks T 1 ; T 2 ; : : : ; T i do not appear in the left-handed side of (1), only their utilizations.
Reference: [10] <author> J. W. S. Liu, J. Redondo, Z. Deng, T. Tia, R. Bettati, A. Silberman, M. Storch, R. Ha, and W. Shih. PERTS: </author> <title> A prototyping environment for real-time systems. </title> <type> Technical Report UIUCDCS-R-93-1802, </type> <institution> University of Illinois at Urbana-Champaign, </institution> <year> 1993. </year>
Reference-contexts: An algorithm that makes use of the known parameters p i and e + i can give a more accurate prediction of the worst 11 case response times. Such algorithms are used in PERTS <ref> [10] </ref>. They are based on a more exact characterization [3] of the rate-monotonically scheduled periodic tasks.
Reference: [11] <author> E. L. Lawler and J. M. Moore. </author> <title> A functional equation and its application to resource allocation and scheduling problem. </title> <journal> Management Science, </journal> <volume> 16 </volume> <pages> 77-84, </pages> <year> 1969. </year> <month> 36 </month>
Reference-contexts: Similarly, its effective release time is the latest time among its release time and the release times of its successors. Working with effective release times and deadlines allows the scheduler to temporarily ignore the precedence constraints between jobs and make scheduling decisions as if the jobs are independent <ref> [11] </ref>. Similarly, to validate whether every job completes before its deadline, we can use the algorithms for validating independent jobs. Unfortunately, this method does not work when the system is dynamic.
References-found: 11

