URL: http://www.cs.umn.edu/classes/Previous-Qtrs/Older/csci5181/reading/tech-rep.ps
Refering-URL: http://www.cs.umn.edu/classes/Previous-Qtrs/Older/csci5181/
Root-URL: http://www.cs.umn.edu
Email: fshekar,tsaig@cs.umn.edu  kirani@advtech.uswest.com  
Title: Specification and Verification of Object-Oriented Programs  
Author: Shekhar Kirani and W. T. Tsai 
Note: 1 Currently employed  
Date: December 4, 1994  
Address: Minneapolis, MN 55455  Boulder, CO.  
Affiliation: Computer Science Department University of Minnesota  at U S WEST Technologies,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1986. </year>
Reference-contexts: The methods can also have a time-based relationship such as the method m 1 must be invoked within 20 milli seconds after the method m 2 . In this thesis, we model only the causal relationship between methods. We use regular definitions <ref> [1] </ref> to model the causal relationship between methods. For modeling the timing relationship between methods we need more powerful formalism than the regular definition. The strict sequence rules between methods of a class depends on the functionality of the class. <p> We use MtSS in conjunction with the conventional data flow anomaly detection techniques to identify the data flow anomalies in classes. The proposed technique is applicable under different inheritance mechanisms. Data flow analysis used in compiler optimizations <ref> [1] </ref>, has been used for identifying data flow anomalies in procedural programs [26, 35, 36]. A data flow anomaly is present when the pattern of variable usage is abnormal in the sense that the usage of variable violates the principles of computation [26]. <p> The path expressions at each node of a program can be efficiently computed using the data flow analysis and code optimization algorithms of LIVE, AVAIL, and REACH. These algorithms are well studied and known in compiler literature <ref> [1] </ref>. The paper from [26] describes a technique for determining the path expressions using these algorithms. An improved and efficient algorithm is given in [36] for computing the path expressions.
Reference: [2] <author> T. R. Arnold and W. A. Fuson. </author> <title> Testing In a Perfect World. </title> <journal> CACM, </journal> <volume> 37(9) </volume> <pages> 78-86, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: In [50], authors have presented an integrated testing of OO programs with the software development process. In [49], authors present an interaction testing technique that allows the tester to incrementally increase the number of interactions for testing. In <ref> [2] </ref>, authors discuss about their experiences with testing of OO programs. In [7], there is a discussion on how to align developmental process with testing so that designs are testable and testing is maximally effective. In [14], authors provide data related to testing of Smalltalk library software.
Reference: [3] <author> J. Bachant. </author> <title> R1 revisited: Four years in the trenches. </title> <journal> AI Magazine, </journal> <pages> pages 21-32, </pages> <month> Fall </month> <year> 1984. </year>
Reference-contexts: Auto-regression testing has been used extensively in industry to maintain and conventional software <ref> [3] </ref>. Reliability tests can also be used in conjunction with mutation to evaluate both black-box and white-box testing methods. In this section we discuss reliability testing. As discussed in section 1.2.2 the size of input space of an expert system is huge.
Reference: [4] <author> F. B. Bastani. </author> <title> Reliability of AI programs. </title> <editor> In B. W. Wah and C. V. Ramamoorthy, editors, </editor> <booktitle> Computers for Artificial Intelligence Processing, </booktitle> <pages> pages 532-562. </pages> <publisher> John wiley & Sons, </publisher> <address> New York, New York, </address> <year> 1990. </year>
Reference-contexts: The techniques reported in [43] assume that test samples are homogeneous and test results follow a binomial distribution. It is not clear that any software can completely satisfy these assumptions. However, reliability models such as this can provide at least pragmatic hints for practicing engineers <ref> [4, 5] </ref> concerned with the reliability of software with respect to certain testing techniques. 1.3 Related Research in OO Testing In recent years, several techniques have been proposed for analysis, design, and implementation of OO software. A recent survey article [54] mentions more than twenty OO analysis and design techniques.
Reference: [5] <author> F. B. Bastani and I. R. Chen. </author> <title> Assessment of reliability of AI programs. </title> <booktitle> Proc. of IEEE International Conference on Tools for AI, </booktitle> <pages> pages 753-759, </pages> <year> 1990. </year>
Reference-contexts: The techniques reported in [43] assume that test samples are homogeneous and test results follow a binomial distribution. It is not clear that any software can completely satisfy these assumptions. However, reliability models such as this can provide at least pragmatic hints for practicing engineers <ref> [4, 5] </ref> concerned with the reliability of software with respect to certain testing techniques. 1.3 Related Research in OO Testing In recent years, several techniques have been proposed for analysis, design, and implementation of OO software. A recent survey article [54] mentions more than twenty OO analysis and design techniques.
Reference: [6] <author> B. Beizer. </author> <title> Software Testing Techniques. </title> <publisher> Van Nostrand Reinhold, </publisher> <address> second edition, </address> <year> 1990. </year>
Reference-contexts: Development paradigms for conventional software, for example, include several variants of the Waterfall model [65] (e.g., the Spiral model [11]). In this class of models, testing (generally referred to as verification and validation <ref> [57, 6, 61] </ref>) establishes a binary relationship between two by-products of the software development process. For example, one type of binary testing comparison is between a specification (a description of the problem to be solved) and a design document (a description of the functional decomposition, data structures and algorithms) [10]. <p> A variety of pragmatic testing methods have been used to test conventional software ranging from small programs to mission-critical software such as space shuttle software <ref> [6, 57, 71] </ref>. These methods include for example random testing, equivalence and boundary partition testing, cause-effect graph testing, ablation testing, inspection and walkthroughs, auto-regressive testing. Each of these methods specifies a strategy for generating and evaluating test cases to judge various aspects of quality of program. <p> It is well known that extensive V&V is essential for developing reliable software. The development of software involves various production activities where opportunities for introducing faults by human mistakes is enormous. It has been observed that software constructed from an unreliable specification requires major resources and cost during V&V <ref> [6] </ref>. The importance of specification Consistency and Completeness (C&C) is well known in software engineering. Design and construction of software specification is a highly iterative process. Because the specification for software is written by humans it is bound to contain gaps and contradictions. <p> The presence of data flow anomalies indicate a possible programming error and thus a program if executed may produce incorrect results. From the fault statistics published in <ref> [6] </ref> it is reported that at least 15% of the data related faults (22% of the total faults) are due to different types of data flow anomalies. A program containing data flow anomalies is less reliable than the one which does not contain any data flow anomalies. <p> It is also important to generate test cases to test the robustness of the classes. One way to test the robustness is to generate negative test cases or dirty test cases <ref> [6] </ref>. A negative test case is a test case with invalid data so that the target code can identify and raise exceptions. <p> OO software in a distributed environment, introduces new issues for testing due to concurrency, reliability, administration, and security. (6) Fault Taxonomy for OO paradigm: The fault taxonomy for software is important as it provides several valuable information such as frequency, type of fault, correction cost, installation cost and possible consequences <ref> [6] </ref>. The fault taxonomy available in [6] does not contain new kinds of faults possible in OO paradigm. Further the classification of different kinds of faults may not be applicable in OO paradigm. Therefore the research issue is to identify and classify different kinds of faults possible in OO software. <p> introduces new issues for testing due to concurrency, reliability, administration, and security. (6) Fault Taxonomy for OO paradigm: The fault taxonomy for software is important as it provides several valuable information such as frequency, type of fault, correction cost, installation cost and possible consequences <ref> [6] </ref>. The fault taxonomy available in [6] does not contain new kinds of faults possible in OO paradigm. Further the classification of different kinds of faults may not be applicable in OO paradigm. Therefore the research issue is to identify and classify different kinds of faults possible in OO software.
Reference: [7] <author> R. V. Binder. </author> <title> Design for testability. </title> <journal> CACM, </journal> <volume> 37(9) </volume> <pages> 89-101, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: In [49], authors present an interaction testing technique that allows the tester to incrementally increase the number of interactions for testing. In [2], authors discuss about their experiences with testing of OO programs. In <ref> [7] </ref>, there is a discussion on how to align developmental process with testing so that designs are testable and testing is maximally effective. In [14], authors provide data related to testing of Smalltalk library software.
Reference: [8] <author> R. V. Binder. </author> <title> Testing object-oriented systems: A status report. </title> <journal> American Programmer, </journal> <volume> 7(4) </volume> <pages> 23-28, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: An excellent introduction to multiple interfaces for classes is given in [29]. OO paradigm being a new field, not much research has been done in V&V of OO programs. Majority of the research is in the initial stages of defining the issues related to V&V of OO <ref> [8] </ref>. We can classify the testing related research into (1) introductory and definition of issues in OO 13 testing, (2) Specification based OO testing, (3) Class and Cluster Related testing, (4) Data flow based testing, (5) State based testing, and (6) techniques for managing the testing process.
Reference: [9] <author> B. W. Boehm. </author> <title> The high cost of software. In Ellis Horowitz, editor, Practical Strategies for Developing Large Software Systems. </title> <publisher> Addison-WesleY, </publisher> <year> 1975. </year>
Reference-contexts: It has been studied that Verification and Validation (V&V) related activities consume at least half of the labor to bring out a production quality software <ref> [9, 78] </ref>. In conventional paradigm, statistics show that a software programmed well will still have one to three bugs per hundred statements [75]. This quality of the software is not acceptable in many critical applications such as nuclear reactor control [58], or safety critical systems [53]. <p> Thus, to get a proper understanding, testing, and debugging of the system, tracing of the methods and messages is essential. 1.2 Testing Concepts It has been reported that to bring out a production quality software, testing related activities consume at least half of the labor <ref> [9, 78] </ref>. The primary goal of software testing is to ensure that the end product under investigation is in conformance with the product from which the end product was built. In this section, we introduce various concepts in testing and discuss with respect to OO paradigm.
Reference: [10] <author> B. W. Boehm. </author> <title> Verifying and validating software requirement specifications and design specification. </title> <journal> IEEE Software, </journal> <volume> 1 </volume> <pages> 61-72, </pages> <year> 1984. </year>
Reference-contexts: Validation refers to those activities that ensure that the current stage in software development is correctly built with respect to the original requirements. A specification is complete when all the required components are present and completely developed <ref> [10] </ref>. A specification is consistent if its components does not conflict with each other [10]. <p> A specification is complete when all the required components are present and completely developed <ref> [10] </ref>. A specification is consistent if its components does not conflict with each other [10]. Consistency and Completeness of specification is inter-related and often inconsistency leads to incompleteness and vice-versa. 6 1.2.1 What is Testing? What constitutes "testing" for a software system is closely tied to the paradigm used for its development. <p> For example, one type of binary testing comparison is between a specification (a description of the problem to be solved) and a design document (a description of the functional decomposition, data structures and algorithms) <ref> [10] </ref>. The OO development paradigm can be mapped to Spiral model of software development. Thus, testing in OO paradigm can be similarly defined as a method of establishing a binary relationship between two by-products of the software development such as between analysis and design or between design and implementation.
Reference: [11] <author> B. W. Boehm. </author> <title> A spiral model of software development and enhancement. </title> <journal> IEEE Computer, </journal> <volume> 21(5) </volume> <pages> 61-72, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Development paradigms for conventional software, for example, include several variants of the Waterfall model [65] (e.g., the Spiral model <ref> [11] </ref>). In this class of models, testing (generally referred to as verification and validation [57, 6, 61]) establishes a binary relationship between two by-products of the software development process.
Reference: [12] <author> G. Booch. </author> <title> Object-Oriented Analysis and Design with Applications. </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <address> second edition, </address> <year> 1993. </year>
Reference-contexts: OO paradigm has moved into mainstream software development industry. It is currently being used in variety of applications development starting from system software such as databases, operating systems to application software for banking, billing, service providing and so on <ref> [12, 66] </ref>. Software is inherently complex and this complexity of the software is its fundamental property, not an accidental one. The complexity is due to difficulty in comprehending the problem domain completely, the flexibility in software and difficulty in managing development process [13]. <p> OO software development is based on identifying and modeling the real-world entities as objects. OO paradigm supports abstraction, decomposition, encapsulation, modularity, and hierarchy. Thus OO-based software engineering is seen as an approach for tackling the intricacies and complexities associated with software construction <ref> [51, 12, 47] </ref>. The current research so far in OO software engineering is focussed on problem analysis, software design, and implementation techniques resulting in a potpourri of representations and procedures [51, 12, 18, 19, 47, 54]. <p> Thus OO-based software engineering is seen as an approach for tackling the intricacies and complexities associated with software construction [51, 12, 47]. The current research so far in OO software engineering is focussed on problem analysis, software design, and implementation techniques resulting in a potpourri of representations and procedures <ref> [51, 12, 18, 19, 47, 54] </ref>. OO analysis methods help in identifying and expressing software requirements in the vocabulary of classes and objects found in the problem domain. <p> We first discuss a technique of deriving MtSS of a class from the corresponding state based OO design. We then discuss the derivation of MtSS and MgSS from other well-known dynamic models built during design such as object diagram <ref> [12] </ref>, event trace diagram [66], or use-case diagrams [37]. The importance of specification Consistency and Completeness (C&C) is well-known in software engineering. Inconsistency and incompleteness in sequence specification would lead to faulty verification and therefore, C&C of the specification is essential for developing OO systems with less faults. <p> The MtSS represents the method interactions, i.e. the dynamic interaction between the class instances. We then discuss the deriving of MtSS of a class from the state based OO design. MtSS can also be derived from the dynamic models built during design such as Interaction Diagrams <ref> [12] </ref>, Event Trace Diagrams [66], or Use-Case Diagrams [37]. Definition 2.1 Methods (C): For a class C we define M ethods (C) as a set of all the instance methods defined in C that are publicly available. <p> The commonly used dynamic models are State Transition Diagram (STD), Object Diagram, Event Trace Diagram, and Use-case Diagram. For example, OO Analysis and Design technique from Booch <ref> [12] </ref> prescribes STD, object diagram, and interaction diagram for capturing and modeling the dynamic behavior of the objects. Similarly, Iverson's Use Case diagram captures the dynamic interaction between the objects. <p> Similarly , sequence specification can also be derived from Event diagram. 2.2.1 MtSS from State Transition Diagram Many OO analysis and design techniques propose State Transition Diagrams (STD) for modeling the dynamic behavior of classes <ref> [12, 66, 19, 79] </ref>. STDs can be used to model both inter-class and intra-class dynamic behavior [19]. For deriving MtSS of a class, we use its intra-class STD. <p> The regular expression that can be derived automatically from the STD is: (open deposit (depositjwithdraw) fl close) This regular expression is the MtSS for the class Account. 2.2.2 MtSS from Object Diagram The Object Diagram forms an important notation in Booch's OO analysis and design method <ref> [12] </ref> to show the existence of objects and their relationships. In this section, we describe a set of rules for deriving the MtSS from an Object diagram. An Object diagram represents interactions between class instances. <p> The MtSS and MgSS is used extensively in this thesis for test case generation. 2.3.1 MgSS and MtSS from Interaction Diagram Interaction diagrams are used in many OO analysis and design techniques for representing the interaction between objects <ref> [37, 12] </ref>. In [37], authors use Interaction diagrams for representing the use cases. Use cases are used predominantly for representing the analysis and design information. Interaction diagrams are used to describe how each use case will be implemented by communicating objects. <p> We then extend the rules to check the consistency and completeness in the presence of multiple interfaces to a class. Inheritance relation is used extensively in OO based applications. OO languages support inheritance to model the hierarchical relationship between classes as well as to promote code reuse <ref> [28, 51, 70, 22, 12, 42] </ref>. Inheritance allows a class definition to use the definition of one or more other classes. If a class C 1 directly inherits from another class C 2 , then C 1 is called the child class and C 2 is called the parent class. <p> A program containing data flow anomalies is less reliable than the one which does not contain any data flow anomalies. OO paradigm supports the development of reusable classes <ref> [12, 37] </ref>. Reusable classes are well specified and general enough so that they can be used in variety of applications. A class defines a set of instance and class variables. These variables are used and modified by the methods defined in the class. <p> OO paradigm has moved into mainstream software development industry. It is currently being used in a variety of application development starting from system software such as databases, operating systems to application software such as banking, billing, and service providing <ref> [12, 66] </ref>. The software industry, in general, is moving towards OO paradigm. The current research so far in OO software engineering is focussed on problem analysis, software design, and implementation techniques resulting in a potpourri of representations and procedures.
Reference: [13] <author> F. P. Brooks. </author> <title> No silver bullet, </title> <journal> essence and accidents of software engineering. IEEE Computer, </journal> <volume> 20(4) </volume> <pages> 10-19, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Software is inherently complex and this complexity of the software is its fundamental property, not an accidental one. The complexity is due to difficulty in comprehending the problem domain completely, the flexibility in software and difficulty in managing development process <ref> [13] </ref>. OO software development is based on identifying and modeling the real-world entities as objects. OO paradigm supports abstraction, decomposition, encapsulation, modularity, and hierarchy. Thus OO-based software engineering is seen as an approach for tackling the intricacies and complexities associated with software construction [51, 12, 47].
Reference: [14] <author> T. J. Cheatham and L. Mellinger. </author> <title> Testing object-oriented systems. </title> <booktitle> In Proceedings of the 18Th ACM annual Computer Science Conference, </booktitle> <pages> pages 161-165. </pages> <publisher> ACM Inc., </publisher> <address> New York, </address> <year> 1990. </year> <month> 95 </month>
Reference-contexts: In [2], authors discuss about their experiences with testing of OO programs. In [7], there is a discussion on how to align developmental process with testing so that designs are testable and testing is maximally effective. In <ref> [14] </ref>, authors provide data related to testing of Smalltalk library software. The article in [72] discusses various issues related to data flow anomaly testing at various levels in OO programs. In [73, 32] authors discuss about state-based software testing of OO programs by modeling classes as state machines.
Reference: [15] <author> S. Chidamber and C. Kemerer. </author> <title> Towards a metrics suite for object-oriented design. </title> <booktitle> In OOPSLA, </booktitle> <year> 1991. </year>
Reference-contexts: Issues related to adequate testing of classes is considered in detail in [62]. In [30], there is a discussion on hierarchical incremental testing of classes. In [69], authors discuss about a framework for testing OO programs. In <ref> [15, 16] </ref> authors have provided a set of metrics suite for object-oriented design.
Reference: [16] <author> S. Chidamber and C. Kemerer. </author> <title> A metrics suite for object-oriented design. </title> <type> Technical report, </type> <institution> Sloan School of Management, MIT, </institution> <year> 1993. </year>
Reference-contexts: Issues related to adequate testing of classes is considered in detail in [62]. In [30], there is a discussion on hierarchical incremental testing of classes. In [69], authors discuss about a framework for testing OO programs. In <ref> [15, 16] </ref> authors have provided a set of metrics suite for object-oriented design.
Reference: [17] <author> P. Coad and J. Nicola. </author> <title> Object-Oriented Programming. </title> <publisher> Yourdon Press, </publisher> <year> 1993. </year>
Reference-contexts: Unlike conventional techniques, in OO software life-cycle, several classes can be concurrently analyzed, designed, implemented, and tested. Concurrent development of individual and related classes facilitate better understanding of requirements, alleviates risk, and thus help in dividing the complexity of a problem. It also helps in producing early tangible results <ref> [17] </ref>. In figure 1.3 several threads of software development activities are shown. Each thread corresponds to the development of a class and usually there exists a dependency relation across the threads. <p> Even though in OO paradigm it is possible to concurrently perform analysis, design and implementation of classes, each class is developed sequentially <ref> [17] </ref>. Early C&C of designed classes help in the detection of contradictions and gaps and thus promote reliable implementation. 1.1.5 OO Potential Benefits and Drawbacks From the software engineering life-cycle perspective, it is advocated to design systems that are modular and well encapsulated. <p> difference is that some of the parent methods are not inherited and therefore these methods must not be considered in parent class regular expression when applying the consistency rule. 3.1.4 Feasibility Evaluation The practicality of the MtSS technique was evaluated by using it to specify two OO designs given in <ref> [17] </ref>. In [17], authors provide a detailed OO design and program in SmallTalk and C++ for four projects. We chose the Counter and ATM design projects for representing all the classes in each design using MtSS technique. In figure 3.2 the inheritance hierarchy of Count class is given. <p> that some of the parent methods are not inherited and therefore these methods must not be considered in parent class regular expression when applying the consistency rule. 3.1.4 Feasibility Evaluation The practicality of the MtSS technique was evaluated by using it to specify two OO designs given in <ref> [17] </ref>. In [17], authors provide a detailed OO design and program in SmallTalk and C++ for four projects. We chose the Counter and ATM design projects for representing all the classes in each design using MtSS technique. In figure 3.2 the inheritance hierarchy of Count class is given.
Reference: [18] <author> P. Coad and E. Yourdon. </author> <title> Object-Oriented Analysis. </title> <publisher> Yourdon Press, Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <note> second edition, </note> <year> 1991. </year>
Reference-contexts: Thus OO-based software engineering is seen as an approach for tackling the intricacies and complexities associated with software construction [51, 12, 47]. The current research so far in OO software engineering is focussed on problem analysis, software design, and implementation techniques resulting in a potpourri of representations and procedures <ref> [51, 12, 18, 19, 47, 54] </ref>. OO analysis methods help in identifying and expressing software requirements in the vocabulary of classes and objects found in the problem domain.
Reference: [19] <author> J. M. Drake, W. W. Xie, and W. T. Tsai. </author> <title> Document-driven analysis: Description and formalization. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 33-50, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Thus OO-based software engineering is seen as an approach for tackling the intricacies and complexities associated with software construction [51, 12, 47]. The current research so far in OO software engineering is focussed on problem analysis, software design, and implementation techniques resulting in a potpourri of representations and procedures <ref> [51, 12, 18, 19, 47, 54] </ref>. OO analysis methods help in identifying and expressing software requirements in the vocabulary of classes and objects found in the problem domain. <p> Similarly , sequence specification can also be derived from Event diagram. 2.2.1 MtSS from State Transition Diagram Many OO analysis and design techniques propose State Transition Diagrams (STD) for modeling the dynamic behavior of classes <ref> [12, 66, 19, 79] </ref>. STDs can be used to model both inter-class and intra-class dynamic behavior [19]. For deriving MtSS of a class, we use its intra-class STD. <p> STDs can be used to model both inter-class and intra-class dynamic behavior <ref> [19] </ref>. For deriving MtSS of a class, we use its intra-class STD. The STD model represents all possible states of the class, the events that can cause state transitions, and the actions that result from the state change.
Reference: [20] <author> J. W. Duran and S. C. Ntafos. </author> <title> An evaluation of random testing. </title> <journal> IEEE Transacitons on Software Engineering, </journal> <volume> SE-10(4):438-444, </volume> <year> 1984. </year>
Reference-contexts: In the following we briefly discuss each of the testing techniques. Random testing Random testing [57] generates test inputs randomly from input space. Although traditionally considered a weak method, its ease of generating test inputs and power of detecting failures in small publicized programs have been noticed <ref> [20] </ref>. However, in another study it was found that random testing may not be quite effective on larger programs (or large sample space to select test cases) that are more sensitive to special values [74]. For random testing to be effective it must be easy to generate expected outputs [46].
Reference: [21] <author> M. Dyer. </author> <title> The Cleanroom Approach to Quality Software Development. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1992. </year>
Reference-contexts: Even though the importance of (V&V) is well known, it has commanded little attention in OO paradigm. A sound software engineering practice is to verify and validate everything that is developed. Thus, extensive V&V during software development is essential for building zero-defect software <ref> [21] </ref>. Unfortunately, most of the OO analysis and design techniques proposed to date do not adequately address V&V activities. Currently, most of the V&V 1 activities are ad-hoc. <p> Even though the importance of (V&V) is well known, it has commanded little attention in OO paradigm. A sound software engineering practice is to verify and validate everything that is developed. Thus, extensive V&V during software development is essential for building zero-defect software <ref> [21] </ref>. Unfortunately, most of the OO analysis and design techniques proposed to date do not adequately address V&V activities. Currently, most of the V&V activities are ad-hoc.
Reference: [22] <author> M. Ellis and B. Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: We then extend the rules to check the consistency and completeness in the presence of multiple interfaces to a class. Inheritance relation is used extensively in OO based applications. OO languages support inheritance to model the hierarchical relationship between classes as well as to promote code reuse <ref> [28, 51, 70, 22, 12, 42] </ref>. Inheritance allows a class definition to use the definition of one or more other classes. If a class C 1 directly inherits from another class C 2 , then C 1 is called the child class and C 2 is called the parent class.
Reference: [23] <author> M. E. Fagan. </author> <title> Design and code inspections to reduce errors in program development. </title> <journal> IBM Systems Journal, </journal> <volume> 3 </volume> <pages> 182-211, </pages> <year> 1976. </year>
Reference-contexts: can be expressed in a state based design, then state-based test case generation techniques can be applied to each method for test case generation. * Inspections and Walkthroughs: Inspections and walkthroughs are manual or computer assisted comparison of various software development products such as requirements, design documents, and final code <ref> [23, 48] </ref>. Walkthroughs are done by going through the various execution paths of a program.
Reference: [24] <editor> J. E. Fetzer, editor. </editor> <booktitle> Aspects of Artificial Intelligence, </booktitle> <pages> pages 209-250. </pages> <publisher> Kluwer Academic Publishing, </publisher> <year> 1988. </year>
Reference-contexts: In white-box testing we need to trace paths through the software system in addition to comparing inputs and expected outputs. Usually, there exists a large number of paths through a software system. For example, in MYCIN <ref> [24] </ref> it is estimated that the minimum number of paths is approximately 250,000. Given a legal test case input, the generation of an expected path from the large set of possible paths is not obvious.
Reference: [25] <author> S. P. Fielder. </author> <title> Object-oriented unit testing. </title> <journal> Hewlett-Packard Journal, </journal> <pages> pages 69-74, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: Thus testing of methods on the inheritance hierarchy can be optimized. In [62], it has been demonstrated that many of the well tested parent classes have to be retested in the context of child classes. In <ref> [25] </ref> it is suggested that methods that are inherited from parent classes may require minimal testing if their functionality is not modified in the child classes. In [30], authors discuss about incremental testing of classes. In their technique, initially a base class is tested thoroughly by testing each method.
Reference: [26] <author> L. D. Fosdick and L. J. Osterweil. </author> <title> Data flow analysis in software reliability. </title> <journal> ACM Computing Surveys, </journal> <month> Septmber </month> <year> 1976. </year>
Reference-contexts: We use MtSS in conjunction with the conventional data flow anomaly detection techniques to identify the data flow anomalies in classes. The proposed technique is applicable under different inheritance mechanisms. Data flow analysis used in compiler optimizations [1], has been used for identifying data flow anomalies in procedural programs <ref> [26, 35, 36] </ref>. A data flow anomaly is present when the pattern of variable usage is abnormal in the sense that the usage of variable violates the principles of computation [26]. <p> Data flow analysis used in compiler optimizations [1], has been used for identifying data flow anomalies in procedural programs [26, 35, 36]. A data flow anomaly is present when the pattern of variable usage is abnormal in the sense that the usage of variable violates the principles of computation <ref> [26] </ref>. The presence of data flow anomalies indicate a possible programming error and thus a program if executed may produce incorrect results. <p> In section 5.4 we discuss about data flow anomalies in the presence of inheritance. Then, we conclude this chapter and list out possible future work. 5.1.1 Related Research Data flow anomaly detection in programs written using procedural languages such as FORTRAN and C has been studied in the past <ref> [26, 35, 33, 36] </ref>. In [26], authors define the data flow anomaly problem and provide algorithms adapted from data flow analysis techniques for identifying the data flow anomalies. <p> Then, we conclude this chapter and list out possible future work. 5.1.1 Related Research Data flow anomaly detection in programs written using procedural languages such as FORTRAN and C has been studied in the past [26, 35, 33, 36]. In <ref> [26] </ref>, authors define the data flow anomaly problem and provide algorithms adapted from data flow analysis techniques for identifying the data flow anomalies. The representation of data flow accesses as path expressions and then checking the path expressions for a possible anomaly detection is presented in [26, 35]. <p> In [26], authors define the data flow anomaly problem and provide algorithms adapted from data flow analysis techniques for identifying the data flow anomalies. The representation of data flow accesses as path expressions and then checking the path expressions for a possible anomaly detection is presented in <ref> [26, 35] </ref>. In [36], authors identify a flaw in the algorithm given in [26] and provide an efficient and easy to implement algorithm for identifying the data flow anomalies. Recently, [72] discusses various issues related to data flow anomaly testing at various levels in OO programs. <p> The representation of data flow accesses as path expressions and then checking the path expressions for a possible anomaly detection is presented in [26, 35]. In [36], authors identify a flaw in the algorithm given in <ref> [26] </ref> and provide an efficient and easy to implement algorithm for identifying the data flow anomalies. Recently, [72] discusses various issues related to data flow anomaly testing at various levels in OO programs. Several issues related to V&V and maintenance of object-oriented programs are given in [68]. <p> In the above example, the variable err in line 8 is referenced before its value is initialized. 5.2.2 Anomaly Detection in Conventional Programs The data flow anomaly detection techniques described in <ref> [26, 36] </ref> are based on the static analysis of the control flow of a program. The techniques initially represent the program statements as a control flow graph and then the graph is analyzed for various data flow anomalies. The techniques identify the anomalies in linear time. <p> In the following we briefly describe the data flow anomaly detection technique <ref> [26, 36] </ref> that use path expressions. Let, G (N; E; n 0 ; n e ) represent a flow graph where N is the set of nodes, E is the set of edges, n 0 is the unique entry node 2 N and n e is the unique exit node. <p> The path expressions at each node of a program can be efficiently computed using the data flow analysis and code optimization algorithms of LIVE, AVAIL, and REACH. These algorithms are well studied and known in compiler literature [1]. The paper from <ref> [26] </ref> describes a technique for determining the path expressions using these algorithms. An improved and efficient algorithm is given in [36] for computing the path expressions.
Reference: [27] <author> P. G. Frankl and R. Doong. </author> <title> Tools for testing object-oriented programs. </title> <booktitle> In Proceedings of the Pacific Northwest Software Quality Conference, </booktitle> <pages> pages 309-324, </pages> <year> 1990. </year>
Reference-contexts: Several issues related to V&V and maintenance of object-oriented programs are given in [68, 41]. A class testing using the algebraic specifications of the classes is discussed in <ref> [27] </ref>. In [67], authors use assertion definition language (ADL) for class interface testing. Test case generation from OO analysis and design products of OMT is discussed in [63]. OO integration testing using message-method pairs is discussed in [38].
Reference: [28] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: We then extend the rules to check the consistency and completeness in the presence of multiple interfaces to a class. Inheritance relation is used extensively in OO based applications. OO languages support inheritance to model the hierarchical relationship between classes as well as to promote code reuse <ref> [28, 51, 70, 22, 12, 42] </ref>. Inheritance allows a class definition to use the definition of one or more other classes. If a class C 1 directly inherits from another class C 2 , then C 1 is called the child class and C 2 is called the parent class. <p> For example, a test sequence generated from the partition 6.4.13 is, P artitionT estCase3 ) open setupAccnt deposit withdraw creditLimit withdraw close (6.4.16) C. Category Based Partitioning: The methods of a class can also be partitioned to several categories depending on the operations they perform. In Smalltalk <ref> [28] </ref>, class and instance methods are divided into several categories for the purpose of easy understanding and grouping. One can use the same partition to generate test method sequences. In category based partition scheme, one has to write the MtSS at the category level rather than individual method level.
Reference: [29] <author> B. Hailpern and H. Ossher. </author> <title> Extending objects to support multiple interfaces and access control. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(11) </volume> <pages> 1247-1257, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Meyer, in his research on 'design by contract' provides a rigorous usage of preconditions, post-conditions, and invariants for specifying and implementing methods of a class [51, 52]. An excellent introduction to multiple interfaces for classes is given in <ref> [29] </ref>. OO paradigm being a new field, not much research has been done in V&V of OO programs. Majority of the research is in the initial stages of defining the issues related to V&V of OO [8]. <p> Even though an object defines many external methods, all these methods are not universally available to all the client objects. Thus, for each class, multiple interfaces exporting a subset of methods providing restricted access can be defined <ref> [29, 70] </ref>. Multiple interfaces are useful as they provide additional encapsulation to object structure. Separate subinterfaces to different users facilitates understanding, maintenance, and proper use. Multiple interfaces thus support the concept, separation of concern which is essential for understanding complex software. Multiple subinterfaces provide a well guarded access control.
Reference: [30] <author> M. J. Harrold, J. D. McGregor, and K. J. Fitzpatrick. </author> <title> Incremental testing of object-oriented class structures. </title> <booktitle> In International Conference on Software Engineering, </booktitle> <pages> pages 68-80. </pages> <publisher> ACM Inc., </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: In [73, 32] authors discuss about state-based software testing of OO programs by modeling classes as state machines. Issues related to adequate testing of classes is considered in detail in [62]. In <ref> [30] </ref>, there is a discussion on hierarchical incremental testing of classes. In [69], authors discuss about a framework for testing OO programs. In [15, 16] authors have provided a set of metrics suite for object-oriented design. <p> In [25] it is suggested that methods that are inherited from parent classes may require minimal testing if their functionality is not modified in the child classes. In <ref> [30] </ref>, authors discuss about incremental testing of classes. In their technique, initially a base class is tested thoroughly by testing each method. The test case design and test case execution information is saved along with the base class.
Reference: [31] <author> M. S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: Thus the goal of dependency analysis is to determine the actual sequence in which the methods of an object are invoked. To determine the use sequences at each object, control flow analysis <ref> [31, 44] </ref> of the OO program is essential. Specifically, for a given OO program and a starting method, if a method invocation tree can be generated, then one can generate use sequences from the the method invocation tree.
Reference: [32] <author> D. M. Hoffman and P. A. Strooper. </author> <title> A case study in class testing. </title> <booktitle> In Proceedings of CASCON-93, </booktitle> <pages> pages 472-482. </pages> <institution> IBM Toronto, </institution> <year> 1993. </year> <month> 96 </month>
Reference-contexts: In [14], authors provide data related to testing of Smalltalk library software. The article in [72] discusses various issues related to data flow anomaly testing at various levels in OO programs. In <ref> [73, 32] </ref> authors discuss about state-based software testing of OO programs by modeling classes as state machines. Issues related to adequate testing of classes is considered in detail in [62]. In [30], there is a discussion on hierarchical incremental testing of classes.
Reference: [33] <author> L. H. Holley and B. K. Rosen. </author> <title> Qualified data flow problems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-7:60-78, </volume> <month> Jan </month> <year> 1981. </year>
Reference-contexts: In section 5.4 we discuss about data flow anomalies in the presence of inheritance. Then, we conclude this chapter and list out possible future work. 5.1.1 Related Research Data flow anomaly detection in programs written using procedural languages such as FORTRAN and C has been studied in the past <ref> [26, 35, 33, 36] </ref>. In [26], authors define the data flow anomaly problem and provide algorithms adapted from data flow analysis techniques for identifying the data flow anomalies.
Reference: [34] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1979. </year>
Reference-contexts: Construction of regular definitions that accepts the same language as that of an STD is well studied in literature. Several efficient algorithms exists for deriving the regular expression from the STD (see theorem 2.4, page 33 of <ref> [34] </ref>). As STDs are constructed for each class during analysis and design phases, these STDs can be used for generating the sequence specification of the class. Because the efficient algorithms are available, an easy tool support can be provided for deriving a method sequence specification of a class. <p> All the consistency checking rules use the equality boolean operator to verify the consistency between two regular expressions. The equality between two regular expressions can be expressed as a decision algorithm on the regular sets of each these regular expressions. In <ref> [34] </ref>, an efficient algorithm is presented for verifying whether one regular expression is the same as the other. Each regular expression defines a Finite Automata (FA). A FA accepts a set of strings and all the acceptable strings form the language defined by the FA. <p> If D 1 represents an empty regular set, then L 1 = L 2 . Efficient methods and proofs for constructing intersection and complement operators are provided in <ref> [34] </ref>. 3.4 C&C of MgSS In the last section, we have discussed about C&C of MtSS in the presence of inheritance and multiple interfaces. In this section we discuss about various C&C rules associated with MgSS. MgSS is specified for each method in a class that interacts with other classes. <p> The verification of use sequences with respect to the MtSS is similarly to checking whether a string is part of a regular definition. This algorithm to check whether a string is part of a regular set is well known <ref> [34] </ref> and can be easily implemented. Objects when they are created during run-time, maintain link to its class. The class maintains the method dictionary for all its instances. The method dictionary contains the name of the method and the address of the executable binary code.
Reference: [35] <author> J. C. Huang. </author> <title> Detection of data flow anomaly through program instrumentation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-5:226-236, </volume> <month> May </month> <year> 1979. </year>
Reference-contexts: We use MtSS in conjunction with the conventional data flow anomaly detection techniques to identify the data flow anomalies in classes. The proposed technique is applicable under different inheritance mechanisms. Data flow analysis used in compiler optimizations [1], has been used for identifying data flow anomalies in procedural programs <ref> [26, 35, 36] </ref>. A data flow anomaly is present when the pattern of variable usage is abnormal in the sense that the usage of variable violates the principles of computation [26]. <p> In section 5.4 we discuss about data flow anomalies in the presence of inheritance. Then, we conclude this chapter and list out possible future work. 5.1.1 Related Research Data flow anomaly detection in programs written using procedural languages such as FORTRAN and C has been studied in the past <ref> [26, 35, 33, 36] </ref>. In [26], authors define the data flow anomaly problem and provide algorithms adapted from data flow analysis techniques for identifying the data flow anomalies. <p> In [26], authors define the data flow anomaly problem and provide algorithms adapted from data flow analysis techniques for identifying the data flow anomalies. The representation of data flow accesses as path expressions and then checking the path expressions for a possible anomaly detection is presented in <ref> [26, 35] </ref>. In [36], authors identify a flaw in the algorithm given in [26] and provide an efficient and easy to implement algorithm for identifying the data flow anomalies. Recently, [72] discusses various issues related to data flow anomaly testing at various levels in OO programs. <p> The nodes n 1 and n 2 does not read or modify any variables. A? The regular expression operator '?' indicates that a method can be repeatedly invoked (possibly 0 times). In <ref> [35] </ref> it has been shown that for data flow analysis purposes for every 'A?' in a regular expression, one can substitute with '(1 j (A A))' without any changes in the number of data flow anomalies. <p> While constructing the control flow graph, this theorem is used and the equivalent control flow graph for '?' is shown in figure 5.3. A+ The regular expression operator '+' indicates that a method can be executed repeatedly but at least one time. Extending the theorem from <ref> [35] </ref>, the regular expression 'A+' can be converted to '(A j (A A))' for data flow analysis purposes. The control flow graph equivalent to 'A+' is shown in figure 5.3. A sequence specification can contain several methods connected through these various regular expression operators. <p> Using the Huang's theorem <ref> [35] </ref>, in equation 5.3.11, the regular expression '?' operator is reduced. In equation 5.3.12, the exponentiation is expanded using the equation (A j B) 2 = (A A) j (A B) j (B A) j (B B). We use the equation 5.3.12 for converting it to control flow graph.
Reference: [36] <author> J. Jachner and V. K. Agarwal. </author> <title> Data flow anomaly detection. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):432-437, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: We use MtSS in conjunction with the conventional data flow anomaly detection techniques to identify the data flow anomalies in classes. The proposed technique is applicable under different inheritance mechanisms. Data flow analysis used in compiler optimizations [1], has been used for identifying data flow anomalies in procedural programs <ref> [26, 35, 36] </ref>. A data flow anomaly is present when the pattern of variable usage is abnormal in the sense that the usage of variable violates the principles of computation [26]. <p> In section 5.4 we discuss about data flow anomalies in the presence of inheritance. Then, we conclude this chapter and list out possible future work. 5.1.1 Related Research Data flow anomaly detection in programs written using procedural languages such as FORTRAN and C has been studied in the past <ref> [26, 35, 33, 36] </ref>. In [26], authors define the data flow anomaly problem and provide algorithms adapted from data flow analysis techniques for identifying the data flow anomalies. <p> The representation of data flow accesses as path expressions and then checking the path expressions for a possible anomaly detection is presented in [26, 35]. In <ref> [36] </ref>, authors identify a flaw in the algorithm given in [26] and provide an efficient and easy to implement algorithm for identifying the data flow anomalies. Recently, [72] discusses various issues related to data flow anomaly testing at various levels in OO programs. <p> In the above example, the variable err in line 8 is referenced before its value is initialized. 5.2.2 Anomaly Detection in Conventional Programs The data flow anomaly detection techniques described in <ref> [26, 36] </ref> are based on the static analysis of the control flow of a program. The techniques initially represent the program statements as a control flow graph and then the graph is analyzed for various data flow anomalies. The techniques identify the anomalies in linear time. <p> In the following we briefly describe the data flow anomaly detection technique <ref> [26, 36] </ref> that use path expressions. Let, G (N; E; n 0 ; n e ) represent a flow graph where N is the set of nodes, E is the set of edges, n 0 is the unique entry node 2 N and n e is the unique exit node. <p> These algorithms are well studied and known in compiler literature [1]. The paper from [26] describes a technique for determining the path expressions using these algorithms. An improved and efficient algorithm is given in <ref> [36] </ref> for computing the path expressions.
Reference: [37] <author> I. Jacobson, M. Christerson, P. Jonsson, and G. Overgaard. </author> <title> Object-Oriented Software Engineering. </title> <publisher> Addison-Wesley Publishing, </publisher> <address> Workingham, England, </address> <year> 1992. </year>
Reference-contexts: We first discuss a technique of deriving MtSS of a class from the corresponding state based OO design. We then discuss the derivation of MtSS and MgSS from other well-known dynamic models built during design such as object diagram [12], event trace diagram [66], or use-case diagrams <ref> [37] </ref>. The importance of specification Consistency and Completeness (C&C) is well-known in software engineering. Inconsistency and incompleteness in sequence specification would lead to faulty verification and therefore, C&C of the specification is essential for developing OO systems with less faults. <p> We then discuss the deriving of MtSS of a class from the state based OO design. MtSS can also be derived from the dynamic models built during design such as Interaction Diagrams [12], Event Trace Diagrams [66], or Use-Case Diagrams <ref> [37] </ref>. Definition 2.1 Methods (C): For a class C we define M ethods (C) as a set of all the instance methods defined in C that are publicly available. <p> The MtSS and MgSS is used extensively in this thesis for test case generation. 2.3.1 MgSS and MtSS from Interaction Diagram Interaction diagrams are used in many OO analysis and design techniques for representing the interaction between objects <ref> [37, 12] </ref>. In [37], authors use Interaction diagrams for representing the use cases. Use cases are used predominantly for representing the analysis and design information. Interaction diagrams are used to describe how each use case will be implemented by communicating objects. <p> The MtSS and MgSS is used extensively in this thesis for test case generation. 2.3.1 MgSS and MtSS from Interaction Diagram Interaction diagrams are used in many OO analysis and design techniques for representing the interaction between objects [37, 12]. In <ref> [37] </ref>, authors use Interaction diagrams for representing the use cases. Use cases are used predominantly for representing the analysis and design information. Interaction diagrams are used to describe how each use case will be implemented by communicating objects. In this chapter we use the Interaction diagrams as given in [37] and <p> In <ref> [37] </ref>, authors use Interaction diagrams for representing the use cases. Use cases are used predominantly for representing the analysis and design information. Interaction diagrams are used to describe how each use case will be implemented by communicating objects. In this chapter we use the Interaction diagrams as given in [37] and provide an outline for deriving MgSS and MtSS. Interaction diagram Interaction diagrams are used to describe how an use case can be realized through communicating objects. The interactions take place when objects send messages (stimuli) between them. <p> A program containing data flow anomalies is less reliable than the one which does not contain any data flow anomalies. OO paradigm supports the development of reusable classes <ref> [12, 37] </ref>. Reusable classes are well specified and general enough so that they can be used in variety of applications. A class defines a set of instance and class variables. These variables are used and modified by the methods defined in the class. <p> It is also possible to derive the sequence specification from OO analysis and design products. We have first discussed a technique of deriving MtSS of a class from the corresponding state based OO design. We have then discussed the derivation of MgSS from Use-case diagrams <ref> [37] </ref>. The mapping from these dynamic models to sequence specification is well-defined and most of the derivation can be automated. The importance of specification Consistency and Completeness (C&C) is well-known in software engineering.
Reference: [38] <author> P. C. Jorgenson and C. Erickson. </author> <title> Object-oriented integration testing. </title> <journal> CACM, </journal> <volume> 37(9) </volume> <pages> 30-38, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: In [67], authors use assertion definition language (ADL) for class interface testing. Test case generation from OO analysis and design products of OMT is discussed in [63]. OO integration testing using message-method pairs is discussed in <ref> [38] </ref>. However, in this article authors do not discuss about test case generation and criteria of selecting message-method pairs from the all possible pairs. In [55], there is a discussion on cluster and class testing. In this article, authors discuss about test case management and execution using a scripting language.
Reference: [39] <author> T. F. Keefe, W. T. Tsai, and M. B. Thuraisingham. </author> <title> Soda: A secure object-oriented database system. </title> <journal> Computers and Security, </journal> <volume> 8(6) </volume> <pages> 517-533, </pages> <year> 1989. </year>
Reference-contexts: Multiple interfaces also provide support for implementing trusted users, and for implementing security levels and users in programs such as operating systems <ref> [39] </ref>. An object may support multiple methods and only subset of these methods may be a part of a subinterface to a client. Some of the methods can also be shared in more than one subinterfaces.
Reference: [40] <author> S. Kirani. </author> <title> Specification and Verification of Object-Oriented Programs. </title> <type> PhD thesis, </type> <institution> University of Minnesota, </institution> <month> December </month> <year> 1994. </year>
Reference: [41] <author> S. Kirani, I. A. Zualkernan, and W. T. Tsai. </author> <title> Evaluation of expert system testing methods. </title> <journal> Communications of the ACM, </journal> <pages> pages 71-81, </pages> <month> november </month> <year> 1994. </year>
Reference-contexts: Several issues related to V&V and maintenance of object-oriented programs are given in <ref> [68, 41] </ref>. A class testing using the algebraic specifications of the classes is discussed in [27]. In [67], authors use assertion definition language (ADL) for class interface testing. Test case generation from OO analysis and design products of OMT is discussed in [63]. <p> Random testing is found to be effective during initial stages of testing, where the fault space is large enough for adequate random sampling <ref> [41] </ref>. 61 A class usually consists of several methods. The MtSS of the class captures the causal order in which the methods can get executed.
Reference: [42] <author> H. J. Lee and W. T. Tsai. </author> <title> A new partial inheritance mechanism and its applications. </title> <type> Technical Report TR:92-17, </type> <institution> University of Minnesota, Computer Science Department, Minneapolis, MN-55455, </institution> <year> 1992. </year>
Reference-contexts: We then extend the rules to check the consistency and completeness in the presence of multiple interfaces to a class. Inheritance relation is used extensively in OO based applications. OO languages support inheritance to model the hierarchical relationship between classes as well as to promote code reuse <ref> [28, 51, 70, 22, 12, 42] </ref>. Inheritance allows a class definition to use the definition of one or more other classes. If a class C 1 directly inherits from another class C 2 , then C 1 is called the child class and C 2 is called the parent class. <p> If inheritance is used for implementation, then the child class may not inherit all the methods from the parent class, and may modify the semantics of the inherited methods <ref> [70, 42] </ref>. In this thesis, we propose a set of C&C rules for consistency checking of MtSS of classes for each type of inheritance. Let C 1 ; C 2 ; : : : C k be a set of classes that are related to one another through inheritance relationship. <p> The child class, in addition to inherited methods, can further enhance the class with additional operations or change the implementation of inherited methods <ref> [70, 51, 42] </ref>. Inheritance can be used for specialization, refinement as well as for implementation (reuse) purposes [51, 70]. If inheritance is used for specialization, then the child class conforms to the semantics of all the inherited methods from the parent class. <p> If inheritance is used for implementation, then the child class may not inherit all the methods from the parent class, and may modify the semantics of the inherited methods <ref> [70, 42] </ref>. Inheritance is used commonly in OO systems. Further, the depth of inheritance hierarchy can be deep for large systems. The child classes in the inheritance hierarchy usually specialize or refine the parent classes.
Reference: [43] <author> Y. Levendel. </author> <title> Improving quality with a manufacturing process. </title> <journal> IEEE Software, </journal> <pages> pages 65-79, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: Because it is not possible to exhaustively test such a space, only a small portion of the test cases has to be tested. One method for estimating an appropriate number of test cases at AT&T is given in <ref> [43] </ref>. <p> P s , the pass-rate is recomputed after running each test case. The crossing point of P + s and P t determines the number of test cases required for achieving the required quality of testing. The techniques reported in <ref> [43] </ref> assume that test samples are homogeneous and test results follow a binomial distribution. It is not clear that any software can completely satisfy these assumptions.
Reference: [44] <author> M. Lijter, S. Meyers, and S. P. Reiss. </author> <title> Support for maintaining object oriented programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(12) </volume> <pages> 1045-1052, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Thus the goal of dependency analysis is to determine the actual sequence in which the methods of an object are invoked. To determine the use sequences at each object, control flow analysis <ref> [31, 44] </ref> of the OO program is essential. Specifically, for a given OO program and a starting method, if a method invocation tree can be generated, then one can generate use sequences from the the method invocation tree. <p> Control flow analysis of the procedural programs has been well studied. However, the control flow analysis for OO programs may require modifications to identify all possible method use sequences for each object. The presence of pointers, polymorphism, dynamic typing, and dynamic binding complicates the control flow analysis. In <ref> [44] </ref>, authors have discussed about generating cross-reference information about method-message pairs in C++. Thus, MtSS of a class can be used for verifying the consistency of the implementation of the class against the specification.
Reference: [45] <author> S. B. Lippman. </author> <title> C++ Primer. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> second edition, </address> <year> 1991. </year>
Reference-contexts: The define type methods change object state by modifying the attribute contents. The use type methods (also known as implementor methods) access the current values of attributes. The define-use type method uses as well as changes the contents of attributes <ref> [45] </ref>. The objects in a system are created during execution time. 1.1.2 Class Classes describe a common behavior of a group of unique objects. A class is a static description of a set of objects. A class describes all the instance methods and attributes. <p> Thus inheritance for implementation promotes reuse of previously developed code. Several languages such as C++ and CommonObjects support for excluding methods of parent class in child class <ref> [45, 70] </ref>. The rule that checks the consistency between parent and child class remain similar to the one described in section 3.1.1. <p> Some new methods can be added in the child class. Thus inheritance for implementation promotes reuse of previously developed code. Several languages such as C++ and CommonObjects support for excluding methods of parent class in child class <ref> [45, 70] </ref>. For data flow anomaly testing, because some of the methods are not inherited in the child class, the path expressions for those methods that appear later in sequence specification change.
Reference: [46] <author> P. S. Loo, W. T. Tsai, and W. K. Tsai. </author> <title> Random testing revisited. </title> <journal> Information and Software Technology, </journal> <volume> 30(7) </volume> <pages> 402-417, </pages> <year> 1989. </year>
Reference-contexts: However, in another study it was found that random testing may not be quite effective on larger programs (or large sample space to select test cases) that are more sensitive to special values [74]. For random testing to be effective it must be easy to generate expected outputs <ref> [46] </ref>. Furthermore, random testing works well on programs whose fault-prone regions (input regions that result in failures) of the input space are large enough for adequate random sampling. Random testing is also useful during early stages of software development when system contains many undetected faults. <p> Although, traditionally random testing is considered a weak method, its ease of generating test inputs and power of detecting failures in publicized programs have been noticed <ref> [46] </ref>. Random testing is found to be effective during initial stages of testing, where the fault space is large enough for adequate random sampling [41]. 61 A class usually consists of several methods. The MtSS of the class captures the causal order in which the methods can get executed.
Reference: [47] <author> J. Martin. </author> <title> Principles of Object-Oriented Analysis and Design. </title> <publisher> P T R Prentice Hall, </publisher> <year> 1993. </year>
Reference-contexts: OO software development is based on identifying and modeling the real-world entities as objects. OO paradigm supports abstraction, decomposition, encapsulation, modularity, and hierarchy. Thus OO-based software engineering is seen as an approach for tackling the intricacies and complexities associated with software construction <ref> [51, 12, 47] </ref>. The current research so far in OO software engineering is focussed on problem analysis, software design, and implementation techniques resulting in a potpourri of representations and procedures [51, 12, 18, 19, 47, 54]. <p> Thus OO-based software engineering is seen as an approach for tackling the intricacies and complexities associated with software construction [51, 12, 47]. The current research so far in OO software engineering is focussed on problem analysis, software design, and implementation techniques resulting in a potpourri of representations and procedures <ref> [51, 12, 18, 19, 47, 54] </ref>. OO analysis methods help in identifying and expressing software requirements in the vocabulary of classes and objects found in the problem domain.
Reference: [48] <author> J. Martin and W. T. Tsai. </author> <title> N-Fold inspection: A requirement analysis technique. </title> <journal> Communications of ACM, </journal> <volume> 33(2) </volume> <pages> 225-232, </pages> <year> 1989. </year>
Reference-contexts: can be expressed in a state based design, then state-based test case generation techniques can be applied to each method for test case generation. * Inspections and Walkthroughs: Inspections and walkthroughs are manual or computer assisted comparison of various software development products such as requirements, design documents, and final code <ref> [23, 48] </ref>. Walkthroughs are done by going through the various execution paths of a program.
Reference: [49] <author> R. McDaniel and J. D. McGregor. </author> <title> Testing the polymorphic interactions of classes. </title> <type> Technical Report TR:94-103, </type> <institution> Clemson University, </institution> <year> 1994. </year>
Reference-contexts: In [55], there is a discussion on cluster and class testing. In this article, authors discuss about test case management and execution using a scripting language. In [50], authors have presented an integrated testing of OO programs with the software development process. In <ref> [49] </ref>, authors present an interaction testing technique that allows the tester to incrementally increase the number of interactions for testing. In [2], authors discuss about their experiences with testing of OO programs.
Reference: [50] <author> J. D. McGregor and T. D. Korson. </author> <title> Integrating object-oriented testing and development processes. </title> <journal> CACM, </journal> <volume> 37(9) </volume> <pages> 59-77, </pages> <month> September </month> <year> 1994. </year> <month> 97 </month>
Reference-contexts: In [55], there is a discussion on cluster and class testing. In this article, authors discuss about test case management and execution using a scripting language. In <ref> [50] </ref>, authors have presented an integrated testing of OO programs with the software development process. In [49], authors present an interaction testing technique that allows the tester to incrementally increase the number of interactions for testing. In [2], authors discuss about their experiences with testing of OO programs.
Reference: [51] <author> B. Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall International, </publisher> <year> 1988. </year>
Reference-contexts: OO software development is based on identifying and modeling the real-world entities as objects. OO paradigm supports abstraction, decomposition, encapsulation, modularity, and hierarchy. Thus OO-based software engineering is seen as an approach for tackling the intricacies and complexities associated with software construction <ref> [51, 12, 47] </ref>. The current research so far in OO software engineering is focussed on problem analysis, software design, and implementation techniques resulting in a potpourri of representations and procedures [51, 12, 18, 19, 47, 54]. <p> Thus OO-based software engineering is seen as an approach for tackling the intricacies and complexities associated with software construction [51, 12, 47]. The current research so far in OO software engineering is focussed on problem analysis, software design, and implementation techniques resulting in a potpourri of representations and procedures <ref> [51, 12, 18, 19, 47, 54] </ref>. OO analysis methods help in identifying and expressing software requirements in the vocabulary of classes and objects found in the problem domain. <p> But, none of these proposed techniques explicitly address the V&V related issues in analysis, design, and implementation. Meyer, in his research on 'design by contract' provides a rigorous usage of preconditions, post-conditions, and invariants for specifying and implementing methods of a class <ref> [51, 52] </ref>. An excellent introduction to multiple interfaces for classes is given in [29]. OO paradigm being a new field, not much research has been done in V&V of OO programs. Majority of the research is in the initial stages of defining the issues related to V&V of OO [8]. <p> We then extend the rules to check the consistency and completeness in the presence of multiple interfaces to a class. Inheritance relation is used extensively in OO based applications. OO languages support inheritance to model the hierarchical relationship between classes as well as to promote code reuse <ref> [28, 51, 70, 22, 12, 42] </ref>. Inheritance allows a class definition to use the definition of one or more other classes. If a class C 1 directly inherits from another class C 2 , then C 1 is called the child class and C 2 is called the parent class. <p> A child class, in addition to inherited methods, can further enhance the class with additional operations or change the implementation of inherited methods <ref> [70, 51] </ref>. Inheritance can be used for specialization, refinement, and implementation (reuse) [51, 70]. If inheritance is used for specialization, then the child class satisfies the semantics of all the inherited methods from the parent class 1 . A child class may be extended with additional methods and instance variables. <p> A child class, in addition to inherited methods, can further enhance the class with additional operations or change the implementation of inherited methods [70, 51]. Inheritance can be used for specialization, refinement, and implementation (reuse) <ref> [51, 70] </ref>. If inheritance is used for specialization, then the child class satisfies the semantics of all the inherited methods from the parent class 1 . A child class may be extended with additional methods and instance variables. <p> Thus, a child class does not modify the semantics of the inherited methods and obeys the inherited methods protocol. In Eiffel, the specialization inheritance can be ensured with the help of pre-conditions and post-conditions for the parent class methods <ref> [51] </ref>. If inheritance is used for refinement of the parent class, then the child class may modify the semantics of the inherited methods. <p> The child class, in addition to inherited methods, can further enhance the class with additional operations or change the implementation of inherited methods <ref> [70, 51, 42] </ref>. Inheritance can be used for specialization, refinement as well as for implementation (reuse) purposes [51, 70]. If inheritance is used for specialization, then the child class conforms to the semantics of all the inherited methods from the parent class. <p> The child class, in addition to inherited methods, can further enhance the class with additional operations or change the implementation of inherited methods [70, 51, 42]. Inheritance can be used for specialization, refinement as well as for implementation (reuse) purposes <ref> [51, 70] </ref>. If inheritance is used for specialization, then the child class conforms to the semantics of all the inherited methods from the parent class. The child class may extend the class with additional methods. <p> The child class may extend the class with additional methods. Thus, the child class does not modify the semantics of the inherited methods and obeys the inherited methods protocol. In Eiffel, the specialization inheritance can be ensured with the help of pre-conditions and post-conditions for the parent class methods <ref> [51] </ref>. If inheritance is used for refinement of the parent class, then the child class may modify the semantics of the inherited methods.
Reference: [52] <author> B. Meyer. </author> <title> Applying design by contract. </title> <booktitle> COMPUTER, </booktitle> <pages> pages 40-51, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: But, none of these proposed techniques explicitly address the V&V related issues in analysis, design, and implementation. Meyer, in his research on 'design by contract' provides a rigorous usage of preconditions, post-conditions, and invariants for specifying and implementing methods of a class <ref> [51, 52] </ref>. An excellent introduction to multiple interfaces for classes is given in [29]. OO paradigm being a new field, not much research has been done in V&V of OO programs. Majority of the research is in the initial stages of defining the issues related to V&V of OO [8]. <p> The MtSS and MgSS model the dynamic behavior of the objects in a system. Many OOAD techniques strive to separate the implementation details of a system from the specification. In "Design by Contract" technique, the output of OOAD is a contract between designers and implementors <ref> [52] </ref>. Another OOAD technique based on responsibilities also suggests using responsibilities as a contract of the specification of publicly available services [77]. The contract specification and separation of the specification from the implementation is useful in several ways.
Reference: [53] <author> R. Mojdehbakhsh, W. T. Tsai, S. Kirani, and L. Elliott. </author> <title> Retrofitting software safety in an implantable medical device. </title> <journal> IEEE Software, </journal> <pages> pages 41-50, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: In conventional paradigm, statistics show that a software programmed well will still have one to three bugs per hundred statements [75]. This quality of the software is not acceptable in many critical applications such as nuclear reactor control [58], or safety critical systems <ref> [53] </ref>. Even though the importance of (V&V) is well known, it has commanded little attention in OO paradigm. A sound software engineering practice is to verify and validate everything that is developed. Thus, extensive V&V during software development is essential for building zero-defect software [21]. <p> In this thesis, we propose a run-time verification system that checks for the consistency of messages received at each object with respect to its sequence specification and flags out out-of-sequence messages. A support for run-time verification is very essential in safety-critical systems <ref> [53] </ref>. Research in V&V of OO systems will continue to introduce new testing techniques for OO systems. These testing techniques vary in their effectiveness, robustness, and cost. In this thesis, we propose a testing technique evaluation methodology based on life cycle mutation testing. <p> For dynamically typed languages such as SmallTalk, it may be impossible to derive all the use sequences from the program. If all use sequences are not identified and compared for its compliance against the MtSS, then there may be some inconsistencies left out in the program. For safety-critical systems <ref> [53] </ref> it may be necessary to identify all such inconsistencies in using the methods of an object, either at compile time or during execution. The run-time verification system proposed in this chapter helps in identifying such incorrect method invocations. During execution, each object receives a message from client objects. <p> In this thesis, we have proposed a run-time verification system that checks for the consistency of messages received at each object with respect to its sequence specification and flags out out-of-sequence messages. This kind of run-time verification is very essential in safety-critical systems <ref> [53] </ref>. The run-time verification system maintains the sequence specification as a part of the class structure. All the class instances keep track of the messages they receive and compare against the sequence specification to ensure that the objects are receiving the methods in correct order.
Reference: [54] <author> D. E. Monarchi and G. I. Puhr. </author> <title> A research typology for object-oriented analysis and design. </title> <journal> Communications of the ACM, </journal> <volume> 35(9) </volume> <pages> 35-47, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Thus OO-based software engineering is seen as an approach for tackling the intricacies and complexities associated with software construction [51, 12, 47]. The current research so far in OO software engineering is focussed on problem analysis, software design, and implementation techniques resulting in a potpourri of representations and procedures <ref> [51, 12, 18, 19, 47, 54] </ref>. OO analysis methods help in identifying and expressing software requirements in the vocabulary of classes and objects found in the problem domain. <p> A recent survey article <ref> [54] </ref> mentions more than twenty OO analysis and design techniques. The survey article provides a comparative evaluation of these techniques. But, none of these proposed techniques explicitly address the V&V related issues in analysis, design, and implementation.
Reference: [55] <author> G. C. Murphy, P. Townsend, and P. S. Wong. </author> <title> Experiences with cluster and class testing. </title> <journal> CACM, </journal> <volume> 37(9) </volume> <pages> 39-47, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Test case generation from OO analysis and design products of OMT is discussed in [63]. OO integration testing using message-method pairs is discussed in [38]. However, in this article authors do not discuss about test case generation and criteria of selecting message-method pairs from the all possible pairs. In <ref> [55] </ref>, there is a discussion on cluster and class testing. In this article, authors discuss about test case management and execution using a scripting language. In [50], authors have presented an integrated testing of OO programs with the software development process.
Reference: [56] <author> J. Musa, A. Iannino, and K. Okumoto. </author> <title> Software Reliability: Measurement, Prediction, Application. </title> <publisher> McGraw-Hill, </publisher> <address> New York, New York, </address> <year> 1987. </year>
Reference-contexts: In this paper we adopt the IEEE standard terminology of error, fault, and failure. According to this terminology errors represent human mistakes which can result in faults in a system. The execution of a faulty system produces failures <ref> [56] </ref>. A fault (or commonly referred to as bug) may cause a system to fail on multiple inputs, but each failure can potentially lead to the discovery of a new fault. Thus, multiple failures of a system do not necessarily imply that the system has multiple faults.
Reference: [57] <author> G. Myers. </author> <title> The Art of Software Testing. </title> <publisher> Prentice Hall, </publisher> <year> 1979. </year>
Reference-contexts: Development paradigms for conventional software, for example, include several variants of the Waterfall model [65] (e.g., the Spiral model [11]). In this class of models, testing (generally referred to as verification and validation <ref> [57, 6, 61] </ref>) establishes a binary relationship between two by-products of the software development process. For example, one type of binary testing comparison is between a specification (a description of the problem to be solved) and a design document (a description of the functional decomposition, data structures and algorithms) [10]. <p> In the following, we discuss the reasons for testing being hard. We then discuss testing related issues with respect to OO paradigm. 1.2.2 Why Testing is Hard? Testing in general is a labor-intensive and fault-prone process <ref> [57] </ref>. Testing generally consists of the following distinct steps. 1. Establish the criteria for testing. 2. Identify the target components for testing. 3. Generate appropriate test cases, where each test case consists of test input and expected output. 4. Execute test cases against the target components and evaluate its outcomes. <p> Unclear testing criteria Testing criteria define the goals for comparing a system against a specification. Black-box comparisons are based on the input and output alone without any consideration of, for example, "how" the system solves the problem specified in the problem specification <ref> [57] </ref>. White-box comparisons, on the other hand, use properties of the solution process of the system (such as a line of reasoning) as a comparison criteria [57]. <p> based on the input and output alone without any consideration of, for example, "how" the system solves the problem specified in the problem specification <ref> [57] </ref>. White-box comparisons, on the other hand, use properties of the solution process of the system (such as a line of reasoning) as a comparison criteria [57]. Some important testing criteria are: 7 * Testability: Testability is a measure of the ease with which other criteria for testing can be established (e.g., robustness). <p> Further, the execution paths in OO are much more dynamic than the paths in conventional programs. Thus, OO paradigm offers new challenges for testing. Input and output spaces are huge To test a selected component, a test case consists of a test input and its expected output <ref> [57] </ref>. For the selection of test inputs and expected outputs, often these input and output spaces are very huge. For example, in table 1.1 shows the potential input and output spaces for the expert systems (and, therefore potential number of test cases) are large. <p> A variety of pragmatic testing methods have been used to test conventional software ranging from small programs to mission-critical software such as space shuttle software <ref> [6, 57, 71] </ref>. These methods include for example random testing, equivalence and boundary partition testing, cause-effect graph testing, ablation testing, inspection and walkthroughs, auto-regressive testing. Each of these methods specifies a strategy for generating and evaluating test cases to judge various aspects of quality of program. <p> Each of these methods specifies a strategy for generating and evaluating test cases to judge various aspects of quality of program. In the following we briefly discuss each of the testing techniques. Random testing Random testing <ref> [57] </ref> generates test inputs randomly from input space. Although traditionally considered a weak method, its ease of generating test inputs and power of detecting failures in small publicized programs have been noticed [20]. <p> Because more failures help in identifying more faults, partition testing can be potentially more cost effective than random testing when the software is no longer so error-prone. This is consistent with one of Myers' testing principles 11 in <ref> [57] </ref> that the probability of the existence of more faults in a section of a program is proportional to the number of faults already found in that section. Path related testing exploits the internal structure of a program in addition to input and expected output. <p> Although this type of testing is not feasible for a complete system, it can point out ambiguities and incompleteness in subset of solution (or problem) specifications and implementation. The exhaustive nature of this testing makes it particularly effective for detecting unanticipated side effects <ref> [57] </ref>. This type of testing can also be used to demonstrate the quality of the solution specification. However, for a large software system the cost of cause-effect testing can be enormous. A well decomposed software system can be more suitable for this type of testing. <p> In the following we discuss random, partition, and data flow based test case generation techniques. 6.4.1 Single Class Random Test Cases Random testing has been used extensively in procedural paradigm, where the test inputs are generated randomly from input space <ref> [57] </ref>. Although, traditionally random testing is considered a weak method, its ease of generating test inputs and power of detecting failures in publicized programs have been noticed [46].
Reference: [58] <author> J. A. Naser. </author> <title> Nuclear power plant expert system verification and validation. </title> <editor> In U. G. Gupta, editor, </editor> <booktitle> Validating and Verifying Knowledge-based Systems, </booktitle> <pages> pages 26-41. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: In conventional paradigm, statistics show that a software programmed well will still have one to three bugs per hundred statements [75]. This quality of the software is not acceptable in many critical applications such as nuclear reactor control <ref> [58] </ref>, or safety critical systems [53]. Even though the importance of (V&V) is well known, it has commanded little attention in OO paradigm. A sound software engineering practice is to verify and validate everything that is developed. Thus, extensive V&V during software development is essential for building zero-defect software [21].
Reference: [59] <author> NeXT Inc. </author> <title> Reference to NeXTSTEP Programming Objects, </title> <year> 1989. </year>
Reference-contexts: Partition testing is more useful in situations where a class supports a large number of methods. For example, in NeXTSTEP or OpenSTEP OO programming environment, the user interface classes such as Text, TextCell, and Button on the average have 25 methods <ref> [59] </ref>. With more than 500 user classes in total, generating test cases for each of the class can be difficult. Thus, partitioning the method space into several partitions is helpful. The effectiveness of partition based test cases depend on the effectiveness of the partitioning criteria.
Reference: [60] <author> S. Ntafos. </author> <title> On required element testing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(6):795-803, </volume> <year> 1984. </year>
Reference-contexts: Data flow testing tests all paths between such a define-use (DU) pair. There exists different variations of data flow testing based on the coverage criteria. The following criteria are commonly employed for testing conventional programs <ref> [64, 60] </ref> * All-c-uses: All the paths from a variable define to its use in a calculation. * All-p-uses: All the paths from a variable define to its use as a predicate. * All-uses: The union of all the paths derived from All-c-uses and All-p-uses. 12 * All-du-uses: All the loopless
Reference: [61] <author> M. A. Ould and C. </author> <title> Unwin. Testing in Software Development. </title> <publisher> Cambridge University Press, </publisher> <year> 1987. </year>
Reference-contexts: Development paradigms for conventional software, for example, include several variants of the Waterfall model [65] (e.g., the Spiral model [11]). In this class of models, testing (generally referred to as verification and validation <ref> [57, 6, 61] </ref>) establishes a binary relationship between two by-products of the software development process. For example, one type of binary testing comparison is between a specification (a description of the problem to be solved) and a design document (a description of the functional decomposition, data structures and algorithms) [10].
Reference: [62] <author> D. E. Perri and G. E. Kaiser. </author> <title> Adequate testing and object-oriented programming. </title> <journal> Journal of Object-Oriented Programming, </journal> <pages> pages 13-19, </pages> <month> January/February </month> <year> 1990. </year>
Reference-contexts: The article in [72] discusses various issues related to data flow anomaly testing at various levels in OO programs. In [73, 32] authors discuss about state-based software testing of OO programs by modeling classes as state machines. Issues related to adequate testing of classes is considered in detail in <ref> [62] </ref>. In [30], there is a discussion on hierarchical incremental testing of classes. In [69], authors discuss about a framework for testing OO programs. In [15, 16] authors have provided a set of metrics suite for object-oriented design. <p> Recently, [72] discusses various issues related to data flow anomaly testing at various levels in OO programs. Several issues related to V&V and maintenance of object-oriented programs are given in [68]. Issues related to adequate testing of classes is considered in detail in <ref> [62] </ref>. In this paper, we provide a technique for identifying the data flow anomalies in classes. <p> Further, exhaustive testing of each class does not reuse the test cases developed for the parent class methods. Thus testing of methods on the inheritance hierarchy can be optimized. In <ref> [62] </ref>, it has been demonstrated that many of the well tested parent classes have to be retested in the context of child classes. In [25] it is suggested that methods that are inherited from parent classes may require minimal testing if their functionality is not modified in the child classes.
Reference: [63] <author> R. M. Poston. </author> <title> Automated testing from object models. </title> <journal> CACM, </journal> <volume> 37(9) </volume> <pages> 48-58, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: A class testing using the algebraic specifications of the classes is discussed in [27]. In [67], authors use assertion definition language (ADL) for class interface testing. Test case generation from OO analysis and design products of OMT is discussed in <ref> [63] </ref>. OO integration testing using message-method pairs is discussed in [38]. However, in this article authors do not discuss about test case generation and criteria of selecting message-method pairs from the all possible pairs. In [55], there is a discussion on cluster and class testing.
Reference: [64] <author> S. Rapps and E. J. Weyuker. </author> <title> Selecting software test data using data flow information. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(4):367-375, </volume> <year> 1985. </year>
Reference-contexts: Data flow testing tests all paths between such a define-use (DU) pair. There exists different variations of data flow testing based on the coverage criteria. The following criteria are commonly employed for testing conventional programs <ref> [64, 60] </ref> * All-c-uses: All the paths from a variable define to its use in a calculation. * All-p-uses: All the paths from a variable define to its use as a predicate. * All-uses: The union of all the paths derived from All-c-uses and All-p-uses. 12 * All-du-uses: All the loopless <p> A simple C++ code that implements the above is given below. class Account - public: void open (int acct_no, name cust_name); void deposit (int acct_no, amount amt); void withdraw (int acct_no, amount amt); void close (int acct_no, name *cust_name); ... protected: amount balance; name customer_name <ref> [64] </ref>; int account_no; ... void Account::open (int acct_no, name cust_name) - account_no = acct_no; customer_name = cust_name; - void Account::deposit (int acct_no, amount amt) - if (account_no == acct_no) balance = balance + amt; else error (acct_no); - void Account::withdraw (int acct_no, amount amt) - if (account_no == acct_no)- if (amt
Reference: [65] <author> W. W. </author> <title> Royce. Managing the development of large software systems: Concepts and techniques. </title> <booktitle> Proc. of WESCON, </booktitle> <pages> pages 1-9, </pages> <year> 1970. </year>
Reference-contexts: Development paradigms for conventional software, for example, include several variants of the Waterfall model <ref> [65] </ref> (e.g., the Spiral model [11]). In this class of models, testing (generally referred to as verification and validation [57, 6, 61]) establishes a binary relationship between two by-products of the software development process.
Reference: [66] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: OO paradigm has moved into mainstream software development industry. It is currently being used in variety of applications development starting from system software such as databases, operating systems to application software for banking, billing, service providing and so on <ref> [12, 66] </ref>. Software is inherently complex and this complexity of the software is its fundamental property, not an accidental one. The complexity is due to difficulty in comprehending the problem domain completely, the flexibility in software and difficulty in managing development process [13]. <p> We first discuss a technique of deriving MtSS of a class from the corresponding state based OO design. We then discuss the derivation of MtSS and MgSS from other well-known dynamic models built during design such as object diagram [12], event trace diagram <ref> [66] </ref>, or use-case diagrams [37]. The importance of specification Consistency and Completeness (C&C) is well-known in software engineering. Inconsistency and incompleteness in sequence specification would lead to faulty verification and therefore, C&C of the specification is essential for developing OO systems with less faults. <p> We then discuss the deriving of MtSS of a class from the state based OO design. MtSS can also be derived from the dynamic models built during design such as Interaction Diagrams [12], Event Trace Diagrams <ref> [66] </ref>, or Use-Case Diagrams [37]. Definition 2.1 Methods (C): For a class C we define M ethods (C) as a set of all the instance methods defined in C that are publicly available. <p> Similarly , sequence specification can also be derived from Event diagram. 2.2.1 MtSS from State Transition Diagram Many OO analysis and design techniques propose State Transition Diagrams (STD) for modeling the dynamic behavior of classes <ref> [12, 66, 19, 79] </ref>. STDs can be used to model both inter-class and intra-class dynamic behavior [19]. For deriving MtSS of a class, we use its intra-class STD. <p> OO paradigm has moved into mainstream software development industry. It is currently being used in a variety of application development starting from system software such as databases, operating systems to application software such as banking, billing, and service providing <ref> [12, 66] </ref>. The software industry, in general, is moving towards OO paradigm. The current research so far in OO software engineering is focussed on problem analysis, software design, and implementation techniques resulting in a potpourri of representations and procedures.
Reference: [67] <author> S. Sankar and R. Hayes. </author> <title> ADL-an interface definition language for specifying and testing software. </title> <booktitle> In Proceedings of the Workshop on Interface Definition Languages, </booktitle> <pages> pages 13-21, </pages> <year> 1994. </year>
Reference-contexts: Several issues related to V&V and maintenance of object-oriented programs are given in [68, 41]. A class testing using the algebraic specifications of the classes is discussed in [27]. In <ref> [67] </ref>, authors use assertion definition language (ADL) for class interface testing. Test case generation from OO analysis and design products of OMT is discussed in [63]. OO integration testing using message-method pairs is discussed in [38].
Reference: [68] <author> M. D. Smith and D. J. Robson. </author> <title> Object-oriented programming the problems of validation. </title> <booktitle> In IEEE Conference on Software Maintenance, </booktitle> <pages> pages 272-281, </pages> <year> 1990. </year>
Reference-contexts: Several issues related to V&V and maintenance of object-oriented programs are given in <ref> [68, 41] </ref>. A class testing using the algebraic specifications of the classes is discussed in [27]. In [67], authors use assertion definition language (ADL) for class interface testing. Test case generation from OO analysis and design products of OMT is discussed in [63]. <p> Recently, [72] discusses various issues related to data flow anomaly testing at various levels in OO programs. Several issues related to V&V and maintenance of object-oriented programs are given in <ref> [68] </ref>. Issues related to adequate testing of classes is considered in detail in [62]. In this paper, we provide a technique for identifying the data flow anomalies in classes.
Reference: [69] <author> M. D. Smith and D. J. Robson. </author> <title> A framework for testing object-oriented programs. </title> <booktitle> Jouranl of Object-Oriented Programming, </booktitle> <volume> 5(3) </volume> <pages> 45-53, </pages> <year> 1992. </year> <month> 98 </month>
Reference-contexts: In [73, 32] authors discuss about state-based software testing of OO programs by modeling classes as state machines. Issues related to adequate testing of classes is considered in detail in [62]. In [30], there is a discussion on hierarchical incremental testing of classes. In <ref> [69] </ref>, authors discuss about a framework for testing OO programs. In [15, 16] authors have provided a set of metrics suite for object-oriented design.
Reference: [70] <author> A. Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <editor> In Stan--ley B. Xdonik and David Maier, editors, </editor> <booktitle> Readings in Object-Oriented database systems, </booktitle> <pages> pages 84-91. </pages> <publisher> Morgan Kaufmann Publishers, Inc, </publisher> <year> 1986. </year>
Reference-contexts: We then extend the rules to check the consistency and completeness in the presence of multiple interfaces to a class. Inheritance relation is used extensively in OO based applications. OO languages support inheritance to model the hierarchical relationship between classes as well as to promote code reuse <ref> [28, 51, 70, 22, 12, 42] </ref>. Inheritance allows a class definition to use the definition of one or more other classes. If a class C 1 directly inherits from another class C 2 , then C 1 is called the child class and C 2 is called the parent class. <p> A child class, in addition to inherited methods, can further enhance the class with additional operations or change the implementation of inherited methods <ref> [70, 51] </ref>. Inheritance can be used for specialization, refinement, and implementation (reuse) [51, 70]. If inheritance is used for specialization, then the child class satisfies the semantics of all the inherited methods from the parent class 1 . A child class may be extended with additional methods and instance variables. <p> A child class, in addition to inherited methods, can further enhance the class with additional operations or change the implementation of inherited methods [70, 51]. Inheritance can be used for specialization, refinement, and implementation (reuse) <ref> [51, 70] </ref>. If inheritance is used for specialization, then the child class satisfies the semantics of all the inherited methods from the parent class 1 . A child class may be extended with additional methods and instance variables. <p> If inheritance is used for implementation, then the child class may not inherit all the methods from the parent class, and may modify the semantics of the inherited methods <ref> [70, 42] </ref>. In this thesis, we propose a set of C&C rules for consistency checking of MtSS of classes for each type of inheritance. Let C 1 ; C 2 ; : : : C k be a set of classes that are related to one another through inheritance relationship. <p> methods as new methods in Savings Acc class and not considering them for the rule application. 3.1.3 Inheritance for Implementation and MtSS If inheritance is used for reuse by excluding some of the methods of the parent class, then this type of inheritance is generally known as inheritance for implementation <ref> [70] </ref>. In this case, some methods of the parent class are excluded in the child class public interface. The semantics of the inherited methods are not modified. <p> Thus inheritance for implementation promotes reuse of previously developed code. Several languages such as C++ and CommonObjects support for excluding methods of parent class in child class <ref> [45, 70] </ref>. The rule that checks the consistency between parent and child class remain similar to the one described in section 3.1.1. <p> Even though an object defines many external methods, all these methods are not universally available to all the client objects. Thus, for each class, multiple interfaces exporting a subset of methods providing restricted access can be defined <ref> [29, 70] </ref>. Multiple interfaces are useful as they provide additional encapsulation to object structure. Separate subinterfaces to different users facilitates understanding, maintenance, and proper use. Multiple interfaces thus support the concept, separation of concern which is essential for understanding complex software. Multiple subinterfaces provide a well guarded access control. <p> The child class, in addition to inherited methods, can further enhance the class with additional operations or change the implementation of inherited methods <ref> [70, 51, 42] </ref>. Inheritance can be used for specialization, refinement as well as for implementation (reuse) purposes [51, 70]. If inheritance is used for specialization, then the child class conforms to the semantics of all the inherited methods from the parent class. <p> The child class, in addition to inherited methods, can further enhance the class with additional operations or change the implementation of inherited methods [70, 51, 42]. Inheritance can be used for specialization, refinement as well as for implementation (reuse) purposes <ref> [51, 70] </ref>. If inheritance is used for specialization, then the child class conforms to the semantics of all the inherited methods from the parent class. The child class may extend the class with additional methods. <p> If inheritance is used for implementation, then the child class may not inherit all the methods from the parent class, and may modify the semantics of the inherited methods <ref> [70, 42] </ref>. Inheritance is used commonly in OO systems. Further, the depth of inheritance hierarchy can be deep for large systems. The child classes in the inheritance hierarchy usually specialize or refine the parent classes. <p> from parent classes, the testing technique remain the same as described in the previous section. 5.4.3 Implementation Inheritance and Anomaly Detection If inheritance is used for reuse by excluding some of the methods of a previously defined class, then this type of inheritance is generally known as inheritance for implementation <ref> [70] </ref>. In this case, some methods of the parent class are excluded in the child class public interface. The semantics of the inherited methods are not modified. <p> Some new methods can be added in the child class. Thus inheritance for implementation promotes reuse of previously developed code. Several languages such as C++ and CommonObjects support for excluding methods of parent class in child class <ref> [45, 70] </ref>. For data flow anomaly testing, because some of the methods are not inherited in the child class, the path expressions for those methods that appear later in sequence specification change.
Reference: [71] <author> A. Spector and D. Gifford. </author> <title> Case study: The space shuttle primary computer system. </title> <journal> Communications of the ACM, </journal> <volume> 27(9) </volume> <pages> 872-900, </pages> <month> September </month> <year> 1984. </year>
Reference-contexts: A variety of pragmatic testing methods have been used to test conventional software ranging from small programs to mission-critical software such as space shuttle software <ref> [6, 57, 71] </ref>. These methods include for example random testing, equivalence and boundary partition testing, cause-effect graph testing, ablation testing, inspection and walkthroughs, auto-regressive testing. Each of these methods specifies a strategy for generating and evaluating test cases to judge various aspects of quality of program.
Reference: [72] <author> S. Subramanian, W. T. Tsai, and S. Kirani. </author> <title> Hierarchical data flow analysis for oo programs. </title> <journal> Journal of Object-Oriented Programming, </journal> <volume> 7(2) </volume> <pages> 36-46, </pages> <year> 1994. </year>
Reference-contexts: In [7], there is a discussion on how to align developmental process with testing so that designs are testable and testing is maximally effective. In [14], authors provide data related to testing of Smalltalk library software. The article in <ref> [72] </ref> discusses various issues related to data flow anomaly testing at various levels in OO programs. In [73, 32] authors discuss about state-based software testing of OO programs by modeling classes as state machines. Issues related to adequate testing of classes is considered in detail in [62]. <p> In [36], authors identify a flaw in the algorithm given in [26] and provide an efficient and easy to implement algorithm for identifying the data flow anomalies. Recently, <ref> [72] </ref> discusses various issues related to data flow anomaly testing at various levels in OO programs. Several issues related to V&V and maintenance of object-oriented programs are given in [68]. Issues related to adequate testing of classes is considered in detail in [62].
Reference: [73] <author> C. D. Turner and D. J. Robson. </author> <title> The testing of object-oriented programs. </title> <type> Technical Report TR-13/92, </type> <institution> University of Durham, Computer Science Division, SECS, Durham, </institution> <address> England, </address> <year> 1992. </year>
Reference-contexts: In [14], authors provide data related to testing of Smalltalk library software. The article in [72] discusses various issues related to data flow anomaly testing at various levels in OO programs. In <ref> [73, 32] </ref> authors discuss about state-based software testing of OO programs by modeling classes as state machines. Issues related to adequate testing of classes is considered in detail in [62]. In [30], there is a discussion on hierarchical incremental testing of classes.
Reference: [74] <author> M. A. Vouk, D. F. McAllister, and K. C. Tai. </author> <title> An experimental evaluation of the effectiveness of random testing of fault-tolerant software. </title> <booktitle> In Proceedings of the Workshop on Software Testing Conference, </booktitle> <pages> pages 74-81, </pages> <year> 1986. </year>
Reference-contexts: However, in another study it was found that random testing may not be quite effective on larger programs (or large sample space to select test cases) that are more sensitive to special values <ref> [74] </ref>. For random testing to be effective it must be easy to generate expected outputs [46]. Furthermore, random testing works well on programs whose fault-prone regions (input regions that result in failures) of the input space are large enough for adequate random sampling.
Reference: [75] <author> D. M. Weiss and V. R. Basili. </author> <title> Evaluating software development by analysis of changes: some data from the software engineering laboratory. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 11(2) </volume> <pages> 157-168, </pages> <year> 1985. </year>
Reference-contexts: It has been studied that Verification and Validation (V&V) related activities consume at least half of the labor to bring out a production quality software [9, 78]. In conventional paradigm, statistics show that a software programmed well will still have one to three bugs per hundred statements <ref> [75] </ref>. This quality of the software is not acceptable in many critical applications such as nuclear reactor control [58], or safety critical systems [53]. Even though the importance of (V&V) is well known, it has commanded little attention in OO paradigm.
Reference: [76] <author> R. J. Wirfs-Brock and R. E. Johnson. </author> <title> Surveying current research in object-oriented design. </title> <journal> CACM, </journal> <volume> 33(9) </volume> <pages> 104-124, </pages> <month> september </month> <year> 1990. </year>
Reference-contexts: Messages are requests sent from one object to other for computing a desired functionality. Methods are the functions an object executes in response to a message. There exists a one-to-one relation between the messages an object receives and the method it executes <ref> [76] </ref>. A method before sending a message to other object, must uniquely identify the other object. In addition, an object accessing the services of other objects must know the proper interface protocol of the objects. The instance methods of a class can be classified into define, use, or define-use type.
Reference: [77] <author> R. J. Wirfs-Brock, B. Wilkerson, and L. Wiener. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey 07632, </address> <year> 1990. </year>
Reference-contexts: In "Design by Contract" technique, the output of OOAD is a contract between designers and implementors [52]. Another OOAD technique based on responsibilities also suggests using responsibilities as a contract of the specification of publicly available services <ref> [77] </ref>. The contract specification and separation of the specification from the implementation is useful in several ways. Clear specification help implementors to deliver the software as promised in the contract. The contract specification also helps in documenting a class as a library component, thus promoting reuse.
Reference: [78] <author> R. W. Wolverton. </author> <title> The cost of developing large scale software. In Ellis Horowitz, editor, Practical Strategies for Developing Large Software Systems. </title> <publisher> Addison-Wesley, </publisher> <year> 1975. </year>
Reference-contexts: It has been studied that Verification and Validation (V&V) related activities consume at least half of the labor to bring out a production quality software <ref> [9, 78] </ref>. In conventional paradigm, statistics show that a software programmed well will still have one to three bugs per hundred statements [75]. This quality of the software is not acceptable in many critical applications such as nuclear reactor control [58], or safety critical systems [53]. <p> Thus, to get a proper understanding, testing, and debugging of the system, tracing of the methods and messages is essential. 1.2 Testing Concepts It has been reported that to bring out a production quality software, testing related activities consume at least half of the labor <ref> [9, 78] </ref>. The primary goal of software testing is to ensure that the end product under investigation is in conformance with the product from which the end product was built. In this section, we introduce various concepts in testing and discuss with respect to OO paradigm.
Reference: [79] <author> I. A. Zualkernan, W. T. Tsai, A. Jemie, I. C. Wen, and J. M. Drake. </author> <title> Object-oriented analysis as design: A case study. </title> <journal> International Journal on Software Engineering and Knowledge Engineering, </journal> <volume> 2(4) </volume> <pages> 489-521, </pages> <year> 1992. </year> <month> 99 </month>
Reference-contexts: Similarly , sequence specification can also be derived from Event diagram. 2.2.1 MtSS from State Transition Diagram Many OO analysis and design techniques propose State Transition Diagrams (STD) for modeling the dynamic behavior of classes <ref> [12, 66, 19, 79] </ref>. STDs can be used to model both inter-class and intra-class dynamic behavior [19]. For deriving MtSS of a class, we use its intra-class STD.
References-found: 79

