URL: http://www.cs.unc.edu/~molnar/Papers/Sort.ps
Refering-URL: http://www.cs.unc.edu/~molnar/
Root-URL: http://www.cs.unc.edu
Title: A Sorting Classification of Parallel Rendering Front-page photo: Simulation of communication traffic between sort-first processors
Author: Steven Molnar Michael Cox David Ellsworth Henry Fuchs 
Affiliation: University of North Carolina at Chapel Hill and Princeton University  
Abstract: We describe three broad classes of parallel rendering methods, based on where the sort from objectspace to screen space occurs. These classes encompass most feed - forward parallel software and hardware rendering architectures that have been described to date. After introducing the classes, we perform a coarse analysis of the aggregate processing and communication costs of each and identify constraints they impose on the rendering application. The aim is to provide a conceptual model of the tradeoffs between the approaches as an aid to designers and implementers of high-performance, parallel rendering systems. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <institution> National Computer Graphics Association, </institution> <note> GPC Quarterly Report, </note> <editor> Vol. </editor> <volume> 2, No. 4, </volume> <booktitle> 4th, </booktitle> <address> Fairfax, VA, </address> <year> 1992. </year>
Reference-contexts: Of course, the application must support retained-mode (display-list) rendering, and bookkeeping is needed to keep track of primitive ownership. To get an estimate of c, we have analyzed traces from two rendering sequences: the rotating head model in the NCGA Graphics Performance Committee's Picture-Level Benchmark <ref> [1] </ref>, and an architectural walkthrough of a building interior seen through a head-mounted display. In both cases, we assumed a display size of 1280x1024 pixels and a region size of 64x64 pixels. In the Picture-Level Benchmark, the head contains 60,000 triangles and rotates 4.5 each frame.
Reference: 2. <author> N. Gharachorloo, S. Gupta, </author> <title> R.F. Sproull, I.E. Sutherland, "A Characterization of Ten Rasterization Techniques," </title> <booktitle> Computer Graphics (Siggraph 89 Proceedings), </booktitle> <volume> Vol. 23, No. 3, </volume> <month> July </month> <year> 1989, </year> <pages> pp. 355368. </pages>
Reference-contexts: Common data-parallel approaches are by object ( object-parallelism) and by pixel or portion of the screen (pixel- or image-parallelism). Several taxonomies of parallel rendering algorithms have been proposed <ref> [2, 3, 4] </ref>. These taxonomies are useful for classifying and understanding systems, but do not lend themselves easily to comparison or analysis. Some rendering systems have been analyzed in isolation [5, 6, 7].
Reference: 3. <author> S. Molnar, H. Fuchs, </author> <title> Advanced Raster Graphics Architecture, </title> <note> Chapter 18 in J. </note> <author> D. Foley, A. van Dam, S. K. Feiner, J. F. Hughes, </author> <title> Computer Graphics: </title> <booktitle> Principles and Practice, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Common data-parallel approaches are by object ( object-parallelism) and by pixel or portion of the screen (pixel- or image-parallelism). Several taxonomies of parallel rendering algorithms have been proposed <ref> [2, 3, 4] </ref>. These taxonomies are useful for classifying and understanding systems, but do not lend themselves easily to comparison or analysis. Some rendering systems have been analyzed in isolation [5, 6, 7]. <p> Both methods have advantages, as we will see later. Sort-last systems have existed in various forms for more than 20 years. The 1967 GE NASA II flight simulator used a simple version of SL-full in which a processor was assigned to each primitive [13]. Since then, several primitive-per-processor <ref> [3, 14] </ref> and multi ple-primitive-per-processor [15, 16] SL-full systems have been proposed. Several recent commercial systems have used SL-sparse [17, 18, 19]. We will examine sort-last in more detail shortly. Processing and communication model We now analyze each of the three rendering methods in more detail.
Reference: 4. <author> S. Whitman, </author> <title> Multiprocessor Methods for Computer Graphics Rendering, AK Peters, </title> <publisher> Ltd., </publisher> <address> Wellesley, MA, </address> <year> 1992. </year>
Reference-contexts: Common data-parallel approaches are by object ( object-parallelism) and by pixel or portion of the screen (pixel- or image-parallelism). Several taxonomies of parallel rendering algorithms have been proposed <ref> [2, 3, 4] </ref>. These taxonomies are useful for classifying and understanding systems, but do not lend themselves easily to comparison or analysis. Some rendering systems have been analyzed in isolation [5, 6, 7]. <p> Load balancing the assignment of objects in hierarchical display structures has been explored [22]. The other problem, primitive clumping, has been the focus of much of the research in hardware [23] and software <ref> [4, 7, 12] </ref> sort-middle renderers. The main techniques are to make regions smaller (and more numerous) and to assign regions dynamically to processors.
Reference: 5. <author> K. Akeley, T. Jermoluk, </author> <title> "High-Performance Polygon Rendering," </title> <booktitle> Computer Graphics (Siggraph 88 Proceedings), </booktitle> <volume> Vol. 22, No. 4, </volume> <month> Aug. </month> <year> 1988, </year> <pages> pp. 239246. </pages>
Reference-contexts: Several taxonomies of parallel rendering algorithms have been proposed [2, 3, 4]. These taxonomies are useful for classifying and understanding systems, but do not lend themselves easily to comparison or analysis. Some rendering systems have been analyzed in isolation <ref> [5, 6, 7] </ref>. However, these analyses tend to focus on unique attributes of each system and make comparison between systems difficult. In this paper we describe a classification scheme, which we hope will provide a more structured framework for reasoning about parallel rendering.
Reference: 6. <author> T. W. Crockett, T. Orloff, </author> <title> "A Parallel Rendering Algorithm for MIMD Architectures," </title> <booktitle> Proceedings of the 1993 Parallel Rendering Symposium, ACM, </booktitle> <address> New York, </address> <year> 1993, </year> <pages> pp. 3542. </pages>
Reference-contexts: Several taxonomies of parallel rendering algorithms have been proposed [2, 3, 4]. These taxonomies are useful for classifying and understanding systems, but do not lend themselves easily to comparison or analysis. Some rendering systems have been analyzed in isolation <ref> [5, 6, 7] </ref>. However, these analyses tend to focus on unique attributes of each system and make comparison between systems difficult. In this paper we describe a classification scheme, which we hope will provide a more structured framework for reasoning about parallel rendering. <p> Redistribute screen-space primitives Graphics database (arbitrarily partitioned) R R R R Display Geometry processing Rasterization G G G G primitives between geometry processing and rasterization. Sort-middle is general and straightforward, and has been the most common approach to date for both hardware [9, 10, 11] and software <ref> [6, 7, 12] </ref> parallel rendering systems. We will examine the advantages and disadvantages of sort-middle in more detail later. Sort-last Sort-last defers sorting until the end of the rendering pipelineafter primitives have been rasterized into pixels, samples, or pixel fragments.
Reference: 7. <author> S. Whitman, </author> <title> "A Task Adaptive Parallel Graphics Renderer," </title> <note> to appear in IEEE CG&A, </note> <month> July </month> <year> 1994. </year>
Reference-contexts: Several taxonomies of parallel rendering algorithms have been proposed [2, 3, 4]. These taxonomies are useful for classifying and understanding systems, but do not lend themselves easily to comparison or analysis. Some rendering systems have been analyzed in isolation <ref> [5, 6, 7] </ref>. However, these analyses tend to focus on unique attributes of each system and make comparison between systems difficult. In this paper we describe a classification scheme, which we hope will provide a more structured framework for reasoning about parallel rendering. <p> Redistribute screen-space primitives Graphics database (arbitrarily partitioned) R R R R Display Geometry processing Rasterization G G G G primitives between geometry processing and rasterization. Sort-middle is general and straightforward, and has been the most common approach to date for both hardware [9, 10, 11] and software <ref> [6, 7, 12] </ref> parallel rendering systems. We will examine the advantages and disadvantages of sort-middle in more detail later. Sort-last Sort-last defers sorting until the end of the rendering pipelineafter primitives have been rasterized into pixels, samples, or pixel fragments. <p> Load balancing the assignment of objects in hierarchical display structures has been explored [22]. The other problem, primitive clumping, has been the focus of much of the research in hardware [23] and software <ref> [4, 7, 12] </ref> sort-middle renderers. The main techniques are to make regions smaller (and more numerous) and to assign regions dynamically to processors.
Reference: 8. <author> I.E. Sutherland, R.F. Sproull, R.A. Schumacker, </author> <title> "A Characterization of Ten Hidden Surface Algorithms," </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 6, No. 1, </volume> <month> March </month> <year> 1974, </year> <pages> pp. 155. </pages>
Reference-contexts: Due to the arbitrary nature of the modeling and viewing transformations, a primitive can fall anywhere on (or off) the screen. Thus rendering can be viewed as a problem of sorting primitives to the screen, as noted by Sutherland, Sproull, and Schumacher in their seminal paper on visible-surface algorithms <ref> [8] </ref>. For fully parallel renderers, this sort involves a redistribution of data between processors, because responsibility for primitives and pixels is distributed. The location of this sort largely determines the structure of the resulting parallel rendering system.
Reference: 9. <author> H. Fuchs, J. Poulton, et. al, </author> <title> "Pixel-Planes 5: A Heterogeneous Multiprocessor Graphics System Using Processor-Enhanced Memories," </title> <booktitle> Computer Graphics (Siggraph 89 Proceedings), </booktitle> <volume> Vol. 23, No. 3, </volume> <month> July </month> <year> 1989, </year> <pages> pp. 7988. </pages>
Reference-contexts: Redistribute screen-space primitives Graphics database (arbitrarily partitioned) R R R R Display Geometry processing Rasterization G G G G primitives between geometry processing and rasterization. Sort-middle is general and straightforward, and has been the most common approach to date for both hardware <ref> [9, 10, 11] </ref> and software [6, 7, 12] parallel rendering systems. We will examine the advantages and disadvantages of sort-middle in more detail later. Sort-last Sort-last defers sorting until the end of the rendering pipelineafter primitives have been rasterized into pixels, samples, or pixel fragments.
Reference: 10. <author> K. Akeley, </author> <title> RealityEngine Graphics, </title> <booktitle> Computer Graphics (Siggraph 93 Proceedings), Aug. </booktitle> <volume> 93, </volume> <pages> pp. 109116. </pages>
Reference-contexts: Redistribute screen-space primitives Graphics database (arbitrarily partitioned) R R R R Display Geometry processing Rasterization G G G G primitives between geometry processing and rasterization. Sort-middle is general and straightforward, and has been the most common approach to date for both hardware <ref> [9, 10, 11] </ref> and software [6, 7, 12] parallel rendering systems. We will examine the advantages and disadvantages of sort-middle in more detail later. Sort-last Sort-last defers sorting until the end of the rendering pipelineafter primitives have been rasterized into pixels, samples, or pixel fragments.
Reference: 11. <author> M. Deering, S.R. Nelson, Leo: </author> <title> A System for Cost Effective 3D Shaded Graphics, </title> <booktitle> Computer Graphics (Siggraph 93 Proceedings), Aug. </booktitle> <volume> 93., </volume> <pages> pp. 101108. </pages>
Reference-contexts: Redistribute screen-space primitives Graphics database (arbitrarily partitioned) R R R R Display Geometry processing Rasterization G G G G primitives between geometry processing and rasterization. Sort-middle is general and straightforward, and has been the most common approach to date for both hardware <ref> [9, 10, 11] </ref> and software [6, 7, 12] parallel rendering systems. We will examine the advantages and disadvantages of sort-middle in more detail later. Sort-last Sort-last defers sorting until the end of the rendering pipelineafter primitives have been rasterized into pixels, samples, or pixel fragments.
Reference: 12. <author> D. Ellsworth, </author> <title> "A Multicomputer Polygon Rendering Algorithm for Interactive Applications," </title> <note> to appear in IEEE CG&A, </note> <month> July </month> <year> 1994. </year>
Reference-contexts: Redistribute screen-space primitives Graphics database (arbitrarily partitioned) R R R R Display Geometry processing Rasterization G G G G primitives between geometry processing and rasterization. Sort-middle is general and straightforward, and has been the most common approach to date for both hardware [9, 10, 11] and software <ref> [6, 7, 12] </ref> parallel rendering systems. We will examine the advantages and disadvantages of sort-middle in more detail later. Sort-last Sort-last defers sorting until the end of the rendering pipelineafter primitives have been rasterized into pixels, samples, or pixel fragments. <p> Load balancing the assignment of objects in hierarchical display structures has been explored [22]. The other problem, primitive clumping, has been the focus of much of the research in hardware [23] and software <ref> [4, 7, 12] </ref> sort-middle renderers. The main techniques are to make regions smaller (and more numerous) and to assign regions dynamically to processors.
Reference: 13. <author> R. Bunker, R. </author> <title> Economy, "Evolution of GE CIG Systems," SCSD Document, General Electric Company, </title> <address> Daytona Beach, FL 32015, </address> <year> 1989. </year>
Reference-contexts: Both methods have advantages, as we will see later. Sort-last systems have existed in various forms for more than 20 years. The 1967 GE NASA II flight simulator used a simple version of SL-full in which a processor was assigned to each primitive <ref> [13] </ref>. Since then, several primitive-per-processor [3, 14] and multi ple-primitive-per-processor [15, 16] SL-full systems have been proposed. Several recent commercial systems have used SL-sparse [17, 18, 19]. We will examine sort-last in more detail shortly.
Reference: 14. <author> G. C. Roman, T. Kimura, </author> <title> "A VLSI Architecture for Real - Time Color Display of Three-Dimensional Objects," </title> <booktitle> Proceedings of IEEE Micro-Delcon, </booktitle> <address> March 20, </address> <year> 1979, </year> <pages> pp. 113118. </pages>
Reference-contexts: Both methods have advantages, as we will see later. Sort-last systems have existed in various forms for more than 20 years. The 1967 GE NASA II flight simulator used a simple version of SL-full in which a processor was assigned to each primitive [13]. Since then, several primitive-per-processor <ref> [3, 14] </ref> and multi ple-primitive-per-processor [15, 16] SL-full systems have been proposed. Several recent commercial systems have used SL-sparse [17, 18, 19]. We will examine sort-last in more detail shortly. Processing and communication model We now analyze each of the three rendering methods in more detail.
Reference: 15. <author> C. Shaw, M. Green, J. Schaeffer, </author> <title> "A VLSI Architecture for Image Composition," </title> <booktitle> in Advances in Computer Graphics Hardware III, </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1988, </year> <pages> pp. 183199. </pages>
Reference-contexts: Sort-last systems have existed in various forms for more than 20 years. The 1967 GE NASA II flight simulator used a simple version of SL-full in which a processor was assigned to each primitive [13]. Since then, several primitive-per-processor [3, 14] and multi ple-primitive-per-processor <ref> [15, 16] </ref> SL-full systems have been proposed. Several recent commercial systems have used SL-sparse [17, 18, 19]. We will examine sort-last in more detail shortly. Processing and communication model We now analyze each of the three rendering methods in more detail.
Reference: 16. <author> S. Molnar, J. Eyles, J. Poulton, "PixelFlow: </author> <title> HighSpeed Rendering Using Image Composition," </title> <booktitle> Computer Graphics (Siggraph 92 Proceedings), </booktitle> <volume> Vol. 26, No. 2, </volume> <month> July </month> <year> 1992, </year> <pages> pp. 231240. </pages>
Reference-contexts: Sort-last systems have existed in various forms for more than 20 years. The 1967 GE NASA II flight simulator used a simple version of SL-full in which a processor was assigned to each primitive [13]. Since then, several primitive-per-processor [3, 14] and multi ple-primitive-per-processor <ref> [15, 16] </ref> SL-full systems have been proposed. Several recent commercial systems have used SL-sparse [17, 18, 19]. We will examine sort-last in more detail shortly. Processing and communication model We now analyze each of the three rendering methods in more detail. <p> Full-frame merging takes advantage of the fact that merging a full frame from each processor is very regular and can be done using simple hardware <ref> [16] </ref>. Second, even sparse merging algorithms may be improved in some cases. The simplest sparse algorithm merges every pixel rendered by every processor. Under some circumstances (e.g. when broadcast is available [25]), it is possible to merge only a fraction of the pixels rendered at each pixel location.
Reference: 17. <author> Evans and Sutherland Computer Corporation, </author> <type> Freedom Series Technical Report, </type> <month> October </month> <year> 1992. </year>
Reference-contexts: The 1967 GE NASA II flight simulator used a simple version of SL-full in which a processor was assigned to each primitive [13]. Since then, several primitive-per-processor [3, 14] and multi ple-primitive-per-processor [15, 16] SL-full systems have been proposed. Several recent commercial systems have used SL-sparse <ref> [17, 18, 19] </ref>. We will examine sort-last in more detail shortly. Processing and communication model We now analyze each of the three rendering methods in more detail. The aim is to build a quantitative model of their processing and communication costs to use as a basis for comparing them. <p> For example, communicating a bit of data over an ethernet network can be orders of magnitude more expensive than sending the same bit over a dedicated hardware communication channel. Similarly, if communication in sort-last is accelerated in hardware, as it is in several current commercial machines <ref> [17, 18, 19] </ref>, it may be less expensive according to some measures than communication in a sort-middle system that sends much less data. We can view hardware acceleration, then, as a way of reducing the real costs of critical or "bottlenecked" operations.
Reference: 18. <author> Fujitsu Limited, </author> <title> AG Series Graphics Technical Overview, Fujitsu Open Systems Solutions, </title> <publisher> Inc., </publisher> <address> San Jose, CA 95134-2022, </address> <year> 1993. </year>
Reference-contexts: The 1967 GE NASA II flight simulator used a simple version of SL-full in which a processor was assigned to each primitive [13]. Since then, several primitive-per-processor [3, 14] and multi ple-primitive-per-processor [15, 16] SL-full systems have been proposed. Several recent commercial systems have used SL-sparse <ref> [17, 18, 19] </ref>. We will examine sort-last in more detail shortly. Processing and communication model We now analyze each of the three rendering methods in more detail. The aim is to build a quantitative model of their processing and communication costs to use as a basis for comparing them. <p> For example, communicating a bit of data over an ethernet network can be orders of magnitude more expensive than sending the same bit over a dedicated hardware communication channel. Similarly, if communication in sort-last is accelerated in hardware, as it is in several current commercial machines <ref> [17, 18, 19] </ref>, it may be less expensive according to some measures than communication in a sort-middle system that sends much less data. We can view hardware acceleration, then, as a way of reducing the real costs of critical or "bottlenecked" operations.
Reference: 19. <institution> Kubota Pacific Computer, </institution> <note> Denali Technical Overview, version 1.0, </note> <month> March </month> <year> 1993. </year>
Reference-contexts: The 1967 GE NASA II flight simulator used a simple version of SL-full in which a processor was assigned to each primitive [13]. Since then, several primitive-per-processor [3, 14] and multi ple-primitive-per-processor [15, 16] SL-full systems have been proposed. Several recent commercial systems have used SL-sparse <ref> [17, 18, 19] </ref>. We will examine sort-last in more detail shortly. Processing and communication model We now analyze each of the three rendering methods in more detail. The aim is to build a quantitative model of their processing and communication costs to use as a basis for comparing them. <p> For example, communicating a bit of data over an ethernet network can be orders of magnitude more expensive than sending the same bit over a dedicated hardware communication channel. Similarly, if communication in sort-last is accelerated in hardware, as it is in several current commercial machines <ref> [17, 18, 19] </ref>, it may be less expensive according to some measures than communication in a sort-middle system that sends much less data. We can view hardware acceleration, then, as a way of reducing the real costs of critical or "bottlenecked" operations.
Reference: 20. <author> S. Upstill, </author> <title> The RenderMan Companion, </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1989. </year>
Reference-contexts: We will, however, discuss these factors (particularly load balancing) where appropriate. Uniprocessor pipeline For the analysis that follows, we refine the rendering pipeline as shown in Figure 5. First, some rendering systems tessellate primitives in order to generate higher quality images (RenderMan <ref> [20] </ref> is one widely used example). Tessellation is the process of decomposing larger primitives into smaller ones, typically into polygons or polygonal meshes. Not all rendering packages tessellate. We include it in the pipeline because it can greatly expand the number of primitives that need to be displayed.
Reference: 21. <author> S. Molnar, </author> <title> Image-Composition Architectures for Real-Time Image Generation, </title> <type> Ph.D. Thesis, TR 91-046, </type> <institution> University of North Carolina at Chapel Hill, </institution> <month> October </month> <year> 1991. </year>
Reference-contexts: The following graph plots O for various region and bounding-box sizes. We have found that these values correlate well with data obtained from actual renderings <ref> [21] </ref>. <p> If the communication network in SL-full is implemented as a pipeline, increasing N increases the available communication bandwidth by the same factor, thereby stenciling the network to fit the algorithm. This gives it an unusual property of linear scalability <ref> [21] </ref>. Oversampling Many systems perform antialiasing by oversampling: calculating the color for some number of samples that lie within each pixel and filtering these samples down to one color. In sort-last systems that oversample, samples are treated as pixels and merged and processed similarly. <p> On sample datasets analyzed by the authors, depth complexity ranged from 0.53 to 12.9 with a median of 3.2 <ref> [21, 24] </ref>. From these results we conclude that SL-sparse requires less communication bandwidth than SL-full under most conditions.
Reference: 22. <author> D. Ellsworth, H. Good, B. Tebbs, </author> <title> Distributing Display Lists on a Multicomputer, </title> <booktitle> Computer Graphics (Proceedings 1990 Symposium on Interactive 3D Graphics), </booktitle> <volume> Vol. 24, No. 2, </volume> <month> March </month> <year> 1990, </year> <pages> pp. 147-155. </pages>
Reference-contexts: Load balancing Sort-middle can suffer load imbalances from object assignment and the clumping of primitives into regions in the same manner as sort-first. Load balancing the assignment of objects in hierarchical display structures has been explored <ref> [22] </ref>. The other problem, primitive clumping, has been the focus of much of the research in hardware [23] and software [4, 7, 12] sort-middle renderers. The main techniques are to make regions smaller (and more numerous) and to assign regions dynamically to processors.
Reference: 23. <author> F. Parke, </author> <title> Simulation and Expected Performance Analysis of Multiple Processor Z-buffer Systems, </title> <booktitle> Computer Graphics (Siggraph 80 Proceedings), </booktitle> <volume> Vol. 14, No. 3, </volume> <month> July </month> <year> 1980, </year> <pages> pp. 4856. </pages>
Reference-contexts: Load balancing the assignment of objects in hierarchical display structures has been explored [22]. The other problem, primitive clumping, has been the focus of much of the research in hardware <ref> [23] </ref> and software [4, 7, 12] sort-middle renderers. The main techniques are to make regions smaller (and more numerous) and to assign regions dynamically to processors.
Reference: 24. <author> M. Cox, P. Hanrahan, </author> <title> "Depth Complexity in Object-Parallel Graphics Architectures," </title> <booktitle> Proceedings of the Seventh Workshop on Graphics Hardware, Eurographics Technical Report Series, </booktitle> <pages> ISSN 1017-4656, </pages> <year> 1992, </year> <pages> pp. </pages> <year> 204222. </year>
Reference-contexts: First, there is the difference between sparse merging and full-frame merging. Sparse merging takes advantage of the observation that renderers in a sort-last system may generate pixels for only a fraction of the screen, and only these pixels need be merged <ref> [24] </ref>. Full-frame merging takes advantage of the fact that merging a full frame from each processor is very regular and can be done using simple hardware [16]. Second, even sparse merging algorithms may be improved in some cases. The simplest sparse algorithm merges every pixel rendered by every processor. <p> On sample datasets analyzed by the authors, depth complexity ranged from 0.53 to 12.9 with a median of 3.2 <ref> [21, 24] </ref>. From these results we conclude that SL-sparse requires less communication bandwidth than SL-full under most conditions.

References-found: 24

