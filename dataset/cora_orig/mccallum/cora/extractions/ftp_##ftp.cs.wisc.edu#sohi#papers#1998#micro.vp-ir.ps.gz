URL: ftp://ftp.cs.wisc.edu/sohi/papers/1998/micro.vp-ir.ps.gz
Refering-URL: http://www.cs.wisc.edu/mscalar/publications.html
Root-URL: http://www.cs.wisc.edu
Title: Abstract  
Abstract: Recently two hardware techniques Value Prediction (VP) and Instruction Reuse (IR) have been proposed for exploiting the redundancy in programs to collapse data dependences. In this paper, we attempt to understand the different ways in which VP and IR interact with other microarchitectural features and the impact of such interactions on net performance. More specifically, we perform the following tasks: (i) we identify the various differences between the two techniques and qualitatively discuss their microar-chitectural interactions, (ii) we evaluate the impact on performance of these interactions, and (iii) since IR is more restrictive of the two techniques, we also estimate the amount of total redundancy, present in programs, that can be captured by IR. Our results show that the performance obtained by VP is sensitive to the way branches with value-speculative operands are handled. We also see that, although IR captures less amount of redundancy, it may perform equally well because it validates results early, it is non-speculative, and it reduces branch misprediction penalty. Finally, we show that 84-97% of redundancy in programs can be reused, implying that the approach of detecting redundant instructions non-speculatively, based on their operands, does not significantly restrict IRs ability to capture redundancy present in programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Burger, T. M. Austin, and S. Bennett. </author> <title> Evaluating Future Microprocessors: The SimpleScalar Tool Set. </title> <type> Technical Report CS-TR-96-1308, </type> <institution> University of Wisconsin-Madison, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: Second, if the operand values for an invalidated entry become current again then the entry is reverted to the valid state. 4.1.3 Microarchitecture Our microarchitectural simulator is built on top of the SimpleScalar toolset <ref> [1] </ref>, an execution-driven simulator 1 One way to select the correct instance from among several instances is to read all instances out of the RB, and then perform the reuse test on each of them in parallel.
Reference: [2] <author> F. Gabbay and A. Mendelson. </author> <title> Speculative Execution based on Value Prediction. </title> <type> Technical Report EE Department TR 1080, </type> <institution> Technion - Israel Institute of Technology, </institution> <month> Nov. </month> <year> 1996. </year>
Reference-contexts: 1. Introduction Several recent studies <ref> [2, 5, 8, 10] </ref> have shown that there is significant result redundancy in programs, i.e., many instructions perform the same computation and, hence, produce the same result over and over again.
Reference: [3] <author> F. Gabbay and A. Mendelson. </author> <title> Using Value Prediction to Increase the Power of Speculative Execution Hardware. </title> <journal> ACM Transaction on Computer Systems (TOCS), </journal> <month> Aug. </month> <year> 1998. </year>
Reference-contexts: These studies have found that for several benchmarks more than 75% of the dynamic instructions produce the same result as before. Also, recently, two hardware techniques have been proposed to exploit this redundancy: (i) Value Prediction (VP) <ref> [3, 4, 5] </ref>, and (ii) Instruction Reuse (IR) [9]. Both techniques attempt to reduce the execution time of programs by alleviating the dataow constraint. They use the redundancy in programs to determine speculatively (Value Prediction) or non-speculatively (Instruction Reuse) the results of instructions without actually executing them.
Reference: [4] <author> M. H. Lipasti and J. P. Shen. </author> <title> Exceeding the Dataow Limit Via Value Prediction. </title> <booktitle> In Proc. of 29th International Symposium on Microarchitecture, </booktitle> <pages> pages 226237, </pages> <month> Dec. </month> <year> 1996. </year>
Reference-contexts: These studies have found that for several benchmarks more than 75% of the dynamic instructions produce the same result as before. Also, recently, two hardware techniques have been proposed to exploit this redundancy: (i) Value Prediction (VP) <ref> [3, 4, 5] </ref>, and (ii) Instruction Reuse (IR) [9]. Both techniques attempt to reduce the execution time of programs by alleviating the dataow constraint. They use the redundancy in programs to determine speculatively (Value Prediction) or non-speculatively (Instruction Reuse) the results of instructions without actually executing them. <p> Thus, we choose two comparable and realistic schemes to implement each of the technique. We describe these schemes below. 4.1.1 Value Predictor We implement VP using a scheme, which we call VP Magic . This scheme is like the last value predictor <ref> [4] </ref>, except that instead of saving only the last result of an instruction we save its last n unique results. With each result we also store a 2-bit confidence counter, which is incremented or decremented depending on whether prediction is right or wrong.
Reference: [5] <author> M. H. Lipasti, C. B. Wilkerson, and J. P. Shen. </author> <title> Value Locality and Load Value Prediction. </title> <booktitle> In Proc. of 7th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 138147, </pages> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: 1. Introduction Several recent studies <ref> [2, 5, 8, 10] </ref> have shown that there is significant result redundancy in programs, i.e., many instructions perform the same computation and, hence, produce the same result over and over again. <p> These studies have found that for several benchmarks more than 75% of the dynamic instructions produce the same result as before. Also, recently, two hardware techniques have been proposed to exploit this redundancy: (i) Value Prediction (VP) <ref> [3, 4, 5] </ref>, and (ii) Instruction Reuse (IR) [9]. Both techniques attempt to reduce the execution time of programs by alleviating the dataow constraint. They use the redundancy in programs to determine speculatively (Value Prediction) or non-speculatively (Instruction Reuse) the results of instructions without actually executing them.
Reference: [6] <author> S. MacFarling. </author> <title> Combining Branch Predictors. </title> <type> Technical Report TN-36, </type> <institution> WRL, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: Instruction fetch 4 insts per cycle. Only one taken branch per cycle. Cannot fetch across cache line boundaries in the same cycle. Instruction cache 64K bytes, 2-way set assoc., 32 byte line, 6 cycles miss latency. Branch predictor Gshare <ref> [6] </ref>. 10-bit history register, 16K entry counter table. Speculative execution mechanism O-o-O issue of 4 operations/cycle, 32 entry reorder buffer, 32 entry load/store queue. Max of 8 unresolved branches. Loads executed only after all preceding store addresses are known.
Reference: [7] <author> E. Rotenberg, Q. Jacobsen, Y. Sazeides, and J. E. Smith. </author> <title> Trace Processors. </title> <booktitle> In Proc. of 30th Annual International Symposium on Microarchitecture, </booktitle> <pages> pages 138148, </pages> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: We see that very few instructions (&lt; 0.5% in most cases) execute more than twice (similar results are also presented in section 5 of <ref> [7] </ref>), and hence, restricting the number of executions per instruction to 2 (as done by NME configuration) does not benefit much. 4.2.4 Net Performance VP Magic and IR In Figure 6, we show the impact on performance of the two techniques.
Reference: [8] <author> Y. Sazeides and J. E. Smith. </author> <title> The Predictability of Data Values. </title> <booktitle> In Proc. of 30th Annual international Symposium on Microarchitecture (MICRO-30), </booktitle> <pages> pages 248258, </pages> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: 1. Introduction Several recent studies <ref> [2, 5, 8, 10] </ref> have shown that there is significant result redundancy in programs, i.e., many instructions perform the same computation and, hence, produce the same result over and over again.
Reference: [9] <author> A. Sodani and G. S. Sohi. </author> <title> Dynamic Instruction Reuse. </title> <booktitle> In Proc. of 24th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 194205, </pages> <month> July </month> <year> 1997. </year>
Reference-contexts: These studies have found that for several benchmarks more than 75% of the dynamic instructions produce the same result as before. Also, recently, two hardware techniques have been proposed to exploit this redundancy: (i) Value Prediction (VP) [3, 4, 5], and (ii) Instruction Reuse (IR) <ref> [9] </ref>. Both techniques attempt to reduce the execution time of programs by alleviating the dataow constraint. They use the redundancy in programs to determine speculatively (Value Prediction) or non-speculatively (Instruction Reuse) the results of instructions without actually executing them. <p> We simulate this predictor because it permits us to observe how the various interactions we wish to study will shape up for programs where the value prediction performance is not high. 4.1.2 Reuse Scheme The IR scheme we simulate is S n+d , 2 described in <ref> [9] </ref>. In this scheme, results of instructions are stored in the RB along with two pieces of information needed for establishing the reusability of the result: (i) the operand register names and (ii) pointers to the RB entries of the instructions which produced values for the operands.
Reference: [10] <author> A. Sodani and G. S. Sohi. </author> <title> An Empirical Analysis of Instruction Repetition. </title> <booktitle> In Proc. of 8th International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <month> Oct. </month> <year> 1998. </year>
Reference-contexts: 1. Introduction Several recent studies <ref> [2, 5, 8, 10] </ref> have shown that there is significant result redundancy in programs, i.e., many instructions perform the same computation and, hence, produce the same result over and over again.
Reference: [11] <author> K. Wang and M. Franklin. </author> <title> Highly Accurate Data Value Prediction using Hybrid Predictors. </title> <booktitle> In Proc. of 30th Annual international Symposium on Microarchitecture (MICRO-30), </booktitle> <pages> pages 281290, </pages> <month> Dec. </month> <year> 1997. </year>
Reference-contexts: The IR scheme is capable of buffering different instances of an instruction and selecting the correct instance for reuse. 1 Since we did not want this difference to bias our evaluation, we choose to make VP scheme equally powerful. However, this VP scheme is still quite realistic; <ref> [11] </ref> describes a value prediction scheme, which buffers n results per instruction and accurately selects the prediction value from these n values. We also simulate the last value predictor, V LVP , which uses the last result of an instruction as a prediction for its future result.
References-found: 11

