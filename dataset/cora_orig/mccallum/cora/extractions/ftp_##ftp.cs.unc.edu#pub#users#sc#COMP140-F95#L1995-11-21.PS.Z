URL: ftp://ftp.cs.unc.edu/pub/users/sc/COMP140-F95/L1995-11-21.PS.Z
Refering-URL: http://www.cs.unc.edu/~sc/teaching/COMP140-F1995/lectures.html
Root-URL: http://www.cs.unc.edu
Title: COMP 140: Introduction to Translator Systems Linking and Loading 1 Linking and loading dynamic linking.
Author: Siddhartha Chatterjee 
Note: executed. This was prevalent in old machines where secondary storage was at a premium. The tradeoff is that relinking is required every time the program needs to be run. 3. Linking could be deferred until runtime, when missing external references are loaded if and when they are actually invoked by the program. This is called  that are not already present.  
Date: 21 November 1995  
Abstract: The high-level language source code that we started with has at this point been converted into an object module. This is almost executable machine code except for two differences: references to symbols that are external to the module, and relocatable references within the module. The job of the linker and the loader is to take one or more object modules and combine them to form a load module (also called binary module or executable module, or a.out in Unix parlance). The chief task in linking is the resolution of external references, i.e., the binding of the reference (which must be the name of an executable routine) to the memory location corresponding to the entry point of the machine code for that routine. This binding can be done at several points in the compile-execute cycle. 2. Linking could be performed to produce a load module that is saved as a binary file. Relocation is performed when the program is executed. This resolves the external references once but requires storage for the binary file. With the advent of virtual memory, relocation is implicitly handled and need not be performed during loading. This is essentially the scheme that we use in Unix. An object file in Unix can be in one of several different formats. Common formats include the traditional a.out format, COFF (Common Object File Format), and ELF (Executable and Linking Format). While the details differ, in all cases the files contain information about relocation and external references in addition to the text and data segments. Usually, there is a header containing the byte offets within the file at which these information records are located, and the number of such records. These offsets can be used as arguments to low-level file I/O calls like fseek and ftell. This allows the linker random access to the object files, so that it can skip over the parts of the file that it does not need to process at the moment. The input to the linker is a list of object files and library archives, which are typically processed in order. Certain runtime libraries (such as the standard C library libc.a) may be included by default at the end of this list. A library archive is much like object files except for two things: 
Abstract-found: 1
Intro-found: 1
References-found: 0

