URL: http://www.cse.psu.edu/~furer/Papers/splay-long.ps
Refering-URL: http://www.cse.psu.edu/~furer/Papers/bib.html
Root-URL: http://www.cse.psu.edu
Email: furer@cse.psu.edu  
Title: Randomized Splay Trees  
Author: Martin Furer 
Date: July 7, 1998  
Affiliation: Department of Computer Science and Engineering Pennsylvania State University  
Abstract: The performance of the original version of the splay tree algorithm has been unchallenged for over a decade. We present three randomized versions with better upper bounds on the expected running times (by constant factors). The improvements are particularly strong if the number of insertions is relatively small. All expectations are taken over the coin tosses of the randomized algorithms for worst case inputs. Hence slow running times are very unlikely for any input sequence. Algorithm A improves the expected running time, but can be very slow (with tiny probability). Algorithm B shows that without any loss in the original amortized running time, the expected running time can still be improved by a small percentage. Algorithm C has the same efficient expected running time as Algorithm A, while its (worst case) amortized running time deteriorates only by a constant factor. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Albers and M. Karpinski, </author> <title> Randomized splay trees, </title> <type> Manuscript, </type> <year> 1997. </year>
Reference-contexts: The version of this algorithm corresponding to full splaying (hence with a factor of 3 instead of 2) has been found independently by Albers and Karpinski <ref> [1] </ref>. 2 Here, the probability p (with 0 &lt; p 1) is an arbitrary positive constant. The Delete operation is handled within the same time, while Insert requires an additional (R + 1=p) log n + O (1) steps.
Reference: [2] <author> R. Chaudhuri and H. Hoft, </author> <title> Splaying a search tree in preorder takes linear time, </title> <booktitle> SIGACT News (ACM Special Interest Group on Automata and Computability Theory) 24 (1993), </booktitle> <volume> no. 2, </volume> <pages> 88-93. </pages>
Reference-contexts: Sleator and Tarjan [8] have also stated two interesting special cases as open problems, namely the Dynamic Finger Conjecture and the Traversal Conjecture. Various special cases have been solved for the original splaying algorithm <ref> [2, 5, 4] </ref>. Finally, the Dynamic Finger Conjecture has been solved [3]. An interesting challenge is to investigate whether the Dynamic Finger Conjecture and the Traversal Conjecture hold for any of the proposed randomized splaying algorithms.
Reference: [3] <author> R. Cole, </author> <title> On the dynamic finger conjecture for splay trees part II: The proof, </title> <type> Technical Report TR1995-701, </type> <address> New York University, </address> <month> August, </month> <year> 1995. </year>
Reference-contexts: Sleator and Tarjan [8] have also stated two interesting special cases as open problems, namely the Dynamic Finger Conjecture and the Traversal Conjecture. Various special cases have been solved for the original splaying algorithm [2, 5, 4]. Finally, the Dynamic Finger Conjecture has been solved <ref> [3] </ref>. An interesting challenge is to investigate whether the Dynamic Finger Conjecture and the Traversal Conjecture hold for any of the proposed randomized splaying algorithms.
Reference: [4] <author> R. Cole, B. Mishra, J. Schmidt, and A. Siegel, </author> <title> On the dynamic finger conjecture for splay trees part I: Splay sorting log n-block sequences, </title> <type> Technical Report TR1995-700, </type> <address> New York University, </address> <month> August, </month> <year> 1995. </year>
Reference-contexts: Sleator and Tarjan [8] have also stated two interesting special cases as open problems, namely the Dynamic Finger Conjecture and the Traversal Conjecture. Various special cases have been solved for the original splaying algorithm <ref> [2, 5, 4] </ref>. Finally, the Dynamic Finger Conjecture has been solved [3]. An interesting challenge is to investigate whether the Dynamic Finger Conjecture and the Traversal Conjecture hold for any of the proposed randomized splaying algorithms.
Reference: [5] <author> Richard Cole, </author> <title> On the dynamic finger conjecture for splay trees (extended abstract), </title> <booktitle> Proceedings of the Twenty Second Annual ACM Symposium on Theory of Computing (Bal-timore, </booktitle> <address> Maryland), </address> <month> 14-16 May </month> <year> 1990, </year> <pages> pp. 8-17. </pages>
Reference-contexts: Sleator and Tarjan [8] have also stated two interesting special cases as open problems, namely the Dynamic Finger Conjecture and the Traversal Conjecture. Various special cases have been solved for the original splaying algorithm <ref> [2, 5, 4] </ref>. Finally, the Dynamic Finger Conjecture has been solved [3]. An interesting challenge is to investigate whether the Dynamic Finger Conjecture and the Traversal Conjecture hold for any of the proposed randomized splaying algorithms.
Reference: [6] <author> Salvador Roura and Conrado Martinez, </author> <title> Randomization of search trees by subtree size, Algorithms | ESA '96, </title> <booktitle> Fourth Annual European Symposium (Barcelona, Spain), Lecture Notes in Computer Science, </booktitle> <volume> vol. 1136, </volume> <publisher> Springer, </publisher> <year> 1996, </year> <pages> pp. 91-106. </pages>
Reference-contexts: In Section 7 we address the Dynamic Optimality Conjecture for Algorithm A. For other work, investigating several variants of splaying, the reader is referred to [9, 7, 10] and the literature cited in the open problems section at the end of this paper. See also the related work <ref> [6] </ref>. 2 Rotation and Amortized Time Up to constant factors, we use the same potential as Sleator and Tarjan [8]. The size of a node is the number of nodes in its subtree, and the rank r (x) of a node x is the binary logarithm of its size.
Reference: [7] <author> B. Schoenmakers, </author> <title> A systematic analysis of splaying, </title> <journal> Information Processing Letters 45 (1993), </journal> <volume> no. 1, </volume> <pages> 41-50. </pages>
Reference-contexts: This analysis is the basis for Algorithms A - C presented in the three subsequent sections. In Section 7 we address the Dynamic Optimality Conjecture for Algorithm A. For other work, investigating several variants of splaying, the reader is referred to <ref> [9, 7, 10] </ref> and the literature cited in the open problems section at the end of this paper. See also the related work [6]. 2 Rotation and Amortized Time Up to constant factors, we use the same potential as Sleator and Tarjan [8].
Reference: [8] <author> D.D. Sleater and R.E. Tarjan, </author> <title> Self-adjusting binary search trees, </title> <editor> J. </editor> <booktitle> of the ACM 32 (1985), </booktitle> <volume> no. 3, </volume> <pages> 652-686. </pages>
Reference-contexts: 1 Introduction Splay trees <ref> [8] </ref> are the standard examples of self-adjusting binary search trees. They have great advantages over explicitly balanced trees, as they automatically adapt to various nonuniform access patterns. On the other hand, they also have an obvious disadvantage. <p> With the help of just one parameter, we can define a very natural and stable model of computation suitable for this task. The step size employed by Sleator and Tarjan <ref> [8] </ref> is the obvious one for their particular algorithm. One step not only accounts for one single rotation, but also for one comparison followed by traversing one edge down the tree searching for a node to access. <p> Notation 1.1 We denote the total number of operations by m, while n is the number of Insert operations. Hence, n is an upper bound on the size of the tree. The original paper of Sleator and Tarjan <ref> [8] </ref> not only proposes the standard (full) spaying, but also contains another version called semisplaying, where in the zig-zig case only the rotation around the upper edge is performed. <p> See also the related work [6]. 2 Rotation and Amortized Time Up to constant factors, we use the same potential as Sleator and Tarjan <ref> [8] </ref>. The size of a node is the number of nodes in its subtree, and the rank r (x) of a node x is the binary logarithm of its size. <p> Hence the analysis of the expected running time has to focus on a sequence of accesses like the analysis of the (worst case) amortized time. Indeed, we can inherit the model of amortized time that has been used for the traditional deterministic splaying algorithms <ref> [8] </ref>. For every access, an amount of t in = O (log n) is paid into the bank (i.e., added to the potential ). Furthermore, the bank makes payments which are determined by the change of the potential. <p> It is impossible that Algorithm C only does bad rotations on a long access path. Still, in the worst case, Algorithm C does not pick the best rotations. Only in the average (for each access) it does very well. 7 The Dynamic Optimality Conjecture The Dynamic Optimality Conjecture <ref> [8] </ref> says that standard splaying is (up to a constant factor) as good as doing any other sequence of rotations for every sequence of requests. We conjecture the same for all our versions of splaying. <p> We omit the proofs in this extended abstract. 9 8 Open Problems The interesting open problems ask whether the new algorithms can shed any new light on the Dynamic Optimality Conjecture <ref> [8] </ref>. In particular, are the Dynamic Optimality Conjectures for the various algorithms equivalent? Except for the equivalences of the previous section, the problems are open. Sleator and Tarjan [8] have also stated two interesting special cases as open problems, namely the Dynamic Finger Conjecture and the Traversal Conjecture. <p> 8 Open Problems The interesting open problems ask whether the new algorithms can shed any new light on the Dynamic Optimality Conjecture <ref> [8] </ref>. In particular, are the Dynamic Optimality Conjectures for the various algorithms equivalent? Except for the equivalences of the previous section, the problems are open. Sleator and Tarjan [8] have also stated two interesting special cases as open problems, namely the Dynamic Finger Conjecture and the Traversal Conjecture. Various special cases have been solved for the original splaying algorithm [2, 5, 4]. Finally, the Dynamic Finger Conjecture has been solved [3].
Reference: [9] <author> Ashok Subramanian, </author> <title> An explanation of splaying, </title> <journal> Journal of Algorithms 20 (1996), </journal> <volume> no. 3, </volume> <pages> 512-525. </pages>
Reference-contexts: This analysis is the basis for Algorithms A - C presented in the three subsequent sections. In Section 7 we address the Dynamic Optimality Conjecture for Algorithm A. For other work, investigating several variants of splaying, the reader is referred to <ref> [9, 7, 10] </ref> and the literature cited in the open problems section at the end of this paper. See also the related work [6]. 2 Rotation and Amortized Time Up to constant factors, we use the same potential as Sleator and Tarjan [8].
Reference: [10] <author> R. Sundar, Twists, </author> <title> turns, cascades, deque conjecture, and scanning theorem, </title> <booktitle> IEEE Symposium on Foundations of Computer Science (FOCS), </booktitle> <year> 1989, </year> <pages> pp. 555-559. 10 </pages>
Reference-contexts: This analysis is the basis for Algorithms A - C presented in the three subsequent sections. In Section 7 we address the Dynamic Optimality Conjecture for Algorithm A. For other work, investigating several variants of splaying, the reader is referred to <ref> [9, 7, 10] </ref> and the literature cited in the open problems section at the end of this paper. See also the related work [6]. 2 Rotation and Amortized Time Up to constant factors, we use the same potential as Sleator and Tarjan [8].
References-found: 10

