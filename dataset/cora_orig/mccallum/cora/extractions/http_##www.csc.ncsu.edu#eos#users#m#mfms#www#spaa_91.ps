URL: http://www.csc.ncsu.edu/eos/users/m/mfms/www/spaa_91.ps
Refering-URL: http://www.csc.ncsu.edu/eos/users/m/mfms/www/publications.html
Root-URL: http://www.csc.ncsu.edu
Title: A ONE-WAY ARRAY ALGORITHM FOR MATROID SCHEDULING  
Author: MATTHIAS F.M. STALLMANN 
Abstract: The greedy algorithm is a standard paradigm for solving matroid optimization problems on sequential computers. This paper presents a greedy algorithm suitable for a fully-pipelined linear array of processors, a generalization of Huang's algorithm [Hua90] for minimum spanning trees. Application of the algorithm to uniprocessor scheduling with release times and deadlines is discussed in detail. A key feature of the algorithm is its use of matroid contraction. 
Abstract-found: 1
Intro-found: 1
Reference: [Aig79] <author> M. Aigner. </author> <title> Combinatorial Theory. </title> <publisher> Springer Verlag, </publisher> <year> 1979. </year>
Reference-contexts: It can be shown, using for example the characterization of Bondy and Welsh (see <ref> [Aig79] </ref>, page 378), that M=fcg is not even a transversal matroid, much less a monotone scheduling matroid. Intuitively, at least 3 time slots are needed to represent the fact that fa i ; b i g is a circuit for each i, but the rank of M=fcg is 2. <p> Intuitively, at least 3 time slots are needed to represent the fact that fa i ; b i g is a circuit for each i, but the rank of M=fcg is 2. The smallest contraction-closed class of matroids known to contain monotone scheduling is the class of gammoids (see <ref> [Aig79] </ref>). Elements of a gammoid cannot be represented as succinctly as those of a scheduling matroid. 4. Implementation Details. We now describe how the optimum base is produced as output and illustrate, with an example, how the array algorithm works. <p> For example, were we to store all of A in our representation of f =A, and allow sufficient computational power per time unit to solve a linear system of equations, the generic one-way algorithm could be used to solve optimization problems on arbitrary linear matroids (see <ref> [Aig79] </ref> for a definition). Linear matroids include most problems that are of practical interest.
Reference: [AS85] <author> S. Ashtaputre and C. Savage. </author> <title> Systolic arrays with embedded tree structures for connectivity problems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-34(5):483 - 484, </volume> <year> 1985. </year>
Reference-contexts: They are simple, fault-tolerant (can work correctly when faulty processors are bypassed), and allow for pipelining of successive problem instances. They are also intriguing from a theoretical point of view. Several combinatorial problems that have efficient sequential algorithms also have one-way array algorithms. These include connected components <ref> [AS85, TM83] </ref>, biconnected components [SSP90], and minimum spanning trees [Hua90]. These algorithms are typically more elegant than their sequential counterparts, and require nontrivial insights. The purpose of this work is to propose a paradigm for solving matroid problems on one-way arrays, generalizing the algorithm of Huang [Hua90].
Reference: [Fre83] <author> G. N. Frederickson. </author> <title> Scheduling unit-time tasks with integer release times and deadlines. </title> <journal> Information Processing Letters, </journal> <volume> 16:171 - 173, </volume> <year> 1983. </year>
Reference-contexts: Lack of closure under contraction may also explain why the best time bound known for non-monotone scheduling is O (m log n + n 2 ) [GT84] and the known efficient algorithms for independence testing appear to require non-trivial data structures and use of random access memory <ref> [Fre83, GT85, LP81] </ref>.
Reference: [FS87] <author> G. N. Frederickson and M. A. Srinivas. </author> <title> On-line updating of solutions to a class of matroid intersection problems. </title> <journal> Information and Computation, </journal> <volume> 74:113 - 139, </volume> <year> 1987. </year>
Reference-contexts: Proof. See <ref> [FS87] </ref>. Suppose f (or e q ) is deleted and let B 0 be the earliest base (after the deletion) for which f; e is a swap wrt B 0 having w (f ) &gt; w (e).
Reference: [Glo67] <author> F. Glover. </author> <title> Maximum matching in a convex bipartite graph. </title> <journal> Naval Research Logistics Quarterly, </journal> <volume> 14:313 - 316, </volume> <year> 1967. </year>
Reference-contexts: A sort by increasing release time (and increasing deadline as a secondary key) would allow the 9 last cell to assign time slots to the elements it outputs using the algorithm of Glover <ref> [Glo67] </ref> (the next feasible slot is assigned to a task with earliest release time | earliest deadline is used to break ties).
Reference: [GT84] <author> H. N. Gabow and R. E. Tarjan. </author> <title> Efficient algorithms for a family of matroid intersection problems. </title> <journal> Journal of Algorithms, </journal> <volume> 5:80 - 131, </volume> <year> 1984. </year>
Reference-contexts: The remaining tasks can be scheduled arbitrarily late (or not at all). The best sequential time bound for deadline scheduling, O (m + n log n), is due to Gabow and Tarjan <ref> [GT84] </ref>. The one-way array algorithm also extends to the scheduling problem if release times as well as deadlines are considered, as long as the release times and deadlines obey a monotonicity restriction. <p> The monotone scheduling problem requires that any two tasks i and j having r i &lt; r j also have d i d j Monotone scheduling is a generalization of deadline scheduling. Gabow and Tarjan <ref> [GT84] </ref> give a sequential time bound of O (m log m + n 2 ) for scheduling with release times and deadlines (without the monotonicity restriction). <p> On-line algorithms on the RAM model exist for both the minimum spanning tree problem (using dynamic trees [ST83]), and the deadline scheduling problem (using a data structure described in <ref> [GT84] </ref>). In each case, the period (time between processing successive inputs) is fi (log n). The one-way array algorithm requires the same area (in this case n processors, each capable of storing a constant number of matroid elements) and has a constant period for both problems. <p> Proof. It is known (see, e.g. <ref> [GT84] </ref>) that s r 1 ; d 1 t, where s and t are chosen so that s r 0 ; d 0 t and ffi (A; s; t) = 0. If s a; b t, the lemma follows immediately. <p> roughly linear area) exist for matroids which have efficient (subquadratic) greedy algorithms, as has already been demonstrated for minimum spanning trees and monotone scheduling (the author is not aware of sequential algorithms specifically for monotone scheduling, but it is possible that techniques for deadline scheduling described by Gabow and Tarjan <ref> [GT84] </ref> can be generalized). One interesting open question related to one-way array algorithms for matroid prob 10 lems is whether there exists an efficient one-way array algorithm for the non-monotone scheduling problem. <p> Lack of closure under contraction may also explain why the best time bound known for non-monotone scheduling is O (m log n + n 2 ) <ref> [GT84] </ref> and the known efficient algorithms for independence testing appear to require non-trivial data structures and use of random access memory [Fre83, GT85, LP81].
Reference: [GT85] <author> H. N. Gabow and R. E. Tarjan. </author> <title> A linear-time algorithm for a special case of disjoint set union. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 30:209 - 221, </volume> <year> 1985. </year>
Reference-contexts: Lack of closure under contraction may also explain why the best time bound known for non-monotone scheduling is O (m log n + n 2 ) [GT84] and the known efficient algorithms for independence testing appear to require non-trivial data structures and use of random access memory <ref> [Fre83, GT85, LP81] </ref>.
Reference: [Hua90] <author> Shing-Tsaan Huang. </author> <title> A fully pipelined minimum-cost-spanning tree constructor. </title> <journal> Journal on Parallel and Distributed Computing, </journal> <volume> 9(1):55 - 62, </volume> <year> 1990. </year>
Reference-contexts: They are also intriguing from a theoretical point of view. Several combinatorial problems that have efficient sequential algorithms also have one-way array algorithms. These include connected components [AS85, TM83], biconnected components [SSP90], and minimum spanning trees <ref> [Hua90] </ref>. These algorithms are typically more elegant than their sequential counterparts, and require nontrivial insights. The purpose of this work is to propose a paradigm for solving matroid problems on one-way arrays, generalizing the algorithm of Huang [Hua90]. <p> These include connected components [AS85, TM83], biconnected components [SSP90], and minimum spanning trees <ref> [Hua90] </ref>. These algorithms are typically more elegant than their sequential counterparts, and require nontrivial insights. The purpose of this work is to propose a paradigm for solving matroid problems on one-way arrays, generalizing the algorithm of Huang [Hua90]. The paradigm yields an efficient one-way array algorithm for the scheduling problem described in the following paragraph, and suggests future work on one-way array algorithms for matroid problems. The deadline scheduling problem is defined as follows. <p> A generic linear-array algorithm for matroid optimization is presented, along with an efficient implementations for the deadline and monotone scheduling. The generic algorithm simplifies and generalizes an algorithm for the minimum spanning tree problem due to Huang <ref> [Hua90] </ref>. The one-way array algorithm has several advantages over the sequential greedy algorithm. First, it is an on-line algorithm, able to deal with matroid elements presented to it one at a time, in random order.
Reference: [Law76] <author> Eugene L. Lawler. </author> <title> Combinatorial Optimization: Networks and Matroids. </title> <publisher> Holt, Rinehart and Winston, </publisher> <year> 1976. </year>
Reference-contexts: It is not hard to show that any problem of this general form can be solved by the greedy algorithm, which repeatedly adds the largest weight element that can be added without violating independence (see, e.g. <ref> [Law76] </ref>). This paper discusses a variant of the greedy algorithm for a linear array of processors with one-way data flow. A generic linear-array algorithm for matroid optimization is presented, along with an efficient implementations for the deadline and monotone scheduling.
Reference: [LP81] <author> W. Lipski, Jr. and F. P. Preparata. </author> <title> Efficient algorithms for finding maximum matchings in convex bipartite graphs and related problems. </title> <journal> Acta Informatica, </journal> <volume> 15:329 - 346, </volume> <year> 1981. </year>
Reference-contexts: Lack of closure under contraction may also explain why the best time bound known for non-monotone scheduling is O (m log n + n 2 ) [GT84] and the known efficient algorithms for independence testing appear to require non-trivial data structures and use of random access memory <ref> [Fre83, GT85, LP81] </ref>.
Reference: [SSK87] <author> C. D. Savage, M. F.M. Stallmann, and A. Z. Kotob. </author> <title> Simulation of two-way computations on arrays with one-way data flow. </title> <type> Technical Report CCSP-TR-87/6, </type> <institution> North Carolina State University Center for Communications and Signal Processing, </institution> <year> 1987. </year>
Reference-contexts: Second, assume that each cell has the same initial value (a dummy record) before computation begins. This could be arranged by having a start marker propagate through the array before the first input record (see <ref> [SSK87] </ref>). Subsequent description of the algorithm ignores any complications having to do with output. <p> The solution (optimum base) can then be "pushed" out using techniques described in <ref> [SSP90, SSK87] </ref>. A more detailed description of how this is accomplished, and how the tasks of the optimum schedule in the scheduling problem can be tagged with their time slot assignments, is given in Section 4.
Reference: [SSP90] <author> C.D. Savage, M. Stallmann, and J.E. Perry. </author> <title> Solving some combinatorial problems on arrays with one-way dataflow. </title> <journal> Algorithmica, </journal> <volume> 5:179 - 199, </volume> <year> 1990. </year>
Reference-contexts: They are also intriguing from a theoretical point of view. Several combinatorial problems that have efficient sequential algorithms also have one-way array algorithms. These include connected components [AS85, TM83], biconnected components <ref> [SSP90] </ref>, and minimum spanning trees [Hua90]. These algorithms are typically more elegant than their sequential counterparts, and require nontrivial insights. The purpose of this work is to propose a paradigm for solving matroid problems on one-way arrays, generalizing the algorithm of Huang [Hua90]. <p> The Generic Algorithm. Some simplifications are used to describe the array algorithm. First note, as was observed by Savage et al. <ref> [SSP90] </ref>, that the actions of a one-way array can be described by tracing the actions of each individual input record as it propagates through the array. <p> The solution (optimum base) can then be "pushed" out using techniques described in <ref> [SSP90, SSK87] </ref>. A more detailed description of how this is accomplished, and how the tasks of the optimum schedule in the scheduling problem can be tagged with their time slot assignments, is given in Section 4.
Reference: [ST83] <author> D. D. Sleator and R. E. Tarjan. </author> <title> A data structure for dynamic trees. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 26:362 - 391, </volume> <year> 1983. </year>
Reference-contexts: On-line algorithms on the RAM model exist for both the minimum spanning tree problem (using dynamic trees <ref> [ST83] </ref>), and the deadline scheduling problem (using a data structure described in [GT84]). In each case, the period (time between processing successive inputs) is fi (log n).

References-found: 13

