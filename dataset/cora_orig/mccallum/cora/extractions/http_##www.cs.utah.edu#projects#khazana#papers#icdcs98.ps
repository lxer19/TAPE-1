URL: http://www.cs.utah.edu/projects/khazana/papers/icdcs98.ps
Refering-URL: http://www.cs.utah.edu/projects/khazana/index.html
Root-URL: 
Title: Khazana An Infrastructure for Building Distributed Services  
Author: John Carter Anand Ranganathan Sai Susarla 
Keyword: chronization operations.  
Date: Abstract  
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah  
Abstract: Essentially all distributed systems, applications, and services at some level boil down to the problem of managing distributed shared state. Unfortunately, while the problem of managing distributed shared state is shared by many applications, there is no common means of managing the data every application devises its own solution. We have developed Khazana, a distributed service exporting the abstraction of a distributed persistent globally shared store that applications can use to store their shared state. Khazana is responsible for performing many of the common operations needed by distributed applications, including replication, consistency management, fault recovery, access control, and location management. Using Khazana as a form of middleware, distributed applications can be quickly developed from corresponding uniprocessor applications through the insertion of Khazana data access and syn 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. Amza, A.L. Cox, S. Dwarkadas, P. Keleher, H. Lu, R. Rajamony, W. Yu, and W. Zwaenepoel. </author> <title> Tread-marks: Shared memory computing on networks of workstations. </title> <booktitle> In IEEE Computer, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: We are currently experimenting with various classes of applications using Khazana to validate this belief. 7 Related Work Building distributed applications and services on top of Khazana is analogous to building shared memory parallel applications on top of a software distributed shared memory system (DSM) <ref> [1, 8, 17, 21] </ref>. Just as parallelizing compute-intensive scientific programs using DSM simplifies the task of building and maintaining the parallel program, building distributed applications and services on top of Khazana will make them easier to build and maintain.
Reference: [2] <author> T.E. Anderson, M.D. Dahlin, J.M. Neefe, D.A. Patter-son, D.S. Roselli, and R.Y. Wang. </author> <title> Serverless network file systems. </title> <booktitle> In Proceedings of the 15th Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: It is most useful for disconnected operations and uses a very specialized weak consistency protocol. In the current implementation, Khazana does not support dis connected operations or such a protocol, although we are considering adding a coherence protocol similar to Bayou's for mobile data. Serverless file systems <ref> [2] </ref> utilize workstations on a closely coupled network, cooperating as peers to provide filesystem services.
Reference: [3] <author> J.K. Bennett, J.B. Carter, and W. Zwaenepoel. </author> <title> Adaptive software cache management for distributed shared memory architectures. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: In fact, unless the application ex-plicitly queries Khazana, it will be unaware that there are other applications accessing and caching the shared state. The application can specify the object's consistency requirements <ref> [3] </ref>. Currently, Khazana can support strictly consistent objects [19]. The application can also specify that a minimum number of replicas be maintained for fault-tolerance.
Reference: [4] <author> G. Brun-Cottan and M. Makpangou. </author> <title> Adaptable replicated objects in distributed environments. </title> <booktitle> 2nd BROADCAST Open Workshop, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Program modules called Consistency Managers (CMs) run at each of the replica sites and cooperate to implement the required level of consistency among the replicas as is done by Brun-Cottan <ref> [4] </ref>. A Khazana node treats lock requests on an object as indications of intent to access the object in the specified mode (read-only, read-write, write-shared, etc.). It obtains the local consistency manager's permission before granting such requests. <p> As a result, consistency management on fine-grain objects (small enough that many of them fit on a single region-page) is likely to incur a substantial overhead if false sharing is not addressed, although there are known techniques for addressing this problem <ref> [4, 9] </ref>. Khazana's CM interface adopts the approach of Brun-Cottan and Makpangou [4] to enable better application-specific conflict detection to address false sharing. 5 Implementation Status We currently have a working, single-cluster prototype of Khazana ready. Cluster hierarchies are yet to be implemented. <p> Khazana's CM interface adopts the approach of Brun-Cottan and Makpangou <ref> [4] </ref> to enable better application-specific conflict detection to address false sharing. 5 Implementation Status We currently have a working, single-cluster prototype of Khazana ready. Cluster hierarchies are yet to be implemented. We have been able to test the algorithms and infrastructure. <p> The notion of state is hidden within the objects and cannot be made visible to the lower layer except by explicit object serialization, which can be costly and cumbersome in many applications. This argument applies equally to object systems that provide replication management <ref> [4, 23] </ref>, but some of the techniques devel oped for explicitly managing replication and caching of individual objects would work well in a Khazana-like environment. For example, Brun-Cottan's approach to separating application-specific conflict-detection from generic consistency management [4] is used in Khazana as a modular consistency management framework. <p> This argument applies equally to object systems that provide replication management [4, 23], but some of the techniques devel oped for explicitly managing replication and caching of individual objects would work well in a Khazana-like environment. For example, Brun-Cottan's approach to separating application-specific conflict-detection from generic consistency management <ref> [4] </ref> is used in Khazana as a modular consistency management framework. Object databases [6, 7, 9, 18, 22] provide the necessary distributed storage abstraction, but most are implemented in a client-server environment and the systems we know of were not implemented with wide-area networks and high scalability in mind.
Reference: [5] <author> B. Callaghan. WebNFS: </author> <title> The filesystem for the Internet. </title> <note> http://sun.com/webnfs/wp-webnfs/, 1997. </note>
Reference-contexts: The discussion focuses on both the implementation issues involved and on how Khazana enables each application to be unaware of the fact that it is distributed. 4.1 Wide Area Distributed Filesystem Recently the notion of Internet-wide file systems has become popular <ref> [5, 11] </ref>. Some of the desirable characteristics of such a filesystem are simplicity, support for efficient handling of files with diverse access patterns (e.g., temporary files, system files, program development files), scalability, availability, and easy load balancing.
Reference: [6] <author> M. Carey, D. Dewitt, D. Frank, G. Graefe, J. Richards, E. Shekita, and M. Muralikrishna. </author> <title> The architecture of the EXODUS extensible DBMS. </title> <booktitle> In Proceedings of the 1st International Workshop on Object-Oriented Database Systems, </booktitle> <month> September </month> <year> 1996. </year>
Reference-contexts: In particular, Khazana itself does not provide a notion of objects, transactions, streams, or other higher semantic level operations often found in distributed object systems or object databases <ref> [6, 7, 9, 18, 22] </ref>. We believe that these features of a global storage system are useful to many applications, but are heavyweight and unnecessary for many others. <p> For example, Brun-Cottan's approach to separating application-specific conflict-detection from generic consistency management [4] is used in Khazana as a modular consistency management framework. Object databases <ref> [6, 7, 9, 18, 22] </ref> provide the necessary distributed storage abstraction, but most are implemented in a client-server environment and the systems we know of were not implemented with wide-area networks and high scalability in mind.
Reference: [7] <author> M. Carey, D. Dewitt, D. Naughton, J. Solomon, et al. </author> <title> Shoring up persistent applications. </title> <booktitle> In Proceedings, of the 1994 ACM SIGMOD Conf, </booktitle> <month> May </month> <year> 1994. </year>
Reference-contexts: In particular, Khazana itself does not provide a notion of objects, transactions, streams, or other higher semantic level operations often found in distributed object systems or object databases <ref> [6, 7, 9, 18, 22] </ref>. We believe that these features of a global storage system are useful to many applications, but are heavyweight and unnecessary for many others. <p> For example, Brun-Cottan's approach to separating application-specific conflict-detection from generic consistency management [4] is used in Khazana as a modular consistency management framework. Object databases <ref> [6, 7, 9, 18, 22] </ref> provide the necessary distributed storage abstraction, but most are implemented in a client-server environment and the systems we know of were not implemented with wide-area networks and high scalability in mind.
Reference: [8] <author> J.B. Carter, J.K. Bennett, and W. Zwaenepoel. </author> <title> Techniques for reducing consistency-related communication in distributed shared memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <month> August </month> <year> 1995. </year>
Reference-contexts: We are currently experimenting with various classes of applications using Khazana to validate this belief. 7 Related Work Building distributed applications and services on top of Khazana is analogous to building shared memory parallel applications on top of a software distributed shared memory system (DSM) <ref> [1, 8, 17, 21] </ref>. Just as parallelizing compute-intensive scientific programs using DSM simplifies the task of building and maintaining the parallel program, building distributed applications and services on top of Khazana will make them easier to build and maintain.
Reference: [9] <author> M. Castro, A. Adya, B. Liskov, and A.C. Myers. HAC: </author> <title> Hybrid adaptive caching for distributed storage systems. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Operating Systems Principles, </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: In particular, Khazana itself does not provide a notion of objects, transactions, streams, or other higher semantic level operations often found in distributed object systems or object databases <ref> [6, 7, 9, 18, 22] </ref>. We believe that these features of a global storage system are useful to many applications, but are heavyweight and unnecessary for many others. <p> As a result, consistency management on fine-grain objects (small enough that many of them fit on a single region-page) is likely to incur a substantial overhead if false sharing is not addressed, although there are known techniques for addressing this problem <ref> [4, 9] </ref>. Khazana's CM interface adopts the approach of Brun-Cottan and Makpangou [4] to enable better application-specific conflict detection to address false sharing. 5 Implementation Status We currently have a working, single-cluster prototype of Khazana ready. Cluster hierarchies are yet to be implemented. <p> For example, Brun-Cottan's approach to separating application-specific conflict-detection from generic consistency management [4] is used in Khazana as a modular consistency management framework. Object databases <ref> [6, 7, 9, 18, 22] </ref> provide the necessary distributed storage abstraction, but most are implemented in a client-server environment and the systems we know of were not implemented with wide-area networks and high scalability in mind.
Reference: [10] <institution> Microsoft Corp. </institution> <note> DCOM technical overview. http://microsoft.com/ntserver/library/dcomtec.exe. </note>
Reference-contexts: yet spent enough time tuning performance to make a judgement about the inherent cost of building distributed systems on top of a Khazana-like middleware layer. 4.2 Distributed Objects Another of the motivating applications for Khazana is an efficient implementation of a distributed objects runtime layer (e.g., CORBA [16] or DCOM <ref> [10] </ref>). To build a distributed object runtime system on top of Khazana, we plan to use Khazana as the repository for object data and for maintaining location information related to each object. <p> Khazana addresses these limitations of conventional DSM systems. Distributed object systems such as CORBA [16] and DCOM <ref> [10] </ref> provide uniform location-transparent naming and access to heterogeneous networked objects. Although these systems provide a convenient way for applications to access information in well-defined ways, they do not by themselves provide the basic functionality of managing shared state.
Reference: [11] <author> Microsoft Corp. </author> <title> Common Internet File System (CIFS). </title> <note> http://microsoft.com/intdev/cifs, 1997. </note>
Reference-contexts: The discussion focuses on both the implementation issues involved and on how Khazana enables each application to be unaware of the fact that it is distributed. 4.1 Wide Area Distributed Filesystem Recently the notion of Internet-wide file systems has become popular <ref> [5, 11] </ref>. Some of the desirable characteristics of such a filesystem are simplicity, support for efficient handling of files with diverse access patterns (e.g., temporary files, system files, program development files), scalability, availability, and easy load balancing.
Reference: [12] <author> A. Demers, K. Petersen, M. Spreitzer, D. Terry, M. Theimer, and B. Welch. </author> <title> The Bayou architecture: Support for data sharing among mobile users. </title> <booktitle> In Proceedings of the Workshop on Mobile Computing Systems and Applications, </booktitle> <month> December </month> <year> 1994. </year>
Reference-contexts: GMS [13] allows the operating system to utilize cluster-wide main memory to avoid disk accesses, which could support similar single-cluster applications as Khazana. However, GMS was not designed with scalability, persistence, security, high availability, or interoperability in mind, which will limit its applicability. Bayou <ref> [12] </ref> is a system designed to support data sharing among mobile users. Bayou focuses on providing a platform to build collaborative applications for users who are likely to be disconnected more often than not. It is most useful for disconnected operations and uses a very specialized weak consistency protocol.
Reference: [13] <author> M.J. Feeley, W.E. Morgan, F.H. Pighin, A.R. Karlin, H.M. Levy, and C.A. Thekkath. </author> <title> Implementing global memory management in a workstation cluster. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1995. </year>
Reference-contexts: On the other hand, Khazana attempts to provide infrastructure for the development and deployment of distributed services. However, it is conceivable that Khazana could use Petal for storage management | in such a scenario, Khazana would be the middleware between Petal and the distributed service. GMS <ref> [13] </ref> allows the operating system to utilize cluster-wide main memory to avoid disk accesses, which could support similar single-cluster applications as Khazana. However, GMS was not designed with scalability, persistence, security, high availability, or interoperability in mind, which will limit its applicability.
Reference: [14] <author> B. Ford, G. Back, G. Benson, J. Lepreau, A. Lin, and O. Shivers. </author> <title> The Flux OSKit: A substrate for OS and language research. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Operating Systems Principles, </booktitle> <month> Decem-ber </month> <year> 1995. </year>
Reference-contexts: Cluster hierarchies are yet to be implemented. We have been able to test the algorithms and infrastructure. We are currently porting the BSD Fast File System available as part of the OSKit <ref> [14] </ref> to use Khazana. Concurrently, a simplified distributed object system is being implemented using Khazana. The only consistency model we currently support is a Concurrent Read Exclusive Write (CREW) protocol [19].
Reference: [15] <author> K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. Hennessy. </author> <title> Memory consistency and event ordering in scalable shared-memory multiprocessors. </title> <booktitle> In Proceedings of the 17th Annual International Symposium on Computer Architecture, </booktitle> <month> May </month> <year> 1990. </year>
Reference-contexts: Given this consistency management framework, a variety of consistency protocols can be implemented for use by the Khazana to suit various application needs. For example, for the address map tree nodes, we use a release consistent protocol <ref> [15] </ref>. We plan to experiment with even more relaxed models for applications such as web caches and some database query engines for which release consistency is overkill.
Reference: [16] <author> Object Management Group. </author> <title> The Common Object Request Broker: Architecture and Specification, </title> <year> 1996. </year>
Reference-contexts: we have not yet spent enough time tuning performance to make a judgement about the inherent cost of building distributed systems on top of a Khazana-like middleware layer. 4.2 Distributed Objects Another of the motivating applications for Khazana is an efficient implementation of a distributed objects runtime layer (e.g., CORBA <ref> [16] </ref> or DCOM [10]). To build a distributed object runtime system on top of Khazana, we plan to use Khazana as the repository for object data and for maintaining location information related to each object. <p> Khazana addresses these limitations of conventional DSM systems. Distributed object systems such as CORBA <ref> [16] </ref> and DCOM [10] provide uniform location-transparent naming and access to heterogeneous networked objects. Although these systems provide a convenient way for applications to access information in well-defined ways, they do not by themselves provide the basic functionality of managing shared state.
Reference: [17] <author> K.L. Johnson, M.F. Kaashoek, and D.A. Wal-lach. </author> <title> CRL: High performance all-software distributed shared memory. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <year> 1995. </year>
Reference-contexts: We are currently experimenting with various classes of applications using Khazana to validate this belief. 7 Related Work Building distributed applications and services on top of Khazana is analogous to building shared memory parallel applications on top of a software distributed shared memory system (DSM) <ref> [1, 8, 17, 21] </ref>. Just as parallelizing compute-intensive scientific programs using DSM simplifies the task of building and maintaining the parallel program, building distributed applications and services on top of Khazana will make them easier to build and maintain.
Reference: [18] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The Objectstore database system. </title> <journal> Communications of the ACM, </journal> <month> October </month> <year> 1991. </year>
Reference-contexts: In particular, Khazana itself does not provide a notion of objects, transactions, streams, or other higher semantic level operations often found in distributed object systems or object databases <ref> [6, 7, 9, 18, 22] </ref>. We believe that these features of a global storage system are useful to many applications, but are heavyweight and unnecessary for many others. <p> For example, Brun-Cottan's approach to separating application-specific conflict-detection from generic consistency management [4] is used in Khazana as a modular consistency management framework. Object databases <ref> [6, 7, 9, 18, 22] </ref> provide the necessary distributed storage abstraction, but most are implemented in a client-server environment and the systems we know of were not implemented with wide-area networks and high scalability in mind.
Reference: [19] <author> L. Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690-691, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: In fact, unless the application ex-plicitly queries Khazana, it will be unaware that there are other applications accessing and caching the shared state. The application can specify the object's consistency requirements [3]. Currently, Khazana can support strictly consistent objects <ref> [19] </ref>. The application can also specify that a minimum number of replicas be maintained for fault-tolerance. <p> We are currently porting the BSD Fast File System available as part of the OSKit [14] to use Khazana. Concurrently, a simplified distributed object system is being implemented using Khazana. The only consistency model we currently support is a Concurrent Read Exclusive Write (CREW) protocol <ref> [19] </ref>. However, the system was designed so that plugging in new protocols or consistency managers is only a matter of registering them with Khazana, provided they export the required functionality. While the current implementation runs in a Unix environment, only the messaging layer is system dependent.
Reference: [20] <author> E.K. Lee and C.A. Thekkath. </author> <title> Petal: Distributed virtual disks. </title> <booktitle> In Proceedings 7th International Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: In effect, Khazana can be thought of as a globally accessible disk against which distributed applications read and write data, similar to Petal <ref> [20] </ref>. Unlike Petal, however, Khazana explicitly supports consistency management and is designed as a middleware layer for arbitrary distributed applications. <p> It uses URLs for naming, and supports application-specific coherency protocols. In contrast, Khazana exports a shared global cache coherent shared storage abstraction. For many distributed services with fine-grained objects like object systems, a file abstraction may be too heavyweight. Petal <ref> [20] </ref> exports the notion of a distributed virtual disk. It has been used to implement Frangipani [24] which is similar to the filesystem we envisage in Section 4.1. Petal works at a lower level than Khazana, in particular it provides no means of consistency management.
Reference: [21] <author> K. Li and P. Hudak. </author> <title> Memory coherence in shared virtual memory systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <month> November </month> <year> 1989. </year>
Reference-contexts: The address map is used to keep track of reserved and free regions within the global address space. It is also used to locate the home nodes of regions in much the same way that directories are used to track copies of pages in software DSM systems <ref> [21] </ref>. The address map is implemented as a distributed tree where each subtree describes a range of global address space in finer detail. <p> We are currently experimenting with various classes of applications using Khazana to validate this belief. 7 Related Work Building distributed applications and services on top of Khazana is analogous to building shared memory parallel applications on top of a software distributed shared memory system (DSM) <ref> [1, 8, 17, 21] </ref>. Just as parallelizing compute-intensive scientific programs using DSM simplifies the task of building and maintaining the parallel program, building distributed applications and services on top of Khazana will make them easier to build and maintain.
Reference: [22] <author> B. Liskov, A. Adya, M. Castro, M. Day, S. Ghemawat, R. Gruber, U. Maheshwari, A. C. Myers, and L. Shrira. </author> <title> Safe and efficient sharing of persistent objects in Thor. </title> <booktitle> In Proceedings of SIGMOD '96, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: In particular, Khazana itself does not provide a notion of objects, transactions, streams, or other higher semantic level operations often found in distributed object systems or object databases <ref> [6, 7, 9, 18, 22] </ref>. We believe that these features of a global storage system are useful to many applications, but are heavyweight and unnecessary for many others. <p> For example, Brun-Cottan's approach to separating application-specific conflict-detection from generic consistency management [4] is used in Khazana as a modular consistency management framework. Object databases <ref> [6, 7, 9, 18, 22] </ref> provide the necessary distributed storage abstraction, but most are implemented in a client-server environment and the systems we know of were not implemented with wide-area networks and high scalability in mind.
Reference: [23] <author> M. Makpangou, Y. Gourhant, J.L. Narzul, and M. Shapiro. </author> <title> Fragmented Objects for Distributed Abstractions. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: The notion of state is hidden within the objects and cannot be made visible to the lower layer except by explicit object serialization, which can be costly and cumbersome in many applications. This argument applies equally to object systems that provide replication management <ref> [4, 23] </ref>, but some of the techniques devel oped for explicitly managing replication and caching of individual objects would work well in a Khazana-like environment. For example, Brun-Cottan's approach to separating application-specific conflict-detection from generic consistency management [4] is used in Khazana as a modular consistency management framework.
Reference: [24] <author> C.A. Thekkath, T. Mann, and E.K. Lee. Frangipani: </author> <title> A scalable distributed file system. </title> <booktitle> In Proceedings 16th ACM Symposium on Operating Systems, </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: In contrast, Khazana exports a shared global cache coherent shared storage abstraction. For many distributed services with fine-grained objects like object systems, a file abstraction may be too heavyweight. Petal [20] exports the notion of a distributed virtual disk. It has been used to implement Frangipani <ref> [24] </ref> which is similar to the filesystem we envisage in Section 4.1. Petal works at a lower level than Khazana, in particular it provides no means of consistency management. Petal was conceived as a globally accessible, distributed storage system.
Reference: [25] <author> A. Vahdat, P. Eastham, and T. Anderson. WebFS: </author> <title> A global cache coherent filesystem. </title> <note> http://www.cs.berkeley.edu/~vahdat/webfs/webfs.html, 1996. </note>
Reference-contexts: There are many projects that closely resemble Kha-zana. Globe [26] provides functionality similar to Kha-zana but uses distributed shared objects as its base abstraction. We did not choose the same abstraction for the reasons outlined above. WebFS <ref> [25] </ref> is a global cache coherent file system to provide a common substrate for developing (distributed) Internet applications. Its goals are similar to those of Khazana, but it exports a file system as its base abstraction. It uses URLs for naming, and supports application-specific coherency protocols.
Reference: [26] <author> M. van Steen, P. Homburg, </author> <title> and A.S. Tanenbaum. Architectural design of globe: A wide-area distributed system. </title> <type> Technical Report IR-422, </type> <institution> Vrije Universiteit, Department of Mathematics and Computer Science, </institution> <month> March </month> <year> 1997. </year>
Reference-contexts: Therefore, they do not have the degree of aggressive caching and replication provided by Khazana. There are many projects that closely resemble Kha-zana. Globe <ref> [26] </ref> provides functionality similar to Kha-zana but uses distributed shared objects as its base abstraction. We did not choose the same abstraction for the reasons outlined above. WebFS [25] is a global cache coherent file system to provide a common substrate for developing (distributed) Internet applications.
Reference: [27] <author> R.Y. Wang and T.E. Anderson. xFS: </author> <title> A wide area mass storage file system. </title> <booktitle> In 4th Workshop on Workstation Operating Systems, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: The local storage system provides raw storage for pages without knowledge of global memory region boundaries or their semantics. There may be different kinds of local storage main memory, disk, local filesystem, tape, etc., organized into a storage hierarchy based on access speed, as in xFS <ref> [27] </ref>. The local storage system handles access to global pages stored locally. In response to allocation requests, the local storage system will attempt to locate available storage for the specified range of addresses. If available, it will simply allocate available local storage. <p> Serverless file systems [2] utilize workstations on a closely coupled network, cooperating as peers to provide filesystem services. Like Khazana, serverless file systems reject the use of servers and instead use a collection of peer processes to support a distributed system service. xFS <ref> [27] </ref> is a wide area mass storage filesystem with similar scalability goals as Khazana.
References-found: 27

