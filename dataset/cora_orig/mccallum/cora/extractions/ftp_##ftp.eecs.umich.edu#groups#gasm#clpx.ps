URL: ftp://ftp.eecs.umich.edu/groups/gasm/clpx.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: e-mail: Christoph.Beierle@fernuni-hagen.de  
Title: Formal Design of an Abstract Machine for Constraint Logic Programming  
Author: Christoph Beierle a 
Keyword: Keyword Codes: D.1.6, F.3.1 Keywords: Logic Programming, Specifying and Verifying about Programs  
Note: [To appear in: B. Pehrson, I. Simon (eds): Proceedings of the IFIP Congress 94, Elsevier, Amsterdam, 1994]  
Address: D-58084 Hagen, Germany  
Affiliation: a Fachbereich Informatik, Fernuniversitat Hagen,  
Abstract: By studying properties of CLP over an unspecified constraint domain X one obtains general results applicable to all instances of CLP(X ). The purpose of this paper is to study a general implementation scheme for CLP(X ) by designing a generic extension WAM(X ) of the WAM and a corresponding generic compilation scheme of CLP(X ) programs to WAM(X ) code which is based on Borger and Rosenzweig's WAM specification and correctness proof. Thus, using the evolving algebra specification method, we obtain not only a formal description of our WAM(X ) scheme, but also a mathematical correctness proof for the design. fl 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> H. At-Kaci. </author> <title> Warren's Abstract Machine: A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <address> Cam-bridge, MA, </address> <year> 1991. </year>
Reference-contexts: Unification Low-level unification in the WAM (X) can be carried out as in the WAM (see <ref> [1] </ref>) if we refine the bind operation into one that takes into account also the constraints of the variables (see [4] for the case of type constraints). The bind operation may thus also fail and initiate backtracking if the constraints are not satisfied. <p> For a discussion of these aspects we refer to <ref> [1] </ref> and [6]. In the case of type constraints we showed in [2] how the treamtment of these WAM optimizations in [6] carried over to the PAM, including the realization of the Cut operator.
Reference: 2. <author> C. Beierle and E. Borger. </author> <title> Correctness proof for the WAM with types. </title> <editor> In E. Borger, H. Kleine Buning, G. Jager, and M. M. Richter, editors, </editor> <booktitle> Computer Science Logic - CSL'91, volume 626 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: The description consists of several refinement levels together with correctness proofs, and a correctness proof w.r.t. Borger's phenomenological Prolog description [5]. Based on Borger and Rosenzweig's WAM description, <ref> [2] </ref> provides a mathematical specification of the PAM, a WAM extension to type-constraint logic programming, and proves its correctness w.r.t. <p> These approaches demonstrate how the evolving algebra approach naturally allows for modifications and extensions in the description of both the semantics of programming languages as well as in the description of implementation methods. However, both <ref> [2] </ref> and [7] aim at the specification and verification of specific systems that are within the constraint logic programming paradigm. <p> over the real numbers) of CLP [10], a framework for constraint handling in logic programming; similarly, the type constraints of PROTOS-L fl Acknowledgements: I am most grateful to Egon Borger for many fruitful and encouraging discussions; the research reported here has profited very much from our joint work described in <ref> [2] </ref> and [3]. 2 could be seen as an instance CLP (T YPE). On the other hand, many other approaches to constraint logic programming can be seen as instances of CLP. <p> Based on the mathematical WAM specification and correctness proof in [6], we extend the work of <ref> [2] </ref> to general constraints. Thus, we obtain not only a formal description of our WAM (X ) scheme, but also a mathematical correctness proof for the design. <p> Leaving the notion of terms and substitutions as abstract as in 2, we can use the compiled AND/OR structure development for Prolog 4 in [6] which was also used for PROTOS-L in <ref> [2] </ref> and for CLP (R) in [7]. Essentially we just have have to replace substitutions (resp. substitutions with type constraints) by the more general constraint systems, where the new instruction add constraint enlarges the current constraint system accumulated so far. 4. <p> For a discussion of these aspects we refer to [1] and [6]. In the case of type constraints we showed in <ref> [2] </ref> how the treamtment of these WAM optimizations in [6] carried over to the PAM, including the realization of the Cut operator.
Reference: 3. <author> C. Beierle and E. Borger. </author> <title> Evolving algebra specification of an abstract machine for constraint logic programming. </title> <type> Technical Report, </type> <institution> FernUniversitat Hagen, </institution> <year> 1994. </year> <note> (to appear). </note>
Reference-contexts: real numbers) of CLP [10], a framework for constraint handling in logic programming; similarly, the type constraints of PROTOS-L fl Acknowledgements: I am most grateful to Egon Borger for many fruitful and encouraging discussions; the research reported here has profited very much from our joint work described in [2] and <ref> [3] </ref>. 2 could be seen as an instance CLP (T YPE). On the other hand, many other approaches to constraint logic programming can be seen as instances of CLP. <p> For notational convenience we will, however, stick to the names CLP (X ) and WAM (X ). Furthermore, we assume that the reader is familiar with the WAM and the WAM specification given in [6]. For further details of the WAM (X ) specification we refer to <ref> [3] </ref>. 2. AN ABSTRACT NOTION OF CONSTRAINTS The basic universes and functions in CLP (X ) algebras dealing with terms and substitutions are taken directly from the standard Prolog algebras.
Reference: 4. <author> C. Beierle and G. Meyer. </author> <title> Run-time type computations in the Warren Abstract Machine. </title> <journal> The Journal of Logic Programming, </journal> <volume> 18(2) </volume> <pages> 123-148, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Borger's phenomenological Prolog description [5]. Based on Borger and Rosenzweig's WAM description, [2] provides a mathematical specification of the PAM, a WAM extension to type-constraint logic programming, and proves its correctness w.r.t. PROTOS-L, a logic programming language with polymorphic order-sorted types <ref> [4] </ref>. [7] extends the correctness proof in [6] to the compilation of CLP (R) programs to the Constraint Logic Arithmetic Machine (CLAM) [12], [11]. <p> Unification Low-level unification in the WAM (X) can be carried out as in the WAM (see [1]) if we refine the bind operation into one that takes into account also the constraints of the variables (see <ref> [4] </ref> for the case of type constraints). The bind operation may thus also fail and initiate backtracking if the constraints are not satisfied.
Reference: 5. <author> E. Borger. </author> <title> A logical operational semantics of full Prolog. Part I. Selection core and control. </title> <editor> In E. Borger, H. Kleine Buning, and M. M. Richter, editors, </editor> <booktitle> CSL'89 3rd Workshop on Computer Science Logic, volume 440 of Lecture Notes in Computer Science, </booktitle> <pages> pages 36-64. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference-contexts: The description consists of several refinement levels together with correctness proofs, and a correctness proof w.r.t. Borger's phenomenological Prolog description <ref> [5] </ref>. Based on Borger and Rosenzweig's WAM description, [2] provides a mathematical specification of the PAM, a WAM extension to type-constraint logic programming, and proves its correctness w.r.t.
Reference: 6. <author> E. Borger and D. Rosenzweig. </author> <title> The WAM definition and compiler correctness. </title> <editor> In C. Beierle and L. Plumer, editors, </editor> <booktitle> Logic Programming: Formal Methods and Practical Applications, Studies in Computer Science and Artificial Intelligence. </booktitle> <publisher> North-Holland, </publisher> <year> 1994. </year> <note> (to appear). </note>
Reference-contexts: 1. INTRODUCTION Recently, Gurevich's evolving algebra approach has not only been used for the description of the (operational) semantics of various programming languages (Modula-2, Occam, Prolog, Prolog III, Smalltalk, Parlog, C; see [9]), but also for the description and analysis of implementation methods: Borger and Rosenzweig <ref> [6] </ref> provide a mathematical elaboration of Warren's Abstract Machine [14,1] for executing Prolog. The description consists of several refinement levels together with correctness proofs, and a correctness proof w.r.t. Borger's phenomenological Prolog description [5]. <p> Borger's phenomenological Prolog description [5]. Based on Borger and Rosenzweig's WAM description, [2] provides a mathematical specification of the PAM, a WAM extension to type-constraint logic programming, and proves its correctness w.r.t. PROTOS-L, a logic programming language with polymorphic order-sorted types [4]. [7] extends the correctness proof in <ref> [6] </ref> to the compilation of CLP (R) programs to the Constraint Logic Arithmetic Machine (CLAM) [12], [11]. These approaches demonstrate how the evolving algebra approach naturally allows for modifications and extensions in the description of both the semantics of programming languages as well as in the description of implementation methods. <p> Based on the mathematical WAM specification and correctness proof in <ref> [6] </ref>, we extend the work of [2] to general constraints. Thus, we obtain not only a formal description of our WAM (X ) scheme, but also a mathematical correctness proof for the design. <p> Although in this paper we keep the domain X of constraints abstract, we will provide one further step of reuse of logic programming and WAM technology (and of the evolving algebra specification of <ref> [6] </ref> as well). Since a constraint solver for X also gives us a constraint solver for equational constraints in T (X ), the algebra of freely generated terms over X , we will consider such constraints over T (X ). <p> For notational convenience we will, however, stick to the names CLP (X ) and WAM (X ). Furthermore, we assume that the reader is familiar with the WAM and the WAM specification given in <ref> [6] </ref>. For further details of the WAM (X ) specification we refer to [3]. 2. AN ABSTRACT NOTION OF CONSTRAINTS The basic universes and functions in CLP (X ) algebras dealing with terms and substitutions are taken directly from the standard Prolog algebras. <p> Leaving the notion of terms and substitutions as abstract as in 2, we can use the compiled AND/OR structure development for Prolog 4 in <ref> [6] </ref> which was also used for PROTOS-L in [2] and for CLP (R) in [7]. Essentially we just have have to replace substitutions (resp. substitutions with type constraints) by the more general constraint systems, where the new instruction add constraint enlarges the current constraint system accumulated so far. 4. <p> TERM REPRESENTATION The representation of terms and substitutions in the WAM (X ) can be introduced in several steps. Following the development in <ref> [6] </ref> we first introduce the treatment of the low-level run-time unification but we keep the (non-equational) constraints completely abstract. Thus, in the WAM (X ) algebras to be developed here we introduce a 0-ary function xcs holding the current non-substitutional constraint system accumulated so far. <p> The bind operation may thus also fail and initiate backtracking if the constraints are not satisfied. Thus, we can use the treatment of unification as described in <ref> [6] </ref>, while leaving the bind operation abstract for the moment, not only in order to postpone the discussion of occur check and trailing but also to stress the fact that the bind operation will take care of the constraints for the variables. <p> For the WAM (X ) algebras developed so far from CLP (X ) algebras with compiled AND/OR structure we can now generalize the "Pure Prolog Theorem" of <ref> [6] </ref>. 6 5.3. <p> For a discussion of these aspects we refer to [1] and <ref> [6] </ref>. In the case of type constraints we showed in [2] how the treamtment of these WAM optimizations in [6] carried over to the PAM, including the realization of the Cut operator. <p> For a discussion of these aspects we refer to [1] and <ref> [6] </ref>. In the case of type constraints we showed in [2] how the treamtment of these WAM optimizations in [6] carried over to the PAM, including the realization of the Cut operator. The same argumentation applies to the WAM (X ) extension since no constraint related actions are involved, allowing us to extend the correctnes theorems of [6] to the full WAM (X ) with all WAM characteristics like environment <p> we showed in [2] how the treamtment of these WAM optimizations in <ref> [6] </ref> carried over to the PAM, including the realization of the Cut operator. The same argumentation applies to the WAM (X ) extension since no constraint related actions are involved, allowing us to extend the correctnes theorems of [6] to the full WAM (X ) with all WAM characteristics like environment trimming, LCO, or indexing.
Reference: 7. <author> E. Borger and R. Salamone. </author> <title> CLAM specification for provably correct compilation of CLP(R) programs. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods for Programming Languages and Systems. </title> <publisher> Oxford University Press, </publisher> <year> 1994. </year> <note> (to appear). </note>
Reference-contexts: Borger's phenomenological Prolog description [5]. Based on Borger and Rosenzweig's WAM description, [2] provides a mathematical specification of the PAM, a WAM extension to type-constraint logic programming, and proves its correctness w.r.t. PROTOS-L, a logic programming language with polymorphic order-sorted types [4]. <ref> [7] </ref> extends the correctness proof in [6] to the compilation of CLP (R) programs to the Constraint Logic Arithmetic Machine (CLAM) [12], [11]. <p> These approaches demonstrate how the evolving algebra approach naturally allows for modifications and extensions in the description of both the semantics of programming languages as well as in the description of implementation methods. However, both [2] and <ref> [7] </ref> aim at the specification and verification of specific systems that are within the constraint logic programming paradigm. <p> Leaving the notion of terms and substitutions as abstract as in 2, we can use the compiled AND/OR structure development for Prolog 4 in [6] which was also used for PROTOS-L in [2] and for CLP (R) in <ref> [7] </ref>. Essentially we just have have to replace substitutions (resp. substitutions with type constraints) by the more general constraint systems, where the new instruction add constraint enlarges the current constraint system accumulated so far. 4.
Reference: 8. <author> A. Colmerauer. </author> <title> An introduction to Prolog-III. </title> <journal> Communications of the ACM, </journal> <volume> 33(7) </volume> <pages> 69-906, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: On the other hand, many other approaches to constraint logic programming can be seen as instances of CLP. E.g., Trilogy [13] could be viewed as CLP (Z), or Prolog III <ref> [8] </ref> could be viewed as instantiating CLP by constraints over boolean and rational terms. Thus, by studying properties of CLP over an unspecified constraint domain X (denoted by CLP (X ) in the sequel) one obtains general results applicable to all instances of CLP (X ).
Reference: 9. <author> Y. Gurevich. </author> <title> Evolving algebras. A tutorial introduction. </title> <journal> EATCS Bulletin, </journal> <volume> 43, </volume> <month> February </month> <year> 1991. </year>
Reference-contexts: 1. INTRODUCTION Recently, Gurevich's evolving algebra approach has not only been used for the description of the (operational) semantics of various programming languages (Modula-2, Occam, Prolog, Prolog III, Smalltalk, Parlog, C; see <ref> [9] </ref>), but also for the description and analysis of implementation methods: Borger and Rosenzweig [6] provide a mathematical elaboration of Warren's Abstract Machine [14,1] for executing Prolog. The description consists of several refinement levels together with correctness proofs, and a correctness proof w.r.t. Borger's phenomenological Prolog description [5].
Reference: 10. <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1987. </year>
Reference-contexts: However, both [2] and [7] aim at the specification and verification of specific systems that are within the constraint logic programming paradigm. CLP (R) is a particular instance (by arithmetic constraints over the real numbers) of CLP <ref> [10] </ref>, a framework for constraint handling in logic programming; similarly, the type constraints of PROTOS-L fl Acknowledgements: I am most grateful to Egon Borger for many fruitful and encouraging discussions; the research reported here has profited very much from our joint work described in [2] and [3]. 2 could be seen
Reference: 11. <author> J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> An abstract machine for CLP(R). </title> <type> Technical report, </type> <institution> IBM Research Devision, </institution> <year> 1992. </year>
Reference-contexts: PROTOS-L, a logic programming language with polymorphic order-sorted types [4]. [7] extends the correctness proof in [6] to the compilation of CLP (R) programs to the Constraint Logic Arithmetic Machine (CLAM) [12], <ref> [11] </ref>. These approaches demonstrate how the evolving algebra approach naturally allows for modifications and extensions in the description of both the semantics of programming languages as well as in the description of implementation methods.
Reference: 12. <author> J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(R) language and system. </title> <journal> ACM TOPLAS, </journal> <pages> pages 339-395, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: PROTOS-L, a logic programming language with polymorphic order-sorted types [4]. [7] extends the correctness proof in [6] to the compilation of CLP (R) programs to the Constraint Logic Arithmetic Machine (CLAM) <ref> [12] </ref>, [11]. These approaches demonstrate how the evolving algebra approach naturally allows for modifications and extensions in the description of both the semantics of programming languages as well as in the description of implementation methods.
Reference: 13. <author> P. Voda. </author> <title> The constraint language Trilogy. </title> <type> Technical report, </type> <institution> Complete Logic Systems, North Vancouver, BC, Canada, </institution> <year> 1988. </year>
Reference-contexts: On the other hand, many other approaches to constraint logic programming can be seen as instances of CLP. E.g., Trilogy <ref> [13] </ref> could be viewed as CLP (Z), or Prolog III [8] could be viewed as instantiating CLP by constraints over boolean and rational terms.
Reference: 14. <author> D. H. D. Warren. </author> <title> An Abstract PROLOG Instruction Set. </title> <type> Technical Report 309, </type> <institution> SRI, </institution> <year> 1983. </year>
References-found: 14

