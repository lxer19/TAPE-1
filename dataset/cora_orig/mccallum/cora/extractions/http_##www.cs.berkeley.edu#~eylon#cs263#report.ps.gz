URL: http://www.cs.berkeley.edu/~eylon/cs263/report.ps.gz
Refering-URL: http://www.cs.berkeley.edu/~eylon/cs263/
Root-URL: http://www.cs.berkeley.edu
Title: Binding Time Analysis for Bits CS-263 Course Project  
Author: Eylon Caspi 
Date: May 25, 1998  
Abstract: Using a high level language (HLL) to specify a computation for synthesis in ASIC or FPGA hardware requires aggressive compiler analysis to capture bit-level program characteristics that cannot normally be expressed in a HLL but which are important to specializing and optimizing logic for size and speed. It is useful, for instance, to identify unchanging bits of a variable and subsequently remove using partial evaluation any logic which depends on them. We describe a binding-time analysis for bits which can identify static and dynamic bits of computed expressions. The analysis proves to be expensive, possibly taking logarithmically as many steps as the actual binary computation.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> William Blume, Rudolf Eigenmann, </author> <title> "Symbolic Range Propagation," </title> <booktitle> Proc. 9th International Parallel Processing Symposium, </booktitle> <address> Santa Barbara, California, </address> <month> April 25-28 </month> <year> 1995, </year> <pages> pp. 357-363. </pages>
Reference-contexts: We would like to develop compiler analysis techniques to discover certain bit-level characteristics which are not expressible in C and which lead to wasted computation. Discovering unused high-order bits of integral quantities can be accomplished by known techniques of value range analysis [2] <ref> [1] </ref>, which computes via data-flow analysis a range [l; u] of possible values for every numerical expression in a program. The purpose of such an analysis in microprocessor-oriented compiler technology is primarily to predict the outcome of conditional statements involving numerical comparisons. <p> As such, the high cost and weak yield of inverse abstract operators may make their use impractical. To better handle numerical inequality comparisons, we might combine bit binding-time analysis with value-range analysis [2] <ref> [1] </ref> whose representation of contiguous value ranges is better suited for such comparisons. 3 Compiler Analysis Framework The abstract interpretation described in the previous section could be used in a number of compiler analysis framework.
Reference: [2] <author> William H. Harrison, </author> <title> "Compiler analysis of the value ranges for variables," </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> vol. SE-3, no. 3, </volume> <pages> pp. 243-250, </pages> <month> May </month> <year> 1977. </year>
Reference-contexts: We would like to develop compiler analysis techniques to discover certain bit-level characteristics which are not expressible in C and which lead to wasted computation. Discovering unused high-order bits of integral quantities can be accomplished by known techniques of value range analysis <ref> [2] </ref> [1], which computes via data-flow analysis a range [l; u] of possible values for every numerical expression in a program. The purpose of such an analysis in microprocessor-oriented compiler technology is primarily to predict the outcome of conditional statements involving numerical comparisons. <p> As such, the high cost and weak yield of inverse abstract operators may make their use impractical. To better handle numerical inequality comparisons, we might combine bit binding-time analysis with value-range analysis <ref> [2] </ref> [1] whose representation of contiguous value ranges is better suited for such comparisons. 3 Compiler Analysis Framework The abstract interpretation described in the previous section could be used in a number of compiler analysis framework.
Reference: [3] <author> Luke Hornof, Jacques Noye, </author> <title> "Accurate binding-time analysis for imperative languages: flow, context, and return sensitivity," </title> <booktitle> Proc. ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation (PEPM'97), </booktitle> <address> Amsterdam, The Netherlands, </address> <month> June 12-13 </month> <year> 1997, </year> <pages> pp. 63-73. </pages>
Reference-contexts: In section 2 we discuss an abstract interpretation suitable for propagating bit staticness information in a data-flow analysis. In section 3 we discuss a framework for bit-level compiler analysis based on the word-level analysis of Hornof and Noye <ref> [3] </ref>. <p> In this section we describe how it could be used in a particular context-sensitive data-flow analysis framework. This framework is based on the word-level binding-time analysis engine of Hornof and Noye <ref> [3] </ref>, which assigns to each expression and statement of a C program a binding-time in the lattice: unknown @ static @ dynamic. <p> Data-flow equations describe the relation between each statement's pre-state and post-state based on the operations of that statement. The equations can be solved iteratively to find all program states, simultaneously computing expression and statement binding-times consistent with those states. The data-flow equations relating program states, as given by <ref> [3] </ref>, are shown in figure 4. The state transfer functions t s () and t s;e () account for state updates in assignment statements and control-flow statements, respectively. Their formal definitions are given in figure 5. <p> Their formal definitions are given in figure 5. Note the use of functions defs (s) and unambiguous-defs (s) which compute the set of locations possibly-defined and unambiguously-defined by statement s, respectively. These functions derive from prior liveness analysis and pointer alias analysis. In the language of <ref> [3] </ref>, a location is unambiguously-defined by an assignment if the location is not aliased, i.e. if no more than one location can be affected by the assignment. The statement/expression binding-time propagation functions used by the state transfer functions t s (); t s;e () are shown in figure 6. <p> The statement/expression binding-time propagation functions used by the state transfer functions t s (); t s;e () are shown in figure 6. Several departures are taken from the analysis of <ref> [3] </ref>. Statement binding-times remain in the 3-valued domain unknown @ static @ dynamic, while expression binding-times are in the new domain D 7 . <p> ) t (t loc2aliases (e) lookup (; loc)) exp e 1 2 : exp-bt (e; ) = bop-bt (e 1 ; e 2 ; ) left-hand expressions: id e : lexp-bt (e; ) = ? fl e exp e 0 : lexp-bt (e; ) = exp-bt (e 0 ; ) <ref> [3] </ref>. if s (exp e ) stmt s 1 1 else stmt s 2 2 : [[s 1 ]] in = [[s]] in t t e ([[s]] in ) [[s]] out = t e;s 1 ([[s 1 ]] out ) t t e;s 2 ([[s 2 ]] out ) do s
Reference: [4] <author> Chunho Lee, Miodrag Potkanjak, William H. Mangione-Smith, "Media-Bench: </author> <title> a tool for evaluating and synthesizing multimedia and communication systems," </title> <booktitle> Proc. 30th International Symposium on Microarchitecture, </booktitle> <institution> Research Triangle Park, North Carolina, </institution> <month> Dec. 1-3 </month> <year> 1997, </year> <pages> pp. 330-333. 15 </pages>
Reference-contexts: Recent empirical findings in U.C.Berkeley's BRASS 1 group suggest that such undiscovered bit-level characteristics are frequent and lead to significant wasted computation. In a variety of C programs from such sources as SPEC '95 and the UCLA MediaBench suite <ref> [4] </ref>, program profiling has found that typically 50% of bit-level read-accesses to program variables retrieve bits that never change during the course of a program run. Furthermore, typically over 90% of these bit-reads are to unchanging high- or low-order bit-ranges of variables.
References-found: 4

