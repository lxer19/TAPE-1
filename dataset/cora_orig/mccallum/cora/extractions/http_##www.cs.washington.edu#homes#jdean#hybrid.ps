URL: http://www.cs.washington.edu/homes/jdean/hybrid.ps
Refering-URL: http://www.cs.washington.edu/homes/jdean/papers.html
Root-URL: 
Email: chambers-@cs.washington.edu  
Phone: (206) 616-1849; fax: (206) 543-2969  
Title: Vortex: An Optimizing Compiler for Object-Oriented Languages  
Author: Jeffrey Dean, Greg DeFouw, David Grove, Vassily Litvinov, and Craig Chambers 
Note: A Research Paper in Language Implementation  
Address: Box 352350, Seattle, Washington 98195-2350 USA  -jdean, gdefouw, grove, vass,  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: Previously, techniques such as class hierarchy analysis and profile-guided receiver class prediction have been demonstrated to greatly improve the performance of applications written in pure object-oriented languages, but the degree to which these results are transferable to applications written in hybrid languages is still unclear. We have developed the Vortex compiler infrastructure, a language-independent optimizing compiler for object-oriented languages, with front-ends for Cecil, C++, and Modula-3, that incorporates these optimizations. In this paper, we describe the Vortex compiler technology and present the results of the first controlled study of these techniques across a range of pure and hybrid object-oriented languages, for medium-sized applications. As an integral part of this study, we define a set of metrics that characterize aspects of the underlying structure of an application and use them to more precisely characterize the studied programs. 
Abstract-found: 1
Intro-found: 1
Reference: [Agesen & Hlzle 95] <author> Ole Agesen and Urs Hlzle. </author> <title> Type Feedback vs. Concrete Type Analysis: A Comparison of Optimization Techniques for Object-Oriented Languages. </title> <booktitle> In In OOPSLA95 Conference Proceedings, </booktitle> <pages> pages 91107, </pages> <address> Austin, Tx, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Agesen and Hlzle compared the effectiveness of the Cartesian Product type inference algorithm [Agesen 95] with profile-guided receiver-class prediction for Self programs <ref> [Agesen & Hlzle 95, Agesen & Hlzle 96] </ref>. Their results indicated that the two techniques had similar effectiveness at optimizing message sends.
Reference: [Agesen & Hlzle 96] <author> Ole Agesen and Urs Hlzle. </author> <title> Dynamic vs. Static Optimization Techniques for Object-Oriented Languages. </title> <journal> Theory and Practive of Object Systems, </journal> <volume> 1(3), </volume> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: Agesen and Hlzle compared the effectiveness of the Cartesian Product type inference algorithm [Agesen 95] with profile-guided receiver-class prediction for Self programs <ref> [Agesen & Hlzle 95, Agesen & Hlzle 96] </ref>. Their results indicated that the two techniques had similar effectiveness at optimizing message sends.
Reference: [Agesen 95] <author> Ole Agesen. </author> <title> The Cartesian Product Algorithm: Simple and Precise Type Inference of Parametric Polymorphism. </title> <booktitle> In Proceedings ECOOP 95, </booktitle> <address> Aarhus, Denmark, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: Further, because compilation was done at run-time, their compiler had to be extremely fast and they therefore eschewed static analyses such as iterative intraprocedural class analysis and class hierarchy analysis. Agesen and Hlzle compared the effectiveness of the Cartesian Product type inference algorithm <ref> [Agesen 95] </ref> with profile-guided receiver-class prediction for Self programs [Agesen & Hlzle 95, Agesen & Hlzle 96]. Their results indicated that the two techniques had similar effectiveness at optimizing message sends.
Reference: [Aho et al. 86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <address> Ad-dison-Wesley, Reading, MA, </address> <year> 1986. </year>
Reference-contexts: changed this when we began work on the Modula-3 front-end, since Modula-3 allows arbitrary procedures to be used as methods, perhaps in multiple places. 3.1.4 IL Statements Executable code in the Vortex IL is represented in a three-address representation, with the usual complement of arithmetic, logical, pointer, and control operations <ref> [Aho et al. 86] </ref>. However, because we want to be able to optimize the special features of object-oriented languages, many higher-level operations are reified in the IL, allowing the optimizer to reason about them. The higher-level operations and the motivation for including them are described below: Message sends.
Reference: [Aigner & Hlzle 96] <author> Gerald Aigner and Urs Hlzle. </author> <title> Eliminating Virtual Function Calls in C++ Programs. </title> <booktitle> In Proceedings ECOOP 96, </booktitle> <address> Linz, Austria, </address> <month> August </month> <year> 1996. </year> <note> Springer-Verlag. To appear. </note>
Reference-contexts: receiver class prediction is more conservative than Aigner and Hlzles; we only insert a class test if the target method is small enough to be inlined, they always insert class tests if the class distributions are peaked, regardless of whether the statically bound method is a good candidate for inlining <ref> [Aigner & Hlzle 96] </ref>. It has been our experience in Cecil that the performance gained by statically binding a message via class prediction that is not subsequently inlined does not justify the additional code space and compile time overhead. <p> In particular, many research groups are exploring the effectiveness of class hierarchy analysis and other similar techniques in hybrid object-oriented languages <ref> [Aigner & Hlzle 96, Diwan et al. 95, Fernandez 95] </ref>. <p> Aigner and Hlzle implemented a prototype system to compare class hierarchy analysis and profile-guided receiver-class prediction for C++ programs <ref> [Aigner & Hlzle 96] </ref>. Their system works by first combining a 17 Vortex: An Optimizing Compiler for Object-Oriented Languages Dean et al. OOPSLA96 Submission C++ program composed of multiple source files to produce a single, monolithic C++ file.
Reference: [Bieman & Zhao 95] <author> James M. Bieman and Josephine Xia Zhao. </author> <title> Reuse Through Inheritance: A Quantitative Study of C++ Software. </title> <booktitle> In Proceedings of the Symposium on Software Reusability. ACM SIGSOFT, </booktitle> <month> August </month> <year> 1995. </year> <note> Software Engineering Notes. </note>
Reference-contexts: Calls to methods with no overriding methods can be statically bound by class hierarchy analysis. Bieman and Zhao also used the first three of these metrics (and some additional ones) in their study of inheritance in C++ applications <ref> [Bieman & Zhao 95] </ref>. They utilized the metrics to assess the amount of code reuse through inheritance in large C++ programs; in contrast, we are interested in characterizing how the structure of the inheritance hierarchy impacts optimization. The above metrics are all static metrics.
Reference: [Bobrow et al. 88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, and D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> SIGPLAN Notices, 28(Special Issue), </journal> <month> September </month> <year> 1988. </year>
Reference-contexts: However, a few languages use other rules for resolving ambiguities (notably CLOS, which uses a strict left-to-right ordering of parents for resolving ambiguities <ref> [Bobrow et al. 88] </ref>), and compiling such languages would require adding back-end support for the alternative lookup rules. 3.1.2 Instance Variables and Representations Classes can have many different possible representations, depending on how their instance variables are laid out and other factors such as alignment, padding, and the sizes of numeric <p> The Vortex IL similarly supports global variable declarations. A declaration specifies a representation and optionally the initial value for the variable (even if the variable is an aggregate data type). 3.1.3 Methods and Procedures The back-end uses a notion of a generic function <ref> [Bobrow et al. 88] </ref> to unify the concepts of procedures, methods, and multi-methods. Each call or message maps to a single generic function. A generic function contains a set of dynamically-overloaded procedures, with each procedure indicating where in the programs class hierarchy it is attached.
Reference: [Calder & Grunwald 94] <author> Brad Calder and Dirk Grunwald. </author> <title> Reducing Indirect Function Call Overhead in C++ Programs. </title> <booktitle> In Conference Record of POPL 94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 397408, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Calder and Grunwald consider several ways of optimizing dynamically-bound calls in C++ <ref> [Calder & Grunwald 94] </ref>. They examined some characteristics of the class distributions of several C++ programs and found that although the potential polymorphism was high, the distributions seen at individual call sites were strongly peaked, suggesting that profile-guided receiver class prediction would pay off.
Reference: [Chambers & Ungar 89] <author> Craig Chambers and David Ungar. </author> <title> Customization: Optimizing Compiler Technology for Self, </title>
Reference-contexts: Receiver class prediction can be driven either by information hard-wired into the compiler, as in early Smalltalk and Self implementations <ref> [Deutsch & Schiffman 84, Chambers & Ungar 89] </ref>, or by profile-derived class distributions [Hlzle & Ungar 94, Grove et al. 95]. It is quite common for a method to contain multiple message sends to a single receiver value; for example, several messages might be sent to self. <p> Splitting is a transformation that can be applied to eliminate these redundant tests by duplicating selected regions of the methods control ow graph [Chambers & Ungar 90]. 2.4 Customization and Specialization Customization and method specialization <ref> [Chambers & Ungar 89, Lea 90, Dean et al. 95a] </ref> are techniques that also can be used to statically bind messages sent to self, by creating multiple compiled copies of a single source method, each specialized to particular receiver classes. <p> However, it places some limitations on the optimizations that the back-end can perform. In particular, because dispatch tables are not exposed at a high enough level, the back-end cannot perform optimizations that would require generating different dispatch tables. Examples of such optimizations include customization and specialization <ref> [Chambers & Ungar 89, Lea 90, Dean et al. 95a] </ref> and converting a C++-style method from virtual to non-virtual to reduce the size of dispatch tables, when the back-end is able to detect that the method is not overridden anywhere in the program. 3.2 Optimization Phases Vortex takes the IL representation <p> In particular, many research groups are exploring the effectiveness of class hierarchy analysis and other similar techniques in hybrid object-oriented languages [Aigner & Hlzle 96, Diwan et al. 95, Fernandez 95]. Smalltalk-80 [Deutsch & Schiffman 84], Self-89 <ref> [Chambers & Ungar 89] </ref>, Self-91 [Chambers 92a] and Cecil [Dean et al. 95b] compilers have all utilized hard-wired receiver class prediction (called type prediction in the Self work) for a few common messages such as + and if to eliminate much of the overhead due to their pure object model and
References-found: 9

