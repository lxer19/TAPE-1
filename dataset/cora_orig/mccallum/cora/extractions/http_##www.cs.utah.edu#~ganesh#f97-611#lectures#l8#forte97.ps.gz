URL: http://www.cs.utah.edu/~ganesh/f97-611/lectures/l8/forte97.ps.gz
Refering-URL: http://www.cs.utah.edu/~ganesh/f97-611/lectures/l8/
Root-URL: 
Title: Specification, Proof Checking, and Model Checking for Protocols and Distributed Systems with PVS 1 Tutorial
Author: John Rushby 
Note: 1 This work was supported by the National Science Foundation under contract CCR 9509931.  
Address: Menlo Park CA 94025 USA  
Affiliation: Computer Science Laboratory SRI International  
Abstract-found: 0
Intro-found: 1
Reference: <institution> Papers by SRI authors are available from http://www.csl.sri.com/fm.html. </institution>
Reference: [1] <editor> Rajeev Alur and Thomas A. Henzinger, editors. </editor> <booktitle> Computer-Aided Verification, CAV '96, volume 1102 of Lecture Notes in Computer Science, </booktitle> <address> New Brunswick, NJ, July/August 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This is accomplished by the proof commands (expand "p next") and (ground). Applying propositional simplification and decision procedures, this yields 4 subgoals: invariant.2.1: f-1g idle?(transaction (ps0!1)) f-2g do_idle (ps0!1, ps1!1) [-3] p_safe (ps0!1) |------- <ref> [1] </ref> p_safe (ps1!1) Rule? This first subgoal concerns the idle transaction and is easily dispatched with (grind). Skipping the second and third subgoals temporarily, the fourth subgoal concerns the case of a write back transaction. invariant.2.4: f-1g write_back?(transaction (ps0!1)) f-2g do_write_back (ps0!1, ps1!1)(bus_master (ps0!1)) [-3] p_safe (ps0!1) |------- [1] p_safe (ps1!1) <p> (ps0!1) |------- <ref> [1] </ref> p_safe (ps1!1) Rule? This first subgoal concerns the idle transaction and is easily dispatched with (grind). Skipping the second and third subgoals temporarily, the fourth subgoal concerns the case of a write back transaction. invariant.2.4: f-1g write_back?(transaction (ps0!1)) f-2g do_write_back (ps0!1, ps1!1)(bus_master (ps0!1)) [-3] p_safe (ps0!1) |------- [1] p_safe (ps1!1) rule? This is dispatched by the command (grind: if-match all), which instructs grind to consider more instantiations for quantified variables than it would normally. <p> Returning to the third subgoal, we are presented with the case corresponding to a read shared transaction. 14 invariant.2.2: f-1g read_shared?(transaction (ps0!1)) f-2g do_read_shared (ps0!1, ps1!1)(bus_master (ps0!1)) [-3] p_safe (ps0!1) |------- <ref> [1] </ref> p_safe (ps1!1) Rule? This requires a more interactive proof because the automated strategies of PVS guess incorrect instantiations for variables. We start the proof off with (grind :if-match nil), which is a variant of grind in which the prover is instructed to not attempt instantiation of variables. <p> Finally, we are presented with the case corresponding to a read modified transaction. invariant.2.3: f-1g read_modified?(transaction (ps0!1)) f-2g do_read_modified (ps0!1, ps1!1)(bus_master (ps0!1)) [-3] p_safe (ps0!1) |------- <ref> [1] </ref> p_safe (ps1!1) Rule? As with the previous case, we start off with (grind :if-match nil) and are pre sented with the following proof goal. 15 invariant.2.2: f-1g q!1 &lt; N [-3] read_modified?(transaction (ps0!1)) f-4g shared?(cache (ps0!1)(bus_master (ps0!1))) f-5g FORALL (q: processor): cache (ps1!1)(q) = IF bus_master (ps0!1) = q THEN <p> This simplifies to: safety_preserved.1 : [-1] p!2 &lt; N [-3] q!1 &lt; N f-4g exclusive?(cache (ps!1)(q!1)) IMPLIES p!2 = q!1 [-5] exclusive?(cache (ps!1)(p!1)) IMPLIES p!2 = p!1 [-6] exclusive?[N](cache (ps!1)(p!1)) [-7] exclusive?[N](cache (ps!1)(q!1)) |------- <ref> [1] </ref> (EXISTS (q: processor [N]): shared?(cache (ps!1)(q))) [2] p!1 = q!1 Rule? It is now a trivial consequence of propositional and equality reasoning that the formulas -4 to -7 imply that p!1 = q!1, and hence discharge formula 2 in the conclusion.
Reference: [2] <author> Saddek Bensalem, Yassine Lakhnech, and Hassen Sadi. </author> <title> Powerful techniques for the automatic generation of invariants. </title> <booktitle> In Alur and Henzinger [1], </booktitle> <pages> pages 323-335. </pages>
Reference-contexts: This simplifies to: safety_preserved.1 : [-1] p!2 &lt; N [-3] q!1 &lt; N f-4g exclusive?(cache (ps!1)(q!1)) IMPLIES p!2 = q!1 [-5] exclusive?(cache (ps!1)(p!1)) IMPLIES p!2 = p!1 [-6] exclusive?[N](cache (ps!1)(p!1)) [-7] exclusive?[N](cache (ps!1)(q!1)) |------- [1] (EXISTS (q: processor [N]): shared?(cache (ps!1)(q))) <ref> [2] </ref> p!1 = q!1 Rule? It is now a trivial consequence of propositional and equality reasoning that the formulas -4 to -7 imply that p!1 = q!1, and hence discharge formula 2 in the conclusion. <p> In our example, only a single strengthening was required, but dozens may be required in more difficult cases. Much recent work focusses on systematic and automated ways to generate and strengthen invariants; see, for example <ref> [2] </ref>. Other work focusses on methods that are particularly effective for certain classes of applications: see, for example [22-24] The proofs required a fair degree of interactive guidance, and therefore a certain familiarity with PVS.
Reference: [3] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference: [4] <author> Edmund M. Clarke, Orna Grumberg, and David E. </author> <title> Long. Model checking and abstraction. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1512-1542, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: (abst (ps)) next_simulation: THEOREM p_next (ps0, ps1) IMPLIES a_next (abst (ps0), abst (ps1)) safety_preserved: THEOREM a_safe (abst (ps)) IMPLIES p_safe (ps) as: VAR abstract_state abs_invariant_ctl: THEOREM a_init (as) IMPLIES AG (a_next, a_safe)(as) That these four conditions are sufficient to establish invariant ctl is a consequence of general results established in <ref> [4] </ref>. The goal is to arrange matters so that the fourth of these conditions can be established by model checking, and the other three by fairly simple theorem proving.
Reference: [5] <author> David L. Dill. </author> <title> The Mur verification system. </title> <booktitle> In Alur and Henzinger [1], </booktitle> <pages> pages 390-393. </pages>
Reference-contexts: Related methods include those based on language inclusion [17], those based on refinement in process algebras [27], and those that perform straightforward state exploration <ref> [5] </ref>; because they use similar underlying technology, these are all loosely referred to as model checking methods. 2 This tutorial aims to make concrete some of the ideas and issues raised above.
Reference: [6] <author> Bruno Dutertre and Steve Schneider. </author> <title> Embedding CSP in PVS. an application to authentication protocols. </title> <editor> In Elsa Gunter and Amy Felty, editors, </editor> <title> Theorem Proving in Higher Order Logics: </title> <booktitle> 10th International Conference, TPHOLs '97, volume 1275 of Lecture Notes in Computer Science, </booktitle> <pages> pages 121-136, </pages> <address> Murray Hill, NJ, </address> <month> August </month> <year> 1997. </year> <note> Springer-Verlag. </note>
Reference-contexts: There are two well-established methods for formalizing distributed computations: one method focusses on the events exchanged among the components (these methods are generally process algebras), the other focuses on the states of the components and their transitions. PVS has been used with both methods (see, e.g., <ref> [6, 16] </ref>), but this example will focus on the state-based method. 4 Actually, "at most one exclusive copy" is insufficient to ensure sequential consistency, but the counterexample requires more than one cache line, so this kind of simplification needs to be undertaken with care and caution. 7 The basic idea is
Reference: [7] <author> Rob Gerth. </author> <title> Verifying sequentially consistent memory: Problem definition. </title> <institution> Eindhoven Institute of Technology, </institution> <month> April </month> <year> 1993. </year> <note> Available from http://www. research.digital.com/SRC/tla/Intro.ps.Z. </note>
Reference-contexts: For the cache-coherence example, the ultimate property of interest is sequential consistency. To analyze this, we would need to model the reading and writing of memory, and would need to formulate a precise specification for sequential consistency <ref> [7] </ref>. This requires quite a lot of work, so we might decide instead to focus on "internal" properties of the protocol itself: for example, at most one cache should have an exclusive copy of any given line. This is certainly a necessary condition for sequential consistency. <p> Does this not potentially allow multiple processors to respond, causing collisions on the bus? Does the formal model expose this? If not, how can it be extended to do so? * (This is an advanced exercise:) Show that the protocol provides sequential consistency <ref> [7] </ref>. 27 28 Appendix A PVS Specification and Proof Listings You can obtain the PVS "dump file" for all the specifications and proofs listed here from http://www.csl.sri.com/forte97.html.
Reference: [8] <author> Patrice Godefroid, Doron Peled, and Mark Staskauskas. </author> <title> Using partial-order methods in the formal validation of industrial concurrent programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(7) </volume> <pages> 496-507, </pages> <month> July </month> <year> 1996. </year> <month> 43 </month>
Reference-contexts: Research in model checking is addressing the "state explosion problem" (the tendency for the number of states that must be explored to grow exponentially with the number of components considered) using symbolic methods, reductions based on special properties of the system or property considered (e.g., symmetry [14], partial order <ref> [8] </ref>), and is also exploring compositional methods [10]. Using Theorem Proving to Verify an Invariant: This was conceptually straightforward, but required strengthening the invariant to obtain one that is inductive. In our example, only a single strengthening was required, but dozens may be required in more difficult cases.
Reference: [9] <author> Orna Grumberg, </author> <title> editor. Computer-Aided Verification, </title> <booktitle> CAV '97, volume 1254 of Lecture Notes in Computer Science, </booktitle> <address> Haifa, Israel, June 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference: [10] <author> Orna Grumberg and David E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: the "state explosion problem" (the tendency for the number of states that must be explored to grow exponentially with the number of components considered) using symbolic methods, reductions based on special properties of the system or property considered (e.g., symmetry [14], partial order [8]), and is also exploring compositional methods <ref> [10] </ref>. Using Theorem Proving to Verify an Invariant: This was conceptually straightforward, but required strengthening the invariant to obtain one that is inductive. In our example, only a single strengthening was required, but dozens may be required in more difficult cases.
Reference: [11] <author> Klaus Havelund and N. Shankar. </author> <title> Experiments in theorem proving and model checking for protocol verification. </title> <booktitle> In Formal Methods Europe FME '96, volume 1051 of Lecture Notes in Computer Science, </booktitle> <pages> pages 662-681, </pages> <address> Oxford, UK, March 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: It attempts to do so by working through a single simple example using model checking, theorem proving, and their combination. The approach taken is almost identical to that described, for a much more difficult example, by Havelund and Shankar <ref> [11] </ref>, and their paper is a useful source for additional information. <p> Typically, each iteration involves an unsuccessful proof attempt that yields insight and a new term to be conjoined to the putative invariant. Havelund and Shankar <ref> [11] </ref> report the example of a simple communications protocol (known as the Bounded Retransmission Protocol, or BRP) that required 57 strengthenings of the invariant. Some of the most attractive and promising ideas in protocol verification seek to combine the complementary strengths of model checking and theorem proving.
Reference: [12] <author> G. J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: There are, of course, many systems specifically intended for the formal description and analysis of protocols; these systems generally provide a specification language tailored for that application, together with a simulator, a model checker, or both; examples include the many tools for LOTOS [13], and the Spin system <ref> [12] </ref>. A simulator allows representative, or interesting, runs of a protocol to be examined and is useful for gaining an understanding of its operation in normal and abnormal circumstances, and may also reveal bugs.
Reference: [13] <institution> LOTOS|A Formal Description Technique Based on the Temporal Ordering of Observational Behavior. International Organization for Standardization| Information Processing Systems|Open Systems Interconnection, Geneva, Switzerland, </institution> <month> September </month> <year> 1988. </year> <title> ISO Standard 8807. </title>
Reference-contexts: There are, of course, many systems specifically intended for the formal description and analysis of protocols; these systems generally provide a specification language tailored for that application, together with a simulator, a model checker, or both; examples include the many tools for LOTOS <ref> [13] </ref>, and the Spin system [12]. A simulator allows representative, or interesting, runs of a protocol to be examined and is useful for gaining an understanding of its operation in normal and abnormal circumstances, and may also reveal bugs.
Reference: [14] <author> C. Norris Ip and David L. Dill. </author> <title> Better verification through symmetry. </title> <booktitle> Formal Methods in Systems Design, </booktitle> 9(1/2):41-75, August 1996. 
Reference-contexts: Research in model checking is addressing the "state explosion problem" (the tendency for the number of states that must be explored to grow exponentially with the number of components considered) using symbolic methods, reductions based on special properties of the system or property considered (e.g., symmetry <ref> [14] </ref>, partial order [8]), and is also exploring compositional methods [10]. Using Theorem Proving to Verify an Invariant: This was conceptually straightforward, but required strengthening the invariant to obtain one that is inductive.
Reference: [15] <author> International Standard: </author> <title> Information Technology|Microprocessor Systems | Futurebus+ | Logical Protocol Specification. </title> <booktitle> ISO/IEC 10857 and ANSI/IEEE Std. </booktitle> <address> 896.1, </address> <year> 1994. </year>
Reference-contexts: Another paper by Shankar is a good source for a more technical exposition of many of the topics raised here [33]. 3 4 Chapter 2 A Simple Example: Cache Coherence The example is a simplification of the single-bus cache coherence protocol from Futurebus+ (without split transactions) <ref> [15] </ref>. 1 A memory and several processors, each with a local cache, are attached to a bus. The caches maintain "coherence" (explained below) by snooping (i.e., observing) all bus transactions and updating their local states appropriately.
Reference: [16] <author> Pertti Kellomaki. </author> <title> Verification of reactive systems using DisCo and PVS. </title> <booktitle> In Formal Methods Europe FME '97, volume 1313 of Lecture Notes in Computer Science, </booktitle> <pages> pages 589-604, </pages> <address> Graz, Austria, </address> <month> September </month> <year> 1997. </year> <note> Springer-Verlag. </note>
Reference-contexts: There are two well-established methods for formalizing distributed computations: one method focusses on the events exchanged among the components (these methods are generally process algebras), the other focuses on the states of the components and their transitions. PVS has been used with both methods (see, e.g., <ref> [6, 16] </ref>), but this example will focus on the state-based method. 4 Actually, "at most one exclusive copy" is insufficient to ensure sequential consistency, but the counterexample requires more than one cache line, so this kind of simplification needs to be undertaken with care and caution. 7 The basic idea is
Reference: [17] <author> R. P. Kurshan. </author> <title> Computer-Aided Verification of Coordinating Processes|The Automata-Theoretic Approach. </title> <publisher> Princeton University Press, </publisher> <address> Princeton, NJ, </address> <year> 1994. </year>
Reference-contexts: Related methods include those based on language inclusion <ref> [17] </ref>, those based on refinement in process algebras [27], and those that perform straightforward state exploration [5]; because they use similar underlying technology, these are all loosely referred to as model checking methods. 2 This tutorial aims to make concrete some of the ideas and issues raised above.
Reference: [18] <author> Leslie Lamport. </author> <title> How to make a multiprocessor that correctly executes multipro-cess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-28(9):690-692, </volume> <month> September </month> <year> 1979. </year>
Reference-contexts: require that any trace of memory values read and written by a processor in the presence of the caches should also be possible in their absence; this is the sequentially consistent memory model|the behavior perceived by the processors should be consistent with some sequential interleaving of their reads and writes <ref> [18] </ref>. 3 Other properties we might be interested in include latency: how long a processor might have to wait to get a value.
Reference: [19] <author> C. Loiseaux, S. Graf, J. Sifakis, A. Bouajjani, and S. Bensalem. </author> <title> Property preserving abstractions for the verification of concurrent systems. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 6 </volume> <pages> 11-44, </pages> <year> 1995. </year>
Reference: [20] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, MA, </address> <year> 1993. </year> <month> 44 </month>
Reference-contexts: several techniques (for example, theorem proving and model checking). * It provides a way to prototype development of new specialized methods. * By making the representational issues explicit, it can help students understand the techniques underlying the more specialized methods. by brute-force enumeration of the state space [3,25], or symbolically <ref> [20] </ref>.
Reference: [21] <author> Sam Owre, John Rushby, Natarajan Shankar, and Friedrich von Henke. </author> <title> Formal verification for fault-tolerant architectures: Prolegomena to the design of PVS. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(2) </volume> <pages> 107-125, </pages> <month> February </month> <year> 1995. </year>
Reference-contexts: The salient attributes of PVS are that it provides a specification language based on higher-order logic with a very rich type system, and an interactive theorem prover with significant automation including decision procedures for several common theories (such as equality and linear arithmetic) <ref> [21] </ref>. PVS has hundreds of users worldwide; you can discover some of their applications at http://www.csl.sri.com/pvs-bib.html. The PVS system is freely available from http://www.csl.sri.com/pvs.html as a binary image for Sun, AIX, and Linux workstations.
Reference: [22] <author> Seungjoon Park. </author> <title> Practical verification of cache coherence algorithms with an automatic theorem-prover. </title> <booktitle> In 2nd International Workshop on Verification of Infinite State Systems: Infinity '97, </booktitle> <address> Bologna, Italy, </address> <month> July </month> <year> 1997. </year> <note> To appear. </note>
Reference: [23] <author> Seungjoon Park and David L. Dill. </author> <title> Protocol verification by aggregation of distributed actions. </title> <booktitle> In Alur and Henzinger [1], </booktitle> <pages> pages 300-310. </pages>
Reference: [24] <author> Seungjoon Park and David L. Dill. </author> <title> Verification of the FLASH cache coherence protocol by aggregation of distributed transactions. </title> <booktitle> In 8th ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 288-296, </pages> <address> Padua, Italy, </address> <month> June </month> <year> 1996. </year>
Reference: [25] <author> J. P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Proc. 5th International Symposium on Programming, volume 137 of Lecture Notes in Computer Science, </booktitle> <pages> pages 337-351, </pages> <address> Turin, Italy, April 1982. </address> <publisher> Springer-Verlag. </publisher>
Reference: [26] <author> S. Rajan, N. Shankar, </author> <title> and M.K. Srivas. An integration of model-checking with automated proof checking. </title> <editor> In Pierre Wolper, editor, </editor> <booktitle> Computer-Aided Verification, CAV '95, volume 939 of Lecture Notes in Computer Science, </booktitle> <pages> pages 84-97, </pages> <address> Liege, Belgium, June 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Some verification systems, such as PVS, provide a model checker as well as a theorem prover and do so in an integrated way that allows the two methods to be used in combination <ref> [26] </ref>.
Reference: [27] <author> A. W. Roscoe. </author> <title> Model-checking CSP. In A Classical Mind: Essays in Honour of C. </title> <editor> A. R. Hoare, </editor> <publisher> Prentice Hall International Series in Computer Science. Prentice Hall, </publisher> <address> Hemel Hempstead, UK, </address> <year> 1994. </year>
Reference-contexts: Related methods include those based on language inclusion [17], those based on refinement in process algebras <ref> [27] </ref>, and those that perform straightforward state exploration [5]; because they use similar underlying technology, these are all loosely referred to as model checking methods. 2 This tutorial aims to make concrete some of the ideas and issues raised above.
Reference: [28] <author> Hassen Sadi. </author> <title> A tool for proving invariance properties of concurrent systems automatically. </title> <booktitle> In Tools and Algorithms for the Construction and Analysis of Systems TACAS '96, volume 1055 of Lecture Notes in Computer Science, </booktitle> <pages> pages 412-416, </pages> <address> Passau, Germany, March 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference: [29] <author> Hassen Sadi. </author> <title> The Invariant Checker: Automated deductive verification of reactive systems. </title> <booktitle> In Grumberg [9], </booktitle> <pages> pages 436-439. </pages>
Reference: [30] <author> Hassen Sadi and Susanne Graf. </author> <title> Construction of abstract state graphs with PVS. </title> <booktitle> In Grumberg [9], </booktitle> <pages> pages 72-83. </pages>
Reference-contexts: Some of the most attractive and promising ideas in protocol verification seek to combine the complementary strengths of model checking and theorem proving. One 17 class of approaches uses model checking to help generate the invariants needed for theorem proving. Using such an approach, Sadi and Graf <ref> [30] </ref> were able to generate the invariants needed for the BRP example automatically. Another method for combining theorem proving and model checking is to use theorem proving to justify a property-preserving finite-state abstraction of the protocol, which can then be analyzed by model checking [4,19].
Reference: [31] <author> N. Shankar. </author> <title> Computer-aided computing. </title> <editor> In Bernhard Moller, editor, </editor> <booktitle> Mathematics of Program Construction '95, volume 947 of Lecture Notes in Computer Science, </booktitle> <pages> pages 50-66. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year> <month> 45 </month>
Reference-contexts: As noted above, improved selection of variable instantiations would significantly increase the automation of this proof. Another approach establishes properties of N-process systems using the combination of induction and model checking, where the latter is used to discharge the inductive and/or base cases established by the former <ref> [31, 33] </ref>. Other recent work investigates a different way of using model checking and theorem proving in combination: using model checking to help develop invariants for use by theorem proving [28-30].
Reference: [32] <author> N. Shankar. </author> <title> Machine-assisted verification using theorem proving and model checking. </title> <editor> In M. Broy, editor, </editor> <booktitle> Mathematical Methods in Program Development. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <note> To appear. Draft available at http://www.csl.sri. com/~shankar/shankar-papers.html. </note>
Reference-contexts: The model checker of PVS supports the branching time temporal logic called Computation Tree Logic (CTL). We do not define CTL here, and do not explain the general technology of CTL model checking, nor the manner of its implementation in PVS; see <ref> [32] </ref> for coverage of these topics. In CTL as encoded in PVS, an invariant property is specified in the form AG (trans, prop)(s), where trans is the transition relation of the system concerned, prop is the property of interest, and s is the starting state.
Reference: [33] <author> Natarajan Shankar. </author> <title> Unifying verification paradigms. </title> <editor> In Bengt Jonsson and Joachim Parrow, editors, </editor> <booktitle> Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 1135 of Lecture Notes in Computer Science, </booktitle> <pages> pages 22-39, </pages> <institution> Uppsala, Sweden, </institution> <month> September </month> <year> 1996. </year> <note> Springer-Verlag. 46 </note>
Reference-contexts: Another paper by Shankar is a good source for a more technical exposition of many of the topics raised here <ref> [33] </ref>. 3 4 Chapter 2 A Simple Example: Cache Coherence The example is a simplification of the single-bus cache coherence protocol from Futurebus+ (without split transactions) [15]. 1 A memory and several processors, each with a local cache, are attached to a bus. <p> As noted above, improved selection of variable instantiations would significantly increase the automation of this proof. Another approach establishes properties of N-process systems using the combination of induction and model checking, where the latter is used to discharge the inductive and/or base cases established by the former <ref> [31, 33] </ref>. Other recent work investigates a different way of using model checking and theorem proving in combination: using model checking to help develop invariants for use by theorem proving [28-30].
References-found: 34

