URL: http://www.cs.indiana.edu/database/Ode/doc/att-db-93-1.ps.Z
Refering-URL: http://www.cs.indiana.edu/database/Ode/doc/
Root-URL: http://www.cs.indiana.edu
Title: A Flexible Transaction Facility for an Object-Oriented Database  
Author: A. Biliris, S. Dar N. Gehani, H. V. Jagadish, K. Ramamritham 
Date: December 5, 1992  
Address: Murray Hill, NJ 07974  Wisconsin, Madison, WI 53706  Amherst MA 01003  
Affiliation: AT&T Bell Labs  Computer Sciences Dept., University of  Dept. of Computer and Information Science, University of Massachusetts,  
Abstract: Object-oriented databases were motivated by the needs of complex applications such as CAD and software engineering. Transactions in such applications have diverse needs: they may be long lived and they may need to cooperate. This paper describes a flexible transaction facility, for an object-oriented database, consisting of a set of transaction modeling primitives that allow users to define customized transaction semantics matching the needs of specific applications. We show how the transaction primitives can be used to specify different transaction models, including nested transactions, split transactions, sagas, and several other extended transaction models described in the literature. We illustrate use of the transaction modeling primitives by means of examples and show how to implement them efficiently. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Agrawal, R. and N. Gehani. </author> <title> Ode (Object Database and Environment): The Language and the Data Model. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 35-45, </pages> <year> 1989. </year>
Reference-contexts: It is our intention to implement this transaction facility in Ode, an object-oriented database system based on the C++ data model. Hence, we describe the facility in the context of O++, the database programming language of Ode <ref> [1] </ref>. We assume that the reader is familiar with C++ [17] and object-oriented programming concepts. 2 Terminology, Definitions, and Assumptions In this section we define the terms and concepts used in the rest of the paper. These terms and concepts have their origins in ACTA [5, 6].
Reference: [2] <author> Badrinath, B. R. and K. Ramamritham. </author> <title> Semantics-Based Concurrency Control: Beyond Commutativity. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> Vol. 17, No. 1, </volume> <month> March </month> <year> 1992, </year> <pages> pp. 163-199. </pages>
Reference-contexts: Wait, i.e. block and retry. If t i has any incoming edges in CDREL, t i can only pseudo commit <ref> [2] </ref>. That is, from the user's point of view, t i can commit and so a 1 is returned. However, CDREL and the objects accessed by t i must continue to maintain information pertaining to t i until all its predecessors in CDREL commit.
Reference: [3] <author> Beeri, C., H. J. Schek, and G. Weikum. </author> <title> Multilevel Transaction Management, Theoretical art or practical need?. </title> <booktitle> First Int. Conference on Extended Database technology, </booktitle> <address> Venice, 1988, </address> <publisher> Springer LNCS 303. </publisher>
Reference-contexts: Although our object model has nested operations, we do not have different operation levels as in multi-level transactions <ref> [3] </ref>. In multi-level operations, a level n operation is implemented by calling one or more level n-1 operations. Each operation is assumed to have a compensating operation.
Reference: [4] <author> Bernstein P. A., V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1987. </year>
Reference-contexts: We denote the invocation of operation op by transaction t on object ob by op t [ob]. The concurrent execution of a set of transactions s t is represented by H, the history <ref> [4] </ref> of the events invoked by the transactions in the set T . H also indicates the (partial) order in which these events occur. This partial order is consistent with the order of the events of each individual transaction t in s t .
Reference: [5] <author> Chrysanthis P. K. and K. Ramamritham. </author> <title> A Formalism for Extended Transaction Models. </title> <booktitle> In Proceedings of the seventeenth International Conference on Very Large Databases, </booktitle> <month> September </month> <year> 1991. </year>
Reference-contexts: The primitives are inspired by the ACTA transaction framework, a formal framework designed to specify, analyze and synthesize extended transaction models <ref> [5, 6] </ref>. These transaction primitives can be used to define customized transaction models suitable for specific applications. The customization may take advantage of the semantics of objects in an object-oriented database, by taking into account the compatibility of class specific operations (methods). <p> We assume that the reader is familiar with C++ [17] and object-oriented programming concepts. 2 Terminology, Definitions, and Assumptions In this section we define the terms and concepts used in the rest of the paper. These terms and concepts have their origins in ACTA <ref> [5, 6] </ref>. Our assumptions concerning the nature of programs, objects, and operations are also stated in this section. 2.1 Terminology and Definitions During the course of their execution, transactions invoke operations on objects.
Reference: [6] <author> Chrysanthis P. K. and K. Ramamritham. </author> <title> ACTA: The SAGA Continues. </title> <editor> In A. K. Elmagarmid, editor, </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: The primitives are inspired by the ACTA transaction framework, a formal framework designed to specify, analyze and synthesize extended transaction models <ref> [5, 6] </ref>. These transaction primitives can be used to define customized transaction models suitable for specific applications. The customization may take advantage of the semantics of objects in an object-oriented database, by taking into account the compatibility of class specific operations (methods). <p> We assume that the reader is familiar with C++ [17] and object-oriented programming concepts. 2 Terminology, Definitions, and Assumptions In this section we define the terms and concepts used in the rest of the paper. These terms and concepts have their origins in ACTA <ref> [5, 6] </ref>. Our assumptions concerning the nature of programs, objects, and operations are also stated in this section. 2.1 Terminology and Definitions During the course of their execution, transactions invoke operations on objects.
Reference: [7] <author> Chrysanthis P. K., S. Raghuram, and K. Ramamritham. </author> <title> Extracting Concurrency from Objects: </title> <booktitle> A Methodology In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 108-117, </pages> <year> 1991. </year>
Reference-contexts: The compatibility table is provided by the class designer who knows the semantics of the class operations <ref> [7] </ref>. The class 11 designer also specifies if an operation is a read operation (e.g., a "const" member function) or an update operation. The value of each (op i ; op j ) entry is one of the following: OK, NOK, CD, or AD.
Reference: [8] <author> Dayal U., M. Hsu, and R. Ladin. </author> <title> Organizing Long-Running Activities with Triggers and Transactions. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 204-214, </pages> <address> Atlantic City, </address> <month> May </month> <year> 1990. </year>
Reference: [9] <editor> Elmagarmid, A. K., editor, </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: Such applications have diverse needs. This has lead to the search for more flexible correctness requirements as well as the introduction of new transaction models that extend the traditional atomic transaction model. (See <ref> [9] </ref> for a description of some of the extended transaction models and [16] for a review of the proposed correctness requirements).
Reference: [10] <author> Garcia-Molina H. and Kenneth Salem. SAGAS. </author> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 249-259, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: (t1); ... commit (t1); ... 9 Function f1 is defined as void f1 () f initiate (f2,t2); // splitting off delegate (t2, X); begin (t2); ... delegate (parent ()); // joining t g Function f2 is defined as void f2 () f ... commit (self ()); g 4.6 Sagas Sagas <ref> [10] </ref> have been proposed as a transaction model for long-lived activities. A saga is a set of relatively independent (component) transactions t 1 , t 2 ,..., t n which can interleave in any way with component transactions of other sagas.
Reference: [11] <author> Korth H. F., W. Kim, and F. </author> <title> Bancilhon. </title> <journal> On Long-Duration CAD Transactions. Information Sciences, </journal> <volume> 46(1-2):73-107, </volume> <month> October-November </month> <year> 1988. </year>
Reference: [12] <author> Korth H. F., E. Levy, and A. Silberschatz. </author> <title> Compensating Transactions: A New Recovery Paradigm. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <pages> pages 95-106, </pages> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference: [13] <author> Liskov B. and R. Scheifler. </author> <title> Guardians and Actions: Linguistic support for robust distributed programs. </title> <journal> ACM Transactions on Programming Languages and Systems Vol 8, </journal> <volume> No.4, </volume> <month> December </month> <year> 1983, </year> <pages> pp 484-502. 19 </pages>
Reference-contexts: We provided details of how each of the transaction primitives could be implemented. As part of our future work, we intend to implement such a facility for the Ode database. With regard to related work, Argus <ref> [13] </ref> represents one of the earliest efforts at providing linguistic supports for transactions. Argus, however, supported only nested transactions; each operation invocation was considered to be a (sub)transaction. A more recent effort is the work done in the context of the Contract model [18].
Reference: [14] <author> Moss J. E. B. </author> <title> Nested Transactions: An approach to reliable distributed computing. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> April </month> <year> 1981. </year>
Reference-contexts: It should not be difficult to see how one can specify a variation wherein all the alternatives are begun in parallel but only one is committed. 4.4 Nested Transactions In the nested transaction model, cf. <ref> [14] </ref>, there are two types of transactions: root transactions and nested subtransactions. A root transaction can be composed of subtransactions which can themselves consist of subtransactions; thus, a root transaction may expand in a hierarchical manner. Subtransactions execute atomically with respect to their siblings and other non-related transactions.
Reference: [15] <author> Pu C., G. Kaiser, and N. Hutchinson. </author> <title> Split-Transactions for Open-Ended activities. </title> <booktitle> In Proceedings of the Fourteenth International Conference on Very Large Databases, </booktitle> <pages> pages 26-37, </pages> <address> Los Angeles, California, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: transaction is defined as void f11 () f ... delegate (parent ()); g Note that if a transaction delegates all its operations, and does nothing afterwards, then it does not make any difference whether this transaction is committed or aborted. 4.5 Split and Join Transactions In the split transaction model <ref> [15] </ref>, it is possible for a transaction t a to split into two transactions, t a and t b and for two transactions t a and t b to join into one joint transaction t a .
Reference: [16] <author> Ramamritham, K. and P. Chrysanthis. </author> <title> In Search of Acceptability Criteria: Database Consistency Requirements and Transaction Correctness Properties. Distributed Object Management, </title> <editor> Ozsu,Dayal, and Valduriez Ed., </editor> <publisher> Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: Such applications have diverse needs. This has lead to the search for more flexible correctness requirements as well as the introduction of new transaction models that extend the traditional atomic transaction model. (See [9] for a description of some of the extended transaction models and <ref> [16] </ref> for a review of the proposed correctness requirements). However, thus far very little work exists that attempts to provide a facility, to express the needs of users who desire to make use of recent work in this area.
Reference: [17] <author> Stroustrup, B. and M. A. Ellis. </author> <title> The Annotated C++ Reference Manual, </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: It is our intention to implement this transaction facility in Ode, an object-oriented database system based on the C++ data model. Hence, we describe the facility in the context of O++, the database programming language of Ode [1]. We assume that the reader is familiar with C++ <ref> [17] </ref> and object-oriented programming concepts. 2 Terminology, Definitions, and Assumptions In this section we define the terms and concepts used in the rest of the paper. These terms and concepts have their origins in ACTA [5, 6].
Reference: [18] <author> Wachter, H. and A. Reuter. </author> <title> The ConTract Model. </title> <editor> In A. K. Elmagarmid, editor, </editor> <title> Database Transaction Models for Advanced Applications, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1991. </year> <month> 20 </month>
Reference-contexts: With regard to related work, Argus [13] represents one of the earliest efforts at providing linguistic supports for transactions. Argus, however, supported only nested transactions; each operation invocation was considered to be a (sub)transaction. A more recent effort is the work done in the context of the Contract model <ref> [18] </ref>. Here a set of steps define individual transactions and a script is provided to control the execution of these transactions. Even though the functions associated with transactions in our work may appear to be similar in concept to steps, transaction management primitives can be invoked from within our functions.
References-found: 18

