URL: http://www.cs.tamu.edu/faculty/vaidya/papers/fault-tolerance/prfts95rdsm.ps.Z
Refering-URL: http://www.cs.tamu.edu/faculty/vaidya/Vaidya-ftc.html
Root-URL: http://www.cs.tamu.edu
Email: Email:  
Title: Recoverable Distributed Shared Memory Using the Competitive Update Protocol  
Author: Jai-Hoon Kim Nitin H. Vaidya 
Web: fjhkim,vaidyag@ cs.tamu.edu Web: http://www.cs.tamu.edu/faculty/vaidya/  
Address: College Station, TX, 77843-3112  
Affiliation: Department of Computer Science Texas A&M University  
Abstract: In this paper, we propose a recoverable DSM that uses a competitive update protocol. In this update protocol, multiple copies of each page maybe maintainedatdifferent nodes. However, itis also possible for a page to existin only one node, as some copies of the page may be invalidated. We propose an implementation that makes the competitive update protocol recoverable from a single node failure, by guaranteeing that at least two copies of each page exist. The paper presents preliminary evaluation of the recoverable DSM (using simulation). It is shown that the message overhead of making the DSM recoverable is small. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. V. Adve, </author> <title> Designing Memory Consistency Models for Shared-MemoryMultiprocessors, </title> <type> PhD thesis, </type> <institution> University of Wisconsin-Madison, </institution> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: This can happen because a read can be performed locally without other nodes knowing about it. The modifi ed (recoverable) competitive update protocol The proposed scheme assumes that programs are data-race-free <ref> [1] </ref>.
Reference: [2] <author> M. Banatre, A. Gefflaut, and C. Morin, </author> <title> Tolerating node failures in cache only memory architectures, </title> <type> Tech. Rep. 853, </type> <institution> INRIA, </institution> <year> 1994. </year>
Reference-contexts: Many recoverable DSM schemes have been presented in the literature. Some of them use stable storage (disk) to save recovery data [22, 8, 18, 9], and others use main memory for checkpointing, replicating shared memory or logging the shared memory accesses <ref> [20, 2, 4, 16, 6, 12, 21] </ref>. Proposed recoverable DSM belongs to the second category (uses main memory). [20, 21] are based on update (full-replication) protocol, while [2, 4, 16, 6, 12] are based on invalidate (read-replication) protocol. <p> Proposed recoverable DSM belongs to the second category (uses main memory). [20, 21] are based on update (full-replication) protocol, while <ref> [2, 4, 16, 6, 12] </ref> are based on invalidate (read-replication) protocol. Stumm and Zhou extended four DSM algorithms to tolerate single node failures [20]. One of their algorithmsis for an update protocol. <p> Backward error recovery on a Cache Only Memory Architecture is implemented using invalidate protocol by Ba-natre et al. <ref> [2] </ref>. (A similar scheme was implemented on an Intel Paragon by Kermarrec et al. [12].) This scheme periodically takes systemwide consistent checkpoints.
Reference: [3] <author> E. Brewer and C. Dellarocas, Proteus User Doc., </author> <year> 1992. </year>
Reference-contexts: As a preliminary test, we generated synthetic trace data by using an event generator. (Possible events are read, write, acquire, and release.) The event generator can produce synthetic trace data according to the memory access behavior which we can define as input. We also modified the Proteus <ref> [3] </ref>, execution-driven multiprocessor system simulator, to produce trace data. The modified Proteus produces trace data for shared memory operations, read, 3 We did notmeasure the overhead (the number of messages and the amountof data) for non-shareddata.
Reference: [4] <author> L. Brown and J. Wu, </author> <title> Dynamic snooping in a fault-tolerant distributed shared memory, </title> <booktitle> in Symposium on Distributed Computing Systems, </booktitle> <pages> pp. 218-226, </pages> <year> 1994. </year>
Reference-contexts: Many recoverable DSM schemes have been presented in the literature. Some of them use stable storage (disk) to save recovery data [22, 8, 18, 9], and others use main memory for checkpointing, replicating shared memory or logging the shared memory accesses <ref> [20, 2, 4, 16, 6, 12, 21] </ref>. Proposed recoverable DSM belongs to the second category (uses main memory). [20, 21] are based on update (full-replication) protocol, while [2, 4, 16, 6, 12] are based on invalidate (read-replication) protocol. <p> Proposed recoverable DSM belongs to the second category (uses main memory). [20, 21] are based on update (full-replication) protocol, while <ref> [2, 4, 16, 6, 12] </ref> are based on invalidate (read-replication) protocol. Stumm and Zhou extended four DSM algorithms to tolerate single node failures [20]. One of their algorithmsis for an update protocol. <p> Janssens and Fuchs [10] also present an approach to reduce interprocessor dependencies in recoverable DSM. Brown and Wu presented recoverable DSM, based on an invalidate protocol, that can tolerate single point failure <ref> [4] </ref>. A dynamic snooper keeps a backup copy of each page and takes over if the page owner fails. The snooper keeps track of the page contents, location of page replicas, and the identity of the page owner. The snooper can respond on behalf of a failed owner. <p> The snooper can respond on behalf of a failed owner. Our scheme also maintains at least two copies of a page, however, the scheme is based on an update protocol, unlike <ref> [4] </ref>. Neves et al. presented acheckpointprotocol for a multi-threaded distributed shared memory system based on the entry consistency memory model [16]. Their algorithm needs to maintain log of shared data accesses in the volatile memory. Fuchi and Tokoro proposed a mechanism for recoverable shared virtual memory [6].
Reference: [5] <author> J. B. Carter, </author> <title> Effi cient Distributed Shared Memory Based On Multi-Protocol Release Consistency. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Distributed shared memory (DSM) systems have many advantages over message passing systems [19, 17]. Since DSM provides a user a simple shared memory abstraction, the user does not have to be concerned with data move-mentbetween hosts. Many approaches have been proposed to implement distributed shared memory (e.g., <ref> [15, 5] </ref>). The DSM implementations are based on write-invalidation and/or write-update. A simple implementation of a write-update protocolis likelyto be inefficient, as many copies of a page may be updated, even if some of them are not going to be accessed in the future. <p> We assume an implementation that is similar to Munin <ref> [5] </ref>, with afewmodificationsto facilitate competitive updates. Each node maintains an information structure for each page residentin its memory. <p> The last-updater is identical for all copies of a page. * copyset: Set of nodes that are assumed to have a copy of this page. * probOwner: Points towards the owner" of the page <ref> [5] </ref>. On a page fault, a node requests the page from the probOwner. If the probOwner does not have a copy of the page, it forwards the request to its probOwner. <p> We assume thatthe DSM system consists of 16 nodes, and that the page size is 1024 bytes. For the simulation, we assume an implementation similar to Munin, i.e., based on the dynamic distributed ownership mechanism <ref> [5] </ref>. 5.2 Cost Measurement On a page fault, the number of messages required varies because of the dynamic distributed ownership mechanism.
Reference: [6] <author> T. Fuchi and M. Tokoro, </author> <title> A mechanism for recoverable shared virtual memory, </title> <year> 1994. </year>
Reference-contexts: Many recoverable DSM schemes have been presented in the literature. Some of them use stable storage (disk) to save recovery data [22, 8, 18, 9], and others use main memory for checkpointing, replicating shared memory or logging the shared memory accesses <ref> [20, 2, 4, 16, 6, 12, 21] </ref>. Proposed recoverable DSM belongs to the second category (uses main memory). [20, 21] are based on update (full-replication) protocol, while [2, 4, 16, 6, 12] are based on invalidate (read-replication) protocol. <p> Proposed recoverable DSM belongs to the second category (uses main memory). [20, 21] are based on update (full-replication) protocol, while <ref> [2, 4, 16, 6, 12] </ref> are based on invalidate (read-replication) protocol. Stumm and Zhou extended four DSM algorithms to tolerate single node failures [20]. One of their algorithmsis for an update protocol. <p> Neves et al. presented acheckpointprotocol for a multi-threaded distributed shared memory system based on the entry consistency memory model [16]. Their algorithm needs to maintain log of shared data accesses in the volatile memory. Fuchi and Tokoro proposed a mechanism for recoverable shared virtual memory <ref> [6] </ref>. Their scheme maintains backup process for every primary process. When the primary process sends/receives a message to/from another process (or writes/readsashared memory), the primary process sends this information to backup process so that the backup process can log the events of the primary process.
Reference: [7] <author> H. Grahn, P. Stenstrom, and M. Dubois, </author> <title> Implementation and evaluation of update-based cache protocols under relaxed memory consistency models, </title> <journal> Future Generation Computer Systems, </journal> <volume> vol. 11, </volume> <pages> pp. 247-271, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The DSM implementations are based on write-invalidation and/or write-update. A simple implementation of a write-update protocolis likelyto be inefficient, as many copies of a page may be updated, even if some of them are not going to be accessed in the future. The competitive update protocol <ref> [11, 7] </ref> invalidates a copy of a page at some node A, if it is updated by other nodes too many times before node A accesses it. The proposed recoverable DSM is based on the competitive update protocol, and itcan tolerate asingle node failure without significant overhead. <p> For future reference, note that we use the terms node and processor interchangeably. A node may execute one or more processes, however, failure of a node results in the failure of all such processes. 2 Related Work This paper presents a recoverable DSM based on the competitive update protocol <ref> [11, 7] </ref>. The competitive update protocol defines a limit for each page at each node. <p> After a node fails, all nodes need to rollback to the last checkpoint. 3 Competitive Update Protocol <ref> [11, 7] </ref> The basic ideaof the competitive update protocol [11, 7] is to update those copies of a page that are expected to be used in the near future, while selectively invalidating other copies. We assume an implementation that is similar to Munin [5], with afewmodificationsto facilitate competitive updates. <p> After a node fails, all nodes need to rollback to the last checkpoint. 3 Competitive Update Protocol <ref> [11, 7] </ref> The basic ideaof the competitive update protocol [11, 7] is to update those copies of a page that are expected to be used in the near future, while selectively invalidating other copies. We assume an implementation that is similar to Munin [5], with afewmodificationsto facilitate competitive updates. <p> It is possible to choose a different limit for each copy of each page, and the limits can be changed dynamically [13, 14]. 4 Recoverable Competitive Update Protocol Recoverable scheme for a DSM, based on the competitive update protocol <ref> [11, 7] </ref>, is relatively simple. The basic ideabehindthe proposed scheme is to maintain, atall times, at least two copies of each page (at two different nodes) in stead of checkpointing.
Reference: [8] <author> G. Janakiraman and Y. Tamir, </author> <title> Coordinated checkpointing-rollback error recovery for distributed shared memory mul-ticomputer, </title> <booktitle> in 13th Symp. on Rel. Distr. Syst., </booktitle> <year> 1994. </year>
Reference-contexts: Many recoverable DSM schemes have been presented in the literature. Some of them use stable storage (disk) to save recovery data <ref> [22, 8, 18, 9] </ref>, and others use main memory for checkpointing, replicating shared memory or logging the shared memory accesses [20, 2, 4, 16, 6, 12, 21].
Reference: [9] <author> B. Janssens and W. K. Fuchs, </author> <title> Relaxing consistency in recoverable distributed shared memory, </title> <booktitle> in Proc. 23rd Int. Symp. on Fault-TolerantComputing, </booktitle> <pages> pp. 155-163, </pages> <year> 1993. </year>
Reference-contexts: Many recoverable DSM schemes have been presented in the literature. Some of them use stable storage (disk) to save recovery data <ref> [22, 8, 18, 9] </ref>, and others use main memory for checkpointing, replicating shared memory or logging the shared memory accesses [20, 2, 4, 16, 6, 12, 21]. <p> Their scheme has an upper bound (to reduce overhead) as well as a lower bound (for availability) on the number of copies of each shared memory page. Unlike [21], our scheme is based on the competitive update protocol. Janssens and Fuchs <ref> [9] </ref> present a recoverable DSM that exploits release consistency to reduce the number of checkpoints, as compared to communication-induced check-pointing schemes for sequential consistency. Their scheme requires aprocess to take acheckpointeitherwhen performing a write on a synchronization variable, or when another process performs a read on the synchronization variable. <p> Their scheme requires aprocess to take acheckpointeitherwhen performing a write on a synchronization variable, or when another process performs a read on the synchronization variable. The checkpoints are stored on a storage not subject to failures. Our single fault tolerance scheme handles the non-shared data similar to <ref> [9] </ref>; it checkpoints non-shared data in the volatile memory of another processor. However, the shared data is not explicitly checkpointed instead the shared data is duplicated as a part of the update protocol (if multiple copies already exist, no additional overhead is incurred).
Reference: [10] <author> B. Janssens and W. K. Fuchs, </author> <title> Reducing interprocessor de-pendencein recoverable distributedsharedmemory, </title> <booktitle> in 13th Symposiumon reliable Distributed Systems, </booktitle> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: However, the shared data is not explicitly checkpointed instead the shared data is duplicated as a part of the update protocol (if multiple copies already exist, no additional overhead is incurred). Janssens and Fuchs <ref> [10] </ref> also present an approach to reduce interprocessor dependencies in recoverable DSM. Brown and Wu presented recoverable DSM, based on an invalidate protocol, that can tolerate single point failure [4]. A dynamic snooper keeps a backup copy of each page and takes over if the page owner fails.
Reference: [11] <author> A. Karlin et al., </author> <title> Competitive snoopy caching, </title> <booktitle> in Proc. of the 27'th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pp. 244-254, </pages> <year> 1986. </year>
Reference-contexts: The DSM implementations are based on write-invalidation and/or write-update. A simple implementation of a write-update protocolis likelyto be inefficient, as many copies of a page may be updated, even if some of them are not going to be accessed in the future. The competitive update protocol <ref> [11, 7] </ref> invalidates a copy of a page at some node A, if it is updated by other nodes too many times before node A accesses it. The proposed recoverable DSM is based on the competitive update protocol, and itcan tolerate asingle node failure without significant overhead. <p> For future reference, note that we use the terms node and processor interchangeably. A node may execute one or more processes, however, failure of a node results in the failure of all such processes. 2 Related Work This paper presents a recoverable DSM based on the competitive update protocol <ref> [11, 7] </ref>. The competitive update protocol defines a limit for each page at each node. <p> After a node fails, all nodes need to rollback to the last checkpoint. 3 Competitive Update Protocol <ref> [11, 7] </ref> The basic ideaof the competitive update protocol [11, 7] is to update those copies of a page that are expected to be used in the near future, while selectively invalidating other copies. We assume an implementation that is similar to Munin [5], with afewmodificationsto facilitate competitive updates. <p> After a node fails, all nodes need to rollback to the last checkpoint. 3 Competitive Update Protocol <ref> [11, 7] </ref> The basic ideaof the competitive update protocol [11, 7] is to update those copies of a page that are expected to be used in the near future, while selectively invalidating other copies. We assume an implementation that is similar to Munin [5], with afewmodificationsto facilitate competitive updates. <p> It is possible to choose a different limit for each copy of each page, and the limits can be changed dynamically [13, 14]. 4 Recoverable Competitive Update Protocol Recoverable scheme for a DSM, based on the competitive update protocol <ref> [11, 7] </ref>, is relatively simple. The basic ideabehindthe proposed scheme is to maintain, atall times, at least two copies of each page (at two different nodes) in stead of checkpointing.
Reference: [12] <author> A.-M. Kermarrec, G. Cabillic, A. Gefflaut, C. Morin, and I. Puaut, </author> <title> A recoverable distributedsharedmemory integrating coherence and recoverability, </title> <booktitle> in Proc. 25th Int. Symp. on Fault-TolerantComputing, </booktitle> <pages> pp. 289-298, </pages> <year> 1995. </year>
Reference-contexts: Many recoverable DSM schemes have been presented in the literature. Some of them use stable storage (disk) to save recovery data [22, 8, 18, 9], and others use main memory for checkpointing, replicating shared memory or logging the shared memory accesses <ref> [20, 2, 4, 16, 6, 12, 21] </ref>. Proposed recoverable DSM belongs to the second category (uses main memory). [20, 21] are based on update (full-replication) protocol, while [2, 4, 16, 6, 12] are based on invalidate (read-replication) protocol. <p> Proposed recoverable DSM belongs to the second category (uses main memory). [20, 21] are based on update (full-replication) protocol, while <ref> [2, 4, 16, 6, 12] </ref> are based on invalidate (read-replication) protocol. Stumm and Zhou extended four DSM algorithms to tolerate single node failures [20]. One of their algorithmsis for an update protocol. <p> Backward error recovery on a Cache Only Memory Architecture is implemented using invalidate protocol by Ba-natre et al. [2]. (A similar scheme was implemented on an Intel Paragon by Kermarrec et al. <ref> [12] </ref>.) This scheme periodically takes systemwide consistent checkpoints.
Reference: [13] <author> J.-H. Kim and N. H. Vaidya, </author> <title> Distributed shared memory: Recoverable and non-recoverable limited update protocols, </title> <type> Tech. Rep. 95-025, </type> <institution> Texas A&M Univ., College Stn., </institution> <year> 1995. </year>
Reference-contexts: It is possible to choose a different limit for each copy of each page, and the limits can be changed dynamically <ref> [13, 14] </ref>. 4 Recoverable Competitive Update Protocol Recoverable scheme for a DSM, based on the competitive update protocol [11, 7], is relatively simple. The basic ideabehindthe proposed scheme is to maintain, atall times, at least two copies of each page (at two different nodes) in stead of checkpointing. <p> Due to lack of space, we present the results for only one application in Figure 5 (Note thatFigure refmp3dplots totalcost over the entire application) the other applications yield similar results <ref> [13] </ref>. Observe that, in most cases, the recoverable scheme has a comparable or smaller cost than the non-recoverable protocol. As noted previously, the difference in the cost of the recoverable protocol and the non-recoverable protocol is likely to be the greatest when the limit, is small. <p> The proposed scheme is applicable to other updated-based protocols thatincorpo-rate mechanisms to selectively invalidate some pages. It is also applicable to generalizations of the competitive update protocols where the limit may be different for each page, and vary with time <ref> [13, 14] </ref>. Preliminary performance evaluation results indicate that the proposed scheme does not significantly increase the number or size of messages required by an application. Further analysis is necessary to fully evaluate the proposed scheme. The proposed recoverable DSM scheme is presently being implemented on a network of workstations.
Reference: [14] <author> J.-H. Kim and N. H. Vaidya, </author> <title> Towards an adaptive distributed shared memory, </title> <type> Tech. Rep. 95-037, </type> <institution> Texas A&M University, College Station, </institution> <year> 1995. </year>
Reference-contexts: It is possible to choose a different limit for each copy of each page, and the limits can be changed dynamically <ref> [13, 14] </ref>. 4 Recoverable Competitive Update Protocol Recoverable scheme for a DSM, based on the competitive update protocol [11, 7], is relatively simple. The basic ideabehindthe proposed scheme is to maintain, atall times, at least two copies of each page (at two different nodes) in stead of checkpointing. <p> The proposed scheme is applicable to other updated-based protocols thatincorpo-rate mechanisms to selectively invalidate some pages. It is also applicable to generalizations of the competitive update protocols where the limit may be different for each page, and vary with time <ref> [13, 14] </ref>. Preliminary performance evaluation results indicate that the proposed scheme does not significantly increase the number or size of messages required by an application. Further analysis is necessary to fully evaluate the proposed scheme. The proposed recoverable DSM scheme is presently being implemented on a network of workstations.
Reference: [15] <author> K. Li and P. Hudak, </author> <title> Memory coherence in shared virtual memory systems,ACMTransactions on ComputerSystems, </title> <journal> vol. </journal> <volume> 7, </volume> <pages> pp. 321-359, </pages> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: 1 Introduction Distributed shared memory (DSM) systems have many advantages over message passing systems [19, 17]. Since DSM provides a user a simple shared memory abstraction, the user does not have to be concerned with data move-mentbetween hosts. Many approaches have been proposed to implement distributed shared memory (e.g., <ref> [15, 5] </ref>). The DSM implementations are based on write-invalidation and/or write-update. A simple implementation of a write-update protocolis likelyto be inefficient, as many copies of a page may be updated, even if some of them are not going to be accessed in the future.
Reference: [16] <author> N. Neves, M. Castro, and P. Guedes, </author> <title> A checkpointprotocol for an entry consistentshared memory system, </title> <booktitle> in Symp. on Principles of Distr. Comp., </booktitle> <pages> pp. 121-129, </pages> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: Many recoverable DSM schemes have been presented in the literature. Some of them use stable storage (disk) to save recovery data [22, 8, 18, 9], and others use main memory for checkpointing, replicating shared memory or logging the shared memory accesses <ref> [20, 2, 4, 16, 6, 12, 21] </ref>. Proposed recoverable DSM belongs to the second category (uses main memory). [20, 21] are based on update (full-replication) protocol, while [2, 4, 16, 6, 12] are based on invalidate (read-replication) protocol. <p> Proposed recoverable DSM belongs to the second category (uses main memory). [20, 21] are based on update (full-replication) protocol, while <ref> [2, 4, 16, 6, 12] </ref> are based on invalidate (read-replication) protocol. Stumm and Zhou extended four DSM algorithms to tolerate single node failures [20]. One of their algorithmsis for an update protocol. <p> Our scheme also maintains at least two copies of a page, however, the scheme is based on an update protocol, unlike [4]. Neves et al. presented acheckpointprotocol for a multi-threaded distributed shared memory system based on the entry consistency memory model <ref> [16] </ref>. Their algorithm needs to maintain log of shared data accesses in the volatile memory. Fuchi and Tokoro proposed a mechanism for recoverable shared virtual memory [6]. Their scheme maintains backup process for every primary process.
Reference: [17] <author> B. Nitzberg and V. Lo, </author> <title> Distributed shared memory: A survey of issues and algorithms, </title> <journal> IEEE Computer, </journal> <volume> vol. 24, </volume> <pages> pp. 52-60, </pages> <month> Aug. </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Distributed shared memory (DSM) systems have many advantages over message passing systems <ref> [19, 17] </ref>. Since DSM provides a user a simple shared memory abstraction, the user does not have to be concerned with data move-mentbetween hosts. Many approaches have been proposed to implement distributed shared memory (e.g., [15, 5]). The DSM implementations are based on write-invalidation and/or write-update.
Reference: [18] <author> G. Richard and M. Singhal, </author> <title> Using logging and asynchronous checkpointing to implement recoverable distributed shared memory, </title> <booktitle> in 12th Symposium on Reliable Distributed Systems, </booktitle> <year> 1993. </year>
Reference-contexts: Many recoverable DSM schemes have been presented in the literature. Some of them use stable storage (disk) to save recovery data <ref> [22, 8, 18, 9] </ref>, and others use main memory for checkpointing, replicating shared memory or logging the shared memory accesses [20, 2, 4, 16, 6, 12, 21].
Reference: [19] <author> M. Stumm and S. Zhou, </author> <title> Algorithms implementing distributed shared memory, </title> <booktitle> IEEE Computer, </booktitle> <pages> pp. 54-64, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Distributed shared memory (DSM) systems have many advantages over message passing systems <ref> [19, 17] </ref>. Since DSM provides a user a simple shared memory abstraction, the user does not have to be concerned with data move-mentbetween hosts. Many approaches have been proposed to implement distributed shared memory (e.g., [15, 5]). The DSM implementations are based on write-invalidation and/or write-update.
Reference: [20] <author> M. Stumm and S. Zhou, </author> <title> Fault tolerant distributed shared memory algorithms, </title> <booktitle> in Int. Conf. on Parallel and Distr. Processing, </booktitle> <pages> pp. 719-724, </pages> <year> 1990. </year>
Reference-contexts: Many recoverable DSM schemes have been presented in the literature. Some of them use stable storage (disk) to save recovery data [22, 8, 18, 9], and others use main memory for checkpointing, replicating shared memory or logging the shared memory accesses <ref> [20, 2, 4, 16, 6, 12, 21] </ref>. Proposed recoverable DSM belongs to the second category (uses main memory). [20, 21] are based on update (full-replication) protocol, while [2, 4, 16, 6, 12] are based on invalidate (read-replication) protocol. <p> Some of them use stable storage (disk) to save recovery data [22, 8, 18, 9], and others use main memory for checkpointing, replicating shared memory or logging the shared memory accesses [20, 2, 4, 16, 6, 12, 21]. Proposed recoverable DSM belongs to the second category (uses main memory). <ref> [20, 21] </ref> are based on update (full-replication) protocol, while [2, 4, 16, 6, 12] are based on invalidate (read-replication) protocol. Stumm and Zhou extended four DSM algorithms to tolerate single node failures [20]. One of their algorithmsis for an update protocol. <p> Proposed recoverable DSM belongs to the second category (uses main memory). [20, 21] are based on update (full-replication) protocol, while [2, 4, 16, 6, 12] are based on invalidate (read-replication) protocol. Stumm and Zhou extended four DSM algorithms to tolerate single node failures <ref> [20] </ref>. One of their algorithmsis for an update protocol. But, implementations of our algorithm is different because their algorithm is based on update protocol where all copies of a page are updated, whereas our scheme is based on the competitive update protocol (some copies are invalidated to reduce overhead). <p> The copy with the largest version number is the most up-to-date copy (this is similar to <ref> [20] </ref>). If a node fails after it has written to a page, butbefore ithas performed a release then the modifications made by the node are lostwhen the node fails. This is acceptable, as the system state will still be consistent after the failure.
Reference: [21] <author> O. Theel and B. Fleisch, </author> <title> Design and analysis of highly available and scalable coherence protocols for distributed shared memory systems using stochastic modeling, </title> <booktitle> in Int. Conf. on Parallel Procesing, </booktitle> <volume> vol. I, </volume> <month> Aug. </month> <year> 1995. </year>
Reference-contexts: Many recoverable DSM schemes have been presented in the literature. Some of them use stable storage (disk) to save recovery data [22, 8, 18, 9], and others use main memory for checkpointing, replicating shared memory or logging the shared memory accesses <ref> [20, 2, 4, 16, 6, 12, 21] </ref>. Proposed recoverable DSM belongs to the second category (uses main memory). [20, 21] are based on update (full-replication) protocol, while [2, 4, 16, 6, 12] are based on invalidate (read-replication) protocol. <p> Some of them use stable storage (disk) to save recovery data [22, 8, 18, 9], and others use main memory for checkpointing, replicating shared memory or logging the shared memory accesses [20, 2, 4, 16, 6, 12, 21]. Proposed recoverable DSM belongs to the second category (uses main memory). <ref> [20, 21] </ref> are based on update (full-replication) protocol, while [2, 4, 16, 6, 12] are based on invalidate (read-replication) protocol. Stumm and Zhou extended four DSM algorithms to tolerate single node failures [20]. One of their algorithmsis for an update protocol. <p> Additionally, our scheme supports release consistency. Theel and Fleisch recently presented a coherence protocol <ref> [21] </ref> that is highly available. Their scheme has an upper bound (to reduce overhead) as well as a lower bound (for availability) on the number of copies of each shared memory page. Unlike [21], our scheme is based on the competitive update protocol. <p> Additionally, our scheme supports release consistency. Theel and Fleisch recently presented a coherence protocol <ref> [21] </ref> that is highly available. Their scheme has an upper bound (to reduce overhead) as well as a lower bound (for availability) on the number of copies of each shared memory page. Unlike [21], our scheme is based on the competitive update protocol. Janssens and Fuchs [9] present a recoverable DSM that exploits release consistency to reduce the number of checkpoints, as compared to communication-induced check-pointing schemes for sequential consistency.
Reference: [22] <author> K.-L. Wu and W. K. Fuchs, </author> <title> Recoverable distributed shared virtual memory: Memory coherenceandstorage structures, </title> <booktitle> in Int. Symp. on Fault-TolerantComp., </booktitle> <pages> pp. 520-527, </pages> <year> 1989. </year>
Reference-contexts: Many recoverable DSM schemes have been presented in the literature. Some of them use stable storage (disk) to save recovery data <ref> [22, 8, 18, 9] </ref>, and others use main memory for checkpointing, replicating shared memory or logging the shared memory accesses [20, 2, 4, 16, 6, 12, 21].
References-found: 22

