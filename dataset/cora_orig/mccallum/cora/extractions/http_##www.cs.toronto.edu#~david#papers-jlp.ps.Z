URL: http://www.cs.toronto.edu/~david/papers-jlp.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/cv.html
Root-URL: http://www.cs.toronto.edu
Title: Datalog with Integer Periodicity Constraints  
Author: David Toman and Jan Chomicki 
Note: J. LOGIC PROGRAMMING (DRAFT) 1  
Abstract: fl In this paper we introduce a generalization of Datalog that operates on periodicity constraints over integers. We develop a closed-form bottom-up evaluation procedure for this class of constraints. We also develop a closed-form bottom-up query evaluation procedure for the class of periodic constraints combined with gap-order constraints. We provide complexity bounds for the query evaluation procedures. We extend the approach to combinations of classes of constraints over disjoint domains in the frame work of Datalog. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Baudinet, M., Chomicki, J., Wolper, P. </author> <title> Temporal Deductive Databases. In Temporal Databases: Theory, Design, And Implementation, Tansel, </title> <editor> A. et al. (editors). </editor> <publisher> Benjamin Cummings 1993. </publisher>
Reference-contexts: We have also shown complexity bounds for the bottom-up evaluation algorithm. Below we list some further directions of research. Expressiveness. In <ref> [1] </ref> the expressiveness of a number of deductive and constraint query languages is discussed. However, only monadic programs are considered there. It is interesting to see, whether the expressiveness of query languages defined in this section can also be formally characterized. Efficient Implementation. Periodicity constraints define non-convex sets.
Reference: 2. <author> Baudinet, M., Niezette, M., Wolper P. </author> <title> On the Representation of Infinite Temporal Data and Queries. </title> <booktitle> 10th ACM Symposium on Principles of Database Systems, </booktitle> <pages> 280-290, </pages> <year> 1991. </year>
Reference-contexts: In particular, order constraints are not expressible in this language. Also, the unary successor symbol is used in the deductive layer on top of the database. Our approach allows a representation of the infinite relations to be directly stored in the database. Another extension of Datalog was proposed in <ref> [2] </ref>. This extension combines linear repeating points, order constraints, and unlimited use of successor function. The resulting language is very expressive, but the termination of query evaluation cannot be guaranteed. There are also many proposals to extend a first-order query language (e.g., the relational calculus) with constraints [10]. <p> However even the simplest extension beyond (gap-)order constraints, e.g., inclusion of the linear arithmetic constraints leads immediately to nontermination in the case of Datalog. Summarizing: [12, 13] cannot handle periodicity constraints, [9] cannot handle recursion, [4, 5] cannot handle ordering, and <ref> [2] </ref> does not guarantee termination. 2 Under few mild restrictions. Datalog with Integer Periodicity Constraints 5 Our language is thus another step towards a tractable and expressive query language for temporal databases. The rest of the paper is organized as follows.
Reference: 3. <author> Birkhoff, G., MacLane, S. </author> <title> Algebra. </title> <publisher> The MacMillan Co., </publisher> <year> 1967. </year>
Reference-contexts: We show an exponential lower bound for Datalog jZ programs that do not meet this requirement. To show this bound we use the following proposition: Proposition 3.17 (The cyclic primary decomposition theorem <ref> [3] </ref>). Any finite Abelian group is isomorphic to a finite product of cyclic groups of prime power orders, and the list of the prime power orders is unique up to permutation. <p> Most of the results about integers can be easily found in books on number theory, e.g., [6, 23], or [17] (if you read Polish). Other useful results about cyclic groups Z n can be found in books on group theory and modern algebra in general, e.g., <ref> [3] </ref>.
Reference: 4. <author> Chomicki, J., Imielinski, T. </author> <title> Temporal Deductive Databases and Infinite Objects. </title> <booktitle> Proc. 7th ACM Symposium on Principles of Database Systems, </booktitle> <pages> 61-73, </pages> <year> 1988. </year>
Reference-contexts: This arrangement provides a potentially more general framework, which could be adapted to combinations of other constraint languages over the integers. Another approach comes from the area of temporal databases. In <ref> [4, 5] </ref> Datalog was extended with a limited use of the successor function symbol (the use is restricted to a single distinguished argument in each literal). In this way it is possible to represent infinite periodic sets of integers using Horn rules. <p> However even the simplest extension beyond (gap-)order constraints, e.g., inclusion of the linear arithmetic constraints leads immediately to nontermination in the case of Datalog. Summarizing: [12, 13] cannot handle periodicity constraints, [9] cannot handle recursion, <ref> [4, 5] </ref> cannot handle ordering, and [2] does not guarantee termination. 2 Under few mild restrictions. Datalog with Integer Periodicity Constraints 5 Our language is thus another step towards a tractable and expressive query language for temporal databases. The rest of the paper is organized as follows.
Reference: 5. <author> Chomicki, J., Imielinski, T. </author> <title> Finite Representation of Infinite Query Answers, </title> <journal> In ACM Transactions on Database Systems, </journal> <volume> 181-223, (18) 2, </volume> <year> 1993. </year>
Reference-contexts: This arrangement provides a potentially more general framework, which could be adapted to combinations of other constraint languages over the integers. Another approach comes from the area of temporal databases. In <ref> [4, 5] </ref> Datalog was extended with a limited use of the successor function symbol (the use is restricted to a single distinguished argument in each literal). In this way it is possible to represent infinite periodic sets of integers using Horn rules. <p> However even the simplest extension beyond (gap-)order constraints, e.g., inclusion of the linear arithmetic constraints leads immediately to nontermination in the case of Datalog. Summarizing: [12, 13] cannot handle periodicity constraints, [9] cannot handle recursion, <ref> [4, 5] </ref> cannot handle ordering, and [2] does not guarantee termination. 2 Under few mild restrictions. Datalog with Integer Periodicity Constraints 5 Our language is thus another step towards a tractable and expressive query language for temporal databases. The rest of the paper is organized as follows.
Reference: 6. <author> Hardy, G. H. </author> <title> An Introduction to the Theory of Numbers. </title> <publisher> Oxford University Press, </publisher> <year> 1979. </year>
Reference-contexts: Then G is equivalent to C. Proof. Immediate from Definitions 2.2, 2.3, and 2.4. To combine constraints over the same variables we use the following Proposition <ref> [6] </ref>: Datalog with Integer Periodicity Constraints 7 Proposition 2.7 (Chinese Remainder Theorem). Let k 1 ; k 2 2 N , 0 c 1 &lt; k 1 , and 0 c 2 &lt; k 2 . <p> Bibliographical Comments The work on the combination of Datalog rules with integer order constraints was pursued in [12, 13]. Integer based constraint queries have also been proposed in [9]. Most of the results about integers can be easily found in books on number theory, e.g., <ref> [6, 23] </ref>, or [17] (if you read Polish). Other useful results about cyclic groups Z n can be found in books on group theory and modern algebra in general, e.g., [3].
Reference: 7. <author> Jaffar, J., Lassez, J. L. </author> <title> Constraint Logic Programming. </title> <booktitle> Proc. 14th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> 111-119, </pages> <year> 1987. </year>
Reference-contexts: In this paper we study generalized Datalog programs (function-free logic programs) that operate on constraint tuples in the place of ground atoms. This idea comes from constraint logic programming <ref> [7] </ref> and allows declarative specification of problems not solvable using the standard Datalog framework (e.g., reasoning about infinite sets of integers). fl A preliminary report on this work appeared in the proceedings of the 1994 International Logic Programming Symposium, Ithaca, NY [20]. y Department of Computer Science, University of Toronto Toronto,
Reference: 8. <author> Jensen, C. S., Snodgrass, R. </author> <title> Temporal Specialization and Generalization. </title> <journal> IEEE Transactions on Knowledge and Data Engineering 6(6): </journal> <pages> 954-974, </pages> <year> 1993. </year>
Reference-contexts: The constraints are used to represent possibly infinite sets of time points [9, 19]. Periodicity and order constraints also serve to formulate general integrity constraints over temporal databases <ref> [8] </ref>. Example 1.2. A simple example of a Datalog program that uses integer constraints is a database of airline connections between cities (cf. Figure 1).
Reference: 9. <author> Kabanza, F., Stevenne, J-M., Wolper, P. </author> <title> Handling Infinite Temporal Data. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> (51) 1, </volume> <pages> 149-186, </pages> <year> 1995. </year>
Reference-contexts: 1. Introduction Generalized databases <ref> [9, 10, 19] </ref> are infinite databases that can be represented using finite sets of generalized (or constraint ) tuples. A number of query languages over such databases have been studied. <p> Applications of both periodicity and order constraints over integers can be found in several areas, including temporal databases where the time component is isomorphic to integers. The constraints are used to represent possibly infinite sets of time points <ref> [9, 19] </ref>. Periodicity and order constraints also serve to formulate general integrity constraints over temporal databases [8]. Example 1.2. A simple example of a Datalog program that uses integer constraints is a database of airline connections between cities (cf. Figure 1). <p> Related Work There are other proposals that introduce classes of infinite integer relations into various query languages and define closed-form bottom-up evaluation procedures for Datalog over these constraint classes: Datalog with (gap-)order constraints was introduced in [12]. In <ref> [9] </ref> relational calculus over generalized relational databases with order constraints and linear repeating points was studied (a linear repeating point has the form fc + knjn 2 Zg for some fixed integers c and k and is just a different notation for a periodicity constraint). <p> There are also many proposals to extend a first-order query language (e.g., the relational calculus) with constraints [10]. However even the simplest extension beyond (gap-)order constraints, e.g., inclusion of the linear arithmetic constraints leads immediately to nontermination in the case of Datalog. Summarizing: [12, 13] cannot handle periodicity constraints, <ref> [9] </ref> cannot handle recursion, [4, 5] cannot handle ordering, and [2] does not guarantee termination. 2 Under few mild restrictions. Datalog with Integer Periodicity Constraints 5 Our language is thus another step towards a tractable and expressive query language for temporal databases. <p> This idea is used for the projection operation needed in the TP j;&lt; operator; a similar idea was used in <ref> [9] </ref>; our procedure is simpler due to a different representation of constraints, especially we can omit the normalization (in the sense of [9]) of constraint tuples 5 . Algorithm 4.7 (Projection). <p> This idea is used for the projection operation needed in the TP j;&lt; operator; a similar idea was used in <ref> [9] </ref>; our procedure is simpler due to a different representation of constraints, especially we can omit the normalization (in the sense of [9]) of constraint tuples 5 . Algorithm 4.7 (Projection). <p> Lemma 4.8. Let f (G i ; H i )ji 2 Ig be the set of graphs produced by Algorithm 4.7 from the pair (G; H) with respect to a variable y. Then for all valuations : j= i2I 5 The normalization in <ref> [9] </ref> is different from Definition 2.11 and requires whole relations to be normalized. 22 David Toman and Jan Chomicki qe (y,(G; H)) = if indegree (y) = 0 then return f (G fyg; H fyg)g else let x be a node such that (x; y) 2 E H and l be <p> However, this approach works only for convex sets. Thus, periodicity constraints call for new storage management techniques. Bibliographical Comments The work on the combination of Datalog rules with integer order constraints was pursued in [12, 13]. Integer based constraint queries have also been proposed in <ref> [9] </ref>. Most of the results about integers can be easily found in books on number theory, e.g., [6, 23], or [17] (if you read Polish). Other useful results about cyclic groups Z n can be found in books on group theory and modern algebra in general, e.g., [3].
Reference: 10. <author> Kanellakis, P. C., Kuper, G. M., Revesz, P.Z. </author> <title> Constraint Query Languages, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> (51) 1, </volume> <pages> 26-52, </pages> <year> 1995. </year>
Reference-contexts: 1. Introduction Generalized databases <ref> [9, 10, 19] </ref> are infinite databases that can be represented using finite sets of generalized (or constraint ) tuples. A number of query languages over such databases have been studied. <p> THE JOURNAL OF LOGIC PROGRAMMING c flElsevier Science Publishing Co., Inc., 1993 655 Avenue of the Americas, New York, NY 10010 0743-1066/93/$3.50 2 David Toman and Jan Chomicki Out work generally follows the conventions in <ref> [10] </ref>: In particular, constraints (constraint tuples 1 ) are built out of a given set of atomic constraints over integers using finite application conjunction and quantifier elimination (cf. Definitions 2.1 and 4.1). <p> This extension combines linear repeating points, order constraints, and unlimited use of successor function. The resulting language is very expressive, but the termination of query evaluation cannot be guaranteed. There are also many proposals to extend a first-order query language (e.g., the relational calculus) with constraints <ref> [10] </ref>. However even the simplest extension beyond (gap-)order constraints, e.g., inclusion of the linear arithmetic constraints leads immediately to nontermination in the case of Datalog. <p> The relation defines the meaning (semantics) of the j-interpretations. The ground interpretation I can be viewed as a set of unrestricted relations <ref> [10] </ref>. To show that the bottom-up evaluation on j-interpretations gives the same result (with respect to ) as the fixed-point iteration of the TP, we first show that a single application of TP and TP j preserves : Lemma 3.7. <p> However, only monadic programs are considered there. It is interesting to see, whether the expressiveness of query languages defined in this section can also be formally characterized. Efficient Implementation. Periodicity constraints define non-convex sets. In this respect they differ from most common constraint languages. <ref> [10] </ref> describes how to adapt interval management techniques for indexing in constraint databases. However, this approach works only for convex sets. Thus, periodicity constraints call for new storage management techniques. Bibliographical Comments The work on the combination of Datalog rules with integer order constraints was pursued in [12, 13].
Reference: 11. <author> Lloyd, J. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year> <note> 28 David Toman and Jan Chomicki </note>
Reference-contexts: Then by the assumption B i 2 I and by the definition of TP A 2 TP (I). Lemma 3.8. The immediate consequence operator TP j is monotonic and continu ous (preserves suprema of directed chains). Proof. Immediate from Lemma 3.7 as TP is monotonic and continuous <ref> [11] </ref> Now we prove the correctness of the closed form bottom-up evaluation algorithm by relating the iteration of the standard TP operator on ground interpretations to the iteration of TP j .
Reference: 12. <author> Revesz, P. Z. </author> <title> A Closed Form Evaluation for Datalog Queries with Integer Order. </title> <booktitle> Proc. 3rd International Conference on Database Theory, </booktitle> <pages> 187-201, </pages> <publisher> Springer-Verlag LNCS 470, </publisher> <year> 1990. </year>
Reference-contexts: Periodic sets are useful for encoding and storing information about periodic activities in temporal databases, such as schedules, workflows, or experimental data. In addition, we show how such constraints can be combined with other classes of constraints over integers|gap-order constraints <ref> [12] </ref> and equality constraints over integers. Applications of both periodicity and order constraints over integers can be found in several areas, including temporal databases where the time component is isomorphic to integers. The constraints are used to represent possibly infinite sets of time points [9, 19]. <p> This language can be used as a simple but very expressive query language for temporal databases. The evaluation for gap-order constraints is based on the results in <ref> [12, 13] </ref>. The proposed bottom-up evaluation procedure has polynomial data complexity 2 . Also, a general method for incorporating various classes of constraints into Datalog is studied. 1.1. <p> Related Work There are other proposals that introduce classes of infinite integer relations into various query languages and define closed-form bottom-up evaluation procedures for Datalog over these constraint classes: Datalog with (gap-)order constraints was introduced in <ref> [12] </ref>. In [9] relational calculus over generalized relational databases with order constraints and linear repeating points was studied (a linear repeating point has the form fc + knjn 2 Zg for some fixed integers c and k and is just a different notation for a periodicity constraint). <p> There are also many proposals to extend a first-order query language (e.g., the relational calculus) with constraints [10]. However even the simplest extension beyond (gap-)order constraints, e.g., inclusion of the linear arithmetic constraints leads immediately to nontermination in the case of Datalog. Summarizing: <ref> [12, 13] </ref> cannot handle periodicity constraints, [9] cannot handle recursion, [4, 5] cannot handle ordering, and [2] does not guarantee termination. 2 Under few mild restrictions. Datalog with Integer Periodicity Constraints 5 Our language is thus another step towards a tractable and expressive query language for temporal databases. <p> Combining Classes of Constraints over Integers In this section we show how periodicity constraints can be combined with other classes of constraints over integers in the framework of Datalog. 4.1. Gap-order Constraints First we combine the constraint language developed so far with Datalog &lt;Z (Datalog with gap-order constraints <ref> [12, 13] </ref>). Definition 4.1 (Gap-order constraint). Let u and l be integers, c a nonnegative integer, and x; y; : : : be variables over integers. <p> Then a finite conjunction of formulas of the form l &lt; x, x &lt; u, and x + c &lt; y is called a gap-order constraint (tuple). Conjunctions of gap-order constraints can be efficiently represented using gap graphs <ref> [12] </ref> (directed acyclic graphs where nodes represent variables and the lower and the upper bounds of constraints, and directed labeled edges represent gaps|the minimal integer distances between nodes). This representation also supports all the necessary operations for closed-form bottom-up evaluation [12]. <p> of gap-order constraints can be efficiently represented using gap graphs <ref> [12] </ref> (directed acyclic graphs where nodes represent variables and the lower and the upper bounds of constraints, and directed labeled edges represent gaps|the minimal integer distances between nodes). This representation also supports all the necessary operations for closed-form bottom-up evaluation [12]. We show that the combination of these two approaches still has a closed-form evaluation procedure and the complexity bound does not increase. Datalog with Integer Periodicity Constraints 19 Definition 4.2 (Datalog jZ;&lt;Z programs). <p> Then P is a Datalog jZ;&lt;Z program. 4.1.1. Complexity of Consistency Checking Consistency (satisfiability) checking of periodicity graphs and gap-order graphs (separately) can be done in polynomial time with respect to the size of the graph (cf. Section 2 and <ref> [12, 13] </ref>). However, Theorem 4.3. Consistency checking of a conjunction of a periodicity graph with a gap graph is NP-complete. Proof. By reduction of 3SAT to satisfiability of conjunctions of constraints of the form x j k (y + c) and x + c &lt; y. <p> On the other hand: Theorem 4.4. Consistency checking of a conjunction of a periodicity graph constructed from simple periodicity constraints only and a gap graph can be decided in PTIME. Proof. By generalization of the consistency checking procedure given in <ref> [12] </ref>; the algorithm computes the length of every path from the lower bound to the upper bound of the gap-graph by adding the gap sizes on the edges of the path. <p> Proof. By induction on i. Corollary 4.13. The bottom-up evaluation terminates for all Datalog jZ;&lt;Z pro gram. 24 David Toman and Jan Chomicki Combination of results in <ref> [12, 14] </ref> shows DEXPTIME-completeness of Datalog &lt;Z (again, a data-complexity result). The addition of periodicity constraints does not affect this result. <p> The addition of periodicity constraints does not affect this result. To show a polynomial bound for the tuple recognition procedure for Datalog jZ;&lt;Z programs we use the same technique: the tuple recognition runs in PTIME (follows from Theorem 3.15 and the complexity of the TEST Algorithm <ref> [12] </ref>) 6 . 4.1.3. Negation. Adding stratified negation to Datalog &lt;Z is nontrivial: [12] shows that Datalog &lt;Z;: with full stratified negation is Turing-complete (and thus termination of queries cannot be guaranteed), [15] defines a syntactic restriction on stratified Datalog &lt;Z;: programs where queries are terminating (but nonelementary). <p> To show a polynomial bound for the tuple recognition procedure for Datalog jZ;&lt;Z programs we use the same technique: the tuple recognition runs in PTIME (follows from Theorem 3.15 and the complexity of the TEST Algorithm <ref> [12] </ref>) 6 . 4.1.3. Negation. Adding stratified negation to Datalog &lt;Z is nontrivial: [12] shows that Datalog &lt;Z;: with full stratified negation is Turing-complete (and thus termination of queries cannot be guaranteed), [15] defines a syntactic restriction on stratified Datalog &lt;Z;: programs where queries are terminating (but nonelementary). <p> This kind of constraints can be handled directly using the gap-order constraints: (x = d) () (d 1 &lt; x &lt; d + 1) 2. x = y, where both x and y are variables. In <ref> [12] </ref> this kind of constraints is handled by adding extra information to the gap-graphs. In the case of Datalog jZ it can be done in the same way; in all cases we need some mechanism to represent a single constraint of the form x = y. <p> However, this approach works only for convex sets. Thus, periodicity constraints call for new storage management techniques. Bibliographical Comments The work on the combination of Datalog rules with integer order constraints was pursued in <ref> [12, 13] </ref>. Integer based constraint queries have also been proposed in [9]. Most of the results about integers can be easily found in books on number theory, e.g., [6, 23], or [17] (if you read Polish).
Reference: 13. <author> Revesz, P. Z. </author> <title> A Closed Form Evaluation for Datalog Queries with Integer (Gap)- Order Constraints. </title> <journal> Theoretical Computer Science, </journal> <volume> vol. 116, no. 1, </volume> <pages> 117-149, </pages> <year> 1993. </year>
Reference-contexts: This language can be used as a simple but very expressive query language for temporal databases. The evaluation for gap-order constraints is based on the results in <ref> [12, 13] </ref>. The proposed bottom-up evaluation procedure has polynomial data complexity 2 . Also, a general method for incorporating various classes of constraints into Datalog is studied. 1.1. <p> There are also many proposals to extend a first-order query language (e.g., the relational calculus) with constraints [10]. However even the simplest extension beyond (gap-)order constraints, e.g., inclusion of the linear arithmetic constraints leads immediately to nontermination in the case of Datalog. Summarizing: <ref> [12, 13] </ref> cannot handle periodicity constraints, [9] cannot handle recursion, [4, 5] cannot handle ordering, and [2] does not guarantee termination. 2 Under few mild restrictions. Datalog with Integer Periodicity Constraints 5 Our language is thus another step towards a tractable and expressive query language for temporal databases. <p> Combining Classes of Constraints over Integers In this section we show how periodicity constraints can be combined with other classes of constraints over integers in the framework of Datalog. 4.1. Gap-order Constraints First we combine the constraint language developed so far with Datalog &lt;Z (Datalog with gap-order constraints <ref> [12, 13] </ref>). Definition 4.1 (Gap-order constraint). Let u and l be integers, c a nonnegative integer, and x; y; : : : be variables over integers. <p> Then P is a Datalog jZ;&lt;Z program. 4.1.1. Complexity of Consistency Checking Consistency (satisfiability) checking of periodicity graphs and gap-order graphs (separately) can be done in polynomial time with respect to the size of the graph (cf. Section 2 and <ref> [12, 13] </ref>). However, Theorem 4.3. Consistency checking of a conjunction of a periodicity graph with a gap graph is NP-complete. Proof. By reduction of 3SAT to satisfiability of conjunctions of constraints of the form x j k (y + c) and x + c &lt; y. <p> However, this approach works only for convex sets. Thus, periodicity constraints call for new storage management techniques. Bibliographical Comments The work on the combination of Datalog rules with integer order constraints was pursued in <ref> [12, 13] </ref>. Integer based constraint queries have also been proposed in [9]. Most of the results about integers can be easily found in books on number theory, e.g., [6, 23], or [17] (if you read Polish).
Reference: 14. <author> Revesz, P. Z. </author> <title> Datalog Queries of Set Constraint Databases. </title> <booktitle> In Proc. 5th International Conference on Database Theory, </booktitle> <pages> 423-438, </pages> <year> 1995. </year>
Reference-contexts: Proof. By induction on i. Corollary 4.13. The bottom-up evaluation terminates for all Datalog jZ;&lt;Z pro gram. 24 David Toman and Jan Chomicki Combination of results in <ref> [12, 14] </ref> shows DEXPTIME-completeness of Datalog &lt;Z (again, a data-complexity result). The addition of periodicity constraints does not affect this result.
Reference: 15. <author> Revesz, P. </author> <title> Safe Stratified Datalog with Integer Order Programs. </title> <booktitle> In Proc. First International Conference on Constraint Programming, </booktitle> <editor> Montanari U., Rossi F. eds., </editor> <publisher> Springer-Verlag LNCS 976, </publisher> <address> Cassis, France, </address> <month> September </month> <year> 1995. </year>
Reference-contexts: Negation. Adding stratified negation to Datalog &lt;Z is nontrivial: [12] shows that Datalog &lt;Z;: with full stratified negation is Turing-complete (and thus termination of queries cannot be guaranteed), <ref> [15] </ref> defines a syntactic restriction on stratified Datalog &lt;Z;: programs where queries are terminating (but nonelementary). The second approach can be immediately combined with unary periodicity constraints to obtain a safe version of stratified Datalog jZ;&lt;Z;: . The addition of periodicity constraints does not affect the query evaluation complexity. 4.2.
Reference: 16. <author> Shapiro, H. N. </author> <title> Introduction to the Theory of Numbers. </title> <publisher> John Wiley & Sons, </publisher> <year> 1983. </year>
Reference-contexts: The fact that this program generates all the constraints follows immediately from Proposition 3.17 and the fact that the growth rate of the sequence of primes is approximately n log n <ref> [16, 17] </ref>; every element of Z P is isomorphic to the product of the appropriate elements in the individual groups Z p i .
Reference: 17. <author> Sierpinski, W. </author> <title> Teoria Liczb, Part II, </title> <address> Warsaw, </address> <year> 1959. </year>
Reference-contexts: The fact that this program generates all the constraints follows immediately from Proposition 3.17 and the fact that the growth rate of the sequence of primes is approximately n log n <ref> [16, 17] </ref>; every element of Z P is isomorphic to the product of the appropriate elements in the individual groups Z p i . <p> Bibliographical Comments The work on the combination of Datalog rules with integer order constraints was pursued in [12, 13]. Integer based constraint queries have also been proposed in [9]. Most of the results about integers can be easily found in books on number theory, e.g., [6, 23], or <ref> [17] </ref> (if you read Polish). Other useful results about cyclic groups Z n can be found in books on group theory and modern algebra in general, e.g., [3].
Reference: 18. <author> Swift, T., Warren, D. S. </author> <title> Analysis of SLG-WAM Evaluation of Definite Programs. </title> <booktitle> Proc. 1994 International Logic Programming Symposium, </booktitle> <publisher> MIT Press, </publisher> <year> 1994, </year> <pages> 219-235. </pages>
Reference-contexts: However, the TP operator would have to operate on infinite ground interpretations. This arrangement also shows how other evaluation procedures based on the constraint operations or the TP operator can be utilized for constraint query evaluation, e.g., the semi-naive bottom-up evaluation [22], or the SLG resolution <ref> [18, 21] </ref>. 3.2. Termination We show termination of an arbitrary Datalog jZ program by showing that the set of all possible periodicity graphs of given arity is finite for any given Datalog jZ program. Definition 3.10 (Upper bound).
Reference: 19. <author> Tansel A., Clifford J., Gadia S., Jajodia S., Segev A., Snodgrass R. </author> <title> Temporal Databases. Theory, Design, and Implementation. </title> <publisher> Benjamin Cummings 1993. </publisher>
Reference-contexts: 1. Introduction Generalized databases <ref> [9, 10, 19] </ref> are infinite databases that can be represented using finite sets of generalized (or constraint ) tuples. A number of query languages over such databases have been studied. <p> Applications of both periodicity and order constraints over integers can be found in several areas, including temporal databases where the time component is isomorphic to integers. The constraints are used to represent possibly infinite sets of time points <ref> [9, 19] </ref>. Periodicity and order constraints also serve to formulate general integrity constraints over temporal databases [8]. Example 1.2. A simple example of a Datalog program that uses integer constraints is a database of airline connections between cities (cf. Figure 1).
Reference: 20. <author> Toman, D., Chomicki, J., Rogers D. S. </author> <title> Datalog with Integer Periodicity Constraints. </title> <booktitle> Proc. 1994 International Logic Programming Symposium, </booktitle> <pages> 189-203, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: This idea comes from constraint logic programming [7] and allows declarative specification of problems not solvable using the standard Datalog framework (e.g., reasoning about infinite sets of integers). fl A preliminary report on this work appeared in the proceedings of the 1994 International Logic Programming Symposium, Ithaca, NY <ref> [20] </ref>. y Department of Computer Science, University of Toronto Toronto, Ontario, Canada M5S 1A4 david@cs.toronto.edu. z Department of Computer Science, Monmouth University West Long Branch, NJ 07764, U.S.A. chomicki@moncol.monmouth.edu.
Reference: 21. <author> Toman, D. </author> <title> Memoing Evaluation for Constraint Extensions of Datalog. </title> <note> To appear in the International Journal on Constraints, special issue on Databases. </note> <year> 1997. </year> <title> An extended abstract appeared as Top-Down beats Bottom-Up for Constraint Based Extensions of Datalog. </title> <booktitle> Proc. 1995 International Logic Programming Symposium, </booktitle> <pages> 98-112, </pages> <publisher> MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: However, the TP operator would have to operate on infinite ground interpretations. This arrangement also shows how other evaluation procedures based on the constraint operations or the TP operator can be utilized for constraint query evaluation, e.g., the semi-naive bottom-up evaluation [22], or the SLG resolution <ref> [18, 21] </ref>. 3.2. Termination We show termination of an arbitrary Datalog jZ program by showing that the set of all possible periodicity graphs of given arity is finite for any given Datalog jZ program. Definition 3.10 (Upper bound).
Reference: 22. <author> Ullman J. D. </author> <title> Principles of Database and Knowledge-base Systems, </title> <booktitle> Vol. 1,2. Computer Science Systems, </booktitle> <year> 1989. </year>
Reference-contexts: However, the TP operator would have to operate on infinite ground interpretations. This arrangement also shows how other evaluation procedures based on the constraint operations or the TP operator can be utilized for constraint query evaluation, e.g., the semi-naive bottom-up evaluation <ref> [22] </ref>, or the SLG resolution [18, 21]. 3.2. Termination We show termination of an arbitrary Datalog jZ program by showing that the set of all possible periodicity graphs of given arity is finite for any given Datalog jZ program. Definition 3.10 (Upper bound). <p> For a fixed K, the definitions represent a fixed set of clauses added to the original Datalog jZ program. Therefore the data complexity results obtained in the previous section apply to this case as well. Similarly we can introduce the stratified negation <ref> [22] </ref> to Datalog jZ programs and preserve the data complexity bounds: Definition 3.19. Let G be a periodicity graph over the set of variables X.
Reference: 23. <author> Weil, A. </author> <title> Basic number theory. </title> <publisher> 3ed. Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: Bibliographical Comments The work on the combination of Datalog rules with integer order constraints was pursued in [12, 13]. Integer based constraint queries have also been proposed in [9]. Most of the results about integers can be easily found in books on number theory, e.g., <ref> [6, 23] </ref>, or [17] (if you read Polish). Other useful results about cyclic groups Z n can be found in books on group theory and modern algebra in general, e.g., [3].
Reference: 24. <author> Williams, H. P. </author> <title> Fourier-Motzkin Elimination Extension to Integer Programming Problems. </title> <journal> In Journal of Combinatorial Theory (A) 21, </journal> <pages> 118-123, </pages> <year> 1976. </year> <title> Acknowledgment The participation of David S. Rogers in the early stages of this research and the discussions with Peter Revesz are gratefully acknowledged. The authors would also like to thank one of the reviewers for suggesting the possibility of translating Datalog jZ to pure Datalog. </title>
Reference-contexts: We can also use the consistency check from Theorem 4.4. However, the most complex operation|the quantifier elimination|has to take care of the interactions between the periodicity constraints and the gap-order constraints <ref> [24] </ref>: Example 4.6. <p> For indegree (y) = k we select a node x such that (x; y) 2 G. One iteration of the qe procedure removes this edge from G and adds edges from x to all successors of y in G with the appropriate labels (cf. Example 4.6, Algorithm 4.7, and <ref> [24] </ref>). Thus the resulting set of graphs is equivalent to the original graph and indegree (y) = k 1. Application of the inductive hypothesis on each of these graphs gives us the desired conclusion. Thus, Algorithm 4.7 defines the projection operation for periodicity graphs combined with gap graphs.
References-found: 24

