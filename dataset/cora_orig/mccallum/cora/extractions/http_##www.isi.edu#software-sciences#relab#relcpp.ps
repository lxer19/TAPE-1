URL: http://www.isi.edu/software-sciences/relab/relcpp.ps
Refering-URL: http://www.isi.edu/software-sciences/relab/relab.html
Root-URL: http://www.isi.edu
Email: Email: fdonc,goldman,swamyg@isi.edu  
Phone: Voice: (310)822-1511 Fax: (310) 823-6714  
Title: Relations as Abstractions for C++ Programming programmer with relations as a new abstraction mechanism, offering
Author: Don Cohen Neil Goldman K. Narayanaswamy 
Keyword: CATEGORY: Research TOPIC AREAS: Patterns, Templates Generic Programming. Language Design and implementation.  
Note: RC++ provides the C++  
Address: 4676 Admiralty Way Marina del Rey, CA 90292  
Affiliation: USC/Information Sciences Institute  
Abstract: Use of the mathematical abstraction of relations among objects has achieved broad support in the Object-Oriented Modeling community, but is not supported in popular OO programming languages. This not only poses difficulties when implementing OO models in these languages, but deprives programmers of a valuable linguistic abstraction. Traditional implementation encapsulation makes performance of interfaces an implicitly public matter | programmers are forced to compose interfaces into algorithms based on knowledge of individual interface performance. Making performance explicit allows a query optimizer to take over this responsibility. While clients of a relation class may need to be recompiled when only performance characteristics of the class's interfaces change, they do not need to be rewritten.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. Batory et al. </author> <title> Scalable software libraries. </title> <booktitle> In ACM-SIGSOFT. ACM, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: He points out the value of many of the additional capabilities found in RC++ such as computed relations, constraints and programmer control over data representation. Batory <ref> [1] </ref> describes a way to factor container classes into features and generate on demand classes with interesting combinations of those features.
Reference: [2] <author> G. Booch. </author> <title> Object-Oriented Design with Applications. </title> <publisher> Benjamin Cummings Publishing Co., </publisher> <year> 1991. </year>
Reference-contexts: Implementing the Dynamic Model: The problems are compounded when one considers implementing the dynamic (i.e., state-changing) model of a domain. Notions like constraints (which are invariants specified on the state of objects [18, 15]), state machines <ref> [2, 12, 18] </ref>, and triggers (rules) [15], (which specify processing that results from certain conditions arising in the object state), have become staples of OO modeling. Unfortunately, there is considerable distance between these constructs and those supported by C++.
Reference: [3] <author> W. Clocksin and C. Mellish. </author> <title> Programming in PROLOG. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference: [4] <author> P. Coad and E. Yourdon. </author> <title> Object-Oriented Analysis. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction Many widely used OO Modeling methodologies (e.g., Rumbaugh's Object Modeling Technique (OMT) [18], Martin/Odell [15], or Coad/Yourdon <ref> [4] </ref>) advocate using the mathematical concept of relations in object models. Relations are accorded their own graphic symbology, and, in particular, binary relations are distin guished from simpler connections (called attributes) between objects and (generally non-object) values.
Reference: [5] <author> E. F. Codd. </author> <title> A relational model of data for large shared data banks. </title> <journal> Communications of the ACM, </journal> <volume> 13(6) </volume> <pages> 377-387, </pages> <month> Jun </month> <year> 1970. </year>
Reference-contexts: However, we believe that the best solution, in the absence of "open" compilers and debugging environments, is for programmers to be offered these relation metaphors by a commercial C++ development environment. 5 Related Work The most widely used relational systems are relational databases <ref> [5, 21] </ref>. These offer relations, a query language (similar to that of RC++), query optimization, triggering and constraints. These systems allow programmers some control over relation implementation, though not as much as RC++. Part of the reason is that they must provide persistence and controlled sharing of data.
Reference: [6] <author> D. Cohen. </author> <title> Automatic compilation of logical specifications into efficient programs. </title> <booktitle> In Proc. of AAAI 86. AAAI, </booktitle> <year> 1986. </year>
Reference-contexts: This resembles our transition relation implementations in that a large set of templates is replaced by a generator that composes them as needed from smaller pieces. 18 AP5 <ref> [7, 6] </ref> is a relational extension to Common Lisp that we have used for many years. For the most part its functionality is comparable to that of RC++.
Reference: [7] <author> D. Cohen. </author> <title> Compiling complex database triggers. </title> <booktitle> In Proc. of 1989 ACM SIGMOD, </booktitle> <pages> pages 225-234. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: This resembles our transition relation implementations in that a large set of templates is replaced by a generator that composes them as needed from smaller pieces. 18 AP5 <ref> [7, 6] </ref> is a relational extension to Common Lisp that we have used for many years. For the most part its functionality is comparable to that of RC++.
Reference: [8] <author> D. Cohen and N. Campbell. </author> <title> Automating relational operations on data structures. </title> <journal> IEEE Software, </journal> <month> May </month> <year> 1993. </year>
Reference-contexts: Cohen <ref> [8] </ref> describes the semantics of this language and how it is implemented. In the context of RC++ it is translated to produce appropriate member functions for relation classes, e.g., adding a tuple, generating one domain given another as input, etc. The translator also computes performance estimates for these functions. <p> For instance, we might want to represent a Location relation as an array indexed by elevator holding a single floor for each elevator. However this cannot represent a relation with no tuples unless we invent some special floor to represent "no floor". Cohen <ref> [8] </ref> does describe such representations, and we are able to implement most relational operations for them. However initializing them to hold a particular set of tuples has proven more difficult than expected.
Reference: [9] <editor> O. Deux et al. </editor> <title> The o2 system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <year> 1991. </year>
Reference-contexts: These requirements also impose significant performance costs not necessary for typical C++ programs. Relational databases have very primitive type systems that exclude objects belonging to pointer types or C++ classes. Object oriented data bases (OODBs) <ref> [13, 14, 9] </ref> do support user defined data types. What they do not support is relations! These are really object oriented languages with support for persistence and sharing. The argument for adding relations to them is the same as that for adding relations to C++.
Reference: [10] <author> N.M. Goldman and K. Narayanaswamy. </author> <title> Software evolution through iterative prototyping. </title> <booktitle> In 14th Int'l Conf. on Software Engg. IEEE, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: RC++ was not itself with OO modeling in mind, let alone any specific method. Rather we believe that relations are a valuable complement to existing programming languages. We have successfully used a somewhat similar Lisp-based language extension for many years <ref> [10] </ref>. We reference OO modeling primarily to reinforce the validity of our decisions in designing the main features of RC++, and to illustrate the relative advantages of RC++ over C++ in programming.
Reference: [11] <author> M. Jackson. </author> <title> System Development. </title> <publisher> Prentice-Hall, </publisher> <year> 1983. </year>
Reference-contexts: We motivate RC++ by considering the problems of implementing relations and other OO concepts in the context of a specific example, namely Jackson's elevator problem <ref> [11] </ref>. Our intent is simply to use an example that is easy to understand. Similarly, we have chosen Rumbaugh's OMT [18] as an exemplar of OO modeling techniques. Similar analysis applies to other OO methods as well.
Reference: [12] <author> I. Jacobson et al. </author> <title> Object-Oriented Software Engineering. </title> <publisher> ACM Press, </publisher> <year> 1992. </year> <month> 20 </month>
Reference-contexts: Implementing the Dynamic Model: The problems are compounded when one considers implementing the dynamic (i.e., state-changing) model of a domain. Notions like constraints (which are invariants specified on the state of objects [18, 15]), state machines <ref> [2, 12, 18] </ref>, and triggers (rules) [15], (which specify processing that results from certain conditions arising in the object state), have become staples of OO modeling. Unfortunately, there is considerable distance between these constructs and those supported by C++.
Reference: [13] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The objectstore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <year> 1991. </year>
Reference-contexts: These requirements also impose significant performance costs not necessary for typical C++ programs. Relational databases have very primitive type systems that exclude objects belonging to pointer types or C++ classes. Object oriented data bases (OODBs) <ref> [13, 14, 9] </ref> do support user defined data types. What they do not support is relations! These are really object oriented languages with support for persistence and sharing. The argument for adding relations to them is the same as that for adding relations to C++.
Reference: [14] <author> G.M. Lohman, B. Lindsay, H. Pirahesh, and K. Bernhard-Shieffer. </author> <title> The gemstone object database management system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10), </volume> <year> 1991. </year>
Reference-contexts: These requirements also impose significant performance costs not necessary for typical C++ programs. Relational databases have very primitive type systems that exclude objects belonging to pointer types or C++ classes. Object oriented data bases (OODBs) <ref> [13, 14, 9] </ref> do support user defined data types. What they do not support is relations! These are really object oriented languages with support for persistence and sharing. The argument for adding relations to them is the same as that for adding relations to C++.
Reference: [15] <author> J. Martin and J.J. Odell. </author> <title> Object-Oriented Analysis and Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction Many widely used OO Modeling methodologies (e.g., Rumbaugh's Object Modeling Technique (OMT) [18], Martin/Odell <ref> [15] </ref>, or Coad/Yourdon [4]) advocate using the mathematical concept of relations in object models. Relations are accorded their own graphic symbology, and, in particular, binary relations are distin guished from simpler connections (called attributes) between objects and (generally non-object) values. <p> Implementing the Dynamic Model: The problems are compounded when one considers implementing the dynamic (i.e., state-changing) model of a domain. Notions like constraints (which are invariants specified on the state of objects <ref> [18, 15] </ref>), state machines [2, 12, 18], and triggers (rules) [15], (which specify processing that results from certain conditions arising in the object state), have become staples of OO modeling. Unfortunately, there is considerable distance between these constructs and those supported by C++. <p> Implementing the Dynamic Model: The problems are compounded when one considers implementing the dynamic (i.e., state-changing) model of a domain. Notions like constraints (which are invariants specified on the state of objects [18, 15]), state machines [2, 12, 18], and triggers (rules) <ref> [15] </ref>, (which specify processing that results from certain conditions arising in the object state), have become staples of OO modeling. Unfortunately, there is considerable distance between these constructs and those supported by C++. <p> RC++'s constraints, being objects in their own right, can be static, having global extent, automatic, having dynamic extent, or may be heap-allocated, allowing explicit deactivation. Another feature common to many OO modeling methodologies is use of of a dynamic behavioral model, based on finite state diagrams. Martin and Odell <ref> [15] </ref>, for example, define trigger rules consisting of events, control conditions, and operations, that are quite similar to the triggers of RC++. RC++ does not itself provide a high-level abstraction for a state machine.
Reference: [16] <author> D.S. Rosenblum. </author> <title> Towards a method of programming with assertions. </title> <booktitle> In Proc. of 14th ICSE, </booktitle> <address> Melbourne, Australia, 1992. </address> <publisher> IEEE. </publisher>
Reference-contexts: The seminal process programming language APPL/A [20] includes linguistic features that are comparable to those in RC++. Rosenblum <ref> [16] </ref> advocates "assertions", similar to our constraints, as a debugging tool. He also describes a preprocessor for C that adds constraint checking code and provides a limited form of temporal reference. 6 Remaining Issues Our current implementation requires that all transition relations be initialized to contain no tuples.
Reference: [17] <author> J. Rumbaugh. </author> <title> Relations as semantic constructs in an object-oriented language. </title> <booktitle> In Proceedings of OOPSLA 87, </booktitle> <pages> pages 466-481, </pages> <year> 1987. </year>
Reference-contexts: Many "static" OO Modeling concepts (such as attributes, subclasses and inheritance) are already well supported by OO languages, including C++. Relations, however, are not supported directly by OO lan guages. As Rumbaugh, et.al. <ref> [17] </ref> have observed: 1 "Associations are intrinsically important since they arise when capturing and describing re-quirements. The real-world need for associations does not go away merely because most existing OO languages are not rich enough to directly capture them. <p> What they do not support is relations! These are really object oriented languages with support for persistence and sharing. The argument for adding relations to them is the same as that for adding relations to C++. Rumbaugh <ref> [17] </ref> describes why relations ought to be supported in object oriented languages and also describes an implementation with much less power than RC++. He points out the value of many of the additional capabilities found in RC++ such as computed relations, constraints and programmer control over data representation.
Reference: [18] <author> J. Rumbaugh et al. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction Many widely used OO Modeling methodologies (e.g., Rumbaugh's Object Modeling Technique (OMT) <ref> [18] </ref>, Martin/Odell [15], or Coad/Yourdon [4]) advocate using the mathematical concept of relations in object models. Relations are accorded their own graphic symbology, and, in particular, binary relations are distin guished from simpler connections (called attributes) between objects and (generally non-object) values. <p> We motivate RC++ by considering the problems of implementing relations and other OO concepts in the context of a specific example, namely Jackson's elevator problem [11]. Our intent is simply to use an example that is easy to understand. Similarly, we have chosen Rumbaugh's OMT <ref> [18] </ref> as an exemplar of OO modeling techniques. Similar analysis applies to other OO methods as well. The software is to control an elevator system with the usual buttons, lights and sensors. Figure 1 shows part of an object model for this domain. Elevator, Floor, and Direction are classes. <p> A choice must be made based on an analysis of several factors; in particular, the access paths that are to be supported and the performance requirements they must meet. Encoding the implementation often involves more esoteric aspects of the language (such as "friend" declarations in C++; see <ref> [18] </ref> for a more detailed discussion) because many efficient implementations for relations violate the natural class-based encapsulation in OO languages. More importantly, every access to a relation must be encoded in a manner that depends on the chosen implementation. <p> Implementing the Dynamic Model: The problems are compounded when one considers implementing the dynamic (i.e., state-changing) model of a domain. Notions like constraints (which are invariants specified on the state of objects <ref> [18, 15] </ref>), state machines [2, 12, 18], and triggers (rules) [15], (which specify processing that results from certain conditions arising in the object state), have become staples of OO modeling. Unfortunately, there is considerable distance between these constructs and those supported by C++. <p> Implementing the Dynamic Model: The problems are compounded when one considers implementing the dynamic (i.e., state-changing) model of a domain. Notions like constraints (which are invariants specified on the state of objects [18, 15]), state machines <ref> [2, 12, 18] </ref>, and triggers (rules) [15], (which specify processing that results from certain conditions arising in the object state), have become staples of OO modeling. Unfortunately, there is considerable distance between these constructs and those supported by C++.
Reference: [19] <author> B. Stroustroup. </author> <title> Object-Oriented Programming in C++. </title> <publisher> Addison Wesley Publishing, </publisher> <year> 1990. </year>
Reference-contexts: The best solution to this problem would be for language designers to provide support for association objects as a basic concept,..." This paper describes an extension to the C++ programming language <ref> [19] </ref> called RC++which supports relations as a programming abstraction, and provides some arguments and intuition for how this extension can considerably improve software development and maintenance relative to unadorned C++.
Reference: [20] <author> S.M. Sutton, D. Heimbigner, and L.J. Osterweil. </author> <title> Language constructs for managing change in process-centered environments. </title> <booktitle> In Proc. of the Fourth Symposium on Practical Software Development Environments. ACM, </booktitle> <month> December </month> <year> 1990. </year>
Reference-contexts: The seminal process programming language APPL/A <ref> [20] </ref> includes linguistic features that are comparable to those in RC++. Rosenblum [16] advocates "assertions", similar to our constraints, as a debugging tool.
Reference: [21] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year> <month> 21 </month>
Reference-contexts: Programmers define relation classes; each relation class may have it own implementation, allowing it to be customized to the access and performance requirements imposed by its role in the program. RC++ provides a notation for derived relations patterned after the relational calculus <ref> [21] </ref>. This notation expresses the semantics of a derived relation, but not the algorithms required to implement access to the derived relation. Our design permits these algorithms to be generated automatically by a static (compile-time) query optimizer. <p> However, we believe that the best solution, in the absence of "open" compilers and debugging environments, is for programmers to be offered these relation metaphors by a commercial C++ development environment. 5 Related Work The most widely used relational systems are relational databases <ref> [5, 21] </ref>. These offer relations, a query language (similar to that of RC++), query optimization, triggering and constraints. These systems allow programmers some control over relation implementation, though not as much as RC++. Part of the reason is that they must provide persistence and controlled sharing of data.
References-found: 21

