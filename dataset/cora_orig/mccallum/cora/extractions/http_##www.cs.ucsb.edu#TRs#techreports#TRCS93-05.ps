URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS93-05.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Reasoning with Non-Atomic Memories  
Author: Manhoi Choy and Ambuj K. Singh 
Keyword: concurrency, program correctness, memory consistency conditions.  
Date: August 3, 1993  
Address: Santa Barbara, CA 93106  
Affiliation: Department of Computer Science University of California at Santa Barbara  
Abstract: A method for reasoning with non-atomic memory is developed. A program using non-atomic memory is transformed into an equivalent one that uses atomic memory. A number of non-atomic memories including pipelined RAM , causal memory, and hybrid consistency are examined. The approach is illustrated with some examples. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ahamad, J. E. Burns, P. W. Hutto, and G. Neiger. </author> <title> Causal memory. </title> <booktitle> In Proceedings of the Fifth International Workshop on Distributed Algorithms, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: as follows: repeat if X p 6= fg then x p ; X p := m; X p fmg where m 2 X p forever 4 3 Causal Memory This kind of non-atomic memory was defined by Ahamad, Hutto, and John [2], and later by Ahamad, Burns, Hutto, and Neiger <ref> [1] </ref>. A causality relation is maintained across read and write events. There are two components of this causality relation: the first is based on program order (this also occurs in the pipelined RAM model), and the second is based on the values read by the processes.
Reference: [2] <author> M. Ahamad, P. W. Hutto, and R. John. </author> <title> Implementing and programming causal distributed shared memory. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 274-281, </pages> <year> 1991. </year>
Reference-contexts: The specific abstractions of non-atomic memory that we examine include pipelined RAM [12], causal memory <ref> [2] </ref>, T SO and P SO memory models of Sparc [9], and hybrid consistency [5]. In each of these cases, suitable auxiliary variables are defined in the process of transformation. These auxiliary variables may be viewed as an abstract implementation of the corresponding kind of memory. <p> Process M p;x is as follows: repeat if X p 6= fg then x p ; X p := m; X p fmg where m 2 X p forever 4 3 Causal Memory This kind of non-atomic memory was defined by Ahamad, Hutto, and John <ref> [2] </ref>, and later by Ahamad, Burns, Hutto, and Neiger [1]. A causality relation is maintained across read and write events. <p> The rules of translation for process p are as follows. 1. A read statement v := x is translated to the read of any pair (m; ts) in X w that is live <ref> [2] </ref>, i.e, a value which has not been overwritten and for which no later read has returned a different value.
Reference: [3] <author> J. H. Anderson and M. G. Gouda. </author> <title> Atomic semantics of nonatomic programs. </title> <journal> Information Processing Letters, </journal> <volume> 28(2) </volume> <pages> 99-103, </pages> <year> 1988. </year>
Reference-contexts: This approach of transforming a program that uses non-atomic variables into one that uses atomic variables was used earlier by Anderson and Gouda <ref> [3] </ref> to prove the correctness of programs that use safe and regular variables [11]. The specific abstractions of non-atomic memory that we examine include pipelined RAM [12], causal memory [2], T SO and P SO memory models of Sparc [9], and hybrid consistency [5].
Reference: [4] <author> T. E. Anderson. </author> <title> The performance of spin-lock alternatives for shared-memory multiprocessors. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 6-16, </pages> <year> 1990. </year>
Reference-contexts: In order to acquire a lock, a process reads lock until it is 1 and then executes a swap instruction. If successful, the process enters the critical section. Otherwise, the sequence of steps is repeated. (This is the so called test-and-test-and-set implementation of spin locks <ref> [4] </ref>.) To release a lock, a process simply sets lock to 1. initially lock = 1.
Reference: [5] <author> H. Attiya and R. Friedman. </author> <title> A correctness condition for high performance multiprocessors. </title> <booktitle> In Proceedings of the 24th Annual ACM Symposium on the the Theory of Computing, </booktitle> <pages> pages 679-690, </pages> <year> 1992. </year>
Reference-contexts: The specific abstractions of non-atomic memory that we examine include pipelined RAM [12], causal memory [2], T SO and P SO memory models of Sparc [9], and hybrid consistency <ref> [5] </ref>. In each of these cases, suitable auxiliary variables are defined in the process of transformation. These auxiliary variables may be viewed as an abstract implementation of the corresponding kind of memory. The rest of the paper is organized as follows. <p> The particular choice of strong and weak consistency gives rise to different kinds of hybrid consistency. For example, in a definition due to Attiya and Friedman <ref> [5] </ref>, sequential consistency [10] is adopted as the strong consistency condition and a weaker requirement in which program orderings need not be preserved is adopted as the weak consistency requirement.
Reference: [6] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley, </publisher> <address> Reading, Mass., </address> <year> 1988. </year>
Reference-contexts: The transformed program can then be proved using any of the existing proof systems such as Temporal logic [15] and Unity <ref> [6] </ref>. Besides providing a technique for reasoning about non-atomic memory, the approach also provides a clear uniform semantics for the non-atomic memories. Traditional approaches toward defining non-atomic memories are based on histories. Systemwide execution histories are considered and those that satisfy the specification are isolated by considering interleavings of events.
Reference: [7] <author> K. Gharachorloo, D. Lenoski, J. Laudon, P. Gibbons, A. Gupta, and J. Hennessy. </author> <title> Memory consistency and event ordering in scalable shared-memory multiprocessors. </title> <booktitle> In Proceedings of the 17th International Symposium on Computer Architecture, </booktitle> <pages> pages 15-26, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: In a related work, Gibbons and Merritt [8] outline a framework for specifying non-blocking shared memories based on I/O automata [13] and use it to specify release consistency <ref> [7] </ref>. In the future, we intend to develop specifications for other existing consistency conditions as well as investigate semantic constraints under which atomic memory may be replaced by non-atomic memory in a program without affecting the final state of the computation.
Reference: [8] <author> P. B. Gibbons and M. Merritt. </author> <title> Specifying nonblocking shared memories. </title> <booktitle> In Proceedings of the Fourth Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <year> 1992. </year>
Reference-contexts: Our approach is useful for the understanding and comparison of non-atomic memories and for the verification of parallel algorithms that use these memories. In a related work, Gibbons and Merritt <ref> [8] </ref> outline a framework for specifying non-blocking shared memories based on I/O automata [13] and use it to specify release consistency [7].
Reference: [9] <author> Sparc International Inc. </author> <title> The SPARC Architecture Manual. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1992. </year>
Reference-contexts: The specific abstractions of non-atomic memory that we examine include pipelined RAM [12], causal memory [2], T SO and P SO memory models of Sparc <ref> [9] </ref>, and hybrid consistency [5]. In each of these cases, suitable auxiliary variables are defined in the process of transformation. These auxiliary variables may be viewed as an abstract implementation of the corresponding kind of memory. The rest of the paper is organized as follows. <p> where live (m; ts; y; r) od; w; ts r ; X r := m; nx r (max (ts; ts r )); X r [ f (m; max (ts; ts r ))g where live (m; ts; x; r) 6 4 Sparc Memory Model The Sparc Memory Model as defined in <ref> [9] </ref> contains two abstractions of shared memory - T SO (Total Store Ordering) and a weaker variant called P SO (Partial Store Ordering). As in the Pipelined RAM model, every process has its own memory.
Reference: [10] <author> L. Lamport. </author> <title> How to make a multiprocessor computer that correctly executes multiprocess programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 28(9) </volume> <pages> 690-691, </pages> <month> Sept. </month> <year> 1979. </year>
Reference-contexts: The particular choice of strong and weak consistency gives rise to different kinds of hybrid consistency. For example, in a definition due to Attiya and Friedman [5], sequential consistency <ref> [10] </ref> is adopted as the strong consistency condition and a weaker requirement in which program orderings need not be preserved is adopted as the weak consistency requirement.
Reference: [11] <author> L. Lamport. </author> <title> On interprocess communication, parts I and II. </title> <journal> Distributed Computing, </journal> <volume> 1(2) </volume> <pages> 77-101, </pages> <year> 1986. </year>
Reference-contexts: This approach of transforming a program that uses non-atomic variables into one that uses atomic variables was used earlier by Anderson and Gouda [3] to prove the correctness of programs that use safe and regular variables <ref> [11] </ref>. The specific abstractions of non-atomic memory that we examine include pipelined RAM [12], causal memory [2], T SO and P SO memory models of Sparc [9], and hybrid consistency [5]. In each of these cases, suitable auxiliary variables are defined in the process of transformation.
Reference: [12] <author> R. Lipton and J. Sandberg. </author> <title> PRAM: a scalable shared memory. </title> <type> Technical Report CS-TR-180--88, </type> <institution> Princeton University, </institution> <year> 1988. </year>
Reference-contexts: This approach of transforming a program that uses non-atomic variables into one that uses atomic variables was used earlier by Anderson and Gouda [3] to prove the correctness of programs that use safe and regular variables [11]. The specific abstractions of non-atomic memory that we examine include pipelined RAM <ref> [12] </ref>, causal memory [2], T SO and P SO memory models of Sparc [9], and hybrid consistency [5]. In each of these cases, suitable auxiliary variables are defined in the process of transformation. These auxiliary variables may be viewed as an abstract implementation of the corresponding kind of memory. <p> In each case, rules for transforming each non-atomic read and write are included. In some cases, the transformations are also illustrated with small examples. Section 7 includes a brief discussion. 2 Pipelined RAM In this kind of non-atomic memory introduced by Lipton and Sandberg <ref> [12] </ref>, every process has its own copy of the shared memory. A read operation is performed by reading this local copy and a write operation is performed by updating the local copy and sending the update to all other processes on FIFO channels.
Reference: [13] <author> N. A. Lynch and M. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <booktitle> In Proceedings of the Sixth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 137-151, </pages> <year> 1987. </year>
Reference-contexts: Our approach is useful for the understanding and comparison of non-atomic memories and for the verification of parallel algorithms that use these memories. In a related work, Gibbons and Merritt [8] outline a framework for specifying non-blocking shared memories based on I/O automata <ref> [13] </ref> and use it to specify release consistency [7]. In the future, we intend to develop specifications for other existing consistency conditions as well as investigate semantic constraints under which atomic memory may be replaced by non-atomic memory in a program without affecting the final state of the computation.
Reference: [14] <author> Z. Manna and A. Pnueli. </author> <title> How to cook a temporal proof system for your pet language. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 141-154, </pages> <year> 1983. </year>
Reference-contexts: This new program can be proved using existing logics and proof methods. Though the level of fairness for pipelined RAM has not been discussed explicitly in the literature, for our purposes we assume weak fairness (or justice <ref> [14] </ref>) with respect to each process in the transformed program.
Reference: [15] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proceedings of the 18th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year> <month> 13 </month>
Reference-contexts: The transformed program can then be proved using any of the existing proof systems such as Temporal logic <ref> [15] </ref> and Unity [6]. Besides providing a technique for reasoning about non-atomic memory, the approach also provides a clear uniform semantics for the non-atomic memories. Traditional approaches toward defining non-atomic memories are based on histories.
References-found: 15

