URL: file://ftp.cs.wisc.edu/coral/doc/ngopt.ps
Refering-URL: http://www.cs.wisc.edu/coral/coral.papers.html
Root-URL: 
Email: sudarsha@research.att.com  raghu@cs.wisc.edu  
Title: Optimizations of Bottom-Up Eval- uation with Non-Ground Terms (Extended Abstract)  
Author: S. Sudarshan Raghu Ramakrishnan 
Address: 600 Mountain Ave, Murray Hill, NJ 07974, U.S.A.  Madison, WI 53706, U.S.A.  
Affiliation: AT&T Bell Labs,  Computer Sciences Department, Univ. of Wisconsin,  
Abstract: Memoization, such as that performed by bottom-up evaluation, helps detect loops, avoid repeated computation when subgoals are generated repeatedly, and in conjunction with a fair search strategy, ensures that evaluation is complete. Programs that generate non-ground facts (i.e., facts containing universally quantified variables) and also need memoization are important in several contexts. Current bottom-up evaluation techniques (and other memoization techniques), are very inefficient for programs that generate facts containing large non-ground terms. We present an efficient bottom-up evaluation technique for programs that generate non-ground facts. We show that bottom-up evaluation can be implemented with a time cost that is within a log log factor of (a model of) Prolog evaluation, for all queries on definite clause programs; conversely, there are programs where bottom-up evaluation is arbitrarily better than Prolog. These results significantly extend earlier results comparing bottom-up evaluation and top-down evaluation, An implementation of our technique enables us to run some programs faster (asymptotically and practically) than using either Prolog or unoptimized bottom-up evaluation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> An amateur's introduction to recursive query processing strategies. </title> <booktitle> In Procs. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 16-52, </pages> <month> May </month> <year> 1986. </year>
Reference-contexts: In Section 5 we discuss how to tackle the above problem in the case where facts may be non-ground. 2 2 Basics We assume some familiarity with bottom-up evaluation, and refer the reader to <ref> [1] </ref> for a survey of the area. We also assume some familiarity with Semi-Naive evaluation and Supplementary Magic Templates rewriting [2, 9]. To make our discussion and analysis simpler, we assume that all non-equality literals in rules of the program have as arguments only distinct free variables.
Reference: [2] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of Magic. </title> <booktitle> In Procs. of the ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <month> Mar. </month> <year> 1987. </year> <title> 9 Some of these techniques modify Magic rewriting in minor ways. Corresponding changes may need to be made in our optimization technique. </title>
Reference-contexts: Meta-interpreters, partial evaluators, abstract interpreters and other such programs often operate on data structures that contain variables. Memoing of subgoals and their answers is very important for some of these programs [23]. Bottom-up (i.e., forward chaining) evaluation using (variants of) Magic rewriting <ref> [2, 9] </ref> is a way of implementing memoization. <p> We also assume some familiarity with Semi-Naive evaluation and Supplementary Magic Templates rewriting <ref> [2, 9] </ref>. To make our discussion and analysis simpler, we assume that all non-equality literals in rules of the program have as arguments only distinct free variables. <p> The second rule defines what query is generated on r (the second literal in the rule body) given a query on p and an answer fact for q. Supplementary Magic Templates <ref> [2, 9] </ref> can be viewed as a way of eliminating the common subexpressions in the above rules. <p> Return Unify need only replace the supplementary fact bindenv by the answer fact bindenv to carry out unification. However, we show a more general version that works even when the adornment optimization of Magic rewriting <ref> [2] </ref> has been used. Procedure Return Unify (R; s; a; hR 0 ; r env 0 i) /* R is a rule, s is a supplementary fact, and a an answer fact.*/ 1. If s:cont id 6= a:par id Then return failure. 2.
Reference: [3] <author> F. Bry. </author> <title> Query evaluation in recursive databases: Bottom-up and top-down reconciled. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5 </volume> <pages> 289-312, </pages> <year> 1990. </year>
Reference-contexts: We present one such program in Example 7.2. For such programs Opt-NGBU combines the best features of Prolog evaluation and bottom-up evaluation. The question of how bottom-up and top-down methods compare is considered important, and has been under investigation by several researchers <ref> [20, 3, 9, 16] </ref>.
Reference: [4] <author> S. W. Dietrich. </author> <title> Extension tables: Memo relations in logic programming. </title> <booktitle> In Procs. of the Symposium on Logic Programming, </booktitle> <pages> pages 264-272, </pages> <year> 1987. </year>
Reference-contexts: if a given program generates only ground answers (to all subgoals), it may generate non-ground subgoals; correspondingly, non-ground query facts would be generated if either Magic Templates or MTTR rewriting is used. 1 The problems described above (or equivalent ones) also occur with other memoization techniques such as Extension Tables <ref> [4] </ref>, or OLDT resolution [19]. In this extended abstract we present an efficient bottom-up query evaluation mechanism, Opt-NGBU query evaluation, for programs that generate non-ground facts. <p> Persistent versioning can be used with Extension Tables <ref> [4] </ref>, or OLDT resolution [19]. Our optimization of answer-return unification is not useful in the context of Extension Tables. However, with Extension Tables variables in rules would have to be versioned.
Reference: [5] <author> P. F. Dietz. </author> <title> Fully persistent arrays. </title> <booktitle> In Workshop on Algorithms and Data Structures, </booktitle> <pages> pages 67-74, </pages> <year> 1989. </year> <note> (Appeared as LNCS 382). </note>
Reference-contexts: During evaluation, the same fact may be generated with different representations. We call each such representation of a fact an occurrence of the fact. Binding environments are implemented using "fully persistent versions of data structures" <ref> [6, 5] </ref>. When applied to bindenvs represented as arrays, a fully persistent versioning scheme permits us to carry out the following operations efficiently: 1. Create a new child version of an existing bindenv (which itself may have been created as a child version of another bindenv, and so on). <p> be done in constant time, and operations (2) and (3) can be done in time O (min (log log m; log n)), where m is the total number of versions of bindenvs that have been created and n is the number of versions of the variable that have been modified <ref> [5] </ref>. For brevity, we use the notation V (defined below). Definition 4.1 (V) Consider an evaluation of a program. Let fV 1 ; V 2 ; : : :g be the variables used in the evaluation.
Reference: [6] <author> J. R. Driscoll, N. Sarnak, D. Sleator, and R. E. Tarjan. </author> <title> Making data structures persistent. </title> <booktitle> In Eighteenth Annual ACM Symp. on Theory of Computing, </booktitle> <year> 1986. </year>
Reference-contexts: During evaluation, the same fact may be generated with different representations. We call each such representation of a fact an occurrence of the fact. Binding environments are implemented using "fully persistent versions of data structures" <ref> [6, 5] </ref>. When applied to bindenvs represented as arrays, a fully persistent versioning scheme permits us to carry out the following operations efficiently: 1. Create a new child version of an existing bindenv (which itself may have been created as a child version of another bindenv, and so on).
Reference: [7] <author> R. A. O'Keefe. </author> <title> The Craft of Prolog. </title> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: However, even without subsumption-checking, Opt-NGBU evaluation is complete for definite clause programs, while avoiding the repeated computation in iterative deepening (a technique used to make Prolog evaluation complete; see, e.g. <ref> [7] </ref>). Our evaluation optimizations have been implemented in the CORAL deductive database system, and we present performance numbers that show the benefits of our optimizations. <p> Our optimizations enable the use of Magic Templates with Right Recursion [14], which creates programs that generate non-ground facts (Section 7). 1.1 A Motivating Example We now consider an example that illustrates the main issues involved in our optimization techniques. Example 1.1 A difference list (see e.g. <ref> [7] </ref>) is a non-ground data-structure that permits the append operation to be done in constant time in Prolog. 2 An example of a difference list is dlist ([1; 2; 3jX]; X) (the second occurrence of the variable X (logically) gives constant time access to the end of the list).
Reference: [8] <author> F. Pereira. </author> <title> A structure-sharing representation for unification-based grammar formalisms. </title> <booktitle> In Procs. of the 23rd Annual Meeting of the Association for Computational Linguistics, </booktitle> <pages> pages 137-143, </pages> <year> 1985. </year>
Reference-contexts: Then V denotes max i (min (log log m; log n i )). 2 We have implemented a simpler scheme due to D.H.D. Warren ([22], cited in <ref> [8] </ref>) which has an access cost of log n (where n is the number of variables in the bindenv) in the CORAL deductive database system [11]. <p> Section 6 discussed how our results subsumes the earlier ones. Pereira <ref> [8] </ref> describes an implemen-tation of parsers for unification based grammar formalisms, using "virtual copy memory" (i.e., versioned memory). There seems to be no equivalent to answer-return unification in the context of [8]. <p> Section 6 discussed how our results subsumes the earlier ones. Pereira <ref> [8] </ref> describes an implemen-tation of parsers for unification based grammar formalisms, using "virtual copy memory" (i.e., versioned memory). There seems to be no equivalent to answer-return unification in the context of [8]. The optimizations described in this paper work at the level of rule application, and are essentially independent of the control strategy used during evaluation such as those described in [10, 18]). 9 They can be applied to other memoing evaluation schemes such as QSQR [21] and Alexander [13, 16].
Reference: [9] <author> R. Ramakrishnan. </author> <title> Magic Templates: A spellbinding approach to logic programs. </title> <booktitle> In Procs. of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Meta-interpreters, partial evaluators, abstract interpreters and other such programs often operate on data structures that contain variables. Memoing of subgoals and their answers is very important for some of these programs [23]. Bottom-up (i.e., forward chaining) evaluation using (variants of) Magic rewriting <ref> [2, 9] </ref> is a way of implementing memoization. <p> Given a query, it enumerates all answers, but computes facts irrelevant to the query. The Magic Templates transformation <ref> [9] </ref> rewrites the rules in the program by adding `filters' corresponding to subqueries, and adds rules to the program that specify how (further) subqueries are generated from a given (sub) query; only facts `relevant' to the query are generated by the rewritten program. <p> We also assume some familiarity with Semi-Naive evaluation and Supplementary Magic Templates rewriting <ref> [2, 9] </ref>. To make our discussion and analysis simpler, we assume that all non-equality literals in rules of the program have as arguments only distinct free variables. <p> The second rule defines what query is generated on r (the second literal in the rule body) given a query on p and an answer fact for q. Supplementary Magic Templates <ref> [2, 9] </ref> can be viewed as a way of eliminating the common subexpressions in the above rules. <p> We present one such program in Example 7.2. For such programs Opt-NGBU combines the best features of Prolog evaluation and bottom-up evaluation. The question of how bottom-up and top-down methods compare is considered important, and has been under investigation by several researchers <ref> [20, 3, 9, 16] </ref>.
Reference: [10] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> Controlling the search in bottom-up evaluation. </title> <booktitle> In Joint Int'l Conf. and Symp. on Logic Programming, </booktitle> <year> 1992. </year>
Reference-contexts: There seems to be no equivalent to answer-return unification in the context of [8]. The optimizations described in this paper work at the level of rule application, and are essentially independent of the control strategy used during evaluation such as those described in <ref> [10, 18] </ref>). 9 They can be applied to other memoing evaluation schemes such as QSQR [21] and Alexander [13, 16]. Persistent versioning can be used with Extension Tables [4], or OLDT resolution [19]. Our optimization of answer-return unification is not useful in the context of Extension Tables.
Reference: [11] <author> R. Ramakrishnan, D. Srivastava, and S. Sudarshan. </author> <title> CORAL: Control, Relations and Logic. </title> <booktitle> In Procs. of the Int'l Conf. on Very Large Databases, </booktitle> <year> 1992. </year>
Reference-contexts: Warren ([22], cited in [8]) which has an access cost of log n (where n is the number of variables in the bindenv) in the CORAL deductive database system <ref> [11] </ref>. <p> In the case of range-restricted programs, where no non-ground facts are generated, bindenvs need not be stored explicitly, and V reduces to O (1). We have implemented our optimization techniques (except for MGU MTTR rewriting) on the CORAL deductive database system <ref> [11] </ref>, and we present some preliminary performance figures. Example 7.1 Consider the well-known program to append lists, with a query involving non-ground lists. The following table presents the relative time costs of three evaluation techniques, on lists of the specified lengths.
Reference: [12] <author> R. Ramakrishnan and S. Sudarshan. </author> <title> Top-Down vs. Bottom-Up Revisited. </title> <booktitle> In Procs. of the International Logic Programming Symposium, </booktitle> <year> 1991. </year>
Reference-contexts: Memoing of subgoals and their answers is very important for some of these programs [23]. Bottom-up (i.e., forward chaining) evaluation using (variants of) Magic rewriting [2, 9] is a way of implementing memoization. It is shown in <ref> [12] </ref> that in the absence of non-ground facts, bottom-up evaluation using a variant of Magic Templates rewriting (MTTR rewriting) [14] is as fast as Prolog up to a data-independent constant factor (assuming that all answers have to be generated, and intelligent backtracking optimization is not used). <p> In the case of ground facts, there are effective term representation techniques that can reduce the cost of the extra unifications to O (1) (see <ref> [12] </ref>). In Section 5 we discuss how to tackle the above problem in the case where facts may be non-ground. 2 2 Basics We assume some familiarity with bottom-up evaluation, and refer the reader to [1] for a survey of the area.
Reference: [13] <author> J. Rohmer, R. Lescoeur, and J. M. Kerisit. </author> <title> The Alexander method | a technique for the processing of recursive axioms in deductive database queries. </title> <journal> New Generation Computing, </journal> <volume> 4 </volume> <pages> 522-528, </pages> <year> 1986. </year>
Reference-contexts: The optimizations described in this paper work at the level of rule application, and are essentially independent of the control strategy used during evaluation such as those described in [10, 18]). 9 They can be applied to other memoing evaluation schemes such as QSQR [21] and Alexander <ref> [13, 16] </ref>. Persistent versioning can be used with Extension Tables [4], or OLDT resolution [19]. Our optimization of answer-return unification is not useful in the context of Extension Tables. However, with Extension Tables variables in rules would have to be versioned.
Reference: [14] <author> K. Ross. </author> <title> Modular acyclicity and tail recursion in logic programs. </title> <booktitle> In Procs. of the ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991. </year>
Reference-contexts: Bottom-up (i.e., forward chaining) evaluation using (variants of) Magic rewriting [2, 9] is a way of implementing memoization. It is shown in [12] that in the absence of non-ground facts, bottom-up evaluation using a variant of Magic Templates rewriting (MTTR rewriting) <ref> [14] </ref> is as fast as Prolog up to a data-independent constant factor (assuming that all answers have to be generated, and intelligent backtracking optimization is not used). However, the above result does not apply to programs that generate non-ground facts. <p> Our evaluation optimizations have been implemented in the CORAL deductive database system, and we present performance numbers that show the benefits of our optimizations. Our optimizations enable the use of Magic Templates with Right Recursion <ref> [14] </ref>, which creates programs that generate non-ground facts (Section 7). 1.1 A Motivating Example We now consider an example that illustrates the main issues involved in our optimization techniques. <p> We use a term-representation based on `persistent-versioning' to greatly reduce the cost of copying (Section 4). The second cause for inefficiency is less obvious, and is present with Magic Templates rewriting as well as with its variants (MTTR rewriting <ref> [14] </ref>, and Alexander Templates [16]). The unifications in the first two derivations in the evaluation shown above have corresponding unifications in a Prolog evaluation. <p> MGU Magic rewriting generates programs where each rule has at most two literals in the body. MGU MTTR rewriting extends the Magic Templates with Right Recursion rewriting of Ross <ref> [14] </ref>, in exactly the same fashion as MGU Magic rewriting extends Supplementary Magic Templates rewriting. Details may be found in [17]. Example 3.2 We now show (a high level view of) the bottom-up evaluation of the rewritten program generated in Example 3.1 from our running example.
Reference: [15] <author> M. Sassa and E. Goto. </author> <title> A hashing method for fast set operations. </title> <journal> Information Processing Letters, </journal> <volume> 5(4) </volume> <pages> 31-34, </pages> <month> June </month> <year> 1976. </year>
Reference-contexts: Hence answer-return unification can always be done efficiently. In the general case, subsumption-checking is a costly operation, and we are not aware of efficient subsumption-checking techniques for the case of arbitrary non-ground facts. For ground facts, subsumption is the same as equality, and hash-consing <ref> [15] </ref> can be used to perform equality checking in constant time in many cases. Approximate forms of subsumption checking can often be done efficiently, and often suffice in practise. Checking for subsumption avoids recomputation, and can prevent the computation from entering into an infinite loop.
Reference: [16] <author> H. Seki. </author> <title> On the power of Alexander templates. </title> <booktitle> In Procs. of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 150-159, </pages> <year> 1989. </year>
Reference-contexts: We use a term-representation based on `persistent-versioning' to greatly reduce the cost of copying (Section 4). The second cause for inefficiency is less obvious, and is present with Magic Templates rewriting as well as with its variants (MTTR rewriting [14], and Alexander Templates <ref> [16] </ref>). The unifications in the first two derivations in the evaluation shown above have corresponding unifications in a Prolog evaluation. <p> We present one such program in Example 7.2. For such programs Opt-NGBU combines the best features of Prolog evaluation and bottom-up evaluation. The question of how bottom-up and top-down methods compare is considered important, and has been under investigation by several researchers <ref> [20, 3, 9, 16] </ref>. <p> The optimizations described in this paper work at the level of rule application, and are essentially independent of the control strategy used during evaluation such as those described in [10, 18]). 9 They can be applied to other memoing evaluation schemes such as QSQR [21] and Alexander <ref> [13, 16] </ref>. Persistent versioning can be used with Extension Tables [4], or OLDT resolution [19]. Our optimization of answer-return unification is not useful in the context of Extension Tables. However, with Extension Tables variables in rules would have to be versioned.
Reference: [17] <author> S. Sudarshan. </author> <title> Optimizing Bottom-Up Evaluation for Deductive Databases. </title> <type> PhD thesis, </type> <institution> University of Wisconsin, Madison, </institution> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: any increase in the time complexity of either Prolog evaluation or bottom-up evaluation. 3 We assume that equality is a base predicate with a single fact "= (X; X)". 3 MGU Magic and MGU MTTR Rewriting A full description of MGU Magic and MGU MTTR rewriting may be found in <ref> [17] </ref>, but we provide an intuitive description here. We described the intuition behind Magic Templates rewriting in Example 1.1. <p> A goal-identifier is an integer identifier that uniquely identifies a subgoal. The goal-identifiers help avoid certain unnecessary inferences made using subsumed facts (that, in particular, are not made by Prolog evaluation) (see <ref> [17] </ref>), and they provide an efficient mechanism for indexing facts similar to that used in QSQR [21]. Goal-identifiers are generated using a `meta-predicate' goal id (goal; id). If goal id is used with subsumption checking, subgoals are mapped one-to-one to identifiers (modulo renaming) by calls on goal id (goal; id). <p> MGU Magic rewriting generates programs where each rule has at most two literals in the body. MGU MTTR rewriting extends the Magic Templates with Right Recursion rewriting of Ross [14], in exactly the same fashion as MGU Magic rewriting extends Supplementary Magic Templates rewriting. Details may be found in <ref> [17] </ref>. Example 3.2 We now show (a high level view of) the bottom-up evaluation of the rewritten program generated in Example 3.1 from our running example. <p> Procedure Apply Rule is shown below. It essentially performs a left to right nested loops join. 5 Note that due to our rewriting, rules have either one or two body literals. We describe informally some of the procedures that it uses; details are presented in <ref> [17] </ref>. An important point to note in Apply Rule is the creation of versions of bindenvs to ensure that unification operations do not affect any stored facts. Procedure ApplyRule ( R ). <p> Bind each variable in the answer literal of hR 0 ; r env 0 i to the corresponding argument of a:structure. 7 6. Update Context Ids ( R 0 ; r env 0 ; s). 7. Return success. end Return Unify We show <ref> [17] </ref> that the unifier computed by Return Unify is a most general unifier of the supplementary and answer facts with the rule body. <p> Occur checks are not necessary for soundness in Return Unify, since the rule literals have distinct variables that are not present in the facts. It is straightforward to show that Return Unify runs in O (V) time. Further, we show (in <ref> [17] </ref>) that in the absence of subsumption checking, every call to Return Unify succeeds. Hence answer-return unification can always be done efficiently. In the general case, subsumption-checking is a costly operation, and we are not aware of efficient subsumption-checking techniques for the case of arbitrary non-ground facts. <p> The model is quite straightforward, and corresponds closely to the intuitive `procedural' model of Prolog evaluation, augmented with last-call optimization. We call the model of evaluation as Prolog fl evaluation, The detailed model may be found in <ref> [17] </ref>. We make the following simplifying assumption: Given term occurrences a, a1 and b, if a a1, (i.e., they represent the same term) then the time taken to unify a and b is the same as the time taken to unify a1 and b. <p> of Q is t units of time. 8 Opt-NGBU evaluation without subsumption-checking evaluates the query on the given database in time O (t log log t). (The size of the program is not taken into account in this time complexity measure.) 2 The proof of this theorem is presented in <ref> [17] </ref>, where we also discuss how we can relax the assumption that the size of the program is a constant. <p> Since subgoals for this program are ground, subsumption checking can be performed efficiently. For lack of space, we omit details of the program | details may be found in <ref> [17] </ref>. Both variants of the program used the query ?shortest path (X; Y ). The first used a difference list representation, and the second used an ordinary list representation, but used cons rather than append.
Reference: [18] <author> S. Sudarshan and R. Ramakrishnan. </author> <title> Aggregation and relevance in deductive databases. </title> <booktitle> In Procs. of the Int'l Conf. on Very Large Databases, </booktitle> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: For non-ground lists, the cost of optimized evaluation grows linearly with the size of the lists, while for evaluation without our optimizations the cost grows roughly quadratically. 2 Example 7.2 We ran two variants of a shortest path program <ref> [18] </ref> on the CORAL system. Prolog evaluation is inapplicable since it loops if there are cyclic paths. The shortest path program is best evaluated bottom-up (see [18]), and subsumption checking on subgoals is, in general, necessary for termination. <p> lists, while for evaluation without our optimizations the cost grows roughly quadratically. 2 Example 7.2 We ran two variants of a shortest path program <ref> [18] </ref> on the CORAL system. Prolog evaluation is inapplicable since it loops if there are cyclic paths. The shortest path program is best evaluated bottom-up (see [18]), and subsumption checking on subgoals is, in general, necessary for termination. Since subgoals for this program are ground, subsumption checking can be performed efficiently. For lack of space, we omit details of the program | details may be found in [17]. <p> There seems to be no equivalent to answer-return unification in the context of [8]. The optimizations described in this paper work at the level of rule application, and are essentially independent of the control strategy used during evaluation such as those described in <ref> [10, 18] </ref>). 9 They can be applied to other memoing evaluation schemes such as QSQR [21] and Alexander [13, 16]. Persistent versioning can be used with Extension Tables [4], or OLDT resolution [19]. Our optimization of answer-return unification is not useful in the context of Extension Tables.
Reference: [19] <author> H. Tamaki and T. Sato. </author> <title> OLD resolution with tabulation. </title> <booktitle> In Procs. of the Third International Conference on Logic Programming, </booktitle> <pages> pages 84-98, </pages> <year> 1986. </year> <booktitle> (Lecture Notes in Computer Science 225, </booktitle> <publisher> Springer-Verlag). </publisher>
Reference-contexts: generates only ground answers (to all subgoals), it may generate non-ground subgoals; correspondingly, non-ground query facts would be generated if either Magic Templates or MTTR rewriting is used. 1 The problems described above (or equivalent ones) also occur with other memoization techniques such as Extension Tables [4], or OLDT resolution <ref> [19] </ref>. In this extended abstract we present an efficient bottom-up query evaluation mechanism, Opt-NGBU query evaluation, for programs that generate non-ground facts. <p> Persistent versioning can be used with Extension Tables [4], or OLDT resolution <ref> [19] </ref>. Our optimization of answer-return unification is not useful in the context of Extension Tables. However, with Extension Tables variables in rules would have to be versioned.
Reference: [20] <author> J. D. Ullman. </author> <title> Bottom-up beats top-down for Datalog. </title> <booktitle> In Procs. of the Eighth ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 140-149, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: We present one such program in Example 7.2. For such programs Opt-NGBU combines the best features of Prolog evaluation and bottom-up evaluation. The question of how bottom-up and top-down methods compare is considered important, and has been under investigation by several researchers <ref> [20, 3, 9, 16] </ref>. <p> in three important ways: (a) it extends the class of programs considered from safe Datalog to full logic programs, (b) it compares bottom-up evaluation with a sophisticated model of Pro-log evaluation, which incorporates last-call optimization, and (c) it takes all time costs into account (earlier results with the exception of <ref> [20] </ref> ignored the cost of unification, and only compared the number of operations such as inferences performed).
Reference: [21] <author> L. Vieille. </author> <title> Recursive query processing: The power of logic. </title> <booktitle> Theoretical Computer Science, </booktitle> <pages> pages 1-53, </pages> <year> 1989. </year>
Reference-contexts: A goal-identifier is an integer identifier that uniquely identifies a subgoal. The goal-identifiers help avoid certain unnecessary inferences made using subsumed facts (that, in particular, are not made by Prolog evaluation) (see [17]), and they provide an efficient mechanism for indexing facts similar to that used in QSQR <ref> [21] </ref>. Goal-identifiers are generated using a `meta-predicate' goal id (goal; id). If goal id is used with subsumption checking, subgoals are mapped one-to-one to identifiers (modulo renaming) by calls on goal id (goal; id). <p> This technique is essentially the same as the one used in QSQR <ref> [21] </ref>, and provides constant time insertion, and constant time lookup per retrieved fact. Occur checks are not necessary for soundness in Return Unify, since the rule literals have distinct variables that are not present in the facts. It is straightforward to show that Return Unify runs in O (V) time. <p> The optimizations described in this paper work at the level of rule application, and are essentially independent of the control strategy used during evaluation such as those described in [10, 18]). 9 They can be applied to other memoing evaluation schemes such as QSQR <ref> [21] </ref> and Alexander [13, 16]. Persistent versioning can be used with Extension Tables [4], or OLDT resolution [19]. Our optimization of answer-return unification is not useful in the context of Extension Tables. However, with Extension Tables variables in rules would have to be versioned.
Reference: [22] <author> D. H. D. Warren. </author> <title> Logarithmic access arrays for prolog. Unpublished program, </title> <year> 1983. </year>
Reference: [23] <author> D. S. Warren. </author> <title> Memoing for logic programs. </title> <journal> Communications of the ACM, </journal> <volume> 35(3), </volume> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: Meta-interpreters, partial evaluators, abstract interpreters and other such programs often operate on data structures that contain variables. Memoing of subgoals and their answers is very important for some of these programs <ref> [23] </ref>. Bottom-up (i.e., forward chaining) evaluation using (variants of) Magic rewriting [2, 9] is a way of implementing memoization.
References-found: 23

