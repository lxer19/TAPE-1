URL: http://www.research.microsoft.com/~rfc/astlog/astlog6.ps
Refering-URL: http://www.research.microsoft.com/~rfc/astlog/
Root-URL: http://www.research.microsoft.com
Email: rfc@microsoft.com  
Title: ASTLOG: A Language for Examining Abstract Syntax Trees  
Author: Roger F. Crew 
Address: Redmond, WA 98052  
Affiliation: Microsoft Research Microsoft Corporation  
Abstract: We desired a facility for locating/analyzing syntactic artifacts in abstract syntax trees of C/C++ programs, similar to the facility grep or awk provides for locating artifacts at the lexical level. Prolog, with its implicit pattern-matching and backtracking capabilities, is a natural choice for such an application. We have developed a Prolog variant that avoids the overhead of translating the source syntactic structures into the form of a Prolog database; this is crucial to obtaining acceptable performance on large programs. An interpreter for this language has been implemented and used to find various kinds of syntactic bugs and other questionable constructs in real programs like Microsoft SQL server (450Klines) and Microsoft Word (2Mlines) in time comparable to the runtime of the actual compiler. The model in which terms are matched against an implicit current object, rather than simply proven against a database of facts, leads to a distinct "inside-out functional" programming style that is quite unlike typical Prolog, but one that is, in fact, well-suited to the examination of trees. Also, various second-order Prolog set-predicates may be implemented via manipulation of the current object, thus retaining an important feature without entailing that the database be dynamically extensible as the usual implementation does. 
Abstract-found: 1
Intro-found: 1
Reference: [AKW86] <author> A. V. Aho, B. W. Kernighan, and P. J. Weinberger. </author> <title> The AWK Programming Language. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: We first consider a couple of prior approaches. 1.1 The awk Approach One of the more popular approaches is to extend the awk <ref> [AKW86] </ref> paradigm. An awk script is a list of pairs, each being a regular-expression with an accompanying statement in a C-like imperative language. For each line in the input file, we consider each pair of the script in turn; if the regular-expression matches the line, the corresponding statement is executed.
Reference: [BCD + 88] <author> P. Borras, D. Clement, Th. Despeyroux, J. Incerpi, G. Kahn, B. Lang, and V. Pas-cual. </author> <title> Centaur: The system. </title> <booktitle> In Proceedings of the SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <address> Boston, MA, </address> <year> 1988. </year>
Reference-contexts: all of the reasonable search possibilities, and thus would prefer instead to make the pattern language more flexible and extensible, being willing to sacrifice some efficiency to do so. 1.2 The Logic Programming Approach Another common approach is to run an inference engine over a database of program syntactic structures <ref> [BCD + 88, BGV90, CMR92] </ref>. Prolog [SS86] is a convenient language for this sort of application.
Reference: [BGV90] <author> Robert A. Ballance, Susan L. Graham, and Michael L. Van De Vanter. </author> <title> The pan language-based editing system for integrated development environments. </title> <booktitle> In Proceedings of the 4th ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 77-93, </pages> <address> Irvine, CA, </address> <year> 1990. </year>
Reference-contexts: all of the reasonable search possibilities, and thus would prefer instead to make the pattern language more flexible and extensible, being willing to sacrifice some efficiency to do so. 1.2 The Logic Programming Approach Another common approach is to run an inference engine over a database of program syntactic structures <ref> [BCD + 88, BGV90, CMR92] </ref>. Prolog [SS86] is a convenient language for this sort of application. <p> The contribution here is a pattern language sufficiently powerful to provide traversal possibilites beyond what is naturally available in prior awk-like frameworks while avoiding some of the inefficiencies of importing the entire program structure into a logical inference engine. The Pan work <ref> [BGV90] </ref> stressed the need to partition code and data; this we have done in a rather straightforward way. The surprise is that the Prolog-with-an-ambient-current-object model turns out to be so well suited to analyzing treelike structures. To be sure, there are various rough edges: 1.
Reference: [CMR92] <author> Mariano Consens, Alberto Mendelzon, and Arthur Ryman. </author> <title> Visualizing and querying software structures. </title> <booktitle> In Proceedings of the Fourteenth International ACM Conference on Software Engineering, </booktitle> <pages> pages 138-156, </pages> <year> 1992. </year>
Reference-contexts: all of the reasonable search possibilities, and thus would prefer instead to make the pattern language more flexible and extensible, being willing to sacrifice some efficiency to do so. 1.2 The Logic Programming Approach Another common approach is to run an inference engine over a database of program syntactic structures <ref> [BCD + 88, BGV90, CMR92] </ref>. Prolog [SS86] is a convenient language for this sort of application.
Reference: [Dev92] <author> Premkumar T. Devanbu. </author> <title> Genoa a customizable, language-and-front-end independent code analyzer. </title> <booktitle> In Proceedings of the Fourteenth International ACM Conference on Software Engineering, </booktitle> <pages> pages 307-319. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: Still, while language-independence was not one of our priorities, given that the core language is rather language-independent anyway, one would hope for a more automatic means of adapting astlog to work with other language parsers, perhaps by adapting GENII <ref> [Dev92] </ref> or some similar tool to generate code for the basic primitive predicate operators for a fresh language. 6 Acknowledgements astlog would not have been possible without the existence of an ast library for C/C++ implemented by the members of Program Analysis group at Microsoft Research, particularly Linda O'Gara, David Gay,
Reference: [DR96] <author> Premkumar T. Devanbu and David S. Rosenblum. </author> <title> Generating testing and analysis tools with aria. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(1) </volume> <pages> 42-62, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: Our code to do so looks like mccabe (n) &lt;- query ( FN (()&lt;- somenode ( op (or (#IF,#FOR,#DO, #WHILE,#CASE, #?,#||,#&&)));) qcount (minus (n,1)) ); which might be compared with the 17-line version in Aria <ref> [DR96] </ref>. Admittedly, fairness would probably entail including the definitions of somenode and qcount as well. * Finding gaps (unused space due to alignment rules) in structure definitions; this is a matter of traversing C type structures rather than asts.
Reference: [GA96] <author> William G. Griswold and Darren C. Atkin-son. </author> <title> Fast, flexible syntactic pattern matching and processing. </title> <booktitle> In Proceedings of the IEEE Workshop on Program Comprehension. </booktitle> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: We have two objections to this approach, the first having to do with the hardwired framework that usually implicit. In some cases (e. g., tawk <ref> [GA96] </ref>), the traversal order for the ast nodes is essentially fixed; using a different order would be analogous to attempting to use plain awk to scan the lines of a text file in reverse order.
Reference: [LR95] <author> David A. Ladd and J. Christopher Ramming. </author> <title> A*: A language for implementing language processors. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(11) </volume> <pages> 894-901, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: In some cases (e. g., tawk [GA96]), the traversal order for the ast nodes is essentially fixed; using a different order would be analogous to attempting to use plain awk to scan the lines of a text file in reverse order. In a* <ref> [LR95] </ref>, while the user may define a general traversal order, only one traversal method may be defined/active at any given time, making difficult any structure comparisons between subtrees or other applications that require multiple concurrent traversals.
Reference: [McC76] <author> T. McCabe. </author> <title> A complexity measure. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 2(4) </volume> <pages> 308-320, </pages> <month> December </month> <year> 1976. </year>
Reference-contexts: e., where results are discarded); the con verse to the previous problem. * Finding all case statement fall-throughs, i. e., where the preceding statement is not a break. * Finding various patterns of irreducible control flow in functions. * Obtaining all static call-graph edges. * Computing the McCabe cyclomatic complexity <ref> [McC76] </ref> of a function. Our code to do so looks like mccabe (n) &lt;- query ( FN (()&lt;- somenode ( op (or (#IF,#FOR,#DO, #WHILE,#CASE, #?,#||,#&&)));) qcount (minus (n,1)) ); which might be compared with the 17-line version in Aria [DR96].
Reference: [SS86] <author> Leon Sterling and Ehud Shapiro. </author> <title> The Art of Prolog: Advanced Programming Techniques. MIT Press series in logic programming. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1986. </year>
Reference-contexts: Prolog <ref> [SS86] </ref> is a convenient language for this sort of application.
References-found: 10

