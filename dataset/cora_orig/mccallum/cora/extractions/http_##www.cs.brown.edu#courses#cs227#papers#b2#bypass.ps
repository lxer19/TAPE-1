URL: http://www.cs.brown.edu/courses/cs227/papers/b2/bypass.ps
Refering-URL: http://www.cs.brown.edu/courses/cs227/readinglist.html
Root-URL: http://www.cs.brown.edu/
Email: hlastnamei@db.fmi.uni-passau.de  moer@gom.informatik.rwth-aachen.de  
Title: Bypassing Joins in Disjunctive Queries  
Author: Michael Steinbrunn Klaus Peithner Guido Moerkotte Alfons Kemper 
Note: This work was supported by the German Research Council under contract DFG Ke 401/6-2.  
Address: 94030 Passau, Germany  52074 Aachen, Germany  
Affiliation: Universitat Passau Fakultat fur Mathematik und Informatik Lehrstuhl fur Dialogorientierte Systeme  RWTH Aachen Lehrstuhl fur Informatik III  
Abstract: The bypass technique, which was formerly restricted to selections only [KMPS94], is extended to join operations. Analogous to the selection case, the join operator may generate two output streams|the join result and its complement|whose subsequent operator sequence is optimized individually. By extending the bypass technique to joins, several problems have to be solved. (1) An algorithm for exhaustive generation of the search space for bypass plans has to be developed. (2) The search space for bypass plans is quite large. Hence, partial exploration strategies still resulting in sufficiently efficient plans have to be developed. (3) Since the complement of a join can be very large, those cases where the complement can be restricted to the complement of the semijoin have to be detected. We attack all three problems. Especially, we present an algorithm generating the optimal bypass plan and one algorithm producing near optimal plans exploring the search space only partially. As soon as disjunctions occur, bypassing results in savings. Since the join operator is often more expensive than the selection, the savings for bypassing joins are even higher than those for selections only. We give a quantitative assessment of these savings on the basis of some example queries. Further, we evaluate the performance of the two bypass plan generating algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [Bat86] <author> D. S. Batory. </author> <title> Extensible cost models and query optimization in GENESIS. </title> <journal> IEEE Database Engineering, </journal> <volume> 9(4), </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: Consequently, this attention has recently shifted to so-called "next-generation" database systems [FMV93]. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context, as e.g., [OS90, KM90, CD92]. Many researchers have worked on optimizer architectures that facilitate flexibility: <ref> [Bat86, GD87, BMG93, GM93] </ref> are proposals for optimizer generators; [HFLP89, BG92] described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases.
Reference: [BG92] <author> L. Becker and R. H. Guting. </author> <title> Rule-based optimization and query processing in an extensible geometric database system. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 17(2) </volume> <pages> 247-303, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Many researchers have worked on optimizer architectures that facilitate flexibility: [Bat86, GD87, BMG93, GM93] are proposals for optimizer generators; <ref> [HFLP89, BG92] </ref> described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases.
Reference: [BGW + 81] <author> P. A. Bernstein, N. Goodman, E. Wong, C. Reeve, and J. B. Rothnie. </author> <title> Query processing in a system for distributed databases (sdd-1). </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 6(4), </volume> <month> De-cember </month> <year> 1981. </year>
Reference-contexts: disjunctive normal form), thus reducing the problem to the common, purely conjunctive case: either dis-junctions are considered atomic within a single conjunction (conjunctive normal form, for instance in System R [SAC + 79]) or the predicate is subdivided into several conjunctive streams that are optimized separately (disjunctive normal form, e.g., <ref> [BGW + 81, KTY82, OS90, Mur88] </ref>). In this paper, we show that both approaches fail to exploit a vast optimization potential, because a sufficiently fine tuned adaptation to a particular query's characteristics cannot be done that way.
Reference: [BMG93] <author> J. A. Blakeley, W. J. McKenna, and G. Graefe. </author> <title> Experiences building the Open OODB Query Optimizer. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 287-295, </pages> <address> Washington, DC, USA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Consequently, this attention has recently shifted to so-called "next-generation" database systems [FMV93]. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context, as e.g., [OS90, KM90, CD92]. Many researchers have worked on optimizer architectures that facilitate flexibility: <ref> [Bat86, GD87, BMG93, GM93] </ref> are proposals for optimizer generators; [HFLP89, BG92] described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases.
Reference: [Bry89] <author> F. Bry. </author> <title> Towards an efficient evaluation of general queries: Quantifiers and disjunction processing revisited. </title> <booktitle> In Proc. of the ACM SIG-MOD Conf. on Management of Data, </booktitle> <pages> pages 193-204, </pages> <address> Portland, OR, USA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Note, that the semijoin effect can be applied for the true- and the false-output independently of each other. Because the evaluation cost depends heavily on the number of tuples processed, it is obvious that join operators ought to be replaced by semijoin operators (cf., e.g., <ref> [Bry89] </ref>) whenever possible. In Figure 1, both joins could be replaced since none of the attributes from the respective second operand were needed in later stages of the evaluation plan.
Reference: [Cat94] <author> R. G. G. Cattell. </author> <title> Object Database Standard. </title> <publisher> Morgan-Kaufmann Publ. Co., </publisher> <address> San Mateo, CA, USA, </address> <year> 1994. </year>
Reference-contexts: The purchase of a Book requires an Order, which involves a customer (a Person, too) and comprises a certain quantity. Note that even though this schema is designed for an object-oriented database system similar to the ODMG standard <ref> [Cat94] </ref>, the application of the bypassing technique described below is definitely not limited to this kind of systems, but can also be used in conventional relational and extended relational database systems without any modification. <p> Based on this schema, we might state the following query|formulated in an object-oriented extension of SQL [KM94] and resembling OQL <ref> [Cat94] </ref>| that retrieves particularly "interesting" authors and their works: select distinct w.author.name, w.author.first, w.title from w in Work, o in Order, p in Publisher where (o:book:work:author = o:customer and w = o:book:work) or (o:quantity &gt; o:book:stock and w = o:book:work) or w:author:address = p:paddress The query predicate's disjuncts have the following
Reference: [CD92] <author> S. Cluet and C. Delobel. </author> <title> A general framework for the optimization of object-oriented queries. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 383-392, </pages> <address> San Diego, USA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Since the early stages of relational database development, query optimization has received a lot of attention. Consequently, this attention has recently shifted to so-called "next-generation" database systems [FMV93]. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context, as e.g., <ref> [OS90, KM90, CD92] </ref>. Many researchers have worked on optimizer architectures that facilitate flexibility: [Bat86, GD87, BMG93, GM93] are proposals for optimizer generators; [HFLP89, BG92] described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases.
Reference: [FMV93] <author> J.-C. Freytag, D. Maier, and G. Vossen, </author> <title> editors. Query Processing for Advanced Database Systems. </title> <publisher> Morgan-Kaufmann Publ. Co., </publisher> <address> San Mateo, CA, USA, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Since the early stages of relational database development, query optimization has received a lot of attention. Consequently, this attention has recently shifted to so-called "next-generation" database systems <ref> [FMV93] </ref>. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context, as e.g., [OS90, KM90, CD92].
Reference: [Fre87] <author> J. C. Freytag. </author> <title> A rule-based view of query optimization. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 173-180, </pages> <address> San Francisco, USA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Since the early stages of relational database development, query optimization has received a lot of attention. Consequently, this attention has recently shifted to so-called "next-generation" database systems [FMV93]. <ref> [Fre87, GD87, Loh88] </ref> made rule-based query optimization popular, which was later adopted in the object-oriented context, as e.g., [OS90, KM90, CD92].
Reference: [GD87] <author> G. Graefe and D. J. DeWitt. </author> <title> The EXODUS optimizer generator. </title> <booktitle> In Proc. of the ACM SIG-MOD Conf. on Management of Data, </booktitle> <pages> pages 160-172, </pages> <address> San Francisco, USA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: 1 Introduction Since the early stages of relational database development, query optimization has received a lot of attention. Consequently, this attention has recently shifted to so-called "next-generation" database systems [FMV93]. <ref> [Fre87, GD87, Loh88] </ref> made rule-based query optimization popular, which was later adopted in the object-oriented context, as e.g., [OS90, KM90, CD92]. <p> Consequently, this attention has recently shifted to so-called "next-generation" database systems [FMV93]. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context, as e.g., [OS90, KM90, CD92]. Many researchers have worked on optimizer architectures that facilitate flexibility: <ref> [Bat86, GD87, BMG93, GM93] </ref> are proposals for optimizer generators; [HFLP89, BG92] described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases.
Reference: [GM93] <author> G. Graefe and W. J. McKenna. </author> <title> The Volcano optimizer generator: Extensibility and efficient search. </title> <booktitle> In Proc. IEEE Conf. on Data Engineering, </booktitle> <pages> pages 209-218, </pages> <address> Vienna, Austria, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: Consequently, this attention has recently shifted to so-called "next-generation" database systems [FMV93]. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context, as e.g., [OS90, KM90, CD92]. Many researchers have worked on optimizer architectures that facilitate flexibility: <ref> [Bat86, GD87, BMG93, GM93] </ref> are proposals for optimizer generators; [HFLP89, BG92] described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases.
Reference: [Hel94] <author> J. M. Hellerstein. </author> <title> Practical predicate placement. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 325-335, </pages> <address> Min-neapolis, MI, USA, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Bypass optimization used to be restricted to selections [KMPS94], but is now enhanced in order to permit join operations yielding two output streams as well. This extension requires the development of algorithms for generating bypass plans. Since Hellerstein speculates in <ref> [Hel94] </ref> that a well-working heuristic solution for placing selections in the presence of join operations might be hard to obtain (or even impossible), we propose two "building-block algorithms" which are comparable to algorithms based on dynamic programming. <p> Furthermore, particular conditions may appear in more than one Boolean factor, which makes caching indispensable if repeated evaluation of those conditions is to be avoided. That is especially true for "expensive" conditions <ref> [HS93, Hel94] </ref>. Anyway, the optimal CNF-based evaluation plan cannot possibly perform better than the optimal bypass plan, since the set of CNF-plans is a proper subset of the set of bypass plans. <p> Since it has been surmised that heuristic-based predicate placement might be hard in principle even for pure conjunctive selection predicates <ref> [Hel94] </ref>, we proposed another approach which composes the predicates of a query to an evaluation plan step by step.
Reference: [HFLP89] <author> L. M. Haas, J. C. Freytag, G. M. Lohman, and H. Pirahesh. </author> <title> Extensible query processing in starburst. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 377-388, </pages> <address> Portland, OR, USA, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Many researchers have worked on optimizer architectures that facilitate flexibility: [Bat86, GD87, BMG93, GM93] are proposals for optimizer generators; <ref> [HFLP89, BG92] </ref> described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases.
Reference: [HS93] <author> J. M. Hellerstein and M. Stonebraker. </author> <title> Predicate migration: Optimizing queries with expensive predicates. </title> <booktitle> In Proc. of the ACM SIG-MOD Conf. on Management of Data, </booktitle> <pages> pages 267-276, </pages> <address> Washington, DC, USA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Besides these works on optimizer architectures, optimization strategies for both traditional and "next-generation" database systems are being developed. [LMS94] introduces a technique for moving predicates across query components, where a component constitutes, for instance, a view definition. <ref> [HS93] </ref> deals with the optimal placement of predicates within the query graph. The authors pointed out that the ordering of the selection predicate evaluation is particularly important in the presence of expensive conditions. <p> Furthermore, particular conditions may appear in more than one Boolean factor, which makes caching indispensable if repeated evaluation of those conditions is to be avoided. That is especially true for "expensive" conditions <ref> [HS93, Hel94] </ref>. Anyway, the optimal CNF-based evaluation plan cannot possibly perform better than the optimal bypass plan, since the set of CNF-plans is a proper subset of the set of bypass plans. <p> Then, each Boolean factor is independently optimized by ordering selections [MS79], ordering joins [KBZ86], and ordering selections into join orderings <ref> [HS93] </ref>. However, the derived evaluation plans contain non-disjoint tuple streams that must be united by union operators that eliminate duplicates (unlike the special-case "merge" union operators for disjoint operands that can be employed in bypass plans).
Reference: [JK84] <author> M. Jarke and J. Koch. </author> <title> Query optimization in database systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 16(2) </volume> <pages> 111-152, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: Since these approaches are well-known <ref> [JK84] </ref> we shall only sketch them. CNF For the CNF approach, the entire selection predicate is transformed into the Conjunctive Normal Form (CNF), and each disjunct of this normal form is regarded as a Boolean factor.
Reference: [KBZ86] <author> R. Krishnamurthy, H. Boral, and C. Zan-iolo. </author> <title> Optimization of nonrecursive queries. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 128-137, </pages> <address> Kyoto, Japan, </address> <year> 1986. </year>
Reference-contexts: DNF For the DNF approach, the entire selection predicate is transformed into the Disjunctive Normal Form (DNF), and each conjunct of this normal form is regarded as a Boolean factor. Then, each Boolean factor is independently optimized by ordering selections [MS79], ordering joins <ref> [KBZ86] </ref>, and ordering selections into join orderings [HS93]. However, the derived evaluation plans contain non-disjoint tuple streams that must be united by union operators that eliminate duplicates (unlike the special-case "merge" union operators for disjoint operands that can be employed in bypass plans).
Reference: [KM90] <author> A. Kemper and G. Moerkotte. </author> <title> Advanced query processing in object bases using access support relations. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 290-301, </pages> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Since the early stages of relational database development, query optimization has received a lot of attention. Consequently, this attention has recently shifted to so-called "next-generation" database systems [FMV93]. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context, as e.g., <ref> [OS90, KM90, CD92] </ref>. Many researchers have worked on optimizer architectures that facilitate flexibility: [Bat86, GD87, BMG93, GM93] are proposals for optimizer generators; [HFLP89, BG92] described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases.
Reference: [KM94] <author> A. Kemper and G. Moerkotte. </author> <title> Object-Oriented Database Management: </title> <booktitle> Applications in Engineering and Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, USA, </address> <year> 1994. </year>
Reference-contexts: Based on this schema, we might state the following query|formulated in an object-oriented extension of SQL <ref> [KM94] </ref> and resembling OQL [Cat94]| that retrieves particularly "interesting" authors and their works: select distinct w.author.name, w.author.first, w.title from w in Work, o in Order, p in Publisher where (o:book:work:author = o:customer and w = o:book:work) or (o:quantity &gt; o:book:stock and w = o:book:work) or w:author:address = p:paddress The query predicate's
Reference: [KMP93] <author> A. Kemper, G. Moerkotte, and K. Peithner. </author> <title> A blackboard architecture for query optimization in object bases. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 543-554, </pages> <address> Dublin, Ireland, </address> <year> 1993. </year>
Reference-contexts: Many researchers have worked on optimizer architectures that facilitate flexibility: [Bat86, GD87, BMG93, GM93] are proposals for optimizer generators; [HFLP89, BG92] described extensible optimizers in the extended relational context; <ref> [MDZ93, KMP93] </ref> proposed architectural frameworks for query optimization in object bases.
Reference: [KMPS94] <author> A. Kemper, G. Moerkotte, K. Peithner, and M. Steinbrunn. </author> <title> Optimizing disjunctive queries with expensive predicates. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 336-347, </pages> <address> Minneapolis, MI, USA, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: In this technique, specialized operators are employed that yield the tuples that fulfil the operator's predicate and the tuples that do not on two different, disjoint output streams. This gives the opportunity of performing an individual, "customized" optimization for both streams. Bypass optimization used to be restricted to selections <ref> [KMPS94] </ref>, but is now enhanced in order to permit join operations yielding two output streams as well. This extension requires the development of algorithms for generating bypass plans.
Reference: [KTY82] <author> L. Kerschberg, P. D. Ting, and S. B. Yao. </author> <title> Query optimization in a star computer network. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 7(4) </volume> <pages> 678-711, </pages> <month> December </month> <year> 1982. </year>
Reference-contexts: disjunctive normal form), thus reducing the problem to the common, purely conjunctive case: either dis-junctions are considered atomic within a single conjunction (conjunctive normal form, for instance in System R [SAC + 79]) or the predicate is subdivided into several conjunctive streams that are optimized separately (disjunctive normal form, e.g., <ref> [BGW + 81, KTY82, OS90, Mur88] </ref>). In this paper, we show that both approaches fail to exploit a vast optimization potential, because a sufficiently fine tuned adaptation to a particular query's characteristics cannot be done that way.
Reference: [LMS94] <author> A. Y. Levy, I. S. Mumick, and Y. Sagiv. </author> <title> Query optimization by predicate move-around. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 96-107, </pages> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Besides these works on optimizer architectures, optimization strategies for both traditional and "next-generation" database systems are being developed. <ref> [LMS94] </ref> introduces a technique for moving predicates across query components, where a component constitutes, for instance, a view definition. [HS93] deals with the optimal placement of predicates within the query graph.
Reference: [Loh88] <author> G. M. Lohman. </author> <title> Grammar-like functional rules for representing query optimization alternatives. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 18-27, </pages> <address> Chicago, IL, USA, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Since the early stages of relational database development, query optimization has received a lot of attention. Consequently, this attention has recently shifted to so-called "next-generation" database systems [FMV93]. <ref> [Fre87, GD87, Loh88] </ref> made rule-based query optimization popular, which was later adopted in the object-oriented context, as e.g., [OS90, KM90, CD92].
Reference: [MDZ93] <author> G. Mitchell, U. Dayal, and S. B. Zdonik. </author> <title> Control of an extensible query optimizer: A planning-based approach. </title> <booktitle> In Proc. of the Conf. on Very Large Data Bases (VLDB), </booktitle> <pages> pages 517-528, </pages> <address> Dublin, Ireland, </address> <year> 1993. </year>
Reference-contexts: Many researchers have worked on optimizer architectures that facilitate flexibility: [Bat86, GD87, BMG93, GM93] are proposals for optimizer generators; [HFLP89, BG92] described extensible optimizers in the extended relational context; <ref> [MDZ93, KMP93] </ref> proposed architectural frameworks for query optimization in object bases.
Reference: [MS79] <author> C. Monma and J. Sidney. </author> <title> Sequencing with series-parallel precedence constraints. </title> <journal> Math. Oper. Res., </journal> <volume> 4 </volume> <pages> 215-224, </pages> <year> 1979. </year>
Reference-contexts: This approach yields the optimal evaluation sequence for conjunctive selection predicates <ref> [MS79] </ref>. However, it is striking that in all these works the optimization of disjunctive query predicates tends to be neglected. <p> DNF For the DNF approach, the entire selection predicate is transformed into the Disjunctive Normal Form (DNF), and each conjunct of this normal form is regarded as a Boolean factor. Then, each Boolean factor is independently optimized by ordering selections <ref> [MS79] </ref>, ordering joins [KBZ86], and ordering selections into join orderings [HS93]. However, the derived evaluation plans contain non-disjoint tuple streams that must be united by union operators that eliminate duplicates (unlike the special-case "merge" union operators for disjoint operands that can be employed in bypass plans).
Reference: [Mur88] <author> M. Muralikrishna. </author> <title> Optimization of multiple-disjunct queries in a relational database system. </title> <type> Technical Report #750, </type> <institution> University of Wisconsin-Madison, </institution> <month> February </month> <year> 1988. </year>
Reference-contexts: disjunctive normal form), thus reducing the problem to the common, purely conjunctive case: either dis-junctions are considered atomic within a single conjunction (conjunctive normal form, for instance in System R [SAC + 79]) or the predicate is subdivided into several conjunctive streams that are optimized separately (disjunctive normal form, e.g., <ref> [BGW + 81, KTY82, OS90, Mur88] </ref>). In this paper, we show that both approaches fail to exploit a vast optimization potential, because a sufficiently fine tuned adaptation to a particular query's characteristics cannot be done that way. <p> The role of the if-statement is twofold: first, the result can be presented very quickly in case at least one of the base relations is empty, and second, it ensures conformance to the SQL semantics for a query of this kind (cf. <ref> [Mur88] </ref>). For comparison purposes, the optimal evaluation plans that are based on the conjunctive normal form (CNF) and the disjunctive normal form (DNF) of the query predicate, respectively, are shown as well (Figure 2 and 3). <p> Thus, for generating an efficient query evaluation plan we can employ Mura-likrishna's idea <ref> [Mur88] </ref> of applying an if-statement; this is already reflected in Figure 1. The only remaining difference to Figure 1, the kind of join nodes employed, will be discussed in Section 3.2 below.
Reference: [OS90] <author> M. T. Ozsu and D. D. Straube. </author> <title> Queries and query processing in object-oriented database systems. </title> <journal> ACM Trans. Office Inf. Syst., </journal> <volume> 8(4) </volume> <pages> 387-430, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Since the early stages of relational database development, query optimization has received a lot of attention. Consequently, this attention has recently shifted to so-called "next-generation" database systems [FMV93]. [Fre87, GD87, Loh88] made rule-based query optimization popular, which was later adopted in the object-oriented context, as e.g., <ref> [OS90, KM90, CD92] </ref>. Many researchers have worked on optimizer architectures that facilitate flexibility: [Bat86, GD87, BMG93, GM93] are proposals for optimizer generators; [HFLP89, BG92] described extensible optimizers in the extended relational context; [MDZ93, KMP93] proposed architectural frameworks for query optimization in object bases. <p> disjunctive normal form), thus reducing the problem to the common, purely conjunctive case: either dis-junctions are considered atomic within a single conjunction (conjunctive normal form, for instance in System R [SAC + 79]) or the predicate is subdivided into several conjunctive streams that are optimized separately (disjunctive normal form, e.g., <ref> [BGW + 81, KTY82, OS90, Mur88] </ref>). In this paper, we show that both approaches fail to exploit a vast optimization potential, because a sufficiently fine tuned adaptation to a particular query's characteristics cannot be done that way.
Reference: [SAC + 79] <author> P. G. Selinger, M. M. Astrahan, D. D. Cham-berlin, R. A. Lorie, and T. G. Price. </author> <title> Access path selection in a relational database management system. </title> <booktitle> In Proc. of the ACM SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 23-34, </pages> <address> Boston, USA, </address> <month> May </month> <year> 1979. </year>
Reference-contexts: The traditional approaches transform a query predicate (i.e., either selection or join predicate) into a normal form (namely, conjunctive or disjunctive normal form), thus reducing the problem to the common, purely conjunctive case: either dis-junctions are considered atomic within a single conjunction (conjunctive normal form, for instance in System R <ref> [SAC + 79] </ref>) or the predicate is subdivided into several conjunctive streams that are optimized separately (disjunctive normal form, e.g., [BGW + 81, KTY82, OS90, Mur88]). <p> This construction method builds up the query evaluation plans step by step in a bottom up fashion. In this respect, our optimizing technique is similar to the very well-known dynamic programming approach of <ref> [SAC + 79] </ref> which orders joins starting from the entire scan-operations|as we do. A subsequent example will illustrate our approach. <p> Since it has been surmised that heuristic-based predicate placement might be hard in principle even for pure conjunctive selection predicates [Hel94], we proposed another approach which composes the predicates of a query to an evaluation plan step by step. A similar approach works well in the System R optimizer <ref> [SAC + 79] </ref> for determining a join order, and the algorithms OPT and FIX are an extension of this idea for disjunctive queries with bypass evaluation. Acknowledgements We thank Markus Lubert for implementing the algorithms OPT, FIX, CNF, and DNF and carrying out the benchmarks.
Reference: [SPMK94] <author> M. Steinbrunn, K. Peithner, G. Moerkotte, and A. Kemper. </author> <title> Bypassing joins in disjunctive queries. </title> <type> Technical Report MIP-9412, </type> <institution> Uni-versitat Passau, </institution> <address> 94030 Passau, Germany, </address> <year> 1994. </year> <note> WWW: ftp://dodgers.fmi.uni-passau.de/pub/ papers/techreports/MIP9412.ps.Z </note>
Reference-contexts: The cost model itself and a sample application (namely, for the bypass plan) is provided in <ref> [SPMK94] </ref>. The bypass evaluation plan starts on the left-hand side with the semijoin operation C address of Publisher and Work and the selection C quantity of Order on the right-hand side.
References-found: 29

