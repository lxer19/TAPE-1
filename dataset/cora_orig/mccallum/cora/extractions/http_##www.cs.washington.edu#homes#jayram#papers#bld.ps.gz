URL: http://www.cs.washington.edu/homes/jayram/papers/bld.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/jayram/
Root-URL: 
Email: jayram@cs.washington.edu  
Title: On the Limitations of Ordered Representations of Functions  
Author: Jayram S. Thathachar 
Address: Box 352350 Seattle, Washington 98195-2350  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: We demonstrate the limitations of the various ordered representations that have been considered in the literature for symbolic model checking including BDDs [3], *-BMDs [6], HDDs [13], MTBDDs [11] and EVBDDs [24] by giving a variety of simple and natural functions for which each representation requires exponential size to represent them. We introduce a lower bound technique that applies to a broad spectrum of such functional representations. Using an abstraction that encompasses all these representations, we apply our lower bound technique to show exponential size bounds for a wide range of integer and boolean functions that arise in symbolic model checking in the definition and implicit exploration of the state spaces. We give the first examples of integer functions including integer division, remainder, high/low-order words of multiplication, square root and reciprocal that require exponential size in all these representations. Finally, we show that there is a simple regular language that requires exponential size to be represented by any *-BMD, even though BDDs can represent any regular language in linear size. fl This work was supported by the National Science Foundation under Grant CCR-9303017.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Amos Beimel, Francesco Bergadano, Nader H. Bshouty, Eyal Kushilevitz, and Stefano Varricchio. </author> <title> On the applications of multiplicity automata in learning. </title> <booktitle> In 37th Annual Symposium on Foundations of Computer Science, </booktitle> <address> Burlington, Vermont, </address> <month> 14-16 October </month> <year> 1996. </year> <note> IEEE. To appear. </note>
Reference-contexts: A slightly weaker result can be inferred from standard results on multiplicity automata which have previously considered in areas such as stochastic automata [10], theory of formal series [21], and learning theory <ref> [1] </ref>. Informally, a multiplicity automaton is like a non-deterministic automaton with weights (in some field K) on transitions and states.
Reference: [2] <author> R. E. Bryant. </author> <title> Private Communication. </title>
Reference-contexts: Another issue, which arises in verifying arithmetic circuits, is that the outputs are truncated, e.g. certain multiplication circuits require that both the high-order and low-order words of the product be represented efficiently <ref> [2] </ref>. <p> In contrast, for the bit-level multiplication function f 0 representing the middle (second least significant) bit of the product, the matrix M f 0 , shown in Figure 2 (b), has rank 2 over GF <ref> [2] </ref>. We will see shortly that this rank increases exponentially for larger input sizes (for this and any other order of the variables). 4.
Reference: [3] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <month> August </month> <year> 1986. </year>
Reference-contexts: Finally, there should be efficient algorithms for testing various properties such as equivalence of representations and detecting satisfying assignments for boolean functions (more generally, finding roots of equations and inequalities involving boolean and integer functions). BDDs (Ordered Binary decision diagrams) <ref> [3] </ref> are generalizations of decision trees to directed acyclic graphs, where the queries are made in some fixed order.
Reference: [4] <author> R. E. Bryant. </author> <title> On the complexity of VLSI implementations and graph representations of boolean functions with application to integer multiplication. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(2) </volume> <pages> 205-213, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: After their importance to symbolic model checking was realized, various optimizations and heuristics [8] have resulted in enormously successful BDD-based verification packages. The main drawback of BDDs is in concisely representing some important functions, particularly integer functions such as multiplication which requires exponential size <ref> [4] </ref>. <p> Existing lower bounds for BDDs <ref> [4] </ref> or even read-once branching programs [31] do not extend to *-BMDs and HDDs. We derive our lower bounds by defining an abstraction, called the Binary Linear Diagram (BLD), that encompasses all the representations referred to above. <p> For the boolean predicates listed above, the exponential bounds on the rank are a corollary of two of the approaches used for bounding the best-partition communication complexity of boolean functions. In the approach taken in <ref> [27, 30, 4] </ref>, one constructs exponentially large fooling sets. By a theorem of [16], these results imply exponential bounds for the rank. The second approach involves directly bounding the rank, as in [20] for the graph predicates stated above, although there are fewer results that use this approach. <p> Examples of such functions are in [27], [30], <ref> [4] </ref>, [26] and [20], of which we list some below. Corollary 6: The following predicates require BLDs of exponential size: Pattern Matching: Verify if the binary pattern string of ffn bits occurs in the binary text string of (1 ff)n bits, where 0 &lt; ff &lt; 1.
Reference: [5] <author> R. E. Bryant. </author> <title> Binary decision diagrams and beyond: Enabling technologies for formal verification. </title> <booktitle> In International Conference on Computer Aided Design, </booktitle> <pages> pages 236-245, </pages> <address> Los Alamitos, Ca., USA, November 1995. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The main drawback of BDDs is in concisely representing some important functions, particularly integer functions such as multiplication which requires exponential size [4]. Therefore other extensions and alternatives, e.g [11, 28, 6, 13], have been proposed to overcome some of the limitations of BDDs (see <ref> [5] </ref> for references to the "alphabet soup" of various representation schemes). *-BMDs [6] and HDDs [13] are two notable examples that are able to efficiently represent multiplication and other integer functions.
Reference: [6] <author> R.E. Bryant and Y.-A. Chen. </author> <title> Verification of arithmetic circuits with binary moment diagrams. </title> <booktitle> In 32nd ACM/IEEE Design Automation Conference, </booktitle> <address> Pittsburgh, </address> <month> June </month> <year> 1995. </year> <institution> Carnegie Mellon University. </institution>
Reference-contexts: The main drawback of BDDs is in concisely representing some important functions, particularly integer functions such as multiplication which requires exponential size [4]. Therefore other extensions and alternatives, e.g <ref> [11, 28, 6, 13] </ref>, have been proposed to overcome some of the limitations of BDDs (see [5] for references to the "alphabet soup" of various representation schemes). *-BMDs [6] and HDDs [13] are two notable examples that are able to efficiently represent multiplication and other integer functions. <p> Therefore other extensions and alternatives, e.g [11, 28, 6, 13], have been proposed to overcome some of the limitations of BDDs (see [5] for references to the "alphabet soup" of various representation schemes). *-BMDs <ref> [6] </ref> and HDDs [13] are two notable examples that are able to efficiently represent multiplication and other integer functions. <p> division circuits [7, 14] similar to the one used in the Intel Pentium chip. *-BMDs obtain some of their power by treating the outputs of integer functions as a whole rather than splitting them into bits and have been used for verifying many arithmetic circuit designs that were previously intractable <ref> [6] </ref>. HDDs combine many of the advantages of BDDs and *-BMDs and thus have been successfully incorporated into verification packages, e.g. [33]. However, all the representations that have been considered are still far from being an efficient tool for verifying general systems. <p> As far as we know, our result for regular languages is the first that shows such a separation for some natural language class. It also validates the belief in <ref> [6] </ref> that the strengths and weaknesses of *-BMDs and BDDs are orthogonal. 3 The paper is organized as follows. In Section 2, we define the BLD representation and illustrate how it generalizes all the ordered representations.
Reference: [7] <author> R.E. Bryant and Y.-A. Chen. </author> <title> Bit-level analysis of an SRT divider circuit. </title> <booktitle> In 33rd ACM/IEEE Design Automation Conference, </booktitle> <year> 1996. </year> <month> 10 </month>
Reference-contexts: They have been used to verify and identify errors in SRT division circuits <ref> [7, 14] </ref> similar to the one used in the Intel Pentium chip. *-BMDs obtain some of their power by treating the outputs of integer functions as a whole rather than splitting them into bits and have been used for verifying many arithmetic circuit designs that were previously intractable [6].
Reference: [8] <author> J.R. Burch, E.M. Clarke, D.E. Long, K.L. MacMillan, and D.L. Dill. </author> <title> Symbolic model checking for sequential circuit verification. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, </journal> <volume> 13(4) </volume> <pages> 401-424, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Symbolic methods <ref> [9, 28, 8] </ref> have successfully combated this problem in many instances. Central to these methods is an underlying representation for various boolean and integer functions, and predicates combining such functions in arbitrary ways, in order to encode and implicitly explore state spaces. Ideally, these representations must satisfy certain important properties. <p> After their importance to symbolic model checking was realized, various optimizations and heuristics <ref> [8] </ref> have resulted in enormously successful BDD-based verification packages. The main drawback of BDDs is in concisely representing some important functions, particularly integer functions such as multiplication which requires exponential size [4].
Reference: [9] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 1-33, </pages> <address> Washington, D.C., June 1990. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Symbolic methods <ref> [9, 28, 8] </ref> have successfully combated this problem in many instances. Central to these methods is an underlying representation for various boolean and integer functions, and predicates combining such functions in arbitrary ways, in order to encode and implicitly explore state spaces. Ideally, these representations must satisfy certain important properties.
Reference: [10] <author> J. W. Carlyle and A. Paz. </author> <title> Realizations by stochastic finite automata. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 5(1) </volume> <pages> 26-40, </pages> <month> February </month> <year> 1971. </year>
Reference-contexts: in communication complexity by theoreticians. (An excellent source for results and references for this area is [23].) Our lower bound technique is analogous to previously known results in multiplicity automata theory which relate the size of a multiplicity automaton to the rank of the Hankel matrix computed by the automaton <ref> [18, 10] </ref>. Our technique provides insight into the contrast between boolean and integer representations. For example, consider the multiplication function. <p> A slightly weaker result can be inferred from standard results on multiplicity automata which have previously considered in areas such as stochastic automata <ref> [10] </ref>, theory of formal series [21], and learning theory [1]. Informally, a multiplicity automaton is like a non-deterministic automaton with weights (in some field K) on transitions and states. <p> The (x; y) th entry of F for binary strings x and y is f (x ffi y). It has been shown that the size of a minimal automaton that computes f is equal to the rank of F <ref> [10, 18] </ref>. Given any BLD P computing a function f that uses the order x p 1 ; x p 2 ; : : : ; x p n , we transform it to a multiplicity automaton N using the following procedure.
Reference: [11] <author> E. Clarke, K.L. McMillian, X. Zhao, M. Fujita, and J.C.-Y. Yang. </author> <title> Spectral transforms for large boolean functions with application to technologie mapping. </title> <booktitle> In 30th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 54-60, </pages> <address> Dallas, TX, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: The main drawback of BDDs is in concisely representing some important functions, particularly integer functions such as multiplication which requires exponential size [4]. Therefore other extensions and alternatives, e.g <ref> [11, 28, 6, 13] </ref>, have been proposed to overcome some of the limitations of BDDs (see [5] for references to the "alphabet soup" of various representation schemes). *-BMDs [6] and HDDs [13] are two notable examples that are able to efficiently represent multiplication and other integer functions.
Reference: [12] <author> E. M. Clarke and E. A. Emerson. </author> <title> Synthesis of synchronization skeletons from branching time temporal logic. </title> <booktitle> Lecture Notes Comp. Sci., </booktitle> <volume> 131 </volume> <pages> 52-71, </pages> <year> 1982. </year>
Reference-contexts: 1. Introduction Model checking, proposed in <ref> [12] </ref>, is a verification technique for determining whether a given property expressed as a temporal logic formula is satisfied by a system specification (see [15] for references and a summary of the successes of this technique.) One of the major bottlenecks of model checking is the state explosion problem, i.e. the
Reference: [13] <author> E. M. Clarke, M. Fujita, and X. Zhao. </author> <title> Hybrid decision diagrams | overcoming limitations of MTBDDs and BMDs. </title> <booktitle> In International Conference on Computer Aided Design, </booktitle> <pages> pages 159-163, </pages> <address> Los Alamitos, Ca., USA, November 1995. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The main drawback of BDDs is in concisely representing some important functions, particularly integer functions such as multiplication which requires exponential size [4]. Therefore other extensions and alternatives, e.g <ref> [11, 28, 6, 13] </ref>, have been proposed to overcome some of the limitations of BDDs (see [5] for references to the "alphabet soup" of various representation schemes). *-BMDs [6] and HDDs [13] are two notable examples that are able to efficiently represent multiplication and other integer functions. <p> Therefore other extensions and alternatives, e.g [11, 28, 6, 13], have been proposed to overcome some of the limitations of BDDs (see [5] for references to the "alphabet soup" of various representation schemes). *-BMDs [6] and HDDs <ref> [13] </ref> are two notable examples that are able to efficiently represent multiplication and other integer functions.
Reference: [14] <author> E. M. Clarke, S. M. German, and X. Zhao. </author> <title> Verifying the SRT division algorithm using theorem proving techniques. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 1102:111-??, </address> <year> 1996. </year>
Reference-contexts: They have been used to verify and identify errors in SRT division circuits <ref> [7, 14] </ref> similar to the one used in the Intel Pentium chip. *-BMDs obtain some of their power by treating the outputs of integer functions as a whole rather than splitting them into bits and have been used for verifying many arithmetic circuit designs that were previously intractable [6].
Reference: [15] <author> Edmund M. Clarke and Jeanette M. Wing. </author> <title> Formal methods: State of the art and future directions. </title> <journal> ACM Computing Surveys, </journal> <volume> 28(4) </volume> <pages> 626-643, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: 1. Introduction Model checking, proposed in [12], is a verification technique for determining whether a given property expressed as a temporal logic formula is satisfied by a system specification (see <ref> [15] </ref> for references and a summary of the successes of this technique.) One of the major bottlenecks of model checking is the state explosion problem, i.e. the exponential growth in the number of states relative to the size of the system being verified.
Reference: [16] <author> M. Dietzfelbinger, J. Hromkovic, and G. Schnitger. </author> <title> A comparison of two lower bound methods for communication complexity. </title> <booktitle> In Symposium on Mathematical Foundations of Computer Science, </booktitle> <pages> pages 326-335, </pages> <year> 1994. </year>
Reference-contexts: For the boolean predicates listed above, the exponential bounds on the rank are a corollary of two of the approaches used for bounding the best-partition communication complexity of boolean functions. In the approach taken in [27, 30, 4], one constructs exponentially large fooling sets. By a theorem of <ref> [16] </ref>, these results imply exponential bounds for the rank. The second approach involves directly bounding the rank, as in [20] for the graph predicates stated above, although there are fewer results that use this approach. <p> The following proposition <ref> [16] </ref>, which can extended to handle unequal-sized partitions as well, implies that if exponentially large fooling sets exist, then the rank is exponential. Proposition 5 ([16]): For any boolean function f , and any equipartition of its variable set into L and R, let M f be the associated matrix of
Reference: [17] <author> R. Enders. </author> <title> Note on the complexity of binary moment diagram representations. </title> <type> Manuscript, </type> <year> 1995. </year>
Reference-contexts: On the other hand, the exponential bounds that we prove for the integer functions mentioned previously do not follow from standard communication complexity results but from directly analyzing the associated matrices and bounding their rank. As mentioned earlier, *-BMDs represent many arithmetic functions that require exponential size BDDs. Enders <ref> [17] </ref> obtained the first separation result in the other direction by showing that the the graph predicate that checks whether a graph is a triangle has polynomial-sized BDDs but requires exponential size *-BMDs.
Reference: [18] <author> M. Fliess. </author> <title> Matrices de Hankel. </title> <journal> J. Math. Pures et Appl., </journal> <volume> 53 </volume> <pages> 197-224, </pages> <year> 1974. </year>
Reference-contexts: in communication complexity by theoreticians. (An excellent source for results and references for this area is [23].) Our lower bound technique is analogous to previously known results in multiplicity automata theory which relate the size of a multiplicity automaton to the rank of the Hankel matrix computed by the automaton <ref> [18, 10] </ref>. Our technique provides insight into the contrast between boolean and integer representations. For example, consider the multiplication function. <p> The (x; y) th entry of F for binary strings x and y is f (x ffi y). It has been shown that the size of a minimal automaton that computes f is equal to the rank of F <ref> [10, 18] </ref>. Given any BLD P computing a function f that uses the order x p 1 ; x p 2 ; : : : ; x p n , we transform it to a multiplicity automaton N using the following procedure.
Reference: [19] <author> J. Gergov and Ch. Meinel. </author> <title> Efficient boolean manipulation with OBDD's can be extended to read-once only branching programs. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 43(10) </volume> <pages> 1197-1209, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Another direction that can be taken is to study the power of read-once representations that relax the notion of an implicit order on the variables. An important example is the Free Binary Decision Diagram <ref> [19] </ref> representation but we could also consider generalizations of this representation similar to the BLD representation.
Reference: [20] <author> Andras Hajnal, Wolfgang Maass, and Gyorgy Turan. </author> <title> On the communication complexity of graph properties. </title> <booktitle> In Proceedings of the Twentieth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 186-191, </pages> <address> Chicago, Illinois, </address> <month> 2-4 May </month> <year> 1988. </year>
Reference-contexts: In the approach taken in [27, 30, 4], one constructs exponentially large fooling sets. By a theorem of [16], these results imply exponential bounds for the rank. The second approach involves directly bounding the rank, as in <ref> [20] </ref> for the graph predicates stated above, although there are fewer results that use this approach. <p> Examples of such functions are in [27], [30], [4], [26] and <ref> [20] </ref>, of which we list some below. Corollary 6: The following predicates require BLDs of exponential size: Pattern Matching: Verify if the binary pattern string of ffn bits occurs in the binary text string of (1 ff)n bits, where 0 &lt; ff &lt; 1.
Reference: [21] <author> Harju and Karhumaki. </author> <title> The equivalence problem of multitape finite automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 78, </volume> <year> 1991. </year>
Reference-contexts: A slightly weaker result can be inferred from standard results on multiplicity automata which have previously considered in areas such as stochastic automata [10], theory of formal series <ref> [21] </ref>, and learning theory [1]. Informally, a multiplicity automaton is like a non-deterministic automaton with weights (in some field K) on transitions and states.
Reference: [22] <author> Robert D. Hof. </author> <title> Intel takes a bullet | and barely breaks stride. </title> <booktitle> Business Week, </booktitle> <pages> pages 38-39, </pages> <month> Jan </month> <year> 1995. </year>
Reference: [23] <author> Eyal Kushilevitz and Noam Nisan. </author> <title> Communication complexity. </title> <publisher> Cambridge University Press, </publisher> <address> Cam-bridge [England] ; New York, </address> <year> 1997. </year> <month> 11 </month>
Reference-contexts: This matrix is (essentially) the one usually used for VLSI AT 2 bounds, and has been studied extensively in communication complexity by theoreticians. (An excellent source for results and references for this area is <ref> [23] </ref>.) Our lower bound technique is analogous to previously known results in multiplicity automata theory which relate the size of a multiplicity automaton to the rank of the Hankel matrix computed by the automaton [18, 10]. Our technique provides insight into the contrast between boolean and integer representations.
Reference: [24] <author> Y.-T. Lai and S. Sastry. </author> <title> Edge-valued binary decision diagrams for multi-level hierarchical verifica-tion. </title> <booktitle> In 29th ACM/IEEE Design Automation Conference, </booktitle> <pages> pages 608-613, </pages> <year> 1992. </year>
Reference: [25] <author> Tak Wah Lam and Larry Ruzzo. </author> <title> Results on communication complexity classes. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 44, </volume> <year> 1992. </year>
Reference-contexts: Shifted Equality: Given two input strings and a number i, the function evaluates to 1 if and only if the first string equals the second shifted circularly to the right i times. (Lam and Ruzzo <ref> [25] </ref> generalized this proof to show that any function f that has a large fooling set under some fixed partition has a shifting version that has large fooling sets under all partitions.
Reference: [26] <author> Thomas Lengauer. </author> <title> VLSI theory. </title> <booktitle> In Handbook of Theoretical Computer Science, </booktitle> <editor> Ed. Jan van Leeuwen, </editor> <title> Elsevier and MIT Press (Volume A (= "1"): Algorithms and Complexity), volume 1. </title> <publisher> The MIT Press/Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: Examples of such functions are in [27], [30], [4], <ref> [26] </ref> and [20], of which we list some below. Corollary 6: The following predicates require BLDs of exponential size: Pattern Matching: Verify if the binary pattern string of ffn bits occurs in the binary text string of (1 ff)n bits, where 0 &lt; ff &lt; 1.
Reference: [27] <author> Richard J. Lipton and Robert Sedgewick. </author> <title> Lower bounds for VLSI. </title> <booktitle> In Conference Proceedings of the Thirteenth Annual ACM Symposium on Theory of Computation, </booktitle> <pages> pages 300-307, </pages> <address> Milwaukee, Wisconsin, </address> <month> 11-13 May </month> <year> 1981. </year>
Reference-contexts: For the boolean predicates listed above, the exponential bounds on the rank are a corollary of two of the approaches used for bounding the best-partition communication complexity of boolean functions. In the approach taken in <ref> [27, 30, 4] </ref>, one constructs exponentially large fooling sets. By a theorem of [16], these results imply exponential bounds for the rank. The second approach involves directly bounding the rank, as in [20] for the graph predicates stated above, although there are fewer results that use this approach. <p> Examples of such functions are in <ref> [27] </ref>, [30], [4], [26] and [20], of which we list some below. Corollary 6: The following predicates require BLDs of exponential size: Pattern Matching: Verify if the binary pattern string of ffn bits occurs in the binary text string of (1 ff)n bits, where 0 &lt; ff &lt; 1.
Reference: [28] <author> K.L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Norwell Massachusetts, </address> <year> 1993. </year>
Reference-contexts: Symbolic methods <ref> [9, 28, 8] </ref> have successfully combated this problem in many instances. Central to these methods is an underlying representation for various boolean and integer functions, and predicates combining such functions in arbitrary ways, in order to encode and implicitly explore state spaces. Ideally, these representations must satisfy certain important properties. <p> The main drawback of BDDs is in concisely representing some important functions, particularly integer functions such as multiplication which requires exponential size [4]. Therefore other extensions and alternatives, e.g <ref> [11, 28, 6, 13] </ref>, have been proposed to overcome some of the limitations of BDDs (see [5] for references to the "alphabet soup" of various representation schemes). *-BMDs [6] and HDDs [13] are two notable examples that are able to efficiently represent multiplication and other integer functions.
Reference: [29] <author> Kurt Mehlhorn and Erik M. Schmidt. </author> <title> Las Vegas is better than determinism in VLSI and distributed computing (extended abstract). </title> <booktitle> In Proceedings of the Fourteenth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 330-337, </pages> <address> San Francisco, California, </address> <month> 5-7 May </month> <year> 1982. </year>
Reference-contexts: Among the approaches that give lower bounds on this measure are (i) constructing large boolean fooling sets and (ii) computing the rank of M L;R f <ref> [29] </ref>. A fooling set consists of pairs of input assignments to L and R such that for any two distinct pairs (; ) and ( 0 ; 0 ), f ( ) = f ( 0 0 ), but f ( 0 ) 6= f ( 0 ).
Reference: [30] <author> C. Papadimitriou and M. Sipser. </author> <title> Communication complexity. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 28, </volume> <year> 1984. </year>
Reference-contexts: For the boolean predicates listed above, the exponential bounds on the rank are a corollary of two of the approaches used for bounding the best-partition communication complexity of boolean functions. In the approach taken in <ref> [27, 30, 4] </ref>, one constructs exponentially large fooling sets. By a theorem of [16], these results imply exponential bounds for the rank. The second approach involves directly bounding the rank, as in [20] for the graph predicates stated above, although there are fewer results that use this approach. <p> Examples of such functions are in [27], <ref> [30] </ref>, [4], [26] and [20], of which we list some below. Corollary 6: The following predicates require BLDs of exponential size: Pattern Matching: Verify if the binary pattern string of ffn bits occurs in the binary text string of (1 ff)n bits, where 0 &lt; ff &lt; 1.
Reference: [31] <author> Stephen Ponzio. </author> <title> A lower bound for integer multiplication with read-once branching programs. </title> <booktitle> In Proceedings of the Twenty-Seventh Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 130-139, </pages> <address> Las Vegas, Nevada, 29 May-1 June 1995. </address>
Reference-contexts: Existing lower bounds for BDDs [4] or even read-once branching programs <ref> [31] </ref> do not extend to *-BMDs and HDDs. We derive our lower bounds by defining an abstraction, called the Binary Linear Diagram (BLD), that encompasses all the representations referred to above.
Reference: [32] <author> R. K. Brayton, G. D. Hachtel, A. Sangiovanni-Vincentelli, F. Somenzi, A. Aziz, S. -T. Cheng, S. Edwards, S. Khatri, Y. Kukimoto, A. Pardo, S. Qadeer, R. K. Ranjan, S. Sarwary, T. R. Shiple, G. Swamy, and T. Villa. </author> <title> VIS: a system for verification and synthesis. </title> <editor> In Rajeev Alur and Thomas A. Henzinger, editors, </editor> <booktitle> Proceedings of the Eighth International Conference on Computer Aided Verification CAV, volume 1102 of Lecture Notes in Computer Science, </booktitle> <pages> pages 428-432, </pages> <address> New Brunswick, NJ, USA, July/August 1996. </address> <publisher> Springer Verlag. </publisher>
Reference: [33] <author> Y. -A. Chen, E. Clarke, P. -H. Ho, Y. Hoskote, T. Kam, M. Khaira, J. O'Leary, and X. Zhao. </author> <title> Verification of all circuits in a foating-pont unit using word-level model checking. </title> <editor> In M. Srivas and A. Camilleri, editors, </editor> <booktitle> First international conference on formal methods in computer-aided design, volume 1166 of Lecture Notes in Computer Science, </booktitle> <pages> pages 19-33, </pages> <address> Palo Alto, CA, USA, November 1996. </address> <publisher> Springer Verlag. </publisher>
Reference-contexts: HDDs combine many of the advantages of BDDs and *-BMDs and thus have been successfully incorporated into verification packages, e.g. <ref> [33] </ref>. However, all the representations that have been considered are still far from being an efficient tool for verifying general systems. A common feature of all the approaches outlined above is that the system is evaluated in a bottom-up manner to represent its transition relation.
Reference: [34] <author> Andrew Chi-Chih Yao. </author> <title> Some complexity questions related to distributive computing (preliminary report). </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 209-213, </pages> <address> Atlanta, Georgia, </address> <month> 30 April-2 May </month> <year> 1979. </year>
Reference: [35] <author> Yimg-An-Chen and R.E. Bryant. *PHDD: </author> <title> an efficient graph representation for floating point circuit verification. </title> <booktitle> In International Conference on Computer Aided Design, </booktitle> <pages> pages 2-7, </pages> <address> Los Alamitos, Ca., USA, November 1997. </address> <publisher> IEEE Computer Society Press. </publisher> <pages> 12 </pages>
Reference-contexts: This research is aimed at understanding the effectiveness of all these representations in dealing with these functions and predicates. 2 We show that for a variety of specific integer and boolean functions, none of the representations referred to above, including recently defined representations such as <ref> [35] </ref>, can represent many such important boolean and integer functions concisely.
References-found: 35

