URL: ftp://ftp.ics.hawaii.edu/pub/tr/ics-tr-93-07.ps.Z
Refering-URL: ftp://ftp.ics.hawaii.edu/pub/tr/INDEX.html
Root-URL: 
Title: Using Integer Programming to Verify General Safety and Liveness Properties  
Author: James C. Corbett George S. Avrunin 
Date: February 17, 1993  
Address: Amherst  
Affiliation: University of Hawaii at Manoa  University of Massachusetts at  
Abstract: Analysis of concurrent systems is plagued by the state explosion problem. The constrained expression analysis technique uses necessary conditions, in the form of linear inequalities, to verify certain properties of concurrent systems, thus avoiding the enumeration of the potentially explosive number of reachable states of the system. This technique has been shown to be capable of verifying simple safety properties, like freedom from deadlock, that can be expressed in terms of the number of certain events occurring in a finite execution, and has been successfully used to analyze a variety of concurrent software systems. We extend this technique to the verification of more complex safety properties that involve the order of events and to the verification of liveness properties, which involve infinite executions. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. I. Ali, J. Kennington, and B. Shetty. </author> <title> The equal flow problem. </title> <journal> European J. Oper. Res., </journal> <volume> 36 </volume> <pages> 107-115, </pages> <year> 1988. </year>
Reference-contexts: verified Output: A set of inequalities For each transition k of an FSA of M : Create transition variable x k For each accepting state j of an FSA of M : Create accept variable f j For each state j of an FSA of M : Generate flow equation: <ref> [1] </ref> start (j ) + X x k = k2out (j ) For each channel c: Generate synchronization equation: X k2call (c) x k = k2accept (c) x k Generate restriction inequality: X k2hang c (c) x k + k2hang a (c) x k 1 Generate additional inequalities specifying the violation <p> e i 62 alphabet (fsa (j )) or 9k 2 in (j )(label (k) = e i ) then Create connection variable c i;j For each interval i = 1; : : : ; n + 1: For each state j of an FSA of M : Generate flow equation: <ref> [1] </ref> i=1^start (j ) + [c i1;j ] + X x i;k = k2out (j ) For each channel c: Generate synchronization equation: X k2call (c) x i;k = k2accept (c) x i;k For each e in : If e 62 S i then Generate requirement equation: X k2occur (e) x <p> ) + [c i1;j ] + X x i;k = k2out (j ) For each channel c: Generate synchronization equation: X k2call (c) x i;k = k2accept (c) x i;k For each e in : If e 62 S i then Generate requirement equation: X k2occur (e) x i;k = <ref> [1] </ref> i6=n+1^e=e i Else Generate requirement equation: X k2occur (e) x i;k [1] i6=n+1^e=e i For each channel c: Generate restriction inequality: n+1 X 0 X k2hang c (c) x i;k + k2hang a (c) x i;k A 1 11 * In the sequence system for sequence i, the requirement equations <p> ) For each channel c: Generate synchronization equation: X k2call (c) x i;k = k2accept (c) x i;k For each e in : If e 62 S i then Generate requirement equation: X k2occur (e) x i;k = <ref> [1] </ref> i6=n+1^e=e i Else Generate requirement equation: X k2occur (e) x i;k [1] i6=n+1^e=e i For each channel c: Generate restriction inequality: n+1 X 0 X k2hang c (c) x i;k + k2hang a (c) x i;k A 1 11 * In the sequence system for sequence i, the requirement equations that require a symbol occur exactly (or at least) once are changed <p> in an SCC of an FSA of M : Create perpetual variable p j For each accepting state j of an FSA of M : Create accept variable f j For each interval i = 1; 2: For each state j of an FSA of M : Generate flow equation: <ref> [1] </ref> i=1^start (j) + X x i;k = k2out (j ) For each channel c: For each interval i = 1; 2: Generate synchronization equation: X k2call (c) x i;k = k2accept (c) x i;k Generate restriction inequality: X k2hang c (c) x 1;k + k2hang a (c) x 1;k 1 <p> Even papers proposing new methods for solving such problems validate those methods by presenting empirical data on their performance on standard test problems (e.g., <ref> [1] </ref>). We therefore plan a major project involving a thorough empirical evaluation of our technique, including both its application to a large number of sample concurrent systems and comparison with other techniques such as symbolic model checking.
Reference: [2] <author> G. S. Avrunin, U. A. Buy, and J. C. Corbett. </author> <title> Integer programming in the analysis of concurrent systems. </title> <booktitle> In Larsen and Skou [16], </booktitle> <pages> pages 92-102. </pages>
Reference-contexts: Automated tools for performing these analysis [10,22] have been used to verify a range of concurrent systems from simple network protocols such as the alternating bit protocol to standard concurrency problems such as the dining philosophers and the self-service gas station. The constrained expression method <ref> [2, 3] </ref> avoids the enumeration of a system's states altogether. Given a concurrent system and a property to be verified, this method generates a system of linear inequalities that represents necessary conditions for the existence of an execution of the concurrent system violating the property. <p> This model is general enough to represent many common communication mechanisms, including asynchronous message passing <ref> [2] </ref>, but in this paper we will focus on the case where pairs of processes communicate synchronously over named channels that connect them. On each channel, one process acts as the caller while the other acts as the acceptor. <p> In all our examples, we shall take the set of event symbols appearing in an FSA or restriction language as its alphabet and not specify the alphabets separately. The basic technique, detailed in <ref> [2] </ref>, uses necessary conditions, in the form of linear inequalities, to either help find a trace with certain properties or prove that no such trace could exist. <p> In our experience [3], however, such spurious solutions are uncommon. Also, we can sometimes add additional inequalities to remove such solutions. As shown in <ref> [2] </ref>, the formalism and analysis technique can also be applied to systems that use an asynchronous communication mechanism. For such systems, the communication and restriction inequalities would be different.
Reference: [3] <author> G. S. Avrunin, U. A. Buy, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Automated tools for performing these analysis [10,22] have been used to verify a range of concurrent systems from simple network protocols such as the alternating bit protocol to standard concurrency problems such as the dining philosophers and the self-service gas station. The constrained expression method <ref> [2, 3] </ref> avoids the enumeration of a system's states altogether. Given a concurrent system and a property to be verified, this method generates a system of linear inequalities that represents necessary conditions for the existence of an execution of the concurrent system violating the property. <p> This method has been automated as part of the constrained expression toolset and has been applied to some concurrent systems having as many as 10 47 reachable states <ref> [3] </ref>. Unfortunately, the types of properties that can be verified by this method are somewhat limited. <p> If such a solution arises, the analysis is inconclusive since the presence of that solution implies nothing about the existence of another solution that does correspond to a trace. In our experience <ref> [3] </ref>, however, such spurious solutions are uncommon. Also, we can sometimes add additional inequalities to remove such solutions. As shown in [2], the formalism and analysis technique can also be applied to systems that use an asynchronous communication mechanism. For such systems, the communication and restriction inequalities would be different. <p> The size of the inequality system generated by this technique is linear in the size of the automata and linear in the 16 size of the !-star-less expression. 6 Experiments The technique for verifying properties expressible with !-star-less expressions has been implemented as an extension of the constrained expression toolset <ref> [3] </ref>. A series of experiments has demonstrated the feasibility of the technique for verifying different kinds of properties on several examples of concurrent systems. This section describes some of these experiments. All times reported are in seconds on a DECstation 5000. <p> The obvious advantage of the approach is that it does not require enumeration of the system's many states. The disadvantages are that spurious solutions to the inequality system can make the analysis inconclusive and the tractability of integer linear programming in practice is not well understood. Nevertheless, our experience <ref> [3] </ref> suggests that spurious solutions are relatively rare and that our inequality systems, being largely network flow systems, have a special structure that usually makes their solution tractable.
Reference: [4] <author> J. A. Bergstra and J. W. Klop. </author> <title> Algebra of communicating processes with abstraction. </title> <journal> Theoretical Comput. Sci., </journal> <volume> 37(1) </volume> <pages> 77-121, </pages> <year> 1985. </year>
Reference-contexts: Although not completely automatic, these techniques have been applied to systems having over 10 1300 states. Compositional approaches [7, 20, 23], usually based on a process algebra <ref> [4, 14, 17] </ref>, reduce the complexity of the analysis by composing the components of a concurrent system in stages and hiding internal details of the composed entity after each stage. These techniques are best applied to well-structured systems with simple interfaces between the subsystems.
Reference: [5] <author> R. E. Bryant. </author> <title> Graph-based algorithms for boolean function manipulation. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-35(8):677-691, </volume> <year> 1986. </year>
Reference-contexts: This is commonly known as the state explosion problem. Many techniques have been proposed to cope with this problem. Symbolic model checking techniques [6, 15] use binary decision diagrams (BDDs) <ref> [5] </ref>, a compact representation for boolean functions, to represent the state space of a system symbolically.
Reference: [6] <author> J. Burch, E. Clarke, K. McMillan, D. Dill, and L. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: In practice, however, the analysis of these systems is generally intractable since the number of system states grows exponentially with the number of state machines. This is commonly known as the state explosion problem. Many techniques have been proposed to cope with this problem. Symbolic model checking techniques <ref> [6, 15] </ref> use binary decision diagrams (BDDs) [5], a compact representation for boolean functions, to represent the state space of a system symbolically.
Reference: [7] <author> E. Clarke, D. Long, and K. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In Proceedings of the Fourth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1989. </year>
Reference-contexts: The chief difficulty with these techniques is in finding a good abstraction, i.e., one that preserves just enough of the details of the system to verify a particular property. Although not completely automatic, these techniques have been applied to systems having over 10 1300 states. Compositional approaches <ref> [7, 20, 23] </ref>, usually based on a process algebra [4, 14, 17], reduce the complexity of the analysis by composing the components of a concurrent system in stages and hiding internal details of the composed entity after each stage.
Reference: [8] <author> E. M. Clarke, O. Grumberg, and D. E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In Proceedings of the 19th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: In a slight variation of this system in which a "host" process is added to prevent the deadlock, however, the number of states explored remains exponential in n. fl A preliminary version of this paper appeared in the Proceedings of the Fourth Workshop on Computer Aided Verification. 1 Abstraction techniques <ref> [8] </ref> use homomorphisms that map the state space of the system to a smaller, more abstract transition system sufficient for verifying a particular property.
Reference: [9] <editor> E. M. Clarke and R. P. Kurshan, editors. </editor> <booktitle> Computer-Aided Verification '90, number 3 in DI-MACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <address> Providence, RI, 1991. </address> <publisher> American Mathematical Society. </publisher>
Reference: [10] <author> R. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The Concurrency Workbench. </title> <editor> In J. Sifakis, editor, </editor> <booktitle> Proceedings of the International Workshop on Automatic Verification Methods for Finite State Systems, </booktitle> <pages> pages 24-37, </pages> <month> June </month> <year> 1989. </year> <note> Appeared as Lecture Notes in Computer Science 407. 22 </note>
Reference: [11] <author> J. C. Corbett. </author> <title> Automated Formal Analysis Methods for Concurrent and Real-Time Software. </title> <type> PhD thesis, </type> <institution> University of Massachusetts at Amherst, </institution> <year> 1992. </year> <note> Available as COINS Technical Report 92-48. </note>
Reference-contexts: In this paper, we extend the constrained expression method to handle both infinite executions and properties involving the relative order of events. A further extension of these ideas in <ref> [11] </ref> enables the technique to verify properties expressible in linear time temporal logic, thus allowing a very general class of questions about a system to be answered while avoiding the construction of an exponentially-sized state graph. <p> A description of how the analysis technique and the extensions we present here can be adjusted for use with such systems is given in <ref> [11] </ref>. 6 3 Expressiveness In this paper, we extend the basic technique presented in the last section to the verification of properties whose negations can be specified by !-star-less 1 expressions, which are !-regular expressions [19] of the form: m [ S fl i;2 e i;2 : : : S fl <p> The second idea allows the technique to deal with infinite traces and is described in Section 5. In this section, we discuss the power of the technique and some related techniques from <ref> [11] </ref> in relation to model checking. We then sketch how an analysis with our technique proceeds. Model checking techniques can determine whether a system satisfies a formula of temporal logic. <p> Thus !-star-less expressions are strictly less expressible than temporal logic. In practice, we have not yet encountered any commonly verified concurrency properties that are not expressible with !-star-less expressions, though our experience with the technique is limited. Two extensions of our technique are presented in <ref> [11] </ref>. The first allows arbitrary inequalities over the number of occurrences of certain events to be added to the inequality system generated for the analysis of an !-star-less expression. <p> We use the term star-less since the expressions specify patterns of the e i;j events using only concatenation and union (allowing the intervening symbols specified by the S i;j ). 7 The second extension described in <ref> [11] </ref> allows the verification of properties specified by a Buchi automaton. Since Buchi automata are more expressive than first order logic [19], this implies that the technique can be used for any property expressible in linear temporal logic. <p> If S n+1 = , we may omit the last interval (iteration i = n + 1), as we did in the example above. The correctness of these conditions is proved in <ref> [11] </ref>. Given a set of sequences, we derive necessary conditions for the existence of a trace generated by their disjunction as follows. We assign a sequence variable, s i , to each sequence and generate an equation summing the sequence variables to one. <p> The size of the inequality system for the disjunction is equal to the sum of the sizes of the inequality systems for the sequences, plus one additional variable per sequence, plus one additional equation (summing the sequence variables to one). An optimization described in <ref> [11] </ref> can significantly reduce the size of the inequality system for a disjunction by having different sequences share the same transition variables. We have described how to generate necessary conditions for the existence of a prefix of a trace generated by a star-less expression. <p> The generation of fairness inequalities is discussed further in <ref> [11] </ref>. The algorithm to generate inequalities representing necessary conditions for the existence of an infinite trace is shown in Figure 7. The correctness of these conditions is proved in [11]. <p> The generation of fairness inequalities is discussed further in <ref> [11] </ref>. The algorithm to generate inequalities representing necessary conditions for the existence of an infinite trace is shown in Figure 7. The correctness of these conditions is proved in [11]. The technique to find infinite traces can be combined with the technique of Section 4, allowing us to produce necessary conditions for the existence of an infinite trace generated by an !-star-less expression. <p> As Table 2 shows, the average analysis time to verify or disprove a property of these systems, starting from an Ada-like source and an !-star-less expression, was about five minutes. These experiments are described in great detail in <ref> [11] </ref>. The last experiment described here involves a version of the dining philosophers system where the standard deadlock is prevented by having the philosophers pass around a "dictionary"; the philosopher holding the dictionary cannot hold any forks. Each philosopher nondeterministically decides whether to read or eat.
Reference: [12] <author> H. Garcia-Molina and D. Barbara. </author> <title> How to assign votes in a distributed system. </title> <journal> J. ACM, </journal> <volume> 32(4) </volume> <pages> 841-860, </pages> <month> Oct. </month> <year> 1985. </year>
Reference-contexts: The second experiment we describe involves several versions of a mutual exclusion protocol based on the concept of coteries <ref> [12] </ref>. A coterie is a general mechanism for achieving mutually exclusive access to a resource in a distributed system. Each resource has a set of keys. A coterie is a set of subsets of the keys with the property that any two subsets have a non-null intersection.
Reference: [13] <author> P. Godefroid and P. Wolper. </author> <title> Using partial orders for the efficient verification of deadlock freedom and safety properties. </title> <booktitle> In Larsen and Skou [16], </booktitle> <pages> pages 332-242. </pages>
Reference-contexts: These techniques have been applied to certain kinds of circuits, some standard concurrency problems such as the dining philosophers, and recently to a cache coherence protocol. Partial order techniques <ref> [13, 18, 21] </ref> identify transitions that "commute" (have the same effect if performed in either order) and use this information to reduce the number of states explored by not differentiating equivalent interleavings of transitions.
Reference: [14] <author> C. A. R. Hoare. </author> <title> Communicating Sequential Processes. </title> <booktitle> Prentice-Hall International, </booktitle> <year> 1985. </year>
Reference-contexts: Although not completely automatic, these techniques have been applied to systems having over 10 1300 states. Compositional approaches [7, 20, 23], usually based on a process algebra <ref> [4, 14, 17] </ref>, reduce the complexity of the analysis by composing the components of a concurrent system in stages and hiding internal details of the composed entity after each stage. These techniques are best applied to well-structured systems with simple interfaces between the subsystems.
Reference: [15] <author> R. Hojati, H. Touati, R. P. Kurshan, and R. K. Brayton. </author> <title> Efficient !-regular language containment. </title> <editor> In G. von Bochmann, editor, </editor> <booktitle> Computer Aided Verification, 4th International Workshop Proceedings, </booktitle> <pages> pages 371-382, </pages> <address> Montreal, Canada, </address> <year> 1992. </year>
Reference-contexts: In practice, however, the analysis of these systems is generally intractable since the number of system states grows exponentially with the number of state machines. This is commonly known as the state explosion problem. Many techniques have been proposed to cope with this problem. Symbolic model checking techniques <ref> [6, 15] </ref> use binary decision diagrams (BDDs) [5], a compact representation for boolean functions, to represent the state space of a system symbolically. <p> For instance, it took approximately 8000 seconds to solve the system with 60 philosophers and more than 7 hours to solve the system with 100 philosophers. For comparison, we note that the BDD-based technique of <ref> [15] </ref> can verify similar properties of these systems up to 48 philosophers, but was unable to handle a 64 philosopher system. 7 Conclusion We have presented a technique for verifying many safety and liveness properties of concurrent systems.
Reference: [16] <editor> K. G. Larsen and A. Skou, editors. </editor> <booktitle> Computer Aided Verification, 3rd International Workshop Proceedings, volume 575 of Lecture Notes in Computer Science, </booktitle> <address> Aalborg, Denmark, July 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference: [17] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <address> London, </address> <year> 1989. </year>
Reference-contexts: Although not completely automatic, these techniques have been applied to systems having over 10 1300 states. Compositional approaches [7, 20, 23], usually based on a process algebra <ref> [4, 14, 17] </ref>, reduce the complexity of the analysis by composing the components of a concurrent system in stages and hiding internal details of the composed entity after each stage. These techniques are best applied to well-structured systems with simple interfaces between the subsystems.
Reference: [18] <author> D. K. Probst and H. F. Li. </author> <title> Using partial-order semantics to avoid the state explosion problem in asynchronous systems. </title> <booktitle> In Clarke and Kurshan [9], </booktitle> <pages> pages 15-24. </pages>
Reference-contexts: These techniques have been applied to certain kinds of circuits, some standard concurrency problems such as the dining philosophers, and recently to a cache coherence protocol. Partial order techniques <ref> [13, 18, 21] </ref> identify transitions that "commute" (have the same effect if performed in either order) and use this information to reduce the number of states explored by not differentiating equivalent interleavings of transitions.
Reference: [19] <author> W. Thomas. </author> <title> Automata on infinite objects. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B. </booktitle> <publisher> MIT Press/Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: extensions we present here can be adjusted for use with such systems is given in [11]. 6 3 Expressiveness In this paper, we extend the basic technique presented in the last section to the verification of properties whose negations can be specified by !-star-less 1 expressions, which are !-regular expressions <ref> [19] </ref> of the form: m [ S fl i;2 e i;2 : : : S fl i;n i +1 T ! where S i;j ; e i;j 2 ; T i . <p> We then sketch how an analysis with our technique proceeds. Model checking techniques can determine whether a system satisfies a formula of temporal logic. It is well known that such first order logics are equivalent in expressive power to star-free regular expressions <ref> [19] </ref>, which allow concatenation, union, and negation, but not Kleene star. <p> Since Buchi automata are more expressive than first order logic <ref> [19] </ref>, this implies that the technique can be used for any property expressible in linear temporal logic. This extension relies on the same two ideas as the technique for !-star-less expressions. <p> To represent infinite executions, we use infinite strings of event symbols and make two changes to the constrained expression representation of a system. First, the processes of the system are modeled by Buchi automata <ref> [19] </ref> rather than FSAs. A Buchi automaton is the infinite analog of an FSA, accepting languages of infinite strings rather than finite strings. The only difference is the condition for acceptance. In an FSA, a computation must end in an accepting state for the string to be accepted. <p> The second change made to the formalism involves the restrictions. Each restriction language is defined to be the union of a recursive language of finite strings over and an !-context-free language <ref> [19] </ref> of infinite strings over . Restriction languages must include both finite and infinite strings since the projection of an infinite string onto an alphabet may be either finite or infinite. This completes the extension of the formalism.
Reference: [20] <author> A. Valmari. </author> <title> Compositional state space generation. </title> <booktitle> In European Conference on Petri Nets, </booktitle> <pages> pages 43-62, </pages> <year> 1990. </year>
Reference-contexts: The chief difficulty with these techniques is in finding a good abstraction, i.e., one that preserves just enough of the details of the system to verify a particular property. Although not completely automatic, these techniques have been applied to systems having over 10 1300 states. Compositional approaches <ref> [7, 20, 23] </ref>, usually based on a process algebra [4, 14, 17], reduce the complexity of the analysis by composing the components of a concurrent system in stages and hiding internal details of the composed entity after each stage.
Reference: [21] <author> A. Valmari. </author> <title> A stubborn attack on state explosion. </title> <booktitle> In Clarke and Kurshan [9], </booktitle> <pages> pages 25-41. </pages>
Reference-contexts: These techniques have been applied to certain kinds of circuits, some standard concurrency problems such as the dining philosophers, and recently to a cache coherence protocol. Partial order techniques <ref> [13, 18, 21] </ref> identify transitions that "commute" (have the same effect if performed in either order) and use this information to reduce the number of states explored by not differentiating equivalent interleavings of transitions.
Reference: [22] <author> W. J. Yeh and M. Young. </author> <title> Compositional reachability analysis using process algebra. </title> <booktitle> In Proceedings of the Symposium on Testing, Analysis, and Verification (TAV4), </booktitle> <pages> pages 178-187, </pages> <address> New York, </address> <month> Oct. </month> <year> 1991. </year> <institution> ACM SIGSOFT, Association for Computing Machinery. </institution>
Reference: [23] <author> H. Zuidweg. </author> <title> Verification by abstraction and bisimulation. </title> <editor> In J. Sifakis, editor, </editor> <booktitle> Proceedings of the International Workshop on Automatic Verification Methods for Finite State Systems, </booktitle> <pages> pages 105-166, </pages> <month> June </month> <year> 1989. </year> <note> Appeared as Lecture Notes in Computer Science 407. 23 </note>
Reference-contexts: The chief difficulty with these techniques is in finding a good abstraction, i.e., one that preserves just enough of the details of the system to verify a particular property. Although not completely automatic, these techniques have been applied to systems having over 10 1300 states. Compositional approaches <ref> [7, 20, 23] </ref>, usually based on a process algebra [4, 14, 17], reduce the complexity of the analysis by composing the components of a concurrent system in stages and hiding internal details of the composed entity after each stage.
References-found: 23

