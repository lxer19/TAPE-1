URL: http://www.cs.bc.edu/~muller/postscript/icfp97.ps
Refering-URL: http://www.cs.bc.edu/~muller/papers.html
Root-URL: http://www.cs.bc.edu
Title: Strongly Typed Flow-Directed Representation Transformations (Extended Abstract) Topic Areas: compilation, lambda calculus, intersection and union
Author: Allyn Dimock Robert Muller J. B. Wells 
Address: Wellesley College  
Affiliation: Harvard University  Boston College Franklyn Turbak  Glasgow University  
Abstract: We present a new framework for transforming data representations in a strongly typed intermediate language. Our method allows both value producers (sources) and value consumers (sinks) to support multiple representations, automatically inserting any required code. Specialized representations can be easily chosen for particular source/sink pairs. The framework is based on these techniques: 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Alexander S. Aiken, Edward L. Wimmers, and T. K. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In POPL '94 [22], </booktitle> <pages> pages 163-173. </pages>
Reference-contexts: Analysis (FA) In the literature, a flow analysis (sometimes called a clo sure analysis) is any of a class of analyses that either relate abstraction occurrences (function definitions) to application occurrences (function call sites), or relate abstractions which may be called to the abstractions from whose bodies they are called <ref> [1, 5, 10, 11, 26] </ref>. In our intermediate language CIL , as in the work of Heintze [10] and Banerjee [5], flow information is encoded as annotations on arrow types. <p> Relevant research on both intersection and union types includes the work by Pierce [20], Aiken, Wim-mers, and Lakshman <ref> [1] </ref>, Trifonov, Smith, and Eifrig [29, 8], and Barbanera, Dezani-Ciancaglini, and de'Liguoro [6]. Of the above, only Pierce considers intersection and union types in an explicitly typed language.
Reference: [2] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: S [[M]] R;E;N bind x in : : : ; [[o i ]] R;N ) [[M i ]] R;E i ;N ; : : : where E i = E h i All other cases are purely structural. tradeoffs between sharing and time to lookup the value of a variable <ref> [16, 27, 2, 25] </ref>. Our framework abstracts out data structure representation issues. Jagannathan and Wright discuss flow-directed inlining in an untyped system [12]. Their paper examines heuris tics for selecting application sites for inlining. They do not discuss inlining open terms.
Reference: [3] <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In Conf. Rec. 16th Ann. ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 293-302, </pages> <year> 1989. </year>
Reference-contexts: In functional programming languages, a particularly important representation transformation is closure conversion, which implements a function value as a closure, packaging the function code with the values of its free variables <ref> [16, 3, 25, 30, 17] </ref>. fl This author's work was done at Boston University and was partially supported by NSF grants CCR-9113196 and CCR-9417382 and EPSRC grant GR/L 36963. By using multiple representations for a single data type, a compiler can choose more efficient representations by considering their uses.
Reference: [4] <author> Steffen van Bakel. </author> <title> Intersection Type Disciplines in Lambda Calculus and Applicative Term Rewriting Systems. </title> <type> PhD thesis, </type> <institution> University of Nijmegen, </institution> <year> 1993. </year>
Reference-contexts: We have not yet proved that applying the RT algorithm preserves the meaning of the program. 4 Related Work General research into the use of intersection types which has influenced us includes the work of Van Bakel <ref> [4] </ref> and Jim [13, 14]. Relevant research on both intersection and union types includes the work by Pierce [20], Aiken, Wim-mers, and Lakshman [1], Trifonov, Smith, and Eifrig [29, 8], and Barbanera, Dezani-Ciancaglini, and de'Liguoro [6].
Reference: [5] <author> Anindya Banerjee. </author> <title> A modular, polyvariant, and type-based closure analysis. </title> <booktitle> In Proc. 1997 ACM SIGPLAN Int'l Conf. Functional Programming, </booktitle> <year> 1997. </year>
Reference-contexts: To distinguish between multiple representations, it is necessary to separate data flow paths. The "plumbing" of the program must be transformed in such a way that the meaning of the program is preserved. In this paper, we address the plumbing problem while using existing flow analysis techniques <ref> [5] </ref>. We present a framework for representation transformation that supports multiple representations within a strongly typed language. The framework is both type-directed and flow-directed in the sense that it uses the types of terms and global flow information encoded in those types to determine how the terms are transformed. <p> Contributions of this Paper * We show how flows-from and flows-to annotations on types can be used to pair up sources and sinks. We then use this information to make pairwise representation decisions. Flows-from annotations on types have been used in previous work <ref> [10, 5] </ref>, but we are the first to use them in combination with flows-to annotations. * We solve the plumbing problem for multiple representations using intersection and union types. <p> Analysis (FA) In the literature, a flow analysis (sometimes called a clo sure analysis) is any of a class of analyses that either relate abstraction occurrences (function definitions) to application occurrences (function call sites), or relate abstractions which may be called to the abstractions from whose bodies they are called <ref> [1, 5, 10, 11, 26] </ref>. In our intermediate language CIL , as in the work of Heintze [10] and Banerjee [5], flow information is encoded as annotations on arrow types. <p> In our intermediate language CIL , as in the work of Heintze [10] and Banerjee <ref> [5] </ref>, flow information is encoded as annotations on arrow types. The Flow Analysis (FA) stage takes the input program P 0 , performs a flow analysis on P 0 and encodes the results of this analysis in type annotatations on its output P 1 . <p> Even that is somewhat distant from our work because Pierce includes a general sub-typing relation on intersection and union types which we deliberately avoid. Flow-types were first named by Heintze in [10], and are also used by Banerjee in <ref> [5] </ref>. We differ from the above by including sink labels as well as source labels. Our closure conversion is most closely related to Wand and Steckler's work on selective and lightweight closure conversion [30]. They give a 0CFA-based algorithm in the untyped setting and prove its correctness.
Reference: [6] <author> Franco Barbanera, Mariangiola Dezani-Ciancaglini, and Ugo de'Liguoro. </author> <title> Intersection and union types: Syntax and semantics. </title> <journal> Information and Computation, </journal> <volume> 119 </volume> <pages> 202-230, </pages> <year> 1995. </year>
Reference-contexts: Relevant research on both intersection and union types includes the work by Pierce [20], Aiken, Wim-mers, and Lakshman [1], Trifonov, Smith, and Eifrig [29, 8], and Barbanera, Dezani-Ciancaglini, and de'Liguoro <ref> [6] </ref>. Of the above, only Pierce considers intersection and union types in an explicitly typed language. Even that is somewhat distant from our work because Pierce includes a general sub-typing relation on intersection and union types which we deliberately avoid.
Reference: [7] <author> Hendrik Pieter Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In Sam-son Abramsky, Dov M. Gabbay, and Thomas S. E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 2, chapter 2, </volume> <pages> pages 117-309. </pages> <publisher> Oxford University Press, </publisher> <year> 1992. </year>
Reference: [8] <author> Jonathan Eifrig, Scott Smith, and Valery Trifonov. </author> <title> Type inference for recursively constrained types and its application to OOP. </title> <booktitle> In Proc. 1995 Mathematical Foundations of Programming Semantics Conf. </booktitle> <publisher> Elsevier, </publisher> <year> 1995. </year>
Reference-contexts: Relevant research on both intersection and union types includes the work by Pierce [20], Aiken, Wim-mers, and Lakshman [1], Trifonov, Smith, and Eifrig <ref> [29, 8] </ref>, and Barbanera, Dezani-Ciancaglini, and de'Liguoro [6]. Of the above, only Pierce considers intersection and union types in an explicitly typed language. Even that is somewhat distant from our work because Pierce includes a general sub-typing relation on intersection and union types which we deliberately avoid.
Reference: [9] <author> John Hannan. </author> <title> Type systems for closure conversion. </title> <booktitle> In Workshop on Types for Program Analysis, </booktitle> <pages> pages 48-62, </pages> <year> 1995. </year> <note> DAIMI PB-493. </note>
Reference-contexts: We are the first to perform function transformations using multiple representations with multiple interfaces in a strongly typed language. Earlier approaches to typed closure conversion <ref> [9, 17, 18] </ref> have required all function representations to use the same application protocol. The only flow-based closure conversion work known to us that supports multiple application protocols is ex pressed in an untyped language [30]. <p> Their algorithm restricts a function to a single representation and requires all functions flowing to a particular application site to observe the same application protocol. Hannan <ref> [9] </ref> describes the annotations on types to perform the optimizations of [30] in a typed system. He specifies a conversion, but does not supply an algorithm. He does not handle multiple representations for a single function or mixed calling conventions at a single call site.
Reference: [10] <author> Nevin Heintze. </author> <title> Control-flow analysis and type systems. </title> <booktitle> In Proc. 2nd Int'l Static Analysis Symp., </booktitle> <pages> pages 189-206, </pages> <year> 1995. </year>
Reference-contexts: Contributions of this Paper * We show how flows-from and flows-to annotations on types can be used to pair up sources and sinks. We then use this information to make pairwise representation decisions. Flows-from annotations on types have been used in previous work <ref> [10, 5] </ref>, but we are the first to use them in combination with flows-to annotations. * We solve the plumbing problem for multiple representations using intersection and union types. <p> Analysis (FA) In the literature, a flow analysis (sometimes called a clo sure analysis) is any of a class of analyses that either relate abstraction occurrences (function definitions) to application occurrences (function call sites), or relate abstractions which may be called to the abstractions from whose bodies they are called <ref> [1, 5, 10, 11, 26] </ref>. In our intermediate language CIL , as in the work of Heintze [10] and Banerjee [5], flow information is encoded as annotations on arrow types. <p> In our intermediate language CIL , as in the work of Heintze <ref> [10] </ref> and Banerjee [5], flow information is encoded as annotations on arrow types. The Flow Analysis (FA) stage takes the input program P 0 , performs a flow analysis on P 0 and encodes the results of this analysis in type annotatations on its output P 1 . <p> Of the above, only Pierce considers intersection and union types in an explicitly typed language. Even that is somewhat distant from our work because Pierce includes a general sub-typing relation on intersection and union types which we deliberately avoid. Flow-types were first named by Heintze in <ref> [10] </ref>, and are also used by Banerjee in [5]. We differ from the above by including sink labels as well as source labels. Our closure conversion is most closely related to Wand and Steckler's work on selective and lightweight closure conversion [30].
Reference: [11] <author> Suresh Jagannathan and Stephen Weeks. </author> <title> A unified treatment of flow analysis in higher-order languages. </title> <booktitle> In Conf. Rec. 22nd Ann. ACM Symp. Principles of Programming Languages, </booktitle> <pages> pages 393-407, </pages> <year> 1995. </year>
Reference-contexts: Analysis (FA) In the literature, a flow analysis (sometimes called a clo sure analysis) is any of a class of analyses that either relate abstraction occurrences (function definitions) to application occurrences (function call sites), or relate abstractions which may be called to the abstractions from whose bodies they are called <ref> [1, 5, 10, 11, 26] </ref>. In our intermediate language CIL , as in the work of Heintze [10] and Banerjee [5], flow information is encoded as annotations on arrow types.
Reference: [12] <author> Suresh Jagannathan and Andrew Wright. </author> <title> Flow-directed inlin-ing. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. Prog. Language Design & Implementation, </booktitle> <pages> pages 193-205, </pages> <year> 1996. </year>
Reference-contexts: Although beneficial in an optimizing compiler, implementing multiple representations is challenging: 1. Global flow information is required to match up the sources and sinks that share a representation. Because there is growing recognition that such flow analyses are necessary for optimizing higher-order languages <ref> [26, 21, 12] </ref>, this requirement is not too burdensome. 2. To distinguish between multiple representations, it is necessary to separate data flow paths. The "plumbing" of the program must be transformed in such a way that the meaning of the program is preserved. <p> Our framework abstracts out data structure representation issues. Jagannathan and Wright discuss flow-directed inlining in an untyped system <ref> [12] </ref>. Their paper examines heuris tics for selecting application sites for inlining. They do not discuss inlining open terms.
Reference: [13] <author> Trevor Jim. </author> <title> Rank-2 type systems and recursive definitions. </title> <type> Technical Report MIT/LCS/TM-531, </type> <institution> Massachusetts Institute of Technology, </institution> <month> November </month> <year> 1995. </year>
Reference-contexts: We have not yet proved that applying the RT algorithm preserves the meaning of the program. 4 Related Work General research into the use of intersection types which has influenced us includes the work of Van Bakel [4] and Jim <ref> [13, 14] </ref>. Relevant research on both intersection and union types includes the work by Pierce [20], Aiken, Wim-mers, and Lakshman [1], Trifonov, Smith, and Eifrig [29, 8], and Barbanera, Dezani-Ciancaglini, and de'Liguoro [6]. Of the above, only Pierce considers intersection and union types in an explicitly typed language.
Reference: [14] <author> Trevor Jim. </author> <title> What are principal typings and what are they good for? In POPL '96 [23]. </title>
Reference-contexts: We have not yet proved that applying the RT algorithm preserves the meaning of the program. 4 Related Work General research into the use of intersection types which has influenced us includes the work of Van Bakel [4] and Jim <ref> [13, 14] </ref>. Relevant research on both intersection and union types includes the work by Pierce [20], Aiken, Wim-mers, and Lakshman [1], Trifonov, Smith, and Eifrig [29, 8], and Barbanera, Dezani-Ciancaglini, and de'Liguoro [6]. Of the above, only Pierce considers intersection and union types in an explicitly typed language.
Reference: [15] <author> A. J. Kfoury and J. B. Wells. </author> <title> New notions of reduction and non-semantic proofs of fi-strong normalization in typed -calculi. </title> <booktitle> In Proc. 10th Ann. IEEE Symp. Logic in Computer Sci., </booktitle> <pages> pages 311-321, </pages> <year> 1995. </year>
Reference-contexts: In this paper we have presented a simple algorithm for the Splitting/Tagging transformation. We plan to develop and implement a more efficient algorithm. An important practical issue in compiling with types is controlling the size of the intermediate representations. Our current language, following the style of <ref> [15] </ref>, duplicates terms when it duplicates types. Our language is convenient for specifying our framework, but for implementation a consid erable size savings can be obtained by using a typed calculus with intersection and union types in the style of [31].
Reference: [16] <author> David Kranz, Richard Kelsey, Jonathan A. Rees, Paul Hudak, James Philbin, and Norman I. Adams. </author> <title> Orbit: An optimizing compiler for Scheme. </title> <booktitle> In Proc. SIGPLAN '86 Symp. Compiler Construction, </booktitle> <pages> pages 219-233, </pages> <year> 1986. </year>
Reference-contexts: In functional programming languages, a particularly important representation transformation is closure conversion, which implements a function value as a closure, packaging the function code with the values of its free variables <ref> [16, 3, 25, 30, 17] </ref>. fl This author's work was done at Boston University and was partially supported by NSF grants CCR-9113196 and CCR-9417382 and EPSRC grant GR/L 36963. By using multiple representations for a single data type, a compiler can choose more efficient representations by considering their uses. <p> S [[M]] R;E;N bind x in : : : ; [[o i ]] R;N ) [[M i ]] R;E i ;N ; : : : where E i = E h i All other cases are purely structural. tradeoffs between sharing and time to lookup the value of a variable <ref> [16, 27, 2, 25] </ref>. Our framework abstracts out data structure representation issues. Jagannathan and Wright discuss flow-directed inlining in an untyped system [12]. Their paper examines heuris tics for selecting application sites for inlining. They do not discuss inlining open terms.
Reference: [17] <author> Yasuhiko Minamide, Greg Morrisett, and Robert Harper. </author> <title> Typed closure conversion. </title> <note> In POPL '96 [23]. </note>
Reference-contexts: In functional programming languages, a particularly important representation transformation is closure conversion, which implements a function value as a closure, packaging the function code with the values of its free variables <ref> [16, 3, 25, 30, 17] </ref>. fl This author's work was done at Boston University and was partially supported by NSF grants CCR-9113196 and CCR-9417382 and EPSRC grant GR/L 36963. By using multiple representations for a single data type, a compiler can choose more efficient representations by considering their uses. <p> We are the first to perform function transformations using multiple representations with multiple interfaces in a strongly typed language. Earlier approaches to typed closure conversion <ref> [9, 17, 18] </ref> have required all function representations to use the same application protocol. The only flow-based closure conversion work known to us that supports multiple application protocols is ex pressed in an untyped language [30]. <p> These types are only superficially different, because the closures are invoked in the same way. We combine such superficially different types using union types. For some function representations (but not all), existential types can serve a similar purpose <ref> [17] </ref>. As another example of Splitting/Tagging, suppose that 1 3 ; 1 are represented by code pointers and 2 is represented by a closure. <p> He specifies a conversion, but does not supply an algorithm. He does not handle multiple representations for a single function or mixed calling conventions at a single call site. Minamide, Morrisett and Harper present an algorithm for typed closure conversion <ref> [17, 18] </ref>. They use purely local transformations to perform closure conversion. Their framework supports multiple closure representations but it is restricted in that all representations share the same interface.
Reference: [18] <author> Greg Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1995. </year>
Reference-contexts: 1 Introduction Typed intermediate languages <ref> [19, 18, 25, 32] </ref> support type-directed transformations while simultaneously increasing confidence in the correctness of such transformations. In this paper, we focus on representation transformations, i.e., those that arise in data type implementations. <p> We are the first to perform function transformations using multiple representations with multiple interfaces in a strongly typed language. Earlier approaches to typed closure conversion <ref> [9, 17, 18] </ref> have required all function representations to use the same application protocol. The only flow-based closure conversion work known to us that supports multiple application protocols is ex pressed in an untyped language [30]. <p> He specifies a conversion, but does not supply an algorithm. He does not handle multiple representations for a single function or mixed calling conventions at a single call site. Minamide, Morrisett and Harper present an algorithm for typed closure conversion <ref> [17, 18] </ref>. They use purely local transformations to perform closure conversion. Their framework supports multiple closure representations but it is restricted in that all representations share the same interface.
Reference: [19] <author> Simon L. Peyton Jones, Cordy Hall, Kevin Hammond, Will Par-tain, and Phil Wadler. </author> <title> The Glasgow Haskell compiler: a technical overview. </title> <booktitle> In Proc. UK Joint Framework for Information Technology (JFIT) Technical Conf., </booktitle> <year> 1993. </year>
Reference-contexts: 1 Introduction Typed intermediate languages <ref> [19, 18, 25, 32] </ref> support type-directed transformations while simultaneously increasing confidence in the correctness of such transformations. In this paper, we focus on representation transformations, i.e., those that arise in data type implementations.
Reference: [20] <author> Benjamin C. Pierce. </author> <title> Programming with intersection types, union types, and polymorphism. </title> <type> Technical Report CMU-CS-91-106, </type> <institution> Carnegie Mellon University, </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: Relevant research on both intersection and union types includes the work by Pierce <ref> [20] </ref>, Aiken, Wim-mers, and Lakshman [1], Trifonov, Smith, and Eifrig [29, 8], and Barbanera, Dezani-Ciancaglini, and de'Liguoro [6]. Of the above, only Pierce considers intersection and union types in an explicitly typed language.
Reference: [21] <author> John Plevyak and Andrew A. Chien. </author> <title> Iterative flow analysis. </title> <note> Submitted, </note> <month> July </month> <year> 1995. </year>
Reference-contexts: Although beneficial in an optimizing compiler, implementing multiple representations is challenging: 1. Global flow information is required to match up the sources and sinks that share a representation. Because there is growing recognition that such flow analyses are necessary for optimizing higher-order languages <ref> [26, 21, 12] </ref>, this requirement is not too burdensome. 2. To distinguish between multiple representations, it is necessary to separate data flow paths. The "plumbing" of the program must be transformed in such a way that the meaning of the program is preserved. <p> Jagannathan and Wright discuss flow-directed inlining in an untyped system [12]. Their paper examines heuris tics for selecting application sites for inlining. They do not discuss inlining open terms. Plevyak and Chien have experimented with flow directed inlining in an object oriented language <ref> [21] </ref>. 5 Future Work Although this paper focuses on the transformation of function representations, our framework can be extended to transformations on other data types. These extensions involve adding flow labels to all value producing and consuming forms. We expect to handle specialized tuple, variant, and inductive datatype representations.
Reference: [22] <editor> Conf. </editor> <booktitle> Rec. 21st Ann. ACM Symp. Principles of Programming Languages, </booktitle> <year> 1994. </year>
Reference: [23] <editor> Conf. </editor> <booktitle> Rec. POPL '96: 23rd ACM Symp. Principles of Prog. Languages, </booktitle> <year> 1996. </year>
Reference: [24] <author> John C. Reynolds. </author> <title> Design of the programming language Forsythe. </title> <editor> In P. O'Hearn and R. D. Tennent, editors, </editor> <booktitle> Algol-like Languages. </booktitle> <publisher> Birkhauser, </publisher> <year> 1996. </year>
Reference: [25] <author> Zhong Shao. </author> <title> Compiling Standard ML for Efficient Execution on Modern Machines. </title> <type> PhD thesis, </type> <institution> Princeton University, </institution> <year> 1994. </year>
Reference-contexts: 1 Introduction Typed intermediate languages <ref> [19, 18, 25, 32] </ref> support type-directed transformations while simultaneously increasing confidence in the correctness of such transformations. In this paper, we focus on representation transformations, i.e., those that arise in data type implementations. <p> In functional programming languages, a particularly important representation transformation is closure conversion, which implements a function value as a closure, packaging the function code with the values of its free variables <ref> [16, 3, 25, 30, 17] </ref>. fl This author's work was done at Boston University and was partially supported by NSF grants CCR-9113196 and CCR-9417382 and EPSRC grant GR/L 36963. By using multiple representations for a single data type, a compiler can choose more efficient representations by considering their uses. <p> S [[M]] R;E;N bind x in : : : ; [[o i ]] R;N ) [[M i ]] R;E i ;N ; : : : where E i = E h i All other cases are purely structural. tradeoffs between sharing and time to lookup the value of a variable <ref> [16, 27, 2, 25] </ref>. Our framework abstracts out data structure representation issues. Jagannathan and Wright discuss flow-directed inlining in an untyped system [12]. Their paper examines heuris tics for selecting application sites for inlining. They do not discuss inlining open terms.
Reference: [26] <author> Olin Shivers. </author> <title> Control Flow Analysis of Higher Order Languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <year> 1991. </year>
Reference-contexts: Although beneficial in an optimizing compiler, implementing multiple representations is challenging: 1. Global flow information is required to match up the sources and sinks that share a representation. Because there is growing recognition that such flow analyses are necessary for optimizing higher-order languages <ref> [26, 21, 12] </ref>, this requirement is not too burdensome. 2. To distinguish between multiple representations, it is necessary to separate data flow paths. The "plumbing" of the program must be transformed in such a way that the meaning of the program is preserved. <p> Analysis (FA) In the literature, a flow analysis (sometimes called a clo sure analysis) is any of a class of analyses that either relate abstraction occurrences (function definitions) to application occurrences (function call sites), or relate abstractions which may be called to the abstractions from whose bodies they are called <ref> [1, 5, 10, 11, 26] </ref>. In our intermediate language CIL , as in the work of Heintze [10] and Banerjee [5], flow information is encoded as annotations on arrow types. <p> There is a flow analysis for CIL that is as accurate as the 0CFA of Shivers <ref> [26] </ref>.
Reference: [27] <author> Guy Steele. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Technical Report MIT/AI-TR-474, </type> <institution> Massachusetts Institute of Technology, </institution> <year> 1978. </year>
Reference-contexts: S [[M]] R;E;N bind x in : : : ; [[o i ]] R;N ) [[M i ]] R;E i ;N ; : : : where E i = E h i All other cases are purely structural. tradeoffs between sharing and time to lookup the value of a variable <ref> [16, 27, 2, 25] </ref>. Our framework abstracts out data structure representation issues. Jagannathan and Wright discuss flow-directed inlining in an untyped system [12]. Their paper examines heuris tics for selecting application sites for inlining. They do not discuss inlining open terms.
Reference: [28] <author> Andrew Tolmach. </author> <title> Combining closure conversion with closure analysis using algebraic types. </title> <booktitle> Presented at ACM SIGPLAN Types in Compilation Workshop, </booktitle> <address> June 8, Amsterdam, </address> <month> January </month> <year> 1997. </year>
Reference: [29] <author> Valery Trifonov and Scott Smith. </author> <title> Subtyping constrained types. </title> <booktitle> In Proc. 3rd Int'l Static Analysis Symp., </booktitle> <pages> pages 349-365, </pages> <year> 1996. </year>
Reference-contexts: Relevant research on both intersection and union types includes the work by Pierce [20], Aiken, Wim-mers, and Lakshman [1], Trifonov, Smith, and Eifrig <ref> [29, 8] </ref>, and Barbanera, Dezani-Ciancaglini, and de'Liguoro [6]. Of the above, only Pierce considers intersection and union types in an explicitly typed language. Even that is somewhat distant from our work because Pierce includes a general sub-typing relation on intersection and union types which we deliberately avoid.
Reference: [30] <author> Mitchell Wand and Paul Steckler. </author> <title> Selective and lightweight closure conversion. </title> <booktitle> In POPL '94 [22], </booktitle> <pages> pages 435-445. </pages>
Reference-contexts: In functional programming languages, a particularly important representation transformation is closure conversion, which implements a function value as a closure, packaging the function code with the values of its free variables <ref> [16, 3, 25, 30, 17] </ref>. fl This author's work was done at Boston University and was partially supported by NSF grants CCR-9113196 and CCR-9417382 and EPSRC grant GR/L 36963. By using multiple representations for a single data type, a compiler can choose more efficient representations by considering their uses. <p> By using multiple representations for a single data type, a compiler can choose more efficient representations by considering their uses. For example, selective closure conversion uses two function representation <ref> [30] </ref>: it can represent open functions (i.e., functions with free variables) as code/environment pairs, but in some cases can represent closed functions simply as code. The latter can be more efficient because it avoids packing the code into and unpacking it from a pair with a useless empty environment. <p> Earlier approaches to typed closure conversion [9, 17, 18] have required all function representations to use the same application protocol. The only flow-based closure conversion work known to us that supports multiple application protocols is ex pressed in an untyped language <ref> [30] </ref>. Our transformation can inline functions along ar bitrary flow paths, even open functions. 1 This paper is organized as follows. Section 2 gives an overview of our framework. Section 3 presents the stages of our framework in more detail. Section 4 discusses related research. Section 5 discusses future work. <p> Flow-types were first named by Heintze in [10], and are also used by Banerjee in [5]. We differ from the above by including sink labels as well as source labels. Our closure conversion is most closely related to Wand and Steckler's work on selective and lightweight closure conversion <ref> [30] </ref>. They give a 0CFA-based algorithm in the untyped setting and prove its correctness. Their algorithm can avoid closure creation when all the functions flowing to a particular call site are closed. <p> Their algorithm restricts a function to a single representation and requires all functions flowing to a particular application site to observe the same application protocol. Hannan [9] describes the annotations on types to perform the optimizations of <ref> [30] </ref> in a typed system. He specifies a conversion, but does not supply an algorithm. He does not handle multiple representations for a single function or mixed calling conventions at a single call site. Minamide, Morrisett and Harper present an algorithm for typed closure conversion [17, 18]. <p> We expect to handle specialized tuple, variant, and inductive datatype representations. We are implementing our framework and will experiment with various flow analysis algorithms and representation decision heuristics. We will refine the example representation transformation to include analysis enabling lightweight closure conversion <ref> [30] </ref>. This allows variables available at the call site to be omitted from the environment of the closure. This will also improve inlining. In this paper we have presented a simple algorithm for the Splitting/Tagging transformation. We plan to develop and implement a more efficient algorithm.
Reference: [31] <author> J. B. Wells. </author> <title> Intersection types revisited in the Church style. </title> <type> Manuscript, </type> <month> June </month> <year> 1996. </year>
Reference-contexts: Our current language, following the style of [15], duplicates terms when it duplicates types. Our language is convenient for specifying our framework, but for implementation a consid erable size savings can be obtained by using a typed calculus with intersection and union types in the style of <ref> [31] </ref>. Finally, we plan to study the interaction of our current approach with separate compilation. 6 Acknowledgements We would like to thank Mitch Wand, Will Clinger, Paul Steckler and several anonymous reviewers for their helpful comments and suggestions.
Reference: [32] <author> J. B. Wells, Allyn Dimock, Robert Muller, and Franklyn Tur-bak. </author> <title> A typed intermediate language for flow-directed compilation. </title> <booktitle> In Proc. 7th Int'l Joint Conf. Theory & Practice of Software Development, </booktitle> <address> Lille, France, April 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: 1 Introduction Typed intermediate languages <ref> [19, 18, 25, 32] </ref> support type-directed transformations while simultaneously increasing confidence in the correctness of such transformations. In this paper, we focus on representation transformations, i.e., those that arise in data type implementations.
References-found: 32

