URL: ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/typeinfo.ps.gz
Refering-URL: http://www.cs.indiana.edu/scheme-repository/doc.publications.html
Root-URL: http://www.cs.indiana.edu
Email: gudeman@cs.arizona.edu  
Title: Representing Type Information in Dynamically Typed Languages  
Author: David Gudeman 
Date: October 1993  
Address: Gould-Simpson Building  Tucson, AZ 85721, USA TR 93-27  
Affiliation: Department of Computer Science  The University of Arizona  
Abstract: This report is a discussion of various techniques for representing type information in dynamically typed languages, as implemented on general-purpose machines (and costs are discussed in terms of modern RISC machines). It is intended to make readily available a large body of knowledge that currently has to be absorbed piecemeal from the literature or re-invented by each language implementer. This discussion covers not only tagging schemes but other forms of representation as well, although the discussion is strictly limited to the representation of type information. It should also be noted that this report does not purport to contain a survey of the relevant literature. Instead, this report gathers together a body of folklore, organizes it into a logical structure, makes some generalizations, and then discusses the results in terms of modern hardware. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Robert L. Bernstein. </author> <title> "Producing good code for the case statement". </title> <journal> Software | Practice and Experience, </journal> <volume> 15(10) </volume> <pages> 1021-1024, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: In other words, it would be possible to construct an array indexed by (n + m)-bit numbers that has for each element the corresponding (n + m)-bit tag. An implementation ought to pick a good method for dispatching on the type of a variable <ref> [1] </ref>, given the expected value of d, and ought to order the tests in such a way as to minimize d. If this is done, then the overhead of using staged representations is often small enough that the staging is useful.
Reference: [2] <author> Koen De Bosschere, Saumya Debray, David Gudeman, and Sampath Kannan. </author> <title> "Call forwarding: A simple interprocedural optimization technique for dynamically typed languages". </title> <booktitle> In Proc. 21st ACM Sym. on Principles of Programming Languages, </booktitle> <address> Portland, OR, </address> <note> January 1994 (to appear). </note>
Reference-contexts: For example, a tagged sequence type that is represented by a contiguous array on the heap can be manipulated by getting a pointer to the array on the heap and using that directly [9]. There is an optimization |or rather a class of optimizations| called "call forwarding" <ref> [2] </ref> that skips unnecessary instructions at the beginning of a call, including conditional branches (and it can be generalized to skip instructions at other points as well). This optimization is particularly effective at skipping type checks in a program that uses types in a consistent manner.
Reference: [3] <author> Timothy Budd. </author> <title> A Little Smalltalk. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading MA, </address> <year> 1987. </year>
Reference-contexts: This representation has been used in a relatively pure form in Smalltalk 5 <ref> [3, 6] </ref>, Prolog [21], and functional languages [14].
Reference: [4] <author> S. Duvvuru. "Monaco: </author> <title> a high performance implementation of FGHC on shared-memory multiprocessors". </title> <type> Technical Report CIS-TR-92-16, </type> <institution> Department of Computer and Information Science, University of Oregon, </institution> <year> 1992. </year>
Reference-contexts: An implementation can enforce additional alignment restrictions to increase the size of this field. For example in Monaco <ref> [4] </ref>, a concurrent implementation of FGHC, values are represented with two words, one for a tagged value and one for a semaphore (to prevent race conditions on changing the value). <p> If v does not have type t_T then there is a return to lbl instead of the instruction immediately following the call. The executable type description for an integer would look something like this: int_code: compare r1,t_Int branch-eq return-lbl load r0, r0 <ref> [4] </ref> jump r2 19 Here, r0, r1, and r2 are the input argument registers and r0 is the output argument register that contains the unwrapped integer after a successful test. The label of the instruction after the call is stored in the register return-lbl (presumably by the call instruction). <p> In languages with concurrent constraint evaluation (for example: <ref> [9, 4] </ref>), a procedure evaluation can suspend when it needs the value of an unbound variable and it must be woken up when the variable gets assigned a value.
Reference: [5] <author> Richard P. Gabriel. </author> <title> Performance and Evaluation of Lisp Systems. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: For example, the implementation of NIL described in <ref> [5, pp 54-57] </ref> uses a tagging scheme where integers are given the tag 0b00 in the low end of the word and the other three 2-bit codes in the low end of the word represent staging tags. <p> Wrapping a pointer to a block is done by assigning a type code to the correct field in the block that the pointer references #define wrap_T (p) p-&gt;type_code = t_T 4 For example, MacLisp [15] and <ref> [5, pp 31-33] </ref>; Franz Lisp [5, pp 51-53]; Interlisp-VAX [19, page 29]. 5 Smalltalk implementations sometimes represent values with an extra level of indirection between the object pointer and the block. <p> Wrapping a pointer to a block is done by assigning a type code to the correct field in the block that the pointer references #define wrap_T (p) p-&gt;type_code = t_T 4 For example, MacLisp [15] and [5, pp 31-33]; Franz Lisp <ref> [5, pp 51-53] </ref>; Interlisp-VAX [19, page 29]. 5 Smalltalk implementations sometimes represent values with an extra level of indirection between the object pointer and the block.
Reference: [6] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80 The Language and its Implementation. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading MA, </address> <year> 1985. </year>
Reference-contexts: This representation has been used in a relatively pure form in Smalltalk 5 <ref> [3, 6] </ref>, Prolog [21], and functional languages [14].
Reference: [7] <author> Benjamin Goldberg and Michael Glover. </author> <title> "Polymorphic type reconstruction for garbage collection without tags". </title> <booktitle> In Proceedings of the 1992 ACM Conference on LIsp and Functional Programming, </booktitle> <pages> pages 53-65, </pages> <address> San Francisco CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: For each such pattern of static types it is possible to compile a specialized function for garbage collecting or debugging that stack frame, and this function does not need to deal with type codes since it knows what type is at each stack slot by static criteria <ref> [7] </ref>. 7 Hybrid Techniques Representation schemes can be combined in various ways to trade off the various advantages and disadvantages. Sometimes it is possible to merge two schemes so that they share representations.
Reference: [8] <author> Ralph E. Griswold and Madge T. Griswold. </author> <title> The Implementation of the Icon Programming Language. </title> <publisher> Princeton University Press, </publisher> <address> Princeton, NJ, </address> <year> 1986. </year>
Reference-contexts: Of course this further level of indirection reduces speed even further. 4.2 Hooked Values Object pointer representations and executable type descriptions are convenient for representing hooked values. A hooked value is a value that causes special things to happen when it is accessed. For example, in Icon <ref> [8] </ref> there is a hooked variable 6 &pos that must have an integer value in a restricted range. An attempt to assign a value outside of this range to &pos causes a piece of code to be executed that does something special. Icon has other hooked values as well. <p> The implementations of Icon described in <ref> [8] </ref> and [22] both represent dynamically-typed data in such pairs (with some extra information in the type word).
Reference: [9] <author> David Gudeman, Koenraad De Bosschere, and Saumya K. Debray. </author> <title> "jc: An efficient and portable sequential implementation of Janus". </title> <booktitle> In Proceedings of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 399-413, </pages> <address> Cambridge, MA, 1992. </address> <publisher> MIT Press. </publisher>
Reference-contexts: Allocation can cost as little as one cycle if hardware interrupts are used to detect allocation beyond the heap boundary and if the heap pointer is used to reference the newly allocated memory <ref> [9] </ref>. Unwrapping a non-pointer value requires fetching the value from memory: #define unwrap_T (p) p-&gt;val at a cost of 2 cycles. 4.1 Executable Type Descriptions Instead of putting an integer code in the first word of an object, it is possible to place there a piece of executable code. <p> In languages with concurrent constraint evaluation (for example: <ref> [9, 4] </ref>), a procedure evaluation can suspend when it needs the value of an unbound variable and it must be woken up when the variable gets assigned a value. <p> For example, a tagged sequence type that is represented by a contiguous array on the heap can be manipulated by getting a pointer to the array on the heap and using that directly <ref> [9] </ref>. There is an optimization |or rather a class of optimizations| called "call forwarding" [2] that skips unnecessary instructions at the beginning of a call, including conditional branches (and it can be generalized to skip instructions at other points as well).
Reference: [10] <author> Kevin Hammond. </author> <title> "The spineless tagless G-Machine | NOT!". </title> <type> Technical Report (not yet published), </type> <institution> Department of Computer Science, Glasgow University, </institution> <year> 1993. </year>
Reference-contexts: These figures are partially confirmed by the experiments reported in <ref> [10] </ref> where there is also a discussion of re-introducing tags to speed up the case where the value is not hooked. Note that the techniques of executable type descriptions are not restricted to object pointer schemes.
Reference: [11] <author> Samuel P. Harbison and Guy L. Steele Jr. </author> <title> C A Reference Manual. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1987. </year>
Reference-contexts: Many C compilers for machines that have a signed-left-shift instruction will do a signed shift on a signed quantity. However neither K&R nor the ANSI C standard requires that a shift on a signed value be a signed shift <ref> [11] </ref>, so the following macros cannot be considered portable.
Reference: [12] <author> John L. Hennessy and David A. Patterson. </author> <title> Computer Architecture A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <address> San Mateo CA, </address> <year> 1990. </year>
Reference-contexts: The MIPS machine has single instructions for equality and disequality tests <ref> [12] </ref>, and this changes some of the costs, possibly changing the preferred strategies in some cases. The SPARC has some special arithmetic instructions that are intended to work with 2-bit integer tags of 0b00 in the low end of the word [12, 13]. <p> The SPARC has some special arithmetic instructions that are intended to work with 2-bit integer tags of 0b00 in the low end of the word <ref> [12, 13] </ref>. There are instructions taddcc and tsubcc to add or subtract such integers and set the overflow flag if either operand did not have the lower two bits equal to 0b00.
Reference: [13] <author> Douglas Johnson. </author> <title> "Trap architectures for Lisp systems". </title> <booktitle> In Proceedings of the 1990 ACM Conference on LIsp and Functional Programming, </booktitle> <pages> pages 79-86, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Of course this method can be generalized for type-checking situations where it is not an error for the type to be other than as expected, but the costs 31 of interrupts on modern machines are so expensive <ref> [13] </ref>, that this technique is unlikely to be cost effective in other cases. 9 Miscellaneous Considerations 9.1 Avoiding Operations on Dynamic Representations There are a number of ways to avoid dynamic type operations altogether, and it is probably these techniques that will eventually make dynamically typed languages as efficient as statically <p> The SPARC has some special arithmetic instructions that are intended to work with 2-bit integer tags of 0b00 in the low end of the word <ref> [12, 13] </ref>. There are instructions taddcc and tsubcc to add or subtract such integers and set the overflow flag if either operand did not have the lower two bits equal to 0b00.
Reference: [14] <author> Simon L. Peyton Jones. </author> <title> "Implementing lazy functional languages on stock hardware: </title> <journal> the Spineless Tagless G-machine". Journal of Functional Programming, </journal> <volume> 2(2) </volume> <pages> 127-202, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: This representation has been used in a relatively pure form in Smalltalk 5 [3, 6], Prolog [21], and functional languages <ref> [14] </ref>. Although the word "object" has a special meaning in some other contexts, it is used here to mean simply a block with a structure that contains enough information to identify what type of value the block represents (and how it represents that value). <p> Lazy evaluation is implemented by creating hooked values for unevaluated expressions. The hooked value, when accessed, will evaluate the expression and then replace itself with the value of the expression. The Spineless Tagless G-machine <ref> [14] </ref> is a virtual machine for implementing functional languages with lazy evaluation. It represents all wrapped values with object pointers (hence the name "tagless"), where the type of the object is encoded in a piece of executable code as described above.
Reference: [15] <author> Guy Lewis Steele Jr. </author> <title> "Data representations in PDP-10 MacLisp". </title> <booktitle> In Proc. 1977 MACSYMA Users' Conference, </booktitle> <address> Washington, D.C., </address> <month> July </month> <year> 1979. </year> <journal> NASA Scientific and Technical Information Office. </journal> <volume> 37 </volume>
Reference-contexts: Wrapping a pointer to a block is done by assigning a type code to the correct field in the block that the pointer references #define wrap_T (p) p-&gt;type_code = t_T 4 For example, MacLisp <ref> [15] </ref> and [5, pp 31-33]; Franz Lisp [5, pp 51-53]; Interlisp-VAX [19, page 29]. 5 Smalltalk implementations sometimes represent values with an extra level of indirection between the object pointer and the block.
Reference: [16] <author> Atsushi Nagasaka, Yoshihiro Shintani, and Tanji Ito. </author> <title> "Tachyon Common Lisp: An efficient and portable implementation of CLtL2". </title> <booktitle> In Proceedings of the 1992 ACM Conference on LIsp and Functional Programming, </booktitle> <pages> pages 270-276, </pages> <address> San Francisco CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Since all values need two words anyway, the Monaco system loses nothing by allocating all values on two word boundaries, so they can use a 3-bit tagging scheme with no need to shift pointer values. Some Lisp implementations (for example <ref> [16] </ref>) enforce a two word allocation boundary for this reason even though it wastes some space. Instead of enforcing new alignment restrictions, an alternative is to just represent a few pointer types without shifting, and to shift the rest (see section 2.4).
Reference: [17] <author> Michael O. </author> <title> Newton. "A high performance implementation of Prolog". </title> <type> Technical Report 5234:TR:86, </type> <institution> Computer Science Department, California Institute of Technology, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: In contrast, the sign bit can often be tested in one or two cycles. This suggests the possibility of using the sign bit in a staged tagging scheme where one data type could be given a tag based on the sign bit <ref> [17] </ref>. For example, if the staged tag fields are in the high end of the word, cons cells might be given the 1-bit tag 0b0 in the highest bit, and all other types would be assigned 4-bit tags of the form 0b1xyz.
Reference: [18] <author> Stan Shebs and Robert Kessler. </author> <title> "Automatic design and implementation of language datatypes". </title> <booktitle> In Proceedings of the SIGPLAN '87 Symposium on Interpreters and Interpretative Techniques, </booktitle> <pages> pages 26-37, </pages> <address> St. Paul, Minnesota, 1987. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Of course the number of representations is exponential in several parameters, so asking for an optimal scheme is probably not reasonable. There has been a program written <ref> [19, 18] </ref> that actually implements a great deal of this suggestion for a subset of the possible representations ([19] contains an excelent summary of data representations used in many language systems).
Reference: [19] <author> Stanly T. Shebs. </author> <title> "Implementing primitive datatypes for higher-level languages". </title> <type> Technical Report UUCS-88-020, </type> <institution> University of Utah, </institution> <year> 1988. </year>
Reference-contexts: So, since (16i + t int) + 2t int = 16 (i) + t int negation can be implemented by #define ti_neg (i) -i + 2*t_int 9 as mentioned in <ref> [19] </ref>. <p> The standard basically allows these codes to be used for anything, so they can be used to encode non-float values in a tagged-word scheme where all values except floats have 0xFF in bits one through eight of a 32-bit word <ref> [19, page 96] </ref>. This restricts other data types to 24-bit representations, but it allows full IEEE floating point compliance. For example, 0b011111111 can be used as a 9 bit tag in the high end for a non-zero object pointer (see section 7.1), and 0b111111111 can be used to tag integers. <p> Wrapping a pointer to a block is done by assigning a type code to the correct field in the block that the pointer references #define wrap_T (p) p-&gt;type_code = t_T 4 For example, MacLisp [15] and [5, pp 31-33]; Franz Lisp [5, pp 51-53]; Interlisp-VAX <ref> [19, page 29] </ref>. 5 Smalltalk implementations sometimes represent values with an extra level of indirection between the object pointer and the block. <p> Of course the number of representations is exponential in several parameters, so asking for an optimal scheme is probably not reasonable. There has been a program written <ref> [19, 18] </ref> that actually implements a great deal of this suggestion for a subset of the possible representations ([19] contains an excelent summary of data representations used in many language systems).
Reference: [20] <author> Peter Steenkiste and John Hennessy. </author> <title> "Tags and type checking in LISP: hardware and software approaches". </title> <booktitle> In Proceedings of the Second International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 50-59. </pages> <publisher> Computer Society Press of the IEEE, </publisher> <month> October </month> <year> 1987. </year>
Reference-contexts: From tables 1, 2 and 3 it appears that there is a noticeable advantage to tagging values in the low end of the word rather than the high end. 2.3.3 Testing After the Operation It has been suggested <ref> [20] </ref> that addition of tagged integers can be improved by using an integer tag such that when two tagged integers are added directly, the result is the correctly tagged integer result of the operation (tagging integers by sign extension or by all zeros in the low end) and choosing the other
Reference: [21] <author> Paul Tarau. </author> <title> personal communication about his implementation of BinProlog. </title> <month> April </month> <year> 1993. </year>
Reference-contexts: This representation has been used in a relatively pure form in Smalltalk 5 [3, 6], Prolog <ref> [21] </ref>, and functional languages [14]. Although the word "object" has a special meaning in some other contexts, it is used here to mean simply a block with a structure that contains enough information to identify what type of value the block represents (and how it represents that value).
Reference: [22] <author> Kenneth Walker. </author> <title> "The implementation of an optimizing compiler for Icon". </title> <type> Technical Report TR 91-16, </type> <institution> Department of Computer Science, The University of Arizona, </institution> <month> August </month> <year> 1991. </year> <month> 38 </month>
Reference-contexts: The implementations of Icon described in [8] and <ref> [22] </ref> both represent dynamically-typed data in such pairs (with some extra information in the type word).
References-found: 22

