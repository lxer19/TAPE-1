URL: http://www.cs.indiana.edu/l/www/ftp/chaynes/sspace.ps.Z
Refering-URL: http://www.cs.indiana.edu/l/www/ftp/chaynes/
Root-URL: http://www.cs.indiana.edu
Title: Maintaining Dynamic State: Deep, Shallow, and Parallel  
Author: Christopher T. Haynes Richard M. Salter 
Address: 2  
Affiliation: Indiana University  Oberlin College  
Abstract: In the presence of first-class continuations, shallow maintenance of dynamic bindings requires more than the traditional stack-based techniques. This paper provides correctness criteria for such dynamic environments, along with contrasting implementations. A store semantics provides the framework for our correctness criteria and presentation of deep- and shallow-binding implementations. The latter implementation is a new state-space algorithm, which is proved correct. A variation of the algorithm implements Scheme's dynamic-wind operation. Finally, a technique for maintaining dynamic state called semi-shallow binding is presented. This compromise between deep- and shallow-binding appears suitable for parallel systems. Applications include fluid binding of lexical variables and logic programming with first-class continuations.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. G. Baker Jr. </author> <title> Shallow binding in Lisp 1.5. </title> <journal> Comm. ACM, </journal> <volume> 21(7) </volume> <pages> 565-569, </pages> <month> July </month> <year> 1978. </year> <month> 14 </month>
Reference-contexts: Shallow binding yields more efficient lookup, but in the presence of first-class continuations, stack-based techniques cannot be used. State-spaces have traditionally been used to maintain shallow bindings when control is abruptly transferred to prior contexts by the invocation of first-class continuations <ref> [1, 4] </ref>. A state-space algorithm, simpler than those previously reported, is presented and proved correct in our formal context. A generalization of the state-space algorithm that implements the dynamic-wind operation of Scheme is also provided.
Reference: [2] <editor> W. Clinger and J. Rees (editors). </editor> <title> Revised 4 report on the algorithmic language scheme. </title> <journal> Lisp Pointers, </journal> <volume> 4(3) </volume> <pages> 1-55, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Dynamic state-management is required in many situations. Usually dynamic contexts are associated with control contexts, as with dynamic variables, "fluid" assignment to lexical variables [3], and the dynamic-wind operation <ref> [2] </ref>. Logic variable binding is an example of dynamic state-maintenance that is not strictly associated with control (return with success does not undo bindings). In this paper we address the problem of maintaining multiple dynamic contexts when their extent is not limited by a first-in-last-out discipline. <p> To fulfill both of these needs, Scheme supports a dynamic-wind procedure that generalizes unwind-protect by allowing both a prelude and a postlude to be associated with the dynamic context in which a given body is evaluated <ref> [2] </ref>. Its arguments are nullary procedures that are invoked to perform the prelude, body, and postlude operations, respectively. Using dynamic-wind it is straightforward to support dynamic binding of lexical variables, as with the fluid-let form [3].
Reference: [3] <author> R. K. Dybvig. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Dynamic state-management is required in many situations. Usually dynamic contexts are associated with control contexts, as with dynamic variables, "fluid" assignment to lexical variables <ref> [3] </ref>, and the dynamic-wind operation [2]. Logic variable binding is an example of dynamic state-maintenance that is not strictly associated with control (return with success does not undo bindings). <p> Its arguments are nullary procedures that are invoked to perform the prelude, body, and postlude operations, respectively. Using dynamic-wind it is straightforward to support dynamic binding of lexical variables, as with the fluid-let form <ref> [3] </ref>. The dynamic-wind procedure may be defined in Scheme using a state space that is similar in concept to that which supports the lookup and update operations of Section 2.
Reference: [4] <author> C. Hanson and J. Lamping. </author> <title> Dynamic binding in Scheme. </title> <type> Unpublished manuscript, </type> <year> 1984. </year>
Reference-contexts: Shallow binding yields more efficient lookup, but in the presence of first-class continuations, stack-based techniques cannot be used. State-spaces have traditionally been used to maintain shallow bindings when control is abruptly transferred to prior contexts by the invocation of first-class continuations <ref> [1, 4] </ref>. A state-space algorithm, simpler than those previously reported, is presented and proved correct in our formal context. A generalization of the state-space algorithm that implements the dynamic-wind operation of Scheme is also provided.
Reference: [5] <author> R. P. Jones and R. M. Salter. </author> <title> Implementing nondeterminism using graph reduction. </title> <type> Technical report, </type> <institution> Oberlin College, </institution> <year> 1993. </year>
Reference-contexts: A new node with a box containing 7 is then attached to the new edge. Semi-shallow binding has been used in the implementation of a graph-rewrite system for logic programming <ref> [5] </ref>. Preliminary analysis indicates that semi-shallow binding may reasonably be adapted to parallel computation systems without shared memory. Since context trees and the context structure are monotonic (modified only via extension), coherence problems are avoided.
Reference: [6] <author> F. C. N. Pereira. </author> <title> A structure-sharing representation for unification-based grammar formalism. </title> <booktitle> In Proc. of the 23rd Annual Meeting of the Assoc. for Comp. Linguistics, </booktitle> <pages> pages 137-144, </pages> <year> 1985. </year>
Reference-contexts: Context trees are typically sparse, frequently containing chains of nodes without values. Such chains may be path compressed to a single edge labeled by the corresponding path. Pereira's virtual copy arrays are another example of a tree structure dedicated to bindings of a single variable <ref> [6] </ref>. Our context trees differ in that our trees may have compressed paths and values at interior nodes. but restricted to the variable x. Each box contains a binding for x in the environment represented by its node, while unboxed numbers annotate the path.
Reference: [7] <author> R. Salter and C. T. Haynes. </author> <title> Continuation-based control operators for logic programming. </title> <type> Technical Report 293, </type> <institution> Indiana University, </institution> <year> 1989. </year>
Reference-contexts: For example, in implementing a variant of Prolog that supports first-class success and failure continuations we have used the first state-space algorithm presented here to maintain two separate state spaces: one maintaining logic variable bindings and the other providing dynamic protection against database mutation <ref> [7] </ref>. We believe our second implementation technique, based on context paths, may provide an attractive approach to the maintenance of multiple environments in highly-parallel logic programming systems, though experience is needed to explore the system parameters within which this may be the technique of choice.
Reference: [8] <author> D. A. Schmidt. </author> <title> Detecting global variables in denotational definitions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(2) </volume> <pages> 299-310, </pages> <month> April </month> <year> 1985. </year>
Reference-contexts: This preserves the single-threadedness <ref> [8] </ref> of the store, and reflects efficient implementation. The procedure update takes an identifier, x, and a location continuation and returns a value continuation. The value continuation is invoked with a value, v, the current location, l, and the current state, s.
Reference: [9] <author> G. L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year> <month> 15 </month>
Reference-contexts: Control may leave either by normal control flow or through an escaping mechanism, such as a throw to a Lisp catch tag, a C long-jump, an ML exception, or a Scheme continuation. Lisp systems often provide an unwind-protect mechanism for this purpose <ref> [9] </ref>.
References-found: 9

