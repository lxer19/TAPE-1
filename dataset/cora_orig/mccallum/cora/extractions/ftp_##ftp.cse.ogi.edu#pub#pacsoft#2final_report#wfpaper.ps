URL: ftp://ftp.cse.ogi.edu/pub/pacsoft/2final_report/wfpaper.ps
Refering-URL: http://www.cse.ogi.edu/PacSoft/projects/SDRR/p2_report.html
Root-URL: http://www.cse.ogi.edu
Title: Warm Fusion for the Masses: Detailing Virtual Data Structure Elimination in Fully Recursive Languages  
Author: Patricia Johann John Launchbury 
Date: June 22, 1998  
Abstract: In functional programming, small programs are often combined to construct larger, more complex ones. The component reuse encouraged by this modular style of programming yields many benefits, but, unfortunately, modular programs also tend to be less efficient than their monolithic counterparts. Inefficiency is significantly attributable to the construction of intermediate data structures which "glue" together smaller program components into larger ones. Fusion is the process of removing intermediate data structures from modularly constructed programs. Two particularly successful approaches to achieving fusion in functional languages have emerged in recent years. The first is a catamorphic fusion technique based on the promotion theorems of category theory, while the second is a shortcut based on parametricity which fuses compositional programs via canned applications of traditional fold/unfold program transformation steps. Both techniques apply only to programs written in terms of certain special language constructs, but each contributes significantly to the elimination of intermediate data structures in such programs. Warm fusion combines catamorphic fusion and the shortcut to arrive at a two-step method for preparing various components in program compositions | each of which may be written not in some highly stylized form, but instead in the common recursive style | for one-step inter-functional fusion via the shortcut. In essence, catamorphic fusion is used to "preprocess" programs into compositions to which the shortcut applies. The purpose of this paper is two-fold. Its primary purpose is to report on a prototype implementation of the warm fusion, together with the maturing of ideas from [LS95] its construction has entailed. Discussion of the prototype provides an ideal opportunity to give a detailed and self-contained treatment of the entire warm fusion method, however, and so the prototype and its properties are investigated within this broader context; in particular, the evolution of the warm fusion method is traced from early work in program transformation. The discussion here builds on the original presentation of warm fusion by Launchbury and Sheard, and resolves a number of outstanding issues from their 1995 paper. Warm fusion is presented here in the context of a fully polymorphic higher-order language, in which the role played by type information | which is essential in eliminating from programs intermediate data structures other than lists | can be made precise. Considerable effort is taken throughout this paper to place all aspects of the warm fusion method on a secure logical foundation.
Abstract-found: 1
Intro-found: 1
Reference: [Amt92] <author> T. Amtoft. </author> <title> Unfold/Fold Transformations Preserving Termination Properties. </title> <booktitle> In Proceedings, Programming Language Implementation and Logic Programming, </booktitle> <publisher> LNCS 631, Springer-Verlag, </publisher> <pages> pp. 187 - 201, </pages> <year> 1992. </year>
Reference: [Bar92] <author> H.P. Barendregt. </author> <title> Lambda Calculi with Types. </title> <booktitle> In Handbook of Logic in Computer Science, </booktitle> <volume> Volume 2, </volume> <publisher> Oxford University Press, </publisher> <pages> pp. 117 - 309, </pages> <year> 1992. </year> <note> Draft, June 22, 1998 50 </note>
Reference-contexts: Terms other than data constructors and those constructed using cata, build, and case comprise a polymorphic lambda calculus with (in this case, two distinguished sets of) constants. The computational intuition underlying the polymorphic lambda calculus has been discussed at length elsewhere (see, e.g., <ref> [Bar92] </ref> or [Gir89]), and the intuition behind, as well as the typing rule for, terms constructed using case should be self-explanatory.
Reference: [BD77] <author> R. M. Burstall and J. Darlington. </author> <title> A Transformation System for Developing Recursive Programs. </title> <editor> J. </editor> <booktitle> ACM 24:1 (1977), </booktitle> <pages> pp. 44 - 67. </pages>
Reference: [CGW89] <author> T. Coquand, C. Gunter, and G. Winskel. </author> <title> Domain Theoretic Models of Polymorphism. </title> <booktitle> Information and Computation 81 (1989), </booktitle> <pages> pp. 123 - 167. </pages>
Reference: [Fok92] <author> M. Fokkinga. </author> <title> Law and Order in Algorithmics. </title> <type> Dissertation, </type> <institution> Universiteit Twente, </institution> <year> 1992. </year>
Reference: [Fre90] <author> P. Freyd. </author> <title> Recursive Types Reduced to Inductive Types. </title> <booktitle> In Proceedings, IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pp. 498 - 507, </pages> <year> 1990. </year>
Reference: [FW88] <author> A. Ferguson and P. Wadler. </author> <title> When Will Deforestation Stop? In Proceedings, </title> <booktitle> Glasgow Workshop on Functional Programming, </booktitle> <pages> pp. 39 - 56, </pages> <year> 1988. </year>
Reference: [Gil96] <author> A. Gill. </author> <title> Cheap Deforestation for Non-strict Functional Languages. </title> <type> Dissertation, </type> <institution> Department of Computing Science, Glasgow University, </institution> <year> 1996. </year>
Reference-contexts: introduction of build is similarly proscribed in our prototype warm fusion engine. Some of the issues raised by the incorporation of the cata-build rule into GHC are mentioned briefly in Section 4.3, and the topic is discussed quite thoroughly in <ref> [Gil96] </ref>. There are instances of cata and build for algebraic datatypes other than lists, and results analogous to the ones described in this section do indeed hold for them. <p> The significance of the theorem derives primarily from the facts that most of the types used in functional programming are regular, and that many functions of interest are expressible as catamorphisms over them. 4.3 An Implementation of the Shortcut In the dissertation <ref> [Gil96] </ref>, Gill details his implementation of the shortcut to deforestation described in Section 2.4, and assesses its performance on a suite of real application programs ([Par92]). This implementation includes a translation scheme for list comprehensions which guarantees that intermediate lists between them and their producers and consumers are eliminated.
Reference: [Gir71] <author> J.-Y. Girard. </author> <title> Une Extension de l'Interpretation de Godel a l'Analyse, et son Application a l' Elimination des coupures dans l'Analyse et la Theorie des Types. </title> <booktitle> In Proceedings, Second Scandinavian Logic Symposium, </booktitle> <pages> pp. 63 - 92, </pages> <year> 1971. </year>
Reference: [Gir89] <author> J.-Y. Girard. </author> <title> Proofs and Types. </title> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: Terms other than data constructors and those constructed using cata, build, and case comprise a polymorphic lambda calculus with (in this case, two distinguished sets of) constants. The computational intuition underlying the polymorphic lambda calculus has been discussed at length elsewhere (see, e.g., [Bar92] or <ref> [Gir89] </ref>), and the intuition behind, as well as the typing rule for, terms constructed using case should be self-explanatory.
Reference: [GLPJ93] <author> A. Gill, J. Launchbury, and S. Peyton Jones. </author> <title> A Shortcut to Deforestation. </title> <booktitle> In Proceedings, Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp. 223 - 232, </pages> <year> 1993. </year>
Reference-contexts: Doing this turns out to require the expressivity of a fully polymorphic higher-order language. In the next section, we describe how the warm fusion method builds upon Sheard and Fegaras' normalization algorithm and the shortcut of <ref> [GLPJ93] </ref> to provide a virtual data structure elimination method for programs expressing certain recursively defined higher-order polymorphic functions. Particular care is taken to put the warm fusion method on a theoretical foundation secure enough to support its implementation. <p> In the second phase, build-cata forms resulting from the first phase are assembled into compositions corresponding to the original ones, and these then undergo fusion via the cata-build rule from <ref> [GLPJ93] </ref>. This two-step approach to program fusion can be seen as bringing together the algebraic strand and the recursion equation strand of previous methods. <p> In fact, it seems rather remarkable that techniques for eliminating virtual data structures from catamorphic programs can be used to achieve the same for many programs in languages which express recursion equationally as well. Like the normalization algorithm of Sheard and Fegaras and the shortcut of <ref> [GLPJ93] </ref>, warm fusion is calculation-based rather than search-based, and so at no time in the warm fusion process must arbitrary patterns of recursive calls be spotted.
Reference: [GS96] <author> R. Gluck and M. H. Sorensen. </author> <title> A Roadmap to Metacomputation by Supercompilation. In Partial Evaluation, </title> <publisher> LNCS 1110, Springer-Verlag, </publisher> <pages> pp. 137 - 160, </pages> <year> 1996. </year>
Reference-contexts: Modulo the issue of termination, driving thus completely subsumes deforestation. Partial evaluation also performs program specialization, which can be seen as a special case of deforestation, and hence of positive supercompilation. The connections between fold/unfold methodologies and partial evaluation are explored in Chapter 17 of [JGS93]. The recent paper <ref> [GS96] </ref> is a nice exposition of the ideas underlying Turchin's work; [SGJ94] compares and classifies four important instances of the fold/unfold program transformation methodology of Burstall and Darlington, namely program fusion, partial evaluation, supercompilation, and generalized partial computation. 4.2 The Squiggol School and Calculation-based Programming In the middle 1980's and early
Reference: [Hag87] <author> T. Hagino. </author> <title> A Categorical Programming Language. </title> <type> Dissertation, </type> <institution> University of Edinburgh, </institution> <year> 1987. </year>
Reference: [Hug89] <author> J. Hughes. </author> <title> Why Functional Programming Matters. </title> <journal> The Computer Journal 32:2 (1989), </journal> <pages> pp. 98 - 107. </pages>
Reference: [Jeu93] <author> J. Jeuring. </author> <title> Theories for Algorithm Calculation. </title> <type> Dissertation, </type> <institution> Universiteit Utrecht, </institution> <year> 1993. </year>
Reference: [JGS93] <author> N. Jones, C. Gomard, and P. Sestoft. </author> <title> Partial Evaluation and Automatic Program Generation. </title> <publisher> Prentice-Hall, </publisher> <year> 1993. </year>
Reference-contexts: Modulo the issue of termination, driving thus completely subsumes deforestation. Partial evaluation also performs program specialization, which can be seen as a special case of deforestation, and hence of positive supercompilation. The connections between fold/unfold methodologies and partial evaluation are explored in Chapter 17 of <ref> [JGS93] </ref>.
Reference: [Joh94] <author> T. Johnsson. </author> <title> Fold-unfold Transformations on State Monadic Transformers. </title> <booktitle> In Proceedings, Glasgow Functional Programming Workshop, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 127 - 140, </pages> <year> 1994. </year>
Reference-contexts: While Proebsting and Watterson's approach to the fusion problem for stateful computation is ad hoc, an axiomatic treatment for such computations can be found in <ref> [Joh94] </ref>. Johnsson uses manual fold/unfold transformations over stateful interpreters to achieve efficient compilation. <p> Whether or not this is always, or even often, a win remains to be discerned. Draft, June 22, 1998 49 3. Extensions All existing fusion methods | as well as the theoretical work underlying them | restrict attention to programs written in pure functional languages. Recent research ([Lau95], <ref> [Joh94] </ref>) suggests that fusion techniques can be extended to functional programs written in monadic style, especially to those written using the monad of state. This in turn suggests that build-cata fusion can be lifted to imperative programs.
Reference: [Lau95] <author> J. Launchbury. </author> <title> Graph Algorithms with a Functional Flavor. </title> <booktitle> In Proceedings, First International Spring School on Advanced Functional Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 308 - 331, </pages> <year> 1995. </year>
Reference: [LS95] <author> J. Launchbury and T. Sheard. </author> <title> Warm Fusion: Deriving Build-Catas from Recursive Definitions. </title> <booktitle> In Proceedings, Conference on Functional Languages and Computer Architecture, </booktitle> <pages> pp. 314 - 323, </pages> <year> 1995. </year>
Reference-contexts: But, as pointed out in <ref> [LS95] </ref>, it is often possible to take advantage of having already transformed into build-cata form definitions of functions called by programs currently being processed. <p> This is essentially the first approach to fusion described on page 320 of <ref> [LS95] </ref>. On the other hand, body can be fused with the copy function via the Promotion Theorem to arrive at a new catamorphism, with which the outermost cata in the composition can in turn be fused. This is essentially the second approach to fusion described on page 320 of [LS95]. <p> of <ref> [LS95] </ref>. On the other hand, body can be fused with the copy function via the Promotion Theorem to arrive at a new catamorphism, with which the outermost cata in the composition can in turn be fused. This is essentially the second approach to fusion described on page 320 of [LS95]. Launchbury and Sheard report that although the fusion steps in the second approach sometimes fails, it seems to yield better resulting programs when it succeeds. By contrast, the second approach seems to be more robust than the first. <p> On many common examples, however, both methods are reportedly completely equivalent, in the sense that they both succeed and produce the same build-cata form. The first method requires only first-order fusion, but the second method typically involves higher-order fusion (described in <ref> [LS95] </ref>), which is undoubtedly more difficult to implement. For this reason, we have chosen initially to implement only the first method for producing a catamorphic argument to the introduced build. <p> For the prototype implementation of warm fusion reported on here, we actually restrict successful virtual data structure elimination to a smaller class of first-order-fusable programs than permitted in <ref> [LS95] </ref>. This is done by accepting for non-trivial transformation only programs of a particular syntactic form; fortunately, this form is general enough to accommodate many programs of interest, including those defined by of pattern matching on their arguments. <p> A technique similar to the worker-wrapper method for data structure production can be used to propagate from a program's definition to its call sites information about the way in which it processes its arguments, but this is explored neither in <ref> [LS95] </ref> nor in our implementation. <p> This problem Draft, June 22, 1998 18 is not addressed in <ref> [LS95] </ref>, and it is not even clear whether or not the code degradation is sufficiently great to deserve attention. <p> Of course, the term variable v need not appear in e. Mutually recursive declarations are not permitted. The language we describe here differs from that presented in <ref> [LS95] </ref>. One superficial difference is that we permit tuples at neither the type nor the term level, preferring instead to pass bundled arguments as lists. More significantly, the polymorphism of the expression language of [LS95] is not made explicit. <p> The language we describe here differs from that presented in <ref> [LS95] </ref>. One superficial difference is that we permit tuples at neither the type nor the term level, preferring instead to pass bundled arguments as lists. More significantly, the polymorphism of the expression language of [LS95] is not made explicit. <p> The -reduction rule for the polymorphic lambda calculus is not explicitly included in the calculus of <ref> [LS95] </ref>, but repeated use of the rule is, in fact, made throughout that paper. We therefore include it explicitly in R. The fi-reduction rule for types is also not present in calculus of [LS95] although certainly this was intended. <p> The -reduction rule for the polymorphic lambda calculus is not explicitly included in the calculus of <ref> [LS95] </ref>, but repeated use of the rule is, in fact, made throughout that paper. We therefore include it explicitly in R. The fi-reduction rule for types is also not present in calculus of [LS95] although certainly this was intended. <p> Moreover, since we have not implemented higher-order catamorphic fusion, our implementation achieves only the first warm fusion method from <ref> [LS95] </ref>, as explained in Section 3.1 of this paper. <p> Composing, on the left, the program being processed with the build-cata representation of an appropriate identity function. This is achieved by introducing a build-cata pair according to the following specification, which extends that in <ref> [LS95] </ref> to accommodate explicit polymor Draft, June 22, 1998 31 phism.
Reference: [Mal89] <author> G. Malcolm. </author> <title> Homomorphisms and Promotability. In Mathematics of Program Construction, </title> <publisher> LNCS 375, Springer-Verlag, </publisher> <pages> pp. 335 - 347, </pages> <year> 1989. </year>
Reference: [Mar95] <author> S. Marlow. </author> <title> Deforestation for Higher-order Functional Programs. </title> <type> Dissertation, </type> <institution> University of Glasgow, </institution> <year> 1995. </year>
Reference: [Mee86] <author> L. Meertens. </author> <title> Algorithmics Towards Programming as a Mathematical Activity. </title> <booktitle> In Proceedings of the CWI Symposium on Mathematics and Computer Science, </booktitle> <pages> pp. 289 - 334, </pages> <year> 1986. </year> <note> Draft, June 22, 1998 51 </note>
Reference-contexts: The calculational style of programming, first introduced by Bird and Meertens ([Bir97], <ref> [Mee86] </ref>, [Mee92], stresses calculating programs via algebraic identities over list programs in much the same manner that high school students calculate with the laws of algebra. Inherent in the calculational style are techniques for transforming clear but inefficient programs into ones which use resources efficiently.
Reference: [Mee92] <author> L. Meertens. Paramorphisms. </author> <booktitle> Formal Aspects of Computing 4:5 (1992), </booktitle> <pages> pp. 413 - 424. </pages>
Reference-contexts: The calculational style of programming, first introduced by Bird and Meertens ([Bir97], [Mee86], <ref> [Mee92] </ref>, stresses calculating programs via algebraic identities over list programs in much the same manner that high school students calculate with the laws of algebra. Inherent in the calculational style are techniques for transforming clear but inefficient programs into ones which use resources efficiently.
Reference: [Mei92] <author> E. Meijer. </author> <title> Calculating Compilers. </title> <type> Dissertation, </type> <institution> Universiteit Nijmegen, </institution> <year> 1992. </year>
Reference: [MH95] <author> E. Meijer and G. Hutton. </author> <title> Bananas in Space: Extending Fold and Unfold to Exponential Types. </title> <booktitle> in Proceedings, Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp. 324 - 333, </pages> <year> 1995. </year>
Reference: [Par92] <author> W. Partain. </author> <title> The nofib Benchmarking Suite. </title> <booktitle> In Proceedings, Glasgow Workshop on Functional Programming, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 195 - 202, </pages> <year> 1992. </year>
Reference: [PJL91] <author> S. Peyton Jones and J. Launchbury. </author> <title> Unboxed Values as First-class Citizens in a Non-strict Functional Language. </title> <booktitle> In Proceedings, Functional Programming and Computer Architecture, </booktitle> <publisher> LNCS 523, Springer-Verlag, </publisher> <pages> pp. 636 - 666, </pages> <year> 1991. </year>
Reference: [PW96] <author> T. Proebsting and S. Watterson. </author> <title> Filter Fusion. </title> <booktitle> In Proceedings, ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 119 - 130, </pages> <year> 1996. </year>
Reference: [Rey74] <author> J. Reynolds. </author> <title> Towards Theory of Type Structure. </title> <booktitle> In Proceedings, Paris Colloquium on Programming, </booktitle> <publisher> LNCS 19, Springer-Verlag, </publisher> <pages> pp. 408 - 425, </pages> <year> 1974. </year>
Reference-contexts: One approach to investigating the termination and confluence of WF is to first embed the warm fusion calculus in the polymormphic lambda calculus ([Gir71], <ref> [Rey74] </ref>), and then try to extend known results about adding first- and higher-order rewriting to various lambda calculi to the special case of higher-order polymorphic rewriting that WF represents.
Reference: [Rey83] <author> J. Reynolds. </author> <title> Types, Abstraction, and Parametric Polymorphism. </title> <booktitle> In Proceedings, Information Processing, </booktitle> <pages> pp. 513 - 523, </pages> <year> 1983. </year>
Reference: [San94] <author> D. Sands. </author> <title> Total Correctness and Improvement in the Transformation of Functional Programs. </title> <type> Unpublished manuscript, </type> <institution> DIKU, University of Copenhagen, </institution> <year> 1994. </year>
Reference: [Sch86] <author> D.A. Schmidt. </author> <title> Denotational Semantics, Wm. </title> <editor> C. Brown, </editor> <year> 1986. </year>
Reference: [SF93] <author> T. Sheard and L. Fegaras. </author> <title> A Fold for All Seasons. </title> <booktitle> In Proceedings, Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp. 233 - 242, </pages> <year> 1993. </year>
Reference: [SGJ94] <author> M. H. Sorensen, R. Gluck, and N. D. Jones. </author> <title> Toward Unifying Partial Evaluation, Deforestation, Supercompilation, </title> <booktitle> and GPC. In Proceedings, European Symposium on Programming, </booktitle> <publisher> LNCS 788, Springer-Verlag, </publisher> <pages> pp. 485 - 500, </pages> <year> 1994. </year>
Reference-contexts: The connections between fold/unfold methodologies and partial evaluation are explored in Chapter 17 of [JGS93]. The recent paper [GS96] is a nice exposition of the ideas underlying Turchin's work; <ref> [SGJ94] </ref> compares and classifies four important instances of the fold/unfold program transformation methodology of Burstall and Darlington, namely program fusion, partial evaluation, supercompilation, and generalized partial computation. 4.2 The Squiggol School and Calculation-based Programming In the middle 1980's and early 1990's, a new style of programming that would later heavily influence
Reference: [TM95] <author> A. Takano and E. Meijer. </author> <title> Shortcut Deforestation in Calculational Form. </title> <booktitle> In Proceedings, Conference on Functional Programming and Computer Architecture, </booktitle> <address> p. </address> , <year> 1995. </year>
Reference: [Tur86] <author> V. F. Turchin. </author> <title> The Concept of a Supercompiler. </title> <journal> ACM Transactions on Programming Languages and Systems 8:3 (1986), </journal> <pages> pp. 90 - 121. </pages>
Reference: [Wad83] <author> P. Wadler. </author> <title> Listlessness is Better than Laziness. </title> <type> Dissertation, </type> <institution> Department of Computer Science, Carnegie Mellon University, </institution> <year> 1983. </year>
Reference: [Wad86] <author> P. Wadler. </author> <title> Listlessness is Better than Laziness II: Composing Listless Functions. </title> <booktitle> In Proceedings, Workshop on Programs and Data Objects, </booktitle> <publisher> LNCS 217, Springer-Verlag, </publisher> <pages> pp. 282 - 305, </pages> <year> 1985. </year>
Reference: [Wad89] <author> P. Wadler. </author> <title> Theorems for Free! In Proceedings, </title> <booktitle> Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp. 347 - 359, </pages> <year> 1989. </year>
Reference: [Wad90] <author> P. Wadler. </author> <title> Deforestation: Transforming Programs to Eliminate Trees. </title> <booktitle> Theoretical Computer Science 73 (1990), </booktitle> <pages> pp. 231 - 248. </pages>
Reference: [Wat87] <author> R.C. Waters. </author> <title> Obviously Synchronizable Series Expressions: Part I; User's Manual for the OSS Macro Package. </title> <type> Technical report, </type> <institution> Artificial Intelligence Laboratory, Massachusetts Institute of Technology, </institution> <year> 1987. </year>
Reference: [Wat91] <author> R. Waters. </author> <title> Automatic Transformation of Series Expressions into Loops. </title> <journal> Transactions on Programming Languages and Systems 13:1 (1991), </journal> <pages> pp. 52 - 98. </pages>
References-found: 42

