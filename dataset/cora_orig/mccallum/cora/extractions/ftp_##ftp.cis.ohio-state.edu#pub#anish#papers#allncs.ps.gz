URL: ftp://ftp.cis.ohio-state.edu/pub/anish/papers/allncs.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/~anish/pub.html
Root-URL: 
Email: anish@cis.ohio-state.edu  
Title: Efficient Reconfiguration of Trees: A Case Study in Methodical Design of Nonmasking Fault-Tolerant Programs  
Author: .em Anish Arora 
Keyword: Categories and Subject Descriptors C.2.4 [Computer Communication Systems] Distributed Systems D.1.3 [Programming Techniques] Concurrent Programming D.2.4 [Program Verification] Reliability D.2.10 [Program Design] Methodologies G.2.2 [Discrete Mathematics] Graph Algorithms  
Date: =1cm  
Address: Columbus, OH, USA 43210  
Affiliation: Department of Computer Science The Ohio State University  
Abstract: We illustrate a formal method for the design of nonmasking fault-tolerant programs, by demonstrating how the method enables us to effectively design a new and efficient program. Our program maintains the processes of any given distributed system in a spanning tree, tolerates any finite number of fail-stop failures and repairs of system processes and channels, and requires only O(n) time and O(n log n) space to reconfigure the tree, where n is the number of nonfaulty processes. The program is, moreover, simple and fully distributed. ? Research supported in part by NSF Grant CCR-9308640 and OSU Grant 221506. A preliminary version of this paper appears in the Proceedings of the Third International Symposium on Formal Techniques in Real Time and Fault Tolerant Systems, 1994 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Arora and M. G. Gouda, </author> <title> "Closure and convergence: A foundation of fault-tolerant computing". </title> <journal> IEEE Trans. on Soft. </journal> <volume> Engg. </volume> <month> 19(11) </month> <year> (1993) </year> <month> 1015-1027 </month>
Reference-contexts: Our experience suggests that these beliefs are invalid in many cases. We find that a method based on a formal definition of fault-tolerance <ref> [1] </ref> and a few structuring principles [1-2] suffices for the design of many non-masking fault-tolerant programs. <p> Hence, a fault-span predicate characterizes a set of states that includes the set of states characterized by the invariant. Like the invariant, a fault-span of p is, by definition, closed in p. 2.3 Fault-Tolerance We are now ready to give a formal definition of fault-tolerance <ref> [1] </ref>. Let p be a program, F be a set of fault actions, and S be the invariant of p. <p> The definition above enables a formal classification of masking and nonmasking fault-tolerance <ref> [1] </ref>. Let p be F -tolerant for S. If T , the fault-span, is S itself, we say that p is masking F -tolerant.
Reference: 2. <author> A. Arora, M. G. Gouda, and G. Varghese, </author> <title> "Constraint satisfaction as a basis for designing nonmasking fault-tolerance". </title> <editor> J. </editor> <booktitle> High Speed Networks (1994 to appear); Proc. 14th Intl. Conf. on Distributed Computer Systems (1994) 424-431 </booktitle>
Reference-contexts: Several other sufficient conditions for verifying convergence have been suggested in the literature. Some of these are specifically for constraint-based design <ref> [2] </ref>. For our case study, we will recall only the simple Theorem: Let Q and R be closed state predicates of p.
Reference: 3. <author> E. W. Dijkstra, </author> <title> A Discipline of Programming, </title> <publisher> Prentice-Hall (1976) </publisher>
Reference-contexts: If p has an action whose guard is true if Q ^ :R holds and that establishes R, then Q converges to R in p. 2 * Standard approaches to designing Step 4 actions appear in <ref> [3, 4] </ref>. 4 The Case Study: Reconfiguration of Spanning Trees In this section, we employ the method discussed above to design a non-masking fault-tolerant program that satisfies the problem specification for reconfiguration of spanning trees. 4.1 Problem Specification Given is an undirected, connected graph that consists of M nodes named 1;
Reference: 4. <editor> D. Gries, </editor> <booktitle> The Science of Programming, </booktitle> <publisher> Springer-Verlag (1981) </publisher>
Reference-contexts: If p has an action whose guard is true if Q ^ :R holds and that establishes R, then Q converges to R in p. 2 * Standard approaches to designing Step 4 actions appear in <ref> [3, 4] </ref>. 4 The Case Study: Reconfiguration of Spanning Trees In this section, we employ the method discussed above to design a non-masking fault-tolerant program that satisfies the problem specification for reconfiguration of spanning trees. 4.1 Problem Specification Given is an undirected, connected graph that consists of M nodes named 1;
Reference: 5. <author> R. G. Gallagher, P. A. Humblet, and P. M. Spira, </author> <title> "A distributed algorithm for minimum-weight spanning trees". </title> <journal> ACM Trans. on Prog. Lang. and Sys. </journal> <month> 5(1) </month> <year> (1983) </year> <month> 66-77 </month>
Reference-contexts: Of these, a program by Gallagher et al <ref> [5] </ref> is especially notable, but it is fault-intolerant; i.e., it does not solve the spanning tree reconfiguration problem.
Reference: 6. <author> G. Varghese, </author> <title> "Self-stablization by local checking and correction". </title> <type> Ph.D. Dissertation, </type> <institution> Massachusetts Institute of Technology (1992) </institution>
Reference-contexts: Of these, a program by Gallagher et al [5] is especially notable, but it is fault-intolerant; i.e., it does not solve the spanning tree reconfiguration problem. More recently, stabilizing programs (i.e. nonmasking fault-tolerant programs whose T is the predicate true) for spanning tree reconfiguration have been presented <ref> [6, 7] </ref> that tolerate failures as well as repairs of both nodes and edges, but these programs are significantly more complex than RST, since they allow for the formation of transient cycles in the graph of the parent variables.
Reference: 7. <author> A. Arora and M. G. Gouda, </author> <title> "Distributed reset". </title> <journal> IEEE Trans. </journal> <note> on Computers 43(9) (1994) </note>
Reference-contexts: Of these, a program by Gallagher et al [5] is especially notable, but it is fault-intolerant; i.e., it does not solve the spanning tree reconfiguration problem. More recently, stabilizing programs (i.e. nonmasking fault-tolerant programs whose T is the predicate true) for spanning tree reconfiguration have been presented <ref> [6, 7] </ref> that tolerate failures as well as repairs of both nodes and edges, but these programs are significantly more complex than RST, since they allow for the formation of transient cycles in the graph of the parent variables. <p> Other programs we are aware of are at best tolerant only to the failures of edges or only the failures and repairs of nodes. We measure the time complexity of convergence of RST from T to S in terms of rounds <ref> [7] </ref>. A round is a minimal, nonempty sequence of program steps wherein for each up node there exists a step where the node either executes an action or has no actions whose guards are true before or after the step.
References-found: 7

