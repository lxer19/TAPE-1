URL: ftp://ftp.icsi.berkeley.edu/pub/techreports/1995/tr-95-016.ps.gz
Refering-URL: http://www.icsi.berkeley.edu/techreports/1995.html
Root-URL: http://www.icsi.berkeley.edu
Title: A Combined BIT and TIMESTAMP Algorithm for the List Update Problem  
Author: Susanne Albers, Bernhard von Stengel, Ralph Werchner 
Keyword: On-line algorithms, analysis of algorithms, competitive analysis, linear lists, list-update.  
Note: Email: falbers, stengel,  
Address: I 1947 Center St. Suite 600 Berkeley, California 94704-1198  
Affiliation: INTERNATIONAL COMPUTER SCIENCE INSTITUTE  
Pubnum: TR-95-016  
Email: werchnerg@icsi.berkeley.edu  
Phone: (510) 643-9153 FAX (510) 643-7684  
Date: April 27, 1995  
Abstract: A simple randomized on-line algorithm for the list update problem is presented that achieves a competitive factor of 1.6, the best known so far. The algorithm makes an initial random choice between two known algorithms that have different worst-case request sequences. The first is the BIT algorithm that, for each item in the list, alternates between moving it to the front of the list and leaving it at its place after it has been requested. The second is a TIMESTAMP algorithm that moves an item in front of less often requested items within the list. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Albers, </author> <title> Improved randomized on-line algorithms for the list update problem, </title> <booktitle> Proc. 6th Annual ACM-SIAM Symposium on Discrete Algorithms (1995) 412-419. </booktitle>
Reference-contexts: When the value of the bit changes to 1, the requested item is moved to the front of the list. Otherwise the position of the item remains unchanged. The second algorithm is an instance of the TIMESTAMP algorithm recently introduced by Albers <ref> [1] </ref>. Depending on a parameter p in [0; 1], this algorithm achieves a competitiveness of max f2 p; 1 + p (2 p)g. The optimal choice of p gives a - competitive algorithm, where = (1 + p 5)=2 1:62 is the Golden Ratio. <p> When the value of the bit changes to 1, the requested item is moved to the front of the list. Otherwise the position of the item remains unchanged. The second algorithm is an instance of the TIMESTAMP algorithm recently introduced by Albers [1]. Depending on a parameter p in <ref> [0; 1] </ref>, this algorithm achieves a competitiveness of max f2 p; 1 + p (2 p)g. The optimal choice of p gives a - competitive algorithm, where = (1 + p 5)=2 1:62 is the Golden Ratio. <p> We have used the fact that the worst-case request sequences for these algorithms are different. In a similar way, it is possible to construct other 1.6-competitive algorithms. For example, one can use the original TIMESTAMP algorithm <ref> [1] </ref> with different parameters p, determined by a random experiment: With probability 1=10, TIMESTAMP is used with p = 0 (corresponding to our algorithm TS ), with probability 1=15, it is used with p = 1 (yielding the deterministic MOVE-TO-FRONT rule), and with probability 5=6, it is used with p = <p> This means that an item is always moved to the front with probability 2=5, otherwise treated essentially as in algorithm TS (see <ref> [1] </ref> for a full description of TIMESTAMP when p is not 0 or 1). However, with probability 1=6 all items are treated in the same manner. This correlation reduces the competitive factor of the algorithm from the Golden Ratio (about 1.62) to 1.6.
Reference: [2] <author> S. Ben-David, A. Borodin, R. Karp, G. Tardos, and A. Wigderson, </author> <title> On the power of randomization in on-line algorithms, </title> <note> Algorithmica 11 (1994) 2-14. </note>
Reference-contexts: The smallest c with this property is called the competitive factor of the algorithm. The well-known MOVE-TO-FRONT rule is 2-competitive, which is optimal for deterministic algorithms [4, 6]. The performance of a randomized on-line algorithm A can be better, if it is evaluated against the oblivious adversary <ref> [2] </ref>. The oblivious adversary specifies a request sequence in advance and is not allowed to see the random choices made by the on-line algorithm A. Let E [A ()] denote the corresponding expected cost.
Reference: [3] <author> S. Irani, </author> <title> Two results on the list update problem, </title> <note> Information Processing Letters 38 (1991) 301-306. </note>
Reference-contexts: Algorithm COMB. With probability 4=5 the algorithm serves a request sequence using BIT , and with probability 1=5 it serves the sequence using TS . Theorem 1. The on-line algorithm COMB is 1.6-competitive. In the following, we will prove Theorem 1 using a well-known technique <ref> [3, 5] </ref> of analyzing separately the movement of any pair of items in the list. The algorithms BIT and TS permit such a pairwise analysis. 2.
Reference: [4] <author> R. Karp and P. Raghavan, </author> <title> Personal communication (1990), </title> <note> cited in [5]. </note>
Reference-contexts: The smallest c with this property is called the competitive factor of the algorithm. The well-known MOVE-TO-FRONT rule is 2-competitive, which is optimal for deterministic algorithms <ref> [4, 6] </ref>. The performance of a randomized on-line algorithm A can be better, if it is evaluated against the oblivious adversary [2]. The oblivious adversary specifies a request sequence in advance and is not allowed to see the random choices made by the on-line algorithm A.
Reference: [5] <author> N. Reingold, J. Westbrook, and D. D. Sleator, </author> <title> Randomized competitive algorithms for the list update problem, </title> <note> Algorithmica 11 (1994) 15-32. </note>
Reference-contexts: 1. Description of the algorithm The list update problem is one of the first on-line problems that have been studied with respect to competitiveness (see <ref> [5] </ref> and references). The problem is to maintain an unsorted list of items so that access costs are kept small. An initial list of items is given. A sequence of requests must be served in that order. A request specifies an item in the list. <p> We will combine two on-line algorithms for the list update problem that store with each item some information about past requests. Both algorithms use only free exchanges. The first is the 1.75-competitive BIT algorithm due to Reingold, Westbrook, and Sleator <ref> [5] </ref>. The algorithm maintains a bit for each item in the list. Initially, the bit is set at random to 0 or 1 with equal probability so that the bits of the items are pairwise independent. 1 Algorithm BIT. Each time an item is requested, its bit is complemented. <p> An item is treated in one of two ways (which can be determined once at the beginning by a random experiment, so that the algorithm is barely random, that is, it uses only a bounded number of random bits independent of the number of requests <ref> [5] </ref>). With probability p, the item is moved to the front of the list after it has been requested. With probability 1 p, it is treated in a different way. We use the TIMESTAMP algorithm with parameter p = 0, so that it is deterministic. <p> Algorithm COMB. With probability 4=5 the algorithm serves a request sequence using BIT , and with probability 1=5 it serves the sequence using TS . Theorem 1. The on-line algorithm COMB is 1.6-competitive. In the following, we will prove Theorem 1 using a well-known technique <ref> [3, 5] </ref> of analyzing separately the movement of any pair of items in the list. The algorithms BIT and TS permit such a pairwise analysis. 2.
Reference: [6] <author> D. D. Sleator and R. E. Tarjan, </author> <title> Amortized efficiency of list update and paging rules, </title> <booktitle> Communications of the ACM 28 (1985) 202-208. </booktitle>
Reference-contexts: The smallest c with this property is called the competitive factor of the algorithm. The well-known MOVE-TO-FRONT rule is 2-competitive, which is optimal for deterministic algorithms <ref> [4, 6] </ref>. The performance of a randomized on-line algorithm A can be better, if it is evaluated against the oblivious adversary [2]. The oblivious adversary specifies a request sequence in advance and is not allowed to see the random choices made by the on-line algorithm A.
Reference: [7] <author> B. Teia, </author> <title> A lower bound for randomized list update algorithms, </title> <note> Information Processing Letters 47 (1993) 5-9. </note>
Reference-contexts: Clearly, a c-competitive on-line algorithm for this `i 1' cost model is also c-competitive in the original model. With either cost model, it is known that no randomized on-line algorithm for the list update problem can be better than 1.5-competitive <ref> [7] </ref>. We will combine two on-line algorithms for the list update problem that store with each item some information about past requests. Both algorithms use only free exchanges. The first is the 1.75-competitive BIT algorithm due to Reingold, Westbrook, and Sleator [5]. <p> Conclusions We have presented a simple randomized on-line algorithm for the list update problem that has a competitive factor of 1.6. The best known lower bound for that factor is 1.5 <ref> [7] </ref>. The remaining gap is small, but the obvious open question is: what is the best possible competitive factor? Our algorithm uses two known algorithms that already have good competitive factors. We have used the fact that the worst-case request sequences for these algorithms are different.
Reference: [8] <author> A. C. Yao, </author> <title> Probabilistic computations: Towards a unified measure of complexity, </title> <booktitle> Proc. 18th Annual IEEE Symposium on Foundations of Computer Science (1977) 222-227. </booktitle>
Reference-contexts: If a randomizing adversary chooses yy with probability 3=5 and yxx with probability 2=5, then both BIT and TS have expected cost 1.6, or 1.6 times the cost of OPT . Thus, by Yao's Theorem <ref> [8] </ref> (or a simple direct argument), no randomized combination of BIT and TS can have cost less than 1.6 on both sequences (and their repetitions in longer sequences). 4. Conclusions We have presented a simple randomized on-line algorithm for the list update problem that has a competitive factor of 1.6.
References-found: 8

