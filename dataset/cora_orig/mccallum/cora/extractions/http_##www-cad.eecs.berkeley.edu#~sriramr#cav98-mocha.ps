URL: http://www-cad.eecs.berkeley.edu/~sriramr/cav98-mocha.ps
Refering-URL: http://www-cad.eecs.berkeley.edu/~sriramr/research.html
Root-URL: 
Email: Email: alur@cis.upenn.edu  Email: ftah,fmang,shaz,sriramr,serdarg@eecs.berkeley.edu  
Title: Mocha Modularity in Model Checking  
Author: R. Alur T. Henzinger F. Mang S. Qadeer S. Rajamani S. Tasiran 
Address: Philadelphia, PA 19104,  Murray Hill, NJ 07974.  Berkeley, CA 94720-1770.  
Affiliation: Computer Information Science, University of Pennsylvania,  and Computing Science Research Center, Bell Laboratories,  Electrical Engineering Computer Sciences, University of California,  
Abstract: We describe a new interactive verification environment called Mocha for modular verification of heterogeneous systems. Mocha differs from existing model checkers in three important ways. First, instead of manipulating unstructured state-transition graphs, it supports the heterogeneous modeling framework of Reactive Modules. Second, instead of traditional temporal logics such as CTL, it uses Alternating Temporal Logic (ATL), a temporal logic that is designed to specify collaborative as well as adversarial interactions between different components. Third, to support hierarchical design and verification, it combines model checking with automated refinement checking. The specific implementation features reported in this paper include game simulation, ATL model checking, compositional refinement checking, and real-time verification. We illustrate the features via a simple railroad controller and a simple public-key encryption protocol. 
Abstract-found: 1
Intro-found: 1
Reference: [AH96] <author> R. Alur and T.A. Henzinger. </author> <title> Reactive modules. </title> <booktitle> In Proceedings of the 11th IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 207-218, </pages> <year> 1996. </year>
Reference-contexts: As a possible solution, we propose the following methodology for open model checking : 1. For modeling, we replace unstructured state-transition graphs with the heterogeneous modeling framework of Reactive Modules <ref> [AH96] </ref>. The definition of reactive modules is inspired by formalisms such as I/O automata [Lyn96], Esterel [BG88], and allows complex forms of interaction between components within a single transition. Reactive Modules provide a semantic glue that allows the formal embedding and interaction of components with different characteristics. <p> The first example, chosen primarily to illustrate the framework and functionalities, is a simple railroad controller. The second example concerns Needham-Schroeder protocol for public-key encryption, and illustrates a novel use of ATL in design and analysis. 2 Reactive Modules A formal definition of reactive modules can be found in <ref> [AH96] </ref>; here we give only a brief introduction. <p> That work did not deal with fairness. On the other hand, an assume-guarantee rule very similar to the one described above is sound for fair refinement check <ref> [AH96] </ref>. Hence, our methodology allows us to deal with fair modules also. 5 ATL Model-Checking Alternating-time Temporal Logic Alternating Temporal Logic (ATL) is a temporal logic designed to write requirements of open systems [AHK97].
Reference: [AH97] <author> R. Alur and T.A. Henzinger. </author> <title> Modularity for timed and hybrid systems. </title> <booktitle> In Proc. Eighth International Conference on Concurrency Theory, </booktitle> <volume> LNCS 1243, </volume> <pages> pages 74-88, </pages> <year> 1997. </year>
Reference-contexts: Setting X to B is the correct one, and it is exactly the same correction suggested in [Low96]. 6 Support for Timed Modules Mocha supports real-time systems that are described in the form of timed reactive modules as defined in <ref> [AH97] </ref>. In addition to the discrete-valued variables of reactive modules, a timed module makes use real-valued clock variables. All clock variables increase at the same rate, and keep track of time elapsed after they have been assigned a value by a guarded command. <p> Timed modules are converted by Mocha into (untimed) modules, equivalent to the original ones in the sense described. With this, all algorithms presented in previous sections are applicable to timed modules as well. Compositional and assume-guarantee style proof rules are valid also for timed modules (see <ref> [TAK + 96, AH97] </ref>).
Reference: [AHK97] <author> R. Alur, T.A. Henzinger, and O. Kupferman. </author> <title> Alternating-time temporal logic. </title> <booktitle> In Proceedings of the 38th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 100-109, </pages> <year> 1997. </year>
Reference-contexts: Some modules may be synchronous, others asynchronous, some may represent hardware, others software, some may be speed-independent, others time-critical. 2. For requirement specification, we replace the system-level specification languages of linear and branching temporal logics [Pnu77, CE81] with Alternating Temporal Logic (ATL) <ref> [AHK97] </ref>. By taking into account the possible relationships between modules, both cooperative and adversarial module requirements can be specified in ATL. For example, in ATL it is possible to specify that a module can attain a goal regardless of how the environment of the module changes. 3. <p> Hence, our methodology allows us to deal with fair modules also. 5 ATL Model-Checking Alternating-time Temporal Logic Alternating Temporal Logic (ATL) is a temporal logic designed to write requirements of open systems <ref> [AHK97] </ref>. An open system is a system that interacts with its environment and whose behavior depends on the state of the system as well as the behavior of the environment. Models for open systems (e.g. <p> However, this can only be true with the cooperation of Train W . In particular, the following property fails: hhii2hhTrain E ; Controllerii3 (pc E = bridge): Implementation We have implemented a symbolic ATL model-checker in Mocha . The model-checking algorithm (as presented in <ref> [AHK97] </ref>) is very similar to that of CTL model-checking, except in the pre-image computation. In Reactive Modules, each agent corresponds to an atom. For each external variable, there is an extra agent which controls it.
Reference: [AL93] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM TOPLAS, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference-contexts: The refinement checking problem can be simplified using the compositional and assume-guarantee rules. 1 The general principle of using modularity and compositionality in verification has a rich history of research. Sample efforts include compositional proof methodologies <ref> [AL93, MP95] </ref>, compositional CTL model checking [GL94], homomorphism checking [Kur94], property-preserving abstractions [CGL92], minimization [CPS93], module checking [KV96], and symbolic refinement checking [McM97]. However, exploiting modularity in practice still remains a challenge.
Reference: [BG88] <author> G. Berry and G. Gonthier. </author> <title> The synchronous programming language esterel: design, semantics, implementation. </title> <type> Technical Report 842, </type> <institution> INRIA, </institution> <year> 1988. </year>
Reference-contexts: As a possible solution, we propose the following methodology for open model checking : 1. For modeling, we replace unstructured state-transition graphs with the heterogeneous modeling framework of Reactive Modules [AH96]. The definition of reactive modules is inspired by formalisms such as I/O automata [Lyn96], Esterel <ref> [BG88] </ref>, and allows complex forms of interaction between components within a single transition. Reactive Modules provide a semantic glue that allows the formal embedding and interaction of components with different characteristics.
Reference: [BHS + 96] <author> R. Brayton, G. Hachtel, A. Sangiovanni-Vincentell, F. Somenzi, A. Aziz, S. Cheng, S. Edwards, S. Khatri, Y. Kukimoto, A. Pardo, S. Qadeer, R. Ranjan, S. Sarwary, T. Shiple, G. Swamy, and T. Villa. </author> <title> VIS: A system for verification and synthesis. </title> <booktitle> In Proceedings of the 8th International Conference on Computer Aided Verification, </booktitle> <volume> LNCS 1102, </volume> <pages> pages 428-432, </pages> <year> 1996. </year>
Reference-contexts: Explore the abstract graph using symbolic representations for boolean states such as BDDs. We call this four-step methodology, supported by tools such as Smv [McM93], Cospan [HHK96], Mur' [DDH + 92], and Vis <ref> [BHS + 96] </ref>, closed model checking, because it views a complete design in isolation, without reference to ongoing design modifications and without interference from other designs. In comparison, the successful applications of model checking in software and hardware/software codesign have been few and apart (cf. [CW96]). <p> Mocha is an interactive verification environment that reads in Reactive Modules descriptions as input. Mocha is intended as a vehicle for development of new verification algorithms and approaches. It is designed to allow easy extensions. It follows a software architecture similar to VIS <ref> [BHS + 96] </ref>. <p> We keep the transition relation of a reactive module in a conjunctively partitioned form. Each partition is the transition relation of an atom. The image computation routines have been leveraged off VIS <ref> [BHS + 96] </ref>, a symbolic model checking tool from UC Berkeley. VIS provides a heuristic [RAP + 95] for image computation based on early quantification that has been shown to be quite efficient in practice. 5 2. Enumerative.
Reference: [Bry86] <author> R.E. Bryant. </author> <title> Graph-based algorithms for boolean-function manipulation. </title> <journal> IEEE Trans. on Computers, </journal> <volume> C-35(8), </volume> <year> 1986. </year>
Reference-contexts: We have implemented both symbolic and enumerative reachability analysis. 1. Symbolic. We represent the transition relation and the set of reached states of a reactive module as binary decision diagrams (BDDs) <ref> [Bry86] </ref>. We keep the transition relation of a reactive module in a conjunctively partitioned form. Each partition is the transition relation of an atom. The image computation routines have been leveraged off VIS [BHS + 96], a symbolic model checking tool from UC Berkeley.
Reference: [CE81] <author> E.M. Clarke and E.A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching time temporal logic. </title> <booktitle> In Proc. Workshop on Logic of Programs, </booktitle> <volume> LNCS 131, </volume> <pages> pages 52-71. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: Some modules may be synchronous, others asynchronous, some may represent hardware, others software, some may be speed-independent, others time-critical. 2. For requirement specification, we replace the system-level specification languages of linear and branching temporal logics <ref> [Pnu77, CE81] </ref> with Alternating Temporal Logic (ATL) [AHK97]. By taking into account the possible relationships between modules, both cooperative and adversarial module requirements can be specified in ATL.
Reference: [CGL92] <author> E.M. Clarke, O. Grumberg, and D.E. </author> <title> Long. Model checking and abstraction. </title> <booktitle> In Proc. 19th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 343-354, </pages> <year> 1992. </year>
Reference-contexts: The refinement checking problem can be simplified using the compositional and assume-guarantee rules. 1 The general principle of using modularity and compositionality in verification has a rich history of research. Sample efforts include compositional proof methodologies [AL93, MP95], compositional CTL model checking [GL94], homomorphism checking [Kur94], property-preserving abstractions <ref> [CGL92] </ref>, minimization [CPS93], module checking [KV96], and symbolic refinement checking [McM97]. However, exploiting modularity in practice still remains a challenge.
Reference: [CK96] <author> E.M. Clarke and R.P. Kurshan. </author> <title> Computer-aided verification. </title> <journal> IEEE Spectrum, </journal> <volume> 33(6) </volume> <pages> 61-67, </pages> <year> 1996. </year>
Reference-contexts: 1 Introduction Model checking is a fully automatic technology for finding design errors by exhaustive state-space exploration, and has led in recent years to startling breakthroughs in hardware verification (cf. <ref> [CK96] </ref>). This is in part because hardware, usually being homogeneous, static, regular, and finite-state by nature, lends itself to the following steps of the traditional model-checking methodology: 1. Flatten a given, complete design into a huge but finite state-transition graph. 2.
Reference: [CPS93] <author> R. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The concurrency workbench: A semantics-based tool for the verification of finite-state systems. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 36-72, </pages> <year> 1993. </year>
Reference-contexts: Sample efforts include compositional proof methodologies [AL93, MP95], compositional CTL model checking [GL94], homomorphism checking [Kur94], property-preserving abstractions [CGL92], minimization <ref> [CPS93] </ref>, module checking [KV96], and symbolic refinement checking [McM97]. However, exploiting modularity in practice still remains a challenge. The novelty of our approach lies primarily in the choice of modeling language and the choice of temporal logic, both of which, in our opinion, are better suited to exploit modularity.
Reference: [CW96] <author> E.M. Clarke and J.M. Wing. </author> <title> Formal methods: State of the art and future directions. </title> <journal> ACM Computing Surveys, </journal> <year> 1996. </year>
Reference-contexts: In comparison, the successful applications of model checking in software and hardware/software codesign have been few and apart (cf. <ref> [CW96] </ref>). The blame is often assigned to the state-explosion problem: since model checking is based on exhaustive state-space exploration, the size of the state space of a design is the main limiting factor of the technology.
Reference: [DDH + 92] <author> D.L. Dill, A.J. Drexler, A.J. Hu, and C.H. Yang. </author> <title> Protocol verification as a hardware design aid. </title> <booktitle> In IEEE International Conference on Computer Design: VLSI in Computers and Processors, </booktitle> <pages> pages 522-525, </pages> <year> 1992. </year>
Reference-contexts: Explore the abstract graph using symbolic representations for boolean states such as BDDs. We call this four-step methodology, supported by tools such as Smv [McM93], Cospan [HHK96], Mur' <ref> [DDH + 92] </ref>, and Vis [BHS + 96], closed model checking, because it views a complete design in isolation, without reference to ongoing design modifications and without interference from other designs.
Reference: [Exp97] <institution> Expert Interface Technologies. Tix Home Page, </institution> <year> 1997. </year> <note> http://www.xpi.com/tix/index.html. 11 </note>
Reference-contexts: Mocha is intended as a vehicle for development of new verification algorithms and approaches. It is designed to allow easy extensions. It follows a software architecture similar to VIS [BHS + 96]. Written in C with Tcl/Tk and Tix <ref> [Exp97] </ref>, Mocha provides two levels of development: designers and application developers can customize their application or design their own graphical user interface by writing Tcl scripts; algorithm developers and researchers can develop new algorithms by writing C codes, or assemble any verification packages such as those provided by VIS through the
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: The refinement checking problem can be simplified using the compositional and assume-guarantee rules. 1 The general principle of using modularity and compositionality in verification has a rich history of research. Sample efforts include compositional proof methodologies [AL93, MP95], compositional CTL model checking <ref> [GL94] </ref>, homomorphism checking [Kur94], property-preserving abstractions [CGL92], minimization [CPS93], module checking [KV96], and symbolic refinement checking [McM97]. However, exploiting modularity in practice still remains a challenge.
Reference: [HHK96] <author> R. Hardin, Z. Har'El, and R. </author> <title> Kurshan. </title> <booktitle> Cospan. In Proceedings of the 8th International Conference on Computer Aided Verification, </booktitle> <volume> LNCS 1102, </volume> <pages> pages 423-427, </pages> <year> 1996. </year>
Reference-contexts: Explore the abstract graph using symbolic representations for boolean states such as BDDs. We call this four-step methodology, supported by tools such as Smv [McM93], Cospan <ref> [HHK96] </ref>, Mur' [DDH + 92], and Vis [BHS + 96], closed model checking, because it views a complete design in isolation, without reference to ongoing design modifications and without interference from other designs.
Reference: [HMP92] <author> T.A. Henzinger, Z. Manna, and A. Pnueli. </author> <title> What good are digital clocks? In ICALP 92: Automata, </title> <journal> Languages, and Programming, </journal> <volume> LNCS 623, </volume> <pages> pages 545-558. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Mocha restricts guards on clocks and clock invariants to be positive Boolean combinations of inequalities of the form x c and x c, where c 2 IN. This is adequate for modeling the bounds on delays of any physical system. In <ref> [HMP92] </ref>, it is proven that, with this restriction, for each trace fl of a timed module, there exists a trace [fl] such that (i) the sequence values that discrete variables take on is the same for fl and [fl] and (ii) all updates of discrete variables take place at integer-valued points
Reference: [HQR98] <author> T. Henzinger, S. Qadeer, and S. Rajamani. You assume, </author> <title> we guarantee: Methodology and case studies. </title> <type> Technical report, </type> <year> 1998. </year> <note> Submitted to CAV'98. </note>
Reference-contexts: Using symbolic reachability analysis, we have implemented a compositional refinement check for reactive modules in Mocha . The details of our approach are explained in an accompanying paper <ref> [HQR98] </ref>. To illustrate the main aspects of our methodology that deal with explosion of the implementation state space, consider the refinement check P 1 kP 2 Q, where k denotes parallel composition operation and denotes the refinement relation on modules.
Reference: [Kur94] <author> R.P. Kurshan. </author> <title> Computer-aided Verification of Coordinating Processes: the automata-theoretic approach. </title> <publisher> Princeton University Press, </publisher> <year> 1994. </year>
Reference-contexts: The refinement checking problem can be simplified using the compositional and assume-guarantee rules. 1 The general principle of using modularity and compositionality in verification has a rich history of research. Sample efforts include compositional proof methodologies [AL93, MP95], compositional CTL model checking [GL94], homomorphism checking <ref> [Kur94] </ref>, property-preserving abstractions [CGL92], minimization [CPS93], module checking [KV96], and symbolic refinement checking [McM97]. However, exploiting modularity in practice still remains a challenge.
Reference: [KV96] <author> O. Kupferman and M.Y. Vardi. </author> <title> Module checking. </title> <booktitle> In Computer Aided Verification, Proc. 8th Int. Workshop, </booktitle> <volume> LNCS 1102, </volume> <pages> pages 75-86. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Sample efforts include compositional proof methodologies [AL93, MP95], compositional CTL model checking [GL94], homomorphism checking [Kur94], property-preserving abstractions [CGL92], minimization [CPS93], module checking <ref> [KV96] </ref>, and symbolic refinement checking [McM97]. However, exploiting modularity in practice still remains a challenge. The novelty of our approach lies primarily in the choice of modeling language and the choice of temporal logic, both of which, in our opinion, are better suited to exploit modularity.
Reference: [Low96] <author> G. Lowe. </author> <title> Breaking and fixing the needham-schroeder public-key protocol using FDR. </title> <booktitle> In Proc. TACAS'96, </booktitle> <pages> pages 147-166, </pages> <year> 1996. </year>
Reference-contexts: Such a refinement is obtained from M by restricting the behavior of the agents in 1 so that they always collaborate with the agents in 0 to achieve '. Consider the simplified Needham-Schroeder's public-key encryption protocol, as discussed in <ref> [Low96] </ref>. The faulty protocol is given as below: 1: A ! B : A:B:fN a ; Ag K b 3: A ! B : A:B:fN b g K b Here the agent A is the initiator and the agent B is the responder. <p> When this property is checked against our model, Mocha is able to uncover the same execution sequence that leads to false authentication as described in <ref> [Low96] </ref>. Instead of fixing the protocol as suggested in [Low96] directly, we try the following approach. The idea is that we successively weaken the property to be verified, and try to discover a possible refinement of the incorrect protocol to implement the correct one. <p> When this property is checked against our model, Mocha is able to uncover the same execution sequence that leads to false authentication as described in <ref> [Low96] </ref>. Instead of fixing the protocol as suggested in [Low96] directly, we try the following approach. The idea is that we successively weaken the property to be verified, and try to discover a possible refinement of the incorrect protocol to implement the correct one. <p> There are two possible refinements: setting X to either A or B. Verification with Mocha reveals that setting X to A is not the right refinement. Setting X to B is the correct one, and it is exactly the same correction suggested in <ref> [Low96] </ref>. 6 Support for Timed Modules Mocha supports real-time systems that are described in the form of timed reactive modules as defined in [AH97]. In addition to the discrete-valued variables of reactive modules, a timed module makes use real-valued clock variables.
Reference: [Lyn96] <author> N.A. Lynch. </author> <title> Distributed algorithms. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: As a possible solution, we propose the following methodology for open model checking : 1. For modeling, we replace unstructured state-transition graphs with the heterogeneous modeling framework of Reactive Modules [AH96]. The definition of reactive modules is inspired by formalisms such as I/O automata <ref> [Lyn96] </ref>, Esterel [BG88], and allows complex forms of interaction between components within a single transition. Reactive Modules provide a semantic glue that allows the formal embedding and interaction of components with different characteristics.
Reference: [McM93] <author> K. McMillan. </author> <title> Symbolic model checking: an approach to the state explosion problem. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Explore the abstract graph using symbolic representations for boolean states such as BDDs. We call this four-step methodology, supported by tools such as Smv <ref> [McM93] </ref>, Cospan [HHK96], Mur' [DDH + 92], and Vis [BHS + 96], closed model checking, because it views a complete design in isolation, without reference to ongoing design modifications and without interference from other designs. <p> The model checking problem for ATL is to determine whether a given module satisfies a given ATL formula. The symbolic model checking procedure for CTL <ref> [McM93] </ref> generalizes nicely to yield a symbolic model checking procedure for ATL.
Reference: [McM97] <author> K.L. McMillan. </author> <title> A compositional rule for hardware design refinement. </title> <booktitle> In Proc. of the 9th International Conference on Computer-Aided Verification, </booktitle> <pages> pages 24-35, </pages> <year> 1997. </year>
Reference-contexts: Sample efforts include compositional proof methodologies [AL93, MP95], compositional CTL model checking [GL94], homomorphism checking [Kur94], property-preserving abstractions [CGL92], minimization [CPS93], module checking [KV96], and symbolic refinement checking <ref> [McM97] </ref>. However, exploiting modularity in practice still remains a challenge. The novelty of our approach lies primarily in the choice of modeling language and the choice of temporal logic, both of which, in our opinion, are better suited to exploit modularity. <p> Our methodology advocates the use of a witness module that can be composed with P to make it projection comparable with Q. The construction of witness modules also requires manual effort. 6 An implementation of a similar assume-guarantee rule for hardware designs was described in <ref> [McM97] </ref>. That work did not deal with fairness. On the other hand, an assume-guarantee rule very similar to the one described above is sound for fair refinement check [AH96].
Reference: [MP95] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Safety. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: The refinement checking problem can be simplified using the compositional and assume-guarantee rules. 1 The general principle of using modularity and compositionality in verification has a rich history of research. Sample efforts include compositional proof methodologies <ref> [AL93, MP95] </ref>, compositional CTL model checking [GL94], homomorphism checking [Kur94], property-preserving abstractions [CGL92], minimization [CPS93], module checking [KV96], and symbolic refinement checking [McM97]. However, exploiting modularity in practice still remains a challenge.
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proceedings of the 18th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 46-77, </pages> <year> 1977. </year>
Reference-contexts: Some modules may be synchronous, others asynchronous, some may represent hardware, others software, some may be speed-independent, others time-critical. 2. For requirement specification, we replace the system-level specification languages of linear and branching temporal logics <ref> [Pnu77, CE81] </ref> with Alternating Temporal Logic (ATL) [AHK97]. By taking into account the possible relationships between modules, both cooperative and adversarial module requirements can be specified in ATL.
Reference: [RAP + 95] <author> R.K. Ranjan, A. Aziz, B. Plessier, C. Pixley, and R.K. Brayton. </author> <title> Efficient formal design verification: Data structures + algorithms. </title> <booktitle> In Proc. International Workshop on Logic Synthesis, </booktitle> <year> 1995. </year>
Reference-contexts: We keep the transition relation of a reactive module in a conjunctively partitioned form. Each partition is the transition relation of an atom. The image computation routines have been leveraged off VIS [BHS + 96], a symbolic model checking tool from UC Berkeley. VIS provides a heuristic <ref> [RAP + 95] </ref> for image computation based on early quantification that has been shown to be quite efficient in practice. 5 2. Enumerative. The current implementation of the enumerative reachability analysis is rather naive and does not perform any optimization.
Reference: [TAK + 96] <author> S. Tasiran, R. Alur, R.P. Kurshan, and R.K. Brayton. </author> <title> Verifying abstractions of timed systems. </title> <booktitle> In Proceedings of the Seventh Conference on Concurrency Theory CONCUR '96, </booktitle> <volume> LNCS 1119, </volume> <pages> pages 546-562. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year> <month> 12 </month>
Reference-contexts: Timed modules are converted by Mocha into (untimed) modules, equivalent to the original ones in the sense described. With this, all algorithms presented in previous sections are applicable to timed modules as well. Compositional and assume-guarantee style proof rules are valid also for timed modules (see <ref> [TAK + 96, AH97] </ref>).
References-found: 28

