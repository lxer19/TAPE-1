URL: http://foxnet.cs.cmu.edu/papers/mdl-thesis.ps
Refering-URL: http://foxnet.cs.cmu.edu/papers.html
Root-URL: 
Title: Translucent Sums: A Foundation for Higher-Order Module Systems  
Author: Mark Lillibridge 
Degree: Submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy. Thesis Committee: Robert Harper, Chair Peter Lee John Reynolds Luca Cardelli, DEC SRC  
Note: Copyright c fl1997 Mark Lillibridge This research was sponsored by the Air Force Materiel Command (AFMC) and the Defense Advanced Research Projects Agency (DARPA) under contract number, F19628-95-C-0050. The U.S. Government is authorized to reproduce and distribute reprints for Government purposes notwithstanding any copyright notation thereon. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies or endorsements, either expressed or implied, of the U.S. Government.  
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Date: May, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Andrew W. Appel and David B. MacQueen. </author> <title> Standard ML of New Jersey. </title> <editor> In J. Maluszynski and M. Wirsing, editors, </editor> <booktitle> Third Int'l Symp. on Prog. Lang. Implementation and Logic Programming, </booktitle> <pages> pages 1-13, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> Springer-Verlag. </note>
Reference-contexts: This difference cannot be removed because SML does not provide any way to hide automatically-generated equality functions. CHAPTER 14. RELATED WORK 304 The New Jersey implementation of SML (SML/NJ, version 0.93) <ref> [1] </ref> extends SML in a number of ways.
Reference: [2] <author> Henk P. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics, </title> <booktitle> volume 103 of Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> revised edition, </address> <year> 1984. </year>
Reference-contexts: TYPES: CANONICALIZATION 131 (x:A: M 1 ) M 2 ! [M 2 =x]M 1 (LR-BETA) x 62 FTV (M ) (LR-ETA) One of the classic results for ! (see, for example, Barendregt <ref> [2] </ref>) is that all well typed terms are strongly normalizing: Theorem [ ! ] 8.3.9 (Strong normalization) If ` M : A then there are no infinite reduction sequences starting from A using ! (i.e., A ! A 1 ! A 2 ! A 3 : : :).
Reference: [3] <author> Richard J. </author> <title> Beach. Experience with the Cedar programming environment for computer graphics research. </title> <type> Technical Report CSL-84-6, </type> <institution> Xerox Corporation, Palo Alto, </institution> <month> July </month> <year> 1985. </year>
Reference-contexts: The subtyping procedure would need to be revised to handle the resulting inequalities. 14.2.2 Mesa and Cedar The programming languages Mesa [40, 13] and its successor Cedar <ref> [30, 54, 55, 3] </ref> fall outside my opaque verses transparent classification of higher-order module systems.
Reference: [4] <author> Edoardo Biagioni. </author> <title> A structured TCP in Standard ML. </title> <booktitle> In Sigcomm '94, </booktitle> <address> London, England, </address> <month> August/September </month> <year> 1994. </year>
Reference-contexts: Nonetheless, I am now going to present two examples that I feel convey some of the flavor of how higher-order modules systems are used in practice. My first example comes from Carnegie Mellon's Fox Project's implementation of the TCP/IP protocol suite, the FoxNet <ref> [6, 5, 4] </ref>, in SML. The TCP/IP protocol suite is organized modularly in the form of a protocol stack (see Figure 1.1). The leftmost stack in this figure shows the organization of normal TCP/IP.
Reference: [5] <author> Edoardo Biagioni, Robert Harper, and Peter Lee. </author> <title> Standard ML signatures for a protocol stack. </title> <type> Technical Report CMU-CS-93-170, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> July </month> <year> 1993. </year> <note> (Also published as Fox Memorandum CMU-CS-FOX-93-01). </note>
Reference-contexts: Nonetheless, I am now going to present two examples that I feel convey some of the flavor of how higher-order modules systems are used in practice. My first example comes from Carnegie Mellon's Fox Project's implementation of the TCP/IP protocol suite, the FoxNet <ref> [6, 5, 4] </ref>, in SML. The TCP/IP protocol suite is organized modularly in the form of a protocol stack (see Figure 1.1). The leftmost stack in this figure shows the organization of normal TCP/IP.
Reference: [6] <author> Edoardo Biagioni, Robert Harper, Peter Lee, and Brian G. Milnes. </author> <title> Signatures for a network protocol stack: A systems application of Standard ML. </title> <booktitle> In ACM Conference on LISP and Functional Programming, </booktitle> <address> Orlando, Florida, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: Nonetheless, I am now going to present two examples that I feel convey some of the flavor of how higher-order modules systems are used in practice. My first example comes from Carnegie Mellon's Fox Project's implementation of the TCP/IP protocol suite, the FoxNet <ref> [6, 5, 4] </ref>, in SML. The TCP/IP protocol suite is organized modularly in the form of a protocol stack (see Figure 1.1). The leftmost stack in this figure shows the organization of normal TCP/IP.
Reference: [7] <author> Hans-Jurgen Bohm, Alan Demers, and James Donahue. </author> <title> An informal description of Russell. </title> <type> Technical Report 80-430, </type> <institution> Computer Science Department, Cornell University, </institution> <address> Ithaca, New York, </address> <year> 1980. </year>
Reference-contexts: This coercion causes a total loss of typing information. My system is more flexible than this because it only loses just enough information to ensure soundness. Russell <ref> [7] </ref> and Poly [39] both seem likely to have some relationship with my system, but a detailed comparison seems difficult in the absence of a type-theoretical analysis of these languages (see [25] for an early attempt). CHAPTER 14.
Reference: [8] <author> Rod Burstall and Butler Lampson. </author> <title> A kernel language for abstract data types and modules. </title> <editor> In Kahn et al. </editor> <volume> [28], </volume> <pages> pages 1-50. 326 BIBLIOGRAPHY 327 </pages>
Reference-contexts: It is still not possible to compile without implementations of all referenced modules though. 14.2.4 Experimental Designs Burstall and Lampson's experimental language Pebble <ref> [8] </ref> is an early transparent design; unlike later transparent work, it has modules as first-class values.
Reference: [9] <author> Luca Cardelli. </author> <title> Structural subtyping and the notion of power type. </title> <booktitle> In Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: This tradeoff may change, however, if features like bounded polymorphism, which can be implemented using power kinds <ref> [9] </ref>, are added to the language. The second possible reformulation of the kernel system is to reformulate the system so that modules are second class instead of first class.
Reference: [10] <author> Luca Cardelli. </author> <title> Typeful programming. </title> <type> Technical Report 45, </type> <institution> DEC Systems Research Center, </institution> <year> 1989. </year>
Reference-contexts: Examples of programming languages which take this approach are John Mitchell and Gordon Plotkin's SOL [43] and Luca Cardelli's Quest <ref> [10] </ref>. This approach provides data 10 CHAPTER 2. PREVIOUS APPROACHES 11 abstraction at the module level, as we have just seen.
Reference: [11] <author> Luca Cardelli and Xavier Leroy. </author> <title> Abstract types and the dot notation. </title> <type> Technical Report 56, </type> <institution> DEC Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: may be bound to different types at runtime, making it unsafe to refer to it by a single static name outside the scope of the open statement.) Having to write out an open statement each time you want to use a weak sum can be inconvenient; in a 1990 paper <ref> [11] </ref>, Luca Cardelli and Xavier Leroy introduced a shortcut they called the dot notation. The basic idea is to allow the programmer to directly write x.T for the type component of and x.v for the value component of the weak sum denoted by the variable x.
Reference: [12] <author> Luis Damas and Robin Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <year> 1982. </year>
Reference-contexts: This choice greatly simplifies the theoretical complexity of his system and holds out the possibility of a decidable type system if named interfaces are prohibited. (Section 13.8 discusses these matters in more detail.) His system also differs from mine in that his system is based on Damas-Milner style polymorphism <ref> [12] </ref> and is implicitly typed, while my kernel system is based on Girard's F ! and is explicitly typed. He has not yet provided either a proof of soundness or a provably-correct type-checking procedure 4 for his system.
Reference: [13] <author> Charles M. Geschke, James H. Morris Jr., and Edwin H. Satterthwaite. </author> <title> Early experience with Mesa. </title> <type> Technical Report CSL-76-6, </type> <institution> Xerox Corporation, Palo Alto, </institution> <month> October </month> <year> 1976. </year>
Reference-contexts: Partially-opaque type declarations in assignments would induce subtyping inequalities in the same way that transparent type declarations induce equalities in the current system. The subtyping procedure would need to be revised to handle the resulting inequalities. 14.2.2 Mesa and Cedar The programming languages Mesa <ref> [40, 13] </ref> and its successor Cedar [30, 54, 55, 3] fall outside my opaque verses transparent classification of higher-order module systems.
Reference: [14] <author> Herman Geuvers. </author> <title> The Church-Rosser property for fi-reduuction in typed -calculi. </title> <booktitle> In Seventh Symposium on Logic in Computer Science, </booktitle> <pages> pages 453-460, </pages> <address> Santa Cruz, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Showing that K = K 0 from this fact requires some form of confluence in order to handle the possibility of fi-expansions. I shall use a technique due to Herman Geuvers <ref> [14] </ref> to handle this problem.
Reference: [15] <author> Jean-Yves Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieure. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: This choice yields a simple and uniform design. My "recipe" for building translucent higher-module systems is as follows: * Start with a base -calculus (to model the core language); I use Girard's F ! <ref> [15] </ref> in my Kernel system * Add translucent sums (to module modules) * Add dependent functions (to model functors); dependent functions are needed be cause the result type of a functor can depend on its argument * Add a notion of subtyping (to model implementation-interface matching) The key component here is <p> Complete details will be provided in later chapters as I consider each part of the system in turn. My kernel system is based on Girard's F ! <ref> [15] </ref> in much the same way that many systems are based on the second-order lambda calculus (F 2 ). That is to say, my system can CHAPTER 5.
Reference: [16] <author> Robert Harper. </author> <type> Personal communication, </type> <year> 1993. </year>
Reference-contexts: The first reformulation involves using singleton kinds as an alternative way of capturing the notion of transparent constructor declarations. Singleton kinds are due independently to Robert Harper <ref> [16] </ref> and Xavier Leroy [31]. A singleton kind is composed of a base kind and a constructor of that kind; in order for a constructor to belong to a singleton kind, it must belong to the singleton kind's base kind and be equal to the singleton kind's constructor.
Reference: [17] <author> Robert Harper. </author> <note> A propsoal for ML2000 (draft of december 16, 1994). (Unpublished), </note> <month> December </month> <year> 1994. </year>
Reference-contexts: While SML 1996 is essentially a slightly better tuned and simplified version of the original SML, work is underway to build a successor language to SML, currently called ML2000, that will be substantially more powerful than the current SML implementations <ref> [17] </ref>. ML2000's module system is based on my work on translucent sums.
Reference: [18] <author> Robert Harper, Peter Lee, Frank Pfenning, and Eugene Rollins. </author> <title> Incremental recompilation for Standard ML of New Jersey. </title> <type> Technical Report CMU-CS-94-116, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> February </month> <year> 1994. </year> <note> (Also published as Fox Memorandum CMU-CS-FOX-94-02; to appear Workshop on ML, Orlando, FL, June, 1994.). </note>
Reference-contexts: Note that because abstraction bindings can only make a boundary completely opaque, they cannot be used to solve the B-Tree example or similar problems. SML/NJ also adds additional software support for incremental recompilation <ref> [18] </ref>, which partially makes up for SML/NJ's lack of separate compilation by reducing the number of unneeded recompilations required.
Reference: [19] <author> Robert Harper and Mark Lillibridge. </author> <title> Explicit polymorphism and CPS conversion. </title> <booktitle> In Twentieth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 206-219, </pages> <address> Charleston, SC, </address> <month> January </month> <year> 1993. </year> <note> ACM, ACM. </note>
Reference-contexts: Evaluation does not proceed under quantifications because quantification translates into a lambda abstraction. My system differs in this regard from SML which does evaluate under quantifications. See <ref> [19] </ref> for a discussion of the differences between these two interpretations of quantifications and why this choice seems to be preferable. In the terminology of that paper, my system implements the standard call-by-value semantics for F ! extended with the obvious implementations of references and recursive types.
Reference: [20] <author> Robert Harper and Mark Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Twenty-first ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 123-137, </pages> <address> Portland, OR, </address> <month> January </month> <year> 1994. </year> <note> BIBLIOGRAPHY 328 </note>
Reference-contexts: The system translucent sums are embedded in changes greatly, however, due to the enriched behavior of equality, which now works on constructors of all kinds not just types, and subtyping. 5.2 Previous Work I described a much earlier version of this work in a previous paper with Robert Harper <ref> [20] </ref>. Aside from minor notational differences, there are only two changes between the system described in that paper and the one I have described up to this point. <p> In the original formulation of the kernel system <ref> [20] </ref>, rules equivalent to the following rule were used: x 1 62 FTV (A 2 ) x 2 62 FTV (A 1 ) ` fn 1 (x 1 ):A 1 ; n 2 (x 2 ):A 2 ; F g fn 2 (x 2 ):A 2 ; n 1 (x 1 <p> This design decision is problematic, however, because it makes it impossible for the user to refer to outer components shadowed by an inner component with the same external name (e.g., the example in Section 13.1). 14.4 Modules as Second-Class Values Since the initial publication of my work on translucent sums <ref> [20] </ref> and Leroy's work on manifest types [31], followup work has begun to appear in the literature. A sizeable 4 He did give a type checking procedure and a "proof" of its correctness in his paper [31], but both were later discovered to be flawed. CHAPTER 14.
Reference: [21] <author> Robert Harper, Robin Milner, and Mads Tofte. </author> <title> The definition of Standard ML (version 3). </title> <type> Technical Report ECS-LFCS-89-81, </type> <institution> Laboratory for the Foundations of Computer Science, Edinburgh University, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Program organization is crucial to ensuring that large programs are easy to develop, understand, and maintain. The most well-known programming language with a higher-order module system is Standard ML (SML) <ref> [21] </ref>. SML provides functors and submodules, but treats modules as CHAPTER 1. INTRODUCTION 6 normal: mobile: local: TCP TCP MOBILE-IP TCP IP IP glue ETH ETH ETH second-class values. The extensive experience of the SML community with functors and submodules has established their value as program-organization tools. <p> For example, we could make supplying a type for M 1 in let statements optional; since the kernel inference system possesses principle types (see Chapter 12), supplying this type is easy for the elaborator to do. 13.7.1 SML-like Elaborations The language Standard ML (SML) <ref> [21] </ref> possesses many elaborations that would make useful extensions to the kernel system. <p> Modules as first-class values are fairly useless, however, if modules cannot contain types, because it is not possible in that case to choose between different ADT implementations at runtime. 14.2.3 Standard ML Experience with the programming language Standard ML (SML) <ref> [21] </ref> has provided much of the motivation for work on higher-order module systems; SML was the first widely available real programming language with a higher-order module system. SML has a (mostly) transparent module system that provides modules, submodules, and first-order functors at a separate module level.
Reference: [22] <author> Robert Harper, John C. Mitchell, and Eugenio Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: its implementation and then reducing the resulting expression: IntStack.T = (module type T=ref (list (int)); ... end).T = ref (list (int)) Examples of programming languages that take this approach are David MacQueen's DL [37]; Robert Harper and John Mitchell's XML [41]; and Robert Harper, John Mitchell, and Eugenio Moggi's ML <ref> [22] </ref>. As we have just seen, the transparent approach does not provide data abstraction at the module level. <p> CHAPTER 4. TECHNICAL MACHINERY 37 4.5 The Phase Distinction One desirable property of a programming language is that it have a phase distinction <ref> [22] </ref>. A programming language is said to have a phase distinction if programs in it can be type checked without evaluating general program expressions (terms).
Reference: [23] <author> Robert Harper and Greg Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: Because traditional representation methods require that a type's representation be invariant under type substitution, this optimization requires CHAPTER 13. EXTENSIONS 279 non-traditional representation methods in the factored case. New representation methods using intensional polymorphism <ref> [23, 44] </ref> may allow this optimization, but probably not without some runtime and compiler-complexity cost. What notions of equality and subtyping are appropriate for n-ary named translucent sums? One approach is to just extend the kernel system rules in the obvious way.
Reference: [24] <author> Robert Harper and Chris Stone. </author> <title> A type-theoretic account of Standard ML 1996 (version 2). </title> <type> Technical Report CMU-CS-96-136R, </type> <institution> Carnegie Mellon University, </institution> <address> Pitts-burgh, PA, </address> <year> 1996. </year>
Reference-contexts: If more terms than the extended values are desired in TVDs, one sound approach is to formulate a notion of value-like terms whose evaluation does not produce side-effects or depend on the store. Robert Harper and Chris Stone have taken this approach in recent work <ref> [24] </ref>, introducing a separate judgment which they use to determine which terms are value like. What notation of equality is appropriate for extended values (or value-like terms)? Clearly, at an absolute minimum, we need equivalent extended values (i.e., ff-convertible) to be equal. <p> denote the relational operators. 13.7.2 Translucent-Sum Syntax Translucent sums are used in two main ways in the kernel system: they are used as record-like temporary objects that are created and passed around in the process of computation 2 While datatypes were originally built into SML, recent reformulations of the language <ref> [24] </ref> treat them as elaborations in terms of simpler constructs: recursive types, tuples, one-ofs, and patterns. CHAPTER 13. EXTENSIONS 292 and they are used as module-like permanent objects that contain chunks of program namespace. These uses are sufficiently different that they would benefit from different syntax. <p> Structure-sharing specifications are not considered to be very useful and recent proposals for new versions of SML <ref> [24, 47] </ref> suggest dropping them from the language. In addition to structure-sharing specifications, SML allows type-sharing specifications (see Section 3.9). SML allows type-sharing specifications to refer only to type names, not arbitrary type expressions. This restriction prevents SML from giving fully transparent interfaces in many cases. <p> CHAPTER 14. RELATED WORK 311 In [46], John Ophel investigates how a small language with first-class modules based on translucent sums might be defined and what the consequences of such a language might be. In <ref> [24] </ref>, Robert Harper and Chris Stone give a type-theoretic semantics for a new version of SML, SML 1996, using an typed intermediate language with translucent sums.
Reference: [25] <author> James G. Hook. </author> <title> Understanding Russell: A first attempt. </title> <editor> In Kahn et al. </editor> <volume> [28], </volume> <pages> pages 69-85. </pages>
Reference-contexts: My system is more flexible than this because it only loses just enough information to ensure soundness. Russell [7] and Poly [39] both seem likely to have some relationship with my system, but a detailed comparison seems difficult in the absence of a type-theoretical analysis of these languages (see <ref> [25] </ref> for an early attempt). CHAPTER 14. RELATED WORK 305 14.3 Manifest Types The most directly relevant work to mine is Xavier Leroy's work on manifest types [31]. This work, done independently, uses similar ideas but differs most fundamentally from mine in that his system treats modules as second-class values.
Reference: [26] <author> K. Jensen. </author> <title> Pascal User Manual and Report. </title> <publisher> Springer-Verlag, </publisher> <year> 1978. </year> <note> (2nd edition). </note>
Reference-contexts: forms of syntax are useful at the type level (e.g., fx:int;g vs. interface val x:int; end). 13.7.3 Open and Include A useful additional form of binding is the open binding form (open M ), which makes each component of a selected module available under its external name. (Pascal's with statement <ref> [26] </ref> provides a similar form of binding for records.) The elaboration of open M depends on M 's principle type. 4 For example, if M has principle type fx:int; y:bool;g, then let open M in M 0 end will elaborate to let local m=M in val x=m.x and val y=m.y; end
Reference: [27] <author> Mark P. Jones. </author> <title> Using parameterized signatures to express modular structure. </title> <booktitle> In Twenty-Third ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 21-24, </pages> <address> St. Petersburg Beach, FL, </address> <month> January </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: there is as yet no consensus on the value of full transparency to programmers because of insufficient experience with higher-order functors. 14.5 Other Follow-On Work Feeling that the type theory of translucent module systems is unnecessarily complicated, Mark Jones has recently proposed an alternative approach to handling higher-order module systems <ref> [27] </ref>. He observes that programs written in a SML-like module system without abstraction or generativity can be translated into a system with no modules or functors but with (ordinary) records, functions, and universal polymorphism (8ff:A).
Reference: [28] <editor> Gilles Kahn, David MacQueen, and Gordon Plotkin, editors. </editor> <booktitle> Semantics of Data Types, volume 173 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1984. </year>
Reference: [29] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-hall, Inc., </publisher> <year> 1978. </year>
Reference-contexts: First-order module systems have only the trivial module facilities discussed so far: module creation, module naming, and module-component extraction (M.x). Most traditional module systems are of this type. Examples include Ada [52], CLU [36], C <ref> [29] </ref>, C++ [53], and Modula-2 [56]. Higher-order module systems, by contrast, have non-trivial module manipulation facilities. I shall be concerned in this dissertation primarily with three such facilities: functors, submodules, and modules as first-class values. Functors are functions mapping modules to modules.
Reference: [30] <author> Butler W. Lampson. </author> <title> A description of the Cedar language: A Cedar language reference manual. </title> <type> Technical Report CSL-83-15, </type> <institution> Xerox Corporation, Palo Alto, </institution> <month> December </month> <year> 1983. </year>
Reference-contexts: The subtyping procedure would need to be revised to handle the resulting inequalities. 14.2.2 Mesa and Cedar The programming languages Mesa [40, 13] and its successor Cedar <ref> [30, 54, 55, 3] </ref> fall outside my opaque verses transparent classification of higher-order module systems.
Reference: [31] <author> Xavier Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In Proceedings of the Twenty-first Annual ACM Symposium on Principles of Programming Languages, Portland, </booktitle> <pages> pages 109-122. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1994. </year>
Reference-contexts: -&gt; int; end If we compare this interface to the original opaque ORDERED interface (repeated below), we see that the new interface differs only in the addition of the type identity T=string: interface type T; val cmp: T*T -&gt; int; end By using a shorthand notation due to Xavier Leroy <ref> [31] </ref>, we can take advantage of this fact to express the new interface as ORDERED with T=string. Leroy's with notation is a purely syntactic shorthand that expresses the result of adding information about type identities to an existing interface. <p> The analysis based on the translation idea can be extended to deal with reordering and dropping an arbitrary number of fields at the one time, producing generalized versions of TWO-FLIP and SIMPLER. Xavier Leroy's system <ref> [31] </ref> (see Section 14.3) appears to be using a generalized variant of SIMPLER. <p> If a non-principle type was used, it might be missing components because of subsumption. CHAPTER 13. EXTENSIONS 293 13.7.4 Leroy's With Notation An important abbreviation feature when dealing with translucent sum types is some version of Leroy's with notation <ref> [31] </ref>. Leroy's with notation is used to add information about the contents of a translucent sums' constructor components to its interface. <p> The first reformulation involves using singleton kinds as an alternative way of capturing the notion of transparent constructor declarations. Singleton kinds are due independently to Robert Harper [16] and Xavier Leroy <ref> [31] </ref>. A singleton kind is composed of a base kind and a constructor of that kind; in order for a constructor to belong to a singleton kind, it must belong to the singleton kind's base kind and be equal to the singleton kind's constructor. <p> It thus greatly simplifies place lookup as well as many other parts of the system. It particular, it is likely that type checking decidable is decidable for this system. Xavier Leroy's manifest-types system <ref> [31] </ref> (see Section 14.3) takes this approach. It is unclear, though, how problematic CHAPTER 13. EXTENSIONS 298 the lack of transparent interface definitions is from the programmer's viewpoint. <p> CHAPTER 14. RELATED WORK 305 14.3 Manifest Types The most directly relevant work to mine is Xavier Leroy's work on manifest types <ref> [31] </ref>. This work, done independently, uses similar ideas but differs most fundamentally from mine in that his system treats modules as second-class values. <p> The two systems also differ due to slightly different type machinery arranged in different ways. For example, Leroy independently invented an operation he calls strengthening (written A=x in my notation) which corresponds to the self function in my system. In Leroy's original formations of manifest types <ref> [31, 32] </ref>, A=x computes essentially the same type as my [self=x]A except for transparent types: My self function leaves transparent types unchanged ([self=x]&lt;=A::K&gt; = &lt;=A::K&gt;), while Leroy's original strengthening operation replaces the information already in the transparent type with information about the name of the type (&lt;=A::K&gt;=x = &lt;=x!::K&gt;). <p> it makes it impossible for the user to refer to outer components shadowed by an inner component with the same external name (e.g., the example in Section 13.1). 14.4 Modules as Second-Class Values Since the initial publication of my work on translucent sums [20] and Leroy's work on manifest types <ref> [31] </ref>, followup work has begun to appear in the literature. A sizeable 4 He did give a type checking procedure and a "proof" of its correctness in his paper [31], but both were later discovered to be flawed. CHAPTER 14. <p> Modules as Second-Class Values Since the initial publication of my work on translucent sums [20] and Leroy's work on manifest types <ref> [31] </ref>, followup work has begun to appear in the literature. A sizeable 4 He did give a type checking procedure and a "proof" of its correctness in his paper [31], but both were later discovered to be flawed. CHAPTER 14. <p> In additional to being useful as a starting point for building extended systems, my kernel system is likely to be useful as a reduction target because of these proven properties; for example, I expect that the soundness of Xavier Leroy's system <ref> [31] </ref> can be established in this way far more easily than if it was proved directly. The negative results about soundness under certain extensions, the decidability of subtyping (and hence type checking), and the existence of principle types if implicit subsumption is permitted are also contributions of my dissertation.
Reference: [32] <author> Xavier Leroy. </author> <title> Applicative functors and fully transparent higher-order modules. </title> <booktitle> In Conference Record of POPL '95: ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 142-153, </pages> <address> San Francisco, CA, </address> <month> January </month> <year> 1995. </year> <note> BIBLIOGRAPHY 329 </note>
Reference-contexts: One extension that permits such typings is Xavier Leroy's applicative functors <ref> [32] </ref>. (See further discussion in Section 14.4.) The utility of such extensions should be investigated for any second-class module system. <p> The two systems also differ due to slightly different type machinery arranged in different ways. For example, Leroy independently invented an operation he calls strengthening (written A=x in my notation) which corresponds to the self function in my system. In Leroy's original formations of manifest types <ref> [31, 32] </ref>, A=x computes essentially the same type as my [self=x]A except for transparent types: My self function leaves transparent types unchanged ([self=x]&lt;=A::K&gt; = &lt;=A::K&gt;), while Leroy's original strengthening operation replaces the information already in the transparent type with information about the name of the type (&lt;=A::K&gt;=x = &lt;=x!::K&gt;). <p> If modules are restricted to second-class values, the translucent approach can be extended to handle the Apply example in the same way that SML/NJ does. Leroy's work on applicative functors <ref> [32] </ref> demonstrates one way to accomplish this. Under this approach, functor applications are assumed to never generate new constructors: Any result constructor (sub)-component of a functor is assumed to be a (deterministic) function of the constructors contained in that functor's arguments.
Reference: [33] <author> Xavier Leroy. </author> <title> A modular module system. </title> <type> Research report 2866, </type> <institution> INRIA, </institution> <month> April </month> <year> 1996. </year>
Reference-contexts: In more recent formations of manifest types <ref> [33, 34] </ref>, Leroy has switched to a version of strengthening that treats transparent types in the same way as my self function.
Reference: [34] <author> Xavier Leroy. </author> <title> A syntactic theory of type generativity and sharing. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(5) </volume> <pages> 667-698, </pages> <year> 1996. </year>
Reference-contexts: I shall give an example of how this can occur later in Section 3.7. Code that does not involve using modules as first-class values, higher-order functors (functors that take or return other functors as arguments), or type coercions will be given a fully transparent interface <ref> [34] </ref>. This category includes the majority of code written in SML. 1 In particular, the type checker makes no attempt to determine the run-time branching of conditionals, instead assuming that they could branch either way at any time. CHAPTER 3. <p> In more recent formations of manifest types <ref> [33, 34] </ref>, Leroy has switched to a version of strengthening that treats transparent types in the same way as my self function. <p> Leroy showed in a recent paper <ref> [34] </ref> that translucent module systems capable (possibly via extension) of supporting modules as first-class values can express most (unextended) SML programs 5 so long as SML type ascriptions (M : A) are translated to coercion functors in the obvious way. (The translation is necessary because SML type ascriptions can drop or
Reference: [35] <author> Mark Lillibridge, Zhong Shao, and Robert Harper. </author> <booktitle> Minutes of the ML2000 meeting at Portland, Oregon on January 16, </booktitle> <year> 1994. </year> <note> Unpublished, </note> <year> 1994. </year>
Reference-contexts: Xavier Leroy has suggested that it may be possible to some degree to use extra parameterization by possibly-singleton kinds (see Sections 13.4 and 13.8) to produce more flexible versions of Apply <ref> [35] </ref>.
Reference: [36] <author> Barbara Liskov, Russell Atkinson, et al. </author> <title> CLU Reference Manual, </title> <booktitle> volume 114 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: I classify module systems into two types, depending on what sort of facilities they have. First-order module systems have only the trivial module facilities discussed so far: module creation, module naming, and module-component extraction (M.x). Most traditional module systems are of this type. Examples include Ada [52], CLU <ref> [36] </ref>, C [29], C++ [53], and Modula-2 [56]. Higher-order module systems, by contrast, have non-trivial module manipulation facilities. I shall be concerned in this dissertation primarily with three such facilities: functors, submodules, and modules as first-class values. Functors are functions mapping modules to modules.
Reference: [37] <author> David MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In Thirteenth ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1986. </year>
Reference-contexts: Also, we cannot extend ADTs by adding a few new operations to an existing ADT. 1 Another consequence is that many of the more useful idioms using higher-order features are inexpressible. Indeed, David MacQueen argued in a 1986 paper <ref> [37] </ref> that this problem is severe enough that the opaque approach should be abandoned in favor of a transparent one. 2.2 The Transparent Approach Unlike in the opaque approach, under the transparent approach, module and functor boundaries are transparent, allowing all information about the identities of type components to pass through <p> The identity of IntStack.T is computed by substituting in its implementation and then reducing the resulting expression: IntStack.T = (module type T=ref (list (int)); ... end).T = ref (list (int)) Examples of programming languages that take this approach are David MacQueen's DL <ref> [37] </ref>; Robert Harper and John Mitchell's XML [41]; and Robert Harper, John Mitchell, and Eugenio Moggi's ML [22]. As we have just seen, the transparent approach does not provide data abstraction at the module level. <p> This ability may be useful when it is important that two modules constructed independently use a common piece of code. See <ref> [37] </ref> for some good examples of where value sharing is useful.
Reference: [38] <author> David B. MacQueen and Mads Tofte. </author> <title> A semantics for higher-order functors. </title> <editor> In D. Sannella, editor, </editor> <booktitle> Programming Languages and Systems | ESOP '94, volume 788 of Lecture Notes in Computer Science, </booktitle> <pages> pages 409-423. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The rest of the example is composed of a number of sample modules and functors for use in testing Apply. In SML/NJ (assuming the appropriate syntactical translation) and other transparent module systems with higher-order functors, Apply behaves in what MacQueen and Tofte <ref> [38] </ref> call a fully-transparent manner: That is, the type checker knows everything that could be learned from actually executing the functor application (s). <p> Functors in these systems are thus not fully transparent in the sense of <ref> [38] </ref>. This behavior should not be too surprising, however, for the case where modules are first-class values: There is in general no reasonable way to completely evaluate functor applications at type-checking time when they may involve conditionals, recursion, and the computation of arbitrary values. <p> I expect such a system to be highly complicated and hard to reason about. MacQueen and Tofte <ref> [38] </ref> have begun to explore how a system with full transparency might be built. There thus appears to be a tradeoff in higher-order module systems with second-class modules between system simplicity and the degree of full transparency provided.
Reference: [39] <author> David C. J. Matthews. </author> <type> POLY report. Technical Report 28, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <year> 1982. </year>
Reference-contexts: This coercion causes a total loss of typing information. My system is more flexible than this because it only loses just enough information to ensure soundness. Russell [7] and Poly <ref> [39] </ref> both seem likely to have some relationship with my system, but a detailed comparison seems difficult in the absence of a type-theoretical analysis of these languages (see [25] for an early attempt). CHAPTER 14.
Reference: [40] <author> James G. Mitchell, William Maybury, and Richard Sweet. </author> <title> Mesa language manual. </title> <type> Technical Report CSL-78-1, </type> <institution> Xerox Corporation, Palo Alto, </institution> <month> February </month> <year> 1978. </year>
Reference-contexts: Partially-opaque type declarations in assignments would induce subtyping inequalities in the same way that transparent type declarations induce equalities in the current system. The subtyping procedure would need to be revised to handle the resulting inequalities. 14.2.2 Mesa and Cedar The programming languages Mesa <ref> [40, 13] </ref> and its successor Cedar [30, 54, 55, 3] fall outside my opaque verses transparent classification of higher-order module systems.
Reference: [41] <author> John Mitchell and Robert Harper. </author> <title> The essence of ML. </title> <booktitle> In Fifteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, California, </address> <month> January </month> <year> 1988. </year>
Reference-contexts: The identity of IntStack.T is computed by substituting in its implementation and then reducing the resulting expression: IntStack.T = (module type T=ref (list (int)); ... end).T = ref (list (int)) Examples of programming languages that take this approach are David MacQueen's DL [37]; Robert Harper and John Mitchell's XML <ref> [41] </ref>; and Robert Harper, John Mitchell, and Eugenio Moggi's ML [22]. As we have just seen, the transparent approach does not provide data abstraction at the module level.
Reference: [42] <author> John Mitchell, Sigurd Meldal, and Neel Madhav. </author> <title> An extension of Standard ML modules with subtyping and inheritance. </title> <booktitle> In Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1991. </year>
Reference-contexts: Pebble has no phase distinction and its type checking problem is undecidable. These problems have lead later researchers to consider the transparent approach incompatible with modules as first-class values. Mitchell, et al. <ref> [42] </ref> consider an extension of the SML module system with first-class modules as a means of supporting certain object-oriented programming idioms. Their paper is primarily concerned with illustrating an interesting language design rather than with the type-theoretic underpinnings of such a language, though a brief sketch is provided.
Reference: [43] <author> John C. Mitchell and Gordon Plotkin. </author> <title> Abstract types have existential type. </title> <booktitle> In Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1985. </year>
Reference-contexts: Examples of programming languages which take this approach are John Mitchell and Gordon Plotkin's SOL <ref> [43] </ref> and Luca Cardelli's Quest [10]. This approach provides data 10 CHAPTER 2. PREVIOUS APPROACHES 11 abstraction at the module level, as we have just seen.
Reference: [44] <author> John Gregory Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1995. </year> <note> (Available as Carnegie Mellon University School of Computer Science technical report CMU-CS-95-226.). </note>
Reference-contexts: Because traditional representation methods require that a type's representation be invariant under type substitution, this optimization requires CHAPTER 13. EXTENSIONS 279 non-traditional representation methods in the factored case. New representation methods using intensional polymorphism <ref> [23, 44] </ref> may allow this optimization, but probably not without some runtime and compiler-complexity cost. What notions of equality and subtyping are appropriate for n-ary named translucent sums? One approach is to just extend the kernel system rules in the obvious way.
Reference: [45] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: CHAPTER 14. RELATED WORK 301 14.2.1 Modula-3 Modula-3 <ref> [45] </ref> provides a functor-like construct called a generic module. A Modula-3 generic module is a module parametrized by a series of interface names. Such a module can be instantiated by binding its formal interface parameters to the names of actual interfaces.
Reference: [46] <author> John Ophel. </author> <title> A polymorphic language with first-class modules. </title> <journal> Australian Computer Science Communications, </journal> <volume> 17(1) </volume> <pages> 422-430, </pages> <month> February </month> <year> 1995. </year> <note> BIBLIOGRAPHY 330 </note>
Reference-contexts: My work has already begun to be used in the design of new programming languages. CHAPTER 14. RELATED WORK 311 In <ref> [46] </ref>, John Ophel investigates how a small language with first-class modules based on translucent sums might be defined and what the consequences of such a language might be.
Reference: [47] <author> Amit Patel and Chris Stone. </author> <booktitle> Minutes of the ML2000 meeting at King's Beach, </booktitle> <address> CA. (Unpublished), </address> <month> August </month> <year> 1996. </year>
Reference-contexts: Structure-sharing specifications are not considered to be very useful and recent proposals for new versions of SML <ref> [24, 47] </ref> suggest dropping them from the language. In addition to structure-sharing specifications, SML allows type-sharing specifications (see Section 3.9). SML allows type-sharing specifications to refer only to type names, not arbitrary type expressions. This restriction prevents SML from giving fully transparent interfaces in many cases. <p> It treats modules as second-class values in order to keep the type system simple; I feel that this was a wise choice, given that ML2000's type system also has to deal with object oriented features, a known source of complexity <ref> [47] </ref>. Chapter 15 Conclusions In this, the final chapter, I sum up the contributions of my dissertation and discuss possible future work. 15.1 Contributions This dissertation makes a number of contributions.
Reference: [48] <author> Frank Pfenning. </author> <title> Partial polymorphic type inference and higher-order unification. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 153-163, </pages> <address> Snowbird, Utah, July 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: It seems likely that some kind of type reconstruction algorithm could be found which would reduce the amount of information required. One possible approach is to try and modify Frank Pfenning's type reconstruction algorithm for F ! <ref> [48, 49] </ref> to work for the kernel system. The idea would be to require the programmer to provide all constructors involving translucent sums, dependent functions, or reified constructors.
Reference: [49] <author> Frank Pfenning and Peter Lee. </author> <title> LEAP: A language with eval and polymorphism. </title> <booktitle> In TAPSOFT '89, Proceedings of the International Joint Conference on Theory and Practice in Software Development, Barcelona, Spain, </booktitle> <pages> pages 345-359. </pages> <publisher> Springer-Verlag LNCS 352, </publisher> <month> March </month> <year> 1989. </year>
Reference-contexts: It seems likely that some kind of type reconstruction algorithm could be found which would reduce the amount of information required. One possible approach is to try and modify Frank Pfenning's type reconstruction algorithm for F ! <ref> [48, 49] </ref> to work for the kernel system. The idea would be to require the programmer to provide all constructors involving translucent sums, dependent functions, or reified constructors.
Reference: [50] <author> Benjamin Pierce. </author> <title> Bounded quantification is undecidable. </title> <booktitle> In Proceedings of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, Al-buquerque. ACM, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: A 2 ) fails ) : ` A 1 A 2 . 2 10.6 The Simple Type System In this and the next three sections, I show that the subtyping relation for my system is undecidable using a slight modification to Benjamin Pierce's proof of the undecidability of F subtyping <ref> [51, 50] </ref>.
Reference: [51] <author> Benjamin C. Pierce. </author> <title> Programming with Intersection Types and Bounded Polymor-phism. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pitts-burgh, PA, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: A 2 ) fails ) : ` A 1 A 2 . 2 10.6 The Simple Type System In this and the next three sections, I show that the subtyping relation for my system is undecidable using a slight modification to Benjamin Pierce's proof of the undecidability of F subtyping <ref> [51, 50] </ref>. <p> In order to mirror Pierce's fragment F F (see Section 6.4 of Pierce's thesis <ref> [51] </ref>) closely, these rules handle transparent definitions (ff=A) by substitution rather than by adding a transparent definition to the current assignment. (See, for example, the SUM-T and SU-SUM-T rules.) Definition [Simple] 10.6.6 (Assignment Formation Rules) ` * valid (EMP) ` valid ff 62 dom () ` ; ff valid (DCL) CHAPTER <p> : : : ; ff n : m 00 for some ff 1 ; : : : ; ff n ; and m 00 ) 9m 0 : m ! m 0 (ROW). 2 More discussion of row machines, including examples, can be found in Section 6.5 of Pierce's thesis <ref> [51] </ref>. The elaboration function given there differs slightly from the one here because it uses simultaneous substitution where I have used iterated substitution; the definitions can easily be seen to coincide on closed row machines however.
Reference: [52] <author> I. C. Pyle. </author> <booktitle> The Ada Programming Language. Prentice-Hall International, </booktitle> <year> 1981. </year>
Reference-contexts: I classify module systems into two types, depending on what sort of facilities they have. First-order module systems have only the trivial module facilities discussed so far: module creation, module naming, and module-component extraction (M.x). Most traditional module systems are of this type. Examples include Ada <ref> [52] </ref>, CLU [36], C [29], C++ [53], and Modula-2 [56]. Higher-order module systems, by contrast, have non-trivial module manipulation facilities. I shall be concerned in this dissertation primarily with three such facilities: functors, submodules, and modules as first-class values. Functors are functions mapping modules to modules. <p> I have limited this rule to types because none of these languages allow opaque higher-kinds. It would not be difficult, however, to extend this rule to allow holding abstract constructors that when fully applied always produce a type that fits in a single machine word. Ada <ref> [52] </ref> handles the problem of how to implement abstraction in an efficient manner differently: Instead of restricting what types may be held abstract, it replaces opaque type declarations with private type declarations.
Reference: [53] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: First-order module systems have only the trivial module facilities discussed so far: module creation, module naming, and module-component extraction (M.x). Most traditional module systems are of this type. Examples include Ada [52], CLU [36], C [29], C++ <ref> [53] </ref>, and Modula-2 [56]. Higher-order module systems, by contrast, have non-trivial module manipulation facilities. I shall be concerned in this dissertation primarily with three such facilities: functors, submodules, and modules as first-class values. Functors are functions mapping modules to modules.
Reference: [54] <author> Daniel C. Swinehart, Polle T. Zellweger, Richard J. Beach, and Robert B. Hagmann. </author> <title> A structural view of the Cedar programming environment. </title> <type> Technical Report CSL-86-1, </type> <institution> Xerox Corporation, Palo Alto, </institution> <month> June </month> <year> 1986. </year>
Reference-contexts: The subtyping procedure would need to be revised to handle the resulting inequalities. 14.2.2 Mesa and Cedar The programming languages Mesa [40, 13] and its successor Cedar <ref> [30, 54, 55, 3] </ref> fall outside my opaque verses transparent classification of higher-order module systems.
Reference: [55] <author> Warren Teitelman. </author> <title> The Cedar programming environment: A midterm report and examination. </title> <type> Technical Report CSL-83-11, </type> <institution> Xerox Corporation, Palo Alto, </institution> <month> June </month> <year> 1984. </year>
Reference-contexts: The subtyping procedure would need to be revised to handle the resulting inequalities. 14.2.2 Mesa and Cedar The programming languages Mesa [40, 13] and its successor Cedar <ref> [30, 54, 55, 3] </ref> fall outside my opaque verses transparent classification of higher-order module systems.
Reference: [56] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. Texts and Monographs in Computer Science. </title> <publisher> Springer-Verlag, </publisher> <year> 1983. </year>
Reference-contexts: The approach promises a substantially more powerful module system than those built with previous approaches, while at the same time eliminating the problems associated with the previous approaches. Traditional module systems, such as the one provided by Modula-2 <ref> [56] </ref>, are first-order, allowing only trivial manipulations of modules. Some newer programming languages provide higher-order module systems. Higher-order module systems, unlike first-order ones, permit the non-trivial manipulation of modules within the language. <p> First-order module systems have only the trivial module facilities discussed so far: module creation, module naming, and module-component extraction (M.x). Most traditional module systems are of this type. Examples include Ada [52], CLU [36], C [29], C++ [53], and Modula-2 <ref> [56] </ref>. Higher-order module systems, by contrast, have non-trivial module manipulation facilities. I shall be concerned in this dissertation primarily with three such facilities: functors, submodules, and modules as first-class values. Functors are functions mapping modules to modules. <p> Chapter 14 Related Work In this chapter I discuss work related to the work contained in this dissertation. 14.1 First-Order Module Systems How does the module system I built relate to first-order module systems? The answer is that languages like Modula-2 <ref> [56] </ref>, which have first-order module systems, basically implement the first-order fragment of a second-class version of my module system. (By the first-order fragment, I mean here the fragment that results from syntactically disallowing the use of functors and submodules.) These languages allow translucent interfaces (interfaces that may contain both opaque and
References-found: 56

