URL: http://ftp.eecs.umich.edu/people/scoffey/bcmim.ps
Refering-URL: http://ftp.eecs.umich.edu/people/scoffey/
Root-URL: http://www.eecs.umich.edu
Title: Rate Gains in Block Coded Modulation Systems with Interblock Memory effect of designing codes for
Author: Chia-Ning Peng, Member, IEEE, Houshou Chen, Student Member, IEEE, John T. Coffey, Member, IEEE, and Richard G. C. Williams, Member, IEEE 
Date: October 30, 1998  
Note: Submitted to IEEE Transactions on Information Theory,  The  
Abstract: This paper examines the performance gains achievable by adding interblock memory to, and altering the mapping of coded bits to symbols in, block coded modulation systems. The channel noise considered is additive Gaussian, and the twin design goals are to maximize the asymptotic coding gain and to minimize the number of apparent nearest neighbors. In the case of the additive white Gaussian noise channel, these goals translate into the design of block codes of a given weighted or `normalized' distance whose rate is as high as possible, and whose number of codewords at minimum normalized distance is low. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. L. Blokh and V. V. Zyablov, </author> <title> Coding of generalized concatenated codes, Probl. </title> <journal> Peredachi Inform., </journal> <volume> vol. 10, no. 3, </volume> <pages> pp. 4550, </pages> <year> 1974. </year> <title> (In Russian. English translation in Probl. </title> <journal> Inform. Trans., </journal> <volume> vol. 10, no. 3, </volume> <pages> pp. 218222, </pages> <address> Jul.Sep. 1974.). </address>
Reference-contexts: A second necessary condition for equality is that the bits in the ith basic block are linearly independent, i.e., the punctured future code of length n is the <ref> [n; n; 1] </ref> code. Finally, note that since the a i 's form an increasing sequence, the upper bounds on dimension gain follow a law of diminishing returns with increasing i. <p> We concentrate on the natural case in which the normalized distance is equal to the basic block length. The results are summarized in Table I. A. Best codes for QAM-based BCMIM systems with basic block length 8 The codes in the baseline BCM system will be <ref> [8; 1; 8] </ref>, [8; 4; 4], [8; 7; 2] and [8; 8; 1] codes, as given by Cusack [6]. The case n = d n = 8 is a main focus of the papers of Lin et al. <p> The results are summarized in Table I. A. Best codes for QAM-based BCMIM systems with basic block length 8 The codes in the baseline BCM system will be [8; 1; 8], [8; 4; 4], [8; 7; 2] and <ref> [8; 8; 1] </ref> codes, as given by Cusack [6]. The case n = d n = 8 is a main focus of the papers of Lin et al. <p> A.1 Best [8j8; k; 8] codes If we allow interblock memory between the first two basic blocks, we are seeking the best [8j8; k; 8] code. The baseline BCM case with no interblock memory is obtained by taking the direct sum of the <ref> [8; 1; 8] </ref> code and the [8; 4; 4] code, and so has dimension 5. From the full dimension lemma, the gain in dimension when interblock memory is introduced is upper bounded by n K (n; d n =a 2 ) = 8 4 = 4. <p> 0 0 0 0 0 0 1 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 7 7 7 7 7 5 This code can be obtained from an X 4 construction, with C 1 an <ref> [8; 1; 8] </ref> code, C 2 and C 3 [8; 4; 4] codes, and C 4 an [8; 7; 2] code. (The reference [17] cites [26], which introduces the X 4 construction.) (None of the other constructions of Section III give k = 8. <p> Best codes for QAM-based BCMIM systems with basic block length 9 The codes in a baseline BCM system are <ref> [9; 1; 9] </ref>, [9; 2; 6], [9; 5; 3] and [9; 8; 2]. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = <p> length 9 The codes in a baseline BCM system are <ref> [9; 1; 9] </ref>, [9; 2; 6], [9; 5; 3] and [9; 8; 2]. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. Applying split weight linear programming to this case indicates that k 7. <p> We omit the details. C. Best codes for QAM-based BCMIM systems with basic block length 10 The codes in a baseline BCM system are <ref> [10; 1; 10] </ref>, [10; 3; 5], [10; 6; 3], and [10; 9; 2]. 16 C.1 Best [10j10; k; 10] codes With no interblock memory between the first two blocks, the baseline BCM system gives k = 4. <p> The code therefore has minimum normalized weight 10 with 68 codewords of this normalized weight. 17 D. Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are <ref> [11; 1; 11] </ref>, [11; 3; 6], [11; 6; 4] and [11; 10; 2], and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and [12; 11; 2] respectively. <p> Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and [11; 10; 2], and <ref> [12; 1; 12] </ref>, [12; 4; 6], [12; 8; 3]; and [12; 11; 2] respectively. <p> We choose x 1 ; : : : ; x 12 to be words of weight 4 from distinct cosets among these. We form the generator matrix 2 6 6 6 6 6 6 G 1 <ref> [12; 1; 12] </ref> 0 0 0 G 3 [12; 4; 6] 0 x 2 x 12 3 7 7 7 7 7 7 : The x i 's are distance 2 from each other, and distance 4 from C 3 . <p> Split linear programming gives a lower bound of 26 such codewords in any [13j13; 9; 14] code. 20 F. Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be <ref> [16; 1; 16] </ref>, [16; 5; 8], [16; 11; 4] and [16; 15; 2]. F.1 Best [16j16; k; 16] codes Either split linear programming or the Y1/Plotkin argument show that k 12. <p> This gives 759 codewords of normalized weight 16. This number can be reduced to 503 as follows. We use an X 4 construction with C 1 the <ref> [16; 1; 16] </ref> code, C 3 the [16; 5; 8] first order Reed-Muller code, and C 4 the extended Hamming [16; 11; 4] code. This still leaves C 2 to be chosen. <p> The resulting code has generator matrix 2 4 G 3 G 2 7 where G 3 generates the [16; 8; 2] code <ref> [8; 8; 1] </ref> [2; 1; 2]. We find from [5, Table III-B] that a U 16 intersects every codeword of weight 8 from the Golay code in at least two places, and there are 16 such codewords that intersect in exactly two places. <p> The resulting code has generator matrix 2 4 G 3 G 2 7 where G 3 generates the [16; 8; 2] code [8; 8; 1] <ref> [2; 1; 2] </ref>. We find from [5, Table III-B] that a U 16 intersects every codeword of weight 8 from the Golay code in at least two places, and there are 16 such codewords that intersect in exactly two places. <p> The word x i + x j is a word of weight 4 or 8 concatenated with the <ref> [2; 1; 2] </ref> repetition code, and is thus distance at least 4 from the word of weight 6 concatenated with the [2; 1; 2] repetition code. We conclude that this is a [16j16j16; 28; 16] code. There are 1671 codewords of minimum normalized weight. <p> The word x i + x j is a word of weight 4 or 8 concatenated with the <ref> [2; 1; 2] </ref> repetition code, and is thus distance at least 4 from the word of weight 6 concatenated with the [2; 1; 2] repetition code. We conclude that this is a [16j16j16; 28; 16] code. There are 1671 codewords of minimum normalized weight. <p> The case n = 6 above is straightforward. For n = 12, the baseline codes are <ref> [12; 1; 12] </ref>, [12; 7; 4] and [12; 11; 2]. To construct a [12j12; 12; 12] ffi code, we take the [24; 12] Golay code and partition into two U 12 's. <p> Codes of highest dimension in the range 7 to 10 are produced by shortening and puncturing a [10j10; 10; &gt; 10] ffi code. To construct this code, we note that since the past subcode must have dimension zero, the punctured future subcode must be the <ref> [10; 10; 1] </ref> code. Taking an identity matrix on the right of the generator matrix, the rows on the left must have Hamming weight at least 7, and be distance at least 4 apart.
Reference: [2] <author> A. G. Burr, </author> <title> Maximum likelihood and multistage decoding for optimised multilevel coded modulation, </title> <booktitle> in Proc. 1998 Information Theory Workshop (Killarney, </booktitle> <address> Ireland, </address> <month> June </month> <year> 1998), </year> <pages> pp. 8182. </pages>
Reference-contexts: Several alternative approaches have been proposed recently to the code design problem for regular BCM: for example, the capacity rule [10] in which rates are assigned to the component codes according to random coding principles, and the error probability rule <ref> [2, 3, 29] </ref> in which the component codes are chosen to balance the individual error probabilities at all coding levels. (Indeed, Wachsmann and Huber [29] go so far as to suggest that virtually any technique except the traditional Euclidean distance approach will work well!) Kasami et al. [14] discuss block coded <p> The results are summarized in Table I. A. Best codes for QAM-based BCMIM systems with basic block length 8 The codes in the baseline BCM system will be [8; 1; 8], [8; 4; 4], <ref> [8; 7; 2] </ref> and [8; 8; 1] codes, as given by Cusack [6]. The case n = d n = 8 is a main focus of the papers of Lin et al. <p> 0 0 0 0 0 1 1 1 1 1 1 1 1 7 7 7 7 7 5 This code can be obtained from an X 4 construction, with C 1 an [8; 1; 8] code, C 2 and C 3 [8; 4; 4] codes, and C 4 an <ref> [8; 7; 2] </ref> code. (The reference [17] cites [26], which introduces the X 4 construction.) (None of the other constructions of Section III give k = 8. <p> the first 8 bits to be any eight bits that form the support of a codeword.) A.2 Best [8j8j8; k; 8] codes The baseline [8j8j8; k; 8] code is obtained by a direct sum of an [8j8; k 2 ; 8] code for the first two basic blocks and an <ref> [8; 7; 2] </ref> code for the third basic block. Thus using the above code, we can achieve dimension 15 without extending the interblock memory to include the third basic block. <p> This can in fact be achieved by the code considered by Lin et al. [18] in which the [8j8; 8; 8] code for the first two basic blocks and the <ref> [8; 7; 2] </ref> baseline code for the third basic block are glued by the word fi fl This code has the disadvantage that it has 131 codewords of minimum normalized weight. <p> Best codes for QAM-based BCMIM systems with basic block length 9 The codes in a baseline BCM system are [9; 1; 9], <ref> [9; 2; 6] </ref>, [9; 5; 3] and [9; 8; 2]. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. <p> Best codes for QAM-based BCMIM systems with basic block length 9 The codes in a baseline BCM system are [9; 1; 9], [9; 2; 6], [9; 5; 3] and <ref> [9; 8; 2] </ref>. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. <p> in a baseline BCM system are [9; 1; 9], <ref> [9; 2; 6] </ref>, [9; 5; 3] and [9; 8; 2]. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. Applying split weight linear programming to this case indicates that k 7. <p> The punctured future code C f g is then a [9; 7] code, and its dual C ? fg is a <ref> [9; 2; 6] </ref> code. <p> Then applying Y1 with m = 5 gives a code with n 1 = 9, n 2 = 4, and k 3. But the Plotkin bound for this case gives M 10=(10 (9=2 + 4)) &lt; 7. Thus we conclude that C ? fg is the unique <ref> [9; 2; 6] </ref> linear code. <p> There are at least two inequivalent codes that satisfy these constraints. The first is obtained by a version of Piret's construction [21, pp. 5889] applied to the <ref> [9; 6; 2] </ref> irreducible cyclic code. <p> partition and augment the first type to get a [9j9; 7; 10] code. (For example, split linear programming shows that no [9j9; 7; 10] code can contain a codeword with Hamming weight 16.) Split linear programming, constraining the code to have 128 codewords, normalized distance 10 and to have a <ref> [9; 2; 6] </ref> code as dual of the punctured future code gives a lower bound of 31 codewords of minimum normalized weight. <p> Many are ruled out by the extra constraint that the punctured future code is the dual of the <ref> [9; 2; 6] </ref> code. We do not know of any such code with 31 codewords of minimum normalized weight, though an integer weight enumerator, with integer dual weight enumerator, exists. <p> We omit the details. C. Best codes for QAM-based BCMIM systems with basic block length 10 The codes in a baseline BCM system are [10; 1; 10], [10; 3; 5], [10; 6; 3], and <ref> [10; 9; 2] </ref>. 16 C.1 Best [10j10; k; 10] codes With no interblock memory between the first two blocks, the baseline BCM system gives k = 4. Split linear programming gives k 8, and this bound can easily be achieved by modifying the [24; 12] Golay code. <p> This upper bound is achievable. We form a [10j10; 8; 10] code by partitioning the Golay code into two U 12 's, then shortening in two positions on either side. The punctured past and future codes are both <ref> [10; 8; 2] </ref> codes in which one of the cosets has weight enumerator 25x 2 + 100x 4 + 110x 6 + 20x 8 + x 10 . <p> The code therefore has minimum normalized weight 10 with 68 codewords of this normalized weight. 17 D. Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and <ref> [11; 10; 2] </ref>, and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and [12; 11; 2] respectively. <p> Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and [11; 10; 2], and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and <ref> [12; 11; 2] </ref> respectively. The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. <p> However, if such a (linear) code existed, it would have a past shortened subcode p of dimension 0 by the Griesmer argument, so the punctured future code would be an [11; 9] code. The dual would be an <ref> [11; 2; 7] </ref> code, and a Y1 shortening would give an [11j4; 3; 11] code, which the Plotkin bound shows cannot exist. <p> Split linear programming gives a lower bound of 26 such codewords in any [13j13; 9; 14] code. 20 F. Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be [16; 1; 16], [16; 5; 8], [16; 11; 4] and <ref> [16; 15; 2] </ref>. F.1 Best [16j16; k; 16] codes Either split linear programming or the Y1/Plotkin argument show that k 12. This can be achieved using the duplication construction, starting with the [24; 12] Golay code, and forming the first block by duplicating an arbitrary subset of eight bits. <p> The resulting code has generator matrix 2 4 G 3 G 2 7 where G 3 generates the <ref> [16; 8; 2] </ref> code [8; 8; 1] [2; 1; 2]. We find from [5, Table III-B] that a U 16 intersects every codeword of weight 8 from the Golay code in at least two places, and there are 16 such codewords that intersect in exactly two places. <p> The resulting code has generator matrix 2 4 G 3 G 2 7 where G 3 generates the [16; 8; 2] code [8; 8; 1] <ref> [2; 1; 2] </ref>. We find from [5, Table III-B] that a U 16 intersects every codeword of weight 8 from the Golay code in at least two places, and there are 16 such codewords that intersect in exactly two places. <p> Thus the punctured future code hG 1 ; G 2 i is a <ref> [16; 12; 2] </ref> (even) code, and furthermore has covering radius 2 since there are too many codewords of weight 2 for the covering radius to be 1. <p> The word x i + x j is a word of weight 4 or 8 concatenated with the <ref> [2; 1; 2] </ref> repetition code, and is thus distance at least 4 from the word of weight 6 concatenated with the [2; 1; 2] repetition code. We conclude that this is a [16j16j16; 28; 16] code. There are 1671 codewords of minimum normalized weight. <p> The word x i + x j is a word of weight 4 or 8 concatenated with the <ref> [2; 1; 2] </ref> repetition code, and is thus distance at least 4 from the word of weight 6 concatenated with the [2; 1; 2] repetition code. We conclude that this is a [16j16j16; 28; 16] code. There are 1671 codewords of minimum normalized weight. <p> The case n = 6 above is straightforward. For n = 12, the baseline codes are [12; 1; 12], [12; 7; 4] and <ref> [12; 11; 2] </ref>. To construct a [12j12; 12; 12] ffi code, we take the [24; 12] Golay code and partition into two U 12 's. <p> This can be achieved in each case, without increasing the number of minimum normalized weight codewords, by a gluing code of dimension 1. Thus in each case, we take the best [njn; k; d n ] ffi code for the first two basic blocks, an <ref> [n; n 1; 2] </ref> even weight code as shortened future code, and glue these together by adding a word of length 3n to the generator matrix. <p> For n = 7, we glue the [7j7; 7; 8:8] ffi code for the first two basic blocks and the <ref> [7; 6; 2] </ref> code for the third basic block using the gluing code with generator matrix fi fl and similarly for n = 8. For n = 10, the gluing code again has weight 0 in the middle block, and weight 1 in the third block.
Reference: [3] <author> A. G. Burr and T. J. Lunn, </author> <title> Block-coded modulation optimized for finite error rate on the white Gaussian noise channel, </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> vol. 43, no. 1, </volume> <pages> pp. 373385, </pages> <month> Jan. </month> <year> 1997. </year>
Reference-contexts: Several alternative approaches have been proposed recently to the code design problem for regular BCM: for example, the capacity rule [10] in which rates are assigned to the component codes according to random coding principles, and the error probability rule <ref> [2, 3, 29] </ref> in which the component codes are chosen to balance the individual error probabilities at all coding levels. (Indeed, Wachsmann and Huber [29] go so far as to suggest that virtually any technique except the traditional Euclidean distance approach will work well!) Kasami et al. [14] discuss block coded <p> Best codes for QAM-based BCMIM systems with basic block length 9 The codes in a baseline BCM system are [9; 1; 9], [9; 2; 6], <ref> [9; 5; 3] </ref> and [9; 8; 2]. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. <p> We omit the details. C. Best codes for QAM-based BCMIM systems with basic block length 10 The codes in a baseline BCM system are [10; 1; 10], <ref> [10; 3; 5] </ref>, [10; 6; 3], and [10; 9; 2]. 16 C.1 Best [10j10; k; 10] codes With no interblock memory between the first two blocks, the baseline BCM system gives k = 4. <p> We omit the details. C. Best codes for QAM-based BCMIM systems with basic block length 10 The codes in a baseline BCM system are [10; 1; 10], [10; 3; 5], <ref> [10; 6; 3] </ref>, and [10; 9; 2]. 16 C.1 Best [10j10; k; 10] codes With no interblock memory between the first two blocks, the baseline BCM system gives k = 4. <p> The code therefore has minimum normalized weight 10 with 68 codewords of this normalized weight. 17 D. Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], <ref> [11; 3; 6] </ref>, [11; 6; 4] and [11; 10; 2], and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and [12; 11; 2] respectively. <p> Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and [11; 10; 2], and [12; 1; 12], [12; 4; 6], <ref> [12; 8; 3] </ref>; and [12; 11; 2] respectively. The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. <p> However, if such a (linear) code existed, it would have a past shortened subcode p of dimension 0 by the Griesmer argument, so the punctured future code would be an [11; 9] code. The dual would be an [11; 2; 7] code, and a Y1 shortening would give an <ref> [11j4; 3; 11] </ref> code, which the Plotkin bound shows cannot exist. <p> Taking the dual of this simplex code and shortening in the same three positions gives a <ref> [12; 8; 3] </ref> shortened Hamming code C 2 that contains C 1 as a subcode. Applying the reverse-X construction gives a [12j12; 8; 12] code; we need to augment this to get a k = 9 code. <p> There are 214 codewords of minimum normalized weight. To form a [12j12j12j12; k; 12] code, we take a generator matrix of the form 19 6 6 6 6 6 6 6 6 6 6 4 G 2 [12; 4; 6] G 4 <ref> [12; 4; 3] </ref> 0 0 x 1 . . . 0 I 12 0 y 2 y 12 3 7 7 7 7 7 7 7 7 7 7 : The words y 1 ; : : : ; y 12 are words of weight 6, each from distinct cosets with <p> V. 24 TABLE V COMPARISON TO LONGER BASELINE BCM FOR QAM-BASED SYSTEMS Rate, bits/2n symbols Min. (norm.) wt. codewords Component codes n d n BCMIM BCM BCMIM BCM for BCM 8 8 16 16 71 30 & 140 [16; 5; 8] fl 9 10 14 12 31-33 6 & 0 <ref> [18; 3; 10] </ref> 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 <p> n BCMIM BCM BCMIM BCM for BCM 8 8 16 16 71 30 & 140 [16; 5; 8] fl 9 10 14 12 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 <ref> [22; 3; 12] </ref> 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 <p> 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) <ref> [26; 3; 14] </ref> 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 16 24 23 271-503 62 & (263-908) [32; 6; 16] fl The number of apparent nearest neighbors in a BCM system depends on
Reference: [4] <author> A. R. Calderbank, </author> <title> Muli-level codes and multi-stage decoding, </title> <journal> IEEE Trans. Commun., </journal> <volume> vol. COM-37, no. 3, </volume> <pages> pp. 222229, </pages> <month> Mar. </month> <year> 1990. </year>
Reference-contexts: We concentrate on the natural case in which the normalized distance is equal to the basic block length. The results are summarized in Table I. A. Best codes for QAM-based BCMIM systems with basic block length 8 The codes in the baseline BCM system will be [8; 1; 8], <ref> [8; 4; 4] </ref>, [8; 7; 2] and [8; 8; 1] codes, as given by Cusack [6]. The case n = d n = 8 is a main focus of the papers of Lin et al. <p> A.1 Best [8j8; k; 8] codes If we allow interblock memory between the first two basic blocks, we are seeking the best [8j8; k; 8] code. The baseline BCM case with no interblock memory is obtained by taking the direct sum of the [8; 1; 8] code and the <ref> [8; 4; 4] </ref> code, and so has dimension 5. From the full dimension lemma, the gain in dimension when interblock memory is introduced is upper bounded by n K (n; d n =a 2 ) = 8 4 = 4. <p> 1 0 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 7 7 7 7 7 5 This code can be obtained from an X 4 construction, with C 1 an [8; 1; 8] code, C 2 and C 3 <ref> [8; 4; 4] </ref> codes, and C 4 an [8; 7; 2] code. (The reference [17] cites [26], which introduces the X 4 construction.) (None of the other constructions of Section III give k = 8. <p> These can only be obtained by taking the 14 codewords of weight 4 from an <ref> [8; 4; 4] </ref> Hamming code and selecting one word out of every complementary pair. All such choices lead to the same code up to permutation. <p> Also any row of weight 4 of X must be at distance 2 from the <ref> [8; 4] </ref> Hamming code at the left of G 8=2 . We conclude that without loss of generality the rows of X have weight either 2 or 4, and the last eight rows of the overall matrix have weights of the form (2j1j1), (4j1j1), or (4j0j1). <p> We therefore fill all rows of X with words of weight 4 that are distinct from each other and their converses and the words of the <ref> [8; 4] </ref> Hamming code above (there are more than enough to make this possible) and get a code with 87 minimum normalized weight codewords (71 from G 8=2 and 16 more from the rows involving X ). A generator matrix that results from this procedure is given in Table III. <p> The code therefore has minimum normalized weight 10 with 68 codewords of this normalized weight. 17 D. Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], <ref> [11; 6; 4] </ref> and [11; 10; 2], and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and [12; 11; 2] respectively. <p> Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and [11; 10; 2], and [12; 1; 12], <ref> [12; 4; 6] </ref>, [12; 8; 3]; and [12; 11; 2] respectively. <p> The systems without interblock memory therefore give <ref> [11j11; 4; 11] </ref>, [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. <p> We can however construct codes with the next higher dimensions, i.e., [12j12; 9; 12] and (by shortening/puncturing) [11j11; 8; 11] codes. We use a reverse-X construction. Taking a <ref> [15; 4; 8] </ref> simplex code and puncturing in three positions that hold a codeword in the dual code gives a [12; 4; 6] code with weight enumerator 1 + 12x 6 + 3x 8 , which we use as both C 1 and C 3 . <p> We can however construct codes with the next higher dimensions, i.e., [12j12; 9; 12] and (by shortening/puncturing) [11j11; 8; 11] codes. We use a reverse-X construction. Taking a [15; 4; 8] simplex code and puncturing in three positions that hold a codeword in the dual code gives a <ref> [12; 4; 6] </ref> code with weight enumerator 1 + 12x 6 + 3x 8 , which we use as both C 1 and C 3 . <p> We omit the details. D.2 Best [12j12j12; k; 12] and [12j12j12j12; k; 12] codes We will use the same approach to construct a [12j12j12; 21; 12] code as in the basic block length 10 case. The <ref> [12; 4; 6] </ref> punctured simplex code above has 48 cosets with weight enumerator 5x 4 + 7x 6 + 3x 8 + x 10 . We choose x 1 ; : : : ; x 12 to be words of weight 4 from distinct cosets among these. <p> We choose x 1 ; : : : ; x 12 to be words of weight 4 from distinct cosets among these. We form the generator matrix 2 6 6 6 6 6 6 G 1 [12; 1; 12] 0 0 0 G 3 <ref> [12; 4; 6] </ref> 0 x 2 x 12 3 7 7 7 7 7 7 : The x i 's are distance 2 from each other, and distance 4 from C 3 . They are distance at least 1 from hG 3 ; G 4 i. <p> The normalized weight is thus at least 12. There are 214 codewords of minimum normalized weight. To form a [12j12j12j12; k; 12] code, we take a generator matrix of the form 19 6 6 6 6 6 6 6 6 6 6 4 G 2 <ref> [12; 4; 6] </ref> G 4 [12; 4; 3] 0 0 x 1 . . . 0 I 12 0 y 2 y 12 3 7 7 7 7 7 7 7 7 7 7 : The words y 1 ; : : : ; y 12 are words of weight 6, <p> There are 214 codewords of minimum normalized weight. To form a [12j12j12j12; k; 12] code, we take a generator matrix of the form 19 6 6 6 6 6 6 6 6 6 6 4 G 2 [12; 4; 6] G 4 <ref> [12; 4; 3] </ref> 0 0 x 1 . . . 0 I 12 0 y 2 y 12 3 7 7 7 7 7 7 7 7 7 7 : The words y 1 ; : : : ; y 12 are words of weight 6, each from distinct cosets with <p> 7 7 7 7 7 7 7 7 7 7 : The words y 1 ; : : : ; y 12 are words of weight 6, each from distinct cosets with weight enumerator x 2 + 8x 4 + 14x 6 + 8x 8 + x 10 of the <ref> [12; 5; 4] </ref> code hC 2 ; 1i above. The only case that needs to be checked is the case (y i j0j0je i ) + (vjuj0j0), which has weight distribution (2j 3j0j1). <p> The augmented word is normalized distance at least 6 + 2 wt y from codewords of the [10j14; 8; 14] code. We therefore choose the five positions from the [19; 8; 7] code to double so that the <ref> [14; 8; 4] </ref> punctured future code has covering radius 4. Equivalently we seek to puncture the [19; 8; 7] code in five positions, in such a way that the resulting [14; 8] code has covering radius at least 4. Some trial and error shows that this is possible. <p> Split linear programming gives a lower bound of 26 such codewords in any [13j13; 9; 14] code. 20 F. Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be [16; 1; 16], [16; 5; 8], <ref> [16; 11; 4] </ref> and [16; 15; 2]. F.1 Best [16j16; k; 16] codes Either split linear programming or the Y1/Plotkin argument show that k 12. <p> This gives 759 codewords of normalized weight 16. This number can be reduced to 503 as follows. We use an X 4 construction with C 1 the [16; 1; 16] code, C 3 the [16; 5; 8] first order Reed-Muller code, and C 4 the extended Hamming <ref> [16; 11; 4] </ref> code. This still leaves C 2 to be chosen. <p> We use an X 4 construction with C 1 the [16; 1; 16] code, C 3 the [16; 5; 8] first order Reed-Muller code, and C 4 the extended Hamming [16; 11; 4] code. This still leaves C 2 to be chosen. We choose C 2 to be the <ref> [16; 7; 4] </ref> doubly even code formed by taking the [16; 5; 8] first order Reed-Muller code, plus two linearly independent cosets; we choose the cosets so that they both have weight enumerators 4x 4 + 24x 8 + 4x 12 , and their `sum' (i.e., the translate of one coset <p> Note that other cases give normalized weight 16 regardless of the choice of the x i 's. We can find such x i 's by concatenating the <ref> [8; 4; 4] </ref> Hamming code with the (2; 2; 2) nonlinear code f01; 10g. The resulting x i 's all have weight exactly 8, are distance exactly 8 or 16 apart, and distance exactly 8 from C 3 . <p> The case n = 6 above is straightforward. For n = 12, the baseline codes are [12; 1; 12], <ref> [12; 7; 4] </ref> and [12; 11; 2]. To construct a [12j12; 12; 12] ffi code, we take the [24; 12] Golay code and partition into two U 12 's. <p> SYSTEMS Rate, bits/2n symbols Min. (norm.) wt. codewords Component codes n d n BCMIM BCM BCMIM BCM for BCM 8 8 16 16 71 30 & 140 [16; 5; 8] fl 9 10 14 12 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) <ref> [20; 4; 10] </ref> 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15
Reference: [5] <author> J. H. Conway and N. J. A. Sloane, </author> <title> Orbit and coset analysis of the Golay and related codes, </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> vol. 36, no. 5, </volume> <pages> pp. 10381050, </pages> <month> Sep. </month> <year> 1990. </year>
Reference-contexts: All such choices lead to the same code up to permutation. We note that the best [16; 8] code in terms of ordinary Hamming distance, a <ref> [16; 8; 5] </ref> shortened quadratic residue code, also unique [25], cannot by the above discussion be partitioned into two halves to get normalized distance 8 (though 7 is possible). <p> Best codes for QAM-based BCMIM systems with basic block length 9 The codes in a baseline BCM system are [9; 1; 9], [9; 2; 6], <ref> [9; 5; 3] </ref> and [9; 8; 2]. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. <p> We omit the details. C. Best codes for QAM-based BCMIM systems with basic block length 10 The codes in a baseline BCM system are [10; 1; 10], <ref> [10; 3; 5] </ref>, [10; 6; 3], and [10; 9; 2]. 16 C.1 Best [10j10; k; 10] codes With no interblock memory between the first two blocks, the baseline BCM system gives k = 4. <p> This code has 20 codewords of minimum normalized weight. A slightly more complicated construction allows us to reduce this number of normalized weight 10 code-words. We partition the Golay code in such a way that each side forms an X 12 , in the notation of <ref> [5] </ref>. Each side contains exactly three codewords of weight 8: (1 8 0 4 ); (1 4 0 4 1 4 ); and (0 4 1 8 ) up to permutation. <p> The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and <ref> [12j12; 5; 12] </ref>, [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. The case n = d n = 11 is interesting as the first case in which the split linear programming bound on dimension is not tight when i = 2. <p> 7 7 7 7 7 7 7 7 7 7 : The words y 1 ; : : : ; y 12 are words of weight 6, each from distinct cosets with weight enumerator x 2 + 8x 4 + 14x 6 + 8x 8 + x 10 of the <ref> [12; 5; 4] </ref> code hC 2 ; 1i above. The only case that needs to be checked is the case (y i j0j0je i ) + (vjuj0j0), which has weight distribution (2j 3j0j1). <p> Split linear programming gives a lower bound of 26 such codewords in any [13j13; 9; 14] code. 20 F. Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be [16; 1; 16], <ref> [16; 5; 8] </ref>, [16; 11; 4] and [16; 15; 2]. F.1 Best [16j16; k; 16] codes Either split linear programming or the Y1/Plotkin argument show that k 12. <p> This gives 759 codewords of normalized weight 16. This number can be reduced to 503 as follows. We use an X 4 construction with C 1 the [16; 1; 16] code, C 3 the <ref> [16; 5; 8] </ref> first order Reed-Muller code, and C 4 the extended Hamming [16; 11; 4] code. This still leaves C 2 to be chosen. We choose C 2 to be the [16; 7; 4] doubly even code formed by taking the [16; 5; 8] first order Reed-Muller code, plus two <p> the [16; 1; 16] code, C 3 the <ref> [16; 5; 8] </ref> first order Reed-Muller code, and C 4 the extended Hamming [16; 11; 4] code. This still leaves C 2 to be chosen. We choose C 2 to be the [16; 7; 4] doubly even code formed by taking the [16; 5; 8] first order Reed-Muller code, plus two linearly independent cosets; we choose the cosets so that they both have weight enumerators 4x 4 + 24x 8 + 4x 12 , and their `sum' (i.e., the translate of one coset by any element of the other coset) has the same <p> We can achieve this upper bound using the following construction. We begin by forming a [16j16; 12; 16] code C from the Golay code by partitioning the 24 positions of the Golay code into a U 8 and U 16 , again in the notation of <ref> [5] </ref>, then bringing the U 8 to the left and doubling it. The resulting code has generator matrix 2 4 G 3 G 2 7 where G 3 generates the [16; 8; 2] code [8; 8; 1] [2; 1; 2]. <p> The resulting code has generator matrix 2 4 G 3 G 2 7 where G 3 generates the [16; 8; 2] code [8; 8; 1] [2; 1; 2]. We find from <ref> [5, Table III-B] </ref> that a U 16 intersects every codeword of weight 8 from the Golay code in at least two places, and there are 16 such codewords that intersect in exactly two places. <p> are compared on this basis to longer baseline BCM systems in Table V. 24 TABLE V COMPARISON TO LONGER BASELINE BCM FOR QAM-BASED SYSTEMS Rate, bits/2n symbols Min. (norm.) wt. codewords Component codes n d n BCMIM BCM BCMIM BCM for BCM 8 8 16 16 71 30 & 140 <ref> [16; 5; 8] </ref> fl 9 10 14 12 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 <p> 71 30 & 140 [16; 5; 8] fl 9 10 14 12 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 <ref> [24; 5; 12] </ref> fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 16 24 23 271-503 62 & (263-908) [32; 6; 16] fl <p> 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 <ref> [28; 5; 14] </ref> fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 16 24 23 271-503 62 & (263-908) [32; 6; 16] fl The number of apparent nearest neighbors in a BCM system depends on the transmitted sequence and the overall modulation scheme into which the <p> 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 <ref> [30; 5; 15] </ref> fl 16 16 24 23 271-503 62 & (263-908) [32; 6; 16] fl The number of apparent nearest neighbors in a BCM system depends on the transmitted sequence and the overall modulation scheme into which the codes are embedded.
Reference: [6] <author> E. L. Cusack, </author> <title> Error control codes for QAM signaling, </title> <journal> Elec. Letters, </journal> <volume> vol. 20, no. 2, </volume> <pages> pp. 6263, </pages> <month> Jan. </month> <year> 1984. </year>
Reference-contexts: The results are summarized in Table I. A. Best codes for QAM-based BCMIM systems with basic block length 8 The codes in the baseline BCM system will be [8; 1; 8], [8; 4; 4], [8; 7; 2] and [8; 8; 1] codes, as given by Cusack <ref> [6] </ref>. The case n = d n = 8 is a main focus of the papers of Lin et al. Lin and Ma give an [8j8; 8; 8] code [17] and Lin, Wang, and Ma follow by extending this to an [8j8j8; 16; 8] code [18]. <p> Best codes for QAM-based BCMIM systems with basic block length 9 The codes in a baseline BCM system are [9; 1; 9], <ref> [9; 2; 6] </ref>, [9; 5; 3] and [9; 8; 2]. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. <p> in a baseline BCM system are [9; 1; 9], <ref> [9; 2; 6] </ref>, [9; 5; 3] and [9; 8; 2]. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. Applying split weight linear programming to this case indicates that k 7. <p> The punctured future code C f g is then a [9; 7] code, and its dual C ? fg is a <ref> [9; 2; 6] </ref> code. <p> Then applying Y1 with m = 5 gives a code with n 1 = 9, n 2 = 4, and k 3. But the Plotkin bound for this case gives M 10=(10 (9=2 + 4)) &lt; 7. Thus we conclude that C ? fg is the unique <ref> [9; 2; 6] </ref> linear code. <p> There are at least two inequivalent codes that satisfy these constraints. The first is obtained by a version of Piret's construction [21, pp. 5889] applied to the <ref> [9; 6; 2] </ref> irreducible cyclic code. <p> j, so the (unique) best choice for a in this case is 3, giving d ? = 10. (The factor 2 on the right of the expression for d 0 and the corresponding optimal choice of a are the only differences with the development in [21].) This results in a <ref> [9j9; 6; 10] </ref> code, and adding the row (0 9 j1 9 ) to the generator matrix does not affect the minimum normalized distance, thus giving a [9j9; 7; 10] code. (A brute force search showed that adding the row (r l j1 9 ) for any r l 6= 0 <p> 7 7 5 which has 33 codewords of minimum normalized weight. (This code has more codewords of the next higher weight than the code based on Piret's construction, however: 36 codewords of normalized weight 12, versus 27.) The even (Hamming) weight subcode obtained by deleting the first row is an <ref> [18; 6; 8] </ref> code. It is known [7] that there are exactly two such codes up to equivalence, both obtainable by shortening the [24; 12] Golay code. <p> partition and augment the first type to get a [9j9; 7; 10] code. (For example, split linear programming shows that no [9j9; 7; 10] code can contain a codeword with Hamming weight 16.) Split linear programming, constraining the code to have 128 codewords, normalized distance 10 and to have a <ref> [9; 2; 6] </ref> code as dual of the punctured future code gives a lower bound of 31 codewords of minimum normalized weight. <p> Many are ruled out by the extra constraint that the punctured future code is the dual of the <ref> [9; 2; 6] </ref> code. We do not know of any such code with 31 codewords of minimum normalized weight, though an integer weight enumerator, with integer dual weight enumerator, exists. <p> We omit the details. C. Best codes for QAM-based BCMIM systems with basic block length 10 The codes in a baseline BCM system are [10; 1; 10], [10; 3; 5], <ref> [10; 6; 3] </ref>, and [10; 9; 2]. 16 C.1 Best [10j10; k; 10] codes With no interblock memory between the first two blocks, the baseline BCM system gives k = 4. <p> The code therefore has minimum normalized weight 10 with 68 codewords of this normalized weight. 17 D. Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], <ref> [11; 3; 6] </ref>, [11; 6; 4] and [11; 10; 2], and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and [12; 11; 2] respectively. <p> The code therefore has minimum normalized weight 10 with 68 codewords of this normalized weight. 17 D. Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], <ref> [11; 6; 4] </ref> and [11; 10; 2], and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and [12; 11; 2] respectively. <p> Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and [11; 10; 2], and [12; 1; 12], <ref> [12; 4; 6] </ref>, [12; 8; 3]; and [12; 11; 2] respectively. <p> We can however construct codes with the next higher dimensions, i.e., [12j12; 9; 12] and (by shortening/puncturing) [11j11; 8; 11] codes. We use a reverse-X construction. Taking a [15; 4; 8] simplex code and puncturing in three positions that hold a codeword in the dual code gives a <ref> [12; 4; 6] </ref> code with weight enumerator 1 + 12x 6 + 3x 8 , which we use as both C 1 and C 3 . <p> We omit the details. D.2 Best [12j12j12; k; 12] and [12j12j12j12; k; 12] codes We will use the same approach to construct a [12j12j12; 21; 12] code as in the basic block length 10 case. The <ref> [12; 4; 6] </ref> punctured simplex code above has 48 cosets with weight enumerator 5x 4 + 7x 6 + 3x 8 + x 10 . We choose x 1 ; : : : ; x 12 to be words of weight 4 from distinct cosets among these. <p> We choose x 1 ; : : : ; x 12 to be words of weight 4 from distinct cosets among these. We form the generator matrix 2 6 6 6 6 6 6 G 1 [12; 1; 12] 0 0 0 G 3 <ref> [12; 4; 6] </ref> 0 x 2 x 12 3 7 7 7 7 7 7 : The x i 's are distance 2 from each other, and distance 4 from C 3 . They are distance at least 1 from hG 3 ; G 4 i. <p> The normalized weight is thus at least 12. There are 214 codewords of minimum normalized weight. To form a [12j12j12j12; k; 12] code, we take a generator matrix of the form 19 6 6 6 6 6 6 6 6 6 6 4 G 2 <ref> [12; 4; 6] </ref> G 4 [12; 4; 3] 0 0 x 1 . . . 0 I 12 0 y 2 y 12 3 7 7 7 7 7 7 7 7 7 7 : The words y 1 ; : : : ; y 12 are words of weight 6, <p> For n = 7, we glue the [7j7; 7; 8:8] ffi code for the first two basic blocks and the <ref> [7; 6; 2] </ref> code for the third basic block using the gluing code with generator matrix fi fl and similarly for n = 8. For n = 10, the gluing code again has weight 0 in the middle block, and weight 1 in the third block. <p> 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 16 24 23 271-503 62 & (263-908) <ref> [32; 6; 16] </ref> fl The number of apparent nearest neighbors in a BCM system depends on the transmitted sequence and the overall modulation scheme into which the codes are embedded. <p> The star on some BCM component codes indicates that the code is known to be unique. A number as superscript indicates that there are exactly that many inequivalent codes with the given parameters. The information is taken from Jaffe's table [12], except for the uniqueness of the <ref> [18; 9; 6] </ref> code, obtained by Simonis [25]. From the table, the BCMIM system has higher rate in all cases except basic block lengths 8 and 12.
Reference: [7] <author> S. M. Dodunekov and S. B. Encheva, </author> <title> Uniqueness of some linear subcodes of the extended binary Golay code, Probl. </title> <journal> Peredachi Inform., </journal> <volume> vol. 29, no. 1, </volume> <pages> pp. 4551, </pages> <address> Jan.Mar. </address> <year> 1993. </year> <title> (In Russian. English translation in Probl. </title> <journal> Inform. Trans., </journal> <volume> vol. 29, no. 1, </volume> <pages> pp. 3843, </pages> <address> Jan.Mar. 1993.). </address>
Reference-contexts: The results are summarized in Table I. A. Best codes for QAM-based BCMIM systems with basic block length 8 The codes in the baseline BCM system will be [8; 1; 8], [8; 4; 4], <ref> [8; 7; 2] </ref> and [8; 8; 1] codes, as given by Cusack [6]. The case n = d n = 8 is a main focus of the papers of Lin et al. <p> 0 0 0 0 0 1 1 1 1 1 1 1 1 7 7 7 7 7 5 This code can be obtained from an X 4 construction, with C 1 an [8; 1; 8] code, C 2 and C 3 [8; 4; 4] codes, and C 4 an <ref> [8; 7; 2] </ref> code. (The reference [17] cites [26], which introduces the X 4 construction.) (None of the other constructions of Section III give k = 8. <p> the first 8 bits to be any eight bits that form the support of a codeword.) A.2 Best [8j8j8; k; 8] codes The baseline [8j8j8; k; 8] code is obtained by a direct sum of an [8j8; k 2 ; 8] code for the first two basic blocks and an <ref> [8; 7; 2] </ref> code for the third basic block. Thus using the above code, we can achieve dimension 15 without extending the interblock memory to include the third basic block. <p> This can in fact be achieved by the code considered by Lin et al. [18] in which the [8j8; 8; 8] code for the first two basic blocks and the <ref> [8; 7; 2] </ref> baseline code for the third basic block are glued by the word fi fl This code has the disadvantage that it has 131 codewords of minimum normalized weight. <p> On fixing the number of codewords accordingly at 128 and using split weight linear programming to minimize the number of codewords with minimum normalized weight 9, we find that the minimum of the objective is 0. This suggests that we might be able to find a <ref> [9j9; 7; 10] </ref> code. This is in fact possible, and we will give a couple of different constructions. This case is also interesting in that it is the first case in which the Griesmer-type bound of Section III-A.2 is not tight (see Table I). <p> Since the Griesmer argument indicates that k 6 if k p = 1, we must have k p = 0, and so k f + k g = 7. The punctured future code C f g is then a <ref> [9; 7] </ref> code, and its dual C ? fg is a [9; 2; 6] code. <p> for d 0 and the corresponding optimal choice of a are the only differences with the development in [21].) This results in a [9j9; 6; 10] code, and adding the row (0 9 j1 9 ) to the generator matrix does not affect the minimum normalized distance, thus giving a <ref> [9j9; 7; 10] </ref> code. (A brute force search showed that adding the row (r l j1 9 ) for any r l 6= 0 9 gives a lower minimum normalized distance.) From the construction, taking the same cyclic shift of the left and right sides of a codeword produces a codeword. <p> 0 1 0 0 1 0 1 0 0 1 1 0 0 0 0 0 1 1 0 1 1 1 1 1 0 1 1 1 0 0 7 7 7 7 5 A slightly smaller number of minimum normalized weight codewords can be obtained from an optimal <ref> [18; 7; 7] </ref> code partitioned in an appropriate way. <p> It is known <ref> [7] </ref> that there are exactly two such codes up to equivalence, both obtainable by shortening the [24; 12] Golay code. The corresponding Hamming weight enumerators are 1 + 46x 8 + 16x 12 + x 16 and 1 + 45x 8 + 18x 12 . <p> The code generated by the last six rows of the matrix above has the second of these weight enumerators. There is no way to partition and augment the first type to get a <ref> [9j9; 7; 10] </ref> code. (For example, split linear programming shows that no [9j9; 7; 10] code can contain a codeword with Hamming weight 16.) Split linear programming, constraining the code to have 128 codewords, normalized distance 10 and to have a [9; 2; 6] code as dual of the punctured future <p> The code generated by the last six rows of the matrix above has the second of these weight enumerators. There is no way to partition and augment the first type to get a <ref> [9j9; 7; 10] </ref> code. (For example, split linear programming shows that no [9j9; 7; 10] code can contain a codeword with Hamming weight 16.) Split linear programming, constraining the code to have 128 codewords, normalized distance 10 and to have a [9; 2; 6] code as dual of the punctured future code gives a lower bound of 31 codewords of minimum normalized weight. <p> We remark that in the case of a <ref> [9j9; 7; 10] </ref> code, there is a particularly large number of solutions to the linear programming constraints that are feasible candidates for codes, in the sense of having nonnegative integer weights in both code and dual code. <p> However, if such a (linear) code existed, it would have a past shortened subcode p of dimension 0 by the Griesmer argument, so the punctured future code would be an [11; 9] code. The dual would be an <ref> [11; 2; 7] </ref> code, and a Y1 shortening would give an [11j4; 3; 11] code, which the Plotkin bound shows cannot exist. <p> There is one case that is not covered: the optimum dimension for a [13j13; k; 13] code is 9. However, the normalized distance can be increased to 14 without sacrificing rate. To construct such a code, we begin with the (unique) <ref> [19; 8; 7] </ref> code. We apply the expansion construction, taking five positions and doubling them for the left block, and leaving the other 14 for the right block. This produces a [10j14; 8; 14] code. <p> The augmented word is normalized distance at least 6 + 2 wt y from codewords of the [10j14; 8; 14] code. We therefore choose the five positions from the <ref> [19; 8; 7] </ref> code to double so that the [14; 8; 4] punctured future code has covering radius 4. Equivalently we seek to puncture the [19; 8; 7] code in five positions, in such a way that the resulting [14; 8] code has covering radius at least 4. <p> We therefore choose the five positions from the <ref> [19; 8; 7] </ref> code to double so that the [14; 8; 4] punctured future code has covering radius 4. Equivalently we seek to puncture the [19; 8; 7] code in five positions, in such a way that the resulting [14; 8] code has covering radius at least 4. Some trial and error shows that this is possible. <p> We use an X 4 construction with C 1 the [16; 1; 16] code, C 3 the [16; 5; 8] first order Reed-Muller code, and C 4 the extended Hamming [16; 11; 4] code. This still leaves C 2 to be chosen. We choose C 2 to be the <ref> [16; 7; 4] </ref> doubly even code formed by taking the [16; 5; 8] first order Reed-Muller code, plus two linearly independent cosets; we choose the cosets so that they both have weight enumerators 4x 4 + 24x 8 + 4x 12 , and their `sum' (i.e., the translate of one coset <p> The case n = 6 above is straightforward. For n = 12, the baseline codes are [12; 1; 12], <ref> [12; 7; 4] </ref> and [12; 11; 2]. To construct a [12j12; 12; 12] ffi code, we take the [24; 12] Golay code and partition into two U 12 's. <p> For the n = 7 case, we first construct a <ref> [7j7; 7; 8:8] </ref> ffi code by taking a generator matrix 23 with identity matrix at the right and seven distinct rows of weight 6 at the left. This gives 21 codewords of weight 8.8, which integer split linear programming shows is the minimum possible. <p> For n = 7, we glue the <ref> [7j7; 7; 8:8] </ref> ffi code for the first two basic blocks and the [7; 6; 2] code for the third basic block using the gluing code with generator matrix fi fl and similarly for n = 8. <p> For n = 7, we glue the [7j7; 7; 8:8] ffi code for the first two basic blocks and the <ref> [7; 6; 2] </ref> code for the third basic block using the gluing code with generator matrix fi fl and similarly for n = 8. For n = 10, the gluing code again has weight 0 in the middle block, and weight 1 in the third block.
Reference: [8] <author> G. D. Forney, Jr., </author> <title> Coset codesPart I: Introduction and geometrical classification, </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> vol. 34, no. 5, </volume> <pages> pp. 11231151, </pages> <month> Sep. </month> <year> 1988. </year>
Reference-contexts: Performance of BCMIM and BCM systems C. Nearest neighbors It is widely known that the most serious single disadvantage of block coded modulation schemes is the nearest neighbor problem <ref> [8, 9, 14, 31] </ref>. The standard staged decoding procedure, in which each row of the codeword array is decoded in sequence, beginning with the top row, has the effect of producing a large number of apparent nearest neighbors, i.e., a large multiplicity of the most likely error events. <p> These cause the coding gain at finite signal to noise ratios to be less than the asymptotic coding gain. The exact difference varies according to target probability of error; the usual rule of thumb, proposed by Forney <ref> [8] </ref>, is that the signal to noise ratio increases by 0.2 dB for each doubling in the number of apparent nearest neighbors for error probabilities in the range 10 5 10 6 . <p> We concentrate on the natural case in which the normalized distance is equal to the basic block length. The results are summarized in Table I. A. Best codes for QAM-based BCMIM systems with basic block length 8 The codes in the baseline BCM system will be <ref> [8; 1; 8] </ref>, [8; 4; 4], [8; 7; 2] and [8; 8; 1] codes, as given by Cusack [6]. The case n = d n = 8 is a main focus of the papers of Lin et al. <p> We concentrate on the natural case in which the normalized distance is equal to the basic block length. The results are summarized in Table I. A. Best codes for QAM-based BCMIM systems with basic block length 8 The codes in the baseline BCM system will be [8; 1; 8], <ref> [8; 4; 4] </ref>, [8; 7; 2] and [8; 8; 1] codes, as given by Cusack [6]. The case n = d n = 8 is a main focus of the papers of Lin et al. <p> The results are summarized in Table I. A. Best codes for QAM-based BCMIM systems with basic block length 8 The codes in the baseline BCM system will be [8; 1; 8], [8; 4; 4], <ref> [8; 7; 2] </ref> and [8; 8; 1] codes, as given by Cusack [6]. The case n = d n = 8 is a main focus of the papers of Lin et al. <p> The results are summarized in Table I. A. Best codes for QAM-based BCMIM systems with basic block length 8 The codes in the baseline BCM system will be [8; 1; 8], [8; 4; 4], [8; 7; 2] and <ref> [8; 8; 1] </ref> codes, as given by Cusack [6]. The case n = d n = 8 is a main focus of the papers of Lin et al. <p> The case n = d n = 8 is a main focus of the papers of Lin et al. Lin and Ma give an <ref> [8j8; 8; 8] </ref> code [17] and Lin, Wang, and Ma follow by extending this to an [8j8j8; 16; 8] code [18]. These papers give efficient trellis representations and performance simulations, but do not discuss general constructions, bounds, or optimality. <p> The case n = d n = 8 is a main focus of the papers of Lin et al. Lin and Ma give an [8j8; 8; 8] code [17] and Lin, Wang, and Ma follow by extending this to an <ref> [8j8j8; 16; 8] </ref> code [18]. These papers give efficient trellis representations and performance simulations, but do not discuss general constructions, bounds, or optimality. A.1 Best [8j8; k; 8] codes If we allow interblock memory between the first two basic blocks, we are seeking the best [8j8; k; 8] code. <p> Lin and Ma give an [8j8; 8; 8] code [17] and Lin, Wang, and Ma follow by extending this to an [8j8j8; 16; 8] code [18]. These papers give efficient trellis representations and performance simulations, but do not discuss general constructions, bounds, or optimality. A.1 Best <ref> [8j8; k; 8] </ref> codes If we allow interblock memory between the first two basic blocks, we are seeking the best [8j8; k; 8] code. <p> These papers give efficient trellis representations and performance simulations, but do not discuss general constructions, bounds, or optimality. A.1 Best <ref> [8j8; k; 8] </ref> codes If we allow interblock memory between the first two basic blocks, we are seeking the best [8j8; k; 8] code. The baseline BCM case with no interblock memory is obtained by taking the direct sum of the [8; 1; 8] code and the [8; 4; 4] code, and so has dimension 5. <p> A.1 Best [8j8; k; 8] codes If we allow interblock memory between the first two basic blocks, we are seeking the best [8j8; k; 8] code. The baseline BCM case with no interblock memory is obtained by taking the direct sum of the <ref> [8; 1; 8] </ref> code and the [8; 4; 4] code, and so has dimension 5. From the full dimension lemma, the gain in dimension when interblock memory is introduced is upper bounded by n K (n; d n =a 2 ) = 8 4 = 4. <p> A.1 Best [8j8; k; 8] codes If we allow interblock memory between the first two basic blocks, we are seeking the best [8j8; k; 8] code. The baseline BCM case with no interblock memory is obtained by taking the direct sum of the [8; 1; 8] code and the <ref> [8; 4; 4] </ref> code, and so has dimension 5. From the full dimension lemma, the gain in dimension when interblock memory is introduced is upper bounded by n K (n; d n =a 2 ) = 8 4 = 4. <p> the code, so that we can apply the Griesmer argument, from which the maximum rate gain is upper bounded by K (n; d n =(2a 2 )) K (n; d n =a 2 ) = K (8; 2) K (8; 4) = 3, i.e., we have k 8 for an <ref> [8j8; k; 8] </ref> code. This upper bound can be achieved using the code discussed by Lin and Ma [17] with generator matrix G 8=2 (see Table II). <p> This upper bound can be achieved using the code discussed by Lin and Ma [17] with generator matrix G 8=2 (see Table II). TABLE II GENERATOR MATRIX FOR <ref> [8j8; 8; 8] </ref> CODE G 8=2 = 4 G b 0 3 = 6 6 6 6 6 4 1 0 0 1 0 1 1 0 1 0 0 0 0 0 1 0 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 <p> 0 0 0 0 0 0 1 0 0 1 0 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 7 7 7 7 7 5 This code can be obtained from an X 4 construction, with C 1 an <ref> [8; 1; 8] </ref> code, C 2 and C 3 [8; 4; 4] codes, and C 4 an [8; 7; 2] code. (The reference [17] cites [26], which introduces the X 4 construction.) (None of the other constructions of Section III give k = 8. <p> 1 0 1 1 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 7 7 7 7 7 5 This code can be obtained from an X 4 construction, with C 1 an [8; 1; 8] code, C 2 and C 3 <ref> [8; 4; 4] </ref> codes, and C 4 an [8; 7; 2] code. (The reference [17] cites [26], which introduces the X 4 construction.) (None of the other constructions of Section III give k = 8. <p> 0 0 0 0 0 1 1 1 1 1 1 1 1 7 7 7 7 7 5 This code can be obtained from an X 4 construction, with C 1 an [8; 1; 8] code, C 2 and C 3 [8; 4; 4] codes, and C 4 an <ref> [8; 7; 2] </ref> code. (The reference [17] cites [26], which introduces the X 4 construction.) (None of the other constructions of Section III give k = 8. <p> This is the minimum number possible. In fact, it is also the maximum number possible: this code is (up to permutations) the unique <ref> [16; 8] </ref> code with normalized distance 8. The uniqueness follows from the following reasoning. We have C = p f g, where p and f are the shortened past and future subcodes of length n, and g is an appropriate gluing code. <p> These can only be obtained by taking the 14 codewords of weight 4 from an <ref> [8; 4; 4] </ref> Hamming code and selecting one word out of every complementary pair. All such choices lead to the same code up to permutation. <p> These can only be obtained by taking the 14 codewords of weight 4 from an [8; 4; 4] Hamming code and selecting one word out of every complementary pair. All such choices lead to the same code up to permutation. We note that the best <ref> [16; 8] </ref> code in terms of ordinary Hamming distance, a [16; 8; 5] shortened quadratic residue code, also unique [25], cannot by the above discussion be partitioned into two halves to get normalized distance 8 (though 7 is possible). <p> All such choices lead to the same code up to permutation. We note that the best [16; 8] code in terms of ordinary Hamming distance, a <ref> [16; 8; 5] </ref> shortened quadratic residue code, also unique [25], cannot by the above discussion be partitioned into two halves to get normalized distance 8 (though 7 is possible). <p> the best partition for this code. (It is possible to partition the nonlinear (16; 256; 6) code to get an (8j8; 256; 8) code with 57 minimum normalized weight codewords, by taking the first 8 bits to be any eight bits that form the support of a codeword.) A.2 Best <ref> [8j8j8; k; 8] </ref> codes The baseline [8j8j8; k; 8] code is obtained by a direct sum of an [8j8; k 2 ; 8] code for the first two basic blocks and an [8; 7; 2] code for the third basic block. <p> (It is possible to partition the nonlinear (16; 256; 6) code to get an (8j8; 256; 8) code with 57 minimum normalized weight codewords, by taking the first 8 bits to be any eight bits that form the support of a codeword.) A.2 Best <ref> [8j8j8; k; 8] </ref> codes The baseline [8j8j8; k; 8] code is obtained by a direct sum of an [8j8; k 2 ; 8] code for the first two basic blocks and an [8; 7; 2] code for the third basic block. <p> get an (8j8; 256; 8) code with 57 minimum normalized weight codewords, by taking the first 8 bits to be any eight bits that form the support of a codeword.) A.2 Best [8j8j8; k; 8] codes The baseline [8j8j8; k; 8] code is obtained by a direct sum of an <ref> [8j8; k 2 ; 8] </ref> code for the first two basic blocks and an [8; 7; 2] code for the third basic block. Thus using the above code, we can achieve dimension 15 without extending the interblock memory to include the third basic block. <p> the first 8 bits to be any eight bits that form the support of a codeword.) A.2 Best [8j8j8; k; 8] codes The baseline [8j8j8; k; 8] code is obtained by a direct sum of an [8j8; k 2 ; 8] code for the first two basic blocks and an <ref> [8; 7; 2] </ref> code for the third basic block. Thus using the above code, we can achieve dimension 15 without extending the interblock memory to include the third basic block. <p> Thus using the above code, we can achieve dimension 15 without extending the interblock memory to include the third basic block. The full dimension lemma indicates that the dimension of any <ref> [8j8j8; k 3 ; 8] </ref> code will be at most 8 more than the dimension of the best [8j8; k 2 ; 8] code. Thus with interblock memory extended to the third basic block, we can potentially increase the dimension by at most 1. <p> Thus using the above code, we can achieve dimension 15 without extending the interblock memory to include the third basic block. The full dimension lemma indicates that the dimension of any [8j8j8; k 3 ; 8] code will be at most 8 more than the dimension of the best <ref> [8j8; k 2 ; 8] </ref> code. Thus with interblock memory extended to the third basic block, we can potentially increase the dimension by at most 1. <p> Thus with interblock memory extended to the third basic block, we can potentially increase the dimension by at most 1. This can in fact be achieved by the code considered by Lin et al. [18] in which the <ref> [8j8; 8; 8] </ref> code for the first two basic blocks and the [8; 7; 2] baseline code for the third basic block are glued by the word fi fl This code has the disadvantage that it has 131 codewords of minimum normalized weight. <p> This can in fact be achieved by the code considered by Lin et al. [18] in which the [8j8; 8; 8] code for the first two basic blocks and the <ref> [8; 7; 2] </ref> baseline code for the third basic block are glued by the word fi fl This code has the disadvantage that it has 131 codewords of minimum normalized weight. <p> We seek the minimum number of codewords of normalized weight 8 in any linear code with basic block length 8 and length 24 with dimension 16. The past shortened subcode p 16 must be the unique <ref> [8j8; 8; 8] </ref> linear code given above, and the future f 8 subcode must have the 8 fi 8 identity matrix as generator matrix. <p> Also any row of weight 4 of X must be at distance 2 from the <ref> [8; 4] </ref> Hamming code at the left of G 8=2 . We conclude that without loss of generality the rows of X have weight either 2 or 4, and the last eight rows of the overall matrix have weights of the form (2j1j1), (4j1j1), or (4j0j1). <p> We therefore fill all rows of X with words of weight 4 that are distinct from each other and their converses and the words of the <ref> [8; 4] </ref> Hamming code above (there are more than enough to make this possible) and get a code with 87 minimum normalized weight codewords (71 from G 8=2 and 16 more from the rows involving X ). A generator matrix that results from this procedure is given in Table III. <p> 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 7 7 7 7 7 7 7 7 7 7 7 7 7 5 Together with eight uncoded bits for the fourth basic block, we can build a BCMIM system with the parameters <ref> [8j8j8j8; 24; 8] </ref>. This is therefore a 16-QAM system that transmits 24 information bits per eight symbols. Making these most significant label bits uncoded adds 8 minimum normalized weight codewords, whereas adding the most significant label bits to the least significant label bits adds none. <p> Best codes for QAM-based BCMIM systems with basic block length 9 The codes in a baseline BCM system are [9; 1; 9], [9; 2; 6], [9; 5; 3] and <ref> [9; 8; 2] </ref>. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. <p> 7 7 5 which has 33 codewords of minimum normalized weight. (This code has more codewords of the next higher weight than the code based on Piret's construction, however: 36 codewords of normalized weight 12, versus 27.) The even (Hamming) weight subcode obtained by deleting the first row is an <ref> [18; 6; 8] </ref> code. It is known [7] that there are exactly two such codes up to equivalence, both obtainable by shortening the [24; 12] Golay code. <p> Split linear programming gives k 8, and this bound can easily be achieved by modifying the [24; 12] Golay code. Partitioning the Golay code so that each half holds a codeword of weight 12, and then shortening two positions on each side gives a <ref> [10j10; 8; 10] </ref> code, where the normalized distance follows because no codeword of weight 8 in the Golay code can split 8-0 and every codeword has even weight on each side. This code has 20 codewords of minimum normalized weight. <p> Each side contains exactly three codewords of weight 8: (1 8 0 4 ); (1 4 0 4 1 4 ); and (0 4 1 8 ) up to permutation. Shortening in two appropriately chosen bits (e.g., bits 1 and 5) eliminates these three codewords and gives a <ref> [10j10; 8; 10] </ref> code with N min = 12. Split integer programming gives a lower bound of 6 on the number of minimum normalized weight codewords. <p> C.2 Best [10j10j10; k; 10] codes The full dimension lemma indicates that the dimension is at most 10 greater than in the case above, i.e., k 18. This upper bound is achievable. We form a <ref> [10j10; 8; 10] </ref> code by partitioning the Golay code into two U 12 's, then shortening in two positions on either side. <p> This upper bound is achievable. We form a [10j10; 8; 10] code by partitioning the Golay code into two U 12 's, then shortening in two positions on either side. The punctured past and future codes are both <ref> [10; 8; 2] </ref> codes in which one of the cosets has weight enumerator 25x 2 + 100x 4 + 110x 6 + 20x 8 + x 10 . <p> coset, and form the generator matrix 2 6 6 4 x 1 . . . 0 I 10 7 7 7 : This code has minimum normalized weight 10 and 68 codewords of this normalized weight: 18 with weight distribution 2j0j2, 30 with weight distribution 2j2j1, and 20 from the <ref> [10j10; 8; 10] </ref> shortened past subcode. For four basic blocks, we can again achieve the bound of the full dimension lemma, obtaining a code with parameters [10j10j10j10; 28; 10]. <p> Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and [11; 10; 2], and [12; 1; 12], [12; 4; 6], <ref> [12; 8; 3] </ref>; and [12; 11; 2] respectively. The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. <p> We can however construct codes with the next higher dimensions, i.e., [12j12; 9; 12] and (by shortening/puncturing) <ref> [11j11; 8; 11] </ref> codes. We use a reverse-X construction. <p> We can however construct codes with the next higher dimensions, i.e., [12j12; 9; 12] and (by shortening/puncturing) [11j11; 8; 11] codes. We use a reverse-X construction. Taking a <ref> [15; 4; 8] </ref> simplex code and puncturing in three positions that hold a codeword in the dual code gives a [12; 4; 6] code with weight enumerator 1 + 12x 6 + 3x 8 , which we use as both C 1 and C 3 . <p> Taking the dual of this simplex code and shortening in the same three positions gives a <ref> [12; 8; 3] </ref> shortened Hamming code C 2 that contains C 1 as a subcode. Applying the reverse-X construction gives a [12j12; 8; 12] code; we need to augment this to get a k = 9 code. <p> Taking the dual of this simplex code and shortening in the same three positions gives a [12; 8; 3] shortened Hamming code C 2 that contains C 1 as a subcode. Applying the reverse-X construction gives a <ref> [12j12; 8; 12] </ref> code; we need to augment this to get a k = 9 code. If we augment by adding the codeword (1 12 j0 12 ), the punctured past code has weight enumerator 1 + 3x 4 + 24x 6 + 3x 8 + x 12 . <p> Since the last row on the left is distance exactly 6 from all linear combinations of the rows above it, we see that codewords with odd weight in the right basic block have weight exactly 6 in the left basic block. D.1 An <ref> [11j11; 8; 12] </ref> code We can obtain an [11j11; 8; 11] code from the [12j12; 9; 12] code via shortening-puncturing. However, it is possible to increase the minimum normalized distance to 12 without sacrificing rate. <p> D.1 An [11j11; 8; 12] code We can obtain an <ref> [11j11; 8; 11] </ref> code from the [12j12; 9; 12] code via shortening-puncturing. However, it is possible to increase the minimum normalized distance to 12 without sacrificing rate. <p> D.1 An [11j11; 8; 12] code We can obtain an [11j11; 8; 11] code from the [12j12; 9; 12] code via shortening-puncturing. However, it is possible to increase the minimum normalized distance to 12 without sacrificing rate. One such code is 18 obtained by taking the <ref> [24; 12; 8] </ref> Golay code and partitioning to get an [8j16; 12; 8] code with the codeword (1 8 j0 16 ). <p> However, it is possible to increase the minimum normalized distance to 12 without sacrificing rate. One such code is 18 obtained by taking the [24; 12; 8] Golay code and partitioning to get an <ref> [8j16; 12; 8] </ref> code with the codeword (1 8 j0 16 ). All other codewords of weight 8 from the original Golay code have distribution 4-4, 2-6, or 0-8 across the basic blocks and thus have normalized weight at least 12. <p> Shortening in one position on the left therefore gives a [7j16; 11; 12] code. Shortening in three positions on the right gives a <ref> [7j13; 8; 12] </ref> code, and then transferring two bits from right to left and doubling gives an [11j11; 8; 12] code, with 55 minimum normalized weight codewords. <p> Shortening in one position on the left therefore gives a [7j16; 11; 12] code. Shortening in three positions on the right gives a [7j13; 8; 12] code, and then transferring two bits from right to left and doubling gives an <ref> [11j11; 8; 12] </ref> code, with 55 minimum normalized weight codewords. One can verify that although this procedure involves the choice of six positions, the normalized weight enumerator of the resulting code does not depend on the choices. There are at least two more inequivalent [11j11; 8; 12] codes, though none are <p> to left and doubling gives an <ref> [11j11; 8; 12] </ref> code, with 55 minimum normalized weight codewords. One can verify that although this procedure involves the choice of six positions, the normalized weight enumerator of the resulting code does not depend on the choices. There are at least two more inequivalent [11j11; 8; 12] codes, though none are known that have as few minimum normalized weight codewords. Split integer programming gives a lower bound of 24 on the number of minimum normalized weight codewords. <p> There is one case that is not covered: the optimum dimension for a [13j13; k; 13] code is 9. However, the normalized distance can be increased to 14 without sacrificing rate. To construct such a code, we begin with the (unique) <ref> [19; 8; 7] </ref> code. We apply the expansion construction, taking five positions and doubling them for the left block, and leaving the other 14 for the right block. This produces a [10j14; 8; 14] code. <p> To construct such a code, we begin with the (unique) [19; 8; 7] code. We apply the expansion construction, taking five positions and doubling them for the left block, and leaving the other 14 for the right block. This produces a <ref> [10j14; 8; 14] </ref> code. <p> We then augment by adding to the generator matrix a word with a 1 in an eleventh position on the left, a 1 0 in each pair of doubled positions on the left, and a word y in the rightmost 14 positions that is a coset leader in the <ref> [14; 8] </ref> punctured future code of the [10j14; 8; 14] code above. The augmented word is normalized distance at least 6 + 2 wt y from codewords of the [10j14; 8; 14] code. <p> the generator matrix a word with a 1 in an eleventh position on the left, a 1 0 in each pair of doubled positions on the left, and a word y in the rightmost 14 positions that is a coset leader in the [14; 8] punctured future code of the <ref> [10j14; 8; 14] </ref> code above. The augmented word is normalized distance at least 6 + 2 wt y from codewords of the [10j14; 8; 14] code. <p> doubled positions on the left, and a word y in the rightmost 14 positions that is a coset leader in the [14; 8] punctured future code of the <ref> [10j14; 8; 14] </ref> code above. The augmented word is normalized distance at least 6 + 2 wt y from codewords of the [10j14; 8; 14] code. We therefore choose the five positions from the [19; 8; 7] code to double so that the [14; 8; 4] punctured future code has covering radius 4. <p> The augmented word is normalized distance at least 6 + 2 wt y from codewords of the [10j14; 8; 14] code. We therefore choose the five positions from the <ref> [19; 8; 7] </ref> code to double so that the [14; 8; 4] punctured future code has covering radius 4. Equivalently we seek to puncture the [19; 8; 7] code in five positions, in such a way that the resulting [14; 8] code has covering radius at least 4. <p> The augmented word is normalized distance at least 6 + 2 wt y from codewords of the [10j14; 8; 14] code. We therefore choose the five positions from the [19; 8; 7] code to double so that the <ref> [14; 8; 4] </ref> punctured future code has covering radius 4. Equivalently we seek to puncture the [19; 8; 7] code in five positions, in such a way that the resulting [14; 8] code has covering radius at least 4. Some trial and error shows that this is possible. <p> We therefore choose the five positions from the <ref> [19; 8; 7] </ref> code to double so that the [14; 8; 4] punctured future code has covering radius 4. Equivalently we seek to puncture the [19; 8; 7] code in five positions, in such a way that the resulting [14; 8] code has covering radius at least 4. Some trial and error shows that this is possible. <p> We therefore choose the five positions from the [19; 8; 7] code to double so that the [14; 8; 4] punctured future code has covering radius 4. Equivalently we seek to puncture the [19; 8; 7] code in five positions, in such a way that the resulting <ref> [14; 8] </ref> code has covering radius at least 4. Some trial and error shows that this is possible. Thus we obtain an [11j14; 9; 14] code, and transferring one bit from right to left and doubling gives a [13j13; 9; 14] code. <p> Split linear programming gives a lower bound of 26 such codewords in any [13j13; 9; 14] code. 20 F. Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be [16; 1; 16], <ref> [16; 5; 8] </ref>, [16; 11; 4] and [16; 15; 2]. F.1 Best [16j16; k; 16] codes Either split linear programming or the Y1/Plotkin argument show that k 12. <p> This gives 759 codewords of normalized weight 16. This number can be reduced to 503 as follows. We use an X 4 construction with C 1 the [16; 1; 16] code, C 3 the <ref> [16; 5; 8] </ref> first order Reed-Muller code, and C 4 the extended Hamming [16; 11; 4] code. This still leaves C 2 to be chosen. We choose C 2 to be the [16; 7; 4] doubly even code formed by taking the [16; 5; 8] first order Reed-Muller code, plus two <p> the [16; 1; 16] code, C 3 the <ref> [16; 5; 8] </ref> first order Reed-Muller code, and C 4 the extended Hamming [16; 11; 4] code. This still leaves C 2 to be chosen. We choose C 2 to be the [16; 7; 4] doubly even code formed by taking the [16; 5; 8] first order Reed-Muller code, plus two linearly independent cosets; we choose the cosets so that they both have weight enumerators 4x 4 + 24x 8 + 4x 12 , and their `sum' (i.e., the translate of one coset by any element of the other coset) has the same <p> The resulting code has generator matrix 2 4 G 3 G 2 7 where G 3 generates the <ref> [16; 8; 2] </ref> code [8; 8; 1] [2; 1; 2]. We find from [5, Table III-B] that a U 16 intersects every codeword of weight 8 from the Golay code in at least two places, and there are 16 such codewords that intersect in exactly two places. <p> The resulting code has generator matrix 2 4 G 3 G 2 7 where G 3 generates the [16; 8; 2] code <ref> [8; 8; 1] </ref> [2; 1; 2]. We find from [5, Table III-B] that a U 16 intersects every codeword of weight 8 from the Golay code in at least two places, and there are 16 such codewords that intersect in exactly two places. <p> Note that other cases give normalized weight 16 regardless of the choice of the x i 's. We can find such x i 's by concatenating the <ref> [8; 4; 4] </ref> Hamming code with the (2; 2; 2) nonlinear code f01; 10g. The resulting x i 's all have weight exactly 8, are distance exactly 8 or 16 apart, and distance exactly 8 from C 3 . <p> are compared on this basis to longer baseline BCM systems in Table V. 24 TABLE V COMPARISON TO LONGER BASELINE BCM FOR QAM-BASED SYSTEMS Rate, bits/2n symbols Min. (norm.) wt. codewords Component codes n d n BCMIM BCM BCMIM BCM for BCM 8 8 16 16 71 30 & 140 <ref> [16; 5; 8] </ref> fl 9 10 14 12 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13
Reference: [9] <author> G. D. Forney, Jr. and G. Ungerboeck, </author> <title> Modulation and coding for linear Gaussian channels, </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> vol. 44, no. 6, </volume> <pages> pp. 23842415, </pages> <month> Oct. </month> <year> 1998. </year>
Reference-contexts: Performance of BCMIM and BCM systems C. Nearest neighbors It is widely known that the most serious single disadvantage of block coded modulation schemes is the nearest neighbor problem <ref> [8, 9, 14, 31] </ref>. The standard staged decoding procedure, in which each row of the codeword array is decoded in sequence, beginning with the top row, has the effect of producing a large number of apparent nearest neighbors, i.e., a large multiplicity of the most likely error events. <p> Best codes for QAM-based BCMIM systems with basic block length 9 The codes in a baseline BCM system are <ref> [9; 1; 9] </ref>, [9; 2; 6], [9; 5; 3] and [9; 8; 2]. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = <p> Best codes for QAM-based BCMIM systems with basic block length 9 The codes in a baseline BCM system are [9; 1; 9], <ref> [9; 2; 6] </ref>, [9; 5; 3] and [9; 8; 2]. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. <p> Best codes for QAM-based BCMIM systems with basic block length 9 The codes in a baseline BCM system are [9; 1; 9], [9; 2; 6], <ref> [9; 5; 3] </ref> and [9; 8; 2]. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. <p> Best codes for QAM-based BCMIM systems with basic block length 9 The codes in a baseline BCM system are [9; 1; 9], [9; 2; 6], [9; 5; 3] and <ref> [9; 8; 2] </ref>. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. <p> Best codes for QAM-based BCMIM systems with basic block length 9 The codes in a baseline BCM system are [9; 1; 9], [9; 2; 6], [9; 5; 3] and [9; 8; 2]. B.1 Best <ref> [9j9; k; 9] </ref> codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. Applying split weight linear programming to this case indicates that k 7. <p> B.1 Best <ref> [9j9; k; 9] </ref> codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. Applying split weight linear programming to this case indicates that k 7. <p> length 9 The codes in a baseline BCM system are <ref> [9; 1; 9] </ref>, [9; 2; 6], [9; 5; 3] and [9; 8; 2]. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. Applying split weight linear programming to this case indicates that k 7. <p> in a baseline BCM system are [9; 1; 9], <ref> [9; 2; 6] </ref>, [9; 5; 3] and [9; 8; 2]. B.1 Best [9j9; k; 9] codes With interblock memory between the first two blocks, we seek the best [9j9; k; 9] code. A direct sum of the [9; 1; 9] and [9; 2; 6] codes gives k = 3. Applying split weight linear programming to this case indicates that k 7. <p> Since the Griesmer argument indicates that k 6 if k p = 1, we must have k p = 0, and so k f + k g = 7. The punctured future code C f g is then a <ref> [9; 7] </ref> code, and its dual C ? fg is a [9; 2; 6] code. <p> The punctured future code C f g is then a [9; 7] code, and its dual C ? fg is a <ref> [9; 2; 6] </ref> code. <p> Then applying Y1 with m = 5 gives a code with n 1 = 9, n 2 = 4, and k 3. But the Plotkin bound for this case gives M 10=(10 (9=2 + 4)) &lt; 7. Thus we conclude that C ? fg is the unique <ref> [9; 2; 6] </ref> linear code. <p> There are at least two inequivalent codes that satisfy these constraints. The first is obtained by a version of Piret's construction [21, pp. 5889] applied to the <ref> [9; 6; 2] </ref> irreducible cyclic code. <p> partition and augment the first type to get a [9j9; 7; 10] code. (For example, split linear programming shows that no [9j9; 7; 10] code can contain a codeword with Hamming weight 16.) Split linear programming, constraining the code to have 128 codewords, normalized distance 10 and to have a <ref> [9; 2; 6] </ref> code as dual of the punctured future code gives a lower bound of 31 codewords of minimum normalized weight. <p> Many are ruled out by the extra constraint that the punctured future code is the dual of the <ref> [9; 2; 6] </ref> code. We do not know of any such code with 31 codewords of minimum normalized weight, though an integer weight enumerator, with integer dual weight enumerator, exists. <p> We omit the details. C. Best codes for QAM-based BCMIM systems with basic block length 10 The codes in a baseline BCM system are [10; 1; 10], [10; 3; 5], [10; 6; 3], and <ref> [10; 9; 2] </ref>. 16 C.1 Best [10j10; k; 10] codes With no interblock memory between the first two blocks, the baseline BCM system gives k = 4. Split linear programming gives k 8, and this bound can easily be achieved by modifying the [24; 12] Golay code. <p> However, if such a (linear) code existed, it would have a past shortened subcode p of dimension 0 by the Griesmer argument, so the punctured future code would be an <ref> [11; 9] </ref> code. The dual would be an [11; 2; 7] code, and a Y1 shortening would give an [11j4; 3; 11] code, which the Plotkin bound shows cannot exist. <p> We can however construct codes with the next higher dimensions, i.e., <ref> [12j12; 9; 12] </ref> and (by shortening/puncturing) [11j11; 8; 11] codes. We use a reverse-X construction. <p> D.1 An [11j11; 8; 12] code We can obtain an [11j11; 8; 11] code from the <ref> [12j12; 9; 12] </ref> code via shortening-puncturing. However, it is possible to increase the minimum normalized distance to 12 without sacrificing rate. <p> Equivalently we seek to puncture the [19; 8; 7] code in five positions, in such a way that the resulting [14; 8] code has covering radius at least 4. Some trial and error shows that this is possible. Thus we obtain an <ref> [11j14; 9; 14] </ref> code, and transferring one bit from right to left and doubling gives a [13j13; 9; 14] code. <p> Some trial and error shows that this is possible. Thus we obtain an [11j14; 9; 14] code, and transferring one bit from right to left and doubling gives a <ref> [13j13; 9; 14] </ref> code. <p> Split linear programming gives a lower bound of 26 such codewords in any <ref> [13j13; 9; 14] </ref> code. 20 F. Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be [16; 1; 16], [16; 5; 8], [16; 11; 4] and [16; 15; 2]. <p> The star on some BCM component codes indicates that the code is known to be unique. A number as superscript indicates that there are exactly that many inequivalent codes with the given parameters. The information is taken from Jaffe's table [12], except for the uniqueness of the <ref> [18; 9; 6] </ref> code, obtained by Simonis [25]. From the table, the BCMIM system has higher rate in all cases except basic block lengths 8 and 12.
Reference: [10] <author> J. Huber, U. Wachsmann, and R. Fischer, </author> <title> Coded modulation by multilevel codes: Overview and state of the art, in ITG-Fachbericht: </title> <institution> Codierung fur Quelle, Kanal und Ubertragung (Aachen, Germany, </institution> <month> March </month> <year> 1998), </year> <pages> pp. 255266. </pages>
Reference-contexts: It should be acknowledged here that the relevance of the normalized distance criterion is directly tied to the goal of maximizing the minimum Euclidean distance of the system. Several alternative approaches have been proposed recently to the code design problem for regular BCM: for example, the capacity rule <ref> [10] </ref> in which rates are assigned to the component codes according to random coding principles, and the error probability rule [2, 3, 29] in which the component codes are chosen to balance the individual error probabilities at all coding levels. (Indeed, Wachsmann and Huber [29] go so far as to suggest <p> On fixing the number of codewords accordingly at 128 and using split weight linear programming to minimize the number of codewords with minimum normalized weight 9, we find that the minimum of the objective is 0. This suggests that we might be able to find a <ref> [9j9; 7; 10] </ref> code. This is in fact possible, and we will give a couple of different constructions. This case is also interesting in that it is the first case in which the Griesmer-type bound of Section III-A.2 is not tight (see Table I). <p> j, so the (unique) best choice for a in this case is 3, giving d ? = 10. (The factor 2 on the right of the expression for d 0 and the corresponding optimal choice of a are the only differences with the development in [21].) This results in a <ref> [9j9; 6; 10] </ref> code, and adding the row (0 9 j1 9 ) to the generator matrix does not affect the minimum normalized distance, thus giving a [9j9; 7; 10] code. (A brute force search showed that adding the row (r l j1 9 ) for any r l 6= 0 <p> for d 0 and the corresponding optimal choice of a are the only differences with the development in [21].) This results in a [9j9; 6; 10] code, and adding the row (0 9 j1 9 ) to the generator matrix does not affect the minimum normalized distance, thus giving a <ref> [9j9; 7; 10] </ref> code. (A brute force search showed that adding the row (r l j1 9 ) for any r l 6= 0 9 gives a lower minimum normalized distance.) From the construction, taking the same cyclic shift of the left and right sides of a codeword produces a codeword. <p> The code generated by the last six rows of the matrix above has the second of these weight enumerators. There is no way to partition and augment the first type to get a <ref> [9j9; 7; 10] </ref> code. (For example, split linear programming shows that no [9j9; 7; 10] code can contain a codeword with Hamming weight 16.) Split linear programming, constraining the code to have 128 codewords, normalized distance 10 and to have a [9; 2; 6] code as dual of the punctured future <p> The code generated by the last six rows of the matrix above has the second of these weight enumerators. There is no way to partition and augment the first type to get a <ref> [9j9; 7; 10] </ref> code. (For example, split linear programming shows that no [9j9; 7; 10] code can contain a codeword with Hamming weight 16.) Split linear programming, constraining the code to have 128 codewords, normalized distance 10 and to have a [9; 2; 6] code as dual of the punctured future code gives a lower bound of 31 codewords of minimum normalized weight. <p> We remark that in the case of a <ref> [9j9; 7; 10] </ref> code, there is a particularly large number of solutions to the linear programming constraints that are feasible candidates for codes, in the sense of having nonnegative integer weights in both code and dual code. <p> We do not know of any such code with 31 codewords of minimum normalized weight, though an integer weight enumerator, with integer dual weight enumerator, exists. The Golay-based code can be extended to form <ref> [9j9j9; 16; 10] </ref> and [9j9j9j9; 25; 10] codes with 56 minimum normalized weight codewords, as indicated in Table I. We omit the details. C. <p> We do not know of any such code with 31 codewords of minimum normalized weight, though an integer weight enumerator, with integer dual weight enumerator, exists. The Golay-based code can be extended to form [9j9j9; 16; 10] and <ref> [9j9j9j9; 25; 10] </ref> codes with 56 minimum normalized weight codewords, as indicated in Table I. We omit the details. C. <p> We omit the details. C. Best codes for QAM-based BCMIM systems with basic block length 10 The codes in a baseline BCM system are <ref> [10; 1; 10] </ref>, [10; 3; 5], [10; 6; 3], and [10; 9; 2]. 16 C.1 Best [10j10; k; 10] codes With no interblock memory between the first two blocks, the baseline BCM system gives k = 4. <p> We omit the details. C. Best codes for QAM-based BCMIM systems with basic block length 10 The codes in a baseline BCM system are [10; 1; 10], <ref> [10; 3; 5] </ref>, [10; 6; 3], and [10; 9; 2]. 16 C.1 Best [10j10; k; 10] codes With no interblock memory between the first two blocks, the baseline BCM system gives k = 4. <p> We omit the details. C. Best codes for QAM-based BCMIM systems with basic block length 10 The codes in a baseline BCM system are [10; 1; 10], [10; 3; 5], <ref> [10; 6; 3] </ref>, and [10; 9; 2]. 16 C.1 Best [10j10; k; 10] codes With no interblock memory between the first two blocks, the baseline BCM system gives k = 4. <p> We omit the details. C. Best codes for QAM-based BCMIM systems with basic block length 10 The codes in a baseline BCM system are [10; 1; 10], [10; 3; 5], [10; 6; 3], and <ref> [10; 9; 2] </ref>. 16 C.1 Best [10j10; k; 10] codes With no interblock memory between the first two blocks, the baseline BCM system gives k = 4. Split linear programming gives k 8, and this bound can easily be achieved by modifying the [24; 12] Golay code. <p> We omit the details. C. Best codes for QAM-based BCMIM systems with basic block length 10 The codes in a baseline BCM system are [10; 1; 10], [10; 3; 5], [10; 6; 3], and [10; 9; 2]. 16 C.1 Best <ref> [10j10; k; 10] </ref> codes With no interblock memory between the first two blocks, the baseline BCM system gives k = 4. Split linear programming gives k 8, and this bound can easily be achieved by modifying the [24; 12] Golay code. <p> Split linear programming gives k 8, and this bound can easily be achieved by modifying the [24; 12] Golay code. Partitioning the Golay code so that each half holds a codeword of weight 12, and then shortening two positions on each side gives a <ref> [10j10; 8; 10] </ref> code, where the normalized distance follows because no codeword of weight 8 in the Golay code can split 8-0 and every codeword has even weight on each side. This code has 20 codewords of minimum normalized weight. <p> Each side contains exactly three codewords of weight 8: (1 8 0 4 ); (1 4 0 4 1 4 ); and (0 4 1 8 ) up to permutation. Shortening in two appropriately chosen bits (e.g., bits 1 and 5) eliminates these three codewords and gives a <ref> [10j10; 8; 10] </ref> code with N min = 12. Split integer programming gives a lower bound of 6 on the number of minimum normalized weight codewords. <p> Shortening in two appropriately chosen bits (e.g., bits 1 and 5) eliminates these three codewords and gives a [10j10; 8; 10] code with N min = 12. Split integer programming gives a lower bound of 6 on the number of minimum normalized weight codewords. C.2 Best <ref> [10j10j10; k; 10] </ref> codes The full dimension lemma indicates that the dimension is at most 10 greater than in the case above, i.e., k 18. This upper bound is achievable. <p> C.2 Best [10j10j10; k; 10] codes The full dimension lemma indicates that the dimension is at most 10 greater than in the case above, i.e., k 18. This upper bound is achievable. We form a <ref> [10j10; 8; 10] </ref> code by partitioning the Golay code into two U 12 's, then shortening in two positions on either side. <p> This upper bound is achievable. We form a [10j10; 8; 10] code by partitioning the Golay code into two U 12 's, then shortening in two positions on either side. The punctured past and future codes are both <ref> [10; 8; 2] </ref> codes in which one of the cosets has weight enumerator 25x 2 + 100x 4 + 110x 6 + 20x 8 + x 10 . <p> coset, and form the generator matrix 2 6 6 4 x 1 . . . 0 I 10 7 7 7 : This code has minimum normalized weight 10 and 68 codewords of this normalized weight: 18 with weight distribution 2j0j2, 30 with weight distribution 2j2j1, and 20 from the <ref> [10j10; 8; 10] </ref> shortened past subcode. For four basic blocks, we can again achieve the bound of the full dimension lemma, obtaining a code with parameters [10j10j10j10; 28; 10]. <p> For four basic blocks, we can again achieve the bound of the full dimension lemma, obtaining a code with parameters <ref> [10j10j10j10; 28; 10] </ref>. <p> The code therefore has minimum normalized weight 10 with 68 codewords of this normalized weight. 17 D. Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and <ref> [11; 10; 2] </ref>, and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and [12; 11; 2] respectively. <p> The systems without interblock memory therefore give [11j11; 4; 11], <ref> [11j11j11; 10; 11] </ref>, and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. <p> For basic block lengths 7 to 10, however, it produces one codeword at normalized distance n, rather than the zero indicated in the table. Codes of highest dimension in the range 7 to 10 are produced by shortening and puncturing a <ref> [10j10; 10; &gt; 10] </ref> ffi code. To construct this code, we note that since the past subcode must have dimension zero, the punctured future subcode must be the [10; 10; 1] code. <p> Codes of highest dimension in the range 7 to 10 are produced by shortening and puncturing a [10j10; 10; &gt; 10] ffi code. To construct this code, we note that since the past subcode must have dimension zero, the punctured future subcode must be the <ref> [10; 10; 1] </ref> code. Taking an identity matrix on the right of the generator matrix, the rows on the left must have Hamming weight at least 7, and be distance at least 4 apart. <p> For n = 10, the gluing code again has weight 0 in the middle block, and weight 1 in the third block. The first block can be chosen as any word of weight 7 that is distance at least 4 from each of the left hand rows in the <ref> [10j10; 10; 10:4] </ref> ffi code above. Since A (10; 4; 7) = 13, and only 10 of these words have been used, y can be chosen to be any of the remaining 3 words. This gives a [10j10j10; 20; 10:4] ffi code with 10 codewords of normalized weight 10.4. <p> V. 24 TABLE V COMPARISON TO LONGER BASELINE BCM FOR QAM-BASED SYSTEMS Rate, bits/2n symbols Min. (norm.) wt. codewords Component codes n d n BCMIM BCM BCMIM BCM for BCM 8 8 16 16 71 30 & 140 [16; 5; 8] fl 9 10 14 12 31-33 6 & 0 <ref> [18; 3; 10] </ref> 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 <p> SYSTEMS Rate, bits/2n symbols Min. (norm.) wt. codewords Component codes n d n BCMIM BCM BCMIM BCM for BCM 8 8 16 16 71 30 & 140 [16; 5; 8] fl 9 10 14 12 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) <ref> [20; 4; 10] </ref> 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15
Reference: [11] <author> H. Imai and S. Hirakawa, </author> <title> A new multilevel coding method using error-correcting codes, </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> vol. IT-23, no. 3, </volume> <pages> pp. 371377, </pages> <year> 1977. </year>
Reference-contexts: The code therefore has minimum normalized weight 10 with 68 codewords of this normalized weight. 17 D. Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are <ref> [11; 1; 11] </ref>, [11; 3; 6], [11; 6; 4] and [11; 10; 2], and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and [12; 11; 2] respectively. <p> The code therefore has minimum normalized weight 10 with 68 codewords of this normalized weight. 17 D. Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], <ref> [11; 3; 6] </ref>, [11; 6; 4] and [11; 10; 2], and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and [12; 11; 2] respectively. <p> The code therefore has minimum normalized weight 10 with 68 codewords of this normalized weight. 17 D. Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], <ref> [11; 6; 4] </ref> and [11; 10; 2], and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and [12; 11; 2] respectively. <p> The code therefore has minimum normalized weight 10 with 68 codewords of this normalized weight. 17 D. Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and <ref> [11; 10; 2] </ref>, and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and [12; 11; 2] respectively. <p> Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and [11; 10; 2], and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and <ref> [12; 11; 2] </ref> respectively. The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. <p> The systems without interblock memory therefore give <ref> [11j11; 4; 11] </ref>, [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. <p> The systems without interblock memory therefore give [11j11; 4; 11], <ref> [11j11j11; 10; 11] </ref>, and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. <p> The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and <ref> [11j11j11j11; 20; 11] </ref> codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. <p> However, if such a (linear) code existed, it would have a past shortened subcode p of dimension 0 by the Griesmer argument, so the punctured future code would be an <ref> [11; 9] </ref> code. The dual would be an [11; 2; 7] code, and a Y1 shortening would give an [11j4; 3; 11] code, which the Plotkin bound shows cannot exist. <p> However, if such a (linear) code existed, it would have a past shortened subcode p of dimension 0 by the Griesmer argument, so the punctured future code would be an [11; 9] code. The dual would be an <ref> [11; 2; 7] </ref> code, and a Y1 shortening would give an [11j4; 3; 11] code, which the Plotkin bound shows cannot exist. <p> However, if such a (linear) code existed, it would have a past shortened subcode p of dimension 0 by the Griesmer argument, so the punctured future code would be an [11; 9] code. The dual would be an [11; 2; 7] code, and a Y1 shortening would give an <ref> [11j4; 3; 11] </ref> code, which the Plotkin bound shows cannot exist. <p> We can however construct codes with the next higher dimensions, i.e., [12j12; 9; 12] and (by shortening/puncturing) <ref> [11j11; 8; 11] </ref> codes. We use a reverse-X construction. <p> D.1 An [11j11; 8; 12] code We can obtain an <ref> [11j11; 8; 11] </ref> code from the [12j12; 9; 12] code via shortening-puncturing. However, it is possible to increase the minimum normalized distance to 12 without sacrificing rate. <p> All other codewords of weight 8 from the original Golay code have distribution 4-4, 2-6, or 0-8 across the basic blocks and thus have normalized weight at least 12. Shortening in one position on the left therefore gives a <ref> [7j16; 11; 12] </ref> code. Shortening in three positions on the right gives a [7j13; 8; 12] code, and then transferring two bits from right to left and doubling gives an [11j11; 8; 12] code, with 55 minimum normalized weight codewords. <p> Split linear programming gives a lower bound of 26 such codewords in any [13j13; 9; 14] code. 20 F. Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be [16; 1; 16], [16; 5; 8], <ref> [16; 11; 4] </ref> and [16; 15; 2]. F.1 Best [16j16; k; 16] codes Either split linear programming or the Y1/Plotkin argument show that k 12. <p> This gives 759 codewords of normalized weight 16. This number can be reduced to 503 as follows. We use an X 4 construction with C 1 the [16; 1; 16] code, C 3 the [16; 5; 8] first order Reed-Muller code, and C 4 the extended Hamming <ref> [16; 11; 4] </ref> code. This still leaves C 2 to be chosen. <p> The case n = 6 above is straightforward. For n = 12, the baseline codes are [12; 1; 12], [12; 7; 4] and <ref> [12; 11; 2] </ref>. To construct a [12j12; 12; 12] ffi code, we take the [24; 12] Golay code and partition into two U 12 's. <p> Since A (10; 4; 7) = 13 [21, p. 684], we can find 10 such words. We obtain a code with normalized weight enumerator 1 + 10x 10:4 + 33x 10:8 + 12x 12:8 + : The nonexistence of [12j12; 12; &gt;12] ffi and <ref> [11j11; 11; &gt;11] </ref> ffi codes can be demonstrated in a similar way, without using split linear programming. A [12j12; 12; &gt;12] ffi code would have 12 codewords with weight distribution [9j1] and 66 codewords with weight distribution [6j2]. <p> This produces codewords with weight distributions [6j0j1], [0j 2j1], and [0j 0j 2], all of which give normalized weight greater than 12. We thus obtain a [12j12j12; 24; 12] ffi code with one codeword of normalized weight 12; this is the best possible. Shortening and puncturing gives an <ref> [11j11j11; 22; 11] </ref> ffi code that has one codeword of normalized weight 11. VI.
Reference: [12] <author> D. B. Jaffe, </author> <title> Binary linear codes: New results on nonexistence, </title> <type> Technical report, </type> <institution> Dept. Math. Stat., Univ. of Nebraska, Lincoln, </institution> <month> Oct. </month> <year> 1996. </year> <note> Available from http://math.unl.edu/djaffe/codes/codes.ps.gz. </note>
Reference-contexts: A.4 Split Linear Programming The most powerful general upper bound for codes with ordinary Hamming distance is the linear programming bound, and a suitable modification provides good results for normalized distance also. Following Jaffe <ref> [12] </ref>, we fix a partition (p 1 ; ; p r ) of n, and let C ae F n 2 be a linear code. <p> It is known [7] that there are exactly two such codes up to equivalence, both obtainable by shortening the <ref> [24; 12] </ref> Golay code. The corresponding Hamming weight enumerators are 1 + 46x 8 + 16x 12 + x 16 and 1 + 45x 8 + 18x 12 . The code generated by the last six rows of the matrix above has the second of these weight enumerators. <p> Split linear programming gives k 8, and this bound can easily be achieved by modifying the <ref> [24; 12] </ref> Golay code. <p> Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and [11; 10; 2], and <ref> [12; 1; 12] </ref>, [12; 4; 6], [12; 8; 3]; and [12; 11; 2] respectively. <p> Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and [11; 10; 2], and [12; 1; 12], <ref> [12; 4; 6] </ref>, [12; 8; 3]; and [12; 11; 2] respectively. <p> Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and [11; 10; 2], and [12; 1; 12], [12; 4; 6], <ref> [12; 8; 3] </ref>; and [12; 11; 2] respectively. The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. <p> Best codes for QAM-based BCMIM systems with basic block lengths 11 and 12 The codes in the baseline systems are [11; 1; 11], [11; 3; 6], [11; 6; 4] and [11; 10; 2], and [12; 1; 12], [12; 4; 6], [12; 8; 3]; and <ref> [12; 11; 2] </ref> respectively. The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. <p> The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and <ref> [12j12; 5; 12] </ref>, [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. The case n = d n = 11 is interesting as the first case in which the split linear programming bound on dimension is not tight when i = 2. <p> The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], <ref> [12j12j12; 13; 12] </ref>, and [12j12j12j12; 24; 12] codes for basic block length 12. The case n = d n = 11 is interesting as the first case in which the split linear programming bound on dimension is not tight when i = 2. <p> The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and <ref> [12j12j12j12; 24; 12] </ref> codes for basic block length 12. The case n = d n = 11 is interesting as the first case in which the split linear programming bound on dimension is not tight when i = 2. <p> We can however construct codes with the next higher dimensions, i.e., <ref> [12j12; 9; 12] </ref> and (by shortening/puncturing) [11j11; 8; 11] codes. We use a reverse-X construction. <p> We can however construct codes with the next higher dimensions, i.e., [12j12; 9; 12] and (by shortening/puncturing) [11j11; 8; 11] codes. We use a reverse-X construction. Taking a [15; 4; 8] simplex code and puncturing in three positions that hold a codeword in the dual code gives a <ref> [12; 4; 6] </ref> code with weight enumerator 1 + 12x 6 + 3x 8 , which we use as both C 1 and C 3 . <p> Taking the dual of this simplex code and shortening in the same three positions gives a <ref> [12; 8; 3] </ref> shortened Hamming code C 2 that contains C 1 as a subcode. Applying the reverse-X construction gives a [12j12; 8; 12] code; we need to augment this to get a k = 9 code. <p> Taking the dual of this simplex code and shortening in the same three positions gives a [12; 8; 3] shortened Hamming code C 2 that contains C 1 as a subcode. Applying the reverse-X construction gives a <ref> [12j12; 8; 12] </ref> code; we need to augment this to get a k = 9 code. If we augment by adding the codeword (1 12 j0 12 ), the punctured past code has weight enumerator 1 + 3x 4 + 24x 6 + 3x 8 + x 12 . <p> Since the last row on the left is distance exactly 6 from all linear combinations of the rows above it, we see that codewords with odd weight in the right basic block have weight exactly 6 in the left basic block. D.1 An <ref> [11j11; 8; 12] </ref> code We can obtain an [11j11; 8; 11] code from the [12j12; 9; 12] code via shortening-puncturing. However, it is possible to increase the minimum normalized distance to 12 without sacrificing rate. <p> D.1 An [11j11; 8; 12] code We can obtain an [11j11; 8; 11] code from the <ref> [12j12; 9; 12] </ref> code via shortening-puncturing. However, it is possible to increase the minimum normalized distance to 12 without sacrificing rate. <p> D.1 An [11j11; 8; 12] code We can obtain an [11j11; 8; 11] code from the [12j12; 9; 12] code via shortening-puncturing. However, it is possible to increase the minimum normalized distance to 12 without sacrificing rate. One such code is 18 obtained by taking the <ref> [24; 12; 8] </ref> Golay code and partitioning to get an [8j16; 12; 8] code with the codeword (1 8 j0 16 ). <p> However, it is possible to increase the minimum normalized distance to 12 without sacrificing rate. One such code is 18 obtained by taking the [24; 12; 8] Golay code and partitioning to get an <ref> [8j16; 12; 8] </ref> code with the codeword (1 8 j0 16 ). All other codewords of weight 8 from the original Golay code have distribution 4-4, 2-6, or 0-8 across the basic blocks and thus have normalized weight at least 12. <p> All other codewords of weight 8 from the original Golay code have distribution 4-4, 2-6, or 0-8 across the basic blocks and thus have normalized weight at least 12. Shortening in one position on the left therefore gives a <ref> [7j16; 11; 12] </ref> code. Shortening in three positions on the right gives a [7j13; 8; 12] code, and then transferring two bits from right to left and doubling gives an [11j11; 8; 12] code, with 55 minimum normalized weight codewords. <p> Shortening in one position on the left therefore gives a [7j16; 11; 12] code. Shortening in three positions on the right gives a <ref> [7j13; 8; 12] </ref> code, and then transferring two bits from right to left and doubling gives an [11j11; 8; 12] code, with 55 minimum normalized weight codewords. <p> Shortening in one position on the left therefore gives a [7j16; 11; 12] code. Shortening in three positions on the right gives a [7j13; 8; 12] code, and then transferring two bits from right to left and doubling gives an <ref> [11j11; 8; 12] </ref> code, with 55 minimum normalized weight codewords. One can verify that although this procedure involves the choice of six positions, the normalized weight enumerator of the resulting code does not depend on the choices. There are at least two more inequivalent [11j11; 8; 12] codes, though none are <p> to left and doubling gives an <ref> [11j11; 8; 12] </ref> code, with 55 minimum normalized weight codewords. One can verify that although this procedure involves the choice of six positions, the normalized weight enumerator of the resulting code does not depend on the choices. There are at least two more inequivalent [11j11; 8; 12] codes, though none are known that have as few minimum normalized weight codewords. Split integer programming gives a lower bound of 24 on the number of minimum normalized weight codewords. <p> There are at least two more inequivalent [11j11; 8; 12] codes, though none are known that have as few minimum normalized weight codewords. Split integer programming gives a lower bound of 24 on the number of minimum normalized weight codewords. The code described above can be extended to form <ref> [11j11j11; 19; 12] </ref> and [11j11j11j11; 30; 12] codes, meeting the upper bound of the full rate lemma in each case, with 198 codewords of minimum normalized weight. We omit the details. <p> Split integer programming gives a lower bound of 24 on the number of minimum normalized weight codewords. The code described above can be extended to form [11j11j11; 19; 12] and <ref> [11j11j11j11; 30; 12] </ref> codes, meeting the upper bound of the full rate lemma in each case, with 198 codewords of minimum normalized weight. We omit the details. <p> The code described above can be extended to form [11j11j11; 19; 12] and [11j11j11j11; 30; 12] codes, meeting the upper bound of the full rate lemma in each case, with 198 codewords of minimum normalized weight. We omit the details. D.2 Best <ref> [12j12j12; k; 12] </ref> and [12j12j12j12; k; 12] codes We will use the same approach to construct a [12j12j12; 21; 12] code as in the basic block length 10 case. <p> The code described above can be extended to form [11j11j11; 19; 12] and [11j11j11j11; 30; 12] codes, meeting the upper bound of the full rate lemma in each case, with 198 codewords of minimum normalized weight. We omit the details. D.2 Best [12j12j12; k; 12] and <ref> [12j12j12j12; k; 12] </ref> codes We will use the same approach to construct a [12j12j12; 21; 12] code as in the basic block length 10 case. <p> We omit the details. D.2 Best [12j12j12; k; 12] and [12j12j12j12; k; 12] codes We will use the same approach to construct a <ref> [12j12j12; 21; 12] </ref> code as in the basic block length 10 case. The [12; 4; 6] punctured simplex code above has 48 cosets with weight enumerator 5x 4 + 7x 6 + 3x 8 + x 10 . <p> We omit the details. D.2 Best [12j12j12; k; 12] and [12j12j12j12; k; 12] codes We will use the same approach to construct a [12j12j12; 21; 12] code as in the basic block length 10 case. The <ref> [12; 4; 6] </ref> punctured simplex code above has 48 cosets with weight enumerator 5x 4 + 7x 6 + 3x 8 + x 10 . We choose x 1 ; : : : ; x 12 to be words of weight 4 from distinct cosets among these. <p> We choose x 1 ; : : : ; x 12 to be words of weight 4 from distinct cosets among these. We form the generator matrix 2 6 6 6 6 6 6 G 1 <ref> [12; 1; 12] </ref> 0 0 0 G 3 [12; 4; 6] 0 x 2 x 12 3 7 7 7 7 7 7 : The x i 's are distance 2 from each other, and distance 4 from C 3 . <p> We choose x 1 ; : : : ; x 12 to be words of weight 4 from distinct cosets among these. We form the generator matrix 2 6 6 6 6 6 6 G 1 [12; 1; 12] 0 0 0 G 3 <ref> [12; 4; 6] </ref> 0 x 2 x 12 3 7 7 7 7 7 7 : The x i 's are distance 2 from each other, and distance 4 from C 3 . They are distance at least 1 from hG 3 ; G 4 i. <p> Then the weight distributions between basic blocks are of the form (0j 4j1); (0j 2j2); (6j1j1); (4j 2j1), and (j j 3). The normalized weight is thus at least 12. There are 214 codewords of minimum normalized weight. To form a <ref> [12j12j12j12; k; 12] </ref> code, we take a generator matrix of the form 19 6 6 6 6 6 6 6 6 6 6 4 G 2 [12; 4; 6] G 4 [12; 4; 3] 0 0 x 1 . . . 0 I 12 0 y 2 y 12 3 7 <p> The normalized weight is thus at least 12. There are 214 codewords of minimum normalized weight. To form a [12j12j12j12; k; 12] code, we take a generator matrix of the form 19 6 6 6 6 6 6 6 6 6 6 4 G 2 <ref> [12; 4; 6] </ref> G 4 [12; 4; 3] 0 0 x 1 . . . 0 I 12 0 y 2 y 12 3 7 7 7 7 7 7 7 7 7 7 : The words y 1 ; : : : ; y 12 are words of weight 6, <p> There are 214 codewords of minimum normalized weight. To form a [12j12j12j12; k; 12] code, we take a generator matrix of the form 19 6 6 6 6 6 6 6 6 6 6 4 G 2 [12; 4; 6] G 4 <ref> [12; 4; 3] </ref> 0 0 x 1 . . . 0 I 12 0 y 2 y 12 3 7 7 7 7 7 7 7 7 7 7 : The words y 1 ; : : : ; y 12 are words of weight 6, each from distinct cosets with <p> 7 7 7 7 7 7 7 7 7 7 : The words y 1 ; : : : ; y 12 are words of weight 6, each from distinct cosets with weight enumerator x 2 + 8x 4 + 14x 6 + 8x 8 + x 10 of the <ref> [12; 5; 4] </ref> code hC 2 ; 1i above. The only case that needs to be checked is the case (y i j0j0je i ) + (vjuj0j0), which has weight distribution (2j 3j0j1). <p> The only case that needs to be checked is the case (y i j0j0je i ) + (vjuj0j0), which has weight distribution (2j 3j0j1). Thus none of the codewords with ones in the fourth basic block have normalized weight as low as 12. The code is thus <ref> [12j12j12j12; 33; 12] </ref> with 214 codewords of normalized weight 12. E. Best codes for QAM-based BCMIM systems with basic block lengths 1315 The codes of highest dimension with basic block lengths in this range can all be obtained from the n = 16 case below via shortening and puncturing. <p> F.1 Best [16j16; k; 16] codes Either split linear programming or the Y1/Plotkin argument show that k 12. This can be achieved using the duplication construction, starting with the <ref> [24; 12] </ref> Golay code, and forming the first block by duplicating an arbitrary subset of eight bits. This gives 759 codewords of normalized weight 16. This number can be reduced to 503 as follows. <p> We can achieve this upper bound using the following construction. We begin by forming a <ref> [16j16; 12; 16] </ref> code C from the Golay code by partitioning the 24 positions of the Golay code into a U 8 and U 16 , again in the notation of [5], then bringing the U 8 to the left and doubling it. <p> Thus the punctured future code hG 1 ; G 2 i is a <ref> [16; 12; 2] </ref> (even) code, and furthermore has covering radius 2 since there are too many codewords of weight 2 for the covering radius to be 1. <p> The case n = 6 above is straightforward. For n = 12, the baseline codes are <ref> [12; 1; 12] </ref>, [12; 7; 4] and [12; 11; 2]. To construct a [12j12; 12; 12] ffi code, we take the [24; 12] Golay code and partition into two U 12 's. <p> The case n = 6 above is straightforward. For n = 12, the baseline codes are [12; 1; 12], <ref> [12; 7; 4] </ref> and [12; 11; 2]. To construct a [12j12; 12; 12] ffi code, we take the [24; 12] Golay code and partition into two U 12 's. <p> The case n = 6 above is straightforward. For n = 12, the baseline codes are [12; 1; 12], [12; 7; 4] and <ref> [12; 11; 2] </ref>. To construct a [12j12; 12; 12] ffi code, we take the [24; 12] Golay code and partition into two U 12 's. <p> The case n = 6 above is straightforward. For n = 12, the baseline codes are [12; 1; 12], [12; 7; 4] and [12; 11; 2]. To construct a <ref> [12j12; 12; 12] </ref> ffi code, we take the [24; 12] Golay code and partition into two U 12 's. <p> The case n = 6 above is straightforward. For n = 12, the baseline codes are [12; 1; 12], [12; 7; 4] and [12; 11; 2]. To construct a [12j12; 12; 12] ffi code, we take the <ref> [24; 12] </ref> Golay code and partition into two U 12 's. Since these are codewords in the [24; 12] code, the possible weight distributions of words of Hamming weight 8 are 6j2, 4j4, and 2j6, all of which have normalized weight greater than 12. <p> For n = 12, the baseline codes are [12; 1; 12], [12; 7; 4] and [12; 11; 2]. To construct a [12j12; 12; 12] ffi code, we take the <ref> [24; 12] </ref> Golay code and partition into two U 12 's. Since these are codewords in the [24; 12] code, the possible weight distributions of words of Hamming weight 8 are 6j2, 4j4, and 2j6, all of which have normalized weight greater than 12. <p> Since A (10; 4; 7) = 13 [21, p. 684], we can find 10 such words. We obtain a code with normalized weight enumerator 1 + 10x 10:4 + 33x 10:8 + 12x 12:8 + : The nonexistence of <ref> [12j12; 12; &gt;12] </ref> ffi and [11j11; 11; &gt;11] ffi codes can be demonstrated in a similar way, without using split linear programming. A [12j12; 12; &gt;12] ffi code would have 12 codewords with weight distribution [9j1] and 66 codewords with weight distribution [6j2]. <p> We obtain a code with normalized weight enumerator 1 + 10x 10:4 + 33x 10:8 + 12x 12:8 + : The nonexistence of <ref> [12j12; 12; &gt;12] </ref> ffi and [11j11; 11; &gt;11] ffi codes can be demonstrated in a similar way, without using split linear programming. A [12j12; 12; &gt;12] ffi code would have 12 codewords with weight distribution [9j1] and 66 codewords with weight distribution [6j2]. <p> This produces codewords with weight distributions [6j0j1], [0j 2j1], and [0j 0j 2], all of which give normalized weight greater than 12. We thus obtain a <ref> [12j12j12; 24; 12] </ref> ffi code with one codeword of normalized weight 12; this is the best possible. Shortening and puncturing gives an [11j11j11; 22; 11] ffi code that has one codeword of normalized weight 11. VI. <p> n BCMIM BCM BCMIM BCM for BCM 8 8 16 16 71 30 & 140 [16; 5; 8] fl 9 10 14 12 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 <ref> [22; 3; 12] </ref> 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 <p> 71 30 & 140 [16; 5; 8] fl 9 10 14 12 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 <ref> [24; 5; 12] </ref> fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 16 24 23 271-503 62 & (263-908) [32; 6; 16] fl <p> The star on some BCM component codes indicates that the code is known to be unique. A number as superscript indicates that there are exactly that many inequivalent codes with the given parameters. The information is taken from Jaffe's table <ref> [12] </ref>, except for the uniqueness of the [18; 9; 6] code, obtained by Simonis [25]. From the table, the BCMIM system has higher rate in all cases except basic block lengths 8 and 12.
Reference: [13] <author> T. Kasami, T. Takata, T. Fujiwara, and S. Lin, </author> <title> A concatenated coded modulation scheme for error control, </title> <journal> IEEE Trans. Com-mun., </journal> <volume> vol. COM-38, no. 6, </volume> <pages> pp. 752763, </pages> <month> Jun. </month> <year> 1990. </year>
Reference-contexts: The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], <ref> [12j12j12; 13; 12] </ref>, and [12j12j12j12; 24; 12] codes for basic block length 12. The case n = d n = 11 is interesting as the first case in which the split linear programming bound on dimension is not tight when i = 2. <p> There is one case that is not covered: the optimum dimension for a <ref> [13j13; k; 13] </ref> code is 9. However, the normalized distance can be increased to 14 without sacrificing rate. To construct such a code, we begin with the (unique) [19; 8; 7] code.
Reference: [14] <author> T. Kasami, T. Takata, T. Fujiwara, and S. Lin, </author> <title> On multilevel block modulation codes, </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> vol. 37, no. 4, </volume> <pages> pp. 965975, </pages> <month> Jul. </month> <year> 1991. </year>
Reference-contexts: error probability rule [2, 3, 29] in which the component codes are chosen to balance the individual error probabilities at all coding levels. (Indeed, Wachsmann and Huber [29] go so far as to suggest that virtually any technique except the traditional Euclidean distance approach will work well!) Kasami et al. <ref> [14] </ref> discuss block coded modulation schemes in which there is interblock memory between the component row codes, but in which the coded bits are assigned to symbols in the usual way. <p> Performance of BCMIM and BCM systems C. Nearest neighbors It is widely known that the most serious single disadvantage of block coded modulation schemes is the nearest neighbor problem <ref> [8, 9, 14, 31] </ref>. The standard staged decoding procedure, in which each row of the codeword array is decoded in sequence, beginning with the top row, has the effect of producing a large number of apparent nearest neighbors, i.e., a large multiplicity of the most likely error events. <p> To construct such a code, we begin with the (unique) [19; 8; 7] code. We apply the expansion construction, taking five positions and doubling them for the left block, and leaving the other 14 for the right block. This produces a <ref> [10j14; 8; 14] </ref> code. <p> We then augment by adding to the generator matrix a word with a 1 in an eleventh position on the left, a 1 0 in each pair of doubled positions on the left, and a word y in the rightmost 14 positions that is a coset leader in the <ref> [14; 8] </ref> punctured future code of the [10j14; 8; 14] code above. The augmented word is normalized distance at least 6 + 2 wt y from codewords of the [10j14; 8; 14] code. <p> the generator matrix a word with a 1 in an eleventh position on the left, a 1 0 in each pair of doubled positions on the left, and a word y in the rightmost 14 positions that is a coset leader in the [14; 8] punctured future code of the <ref> [10j14; 8; 14] </ref> code above. The augmented word is normalized distance at least 6 + 2 wt y from codewords of the [10j14; 8; 14] code. <p> doubled positions on the left, and a word y in the rightmost 14 positions that is a coset leader in the [14; 8] punctured future code of the <ref> [10j14; 8; 14] </ref> code above. The augmented word is normalized distance at least 6 + 2 wt y from codewords of the [10j14; 8; 14] code. We therefore choose the five positions from the [19; 8; 7] code to double so that the [14; 8; 4] punctured future code has covering radius 4. <p> The augmented word is normalized distance at least 6 + 2 wt y from codewords of the [10j14; 8; 14] code. We therefore choose the five positions from the [19; 8; 7] code to double so that the <ref> [14; 8; 4] </ref> punctured future code has covering radius 4. Equivalently we seek to puncture the [19; 8; 7] code in five positions, in such a way that the resulting [14; 8] code has covering radius at least 4. Some trial and error shows that this is possible. <p> We therefore choose the five positions from the [19; 8; 7] code to double so that the [14; 8; 4] punctured future code has covering radius 4. Equivalently we seek to puncture the [19; 8; 7] code in five positions, in such a way that the resulting <ref> [14; 8] </ref> code has covering radius at least 4. Some trial and error shows that this is possible. Thus we obtain an [11j14; 9; 14] code, and transferring one bit from right to left and doubling gives a [13j13; 9; 14] code. <p> Equivalently we seek to puncture the [19; 8; 7] code in five positions, in such a way that the resulting [14; 8] code has covering radius at least 4. Some trial and error shows that this is possible. Thus we obtain an <ref> [11j14; 9; 14] </ref> code, and transferring one bit from right to left and doubling gives a [13j13; 9; 14] code. <p> Some trial and error shows that this is possible. Thus we obtain an [11j14; 9; 14] code, and transferring one bit from right to left and doubling gives a <ref> [13j13; 9; 14] </ref> code. <p> Split linear programming gives a lower bound of 26 such codewords in any <ref> [13j13; 9; 14] </ref> code. 20 F. Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be [16; 1; 16], [16; 5; 8], [16; 11; 4] and [16; 15; 2]. <p> 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) <ref> [26; 3; 14] </ref> 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 16 24 23 271-503 62 & (263-908) [32; 6; 16] fl The number of apparent nearest neighbors in a BCM system depends on <p> 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 <ref> [28; 5; 14] </ref> fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 16 24 23 271-503 62 & (263-908) [32; 6; 16] fl The number of apparent nearest neighbors in a BCM system depends on the transmitted sequence and the overall modulation scheme into which the
Reference: [15] <author> Y. Kofman, E. Zehavi, and S. Shamai, </author> <title> Performance analysis of a multilevel coded modulation system, </title> <journal> IEEE Trans. Com-mun., </journal> <volume> vol. 42, no. 2/3/4, </volume> <pages> pp. 299312, </pages> <address> Feb./Mar./Apr. </address> <year> 1994. </year>
Reference-contexts: of the additive noise given that previous blocks were correct is not Gaussian; more seriously, the conditional noise distribution given that errors did occur in the blocks above the current one in the codeword array above will be both non-Gaussian and more severe than the unconditional distribution. (Kofman et al. <ref> [15] </ref> develop rigorous analytical bounds on bit error probability for a bit-interleaved coded modulation system using convolutional codes with 8-PSK, taking these complicating factors into account.) Thus there will be an error propagation effect in the system. <p> We can however construct codes with the next higher dimensions, i.e., [12j12; 9; 12] and (by shortening/puncturing) [11j11; 8; 11] codes. We use a reverse-X construction. Taking a <ref> [15; 4; 8] </ref> simplex code and puncturing in three positions that hold a codeword in the dual code gives a [12; 4; 6] code with weight enumerator 1 + 12x 6 + 3x 8 , which we use as both C 1 and C 3 . <p> Split linear programming gives a lower bound of 26 such codewords in any [13j13; 9; 14] code. 20 F. Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be [16; 1; 16], [16; 5; 8], [16; 11; 4] and <ref> [16; 15; 2] </ref>. F.1 Best [16j16; k; 16] codes Either split linear programming or the Y1/Plotkin argument show that k 12. This can be achieved using the duplication construction, starting with the [24; 12] Golay code, and forming the first block by duplicating an arbitrary subset of eight bits. <p> 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 <ref> [30; 5; 15] </ref> fl 16 16 24 23 271-503 62 & (263-908) [32; 6; 16] fl The number of apparent nearest neighbors in a BCM system depends on the transmitted sequence and the overall modulation scheme into which the codes are embedded.
Reference: [16] <author> M.-C. Lin, </author> <title> A coded modulation scheme with inter block memory, </title> <booktitle> in Proc. 1990 IEEE Intl. Symp. </booktitle> <publisher> Inform. </publisher> <address> Theory (San Diego, California, </address> <month> Jan. </month> <year> 1990), </year> <note> p. 51. </note>
Reference-contexts: The abbreviation BCMIM will refer to interblock memory systems of this type, rather than the kind considered by Kasami et al. Previous work on such block coded modulation with interblock memory systems include the original paper of Lin <ref> [16] </ref> and subsequent papers by Yamaguchi and Imai [32] and by Lin et al. [17, 18, 20] that give codes, with associated trellis decoding structures and performance simulations, though not general bounds and constructions. This paper generalizes the performance metric and explores the limits of such schemes. II. <p> The case n = d n = 8 is a main focus of the papers of Lin et al. Lin and Ma give an [8j8; 8; 8] code [17] and Lin, Wang, and Ma follow by extending this to an <ref> [8j8j8; 16; 8] </ref> code [18]. These papers give efficient trellis representations and performance simulations, but do not discuss general constructions, bounds, or optimality. A.1 Best [8j8; k; 8] codes If we allow interblock memory between the first two basic blocks, we are seeking the best [8j8; k; 8] code. <p> This is the minimum number possible. In fact, it is also the maximum number possible: this code is (up to permutations) the unique <ref> [16; 8] </ref> code with normalized distance 8. The uniqueness follows from the following reasoning. We have C = p f g, where p and f are the shortened past and future subcodes of length n, and g is an appropriate gluing code. <p> These can only be obtained by taking the 14 codewords of weight 4 from an [8; 4; 4] Hamming code and selecting one word out of every complementary pair. All such choices lead to the same code up to permutation. We note that the best <ref> [16; 8] </ref> code in terms of ordinary Hamming distance, a [16; 8; 5] shortened quadratic residue code, also unique [25], cannot by the above discussion be partitioned into two halves to get normalized distance 8 (though 7 is possible). <p> All such choices lead to the same code up to permutation. We note that the best [16; 8] code in terms of ordinary Hamming distance, a <ref> [16; 8; 5] </ref> shortened quadratic residue code, also unique [25], cannot by the above discussion be partitioned into two halves to get normalized distance 8 (though 7 is possible). <p> We do not know of any such code with 31 codewords of minimum normalized weight, though an integer weight enumerator, with integer dual weight enumerator, exists. The Golay-based code can be extended to form <ref> [9j9j9; 16; 10] </ref> and [9j9j9j9; 25; 10] codes with 56 minimum normalized weight codewords, as indicated in Table I. We omit the details. C. <p> Split linear programming gives a lower bound of 26 such codewords in any [13j13; 9; 14] code. 20 F. Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be <ref> [16; 1; 16] </ref>, [16; 5; 8], [16; 11; 4] and [16; 15; 2]. F.1 Best [16j16; k; 16] codes Either split linear programming or the Y1/Plotkin argument show that k 12. <p> Split linear programming gives a lower bound of 26 such codewords in any [13j13; 9; 14] code. 20 F. Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be [16; 1; 16], <ref> [16; 5; 8] </ref>, [16; 11; 4] and [16; 15; 2]. F.1 Best [16j16; k; 16] codes Either split linear programming or the Y1/Plotkin argument show that k 12. <p> Split linear programming gives a lower bound of 26 such codewords in any [13j13; 9; 14] code. 20 F. Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be [16; 1; 16], [16; 5; 8], <ref> [16; 11; 4] </ref> and [16; 15; 2]. F.1 Best [16j16; k; 16] codes Either split linear programming or the Y1/Plotkin argument show that k 12. <p> Split linear programming gives a lower bound of 26 such codewords in any [13j13; 9; 14] code. 20 F. Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be [16; 1; 16], [16; 5; 8], [16; 11; 4] and <ref> [16; 15; 2] </ref>. F.1 Best [16j16; k; 16] codes Either split linear programming or the Y1/Plotkin argument show that k 12. This can be achieved using the duplication construction, starting with the [24; 12] Golay code, and forming the first block by duplicating an arbitrary subset of eight bits. <p> Best codes for QAM-based BCMIM systems with basic block length 16 The codes in the baseline BCM system will be [16; 1; 16], [16; 5; 8], [16; 11; 4] and [16; 15; 2]. F.1 Best <ref> [16j16; k; 16] </ref> codes Either split linear programming or the Y1/Plotkin argument show that k 12. This can be achieved using the duplication construction, starting with the [24; 12] Golay code, and forming the first block by duplicating an arbitrary subset of eight bits. <p> This gives 759 codewords of normalized weight 16. This number can be reduced to 503 as follows. We use an X 4 construction with C 1 the <ref> [16; 1; 16] </ref> code, C 3 the [16; 5; 8] first order Reed-Muller code, and C 4 the extended Hamming [16; 11; 4] code. This still leaves C 2 to be chosen. <p> This gives 759 codewords of normalized weight 16. This number can be reduced to 503 as follows. We use an X 4 construction with C 1 the [16; 1; 16] code, C 3 the <ref> [16; 5; 8] </ref> first order Reed-Muller code, and C 4 the extended Hamming [16; 11; 4] code. This still leaves C 2 to be chosen. We choose C 2 to be the [16; 7; 4] doubly even code formed by taking the [16; 5; 8] first order Reed-Muller code, plus two <p> This gives 759 codewords of normalized weight 16. This number can be reduced to 503 as follows. We use an X 4 construction with C 1 the [16; 1; 16] code, C 3 the [16; 5; 8] first order Reed-Muller code, and C 4 the extended Hamming <ref> [16; 11; 4] </ref> code. This still leaves C 2 to be chosen. <p> We use an X 4 construction with C 1 the [16; 1; 16] code, C 3 the [16; 5; 8] first order Reed-Muller code, and C 4 the extended Hamming [16; 11; 4] code. This still leaves C 2 to be chosen. We choose C 2 to be the <ref> [16; 7; 4] </ref> doubly even code formed by taking the [16; 5; 8] first order Reed-Muller code, plus two linearly independent cosets; we choose the cosets so that they both have weight enumerators 4x 4 + 24x 8 + 4x 12 , and their `sum' (i.e., the translate of one coset <p> the [16; 1; 16] code, C 3 the <ref> [16; 5; 8] </ref> first order Reed-Muller code, and C 4 the extended Hamming [16; 11; 4] code. This still leaves C 2 to be chosen. We choose C 2 to be the [16; 7; 4] doubly even code formed by taking the [16; 5; 8] first order Reed-Muller code, plus two linearly independent cosets; we choose the cosets so that they both have weight enumerators 4x 4 + 24x 8 + 4x 12 , and their `sum' (i.e., the translate of one coset by any element of the other coset) has the same <p> Furthermore this number is the only feasible solution to the split linear programming problem when the past subcode is constrained to have the weight enumerator of C 2 .) Split linear programming gives an overall lower bound of 271 on the number of minimum normalized weight codewords. 21 F.2 Best <ref> [16j16j16; k; 16] </ref> codes The full dimension lemma combined with the result above indicates that k 28 in this case. We can achieve this upper bound using the following construction. <p> We can achieve this upper bound using the following construction. We begin by forming a <ref> [16j16; 12; 16] </ref> code C from the Golay code by partitioning the 24 positions of the Golay code into a U 8 and U 16 , again in the notation of [5], then bringing the U 8 to the left and doubling it. <p> The resulting code has generator matrix 2 4 G 3 G 2 7 where G 3 generates the <ref> [16; 8; 2] </ref> code [8; 8; 1] [2; 1; 2]. We find from [5, Table III-B] that a U 16 intersects every codeword of weight 8 from the Golay code in at least two places, and there are 16 such codewords that intersect in exactly two places. <p> Thus the punctured future code hG 1 ; G 2 i is a <ref> [16; 12; 2] </ref> (even) code, and furthermore has covering radius 2 since there are too many codewords of weight 2 for the covering radius to be 1. <p> We now select a coset leader y of weight 2 of the punctured future code and select a generator matrix for the <ref> [16j16j16; 28; 16] </ref> code of the form 2 6 6 6 6 4 G 3 G 2 0 x 2 y . . . <p> We conclude that this is a <ref> [16j16j16; 28; 16] </ref> code. There are 1671 codewords of minimum normalized weight. This code can easily be extended to more basic blocks, forming [16j16j16j16; 44; 16] and [16j16j16j16j16; 60; 16] codes, i.e., the full dimension lemma bound can be achieved in each case. V. <p> We conclude that this is a [16j16j16; 28; 16] code. There are 1671 codewords of minimum normalized weight. This code can easily be extended to more basic blocks, forming <ref> [16j16j16j16; 44; 16] </ref> and [16j16j16j16j16; 60; 16] codes, i.e., the full dimension lemma bound can be achieved in each case. V. BEST CODES FOR 8-PSK BASED BCMIM SYSTEM In an 8-PSK modulation system, the minimum squared intra-subset Euclidean distance increases with the ratio 1 : 3.414 : 6.828. <p> We conclude that this is a [16j16j16; 28; 16] code. There are 1671 codewords of minimum normalized weight. This code can easily be extended to more basic blocks, forming [16j16j16j16; 44; 16] and <ref> [16j16j16j16j16; 60; 16] </ref> codes, i.e., the full dimension lemma bound can be achieved in each case. V. BEST CODES FOR 8-PSK BASED BCMIM SYSTEM In an 8-PSK modulation system, the minimum squared intra-subset Euclidean distance increases with the ratio 1 : 3.414 : 6.828. <p> are compared on this basis to longer baseline BCM systems in Table V. 24 TABLE V COMPARISON TO LONGER BASELINE BCM FOR QAM-BASED SYSTEMS Rate, bits/2n symbols Min. (norm.) wt. codewords Component codes n d n BCMIM BCM BCMIM BCM for BCM 8 8 16 16 71 30 & 140 <ref> [16; 5; 8] </ref> fl 9 10 14 12 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 <p> 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 16 24 23 271-503 62 & (263-908) <ref> [32; 6; 16] </ref> fl The number of apparent nearest neighbors in a BCM system depends on the transmitted sequence and the overall modulation scheme into which the codes are embedded.
Reference: [17] <author> M.-C. Lin and S.-H. Ma, </author> <title> A coded modulation scheme with inter block memory, </title> <journal> IEEE Trans. Commun., </journal> <volume> vol. 42, no. 2/3/4, </volume> <pages> pp. 911916, </pages> <address> Feb./Mar./Apr. </address> <year> 1994. </year>
Reference-contexts: Previous work on such block coded modulation with interblock memory systems include the original paper of Lin [16] and subsequent papers by Yamaguchi and Imai [32] and by Lin et al. <ref> [17, 18, 20] </ref> that give codes, with associated trellis decoding structures and performance simulations, though not general bounds and constructions. This paper generalizes the performance metric and explores the limits of such schemes. II. <p> The case n = d n = 8 is a main focus of the papers of Lin et al. Lin and Ma give an [8j8; 8; 8] code <ref> [17] </ref> and Lin, Wang, and Ma follow by extending this to an [8j8j8; 16; 8] code [18]. These papers give efficient trellis representations and performance simulations, but do not discuss general constructions, bounds, or optimality. <p> This upper bound can be achieved using the code discussed by Lin and Ma <ref> [17] </ref> with generator matrix G 8=2 (see Table II). <p> 1 1 1 1 1 1 1 7 7 7 7 7 5 This code can be obtained from an X 4 construction, with C 1 an [8; 1; 8] code, C 2 and C 3 [8; 4; 4] codes, and C 4 an [8; 7; 2] code. (The reference <ref> [17] </ref> cites [26], which introduces the X 4 construction.) (None of the other constructions of Section III give k = 8.
Reference: [18] <author> M.-C. Lin, J.-Y. Wang, and S.-C. Ma, </author> <title> On block-coded modulation with interblock memory, </title> <journal> IEEE Trans. Commun., </journal> <volume> vol. 45, no. 11, </volume> <pages> pp. 14011411, </pages> <month> Nov. </month> <year> 1997. </year>
Reference-contexts: Previous work on such block coded modulation with interblock memory systems include the original paper of Lin [16] and subsequent papers by Yamaguchi and Imai [32] and by Lin et al. <ref> [17, 18, 20] </ref> that give codes, with associated trellis decoding structures and performance simulations, though not general bounds and constructions. This paper generalizes the performance metric and explores the limits of such schemes. II. <p> The case n = d n = 8 is a main focus of the papers of Lin et al. Lin and Ma give an [8j8; 8; 8] code [17] and Lin, Wang, and Ma follow by extending this to an [8j8j8; 16; 8] code <ref> [18] </ref>. These papers give efficient trellis representations and performance simulations, but do not discuss general constructions, bounds, or optimality. A.1 Best [8j8; k; 8] codes If we allow interblock memory between the first two basic blocks, we are seeking the best [8j8; k; 8] code. <p> Thus with interblock memory extended to the third basic block, we can potentially increase the dimension by at most 1. This can in fact be achieved by the code considered by Lin et al. <ref> [18] </ref> in which the [8j8; 8; 8] code for the first two basic blocks and the [8; 7; 2] baseline code for the third basic block are glued by the word fi fl This code has the disadvantage that it has 131 codewords of minimum normalized weight. <p> 0 1 0 0 1 0 1 0 0 1 1 0 0 0 0 0 1 1 0 1 1 1 1 1 0 1 1 1 0 0 7 7 7 7 5 A slightly smaller number of minimum normalized weight codewords can be obtained from an optimal <ref> [18; 7; 7] </ref> code partitioned in an appropriate way. <p> 7 7 5 which has 33 codewords of minimum normalized weight. (This code has more codewords of the next higher weight than the code based on Piret's construction, however: 36 codewords of normalized weight 12, versus 27.) The even (Hamming) weight subcode obtained by deleting the first row is an <ref> [18; 6; 8] </ref> code. It is known [7] that there are exactly two such codes up to equivalence, both obtainable by shortening the [24; 12] Golay code. <p> Since A (10; 4; 7) = 13, and only 10 of these words have been used, y can be chosen to be any of the remaining 3 words. This gives a [10j10j10; 20; 10:4] ffi code with 10 codewords of normalized weight 10.4. Shortening and puncturing gives a <ref> [9j9j9; 18; 9:4] </ref> ffi code with 8 codewords of normalized weight 9.4. For n = 12, the gluing code generator matrix can be taken to be any row with weight distribution [6j0j1] between the three basic blocks. <p> V. 24 TABLE V COMPARISON TO LONGER BASELINE BCM FOR QAM-BASED SYSTEMS Rate, bits/2n symbols Min. (norm.) wt. codewords Component codes n d n BCMIM BCM BCMIM BCM for BCM 8 8 16 16 71 30 & 140 [16; 5; 8] fl 9 10 14 12 31-33 6 & 0 <ref> [18; 3; 10] </ref> 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 <p> The star on some BCM component codes indicates that the code is known to be unique. A number as superscript indicates that there are exactly that many inequivalent codes with the given parameters. The information is taken from Jaffe's table [12], except for the uniqueness of the <ref> [18; 9; 6] </ref> code, obtained by Simonis [25]. From the table, the BCMIM system has higher rate in all cases except basic block lengths 8 and 12.
Reference: [19] <author> T. J. Lunn and A. G. Burr, </author> <title> Number of neighbors for staged decoding of block coded modulation, </title> <journal> Elec. Letters, </journal> <volume> vol. 29, no. 20, </volume> <pages> pp. 18301831, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: There are at least two more inequivalent [11j11; 8; 12] codes, though none are known that have as few minimum normalized weight codewords. Split integer programming gives a lower bound of 24 on the number of minimum normalized weight codewords. The code described above can be extended to form <ref> [11j11j11; 19; 12] </ref> and [11j11j11j11; 30; 12] codes, meeting the upper bound of the full rate lemma in each case, with 198 codewords of minimum normalized weight. We omit the details. <p> There is one case that is not covered: the optimum dimension for a [13j13; k; 13] code is 9. However, the normalized distance can be increased to 14 without sacrificing rate. To construct such a code, we begin with the (unique) <ref> [19; 8; 7] </ref> code. We apply the expansion construction, taking five positions and doubling them for the left block, and leaving the other 14 for the right block. This produces a [10j14; 8; 14] code. <p> The augmented word is normalized distance at least 6 + 2 wt y from codewords of the [10j14; 8; 14] code. We therefore choose the five positions from the <ref> [19; 8; 7] </ref> code to double so that the [14; 8; 4] punctured future code has covering radius 4. Equivalently we seek to puncture the [19; 8; 7] code in five positions, in such a way that the resulting [14; 8] code has covering radius at least 4. <p> We therefore choose the five positions from the <ref> [19; 8; 7] </ref> code to double so that the [14; 8; 4] punctured future code has covering radius 4. Equivalently we seek to puncture the [19; 8; 7] code in five positions, in such a way that the resulting [14; 8] code has covering radius at least 4. Some trial and error shows that this is possible. <p> (d=8) (where a i (w) denotes the number of codewords of weight w in the ith code) and the average number over all transmitted sequences is a 1 (d)3 d + a 2 (d)2:25 d=2 + a 3 (d)2 d=4 + a 4 (d), assuming all codewords are equally likely <ref> [19, 31] </ref>.
Reference: [20] <author> S.-C. Ma and M.-C. Lin, </author> <title> A trellis coded modulation scheme constructed from block coded modulation with interblock memory, </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> vol. 40, no. 5, </volume> <pages> pp. 13481363, </pages> <month> Sep. </month> <year> 1994. </year>
Reference-contexts: Previous work on such block coded modulation with interblock memory systems include the original paper of Lin [16] and subsequent papers by Yamaguchi and Imai [32] and by Lin et al. <ref> [17, 18, 20] </ref> that give codes, with associated trellis decoding structures and performance simulations, though not general bounds and constructions. This paper generalizes the performance metric and explores the limits of such schemes. II. <p> The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and <ref> [11j11j11j11; 20; 11] </ref> codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and [12j12j12j12; 24; 12] codes for basic block length 12. <p> Since A (10; 4; 7) = 13, and only 10 of these words have been used, y can be chosen to be any of the remaining 3 words. This gives a <ref> [10j10j10; 20; 10:4] </ref> ffi code with 10 codewords of normalized weight 10.4. Shortening and puncturing gives a [9j9j9; 18; 9:4] ffi code with 8 codewords of normalized weight 9.4. <p> SYSTEMS Rate, bits/2n symbols Min. (norm.) wt. codewords Component codes n d n BCMIM BCM BCMIM BCM for BCM 8 8 16 16 71 30 & 140 [16; 5; 8] fl 9 10 14 12 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) <ref> [20; 4; 10] </ref> 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15
Reference: [21] <author> F. J. MacWilliams and N. J. A. Sloane, </author> <title> The Theory of Error-Correcting Codes, </title> <publisher> North-Holland, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: A.1 Plotkin bound Suppose we have a code with n 1 bits in the first basic block, n 2 in the second, and so on. A straightforward application of the classical Plotkin bound argument, in which we evaluate X X d n (u; v) via both rows and columns <ref> [21, pp. 4142] </ref> gives the result M d n 1 ; with equality if and only if every nonzero codeword has the minimum normalized weight d n . <p> We list below the constructions that were found most useful in the main case. The distance bounds follow by elementary adaptation of the reasoning for the ordinary Hamming distance case (see for example <ref> [21] </ref>). B.1 Extension bound This bound relates the normalized and Hamming distance problems directly. The bound is normally useful only in the case of interblock memory between the first two basic blocks, though it can be extended in obvious ways. <p> This results in a code with parameters [2n 1 j2n 2 ; k 1 + k 2 ; d n minf2d 1 ; d 2 g]. B.3 X and Reverse-X constructions The X construction <ref> [21, p. 581] </ref> takes codes C 1 [n 1 ; k 1 ; d 1 ], C 2 [n 1 ; k 2 ; d 2 ], with C 1 ae C 2 and C 3 [n 3 ; k 2 k 1 ; d 3 ]. <p> But A (8; 4; 6) = 4 <ref> [21, p. 684] </ref> so this is impossible. So k (p) = 1, and k (f ) + k (g) = 7. Since the shortened past subcode has dimension 1 and length equal to the target normalized distance, the overall code must contain the codeword (1 8 j0 8 ). <p> Shortening the overall code in any set of m positions holding a codeword of C ? fg gives a code with n 1 = 9, n 2 = 9 m, and k s 7 m + 1 (this is construction Y1 from MacWilliams & Sloane <ref> [21, p. 592] </ref>). Suppose that C ? fg had minimum distance 5. Then applying Y1 with m = 5 gives a code with n 1 = 9, n 2 = 4, and k 3. But the Plotkin bound for this case gives M 10=(10 (9=2 + 4)) &lt; 7. <p> There are at least two inequivalent codes that satisfy these constraints. The first is obtained by a version of Piret's construction <ref> [21, pp. 5889] </ref> applied to the [9; 6; 2] irreducible cyclic code. <p> = w j for all j, so the (unique) best choice for a in this case is 3, giving d ? = 10. (The factor 2 on the right of the expression for d 0 and the corresponding optimal choice of a are the only differences with the development in <ref> [21] </ref>.) This results in a [9j9; 6; 10] code, and adding the row (0 9 j1 9 ) to the generator matrix does not affect the minimum normalized distance, thus giving a [9j9; 7; 10] code. (A brute force search showed that adding the row (r l j1 9 ) for <p> We omit the details. D.2 Best [12j12j12; k; 12] and [12j12j12j12; k; 12] codes We will use the same approach to construct a <ref> [12j12j12; 21; 12] </ref> code as in the basic block length 10 case. The [12; 4; 6] punctured simplex code above has 48 cosets with weight enumerator 5x 4 + 7x 6 + 3x 8 + x 10 . <p> This is possible if we choose one coset to be the one represented by the Boolean function v 1 v 2 and the other to be the one represented by the Boolean function v 1 v 3 <ref> [21, p. 418] </ref>. The `sum' coset is represented by the Boolean function v 1 v 2 +v 1 v 3 . <p> Letting f (v) = v 1 v 3 , we see that v 1 v 2 + v 1 v 3 = f (Av), with A = (1 1 00=0 1 0 0=0 0 1 0=0 0 0 1), from which we conclude (see <ref> [21, Thm. 14.4, p. 417] </ref>) that the cosets represented by v 1 v 3 and v 1 v 2 + v 1 v 3 have the same weight distribution. The code C 2 thus has weight enumerator 1+12x 4 +102x 8 +12x 12 +x 16 . <p> Then all nonzero codewords have weight distribution [7j1], [4j2] and [0j3], and thus have normalized distance at least 10.4. Since A (10; 4; 7) = 13 <ref> [21, p. 684] </ref>, we can find 10 such words.
Reference: [22] <author> R. H. Morelos-Zaragoza, T. Kasami, S. Lin, and H. Imai, </author> <title> On block-coded modulation using unequal error protection codes over Rayleigh fading channels, </title> <journal> IEEE Trans. Commun., </journal> <volume> vol. 46, no. 1, </volume> <pages> pp. 14, </pages> <month> Jan. </month> <year> 1998. </year>
Reference-contexts: This produces codewords with weight distributions [6j0j1], [0j 2j1], and [0j 0j 2], all of which give normalized weight greater than 12. We thus obtain a [12j12j12; 24; 12] ffi code with one codeword of normalized weight 12; this is the best possible. Shortening and puncturing gives an <ref> [11j11j11; 22; 11] </ref> ffi code that has one codeword of normalized weight 11. VI. <p> n BCMIM BCM BCMIM BCM for BCM 8 8 16 16 71 30 & 140 [16; 5; 8] fl 9 10 14 12 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 <ref> [22; 3; 12] </ref> 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16
Reference: [23] <author> C.-N. Peng, </author> <title> Block Coded Modulation Schemes With Interblock Memory, </title> <type> PhD thesis, </type> <institution> Univ. of Michigan, </institution> <year> 1998. </year>
Reference-contexts: w 3 (c) 1 w 4 (c) , and an average of P W (c)=d n 3 w 1 (c) 2:25 w 2 (c) 2 w 3 (c) 1 w 4 (c) , where w i (c) denotes the Hamming weight of the word c in the ith basic block <ref> [23, pp. 152155] </ref>. The star on some BCM component codes indicates that the code is known to be unique. A number as superscript indicates that there are exactly that many inequivalent codes with the given parameters.
Reference: [24] <author> S. I. Sayegh, </author> <title> A class of optimum block codes in signal space, </title> <journal> IEEE Trans. Commun., </journal> <volume> vol. COM34, no. 10, </volume> <pages> pp. 10431045, </pages> <month> Oct. </month> <year> 1986. </year>
Reference-contexts: The minimum squared Euclidean distance between two sequences of n symbols in a baseline BCM system is well known to be D 2 i where d i is the minimum Hamming distance of code C i . (See, for example, Sayegh <ref> [24] </ref>). The quantity min i d i a i is the distance gain of the BCM system over the uncoded system. <p> 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 7 7 7 7 7 7 7 7 7 7 7 7 7 5 Together with eight uncoded bits for the fourth basic block, we can build a BCMIM system with the parameters <ref> [8j8j8j8; 24; 8] </ref>. This is therefore a 16-QAM system that transmits 24 information bits per eight symbols. Making these most significant label bits uncoded adds 8 minimum normalized weight codewords, whereas adding the most significant label bits to the least significant label bits adds none. <p> It is known [7] that there are exactly two such codes up to equivalence, both obtainable by shortening the <ref> [24; 12] </ref> Golay code. The corresponding Hamming weight enumerators are 1 + 46x 8 + 16x 12 + x 16 and 1 + 45x 8 + 18x 12 . The code generated by the last six rows of the matrix above has the second of these weight enumerators. <p> Split linear programming gives k 8, and this bound can easily be achieved by modifying the <ref> [24; 12] </ref> Golay code. <p> The systems without interblock memory therefore give [11j11; 4; 11], [11j11j11; 10; 11], and [11j11j11j11; 20; 11] codes for basic block length 11, and [12j12; 5; 12], [12j12j12; 13; 12], and <ref> [12j12j12j12; 24; 12] </ref> codes for basic block length 12. The case n = d n = 11 is interesting as the first case in which the split linear programming bound on dimension is not tight when i = 2. <p> D.1 An [11j11; 8; 12] code We can obtain an [11j11; 8; 11] code from the [12j12; 9; 12] code via shortening-puncturing. However, it is possible to increase the minimum normalized distance to 12 without sacrificing rate. One such code is 18 obtained by taking the <ref> [24; 12; 8] </ref> Golay code and partitioning to get an [8j16; 12; 8] code with the codeword (1 8 j0 16 ). <p> F.1 Best [16j16; k; 16] codes Either split linear programming or the Y1/Plotkin argument show that k 12. This can be achieved using the duplication construction, starting with the <ref> [24; 12] </ref> Golay code, and forming the first block by duplicating an arbitrary subset of eight bits. This gives 759 codewords of normalized weight 16. This number can be reduced to 503 as follows. <p> The case n = 6 above is straightforward. For n = 12, the baseline codes are [12; 1; 12], [12; 7; 4] and [12; 11; 2]. To construct a [12j12; 12; 12] ffi code, we take the <ref> [24; 12] </ref> Golay code and partition into two U 12 's. Since these are codewords in the [24; 12] code, the possible weight distributions of words of Hamming weight 8 are 6j2, 4j4, and 2j6, all of which have normalized weight greater than 12. <p> For n = 12, the baseline codes are [12; 1; 12], [12; 7; 4] and [12; 11; 2]. To construct a [12j12; 12; 12] ffi code, we take the <ref> [24; 12] </ref> Golay code and partition into two U 12 's. Since these are codewords in the [24; 12] code, the possible weight distributions of words of Hamming weight 8 are 6j2, 4j4, and 2j6, all of which have normalized weight greater than 12. <p> This produces codewords with weight distributions [6j0j1], [0j 2j1], and [0j 0j 2], all of which give normalized weight greater than 12. We thus obtain a <ref> [12j12j12; 24; 12] </ref> ffi code with one codeword of normalized weight 12; this is the best possible. Shortening and puncturing gives an [11j11j11; 22; 11] ffi code that has one codeword of normalized weight 11. VI. <p> 71 30 & 140 [16; 5; 8] fl 9 10 14 12 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 <ref> [24; 5; 12] </ref> fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 16 24 23 271-503 62 & (263-908) [32; 6; 16] fl
Reference: [25] <author> J. Simonis, </author> <title> The [18; 9; 6] code is unique, </title> <journal> Discrete Mathematics, </journal> <volume> vol. 106/107, </volume> <pages> pp. 439448, </pages> <month> Sep. </month> <year> 1992. </year>
Reference-contexts: All such choices lead to the same code up to permutation. We note that the best [16; 8] code in terms of ordinary Hamming distance, a [16; 8; 5] shortened quadratic residue code, also unique <ref> [25] </ref>, cannot by the above discussion be partitioned into two halves to get normalized distance 8 (though 7 is possible). <p> We do not know of any such code with 31 codewords of minimum normalized weight, though an integer weight enumerator, with integer dual weight enumerator, exists. The Golay-based code can be extended to form [9j9j9; 16; 10] and <ref> [9j9j9j9; 25; 10] </ref> codes with 56 minimum normalized weight codewords, as indicated in Table I. We omit the details. C. <p> A number as superscript indicates that there are exactly that many inequivalent codes with the given parameters. The information is taken from Jaffe's table [12], except for the uniqueness of the [18; 9; 6] code, obtained by Simonis <ref> [25] </ref>. From the table, the BCMIM system has higher rate in all cases except basic block lengths 8 and 12.
Reference: [26] <author> N. J. A. Sloane, S. M. Reddy, and C.-L. Chen, </author> <title> New binary codes, </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> vol. IT18, no. 4, </volume> <pages> pp. 503510, </pages> <month> Jul. </month> <year> 1972. </year>
Reference-contexts: When this is done, the resulting generator matrix can be taken to have the form 2 6 G 1 0 0 G 3 7 5 : where C 2 = hG 1 ; G 2=1 i and C 4 = hG 3 ; G 4=3 i <ref> [26] </ref>. The normalized parameters are [n 1 jn 3 ; k 2 + k 3 ; minfd 1 ; a 2 d 3 ; d 2 + a 2 d 4 g]. TABLE I CODES FOR QAM-BASED SYSTEMS Max. rate gain, bits/n symbols Opt. <p> 1 1 1 1 1 7 7 7 7 7 5 This code can be obtained from an X 4 construction, with C 1 an [8; 1; 8] code, C 2 and C 3 [8; 4; 4] codes, and C 4 an [8; 7; 2] code. (The reference [17] cites <ref> [26] </ref>, which introduces the X 4 construction.) (None of the other constructions of Section III give k = 8. <p> 31-33 6 & 0 [18; 3; 10] 10 10 16 15 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) <ref> [26; 3; 14] </ref> 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 16 24 23 271-503 62 & (263-908) [32; 6; 16] fl The number of apparent nearest neighbors in a BCM system depends on
Reference: [27] <author> T. Takata, S. Ujita, T. Kasami, and S. Lin, </author> <title> Multistage decoding of multilevel block M-PSK modulation codes and its performance analysis, </title> <journal> IEEE Trans. Inform. Theory, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 12041218, </pages> <month> Jul. </month> <year> 1993. </year>
Reference: [28] <author> J. H. van Lint, </author> <title> Introduction to Coding Theory, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1982. </year>
Reference-contexts: Since at least half of the other codewords have bd n =2c ones in these positions, we have the claimed normalized distance in the residual code (cf. <ref> [28, p. 46] </ref>).) In the usual situation, we have n = d n and interblock memory between the first two basic blocks. <p> For four basic blocks, we can again achieve the bound of the full dimension lemma, obtaining a code with parameters <ref> [10j10j10j10; 28; 10] </ref>. <p> We now select a coset leader y of weight 2 of the punctured future code and select a generator matrix for the <ref> [16j16j16; 28; 16] </ref> code of the form 2 6 6 6 6 4 G 3 G 2 0 x 2 y . . . <p> We conclude that this is a <ref> [16j16j16; 28; 16] </ref> code. There are 1671 codewords of minimum normalized weight. This code can easily be extended to more basic blocks, forming [16j16j16j16; 44; 16] and [16j16j16j16j16; 60; 16] codes, i.e., the full dimension lemma bound can be achieved in each case. V. <p> 6-12 10 & (1-16) [20; 4; 10] 3 11 12 16 15 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 <ref> [28; 5; 14] </ref> fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 16 24 23 271-503 62 & (263-908) [32; 6; 16] fl The number of apparent nearest neighbors in a BCM system depends on the transmitted sequence and the overall modulation scheme into which the
Reference: [29] <author> U. Wachsmann and J. Huber, </author> <title> Distance profile of multilevel coded transmission and rate design, </title> <booktitle> in Proc. 1998 Information Theory Workshop (Killarney, </booktitle> <address> Ireland, </address> <month> June </month> <year> 1998), </year> <pages> pp. 1011. </pages>
Reference-contexts: Several alternative approaches have been proposed recently to the code design problem for regular BCM: for example, the capacity rule [10] in which rates are assigned to the component codes according to random coding principles, and the error probability rule <ref> [2, 3, 29] </ref> in which the component codes are chosen to balance the individual error probabilities at all coding levels. (Indeed, Wachsmann and Huber [29] go so far as to suggest that virtually any technique except the traditional Euclidean distance approach will work well!) Kasami et al. [14] discuss block coded <p> BCM: for example, the capacity rule [10] in which rates are assigned to the component codes according to random coding principles, and the error probability rule [2, 3, 29] in which the component codes are chosen to balance the individual error probabilities at all coding levels. (Indeed, Wachsmann and Huber <ref> [29] </ref> go so far as to suggest that virtually any technique except the traditional Euclidean distance approach will work well!) Kasami et al. [14] discuss block coded modulation schemes in which there is interblock memory between the component row codes, but in which the coded bits are assigned to symbols in
Reference: [30] <author> R. G. C. Williams, </author> <title> Low Complexity Block Coded Modulation, </title> <type> PhD thesis, </type> <institution> Univ. of Manchester, </institution> <year> 1988. </year>
Reference-contexts: Split integer programming gives a lower bound of 24 on the number of minimum normalized weight codewords. The code described above can be extended to form [11j11j11; 19; 12] and <ref> [11j11j11j11; 30; 12] </ref> codes, meeting the upper bound of the full rate lemma in each case, with 198 codewords of minimum normalized weight. We omit the details. <p> 24-55 (3-6) & 77 [22; 3; 12] 12 12 18 19 6-60 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 <ref> [30; 5; 15] </ref> fl 16 16 24 23 271-503 62 & (263-908) [32; 6; 16] fl The number of apparent nearest neighbors in a BCM system depends on the transmitted sequence and the overall modulation scheme into which the codes are embedded.
Reference: [31] <author> R. G. C. Williams, </author> <title> Block coding for voiceband modems, </title> <journal> British Telecom Tech. J., </journal> <volume> vol. 10, no. 1, </volume> <pages> pp. 101111, </pages> <month> January </month> <year> 1992. </year> <month> 26 </month>
Reference-contexts: Performance of BCMIM and BCM systems C. Nearest neighbors It is widely known that the most serious single disadvantage of block coded modulation schemes is the nearest neighbor problem <ref> [8, 9, 14, 31] </ref>. The standard staged decoding procedure, in which each row of the codeword array is decoded in sequence, beginning with the top row, has the effect of producing a large number of apparent nearest neighbors, i.e., a large multiplicity of the most likely error events. <p> (d=8) (where a i (w) denotes the number of codewords of weight w in the ith code) and the average number over all transmitted sequences is a 1 (d)3 d + a 2 (d)2:25 d=2 + a 3 (d)2 d=4 + a 4 (d), assuming all codewords are equally likely <ref> [19, 31] </ref>.
Reference: [32] <author> K. Yamaguchi and H. Imai, </author> <title> A new block coded modulation scheme and its soft decision decoding, </title> <booktitle> in Proc. 1993 IEEE Intl. Symp. </booktitle> <institution> Inform. Theory (San Antonio, Texas, </institution> <month> Jan. </month> <year> 1993), </year> <note> p. 64. </note>
Reference-contexts: The abbreviation BCMIM will refer to interblock memory systems of this type, rather than the kind considered by Kasami et al. Previous work on such block coded modulation with interblock memory systems include the original paper of Lin [16] and subsequent papers by Yamaguchi and Imai <ref> [32] </ref> and by Lin et al. [17, 18, 20] that give codes, with associated trellis decoding structures and performance simulations, though not general bounds and constructions. This paper generalizes the performance metric and explores the limits of such schemes. II. <p> 28 & 336 [24; 5; 12] fl 13 14 18 16 26-96 (2-4) & (1-116) [26; 3; 14] 14 14 20 19 9-34 24 & 0 [28; 5; 14] fl 15 15 22 20 39-136 16 & 0 [30; 5; 15] fl 16 16 24 23 271-503 62 & (263-908) <ref> [32; 6; 16] </ref> fl The number of apparent nearest neighbors in a BCM system depends on the transmitted sequence and the overall modulation scheme into which the codes are embedded.
Reference: [33] <author> L. Zhang and B. Vucetic, </author> <title> Multilevel block codes for Rayleigh fading channels, </title> <journal> IEEE Trans. Commun., </journal> <volume> vol. 43, no. 1, </volume> <pages> pp. 2431, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: The only case that needs to be checked is the case (y i j0j0je i ) + (vjuj0j0), which has weight distribution (2j 3j0j1). Thus none of the codewords with ones in the fourth basic block have normalized weight as low as 12. The code is thus <ref> [12j12j12j12; 33; 12] </ref> with 214 codewords of normalized weight 12. E. Best codes for QAM-based BCMIM systems with basic block lengths 1315 The codes of highest dimension with basic block lengths in this range can all be obtained from the n = 16 case below via shortening and puncturing.
References-found: 33

