URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1278/CS-TR-95-1278.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-95-1278/
Root-URL: http://www.cs.wisc.edu
Title: ALGORITHMS FOR LOADING OBJECT DATABASES  
Author: By Janet Lynn Wiener 
Degree: A dissertation submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy (Computer Sciences) at the  
Date: 1995  
Address: WISCONSIN MADISON  
Affiliation: UNIVERSITY OF  
Abstract-found: 0
Intro-found: 1
Reference: [Cam95] <author> John Campbell, </author> <month> January </month> <year> 1995. </year> <type> Personal correspondence. </type>
Reference-contexts: We give two examples of such data sets from the scientific community. In both cases, the scientists involved are using or planning to use an OODB to store their data. * The Human Genome Database <ref> [Cam95, CPea93] </ref> is currently just over 1 Gb of 50-200 byte objects, containing 3-15 bidirectional relationships each.
Reference: [Cat93] <author> R. G. G. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <publisher> Morgan-Kaufman, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Inverse relationships are sometimes called bidirectional relationships, and are part of the ODMG standard <ref> [Cat93] </ref>. Ontos, Objectivity, ObjectStore, and Versant all support inverse relationships [Ont94, Obj92, LLOW91, Ver93]. Loading object-relational data involves surmounting the same problems with relationships as loading object-oriented data. <p> In this schema, each Experiment object has a many-to-one relationship with an Input object and a one-to-one relationship with an Output object. Figure 1 defines the schema in the Object Definition Language proposed by ODMG <ref> [Cat93] </ref>. 9 interface Experiment f attribute char scientist [16]; relationship Ref&lt;Input&gt; input inverse Input::expts; relationship Ref&lt;Output&gt; output inverse Output::expt; g; interface Input f attribute double temperature; attribute integer humidity; relationship Set&lt;Experiment&gt; expts inverse Experiment::input; g; interface Output f attribute double plant growth; relationship Ref&lt;Experiment&gt; expt inverse Experiment::output; g; 3.2.2 Data file <p> Enrollment has a one-to-one relationship with both a Student and a Section, representing the Student's enrollment in that Section. We define the schema in Figure 31 using the Object Definition Language proposed by ODMG <ref> [Cat93] </ref>. 5.3.2 Example query functions In Figure 32, we define two query functions over the university database.
Reference: [CDF + 94] <author> M. Carey, D. DeWitt, M. Franklin, N. Hall, M. McAuliffe, J. Naughton, D. Schuh, M. Solomon, C. Tan, O. Tsatalos, S. White, and M. Zwilling. </author> <title> Shoring Up Persistent Applications. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 383-394, </pages> <year> 1994. </year>
Reference-contexts: Second, we explore the space of possible load algorithms with extensive performance studies of their behavior. We use both an analytic model and an implementation within the Shore persistent object repository <ref> [CDF + 94] </ref> to examine a wide variety of conditions that affect the loading speed, and are able to recommend a single algorithm for OODB load utility writers to implement. <p> In the data sets with no locality of reference, all relationships are to objects chosen at random. 7 2.2 Implementation We implemented all of the algorithms in C ++ . The database was stored under the Shore storage manager <ref> [CDF + 94] </ref>. We used the Shore persistent object manager, even though it is still under development, for two reasons. First, Shore provides the notion of a "value-added server" (VAS), which allowed us to place the load utility directly in the server. <p> We examine several techniques for dealing with circular and inverse relationships and introduce seven algorithms based on these techniques. We evaluate the performance of these algorithms with an analytic model and an implementation on top of the Shore persistent object repository <ref> [CDF + 94] </ref>. We use the analytic model to explore a wide range of load file and system configurations. The implementation results both validate the analytic model and highlight several key advantages and disadvantages of using logical OIDs.
Reference: [CMR92] <author> J. B. Cushing, D. Maier, and M. Rao. </author> <title> Computational Proxies: Modeling Scientific Applications in Object Databases. </title> <type> Technical Report 92-020, </type> <institution> Oregon Graduate Institute, </institution> <month> December </month> <year> 1992. </year> <note> Revised May, </note> <year> 1993. </year>
Reference-contexts: Loading large amounts of data is currently a bottleneck in many OODB applications <ref> [CMR92, CMR + 94] </ref>. Relational database systems provide a load utility to bypass the individual language statements; OODB need a similar facility. Users are currently spending too much time and effort just loading the data they want to examine. <p> Users are currently spending too much time and effort just loading the data they want to examine. For example, Cushing reports that loading the experimental data was the most time-consuming part of analyzing a set of computational chemistry experiments <ref> [CMR92] </ref>. A load utility takes an ascii description of all of the data to be loaded and returns when it has loaded it. For relational systems, a load utility significantly improves performance even when loading only a small number of objects, because it is based in the database server [Moh93b].
Reference: [CMR + 94] <author> J. B. Cushing, D. Maier, M. Rao, D. Abel, D. Feller, and D. M. DeVaney. </author> <title> Computational Proxies: Modeling Scientific Applications in Object Databases. </title> <booktitle> In Proceedings of the Seventh Intenational Conference on Scientific and Statistical Database Management, </booktitle> <address> Charlottesville, VA, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Loading large amounts of data is currently a bottleneck in many OODB applications <ref> [CMR92, CMR + 94] </ref>. Relational database systems provide a load utility to bypass the individual language statements; OODB need a similar facility. Users are currently spending too much time and effort just loading the data they want to examine. <p> We also discuss when to update the existing objects that share bidirectional relationships with new objects, and hence need to be modified. After describing our new technique, we present a performance study comparing it to simpler techniques. 5.2 Related work In the context of scientific experiments, Cushing et al. <ref> [CMR + 94] </ref> propose using proxy objects to keep track of an experiment's input objects and to facilitate loading the result objects, including linking them to the input objects.
Reference: [CPea93] <author> M.A. Chipperfield, C.J. Porter, and et al. </author> <title> Growth of Data in the Genome Data Base since CCM92 and Methods for Access. </title> <booktitle> In Human Genome Mapping, </booktitle> <pages> pages 3-5, </pages> <year> 1993. </year>
Reference-contexts: We give two examples of such data sets from the scientific community. In both cases, the scientists involved are using or planning to use an OODB to store their data. * The Human Genome Database <ref> [Cam95, CPea93] </ref> is currently just over 1 Gb of 50-200 byte objects, containing 3-15 bidirectional relationships each.
Reference: [Day87] <author> U. Dayal. </author> <title> Of Nests and Trees: A Unified Approach to Processing Queries that Contain Nested Subqueries, Aggregates, and Quantifiers. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <pages> pages 197-208, </pages> <year> 1987. </year>
Reference-contexts: We let the explicit use of query functions solve the recognition problem. Evaluating multiple instances of query functions is also related to evaluating correlated subqueries. The techniques we apply to evaluate multiple queries together are similar to those for decorrelating subqueries <ref> [Kim82, Day87, GW87] </ref>, and attain similar improvements in performance.
Reference: [Deu90] <author> O. </author> <title> Deux. The Story of O2. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 91-108, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: Introduction There has been a recent trend to add object functionality to database systems. The resulting technology has resulted in object-oriented databases, object-relational databases, and even relational databases augmented with objects. There are many commercial object-oriented database products today, including Ontos [Ont94], O2 <ref> [Deu90] </ref>, Objectivity [Obj92], ObjectStore [LLOW91], Versant [Ver93], and Gemstone [MS90]. Yet in these systems, loading new data can only be accomplished by creating one object at a time. There are also several object-relational database products on the market, such as Il-lustra [Ube94] and UniSQL [Kim94].
Reference: [DKO + 84] <author> D. J. DeWitt, R. H. Katz, F. Olken, L. D. Shapiro, M. R. Stonebraker, and D. Wood. </author> <title> Implementation Techniques for Main Memory Database Systems. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 1-8, </pages> <year> 1984. </year>
Reference-contexts: In-mem is better than partitioned-list when the id map does fit in memory because it writes neither the id map nor a todo list to disk. This performance gap could be narrowed by using a hybrid hash join <ref> [DKO + 84] </ref> in the partitioned-list algorithm instead of the standard Grace hash join [Kea83] to join the id map, todo list, and inverse todo lists. <p> Deferred-evaluation, therefore, defers evaluating any query instantiation until all of the instantiations are known. Then one join is performed per query function. We chose to implement (and describe) hybrid hash join <ref> [DKO + 84] </ref> for the join, but any join technique could be used. The following changes are made to the load algorithm. 1. Insert into step 1. * For each query function, allocate an instantiation table. 2.
Reference: [DLP + 93] <author> R. Drach, S. Louis, G. Potter, G. Richmond, D. Rotem, H. Samet, A. Segev, and A. Shoshani. </author> <title> Optimizing Mass Storage Organization and Access for Multi-Dimensional Scientific Data. </title> <booktitle> In Proceedings of the IEEE Symposium on Mass Storage Systems, </booktitle> <address> Mon-terey, CA, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: For example, the climate modeling project at Lawrence Livermore National Laboratory uses a very complex schema and generates single data points in the range of 20 to 150 megabytes; a single data set typically contains 1 to 20 gigabytes of data <ref> [DLP + 93] </ref>. Loading large amounts of data is currently a bottleneck in many OODB applications [CMR92, CMR + 94]. Relational database systems provide a load utility to bypass the individual language statements; OODB need a similar facility. <p> In the range of 40 Gb to 3 terabytes of data is produced in a single simulation history <ref> [DLP + 93] </ref>! An id map for a single data set requires upwards of 200 Mb. In this chapter, we propose a new algorithm, the partitioned-list algorithm, that extends the 2pass-invsort ++ algorithm we recommended in Chapter 3 to handle large data sets.
Reference: [DNB93] <author> David J. DeWitt, Jeffrey F. Naughton, and Joseph Burger. </author> <title> Nested Loops Revisited. </title> <booktitle> In Proceedings of the Symposium on Parallel and Distributed Information Systems, </booktitle> <address> San Diego, CA, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: It is known that nested-loops-with-index is the algorithm of choice when only a small percentage of the inner relation (the existing object collection) participates in the join <ref> [DNB93] </ref>. This is the case both when there are few tuples in the outer relation (few queries) and when there are few distinct tuples in the outer relation (few distinct queries).
Reference: [FBC + 90] <author> D.H. Fishman, D. Beech, H.P. Cate, E. C. Chow, T. Connors, J. W. Davis, N. Derrett, C. G. Hoch, W. Kent, P. Lyngbaek, B. Mahbod, M. A. Neimat, T.A. Ryan, and M. C. Shan. </author> <title> Iris: An Object-Oriented Database Management System. </title> <editor> In S. B. Zdonik and D. Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 216-226. </pages> <address> Morgan-Kaufman, </address> <publisher> Inc., </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: Using query functions has two advantages. First, query optimization is only necessary per query function, rather than per query. Second, use of the query functions allows easy identification of similar queries. We give examples of query functions in Section 5.3; the research OODB systems Iris <ref> [FBC + 90] </ref> and Postgres [RS87] both support query functions, as does Illustra [Ill94]. The main contribution of this chapter is our observation that similar queries can be evaluated together during the load, and that doing so provides huge performance gains.
Reference: [GR93] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan-Kaufman, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1993. </year> <month> 90 </month>
Reference-contexts: Gray and Reuter give a useful overview of ways to reestablish the context of a long-running transaction, such as a load, in order to resume it <ref> [GR93] </ref>. 78 6.3 Restart checkpoints In the worst case, a load is interrupted by a system crash, and the load algorithm does not receive a warning of the impending crash that would allow it to halt in a coherent state. <p> We similarly would like to avoid logging during load. Second, normally, database systems undo the effects of an uncommitted transaction during restart recovery <ref> [GR93] </ref>. We want to resume an uncommitted load. <p> Therefore, the load must continue to hold its resources, e.g., locks, after the commit. Either chained transactions or persistent checkpoints (also called Phoenix transactions) allow a transaction to keep its resources after committing <ref> [GR93] </ref>. Teradata, for example, provides this capability to its parallel relational resumable load [Wit94]. * The load must be resumed. The checkpoint record's existence must be recognized, the resources, e.g., locks, of the load must be regained, and the load process restarted.
Reference: [GW87] <author> R. A. Ganski and H. K. T. Wong. </author> <title> Optimization of Nested SQL Queries Revisited. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 23-33, </pages> <year> 1987. </year>
Reference-contexts: We let the explicit use of query functions solve the recognition problem. Evaluating multiple instances of query functions is also related to evaluating correlated subqueries. The techniques we apply to evaluate multiple queries together are similar to those for decorrelating subqueries <ref> [Kim82, Day87, GW87] </ref>, and attain similar improvements in performance.
Reference: [Ill94] <institution> Illustra Information Technologies, Inc. </institution> <note> Illustra User's Guide, </note> <month> June </month> <year> 1994. </year>
Reference-contexts: For example, objects describing the growth of each plant must be connected to the objects describing the plants. Although the load utilities offered by the object-relational systems Illustra <ref> [Ill94] </ref> and UniSQL [Kim94] solve some of the problems posed by relationships, they are incapable of connecting new objects to existing objects during the load. Instead, those relationships must be created by update 54 statements after the load is complete. <p> We propose using queries as the most natural means of identifying existing objects. For example, it is already possible to use queries to connect objects when creating them with individual insert statements in Illustra <ref> [Ill94] </ref>, although not when creating them during a bulk load. We further suggest using query functions to define similar queries. A query function defines a query where some or all of the query constants are parameters to the function. <p> Second, use of the query functions allows easy identification of similar queries. We give examples of query functions in Section 5.3; the research OODB systems Iris [FBC + 90] and Postgres [RS87] both support query functions, as does Illustra <ref> [Ill94] </ref>. The main contribution of this chapter is our observation that similar queries can be evaluated together during the load, and that doing so provides huge performance gains. We address both how to evaluate the queries, and how to integrate the query evaluation into a load algorithm.
Reference: [Inf94] <institution> Informix Software, Inc. </institution> <note> Informix Guide to SQL, </note> <month> December </month> <year> 1994. </year>
Reference-contexts: We further suggest using query functions to define similar queries. A query function defines a query where some or all of the query constants are parameters to the function. Query functions are common in relational database systems, such as Sybase [Syb92] and Informix <ref> [Inf94] </ref>. Using query functions has two advantages. First, query optimization is only necessary per query function, rather than per query. Second, use of the query functions allows easy identification of similar queries.
Reference: [Kea83] <author> M. Kitsuregawa and et al. </author> <title> Application of Hash to Data Base Machine and its Architecture. </title> <journal> New Generation Computing, </journal> <volume> 1 </volume> <pages> 62-74, </pages> <year> 1983. </year>
Reference-contexts: This performance gap could be narrowed by using a hybrid hash join [DKO + 84] in the partitioned-list algorithm instead of the standard Grace hash join <ref> [Kea83] </ref> to join the id map, todo list, and inverse todo lists.
Reference: [Kim82] <author> W. Kim. </author> <title> On Optimizing an SQL-like Nested Query. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(3) </volume> <pages> 443-469, </pages> <month> September </month> <year> 1982. </year>
Reference-contexts: We let the explicit use of query functions solve the recognition problem. Evaluating multiple instances of query functions is also related to evaluating correlated subqueries. The techniques we apply to evaluate multiple queries together are similar to those for decorrelating subqueries <ref> [Kim82, Day87, GW87] </ref>, and attain similar improvements in performance.
Reference: [Kim94] <author> W. Kim. </author> <title> UniSQL/X Unified Relational and Object-Oriented Database System. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> page 481, </pages> <address> Minneapolis, MN, </address> <year> 1994. </year>
Reference-contexts: Yet in these systems, loading new data can only be accomplished by creating one object at a time. There are also several object-relational database products on the market, such as Il-lustra [Ube94] and UniSQL <ref> [Kim94] </ref>. These systems try to provide better facilities for loading data, but address only some of the challenges posed by object-oriented data. In this thesis, we explore alternative solutions to the problems presented for loading and develop novel algorithms for loading object-oriented and object-relational databases (OODBs) based on them. <p> Ontos, Objectivity, ObjectStore, and Versant all support inverse relationships [Ont94, Obj92, LLOW91, Ver93]. Loading object-relational data involves surmounting the same problems with relationships as loading object-oriented data. While the object-relational systems Illustra [Ube94] and Unisql <ref> [Kim94] </ref> provide a load utility, they only provide (not necessarily optimal) solutions to some of the problems posed by relationships. <p> buffer pool, which happens whether or not the page must first be (expensively) fetched from disk. 4.3.3 Comparing large data set algorithms when there are no inverse rela tionships Although all of the major commercial OODB vendors support inverse relationships, many object-relational databases do not (e.g., Illustra [Ube94] and UniSQL <ref> [Kim94] </ref>) and/or users may choose not to use them. As a final comparison of the algorithms for handling large data sets, we altered the data file to explicitly list all ten relationships from each object and removed the inverse relationships from the schema. <p> For example, objects describing the growth of each plant must be connected to the objects describing the plants. Although the load utilities offered by the object-relational systems Illustra [Ill94] and UniSQL <ref> [Kim94] </ref> solve some of the problems posed by relationships, they are incapable of connecting new objects to existing objects during the load. Instead, those relationships must be created by update 54 statements after the load is complete.
Reference: [LLOW91] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The ObjectStore Database System. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Introduction There has been a recent trend to add object functionality to database systems. The resulting technology has resulted in object-oriented databases, object-relational databases, and even relational databases augmented with objects. There are many commercial object-oriented database products today, including Ontos [Ont94], O2 [Deu90], Objectivity [Obj92], ObjectStore <ref> [LLOW91] </ref>, Versant [Ver93], and Gemstone [MS90]. Yet in these systems, loading new data can only be accomplished by creating one object at a time. There are also several object-relational database products on the market, such as Il-lustra [Ube94] and UniSQL [Kim94]. <p> Inverse relationships are sometimes called bidirectional relationships, and are part of the ODMG standard [Cat93]. Ontos, Objectivity, ObjectStore, and Versant all support inverse relationships <ref> [Ont94, Obj92, LLOW91, Ver93] </ref>. Loading object-relational data involves surmounting the same problems with relationships as loading object-oriented data. While the object-relational systems Illustra [Ube94] and Unisql [Kim94] provide a load utility, they only provide (not necessarily optimal) solutions to some of the problems posed by relationships.
Reference: [Mai94] <author> David Maier, </author> <month> January </month> <year> 1994. </year> <type> Personal communication. </type>
Reference-contexts: This is only possible with logical OIDs, because the OID does not depend on a physical representation of the object. We believe that any OODB that provides logical OIDs can also provide pre-assignment of OIDs; we know it is possible at the buffer manager level in GemStone <ref> [Mai94] </ref> and in Ontos, as well as in Shore. 3.3.3 Creating inverse relationships Whenever we find a relationship from object A to object B that has an inverse, we know we need to store the inverse relationship, i.e., store the OID for A in object B.
Reference: [MHL + 92] <author> C. Mohan, D. Haderle, B. Lindsay, H. Pirahesh, and P. Schwarz. </author> <title> ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(1) </volume> <pages> 94-162, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: Therefore, many commercial relational database systems allow logging to be turned off for loading, e.g., Teradata's NCR 3700 [WCK93], Tandom's NonStop SQL <ref> [MHL + 92] </ref>, Sybase's SQL Server [Syb92], IBM's DB2 [Moh93a]. We similarly would like to avoid logging during load. Second, normally, database systems undo the effects of an uncommitted transaction during restart recovery [GR93]. We want to resume an uncommitted load. <p> If the database server is responsible for resuming the load, then the restart checkpoint record can be placed in the recovery log, where it will be found during restart recovery. The server can then regain resources on behalf of the load and restart it. The Aries recovery algorithm <ref> [MHL + 92] </ref>, for example, contains features that allow the server to perform all three of the above requirements on behalf of a resumable transaction.
Reference: [MN92] <author> C. Mohan and I. Narang. </author> <title> Algorithms for Creating Indexes for Very Large Tables Without Quiescing Updates. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 361-370, </pages> <year> 1992. </year>
Reference-contexts: The system features are actually quite general, and can be used to suport other resumable transactions. 6.2 Related work Teradata provides a resumable load for their relational database [WCK93] as does DB2 [RZ89]. Mohan and Narang provide an algorithm for what to checkpoint for a resumable sort <ref> [MN92] </ref>, which was the original inspiration for what to checkpoint during a load to make it resumable. <p> Sybase, 1 An index built as part of the load should be created in bulk, from the bottom up <ref> [MN92] </ref>, and would be checkpointed in a manner similar to the load objects. 81 for example, can load relational data using this granularity of logging only if there are no indices [Syb92]. * After committing the current state of the load transaction and taking a restart checkpoint, the load needs to
Reference: [MN93] <author> C. Mohan and I. Narang. </author> <title> An Efficient and Flexible Method for Archiving a Data Base. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 139-146, </pages> <year> 1993. </year>
Reference-contexts: One additional step is necessary before pronouncing the load complete. If an archive copy of the database is maintained in case of media failure, a full archive copy of the newly loaded data must be made before the data is read or written <ref> [MN93] </ref>. Otherwise, the data might be lost due to media failure, since there is no log record of the loaded data. This step is necessary for all of the algorithms.
Reference: [Moh93a] <author> C. Mohan. </author> <title> A Survey of DBMS Research Issues in Supporting Very Large Tables. </title> <booktitle> In Proceedings of the International Conference on Foundations of Data Organization and Algorithms, </booktitle> <pages> pages 279-300, </pages> <address> Chicago, Il., 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The load utility can therefore dramatically reduce the amount of client-server interaction, and hence both the layers of software traversed and the communication overhead to create each new object. Additionally, a load utility can group certain operations, such as integrity checks, to dramatically reduce their cost for the load <ref> [Moh93a] </ref>. <p> The data file resided on a separate disk in the file system, and thus did not interfere with the database I/O. For these tests, we turned logging off. It is important to be able to turn off logging when loading a lot of new data <ref> [Moh93a] </ref>; we found that when we used full logging, the log outgrew the database. 8 Chapter 3 Alternative load algorithms 3.1 Introduction As described in Chapter 1, our goal is develop efficient algorithms for loading object databases. <p> Therefore, many commercial relational database systems allow logging to be turned off for loading, e.g., Teradata's NCR 3700 [WCK93], Tandom's NonStop SQL [MHL + 92], Sybase's SQL Server [Syb92], IBM's DB2 <ref> [Moh93a] </ref>. We similarly would like to avoid logging during load. Second, normally, database systems undo the effects of an uncommitted transaction during restart recovery [GR93]. We want to resume an uncommitted load. <p> It is clear from experiences with relational systems that delaying integrity checks until the end of a load and sorting them before applying the checks, similar to the way we delayed and sorted updates to inverse objects, can save time and reduce duplicate checks <ref> [Moh93a] </ref>. Although integrity checks may be significantly more complicated in an object-oriented system, and may require evaluating complex path expressions, it is likely that batching integrity checks and trigger evaluations will also yield significant performance improvements.
Reference: [Moh93b] <author> C. Mohan. </author> <title> IBM's Relational DBMS Products: Features and Technologies. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 445-448, </pages> <year> 1993. </year>
Reference-contexts: A load utility takes an ascii description of all of the data to be loaded and returns when it has loaded it. For relational systems, a load utility significantly improves performance even when loading only a small number of objects, because it is based in the database server <ref> [Moh93b] </ref>. The load utility can therefore dramatically reduce the amount of client-server interaction, and hence both the layers of software traversed and the communication overhead to create each new object. <p> We feel that this is the best place for a load utility; the client-server communication overhead is greatly reduced. The implementors of DB2 experienced significantly better performance when the load utility interacted directly with the buffer manager, instead of as a client <ref> [Moh93b] </ref>. Additionally, the load algorithms have direct access to the server buffer pools and can determine what is in the buffer pool at any given time, which is needed by some of the techniques we explore. Second, Shore provides both physical and logical OIDs.
Reference: [MS90] <author> D. Maier and J. Stein. </author> <title> Development and Implementation of an Object-Oriented DBMS. </title> <editor> In S. B. Zdonik and D. Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 167-185. </pages> <address> Morgan-Kaufman, </address> <publisher> Inc., </publisher> <year> 1990. </year>
Reference-contexts: The resulting technology has resulted in object-oriented databases, object-relational databases, and even relational databases augmented with objects. There are many commercial object-oriented database products today, including Ontos [Ont94], O2 [Deu90], Objectivity [Obj92], ObjectStore [LLOW91], Versant [Ver93], and Gemstone <ref> [MS90] </ref>. Yet in these systems, loading new data can only be accomplished by creating one object at a time. There are also several object-relational database products on the market, such as Il-lustra [Ube94] and UniSQL [Kim94].
Reference: [Nel91] <author> G. Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: We know of no other work that addresses loading for OODBs. There are several published methods for mapping complex data structures to an ASCII or binary file, and then reading it back in again, including Snodgrass's Interface Description Language [Sno89], Pkl <ref> [Nel91] </ref> for Modula3 data, and Vegdahl's method for Smalltalk images [Veg86]. However, these methods do not address the problem of loading more data than can fit into virtual memory, and also ignore the performance issues that arise when the data to be loaded fits in virtual but not physical memory.
Reference: [Obj92] <institution> Objectivity, Inc. Objectivity/DB Documentation, </institution> <address> 2.0 edition, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: Introduction There has been a recent trend to add object functionality to database systems. The resulting technology has resulted in object-oriented databases, object-relational databases, and even relational databases augmented with objects. There are many commercial object-oriented database products today, including Ontos [Ont94], O2 [Deu90], Objectivity <ref> [Obj92] </ref>, ObjectStore [LLOW91], Versant [Ver93], and Gemstone [MS90]. Yet in these systems, loading new data can only be accomplished by creating one object at a time. There are also several object-relational database products on the market, such as Il-lustra [Ube94] and UniSQL [Kim94]. <p> Inverse relationships are sometimes called bidirectional relationships, and are part of the ODMG standard [Cat93]. Ontos, Objectivity, ObjectStore, and Versant all support inverse relationships <ref> [Ont94, Obj92, LLOW91, Ver93] </ref>. Loading object-relational data involves surmounting the same problems with relationships as loading object-oriented data. While the object-relational systems Illustra [Ube94] and Unisql [Kim94] provide a load utility, they only provide (not necessarily optimal) solutions to some of the problems posed by relationships. <p> More specifically, they can create relationships among new objects and they allow 2 Objectivity has something it calls a load utility, however, it can only load data that already contains system-specific OIDs <ref> [Obj92] </ref>. Similarly, Ontos's bulk load facility is really just an option to turn off logging while running user code that creates large amounts of data [Ont94]. 4 forward references in the data file.
Reference: [Ont94] <author> Ontos, Inc. </author> <title> Ontos DB Reference Manual, release 3.0 beta edition, </title> <year> 1994. </year>
Reference-contexts: Introduction There has been a recent trend to add object functionality to database systems. The resulting technology has resulted in object-oriented databases, object-relational databases, and even relational databases augmented with objects. There are many commercial object-oriented database products today, including Ontos <ref> [Ont94] </ref>, O2 [Deu90], Objectivity [Obj92], ObjectStore [LLOW91], Versant [Ver93], and Gemstone [MS90]. Yet in these systems, loading new data can only be accomplished by creating one object at a time. There are also several object-relational database products on the market, such as Il-lustra [Ube94] and UniSQL [Kim94]. <p> Inverse relationships are sometimes called bidirectional relationships, and are part of the ODMG standard [Cat93]. Ontos, Objectivity, ObjectStore, and Versant all support inverse relationships <ref> [Ont94, Obj92, LLOW91, Ver93] </ref>. Loading object-relational data involves surmounting the same problems with relationships as loading object-oriented data. While the object-relational systems Illustra [Ube94] and Unisql [Kim94] provide a load utility, they only provide (not necessarily optimal) solutions to some of the problems posed by relationships. <p> Similarly, Ontos's bulk load facility is really just an option to turn off logging while running user code that creates large amounts of data <ref> [Ont94] </ref>. 4 forward references in the data file. However, neither system provides bidirectional relationships, and neither can connect new objects to objects already in the database during a load. 1.2 Contributions of the thesis This thesis makes several contributions to the development of fast load algorithms.
Reference: [PG88] <author> N. W. Paton and P. M. D. Gray. </author> <title> Identification of Database Objects by Key. </title> <editor> In K. R. Dit-trich, editor, </editor> <booktitle> Advances in Object-Oriented Database Systems: 2nd International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 280-285, </pages> <address> Berlin, Germany, </address> <month> September </month> <year> 1988. </year> <note> Springer-Verlag. 91 </note>
Reference-contexts: In this example, the surrogates are integers, and they are unique in the data file. In general, however, the surrogates may be strings or numbers; if the class has a key they may be part of the object's data <ref> [PG88] </ref>. Wherever one object references another object, the data file entry for the referencing object contains the surrogate for the referenced object.
Reference: [PS88] <author> J. Park and A. Segev. </author> <title> Using common subexpressions to optimize multiple queries. </title> <booktitle> In IEEE Conference on Data Engineering, </booktitle> <pages> pages 311-319, </pages> <year> 1988. </year>
Reference-contexts: Sellis [Sel88] and others <ref> [PS88] </ref> look at how to optimize and evaluate multiple queries. However, they do not consider queries that have the same form but different constants in their predicates, which is exactly the set of queries we would like to optimize together. Furthermore, much of their work focuses on recognizing related queries.
Reference: [RS87] <author> L. A. Rowe and M. Stonebreaker. </author> <title> The POSTGRES Data Model. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <pages> pages 83-96, </pages> <year> 1987. </year>
Reference-contexts: First, query optimization is only necessary per query function, rather than per query. Second, use of the query functions allows easy identification of similar queries. We give examples of query functions in Section 5.3; the research OODB systems Iris [FBC + 90] and Postgres <ref> [RS87] </ref> both support query functions, as does Illustra [Ill94]. The main contribution of this chapter is our observation that similar queries can be evaluated together during the load, and that doing so provides huge performance gains.
Reference: [RZ89] <author> R. Reinsch and M. Zimowski. </author> <title> Method for Restarting a Long-Running, Fault-Tolerant Operation in a Transaction-Oriented Data Base System Without Burdening the System Log. </title> <type> U.S. Patent 4,868,744, </type> <institution> IBM, </institution> <month> September </month> <year> 1989. </year>
Reference-contexts: Second, we survey the features that a system like Shore must provide to support a resumable load. The system features are actually quite general, and can be used to suport other resumable transactions. 6.2 Related work Teradata provides a resumable load for their relational database [WCK93] as does DB2 <ref> [RZ89] </ref>. Mohan and Narang provide an algorithm for what to checkpoint for a resumable sort [MN92], which was the original inspiration for what to checkpoint during a load to make it resumable. <p> The records can either have a user-specified tag, be related to the name of the data file, or hard-coded into the load program. Teradata's users are responsible for resuming the load, but the restart checkpoints are remembered by the system [Ter91]. Both Teradata and DB2 provide stable state changes <ref> [Wit94, RZ89] </ref> to files, which protect them from being read. Some of the above system features are only necessary to protect the user from seeing incorrect or incomplete data. For example, the first created object will contain the OIDs of not yet created objects.
Reference: [Sel88] <author> T.K. Sellis. </author> <title> Multiple Query Optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 23-52, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Sellis <ref> [Sel88] </ref> and others [PS88] look at how to optimize and evaluate multiple queries. However, they do not consider queries that have the same form but different constants in their predicates, which is exactly the set of queries we would like to optimize together.
Reference: [Sho93] <author> A. Shoshani. </author> <title> A Layered Apporach to Scientific Data Management at Lawrence Berkeley Laboratory. </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 16(1) </volume> <pages> 4-8, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Scientific applications generate a large volume of data with many complex associations in the information structure <ref> [Sho93] </ref>. It is not uncommon for a single experiment to have input and output parameters that number in the hundreds and thousands, and must be loaded into the OODB for each experiment.
Reference: [Sno89] <author> R. Snodgrass. </author> <title> The Interface Description Language: Definition and Use. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: We know of no other work that addresses loading for OODBs. There are several published methods for mapping complex data structures to an ASCII or binary file, and then reading it back in again, including Snodgrass's Interface Description Language <ref> [Sno89] </ref>, Pkl [Nel91] for Modula3 data, and Vegdahl's method for Smalltalk images [Veg86].
Reference: [Syb92] <institution> Sybase, Inc. </institution> <note> Command Reference Manual, release 4.9 edition, </note> <year> 1992. </year>
Reference-contexts: We further suggest using query functions to define similar queries. A query function defines a query where some or all of the query constants are parameters to the function. Query functions are common in relational database systems, such as Sybase <ref> [Syb92] </ref> and Informix [Inf94]. Using query functions has two advantages. First, query optimization is only necessary per query function, rather than per query. Second, use of the query functions allows easy identification of similar queries. <p> Therefore, many commercial relational database systems allow logging to be turned off for loading, e.g., Teradata's NCR 3700 [WCK93], Tandom's NonStop SQL [MHL + 92], Sybase's SQL Server <ref> [Syb92] </ref>, IBM's DB2 [Moh93a]. We similarly would like to avoid logging during load. Second, normally, database systems undo the effects of an uncommitted transaction during restart recovery [GR93]. We want to resume an uncommitted load. <p> Sybase, 1 An index built as part of the load should be created in bulk, from the bottom up [MN92], and would be checkpointed in a manner similar to the load objects. 81 for example, can load relational data using this granularity of logging only if there are no indices <ref> [Syb92] </ref>. * After committing the current state of the load transaction and taking a restart checkpoint, the load needs to continue from where it was prior to the checkpoint. Therefore, the load must continue to hold its resources, e.g., locks, after the commit.
Reference: [Ter91] <author> Teradata Corporation. </author> <title> Fast Load User's Guide for Network-Attached Systems, </title> <note> release 4.1.1/4.1.2 edition, </note> <month> October </month> <year> 1991. </year>
Reference-contexts: The records can either have a user-specified tag, be related to the name of the data file, or hard-coded into the load program. Teradata's users are responsible for resuming the load, but the restart checkpoints are remembered by the system <ref> [Ter91] </ref>. Both Teradata and DB2 provide stable state changes [Wit94, RZ89] to files, which protect them from being read. Some of the above system features are only necessary to protect the user from seeing incorrect or incomplete data.
Reference: [Ube94] <author> M. Ubell. </author> <title> The Montage Extensible DataBlade Architecture. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> page 482, </pages> <address> Minneapolis, MN, </address> <year> 1994. </year>
Reference-contexts: Yet in these systems, loading new data can only be accomplished by creating one object at a time. There are also several object-relational database products on the market, such as Il-lustra <ref> [Ube94] </ref> and UniSQL [Kim94]. These systems try to provide better facilities for loading data, but address only some of the challenges posed by object-oriented data. <p> Inverse relationships are sometimes called bidirectional relationships, and are part of the ODMG standard [Cat93]. Ontos, Objectivity, ObjectStore, and Versant all support inverse relationships [Ont94, Obj92, LLOW91, Ver93]. Loading object-relational data involves surmounting the same problems with relationships as loading object-oriented data. While the object-relational systems Illustra <ref> [Ube94] </ref> and Unisql [Kim94] provide a load utility, they only provide (not necessarily optimal) solutions to some of the problems posed by relationships. <p> control inside the buffer pool, which happens whether or not the page must first be (expensively) fetched from disk. 4.3.3 Comparing large data set algorithms when there are no inverse rela tionships Although all of the major commercial OODB vendors support inverse relationships, many object-relational databases do not (e.g., Illustra <ref> [Ube94] </ref> and UniSQL [Kim94]) and/or users may choose not to use them. As a final comparison of the algorithms for handling large data sets, we altered the data file to explicitly list all ten relationships from each object and removed the inverse relationships from the schema.
Reference: [Veg86] <author> S. R. Vegdahl. </author> <title> Moving Structures between Smalltalk Images. </title> <booktitle> In Proceedings of the International Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 466-471, </pages> <year> 1986. </year>
Reference-contexts: There are several published methods for mapping complex data structures to an ASCII or binary file, and then reading it back in again, including Snodgrass's Interface Description Language [Sno89], Pkl [Nel91] for Modula3 data, and Vegdahl's method for Smalltalk images <ref> [Veg86] </ref>. However, these methods do not address the problem of loading more data than can fit into virtual memory, and also ignore the performance issues that arise when the data to be loaded fits in virtual but not physical memory.
Reference: [Ver93] <author> Versant Object Technology. </author> <title> Versant Object Database Management System C++Versant Manual, </title> <note> release 2 edition, </note> <month> July </month> <year> 1993. </year>
Reference-contexts: Introduction There has been a recent trend to add object functionality to database systems. The resulting technology has resulted in object-oriented databases, object-relational databases, and even relational databases augmented with objects. There are many commercial object-oriented database products today, including Ontos [Ont94], O2 [Deu90], Objectivity [Obj92], ObjectStore [LLOW91], Versant <ref> [Ver93] </ref>, and Gemstone [MS90]. Yet in these systems, loading new data can only be accomplished by creating one object at a time. There are also several object-relational database products on the market, such as Il-lustra [Ube94] and UniSQL [Kim94]. <p> Inverse relationships are sometimes called bidirectional relationships, and are part of the ODMG standard [Cat93]. Ontos, Objectivity, ObjectStore, and Versant all support inverse relationships <ref> [Ont94, Obj92, LLOW91, Ver93] </ref>. Loading object-relational data involves surmounting the same problems with relationships as loading object-oriented data. While the object-relational systems Illustra [Ube94] and Unisql [Kim94] provide a load utility, they only provide (not necessarily optimal) solutions to some of the problems posed by relationships.
Reference: [WCK93] <author> A. Witkowski, F. Cari~no, and P. Kostamaa. </author> <title> NCR 3700 | The Next-Generation Industrial Database Computer. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <pages> pages 230-243, </pages> <year> 1993. </year>
Reference-contexts: Second, we survey the features that a system like Shore must provide to support a resumable load. The system features are actually quite general, and can be used to suport other resumable transactions. 6.2 Related work Teradata provides a resumable load for their relational database <ref> [WCK93] </ref> as does DB2 [RZ89]. Mohan and Narang provide an algorithm for what to checkpoint for a resumable sort [MN92], which was the original inspiration for what to checkpoint during a load to make it resumable. <p> Therefore, many commercial relational database systems allow logging to be turned off for loading, e.g., Teradata's NCR 3700 <ref> [WCK93] </ref>, Tandom's NonStop SQL [MHL + 92], Sybase's SQL Server [Syb92], IBM's DB2 [Moh93a]. We similarly would like to avoid logging during load. Second, normally, database systems undo the effects of an uncommitted transaction during restart recovery [GR93]. We want to resume an uncommitted load. <p> Flushing the buffer pool ensures that the state of the load as of the checkpoint can be recovered from disk after a crash. Teradata also flushes all loaded data to disk when taking a resumable load checkpoint <ref> [WCK93] </ref>. For each step of the partitioned-list load algorithm present in Chapter 4, we now summarize the action of the step, describe when a checkpoint is permitted, what to write in the checkpoint record, and how to use the checkpoint record information to resume the load. 1.
Reference: [WI93] <author> J. L. Wiener and Y. Ioannidis. </author> <title> A Moose and a Fox Can Aid Scientists with Data Management Problems. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <pages> pages 376-398, </pages> <address> New York, NY, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We illustrate the data file format in Figure 2. Although we developed it for the Moose data model <ref> [WI93] </ref>, it fits a generic OO data 1 Loading from binary data files would be similar. We chose to use ascii files because they are transferrable across different hardware platforms and are easy for the user to examine. 10 model.
Reference: [Wit94] <author> Andrew Witkowski, </author> <month> October </month> <year> 1994. </year> <type> Personal correspondence. </type>
Reference-contexts: Therefore, the load must continue to hold its resources, e.g., locks, after the commit. Either chained transactions or persistent checkpoints (also called Phoenix transactions) allow a transaction to keep its resources after committing [GR93]. Teradata, for example, provides this capability to its parallel relational resumable load <ref> [Wit94] </ref>. * The load must be resumed. The checkpoint record's existence must be recognized, the resources, e.g., locks, of the load must be regained, and the load process restarted. <p> The records can either have a user-specified tag, be related to the name of the data file, or hard-coded into the load program. Teradata's users are responsible for resuming the load, but the restart checkpoints are remembered by the system [Ter91]. Both Teradata and DB2 provide stable state changes <ref> [Wit94, RZ89] </ref> to files, which protect them from being read. Some of the above system features are only necessary to protect the user from seeing incorrect or incomplete data. For example, the first created object will contain the OIDs of not yet created objects.
Reference: [WN94] <author> J. L. Wiener and J. F. Naughton. </author> <title> Bulk Loading into an OODB: A Performance Study. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <pages> pages 120-131, </pages> <address> Santiago, Chile, 1994. Morgan-Kaufman, </address> <publisher> Inc. </publisher>
Reference-contexts: In this thesis, we explore alternative solutions to the problems presented for loading and develop novel algorithms for loading object-oriented and object-relational databases (OODBs) based on them. Portions of this thesis also appear elsewhere <ref> [WN94, WN95] </ref>. 1.1 Motivation As OODBs attract more and more users, the problem of loading the users' data into the OODB becomes more and more important. The current methods of loading create only one object at a time.
Reference: [WN95] <author> J. L. Wiener and J. F. Naughton. </author> <title> OODB Bulk Loading Revisited: The Partitioned-List Approach. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <address> Zurich, Switzerland, </address> <year> 1995. </year> <institution> Morgan-Kaufman, Inc. </institution> <note> To appear. </note>
Reference-contexts: In this thesis, we explore alternative solutions to the problems presented for loading and develop novel algorithms for loading object-oriented and object-relational databases (OODBs) based on them. Portions of this thesis also appear elsewhere <ref> [WN94, WN95] </ref>. 1.1 Motivation As OODBs attract more and more users, the problem of loading the users' data into the OODB becomes more and more important. The current methods of loading create only one object at a time.
References-found: 47

