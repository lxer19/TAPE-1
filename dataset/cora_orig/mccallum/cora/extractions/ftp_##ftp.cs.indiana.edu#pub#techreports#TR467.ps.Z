URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR467.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Email: keahey@cs.indiana.edu  
Title: A Model of Interaction for Parallel Objects in A Heterogeneous Distributed Environment  
Author: Katarzyna Keahey 
Date: September 23, 1996  
Address: 215 Lindley Hall Bloomington, IN 47401  
Affiliation: Indiana University  
Abstract: This paper describes a model of interaction developed as a part of an environment which enables heterogeneous parallel objects to interoperate in a distributed domain. It describes the interactive needs of parallel objects in such an environment and proposes a solution which would satisfy them within the object model as used by CORBA. The model of interaction has been prototyped in PARDIS, a PARallel DIStributed environment based on the CORBA design principles. PARDIS is built on top of the Nexus run-time system and has been used to demonstrate how the model of interaction can be used in scenarios involving parallel objects implemented using the POOMA framework. 
Abstract-found: 1
Intro-found: 1
Reference: [BG96] <author> P. Beckman and D. Gannon, </author> <title> Tulip:a portable run-time system for object-parallel systems, </title> <booktitle> 10th International Parallel Processing Symposium, </booktitle> <month> April </month> <year> 1996, </year> <pages> pp. 532-536. </pages>
Reference-contexts: Requests for remote execution, employed by many run-time systems <ref> [vEGS92, FKOT94, BG96] </ref> are a low-level form of a priority request. Including them in the object model is a natural consequence of extending the design domain to heterogeneous architectures and programming styles. Likewise, registered request have their counterpart in channels (see [OMG95a]). <p> Further, the impact of different run-time system designs needs to be considered. To date, two general designs were considered: message-passing based systems (such as MPI or PVM [GLS94, GBD + 94]) and remote execution requests (RER) based systems <ref> [vEGS92, FKOT94, BG96] </ref>. 4.2 Futures In order to enable the client to compute while waiting for results from requests processed by remote servers, PARDIS allows non-blocking invocations. <p> The other is how to notify all processes of the data-parallel object of this interruption. At least three techniques have been used in parallel processing to deal with the first problem: a system interrupt, threads, and polling <ref> [vEGS92, FKOT94, BG96] </ref>. Of these three only the first two provide truly asynchronous modes of interaction and a practical solution for implementing the enable/disable pair; polling demands and offers a high degree of control on priority processing at the expense of response time. <p> Preliminary enquiry into efficiency-flexibility tradeoffs between the implementation of process priority requests in message-passing based and RER based systems confirmed the expectation of higher efficiency in the message-passing systems. Similar problems were investigated in <ref> [BG96] </ref>.
Reference: [CCK92] <author> P. Carlin, M. Chandy, and C. Kesselman, </author> <title> The Compositional C++ Language Definition, </title> <type> Tech. Report CS-TR-92-02, </type> <institution> CalTech, </institution> <year> 1992. </year>
Reference-contexts: This work is a part of an effort aimed at designing an environment which would enable parallel objects implemented according to different programming paradigms (such as : pC++, POOMA, CC++, ABC++ <ref> [GBB + 93, RHea96, CCK92, OEPW96] </ref> etc.) to interact in a distributed domain. This design relies on the idea of interoperability through a common object architecture model introduced by the Common Object Request Broker Architecture (CORBA) [OMG95b] from the Object Management Group (OMG).
Reference: [FKOT94] <author> Ian Foster, Carl Kesselman, Robert Olson, and Steven Tuecke, </author> <title> Nexus: An Interoperability Layer for Parallel and Distributed Computer Systems, </title> <note> Technical Memorandum ANL/MCS-TM-189 (1994). </note>
Reference-contexts: The current, initial implementation of PARDIS is built on top of the Nexus <ref> [FKOT94] </ref> run-time system. The work on the implementation of PARDIS is currently in progress. Although the main focus of this paper is to describe the rationale and design of the model of interaction, it also provides an illustration of how this model can be implemented and used with parallel servers. <p> Requests for remote execution, employed by many run-time systems <ref> [vEGS92, FKOT94, BG96] </ref> are a low-level form of a priority request. Including them in the object model is a natural consequence of extending the design domain to heterogeneous architectures and programming styles. Likewise, registered request have their counterpart in channels (see [OMG95a]). <p> The present implementation supports the basic CORBA interactive scenario, that is interoperability between non-distributed clients and servers, as well as data-parallel servers, and incorporates the extensions to the client-server model of interaction described in this paper. The present implementation of PARDIS is layered on top of the Nexus <ref> [FKOT94] </ref> run-time system. PARDIS supports interaction of objects running on widely distributed heterogeneous architectures, as well as activation of remote objects registered with PARDIS database. <p> Further, the impact of different run-time system designs needs to be considered. To date, two general designs were considered: message-passing based systems (such as MPI or PVM [GLS94, GBD + 94]) and remote execution requests (RER) based systems <ref> [vEGS92, FKOT94, BG96] </ref>. 4.2 Futures In order to enable the client to compute while waiting for results from requests processed by remote servers, PARDIS allows non-blocking invocations. <p> The other is how to notify all processes of the data-parallel object of this interruption. At least three techniques have been used in parallel processing to deal with the first problem: a system interrupt, threads, and polling <ref> [vEGS92, FKOT94, BG96] </ref>. Of these three only the first two provide truly asynchronous modes of interaction and a practical solution for implementing the enable/disable pair; polling demands and offers a high degree of control on priority processing at the expense of response time.
Reference: [GBB + 93] <author> D. Gannon, F. Bodin, P. Beckman, S. Yang, and S. Narayana, </author> <title> Distributed pC++: Basic ideas for an object parallel language, </title> <journal> Journal of Scientific Programming 2 (1993), </journal> <pages> 7-22. </pages>
Reference-contexts: This work is a part of an effort aimed at designing an environment which would enable parallel objects implemented according to different programming paradigms (such as : pC++, POOMA, CC++, ABC++ <ref> [GBB + 93, RHea96, CCK92, OEPW96] </ref> etc.) to interact in a distributed domain. This design relies on the idea of interoperability through a common object architecture model introduced by the Common Object Request Broker Architecture (CORBA) [OMG95b] from the Object Management Group (OMG).
Reference: [GBD + 94] <author> A. Geist, A. Beguelin, J. Dongarra, W. Jiang, R. Manchek, and V. Sunderam, </author> <title> PVM: Parallel virtual machine. A users' guide and tutorial for networked parallel computing, </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Further, the impact of different run-time system designs needs to be considered. To date, two general designs were considered: message-passing based systems (such as MPI or PVM <ref> [GLS94, GBD + 94] </ref>) and remote execution requests (RER) based systems [vEGS92, FKOT94, BG96]. 4.2 Futures In order to enable the client to compute while waiting for results from requests processed by remote servers, PARDIS allows non-blocking invocations.
Reference: [GK96] <author> Dennis Gannon and Katarzyna Keahey, </author> <title> Distributed parallel environment | a sketch, </title> <booktitle> POOMA '96 Abstracts, </booktitle> <month> February </month> <year> 1996. </year>
Reference-contexts: The idea of using an object model as a common denominator between different programming paradigms is a very useful one, and has been adopted as the central concept of our design. Research is currently underway on how to best adapt it to the needs of parallel processing <ref> [GK96] </ref>. However, the client-server model of interaction is too restrictive to fulfill the needs of parallel processing.
Reference: [GLS94] <author> William Gropp, Ewing Lusk, and Anthony Skjellum, </author> <title> Using MPI. Portable parallel programming with the message-passing interface, </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Further, the impact of different run-time system designs needs to be considered. To date, two general designs were considered: message-passing based systems (such as MPI or PVM <ref> [GLS94, GBD + 94] </ref>) and remote execution requests (RER) based systems [vEGS92, FKOT94, BG96]. 4.2 Futures In order to enable the client to compute while waiting for results from requests processed by remote servers, PARDIS allows non-blocking invocations.
Reference: [Gri93] <author> Andrew S. Grimshaw, </author> <title> The Mentat Computation Model Data-Driven Support for Object-Oriented Parallel Processing, </title> <type> Tech. Report CS-93-30, </type> <institution> University of Virginia, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: After return result has been used, no modifications of the returned result will appear on the client's side. Note that all the results produced by a request can be returned before the processing associated with this request is finished. This feature makes this mechanism similar to rtf in Mentat <ref> [Gri93] </ref>. 4.3 Priority Requests 4.3.1 Syntax and Semantics The declaration of a priority request in IDL is marked by a priority attribute.
Reference: [Hal85] <author> Robert H. Halstead, </author> <title> Multilisp: A Language for Concurrent Symbolic Computation, </title> <journal> ACM Transactions on Programming Languages and Systems 7 (1985), </journal> <volume> no. 4, </volume> <pages> 501-538. </pages>
Reference-contexts: Futures were first introduced in Multilisp <ref> [Hal85] </ref> to identify the results of computation which were still in progress, and they were recently revived in ABC++ [OEPW96]. ABC++ defines an excellent representation of futures in C++, which has been adopted in PARDIS.
Reference: [JP94] <author> C. R. Johnson and S. G. Parker, </author> <title> A computational steering model applied to problems in medicine, </title> <booktitle> Supercomputing '94, </booktitle> <year> 1994, </year> <pages> pp. 540-549. </pages>
Reference-contexts: Also, the requirements of modern problem-solving environments incorporating interactive and visualization components call for providing facilities for computational steering <ref> [JP94] </ref>. Based on these considerations, the following requirements for a model of parallel object interaction were formulated: 1. Mechanisms should be provided that will enable the client to compute while waiting for results 3 values of its neighbors.
Reference: [NBB + 96] <author> Michal L. Norman, Peter Beckman, Greg L. Bryan, John Dubinski, Dennis Gannon, Lars Hernquist, Kate Keahey, Jeremiah P. Ostriker, John Shalf, Joel Welling, and Shelby Yang, </author> <title> Galaxies Collide on the I-WAY: An Example of Heterogenous Wide-Area Collaborative Supercomputing, </title> <note> accpted for publication by The International Journal of Supercomputer Applications (1996). 12 </note>
Reference-contexts: Many parallel computations (especially data-parallel computations <ref> [NBB + 96, RHea96] </ref>) generate output not only at the end, but also during computation. These partial results can represent for example scientific data describing the evolution of a system or visualization data. <p> In large distributed scenarios it may be convenient to make the partial output of parallel objects persistent and subsequently use it to simulate those objects for purposed of debugging and demonstration <ref> [NBB + 96] </ref>. Also, the requirements of modern problem-solving environments incorporating interactive and visualization components call for providing facilities for computational steering [JP94]. Based on these considerations, the following requirements for a model of parallel object interaction were formulated: 1. <p> Also, if the demand-driven approach were adopted, the client might have to synchronize with the server to ensure that the partial results it needs are still available, and thus potentially slow down the server <ref> [NBB + 96] </ref>. On the other hand, data-driven approach requires buffering and by design provides communication in one direction only 1 .
Reference: [OEPW96] <author> W.G. O'Farrell, F. Ch. Eigler, S. D. Pullara, and G. V. Wilson, </author> <title> Parallel Programming Using C++, ch. ABC++, </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: This work is a part of an effort aimed at designing an environment which would enable parallel objects implemented according to different programming paradigms (such as : pC++, POOMA, CC++, ABC++ <ref> [GBB + 93, RHea96, CCK92, OEPW96] </ref> etc.) to interact in a distributed domain. This design relies on the idea of interoperability through a common object architecture model introduced by the Common Object Request Broker Architecture (CORBA) [OMG95b] from the Object Management Group (OMG). <p> Futures were first introduced in Multilisp [Hal85] to identify the results of computation which were still in progress, and they were recently revived in ABC++ <ref> [OEPW96] </ref>. ABC++ defines an excellent representation of futures in C++, which has been adopted in PARDIS.
Reference: [OMG95a] <author> OMG, CORBAservices: </author> <title> Common Object Services Specification. , OMG Document, </title> <month> March </month> <year> 1995. </year>
Reference-contexts: Including them in the object model is a natural consequence of extending the design domain to heterogeneous architectures and programming styles. Likewise, registered request have their counterpart in channels (see <ref> [OMG95a] </ref>).
Reference: [OMG95b] <author> OMG, </author> <title> The Common Object Request Broker: Architecture and Specification. Revision 2.0, OMG Document, </title> <month> June </month> <year> 1995. </year>
Reference-contexts: This design relies on the idea of interoperability through a common object architecture model introduced by the Common Object Request Broker Architecture (CORBA) <ref> [OMG95b] </ref> from the Object Management Group (OMG). In CORBA the client-server relationship which arises from the object model is carried out in the client-server model of interaction; in parallel processing this model of interaction is too restrictive. <p> Stubs and skeletons for non-parallel objects have been adapted based on the C++ mapping through inheritance <ref> [OMG95b] </ref>. In the mapping for data-parallel objects, SPMD model of execution was assumed. In this case it was necessary to convey the information about invocation, as well as its arguments, to all processes of the parallel computation.
Reference: [RHea96] <author> J. V. W. Reynders, P. J. Hinker, and J. C. Cummings et al., </author> <title> Parallel Programming Using C++, </title> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: This work is a part of an effort aimed at designing an environment which would enable parallel objects implemented according to different programming paradigms (such as : pC++, POOMA, CC++, ABC++ <ref> [GBB + 93, RHea96, CCK92, OEPW96] </ref> etc.) to interact in a distributed domain. This design relies on the idea of interoperability through a common object architecture model introduced by the Common Object Request Broker Architecture (CORBA) [OMG95b] from the Object Management Group (OMG). <p> The presented example scenario shows interaction of a parallel object implemented in the POOMA framework <ref> [RHea96] </ref> with non-parallel objects running on remote and heterogeneous platforms. 2 Motivation and Design Guidelines The design of CORBA is based on two concepts: the OMG object model and client-server interaction. <p> Many parallel computations (especially data-parallel computations <ref> [NBB + 96, RHea96] </ref>) generate output not only at the end, but also during computation. These partial results can represent for example scientific data describing the evolution of a system or visualization data. <p> PARDIS supports interaction of objects running on widely distributed heterogeneous architectures, as well as activation of remote objects registered with PARDIS database. So far, PARDIS has been tested with objects written in C++; interoperability with data-parallel servers has been tested in simulations with POOMA <ref> [RHea96] </ref> applications. 4.1 Mapping to the Object Model The current implementation is based on the OMG object model with extensions reflecting changes to the model of interaction. Stubs and skeletons for non-parallel objects have been adapted based on the C++ mapping through inheritance [OMG95b].
Reference: [vEGS92] <author> T. von Eicken, D. Culler S. Goldstein, and K. Schauser, </author> <title> Active messages: a mechanism for integrated communication and computation, </title> <type> Tech. Report UCB/CSD 92/#675, </type> <institution> University of California, Berkeley, </institution> <month> March </month> <year> 1992. </year> <month> 13 </month>
Reference-contexts: Requests for remote execution, employed by many run-time systems <ref> [vEGS92, FKOT94, BG96] </ref> are a low-level form of a priority request. Including them in the object model is a natural consequence of extending the design domain to heterogeneous architectures and programming styles. Likewise, registered request have their counterpart in channels (see [OMG95a]). <p> Further, the impact of different run-time system designs needs to be considered. To date, two general designs were considered: message-passing based systems (such as MPI or PVM [GLS94, GBD + 94]) and remote execution requests (RER) based systems <ref> [vEGS92, FKOT94, BG96] </ref>. 4.2 Futures In order to enable the client to compute while waiting for results from requests processed by remote servers, PARDIS allows non-blocking invocations. <p> The other is how to notify all processes of the data-parallel object of this interruption. At least three techniques have been used in parallel processing to deal with the first problem: a system interrupt, threads, and polling <ref> [vEGS92, FKOT94, BG96] </ref>. Of these three only the first two provide truly asynchronous modes of interaction and a practical solution for implementing the enable/disable pair; polling demands and offers a high degree of control on priority processing at the expense of response time.
References-found: 16

