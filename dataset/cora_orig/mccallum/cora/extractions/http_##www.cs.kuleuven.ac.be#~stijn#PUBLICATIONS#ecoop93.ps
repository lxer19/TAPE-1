URL: http://www.cs.kuleuven.ac.be/~stijn/PUBLICATIONS/ecoop93.ps
Refering-URL: http://www.cs.kuleuven.ac.be/~henk/DPS/publications.html
Root-URL: 
Title: A Reflective Invocation Scheme to Realise Advanced Object Management  
Author: Stijn Bijnens, Wouter Joosen and Pierre Verbaeten 
Address: Celestijnenlaan 200A B-3001 Leuven Belgium  
Affiliation: Department of Computer Science  
Abstract: The integration of the notion of distribution in an object-oriented language not only introduces a need for location independent object invocation but also has to cope with various object management operations. These meta-operations include object migration, object replication and granularity control. Additionally, in a multithreaded environment, the concurrency control specifications defined on an object by the application programmer must be realised correctly. Our object invocation scheme offers mechanisms for realising these management operations and concurrency control transparently. This scheme -based on reference objects- is generic in the sense that it can be extented to realise some additional object management operations currently not supported by our prototype. This prototype is realised in a C++ environment on various distributed memory platforms.
Abstract-found: 1
Intro-found: 1
Reference: [Agh] <author> G. Agha. </author> <title> ACTORS: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> The MIT Press series in artificial intelligence. </publisher>
Reference-contexts: For example, location transparency is achieved by applying the inheritance relationship to define the LocalReference and RemoteReference classes (Figure 3). 4 Inspired by the Actor model <ref> [Agh] </ref> Fig. 3. Reference Class Hierarchy These are both specialisations of the Reference class, with a different implementation of the operations. Remote references are objects that cause the use of OS kernel communication software to use the physical network.
Reference: [AWB + 93] <author> M. Askit, K. Wakita, J. Bosch, L. Bergmans, and A. Yonezawa. </author> <title> Abstracting Object Interactions Using Composition Filters. </title> <booktitle> In Proceedings of the ECOOP'93 Workshop on Object BasedDistributed Programming, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: Encapsulators [Pas86] are an extension of Smalltalk-80 to perform a pre-action and a post-action upon an invocation. This concept is extented by [GGM93] to incorporate distribution and replication. Composition filters, another mechanism for message reification, is proposed in <ref> [AWB + 93] </ref>. In this approach, the basic object model is extented by introducing input and output composition filters that effect the received and sent invocations respectively. Meta-level (or reflective) techniques have been applied in various domains and they are still an active area of research.
Reference: [BGJ + 92] <author> David L. Black, David B. Golub, Daniel P. Julin, Richard F. Rashid, Richard P. Draves, Randall W. Dean, Allessandro Forin, Joseph Barrera, Hideyuki Tokuda, Gerald Malan, and David Bohman. </author> <title> Microkernel Operating system Architecture and Mach. </title> <booktitle> In Proceedings of the Usenix Workshop on Micro-kernels and Other Architectures, </booktitle> <pages> pages 11-30. </pages> <publisher> USENIX association, </publisher> <month> April </month> <year> 1992. </year>
Reference-contexts: Different kinds of group invocation protocols exist [BSS91]. These different protocols can be integrated within our framework by specialising the GroupReference class into different subclasses, each implementing a particular protocol (e.g reliable multicast, atomic multicast,...). 5 Almost all micro-kernels offer a port based communication abstraction <ref> [BGJ + 92, RAA + 92] </ref>. Fig. 5. Before and After migration of object B In conclusion, one particular invocation can be forwarded by a chain of reference objects. <p> Only those invocations for which the concurrency control specifications are satisfied will be triggered. 8 Current Status Currently, the prototype is implemented on: A cluster of DEC Alpha workstations on top of the Mach Microkernel <ref> [BGJ + 92] </ref> (in an OSF/1 environment). Mach Kernel threads are used to realise active objects and asynchronous object invocation. Network communication hap pens via the NetMsgServer (user space). ATransputer system running helios. Both threads and network communica tion are realised within this port-based micro-kernel. A SUN4 cluster running SUNOS.
Reference: [BJMV91] <author> Y. Berbers, W. Joosen, H. Moons, and P. Verbaeten. </author> <title> The XENOOPS Project. </title> <booktitle> In Proceedings of the 1991 International Workshop on Object-Orientation in Operating Systems, </booktitle> <pages> pages 144-146, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: 1 Introduction This paper is a result of ongoing work in the XENOOPS project <ref> [BJMV91] </ref>. XENOOPS is an acronym for an `eXecution ENvironment for Object-Oriented Parallel Software'. It is both a language and a system in the sense that it supports a uniform object model for developing applications on a distributed memory platform.
Reference: [BJP + 93] <author> Stijn Bijnens, Wouter Joosen, Jan Pollet, Yolande Berbers, and Pierre Verbaeten. </author> <title> Active Objects, Message Passing and Concurrency Control in XENOOPS. </title> <booktitle> In Proceedings of the TOOLS EUROPE'93 Workshop on Distributed Objects and Concurrency, </booktitle> <month> March </month> <year> 1993. </year>
Reference-contexts: A C++ language extension is introduced for the realisation of asynchronous invocation (overloading of invocation operator) and for concurrency control specifications <ref> [BJP + 93] </ref>. This paper will only focus on the realisation of the concurrency control and not on the formalism for specifying the concurrency control 2 .
Reference: [BJV94] <author> Stijn Bijnens, Wouter Joosen, and Pierre Verbaeten. </author> <title> Observation of a Global Object Space on a Distributed Memory Machine. </title> <booktitle> In Proceedings of 27th Hawaii International Confererence on System Science. </booktitle> <institution> IEEE, </institution> <note> to be published, </note> <month> January </month> <year> 1994. </year>
Reference-contexts: The performance evaluation of a parallel iterative Red/Black SOR (successive over-relaxation) solver with adaptive local grid refinement on top of the XENOOPS prototype has shown its applicability. Performance results are reported in <ref> [BJV94] </ref>. 9 Related Work Object-oriented approaches are applied to a variety of application domains in the computer science area. Although object-orientation has been identified as the most promising structuring paradigm for operating systems, little work has been done on execution environments in parallel computing systems.
Reference: [Boo91] <author> Grady Booch. </author> <title> Object-Oriented Design with Applications. </title> <address> Ben-jamin/Cummings, </address> <year> 1991. </year>
Reference-contexts: This paper is structured as follows. First we will describe the application programming interface. In section three, we will introduce the advanced object 1 Data abstraction, encapsulation, modularity and hierarchy are considered to be the major elements of the object model <ref> [Boo91] </ref> while distribution and concurrency are not essential for the object-oriented approach. management operations currently supported by the environment and used by the load balancing and fault tolerance facility. Section four will describe the concepts behind our object invocation scheme.
Reference: [BSS91] <author> Kenneth Birman, Andre Schiper, and Pat Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Delegated invocations towards the member objects are again reified by reference objects. These reference objects can be of any type (RemoteReference, LocalReference,...). Thus, group invocation and remote invocation are two orthogonal concepts. Different kinds of group invocation protocols exist <ref> [BSS91] </ref>. These different protocols can be integrated within our framework by specialising the GroupReference class into different subclasses, each implementing a particular protocol (e.g reliable multicast, atomic multicast,...). 5 Almost all micro-kernels offer a port based communication abstraction [BGJ + 92, RAA + 92]. Fig. 5.
Reference: [CJR87] <author> R. Campbell, G. Johnston, and V. Russo. </author> <title> Choices (Class Hierarchical Open Interface for Custom Embedded Systems). </title> <journal> ACM Operating Systems Review, </journal> <volume> 21 </volume> <pages> 9-17, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: A fragment acts as a proxy, i.e., a local interface to the FO. A proxy is a local representation of a remote object or server. SOS implements generic mechanisms for object management, such as migration, identification, location, storage, naming, and communication. Choices <ref> [CJR87] </ref> is a family of operating systems; it embodies the notion of a customised operating system that is tailored for particular hardware configurations and for particular applications. Choices views all entities in a system as objects that belong to a class hierarchy.
Reference: [GGM93] <author> B. Garbinato, R. Guerraoui, and K. Mazouni. </author> <title> Distributed Programming Using Two Orthogonal Object Levels. </title> <booktitle> In Proceedings of the ECOOP'93 Workshop on Object BasedDistributed Programming, </booktitle> <month> July </month> <year> 1993. </year>
Reference-contexts: The transparent interception of object invocations by the run-time environment has been reported in several research papers. Encapsulators [Pas86] are an extension of Smalltalk-80 to perform a pre-action and a post-action upon an invocation. This concept is extented by <ref> [GGM93] </ref> to incorporate distribution and replication. Composition filters, another mechanism for message reification, is proposed in [AWB + 93]. In this approach, the basic object model is extented by introducing input and output composition filters that effect the received and sent invocations respectively.
Reference: [GKB91] <author> J. des Rivieres G. Kiczales and D. G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: In this approach, the basic object model is extented by introducing input and output composition filters that effect the received and sent invocations respectively. Meta-level (or reflective) techniques have been applied in various domains and they are still an active area of research. In CLOS MOP <ref> [GKB91] </ref> a meta-level technique is applied to a practical language: all specifications are modifiable. Another reflective language system is ABCL/R2. This language applies a meta-level technique to parallel computations. 10 Conclusion An efficient and reliable global object space is realised by an advanced object invocation system.
Reference: [HMA90] <author> Sabine Habert, Laurence Mosseri, and Vadim Abrossimov. </author> <title> COOL: Kernel support for object-oriented environments. </title> <journal> SIGPLAN Notices, </journal> (25):269-277, 1990. 
Reference-contexts: Emerald objects can move at any time, even while invocations are executing inside them. Emerald can be considered as one of the most advanced object-oriented distributed system since it offers advanced object management support within a uniform object model. COOL <ref> [HMA90] </ref> (the Chorus Object-Oriented Layer) uses the distributed virtual memory system in Chorus. COOL enables objects to be migrated between two machines. Although coupled with remote invocation, object migration is carried out by mapping and unmapping virtual memory segments on different machines.
Reference: [JBV93a] <author> Wouter Joosen, Stijn Bijnens, and Pierre Verbaeten. </author> <title> Reusable Load Balancing Software for Distributed Memory Applications. </title> <type> Technical report, </type> <institution> Department of Computer Science, KULEUVEN, </institution> <month> January </month> <year> 1993. </year>
Reference-contexts: The basic goal of the XENOOPS project is to develop an object-oriented environment which offers automatic support for load balancing and fault tolerance by means of reusable class libraries which incorporate different strategies <ref> [JBV93a, JBV93b] </ref>. Although XENOOPS focuses on parallel applications, the issues described in this paper are related to distribution and are applicable to distributed applications in the broad sense. <p> An application can be developed without knowing of the existence of these system facilities. Then, the application can be plugged into the framework (Figure 1). The system offers a hierarchy of load balancing and fault tolerance policies <ref> [JBV93a, JBV93b] </ref>. These policies can be specialised by the advanced system programmer. The realisation of these policies is based on the availability of some advanced object management operations. Basically, object migration offers the opportunity to transfer objects between address spaces at run time in case of a work imbalance.
Reference: [JBV93b] <author> Wouter Joosen, Stijn Bijnens, and Pierre Verbaeten. </author> <title> Reusable Load Balancing Software for Parallel Search Problems. </title> <journal> The Euromicro Journal, </journal> <volume> 38 </volume> <pages> 205-212, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: The basic goal of the XENOOPS project is to develop an object-oriented environment which offers automatic support for load balancing and fault tolerance by means of reusable class libraries which incorporate different strategies <ref> [JBV93a, JBV93b] </ref>. Although XENOOPS focuses on parallel applications, the issues described in this paper are related to distribution and are applicable to distributed applications in the broad sense. <p> An application can be developed without knowing of the existence of these system facilities. Then, the application can be plugged into the framework (Figure 1). The system offers a hierarchy of load balancing and fault tolerance policies <ref> [JBV93a, JBV93b] </ref>. These policies can be specialised by the advanced system programmer. The realisation of these policies is based on the availability of some advanced object management operations. Basically, object migration offers the opportunity to transfer objects between address spaces at run time in case of a work imbalance.
Reference: [Mae87] <author> P. Maes. </author> <title> Computational Reflection. </title> <type> Technical Report TR-87-2, </type> <institution> Vrije Uni-versiteit Brussel, </institution> <year> 1987. </year>
Reference-contexts: In fact, they behave like real meta-objects as defined by <ref> [Mae87] </ref>. There exists a causal relationship between these reference objects and the application object they represent. This relationship enables the possibility that a reference object can observe and manipulate the internal state of the application objects. This way we can transparently realise the concurrency control specifications very easily and efficiently.
Reference: [MR88] <author> E. Maehle and J. Rost. </author> <title> Implementation of a parallel branch-and-bound algorithm for the travelling salesman problem. </title> <booktitle> In CONPAR 88. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1988. </year>
Reference-contexts: A SUN4 cluster running SUNOS. Active object are realised with user-space threads, network communication happens via UDP-ports. Applications prototyped within our project are in the area of computational fluid dynamics, molecular dynamics simulation and exhaustive search problems, like the Traveling Salesman Problem <ref> [MR88] </ref> and parallel chess. The performance evaluation of a parallel iterative Red/Black SOR (successive over-relaxation) solver with adaptive local grid refinement on top of the XENOOPS prototype has shown its applicability.
Reference: [MY91] <author> Satochi Matsuoka and Akinori Yonezawa. </author> <title> Analysis of the Inheritance Anomaly in Object-Oriented Concurrent Programming. </title> <type> Technical report, </type> <institution> Dept. of Information Science, University of Tokyo, </institution> <year> 1991. </year>
Reference-contexts: This paper will only focus on the realisation of the concurrency control and not on the formalism for specifying the concurrency control 2 . The ideal formalism has still got to be discovered due to the inheritance anomaly; this issue has been described extensively in <ref> [MY91] </ref>. 3 Advanced Object Management Our system offers automatic support for load balancing and fault tolerance. An application can be developed without knowing of the existence of these system facilities. Then, the application can be plugged into the framework (Figure 1).
Reference: [Pas86] <author> Geoffrey Pascoe. Encapsulators: </author> <title> A New Software Paradigm in Smalltalk-80. </title> <booktitle> In Proceedings of OOPSLA'86, </booktitle> <pages> pages 341-346. </pages> <publisher> ACM, </publisher> <month> September </month> <year> 1986. </year>
Reference-contexts: In our opinion a LocalReference object is not inefficient; the indirection introduced by the LocalReference is needed anyway to realise the concurrency control specification. The transparent interception of object invocations by the run-time environment has been reported in several research papers. Encapsulators <ref> [Pas86] </ref> are an extension of Smalltalk-80 to perform a pre-action and a post-action upon an invocation. This concept is extented by [GGM93] to incorporate distribution and replication. Composition filters, another mechanism for message reification, is proposed in [AWB + 93].
Reference: [RAA + 92] <author> M. Rozier, V. Abbrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrman, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> Overview of the Chorus Distributed Operating System. </title> <booktitle> In Proceedings of the Usenix Workshop on Micro-kernels and Other Architectures, </booktitle> <pages> pages 39-69. </pages> <publisher> USENIX association, </publisher> <month> April </month> <year> 1992. </year>
Reference-contexts: Different kinds of group invocation protocols exist [BSS91]. These different protocols can be integrated within our framework by specialising the GroupReference class into different subclasses, each implementing a particular protocol (e.g reliable multicast, atomic multicast,...). 5 Almost all micro-kernels offer a port based communication abstraction <ref> [BGJ + 92, RAA + 92] </ref>. Fig. 5. Before and After migration of object B In conclusion, one particular invocation can be forwarded by a chain of reference objects.
Reference: [RTL91] <author> Rajendra K. Ray, Ewan Tempero, and Henry M. Levy. </author> <title> Emerald: A General-Purpose Programming Language. </title> <journal> Software: Practice and Experience, </journal> <volume> 21(1) </volume> <pages> 91-92, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: A method invocation on a proxy results in a corresponding method invocation on the object it represents. Choices object management functionality is rather conventional; there exists no support for object migration within the kernel. Emerald <ref> [RTL91] </ref> is a programming language as well as a run-time system that supports location-independent operations on objects. The Emerald compiler transforms the user-defined object representation: its first few bytes are a standard descriptor. Conceptually, all objects live in a single, network-wide address space.
Reference: [SGH + 89] <author> Marc Shapiro, Yvon Gourhant, Sabine Habert, Laurence Mosseri, Michel Ruffin, and Celine Valot. </author> <title> SOS: An Object-Oriented Operating System - Assessment and Perspectives. </title> <journal> Computing Systems, </journal> <volume> 2(2) </volume> <pages> 287-337, </pages> <month> Fall </month> <year> 1989. </year>
Reference-contexts: This paragraph presents a survey of object-orientation in operating systems; we will emphasise object invocation and the offered object management functions (e.g. migration). - SOS <ref> [SGH + 89] </ref> is an object-oriented operating system. The system implements object migration; this mechanism is generic, but can be tailored to specific object semantics thanks to the prerequisite and upcall concepts. SOS supports Fragmented Objects (FOs).
Reference: [SMV + 90] <author> S.Krakowiak, M.Meysembourg, H.Nguyen Van, M.Riveill, C.Roison, and X. Rousset de Pina. </author> <title> Design and Implementation of an Object-Oriented, Strongly Typed Language for Distributed Applications. </title> <booktitle> JOOP, </booktitle> <pages> pages 11-21, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Basically, object migration offers the opportunity to transfer objects between address spaces at run time in case of a work imbalance. In addition, another object management function -granularity control- is provided. Granularity control involves the splitting and joining of 2 At the moment, Xenoops uses synchronisation counters <ref> [SMV + 90] </ref> but we're looking at some alternatives. Fig. 1. Overview objects that represent a particular amount of work 3 and can be used as a mechanism -in cooperation with object migration- for re-establishing the ideal work load distribution.
Reference: [Yok92] <author> Y. Yokoto. </author> <title> The Apertos Reflective Operating System: The Concept and Its Implementation. </title> <booktitle> In Proceedings of Object-Oriented Programming Systems, Languages and Applications., </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: COOL enables objects to be migrated between two machines. Although coupled with remote invocation, object migration is carried out by mapping and unmapping virtual memory segments on different machines. The Muse distributed operating system [YTM + 91], and its successor Apertos <ref> [Yok92] </ref>, provides an open and self-advancing dynamic environment. Muse provides reflective computing that presents facilities for self-modifying an object with its environment. Objects reside in the context of a collection of meta-objects to handle dynamic system behaviour and to provide an optimal execution environment for the object.
Reference: [YTM + 91] <author> Y. Yokote, F. Teraoka, A. Mitsuzawa, N. Fujinami, and M. Tokoro. </author> <title> The Muse Object Architecture: A New Operating System Structuring Concept. </title> <journal> ACM Operating System Review, </journal> <volume> 25(2) </volume> <pages> 22-46, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: COOL [HMA90] (the Chorus Object-Oriented Layer) uses the distributed virtual memory system in Chorus. COOL enables objects to be migrated between two machines. Although coupled with remote invocation, object migration is carried out by mapping and unmapping virtual memory segments on different machines. The Muse distributed operating system <ref> [YTM + 91] </ref>, and its successor Apertos [Yok92], provides an open and self-advancing dynamic environment. Muse provides reflective computing that presents facilities for self-modifying an object with its environment.
References-found: 24

