URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-93-06.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Title: SCHEDULING REAL-TIME DISK TRANSFERS FOR CONTINUOUS MEDIA APPLICATIONS  
Author: Darrell D. E. Long Madhukar N. Thakur 
Address: Santa Cruz, CA 95064  
Affiliation: Computer and Information Sciences University of California  
Abstract: We study how continuous media data can be stored and accessed in the Swift distributed I/O architecture. We provide a scheme for scheduling real-time data transfers that satisfies the strict requirements of continuous media applications. Our scheme allows large data objects to be stored and retrieved concurrently from multiple disks so as to satisfy the high data rate requirements which are typical of real-time video and audio data. To do this, data transfer requests are split into smaller requests which are then handled by the various components of Swift. We study on-line algorithms that respond to a data request by promising to either satisfy or reject it. Each response must be made before the next request is seen by the algorithm. We discuss two different performance measures to evaluate such algorithms and show that no on-line algorithm can optimize these criteria to less than a constant fraction of the optimal. Finally, we propose an algorithm for handling such requests on-line and the related data structures. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> L. F. Cabrera and D. D. E. </author> <title> Long. Using disk striping to provide multiple high I/O data rates. </title> <journal> Computing Systems, </journal> <volume> 4(4):407 - 438, </volume> <month> December </month> <year> 1991. </year>
Reference-contexts: Typically, continuous media applications require large data transfer rates, which may vary from 1.2 megabytes/second for DVI compressed video to 90 megabytes/second for uncompressed full-frame color video. Architectures like Swift <ref> [1, 2] </ref> and RAID [3] stripe files over several disks, and drive the disks in parallel to achieve high data rates. Continuous media data also have large file sizes. A file system dealing with such files must provide mechanisms for manipulating large data objects. <p> Govindan and Anderson [4] investigated CPU scheduling and IPC mechanisms for operating systems for CM applications. Little and Ghafoor [5] studied formal specification and modeling of multimedia objects using a logic based on temporal intervals and Petri Nets. Our aim, is to study how the Swift <ref> [1, 2] </ref> architecture can be used efficiently to read and write CM data objects. Swift is designed to support high data rates in a general purpose distributed system. It is built on the notion of striping data over multiple storage agents and driving them in parallel. <p> In particular, the distribution agents, storage mediators, and storage agents are involved in planning and actual data transfer operations between the client and an array of disks, which are the principal storage media. We refer the reader to <ref> [1, 2] </ref> for details of the functionality of these components of Swift. A client application, when reading or recording CM objects, decides on its data demands in advance and makes a request to preallocate I/O resources. This request is called a client-job. <p> If algorithm X commits to satisfy this rope, then the adversary will present a sequence of c + 2 ropes, all of which require unit time to service, and which follow one another sequentially starting at time 1. Since X is busy in the interval <ref> [1; c + 3] </ref> it must refuse these ropes. Then the ratio of the performances of A and B is less than 1=c. On the other hand, if X refuses to satisfy this first rope, then the adversary ends the sequence immediately with this rope.
Reference: [2] <author> L. F. Cabrera and D. D. E. Long. Swift: </author> <title> A storage architecture for large objects. </title> <booktitle> In Proceedings of the 11th Symposium on Mass Storage Systems, </booktitle> <pages> pages 123-128, </pages> <address> Monterey, Califor-nia, </address> <month> October </month> <year> 1991. </year> <note> IEEE. </note>
Reference-contexts: Typically, continuous media applications require large data transfer rates, which may vary from 1.2 megabytes/second for DVI compressed video to 90 megabytes/second for uncompressed full-frame color video. Architectures like Swift <ref> [1, 2] </ref> and RAID [3] stripe files over several disks, and drive the disks in parallel to achieve high data rates. Continuous media data also have large file sizes. A file system dealing with such files must provide mechanisms for manipulating large data objects. <p> Govindan and Anderson [4] investigated CPU scheduling and IPC mechanisms for operating systems for CM applications. Little and Ghafoor [5] studied formal specification and modeling of multimedia objects using a logic based on temporal intervals and Petri Nets. Our aim, is to study how the Swift <ref> [1, 2] </ref> architecture can be used efficiently to read and write CM data objects. Swift is designed to support high data rates in a general purpose distributed system. It is built on the notion of striping data over multiple storage agents and driving them in parallel. <p> In particular, the distribution agents, storage mediators, and storage agents are involved in planning and actual data transfer operations between the client and an array of disks, which are the principal storage media. We refer the reader to <ref> [1, 2] </ref> for details of the functionality of these components of Swift. A client application, when reading or recording CM objects, decides on its data demands in advance and makes a request to preallocate I/O resources. This request is called a client-job.
Reference: [3] <author> D. Patterson, G. Gibson, and R. Katz. </author> <title> A case for redundant arrays of inexpensive disks (RAID). </title> <booktitle> In Proceedings of the ACM SIGMOD Conference, </booktitle> <pages> pages 109-116, </pages> <address> Chicago, </address> <month> June </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: Typically, continuous media applications require large data transfer rates, which may vary from 1.2 megabytes/second for DVI compressed video to 90 megabytes/second for uncompressed full-frame color video. Architectures like Swift [1, 2] and RAID <ref> [3] </ref> stripe files over several disks, and drive the disks in parallel to achieve high data rates. Continuous media data also have large file sizes. A file system dealing with such files must provide mechanisms for manipulating large data objects.
Reference: [4] <author> R. Govindan and D. P. Anderson. </author> <title> Scheduling and IPC mechanisms for continuous media. </title> <booktitle> In Proceedings of the 13th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 68-80. </pages> <institution> Association for Computing Machinery SIGOPS, </institution> <month> Octo-ber </month> <year> 1991. </year>
Reference-contexts: We study how an array of disks and associated I/O agents can guarantee to read or write data at the transfer rates required by an application. In the past, researchers have investigated other aspects of the design of an operating system to handle CM applications. Govindan and Anderson <ref> [4] </ref> investigated CPU scheduling and IPC mechanisms for operating systems for CM applications. Little and Ghafoor [5] studied formal specification and modeling of multimedia objects using a logic based on temporal intervals and Petri Nets.
Reference: [5] <author> T. D. C. Little and A. Ghafoor. </author> <title> Synchronization and storage models for multimedia objects. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 8(3):413 - 427, </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: In the past, researchers have investigated other aspects of the design of an operating system to handle CM applications. Govindan and Anderson [4] investigated CPU scheduling and IPC mechanisms for operating systems for CM applications. Little and Ghafoor <ref> [5] </ref> studied formal specification and modeling of multimedia objects using a logic based on temporal intervals and Petri Nets. Our aim, is to study how the Swift [1, 2] architecture can be used efficiently to read and write CM data objects.
Reference: [6] <author> C. Osterbrock, D. D. E. Long, and L. F. Cabrera. </author> <title> Providing performance guarantees in an FDDI network. </title> <note> Submitted for publication, </note> <year> 1992. </year>
Reference-contexts: We assume that the time taken to transfer one byte of data over the network is bounded by a constant . The underlying network protocols are assumed to provide for a uniform transfer time without significant variance <ref> [6] </ref>. We describe next how to compute T start and T end for each strand. We consider the read and write cases separately for this computation. In the following discussion, strand i relates to buffer B j , with j = i mod k and the block i of data.
Reference: [7] <author> C. Ruemmler and J. Wilkes. </author> <title> Disk shu*ing. </title> <type> Technical Report HPL-CSP-91-30, </type> <institution> Concurrent Systems Project, Hewlett Packard Laboratories, </institution> <month> October </month> <year> 1991. </year> <note> REFERENCES Page 6 </note>
Reference-contexts: We denote by T (m) the time taken to transfer m bytes of data to or from a disk. It may be difficult to accurately model disks analytically, and so simulation studies may provide the best method to obtain an estimate of T (m) <ref> [7] </ref>.
Reference: [8] <author> R. Abbott and H. Garcia-Molina. </author> <title> Scheduling real-time transactions: A performance evaluation. </title> <booktitle> In Proceedings of 14th VLDB Conference, </booktitle> <year> 1988. </year>
Reference-contexts: ON-LINE SCHEDULING ALGORITHMS On-line or real-time algorithms have been studied theoretically, with an aim of proving performance bounds. We briefly discuss on-line algorithms in general, different measures of performance of such algorithms, and then propose one such algorithm to satisfy a rope. Abbott and Garcia-Molina <ref> [8] </ref> have studied real-time scheduling of transactions with deadlines on a single processor memory resident database system. Shih, Liu and Liu [9] worked on the problem of real-time scheduling periodic jobs which have deferred deadlines.
Reference: [9] <author> W. K. Shih, J. W. S. Liu, and C. L. Liu. </author> <title> Modified rate monotone algorithm for scheduling periodic jobs with deferred deadlines. Real-time Systems Newsletter, </title> <address> 7(1-2):17 - 23, </address> <month> Winter Spring </month> <year> 1991. </year>
Reference-contexts: We briefly discuss on-line algorithms in general, different measures of performance of such algorithms, and then propose one such algorithm to satisfy a rope. Abbott and Garcia-Molina [8] have studied real-time scheduling of transactions with deadlines on a single processor memory resident database system. Shih, Liu and Liu <ref> [9] </ref> worked on the problem of real-time scheduling periodic jobs which have deferred deadlines. Dertouzos and Mok [10] have studied the problem of on-line scheduling of real-time tasks in a multiprocessor environment. They also show that optimal scheduling without a priori knowledge of the input is impossible. <p> The algorithm must check whether the individual strands, in the rope presented to it, are satisfiable given the current set of commitments made by the algorithm. It should commit to satisfy the rope if every strand can be satisfied. While, seemingly, there has been some related work <ref> [14, 9] </ref> on real-time scheduling of tasks, we cannot use their techniques because we have to schedule ropes which not only have a deadline, but also an earliest time before which they cannot be scheduled.
Reference: [10] <author> M. L. Dertouzos and A. K. Mok. </author> <title> Multiprocessor on-line scheduling of hard-real-time tasks. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 15(12):1497 - 1506, </volume> <month> December </month> <year> 1989. </year>
Reference-contexts: Abbott and Garcia-Molina [8] have studied real-time scheduling of transactions with deadlines on a single processor memory resident database system. Shih, Liu and Liu [9] worked on the problem of real-time scheduling periodic jobs which have deferred deadlines. Dertouzos and Mok <ref> [10] </ref> have studied the problem of on-line scheduling of real-time tasks in a multiprocessor environment. They also show that optimal scheduling without a priori knowledge of the input is impossible. On-line algorithms have also been studied analytically in other contexts [11, 12].
Reference: [11] <author> M. S. Manasse, L. A. McGeoch, and D. D. Sleator. </author> <title> Competitive algorithms for server problems. </title> <journal> Journal of Algorithms, </journal> <volume> 11:208 - 230, </volume> <year> 1990. </year>
Reference-contexts: Dertouzos and Mok [10] have studied the problem of on-line scheduling of real-time tasks in a multiprocessor environment. They also show that optimal scheduling without a priori knowledge of the input is impossible. On-line algorithms have also been studied analytically in other contexts <ref> [11, 12] </ref>. Many data structure problems are on-line, including scheduling problems, caching problems, and others. Karlin, Manasse, Rudolph, and Sleator [13] studied on-line algorithms for caching problems.
Reference: [12] <author> D. D. Sleator and R. E. Tarjan. </author> <title> Amortized efficiency of list update and paging rules. </title> <journal> Communications of the ACM, </journal> <volume> 28(2):202 - 208, </volume> <year> 1985. </year>
Reference-contexts: Dertouzos and Mok [10] have studied the problem of on-line scheduling of real-time tasks in a multiprocessor environment. They also show that optimal scheduling without a priori knowledge of the input is impossible. On-line algorithms have also been studied analytically in other contexts <ref> [11, 12] </ref>. Many data structure problems are on-line, including scheduling problems, caching problems, and others. Karlin, Manasse, Rudolph, and Sleator [13] studied on-line algorithms for caching problems.
Reference: [13] <author> A. R. Karlin, M. S. Manasse, L. Rudolph, and D. D. Sleator. </author> <title> Competitive snoopy caching. </title> <journal> Al-gorithmica, </journal> <volume> 3 </volume> <pages> 79-119, </pages> <year> 1988. </year>
Reference-contexts: They also show that optimal scheduling without a priori knowledge of the input is impossible. On-line algorithms have also been studied analytically in other contexts [11, 12]. Many data structure problems are on-line, including scheduling problems, caching problems, and others. Karlin, Manasse, Rudolph, and Sleator <ref> [13] </ref> studied on-line algorithms for caching problems. They also coined the term c-competitive algorithm, to refer to an on-line algorithm which always performs within a constant multiplicative factor, c, of the optimum on any sequence of requests.
Reference: [14] <author> S. K. Dhall and C. L. Liu. </author> <title> On a real-time scheduling problem. </title> <journal> Operations Research, </journal> <volume> 26(1):127 - 140, </volume> <year> 1978. </year> <note> REFERENCES Page 7 </note>
Reference-contexts: The algorithm must check whether the individual strands, in the rope presented to it, are satisfiable given the current set of commitments made by the algorithm. It should commit to satisfy the rope if every strand can be satisfied. While, seemingly, there has been some related work <ref> [14, 9] </ref> on real-time scheduling of tasks, we cannot use their techniques because we have to schedule ropes which not only have a deadline, but also an earliest time before which they cannot be scheduled.
References-found: 14

