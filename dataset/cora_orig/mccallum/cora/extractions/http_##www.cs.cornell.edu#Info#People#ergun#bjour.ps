URL: http://www.cs.cornell.edu/Info/People/ergun/bjour.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/ergun/research.html
Root-URL: 
Title: SELF-TESTING WITHOUT THE GENERATOR BOTTLENECK  
Author: FUNDA ERG UN S RAVI KUMAR AND D. SIVAKUMAR 
Keyword: Key words. program correctness, self-testing, generator bottleneck  
Note: AMS subject classifications. 68Q25, 68Q40, 68Q60  
Abstract: Suppose P is a program designed to compute a function f defined on a group G. The task of self-testing P , that is, testing if P computes f correctly on most inputs, usually involves testing explicitly if P computes f correctly on every generator of G. In the case of multivariate functions, the number of generators, and hence the number of such tests, becomes prohibitively large. We refer to this problem as the generator bottleneck. We develop a technique that can be used to overcome the generator bottleneck for functions that have a certain nice structure, specifically if the relationship between the values of the function on the set of generators is easily checkable. Using our technique, we build the first efficient self-testers for many linear, multilinear, and some non-linear functions. This includes the FFT, and various polynomial functions. All of the self-testers we present make only O(1) calls to the program that is being tested. As a consequence of our techniques, we also obtain efficient program result-checkers for all these problems. 1. Introduction. The notions of program result-checking, self-testing, and self-correcting as introduced in [4, 17, 5] are powerful tools for attacking the problem 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Ar, M. Blum, B. Codenotti, and P. </author> <title> Gemmell, Checking approximate computations over the reals, </title> <booktitle> in Proc. 25th Annual ACM Symposium on the Theory of Computing, </booktitle> <year> 1993, </year> <pages> pp. 786-795. </pages>
Reference-contexts: These methods offer both realistic and efficient tools for software verification. Various useful mathematical functions have been shown to have self-testers and self-correctors; some examples can be found in <ref> [5, 3, 17, 9, 14, 18, 1, 19, 21, 6] </ref>. The theoretical developments in this area are at the heart of the recent breakthrough results on probabilistically checkable proofs and the subsequent results that show non-approximability of hard combinatorial problems.
Reference: [2] <author> L. Babai, L. Fortnow, and C. Lund, </author> <title> Non-deterministic exponential time has two-prover interactive protocols, </title> <journal> Computational Complexity, </journal> <volume> 1(1991), </volume> <pages> pp. 3-40. </pages>
Reference-contexts: Proof. A simple extension of the proof in [5] shows that g is bilinear. (Better bounds on * via a different test can be obtained by appealing to <ref> [2] </ref>.) As in the proof of Theorem 2.1, it suffices to show that given the three conditions, a stronger version of condition (3) holds: g ((ff 1 ); ff 2 ) = h (1) h (ff 2 ; g (ff 1 ; ff 2 )) for every ff 1 ; ff
Reference: [3] <author> D. Beaver and J. Feigenbaum, </author> <title> Hiding instances in multioracle queries, </title> <booktitle> in Proc. 7th Annual Symposium on Theoretical Aspects of Computer Science, </booktitle> <publisher> Springer LNCS 415, </publisher> <year> 1990, </year> <pages> pp. 37-48. </pages>
Reference-contexts: These methods offer both realistic and efficient tools for software verification. Various useful mathematical functions have been shown to have self-testers and self-correctors; some examples can be found in <ref> [5, 3, 17, 9, 14, 18, 1, 19, 21, 6] </ref>. The theoretical developments in this area are at the heart of the recent breakthrough results on probabilistically checkable proofs and the subsequent results that show non-approximability of hard combinatorial problems. <p> Output PASS iff this fraction is less than *. A useful tool in constructing self-correctors is the notion of random self-reducibility . The fine details of this notion are beyond the scope of this paper, and we refer the reader to the papers <ref> [3, 17] </ref> (see also the survey paper [11]). Informally, a function f is randomly self-reducible if evaluation of f on an input can be reduced efficiently to the evaluation of f on one or more random inputs.
Reference: [4] <author> M. Blum and S. Kannan, </author> <title> Designing programs that check their work, </title> <booktitle> in Proc. 21st Annual ACM Symposium on the Theory of Computing, </booktitle> <year> 1989, </year> <pages> pp. 86-97. </pages>
Reference-contexts: 1. Introduction. The notions of program result-checking, self-testing, and self-correcting as introduced in <ref> [4, 17, 5] </ref> are powerful tools for attacking the problem of program correctness. These methods offer both realistic and efficient tools for software verification. <p> ERG UN, S. R. KUMAR, AND D. SIVAKUMAR meet, and a confidence parameter that is an upper bound on the probability that the tester/corrector/checker fails to do its job. The following definitions formalize the notions of self-tester [5], self-corrector [5, 17], and result-checker <ref> [4] </ref>. Definition 1.1 (Self-Tester). <p> We now list three important properties that are required of self-testers, self-correctors, and result-checkers. For definiteness, we state these for the case of self-testers. First, the self-tester T should be computationally different from and more efficient than any program that computes f <ref> [4] </ref>. This restriction ensures that T does not implement the obvious algorithm to compute f (and hence could harbor the same set of bugs, or be computationally inefficient).
Reference: [5] <author> M. Blum, M. Luby, and R. Rubinfeld, </author> <title> Self-testing/correcting with applications to numerical problems, </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 3(1993), </volume> <pages> pp. 549-595. </pages>
Reference-contexts: 1. Introduction. The notions of program result-checking, self-testing, and self-correcting as introduced in <ref> [4, 17, 5] </ref> are powerful tools for attacking the problem of program correctness. These methods offer both realistic and efficient tools for software verification. <p> These methods offer both realistic and efficient tools for software verification. Various useful mathematical functions have been shown to have self-testers and self-correctors; some examples can be found in <ref> [5, 3, 17, 9, 14, 18, 1, 19, 21, 6] </ref>. The theoretical developments in this area are at the heart of the recent breakthrough results on probabilistically checkable proofs and the subsequent results that show non-approximability of hard combinatorial problems. <p> Regan's NSF grant CCR-9409104. 1 2 F. ERG UN, S. R. KUMAR, AND D. SIVAKUMAR meet, and a confidence parameter that is an upper bound on the probability that the tester/corrector/checker fails to do its job. The following definitions formalize the notions of self-tester <ref> [5] </ref>, self-corrector [5, 17], and result-checker [4]. Definition 1.1 (Self-Tester). <p> Regan's NSF grant CCR-9409104. 1 2 F. ERG UN, S. R. KUMAR, AND D. SIVAKUMAR meet, and a confidence parameter that is an upper bound on the probability that the tester/corrector/checker fails to do its job. The following definitions formalize the notions of self-tester [5], self-corrector <ref> [5, 17] </ref>, and result-checker [4]. Definition 1.1 (Self-Tester). <p> For example, Blum, Luby, and Rubinfeld <ref> [5] </ref> establish that the property of linearity f (x + y) = f (x) + f (y) serves as a robust property for the class of all linear functions, and use this to build self-testers for linear functions. This generic technique was first formalized in [19]. Definition 1.5 (Robust Property). <p> We now outline the process of building self-testers using robust properties (cf. <ref> [5] </ref>). Let D be a (finite) group with generators e 1 ; : : : ; e n , and let F denote some class of functions from D into some range R. <p> Related Work. One method that has been used to get around the generator bottleneck has been to exploit the property of downward self-reducibility <ref> [5] </ref>. The self-testers that use this property, however, have to make (log n) calls to the program depending on the way the problem decomposes into smaller problems. <p> For instance, a tester for the permanent function of n fi n matrices makes O (n) calls to the program, whereas a tester for polynomial multiplication that uses similar principles makes O (log n) calls. In <ref> [5] </ref> a bootstrap tester for polynomial multiplication that makes O (log n) calls to the program being tested is given. It is already known that matrix multiplication can be tested (without any calls to the program) using a result-checker due to Freivalds [13]. <p> We assume that the field K is finite, since it is not clear how to choose a random element from an infinite field. The property of linearity I f (ff; fi) [f (ff + fi) = f (ff) + f (fi)] was shown to be robust in <ref> [5] </ref>. Using this and the generic construction of self-testers from robust properties, one obtains the following self-tester for the function f : 6 F. ERG UN, S. R. KUMAR, AND D. <p> Then we know by robustness of linearity that there is a linear function g that agrees with P on most inputs. Note that g can be computed correctly with high probability via the self-corrector (which are easy to construct for linear functions <ref> [5] </ref>). Now, rather than verify that g (x k ) = E c (x k ) for all generators x k of P n , we may instead verify that g satisfies the property g (xq) = cg (q) everywhere. <p> We actually show that h g, hence the "restricted sense.") Notice that the number of points on which the self-tester needs to know the value of f is just one, in contrast to n as in the original approach of <ref> [5] </ref>. Generalization via the Basis Rotation Function . We note that this idea has a natural generalization to vector spaces. <p> What is more important is that h be easy to compute, given just ff and f (ff). Using this scheme, we show that many natural functions f have a suitable candidate for h . The Generator Tests of <ref> [5] </ref> can now be replaced by: Basis Test: Verify P sc (e 1 ) = f (e 1 ) Inductive Test: Repeat O ( 1 * log 1 ) times Pick ff 2 R V Verify P sc ((ff)) = h (ff; P sc (ff)) Reject if the test fails The <p> Note that hypotheses (1), (2), and (3) above are conditions on P and g, not tests performed by a self-tester. Proof. The proof that the function g is linear and P sc computes g (with high probability) is due to <ref> [5] </ref>. For the rest of this proof, we will assume that g is linear and that it satisfies conditions (2) and (3) above. We first argue that it suffices to prove that if the conditions hold, then for every ff 2 V , g ((ff)) = h (ff; g (ff)). <p> Higher Order Differentiation of Polynomials. Let D k denote the k-th differential operator. It is easy to write a recurrence-like identity for D k in terms of D j ; j &lt; k. This gives us a self-tester only in the library setting described in <ref> [5, 20] </ref>, where one assumes that there are programs to compute all these differential operators. If we wish to self-test a program that only computes D k and have no library of lower-order differentials, this assumption is not valid. <p> Now, suppose we wish to test P that purports to compute f . The naive approach would require doing the Generator Tests at these n 2 generators. This requires O (n 2 ) calls to P , rendering the self-tester highly inefficient. Blum, Luby, and Rubinfeld <ref> [5] </ref> give a more efficient bootstrap self-tester that makes O (log O (k) calls to P . <p> Then g (ff 1 ; ff 2 ) = f (ff 1 ; ff 2 ) for all ff 1 ; ff 2 2 V . Proof. A simple extension of the proof in <ref> [5] </ref> shows that g is bilinear. (Better bounds on * via a different test can be obtained by appealing to [2].) As in the proof of Theorem 2.1, it suffices to show that given the three conditions, a stronger version of condition (3) holds: g ((ff 1 ); ff 2 ) <p> We note that this idea is similar to the use of the interpolation formula by Gemmell, et al. [14], which extends the <ref> [5] </ref> result from linear functions to low-degree polynomials. Before proceeding with the proof, we state the following fact concerning the Lagrange interpolation identity. Fact 4.1. Let g be a degree d polynomial.
Reference: [6] <author> M. Blum and H. Wasserman, </author> <title> Program result-checking: A theory of testing meets a test of theory, </title> <booktitle> in Proc. 35th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1994, </year> <pages> pp. 382-392. </pages>
Reference-contexts: These methods offer both realistic and efficient tools for software verification. Various useful mathematical functions have been shown to have self-testers and self-correctors; some examples can be found in <ref> [5, 3, 17, 9, 14, 18, 1, 19, 21, 6] </ref>. The theoretical developments in this area are at the heart of the recent breakthrough results on probabilistically checkable proofs and the subsequent results that show non-approximability of hard combinatorial problems. <p> Moreover, this scheme requires the tester to perform polynomial evaluations, whereas ours does not. For Fourier transforms, a different result-checker that uses preprocessing has been given independently in <ref> [6] </ref>. A Useful Fact. The following fact, a variant of the well-known Chernoff-Hoeffding bounds, is often very useful in obtaining error-bounds in sampling 0/1 random variables [15]: Fact 1.6. Let Y 1 ; Y 2 ; : : : be independently and identically distributed 0=1 random variables with means .
Reference: [7] <author> M. Blum and H. Wasserman, </author> <title> Reflections on the Pentium division bug, </title> <journal> IEEE Transactions on Computers, </journal> <volume> 4(1996), </volume> <pages> pp. 385-393. </pages>
Reference: [8] <author> E. Castillo, M. R. Ruiz-Cobo, </author> <title> Functional Equations and Modeling in Science and Engineer ing, </title> <publisher> Marcel Dekker, Inc., </publisher> <year> 1992. </year>
Reference: [9] <author> R. Cleve and M. Luby, </author> <title> A note on self-testing/correcting methods for trigonometric functions, </title> <type> TR 90-032, ICSI, </type> <institution> Berkeley, </institution> <year> 1990. </year>
Reference-contexts: These methods offer both realistic and efficient tools for software verification. Various useful mathematical functions have been shown to have self-testers and self-correctors; some examples can be found in <ref> [5, 3, 17, 9, 14, 18, 1, 19, 21, 6] </ref>. The theoretical developments in this area are at the heart of the recent breakthrough results on probabilistically checkable proofs and the subsequent results that show non-approximability of hard combinatorial problems.
Reference: [10] <author> F. Erg un, </author> <title> Testing multivariate linear functions: Overcoming the generator bottleneck, </title> <booktitle> in Proc. 27th Annual ACM Symposium on the Theory of Computing, </booktitle> <year> 1995, </year> <pages> pp. 407-416. </pages>
Reference-contexts: that take P as an oracle, and in addition, take one or more of the following parameters as input: an accuracy parameter * that specifies the conditions that P is expected to fl This paper unifies the preliminary versions which appeared in the 27th Annual Symposium on Theory of Computing <ref> [10] </ref> and in the 15th Annual Foundations of Software Technology and Theoretical Computer Science [16]. y Department of Computer Science, Cornell University, Ithaca, NY 14853-7501 (ergun@cs.cornell.edu). This work is partially supported by ONR Young Investigator Award N00014-93-1-0590, the Alfred P.
Reference: [11] <author> J. Feigenbaum, </author> <title> Locally random reductions in interactive complexity theory, </title> <booktitle> in Advances in Computational Complexity Theory, DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <editor> J.-Y. Cai, ed., </editor> <publisher> American Mathematical Society, </publisher> <year> 1993, </year> <pages> pp. 73-98. </pages>
Reference-contexts: A useful tool in constructing self-correctors is the notion of random self-reducibility . The fine details of this notion are beyond the scope of this paper, and we refer the reader to the papers [3, 17] (see also the survey paper <ref> [11] </ref>). Informally, a function f is randomly self-reducible if evaluation of f on an input can be reduced efficiently to the evaluation of f on one or more random inputs.
Reference: [12] <author> U. Feige, S. Goldwasser, L. Lovasz, S. Safra, and M. Szegedy, </author> <title> Approximating clique is almost NP-complete, </title> <booktitle> in Proc. 32nd Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1991, </year> <pages> pp. 2-12. </pages>
Reference: [13] <author> R. Freivalds, </author> <title> Fast probabilistic algorithms, </title> <booktitle> in Mathematical Foundations of Computer Science, </booktitle> <publisher> Springer LNCS 74, </publisher> <year> 1979, </year> <pages> pp. 57-69. </pages>
Reference-contexts: In [5] a bootstrap tester for polynomial multiplication that makes O (log n) calls to the program being tested is given. It is already known that matrix multiplication can be tested (without any calls to the program) using a result-checker due to Freivalds <ref> [13] </ref>. The idea of Freivalds' matrix multiplication checker can also be adapted to build testers for polynomial multiplication that make no calls to the program being tested.
Reference: [14] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson, </author> <title> Self-testing/ correct ing for polynomials and for approximate functions, </title> <booktitle> in Proc. 23rd Annual ACM Symposium on the Theory of Computing, </booktitle> <year> 1991, </year> <pages> pp. 32-42. </pages>
Reference-contexts: These methods offer both realistic and efficient tools for software verification. Various useful mathematical functions have been shown to have self-testers and self-correctors; some examples can be found in <ref> [5, 3, 17, 9, 14, 18, 1, 19, 21, 6] </ref>. The theoretical developments in this area are at the heart of the recent breakthrough results on probabilistically checkable proofs and the subsequent results that show non-approximability of hard combinatorial problems. <p> Suppose a program P claims to perform this exponentiation for all degree n polynomials q 2 P n K [x]. Using the low-degree test of Rubinfeld and Sudan [19] (see also <ref> [14] </ref>) we can first test if the function computed by P is close to some degree d polynomial g. As before, using the self-corrected version P sc of P , we can also verify that g (e 1 ) = f (e 1 ). <p> We follow a strategy similar to the case of linear functions, this time using the Lagrange interpolation formula as the robust property that identifies a degree d polynomial. We note that this idea is similar to the use of the interpolation formula by Gemmell, et al. <ref> [14] </ref>, which extends the [5] result from linear functions to low-degree polynomials. Before proceeding with the proof, we state the following fact concerning the Lagrange interpolation identity. Fact 4.1. Let g be a degree d polynomial.
Reference: [15] <author> R. Karp, M. Luby, and N. </author> <title> Madras, Monte-Carlo approximation algorithms for enumeration problems, </title> <journal> Journal of Algorithms, </journal> <volume> 3(1989), </volume> <pages> pp. 429-448. </pages>
Reference-contexts: For Fourier transforms, a different result-checker that uses preprocessing has been given independently in [6]. A Useful Fact. The following fact, a variant of the well-known Chernoff-Hoeffding bounds, is often very useful in obtaining error-bounds in sampling 0/1 random variables <ref> [15] </ref>: Fact 1.6. Let Y 1 ; Y 2 ; : : : be independently and identically distributed 0=1 random variables with means . Let 2.
Reference: [16] <author> S. R. Kumar and D. Sivakumar, </author> <title> On self-testing without the generator bottleneck, </title> <booktitle> in Proc. 15th Annual Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <publisher> Springer LNCS 1026, </publisher> <year> 1995, </year> <pages> pp. 248-262. </pages>
Reference-contexts: the following parameters as input: an accuracy parameter * that specifies the conditions that P is expected to fl This paper unifies the preliminary versions which appeared in the 27th Annual Symposium on Theory of Computing [10] and in the 15th Annual Foundations of Software Technology and Theoretical Computer Science <ref> [16] </ref>. y Department of Computer Science, Cornell University, Ithaca, NY 14853-7501 (ergun@cs.cornell.edu). This work is partially supported by ONR Young Investigator Award N00014-93-1-0590, the Alfred P. Sloan Research Award, and NSF grant DMI-91157199. z Department of Computer Science, Cornell University, Ithaca, NY 14853-7501 (ravi@cs.cornell.edu).
Reference: [17] <author> R. Lipton, </author> <title> New directions in testing, </title> <booktitle> in Proc. DIMACS Workshop on Distributed Computing and Cryptography, </booktitle> <year> 1991, </year> <pages> pp. 191-202. </pages>
Reference-contexts: 1. Introduction. The notions of program result-checking, self-testing, and self-correcting as introduced in <ref> [4, 17, 5] </ref> are powerful tools for attacking the problem of program correctness. These methods offer both realistic and efficient tools for software verification. <p> These methods offer both realistic and efficient tools for software verification. Various useful mathematical functions have been shown to have self-testers and self-correctors; some examples can be found in <ref> [5, 3, 17, 9, 14, 18, 1, 19, 21, 6] </ref>. The theoretical developments in this area are at the heart of the recent breakthrough results on probabilistically checkable proofs and the subsequent results that show non-approximability of hard combinatorial problems. <p> Regan's NSF grant CCR-9409104. 1 2 F. ERG UN, S. R. KUMAR, AND D. SIVAKUMAR meet, and a confidence parameter that is an upper bound on the probability that the tester/corrector/checker fails to do its job. The following definitions formalize the notions of self-tester [5], self-corrector <ref> [5, 17] </ref>, and result-checker [4]. Definition 1.1 (Self-Tester). <p> Output PASS iff this fraction is less than *. A useful tool in constructing self-correctors is the notion of random self-reducibility . The fine details of this notion are beyond the scope of this paper, and we refer the reader to the papers <ref> [3, 17] </ref> (see also the survey paper [11]). Informally, a function f is randomly self-reducible if evaluation of f on an input can be reduced efficiently to the evaluation of f on one or more random inputs.
Reference: [18] <author> R. Rubinfeld and M. Sudan, </author> <title> Testing polynomial functions efficiently and over rational do mains, </title> <booktitle> in Proc. 3rd Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1992, </year> <pages> pp. 23-43. </pages>
Reference-contexts: These methods offer both realistic and efficient tools for software verification. Various useful mathematical functions have been shown to have self-testers and self-correctors; some examples can be found in <ref> [5, 3, 17, 9, 14, 18, 1, 19, 21, 6] </ref>. The theoretical developments in this area are at the heart of the recent breakthrough results on probabilistically checkable proofs and the subsequent results that show non-approximability of hard combinatorial problems.
Reference: [19] <author> R. Rubinfeld and M. Sudan, </author> <title> Robust characterizations of polynomials with applications to program testing, </title> <journal> SIAM Journal on Computing, </journal> <volume> 2(1996), </volume> <pages> pp. 252-271. </pages> <editor> 22 F. ERG UN, S. R. KUMAR, AND D. </editor> <publisher> SIVAKUMAR </publisher>
Reference-contexts: These methods offer both realistic and efficient tools for software verification. Various useful mathematical functions have been shown to have self-testers and self-correctors; some examples can be found in <ref> [5, 3, 17, 9, 14, 18, 1, 19, 21, 6] </ref>. The theoretical developments in this area are at the heart of the recent breakthrough results on probabilistically checkable proofs and the subsequent results that show non-approximability of hard combinatorial problems. <p> This generic technique was first formalized in <ref> [19] </ref>. Definition 1.5 (Robust Property). A property is a predicate I f (~x = x 1 ; : : : ; x k ). <p> Suppose a program P claims to perform this exponentiation for all degree n polynomials q 2 P n K [x]. Using the low-degree test of Rubinfeld and Sudan <ref> [19] </ref> (see also [14]) we can first test if the function computed by P is close to some degree d polynomial g. As before, using the self-corrected version P sc of P , we can also verify that g (e 1 ) = f (e 1 ). <p> Assume that P passes the Degree Test and P sc passes the Basis Test that is, P agrees with some degree-d polynomial g on most inputs. We note that the low-degree of test of <ref> [19] </ref> makes O ((1=*) log (1=)) calls to render a decision with confidence 1 (=3). Furthermore, P sc also requires only O ((1=*) log (1=)) calls to compute g correctly with probability 1 (=3).
Reference: [20] <author> R. Rubinfeld, </author> <title> A Mathematical Theory of Self-Checking, Self-Testing, and Self-Correcting Programs, </title> <type> Ph.D. Thesis, </type> <institution> University of California at Berkeley, </institution> <year> 1990. </year>
Reference-contexts: Higher Order Differentiation of Polynomials. Let D k denote the k-th differential operator. It is easy to write a recurrence-like identity for D k in terms of D j ; j &lt; k. This gives us a self-tester only in the library setting described in <ref> [5, 20] </ref>, where one assumes that there are programs to compute all these differential operators. If we wish to self-test a program that only computes D k and have no library of lower-order differentials, this assumption is not valid.
Reference: [21] <author> R. Rubinfeld, </author> <title> Robust functional equations with applications to self-testing/ correcting, </title> <booktitle> in Proc. 35th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <year> 1994, </year> <pages> pp. 288-299. </pages>
Reference-contexts: These methods offer both realistic and efficient tools for software verification. Various useful mathematical functions have been shown to have self-testers and self-correctors; some examples can be found in <ref> [5, 3, 17, 9, 14, 18, 1, 19, 21, 6] </ref>. The theoretical developments in this area are at the heart of the recent breakthrough results on probabilistically checkable proofs and the subsequent results that show non-approximability of hard combinatorial problems.
Reference: [22] <author> M. Sudan, </author> <title> On the role of algebra in the efficient verification of proofs, </title> <booktitle> in Proc. Workshop on Algebraic Methods in Complexity Theory, </booktitle> <editor> M. Agrawal, V. Arvind, and M. Mahajan, eds., </editor> <year> 1994, </year> <pages> pp. 58-68. </pages>
References-found: 22

