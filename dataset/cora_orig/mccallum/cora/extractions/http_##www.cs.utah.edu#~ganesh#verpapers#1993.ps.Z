URL: http://www.cs.utah.edu/~ganesh/verpapers/1993.ps.Z
Refering-URL: http://www.cs.utah.edu/~ganesh/verpapers.html
Root-URL: 
Email: (jain@cs.utah.edu)  (ganesh@bliss.utah.edu)  
Title: Efficient Symbolic Simulation-based Verification Using the Parametric form of Boolean Expressions  
Author: PRABHAT JAIN GANESH GOPALAKRISHNAN 
Keyword: Symbolic Simulation, Formal Verification of VLSI, Regular Array Verification, Input Constraints, Para metric Boolean Expressions  
Address: Salt Lake City, Utah 84112  
Affiliation: University of Utah Dept. of Computer Science  
Abstract: Symbolic simulation has been proposed as a way to formally verify the correct operation of an MOS circuit. By allowing non-ground expressions as values, a symbolic simulator avoids the complexity of exhaustive simulation. The symbolic expressions chosen for initializing the state- and input-variables must cover all valid test cases while avoiding those that violate circuit constraints. In this paper, we present a new approach to symbolic simulation-based verification, which hinges on the use of parametric forms of Boolean expressions. A parametric form of a Boolean expression E is an equivalent expression in which the variables in E are expressed in terms of expressions over new variables called parametric variables. In our approach, Boolean expressions representing the operating constraints on the circuit node values are first converted into the parametric form, and the resulting parametric expressions are used as initial (symbolic) node values prior to each simulation step. In addition to the proposal to use the parametric form, we make the following additional contributions. We present a new method for generating the parametric form of a Boolean expression that exploits (among other things) the structural recursion involved in defining commonly used arithmetic/relational operators. Our method generates parametric forms that are more compact, as well as more balanced in terms of term-sizes than generated by the following existing methods: Boole's and Lowenheim's methods, and the generalized cofactor method. We have also developed a variety of example-specific techniques to deal with circuit constraints. All algorithms discussed in this paper have been implemented in a verification prototype system. Experimental results obtained using the COSMOS symbolic simulator are also reported. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Randal E. Bryant, Derek L. Beatty, and Carl-Johan H. Seger. </author> <title> Formal hardware verification by symbolic ternary trajectory evaluation. </title> <booktitle> In Proc. ACM/IEEE 28rd Design Automation Conference, </booktitle> <pages> pages 397-402, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: This method does not scale up to large circuits, in general. Recently, symbolic simulation has emerged to be a practical method for specifying and simulating non-trivial MOS circuits <ref> [1, 2] </ref>. The simulation vectors used during symbolic simulation fl supported in part by the University of Utah Graduate Research Fellowship. y Member, IEEE. <p> In [15], we wrote Prolog programs capturing the above constraints and obtained "answer substitutions" [31]. (Other methods, e.g., [32], are equally applicable.) We obtain sixteen symbolic vectors, some of which are shown below: M I N I 0 = [0; 0; n1; n0] I N 0 = <ref> [1; i2; i1; i0] </ref> M AXI 0 = [0; 1; m1; m0] M I N I 2 = [0; n2; n1; 0] I N 2 = [1; i2; i1; i0] M AXI 2 = [0; n2; n1; 1] M I N I 15 = [i3; i2; i1; 0] I N 15 <p> programs capturing the above constraints and obtained "answer substitutions" [31]. (Other methods, e.g., [32], are equally applicable.) We obtain sixteen symbolic vectors, some of which are shown below: M I N I 0 = [0; 0; n1; n0] I N 0 = [1; i2; i1; i0] M AXI 0 = <ref> [0; 1; m1; m0] </ref> M I N I 2 = [0; n2; n1; 0] I N 2 = [1; i2; i1; i0] M AXI 2 = [0; n2; n1; 1] M I N I 15 = [i3; i2; i1; 0] I N 15 = [i3; i2; i1; 1] M AXI 15 <p> obtain sixteen symbolic vectors, some of which are shown below: M I N I 0 = [0; 0; n1; n0] I N 0 = <ref> [1; i2; i1; i0] </ref> M AXI 0 = [0; 1; m1; m0] M I N I 2 = [0; n2; n1; 0] I N 2 = [1; i2; i1; i0] M AXI 2 = [0; n2; n1; 1] M I N I 15 = [i3; i2; i1; 0] I N 15 = [i3; i2; i1; 1] M AXI 15 = [i3; i2; i1; 0] Here, M I N I i represents the ith vector to be loaded <p> shown below: M I N I 0 = [0; 0; n1; n0] I N 0 = [1; i2; i1; i0] M AXI 0 = [0; 1; m1; m0] M I N I 2 = [0; n2; n1; 0] I N 2 = [1; i2; i1; i0] M AXI 2 = <ref> [0; n2; n1; 1] </ref> M I N I 15 = [i3; i2; i1; 0] I N 15 = [i3; i2; i1; 1] M AXI 15 = [i3; i2; i1; 0] Here, M I N I i represents the ith vector to be loaded into the register MINI, and so on for <p> i1; i0] M AXI 0 = [0; 1; m1; m0] M I N I 2 = [0; n2; n1; 0] I N 2 = [1; i2; i1; i0] M AXI 2 = [0; n2; n1; 1] M I N I 15 = [i3; i2; i1; 0] I N 15 = <ref> [i3; i2; i1; 1] </ref> M AXI 15 = [i3; i2; i1; 0] Here, M I N I i represents the ith vector to be loaded into the register MINI, and so on for the other vectors. <p> Outputs of the tree of OR gates form the inputs of the data register [d3; d2; d1; d0] and the sentinel register [s3; s2; s1; s0]. The sentinel register indicates which data-register bits are valid. For example, if the Huffman code for a character is <ref> [1; 0] </ref>, the OR tree would generate [1; 0; 0; 0] for the data register and [1; 1; 0; 0] for the sentinel register. The bits of the data register corresponding to the 0 bits of the sentinel register are actually don't-cares. <p> The sentinel register indicates which data-register bits are valid. For example, if the Huffman code for a character is [1; 0], the OR tree would generate <ref> [1; 0; 0; 0] </ref> for the data register and [1; 1; 0; 0] for the sentinel register. The bits of the data register corresponding to the 0 bits of the sentinel register are actually don't-cares. <p> The sentinel register indicates which data-register bits are valid. For example, if the Huffman code for a character is [1; 0], the OR tree would generate [1; 0; 0; 0] for the data register and <ref> [1; 1; 0; 0] </ref> for the sentinel register. The bits of the data register corresponding to the 0 bits of the sentinel register are actually don't-cares.
Reference: 2. <author> Prabhat Jain and Ganesh Gopalakrishnan. </author> <title> Some techniques for efficient symbolic simulation based verification. </title> <booktitle> In International Conference on Computer Design (ICCD), </booktitle> <pages> pages 598-602, </pages> <year> 1992. </year>
Reference-contexts: This method does not scale up to large circuits, in general. Recently, symbolic simulation has emerged to be a practical method for specifying and simulating non-trivial MOS circuits <ref> [1, 2] </ref>. The simulation vectors used during symbolic simulation fl supported in part by the University of Utah Graduate Research Fellowship. y Member, IEEE. <p> We have developed a variety of example-specific techniques to deal with circuit constraints using the parametric form. These are discussed in Section 3. 1.2 Overview of Symbolic Simulation Based Verification In our past work <ref> [15, 2, 23] </ref> we have investigated the use of symbolic simulation for verifying MOS circuits.
Reference: 3. <editor> G.Birtwistle and P.A.Subrahmanyam, editors. </editor> <title> Current Trends in Hardware Verification and SYMBOLIC SIMULATION BASED VERIFICATION USING PARAMETRIC BOOLEAN EXPRESSIONS 24 Automated Theorem Proving. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: In this paper, we present efficient techniques to generate symbolic simulation vectors, taking into account various circuit constraints. It is well known that hardware verifiers based on general purpose theorem provers (e.g., <ref> [3, 4, 5] </ref>) can avoid enumerating Boolean combinations, and hence, also can be used to verify large circuits without exhaustive case analysis. They can, in addition, perform hierarchical verification, handle replicated structures (usually through proofs by induction), verify generic modules, and verify even synthesis procedures themselves [6].
Reference: 4. <author> Albert Camilleri, Michael C. Gordon, and Tom Melham. </author> <title> Hardware specification and verification using higher order logic. In Processings of the IFIP WG 10.2 Working Conference on "From HDL Descriptions to Guaranteed Correct Circuit Designs", Grenoble, August 1986. </title> <publisher> North-Holland, </publisher> <year> 1986. </year>
Reference-contexts: In this paper, we present efficient techniques to generate symbolic simulation vectors, taking into account various circuit constraints. It is well known that hardware verifiers based on general purpose theorem provers (e.g., <ref> [3, 4, 5] </ref>) can avoid enumerating Boolean combinations, and hence, also can be used to verify large circuits without exhaustive case analysis. They can, in addition, perform hierarchical verification, handle replicated structures (usually through proofs by induction), verify generic modules, and verify even synthesis procedures themselves [6].
Reference: 5. <author> Warren A. Hunt Jr. </author> <title> The mechanical verification of a microprocessor design. </title> <editor> In D. Borrione, editor, </editor> <title> From HDL Descriptions to Guaranted Correct Circuit Designs. </title> <publisher> Elsevier Science Publishers B.V. (North Holland), </publisher> <year> 1987. </year> <booktitle> (Proc of the IFIP WG 10.2 Working Conference with the same title.). </booktitle>
Reference-contexts: In this paper, we present efficient techniques to generate symbolic simulation vectors, taking into account various circuit constraints. It is well known that hardware verifiers based on general purpose theorem provers (e.g., <ref> [3, 4, 5] </ref>) can avoid enumerating Boolean combinations, and hence, also can be used to verify large circuits without exhaustive case analysis. They can, in addition, perform hierarchical verification, handle replicated structures (usually through proofs by induction), verify generic modules, and verify even synthesis procedures themselves [6].
Reference: 6. <author> Shiu-Kai Chin and Edward P. Stabler. </author> <title> Synthesis of arithmetic hardware using hardware meta-functions. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 9(8) </volume> <pages> 793-803, </pages> <month> August </month> <year> 1990. </year>
Reference-contexts: They can, in addition, perform hierarchical verification, handle replicated structures (usually through proofs by induction), verify generic modules, and verify even synthesis procedures themselves <ref> [6] </ref>. Thus, the theorem proving approach to hardware verification seems to have all the advantages of the symbolic simulation based approach, plus some additional ones.
Reference: 7. <author> Zhou Chaochen and C.A.R. Hoare. </author> <title> A model for synchronous switching circuits and its theory of correctness. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 1(1) </volume> <pages> 7-28, </pages> <year> 1992. </year>
Reference-contexts: In addition, verification of switch-level circuits using theorem provers requires transistors to be modeled in the logic underlying the theorem prover. It has not been demonstrated yet that available formal models of transistors (e.g., <ref> [7, 8, 9] </ref>) can handle `second-order' effects such as charge sharing, improper ratioing, etc. as accurately as modern switch-level simulators or transistor network analysis tools can model these effects. For these reasons, Boolean symbolic simulation remains an attractive option.
Reference: 8. <author> Glynn Winskel. </author> <title> A compositional model of MOS circuits. </title> <editor> In Graham Birtwistle and P.A.Subrahmanyam, editors, </editor> <booktitle> VLSI Specification, Verification and Synthesis, </booktitle> <pages> pages 323-348. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1988. </year> <month> ISBN-0-89838-246-7. </month>
Reference-contexts: In addition, verification of switch-level circuits using theorem provers requires transistors to be modeled in the logic underlying the theorem prover. It has not been demonstrated yet that available formal models of transistors (e.g., <ref> [7, 8, 9] </ref>) can handle `second-order' effects such as charge sharing, improper ratioing, etc. as accurately as modern switch-level simulators or transistor network analysis tools can model these effects. For these reasons, Boolean symbolic simulation remains an attractive option.
Reference: 9. <author> David Musser, Paliath Narendran, and William Premerlani. </author> <title> Bids: A method for specifying and verifying bidirectional hardware. </title> <editor> In Graham Birtwistle and P.A.Subrahmanyam, editors, </editor> <booktitle> VLSI Specification, Verification and Synthesis, </booktitle> <pages> pages 217-233. </pages> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, </address> <year> 1988. </year> <month> ISBN-0-89838-246-7. </month>
Reference-contexts: In addition, verification of switch-level circuits using theorem provers requires transistors to be modeled in the logic underlying the theorem prover. It has not been demonstrated yet that available formal models of transistors (e.g., <ref> [7, 8, 9] </ref>) can handle `second-order' effects such as charge sharing, improper ratioing, etc. as accurately as modern switch-level simulators or transistor network analysis tools can model these effects. For these reasons, Boolean symbolic simulation remains an attractive option.
Reference: 10. <author> Carl-Johan Seger and Jeffrey Joyce. </author> <title> A two-level formal verification methodology using HOL and COSMOS. </title> <type> Technical Report 91-10, </type> <institution> Dept. of Computer Science, University of British Columbia, Vancouver, B.C., </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: For these reasons, Boolean symbolic simulation remains an attractive option. In fact, a practically effective verification approach would combine the strengths of verification and simulation <ref> [10] </ref>. In [11, 12], a different technique for switch-level circuit verification has been proposed. Their approach consists of first extracting a state machine from the representation of the implementation (e.g., a transistor netlist), and then comparing the specification and the implementation machines through symbolic reachability analysis.
Reference: 11. <author> Christian Berthet, Olivier Coudert, and Jean-Christophe Madre. </author> <title> New ideas on symbolic manipulations of finite state machines. </title> <booktitle> In Proceedings of the ICCD, </booktitle> <year> 1990, </year> <pages> pages 224-227, </pages> <year> 1990. </year>
Reference-contexts: For these reasons, Boolean symbolic simulation remains an attractive option. In fact, a practically effective verification approach would combine the strengths of verification and simulation [10]. In <ref> [11, 12] </ref>, a different technique for switch-level circuit verification has been proposed. Their approach consists of first extracting a state machine from the representation of the implementation (e.g., a transistor netlist), and then comparing the specification and the implementation machines through symbolic reachability analysis. <p> The conversion to, and the use of parametric forms of Boolean expressions has been discussed in [17] (which provides a short historical survey) and [18]. Parametric forms have also been used in <ref> [11] </ref> for the verification of finite state machines. In [12], a discussion on algorithms to construct the parametric form of a Boolean expression is presented. The use of parametric expressions to make symbolic simulation-based verification efficient is believed to be new.
Reference: 12. <author> Olivier Coudert Christian Berthet and Jean-Christophe Madre. </author> <title> Verification of sequential machines using boolean functional vectors. </title> <booktitle> In Proceedings of the IMEC-IFIP Workshop on Applied Formal Methods for Correct VLSI Design, </booktitle> <address> Leuven, Belgium, </address> <pages> pages 179-196, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: For these reasons, Boolean symbolic simulation remains an attractive option. In fact, a practically effective verification approach would combine the strengths of verification and simulation [10]. In <ref> [11, 12] </ref>, a different technique for switch-level circuit verification has been proposed. Their approach consists of first extracting a state machine from the representation of the implementation (e.g., a transistor netlist), and then comparing the specification and the implementation machines through symbolic reachability analysis. <p> The conversion to, and the use of parametric forms of Boolean expressions has been discussed in [17] (which provides a short historical survey) and [18]. Parametric forms have also been used in [11] for the verification of finite state machines. In <ref> [12] </ref>, a discussion on algorithms to construct the parametric form of a Boolean expression is presented. The use of parametric expressions to make symbolic simulation-based verification efficient is believed to be new. A general definition of the parametric form is now given. <p> Another method for generating the parametric form is based on the generalized cofactor [21] operator (also called the constraint operator), which was initially proposed by Coudert et al. in <ref> [12] </ref>. Application of this method for generating the parametric form is now illustrated through an example (for details, see the above references). Consider the constraint A &gt; B where A = [a 1 ; a 0 ] and B = [b 1 ; b 0 ].
Reference: 13. <author> Randal E. Bryant. </author> <title> Verifying a static RAM design by logic simulation. </title> <editor> In Jonathan Allen and F. Thomson Leighton, editors, </editor> <booktitle> Advanced Research in VLSI : Proceedings of the Fifth MIT Conference. </booktitle> <publisher> The MIT Press, </publisher> <month> March </month> <year> 1988. </year>
Reference-contexts: Also, we have developed techniques to tailor the verification approach for various classes of circuits such as regular array structures, circuits with different kinds of input- and state-constraints, etc. A closely related approach to Boolean symbolic simulation has been proposed by Bryant: ternary simulation <ref> [13, 14] </ref>. Any simulator that can handle the third logical value X ("don't care") correctly can be employed for ternary simulation based verification. In this approach, simulation vectors over the values 0, 1, and X are employed, each usage of X effectively halving the total number of vectors required.
Reference: 14. <author> Randal E. Bryant. </author> <title> A methodology for hardware verification based on logic simulation. </title> <journal> J.ACM, </journal> <month> April </month> <year> 1991. </year> <title> SYMBOLIC SIMULATION BASED VERIFICATION USING PARAMETRIC BOOLEAN EXPRESSIONS 25 </title>
Reference-contexts: Also, we have developed techniques to tailor the verification approach for various classes of circuits such as regular array structures, circuits with different kinds of input- and state-constraints, etc. A closely related approach to Boolean symbolic simulation has been proposed by Bryant: ternary simulation <ref> [13, 14] </ref>. Any simulator that can handle the third logical value X ("don't care") correctly can be employed for ternary simulation based verification. In this approach, simulation vectors over the values 0, 1, and X are employed, each usage of X effectively halving the total number of vectors required.
Reference: 15. <author> Ganesh Gopalakrishnan, Prabhat Jain, Venkatesh Akella, Luli Josephson, and Wen-Yan Kuo. </author> <title> Combining verification and simulation. </title> <editor> In Carlo Sequin, editor, </editor> <booktitle> Advanced Research in VLSI : Proceedings of the 1991 University of California Santa Cruz Conference. </booktitle> <publisher> The MIT Press, </publisher> <year> 1991. </year> <note> ISBN 0-262-19308-6. </note>
Reference-contexts: In this approach, simulation vectors over the values 0, 1, and X are employed, each usage of X effectively halving the total number of vectors required. However, for verifying strict 1 operations, the ternary X value cannot be used as input <ref> [15] </ref>. As strict operations are widely used, ternary simulation becomes unusable for a large class of 1 f is strict in its ith argument if f , when fed X as its ith actual parameter yields X. Example: add. SYMBOLIC SIMULATION BASED VERIFICATION USING PARAMETRIC BOOLEAN EXPRESSIONS 3 designs. <p> We have developed a variety of example-specific techniques to deal with circuit constraints using the parametric form. These are discussed in Section 3. 1.2 Overview of Symbolic Simulation Based Verification In our past work <ref> [15, 2, 23] </ref> we have investigated the use of symbolic simulation for verifying MOS circuits. <p> In <ref> [15] </ref>, we wrote Prolog programs capturing the above constraints and obtained "answer substitutions" [31]. (Other methods, e.g., [32], are equally applicable.) We obtain sixteen symbolic vectors, some of which are shown below: M I N I 0 = [0; 0; n1; n0] I N 0 = [1; i2; i1; i0] M
Reference: 16. <author> Randal E. Bryant. </author> <title> Formal verification of memory circuits by switch-level simulation. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <volume> 10(1) </volume> <pages> 94-102, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: Example: add. SYMBOLIC SIMULATION BASED VERIFICATION USING PARAMETRIC BOOLEAN EXPRESSIONS 3 designs. Also, because the ternary X does not obey the law of the excluded middle 2 , a great deal of circuit-specific handling is often required before ternary simulation can be employed <ref> [16] </ref>. For these reasons, we prefer the symbolic simulation approach which is, in fact, a more general technique. In the rest of this paper, we focus on Boolean symbolic simulation. We focus on the problem of generating symbolic simulation vectors taking circuit constraints into account.
Reference: 17. <author> Frank M. Brown. </author> <title> Reduced solutions of boolean equations. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-19(10):976-981, </volume> <month> October </month> <year> 1970. </year>
Reference-contexts: The conversion to, and the use of parametric forms of Boolean expressions has been discussed in <ref> [17] </ref> (which provides a short historical survey) and [18]. Parametric forms have also been used in [11] for the verification of finite state machines. In [12], a discussion on algorithms to construct the parametric form of a Boolean expression is presented.
Reference: 18. <author> Eduard Cerny and Miguel A. Marin. </author> <title> A computer algorithm for the synthesis of memoryless logic circuits. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-23(5):455-465, </volume> <month> May </month> <year> 1974. </year>
Reference-contexts: The conversion to, and the use of parametric forms of Boolean expressions has been discussed in [17] (which provides a short historical survey) and <ref> [18] </ref>. Parametric forms have also been used in [11] for the verification of finite state machines. In [12], a discussion on algorithms to construct the parametric form of a Boolean expression is presented. The use of parametric expressions to make symbolic simulation-based verification efficient is believed to be new.
Reference: 19. <author> Ursula Martin and Tobias Nipkow. </author> <title> Boolean unification the story so far. </title> <journal> Journal of Symbolic Computation, </journal> (7):275-293, 1989. 
Reference-contexts: We study different ways of generating the parametric form from a given constraint. We show that 2 The law of the excluded middle says that 8a : (a _ :a) true SYMBOLIC SIMULATION BASED VERIFICATION USING PARAMETRIC BOOLEAN EXPRESSIONS 4 existing methods such as the Boole's method <ref> [19] </ref>, the Lowenheim's method [20], or the generalized cofactor method (also called "constrain" operator method) [21, 22] give rise to either parametric expressions of progressively increasing sizes, or parametric expressions which are all very large.
Reference: 20. <author> F. M. Brown. </author> <title> Boolean Reasoning. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1990. </year>
Reference-contexts: We show that 2 The law of the excluded middle says that 8a : (a _ :a) true SYMBOLIC SIMULATION BASED VERIFICATION USING PARAMETRIC BOOLEAN EXPRESSIONS 4 existing methods such as the Boole's method [19], the Lowenheim's method <ref> [20] </ref>, or the generalized cofactor method (also called "constrain" operator method) [21, 22] give rise to either parametric expressions of progressively increasing sizes, or parametric expressions which are all very large. <p> Section 4 provides a summary of our results and draws conclusions. 2 Constraint Solving: Algorithms and Implementation Details Two widely used methods for obtaining parametric solutions to Boolean constraints are the Boole's method and the Lowenheim's method <ref> [20] </ref>. Boole's method is based on Shannon's expansion of the constraint formula. It uses the approach of successive elimination of variables involved in the constraint, followed by back substitution. Each parametric expression obtained later during the process of back substitution is larger than the one obtained earlier during back substitution.
Reference: 21. <author> Herve J. Touati, Hamid Savoj, Bill Lin, Robert K. Brayton, and Alberto Sangiovanni-Vincentelli. </author> <title> Implicit state enumeration of finite state machines using bdds. </title> <booktitle> In International Conference on Computer Aided Design, </booktitle> <pages> pages 130-133, </pages> <year> 1990. </year>
Reference-contexts: We show that 2 The law of the excluded middle says that 8a : (a _ :a) true SYMBOLIC SIMULATION BASED VERIFICATION USING PARAMETRIC BOOLEAN EXPRESSIONS 4 existing methods such as the Boole's method [19], the Lowenheim's method [20], or the generalized cofactor method (also called "constrain" operator method) <ref> [21, 22] </ref> give rise to either parametric expressions of progressively increasing sizes, or parametric expressions which are all very large. <p> Another method for generating the parametric form is based on the generalized cofactor <ref> [21] </ref> operator (also called the constraint operator), which was initially proposed by Coudert et al. in [12]. Application of this method for generating the parametric form is now illustrated through an example (for details, see the above references).
Reference: 22. <author> Abhijit Ghosh, Srinivas Devadas, and Richard Newton. </author> <title> Sequential Logic Testing and Verification. </title> <publisher> Kluwer, </publisher> <year> 1992. </year> <note> ISBN 0-7923-9188-8. </note>
Reference-contexts: We show that 2 The law of the excluded middle says that 8a : (a _ :a) true SYMBOLIC SIMULATION BASED VERIFICATION USING PARAMETRIC BOOLEAN EXPRESSIONS 4 existing methods such as the Boole's method [19], the Lowenheim's method [20], or the generalized cofactor method (also called "constrain" operator method) <ref> [21, 22] </ref> give rise to either parametric expressions of progressively increasing sizes, or parametric expressions which are all very large.
Reference: 23. <author> Prabhat Jain, Prabhakar Kudva, and Ganesh Gopalakrishnan. </author> <title> Towards a verification technique for large synchronous circuits. </title> <editor> In G.V.Bochmann and D.K.Probst, editors, </editor> <booktitle> Computer Aided Verification, </booktitle> <pages> pages 109-122. </pages> <note> Springer-Verlag Lecture Notes in Computer Science (LNCS) Number 663, </note> <year> 1993. </year>
Reference-contexts: We have developed a variety of example-specific techniques to deal with circuit constraints using the parametric form. These are discussed in Section 3. 1.2 Overview of Symbolic Simulation Based Verification In our past work <ref> [15, 2, 23] </ref> we have investigated the use of symbolic simulation for verifying MOS circuits. <p> form is also example dependent, although in almost all cases it was negligible compared to the symbolic-simulation time. cofactor method, and our method on two examples: the Minmax circuit (involving constraints C 1 and C 2 ), and a pipelined cache memory (involving constraints C 34 , and detailed in <ref> [23] </ref>). These constraints are over bit-vectors, and involve the recursively defined operators , &gt;, and 6=.
Reference: 24. <author> Kyeongsoon Cho and Randal Bryant. </author> <title> Test pattern generation for sequential mos circuits by symbolic fault simulation. </title> <booktitle> In Proceedings of the 26th ACM/IEEE Design Automation Conference, </booktitle> <year> 1989. </year>
Reference-contexts: Total number of variables is M + dlog 2 N e, where M is the total number of variables in the constraint. Similar encoding techniques have been used in <ref> [24] </ref> to encode various single stuck-at faults, as well as in [25] to encode various multiple stuck-at faults during symbolic fault simulation. 2.2 Solving Bit-vector Constraints Most hardware systems consist of the datapath unit and the controller.
Reference: 25. <author> Noriyuki Takahashi, Nagisa Ishiura, and Shuzo Yajima. </author> <title> Fault simulation for multiple faults using shared bdd representation of fault sets. </title> <booktitle> In International Conference on Computer Aided Design, </booktitle> <pages> pages 550-553, </pages> <year> 1991. </year>
Reference-contexts: Total number of variables is M + dlog 2 N e, where M is the total number of variables in the constraint. Similar encoding techniques have been used in [24] to encode various single stuck-at faults, as well as in <ref> [25] </ref> to encode various multiple stuck-at faults during symbolic fault simulation. 2.2 Solving Bit-vector Constraints Most hardware systems consist of the datapath unit and the controller. The controller bases its actions on external signals it receives and also on decoded datapath conditions.
Reference: 26. <author> K.S. Brace, R.L. Rudell, and R.E. Bryant. </author> <title> Efficient implementation of a BDD package. </title> <booktitle> In Proc. ACM/IEEE 27th Design Automation Conference, </booktitle> <pages> pages 40-45, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The BDD package <ref> [26, 27] </ref> is used for the representation and manipulation of Boolean functions. 2.3 Implementation Details We have developed a language to specify symbolic state transitions which allows the specification of transition constraints and the next-state and output functions.
Reference: 27. <author> Randall E. Bryant. </author> <title> Binary decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <month> Septem-ber </month> <year> 1992. </year> <title> SYMBOLIC SIMULATION BASED VERIFICATION USING PARAMETRIC BOOLEAN EXPRESSIONS 26 </title>
Reference-contexts: The BDD package <ref> [26, 27] </ref> is used for the representation and manipulation of Boolean functions. 2.3 Implementation Details We have developed a language to specify symbolic state transitions which allows the specification of transition constraints and the next-state and output functions.
Reference: 28. <author> D. Verkest and L. Claesen. </author> <title> The minmax system benchmark. </title> <booktitle> In Proceedings of the IMEC-IFIP Workshop on Applied Formal Methods for Correct VLSI Design, </booktitle> <address> Leuven, Belgium, </address> <pages> pages 721-740, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: It is illustrated in detail on the M inmax <ref> [28] </ref> circuit, as well as on a portion of a pipelined set-associative cache memory system. M inmax (figure 2) has three registers, MAXI, MINI, and LASTI. It implements five operations, Iclr_en, Iclr_dis, Idis, Ireset, and Ien.
Reference: 29. <author> Ganesh C. Gopalakrishnan, Richard Fujimoto, Venkatesh Akella, and Narayana Mani. HOP: </author> <title> A process model for synchronous hardware. semantics, and experiments in process composition. Integration: </title> <journal> The VLSI Journal, </journal> <pages> pages 209-247, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: Verification of M inmax proceeds as follows. We first obtain the symbolic state transitions associated with each of its operations separately. (A procedure for automatically inferring the symbolic state transitions from a structural description are described in <ref> [29, 30] </ref>.) In figure 3, we show the symbolic state transition for one of the cases of the Ien operation. Note that the transition is taken if IN &gt; M AX I. The designer of the M inmax circuit exploits a state invariant condition, M AXI M IN I .
Reference: 30. <author> Ganesh C. Gopalakrishnan. HOP: </author> <title> A Formal Model for Synchronous Circuits using Communicating Fundamental-mode Symbolic Automata. </title> <type> Technical Report UUCS TR 90-009, </type> <institution> Dept. of Computer Science, University of Utah, </institution> <address> Salt Lake City, UT 84112, </address> <year> 1992. </year>
Reference-contexts: Verification of M inmax proceeds as follows. We first obtain the symbolic state transitions associated with each of its operations separately. (A procedure for automatically inferring the symbolic state transitions from a structural description are described in <ref> [29, 30] </ref>.) In figure 3, we show the symbolic state transition for one of the cases of the Ien operation. Note that the transition is taken if IN &gt; M AX I. The designer of the M inmax circuit exploits a state invariant condition, M AXI M IN I .
Reference: 31. <author> W.F.Clocksin. </author> <title> Logic programming and digital circuit analysis. </title> <journal> Journal of Logic Programming, </journal> (4):59-82, 1987. 
Reference-contexts: In [15], we wrote Prolog programs capturing the above constraints and obtained "answer substitutions" <ref> [31] </ref>. (Other methods, e.g., [32], are equally applicable.) We obtain sixteen symbolic vectors, some of which are shown below: M I N I 0 = [0; 0; n1; n0] I N 0 = [1; i2; i1; i0] M AXI 0 = [0; 1; m1; m0] M I N I 2 =
Reference: 32. <author> Wolfram Buttner and Helmut Simonis. </author> <title> Embedding boolean expressions into logic programming. </title> <journal> Journal of Symbolic Computation, </journal> (4):191-205, 1987. 
Reference-contexts: In [15], we wrote Prolog programs capturing the above constraints and obtained "answer substitutions" [31]. (Other methods, e.g., <ref> [32] </ref>, are equally applicable.) We obtain sixteen symbolic vectors, some of which are shown below: M I N I 0 = [0; 0; n1; n0] I N 0 = [1; i2; i1; i0] M AXI 0 = [0; 1; m1; m0] M I N I 2 = [0; n2; n1; 0]
Reference: 33. <author> Andrew S. Tanenbaum. </author> <title> Operating Systems: Design and Implementation. </title> <publisher> Prentice Hall, </publisher> <address> Engle-wood Cliffs, NJ, </address> <year> 1987. </year> <note> ISBN 0-13-637406-9. </note>
Reference-contexts: This is discussed in section 3.3.2. We use the Least Recently Used (LRU) priority algorithm, implemented as a two-dimensional array of LRU cells in VLSI, as an example to illustrate our techniques to handle input constraints. One hardware implementation of LRU algorithm <ref> [33] </ref> which we consider here maintains an array of n fi n bits, initially all zeros, for a machine with n page frames. Whenever page k is referenced, the hardware sets all the bits of row k to 1 and sets all the bits of column k to 0.
References-found: 33

