URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-96-1294/CS-TR-96-1294.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-96-1294/
Root-URL: http://www.cs.wisc.edu
Title: APPROACHES TO INTERPROCEDURAL REGISTER ALLOCATION  
Author: By Steven M. Kurlander 
Degree: A thesis submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy (Computer Sciences) at the  
Date: 1996  
Address: WISCONSIN MADISON  
Affiliation: UNIVERSITY OF  
Abstract-found: 0
Intro-found: 1
Reference: [BCKT89] <author> Preston Briggs, Keith D. Cooper, Ken Kennedy, and Linda Torczon. </author> <title> Coloring heuristics for register allocation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 275-284, </pages> <month> July </month> <year> 1989. </year>
Reference: [BDM87] <author> A. D. Berenbaum, D. R. Ditzel, and H. R. McLellan. </author> <title> Architectural innovations in the CRISP microprocessor. </title> <booktitle> In Spring 1987 COMPCON Digest of Papers, </booktitle> <pages> pages 91-95, </pages> <month> February </month> <year> 1987. </year>
Reference-contexts: First, we present architectural solutions and then we present software solutions. 2.1 Architectural Support to Avoid Saving and Restoring Registers Across Calls Architectural solutions have been proposed to reduce or eliminate saving and restoring of registers across procedures calls [Moo85] <ref> [BDM87] </ref> [Hen84]. However, there are drawbacks to each of these approaches. The architecture of the Symbolics 3600 is a modern implementation of a stack-based architecture [Moo85]. <p> A register-based machine can be more flexible, as an instruction can usually access its operands from among several registers. A motivation in the design of the CRISP architecture <ref> [BDM87] </ref> [DM82] was to avoid register saves and restores around procedure calls. CRISP uses a stack cache, which is a set of registers containing the top elements of the stack, which can be accessed efficiently. The stack cache is addressable like memory.
Reference: [Ber91] <author> Dmitri P. Bertsekas. </author> <title> Linear Network Optimization. </title> <publisher> The MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: Let f ij represent a flow from node i 2 N to node j 2 N along arc (i; j) 2 A, and let a ij be the cost of the flow f ij <ref> [Ber91] </ref>. The minimum cost flow problem Dual Variables x j ; y j for j such that c j 2 S Constraints A.1 for c j 2 S, 0 x j ; y j k. <p> As we know the dual minimum cost flow problem has an optimal solution provided it is feasible and bounded, which is true; hence, so does the minimum cost flow problem <ref> [Ber91] </ref>. In fact, the objective functions for each problem are equal.
Reference: [BL92] <author> Thomas Ball and James R. Larus. </author> <title> Optimally profiling and tracing programs. </title> <booktitle> In Proceedings of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 59-70, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: We use profile information to compute the number of calls between each procedure and the number of instructions executed in each procedure. Profile information is gathered using qpt <ref> [BL92] </ref>. When profiling, benchmarks are run on input yielding short execution times, except for benchmarks nasa7 and swm256, in which we have only one input file.
Reference: [BL93] <author> Thomas Ball and James R. Larus. </author> <title> Branch prediction for free. </title> <booktitle> In Proceedings of SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 300-313, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: With a static profile, our allocator's overall performance is competitive with Santhanam and Odnert's allocator. Using the static profiling heuristics of Ball and Larus <ref> [BL93] </ref>, we would expect better results. Steenkiste and Hennessy's allocator is faster (runs in linear-time in the size of the input). Given only static profile information, their allocator seems preferable. performance on the standard input.
Reference: [Cam85] <author> Kathie Cameron. </author> <title> Antichain sequences. </title> <booktitle> Order, </booktitle> <volume> 2(3) </volume> <pages> 249-255, </pages> <year> 1985. </year>
Reference-contexts: Register spilling allows registers to be reassigned along a path in the call graph when profitable. To generate a save-free interprocedural register allocation of a call graph, we utilize Cameron's algorithm for finding a maximum weight k-antichain in a partially ordered set <ref> [Cam85] </ref>. To find a maximum weight k-antichain, Cameron maps solutions from a dual minimum cost flow problem 1 . A dual minimum cost flow problem can be transformed into a minimum cost flow problem and solved in polynomial time. <p> Our solution is based on Cameron's algorithm for finding a maximum weight k-antichain in a partially ordered set <ref> [Cam85] </ref>. In Section 4.2, we generalize our allocation model to compute a minimum cost allocation that may include register spilling across calls in (possibly cyclic) call graphs. For each procedure, we assume an intraprocedural register allocator has already grouped locals that can be assigned the same register. <p> Define a comparability digraph D (T ) as having an edge from u to v when u is less than v in the partial order <ref> [Cam85] </ref>. If S is the set of candidates of a call graph G and the partial order is (v), then D (S) is the interference graph for a save-free interprocedural register allocation of G. <p> In Figure 4.2 (c), fp; tg, fp; vg, fq; vg, and fq; tg are examples of antichains, as the candidates in each set are not joined by an edge in the 37 comparability digraph. A k-antichain is the union of at most k antichains <ref> [Cam85] </ref>. Both fp; t; q; vg and fp; t; vg are 2-antichains. Let S be the set of candidates of a call graph G and assume partial order (v) on S. <p> A k-antichain sequence A = (A 1 ; : : : ; A k ), where A i S, and if c i 2 A p , c j 2 A q , and c i &lt; c j , then p &lt; q <ref> [Cam85] </ref>. Each A i , 1 i k, corresponds to an antichain|if c i &lt; c j , then c i and c j cannot be members of the same antichain. <p> This register ordering models the sequence in which antichains are assigned to candidates. To find a maximum weight k-antichain sequence in a partially ordered set, we solve the following dual minimum cost flow problem <ref> [Cam85] </ref>. Dual Variables x j ; y j for j such that c j 2 S Constraints A.1 for c j 2 S, 0 x j ; y j k. <p> The constant above an edge is the integer upper bound in the corresponding constraint. to the dual minimum cost flow problem, one can prove that for c j 2 S, x j + y j = k + 1 or x j + y j = k <ref> [Cam85] </ref>. If x j + y j = k + 1, then we map c j to the antichain whose number in the sequence equals the value of x j . Otherwise, if x j + y j = k, c j is not mapped to an antichain. <p> To find an interproce-dural register allocation we can solve the dual minimum cost flow problem and apply the inverse function. Our proof is structured similar to Cameron's for proving a bijection from maximum weight k-antichain sequences to a network flow problem <ref> [Cam85] </ref>.
Reference: [Cha82] <author> Gregory J. Chaitin. </author> <title> Register allocation and spilling via graph coloring. </title> <booktitle> In Proceedings of the ACM SIGPLAN '82 Symposium on Compiler Construction, </booktitle> <pages> pages 98-105, </pages> <year> 1982. </year>
Reference-contexts: To estimate the register needs of each procedure, we generate an intraprocedural register allocation. An intraprocedural register allocator may assign registers to live ranges, whose interference relation can be non-transitive <ref> [Cha82] </ref>. The interference relation for interproce-dural register allocation is transitive. When finding an interprocedural register allocation with no register spilling across calls, if procedure P calls Q, then we assign different registers to P and Q. <p> Candidates c u and c v cannot be assigned the same register. Since a partial order defines the interference relation between candidates in a save-free interprocedural register allocation, the interference graph is transitive. The interference graph for intraprocedural register allocation, however, can be non-transitive <ref> [Cha82] </ref>. In an intraprocedural register allocation, two live ranges that interfere are assigned different 36 digraph of the candidates in G. registers. Assume live ranges l a and l b interfere and live ranges l b and l c interfere.
Reference: [CHKW86] <author> F. Chow, M. Himmelstein, E. Killian, and L. Weber. </author> <title> Engineering a RISC compiler system. </title> <booktitle> In Proceedings COMPCON, </booktitle> <pages> pages 132-137, </pages> <month> March </month> <year> 1986. </year> <month> 138 </month>
Reference-contexts: This allows sharing of registers between locals and globals in a subgraph. 1.2 A Comparison of Intraprocedural and Interprocedural Register Allocation By convention some compilers, using intraprocedural register allocation, designate certain registers to be saved by either the caller or callee in a procedure call <ref> [CHKW86] </ref>. Often callee-save registers contain variables that are live across a procedure call. Callee-save registers are saved only once on entrance to a procedure and reloaded upon return from the procedure, instead of spilling the register around each call. Caller-save registers are spilled if they are live across calls. <p> between candidates m and n and edge e, we can assign u and v in P 2 the same registers as m and n, without spilling registers across the call. 4.5 Library Routines We assume that library routines have been pre-compiled using a caller-save/callee-save convention for spilling registers across calls <ref> [CHKW86] </ref>. Any caller-save register live across 51 a call to a library routine must be spilled across the call. To allow for pre-compiled library routines, we create a pseudo library routine that allocates the abstract registers that we will map to the pre-defined caller-save registers.
Reference: [Cho88] <author> Fred C. Chow. </author> <title> Minimizing register usage penalty at procedure calls. </title> <booktitle> In Proceedings of SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 85-94, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Steenkiste and Hennessy's approach may spill registers across frequently executed routines in the internal part of the call graph. The approach to interprocedural register proposed in this thesis considers call frequencies. We are able to avoid spilling registers across frequently executed calls. 2.2.3 Chow's Approach Chow <ref> [Cho88] </ref> presents a one-pass algorithm for interprocedural register allocation. Similar to Steenkiste's algorithm, Chow's algorithm uses a bottom-up traversal over the call graph. However, Chow's algorithm deals with incomplete procedure information, which can result from separate compilation. Chow divides registers into two sets, callee-save registers and caller-save registers.
Reference: [CK91] <author> David Callahan and Brian Koblenz. </author> <title> Register allocation via hierarchical graph coloring. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 192-203, </pages> <month> June </month> <year> 1991. </year>
Reference: [DM82] <author> David R. Ditzel and H. R. McLellan. </author> <title> Register allocation for free: The C machine stack cache. </title> <booktitle> In Proceedings of the SIGARCH/SIGPLAN Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 48-56, </pages> <month> March </month> <year> 1982. </year>
Reference-contexts: A register-based machine can be more flexible, as an instruction can usually access its operands from among several registers. A motivation in the design of the CRISP architecture [BDM87] <ref> [DM82] </ref> was to avoid register saves and restores around procedure calls. CRISP uses a stack cache, which is a set of registers containing the top elements of the stack, which can be accessed efficiently. The stack cache is addressable like memory.
Reference: [GJ79] <author> Michael R. Garey and David S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <year> 1979. </year>
Reference-contexts: Let G c = (V c ; E c ) be an undirected graph. The graph is k-colorable if each node can be assigned one of k colors such that no edge joins two nodes assigned the same color <ref> [GJ79] </ref>. In the IRG problem, let call graph G = (P; E), in which P is the set of procedures and E is the set of call edges.
Reference: [Hen84] <author> John L. Hennessy. </author> <title> VLSI processor architecture. </title> <journal> IEEE Transactions on Computers, </journal> <pages> pages 1221-1246, </pages> <month> December </month> <year> 1984. </year>
Reference-contexts: First, we present architectural solutions and then we present software solutions. 2.1 Architectural Support to Avoid Saving and Restoring Registers Across Calls Architectural solutions have been proposed to reduce or eliminate saving and restoring of registers across procedures calls [Moo85] [BDM87] <ref> [Hen84] </ref>. However, there are drawbacks to each of these approaches. The architecture of the Symbolics 3600 is a modern implementation of a stack-based architecture [Moo85]. <p> One drawback of this approach is that a context switch causes the stack cache to be flushed to memory. A large stack cache can lead to a longer context switch. Register windows <ref> [Hen84] </ref> [HP90] [Pat85] is an approach that tries to avoid saving registers across procedure calls. At each procedure invocation, the callee receives a bank (window) of registers. To allow for parameter passing, the caller's window can overlap with the callee's window.
Reference: [HP90] <author> John L. Hennessy and David A. Patterson. </author> <title> Computer Architecture: A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1990. </year>
Reference-contexts: One drawback of this approach is that a context switch causes the stack cache to be flushed to memory. A large stack cache can lead to a longer context switch. Register windows [Hen84] <ref> [HP90] </ref> [Pat85] is an approach that tries to avoid saving registers across procedure calls. At each procedure invocation, the callee receives a bank (window) of registers. To allow for parameter passing, the caller's window can overlap with the callee's window.
Reference: [KH92] <author> Gerry Kane and Joe Heinrich. </author> <title> MIPS RISC Architecture. </title> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: spilling a register into a temporary is two (one for a load and one for a store), but the cost of spilling a register-allocated global into its home location is four|an extra instruction is needed for both the load and store to form the 32-bit address of its home location <ref> [KH92] </ref>. Calls to setjmp and longjmp require special attention. After executing a longjmp, execution resumes after a previous setjmp. After a setjmp, we load the values of a web's register-allocated globals from their home locations.
Reference: [Moo85] <author> David A. Moon. </author> <title> Architecture of the symbolics 3600. </title> <booktitle> In Proceedings of the 12th Annual International Symposium on Computer Architecture, </booktitle> <pages> pages 76-83, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: First, we present architectural solutions and then we present software solutions. 2.1 Architectural Support to Avoid Saving and Restoring Registers Across Calls Architectural solutions have been proposed to reduce or eliminate saving and restoring of registers across procedures calls <ref> [Moo85] </ref> [BDM87] [Hen84]. However, there are drawbacks to each of these approaches. The architecture of the Symbolics 3600 is a modern implementation of a stack-based architecture [Moo85]. <p> Avoid Saving and Restoring Registers Across Calls Architectural solutions have been proposed to reduce or eliminate saving and restoring of registers across procedures calls <ref> [Moo85] </ref> [BDM87] [Hen84]. However, there are drawbacks to each of these approaches. The architecture of the Symbolics 3600 is a modern implementation of a stack-based architecture [Moo85]. The instruction set includes 0-address instructions, in which an instruction pops all of its operands from the top of the stack, and 1-address instructions, in which one operand can be accessed from within the stack, but the other operands are accessed from the top of the stack.
Reference: [Orl93] <author> James B. Orlin. </author> <title> A faster strongly polynomial minimum cost flow algorithm. </title> <journal> Operations Research, </journal> <volume> 41(2) </volume> <pages> 377-387, </pages> <year> 1993. </year>
Reference-contexts: Letting n be the number of nodes and m be the number of arcs, an unconstrained minimum cost flow problem can be solved in O (n log n (m+n log n) <ref> [Orl93] </ref>, which is independent of k, w j , and s j in our dual minimum cost flow problem.
Reference: [Pat85] <author> David A. Patterson. </author> <title> Reduced instruction set computers. </title> <journal> Communications of the ACM, </journal> <pages> pages 8-21, </pages> <month> January </month> <year> 1985. </year> <month> 139 </month>
Reference-contexts: One drawback of this approach is that a context switch causes the stack cache to be flushed to memory. A large stack cache can lead to a longer context switch. Register windows [Hen84] [HP90] <ref> [Pat85] </ref> is an approach that tries to avoid saving registers across procedure calls. At each procedure invocation, the callee receives a bank (window) of registers. To allow for parameter passing, the caller's window can overlap with the callee's window.
Reference: [PF92] <author> Todd A. Proebsting and Charles N. Fischer. </author> <title> Probabilistic register allocation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992. </year>
Reference: [SH89] <author> Peter A. Steenkiste and John L. Hennessy. </author> <title> A simple interprocedural register allocation algorithm and its effectiveness for LISP. </title> <journal> Transactions on Programming Languages and Systems, </journal> <pages> pages 1-30, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Register-windows can benefit from knowledge of the latter, as it uses the profile only to determine the most frequently referenced locals. Wall found the main advantage of the link time scheme is its ability to keep globals in registers. 2.2.2 Steenkiste and Hennessy's Approach Steenkiste and Hennessy <ref> [SH89] </ref> designed an interprocedural register allocator for LISP programs. Their algorithm allocates registers to locals in a bottom-up fashion over the call 12 graph. They found that LISP programs spend a large amount of time in procedures near the bottom of the call graph (leaf procedures). <p> We then generalize our approach to allow for arbitrary acyclic call graphs. Recursive procedures, which represent cycles in the call graph, can be handled by replacing strongly connected components with a single node <ref> [SH89] </ref>. We also incorporate a heuristic for register spilling around calls to increase the number of candidates that are allocated registers. 3.1 Modeling Interprocedural Register Allocation In the call graph each procedure P i is represented by a node. Assume P i has n children. <p> The numbers in parentheses are the performance increase over our interpro-cedural register allocator without this optimization. Overall, this optimization yields only a slight improvement. Column four shows the results from adding Steenkiste and Hennessy's bottom-up inter-procedural register allocator <ref> [SH89] </ref> to gcc. Running Steenkiste and Hennessy's bottom-up register allocator on xlisp results in a worse allocation than an intraprocedural register allocation. Benchmark xlisp has many routines at the bottom of the call graph called less frequently than routines higher in the call graph.
Reference: [SO90] <author> Vatsa Santhanam and Daryl Odnert. </author> <title> Register allocation across procedure and module boundaries. </title> <booktitle> In Proceedings of SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 28-39, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Our last addition to the network flow-based approach involves modeling register allocation of globals. Wall [Wal86] proposes allocating registers to globals throughout the entire call graph. Wall's model is simple to add to our existing solution for interprocedural register allocation of locals with spilling. Santhanam and Odnert <ref> [SO90] </ref> propose allocating registers 3 to globals over an entire subgraph of the call graph. We further refine their approach by allowing register-allocated globals to be spilled within a subgraph. <p> He also felt 20 general-purpose registers is insufficient to allocate registers to variables to avoid spilling. His algorithm does not use profile information, which can be helpful in choosing where to spill registers. 2.2.4 Santhanam and Odnert's Approach Santhanam and Odnert's approach to interprocedural register allocation <ref> [SO90] </ref> keeps global variables in registers throughout regions of the call graph. This improves upon Wall's approach in which once a global variable is assigned a register, the global variable keeps the register throughout the entire program. Santhanam and Odnert divide the references of each global variable into webs. <p> Our approach is based on Santhanam and Odnert's register allocation of globals <ref> [SO90] </ref>. 7.3.1 Webs For each global Santhanam and Odnert [SO90] partition the call graph into webs. <p> Our approach is based on Santhanam and Odnert's register allocation of globals <ref> [SO90] </ref>. 7.3.1 Webs For each global Santhanam and Odnert [SO90] partition the call graph into webs. A web for a global g is a minimal subgraph of a program call graph such that g is not referenced in a procedure that is either an ancestor or a descendant of the subgraph 2 . <p> We follow a similar approach as <ref> [SO90] </ref> for selecting a set of disjoint webs. Given a web interference graph, we select webs in an ordering based on a priority function. Our approach has a different priority function than [SO90]. <p> We follow a similar approach as <ref> [SO90] </ref> for selecting a set of disjoint webs. Given a web interference graph, we select webs in an ordering based on a priority function. Our approach has a different priority function than [SO90]. Santhanam and Odnert's priority function measures the benefit of allocating registers to globals, but subtracts the cost of loads and stores of these globals at the web entry nodes. Our priority function includes additional costs.
Reference: [[Sp] <institution> Systems Performance Evaluation Cooperative, c/o Waterside Associates, </institution> <address> Fre-mont, CA 1992. </address>
Reference: [Sta93] <author> Richard M. Stallman. </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <month> October </month> <year> 1993. </year>
Reference-contexts: The benefit of an additional register for procedure P k over the current register level r is simply M em [P k ; r] M em [P k ; r + 1]. 3.8 Implementation We implemented our algorithm using gcc <ref> [Sta93] </ref> on a DECstation 5000/125 with a MIPS R3000 processor. <p> Since the profiled code is compiled using only an intraprocedural register allocator, some variables live across calls may not be allocated a register because of an insufficient number of callee-save registers. To determine the number of references to registers that can be live across a call, we modified gcc <ref> [Sta93] </ref> to return the number of register references assuming the non-work registers are callee-save.
Reference: [Wal86] <author> David W. Wall. </author> <title> Global register allocation at link-time. </title> <booktitle> In Proceedings of SIG-PLAN '86 Symposium on Compiler Construction, </booktitle> <pages> pages 264-275, </pages> <month> July </month> <year> 1986. </year>
Reference-contexts: Next, we extend our model of interprocedural register allocation to include register spilling, and revise our network flow formulation. Our last addition to the network flow-based approach involves modeling register allocation of globals. Wall <ref> [Wal86] </ref> proposes allocating registers to globals throughout the entire call graph. Wall's model is simple to add to our existing solution for interprocedural register allocation of locals with spilling. Santhanam and Odnert [SO90] propose allocating registers 3 to globals over an entire subgraph of the call graph. <p> Given the information of the register usage and call frequency, we generate an inter-procedural register allocation. In our approach, we recompile the code with this additional information. However, one could also perform interprocedural register allocation at link time <ref> [Wal86] </ref>. Since library routines are pre-compiled, we assume a fixed calling convention across calls to these routines. In this thesis, we examine the benefit of including library routines in the interprocedural register allocation. <p> Wall found that a fixed-size register window can be inappropriate [Wal88]. 2.2 Software Support for Interprocedural Allocation In this section we examine software solutions to interprocedural register allocation. This research is motivated by Wall's seminal work on global register allocation at link time <ref> [Wal86] </ref>. 10 2.2.1 Wall's Approach Link time allocation allows for information to be used for interprocedural register allocation that otherwise is unavailable under separate compilation. First, the frequently referenced variables can be allocated registers, since the frequency of variable references in all procedures can be estimated at link time. <p> The interprocedural register allocator generates information on the registers that are save-free and spilled. Gcc then reads this information to produce the corresponding inter-procedural allocation. Our interprocedural register allocator could be included as part of a link time allocation as, for example, implemented by Wall <ref> [Wal86] </ref>. 30 benchmark time spent computing allocation as a percentage of total compilation time compress 13.8% decompress 12.0% ear 12.2% eqntott 22.1% ora 29.5% allocation of globals as a percentage of the total compilation time. interprocedural register allocation on library routines, each allocation (including gcc's) spills caller-save registers around library calls. <p> To avoid these loads and stores, a global can be assigned the same register across procedures. An inter procedural register allocator can keep a global in a register without loads and stores at procedure boundaries. Wall <ref> [Wal86] </ref> proposes allocating a register to a global throughout the entire execution 88 of a program. Wall assigns locals and globals to groups and assigns registers to the groups whose members are most frequently referenced. All the members of a group can be assigned the same register.
Reference: [Wal88] <author> David W. Wall. </author> <title> Register windows vs. register allocation. </title> <booktitle> In Proceedings of SIG-PLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 67-78, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: The registers in a window are spilled to make room for the caller's registers. A drawback of implementing register windows is the additional cost and complexity. In addition, procedures need different numbers of registers. Wall found that a fixed-size register window can be inappropriate <ref> [Wal88] </ref>. 2.2 Software Support for Interprocedural Allocation In this section we examine software solutions to interprocedural register allocation. <p> Walls' allocator may not find the best allocation with respect to his model, since he allows infrequently referenced locals to be grouped together with frequently referenced locals. Our interprocedural register allocator with spilling finds allocations of minimum cost. Wall <ref> [Wal88] </ref> compares the performance of register windows to link time allocation. For the register window approach, global variables were not kept in registers. A motivation for register windows is to avoid the interprocedural analysis needed to keep globals in registers. <p> cost flow problem for interprocedural register allocations with 83 spilling, we can treat the dual variables for the edges as we treat the dual variables for the candidates above. 84 Chapter 7 Allocating Registers to Globals Global register candidates include global variables, procedure addresses, and global array and record addresses <ref> [Wal88] </ref>. Allocating registers to global candidates is less straightforward than allocating registers to local ones. Let procedures P and Q reference global variable g (see Figure 7.1). Assume an intraprocedural register allocator assigns g a register in P and Q.
Reference: [Wal91] <author> David W. Wall. </author> <title> Predicting program behavior using real or estimated profiles. </title> <booktitle> In Proceedings of SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 59-70, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: With a bottom-up allocation, registers are spilled across the more frequently executed calls. The final column shows the performance of our minimum cost interprocedural register allocator with the postpass and static profiling. We use the call+1-loop (10) estimate proposed by Wall <ref> [Wal91] </ref>. For a procedure invocation an instruction contributes 10 d to the execution count, in which d is the instruction's loop-nesting level within the procedure. Each procedure is called one plus the static number of calls to the procedure.
Reference: [Zak95] <author> Armand Zakarian. </author> <type> Private communication. </type> <institution> University of Wisconsin|Madison, </institution> <month> February </month> <year> 1995. </year>
Reference-contexts: To solve the dual minimum cost flow problem for interprocedural register allocation with spills, the problem is transformed into a minimum cost flow problem. Solutions to the minimum cost flow problem are found using the primal network simplex method <ref> [Zak95] </ref>. Though the primal network simplex method is exponential in the worst case, we found it faster in practice than a polynomial time dual network simplex algorithm available to us. total compilation time without interprocedural register allocation. <p> We transform the equations represented by Table 6.1 into an equivalent set of equations that describes the minimum cost flow problem given above <ref> [Zak95] </ref>. We perform three transformations. As a flow adds to the divergence of one node and subtracts from the divergence of another, we want each column to have a single 1 and a single -1. We can multiply rows y p and y q by -1.
References-found: 27

