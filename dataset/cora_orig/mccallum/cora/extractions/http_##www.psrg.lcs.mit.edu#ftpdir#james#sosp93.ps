URL: http://www.psrg.lcs.mit.edu/ftpdir/james/sosp93.ps
Refering-URL: http://www.psrg.lcs.mit.edu/publications.html
Root-URL: 
Email: otoole@lcs.mit.edu, nettles@cs.cmu.edu, gif-ford@lcs.mit.edu.  
Phone: 02139.  
Title: Concurrent Compacting Garbage Collection of a Persistent Heap  Figure 1: The Transactional Heap Interface  
Author: James O'Toole Scott Nettles David Gifford 
Address: 545 Technology Square, Cambridge, MA  5000 Forbes Avenue, Pittsburgh, PA 15213.  
Affiliation: of Computer Science, Massachusetts Insitute of Technology,  School of Computer Science, Carnegie Mellon University,  
Note: Authors' addresses:  Laboratory  This research was sponsored by the Avionics Lab, Wright Research and Development Center, Aeronautical Systems Division (AFSC), U. S. Air Force, Wright-Patterson AFB, OH 45433-6543 under Contract F33615-90-C-1465, Arpa Order No. 7597, by the Air Force Systems Command, by the Advanced Research Projects Agency under Contract F19628-91-C-0128, and by the Department of the Army under Contract DABT63-92-C-0012.  
Abstract: We describe a replicating garbage collector for a persistent heap. The garbage collector cooperates with a transaction manager to provide safe and efficient transactional storage management. Clients read and write the heap in primary memory and can commit or abort their write operations. When write operations are committed they are preserved in stable storage and survive system failures. Clients can freely access the heap during garbage collection because the collector concurrently builds a compact replica of the heap. A log captures client write operations and is used to support both the transaction manager and the replicating garbage collector. Our implementation is the first to provide concurrent and compacting garbage collection of a persistent heap. Measurements show that concurrent replicating collection produces significantly shorter pause times than stop-and-copy collection. For small transactions, throughput is limited by the logging bandwidth of the underlying log manager. The results suggest that replicating garbage collection offers a flexible and efficient way to provide automatic storage management in transaction systems, object-oriented databases and persistent programming environments. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Guy T. Almes. </author> <title> Garbage Collection in a Object-Oriented System. </title> <type> Technical Report CMU-CS-80-128, </type> <institution> Carnegie Mellon University, </institution> <month> June </month> <year> 1980. </year>
Reference-contexts: Garbage collection algorithms based on replication appear in work by Nettles and O'Toole [16, 17, 19], and an instance of the basic technique is also described by Huelsbergen and Larus [13]. We are aware of only one other implementation of a concurrent collector for a persistent heap. Almes <ref> [1] </ref> designed and implemented a mark-and-sweep collector for use in the Hydra OS for C.mmp. The collector is based on Dijkstra's concurrent mark-and-sweep algorithm [11]. There are two key differences between this work and our own.
Reference: [2] <author> A. Appel. </author> <title> Simple Generational Garbage Collection and Fast Allocation. </title> <journal> Software-Practice and Experience, </journal> <volume> 19(2) </volume> <pages> 171-183, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: The purpose of the prototype implementation was to test the feasibility of our design. Standard ML of New Jersey (SML/NJ) is an implementation of a type-safe programming language that includes an optimizing compiler, a runtime system, and a generational garbage collector <ref> [2] </ref>. The SML/NJ source code is freely available and is easy to modify for experimental purposes. We chose to test our garbage collection algorithm in the SML/NJ environment primarily for reasons of convenience.
Reference: [3] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time Concurrent Garbage Collection on Stock Multiprocessors. </title> <booktitle> In SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 11-20, </pages> <year> 1988. </year>
Reference-contexts: The effects of replication are unobservable by the client, so it continues to operate on the original objects in from-space. This differs from other concurrent compacting collection algorithms, which require the client to operate on objects in to-space <ref> [5, 3] </ref>. Because the client and the collector execute concurrently, the replicas become inconsistent when the client modifies the original objects. To solve this problem, the client records all write operations in a redo log, shown in Figure 2. <p> These collectors require the client to access the to-space version of an object during collections and sometimes force objects to be copied so that the client may access them. The technique of Ellis, Li, and Appel <ref> [3] </ref> enforces this restriction by using virtual memory protection traps to detect certain client accesses and perform required collector work. In contrast, our technique does not constrain the order in which objects are copied nor does it require any special operating system support.
Reference: [4] <author> M. P. Atkinson, K. J. Chisolm, and W. P. Cockshott. </author> <title> PS-Algol: an Algol with a persistent heap. </title> <journal> SIGPLAN Notices, </journal> <volume> 17(7) </volume> <pages> 24-31, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: No deallocation operation is exposed to the clients. Instead, objects that the clients can access by dereferencing pointers starting from either root are considered live and will be preserved by the system. A garbage collector will identify unreachable objects and recycle their storage. Our interface provides orthogonal persistence <ref> [4] </ref>: objects that are reachable via the persistent root are guaranteed to survive system failures. In Figure 1, the stability of the persistent root and the stable heap to which it points are indicated by their gray background. <p> Discussions of persistent heaps and language support for transactions appear in work on Persistent Algol <ref> [4] </ref> and Argus [15]. Garbage collection algorithms based on replication appear in work by Nettles and O'Toole [16, 17, 19], and an instance of the basic technique is also described by Huelsbergen and Larus [13].
Reference: [5] <author> H. G. Baker. </author> <title> List Processing in Real Time on a Serial Computer. </title> <journal> Communications of the ACM, </journal> <volume> 21(4) </volume> <pages> 280-294, </pages> <year> 1978. </year>
Reference-contexts: The effects of replication are unobservable by the client, so it continues to operate on the original objects in from-space. This differs from other concurrent compacting collection algorithms, which require the client to operate on objects in to-space <ref> [5, 3] </ref>. Because the client and the collector execute concurrently, the replicas become inconsistent when the client modifies the original objects. To solve this problem, the client records all write operations in a redo log, shown in Figure 2. <p> The EOS design proposes to combine a marking process and a compaction process. An implementation of EOS is underway but details are not available at this time. There is a long history of incremental and concurrent copying collectors dating back to Baker <ref> [5] </ref>. These collectors require the client to access the to-space version of an object during collections and sometimes force objects to be copied so that the client may access them.
Reference: [6] <author> R. G. G. Cattell. </author> <title> An Engineering Database Benchmark. </title> <editor> In Jim Gray, editor, </editor> <booktitle> The Benchmark Handbook for Database and Transaction Processing Systems, </booktitle> <pages> pages 247-281. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: This 100,000 line program is compute-intensive and contains long-running transactions. * The TP-OO1-V benchmark is a variant of the OO1 En--gineering Database benchmark described by Cattell <ref> [6] </ref>. The benchmark models an engineering application using a database of parts, performing traversals of the database, adding parts, etc. We implemented this algorithm in order to have a representative object-oriented database application.
Reference: [7] <author> Eric Cooper, Scott Nettles, and Indira Subramanian. </author> <title> Improving the Performance of SML Garbage Collection using Application-Specific Virtual Memory Management. </title> <booktitle> In Proceedings of the ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 43-52, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: It would be much more efficient to discard these log records instead. Garbage collectors sometimes benefit from similar features in data caches and virtual memory systems <ref> [7] </ref>. When the garbage collector reclaims a semi-space it is better that cache lines and virtual memory pages that contain reclaimed data be reset to a zero-fill-on-demand status because there is no need for the underlying memory system to preserve their old contents.
Reference: [8] <editor> Transactions Processing Council. TPC-B. In Jim Gray, editor, </editor> <booktitle> The Benchmark Handbook for Database and Transaction Processing Systems, </booktitle> <pages> pages 79-114. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1991. </year>
Reference-contexts: This benchmark is our slightly nonstandard implementation in Standard ML of the TPC-B benchmark from Gray <ref> [8] </ref>. 5.2 Experimental Setup All benchmarks were executed on a Silicon Graphics 4D/340 equipped with 256 megabytes of physical memory. The clock resolution on this system is 1 millisecond. The machine contains four MIPS R3000 processors clocked at 33 megahertz.
Reference: [9] <author> D. L. Detlefs, M. P. Herlihy, and J. M. Wing. </author> <title> Inheritance of Synchronization and Recovery Properties in Avalon/C++. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 57-69, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: There are two earlier designs of concurrent copying garbage collectors for persistent heaps, both based on the Ellis, Li, and Appel algorithm. Detlefs [10] described how to apply this algorithm in the transactional environment of Avalon/C++ <ref> [9] </ref>, while Kolodner [14] worked in the context of Argus. In Detlefs's design, the programmer must explicitly manage object persistence at the time of allocation; Kolodner supports orthogonal persistence. Neither of these designs was completely implemented.
Reference: [10] <author> David L. Detlefs. </author> <title> Concurrent, atomic garbage collection. </title> <type> Technical Report CMU-CS-90-177, </type> <institution> Carnegie Mellon University, </institution> <month> October </month> <year> 1990. </year>
Reference-contexts: We believe that the ability to freely choose the traversal order is especially important in systems that may need to optimize access to the disk. There are two earlier designs of concurrent copying garbage collectors for persistent heaps, both based on the Ellis, Li, and Appel algorithm. Detlefs <ref> [10] </ref> described how to apply this algorithm in the transactional environment of Avalon/C++ [9], while Kolodner [14] worked in the context of Argus. In Detlefs's design, the programmer must explicitly manage object persistence at the time of allocation; Kolodner supports orthogonal persistence. Neither of these designs was completely implemented.
Reference: [11] <author> E. Dijkstra, L. Lamport, A. Martin, C. Scholten, and E. Steffens. </author> <title> On-the-fly Garbage Collection:An Exercise in Cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: We are aware of only one other implementation of a concurrent collector for a persistent heap. Almes [1] designed and implemented a mark-and-sweep collector for use in the Hydra OS for C.mmp. The collector is based on Dijkstra's concurrent mark-and-sweep algorithm <ref> [11] </ref>. There are two key differences between this work and our own. First, it cannot relocate objects and therefore offers no opportunities for heap compaction or clustering of objects for fast access.
Reference: [12] <author> Olivier Gruber. Eos: </author> <title> An Environment for Persistent and Distributed Applications in a Shared Object Space. host ftp.inria.fr directory INRIA/Projects/RODIN file Olivier.Gruber.phd.ps.Z, </title> <month> December </month> <year> 1992. </year>
Reference-contexts: Because of the rather unusual environment in which it operated, we cannot make any performance comparison between it and our work. We have recently learned of ongoing work in the EOS system <ref> [12] </ref>. The EOS design proposes to combine a marking process and a compaction process. An implementation of EOS is underway but details are not available at this time. There is a long history of incremental and concurrent copying collectors dating back to Baker [5].
Reference: [13] <author> Lorenz Huelsbergen and James R. Larus. </author> <title> A Concurrent Copying Garbage Collector for Languages that Distinguish (Im)mutable Data. </title> <booktitle> In Proceedings of the 1993 ACM Symposiym on Principles and Practice of Parallel Programming, </booktitle> <year> 1993. </year>
Reference-contexts: Discussions of persistent heaps and language support for transactions appear in work on Persistent Algol [4] and Argus [15]. Garbage collection algorithms based on replication appear in work by Nettles and O'Toole [16, 17, 19], and an instance of the basic technique is also described by Huelsbergen and Larus <ref> [13] </ref>. We are aware of only one other implementation of a concurrent collector for a persistent heap. Almes [1] designed and implemented a mark-and-sweep collector for use in the Hydra OS for C.mmp. The collector is based on Dijkstra's concurrent mark-and-sweep algorithm [11].
Reference: [14] <author> Eliot K. Kolodner. </author> <title> Atomic Incremental Garbage Collection and Recovery for a Large Stable Heap. </title> <type> Technical Report MIT/LCS/TR-534, </type> <institution> Massachusetts Institute of Technology, </institution> <month> February </month> <year> 1992. </year>
Reference-contexts: There are two earlier designs of concurrent copying garbage collectors for persistent heaps, both based on the Ellis, Li, and Appel algorithm. Detlefs [10] described how to apply this algorithm in the transactional environment of Avalon/C++ [9], while Kolodner <ref> [14] </ref> worked in the context of Argus. In Detlefs's design, the programmer must explicitly manage object persistence at the time of allocation; Kolodner supports orthogonal persistence. Neither of these designs was completely implemented. We believe this is due to the complexity of using the to-space invariant in a transactional setting.
Reference: [15] <author> B. Liskov and R. Scheifler. </author> <title> Guardians and Actions: Linguistic Support for Robust, Distributed Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 382-404, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: Discussions of persistent heaps and language support for transactions appear in work on Persistent Algol [4] and Argus <ref> [15] </ref>. Garbage collection algorithms based on replication appear in work by Nettles and O'Toole [16, 17, 19], and an instance of the basic technique is also described by Huelsbergen and Larus [13]. We are aware of only one other implementation of a concurrent collector for a persistent heap.
Reference: [16] <author> Scott M. Nettles and James W. O'Toole. </author> <title> Real-Time Replication Garbage Collection. </title> <booktitle> In SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 217-226. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: Good performance can be achieved by using battery-protected random access memory to implement high speed stable storage. While the client operates on the heap, a replicating garbage collector concurrently builds a compact replica of it. Replicating garbage collection <ref> [16] </ref> is a new technique for building incremental and concurrent garbage collectors. The key idea of replicating garbage collection is to copy objects non-destructively. As in any copying garbage collection algorithm, the collector copies the reachable objects from the from-space to the to-space. <p> The SML/NJ source code is freely available and is easy to modify for experimental purposes. We chose to test our garbage collection algorithm in the SML/NJ environment primarily for reasons of convenience. Our previous work on persistence [18] and replicating garbage collection <ref> [16, 17, 19] </ref> using ML provided us with several of the components needed for our prototype. The SML/NJ runtime system is similar to most language implementations with copying garbage collection. <p> Discussions of persistent heaps and language support for transactions appear in work on Persistent Algol [4] and Argus [15]. Garbage collection algorithms based on replication appear in work by Nettles and O'Toole <ref> [16, 17, 19] </ref>, and an instance of the basic technique is also described by Huelsbergen and Larus [13]. We are aware of only one other implementation of a concurrent collector for a persistent heap. Almes [1] designed and implemented a mark-and-sweep collector for use in the Hydra OS for C.mmp.
Reference: [17] <author> Scott M. Nettles, James W. O'Toole, David Pierce, and Nicholas Haines. </author> <title> Replication-Based Incremental Copying Collection. </title> <booktitle> In Proceedings of the SIGPLAN International Workshop on Memory Management, </booktitle> <pages> pages 357-364. </pages> <publisher> ACM, Springer-Verlag, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: The SML/NJ source code is freely available and is easy to modify for experimental purposes. We chose to test our garbage collection algorithm in the SML/NJ environment primarily for reasons of convenience. Our previous work on persistence [18] and replicating garbage collection <ref> [16, 17, 19] </ref> using ML provided us with several of the components needed for our prototype. The SML/NJ runtime system is similar to most language implementations with copying garbage collection. <p> Discussions of persistent heaps and language support for transactions appear in work on Persistent Algol [4] and Argus [15]. Garbage collection algorithms based on replication appear in work by Nettles and O'Toole <ref> [16, 17, 19] </ref>, and an instance of the basic technique is also described by Huelsbergen and Larus [13]. We are aware of only one other implementation of a concurrent collector for a persistent heap. Almes [1] designed and implemented a mark-and-sweep collector for use in the Hydra OS for C.mmp.
Reference: [18] <author> S.M. Nettles and J.M. Wing. </author> <title> Persistance + Undoability = Transactions. </title> <booktitle> In Proceedings of the 25th Hawaii International Conference on System Sciences, </booktitle> <volume> volume 2, </volume> <pages> pages 832-843. </pages> <publisher> IEEE, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: The SML/NJ source code is freely available and is easy to modify for experimental purposes. We chose to test our garbage collection algorithm in the SML/NJ environment primarily for reasons of convenience. Our previous work on persistence <ref> [18] </ref> and replicating garbage collection [16, 17, 19] using ML provided us with several of the components needed for our prototype. The SML/NJ runtime system is similar to most language implementations with copying garbage collection.
Reference: [19] <author> James W. O'Toole and Scott M. Nettles. </author> <title> Concurrent Replication Garbage Collection. </title> <institution> Technical Report MIT-LCS-TR-570 and CMU-CS-93-138, Massachusetts Institute of Technology and Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: The SML/NJ source code is freely available and is easy to modify for experimental purposes. We chose to test our garbage collection algorithm in the SML/NJ environment primarily for reasons of convenience. Our previous work on persistence [18] and replicating garbage collection <ref> [16, 17, 19] </ref> using ML provided us with several of the components needed for our prototype. The SML/NJ runtime system is similar to most language implementations with copying garbage collection. <p> Discussions of persistent heaps and language support for transactions appear in work on Persistent Algol [4] and Argus [15]. Garbage collection algorithms based on replication appear in work by Nettles and O'Toole <ref> [16, 17, 19] </ref>, and an instance of the basic technique is also described by Huelsbergen and Larus [13]. We are aware of only one other implementation of a concurrent collector for a persistent heap. Almes [1] designed and implemented a mark-and-sweep collector for use in the Hydra OS for C.mmp.
Reference: [20] <author> M. Satyanarayanan, Henry H. Mashburn, Puneet Ku-mar, David C. Steere, and James J. Kistler. </author> <title> Lightweight Recoverable Virtual Memory. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: To achieve this our implementation uses the Recoverable Virtual Memory system described by Satyanarayanan, et al. <ref> [20] </ref> RVM provides simple non-nested transactions on byte arrays and uses a disk-based log for efficiency. We do not exploit the rollback features of RVM at all; in our implementation, RVM provides only disk logging and recovery services. <p> Note that this database size is smaller than the TPC-B guidelines require for a system claiming 80 transactions per second. We believe that we have complied with all other requirements of the benchmark standard. Although we have not done a careful comparison, a similar RVM benchmark <ref> [20] </ref> also executed approximately 80 transactions per second on our machine. When the TPC-B benchmark is completing 80 transactions per second, each transaction requires 12.5 milliseconds of processing. We measured our system to determine how those 12.5 milliseconds were being used. <p> Recently the designers of RVM have begun the implementation of an incremental log truncation mechanism <ref> [20] </ref>. This new feature will subtly change the semantics of RVM. Currently the only changes to virtual memory that RVM applies to stable storage are the changes that the client explicitly logs via the RVM interface.
Reference: [21] <author> Paul R. Wilson. </author> <title> Uniprocessor Garbage Collection Techniques. </title> <booktitle> In Proceedings of the 1992 SIGPLAN International Workshop on Memory Management, </booktitle> <pages> pages 1-42. </pages> <publisher> ACM, Springer-Verlag, </publisher> <month> September </month> <year> 1992. </year>
Reference-contexts: RVM recovery must perform disk operations to reconstruct the committed contents of the stable heap from its stable log, 6 Related Work The basic literature on uniprocessor garbage collection techniques is surveyed by Wilson <ref> [21] </ref>. Discussions of persistent heaps and language support for transactions appear in work on Persistent Algol [4] and Argus [15].
Reference: [22] <author> J.M. Wing, M. Faehndrrich, N. Haines, K. Kietzke, D. Kindred, J.G. Morrisett, and S.M. Nettles. </author> <title> Ve-nari/ML Interfaces and Examples. </title> <type> Technical Report CMU-CS-93-123, </type> <institution> Carnegie Mellon University, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: Our collector can be made recoverable at the cost of added log traffic, but for many applications this may not be necessary. 7 Future Work We expect to support multiple client threads by using the Venari transaction model <ref> [22] </ref>. We plan to examine closely the remaining sources of delay in the pauses due to the concurrent collector. We also plan to experiment with a few simple optimizations that may compress the logs.
Reference: [23] <author> Benjamin Zorn. </author> <title> The Measured Cost of Conservative Garbage Collection. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 23(7) </volume> <pages> 733-756, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Permanent data storage management should meet the much higher safety standard achieved by tracing garbage collection. Modern garbage collectors are very efficient and can often be competitive with explicit deallocation <ref> [23] </ref>. However, existing garbage collectors are not practical for use in systems applications. Existing implementations either stop the client while garbage collecting or do not maintain a heap image that is resilient to system failure. We have designed and implemented the first concurrent compacting garbage collector for a persistent heap.
References-found: 23

