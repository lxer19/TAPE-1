URL: ftp://coast.cs.purdue.edu/pub/doc/authentication/Derek_Atkins-Charon.ps.Z
Refering-URL: http://www.cs.purdue.edu/coast/archive/data/categ9.html
Root-URL: http://www.cs.purdue.edu
Title: Charon: Kerberos TM Extensions For Authentication Over Secondary Networks  Network Manager  
Author: by Derek A. Atkins Jeffrey I. Schiller Leonard A. Gould 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Bachelor of Science in Electrical Science and Engineering at the  c Derek A. Atkins, MCMXCIII. All rights reserved. The author hereby grants to MIT permission to reproduce and to distribute copies of this thesis document in whole or in part, and to grant others the right to do so. Author  Certified by  Thesis Supervisor Accepted by  Chairman, Departmental Committee on Graduate Students  
Date: May 1993  May 7, 1993  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> E. J. Berkenbilt. Rkinit. Personal Communique, </author> <month> November </month> <year> 1989. </year>
Reference-contexts: This protocol is depicted in figure 2-2. 2.4 The Wire Protocol Although I took some of the ideas for my protocol from rkinit <ref> [1] </ref>, the Charon protocol has been enhanced to meet the requirements of the assumptions placed upon it. Like its predecessor, data is sent in packetized units. A packet consists of a "type byte", a length, and the data. <p> realm *= (void) strncpy (rlm,ptr, sizeof (rlm)); rlm [sizeof (rlm)1] = '"0'; ptr += strlen (rlm) + 1; =* extract ticket lifetime, server key version, ticket length *= =* be sure to avoid sign extension on lifetime! *= 90 lifetime = (unsigned char) ptr [0]; kvno = (unsigned char) ptr <ref> [1] </ref>; tkt&gt;length = (unsigned char) ptr [2]; ptr += 3; if ((tkt&gt;length &lt; 0) jj ((tkt&gt;length + (ptr (char *) cip&gt;dat)) &gt; cip&gt;length)) return (CRN BADPW); =* extract ticket itself *= 100 COPY (ptr,(tkt&gt;dat),tkt&gt;length); ptr += tkt&gt;length; =* Pass KDC time stamp I'm using the Cookie to verify it. *= ptr <p> int retval; u int count, encodedlen; =* First, read the packet type byte (should only be one character) *= if ((retval = crn read line (type, sizeof (type))) != 1) return (CRN BAD PACKET); =* This is special, since I really do know the IA5 encoding scheme here *= type <ref> [1] </ref> = type [2] = type [3] = '='; 250 type [4] = '"0'; =* Decode the typebyte, and get the llen *= encodedlen = 5; if ((retval = ia5 decode data (type, 4, &type byte, &encodedlen)) != CRN OK) return (retval); *datatype = PKT TYPE (type byte); llen = PKT <p> char length [4]; u int count, encodedlen; =* First, read the packet type byte (should only be one character) *= 370 if ((crn read line (type, sizeof (type))) != 1) return (CRN BAD PACKET); =* This is special, since I really do know the IA5 encoding scheme here *= type <ref> [1] </ref> = type [2] = type [3] = '='; type [4] = '"0'; =* Decode the typebyte, and get the llen *= encodedlen = 4; type byte = 0; 380 if ((retval = ia5 decode data (type, 4, &type byte, &encodedlen)) != CRN OK) return (retval); *datatype = PKT TYPE (type
Reference: [2] <author> J. G. Steiner, B. C. Neuman, and J. I. Schiller. </author> <title> Kerberos: An Authentication Service for Open Network Systems. </title> <booktitle> In Usenix Conference Proceedings, </booktitle> <pages> pages 191-202, </pages> <address> Dallas, Texas, </address> <month> February, </month> <year> 1988. </year>
Reference-contexts: The only entities that know these secrets are the owner (i.e., the user or the service-providing machine) and the Kerberos Server. In other words, the key is a "shared secret" between the named entity and the Kerberos Server <ref> [2, 5] </ref>. The Kerberos Server, also called the Key Distribution Center (or KDC), has the job of issuing tickets to users. A ticket is a cryptographic block that a user can present to a service provider to prove the user's identity. <p> (rlm)); rlm [sizeof (rlm)1] = '"0'; ptr += strlen (rlm) + 1; =* extract ticket lifetime, server key version, ticket length *= =* be sure to avoid sign extension on lifetime! *= 90 lifetime = (unsigned char) ptr [0]; kvno = (unsigned char) ptr [1]; tkt&gt;length = (unsigned char) ptr <ref> [2] </ref>; ptr += 3; if ((tkt&gt;length &lt; 0) jj ((tkt&gt;length + (ptr (char *) cip&gt;dat)) &gt; cip&gt;length)) return (CRN BADPW); =* extract ticket itself *= 100 COPY (ptr,(tkt&gt;dat),tkt&gt;length); ptr += tkt&gt;length; =* Pass KDC time stamp I'm using the Cookie to verify it. *= ptr += 4; =* initialize ticket cache, <p> int count, encodedlen; =* First, read the packet type byte (should only be one character) *= if ((retval = crn read line (type, sizeof (type))) != 1) return (CRN BAD PACKET); =* This is special, since I really do know the IA5 encoding scheme here *= type [1] = type <ref> [2] </ref> = type [3] = '='; 250 type [4] = '"0'; =* Decode the typebyte, and get the llen *= encodedlen = 5; if ((retval = ia5 decode data (type, 4, &type byte, &encodedlen)) != CRN OK) return (retval); *datatype = PKT TYPE (type byte); llen = PKT LLENGTH (type byte); <p> u int count, encodedlen; =* First, read the packet type byte (should only be one character) *= 370 if ((crn read line (type, sizeof (type))) != 1) return (CRN BAD PACKET); =* This is special, since I really do know the IA5 encoding scheme here *= type [1] = type <ref> [2] </ref> = type [3] = '='; type [4] = '"0'; =* Decode the typebyte, and get the llen *= encodedlen = 4; type byte = 0; 380 if ((retval = ia5 decode data (type, 4, &type byte, &encodedlen)) != CRN OK) return (retval); *datatype = PKT TYPE (type byte); llen =
Reference: [3] <author> J. Linn. </author> <title> Privacy Enhancement for Internet Electronic Mail: Part I: Message Encryption and Authentication Procedures. </title> <type> RFC 1421, </type> <month> February </month> <year> 1993. </year>
Reference-contexts: This is done so that different architectures can share data even if they represent numbers differently. In addition, before the raw data is transferred, it should be converted to the IA5 alphabet in the encoding scheme described in RFC 1421 <ref> [3] </ref>. This encoding takes a block of 1-3 bytes of data, and converts it, always, to 4 bytes of encoded data. See appendix A.3 for more information on the IA5 encoding scheme. <p> =* First, read the packet type byte (should only be one character) *= if ((retval = crn read line (type, sizeof (type))) != 1) return (CRN BAD PACKET); =* This is special, since I really do know the IA5 encoding scheme here *= type [1] = type [2] = type <ref> [3] </ref> = '='; 250 type [4] = '"0'; =* Decode the typebyte, and get the llen *= encodedlen = 5; if ((retval = ia5 decode data (type, 4, &type byte, &encodedlen)) != CRN OK) return (retval); *datatype = PKT TYPE (type byte); llen = PKT LLENGTH (type byte); =* Read in <p> encodedlen; =* First, read the packet type byte (should only be one character) *= 370 if ((crn read line (type, sizeof (type))) != 1) return (CRN BAD PACKET); =* This is special, since I really do know the IA5 encoding scheme here *= type [1] = type [2] = type <ref> [3] </ref> = '='; type [4] = '"0'; =* Decode the typebyte, and get the llen *= encodedlen = 4; type byte = 0; 380 if ((retval = ia5 decode data (type, 4, &type byte, &encodedlen)) != CRN OK) return (retval); *datatype = PKT TYPE (type byte); llen = PKT LLENGTH (type
Reference: [4] <institution> National Bureau of Standards, </institution> <address> Washington, D.C. </address> <note> Data Encryption Standard, Federal Information Processing Standards Publication 46 edition, 1977. </note> <institution> Government Printing Office. </institution>
Reference-contexts: Kerberos makes a number of assumptions of the machines and network it wants to secure 1 . One assumption is that all decryption of tickets is done locally on the client machine. This means that the client must have enough computing power to do a Data Encryption Standard (DES) <ref> [4] </ref> decryption in a reasonable amount of time. Another assumption in the MIT implementation of Kerberos is that a client must be able to speak directly to the Kerberos Server in order to obtain tickets. <p> *)charon&gt;data, charon&gt;datalen)); g =* Table Procedure Call to send version to other side. *= 130 static int SendVersionInfo (charon t *charon) f return (SendVersion (charon&gt;mode, charon&gt;version)); g =* Effects: Sends the version across to the other side *= static int SendVersion (int mode, int version) 140 f u char data <ref> [4] </ref>; int retval; int2octet (version, data); if (mode == CLIENT MODE) retval = crn send data (data, 4, PKT CVERSION); else retval = crn send data (data, 4, PKT SVERSION); 150 return (retval); g =* Modifies: charon * Effects: sets version to the minimum of version, and the * version of <p> tgt enc data; if ((tgt data.app length = krb mk priv (charon&gt;tgt&gt;dat, tgt data.app data, charon&gt;tgt&gt;length, sched, key, &charon&gt;saddr, &charon&gt;saddr)) == 1) f return (CRN MK PRIV); g 350 =* Encrypt the cookie in this session key *= cookie data.app data = cookie enc data; COPY (charon&gt;cookie, cookie, 4); cookie <ref> [4] </ref> = charon&gt;cli encrypt; if ((cookie data.app length = krb mk priv (cookie, cookie data.app data, 5, sched, key, &charon&gt;saddr, &charon&gt;saddr)) == 1) f return (CRN MK PRIV); g 360 if ((retval = crn rpc sendauth (&auth)) != CRN OK) return (retval); if ((retval = crn rpc senddat (&tgt data)) != <p> (CRN ERR COOKIE); 500 g =* Compare the cookie to make sure they are the same! *= if (CMP (msg data.app data, charon&gt;cookie, 4)) f crn set errbuf ("Cookie Mismatch."); return (CRN ERR COOKIE); g =* Set the value of the encryption flag *= charon&gt;cli encrypt = msg data.app data <ref> [4] </ref>; 510 g else f sprintf (errbuf, "%s in krb_rd_priv of cookie", error message (ERROR TABLE BASE krb+status)); crn set errbuf (errbuf); return (status); g return (CRN OK); g 520 A.2 crn err.c =* crn err.c this file deals with charon errors. <p> It will allocate enough data for the packet * and return the packet type to the caller. *= crn wait for data (u char **data, u int *datalen, u char *datatype) f u char type byte; int llen; char type [5]; char enc length [9]; 240 u char length <ref> [4] </ref>; int retval; u int count, encodedlen; =* First, read the packet type byte (should only be one character) *= if ((retval = crn read line (type, sizeof (type))) != 1) return (CRN BAD PACKET); =* This is special, since I really do know the IA5 encoding scheme here *= type <p> type byte (should only be one character) *= if ((retval = crn read line (type, sizeof (type))) != 1) return (CRN BAD PACKET); =* This is special, since I really do know the IA5 encoding scheme here *= type [1] = type [2] = type [3] = '='; 250 type <ref> [4] </ref> = '"0'; =* Decode the typebyte, and get the llen *= encodedlen = 5; if ((retval = ia5 decode data (type, 4, &type byte, &encodedlen)) != CRN OK) return (retval); *datatype = PKT TYPE (type byte); llen = PKT LLENGTH (type byte); =* Read in the length field *= 260 <p> and send * that to the output file. * Returns 0 on success, or an error code, otherwise *= 290 crn send data (u char *data, u int datalen, u char datatype) f u char type byte; int llen, retval; char type [5]; char enc length [9]; u char length <ref> [4] </ref>; char *coded data; u int count, encodedlen; 300 =* Encoded the length into an octet *= int2octet (datalen, length); llen = 4; if (datalen &lt; 0x010000) llen = 2; if (datalen &lt; 0x100) llen = 1; 310 type byte = TYPE BYTE (llen, datatype); =* Encode and send the type.. <p> the * data into datalen, and the packet type into datatype. * Returns 0 on success, error code otherwise. *= crn read data (u char *data, u int *datalen, u char *datatype) f u char type byte; int llen, retval; char type [5]; char enc length [9]; u char length <ref> [4] </ref>; u int count, encodedlen; =* First, read the packet type byte (should only be one character) *= 370 if ((crn read line (type, sizeof (type))) != 1) return (CRN BAD PACKET); =* This is special, since I really do know the IA5 encoding scheme here *= type [1] = type <p> the packet type byte (should only be one character) *= 370 if ((crn read line (type, sizeof (type))) != 1) return (CRN BAD PACKET); =* This is special, since I really do know the IA5 encoding scheme here *= type [1] = type [2] = type [3] = '='; type <ref> [4] </ref> = '"0'; =* Decode the typebyte, and get the llen *= encodedlen = 4; type byte = 0; 380 if ((retval = ia5 decode data (type, 4, &type byte, &encodedlen)) != CRN OK) return (retval); *datatype = PKT TYPE (type byte); llen = PKT LLENGTH (type byte); =* Read in <p> struct charon t f int mode; =* client or server *= int version; =* What version is this? *= 120 int (*key proc)(); =* Procedure to grab password *= u int datalen; =* length of that data packet *= u char *data; =* A data packet *= u char cookie <ref> [4] </ref>; =* this is a timestamp of the run *= char cli encrypt; =* Encrypt the session? *= char srv encrypt; =* Encrypt the session? *= char obtain ticket; =* Did we write a ticket to a file? *= char principal [ANAME SZ]; =* principal's name *= char instance [INST SZ];
Reference: [5] <author> B. Clifford Neuman and Jennifer G. </author> <title> Steiner. Authentication of Unknown Entities on an Insecure Network of Untrusted Workstations. </title> <booktitle> In Usenix UNIX Security Workshop Proceedings, </booktitle> <pages> pages 10-11, </pages> <address> Portlan, Oregon, </address> <month> August, </month> <year> 1988. </year>
Reference-contexts: The only entities that know these secrets are the owner (i.e., the user or the service-providing machine) and the Kerberos Server. In other words, the key is a "shared secret" between the named entity and the Kerberos Server <ref> [2, 5] </ref>. The Kerberos Server, also called the Key Distribution Center (or KDC), has the job of issuing tickets to users. A ticket is a cryptographic block that a user can present to a service provider to prove the user's identity. <p> DoProcessServerKDC (charon)) != CRN OK) crn send error ("Could not process server kerberos data"); return (retval); g static int DoProcessServerKDC (charon t *charon) f int retval; 280 KTEXT ST auth; CREDENTIALS cred; des cblock key; des key schedule sched; MSG DAT tgt data; MSG DAT cookie data; u char cookie <ref> [5] </ref>; u char tgt enc data [MAX KTXT LEN]; u char cookie enc data [MAX KTXT LEN]; 290 =* First, convert the first packet to ktext *= if ((retval = octet2ktext (charon&gt;data, charon&gt;datalen, charon&gt;tgt)) != CRN OK) return (retval); =* Now, get the second ktext packet *= if ((retval = crn <p> It will allocate enough data for the packet * and return the packet type to the caller. *= crn wait for data (u char **data, u int *datalen, u char *datatype) f u char type byte; int llen; char type <ref> [5] </ref>; char enc length [9]; 240 u char length [4]; int retval; u int count, encodedlen; =* First, read the packet type byte (should only be one character) *= if ((retval = crn read line (type, sizeof (type))) != 1) return (CRN BAD PACKET); =* This is special, since I really <p> convert the data to a 6bit, IA5 encoding, and send * that to the output file. * Returns 0 on success, or an error code, otherwise *= 290 crn send data (u char *data, u int datalen, u char datatype) f u char type byte; int llen, retval; char type <ref> [5] </ref>; char enc length [9]; u char length [4]; char *coded data; u int count, encodedlen; 300 =* Encoded the length into an octet *= int2octet (datalen, length); llen = 4; if (datalen &lt; 0x010000) llen = 2; if (datalen &lt; 0x100) llen = 1; 310 type byte = TYPE BYTE <p> the space of data, put the length of the * data into datalen, and the packet type into datatype. * Returns 0 on success, error code otherwise. *= crn read data (u char *data, u int *datalen, u char *datatype) f u char type byte; int llen, retval; char type <ref> [5] </ref>; char enc length [9]; u char length [4]; u int count, encodedlen; =* First, read the packet type byte (should only be one character) *= 370 if ((crn read line (type, sizeof (type))) != 1) return (CRN BAD PACKET); =* This is special, since I really do know the IA5
Reference: [6] <author> S. P. Miller, B. C. Neuman, J. I. Schiller, and J. H. Saltzer. </author> <title> Kerberos Authentication and Authorization System. </title> <type> Technical report, </type> <institution> M.I.T. Project Athena, </institution> <year> "1985, 1986, 1987". </year> <month> 91 </month>
Reference-contexts: To protect against this kind of attack, it would be nice to extend the Kerberos protocol across the modem link in order to secure that section of the connection, so that a user can log into a host server 1 see <ref> [6] </ref> for more details 2 It is possible to run some sort of IP layer over the modem, such as SLIP, which would enable the client to talk directly to the Kerberos Server. If IP connectivity is available, then Charon would not be necessary.
References-found: 6

