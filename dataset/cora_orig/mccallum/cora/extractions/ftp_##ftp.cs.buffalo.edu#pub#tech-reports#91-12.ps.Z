URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/91-12.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Title: A Taxonomy of Complexity Classes of Functions  
Author: Alan L. Selman 
Note: tt FewPF if and only if NP co-NP, and thus PF NP tt FewPF is likely to be false.  
Date: June 5, 1992  
Address: 226 Bell Hall Buffalo, New York 14260  
Affiliation: Department of Computer Science State University of New York at Buffalo  
Abstract: This paper comprises a systematic comparison of several complexity classes of functions that are computed nondeterministically in polynomial time or with an oracle in NP. There are three components to this work. * A taxonomy is presented that demonstrates all known inclusion relations of these classes. For (nearly) each inclusion that is not shown to hold, evidence is presented to indicate that the inclusion is false. As an example, consider FewPF, the class of multivalued functions that are nondeterministi-cally computable in polynomial time such that for each x, there is a polynomial bound on the number of distinct output values of f (x). We show that FewPF PF NP tt . However, we show PF NP * Whereas it is known that P NP (O(log n)) = P NP tt P NP [Hem87, Wagb, BH88], we show that PF NP (O(log n)) = PF NP NP. Also, we show that PF NP tt = PF NP if and only if P NP tt = P NP . * We show that if every nondeterministic polynomial-time multivalued function has a single-valued nondeterministic refinement (equivalently, if every honest function that is computable in polynomial-time can be inverted by fl The author acknowledges support by the National Science Foundation under grant CCR-9002292. 1 tt implies P = FewP and R =
Abstract-found: 1
Intro-found: 1
Reference: [AR88] <author> E. Allender and R. Rubinstein. </author> <title> P-printable sets. </title> <journal> SIAM J. Comput., </journal> <volume> 17(6), </volume> <year> 1988. </year>
Reference-contexts: it is well known that P NP (O (log n)) = P NP tt ([Hem87, Wagb, BH88]), we will show that the corresponding classes of functions, PF NP (O (log n))and PF NP tt , are equal only if P = FewP and P = R. (FewP is defined in <ref> [AR88] </ref>.) Another surprise is a connection with the study of promise problems and with a conjecture about promise problems of Even, Selman, and Yacobi ([ESY84]). This paper is an attempt at a systematic study of the complexity of computing functions.
Reference: [Bei] <author> R. Beigel. </author> <title> NP-hard sets are P-superterse unless R = NP. </title> <type> Technical Report 88-04, </type> <institution> Department of Computer Science, The Johns Hopkins University. </institution>
Reference-contexts: It is obvious that statement 4 implies statement 1. 2 28 4 Acknowledgements The author originally proved that PF NP (O (log n))= PF NP tt implies UP = P. Richard Beigel identified a similarity between this result and results in <ref> [Bei] </ref> and [Tod91], and for this reason suggested that R = NP might be obtainable also (cf. Theorem 11.) The extension from UP = P to FEW = P (Corollary 3 (i)) is due to Lane Hemachandra.
Reference: [BH88] <author> S. Buss and L. Hay. </author> <title> On truth table reducibility to sat and the difference hierarchy over NP. </title> <booktitle> In Procs. of the 3rd Annual Conference on Structure in Complexity Theory, </booktitle> <pages> pages 224-233. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: The class P NP (O (log n)) has emerged in recent years as a natural and robust complexity class. It is equal to the class of sets that are polynomial time truth-table reducible to SAT <ref> [Hem87, Wagb, BH88] </ref>, namely P NP tt , and has natural complete sets [Kre88, KSW86, Kad87, Waga]. Thus, the relationships P NP (O (log n)) = P NP are known. Here we will consider the corresponding class of functions that can be computed nonadaptively with oracles in NP, viz.
Reference: [BHW89] <author> R. Beigel, L. Hemachandra, and G. Wechsung. </author> <title> On the power of probabilistic polynomial time. </title> <booktitle> In Proc. Fourth Annual IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 225-227, </pages> <year> 1989. </year>
Reference-contexts: We will show that that P NP = P NP tt if and only if PF NP = PF NP tt . I.e., the right two function classes in (2) are equal if and only if all three set classes in (1) are equal. Beigel, Hemachandra, and Wechsung <ref> [BHW89] </ref> showed that P NP (O (log n)) PP. Thus, PF NP = PF NP tt implies P NP PP. We take this to be evidence that the classes PF NP and PF NP tt are not identical.
Reference: [BLS84] <author> R. Book, T. Long, and A. Selman. </author> <title> Quantitative relativizations of complexity classes. </title> <journal> SIAM J. Comput., </journal> <volume> 13(3) </volume> <pages> 461-487, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: Thus, for this reason also, it makes sense to inquire directly about the complexity of multivalued functions that can be solved by nondeterministic algorithms. 1.1 Definitions of some complexity classes of functions Several of the definitions we consider originate in <ref> [BLS84] </ref>. A transducer T is a nondeterministic Turing machine with a read-only input tape, a write-only output tape, and accepting states in the usual manner. <p> Are the two versions equivalent? In fact, if for all f 2 FewPF, some single-valued refinement of f belongs to PF, then c (set-f ) 2 PF follows by an easy iteration. An iterative procedure along the lines of "Oracle procedure 3.1" in <ref> [BLS84] </ref> 3 accomplishes this. Briefly, at each step of the iteration, values of f (x) that the refinement has already found are deleted, until the range of f (x) becomes empty. Then, the list of values that has been found is output. <p> Let SAT denote the NP-complete satisfiability problem. Let sat be the multivalued function whose value on input a formula of propositional logic x is any satisfying assignment of x, if x 2 SAT, 3 The class FewPF is called NPMVPB in <ref> [BLS84] </ref>. 23 and which is undefined, otherwise. Theorem 13 NPMV c NPSV if and only if there is a refinement h in NPSVof sat. Proof. The theorem only requires proof in one direction. Assume h is a refinement in NPSV of sat.
Reference: [CH90] <author> J. Cai and L. Hemachandra. </author> <title> On the power of parity polynomial time. </title> <journal> Math. Systems Theory, </journal> <note> 1990. In press. </note>
Reference-contexts: Proof. Define CS M = f (x; k) j k count M (x)g. Clearly, CS M 2 NP. Then, a binary search algorithm shows that count M 2 P NP (O (log n)). 2 The class FEW is defined by Cai and Hemachandra <ref> [CH90] </ref> to be an extension of UP and FewP.
Reference: [Coo71] <author> S. Cook. </author> <title> The complexity of theorem-proving procedures. </title> <booktitle> In Proc. 3rd ACM Symp. Theory of Computing, </booktitle> <pages> pages 151-158, </pages> <year> 1971. </year> <month> 29 </month>
Reference-contexts: Proof. The theorem only requires proof in one direction. Assume h is a refinement in NPSV of sat. Let f 2 NPMV and let T be a nondeterministic polynomial time transducer that computes f . By Cook's theorem <ref> [Coo71] </ref>, for each string x, there is a formula x , obtainable in polynomial time, such that the satisfying assignments of x are encodings of accepting computations of T on input x.
Reference: [ESY84] <author> S. Even, A. Selman, and Y. Yacobi. </author> <title> The complexity of promise problems with applications to public-key cryptography. </title> <journal> Information And Control, </journal> <volume> 61(2) </volume> <pages> 159-173, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: We will show that this relation holds only if there exist disjoint NP-complete sets such that every set that separates them is NP- hard, which contradicts the conjecture studied in <ref> [ESY84] </ref> and [GS88]. This question is taken up in Section 3. 1.3 Promise problems Section 3 uses previous work on promise problems. Readers who are unfamiliar with promise problems are referred to [ESY84] and [GS88]. <p> NP-complete sets such that every set that separates them is NP- hard, which contradicts the conjecture studied in <ref> [ESY84] </ref> and [GS88]. This question is taken up in Section 3. 1.3 Promise problems Section 3 uses previous work on promise problems. Readers who are unfamiliar with promise problems are referred to [ESY84] and [GS88]. Given multivalued partial functions f and g, define g to be an extension of f if domain (f ) domain (g) and for all x 2 dom (f ) and all y, if g (x) 7! y, then f (x) 7! y. <p> The proof is straightforward. Let h be a refinement of sat in NPSV. To see that every single-valued total extension g of h is NP- hard, observe that x 2 SAT $ g (x) is a satisfying assignment for x: A conjecture is raised in <ref> [ESY84] </ref> which states that there exists no promise problem (Q; R) such that (i) Q 2 NP, (iii) (O; R) is NP-hard. This conjecture implies that NP-hard public key cryptosystems do not exist, that NP 6= co-NP, and, as is proved in [ESY84], that UP 6= NP. 24 Theorem 15 The <p> assignment for x: A conjecture is raised in <ref> [ESY84] </ref> which states that there exists no promise problem (Q; R) such that (i) Q 2 NP, (iii) (O; R) is NP-hard. This conjecture implies that NP-hard public key cryptosystems do not exist, that NP 6= co-NP, and, as is proved in [ESY84], that UP 6= NP. 24 Theorem 15 The following statements are equivalent. 1. NPSVcontains an NP-hard partial function. 2. There is a function f 2 NPSV such that (Q f ; R f ) is NP-hard (i.e. every solution is NP-hard). 3.
Reference: [GS88] <author> J. Grollmann and A. Selman. </author> <title> Complexity measures for public-key cryptosys-tems. </title> <journal> SIAM J. Comput., </journal> <volume> 17(2), </volume> <month> April </month> <year> 1988. </year>
Reference-contexts: We will show that this relation holds only if there exist disjoint NP-complete sets such that every set that separates them is NP- hard, which contradicts the conjecture studied in [ESY84] and <ref> [GS88] </ref>. This question is taken up in Section 3. 1.3 Promise problems Section 3 uses previous work on promise problems. Readers who are unfamiliar with promise problems are referred to [ESY84] and [GS88]. <p> such that every set that separates them is NP- hard, which contradicts the conjecture studied in [ESY84] and <ref> [GS88] </ref>. This question is taken up in Section 3. 1.3 Promise problems Section 3 uses previous work on promise problems. Readers who are unfamiliar with promise problems are referred to [ESY84] and [GS88]. Given multivalued partial functions f and g, define g to be an extension of f if domain (f ) domain (g) and for all x 2 dom (f ) and all y, if g (x) 7! y, then f (x) 7! y. <p> For convenience, we repeat here the following proposition from <ref> [GS88] </ref>. <p> ; R f ) Proposition 2 2 (i) If f is a single-valued partial function and A is a solution of (Q f ; R f ), then there is a total function h that extends f such that h P T A. 2 Both statements of this proposition in <ref> [GS88] </ref> include as hypothesis that f 2 NPSV, but this is not required. 8 (ii) If f is a single-valued partial function and h is a total extension of f , then there is a solution A of (Q f ; R f ) such that A P T h. <p> To see that item 6 implies NP = co-NP, consider the characteristic function of any NP-complete set. The remaining cases are proved similarly. 2 2.2.1 UP, FewP, and FEW Some of the remaining possibilities are equivalent to either P = UP or P = FewP. It is proved in <ref> [GS88] </ref> that P = UP if an only if NPSV g PF. Thus, using Proposition 7 as well, we have the following theorem. Theorem 5 The following statements are equivalent. 1. P = UP 2. NPSV g PF 3. <p> P = UP 2. NPSV g PF 3. NPSV g PF NP (O (log n)) 15 Corollary 2 NPSV PF NP (O (log n)) implies P = UP. Theorem 6 NPMV g c NPSV g implies NP = UP. Proof. It is proved in <ref> [GS88] </ref> that NP = UP if and only if there is a function in NPSV g whose domain is NP-complete. Let L be any NP-complete set and let M be an NP-acceptor for L. <p> By Proposition 2, there is a total extension h of f such that h P T A. Thus, A is NP-hard. That statement 2 implies 3, and that 3 implies 4, are demonstrated in <ref> [GS88] </ref>. To see that statement 4 implies 1, let A and B be disjoint P T -complete sets such that every set that separates them is NP- hard. Define f (x) = &gt; &lt; 0 x 2 A " otherwise. Clearly, f 2 NPSV. <p> P T L 1 follows, and this is what we needed to prove. (Q f ; R f ) PP T (Q g ; R g ) implies (Q f ; R f ) PP UT (Q g ; R g ) is one of the main results proved in <ref> [GS88] </ref>. Assume (Q f ; R f ) PP UT (Q g ; R g ), and let M be a Turing machine that witnesses the uniform reduction. The general idea is this: Let g 0 be a total extension of g.
Reference: [Hem87] <author> L. Hemachandra. </author> <title> Counting in Structural Complexity Theory. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1987. </year>
Reference-contexts: The class P NP (O (log n)) has emerged in recent years as a natural and robust complexity class. It is equal to the class of sets that are polynomial time truth-table reducible to SAT <ref> [Hem87, Wagb, BH88] </ref>, namely P NP tt , and has natural complete sets [Kre88, KSW86, Kad87, Waga]. Thus, the relationships P NP (O (log n)) = P NP are known. Here we will consider the corresponding class of functions that can be computed nonadaptively with oracles in NP, viz.
Reference: [Kad87] <author> J. Kadin. </author> <title> p np [log n] and sparse Turing-complete sets for NP. </title> <booktitle> In Proc. Struct. in Complexity Second Annual Conference, </booktitle> <pages> pages 33-40, </pages> <year> 1987. </year>
Reference-contexts: Krentel [Kre88] studied these classes and demonstrated that if PF NP = PF NP (O (log n)), then P = NP. Kadin <ref> [Kad87] </ref> showed that if NP has sparse Turing-complete sets, then the entire polynomial hierarchy collapses to P NP (O (log n)). The class P NP (O (log n)) has emerged in recent years as a natural and robust complexity class. <p> The class P NP (O (log n)) has emerged in recent years as a natural and robust complexity class. It is equal to the class of sets that are polynomial time truth-table reducible to SAT [Hem87, Wagb, BH88], namely P NP tt , and has natural complete sets <ref> [Kre88, KSW86, Kad87, Waga] </ref>. Thus, the relationships P NP (O (log n)) = P NP are known. Here we will consider the corresponding class of functions that can be computed nonadaptively with oracles in NP, viz. PF NP tt . 1.2 Summary of results the classes just described.
Reference: [Kre88] <author> M. Krentel. </author> <title> The complexity of optimization problems. </title> <journal> J. Computer Systems Sci., </journal> <volume> 36 </volume> <pages> 490-509, </pages> <year> 1988. </year>
Reference-contexts: This is true for example of Toda's result that PH P #P [Tod89]. Krentel's work that relates the complexity of optimization problems to set recognition problems in the Boolean Hierarchy is concerned not only with the complexity of function classes <ref> [Kre88] </ref>, but is directly concerned with relating the complexity of function classes with those of certain set recognition problems. The problems we traditionally think of as set recognition problems are more naturally thought of as functional computational problems. <p> Finally, we mention the class of functions computed in polynomial time with oracles in NP, namely PF NP , and the class of functions computed in polynomial time with at most O (log n) queries to an oracle in NP, namely PF NP (O (log n)). Krentel <ref> [Kre88] </ref> studied these classes and demonstrated that if PF NP = PF NP (O (log n)), then P = NP. Kadin [Kad87] showed that if NP has sparse Turing-complete sets, then the entire polynomial hierarchy collapses to P NP (O (log n)). <p> The class P NP (O (log n)) has emerged in recent years as a natural and robust complexity class. It is equal to the class of sets that are polynomial time truth-table reducible to SAT [Hem87, Wagb, BH88], namely P NP tt , and has natural complete sets <ref> [Kre88, KSW86, Kad87, Waga] </ref>. Thus, the relationships P NP (O (log n)) = P NP are known. Here we will consider the corresponding class of functions that can be computed nonadaptively with oracles in NP, viz. PF NP tt . 1.2 Summary of results the classes just described. <p> Corollary 1 NPMV c NPSV if and only if NPMV g c NPSV. Proposition 7 (Krentel) f 2 PF NP (O (log n)) and graph (f ) 2 P implies f 2 PF. Though this proposition is not stated in <ref> [Kre88] </ref>, the proof is embedded in the proof of his Theorem 4.1. Namely, there is a P SAT machine M that computes f and that makes at most O (log n) queries. Simulate M on input x for all possible oracle answers.
Reference: [KSW86] <author> J. Kobler, U. Schoning, and K. Wagner. </author> <title> The difference and truth-table hierarchies for NP. </title> <booktitle> In Theoretical Informatics and Applications, </booktitle> <year> 1986. </year>
Reference-contexts: The class P NP (O (log n)) has emerged in recent years as a natural and robust complexity class. It is equal to the class of sets that are polynomial time truth-table reducible to SAT [Hem87, Wagb, BH88], namely P NP tt , and has natural complete sets <ref> [Kre88, KSW86, Kad87, Waga] </ref>. Thus, the relationships P NP (O (log n)) = P NP are known. Here we will consider the corresponding class of functions that can be computed nonadaptively with oracles in NP, viz. PF NP tt . 1.2 Summary of results the classes just described.
Reference: [Sel78] <author> A. Selman. </author> <title> Polynomial time enumeration reducibility. </title> <journal> SIAM J. Comput., </journal> <volume> 7(4) </volume> <pages> 440-457, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: This intuition states that a function f is nonadaptively computed (relative to some oracle) if and only if each output bit of the answer f (x) can be determined independently, and nonadaptively (relative to the oracle). For any single-valued function f , code (f ) is defined in <ref> [Sel78] </ref> to be the set of all triples h; x; ki, where 2 f0; 1g, x 2 fl and k 2 f0; 1g fl is the binary representation of a number n (k), such that the following properties hold: h0; x; ki 2 code (f ) $ f (x) has an
Reference: [Sel88] <author> A. Selman. </author> <title> Natural self-reducible sets. </title> <journal> SIAM J. Comput., </journal> <volume> 17 </volume> <pages> 989-996, </pages> <year> 1988. </year>
Reference-contexts: This is because the combinatorial problems we usually study are self-reducible. It is not known whether all problems in NP are self-reducible (cf. <ref> [Sel88] </ref>), so it is not known whether the familiar approach can work in all cases. This is a primary motivation for studying function classes directly, and for directly inquiring about the complexity of multivalued functions that can be solved by nondeterministic algorithms.
Reference: [Sel90] <author> A. Selman. </author> <title> One-way functions in complexity theory. </title> <booktitle> In Proc. Symp. on Math. Foundations of Computer Science, Lecture Notes in Computer Science, </booktitle> <volume> volume 452, </volume> <pages> pages 88-104, </pages> <address> Berlin, 1990. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Thus, "NPMV c PF" would mean that every partial multivalued function in NPMV can be computed efficiently by some deterministic polynomial time transducer. The following proposition is known: Proposition 1 1. <ref> [Sel90] </ref> NPMV c PF if and only if P = NP. 2. [SXB83] NPSV PF if and only if P = NP.
Reference: [SXB83] <author> A. Selman, Xu M.-R., and R. </author> <title> Book. Positive relativizations of complexity classes. </title> <journal> SIAM J. Comput., </journal> <volume> 12 </volume> <pages> 465-479, </pages> <year> 1983. </year>
Reference-contexts: Thus, "NPMV c PF" would mean that every partial multivalued function in NPMV can be computed efficiently by some deterministic polynomial time transducer. The following proposition is known: Proposition 1 1. [Sel90] NPMV c PF if and only if P = NP. 2. <ref> [SXB83] </ref> NPSV PF if and only if P = NP. <p> A number of properties of code (f ) are summarized in Lemma 2.2 of <ref> [SXB83] </ref>, and we repeat them here in the following proposition. A function f is polynomial-bounded if there is a polynomial p such that for all x in the domain of f , jf (x)j p (jxj).
Reference: [Tod89] <author> S. </author> <title> Toda. </title> <booktitle> On the computational power of PP and P. In Proc. 30th IEEE Symp. on Foundations of Computer Science, </booktitle> <pages> pages 514-519, </pages> <year> 1989. </year>
Reference-contexts: This is unfortunate, for some of the exciting recent developments in complexity theory directly concern complexity of function classes. This is true for example of Toda's result that PH P #P <ref> [Tod89] </ref>. Krentel's work that relates the complexity of optimization problems to set recognition problems in the Boolean Hierarchy is concerned not only with the complexity of function classes [Kre88], but is directly concerned with relating the complexity of function classes with those of certain set recognition problems.
Reference: [Tod91] <author> S. </author> <title> Toda. On polynomial-time truth-table reducibilities of intractable sets to P-selective sets. </title> <journal> Mathematical Systems Theory, </journal> <volume> 24(2) </volume> <pages> 69-82, </pages> <year> 1991. </year> <month> 30 </month>
Reference-contexts: Valiant and Vazirani [VV85] showed that R = NP if the promise 19 problem (SAT 1; SAT ) has a solution in P. We use their result in order to prove the following theorem. The proof of this theorem is inspired by, but easier than, a result in <ref> [Tod91] </ref>. Theorem 12 PF NP tt = PF NP (O (log n)) implies R = NP. Proof. Define SAT 0 = f (; i) j has n variables, n i, and there is a satisfying assignment w of in which the i-th variable is trueg: Clearly, SAT 0 2 NP. <p> It is obvious that statement 4 implies statement 1. 2 28 4 Acknowledgements The author originally proved that PF NP (O (log n))= PF NP tt implies UP = P. Richard Beigel identified a similarity between this result and results in [Bei] and <ref> [Tod91] </ref>, and for this reason suggested that R = NP might be obtainable also (cf. Theorem 11.) The extension from UP = P to FEW = P (Corollary 3 (i)) is due to Lane Hemachandra.
Reference: [Val76] <author> L. Valiant. </author> <title> Relative complexity of checking and evaluating. </title> <journal> Information Pro--cessing Letters, </journal> <volume> 5(1) </volume> <pages> 20-23, </pages> <month> May </month> <year> 1976. </year>
Reference-contexts: The following proposition is known: Proposition 1 1. [Sel90] NPMV c PF if and only if P = NP. 2. [SXB83] NPSV PF if and only if P = NP. Following Valiant <ref> [Val76] </ref>, given a class of partial functions F , let F g denote the class of all functions f 2 F such that graph (f ) 2 P. 1 Valiant noticed that ordinary search problems associated with NP decision problems are functions in NPMV g : That is, let R (x;
Reference: [VV85] <author> L. Valiant and V. Vazirani. </author> <title> NP is as easy as detecting unique solutions. </title> <booktitle> In Proc. 17th ACM Symp. Theory of Computing, </booktitle> <pages> pages 458-463, </pages> <year> 1985. </year>
Reference-contexts: Proof. By Theorem 2, FewPF PF NP tt . Thus, PF NP tt PF NP (O (log n)) implies P = FewP, by the previous corollary. 2 Let SAT 1 denote the set of formulas of propositional logic that contain at most one satisfying assignment. Valiant and Vazirani <ref> [VV85] </ref> showed that R = NP if the promise 19 problem (SAT 1; SAT ) has a solution in P. We use their result in order to prove the following theorem. The proof of this theorem is inspired by, but easier than, a result in [Tod91].
Reference: [Waga] <author> K. Wagner. </author> <title> Bounded query classes. </title> <type> Technical Report TR-157, </type> <institution> Universitat Ausburg, Institut fur Mathematik, </institution> <year> 1987. </year>
Reference-contexts: The class P NP (O (log n)) has emerged in recent years as a natural and robust complexity class. It is equal to the class of sets that are polynomial time truth-table reducible to SAT [Hem87, Wagb, BH88], namely P NP tt , and has natural complete sets <ref> [Kre88, KSW86, Kad87, Waga] </ref>. Thus, the relationships P NP (O (log n)) = P NP are known. Here we will consider the corresponding class of functions that can be computed nonadaptively with oracles in NP, viz. PF NP tt . 1.2 Summary of results the classes just described.
Reference: [Wagb] <author> K. Wagner. </author> <title> Log query classes. </title> <type> Technical Report TR-145, </type> <institution> Universitat Ausburg, Institut fur Mathematik, </institution> <year> 1987. </year>
Reference-contexts: The class P NP (O (log n)) has emerged in recent years as a natural and robust complexity class. It is equal to the class of sets that are polynomial time truth-table reducible to SAT <ref> [Hem87, Wagb, BH88] </ref>, namely P NP tt , and has natural complete sets [Kre88, KSW86, Kad87, Waga]. Thus, the relationships P NP (O (log n)) = P NP are known. Here we will consider the corresponding class of functions that can be computed nonadaptively with oracles in NP, viz.
Reference: [WT] <author> O. Watanabe and S. </author> <title> Toda. Some structural analyses on the complexity of inverse functions. </title> <type> manuscript, </type> <year> 1991. </year> <month> 31 </month>
Reference-contexts: c PF NP tt $ NPMV c PF NP tt : Example 5 Every honest polynomial time computable function is invertible in the class NPSV $ NPMV g c NPSV $ NPSV c PF NP tt : The question of whether NPMV g c PF NP tt is studied in <ref> [WT] </ref>, where it is shown that this assertion holds relative to a set of oracles of Lebesgue measure one. The question of whether NPMV g c NPSV is studied in greater detail in the next section.
References-found: 24

