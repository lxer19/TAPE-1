URL: file://ftp.cs.ucsd.edu/pub/baden/tr/cs92-243.ps.gz
Refering-URL: http://www.cs.ucsd.edu/groups/hpcl/scg/tr.html
Root-URL: http://www.cs.ucsd.edu
Title: THE REFERENCE GUIDE TO GENMP THE GENERIC MULTIPROCESSOR  
Author: SCOTT B. BADEN AND SCOTT KOHN 
Keyword: Key Words. Multiprocessors, Dynamic Load Balancing, Scientific Computing, Software Portability, Particle Methods.  
Abstract: This document discusses programming the Generic Multiprocessor, an abstraction for a class of mesh-based scientific calculations exhibiting spatial locality. GenMP's facilities hide low-level implementation details and provide the programmer with high-level abstractions which can be used to create portable scientific software. GenMP's programming paradigm, portability, partitioning methods, communications facilities, and support routines are described. This report closes with an overview of the GenMP distribution source and the sample particle program binz. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. R. Anderson, </author> <title> A method of local corrections for computing the velocity field due to a distribution of vortex blobs, </title> <journal> Journal of Computational Physics, </journal> <volume> 62 (1986), </volume> <pages> pp. 111-123. </pages>
Reference-contexts: The genmp/lib directory and subdirectories contain the Fortran source code for the library routines which were described in Section 5. The GenMP directories also contain a sample program, binz, described in the Appendix, which uses a vortex-blob method <ref> [1] </ref> to solve the vorticity-stream function formulation of Euler's equations for incompressible flow in two dimensions on an infinite domain.
Reference: [2] <author> S. B. Baden, </author> <title> Run-Time Partitioning of Scientific Continuum Calculations Running on Multiprocessors, </title> <type> PhD thesis, </type> <institution> University of California at Berkeley, </institution> <month> June </month> <year> 1987. </year> <note> Also Technical Report LBL-23625, </note> <institution> Lawrence Berkeley Laboratory, Berkeley, </institution> <month> CA. </month> <title> [3] , Programming abstractions for dynamically partitioning and coordinating localized scientific calculations running on multiprocessors, </title> <journal> SIAM Journal on Scientific and Statistical Computing, </journal> <volume> 12 (1991), </volume> <pages> pp. 145-157. </pages>
Reference-contexts: Code written for one multiprocessor will rarely be portable to other parallel platforms. Time-dependent calculations which assign computational effort non-uniformly over the problem domain can be particularly troublesome, since the processor workload must be redistributed dynamically as the calculation progresses. GenMP, originally developed by Baden in his Ph.D. research <ref> [2] </ref> [3], attempts to address these issues for an important class of scientific calculations which operate on a mesh and are spatially localized. These types of problems spend most of their time calculating the influences between nearby mesh boxes.
Reference: [4] <author> S. B. Baden and S. Kohn, </author> <title> A comparison of load balancing strategies for particle methods running on mimd multiprocessors, </title> <booktitle> in Proceedings of the Fifth SIAM Conference on Parallel Processing for Scientific Computing, </booktitle> <address> Houston, Texas, </address> <month> March 25-27 </month> <year> 1991. </year> <note> Also Technical Report CS91-199, </note> <institution> Computer Science and Engineering, University of California, </institution> <address> San Diego, CA. </address>
Reference-contexts: Other contributing factors include the choice of workload balancing strategy, the relative cost of communication to computation on the multiprocessor platform, and the number of processors <ref> [4] </ref>. GenMP currently implements three partitioning strategies for solving the load balancing problem: * recursive bisection, * interleaved or scattered decomposition, and * processor self-scheduling. 3.1. Recursive Bisection. <p> Domains are represented by integer arrays which hold the bounds of the regions. For example, the following Fortran code describes a two dimensional domain <ref> [0; 4] </ref> fi [4; 5] and a three dimensional domain [5; 10] fi [7; 8] fi [4; 10]. integer twod (0:3), threed (0:5) data twod/0,4,4,5/, threed/5,10,7,8,4,10/ Subroutines partitn () and lBar () require that subroutine initDmn () (Table 3) is called first to initialize a special integer working array dmn of <p> Domains are represented by integer arrays which hold the bounds of the regions. For example, the following Fortran code describes a two dimensional domain [0; 4] fi <ref> [4; 5] </ref> and a three dimensional domain [5; 10] fi [7; 8] fi [4; 10]. integer twod (0:3), threed (0:5) data twod/0,4,4,5/, threed/5,10,7,8,4,10/ Subroutines partitn () and lBar () require that subroutine initDmn () (Table 3) is called first to initialize a special integer working array dmn of size 5 + <p> Domains are represented by integer arrays which hold the bounds of the regions. For example, the following Fortran code describes a two dimensional domain [0; 4] fi [4; 5] and a three dimensional domain [5; 10] fi [7; 8] fi <ref> [4; 10] </ref>. integer twod (0:3), threed (0:5) data twod/0,4,4,5/, threed/5,10,7,8,4,10/ Subroutines partitn () and lBar () require that subroutine initDmn () (Table 3) is called first to initialize a special integer working array dmn of size 5 + p + 8d (p + 1) for p processors and a d-dimensional domain.
Reference: [5] <author> M. J. Berger and S. H. Bokhari, </author> <title> A partitioning strategy for nonuniform problems on multiprocessors, </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-36 (1987), </volume> <pages> pp. 570-580. </pages>
Reference-contexts: GenMP currently implements three partitioning strategies for solving the load balancing problem: * recursive bisection, * interleaved or scattered decomposition, and * processor self-scheduling. 3.1. Recursive Bisection. Recursive bisection <ref> [5] </ref> is a domain decomposition strategy which divides the problem domain fl into two regions carrying approximately the same amount of work and then recursively applies itself to the two regions until the desired number of partitions has been rendered. <p> Domains are represented by integer arrays which hold the bounds of the regions. For example, the following Fortran code describes a two dimensional domain [0; 4] fi <ref> [4; 5] </ref> and a three dimensional domain [5; 10] fi [7; 8] fi [4; 10]. integer twod (0:3), threed (0:5) data twod/0,4,4,5/, threed/5,10,7,8,4,10/ Subroutines partitn () and lBar () require that subroutine initDmn () (Table 3) is called first to initialize a special integer working array dmn of size 5 + <p> Domains are represented by integer arrays which hold the bounds of the regions. For example, the following Fortran code describes a two dimensional domain [0; 4] fi [4; 5] and a three dimensional domain <ref> [5; 10] </ref> fi [7; 8] fi [4; 10]. integer twod (0:3), threed (0:5) data twod/0,4,4,5/, threed/5,10,7,8,4,10/ Subroutines partitn () and lBar () require that subroutine initDmn () (Table 3) is called first to initialize a special integer working array dmn of size 5 + p + 8d (p + 1) for
Reference: [6] <author> A. J. Chorin, </author> <title> Numerical study of slightly viscous flow, </title> <journal> Journal of Computational Fluid Mechanics, </journal> <volume> 57 (1973), </volume> <pages> pp. 785-796. </pages>
Reference-contexts: Program binz solves a certain class of fluid flow problems using a particle-particle particle-mesh method. The particle-particle interactions represent short range particle interactions and are implemented using the GenMP programming abstractions. The particle-mesh calculations are only partially localized and use a fast Poisson solver to calculate the velocity corrections <ref> [6] </ref>. A.1. Vortex Algorithm.
Reference: [7] <author> R. W. Hockney and J. W. Eastwood, </author> <title> Computer Simulation Using Particles, </title> <publisher> McGraw-Hill, </publisher> <year> 1981. </year>
Reference-contexts: GenMP is not restricted to finite difference type methods; any method which uses a mesh to organize the computation also qualifies as a mesh-based method. Some examples would be particle in a cell and particle-particle particle-mesh methods <ref> [7] </ref>. GenMP provides a generic multiprocessor abstraction for dynamically partitioning and coordinating localized, mesh-based numerical computations. This abstraction allows code developed under the GenMP model to be portable to a wide variety of multiprocessor architectures, including both shared memory and distributed memory MIMD architectures. <p> Domains are represented by integer arrays which hold the bounds of the regions. For example, the following Fortran code describes a two dimensional domain [0; 4] fi [4; 5] and a three dimensional domain [5; 10] fi <ref> [7; 8] </ref> fi [4; 10]. integer twod (0:3), threed (0:5) data twod/0,4,4,5/, threed/5,10,7,8,4,10/ Subroutines partitn () and lBar () require that subroutine initDmn () (Table 3) is called first to initialize a special integer working array dmn of size 5 + p + 8d (p + 1) for p processors and
Reference: [8] <author> D. M. Nicol and J. H. Saltz, </author> <title> An analysis of scatter decomposition, </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39 (1990), </volume> <pages> pp. 1337-1345. </pages>
Reference-contexts: Of the three partitioning strategies implemented in GenMP, recursive bisection is likely to incur the lowest communications overheads. 3.2. Interleaved or Scattered Decomposition. Whereas recursive bisection is a semi-static coarse-grained method for balancing workloads, interleaved or scattered decomposition <ref> [8] </ref> is a static fine-grained strategy. Interleaved decomposition decomposes a domain fl by assigning the processors periodically to the boxes of the mesh. The processors are arranged in a canonical d-dimensional stencil or template; this template is tessellated over the problem domain to obtain the assignment of boxes to processors. <p> Domains are represented by integer arrays which hold the bounds of the regions. For example, the following Fortran code describes a two dimensional domain [0; 4] fi [4; 5] and a three dimensional domain [5; 10] fi <ref> [7; 8] </ref> fi [4; 10]. integer twod (0:3), threed (0:5) data twod/0,4,4,5/, threed/5,10,7,8,4,10/ Subroutines partitn () and lBar () require that subroutine initDmn () (Table 3) is called first to initialize a special integer working array dmn of size 5 + p + 8d (p + 1) for p processors and
Reference: [9] <author> P. Tang and P. C. Yew, </author> <title> Processor self-scheduling for multiple-nested parallel loops, </title> <booktitle> in Proceedings of the International Conference on Parallel Processing, </booktitle> <year> 1986, </year> <pages> pp. 528-535. 22 </pages>
Reference-contexts: The amount of communication overhead can be reduced by chunking boxes of the domain together into larger grains of work at the expense of the workload balance. 3.3. Processor Self-Scheduling. In processor self-scheduling <ref> [9] </ref>, processors are assigned work on demand from a shared list of tasks to be performed. The communications patterns among processors are both irregular and unpredictable since work assignments are never associated with a particular processor and can freely migrate from one processor to another.
References-found: 8

