URL: http://www.cs.ucsb.edu/~dsl/Kan/Papers/dcca7.ps.gz
Refering-URL: http://www.cs.ucsb.edu/~dsl/Kan/Papers/
Root-URL: http://www.cs.ucsb.edu
Title: Dependable Distributed Objects  
Author: Jerry James Ambuj K. Singh 
Keyword: formal reasoning, distributed systems, fault tolerance, object-oriented programming, concurrent programming, compositionality  
Abstract: We describe the design of Kan, a Java-based distributed system whose goal is to study, design, and implement dependable distributed objects for multithreaded applications. Dependability in this context denotes both fault-tolerance and support for formal specification and verification of system components. The first criterion is achieved through logging and forward recovery, and dynamic replication and migration of both objects and threads. The second criterion is achieved through a compositional proof methodology: properties of individual objects are proved in isolation, and then composed to derive the properties of the entire system. The system is based on a concurrent object model that extends the Java programming language with the constructs of asynchronous method calls, nested atomic actions, and guards. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martn Abadi and Leslie Lamport. </author> <title> Conjoining specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 17(3):50734, </volume> <month> May </month> <year> 1995. </year>
Reference-contexts: Objects provide a convenient abstraction for reasoning about such systems. We provide a formal specification and verification methodology for our concurrent object-oriented model. We provide a translation from model components to TLA [25] formulas, and use TLA to construct the proofs. TLA has a Composition Theorem <ref> [1] </ref> which we use to derive system properties by composing object properties. Our proof system supports proof reuse in subclasses by elucidating the conditions under which method properties continue to hold. <p> Instead, we translate from our model into an established non-object-oriented specification language. We have chosen TLA [25] (the Temporal Logic of Actions), which has a complete Composition Theorem <ref> [1] </ref>, meaning that all properties of a synthesis follow from the properties of its parts and the Composition Theorem. Note, however, that other concurrent logics could be used, such as Unity [12] with a complete composition rule [13].
Reference: [2] <author> Lorenzo Alvisi, R. Joshi, Calvin Lin, and Jayadev Misra. Seuss: </author> <title> What the doctor ordered. </title> <booktitle> In PDSE '97, </booktitle> <pages> pages 28490, </pages> <address> Boston, MA, USA, </address> <month> 1718 May </month> <year> 1997. </year>
Reference-contexts: Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification <ref> [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46] </ref>. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments. <p> Its notion of object is different from ours, due to the use of joint actions rather than threads of control. The goal of Seuss <ref> [2] </ref> is to separate the sequential and concurrent aspects of programming concurrent systems. Programs are written and reasoned about sequentially, but multithreaded implementations easily follow from the programming model.
Reference: [3] <author> Lorenzo Alvisi and Keith Marzullo. </author> <title> Message logging: Pessimistic, optimistic, causal, and optimal. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 24(2):149 59, </volume> <month> February </month> <year> 1998. </year> <title> [4] zalp Babao ff glu and Andr Schiper. On group communication in large-scale distributed systems. Operating Systems Review, </title> <address> 29(1):627, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: In Section 4, we describe the specification and verification methodology for our system. Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., <ref> [3, 6, 17, 35, 40, 47] </ref>), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46]. In this section, we list some of the more closely-related work. <p> With sender-based logging, we must take care when a node sends a message and then immediately fails. On recovery, we do not want to send the message a second time. With pessimistic or causal logging <ref> [3] </ref>, this problem is avoided. Semantic logging The system cannot know the precise set of events that are nondeterministic, and so must be conservative in its logging. However, this results Dependable Distributed Objects 9 in many unnecessary log entries. We only need to log concurrent noncom-muting events. <p> We are able to take independent checkpoints on each node, and are in the planning stages for implementing logging schemes. We plan to experiment with optimistic, pessimistic, and causal logging schemes <ref> [3] </ref> under a variety of application loads and study the impact on performance. 12 James, Singh 4 Specification and Verification The great promise of object-oriented technology is that it makes truly open systems possible.
Reference: [5] <author> Henri E. Bal. </author> <title> Programming Distributed Systems. </title> <publisher> Prentice-Hall, </publisher> <address> New York, NY, USA, </address> <year> 1991. </year>
Reference-contexts: The Kan compiler produces standard Java bytecode, and the runtime system is written in standard Java, allowing Kan programs to run on any system with a Java installation. The underlying object model is similar to that used by C++ [44], Java [18], Orca <ref> [5] </ref>, and related languages. The major differences are as follows. First, con-currency is introduced by asynchronous method calls. The ability to overlap communication with computation has always been important in distributed systems, but will become more so as computing nodes increase in speed.
Reference: [6] <author> R. Baldoni, J. M. Hlary, A. Mostefaoui, and M. Raynal. </author> <title> Adaptive check-pointing in message passing distributed systems. </title> <journal> Journal of Systems Science, </journal> <volume> 28(11):114561, </volume> <month> November </month> <year> 1998. </year>
Reference-contexts: In Section 4, we describe the specification and verification methodology for our system. Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., <ref> [3, 6, 17, 35, 40, 47] </ref>), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46]. In this section, we list some of the more closely-related work.
Reference: [7] <author> Howard Barringer, Ruurd Kuiper, and Amir Pnueli. </author> <title> Now you may compose temporal logic specifications. </title> <booktitle> In STOC '84, </booktitle> <pages> pages 5163, </pages> <address> Washington, D.C., USA, </address> <month> 30 April2 May </month> <year> 1984. </year>
Reference-contexts: Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification <ref> [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46] </ref>. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments.
Reference: [8] <author> Gerald Brose, Klaus-Peter Lhr, and Andr Spiegel. </author> <title> Java does not distribute. </title> <editor> In Christine Mingins, Roger Duke, and Bertrand Meyer, editors, </editor> <booktitle> TOOLS Pacific '97, </booktitle> <pages> pages 14452, </pages> <address> Melbourne, Australia, </address> <month> 2427 November </month> <year> 1997. </year>
Reference-contexts: The system is based on Java [18], due to its portability and support for object-oriented programming. However, Java is not fully suited for distributed system development (e.g., <ref> [8, 9] </ref>). In particular, some simple, commonly-used distributed system programming constructs (such as guarded atomic actions) cannot be expressed simply. We have extended Java in a few ways in order to remedy such defects.
Reference: [9] <author> Gerald Brose, Klaus-Peter Lhr, and Andr Spiegel. </author> <title> Java resists transparent distribution. Object Magazine, </title> <address> 7(10):502, </address> <month> December </month> <year> 1997. </year>
Reference-contexts: The system is based on Java [18], due to its portability and support for object-oriented programming. However, Java is not fully suited for distributed system development (e.g., <ref> [8, 9] </ref>). In particular, some simple, commonly-used distributed system programming constructs (such as guarded atomic actions) cannot be expressed simply. We have extended Java in a few ways in order to remedy such defects.
Reference: [10] <author> Manfred Broy. </author> <title> Compositional refinement of interactive systems. </title> <journal> Journal of the ACM, </journal> <volume> 44(6):85091, </volume> <month> November </month> <year> 1997. </year>
Reference-contexts: Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification <ref> [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46] </ref>. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments. <p> Our model contains an explicit representation of enabled actions. The system progresses through a series of enabled actions, each one potentially changing the state of the system. Locks, semaphores, barriers, etc. are represented as enabling conditions for actions. Compositional language-independent specification and verification systems have been proposed by Broy <ref> [10] </ref> and Xu, de Roever, and He [46]. These systems show how to reason compositionally, giving formal proofs of the conditions under which compositional reasoning and refinement can take place.
Reference: [11] <author> K. Mani Chandy and Leslie Lamport. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1):6375, </volume> <month> February </month> <year> 1985. </year>
Reference-contexts: A guard may be evaluated an arbitrary number of times, so all method calls in guards must be to read-only methods. Determining this property of methods requires further compiler extensions. Dependable Distributed Objects 7 Chandy and Lamport <ref> [11] </ref>), or search through a set of available checkpoints in an effort to find a mutually consistent subset.
Reference: [12] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <year> 1988. </year> <note> Reprinted with corrections, </note> <month> May </month> <year> 1989. </year>
Reference-contexts: Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification <ref> [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46] </ref>. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments. <p> We have chosen TLA [25] (the Temporal Logic of Actions), which has a complete Composition Theorem [1], meaning that all properties of a synthesis follow from the properties of its parts and the Composition Theorem. Note, however, that other concurrent logics could be used, such as Unity <ref> [12] </ref> with a complete composition rule [13]. Both TLA and Unity are state-based, meaning that they favor a shared variable model. Action-based models such as I/O Automata [28] favor a message-passing model. A concurrent object system, however, draws from both kinds of models.
Reference: [13] <author> Pierre Collette and Edgar Knapp. </author> <title> A foundation for modular reasoning about safety and progress properties of state-based concurrent programs. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 183(2):25379, </address> <month> September </month> <year> 1997. </year> <note> 18 James, Singh </note>
Reference-contexts: Note, however, that other concurrent logics could be used, such as Unity [12] with a complete composition rule <ref> [13] </ref>. Both TLA and Unity are state-based, meaning that they favor a shared variable model. Action-based models such as I/O Automata [28] favor a message-passing model. A concurrent object system, however, draws from both kinds of models.
Reference: [14] <author> Frank S. de Boer. </author> <title> A proof system for the parallel object-oriented language POOL. </title> <editor> In M. S. Paterson, editor, </editor> <booktitle> ICALP '90, volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 57285, </pages> <institution> Warwick University, </institution> <address> England, </address> <month> 1620 July </month> <year> 1990. </year>
Reference-contexts: They find that the process group mechanism provides a good application structuring mechanism for reliable applications. We address the structuring of nodes into static groups in Section 3 when we discuss compositional recovery mechanisms. A proof system for the parallel object-oriented language POOL is developed in <ref> [14] </ref>. This proof system enables proofs of safety properties, but is not adequate for general liveness properties. Furthermore, the proof system is inextricably tied to the language. Nevertheless, it represents an important step forward in the design 4 James, Singh of practical proof systems for concurrent object-oriented languages.
Reference: [15] <author> Geert Deconinck, Johan Vounckx, Rudy Lauwereins, and Jean Peperstraete. </author> <title> Survey of backward error recovery techniques for multicomputers based on checkpointing and rollback. </title> <journal> International Journal of Modelling and Simulation, </journal> <volume> 18(1):6671, </volume> <year> 1998. </year>
Reference-contexts: In Section 4, we describe the specification and verification methodology for our system. Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery <ref> [15, 16, 37, 38] </ref>, and compositional specification and verification [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46]. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments.
Reference: [16] <author> E. N. Elnozahy, D. B. Johnson, and Y. M. Wang. </author> <title> A survey of rollback-recovery protocols in message-passing systems. </title> <type> Technical Report CMU-CS 96181, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> 3 October </month> <year> 1996. </year>
Reference-contexts: In Section 4, we describe the specification and verification methodology for our system. Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery <ref> [15, 16, 37, 38] </ref>, and compositional specification and verification [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46]. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments.
Reference: [17] <author> E. N. Elnozahy, D. B. Johnson, and W. Zwaenepoel. </author> <title> The performance of consistent checkpointing. </title> <booktitle> In 11th Symposium on Reliable Distributed Systems, </booktitle> <pages> pages 3947, </pages> <address> Houston, TX, USA, </address> <month> 57 October </month> <year> 1992. </year>
Reference-contexts: In Section 4, we describe the specification and verification methodology for our system. Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., <ref> [3, 6, 17, 35, 40, 47] </ref>), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46]. In this section, we list some of the more closely-related work.
Reference: [18] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: This scheme was designed for large open systems. Formal specification and verification is carried out by translating from a formal object-oriented system model into TLA [25], and proving the TLA properties. The system is based on Java <ref> [18] </ref>, due to its portability and support for object-oriented programming. However, Java is not fully suited for distributed system development (e.g., [8, 9]). In particular, some simple, commonly-used distributed system programming constructs (such as guarded atomic actions) cannot be expressed simply. <p> The Kan compiler produces standard Java bytecode, and the runtime system is written in standard Java, allowing Kan programs to run on any system with a Java installation. The underlying object model is similar to that used by C++ [44], Java <ref> [18] </ref>, Orca [5], and related languages. The major differences are as follows. First, con-currency is introduced by asynchronous method calls. The ability to overlap communication with computation has always been important in distributed systems, but will become more so as computing nodes increase in speed.
Reference: [19] <author> Bart P. F. Jacobs, Joachim A. G. M. van den Berg, Marieke Huisman, Martijn van Berkum, Ulrich Hensel, and Hendrik Tews. </author> <title> Reasoning about Java classes. </title> <booktitle> In OOPSLA '98, </booktitle> <address> Vancouver, British Columbia, Canada, </address> <month> 1822 October </month> <year> 1998. </year> <note> To appear. </note>
Reference-contexts: Furthermore, the proof system is inextricably tied to the language. Nevertheless, it represents an important step forward in the design 4 James, Singh of practical proof systems for concurrent object-oriented languages. A proof system for unmodified Java classes is presented in <ref> [19] </ref>. The technique is very similar to ours, in that the classes are translated to the input language of an existing verification system (PVS, in this case). This system can not yet handle arbitrary Java input, but is a necessary step toward that eventuality.
Reference: [20] <author> Jerry James and Ambuj K. Singh. </author> <title> Compositional proofs for concurrent objects. </title> <editor> In Willem-Paul de Roever, editor, </editor> <address> COMPOS '97, Malente, Germany, </address> <month> September </month> <year> 1997. </year> <note> Springer. To appear as a volume of Lecture Notes in Computer Science. </note>
Reference-contexts: Finally, operations on multiple objects are achieved through nested transactions, in which a (partially) synchronous method call is made inside a transaction. We have explored a compositional proof methodology for this object model <ref> [20] </ref>, described in Section 4, that allows us to prove properties of individual objects, and compose them to reason about entire systems. Atomic actions are expressed with atomic transactions, which are arbitrarily-sized units of code whose effects are guaranteed to be equivalent to some linear order of execution. <p> However, we have to redo the proof of the enqueue method, and verify that it does not violate the environment assumptions of the dequeue method. 4.5 Current State A more complete description of the specification and verification methodology presented above can be found in <ref> [20] </ref>. We have used this methodology to prove properties of a number of simple objects, such as several variations on buffers and a PIF (propagation of information with feedback) process coordination algorithm.
Reference: [21] <author> H.-M. Jrvinen, R. Kurki-Suonio, M. Sakkinen, and K. Syst. </author> <title> Object-oriented specification of reactive systems. </title> <booktitle> In Proc. 12th Int. Conf. on Software Eng., </booktitle> <pages> pages 6371, </pages> <year> 1990. </year>
Reference-contexts: Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification <ref> [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46] </ref>. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments. <p> This system can not yet handle arbitrary Java input, but is a necessary step toward that eventuality. Again, the proof system is tied to the input language. DisCo <ref> [21] </ref> is an object-oriented specification language for reactive systems that is based on the joint action model of execution (see [24] for an example of its use). It has guarded multi-object actions instead of single-object methods.
Reference: [22] <author> H. Kopetz and S. Poledna. </author> <title> A node as a real-time object. </title> <booktitle> In WORDS '96, </booktitle> <pages> pages 27, </pages> <address> Laguna Beach, CA, USA, </address> <month> 12 February </month> <year> 1996. </year>
Reference-contexts: Our work has the same goals of providing transparent fault recovery to the application programmer via replication on standard commercial systems. Kopetz and Poledna <ref> [22] </ref> argue that a node should be viewed as an object for the purpose of making real-time guarantees. This abstraction is also useful for providing fault-tolerance guarantees, a subject we touch on in this paper.
Reference: [23] <author> Hermann Kopetz. </author> <title> A communication infrastructure for a fault-tolerant distributed real-time system. </title> <journal> Control Engineering Practice, </journal> <volume> 3(8):113946, </volume> <month> August </month> <year> 1995. </year>
Reference-contexts: Kopetz and Poledna [22] argue that a node should be viewed as an object for the purpose of making real-time guarantees. This abstraction is also useful for providing fault-tolerance guarantees, a subject we touch on in this paper. Kopetz <ref> [23] </ref> also argues the importance of compositionality in designing communication systems for distributed real-time systems. Again, the same issues arise when designing fault-tolerant distributed systems. We discuss compositionality in Section 4 of this paper.
Reference: [24] <author> Reino Kurki-Suonio. </author> <title> Incremental specification with joint actions: The RPC-memory specification problem. </title> <editor> In Manfred Broy, Stephan Merz, and Katha-rina Spies, editors, </editor> <title> Formal Systems Specification: The RPC-Memory Specification Case Study, </title> <booktitle> volume 1169 of Lecture Notes in Computer Science, </booktitle> <pages> pages 375404. </pages> <publisher> Springer, </publisher> <address> Berlin, </address> <year> 1996. </year> <title> Dependable Distributed Objects 19 </title>
Reference-contexts: Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification <ref> [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46] </ref>. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments. <p> This system can not yet handle arbitrary Java input, but is a necessary step toward that eventuality. Again, the proof system is tied to the input language. DisCo [21] is an object-oriented specification language for reactive systems that is based on the joint action model of execution (see <ref> [24] </ref> for an example of its use). It has guarded multi-object actions instead of single-object methods. Like our model, DisCo has a formal basis in TLA; i.e., it can be considered another example of an object model with a TLA-based proof system.
Reference: [25] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(3):872923, </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: Fault tolerance is supported by a compositional forward recovery scheme, which recovers both objects and threads in the event of node failures. This scheme was designed for large open systems. Formal specification and verification is carried out by translating from a formal object-oriented system model into TLA <ref> [25] </ref>, and proving the TLA properties. The system is based on Java [18], due to its portability and support for object-oriented programming. However, Java is not fully suited for distributed system development (e.g., [8, 9]). <p> Objects provide a convenient abstraction for reasoning about such systems. We provide a formal specification and verification methodology for our concurrent object-oriented model. We provide a translation from model components to TLA <ref> [25] </ref> formulas, and use TLA to construct the proofs. TLA has a Composition Theorem [1] which we use to derive system properties by composing object properties. Our proof system supports proof reuse in subclasses by elucidating the conditions under which method properties continue to hold. <p> Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification <ref> [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46] </ref>. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments. <p> Creating a proof system is difficult and error-prone work, so we want to avoid creating a new proof system for every variation in our object model. Instead, we translate from our model into an established non-object-oriented specification language. We have chosen TLA <ref> [25] </ref> (the Temporal Logic of Actions), which has a complete Composition Theorem [1], meaning that all properties of a synthesis follow from the properties of its parts and the Composition Theorem. Note, however, that other concurrent logics could be used, such as Unity [12] with a complete composition rule [13].
Reference: [26] <author> Leslie Lamport. </author> <title> Composition: A way to make proofs harder. </title> <note> SRC Technical Note 1997030a, </note> <institution> Digital Equipment Corporation, </institution> <month> 9 December </month> <year> 1997. </year>
Reference-contexts: However, a number of design choices must be made when creating a proof system. For example, the underlying object model must be both simple enough to support compositional reasoning, and rich enough to model actual systems. Also, since composition tends to make proofs more complex <ref> [26] </ref>, the proof system should support both proof and code reuse in subclasses to conserve effort. Creating a proof system is difficult and error-prone work, so we want to avoid creating a new proof system for every variation in our object model.
Reference: [27] <author> Doug Lea. </author> <title> Concurrent Programming in Java: Design Principles and Patterns. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <year> 1997. </year>
Reference-contexts: For example, the canonical form for a guarded action in Java is given in Figure 1 <ref> [27, page 90] </ref>. This code requires that notify or notifyAll be called anywhere in the code that condition can change from false to true, to wake up any threads waiting on the condition. <p> If the programmer omits such a call at any point where the condition might become true, starvation or deadlock can result. Also, in some cases, the construction of a subclass requires changing uses of notify in the parent class to notifyAll to avoid such problems <ref> [27, page 125] </ref>. In spite of problems with the underlying model, we chose Java as the base language for the Kan project, due to its portability and support for heterogeneous systems.
Reference: [28] <author> Nancy A. Lynch and Mark Tuttle. </author> <title> An introduction to input/output automata. </title> <journal> CWI Quarterly, </journal> <volume> 2(3):21946, </volume> <month> September </month> <year> 1989. </year>
Reference-contexts: Note, however, that other concurrent logics could be used, such as Unity [12] with a complete composition rule [13]. Both TLA and Unity are state-based, meaning that they favor a shared variable model. Action-based models such as I/O Automata <ref> [28] </ref> favor a message-passing model. A concurrent object system, however, draws from both kinds of models. Methods share state of the enclosing object; objects send messages to (make method calls on) one another.
Reference: [29] <author> L. E. Moser, P. M. Melliar-Smith, and P. Narasimhan. </author> <title> Consistent object replication in the Eternal system. </title> <journal> Theory and Practice of Object Systems, </journal> <volume> 4(2):81 92, </volume> <year> 1998. </year>
Reference-contexts: Our system provides atomic transactions and distributed exceptions, which are used in [45] to support conversations. However, we do not provide explicit conversation support. The goal of the Eternal <ref> [29] </ref> system is to run without interruption in the presence of failures and system upgrades. This is accomplished by enhancing CORBA objects with fault-tolerance and real-time guarantees via the Realize system [30], and running on a totally ordered, multicast, fault-tolerant messaging system.
Reference: [30] <author> L. E. Moser, P. Narasimhan, and P. M. Melliar-Smith. </author> <title> Object-oriented programming of complex fault-tolerant real-time systems. </title> <booktitle> In WORDS '96, </booktitle> <pages> pages 1169, </pages> <address> Laguna Beach, CA, USA, </address> <month> 12 February </month> <year> 1996. </year>
Reference-contexts: However, we do not provide explicit conversation support. The goal of the Eternal [29] system is to run without interruption in the presence of failures and system upgrades. This is accomplished by enhancing CORBA objects with fault-tolerance and real-time guarantees via the Realize system <ref> [30] </ref>, and running on a totally ordered, multicast, fault-tolerant messaging system. Our work has the same goals of providing transparent fault recovery to the application programmer via replication on standard commercial systems.
Reference: [31] <author> Nuno Neves and W. Kent Fuchs. </author> <title> Adaptive recovery for mobile environments. </title> <journal> Communications of the ACM, </journal> <volume> 40(1):6874, </volume> <month> January </month> <year> 1997. </year>
Reference-contexts: In this section, we list some of the more closely-related work. Neves and Fuchs <ref> [31] </ref> consider the problem of recovery in mobile environments. The solutions they propose are also applicable to the distributed system case, where the processing power of individual nodes typically outstrips the network capacity.
Reference: [32] <author> Nuno Neves and W. Kent Fuchs. RENEW: </author> <title> A tool for fast and efficient implementation of checkpoint protocols. </title> <booktitle> In FTCS '98, </booktitle> <pages> pages 3847, </pages> <address> Munich, Germany, </address> <month> 2325 June </month> <year> 1998. </year>
Reference-contexts: The Kan system also provides checkpoints for homogeneous environments, but approaches the problem in a different way. We produce checkpoints for a system that runs in homogeneous environments (Java), thereby eliminating the need for redundant checkpoints. The RENEW system <ref> [32] </ref> provides a flexible set of operations for simulating and experimenting with checkpoint protocols. A study conducted with this tool found that, although a message-logging protocol had degraded performance over pure checkpointing protocols, all protocols required approximately equal time to restore application state after a failure.
Reference: [33] <author> Susan Owicki and David Gries. </author> <title> An axiomatic proof technique for parallel programs I. </title> <journal> Acta Informatica, </journal> <volume> 6(4):319340, </volume> <year> 1976. </year>
Reference-contexts: The guard may only reference the state of the associated object and the executing thread 1 . A trivial guard is true in all states. The guard plays much the same role as in Owicki and Gries' system <ref> [33] </ref>, ensuring that the local state meets some criterion before the following atomic step takes place. However, our construction differs from their await B then S construction in allowing method calls inside a transaction.
Reference: [34] <author> Paritosh K. Pandya and Mathai Joseph. </author> <title> P-A logica compositional proof system for distributed programs. </title> <booktitle> Distributed Computing, </booktitle> <address> 5(1):3754, </address> <year> 1991. </year>
Reference-contexts: Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification <ref> [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46] </ref>. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments.
Reference: [35] <author> J. S. Plank and W. R. Elwasif. </author> <title> Experimental assessment of workstation failures and their impact on checkpointing systems. </title> <booktitle> In FTCS '98, </booktitle> <pages> pages 4857, </pages> <address> Munich, Germany, </address> <month> 2325 June </month> <year> 1998. </year>
Reference-contexts: In Section 4, we describe the specification and verification methodology for our system. Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., <ref> [3, 6, 17, 35, 40, 47] </ref>), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46]. In this section, we list some of the more closely-related work.
Reference: [36] <author> Amir Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <editor> In Krzysztof R. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, volume 13 of NATO ASI Series F, </booktitle> <pages> pages 12344. </pages> <publisher> Springer-Verlag, </publisher> <address> Heidelberg, </address> <year> 1985. </year>
Reference-contexts: Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification <ref> [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46] </ref>. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments.
Reference: [37] <author> D. K. Pradhan and N. H. Vaidya. </author> <title> Roll-forward and rollback recovery: </title> <journal> Performance-reliability trade-off. IEEE Transactions on Computers, </journal> <volume> 46(3):3728, </volume> <month> March </month> <year> 1997. </year>
Reference-contexts: In Section 4, we describe the specification and verification methodology for our system. Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery <ref> [15, 16, 37, 38] </ref>, and compositional specification and verification [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46]. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments.
Reference: [38] <author> A. Romanovsky, B. Randell, R. Stroud, J. Xu, and A. Zorzo. </author> <title> Implementation of blocking coordinated atomic actions based on forward error recovery. </title> <journal> Journal of Systems Architecture, </journal> <volume> 43(10):68799, </volume> <month> September </month> <year> 1997. </year> <note> 20 James, Singh </note>
Reference-contexts: In Section 4, we describe the specification and verification methodology for our system. Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery <ref> [15, 16, 37, 38] </ref>, and compositional specification and verification [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46]. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments.
Reference: [39] <author> J. Hamilton Slye and E. N. Elnozahy. </author> <title> Supporting nondeterministic execution in fault-tolerant systems. </title> <booktitle> In FTCS '96, </booktitle> <pages> pages 2509, </pages> <address> Sendai, Japan, </address> <month> 25 27 June </month> <year> 1996. </year>
Reference-contexts: Hence, nondeterministic events appear to take place between atomic actions. We design our thread scheduler to generate a list of atomic actions commits, in some serial order consistent with the actual execution. We then use an instruction counting technique <ref> [39] </ref> to identify the points at which nondeterministic events take place. From the foregoing, it is sufficient to log object and thread creation, thread completion (with the return value, if any), and atomic action commits.
Reference: [40] <author> Kuo-Feng Ssu and W. Kent Fuchs. </author> <title> PREACHESPortable recovery and checkpointing in heterogeneous systems. </title> <booktitle> In FTCS '98, </booktitle> <pages> pages 3847, </pages> <address> Munich, Germany, </address> <month> 2325 June </month> <year> 1998. </year>
Reference-contexts: In Section 4, we describe the specification and verification methodology for our system. Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., <ref> [3, 6, 17, 35, 40, 47] </ref>), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46]. In this section, we list some of the more closely-related work. <p> Dependable Distributed Objects 3 Also, in a shared-nothing system (typical of large distributed systems), checkpoints must be stored on remote nodes to survive permanent crashes, just as with mobile nodes. The latter is the solution we employ for tolerating permanent failures. The PREACHES system <ref> [40] </ref> provides checkpointing in homogeneous environments by saving one checkpoint for every platform type in the system. The Kan system also provides checkpoints for homogeneous environments, but approaches the problem in a different way.
Reference: [41] <author> Eugene W. Stark. </author> <title> A proof technique for rely/guarantee properties. </title> <editor> In S. N. Maheshwari, editor, </editor> <booktitle> FST&TCS '85, volume 206 of Lecture Notes in Computer Science, </booktitle> <pages> pages 36991, </pages> <address> New Delhi, India, </address> <month> 1618 December </month> <year> 1985. </year>
Reference-contexts: Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification <ref> [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46] </ref>. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments.
Reference: [42] <author> Raymie Stata and John V. Guttag. </author> <title> Modular reasoning in the presence of sub-classing. </title> <booktitle> In OOPSLA '95, pages 20014, </booktitle> <address> Austin, TX, USA, </address> <month> 1519 October </month> <year> 1995. </year>
Reference-contexts: However, the user of the priority queue needs to know its interface only. This leads us to distinguish between abstract and concrete properties of an object. Although this distinction is very language-dependent and perhaps somewhat arbitrary, it has been shown to be useful in structuring object class development <ref> [42] </ref>.
Reference: [43] <author> Guy L. Steele, Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, USA, 2nd edition, </address> <year> 1990. </year>
Reference-contexts: Thus, proofs constructed for one member of a class apply to all instances of that class. For the moment, we assume that class implementations are fixed in advance, so that we may reason from the program text. This assumption does not hold for all languages. For example, Common Lisp <ref> [43] </ref> has a Meta-Object Protocol (MOP) that allows the user to construct and alter classes at runtime. Such systems introduce complexities that we do not address. 3 Fault Tolerance In this section, we outline our design for tolerating node failures in distributed systems.
Reference: [44] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <note> 3rd edition, </note> <year> 1997. </year>
Reference-contexts: The Kan compiler produces standard Java bytecode, and the runtime system is written in standard Java, allowing Kan programs to run on any system with a Java installation. The underlying object model is similar to that used by C++ <ref> [44] </ref>, Java [18], Orca [5], and related languages. The major differences are as follows. First, con-currency is introduced by asynchronous method calls. The ability to overlap communication with computation has always been important in distributed systems, but will become more so as computing nodes increase in speed.
Reference: [45] <author> Jie Xu, Brian Randell, Alexander Romanovsky, Cecilia M. F. Rubira, Robert J. Stroud, and Zhixue Wu. </author> <title> Fault tolerance in concurrent object-oriented software through coordinated error recovery. </title> <booktitle> In FTCS '95, </booktitle> <pages> pages 499508, </pages> <address> Pasadena, CA, USA, </address> <month> 2730 June </month> <year> 1995. </year>
Reference-contexts: In our system, the desirability of roll forward recovery mandates the use of message logging. Transactions and conversations are proposed as constructs for handling error recovery in <ref> [45] </ref>. Both may be nested, although nested conversations may involve only a subset of the nodes in the parent conversation. Both are special cases of the more general Coordinated Action. <p> Both are special cases of the more general Coordinated Action. Atomic objects are the means by which the outside world is affected, so that aborts and restarts do not cause undesirable side effects. Our system provides atomic transactions and distributed exceptions, which are used in <ref> [45] </ref> to support conversations. However, we do not provide explicit conversation support. The goal of the Eternal [29] system is to run without interruption in the presence of failures and system upgrades.
Reference: [46] <author> Qiwen Xu, Willem-Paul de Roever, and Jifeng He. </author> <title> The rely-guarantee method for verifying shared variable concurrent programs. </title> <journal> Formal Aspects of Computing, </journal> <volume> 9(2):14974, </volume> <year> 1997. </year>
Reference-contexts: Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., [3, 6, 17, 35, 40, 47]), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification <ref> [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46] </ref>. In this section, we list some of the more closely-related work. Neves and Fuchs [31] consider the problem of recovery in mobile environments. <p> The system progresses through a series of enabled actions, each one potentially changing the state of the system. Locks, semaphores, barriers, etc. are represented as enabling conditions for actions. Compositional language-independent specification and verification systems have been proposed by Broy [10] and Xu, de Roever, and He <ref> [46] </ref>. These systems show how to reason compositionally, giving formal proofs of the conditions under which compositional reasoning and refinement can take place.
Reference: [47] <author> Avi Ziv and Jehoshua Bruck. </author> <title> Analysis of checkpointing schemes with task duplication. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 47(2):2227, </volume> <month> February </month> <year> 1998. </year>
Reference-contexts: In Section 4, we describe the specification and verification methodology for our system. Finally, we conclude with notes on future work in Section 5. 1.1 Related Work Much work has been done on checkpointing and logging algorithms (e.g., <ref> [3, 6, 17, 35, 40, 47] </ref>), backward and forward recovery [15, 16, 37, 38], and compositional specification and verification [2, 7, 10, 12, 21, 24, 25, 34, 36, 41, 46]. In this section, we list some of the more closely-related work.
References-found: 46

