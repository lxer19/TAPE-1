URL: ftp://db.stanford.edu/pub/papers/view.ps
Refering-URL: http://www.cs.toronto.edu/~mendel/dwbib.html
Root-URL: 
Title: Physical Database Design for Data Warehouses  
Author: Wilburt Juan Labio Dallan Quass Brad Adelberg 
Keyword: data warehouses, materialized views, view maintenance, index selection, and  
Date: 1138  
Note: Paper Number  physical database design, A*.  
Abstract: Data warehouses collect copies of information from remote sources into a single database. Since the remote data is cached at the warehouse, it appears as local relations to the users of the warehouse. To improve query response time, the warehouse administrator (WHA) will often materialize views defined on the local relations to support common or complicated queries. Unfortunately, the requirement to keep the views consistent with the local relations creates additional overhead when the remote sources change. The warehouse is often kept only loosely consistent with the sources: it is periodically refreshed with changes sent from the source. When this happens, the warehouse is taken off-line until the local relations and materialized views can be updated. Clearly, the users would prefer as little down time as possible. Often the down time can be reduced by adding carefully selected materialized views or indexes to the physical schema. This paper studies how to select the sets of supporting views and of indexes to materialize to minimize the down time. We call this the view index selection (VIS) problem. We present an A* search based solution to the problem as well as rules of thumb. We also perform additional experiments to understand the space-time tradeoff as it applies to data warehouses. 
Abstract-found: 1
Intro-found: 1
Reference: [CBC93] <author> S. Choenni, H. Blanken, and T. Chang. </author> <title> On the selection of secondary indices in relational databases. </title> <journal> Data and Knowledge Engineering, </journal> <volume> 11 </volume> <pages> 207-33, </pages> <year> 1993. </year>
Reference: [For82] <author> C. L. Forgy. </author> <title> Rete: A fast algorithm for the many pattern/many object pattern match problem. </title> <journal> Artificial Intelligence, </journal> <volume> 19 </volume> <pages> 17-37, </pages> <year> 1982. </year>
Reference-contexts: Many authors have considered how to evaluate trigger conditions for rules. This can be considered a view maintenance problem where a rule is triggered whenever the view that satisfies its condition becomes non-empty. Wang and Hanson [WH92] study how the production system algorithms Rete <ref> [For82] </ref> and TREAT [Mir87] perform in a database environment. An extension to TREAT called A-TREAT is considered in [Han92]. Fabret et al. [FRS93] took an approach similar to ours by considering how to choose supporting views for the trigger condition view.
Reference: [FRS93] <author> F. Fabret, M. Regnier, and E. Simon. </author> <title> An adaptive algorithm for incremental evaluation of production rules in database. </title> <booktitle> In Proceedings of International Conference on Very Large Data Bases, </booktitle> <pages> pages 455-66, </pages> <year> 1993. </year>
Reference-contexts: Wang and Hanson [WH92] study how the production system algorithms Rete [For82] and TREAT [Mir87] perform in a database environment. An extension to TREAT called A-TREAT is considered in [Han92]. Fabret et al. <ref> [FRS93] </ref> took an approach similar to ours by considering how to choose supporting views for the trigger condition view.
Reference: [FST88] <author> S. Finkelstein, M. Schkolnick, and P. Tiberio. </author> <title> Physical database design for relational databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 91-128, </pages> <year> 1988. </year>
Reference-contexts: Thus, to consider all possible subsets of C, we need to evaluate roughly O (2 2 n ) different view states. 2.1.2 Choosing the indexes Now we must consider all possible subsets of the set of candidate indexes, I. Candidate indexes, as defined in Finkelstein et. al. <ref> [FST88] </ref>, are indexes on the following types of attributes: 4 * attributes with selection or join predicates on them. 1 * key attributes for base relations where changes to the base relation include deletions or up dates. <p> When views are materialized on the base relations, key attributes of any base relation appearing in the view also qualify. * attributes in GROUP BY or ORDER BY clauses. Additional attributes can be candidates depending on the query optimizer being used. The reader is refered to <ref> [FST88] </ref> for more detail. Since each materialized view will usually have candidate indexes, I must be recomputed at the beginning of every inner loop. The cardinality of I for a particular view state is roughly proportional to the number of materialized views and base relations in that state. <p> The only area where the optimizer seems sensitive is in the range shown in the middle of the 2 It also depends on how closely the VIS optimizer's cost model follows that of the dbms. This concept is discussed in <ref> [FST88] </ref>. 0 R R0 R1 0 S S0 S1 0 T T0 T1 4T' T0 T1 (a) Low Update Rate 10 10 0 RST R0 R1 S0 T0 T1S1 3 (b) High Update Rate 5 6 0 RST R0 R1 S0 S1 T0 T1 graph where an order of magnitude error
Reference: [GL95] <author> T. Griffin and L. Libkin. </author> <title> Incremental maintenance of views with duplicates. </title> <editor> In M. Carey and D. Schneider, editors, </editor> <booktitle> Proceedings of ACM SIGMOD 1995 International Conference on Manage ment of Data, </booktitle> <pages> pages 328-339, </pages> <address> San Jose, CA, </address> <month> May 23-25 </month> <year> 1995. </year> <month> 25 </month>
Reference-contexts: In order to make a materialized view consistent again with the base relations from which it is derived, the view may either be recomputed from scratch, or incrementally maintained [GMS93] by calculating just the effects of the deltas on the view. These effects are captured in view maintenance expressions <ref> [GL95] </ref>. Each type of change (insertion, deletion, or update) requires a different expression. For example, if view RST in Figure 1 is materialized, the maintenance expression calculating the tuples to insert into RST due to insertions into R is 4R1S1T , where 4R denotes the insertions into R.
Reference: [GMS93] <author> A. Gupta, I. Mumick, and V. Subrahmanian. </author> <title> Maintaining views incrementally. </title> <booktitle> In Proceedings of ACM SIGMOD 1993 International Conference on Management of Data, </booktitle> <address> Washington, DC, </address> <month> May 26-28 </month> <year> 1993. </year>
Reference-contexts: In order to make a materialized view consistent again with the base relations from which it is derived, the view may either be recomputed from scratch, or incrementally maintained <ref> [GMS93] </ref> by calculating just the effects of the deltas on the view. These effects are captured in view maintenance expressions [GL95]. Each type of change (insertion, deletion, or update) requires a different expression.
Reference: [Han92] <author> E. Hanson. </author> <title> Rule condition testing and action execution in Ariel. </title> <booktitle> In Proceedings of 1992 ACM SIGMOD, </booktitle> <pages> pages 49-58, </pages> <year> 1992. </year>
Reference-contexts: Wang and Hanson [WH92] study how the production system algorithms Rete [For82] and TREAT [Mir87] perform in a database environment. An extension to TREAT called A-TREAT is considered in <ref> [Han92] </ref>. Fabret et al. [FRS93] took an approach similar to ours by considering how to choose supporting views for the trigger condition view.
Reference: [HRU96] <author> V. Harinarayan, A. Rajaraman, and J.D. Ullman. </author> <title> Implementing data cubes efficiently. </title> <booktitle> In Pro ceedings of 1996 ACM SIGMOD, </booktitle> <year> 1996. </year>
Reference-contexts: Other work has looked at the initial problem of choosing a set of primary views such that the cost of (1) is minimized, while ensuring that the costs of (2) and (3) are not too high. [SP89] 23 considers this problem in the case of distributed views. <ref> [HRU96] </ref> has investigated this problem for the case of aggregate views. Tsatalos et al. [TSI94] consider materializing views in place of the base relations in order to improve query response time. Rozen et al. [RS91] look at this problem as adding a set of "features" to the database.
Reference: [LMSS95] <author> A. Levy, A. Mendelzon, Y. Sagiv, and D. Srivastava. </author> <title> Answering queries using views. </title> <booktitle> In Proceedings of the Fourteenth Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 95-104, </pages> <address> San Jose, CA, </address> <month> May 22-24 </month> <year> 1995. </year>
Reference-contexts: Suppose the view ST = S1T is also materialized. The query optimization algorithm must consider the possibility of evaluating 4R1S1T as 4R1ST in finding the best query plan. This problem is known as "answering queries using views" <ref> [LMSS95] </ref>. To complicate matters, one batch of changes can generate multiple maintenance expressions that need to be evaluated. This happens due to different types of changes to the base relations. The maintenance expressions can be optimized as a group because of possible common subexpressions [RSS96].
Reference: [LQA96] <author> W. Labio, D. Quass, and B. Adelberg. </author> <title> Physical database design for data warehouses the vis problem. </title> <type> Technical report, </type> <institution> Stanford University, </institution> <year> 1996. </year> <note> Available by anonymous ftp from db.stanford.edu in /pub/labio/1996. </note>
Reference-contexts: The rule of thumb governing when to materialize overlapping supporting views is presented in <ref> [LQA96] </ref>. Rule 5.1 can support materializing a view even when Rule 5.2 doesn't hold. <p> In addition, in the full version of the paper <ref> [LQA96] </ref>, we also consider whether protected updates should be treated atomically or split into pairs of insertions and deletions. The experiments shown in this section were all run on Schema 1 (described in Section 5.1). <p> In this section, we investigate just how badly optimal solutions decay at neighboring points. Due to space constraints, we consider only the estimate of insertion and deletion rates. (The reader is referred to <ref> [LQA96] </ref> for more experimental results.) In this experiment, we varied the combined insertion and deletion rates to each base relation such that the ratio I (R)+D (R) I (S)+D (S) I (T )+D (T ) kT k increased from 0.001 to 0.1 in five steps.
Reference: [Mir87] <author> D. P. Miranker. </author> <title> Treat: A better match algorithm for ai production systems. </title> <booktitle> In Proceedings of AAII 87 Conference on Artificial Intelligence, </booktitle> <pages> pages 42-47, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Many authors have considered how to evaluate trigger conditions for rules. This can be considered a view maintenance problem where a rule is triggered whenever the view that satisfies its condition becomes non-empty. Wang and Hanson [WH92] study how the production system algorithms Rete [For82] and TREAT <ref> [Mir87] </ref> perform in a database environment. An extension to TREAT called A-TREAT is considered in [Han92]. Fabret et al. [FRS93] took an approach similar to ours by considering how to choose supporting views for the trigger condition view.
Reference: [ML89] <author> L.F. Mackert and G.M. Lohman. </author> <title> Index scans using a finite lru buffer: A validated i/o model. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(3) </volume> <pages> 401-24, </pages> <year> 1989. </year>
Reference: [Nil71] <author> N. Nilsson. </author> <title> Problem solving methods in artificial intelligence. </title> <publisher> McGraw-Hill, </publisher> <year> 1971. </year>
Reference-contexts: In this section we describe how we have used the A* algorithm to solve the VIS problem. For further details on the A* algorithm itself, the reader is referred to <ref> [Nil71] </ref>. 8 The algorithm takes as input the set of all possible views and indexes to materialize, M.
Reference: [Rou82] <author> N. Roussopoulos. </author> <title> View indexing in relational databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 7(2) </volume> <pages> 258-90, </pages> <year> 1982. </year>
Reference-contexts: We have assumed that the primary view is materialized, which minimizes the cost of (1), and focused on choosing supporting view and indices such that the cost of (2) is minimized. We have also considered how constraining cost (3) affects our results. This problem was first studied by Roussopoloulos <ref> [Rou82] </ref>. The additional structures considered for materialization are view indices, rather than the views themselves, to save on storage.
Reference: [RS91] <author> S. Rozen and D. Shasha. </author> <title> A framework for automating physical database design. </title> <booktitle> In Proceedings of International Conference on Very Large Data Bases, </booktitle> <pages> pages 401-11, </pages> <year> 1991. </year>
Reference-contexts: Tsatalos et al. [TSI94] consider materializing views in place of the base relations in order to improve query response time. Rozen et al. <ref> [RS91] </ref> look at this problem as adding a set of "features" to the database. In particular, the index selection part of our VIS problem has been well-studied [FST88,CBC93] in the context of physical database design. Choosing indexes for materialized views is a straightfor ward extension.
Reference: [RSS96] <author> K.A. Ross, D. Srivastava, and S. Sudarshan. </author> <title> Materialized view maintenance and integrity con straint checking: Trading space for time. </title> <booktitle> In Proceedings of 1996 ACM SIGMOD, </booktitle> <year> 1996. </year>
Reference-contexts: To find the optimal solution, then, we must solve the optimization problem globally. One approach, proposed in Ross et al. <ref> [RSS96] </ref> (although this work does not consider indices), is to exhaustively search the solution space. Although exhaustive search is impractical for large problems, it illustrates the complexity of the problem and provides a basis of comparison for other solutions. <p> As proposed in <ref> [RSS96] </ref>, we consider as candidate views all distinct nodes that appear in a query plan for the primary view. Since the primary view is already materialized, it is not included in the candidate view set. For example, given a view V = R1S1T , C = fRS; RT; ST g. <p> To complicate matters, one batch of changes can generate multiple maintenance expressions that need to be evaluated. This happens due to different types of changes to the base relations. The maintenance expressions can be optimized as a group because of possible common subexpressions <ref> [RSS96] </ref>. This problem is known as the "multiple-query optimization" problem [Sel88]. 2.2 Example Consider the following base relations and view. 1 In addition, the system must be able to use an index to process the predicate. <p> In addition, indexes on V , the base relations, and the supporting views need to be considered. It is useful to think of the expression dag in Figure 3 when considering the different update paths <ref> [RSS96] </ref> changes to base relations can take as they are propagated to the view. An update path corresponds to a specific query plan for evaluating a view maintenance expression. <p> Relaxing either of the above two assumptions invalidates the use of the Roussopoloulos algorithm. Still, this is a good first treatment of the subject and the author presents experimental results for the algorithm. More recently, Ross et al. <ref> [RSS96] </ref> examines the same problem. They describe an exhaustive search algorithm to solve the view selection problem but without considering indexes. They also propose heuristics for pruning the space to search. <p> We described and implemented an optimal algorithm based on A* that vastly prunes the search space compared to previously proposed algorithms <ref> [RSS96] </ref>. Since even the A* algorithm is impractical for many real world problems, we developed rules of thumb for view and index selection. These rules were validated through both analysis and experimental results.
Reference: [Sel88] <author> T. Sellis. </author> <title> Multiple-query optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 13(1) </volume> <pages> 23-52, </pages> <year> 1988. </year>
Reference-contexts: This happens due to different types of changes to the base relations. The maintenance expressions can be optimized as a group because of possible common subexpressions [RSS96]. This problem is known as the "multiple-query optimization" problem <ref> [Sel88] </ref>. 2.2 Example Consider the following base relations and view. 1 In addition, the system must be able to use an index to process the predicate.
Reference: [SF91] <author> A. Segev and W. Fang. </author> <title> Optimal update policies for distribtued materialized views. </title> <journal> Management Science, </journal> <volume> 17(7) </volume> <pages> 851-70, </pages> <year> 1991. </year>
Reference-contexts: We have found through the results of our experimentation that for our environment almost the opposite is true. We have a rule of thumb that specifies to materialize a view when no deletions (insertions are fine) are expected to the base relations involved in the view. Segev et al. <ref> [SF91, SZ91] </ref> consider a similar problem in expert systems. They also assume small deltas and ubiquitous indexes. They do not, however, consider maintaining subviews of the primary view, but instead describe join pattern indexes, which are specialized structures for maintaining materialized views.
Reference: [SP89] <author> Arie Segev and Jooseok Park. </author> <title> Updating distributed materialized views. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(2) </volume> <pages> 173-184, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Other work has looked at the initial problem of choosing a set of primary views such that the cost of (1) is minimized, while ensuring that the costs of (2) and (3) are not too high. <ref> [SP89] </ref> 23 considers this problem in the case of distributed views. [HRU96] has investigated this problem for the case of aggregate views. Tsatalos et al. [TSI94] consider materializing views in place of the base relations in order to improve query response time.
Reference: [ST85] <author> M. Schkolnick and P. Tiberio. </author> <title> Estimating the cost of updates in a relational database. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 10(2) </volume> <pages> 163-79, </pages> <year> 1985. </year>
Reference: [SZ91] <author> A. Segev and J.L. Zhao. </author> <title> Data management for large rule systems. </title> <booktitle> In Proceedings of International Conference on Very Large Data Bases, </booktitle> <pages> pages 297-307, </pages> <year> 1991. </year>
Reference-contexts: We have found through the results of our experimentation that for our environment almost the opposite is true. We have a rule of thumb that specifies to materialize a view when no deletions (insertions are fine) are expected to the base relations involved in the view. Segev et al. <ref> [SF91, SZ91] </ref> consider a similar problem in expert systems. They also assume small deltas and ubiquitous indexes. They do not, however, consider maintaining subviews of the primary view, but instead describe join pattern indexes, which are specialized structures for maintaining materialized views.
Reference: [TSI94] <author> O.G. Tsatalos, M.H. Solomon, and Y.E. Ioannidis. </author> <title> The gmap: A versatile tool for physical data independence. </title> <booktitle> In Proceedings of International Conference on Very Large Data Bases, </booktitle> <pages> pages 367-78, </pages> <year> 1994. </year>
Reference-contexts: Tsatalos et al. <ref> [TSI94] </ref> consider materializing views in place of the base relations in order to improve query response time. Rozen et al. [RS91] look at this problem as adding a set of "features" to the database.
Reference: [WH92] <author> Y. Wang and E. Hanson. </author> <title> A performance comparison of the rete and treat algorithms for testing database rule conditions. </title> <booktitle> In Proceedings of International Conference on Very Large Data Bases, </booktitle> <pages> pages 88-97, </pages> <year> 1992. </year> <month> 26 </month>
Reference-contexts: Many authors have considered how to evaluate trigger conditions for rules. This can be considered a view maintenance problem where a rule is triggered whenever the view that satisfies its condition becomes non-empty. Wang and Hanson <ref> [WH92] </ref> study how the production system algorithms Rete [For82] and TREAT [Mir87] perform in a database environment. An extension to TREAT called A-TREAT is considered in [Han92]. Fabret et al. [FRS93] took an approach similar to ours by considering how to choose supporting views for the trigger condition view.
References-found: 23

