URL: ftp://ftp.cs.kun.nl/pub/CSI/SoftwEng.FunctLang/papers/baks-CAAP92.ps.gz
Refering-URL: http://www.cs.kun.nl/~clean/Clean.Papers.html
Root-URL: 
Phone: 2  
Title: Partial Type Assignment in Left Linear Applicative Term Rewriting Systems Theory, Applications and Implementation.  
Author: Steffen van Bakel y Sjaak Smetsers Simon Brock 
Address: jmegen, Toernooiveld 1, 6525 ED Nijmegen, The Netherlands.  East Anglia, Norwich NR4 7TJ, United Kingdom.  
Affiliation: 1 Department of Informatics, Faculty of Mathematics and Informatics, University of Ni  School of Information Systems, University of  
Abstract: This paper introduces a notion of partial type assignment on left linear applicative term rewriting systems that is based on the extension defined by Mycroft of Curry's type assignment system. The left linear applicative TRS we consider are extensions to those suggested by most functional programming languages in that they do not discriminate against the varieties of function symbols that can be used in patterns. As such there is no distinction between function symbols (such as append and plus) and constructor symbols (such as cons and succ). Terms and rewrite rules will be written as trees, and type assignment will consist of assigning types to function symbols, nodes and edges between nodes. The only constraints on this system are imposed by the relation between the type assigned to a node and those assigned to its incoming and out-going edges. We will show that every typeable term has a principal type, and formulate a needed and sufficient condition typeable rewrite rules should satisfy in order to gain preservance of types under rewriting. As an example we will show that the optimisation function performed after bracket abstraction is typeable. Finally we will present a type check algorithm that checks if rewrite rules are correctly typed, and finds the principal pair for typeable terms.
Abstract-found: 1
Intro-found: 1
Reference: [Barendregt '84] <author> Barendregt H. </author> <title> The Lambda Calculus: its Syntax and Semantics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <note> revised edition, </note> <year> 1984. </year>
Reference-contexts: Introduction In the recent years several paradigms have been investigated for the implementation of functional programming languages. Not only the lambda calculus <ref> [Barendregt '84] </ref>, but also term rewriting systems [Klop '92] and graph rewriting systems [Barendregt et al. '87] are topics of research.
Reference: [Barendregt et al. '83] <author> Barendregt H., M. Coppo, and M. Dezani-Ciancaglini. </author> <title> A filter lambda model and the completeness of type assignment. </title> <journal> The Journal of Symbolic Logic, </journal> <volume> 48(4) </volume> <pages> 931-940, </pages> <year> 1983. </year>
Reference-contexts: This in fact corresponds to the definition of ML-type 7 assignment as given in [Damas '85], and is used there for dealing with the let-construct. It could also be compared with using intersection types <ref> [Barendregt et al. '83] </ref> on free variables of terms. Unlike in lambda calculus, in term rewriting systems this causes no difficulties, since there is no notion of `abstraction' in this world. Moreover, condition (i.b) of definition 3.2.3 deals with this apparent anomaly.
Reference: [Barendregt et al. '87] <author> Barendregt H.P., M.C.J.D. van Eekelen, J.R.W. Glauert, J.R. Kennaway, M.J. Plasmeijer, </author> <title> and M.R. Sleep. Term graph rewriting. </title> <booktitle> In Proceedings of PARLE, Parallel Architectures and Languages Europe, Eindhoven, The Netherlands, volume 259-II of Lecture Notes in Computer Science, </booktitle> <pages> pages 141-158. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Introduction In the recent years several paradigms have been investigated for the implementation of functional programming languages. Not only the lambda calculus [Barendregt '84], but also term rewriting systems [Klop '92] and graph rewriting systems <ref> [Barendregt et al. '87] </ref> are topics of research.
Reference: [Brus et al. '87] <author> Brus T., M.C.J.D. van Eekelen, M.O. van Leer, and M.J. Plasmeijer. </author> <title> Clean A Language for Functional Graph Rewriting. </title> <booktitle> In Proceedings of the Third International Conference on Functional Programming Languages and Computer Architecture, Portland, Oregon, USA, volume 274 of Lecture Notes in Computer Science, </booktitle> <pages> pages 364-368. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Lambda calculus (or rather combinator systems) forms the underlying model for the functional programming language Miranda [Turner '85], term rewriting systems are used in the underlying model for the language OBJ [Futatsugi et al. '85], and graph rewriting systems is the model for the language Clean <ref> [Brus et al. '87, Nocker et al. '91] </ref>.
Reference: [Curry & Feys '58] <author> Curry H.B. and R. </author> <title> Feys. </title> <booktitle> Combinatory Logic. </booktitle> <volume> volume 1. </volume> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference-contexts: There exists a well understood and well defined notion of type assignment on lambda terms, fl Supported by the Esprit Basic Research Action 3074 "Semagraph". y Partially supported by the Netherlands Organisation for the advancement of pure research (N.W.O.). 1 known as the Curry type assignment system <ref> [Curry & Feys '58] </ref>. This type assignment system is the basis for many type checkers and inferers used in functional programming languages. For example the type assignment system for the language ML [Milner '78], as defined by R. Milner forms in fact an extension of Curry's system. <p> For example we use the word `replacement' for the operation that replaces term variables by terms, instead of the word `substitution', which will be used for operations that replace type variables by types. Substitution and replacement are also operations defined in <ref> [Curry & Feys '58] </ref>. Both operations are there defined as operations on terms, where substitution is defined as the operation that replaces term variables by terms, and replacement is defined as the operation that 4 replaces subterms by terms. <p> <ref> [Curry & Feys '58] </ref>. Both operations are there defined as operations on terms, where substitution is defined as the operation that replaces term variables by terms, and replacement is defined as the operation that 4 replaces subterms by terms. Note that our definition therefore differs from the one given in [Curry & Feys '58]. To denote a replacement, we use capital characters like `R', instead of greek symbols like `', which are used to denote types. We use the symbol `!' for the rewriting symbol, instead of `!' which is used as a type constructor. <p> If in the bracket abstraction we would use the following combinator set: I x = x B x y z = x (y z) C x y z = x z y then we could define, as Curry did in <ref> [Curry & Feys '58] </ref>, the following optimizations: S (K x) (K y) = K (x y) S (K x) y = B x y We can see that these rules work on combinators that have not yet been applied to all their arguments.
Reference: [Damas '85] <author> Damas L.M.M. </author> <title> Type Assignment in Programming Languages. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, Department of Computer Science, Edinburgh, </institution> <year> 1985. </year> <note> Thesis CST-33-85. </note>
Reference-contexts: The bases allowed in the system we present however can contain several different statements for the same term variable. This in fact corresponds to the definition of ML-type 7 assignment as given in <ref> [Damas '85] </ref>, and is used there for dealing with the let-construct. It could also be compared with using intersection types [Barendregt et al. '83] on free variables of terms.
Reference: [Futatsugi et al. '85] <author> Futatsugi K., J. Goguen, J.P. Jouannaud, and J. Meseguer. </author> <booktitle> Principles of OBJ2. In Proceedings 12 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 52-66, </pages> <year> 1985. </year>
Reference-contexts: Lambda calculus (or rather combinator systems) forms the underlying model for the functional programming language Miranda [Turner '85], term rewriting systems are used in the underlying model for the language OBJ <ref> [Futatsugi et al. '85] </ref>, and graph rewriting systems is the model for the language Clean [Brus et al. '87, Nocker et al. '91].
Reference: [Hindley '69] <author> Hindley J.R. </author> <title> The principal type scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <year> 1969. </year>
Reference-contexts: This mapping is also convenient to make sure that types assigned to different occurrences of constants do not conflict. In fact, the approach we take here is very much the same as the one taken by Hindley in <ref> [Hindley '69] </ref>, where he defines the principal type scheme of an object in Combinatory Logic. Even his notion of type assignment could be regarded as a partial one. <p> Moreover, since combinator systems can easily be translated into left linear applicative term rewriting systems, the results of this paper, when restricting the allowed rewrite rules to those that correspond to combinators, are the same as in <ref> [Hindley '69] </ref>. In section 1 we define the left linear applicative term rewriting systems, as the subclass of term rewriting systems that contain a predefined symbol Ap, and in which all rewrite rules are left linear. <p> The use of an environment corresponds to the use of `axiom-schemes', and part (i.c) of definition 3.2.2 to the use of `axioms' as in <ref> [Hindley '69] </ref>. 9 A typical example for part (i.b) of definition 3.2.2 is the function symbol Ap, which has the type (1!2)!1!2.
Reference: [Kfoury et al. '88] <author> Kfoury A.J., J. Tiuryn, and P. Urzyczyn. </author> <title> A proper extension of ML with an effective type-assignment. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <pages> pages 58-69, </pages> <address> San Diego, California, </address> <year> 1988. </year>
Reference-contexts: A real difference between these languages lies in the fact that Miranda also contains a type check algorithm, which is based on the type assignment system defined by A. Mycroft, an extension of Milner's type assignment system <ref> [Mycroft '84, Kfoury et al. '88] </ref>. To provide a formal type system for all languages that use pattern matching this paper presents a formal notion of type assignment on left linear applicative term rewriting systems. <p> In tree representation, this rule looks like: ? ? @ @R ! S 2 I 0 y 3 Type assignment in LLATRS's In this section we present a notion of partial type assignment on LLATRS's, based on the Mycroft type assignment system <ref> [Mycroft '84, Kfoury et al. '88] </ref>. Assigning types to a LLATRS will consist of labelling the nodes and edges in the tree representation of terms and rewrite rules with type information.
Reference: [Klop '92] <author> Klop J.W. </author> <title> Term Rewriting Systems. </title> <editor> In S. Abramsky, Dov M. Gabbay, and T.S.E. Maibaum, editors, </editor> <booktitle> Handbook of Logic in Computer Science, </booktitle> <volume> volume 2, chapter 1, </volume> <pages> pages 1-116. </pages> <publisher> Clarendon Press, </publisher> <year> 1992. </year>
Reference-contexts: Introduction In the recent years several paradigms have been investigated for the implementation of functional programming languages. Not only the lambda calculus [Barendregt '84], but also term rewriting systems <ref> [Klop '92] </ref> and graph rewriting systems [Barendregt et al. '87] are topics of research. <p> a type check algorithm, that checks if rewrite rules are correctly typed, and finds the principal pair for typeable terms. 1 Left linear applicative term rewriting systems In this paper we study left linear applicative term rewriting systems (LLATRS), which are a subclass of term rewriting systems, as defined in <ref> [Klop '92] </ref>. LLATRS's are defined as the class of term rewriting systems that (can) contain a special binary operator Ap, and in which all rewrite rules are left linear. <p> In this paper we consider left linear rewriting systems, that contain only rewrite rules for which the left hand side is linear (term variables occur only once), because for those rules the binding occurrence of a term variable is unique. The following definitions are based on definitions given in <ref> [Klop '92] </ref>. Definition 1.1 defines LLATRS's, in the same way as the definition given by Klop for term rewriting systems, extended with part (i.c) to express the existence of the predefined symbol Ap.
Reference: [Milner '78] <author> Milner R. </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: This type assignment system is the basis for many type checkers and inferers used in functional programming languages. For example the type assignment system for the language ML <ref> [Milner '78] </ref>, as defined by R. Milner forms in fact an extension of Curry's system. The type inference algorithm for the functional programming language Miranda works in roughly the same way as the one for ML.
Reference: [Mycroft '84] <author> Mycroft A. </author> <title> Polymorphic type schemes and recursive definitions. </title> <booktitle> In Proceedings of the International Symposium on Programming, Toulouse, volume 167 of Lecture Notes Computer Science, </booktitle> <pages> pages 217-239. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: A real difference between these languages lies in the fact that Miranda also contains a type check algorithm, which is based on the type assignment system defined by A. Mycroft, an extension of Milner's type assignment system <ref> [Mycroft '84, Kfoury et al. '88] </ref>. To provide a formal type system for all languages that use pattern matching this paper presents a formal notion of type assignment on left linear applicative term rewriting systems. <p> In tree representation, this rule looks like: ? ? @ @R ! S 2 I 0 y 3 Type assignment in LLATRS's In this section we present a notion of partial type assignment on LLATRS's, based on the Mycroft type assignment system <ref> [Mycroft '84, Kfoury et al. '88] </ref>. Assigning types to a LLATRS will consist of labelling the nodes and edges in the tree representation of terms and rewrite rules with type information.
Reference: [Nocker et al. '91] <author> Nocker E.G.J.M.H., J.E.W. Smetsers, M.C.J.D. van Eekelen, and M.J. Plasmeijer. </author> <title> Concurrent Clean. </title> <booktitle> In Proceedings of PARLE '91, Parallel Architectures and Languages Europe, Eindhoven, The Netherlands, volume 506-II of Lecture Notes in Computer Science, </booktitle> <pages> pages 202-219. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Lambda calculus (or rather combinator systems) forms the underlying model for the functional programming language Miranda [Turner '85], term rewriting systems are used in the underlying model for the language OBJ [Futatsugi et al. '85], and graph rewriting systems is the model for the language Clean <ref> [Brus et al. '87, Nocker et al. '91] </ref>.
Reference: [Pfenning '88] <author> Pfenning F. </author> <title> Partial Polymorphic Type Inference and Higher-Order Unification. </title> <booktitle> In Proceedings of the 1988 conference on LISP and Functional Programming Languages, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 153-163. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: It is our aim to extend the notion presented in this paper to a notion of type assignment for term graph rewriting systems, and, possibly, general graph rewriting systems. The type assignment system we present in this paper is a partial system in the sense of <ref> [Pfenning '88] </ref>, because we not only define how terms and rewrite rules can be typed, but also provide a type for each function symbol. There are several reasons to do so.
Reference: [Robinson '65] <author> Robinson J.A. </author> <title> A machine-oriented logic based on the resolution principle. </title> <journal> Journal of the ACM, </journal> <volume> 12(1) </volume> <pages> 23-41, </pages> <year> 1965. </year>
Reference-contexts: tree. ? t !t @ @R 3.3 The principal pair for a term In this subsection we define the principal pair for a typeable term M with respect to E, consisting of basis B and type , by defining the notion pp (M ) using Robinsons unification algorithm unify R <ref> [Robinson '65] </ref>. (Notice that, from a formal point of view, we would have to define pp E (M ), but that again we are omitting the subscript E.) In the following we show that for every typeable term, this is a legal pair and is indeed the most general one.
Reference: [Turner '85] <author> Turner D.A. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In Proceedings of the conference on Functional Programming Languages and Computer Architecture, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-16. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <month> 20 </month>
Reference-contexts: Not only the lambda calculus [Barendregt '84], but also term rewriting systems [Klop '92] and graph rewriting systems [Barendregt et al. '87] are topics of research. Lambda calculus (or rather combinator systems) forms the underlying model for the functional programming language Miranda <ref> [Turner '85] </ref>, term rewriting systems are used in the underlying model for the language OBJ [Futatsugi et al. '85], and graph rewriting systems is the model for the language Clean [Brus et al. '87, Nocker et al. '91].
References-found: 16

