URL: http://www.cs.cmu.edu/~clh/papers/words96.ps.Z
Refering-URL: http://www.cs.cmu.edu/~clh/papers/publications.html
Root-URL: 
Title: An Analytical Approach to Change for the Design of Reusable Real-Time Software Second Workshop on
Author: Carol L. Hoover and Pradeep K. Khosla 
Keyword: Real-time software design, reusable software, change analysis.  
Affiliation: Carnegie Mellon University  
Abstract: In this paper, we present an analytical method for incorporating knowledge about change into the design of reusable real-time software components. We apply this method to the construction of algorithmic software solutions that minimize the effect of anticipated changes in the solution. The motivation for our research is based on two premises: (1) software solutions that can easily be adapted to changes in the problem and solution domains are more readily reused and (2) the reuse of reliable software promotes the construction of high quality software systems and reduces development costs. This paper also briey overviews our current research goals involving analysis and design methods to enable software engineers to rapidly adapt their real-time software solutions to changing application requirements. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Burns and A. Wellings, </author> <title> Real-Time Systems and Their Programming Languages, </title> <publisher> Addison-Wesley Publ., </publisher> <address> Wokingham, England, </address> <year> 1990, </year> <pages> pp. 2-10. </pages>
Reference-contexts: 1 Background It is well-known that real-time systems often have stringent timing and safety requirements <ref> [1] </ref>. The ad hoc way in which software engineers develop and maintain real-time software systems is often difficult, time-consuming, and costly [12]. To make matters worse, as in the example of the software problem that delayed the first NASA Space Shuttle orbital ight, the software process is sometimes error-prone.
Reference: 2. <author> W. B. Frakes and S. Isoda, </author> <title> Success Factors for Systematic Reuse, </title> <journal> IEEE Software, </journal> <month> Sept. </month> <year> 1994, </year> <pages> pp. 14-19. </pages>
Reference-contexts: Software reuse, broadly defined as the use of engineering knowledge or artifacts from existing systems to build new ones, is considered to be an important technology for improving software quality, reducing development cost, and reducing the time-to-market <ref> [2] </ref>. Some researchers argue that reuse does not guarantee the safety of a software solution. For instance, Leveson states that safety is not just a property of the software itself but also a property of the software design and environment in which it is used [10].
Reference: 3. <author> J. R. Garman, </author> <title> The Bug Heard Round the World, </title> <booktitle> ACM SIGSOFT: Software Engineering Notes, </booktitle> <volume> Vol. 6, No. 5, </volume> <month> Oct. </month> <year> 1981. </year>
Reference-contexts: In discussing the Shuttle incident, Garman notes a key idea: though software is easy to change, it is also via change that software is the easiest part of a real-time system to compromise <ref> [3] </ref>. Software reuse, broadly defined as the use of engineering knowledge or artifacts from existing systems to build new ones, is considered to be an important technology for improving software quality, reducing development cost, and reducing the time-to-market [2].
Reference: 4. <author> W. A. Halang, </author> <title> Real-Time Systems: Another Perspective, </title> <editor> K.M. Kavi, ed., </editor> <title> Real-Time Systems: Abstractions, </title> <booktitle> Languages, and Design Methodologies, </booktitle> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> Ca., </address> <year> 1992, </year> <pages> pp. </pages> <month> 11-18.x </month>
Reference-contexts: Similar to the type of analysis used to estimate the dependability of MARS application designs [9], we would like to be able to estimate the cost of software change. Halang states that real-time software systems are more likely to be predictable and dependable if they are simple <ref> [4] </ref>. Our analytical techniques should seek to reduce software complexity. We think there is a need to formally study the way in which software engineers think about change during the design of new software components and about reuse when building new software solutions.
Reference: 5. <author> C. L. </author> <title> Hoover, The Role of the Real-Time Software Engineer: An Introductory Course, </title> <booktitle> in Proc. of the Eighth SEI Conference on Software Engineering Education, </booktitle> <address> New Orleans, La., Mar./Apr. 1995, </address> <publisher> Springer-Verlag, Berlin, </publisher> <pages> pp. 167-186. </pages>
Reference-contexts: Depending upon the type of change and the organization of the software, the software engineer may need to examine and modify multiple parts of the software system <ref> [5] </ref>. During the design of a new application, we would like to be able to experiment with alternative software solutions to achieve real-time performance or reliability. Sometimes we can achieve our goals via tunable parameters.
Reference: 6. <institution> IEEE Software (issue featuring systematic reuse), </institution> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: As evidenced by the comprehensive literature dedicated to the topic of software reuse, it is clear that software experts consider software reuse to be an important technology <ref> [6, 8, 11] </ref>. The Chimera software infrastructure prescribes a standard format for building reusable software objects. These port-based objects automatically map to executable processes. The format includes operations for initializing, executing, and deactivating these dynamic objects as well as for error handling and inter-object communications [16].
Reference: 7. <author> D. Jackson and M. Jackson, </author> <title> Problem Decomposition for Reuse, </title> <type> Technical Report: </type> <institution> CMU-CS-95-108, School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, Pa., </address> <year> 1995. </year>
Reference-contexts: But do software components organized on the basis of localizing change necessarily lead to the construction of reusable components and software solutions? Jackson and Jackson suggest that hierarchical decompositions yield reusable software modules in numerical applications but not necessary so in other domains <ref> [7] </ref>. Would our approach yield reusable components in less mathematically-oriented real-time applications such as multi-media and real-time financial data reporting? Another problem that we need to research is the possibility that components organized according to anticipated changes may exhibit undesirable software qualities and discourage reuse.
Reference: 8. <author> T. Capers Jones, </author> <title> Reusability in Programming: A Survey of the State of the Art, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. 10, No. 5, </volume> <month> Sept. </month> <year> 1984, </year> <pages> pp. 488-494. </pages>
Reference-contexts: As evidenced by the comprehensive literature dedicated to the topic of software reuse, it is clear that software experts consider software reuse to be an important technology <ref> [6, 8, 11] </ref>. The Chimera software infrastructure prescribes a standard format for building reusable software objects. These port-based objects automatically map to executable processes. The format includes operations for initializing, executing, and deactivating these dynamic objects as well as for error handling and inter-object communications [16].
Reference: 9. <author> H. Kopetz et. al., </author> <title> Distributed Fault-Tolerant Real-Time Systems: The Mars Approach, </title> <journal> IEEE Micro, </journal> <volume> Vol. 9, No. 1, </volume> <month> Feb. </month> <year> 1989, </year> <pages> pp. 25-40. </pages>
Reference-contexts: We need models for building knowledge bases of change and for incorporating information about change into the design process. Similar to the type of analysis used to estimate the dependability of MARS application designs <ref> [9] </ref>, we would like to be able to estimate the cost of software change. Halang states that real-time software systems are more likely to be predictable and dependable if they are simple [4]. Our analytical techniques should seek to reduce software complexity.
Reference: 10. <author> N. G. Leveson, Safeware: </author> <title> System Safety and Computers, </title> <publisher> Addison-Wesley Publ., </publisher> <address> Reading, Mass., </address> <year> 1995, </year> <pages> pp. 30-31. </pages> <booktitle> 8 Second Workshop on Object-Oriented Real-Time Dependable Systems (WORDS96) </booktitle>
Reference-contexts: Some researchers argue that reuse does not guarantee the safety of a software solution. For instance, Leveson states that safety is not just a property of the software itself but also a property of the software design and environment in which it is used <ref> [10] </ref>. It appears to be an open question as to whether or not it is easier to construct a safe software system totally from scratch or from parts of a safe existing software solution.
Reference: 11. <author> H. Mili, F. Mili, and A. Mili, </author> <title> Reusing Software: Issues and Research Directions, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. 21, No. 6, </volume> <month> June </month> <year> 1995, </year> <pages> pp. 528-562. </pages>
Reference-contexts: As evidenced by the comprehensive literature dedicated to the topic of software reuse, it is clear that software experts consider software reuse to be an important technology <ref> [6, 8, 11] </ref>. The Chimera software infrastructure prescribes a standard format for building reusable software objects. These port-based objects automatically map to executable processes. The format includes operations for initializing, executing, and deactivating these dynamic objects as well as for error handling and inter-object communications [16].
Reference: 12. <author> A. K. Mok, </author> <title> Towards Mechanization of Real-Time System Design, A.M. </title> <editor> van Tilborg and G.M. Koob, eds., </editor> <title> Foundations of Real-Time Computing: Formal Specifications and Methods, </title> <publisher> Kluwer Academic Publ., </publisher> <address> Boston, </address> <year> 1991, </year> <pages> pp. 1-37. </pages>
Reference-contexts: 1 Background It is well-known that real-time systems often have stringent timing and safety requirements [1]. The ad hoc way in which software engineers develop and maintain real-time software systems is often difficult, time-consuming, and costly <ref> [12] </ref>. To make matters worse, as in the example of the software problem that delayed the first NASA Space Shuttle orbital ight, the software process is sometimes error-prone.
Reference: 13. <author> D. L. Parnas, </author> <title> On the criteria to be used in decomposing systems into modules, </title> <journal> Communications of the ACM, </journal> <volume> Vol. 15, No. 12, </volume> <month> Dec. </month> <year> 1972, </year> <pages> pp. 1053-1058. </pages>
Reference-contexts: Though the control parameters could have been encapsulated as an ADT, actual input and output of these parameters may have been intertwined with the control logic. Experience or engineering guidelines may have directed us to separate the input/output logic from the master control logic <ref> [13] </ref>, but even well-known design principles are not always applied systematically. In our monolithic optimization programs the input/output operations and control logic were integrated and could not easily be mapped into separate processes.
Reference: 14. <author> D. L. Parnas, P.C. Clements, and D. M. Weiss, </author> <title> The Modular Structure of Complex Systems, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. SE-11, No. 3, </volume> <month> Mar. </month> <year> 1985, </year> <pages> pp. 259-266. </pages>
Reference-contexts: But by analyzing the expected changes, we thought of changing the facility for the input and output of control parameters. Our analysis systematically directed us to create a separate component for these operations. Our analytical approach supports the fundamental design principles of decomposition, partitioning, and encapsulation <ref> [14] </ref>. The population and cost components encapsulate data objects similar to those that would result from an object-oriented analysis. Our approach also gave us direction about how to organize non-data parts of the software solution such as the randomized operator selector and the master control logic.
Reference: 15. <author> M. Sitaraman, </author> <title> Performance-Parameterized Reusable Software Components, </title> <journal> Intl Journal of Software Engineering and Knowledge Engineering, </journal> <volume> Vol. 2, No. 4, </volume> <year> 1992, </year> <pages> pp. 567-587. </pages>
Reference-contexts: During the design of a new application, we would like to be able to experiment with alternative software solutions to achieve real-time performance or reliability. Sometimes we can achieve our goals via tunable parameters. Other times, we need to tune the solution by replacing poor-performing parts of the system <ref> [15] </ref>. We would like to localize the parts of a software system affected by a change because it is easier to modify software when the related changes are close together. <p> But in the monolithic program component, we had to be careful not to introduce errors into unrelated sections of the monolithic solution. From a real-time point-of-view, the ability to make localized changes by replacing components is valuable <ref> [15] </ref>. To improve the performance of a genetic operator, we modify or replace only the population component. As expected, we found that our decomposed software solution (in contrast to our monolithic solution) could be executed as concurrent processes.
Reference: 16. <author> D. B. Stewart and P. K. Khosla, </author> <title> The Chimera Methodology: Design of Dynamically Reconfigurable Real-Time Software Using Port-Based Objects, </title> <booktitle> in Proc. of the IEEE Workshop on Object-Oriented Real-Time Dependable Systems (WORDS94), Dana Point, </booktitle> <address> Ca., </address> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: The Chimera software infrastructure prescribes a standard format for building reusable software objects. These port-based objects automatically map to executable processes. The format includes operations for initializing, executing, and deactivating these dynamic objects as well as for error handling and inter-object communications <ref> [16] </ref>. The Chimera infrastructure includes a real-time kernel designed to ensure a performance-efficient and reliable real-time operating environment for robotics and factory applications [17]. Chimera objects are software packages that become processes activated by the real-time kernel.
Reference: 17. <author> D. B. Stewart, D. E. Schmitz, and P. K. Khosla, </author> <title> The Chimera II Real-Time Operating System for Advanced Sensor-Based Control Applications, </title> <journal> IEEE Trans. on Systems, Man, and Cybernetics, </journal> <volume> Nov./Dec. </volume> <year> 1992, </year> <pages> pp. 1282-1295. </pages>
Reference-contexts: The format includes operations for initializing, executing, and deactivating these dynamic objects as well as for error handling and inter-object communications [16]. The Chimera infrastructure includes a real-time kernel designed to ensure a performance-efficient and reliable real-time operating environment for robotics and factory applications <ref> [17] </ref>. Chimera objects are software packages that become processes activated by the real-time kernel. The concern of the Chimera infrastructure is with the dynamic and real-time world of the computer and its operating environment.
Reference: 18. <author> B. W. Weide, W. F. Ogden, and M. Sitaraman, </author> <title> Re-casting Algorithms to Encourage Reuse, </title> <journal> IEEE Software, </journal> <month> Sept. </month> <year> 1994, </year> <pages> pp. 80-88. </pages>
Reference-contexts: A reusable software component is, for the purposes of our study, an executable or compilable module carefully designed to be useful in several programs, including unanticipated ones <ref> [18] </ref>. Before presenting our approach, we should mention that other researchers have also studied ways to decompose mathematical software solutions into software components. For instance, Westerbergs work reects the common approach of intuitively decomposing algorithms into functional modules. <p> The idea is that software components that encapsulate whole algorithms more likely require internal modification in order to be reused; whereas, components that contain parts of an algorithm can be alternated to achieve variations in the algorithms logic or implementation features <ref> [18] </ref>. Our interpretation of this rationale is that software solutions implemented as large-effect components are not likely to be as reusable as those implemented as small-effect components.
Reference: 19. <author> K. Westerberg, </author> <title> Development of Software for Solving Systems of Linear Equations, </title> <type> Technical Report: </type> <institution> EDRC-05-35-89, Engineering and Design Research Center, Carnegie Mellon University, </institution> <address> Pittsburgh, Pa., </address> <year> 1989. </year>
Reference-contexts: For instance, Westerbergs work reects the common approach of intuitively decomposing algorithms into functional modules. Westerbergs modules can be 2 Second Workshop on Object-Oriented Real-Time Dependable Systems (WORDS96) used in various permutations to solve systems of linear equations <ref> [19] </ref>. We think our approach differs because we systematically decompose a software solution into small-effect operations.
References-found: 19

