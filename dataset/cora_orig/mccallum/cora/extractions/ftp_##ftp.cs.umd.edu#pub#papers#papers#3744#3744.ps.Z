URL: ftp://ftp.cs.umd.edu/pub/papers/papers/3744/3744.ps.Z
Refering-URL: http://www.cs.umd.edu/TRs/TR.html
Root-URL: 
Email: fshin, saltzg@cs.umd.edu  
Title: Compile-Time Analysis on Programs with Dynamic Pointer-Linked Data Structures  
Author: Yuan-Shin Hwang Joel Saltz 
Date: November 8, 1996  
Address: College Park, MD 20742  
Affiliation: Department of Computer Science University of Maryland  
Abstract: This paper studies static analysis on programs that create and traverse dynamic pointer-linked data structures. It introduces a new type of auxiliary structures, called link graphs, to depict the alias information of pointers and connection relationships of dynamic pointer-linked data structures. The link graphs can be used by compilers to detect side effects, to identify the patterns of traversal, and to gather the DEF-USE information of dynamic pointer-linked data structures. The results of the above compile-time analysis are essential for parallelization and optimizations on communication and synchronization overheads. Algorithms that perform compile-time analysis on side effects and DEF-USE information using link graphs will be proposed. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Barnes and P. Hut. </author> <title> A hierarchical O(NlogN) force-calculation algorithm. </title> <booktitle> Nature, </booktitle> <pages> pages 446-449, </pages> <month> December </month> <year> 1976. </year>
Reference-contexts: One example is the Barnes-Hut N-body solver, which stores particles in a linked list and uses a space subdivision tree (i.e. an oct-tree) to summarize the information of particles <ref> [1] </ref>. Furthermore, there have been proposals to introduce user-defined reduction functions to provide programmers the ability to formulate new combining operations on dynamic pointer-linked data structures in data-parallel languages [8, 17]. <p> p ) p%next p ) p%next call append (list, node (i)) end do end do end do p%next ) node allocate (p%next) end p%next%node ) node end 6 Example This section studies the properties of the linked list and tree used in a simplified version of the Barnes-Hut tree code <ref> [1] </ref> by building link graphs and performing the side effect analysis and DEF-USE information construction. <p> The shape analysis algorithm proposed by Ghiya and Hendren [9] reports that 12 linked structures created by the n-body solver <ref> [1] </ref> are cyclic, whereas the link graphs reveal that it is acyclic. The link graphs are, in a sense, similar to the shape-graphs developed by Sagiv et al [16].
Reference: [2] <author> David R. Chase, Mark Wegman, and F. Kenneth Zadeck. </author> <title> Analysis of pointers and structures. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(6) </volume> <pages> 296-310, </pages> <month> June </month> <year> 1990. </year> <booktitle> Proceedings of the ACM SIGPLAN '90 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Furthermore, although shape analysis can estimate the possible shapes of pointer-linked data structures <ref> [2, 9, 15, 16] </ref>, it is inefficient to combine the effects of sequences of statements on dynamic pointer-linked data structures by comparing all the shape graphs of these statements. <p> The innovative idea of this paper is to differentiate associations (instances) of pointer variables, and to represent the connection relationships of these pointer associations by constructing a new form of alias graphs, called link graphs. In contrast to the structures proposed other researchers <ref> [2, 10, 12, 16] </ref> which build a table, a matrix, or a graph to depict alias information for every statement, only a single link graph is needed for multiple statements. <p> representation without concerning aliases caused by pointers, and then propagates the side effect information through the links of link graphs. (See Section 4.1) * None of the previously developed methods provide information of how and where the currently referenced data structure is created, modified, and traversed by previously executed statements <ref> [2, 3, 10, 11, 12, 16] </ref>. This paper proposes an algorithm to identify DEF and USE regions in programs, and construct DEF-USE information of dynamic pointer-linked data structures on link graphs. <p> For example, the link graph of the first loop of the program (in SSA format) in Figure 2 (a), which is adapted from <ref> [2] </ref>, can be built by following the above steps, as shown in Figure 2 (b). This link graph not only clearly depicts the relationship between pointer variables w and x, but also carries important program flow control information. <p> One important ability is that link graphs can differentiate the cycles that represent cycles in run-time data structures from those that represent unbounded acyclic data structures, in contrast to other similar graphs, e.g. alias graphs [12], and storage shape graphs <ref> [2] </ref>, etc. If a cycle of a link graph does not have an iteration edge of the -function at the header of the loop, then it signals a cycle in a data structure at runtime. <p> Another related field is shape analysis, which is to find the characterization of possible shapes of the dynamic linked data structures in programs <ref> [2, 9, 15, 16] </ref>. The link graphs in this paper can differentiate the cycles that represent cycles in run-time data structures from those that represent unbounded acyclic data structures, while the Storage Shape Graphs (SSG) can not [2]. <p> The link graphs in this paper can differentiate the cycles that represent cycles in run-time data structures from those that represent unbounded acyclic data structures, while the Storage Shape Graphs (SSG) can not <ref> [2] </ref>. Plevyak et al. adapted the SSA and developed the Abstract Storage Graph (ASG) that solved about problem [15].
Reference: [3] <author> Jong-Deok Choi, Michael Burke, and Paul Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Furthermore, there have been proposals to introduce user-defined reduction functions to provide programmers the ability to formulate new combining operations on dynamic pointer-linked data structures in data-parallel languages [8, 17]. Previously proposed methods for pointer analysis, such as side effect analysis <ref> [3, 11] </ref> and conflict/interference analysis [10, 12], do not provide sufficient information for compilers to perform parallelization on sequential programs or code transformation on data-parallel programs with dynamic pointer-linked data structures. <p> representation without concerning aliases caused by pointers, and then propagates the side effect information through the links of link graphs. (See Section 4.1) * None of the previously developed methods provide information of how and where the currently referenced data structure is created, modified, and traversed by previously executed statements <ref> [2, 3, 10, 11, 12, 16] </ref>. This paper proposes an algorithm to identify DEF and USE regions in programs, and construct DEF-USE information of dynamic pointer-linked data structures on link graphs. <p> Therefore, both phases can be executed in parallel. The user-defined reduction functions can be used to program this type of codes in data-parallel languages. 7 Related Work The analysis done in this paper is closely related to the side effect analysis on programs with pointers <ref> [3, 7, 11] </ref> and conflict/interference analysis for programs with dynamic pointer-linked data structures [10, 12]. Each of these algorithms builds either tables, graphs, or sets to represent the aliases or connections of locations, and then performs compile-time analysis on these auxiliary structures.
Reference: [4] <author> K. D. Cooper, M. W. Hall, R. Hood, K. Kennedy, K. McKinley, J. Mellor-Crummey, L. Torczon, and S. Warren. </author> <title> The ParaScope parallel programming environment. </title> <booktitle> Proceedings of the IEEE, </booktitle> <pages> pages 244-263, </pages> <month> February </month> <year> 1993. </year> <month> 13 </month>
Reference-contexts: The extended form of SSA representation and link graphs have been implemented on top of the ParaScope programming environment, originally developed by Rice University <ref> [4] </ref>. The implementation of the algorithms proposed in the paper are currently underway. The algorithms will be integrated as part of Fortran 90D compiler that transforms data-parallel programs with dynamic pointer-linked data structures into efficient parallel code.
Reference: [5] <author> Ron Cytron, Jeanne Ferrante, Barry K. Rosen, Mark N. Wegman, and F. Kenneth Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: The link graphs are constructed from an extended form of the SSA (Static Single Assignment) intermediate representation <ref> [5] </ref>. This new SSA form extends the original SSA representation to accommodate both pointers and variables. In addition to providing information for link graph construction, this extended form of SSA can be used to perform compile-time analysis on programs with pointers. <p> Fortran-77 programs, since any definitions to a variable will create a new value in one location without affecting the existing values of any other locations <ref> [5] </ref>. However, it does not apply for programs with pointers because every pointer can be dynamically assigned to point to any location. Definitions via a pointer would potentially change any existing values. Therefore, the dynamic associations of pointer variables must be resolved before converting programs into SSA form.
Reference: [6] <author> Ron Cytron and Reid Gershbein. </author> <title> Efficient accommodation of may-alias information in SSA form. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(6) </volume> <pages> 36-45, </pages> <month> June </month> <year> 1993. </year> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation. </booktitle>
Reference: [7] <author> Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. </author> <title> Context-sensitive interprocedural Points-to analysis in the presence of function pointers. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6) </volume> <pages> 242-256, </pages> <month> June </month> <year> 1994. </year> <booktitle> Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Therefore, both phases can be executed in parallel. The user-defined reduction functions can be used to program this type of codes in data-parallel languages. 7 Related Work The analysis done in this paper is closely related to the side effect analysis on programs with pointers <ref> [3, 7, 11] </ref> and conflict/interference analysis for programs with dynamic pointer-linked data structures [10, 12]. Each of these algorithms builds either tables, graphs, or sets to represent the aliases or connections of locations, and then performs compile-time analysis on these auxiliary structures.
Reference: [8] <institution> High Performance Fortran Forum. HPF-2 Scope of Activities and Motivating Applications, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: Furthermore, there have been proposals to introduce user-defined reduction functions to provide programmers the ability to formulate new combining operations on dynamic pointer-linked data structures in data-parallel languages <ref> [8, 17] </ref>. Previously proposed methods for pointer analysis, such as side effect analysis [3, 11] and conflict/interference analysis [10, 12], do not provide sufficient information for compilers to perform parallelization on sequential programs or code transformation on data-parallel programs with dynamic pointer-linked data structures. <p> insert, can be shared by the link graphs of calling procedures, but not the two edges of F boundary node. 5.2 Safety Analysis of User-Defined Reduction Functions The introduction of user-defined reduction functions provides programmers the ability to formulate new combining operations on dynamic pointer-linked data structures in data-parallel languages <ref> [8, 17] </ref>. It usually takes two parameters reduction variable is where the result is accumulated and input parameter passes the input value to the function. However, none have proposed algorithms to determine if user-defined reduction functions with dynamic pointer-linked data structures have undesired side effects.
Reference: [9] <author> Rakesh Ghiya and Laurie J. Hendren. </author> <title> Is it a tree, a DAG, or a cyclic graph? A shape analysis for heap-directed pointers in C. </title> <booktitle> In Conference Record of POPL '96: 23nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 1-15, </pages> <address> St. Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Furthermore, although shape analysis can estimate the possible shapes of pointer-linked data structures <ref> [2, 9, 15, 16] </ref>, it is inefficient to combine the effects of sequences of statements on dynamic pointer-linked data structures by comparing all the shape graphs of these statements. <p> However, paths exist only from the tree to the particle list, but not vice versa. This connection causes other shape analysis techniques to wrongly guess the tree is cyclic <ref> [9] </ref>. * Applying the DEF-USE algorithm will reveal that linked data structure referenced in the second loop (S25-29) is created by the first loop. <p> Another related field is shape analysis, which is to find the characterization of possible shapes of the dynamic linked data structures in programs <ref> [2, 9, 15, 16] </ref>. The link graphs in this paper can differentiate the cycles that represent cycles in run-time data structures from those that represent unbounded acyclic data structures, while the Storage Shape Graphs (SSG) can not [2]. <p> The shape analysis algorithm proposed by Ghiya and Hendren <ref> [9] </ref> reports that 12 linked structures created by the n-body solver [1] are cyclic, whereas the link graphs reveal that it is acyclic. The link graphs are, in a sense, similar to the shape-graphs developed by Sagiv et al [16].
Reference: [10] <author> Laurie J. Hendren and Alexandru Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Furthermore, there have been proposals to introduce user-defined reduction functions to provide programmers the ability to formulate new combining operations on dynamic pointer-linked data structures in data-parallel languages [8, 17]. Previously proposed methods for pointer analysis, such as side effect analysis [3, 11] and conflict/interference analysis <ref> [10, 12] </ref>, do not provide sufficient information for compilers to perform parallelization on sequential programs or code transformation on data-parallel programs with dynamic pointer-linked data structures. <p> The innovative idea of this paper is to differentiate associations (instances) of pointer variables, and to represent the connection relationships of these pointer associations by constructing a new form of alias graphs, called link graphs. In contrast to the structures proposed other researchers <ref> [2, 10, 12, 16] </ref> which build a table, a matrix, or a graph to depict alias information for every statement, only a single link graph is needed for multiple statements. <p> representation without concerning aliases caused by pointers, and then propagates the side effect information through the links of link graphs. (See Section 4.1) * None of the previously developed methods provide information of how and where the currently referenced data structure is created, modified, and traversed by previously executed statements <ref> [2, 3, 10, 11, 12, 16] </ref>. This paper proposes an algorithm to identify DEF and USE regions in programs, and construct DEF-USE information of dynamic pointer-linked data structures on link graphs. <p> The user-defined reduction functions can be used to program this type of codes in data-parallel languages. 7 Related Work The analysis done in this paper is closely related to the side effect analysis on programs with pointers [3, 7, 11] and conflict/interference analysis for programs with dynamic pointer-linked data structures <ref> [10, 12] </ref>. Each of these algorithms builds either tables, graphs, or sets to represent the aliases or connections of locations, and then performs compile-time analysis on these auxiliary structures.
Reference: [11] <author> William Landi, Barbara G. Ryder, and Sean Zhang. </author> <title> Interprocedural side effect analysis with pointer aliasing. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(6) </volume> <pages> 56-67, </pages> <month> June </month> <year> 1993. </year> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Furthermore, there have been proposals to introduce user-defined reduction functions to provide programmers the ability to formulate new combining operations on dynamic pointer-linked data structures in data-parallel languages [8, 17]. Previously proposed methods for pointer analysis, such as side effect analysis <ref> [3, 11] </ref> and conflict/interference analysis [10, 12], do not provide sufficient information for compilers to perform parallelization on sequential programs or code transformation on data-parallel programs with dynamic pointer-linked data structures. <p> representation without concerning aliases caused by pointers, and then propagates the side effect information through the links of link graphs. (See Section 4.1) * None of the previously developed methods provide information of how and where the currently referenced data structure is created, modified, and traversed by previously executed statements <ref> [2, 3, 10, 11, 12, 16] </ref>. This paper proposes an algorithm to identify DEF and USE regions in programs, and construct DEF-USE information of dynamic pointer-linked data structures on link graphs. <p> Therefore, both phases can be executed in parallel. The user-defined reduction functions can be used to program this type of codes in data-parallel languages. 7 Related Work The analysis done in this paper is closely related to the side effect analysis on programs with pointers <ref> [3, 7, 11] </ref> and conflict/interference analysis for programs with dynamic pointer-linked data structures [10, 12]. Each of these algorithms builds either tables, graphs, or sets to represent the aliases or connections of locations, and then performs compile-time analysis on these auxiliary structures.
Reference: [12] <author> James R. Larus and Paul N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <journal> SIGPLAN Notices, </journal> <volume> 23(7) </volume> <pages> 21-34, </pages> <month> July </month> <year> 1988. </year> <booktitle> Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Furthermore, there have been proposals to introduce user-defined reduction functions to provide programmers the ability to formulate new combining operations on dynamic pointer-linked data structures in data-parallel languages [8, 17]. Previously proposed methods for pointer analysis, such as side effect analysis [3, 11] and conflict/interference analysis <ref> [10, 12] </ref>, do not provide sufficient information for compilers to perform parallelization on sequential programs or code transformation on data-parallel programs with dynamic pointer-linked data structures. <p> The innovative idea of this paper is to differentiate associations (instances) of pointer variables, and to represent the connection relationships of these pointer associations by constructing a new form of alias graphs, called link graphs. In contrast to the structures proposed other researchers <ref> [2, 10, 12, 16] </ref> which build a table, a matrix, or a graph to depict alias information for every statement, only a single link graph is needed for multiple statements. <p> representation without concerning aliases caused by pointers, and then propagates the side effect information through the links of link graphs. (See Section 4.1) * None of the previously developed methods provide information of how and where the currently referenced data structure is created, modified, and traversed by previously executed statements <ref> [2, 3, 10, 11, 12, 16] </ref>. This paper proposes an algorithm to identify DEF and USE regions in programs, and construct DEF-USE information of dynamic pointer-linked data structures on link graphs. <p> One important ability is that link graphs can differentiate the cycles that represent cycles in run-time data structures from those that represent unbounded acyclic data structures, in contrast to other similar graphs, e.g. alias graphs <ref> [12] </ref>, and storage shape graphs [2], etc. If a cycle of a link graph does not have an iteration edge of the -function at the header of the loop, then it signals a cycle in a data structure at runtime. <p> The user-defined reduction functions can be used to program this type of codes in data-parallel languages. 7 Related Work The analysis done in this paper is closely related to the side effect analysis on programs with pointers [3, 7, 11] and conflict/interference analysis for programs with dynamic pointer-linked data structures <ref> [10, 12] </ref>. Each of these algorithms builds either tables, graphs, or sets to represent the aliases or connections of locations, and then performs compile-time analysis on these auxiliary structures.
Reference: [13] <author> Pedro C. Diniz Martin C. Rinard. </author> <title> Commutativity analysis: A new analysis framework for parallelizing compilers. </title> <journal> SIGPLAN Notices, </journal> <volume> 31(5) </volume> <pages> 54-67, </pages> <month> May </month> <year> 1996. </year> <booktitle> Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: This piece of information is not easy to extract from other auxiliary structures proposed by other researchers. Recently, commutativity analysis has been proposed as a new framework for parallelizing compilers <ref> [13] </ref>. It parallelizes programs by analyzing if the operations commute. However, it only applies to object-based programs.
Reference: [14] <author> Kevin M. Olson and Charles V. Packer. </author> <title> An n-body tree algorithm for the Cray T3D. </title> <type> Technical Report 199882, NASA Contractor Report, </type> <month> May </month> <year> 1996. </year>
Reference-contexts: As a result, compilers would have to sequentialize the tree creation phase. However, other researchers have proposed and implemented tree codes that processors create subtrees from local particles in parallel <ref> [14] </ref>. Therefore, both phases can be executed in parallel.
Reference: [15] <author> J. Plevyak, A. Chien, and V. Karamcheti. </author> <title> Analysis of dynamic structures for efficient parallel execution. </title> <booktitle> In Proceedings of the 6th International Workshop on Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 37-56, </pages> <address> Portland, Oregon, </address> <month> August </month> <year> 1993. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Vol. 768, </volume> <publisher> Springer Verlag. </publisher>
Reference-contexts: Furthermore, although shape analysis can estimate the possible shapes of pointer-linked data structures <ref> [2, 9, 15, 16] </ref>, it is inefficient to combine the effects of sequences of statements on dynamic pointer-linked data structures by comparing all the shape graphs of these statements. <p> Another related field is shape analysis, which is to find the characterization of possible shapes of the dynamic linked data structures in programs <ref> [2, 9, 15, 16] </ref>. The link graphs in this paper can differentiate the cycles that represent cycles in run-time data structures from those that represent unbounded acyclic data structures, while the Storage Shape Graphs (SSG) can not [2]. <p> Plevyak et al. adapted the SSA and developed the Abstract Storage Graph (ASG) that solved about problem <ref> [15] </ref>.
Reference: [16] <author> Mooly Sagiv, Thomas Reps, and Reinhard Wilhelm. </author> <title> Solving shape-analysis problems in languages with destructive updating. </title> <booktitle> In Conference Record of POPL '96: 23nd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 16-31, </pages> <address> St. Petersburg Beach, Florida, </address> <month> January </month> <year> 1996. </year>
Reference-contexts: Furthermore, although shape analysis can estimate the possible shapes of pointer-linked data structures <ref> [2, 9, 15, 16] </ref>, it is inefficient to combine the effects of sequences of statements on dynamic pointer-linked data structures by comparing all the shape graphs of these statements. <p> The innovative idea of this paper is to differentiate associations (instances) of pointer variables, and to represent the connection relationships of these pointer associations by constructing a new form of alias graphs, called link graphs. In contrast to the structures proposed other researchers <ref> [2, 10, 12, 16] </ref> which build a table, a matrix, or a graph to depict alias information for every statement, only a single link graph is needed for multiple statements. <p> representation without concerning aliases caused by pointers, and then propagates the side effect information through the links of link graphs. (See Section 4.1) * None of the previously developed methods provide information of how and where the currently referenced data structure is created, modified, and traversed by previously executed statements <ref> [2, 3, 10, 11, 12, 16] </ref>. This paper proposes an algorithm to identify DEF and USE regions in programs, and construct DEF-USE information of dynamic pointer-linked data structures on link graphs. <p> Another related field is shape analysis, which is to find the characterization of possible shapes of the dynamic linked data structures in programs <ref> [2, 9, 15, 16] </ref>. The link graphs in this paper can differentiate the cycles that represent cycles in run-time data structures from those that represent unbounded acyclic data structures, while the Storage Shape Graphs (SSG) can not [2]. <p> The shape analysis algorithm proposed by Ghiya and Hendren [9] reports that 12 linked structures created by the n-body solver [1] are cyclic, whereas the link graphs reveal that it is acyclic. The link graphs are, in a sense, similar to the shape-graphs developed by Sagiv et al <ref> [16] </ref>. The nodes of the shape-graphs represent distinct locations while those of link graphs correspond to unique pointer instances, and the edges of both type of graphs depict the connections.
Reference: [17] <author> Guhan Viswanathan and James R. Larus. </author> <title> User-defined reductions for communication in data-parallel languages. </title> <type> Technical Report 1293, </type> <institution> Computer Science Department, University of Wisconsin-Madison, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: Furthermore, there have been proposals to introduce user-defined reduction functions to provide programmers the ability to formulate new combining operations on dynamic pointer-linked data structures in data-parallel languages <ref> [8, 17] </ref>. Previously proposed methods for pointer analysis, such as side effect analysis [3, 11] and conflict/interference analysis [10, 12], do not provide sufficient information for compilers to perform parallelization on sequential programs or code transformation on data-parallel programs with dynamic pointer-linked data structures. <p> Without safety analysis, data-parallel language compilers have to assume all user-defined reduction functions are safe <ref> [17] </ref>. <p> insert, can be shared by the link graphs of calling procedures, but not the two edges of F boundary node. 5.2 Safety Analysis of User-Defined Reduction Functions The introduction of user-defined reduction functions provides programmers the ability to formulate new combining operations on dynamic pointer-linked data structures in data-parallel languages <ref> [8, 17] </ref>. It usually takes two parameters reduction variable is where the result is accumulated and input parameter passes the input value to the function. However, none have proposed algorithms to determine if user-defined reduction functions with dynamic pointer-linked data structures have undesired side effects.
Reference: [18] <author> Mark N. Wegman and F. Kenneth Zadeck. </author> <title> Constant propagation with conditional branches. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 181-210, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: In addition to providing information for link graph construction, this extended form of SSA can be used to perform compile-time analysis on programs with pointers. Algorithms using the original SSA form to perform code 1 optimizations on programs without pointers, such as constant propagation and induction variable analysis <ref> [18, 19] </ref>, can be modified to be applied on programs with pointers. Appendix A presents an example by adapting a constant propagation algorithm [18]. <p> Algorithms using the original SSA form to perform code 1 optimizations on programs without pointers, such as constant propagation and induction variable analysis [18, 19], can be modified to be applied on programs with pointers. Appendix A presents an example by adapting a constant propagation algorithm <ref> [18] </ref>. The contributions of this paper are outlined as follows: * An auxiliary structure, called the link graph, is proposed to represent the connections among associations (instances) of pointer variables and fixed-location variables.
Reference: [19] <author> Michael Wolfe. </author> <title> Beyond induction variables. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(7) </volume> <pages> 162-174, </pages> <month> July </month> <year> 1992. </year> <booktitle> Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation. </booktitle> <pages> 14 </pages>
Reference-contexts: In addition to providing information for link graph construction, this extended form of SSA can be used to perform compile-time analysis on programs with pointers. Algorithms using the original SSA form to perform code 1 optimizations on programs without pointers, such as constant propagation and induction variable analysis <ref> [18, 19] </ref>, can be modified to be applied on programs with pointers. Appendix A presents an example by adapting a constant propagation algorithm [18].
References-found: 19

