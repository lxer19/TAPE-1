URL: http://www.cs.washington.edu/homes/vanhilst/fse60l.ps.gz
Refering-URL: http://www.cs.washington.edu/homes/vanhilst/research.html
Root-URL: 
Email: fvanhilst,notking@cs.washington.edu  
Title: Decoupling Change from Design method of implementation is presented using inheritance, parameterization, and static binding
Author: Michael VanHilst and David Notkin 
Note: A  
Address: PO Box 352350 Seattle, Washington 98195 USA  
Affiliation: Department of Computer Science and Engineering University of Washington  
Abstract: Parnas' seminal 1972 paper, "On the Criteria To Be Used in Decomposing Systems into Modules," identified simplifying change as a critical criterion for mod-ularizing software. Successful designs are those in which a change can be accommodated by modifying a single module. There is a tacit assumption in most of the literature that once a change has been limited to a single module, the cost of making the change is essentially inconsequential. But modules have complexity of their own and are frequently large. Thus, making a change can be expensive, even if limited to a single module. We present a method of decomposing modules into smaller components for the purpose of supporting change. Although similar to the approach of modu-larizing programs described by Parnas, our approach is specific to decomposing modules. It is not intended to replace traditional high level modularization but rather to augment it with a second level of modulari-zation where the standard of information hiding can be relaxed. The goal of the method is to make modules easier to change by decomposing them around smaller design decisions|ideally encoding only one design choice per submodule component. In this paper we show how submodule components can be used to address the issue of change. We also demonstrate how the ability to address change with submodule components is, to a large extent, independent of the design level modularization. Moreover, we show that, at least in some cases, by using submodule components the choice of high level modularization can itself be changed without having to rewrite large amounts of code. 0 Copyright c fl199x by the Association for Computing Machinery, Inc. Permission to make digital or hard copies of part or all of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from Publications Dept, ACM Inc., fax +1 (212) 869-0481, or permissions@acm.org. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ak~sit, L. Bergmans, and S. Vural. </author> <title> An object-oriented language-database integration model: The composition-filters approach. </title> <booktitle> In Proceedings of the 1992 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 372-395, </pages> <year> 1992. </year>
Reference-contexts: To date, their work has focused more on merging two or more existing programs than creating a new program from little pieces. A similar approach to runtime dispatching is used by the composition filters of Ak~set, et al. <ref> [1] </ref>. Their Sina language offers additional capabilities such as dispatching based on runtime queries, and can encode a wide range of concerns, including persistence and transactions.
Reference: [2] <author> D. Batory, V. Singhal, M. Sirkin, and J. Thomas. </author> <title> Scalable software libraries. </title> <booktitle> In Proceedings of SIGSOFT'93: Foundations of Software Engineering, </booktitle> <pages> pages 191-199. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: The range of choices is limited to those provided by the module's developer. Our approach allows the user to make choices about a module's composition, as well its implementation. The Predator and P2 systems, by Batory, et al., factor data structures and other domain specific structures into independent components <ref> [2, 3] </ref>. In the Predator approach, handcrafted generators are used to compose modules from a limited set of choices. The fine grained factoring in this approach is similar to our own, but applicable only to a small set of well understood domain components.
Reference: [3] <author> D.S. Batory and S. O'Malley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 1(4) </volume> <pages> 355-398, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: The range of choices is limited to those provided by the module's developer. Our approach allows the user to make choices about a module's composition, as well its implementation. The Predator and P2 systems, by Batory, et al., factor data structures and other domain specific structures into independent components <ref> [2, 3] </ref>. In the Predator approach, handcrafted generators are used to compose modules from a limited set of choices. The fine grained factoring in this approach is similar to our own, but applicable only to a small set of well understood domain components.
Reference: [4] <author> G. Bracha and W. Cooke. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 303-311, </pages> <year> 1990. </year>
Reference-contexts: Also, the linearization of the order of inheritance, provided in CLOS but not in C++, is essential for allowing components to call other components and for resolving name conflicts. Our approach of using type parameters to defer inheritance was described in a paper by Bracha <ref> [4] </ref>, but so far has not been widely exploited. The Patterns book by Gamma, Helm, Johnson, and Vlissides describes a decorator pattern for applying multiple independent properties to an object [5]. Decorators support dynamic change.
Reference: [5] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlis-sides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Our approach of using type parameters to defer inheritance was described in a paper by Bracha [4], but so far has not been widely exploited. The Patterns book by Gamma, Helm, Johnson, and Vlissides describes a decorator pattern for applying multiple independent properties to an object <ref> [5] </ref>. Decorators support dynamic change. But they must be written specifically for the composition in which they are used|the decorators composed by this method must all subclass from the same superclass and have the same interface.
Reference: [6] <author> D. Garlan, R. Allen, and J. Ockerbloom. </author> <title> Archi--tectural mismatch: Why reuse is so hard. </title> <journal> IEEE Software, </journal> <volume> 12(6) </volume> <pages> 17-26, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: We have used this technique in our own work to explore difficult questions in the design of an image display application. Decomposing modules into separate composable concerns benefits module reuse, as well. Currently, large modules are hard to reuse in part because of the number of decisions they encode <ref> [6, 9] </ref>. Applications that reuse existing modules often must settle for approximate solutions to specific requirements. Having a submodularization that allows decisions to be altered individually makes it easier to adapt large modules to new applications.
Reference: [7] <author> D. Garlan, G.E. Kaiser, and D. Notkin. </author> <title> Using tool abstraction to compose systems. </title> <journal> IEEE Computer, </journal> <volume> 25(6) </volume> <pages> 30-38, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: At our lower level, this change in the alphabetization algorithm involves only the In-dexSorter component of the alphabetizer module. A 1992 article by Garlan, Kaiser, and Notkin proposed an alternative modularization of KWIC based on tool abstraction and involving special modules known as toolies <ref> [7] </ref>. This article pointed out that the changes listed in the original KWIC paper were mostly data oriented, and that functional enhancements would be more difficult for the originally preferred modularization. The paper suggested an additional set of changes to consider. These changes are paraphrased below. 6. <p> This line trimming component can also be placed in the input module. Our component based approach satisfies the objective described in the toolie article. "It should be possible to treat each enhancement as an independent unit, with the only interactions being through operations on the shared data structures" <ref> [7, p.33] </ref>. Each of LineStore PutStoredLine GetStoredLine ShiftIndex Shifter GetShiftedLine LineIndex IndexSorter GetIndexedLine PutLineServer GetLineServer KWIC server PutLineClient ReadInput input client GetLineClient WriteOutput output client form a simple client/server modularization of KWIC.
Reference: [8] <author> W. Harrison and H. Ossher. </author> <title> Subject-oriented programming (a critique of pure objects). </title> <booktitle> In Proceedings of the 1993 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 411-428, </pages> <year> 1993. </year>
Reference-contexts: New components in our approach can be written by the application developer as they are needed. Harrison and Ossher's Subject Oriented Programming allows concerns encoded in different views to be merged as a single class <ref> [8] </ref>. Their system uses a special runtime dispatcher that redirects method calls to achieve the effect of composition. To date, their work has focused more on merging two or more existing programs than creating a new program from little pieces.
Reference: [9] <author> G. Kiczales. </author> <title> Beyond the black box: Open implementation. </title> <journal> IEEE Software, </journal> <volume> 13(1) </volume> <pages> 8-11, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: We have used this technique in our own work to explore difficult questions in the design of an image display application. Decomposing modules into separate composable concerns benefits module reuse, as well. Currently, large modules are hard to reuse in part because of the number of decisions they encode <ref> [6, 9] </ref>. Applications that reuse existing modules often must settle for approximate solutions to specific requirements. Having a submodularization that allows decisions to be altered individually makes it easier to adapt large modules to new applications. <p> Our components can define their own interfaces and do not have to be anticipated by other components with which they interact, making them more generally usable. Open Implementation allows users of a module to alter certain decisions of its implementation <ref> [9] </ref>. The choices are generally encoded in the module itself, or in a corresponding meta-object, and accessed through a separate module interface. The range of choices is limited to those provided by the module's developer.
Reference: [10] <author> K.J. Lieberherr and C. Xiao. </author> <title> Minimizing dependency on class structures with adaptive programs. </title> <booktitle> In Object Technologies for Advanced Software: Proceedings of the First JSSST International Symposium, </booktitle> <pages> pages 424-441, </pages> <year> 1993. </year>
Reference-contexts: Method call dispatchers like those used in both these systems provide much flexibility, but they require special runtime support and add extra levels of indirection. The Demeter system allows program fragments to be flexibly composed in the structure of an application <ref> [10, 11] </ref>. In Demeter, components encode fragments of the program structure to allow their position in the finished application to be inferred. Our components do not encode any structural dependencies. Instead, we require explicit statements to specify the positions of components.
Reference: [11] <author> K.J. Lieberherr and C. Xiao. </author> <title> Object-oriented software evolution. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(4) </volume> <pages> 313-343, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Method call dispatchers like those used in both these systems provide much flexibility, but they require special runtime support and add extra levels of indirection. The Demeter system allows program fragments to be flexibly composed in the structure of an application <ref> [10, 11] </ref>. In Demeter, components encode fragments of the program structure to allow their position in the finished application to be inferred. Our components do not encode any structural dependencies. Instead, we require explicit statements to specify the positions of components.
Reference: [12] <author> D.L. Parnas. </author> <title> On the criteria to be used in decomposing systems into modules. </title> <journal> Communications of the ACM, </journal> <volume> 15(12) </volume> <pages> 1053-1058, </pages> <month> December </month> <year> 1972. </year>
Reference-contexts: But is this always the case? Are there design approaches for implementing modules that make them easier or harder to change? Consider Parnas' KWIC example, which reads lines of text and outputs all the circular shifts of all the lines in sorted order <ref> [12] </ref>. The preferred modulariza-tion of KWIC had five modules|line storage, input, circular shifter, alphabetizer, and output. The dominant reason for preferring this modularization to a more conventional functional decomposition was that it isolated a given set of likely changes to one or at most two modules. <p> Two additional pairs of module interconnection components provide the remote procedure call connections between the server module and client modules. All of the other components correspond to components used in the component decomposition of the original KWIC modularization. Parnas' original KWIC article described a second, supposedly less desirable, modularization <ref> [12] </ref>. The alternative implementation was modularized around functions or processing steps. Data was stored separately and accessed directly by code in each module. <p> To quote the original article, "the second change would result in changes in every module!" <ref> [12, p.1055] </ref>. The change affects the same two components; they are just repeated in several modules. In the functional mod-ularization, the change can be applied by adding a LineCompress component between the LineStoreIm-port component and any Put/GetStoredLine component in every module.
Reference: [13] <author> D.L. Parnas. </author> <title> On the design and development of program families. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-2(1):1-9, </volume> <month> March </month> <year> 1976. </year>
Reference-contexts: A subclass hierarchy forms a tree (or DAG) where each arc represents an increment of specialization. Parnas described a similar graph structure for the family of possible programs using stepwise refinement, where each arc represented a design decision <ref> [13] </ref>. To change a design decision, one starts at the node before that decision's arc, and continues anew with design decisions, ignoring or revisiting decisions made after that point in the development of the previous version. Decisions that may change are deferred, since later decisions are less disruptive to change.
Reference: [14] <author> R. Selby. </author> <title> Empirically analyzing software reuse in a production environment. </title> <booktitle> In Software Reuse: Emerging Technology, </booktitle> <pages> pages 176-189. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: Some studies suggest that it is generally easier to replace a module, or add a new one, than to alter the implementation of an existing module <ref> [14, 18] </ref>. How difficult would it be to build a new circular shifter? The difficulty of changing or building a module necessarily depends on its complexity. Complex modules should be subdivided into smaller, less complex components.
Reference: [15] <author> M. Shaw and D. Garlan. </author> <title> Software Architecture: Perspectives on an Emerging Discipline. </title> <publisher> Pren-tice Hall, </publisher> <year> 1996. </year>
Reference-contexts: For example, in a design based on pipes and filters, where sorting is implemented as a filter, incremental sorting is not an option <ref> [15] </ref>. The sorting filter cannot both output the lines as they become available and output them in sorted order. How difficult is it to change the modularization? Can existing low level components be used to form a different high level modularization? pipe and filter modularization.
Reference: [16] <author> M. VanHilst and D. Notkin. </author> <title> Using C++ templates to implement role-based designs. </title> <booktitle> In Proceedings of the 2nd JSSST International Symposium on Object Technologies for Advanced Software, </booktitle> <pages> pages 22-37. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The method supports fine grained decomposition with flexible composability and almost no run-time overhead. In two earlier papers we compared our method of implementation to frameworks with respect to flexi bility and performance <ref> [16] </ref> and discussed using our approach to implement role based components as an extension to collaboration based design [17]. In this paper, we focus on submodularization as a useful and realizable method of decomposing modules in any design. <p> The method combines features in an object oriented language|namely inheritance, static binding, and type parameterization|in a stylized way to implement the components and to compose them at compile time to form the modules of an application <ref> [16, 17] </ref>. Briefly, in our method, components are implemented as subclasses of an initially unspecified superclass|that is to say, the type of the superclass is parameterized. References to the types of other modules are parameterized as well. Components are composed with other components by binding types to parameters. <p> But it does not address the issue of dynamic change|that is to say the ability of a program to change while running. For that, other methods must be applied. We have used our approach successfully on a number of small programs <ref> [16, 17] </ref>. To test its scalability, we are currently using the approach to implement an image display program modeled after one that was originally written in 30,000 lines of C code. The results, while not conclusive, have been promising. The new design uses 10 to 20 components per module.
Reference: [17] <author> M. VanHilst and D. Notkin. </author> <title> Using role components to implement collaboration-based designs. </title> <booktitle> In Proceedings of the 1996 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <year> 1996. </year>
Reference-contexts: In two earlier papers we compared our method of implementation to frameworks with respect to flexi bility and performance [16] and discussed using our approach to implement role based components as an extension to collaboration based design <ref> [17] </ref>. In this paper, we focus on submodularization as a useful and realizable method of decomposing modules in any design. <p> The method combines features in an object oriented language|namely inheritance, static binding, and type parameterization|in a stylized way to implement the components and to compose them at compile time to form the modules of an application <ref> [16, 17] </ref>. Briefly, in our method, components are implemented as subclasses of an initially unspecified superclass|that is to say, the type of the superclass is parameterized. References to the types of other modules are parameterized as well. Components are composed with other components by binding types to parameters. <p> The order of composition shown in Fig. 4 binds the calls in Shifter to the methods in GetLineImport, while making the methods in Get-StoredLine visible through the module's exported interface. A method of analysis to address the ordering of composition is discussed elsewhere <ref> [17] </ref>. 3 Analysis In this section we discuss how our submodularization affects the ease or difficulty of making changes. The section is divided into three parts. In the first part, we discuss changes to the KWIC application, applying them to our submodularization of Parnas' preferred modularization. <p> While submodularization could be applied in an existing design, the redistribution of concerns may also suggest a different design. In another paper, we showed how a design, taken from the literature, had been distorted to accommodate change <ref> [17] </ref>. Applying our technique resulted in both improved flexibility and a simpler design. The previous section also showed how the use of submodule components made it possible to change the high level modularization without rewriting large amounts of code. <p> But it does not address the issue of dynamic change|that is to say the ability of a program to change while running. For that, other methods must be applied. We have used our approach successfully on a number of small programs <ref> [16, 17] </ref>. To test its scalability, we are currently using the approach to implement an image display program modeled after one that was originally written in 30,000 lines of C code. The results, while not conclusive, have been promising. The new design uses 10 to 20 components per module.
Reference: [18] <author> S.H. Zweben, S.H. Edwards, B.W. Weide, and J.E. Hollingsworth. </author> <title> The effects of layering and encapsulation on software development cost and quality. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(3) </volume> <pages> 200-208, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Some studies suggest that it is generally easier to replace a module, or add a new one, than to alter the implementation of an existing module <ref> [14, 18] </ref>. How difficult would it be to build a new circular shifter? The difficulty of changing or building a module necessarily depends on its complexity. Complex modules should be subdivided into smaller, less complex components.
References-found: 18

