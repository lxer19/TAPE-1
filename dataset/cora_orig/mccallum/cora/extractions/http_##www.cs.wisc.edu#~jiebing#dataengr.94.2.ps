URL: http://www.cs.wisc.edu/~jiebing/dataengr.94.2.ps
Refering-URL: http://www.cs.wisc.edu/~jiebing/jiebing.html
Root-URL: 
Email: jiebing@cs.wisc.edug  
Title: Storage Reclamation and Reorganization in Client-Server Persistent Object Stores  
Author: Voon-Fee Yong Jeffrey F. Naughton f yong, naughton, Jie-Bing Yu 
Address: Wisconsin, Madison, WI 53706  
Affiliation: Department of Computer Sciences University of  
Abstract: In this paper we develop and evaluate a number of storage reclamation algorithms for client-server persistent object stores. Experience with a detailed simulation and a prototype implementation in the Exodus storage manager shows that one of our proposed algorithms, the Incremental Partitioned Collector, is complete, maintains transaction semantics, and can be run incrementally and concurrently with client applications. Furthermore, it can significantly improve subsequent system performance by reclustering data, rendering it attractive even for systems that choose not to support automatic storage reclamation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Appel, A.W., Ellis, J.R. and Li, K. </author> <title> "Real-time Concurrent Collection on Stock Multiprocessors," </title> <booktitle> Proceedings of SIGPLAN Conference on Programming Language Design and Implementation 1988, </booktitle> <address> Atlanta, Georgia, </address> <month> June </month> <year> 1988, </year> <month> pp.11-20 </month>
Reference-contexts: The algorithms we studied are described in Section 4; Section 5 gives our experiment configurations, and Section 6 gives experimental results. We conclude in Section 7. 2 Related Work Most of the work in the area of storage reclamation has been focused on volatile memory systems <ref> [1, 2, 3, 7, 9, 13, 16, 19, 20, 21, 24] </ref>. Comparatively little attention has been paid for implementing automatic storage reclamation for large persistent object storage systems, and none that we are aware of considers the client-server model.
Reference: [2] <author> Baker, H.G. </author> <title> "List processing in real time on a serial computer," </title> <journal> Communication of the ACM, </journal> <volume> 21(4), </volume> <month> April </month> <year> 1978, </year> <month> pp.280-294 </month>
Reference-contexts: The algorithms we studied are described in Section 4; Section 5 gives our experiment configurations, and Section 6 gives experimental results. We conclude in Section 7. 2 Related Work Most of the work in the area of storage reclamation has been focused on volatile memory systems <ref> [1, 2, 3, 7, 9, 13, 16, 19, 20, 21, 24] </ref>. Comparatively little attention has been paid for implementing automatic storage reclamation for large persistent object storage systems, and none that we are aware of considers the client-server model. <p> We also propose a hybrid approach between generational copying and mark and sweep algorithm. Kolodner's work [14] describes a stop-the-world Semispaces <ref> [2] </ref> copying collector. In addition to being disruptive, it requires the force/no steal buffer management policy for recovery. In [15], an incremental fault tolerant scheme based on Appel, Ellis and Li's copying algorithm was presented. This incremental algorithm has some properties similar to our adaptation of Baker's incremental copying algorithm. <p> We consider two different copying collectors: one based upon Baker's incremental copier, the other an algorithm inspired by generational collectors. 4.3.1 Baker's Incremental Copier The algorithm described in this section is an extension of Baker's incremental copying garbage collector <ref> [2] </ref>. It requires that the system use logical object identifiers. For garbage collection, logical OIDS have the advantage of allowing the movement of objects without the use of forwarding addresses or the need to update all references to the transported objects.
Reference: [3] <author> Brooks, R.A. </author> <title> "Trading Data Space for Reduced Time and Code Space in Real-time Garbage Collection on Stock Hardware," </title> <booktitle> Proceedings of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <address> pp.108-113, </address> <month> August </month> <year> 1984, </year> <institution> Austin, Texas </institution>
Reference-contexts: The algorithms we studied are described in Section 4; Section 5 gives our experiment configurations, and Section 6 gives experimental results. We conclude in Section 7. 2 Related Work Most of the work in the area of storage reclamation has been focused on volatile memory systems <ref> [1, 2, 3, 7, 9, 13, 16, 19, 20, 21, 24] </ref>. Comparatively little attention has been paid for implementing automatic storage reclamation for large persistent object storage systems, and none that we are aware of considers the client-server model.
Reference: [4] <author> Butler, M.H., </author> <title> "Storage Reclamation in Object Oriented Database Systems," </title> <booktitle> ACM-SIGMOD Proceedings, </booktitle> <address> San Francisco, </address> <month> May </month> <year> 1987, </year> <month> pp.410-425 </month>
Reference-contexts: Comparatively little attention has been paid for implementing automatic storage reclamation for large persistent object storage systems, and none that we are aware of considers the client-server model. The most directly relevant work is by Butler <ref> [4] </ref>, who showed that copying collectors are necessary for achieving better performance for future traversal of the database. Our simulation confirmed this. However, the mark and sweep algorithms considered in that apper are not incremental, and none of the algorithms deals with recovery or concurrency control.
Reference: [5] <author> Carey, M.J., DeWitt, </author> <title> D.J., </title> <editor> et. al. </editor> <title> "The Exodus Extensible DBMS Project: An Overview," Readings in Object-Oriented Database Systems, </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, California, </address> <year> 1990, </year> <month> pp.474-499 </month>
Reference-contexts: These are based upon reference counting, mark-and-sweep, and copying collectors, all adapted to applications in a client-server environment. We evaluate these algorithms by both detailed simulation of a client-server OODBMS and implementation in the Exodus storage manager <ref> [5] </ref> (Exodus SM). The results of these experiments will be described in Section 6. <p> The server only needs the most up-to-date copy for verification process. The storage space required for VRTs from all clients may be substantial if the client applications can freely assign persistent OIDs to local variables, as is the case in Exodus <ref> [5] </ref>.
Reference: [6] <author> Carey, M., Dewitt, D.J. and Naughton, J.F. </author> <title> "The 007 Benchmark", </title> <note> to appear in SIGMOD '93. </note>
Reference-contexts: We modified a subset of the C++ implementation of the OO7 benchmark <ref> [6] </ref> by utilizing those routines to perform garbage collection and measure its cost. Due to the lack of a type manager in the current Exodus system, we built a hand-coded type manager. <p> The workload in each case is a subset of an early version of the OO7 Benchmark <ref> [6] </ref>. Space precludes a full description of that benchmark in this paper. It suffices to know that the OO7 benchmark database contains a graph of atomic parts. The graph itself is partitioned into composite parts, with about twenty atomic parts per composite part. <p> The database created in the creation transaction is a small 007 <ref> [6] </ref> database of 2.8MBytes, created by a series of update transactions. The second transaction is a DFS traversal of the database, followed by a replacement transaction that replaces half the atomic objects (5000) in the database. <p> The workload used in this test are the two reorganization operations from an early version of the 007 bench mark <ref> [6] </ref>, which were designed to test the compaction and reclustering capability of object-oriented database systems. The size of the database used in this test is approximately 2.5MBytes with a total of 32943 objects created.
Reference: [7] <author> Deutsch, L.P. and Bobrow, D.G. </author> <title> "An Efficient, </title> <journal> In--cremental, Automatic Garbage Collector" Communications of the ACM, </journal> <volume> Vol. 19, Number 9, </volume> <month> September </month> <year> 1976, </year> <month> pp.522-526 </month>
Reference-contexts: The algorithms we studied are described in Section 4; Section 5 gives our experiment configurations, and Section 6 gives experimental results. We conclude in Section 7. 2 Related Work Most of the work in the area of storage reclamation has been focused on volatile memory systems <ref> [1, 2, 3, 7, 9, 13, 16, 19, 20, 21, 24] </ref>. Comparatively little attention has been paid for implementing automatic storage reclamation for large persistent object storage systems, and none that we are aware of considers the client-server model. <p> We describe each in a subsection below. 4.1 Reference Counting We studied two variations of the reference counting algorithms: Server-Oriented Reference Counting, and Client-Optimized Reference Counting. Both are based upon the deferred reference counting algorithm of Deutsch and Bobrow <ref> [7] </ref>. We chose this algorithm as a basis because it reduces the frequency of updating reference counts, it can be easily adapted to accommodate the concept of transactions, and, unlike naive reference counting schemes, it does not store reference counts with objects.
Reference: [8] <author> DeWitt, D.J., Futtersack, P., Maier, D. and Velez, F. </author> <title> "A Study of Three Alternative Workstation-Server Architectures for Object Oriented Database Systems," </title> <booktitle> Proc. 16th International Conference on VLDB, </booktitle> <address> Brisbane, </address> <month> Aug. </month> <year> 1990 </year>
Reference-contexts: The simulator is based on the client-server model of an object server <ref> [8] </ref> with page-level locking. The components of the simulator correspond to those in the persistent object store model of Figure 1. The client buffer pool consists of 150 4KByte pages, and the server pool is 500 4KByte pages. Both the client and server buffer managers use the LRU replacement policy.
Reference: [9] <author> Dijkstra, E.W., Lamport, L., Martin, A.J., Scholten, C.S. and Steffens, E.F.M. </author> <title> "On-the-fly garbage collection: An exercise in cooperation," </title> <journal> Communication of the ACM, </journal> <volume> 21(11), </volume> <month> November </month> <year> 1978, </year> <month> pp.966-975 </month>
Reference-contexts: The algorithms we studied are described in Section 4; Section 5 gives our experiment configurations, and Section 6 gives experimental results. We conclude in Section 7. 2 Related Work Most of the work in the area of storage reclamation has been focused on volatile memory systems <ref> [1, 2, 3, 7, 9, 13, 16, 19, 20, 21, 24] </ref>. Comparatively little attention has been paid for implementing automatic storage reclamation for large persistent object storage systems, and none that we are aware of considers the client-server model. <p> For that reason, we also considered a variant of the incremental update write barrier algorithms described in [22]. In particular, the algorithm we considered is similar to that developed by Dijkstra <ref> [9] </ref>. The algorithm allows both the mutators (client applications) and the collector to execute simultaneously. This incremental mark and sweep algorithm makes use of a tri-color scheme [22].
Reference: [10] <author> Exodus Project Group, </author> <title> Exodus Storage Manager Architectural Overview, Exodus Project Document, </title> <institution> University of Wisconsin-Madison, </institution> <month> Nov. </month> <year> 1991 </year>
Reference-contexts: The client module provides the upper application layer with a library of interface calls for object manipulation and transaction support. The server is a multi-threaded process that supports I/O, files, transactions, concurrency control, and recovery. Each client request is executed within the context of a thread. See <ref> [10] </ref> for details. We did a prototype implementation of the Client-Optimized reference counting (Subsection 4.1) and the incremental mark and sweep (Subsection 4.2.2) in the Exodus SM.
Reference: [11] <author> Franklin, M.J., Copeland, G., Weikum G. </author> <title> "What's Different About Garbage Collection for Persistent Programming Languages?" MCC Technical Report </title>
Reference-contexts: These problems render traditional solutions to garbage collection either inapplicable or hopelessly inefficient <ref> [11] </ref>. fl This work was supported by NSF grant IRI-9157357 y Current address: Tandem Computers Incorporated, 10100 N. Tantau Ave. LOC 251-04, Cupertino, CA 95014. E-mail: YONG VOONFEE@tandem.com In this paper we develop and evaluate a number of algorithms for storage reclamation (garbage collection) in client-server persistent object stores.
Reference: [12] <author> Franklin, M.J., Zwilling, M.J., Tan, C.K., Carey, M.J., Dewitt, </author> <title> D.J. "Crash Recovery in Client-Server Exodus," </title> <booktitle> ACM-SIGMOD International Conference on the Management of Data, </booktitle> <address> San Diego, </address> <year> 1992 </year>
Reference-contexts: The log manager at the client site is used for simulating the generation of log records due to updates by the client application. The size of a log record is based on that created by Exodus's recovery mechanism <ref> [12] </ref>. We have simulated a per-update logging system without the page-level optimization used in Exodus. Simulating per-update logging accentuates the difference in the number of log records generated by different collection algorithms. We simulated a 2-phase locking scheme for concurrency control.
Reference: [13] <author> Johnson, D. </author> <title> "The Case for a Read Barrier," </title> <booktitle> Fourth International Conference on Architectural Support for Programming Languages and Operating Systems(ASPLOS IV), </booktitle> <address> pp.96-107, Santa Clara, California, </address> <month> April </month> <year> 1991 </year>
Reference-contexts: The algorithms we studied are described in Section 4; Section 5 gives our experiment configurations, and Section 6 gives experimental results. We conclude in Section 7. 2 Related Work Most of the work in the area of storage reclamation has been focused on volatile memory systems <ref> [1, 2, 3, 7, 9, 13, 16, 19, 20, 21, 24] </ref>. Comparatively little attention has been paid for implementing automatic storage reclamation for large persistent object storage systems, and none that we are aware of considers the client-server model.
Reference: [14] <author> Kolodner, E., Liskov, B. and Weihl, W. </author> <title> "Atomic Garbage Collection: Managing a Stable Heap," </title> <booktitle> Proceedings of the ACM-SIGMOD Conference, </booktitle> <address> Portland, Oregon, </address> <year> 1989, </year> <month> pp.15-25 </month>
Reference-contexts: We also propose a hybrid approach between generational copying and mark and sweep algorithm. Kolodner's work <ref> [14] </ref> describes a stop-the-world Semispaces [2] copying collector. In addition to being disruptive, it requires the force/no steal buffer management policy for recovery. In [15], an incremental fault tolerant scheme based on Appel, Ellis and Li's copying algorithm was presented.
Reference: [15] <author> Kolodner, E., Weihl, W. </author> <title> "Atomic Incremental Garbage Collection and Recovery for Large Stable Heap," </title> <booktitle> To appear in Proceedings of ACM-SIGMOD Conference, </booktitle> <address> Washington D.C., </address> <year> 1993 </year>
Reference-contexts: We also propose a hybrid approach between generational copying and mark and sweep algorithm. Kolodner's work [14] describes a stop-the-world Semispaces [2] copying collector. In addition to being disruptive, it requires the force/no steal buffer management policy for recovery. In <ref> [15] </ref>, an incremental fault tolerant scheme based on Appel, Ellis and Li's copying algorithm was presented. This incremental algorithm has some properties similar to our adaptation of Baker's incremental copying algorithm. <p> Since we expect this to be a rare occurrence, in our experiments, we do not include test cases where this doubling was necessary. 4.3.3 Recovery The copying collection algorithms described in this section move objects from one area of the database to another, which, as mentioned in Kolodner's paper <ref> [15] </ref>, can interfere with the proper recovery of the database after system failures. The recovery mechanisms used by our algorithms as described above are simpler than those proposed by Kolodner.
Reference: [16] <author> Moon, D.A. </author> <title> "Garbage Collection in a Large Lisp System," </title> <booktitle> In Conference Record of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <address> pp.235-246, Austin, Texas, </address> <month> August </month> <year> 1984 </year>
Reference-contexts: The algorithms we studied are described in Section 4; Section 5 gives our experiment configurations, and Section 6 gives experimental results. We conclude in Section 7. 2 Related Work Most of the work in the area of storage reclamation has been focused on volatile memory systems <ref> [1, 2, 3, 7, 9, 13, 16, 19, 20, 21, 24] </ref>. Comparatively little attention has been paid for implementing automatic storage reclamation for large persistent object storage systems, and none that we are aware of considers the client-server model.
Reference: [17] <author> Schwetman, H. "C++/CSIM: </author> <title> An Object Oriented Simulation Package" MCC/Octopus Project </title>
Reference-contexts: We consider each in turn. 5.1 Simulation In order to obtain a fair comparison of the the algorithms and an accurate estimate of the cost of garbage collection in a persistent object store, we built a detailed simulator using C++/CSIM <ref> [17] </ref>. The simulator is based on the client-server model of an object server [8] with page-level locking. The components of the simulator correspond to those in the persistent object store model of Figure 1.
Reference: [18] <author> Schuh, D., Carey, M. </author> <title> and "Persistence in E Revisited Implementation Experiences," </title> <note> UW-Madison Computer Sciences Department Technical Report 957 </note>
Reference: [19] <author> Standish, T.A. </author> <title> "Data Structure Techniques," </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1980, </year> <month> pp.212-218 </month>
Reference-contexts: The algorithms we studied are described in Section 4; Section 5 gives our experiment configurations, and Section 6 gives experimental results. We conclude in Section 7. 2 Related Work Most of the work in the area of storage reclamation has been focused on volatile memory systems <ref> [1, 2, 3, 7, 9, 13, 16, 19, 20, 21, 24] </ref>. Comparatively little attention has been paid for implementing automatic storage reclamation for large persistent object storage systems, and none that we are aware of considers the client-server model. <p> In both cases, we use depth first search (DFS) traversal for marking live objects, since more complicated marking algorithms that involve link-inversions <ref> [19] </ref> are very expensive in terms of disk I/Os and require a great deal of states to be logged. The details of the two algorithms are presented in the following subsections. 4.2.1 Server-Oriented Halting Mark and Sweep This algorithm simply stops all client applications when garbage collection is activated.
Reference: [20] <author> Ungar, D. and Jackson, F. </author> <title> "Tenuring Policies for Generation-Based Storage Reclamation," </title> <booktitle> OOP-SLA 1988 Conference Proceedings, </booktitle> <address> San Diego, California, </address> <year> 1988, </year> <month> pp.1-17 </month>
Reference-contexts: The algorithms we studied are described in Section 4; Section 5 gives our experiment configurations, and Section 6 gives experimental results. We conclude in Section 7. 2 Related Work Most of the work in the area of storage reclamation has been focused on volatile memory systems <ref> [1, 2, 3, 7, 9, 13, 16, 19, 20, 21, 24] </ref>. Comparatively little attention has been paid for implementing automatic storage reclamation for large persistent object storage systems, and none that we are aware of considers the client-server model. <p> It provides the reclustering and compacting benefits of Baker's incremental technique without its space overhead and its delay before reclaimed storage is available. This scheme uses one of the basic ideas behind the generational garbage collection algorithms <ref> [20, 21, 24] </ref>: instead of copying the entire database, limit the scope of collection to a small region of the storage that is expected to provide the maximum free space for the collection effort.
Reference: [21] <author> Ungar, D. </author> <title> "Generation Scavenging: A Nondisruptive High Performance Storage Reclamation Algorithm," </title> <journal> ACM SIGPLAN Notices, </journal> <volume> Vol. 19.5, </volume> <month> May </month> <year> 1984, </year> <month> pp.157-167 </month>
Reference-contexts: The algorithms we studied are described in Section 4; Section 5 gives our experiment configurations, and Section 6 gives experimental results. We conclude in Section 7. 2 Related Work Most of the work in the area of storage reclamation has been focused on volatile memory systems <ref> [1, 2, 3, 7, 9, 13, 16, 19, 20, 21, 24] </ref>. Comparatively little attention has been paid for implementing automatic storage reclamation for large persistent object storage systems, and none that we are aware of considers the client-server model. <p> It provides the reclustering and compacting benefits of Baker's incremental technique without its space overhead and its delay before reclaimed storage is available. This scheme uses one of the basic ideas behind the generational garbage collection algorithms <ref> [20, 21, 24] </ref>: instead of copying the entire database, limit the scope of collection to a small region of the storage that is expected to provide the maximum free space for the collection effort. <p> It is also used to construct and maintain a remember set for each partition in the persistent store. The remember set of a partition is the set of all OIDs of objects in other partitions that reference objects stored in this partition <ref> [21] </ref>. Clients send collection-specific information to the server at transaction commit time. Like the previous incremental traversal garbage collection algorithms, the partition algorithm uses the tricolor scheme to differentiate between traversed and untraversed objects. New objects are always allocated as grey and untraversed.
Reference: [22] <author> Wilson, P.R. </author> <title> "Uniprocessor Garbage Collection Techniques," </title> <booktitle> Proceedings of the International Workshop on Memory Management, </booktitle> <month> September </month> <year> 1992 </year>
Reference-contexts: For that reason, we also considered a variant of the incremental update write barrier algorithms described in <ref> [22] </ref>. In particular, the algorithm we considered is similar to that developed by Dijkstra [9]. The algorithm allows both the mutators (client applications) and the collector to execute simultaneously. This incremental mark and sweep algorithm makes use of a tri-color scheme [22]. <p> of the incremental update write barrier algorithms described in <ref> [22] </ref>. In particular, the algorithm we considered is similar to that developed by Dijkstra [9]. The algorithm allows both the mutators (client applications) and the collector to execute simultaneously. This incremental mark and sweep algorithm makes use of a tri-color scheme [22]. Three marking colors are used to identify objects that are made reachable when the collector is traversing the object graph: WHITE for all untraversed objects, BLACK for marked objects with all references examined, and GREY for marked objects which still have some references not yet been examined. <p> Its size is relatively small | only 2 bits required for each object. In this algorithm, the server runs a collector that traverses the set of persistent roots, using the depth first marking scheme. At the same time, client applications can manipulate the persistent objects. A write barrier <ref> [22] </ref> detects changes made to the persistent objects in clients. The write barrier detects the modification of object references in an object, and adds the OIDs of the new object references to a local grey list.
Reference: [23] <author> Wilson, P.R., Lam, M.S. and Moher, T.G. </author> <title> "Effective Static-graph Reorganization to Improve Locality in Garbage-Collected Systems," </title> <booktitle> Proceedings of the SIGPLAN 1991 Conference on Programming Languages Design and Implementation, </booktitle> <address> Toronto, Ontario, Canada, </address> <month> June </month> <year> 1991, </year> <month> pp.177-191 </month>
Reference: [24] <author> Wilson, P.R. and Moher, T.G. </author> <title> "Design of the Opportunistic Garbage Collector," </title> <booktitle> OOPSLA Conference Proceedings 1989, </booktitle> <address> New Orleans, Louisiana, </address> <month> Oct. </month> <year> 1989 </year>
Reference-contexts: The algorithms we studied are described in Section 4; Section 5 gives our experiment configurations, and Section 6 gives experimental results. We conclude in Section 7. 2 Related Work Most of the work in the area of storage reclamation has been focused on volatile memory systems <ref> [1, 2, 3, 7, 9, 13, 16, 19, 20, 21, 24] </ref>. Comparatively little attention has been paid for implementing automatic storage reclamation for large persistent object storage systems, and none that we are aware of considers the client-server model. <p> It provides the reclustering and compacting benefits of Baker's incremental technique without its space overhead and its delay before reclaimed storage is available. This scheme uses one of the basic ideas behind the generational garbage collection algorithms <ref> [20, 21, 24] </ref>: instead of copying the entire database, limit the scope of collection to a small region of the storage that is expected to provide the maximum free space for the collection effort.
Reference: [25] <author> Zorn, B. </author> <title> "Comparing Mark and Sweep and Stop and Copy Garbage Collection," </title> <address> LISPC90, Nice, France, </address> <month> June </month> <year> 1990, </year> <month> pp.87-98. </month>
Reference-contexts: Our simulation confirmed this. However, the mark and sweep algorithms considered in that apper are not incremental, and none of the algorithms deals with recovery or concurrency control. Zorn <ref> [25] </ref> proposed the use of a deferred sweep algorithm to make the sweep phase of the mark and sweep algorithm incremental, very similar to our incremental mark and sweep algorithm described in Section 4.2.2. We also propose a hybrid approach between generational copying and mark and sweep algorithm.
References-found: 25

