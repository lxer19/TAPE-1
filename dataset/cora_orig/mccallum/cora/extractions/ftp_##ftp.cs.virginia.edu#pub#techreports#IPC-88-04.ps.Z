URL: ftp://ftp.cs.virginia.edu/pub/techreports/IPC-88-04.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Implementing Set Operators over Class Hierarchies  
Author: John L. Pfaltz 
Note: This research was supported in part by JPL Contract #957721 and by DOE Grant #DE-FG05-88ER25063.  
Address: Charlottesville, VA 22903  
Affiliation: Institute for Parallel Computation School of Engineering and Applied Science University of Virginia  
Date: August 5, 1988  
Pubnum: IPC-TR-88-004  
Abstract-found: 0
Intro-found: 1
Reference: [AbH87] <author> S. Abiteboul and R. Hull, </author> <title> IFO: A Formal Semantic Database Model, </title> <journal> Trans. </journal> <note> Database Systems 12,4 (Dec. </note> <year> 1987), </year> <pages> 525-565. </pages>
Reference-contexts: 1. Introduction In this paper we introduce the concept of an entity database model. This model is not intended to be a complete working database model in the sense that various semantic database models, (e.g. DAPLEX [Shi81], SDM, Semantic Data Model [HaM81], Galileo [ACO85], IFO <ref> [AbH87] </ref>) or object oriented database models, (e.g. Smalltalk [CoM84, MSe86], Orient84/K [IsT86], and [SSE87]) are. These latter models are "complete" in the sense that entire computational languages with syntax and semantics have, or could be, implemented with respect to them. <p> We never addressed the issue of 15 how they might be formed. In a sense it is irrelevant to the major thesis of this paper. But it is nevertheless an interesting issue. Abiteboul and Hull, in <ref> [AbH87] </ref>, consider the twin concepts of specialization and generalization as methods of defining hierarchical class dependencies. Specialization, in which an existing super-class C 0 is refined to form a new more specialized sub-class C 1 , is the mechanism most commonly employed in semantic database languages.
Reference: [Ada85] <author> T. Adachi, Powerposets, </author> <title> Inf. </title> <booktitle> and Control 66(1985), </booktitle> <pages> 138-162. </pages>
Reference-contexts: Note that the class hierarchy automatically becomes a lattice of data types as described in [Sco76], or more particularly a semi-lattice structure as described in <ref> [Ada85] </ref>, since we do not assume that the least upper bound of two classes need exist. 5.
Reference: [ACO85] <author> A. Albano, L. Cardelli and R. Orsini, </author> <title> Galileo: A Strongly Typed Interactive Conceptual Lanugage, </title> <journal> Trans. Database Systems 10,2 (June 1985), </journal> <pages> 230-260. </pages>
Reference-contexts: 1. Introduction In this paper we introduce the concept of an entity database model. This model is not intended to be a complete working database model in the sense that various semantic database models, (e.g. DAPLEX [Shi81], SDM, Semantic Data Model [HaM81], Galileo <ref> [ACO85] </ref>, IFO [AbH87]) or object oriented database models, (e.g. Smalltalk [CoM84, MSe86], Orient84/K [IsT86], and [SSE87]) are. These latter models are "complete" in the sense that entire computational languages with syntax and semantics have, or could be, implemented with respect to them.
Reference: [AtB87] <author> M. P. Atkinson and O. P. Buneman, </author> <title> Types and Persistence in Database Programming Languages, </title> <journal> Computing Surveys 19,2 (June 1987), </journal> <pages> 105-190. 18 </pages>
Reference-contexts: We require a class constructor of type SET which defines a new class, denoted by S [C ], of sets whose elements belong to the class C. Many type theories introduce class constructors based on Cartesian product (for tuples) [HuK87] or disjoint sum (for variant records) <ref> [AtB87] </ref>. It is our belief that class extension using a set constructor is conceptually clearer. Frequently F S [C ] = , although it need not be.
Reference: [Bra83] <author> R. J. Brachman, </author> <title> What IS-A Is and Isn't: An Analysis of Taxonomic Links in Semantic Networks, </title> <booktitle> COMPUTER 16,10 (Oct. </booktitle> <year> 1983), </year> <pages> 30-36. </pages>
Reference-contexts: All entities in the class, for example the class PERSON, will share common properties, such as name, home_address, age, and social_security_number. Most semantic and object-oriented databases support the concept of sub-class by means of an IS_A construct. Brachman 2 <ref> [Bra83] </ref> correctly notes that inheritance as defined by the IS_A construct is really little more than convenient syntactic shorthand for incrementally creating sub-classes, so we will ignore actual inheritance mechanisms per se. <p> Condition (a) seems to be universally accepted in both object-oriented and semantic-network class hierarchies. Several authors (c.f. <ref> [Bra83, Tou86] </ref>) have found strict implication too strong for many forms of semantic reasoning. They would replace it with a non-monotonic logic that allows exceptions. Nevertheless, a condition similar to (b) would seem to be essential in sub 4 class definition.
Reference: [Car84] <author> L. Cardelli, </author> <title> A Semantics of Multiple Inheritance, in Semantics of Data Types, </title> <booktitle> Lecture Notes in Computer Science 173, </booktitle> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1984, </year> <pages> 51-67. </pages>
Reference-contexts: A similar semi-lattice of set-class declarations, and possibly of set set-class declarations must also be maintained. 4) In view of 2) above, a limited form of "multiple inheritance" induced by the formation of intersection classes is required. But it need not be of the generality described in <ref> [Car84] </ref>. We believe that these represent minimal characteristics which must be present in any entity database model whose class hierarchy is defined by specialization. More general models, such as one which would support generalization, or equivalently the complete closure of the union operator, are possible.
Reference: [CaW85] <author> L. Cardelli and P. Wegner, </author> <title> On Understanding Types, Data Abstraction, and Polymorphism, </title> <journal> Computing Surveys 17,4 (1985), </journal> <pages> 471-522. </pages>
Reference-contexts: Cardelli and Wegner call this inclusion polymorphism in <ref> [CaW85] </ref>, an entity of type "doctor" can be regarded as being of the form "person" as well. Similarly, the concept of the intersection of a set of "doctors" and "patients" to denote those persons who are both "doctors" and "patients" also makes polymorphic sense.
Reference: [CaS84] <author> M. A. Casanova and J. E. A. Sa, </author> <title> Mapping Uninterpreted Schemes into Entity-Relationship Diagrams: Two Applications to Conceptual Schema Design, </title> <institution> IBM Jour. Res & Dev. </institution> <month> 28,1 (Jan. </month> <year> 1984), </year> <pages> 82-94. </pages>
Reference-contexts: We hasten to point out that our entity database model is quite distinct from the entity-relationship model introduced by Peter Chen [Che76] and extended by several others (e.g. <ref> [CaS84, TYF86] </ref>). Their's can be viewed as a design model which is extremely useful for organizing the structure of real world data prior to representing it with respect to some particular language, which is often relational. Our entity database model is strictly an implementational model.
Reference: [CGY81] <author> D. D. Chamberlin, A. M. Gilbert and R. A. Yost, </author> <title> A History of System R and SQL/Data System, </title> <booktitle> Proc. 7th VLDB Conf., </booktitle> <address> Cannes, France, </address> <month> Sep. </month> <year> 1981, </year> <pages> 456-464. </pages>
Reference-contexts: Then we will derive several necessary consequences arising from the implementation of set operators in any such language belonging to the entity model and thereby contrast such languages with the many languages adhering to the relational database model, (e.g. <ref> [CGY81, RoS87, Sho79, SWK76] </ref>). We hasten to point out that our entity database model is quite distinct from the entity-relationship model introduced by Peter Chen [Che76] and extended by several others (e.g. [CaS84, TYF86]).
Reference: [Che76] <author> P. P. Chen, </author> <title> The Entity-Relationship Model---Toward a Unified View of Data, </title> <journal> Trans. Database Systems 1,1 (Mar. </journal> <year> 1976), </year> <pages> 9-36. </pages>
Reference-contexts: We hasten to point out that our entity database model is quite distinct from the entity-relationship model introduced by Peter Chen <ref> [Che76] </ref> and extended by several others (e.g. [CaS84, TYF86]). Their's can be viewed as a design model which is extremely useful for organizing the structure of real world data prior to representing it with respect to some particular language, which is often relational.
Reference: [CoM84] <author> G. Copeland and D. Maier, </author> <title> Making Smalltalk a Database System, </title> <booktitle> Proc. SIGMOD Conf., </booktitle> <address> Boston, </address> <month> June </month> <year> 1984, </year> <pages> 316-325. </pages>
Reference-contexts: This model is not intended to be a complete working database model in the sense that various semantic database models, (e.g. DAPLEX [Shi81], SDM, Semantic Data Model [HaM81], Galileo [ACO85], IFO [AbH87]) or object oriented database models, (e.g. Smalltalk <ref> [CoM84, MSe86] </ref>, Orient84/K [IsT86], and [SSE87]) are. These latter models are "complete" in the sense that entire computational languages with syntax and semantics have, or could be, implemented with respect to them.
Reference: [HaM81] <author> M. Hammer and D. McLeod, </author> <title> Database Description with SDM: A Semantic Database Model, </title> <journal> Trans. Database Systems 6,3 (Sep. </journal> <year> 1981), </year> <pages> 351-386. </pages>
Reference-contexts: 1. Introduction In this paper we introduce the concept of an entity database model. This model is not intended to be a complete working database model in the sense that various semantic database models, (e.g. DAPLEX [Shi81], SDM, Semantic Data Model <ref> [HaM81] </ref>, Galileo [ACO85], IFO [AbH87]) or object oriented database models, (e.g. Smalltalk [CoM84, MSe86], Orient84/K [IsT86], and [SSE87]) are. These latter models are "complete" in the sense that entire computational languages with syntax and semantics have, or could be, implemented with respect to them.
Reference: [HuK87] <author> R. Hull and R. King, </author> <title> Semantic Database Modeling: Survey, Applications, and Research Issues, </title> <journal> Computing Surveys 19,3 (Sep. </journal> <year> 1987), </year> <pages> 201-260. </pages>
Reference-contexts: Nevertheless, a condition similar to (b) would seem to be essential in sub 4 class definition. Given this definition, it is easy to show that Proposition 2.1: is a partial order on any collection of classes. Following Hull and King <ref> [HuK87] </ref>, we shall graphically represent sub-class dependence (or IS_A inheritance) by C k :( F k , E k ) And, of course, a single class may have several non-comparable sub-classes as in, C k :( F k , E k ) Now we can say that a database implementation belongs <p> We require a class constructor of type SET which defines a new class, denoted by S [C ], of sets whose elements belong to the class C. Many type theories introduce class constructors based on Cartesian product (for tuples) <ref> [HuK87] </ref> or disjoint sum (for variant records) [AtB87]. It is our belief that class extension using a set constructor is conceptually clearer. Frequently F S [C ] = , although it need not be.
Reference: [IsT86] <author> Y. Ishiwkawa and M. Tokoro, </author> <title> A Concurrent Object-Oriented Knowledge Representation Language, Orient84/K: Its Features and Implementation, </title> <booktitle> OOPSLA '86, Conf. Proc., </booktitle> <month> Sep. </month> <year> 1986, </year> <pages> 232-241. </pages>
Reference-contexts: This model is not intended to be a complete working database model in the sense that various semantic database models, (e.g. DAPLEX [Shi81], SDM, Semantic Data Model [HaM81], Galileo [ACO85], IFO [AbH87]) or object oriented database models, (e.g. Smalltalk [CoM84, MSe86], Orient84/K <ref> [IsT86] </ref>, and [SSE87]) are. These latter models are "complete" in the sense that entire computational languages with syntax and semantics have, or could be, implemented with respect to them. Instead, we will characterize our generic entity database model by only two fundamental properties which are common to all of them.
Reference: [KhC86] <author> S. N. Khoshafian and G. P. Copeland, </author> <title> Object Identity, </title> <booktitle> OOPSLA '86, Conf. Proc., </booktitle> <month> Sep. </month> <year> 1986, </year> <pages> 406-416. </pages>
Reference-contexts: This is impossible in the relational model, in which any two tuples belonging to a single relation r with schema F R must at least differ over some set of key attributes K F R . Khoshafian and Copeland give a general discussion of object identity in <ref> [KhC86] </ref>. Some of the issues encountered in implementing an entity naming paradigm are discussed in [PFW88]. In this paper, the precise mechanism used to identify entities is not at issue. The concept of set is central to all languages subsumed under the entity database model.
Reference: [MSe86] <author> D. Maier, J. Stein and et.al., </author> <title> Development of an Object-Oriented DBMS, </title> <booktitle> OOPSLA '86, Conf. Proc., </booktitle> <month> Sep. </month> <year> 1986, </year> <pages> 472-482. </pages>
Reference-contexts: This model is not intended to be a complete working database model in the sense that various semantic database models, (e.g. DAPLEX [Shi81], SDM, Semantic Data Model [HaM81], Galileo [ACO85], IFO [AbH87]) or object oriented database models, (e.g. Smalltalk <ref> [CoM84, MSe86] </ref>, Orient84/K [IsT86], and [SSE87]) are. These latter models are "complete" in the sense that entire computational languages with syntax and semantics have, or could be, implemented with respect to them.
Reference: [PFW88] <author> J. L. Pfaltz, J. C. French and J. L. Whitlatch, </author> <title> Scoping Persistent Name Spaces in ADAMS, </title> <institution> IPC TR-88-003, Institute for Parallel Computation, Univ. of Virginia, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Khoshafian and Copeland give a general discussion of object identity in [KhC86]. Some of the issues encountered in implementing an entity naming paradigm are discussed in <ref> [PFW88] </ref>. In this paper, the precise mechanism used to identify entities is not at issue. The concept of set is central to all languages subsumed under the entity database model. One deals with sets of entities. <p> To create a reasonable implementation of the generalization process, one must be prepared to address the potentially sticky issue of synonyms, as discussed in <ref> [PFW88] </ref>. (The issue of synonyms can also arise in specialization, but by the nature of the process itself it is far less likely.) If, at a still later time, we wish to include a third class C 3 , perhaps TRUCK or AIRPLANE to use Abiteboul and Hull's example, then the
Reference: [PSF88] <author> J. L. Pfaltz, S. H. Son and J. C. </author> <title> French, The ADAMS Interface Language, </title> <booktitle> Proc. 3th Conf. on Hypercube Concurrent Computers and Applications, </booktitle> <address> Pasadena, CA, </address> <month> Jan. </month> <year> 1988, </year> <pages> 1382-1389. </pages>
Reference-contexts: Formal Notation The preceding intuitive introduction to classes, sub-classes, and a class hierarchy in the entity database model can be made more formal. Let F C = - f i denote a set of functions associated with a particular class C. Following the syntax used in ADAMS <ref> [PSF88] </ref> we will use the expression x.f i to denote the image of x under f i . <p> These sets, which we will denote by the uppercase letters X, Y, and Z, are themselves entities and so must belong to some class which is distinct from the class of their constituent entities. This distinction must be quite clear in an implementation language, such as ADAMS <ref> [PSF88] </ref>, which employs a syntax like . . . is_a SET of &lt;class_name&gt; elements. An instance set comprised of entities belonging to the class C can not itself belong to C; it must belong to a different class.
Reference: [RoK86] <author> N. Roussopoulos and H. Kang, </author> <booktitle> Principles and Techniques in the Design of ADMS, </booktitle> <institution> IEEE Computer 19,12 (Dec. </institution> <year> 1986), </year> <pages> 19-25. </pages>
Reference-contexts: In the relational model, the union of two relations is a new relation into which the operand tuples are literally copied. (Although most implementations do so, the tuples need not be physically copied at the time of execution (c.f. <ref> [RoK86] </ref>), but the operational semantics must behave as if they were.) In our entity data model, only identifiers need to be copied, that is we replicate the reference to, not the entity instance itself. In our discussion below, we will refer to both "copy" semantics and "reference" semantics. 9 4.2.
Reference: [RoS87] <author> L. A. Rowe and M. R. Stonebraker, </author> <title> The POSTGRES Data Model, </title> <booktitle> Proc. 13th VLDB Conf., </booktitle> <address> Brighton, England, </address> <month> Sep. </month> <year> 1987, </year> <pages> 83-96. </pages>
Reference-contexts: Then we will derive several necessary consequences arising from the implementation of set operators in any such language belonging to the entity model and thereby contrast such languages with the many languages adhering to the relational database model, (e.g. <ref> [CGY81, RoS87, Sho79, SWK76] </ref>). We hasten to point out that our entity database model is quite distinct from the entity-relationship model introduced by Peter Chen [Che76] and extended by several others (e.g. [CaS84, TYF86]).
Reference: [Sco76] <author> D. S. Scott, </author> <title> Data Types as Lattices, </title> <journal> Siam J. on Computing 5,3 (Sep. </journal> <year> 1976), </year> <pages> 522-587. </pages>
Reference-contexts: Note that the class hierarchy automatically becomes a lattice of data types as described in <ref> [Sco76] </ref>, or more particularly a semi-lattice structure as described in [Ada85], since we do not assume that the least upper bound of two classes need exist. 5.
Reference: [SSE87] <author> A. Sernadas, C. Sernadas and H. Ehrich, </author> <title> Object-Oriented Specification of Databases: An Algebraic Approach, </title> <booktitle> Proc. 13th VLDB Conf., </booktitle> <address> Brighton, England, </address> <month> Sep. </month> <year> 1987, </year> <pages> 107-116. </pages>
Reference-contexts: This model is not intended to be a complete working database model in the sense that various semantic database models, (e.g. DAPLEX [Shi81], SDM, Semantic Data Model [HaM81], Galileo [ACO85], IFO [AbH87]) or object oriented database models, (e.g. Smalltalk [CoM84, MSe86], Orient84/K [IsT86], and <ref> [SSE87] </ref>) are. These latter models are "complete" in the sense that entire computational languages with syntax and semantics have, or could be, implemented with respect to them. Instead, we will characterize our generic entity database model by only two fundamental properties which are common to all of them.
Reference: [Shi81] <author> D. W. Shipman, </author> <title> The Functional Data Model and the Data Language DAPLEX, </title> <journal> Trans. Database Systems 6,1 (Mar. </journal> <year> 1981), </year> <pages> 140-173. </pages>
Reference-contexts: 1. Introduction In this paper we introduce the concept of an entity database model. This model is not intended to be a complete working database model in the sense that various semantic database models, (e.g. DAPLEX <ref> [Shi81] </ref>, SDM, Semantic Data Model [HaM81], Galileo [ACO85], IFO [AbH87]) or object oriented database models, (e.g. Smalltalk [CoM84, MSe86], Orient84/K [IsT86], and [SSE87]) are. These latter models are "complete" in the sense that entire computational languages with syntax and semantics have, or could be, implemented with respect to them. <p> The image of f may be a value (e.g. printable string or icon) or some other entity. Permitting f to be set-valued as in DAPLEX <ref> [Shi81] </ref> will not alter the generality of our approach. While we speak of functions in this paper, those more accustomed to an object-oriented approach might choose to regard the f as analogous to the methods associated with a class.
Reference: [Sho79] <author> J. E. Shopiro, </author> <title> Theseus--A Programming Language for Relational Databases, </title> <journal> Trans. </journal> <note> Database Systems 4,4 (Dec. </note> <year> 1979), </year> <pages> 493-517. 19 </pages>
Reference-contexts: Then we will derive several necessary consequences arising from the implementation of set operators in any such language belonging to the entity model and thereby contrast such languages with the many languages adhering to the relational database model, (e.g. <ref> [CGY81, RoS87, Sho79, SWK76] </ref>). We hasten to point out that our entity database model is quite distinct from the entity-relationship model introduced by Peter Chen [Che76] and extended by several others (e.g. [CaS84, TYF86]).
Reference: [SWK76] <author> M. Stonebraker, E. Wong, P. Kreps and G. </author> <title> Held, The Design and Implementation of INGRES, </title> <journal> Trans. Database Systems 1,3 (Sep. </journal> <year> 1976), </year> <pages> 189-222. </pages>
Reference-contexts: Then we will derive several necessary consequences arising from the implementation of set operators in any such language belonging to the entity model and thereby contrast such languages with the many languages adhering to the relational database model, (e.g. <ref> [CGY81, RoS87, Sho79, SWK76] </ref>). We hasten to point out that our entity database model is quite distinct from the entity-relationship model introduced by Peter Chen [Che76] and extended by several others (e.g. [CaS84, TYF86]).
Reference: [TYF86] <author> T. J. Teorey, D. Yang and J. P. Fry, </author> <title> A Logical Design Methodology for Relational Databases Using the Extended Entity-Relationship Model, </title> <journal> Computing Surveys 18,2 (June 1986), </journal> <pages> 197-222. </pages>
Reference-contexts: We hasten to point out that our entity database model is quite distinct from the entity-relationship model introduced by Peter Chen [Che76] and extended by several others (e.g. <ref> [CaS84, TYF86] </ref>). Their's can be viewed as a design model which is extremely useful for organizing the structure of real world data prior to representing it with respect to some particular language, which is often relational. Our entity database model is strictly an implementational model.
Reference: [Tou86] <author> D. S. Touretzky, </author> <title> The Mathematics of Inheritance Systems, </title> <publisher> Morgan Kaufmann Publ., </publisher> <address> Los Altos, CA, </address> <year> 1986. </year>
Reference-contexts: Condition (a) seems to be universally accepted in both object-oriented and semantic-network class hierarchies. Several authors (c.f. <ref> [Bra83, Tou86] </ref>) have found strict implication too strong for many forms of semantic reasoning. They would replace it with a non-monotonic logic that allows exceptions. Nevertheless, a condition similar to (b) would seem to be essential in sub 4 class definition.
Reference: [Ull82] <author> J. D. Ullman, </author> <title> Principles of Database Systems, 2nd Ed., </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1982. </year> <title> 20 Table of Contents 1. Introduction ................................................................................................... 2 2. Formal Notation ............................................................................................ 3 3. The Compass of a Set ................................................................................... 7 4. Set Operators in a Class Hierarchy ............................................................... 8 4.1. Set Representation ................................................................................. 9 4.2. Set Union ............................................................................................... 10 4.3. Set Intersection ...................................................................................... 12 5. Specialization and Generalization ................................................................ 15 6. </title> <type> Summary ....................................................................................................... 17 7. References ..................................................................................................... 18 21 </type>
References-found: 28

