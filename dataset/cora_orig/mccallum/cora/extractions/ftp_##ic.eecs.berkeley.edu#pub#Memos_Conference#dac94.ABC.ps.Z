URL: ftp://ic.eecs.berkeley.edu/pub/Memos_Conference/dac94.ABC.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/HomePages/serdar/publications/index.html
Root-URL: 
Title: HSIS: A BDD-Based Environment for Formal Verification  
Author: A. Aziz, F. Balarin, S. T. Cheng, R. Hojati, T. Kam, S. C. Krishnan, R. K. Ranjan, T. R. Shiple, V. Singhal, S. Tasiran, H.-Y. Wang, R. K. Brayton and A. L. Sangiovanni-Vincentelli 
Address: Berkeley, Berkeley, CA 94720  
Affiliation: Department of EECS, University of California at  
Abstract: Functional and timing verification are currently the bottlenecks in many design efforts. Simulation and emulation are extensively used for verification. Formal verification is now gaining acceptance in advanced design groups. This has been facilitated by the use of binary decision diagrams (BDDs). This paper describes the essential features of HSIS, a BDD-based environment for formal verification: 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Aziz, S. Tasiran, and R. K. Brayton. </author> <title> BDD Variable Ordering for Interacting Finite State Machines. </title> <booktitle> In Design Automation Conference, </booktitle> <year> 1994. </year>
Reference-contexts: While it is arguable whether one would want to verify such properties, it is true that when one abstracts a system, in order that the abstraction not be trivial (and hence useless) it is necessary to impose some fairness constraints. Fairness constraints 1 <ref> [1] </ref> forms the basis for our BDD variable ordering algorithm. are described in Section 5.1. In Section 5.2 we discuss property check-ing by language containment, and CTL model checking.
Reference: [2] <author> F. Balarin and G. York. </author> <title> Verilog HDL Modeling Styles for Formal Verification. </title> <booktitle> In IFIP Conference on Hardware Description Languagesand their Applications, </booktitle> <pages> pages 439-452. </pages> <publisher> OCRI Publications, </publisher> <month> April </month> <year> 1993. </year>
Reference-contexts: In order to allow abstraction in the system or to model an environment, we need to express non-determinism. In most HDLs, including Verilog, non-determinism is not supported. Balarin and York proposed using the non-blocking assignment in Verilog to describe non-determinism of register variables <ref> [2] </ref>. We have further extended Verilog minimally by creating a new construct for describing non-determinism of wire variables. It is also desirable to have the following additional features in Verilog for ease of expression. * Enumerated types.
Reference: [3] <author> R. S. Boyer and J. S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: We seek to improve the efficiency of verification so that larger designs can be verified, and to develop simpler methods for specifying properties. Of the various formal verification methods, the first to be used in design verification was theorem proving <ref> [11, 3] </ref>. These techniques are somewhat similar to the formal verification techniques used to verify the correctness of software written in programming languages. These verification techniques usually require extensive interactive use of human experts. There have been two recent approaches for verifying properties of systems described as state transition systems.
Reference: [4] <author> R. K. Brayton, M. Chiodo, R. Hojati, T. Kam, K. Kodandapani, R. P. Kurshan, S. Malik, A. L. Sangiovanni-Vincentelli, E. M. Sentovich, T. Shiple, K. J. Singh, and H.-Y. Wang. BLIF-MV: </author> <title> An Interchange Format for Design Verification and Synthesis. </title> <type> Technical Report UCB/ERL M91/97, </type> <institution> Electronics Research Lab, Univ. of California, Berkeley, </institution> <address> CA 94720, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: This is achieved by using an intermediate format based on multi-level logic, called BLIF-MV <ref> [4] </ref> and described in Section 4, which is capable of compactly representing finite-state behavior (all digital hardware systems fall in this category). In order to have the same specifications for synthesis, simulation, and verification, we use the synthesis subsets of HDLs. <p> Other times, more detail must be given to the environment to properly account for the actual operating conditions of the component. 4 BLIF-MV We have designed an intermediate format called BLIF-MV <ref> [4] </ref> to allow for easy translation from HDLs for the purposes of both verification and hierarchical synthesis. It is a natural extension of BLIF, the Berkeley Logic Interchange Format [23]. We extended BLIF to provide non-determinism and multiple valued variables.
Reference: [5] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, and D. L. Dill. </author> <title> Symbolic Model Checking: 10 20 States and Beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-170, </pages> <year> 1992. </year>
Reference-contexts: There are two main methods to perform this exploration-explicit methods and implicit methods (based on BDDs). Implicit methods manipulate sets of states at a time. There are very many examples of large state spaces that can be explored with implicit techniques, but not explicit <ref> [5] </ref>. As is discussed in [17] a straight forward translation of the explicit algorithms in not necessarily the best for BDDs. The language containment check is translated to a language emptiness check, and this fails if there is an accepting run in the automaton.
Reference: [6] <author> S. T. Cheng. </author> <title> Compiling Verilog into Automata. </title> <type> Technical report, </type> <institution> UC Berkeley, </institution> <year> 1994. </year>
Reference-contexts: One can compile many languages such as VHDL, Esterel, SMV, and Murphi to BLIF-MV. Currently we provide support for translation from a synthesizable subset of Verilog <ref> [6] </ref>. In order to allow abstraction in the system or to model an environment, we need to express non-determinism. In most HDLs, including Verilog, non-determinism is not supported. Balarin and York proposed using the non-blocking assignment in Verilog to describe non-determinism of register variables [2].
Reference: [7] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <year> 1986. </year>
Reference-contexts: An alternative approach of doing property verification is to specify the properties using temporal logic and perform model checking on the system specification to verify these properties <ref> [7] </ref>. Systems that manipulate these state-based systems explicitly are limited by the size of state spaces. In the context of implementation verification, Coudert and Madre [8] illustrated the use of BDDs to implicitly manipulate state transition systems with much larger state spaces. <p> This is true if and only if no behavior is produced by the system where out1 and out2 are simultaneously asserted. An alternative way to state properties is to use CTL formulas <ref> [7] </ref>. For example, to state the above safety property, we use the CTL formula AG (out1 + out2), which is read for all reachable paths at the same time. from the start state, and for all states on these paths, out1 and out2 are never asserted at the same time.
Reference: [8] <author> O. Coudert and J. C. Madre. </author> <title> A Unified Framework for the Formal Verification of Sequential Circuits. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 126-129, </pages> <month> November </month> <year> 1990. </year>
Reference-contexts: Systems that manipulate these state-based systems explicitly are limited by the size of state spaces. In the context of implementation verification, Coudert and Madre <ref> [8] </ref> illustrated the use of BDDs to implicitly manipulate state transition systems with much larger state spaces. Since then, the use of BDDs has been extended to manipulate transition systems in the area of design verification (as in the tool SMV [21]).
Reference: [9] <author> D. L. Dill, A. J. Drexler, A. J. Hu, and C. H. Yang. </author> <title> Protocol Verification as a Hardware Design Aid. </title> <booktitle> In Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pages 522-525, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: Determining the schedule and performing the multiplication and quantification takes only several seconds. We can show that descriptions in other models of concurrency such as the Selection/Resolution model [18] and the interleaving shared memory model <ref> [9] </ref> can be mapped efficiently (in basically linear or close to linear time) into descriptions in synchronous c/s. Although interleaved (or asynchronous) behavior can be modeled using synchronous c/s, it may be computationally advantageous to directly model it. Therefore, we have extended the c/s model to directly support interleaved semantics.
Reference: [10] <author> E. A. Emerson and C. L. Lei. </author> <title> Modalities for Model Checking: Branching Time Strikes Back. </title> <booktitle> In Proc. ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 84-96, </pages> <year> 1985. </year>
Reference-contexts: In [17], several graph operators were introduced that can be used to obtain various approximations. These operators are based on techniques introduced by Emerson and Lei in <ref> [10] </ref>, and are used in HSIS to provide for efficient BDD-based verification algorithms. 5.4 Early Failure Detection If verification is to be used as a debugging tool, much in the same way as a debugger is used for a programming language like C, then it is expected that it would be
Reference: [11] <author> M. Gordon. </author> <title> HOL: A Proof Generating System for Higher-orderLogic. </title> <editor> In G. Birwis-tle and P. A. Subrahmanyam, editors, </editor> <booktitle> VLSI Specification, Verification and Synthesis, </booktitle> <pages> pages 73-127. </pages> <publisher> Academic Press, </publisher> <address> Boston, </address> <year> 1988. </year>
Reference-contexts: We seek to improve the efficiency of verification so that larger designs can be verified, and to develop simpler methods for specifying properties. Of the various formal verification methods, the first to be used in design verification was theorem proving <ref> [11, 3] </ref>. These techniques are somewhat similar to the formal verification techniques used to verify the correctness of software written in programming languages. These verification techniques usually require extensive interactive use of human experts. There have been two recent approaches for verifying properties of systems described as state transition systems.
Reference: [12] <author> Z. Har'El and R. P. Kurshan. </author> <title> Software for Analytical Development of Communication Protocols. </title> <journal> AT&T Technical Journal, </journal> <pages> pages 45-59, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: One approach is to specify both the system and the properties as !-automata. The verification task is equivalent to verifying that the language of the system is contained in the language of the properties (the language containment approach) (as in the verification tool COSPAN <ref> [12] </ref>). An alternative approach of doing property verification is to specify the properties using temporal logic and perform model checking on the system specification to verify these properties [7]. Systems that manipulate these state-based systems explicitly are limited by the size of state spaces.
Reference: [13] <author> R. Hojati, R. K. Brayton, and R. P. Kurshan. </author> <title> BDD-Based Debugging of Design Using Language Containment and Fair CTL. </title> <editor> In C. Courcoubetis, editor, </editor> <booktitle> Proc. of the Conf. on Computer-Aided Verification, </booktitle> <volume> volume 697, </volume> <pages> pages 41-58. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: This technique is used in conjunction with the first one, that is, it can be applied to a subset of reachable states. 6 Debugging Debugging is one of the most important aspects of a verification tool. HSIS provides a fairly complete debugging environment <ref> [13] </ref>. The debugging methods vary depending on the type of property checking being performed. 6.1 Debugging for Language Containment If the property is specified using automata, a debug trace that violates the property is printed. Intuitively, if the debug trace is short, then it is easier to understand the error.
Reference: [14] <author> R. Hojati, S. Krishnan, and R. K. Brayton. </author> <title> Heuristic Algorithms for Early Quantification and Partial Product Minimization. </title> <type> Technical Report M94/11, </type> <institution> UC Berkeley, </institution> <year> 1994. </year>
Reference-contexts: Automatic algorithm for early quantification. In building transition relations for individual processes, or for the product machine, it is necessary to multiply a set of BDDs and existentially quantify out some variables. This can be done more efficiently taking advantage of early quantification. HSIS provides an automatic procedure <ref> [14] </ref> that gives a schedule of how to multiply and quantify out variables. 3. Use of don't cares. Don't care information can be used to substantially improve the performance of algorithms by minimizing the BDDs in intermediate computations. We take advantage of don't care information as much as possible.
Reference: [15] <author> R. Hojati, T. R. Shiple, R. K. Brayton, and R. P. Kurshan. </author> <title> A Unified Environment for Language Containment and Fair CTL Model Checking. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 475-481, </pages> <address> Dallas, Texas, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: For language containment, the edge-Streett/edge-Rabin environment is supported. One can prove that the next natural extension to this environment makes the language containment problem NP-complete. As for CTL, a logic known as fair CTL is supported. Combining the two environments is achieved using techniques described in <ref> [15] </ref>. 2. Automatic algorithm for early quantification. In building transition relations for individual processes, or for the product machine, it is necessary to multiply a set of BDDs and existentially quantify out some variables. This can be done more efficiently taking advantage of early quantification. <p> There are several reasons to support both automata and CTL formulas. 1. There are properties expressible by one but not the other <ref> [15] </ref>. 2. Some properties may be more easily expressed in one than the other. For example, properties involving sequencing of events are expressed more easily using automata. On the other hand, CTL is easier to use for simple properties. <p> A fair state is one that is involved in some cycle satisfying all fairness constraints, and thus a reachable fair state means a failing language containment check. In <ref> [15] </ref> it is explained how such an emptiness check as well as CTL model checking can be achieved through first computing an approximation to the set of fair states. In [17], several graph operators were introduced that can be used to obtain various approximations.
Reference: [16] <author> R. Hojati, V. Singhal, and R. K. Brayton. </author> <title> Edge-Streett/Edge-Rabin Automata Environment for Formal Verification Using Language Containment. </title> <type> Technical Report M94/12, </type> <institution> UC Berkeley, </institution> <year> 1994. </year>
Reference-contexts: However, now it is possible for the FSM to remain in s forever, which may cause the desired properties to fail. Fairness constraints remove such unwanted behavior. The fairness constraints that are allowed in HSIS <ref> [16] </ref> can be divided into two categories: * Negative fairness constraints. Any behavior satisfying a negative fairness constraint is removed. For example, a negative state-subset constraint says that a behavior that stays in the subset forever should be excluded.
Reference: [17] <author> R. Hojati, H. Touati, R. P. Kurshan, and R. K. Brayton. </author> <title> Efficient !-Regular Language Containment. </title> <booktitle> In Proc. of the Fourth Workshop on Computer-Aided Verification, </booktitle> <pages> pages 371-382, </pages> <address> Montreal, Quebec, Canada, </address> <year> 1992. </year>
Reference-contexts: There are two main methods to perform this exploration-explicit methods and implicit methods (based on BDDs). Implicit methods manipulate sets of states at a time. There are very many examples of large state spaces that can be explored with implicit techniques, but not explicit [5]. As is discussed in <ref> [17] </ref> a straight forward translation of the explicit algorithms in not necessarily the best for BDDs. The language containment check is translated to a language emptiness check, and this fails if there is an accepting run in the automaton. <p> In [15] it is explained how such an emptiness check as well as CTL model checking can be achieved through first computing an approximation to the set of fair states. In <ref> [17] </ref>, several graph operators were introduced that can be used to obtain various approximations.
Reference: [18] <author> R. P. Kurshan. </author> <title> Reducibility in Analysis of Coordination. In Discrete Event Systems: Models and Applications, </title> <booktitle> volume 103 of LNCIS, </booktitle> <pages> pages 19-39. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: In one example, around 1600 relations had to be multiplied and 1500 variables had to be quantified out. Determining the schedule and performing the multiplication and quantification takes only several seconds. We can show that descriptions in other models of concurrency such as the Selection/Resolution model <ref> [18] </ref> and the interleaving shared memory model [9] can be mapped efficiently (in basically linear or close to linear time) into descriptions in synchronous c/s. Although interleaved (or asynchronous) behavior can be modeled using synchronous c/s, it may be computationally advantageous to directly model it. <p> In this case, fairness constraints will be an indispensable feature. 5.2 Property checking Properties can be stated and proved in HSIS using either automata (the language containment paradigm), or CTL formulas (the model checking paradigm). Automata can be used to express properties of designs <ref> [18] </ref>. HSIS offers support for a class of automata, known as edge-Rabin automata [16]O . Such automata can be used to describe two types of properties: safety properties and liveness properties.
Reference: [19] <author> R. P. Kurshan. </author> <title> Automata-Theoretic Verification of Coordinating Processes. </title> <publisher> Prince-ton University Press, </publisher> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: The design is specified in an HDL. Verification starts at the the earliest abstract level of design. Then at each step of the design process, the design is refined by removing some non-determinism in the specification (this process is described in detail in <ref> [19] </ref>). As long as new behavior is not added to the design during refinement, then most properties (all properties except for existential properties, which assert the existence of some behavior) proved at higher levels of abstraction will automatically hold at the lower levels.
Reference: [20] <author> K. L. McMillan and J. Schwalbe. </author> <title> Formal Verification of the Encore Gigamax Cache Consistency Protocols. </title> <booktitle> In International Symposium on Shared Memory Multiprocessors, </booktitle> <month> April </month> <year> 1991. </year>
Reference-contexts: The experiments were run on a DECsystem 5900/260 with 440MB physical memory. The first two examples, dining philosophers and ping pong, are toy examples. 2mdlc is a message data-link controller obtained from industry. Gigamax is a multiprocessor cache consistency protocol <ref> [20] </ref>. Scheduler is a distributed scheduling protocol for multiple tasks from [22]. All examples were written in the augmented subset of Verilog discussed in Section 3. They were then translated into BLIF-MV using the vl2mv tool supplied with HSIS.
Reference: [21] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Since then, the use of BDDs has been extended to manipulate transition systems in the area of design verification (as in the tool SMV <ref> [21] </ref>). In this paper, we describe HSIS (for Hierarchical Sequential Interactive System), a BDD-based environment for design verification. HSIS is designed to be a unified environment for formal verification and logic synthesis; currently we only support the verification framework.
Reference: [22] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1989. </year>
Reference-contexts: The first two examples, dining philosophers and ping pong, are toy examples. 2mdlc is a message data-link controller obtained from industry. Gigamax is a multiprocessor cache consistency protocol [20]. Scheduler is a distributed scheduling protocol for multiple tasks from <ref> [22] </ref>. All examples were written in the augmented subset of Verilog discussed in Section 3. They were then translated into BLIF-MV using the vl2mv tool supplied with HSIS. The time to translate from Verilog to BLIF-MV was in all examples negligibleall under 0.5 seconds.
Reference: [23] <author> E. M. Sentovich, K. J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. R. Stephan, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <note> SIS: </note>
Reference-contexts: It is a natural extension of BLIF, the Berkeley Logic Interchange Format <ref> [23] </ref>. We extended BLIF to provide non-determinism and multiple valued variables. Multiple-valued variables are very useful in describing state transition graphs symbolically. The need for non-determinism is felt in describing the environment and for abstraction in the verification process.
References-found: 23

