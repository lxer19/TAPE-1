URL: http://st-www.cs.uiuc.edu/~hanmer/PLoP-97/Proceedings.ps/ritosilva.ps
Refering-URL: http://st-www.cs.uiuc.edu/~hanmer/PLoP-97/Workshops.html
Root-URL: http://www.cs.uiuc.edu
Email: Rito.Silva@acm.org, fjar@scallabis.inesc.pt, tsg@scallabis.inesc.pt  
Phone: Tel: +351-1-3100287, Fax: +351-1-3145843  
Title: Distributed Proxy: A Design Pattern for Distributed Object Communication  
Author: Antonio Rito Silva, Francisco Assis Rosa, Teresa Goncalves 
Address: Lisbon, Rua Alves Redol n o 9, 1000 Lisboa, PORTUGAL  
Affiliation: INESC/IST Technical University of  
Abstract: This paper presents the Distributed Proxy pattern, a design pattern for distributed object communication. The Distributed Proxy pattern decouples distributed object communication from object specific functionalities. It further decouples logical communication from physical communication. The Distributed Proxy pattern enforces an incremental development process, encapsulates the underlying distribution mechanisms, and offers location transparency. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Grady Booch. </author> <title> Object-Oriented Analyis and Design with Applications. </title> <publisher> The Benjamin/Cummings Publishing Company, Inc., </publisher> <year> 1994. </year>
Reference-contexts: A meeting requires the participation of at least two users. When an agenda session starts, it receives an agenda manager reference from which the agenda user information can be accessed. It is simple to design a solution ignoring distribution issues. The Booch <ref> [1] </ref> class diagram in Figure 1 shows the functionalities design of the agenda application, where distribution issues are ignored. Enriching this design with distribution is complex. For example we must consider different address spaces.
Reference: [2] <author> Pedro Sousa and Antonio Rito Silva. </author> <title> Naming and Identification in Distributed Systems: A Pattern for Naming Policies. </title> <booktitle> In Conference on Pattern Languages of Programs, </booktitle> <address> PLoP '96, Allerton Park, Illinois, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: The performance overhead can be reduced if the implementation uses inheritance, communicators are subclasses of proxies. 6 Implementation 6.1 Variations of Naming Policies There are several possibilities when implementing Name Manager: distributed nodes can share a single Name Manager or have its own Name Manager. As described in <ref> [2] </ref> there are several naming policies. According to name policies, names can be universal or local, absolute or relative and pure or impure. A distributed name is universal if is valid in all the distributed nodes, it exists in all Name Managers.
Reference: [3] <author> Douglas C. Schmidt. </author> <title> The ADAPTIVE Communication Environment: An Object-Oriented Network Programming Toolkit for Developing Communication Software. </title> <booktitle> In 11th and 12th Sun User Group Conferences, </booktitle> <address> San Jose, California and San Francisco, California, </address> <month> December </month> <year> 1993 </year> <month> and June </month> <year> 1994. </year>
Reference-contexts: Impure distributed names avoid the locator conversion. The distributed name is itself a locator. 6.2 Implementation of Communicators The physical layer is implemented using the underlying communication mechanisms. In this section it is described a possible implementation of Communicators on top of the ACE <ref> [3] </ref> framework. ACE (Adaptive Communication Environment) is an object-oriented network programming framework that encapsulates operating system concrete mechanisms with C++ classes. In this implementation the ACE features for interprocess communication will be used. This physical architecture implementation considers a pair of (unidirectional) sockets between two communicating distributed nodes.
Reference: [4] <author> Douglas C. Schmidt. </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching. </title> <editor> In Jim Coplien and Douglas C. Schmidt, editors, </editor> <booktitle> Pattern Languages of Program Design, </booktitle> <pages> pages 529-545. </pages> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: One socket called in-socket is used to receive service request messages and the other called out-socket to send service request messages. Sockets are encapsulated by the ACE Service Handler objects. this implementation. The Reactor class from ACE's Reactor pattern <ref> [4] </ref> is used to register, remove and dispatch Service Handler objects. Two reactors are needed, one for each node. <p> The Distributed Proxy pattern also provides location transparency when the Name Manager supports unique universal identifiers. The Forwarder-Receiver pattern [11] supports the encapsulation of the underlying distributed communication mechanisms. This pattern can be used to implement the Distributed Proxy physical layer. The Reactor pattern <ref> [4] </ref>, Acceptor pattern and Connector pattern [5] can be used in the implementation of the Distributed Proxy physical layer as shown in the implementation section. The Component Configurer pattern [8] decouples component configuration from component functionality. It describes reconfigurable communication entities called Plugs. These Plugs are an implementation of Distributed Proxy.
Reference: [5] <author> Douglas C. Schmidt. </author> <title> Acceptor and Connector: Design Patterns for Active and Passive Estabishment of Network Connections. </title> <editor> In Dirk Riehle Robert Martin and Frank Buschman, editors, </editor> <booktitle> Pattern Languages of Program Design 3. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: Sockets are encapsulated by the ACE Service Handler objects. this implementation. The Reactor class from ACE's Reactor pattern [4] is used to register, remove and dispatch Service Handler objects. Two reactors are needed, one for each node. In the client node a Node Connector object, subclass of ACE's Connector <ref> [5] </ref>, is used to establish the communication with server node, it generates a Client Handler object which encapsulates the out-socket to the server node. The Client Handler is used to send messages associated with invocations and to receive its results. <p> The Client Handler is used to send messages associated with invocations and to receive its results. In the server node a Node Acceptor object, 5 subclass of ACE's Acceptor <ref> [5] </ref>, is used to accept connections from calling nodes, it generates a Server Handler object which encapsulates the in-socket from the client node. The Server Handler is used to receive messages associated with invocations and to return its results. <p> The Forwarder-Receiver pattern [11] supports the encapsulation of the underlying distributed communication mechanisms. This pattern can be used to implement the Distributed Proxy physical layer. The Reactor pattern [4], Acceptor pattern and Connector pattern <ref> [5] </ref> can be used in the implementation of the Distributed Proxy physical layer as shown in the implementation section. The Component Configurer pattern [8] decouples component configuration from component functionality. It describes reconfigurable communication entities called Plugs. These Plugs are an implementation of Distributed Proxy.
Reference: [6] <author> Jon Siegel. </author> <title> CORBA Fundamentals and Programming. </title> <publisher> Wiley, </publisher> <year> 1996. </year>
Reference-contexts: DName *P_CP_Agenda_Manager:: getUserAccess (const String* name) - // obtains logical locator Locator *loc = nameManager_-&gt;resolveName (dnameAgendaManager_); // sets locator at client communicator communicator_-&gt;setLocator (loc); // invokes communicator which returns a distributed name return communicator_-&gt;getUser (name); - 8 Known Uses CORBA <ref> [6] </ref> uses the Distributed Proxy pattern. Implementation of distributed communication is encapsulated by an IDL and object references are dynamically created and passed across nodes. Moreover, CORBA implementations support co-location for the purpose of debugging.
Reference: [7] <author> Antonio Rito Silva, Fiona Hayes, Francisco Mota, Nino Tor-res, and Pedro Santos. </author> <title> A Pattern Language for the Perception, Design and Implementation of Distributed Application 7 Partitioning, October 1996. </title> <booktitle> Presented at the OOPSLA'96 Workshop on Methodologies for Distributed Objects. </booktitle>
Reference-contexts: Moreover, CORBA implementations support co-location for the purpose of debugging. Co-location implements the logical layer of Distributed Proxy pattern because code executes in a centralized node. In the DASCo pattern language <ref> [7] </ref> the Distributed Proxy patterns is integrated with other design patterns, Component Configurer [8] and Passive Replicator [9], to provide component distribution and replicated object distribution, respectively. 9 Related Patterns The Proxy pattern [10, 11] makes the clients of an object communicate with a representative rather than to the object itself.
Reference: [8] <author> Francisco Assis Rosa and Antonio Rito Silva. </author> <title> Component Configurer: A Design Pattern for Component-Based Configuration. </title> <booktitle> In The 2 nd European Conference on Pattern Languages of Programming, </booktitle> <address> EuroPLoP '97, Kloster Irsee, Germany, </address> <month> July </month> <year> 1997. </year>
Reference-contexts: Moreover, CORBA implementations support co-location for the purpose of debugging. Co-location implements the logical layer of Distributed Proxy pattern because code executes in a centralized node. In the DASCo pattern language [7] the Distributed Proxy patterns is integrated with other design patterns, Component Configurer <ref> [8] </ref> and Passive Replicator [9], to provide component distribution and replicated object distribution, respectively. 9 Related Patterns The Proxy pattern [10, 11] makes the clients of an object communicate with a representative rather than to the object itself. <p> This pattern can be used to implement the Distributed Proxy physical layer. The Reactor pattern [4], Acceptor pattern and Connector pattern [5] can be used in the implementation of the Distributed Proxy physical layer as shown in the implementation section. The Component Configurer pattern <ref> [8] </ref> decouples component configuration from component functionality. It describes reconfigurable communication entities called Plugs. These Plugs are an implementation of Distributed Proxy.
Reference: [9] <author> Teresa Goncalves and Antonio Rito Silva. </author> <title> Passive Replicator: A Design Pattern for Object Replication. </title> <booktitle> In The 2 nd Eu-ropean Conference on Pattern Languages of Programming, </booktitle> <address> EuroPLoP '97, Kloster Irsee, Germany, </address> <month> July </month> <year> 1997. </year>
Reference-contexts: Moreover, CORBA implementations support co-location for the purpose of debugging. Co-location implements the logical layer of Distributed Proxy pattern because code executes in a centralized node. In the DASCo pattern language [7] the Distributed Proxy patterns is integrated with other design patterns, Component Configurer [8] and Passive Replicator <ref> [9] </ref>, to provide component distribution and replicated object distribution, respectively. 9 Related Patterns The Proxy pattern [10, 11] makes the clients of an object communicate with a representative rather than to the object itself. In particular the Remote Proxy variation in [11] corresponds to the logical layer of Distributed Proxy.
Reference: [10] <author> Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <publisher> Addison Wesley, </publisher> <year> 1995. </year>
Reference-contexts: In the DASCo pattern language [7] the Distributed Proxy patterns is integrated with other design patterns, Component Configurer [8] and Passive Replicator [9], to provide component distribution and replicated object distribution, respectively. 9 Related Patterns The Proxy pattern <ref> [10, 11] </ref> makes the clients of an object communicate with a representative rather than to the object itself. In particular the Remote Proxy variation in [11] corresponds to the logical layer of Distributed Proxy.
Reference: [11] <author> Frank Buschmann, Regine Meunier, Hans Rohnert, Peter Sommerlad, and Michael Stal. </author> <title> Pattern-Oriented Software Architecture: A System of Patterns. </title> <publisher> John Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: In the DASCo pattern language [7] the Distributed Proxy patterns is integrated with other design patterns, Component Configurer [8] and Passive Replicator [9], to provide component distribution and replicated object distribution, respectively. 9 Related Patterns The Proxy pattern <ref> [10, 11] </ref> makes the clients of an object communicate with a representative rather than to the object itself. In particular the Remote Proxy variation in [11] corresponds to the logical layer of Distributed Proxy. <p> In particular the Remote Proxy variation in <ref> [11] </ref> corresponds to the logical layer of Distributed Proxy. However, Distributed Proxy allows dynamic creation of new proxies and completely decouples the logical layer from the physical layer. The Client-Dispatcher-Server pattern [11] supports location transparency by means of a name service. <p> In particular the Remote Proxy variation in <ref> [11] </ref> corresponds to the logical layer of Distributed Proxy. However, Distributed Proxy allows dynamic creation of new proxies and completely decouples the logical layer from the physical layer. The Client-Dispatcher-Server pattern [11] supports location transparency by means of a name service. The Distributed Proxy pattern also provides location transparency when the Name Manager supports unique universal identifiers. The Forwarder-Receiver pattern [11] supports the encapsulation of the underlying distributed communication mechanisms. <p> The Client-Dispatcher-Server pattern <ref> [11] </ref> supports location transparency by means of a name service. The Distributed Proxy pattern also provides location transparency when the Name Manager supports unique universal identifiers. The Forwarder-Receiver pattern [11] supports the encapsulation of the underlying distributed communication mechanisms. This pattern can be used to implement the Distributed Proxy physical layer. The Reactor pattern [4], Acceptor pattern and Connector pattern [5] can be used in the implementation of the Distributed Proxy physical layer as shown in the implementation section.
References-found: 11

