URL: http://www-cad.eecs.berkeley.edu/~orna/publications/concur95.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~orna/pub.html
Root-URL: 
Title: An Automata-Theoretic Approach to Modular Model Checking  
Author: Orna Kupferman Moshe Y. Vardi 
Date: May 8, 1997  
Affiliation: UC Berkeley  Rice University  
Abstract: In modular verification the specification of a module consists of two parts. One part describes the guaranteed behavior of the module. The other part describes the assumed behavior of the system in which the module is interacting. This is called the assume-guarantee paradigm. In this paper we consider assume-guarantee specifications in which the guarantee is specified by branching temporal formulas. We distinguish between two approaches. In the first approach, the assumption is specified by branching temporal formulas too. In the second approach, the assumption is specified by linear temporal logic. We consider guarantees in 8CTL and 8CTL ? , the universal fragments of CTL and CTL ? , and assumptions in LTL, 8CTL, and 8CTL ? . We develop two fundamental techniques: building maximal models for 8CTL and 8CTL ? formulas and using alternating automata to obtain space-efficient algorithms for fair model checking. Using these techniques we classify the complexity of sat-isfiability, validity, implication, and modular verification for 8CTL and 8CTL ? . We show that modular verification is PSPACE-complete for 8CTL and is is EXPSPACE-complete for 8CTL ? . We prove that when the assumption is linear, these bounds hold also for guarantees in CTL and CTL ? . On the other hand,the problem remains EXPSPACE-hard even when we restrict the assumptions to LTL and take the guarantee as a fixed 8CTL formula. 
Abstract-found: 1
Intro-found: 1
Reference: [AL93] <author> M. Abadi and L. Lamport. </author> <title> Composing specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15(1) </volume> <pages> 73-132, </pages> <year> 1993. </year>
Reference-contexts: This suggests that modular model checking in the branching temporal framework can be practical only for very small assumptions. Indeed, in many examples the assumptions do tend to be of a very small size [Jos87b, Jos89, GL94], see also <ref> [AL93] </ref>. 5.2 The Linear-Branching Modular Model-Checking Problem The modular proof rule in the preceding section uses branching assumptions and guarantees. As mentioned in the introduction, there is another approach in which the assumption is a linear temporal formula, while the guarantee is a branching temporal formula. <p> In addition, heuristics can be employed to avoid unnecessary states in these constructions. If the size of the 41 assumption is not too large and the doubly exponential blowup is avoided, then our algorithms might not be always impractical. Indeed, it is argued in <ref> [AL93] </ref> that assumption formulas should be small, simpler than guarantee formulas. Our result provide an a posteriori justification for Josko's restriction on the linear temporal assumption [Jos87a, Jos87b, Jos89].
Reference: [ASSS94] <author> A. Aziz, T.R. Shiple, V. Singhal, and A.L. Sangiovanni-Vincentelli. </author> <title> Formula-dependent equivalence for compositional CTL model checking. </title> <booktitle> In Proc. 6th Conf. on Computer Aided Verification, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 324-337, </pages> <address> Stanford, CA, June 1994. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: This issue is one of the most important one in the area of computer-aided verification and is the subject of active research (cf. [BCM + 90]). Modular verification is one possible way to address the state-explosion problem, cf. <ref> [CLM89, ASSS94] </ref>.
Reference: [BCM + 90] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <booktitle> In Proceedings of the 5th Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <address> Philadelphia, </address> <month> June </month> <year> 1990. </year> <month> 42 </month>
Reference-contexts: This gives rise to state spaces of exceedingly large sizes, which makes even linear-time algorithms impractical. This issue is one of the most important one in the area of computer-aided verification and is the subject of active research (cf. <ref> [BCM + 90] </ref>). Modular verification is one possible way to address the state-explosion problem, cf. [CLM89, ASSS94].
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching--time model checking. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Computer Aided Verification, Proc. 6th Int. Conference, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-155, </pages> <address> Stanford, June 1994. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: While maximal models for 8CTL involve an exponential blow-up, maximal models for 8CTL ? involve a doubly exponential blow-up. The second technique is the automata-theoretic framework to branching-time model checking introduced in <ref> [BVW94] </ref>. It is shown there how to use alternating tree automata to obtain space-efficient model checking methods. Since the maximal models that we construct include fairness conditions, we extend the automata-theoretic method of [BVW94] to yield space-efficient fair model-checking algorithms. <p> The second technique is the automata-theoretic framework to branching-time model checking introduced in <ref> [BVW94] </ref>. It is shown there how to use alternating tree automata to obtain space-efficient model checking methods. Since the maximal models that we construct include fairness conditions, we extend the automata-theoretic method of [BVW94] to yield space-efficient fair model-checking algorithms. We then show how performing fair model checking over maximal models can solve the satisfiability, validity, and implication problems for 8CTL and 8CTL ? . <p> We bring to bear on the problem the automata-theoretic techniques that were developed for linear and branching temporal logics <ref> [VW86a, BVW94] </ref>. The semantics of the assume-guarantee specification is defined in terms of the computation tree of the module. <p> Similarly, if c is true, A sends copies that check both requirements. As before, a requirement about a is sent universally and a requirement about the b's is sent existentially. 2.5 An Automata-Theoretic Framework to Branching-Time Model Checking In <ref> [BVW94] </ref>, we introduced hesitant alternating automata (HAA). A HAA is a tuple A = h; Q; ffi; Q 0 ; ffi, where , Q, ffi, and Q 0 are as in usual alternating tree automata and ff = hG; Bi, with G Q and B Q, is the acceptance condition. <p> The number of sets in the partition of Q is defined as the depth of A. For a state q 2 Q, we say that q is an existential state iff q 2 Q i for an existential set Q i . Universal states are defined analogously. Theorem 2.4 <ref> [BVW94] </ref> (1) Given a CTL formula and D IN, there exists a HAA A D; = h2 AP ; D; Q; ffi; Q 0 ; ffi, of size and depth O (j j), such that L (A D; ) is exactly the set of D-trees satisfying . (2) Given a CTL <p> W k1 * ffi (A' 1 ~ U ' 2 ; ; k) = ffi (' 2 ; ; k) ^ (ffi (' 1 ; ; k) _ c=0 (c; A' 1 ~ U ' 2 )). As discussed in <ref> [BVW94] </ref>, the product A K; of A D; with a transition system (module with no fairness condition) K is a 1-letter word HAA. The language of A K; is not empty iff K j= . This suggests an automata-based algorithm for branching-time model checking. <p> We now show that the space complexity result of <ref> [BVW94] </ref> for the 1-letter nonemptiness of HAA extends to LAA. Theorem 3.1 The 1-letter nonemptiness problem for a LAA of size n and with m sets can be solved in space O (m log 2 n). <p> Thus, L (A D; ) is exactly the set of D-trees satisfying . Let us mention some of the properties of A D; (for full details see <ref> [BVW94] </ref>). Each state of A D; may be of one of the following three types: 1. A transient state. These states belong to the transient sets of A D; . Typically, they are associated with subformulas of that are atomic propositions or Boolean combination of inner subformulas. 2. <p> Therefore, the lower bound proved there is valid also here. To get the upper bound, we have to check whether A D;'; accepts M t ' . As shown in <ref> [BVW94] </ref>, this can be done by taking the product of A D;'; with M ' . The result is a 1-letter word HAA A M;'; . The size of A M;'; is jM ' j jA D;'; j. <p> As M ' has 2 2 O (jSj) states, the size of A M;'; is double exponential for both CTL and CTL ? . The result then follows from the complexity of the nonemptiness problem for 1-letter word HAA <ref> [BVW94] </ref> (see also the analogue discussion for automata-based fair model checking using LAA in Section 3.2 here).
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: One of the most significant developments in this area is the dis covery of algorithmic methods for verifying temporal-logic properties of finite-state programs fl Address: EECS Department, Berkeley CA 94720-1770, U.S.A. Email: orna@eecs.berkeley.edu y Address: Department of Computer Science, Houston, TX 77251-1892, U.S.A. Email: vardi@cs.rice.edu 1 <ref> [CES86, LP85, QS81] </ref>. This derives its significance both from the fact that many synchroniza-tion and communication protocols can be modeled as finite-state programs, as well as from the great ease of use of fully algorithmic methods. <p> The complexity of model checking for both linear and branching temporal logics is well understood: suppose we are given a program of size n and a temporal logic formula of size m. For a branching temporal logic such as CTL, model-checking algorithms run in time O (nm) <ref> [CES86] </ref>, while, for linear temporal logic such as LTL, model-checking algorithms run in time n2 O (m) [LP85]. Since model checking with respect to a linear temporal logic formula is PSPACE-complete [SC85], the latter bound probably cannot be improved. <p> The situation is different for the branching temporal paradigm. Here the guarantee is a branching temporal formula, which describes the computation tree of the module. There are two approaches, however, to the assumptions in assume-guarantee pairs. The first approach, implicit in <ref> [CES86, EL85, EL87] </ref> and made explicit in [Jos87a, Jos87b, Jos89, DDGJ89], is that the assumption in the assume-guarantee pair concerns the interaction of the module with its environment along each computation, and is therefore more naturally expressed in linear temporal logic.
Reference: [CG87] <author> E.M. Clarke and O. Grumberg. </author> <title> Research on automatic verification of finite-state concurrent systems. </title> <booktitle> In Annual Review of Computer Science, </booktitle> <volume> volume 2, </volume> <pages> pages 269-290, </pages> <year> 1987. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in <ref> [CG87, Wol89] </ref>. We distinguish between two types of temporal logics: linear and branching [Lam80]. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures.
Reference: [CLM89] <author> E.M. Clarke, D.E. Long, and K.L. McMillan. </author> <title> Compositional model checking. </title> <editor> In R. Parikh, editor, </editor> <booktitle> Proc. 4th IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 353-362. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference-contexts: This issue is one of the most important one in the area of computer-aided verification and is the subject of active research (cf. [BCM + 90]). Modular verification is one possible way to address the state-explosion problem, cf. <ref> [CLM89, ASSS94] </ref>. <p> We note that it is argued in [LP85] that an exponential time complexity in the size of the specification might be tolerable in practical applications. Our results also provide an a posteriori justification to the approach taken in <ref> [CLM89] </ref> to avoid the assume-guarantee paradigm. Instead of describing the interaction of the module by an LTL formula, it is proposed there to model the environment by interface processes. As is shown there, these processes are typically much simpler than the full environment of the module.
Reference: [DDGJ89] <author> W. Damm, G. Dohmen, V. Gerstner, and B. Josko. </author> <title> Modular verification of Petri nets: the temporal logic approach. In Stepwise Refinement of Distributed Systems: Models, </title> <booktitle> Formalisms, Correctness (Proceedings of REX Workshop), volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 180-207, </pages> <address> Mook, The Netherlands, May/June 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The situation is different for the branching temporal paradigm. Here the guarantee is a branching temporal formula, which describes the computation tree of the module. There are two approaches, however, to the assumptions in assume-guarantee pairs. The first approach, implicit in [CES86, EL85, EL87] and made explicit in <ref> [Jos87a, Jos87b, Jos89, DDGJ89] </ref>, is that the assumption in the assume-guarantee pair concerns the interaction of the module with its environment along each computation, and is therefore more naturally expressed in linear temporal logic. <p> There, a module M satisfies an assume-guarantee pair h'; i iff whenever M is part of a system satisfying ', the system satisfies too. We call this branching modular model checking. Furthermore, it is argued there, as well as in <ref> [DDGJ89, Jos89, GL91, DGG93] </ref>, that in the context of modular verification it is advantageous to use only universal branching temporal logic, i.e., branching temporal logic without existential path quantifiers.
Reference: [DGG93] <author> D. Dams, O. Grumberg, and R. Gerth. </author> <title> Generation of reduced models for checking fragments of CTL. </title> <booktitle> In Proc. 5th Conf. on Computer Aided Verification, volume 697 of Lecture Notes in Computer Science, </booktitle> <pages> pages 479-490. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1993. </year>
Reference-contexts: There, a module M satisfies an assume-guarantee pair h'; i iff whenever M is part of a system satisfying ', the system satisfies too. We call this branching modular model checking. Furthermore, it is argued there, as well as in <ref> [DDGJ89, Jos89, GL91, DGG93] </ref>, that in the context of modular verification it is advantageous to use only universal branching temporal logic, i.e., branching temporal logic without existential path quantifiers.
Reference: [EJ88] <author> E.A. Emerson and C. Jutla. </author> <title> The complexity of tree automata and logics of programs. </title> <booktitle> In Proceedings of the 29th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 368-377, </pages> <address> White Plains, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: We use here automata-theoretic techniques for CTL ? <ref> [VS85, EJ88] </ref> to construct maximal models for 8CTL ? formulas. While maximal models for 8CTL involve an exponential blow-up, maximal models for 8CTL ? involve a doubly exponential blow-up. The second technique is the automata-theoretic framework to branching-time model checking introduced in [BVW94].
Reference: [EL85] <author> E.A. Emerson and C.-L. Lei. </author> <title> Temporal model checking under generalized fairness constraints. </title> <booktitle> In Proc. 18th Hawaii International Conference on System Sciences, Hawaii, </booktitle> <year> 1985. </year>
Reference-contexts: The situation is different for the branching temporal paradigm. Here the guarantee is a branching temporal formula, which describes the computation tree of the module. There are two approaches, however, to the assumptions in assume-guarantee pairs. The first approach, implicit in <ref> [CES86, EL85, EL87] </ref> and made explicit in [Jos87a, Jos87b, Jos89, DDGJ89], is that the assumption in the assume-guarantee pair concerns the interaction of the module with its environment along each computation, and is therefore more naturally expressed in linear temporal logic.
Reference: [EL87] <author> E.A. Emerson and C.-L. Lei. </author> <title> Modalities for model checking: Branching time logic strikes back. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8 </volume> <pages> 275-306, </pages> <year> 1987. </year>
Reference-contexts: The situation is different for the branching temporal paradigm. Here the guarantee is a branching temporal formula, which describes the computation tree of the module. There are two approaches, however, to the assumptions in assume-guarantee pairs. The first approach, implicit in <ref> [CES86, EL85, EL87] </ref> and made explicit in [Jos87a, Jos87b, Jos89, DDGJ89], is that the assumption in the assume-guarantee pair concerns the interaction of the module with its environment along each computation, and is therefore more naturally expressed in linear temporal logic.
Reference: [GL91] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <booktitle> In Proc. 2nd Con-ferance on Concurrency Theory, volume 527 of Lecture Notes in Computer Science, </booktitle> <pages> pages 250-265. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: There, a module M satisfies an assume-guarantee pair h'; i iff whenever M is part of a system satisfying ', the system satisfies too. We call this branching modular model checking. Furthermore, it is argued there, as well as in <ref> [DDGJ89, Jos89, GL91, DGG93] </ref>, that in the context of modular verification it is advantageous to use only universal branching temporal logic, i.e., branching temporal logic without existential path quantifiers.
Reference: [GL94] <author> O. Grumberg and D.E. </author> <title> Long. Model checking and modular verification. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 16(3) </volume> <pages> 843-871, </pages> <year> 1994. </year>
Reference-contexts: The problem of verifying that a given module M satisfies such a pair h'; i, which we call the linear-branching modular model-checking problem, is more general than either linear or branching model checking. A second approach was considered in <ref> [GL94] </ref>, where assumptions are taken to apply to the computation tree of the system within which the module is interacting. Accordingly, assumptions in [GL94] are also expressed in branching temporal logic. <p> A second approach was considered in <ref> [GL94] </ref>, where assumptions are taken to apply to the computation tree of the system within which the module is interacting. Accordingly, assumptions in [GL94] are also expressed in branching temporal logic. There, a module M satisfies an assume-guarantee pair h'; i iff whenever M is part of a system satisfying ', the system satisfies too. We call this branching modular model checking. <p> Consequently, universal branching temporal logic formulas have the helpful property that once they are satisfied in a module, they are satisfied also in a system that contains this 3 module. The focus in <ref> [GL94] </ref> is on using 8CTL, the universal fragment of CTL, for both the assumption and the guarantee. In this paper, we focus on the branching modular model-checking problem, which we show to be a proper extension of the linear-branching modular model-checking problem. <p> We use two fundamental techniques to solve these questions. The first technique is the maximal-model technique introduced in <ref> [GL94] </ref>. It is shown there that with every 8CTL formula ' one can associate a maximal model M ' (called the tableau of ' in [GL94]) such that a module M satisfies ' precisely when M simulates M ' (we define simulation later on). <p> We use two fundamental techniques to solve these questions. The first technique is the maximal-model technique introduced in <ref> [GL94] </ref>. It is shown there that with every 8CTL formula ' one can associate a maximal model M ' (called the tableau of ' in [GL94]) such that a module M satisfies ' precisely when M simulates M ' (we define simulation later on). We use here automata-theoretic techniques for CTL ? [VS85, EJ88] to construct maximal models for 8CTL ? formulas. <p> The problem of determining whether M satisfies ' is the fair model-checking problem. 7 2.2 Simulation Relation and Composition of Modules In the context of modular verification, it is helpful to define an order relation between modules <ref> [GL94] </ref>. Intuitively, the order captures what it means for a module M 0 to have "more behaviors" than a module M . <p> The following properties of simulation and compositions are proven in <ref> [GL94] </ref> for fair Streett modules (modules where the fairness condition is Streett), and they hold also for fair Rabin modules. Theorem 2.1 [GL94] (1) The simulation relation is a preorder (i.e., a reflexive and transitive order). (2) For every M and M 0 , we have M kM 0 M . <p> The following properties of simulation and compositions are proven in <ref> [GL94] </ref> for fair Streett modules (modules where the fairness condition is Streett), and they hold also for fair Rabin modules. Theorem 2.1 [GL94] (1) The simulation relation is a preorder (i.e., a reflexive and transitive order). (2) For every M and M 0 , we have M kM 0 M . (3) For every M , M 0 , and M 00 , if M M 0 then M kM 00 M 0 <p> Thus, M ' is a maximal model for ' if for every module M , we have that M M ' iff M j= '. A construction of maximal models for 8CTL formulas is described in <ref> [GL94] </ref>. We will describe later a construction of maximal models for 8CTL ? formulas. 2.3 Buchi Word Automata Given an alphabet , an infinite word over is an infinite sequence w = w 1 w 2 w 3 of letters in . <p> Formally, we have the following theorem. The theorem is proved in <ref> [GL94] </ref> for 8CTL, but the proof applies also to 8CTL ? . Theorem 4.2 Let ' and be 8CTL ? formulas, and let M ' be a maximal model of '. Then ' implies iff M ' j= . <p> Proof: Exactly as for 8CTL ? . Here, however, A 8 (') is of size O (j'j), and hence A 8 (') is of size 2 O (j'j) . A different construction for maximal models of 8CTL formulas is given in <ref> [GL94] </ref>. 4.2 Complexity We are now ready to combine the maximal-model technique with the space-efficient fair-model-checking algorithm to solve the implication problem. <p> This suggests that modular model checking in the branching temporal framework can be practical only for very small assumptions. Indeed, in many examples the assumptions do tend to be of a very small size <ref> [Jos87b, Jos89, GL94] </ref>, see also [AL93]. 5.2 The Linear-Branching Modular Model-Checking Problem The modular proof rule in the preceding section uses branching assumptions and guarantees.
Reference: [Jon75] <author> N.D. Jones. </author> <title> Space-bounded reducibility among combinatorial problems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 11 </volume> <pages> 68-75, </pages> <year> 1975. </year>
Reference-contexts: Again, checking this is as 17 simple as evaluating a transition from a transient state. Thus, assuming all values detected by recursion are already assigned, determining whether q 00 is immediately reachable from q 0 can be done in space O (log 2 n). It is known, by <ref> [Jon75] </ref>, that the graph accessibility problem is in NLOGSPACE. Thus, by Savitch's Theorem [Sav70], checking that q 00 is accessible from q 0 can be done deterministically in space O (log 2 n).
Reference: [Jon83] <author> C.B. Jones. </author> <title> Specification and design of (parallel) programs. In R.E.A. </title> <editor> Mason, editor, </editor> <booktitle> Information Processing 83: Proceedings of the IFIP 9th World Congress, </booktitle> <pages> pages 321-332. </pages> <publisher> IFIP, North-Holland, </publisher> <year> 1983. </year>
Reference-contexts: Modular verification is advocated also for other methodological reasons; a robust verification method 2 ology should provide rules for deducing properties of programs from the properties of their con-stituent modules. Indeed, efforts to develop modular verification frameworks were undertaken in the mid 1980s [Pnu85]. A key observation, see <ref> [Lam83, Jon83] </ref>, is that in modular verification the specification should include two parts. One part describes the desired behavior of the module. The other part describes the assumed behavior of the system within which the module is interacting.
Reference: [Jos87a] <author> B. Josko. </author> <title> MCTL an extension of CTL for modular verification of concurrent systems. In Temporal Logic in Specification, </title> <booktitle> Proceedings, volume 398 of Lecture Notes in Computer Science, </booktitle> <pages> pages 165-187, </pages> <address> Altrincham,UK, April 1987. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The situation is different for the branching temporal paradigm. Here the guarantee is a branching temporal formula, which describes the computation tree of the module. There are two approaches, however, to the assumptions in assume-guarantee pairs. The first approach, implicit in [CES86, EL85, EL87] and made explicit in <ref> [Jos87a, Jos87b, Jos89, DDGJ89] </ref>, is that the assumption in the assume-guarantee pair concerns the interaction of the module with its environment along each computation, and is therefore more naturally expressed in linear temporal logic. <p> For every module M , we have that hM t ; P ' i M and hM t ; P ' i M A' . Since hM t ; P ' i M , we 2 We note that the formal definitions in <ref> [Jos87a, Jos87b, Jos89] </ref> apply only to restricted linear temporal assumptions and involve a complicated syntactic construction. 34 have that hM t ; P ' i hM t ; P ' ikM too. <p> Indeed, it is argued in [AL93] that assumption formulas should be small, simpler than guarantee formulas. Our result provide an a posteriori justification for Josko's restriction on the linear temporal assumption <ref> [Jos87a, Jos87b, Jos89] </ref>. Essentially, because of the restriction imposed on the linear temporal assumption, one can get more economical automata-theoretic construction (exponential rather than doubly exponential) of the maximal model associated with the CTL ? formula A' as well as with M ' .
Reference: [Jos87b] <author> B. Josko. </author> <title> Model checking of CTL formulae under liveness assumptions. </title> <booktitle> In Proc. 14th Colloq. on Automata, Programming, and Languages (ICALP), volume 267 of Lecture Notes in Computer Science, </booktitle> <pages> pages 280-289. </pages> <publisher> Springer-Verlag, </publisher> <month> July </month> <year> 1987. </year> <month> 43 </month>
Reference-contexts: The situation is different for the branching temporal paradigm. Here the guarantee is a branching temporal formula, which describes the computation tree of the module. There are two approaches, however, to the assumptions in assume-guarantee pairs. The first approach, implicit in [CES86, EL85, EL87] and made explicit in <ref> [Jos87a, Jos87b, Jos89, DDGJ89] </ref>, is that the assumption in the assume-guarantee pair concerns the interaction of the module with its environment along each computation, and is therefore more naturally expressed in linear temporal logic. <p> This suggests that modular model checking in the branching temporal framework can be practical only for very small assumptions. Indeed, in many examples the assumptions do tend to be of a very small size <ref> [Jos87b, Jos89, GL94] </ref>, see also [AL93]. 5.2 The Linear-Branching Modular Model-Checking Problem The modular proof rule in the preceding section uses branching assumptions and guarantees. <p> For every module M , we have that hM t ; P ' i M and hM t ; P ' i M A' . Since hM t ; P ' i M , we 2 We note that the formal definitions in <ref> [Jos87a, Jos87b, Jos89] </ref> apply only to restricted linear temporal assumptions and involve a complicated syntactic construction. 34 have that hM t ; P ' i hM t ; P ' ikM too. <p> Indeed, it is argued in [AL93] that assumption formulas should be small, simpler than guarantee formulas. Our result provide an a posteriori justification for Josko's restriction on the linear temporal assumption <ref> [Jos87a, Jos87b, Jos89] </ref>. Essentially, because of the restriction imposed on the linear temporal assumption, one can get more economical automata-theoretic construction (exponential rather than doubly exponential) of the maximal model associated with the CTL ? formula A' as well as with M ' .
Reference: [Jos89] <author> B. Josko. </author> <title> Verifying the correctness of AADL modules using model chekcing. In Stepwise Refinement of Distributed Systems: Models, </title> <booktitle> Formalisms, Correctness (Proceedings of REX Workshop), volume 430 of Lecture Notes in Computer Science, </booktitle> <pages> pages 386-400, </pages> <address> Mook, The Netherlands, May/June 1989. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The situation is different for the branching temporal paradigm. Here the guarantee is a branching temporal formula, which describes the computation tree of the module. There are two approaches, however, to the assumptions in assume-guarantee pairs. The first approach, implicit in [CES86, EL85, EL87] and made explicit in <ref> [Jos87a, Jos87b, Jos89, DDGJ89] </ref>, is that the assumption in the assume-guarantee pair concerns the interaction of the module with its environment along each computation, and is therefore more naturally expressed in linear temporal logic. <p> There, a module M satisfies an assume-guarantee pair h'; i iff whenever M is part of a system satisfying ', the system satisfies too. We call this branching modular model checking. Furthermore, it is argued there, as well as in <ref> [DDGJ89, Jos89, GL91, DGG93] </ref>, that in the context of modular verification it is advantageous to use only universal branching temporal logic, i.e., branching temporal logic without existential path quantifiers. <p> This suggests that modular model checking in the branching temporal framework can be practical only for very small assumptions. Indeed, in many examples the assumptions do tend to be of a very small size <ref> [Jos87b, Jos89, GL94] </ref>, see also [AL93]. 5.2 The Linear-Branching Modular Model-Checking Problem The modular proof rule in the preceding section uses branching assumptions and guarantees. <p> For every module M , we have that hM t ; P ' i M and hM t ; P ' i M A' . Since hM t ; P ' i M , we 2 We note that the formal definitions in <ref> [Jos87a, Jos87b, Jos89] </ref> apply only to restricted linear temporal assumptions and involve a complicated syntactic construction. 34 have that hM t ; P ' i hM t ; P ' ikM too. <p> Indeed, it is argued in [AL93] that assumption formulas should be small, simpler than guarantee formulas. Our result provide an a posteriori justification for Josko's restriction on the linear temporal assumption <ref> [Jos87a, Jos87b, Jos89] </ref>. Essentially, because of the restriction imposed on the linear temporal assumption, one can get more economical automata-theoretic construction (exponential rather than doubly exponential) of the maximal model associated with the CTL ? formula A' as well as with M ' .
Reference: [KG96] <author> O. Kupferman and O. Grumberg. </author> <title> Buy one, get one free! Journal of Logic and Computation, </title> <booktitle> 6(4) </booktitle> <pages> 523-539, </pages> <year> 1996. </year>
Reference-contexts: When is a CTL formula, the formula f ( ) is not necessarily a CTL formula. Still, it has a restricted syntax: its path formulas have either a single linear-time operator or two linear-time operators connected by a Boolean operator. By <ref> [KG96] </ref>, formulas of this syntax have a linear translation to CTL. Consider a CTL ? formula . Let M be a module in which &gt; is valid. Clearly, M satisfies iff M satisfies f ( ).
Reference: [Lam80] <author> L. Lamport. </author> <title> Sometimes is sometimes "not never" on the temporal logic of programs. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-185, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in [CG87, Wol89]. We distinguish between two types of temporal logics: linear and branching <ref> [Lam80] </ref>. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures.
Reference: [Lam83] <author> L. Lamport. </author> <title> Specifying concurrent program modules. </title> <journal> ACM Trans. on Programming Languages and Systenms, </journal> <volume> 5 </volume> <pages> 190-222, </pages> <year> 1983. </year>
Reference-contexts: Modular verification is advocated also for other methodological reasons; a robust verification method 2 ology should provide rules for deducing properties of programs from the properties of their con-stituent modules. Indeed, efforts to develop modular verification frameworks were undertaken in the mid 1980s [Pnu85]. A key observation, see <ref> [Lam83, Jon83] </ref>, is that in modular verification the specification should include two parts. One part describes the desired behavior of the module. The other part describes the assumed behavior of the system within which the module is interacting.
Reference: [LP85] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specification. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 97-107, </pages> <address> New Orleans, </address> <month> January </month> <year> 1985. </year>
Reference-contexts: One of the most significant developments in this area is the dis covery of algorithmic methods for verifying temporal-logic properties of finite-state programs fl Address: EECS Department, Berkeley CA 94720-1770, U.S.A. Email: orna@eecs.berkeley.edu y Address: Department of Computer Science, Houston, TX 77251-1892, U.S.A. Email: vardi@cs.rice.edu 1 <ref> [CES86, LP85, QS81] </ref>. This derives its significance both from the fact that many synchroniza-tion and communication protocols can be modeled as finite-state programs, as well as from the great ease of use of fully algorithmic methods. <p> For a branching temporal logic such as CTL, model-checking algorithms run in time O (nm) [CES86], while, for linear temporal logic such as LTL, model-checking algorithms run in time n2 O (m) <ref> [LP85] </ref>. Since model checking with respect to a linear temporal logic formula is PSPACE-complete [SC85], the latter bound probably cannot be improved. The difference in the complexity of linear and branching model checking has been viewed as an argument in favor of the branching paradigm. <p> It will be interesting to find other fragments of LTL (perhaps the fragment studied in [SZ93]) for which we can obtain such a complexity bound. We note that it is argued in <ref> [LP85] </ref> that an exponential time complexity in the size of the specification might be tolerable in practical applications. Our results also provide an a posteriori justification to the approach taken in [CLM89] to avoid the assume-guarantee paradigm.
Reference: [Lyn77] <author> N. Lynch. </author> <title> Log space recognition and translation of parenthesis languages. </title> <journal> J. ACM, </journal> <volume> 24 </volume> <pages> 583-590, </pages> <year> 1977. </year>
Reference-contexts: We start with q which belongs to a transient set. There, we have to evaluate the transition from q. It is known that evaluation of Boolean expressions can be done using space that is logarithmic in the size of the expression <ref> [Lyn77] </ref>. Here, we evaluate expressions over Q, using a recursion to trace their Boolean value. Since each recursive call takes us to a lower Q i , the depth of the recursion is bounded by m.
Reference: [Mil71] <author> R. Milner. </author> <title> An algebraic definition of simulation between programs. </title> <booktitle> In Proceedings of the 2nd International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 481-489, </pages> <month> September </month> <year> 1971. </year>
Reference-contexts: Intuitively, it means that the module M 0 has more behaviors than the module M . In fact, every possible behavior of M is also a possible behavior of M 0 . Note that our simulation is different from the classical simulation used by Milner <ref> [Mil71] </ref>, where there are no fairness conditions. Let M and M 0 be two modules.
Reference: [MS87] <author> D.E. Muller and P.E. Schupp. </author> <title> Alternating automata on infinite trees. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 54,:267-276, </address> <year> 1987. </year>
Reference-contexts: Given a set D IN, a D-tree is a computation tree in which all the nodes have degrees in D. Finite automata on infinite trees (tree automata, for short) run on such -labeled trees. Alternating automata on infinite trees generalize nondeterministic tree automata and were first introduced in <ref> [MS87] </ref>. For simplicity, we refer first to automata over infinite binary trees. Consider a nondeterministic tree automaton A = h; Q; ffi; Q 0 ; ffi. The transition relation ffi maps an automaton state q 2 Q and an input letter 2 to a set of pairs of states.
Reference: [MSS86] <author> D.E. Muller, A. Saoudi, and P.E. Schupp. </author> <title> Alternating automata, the weak monadic theory of the tree and its complexity. </title> <booktitle> In Proc. 13th Int. Colloquium on Automata, Languages and Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: A HAA is a tuple A = h; Q; ffi; Q 0 ; ffi, where , Q, ffi, and Q 0 are as in usual alternating tree automata and ff = hG; Bi, with G Q and B Q, is the acceptance condition. As in weak alternating automata <ref> [MSS86] </ref>, there exists a partition of Q into disjoint sets Q i , 1 i m, and a partial order on the collection of the Q i 's such that for every q 2 Q i and q 0 2 Q j for which q 0 occurs in ffi (q; )
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proc. 18th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: 1 Introduction Temporal logics, which are modal logics geared towards the description of the temporal or dering of events, have been adopted as a powerful tool for specifying and verifying concurrent programs <ref> [Pnu77, Pnu81] </ref>. One of the most significant developments in this area is the dis covery of algorithmic methods for verifying temporal-logic properties of finite-state programs fl Address: EECS Department, Berkeley CA 94720-1770, U.S.A. Email: orna@eecs.berkeley.edu y Address: Department of Computer Science, Houston, TX 77251-1892, U.S.A.
Reference: [Pnu81] <author> A. Pnueli. </author> <title> The temporal semantics of concurrent programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 45-60, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction Temporal logics, which are modal logics geared towards the description of the temporal or dering of events, have been adopted as a powerful tool for specifying and verifying concurrent programs <ref> [Pnu77, Pnu81] </ref>. One of the most significant developments in this area is the dis covery of algorithmic methods for verifying temporal-logic properties of finite-state programs fl Address: EECS Department, Berkeley CA 94720-1770, U.S.A. Email: orna@eecs.berkeley.edu y Address: Department of Computer Science, Houston, TX 77251-1892, U.S.A.
Reference: [Pnu85] <author> A. Pnueli. </author> <title> In transition from global to modular temporal reasoning about programs. </title> <editor> In K. Apt, editor, </editor> <booktitle> Logics and Models of Concurrent Systems, volume F-13 of NATO Advanced Summer Institutes, </booktitle> <pages> pages 123-144. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Modular verification is advocated also for other methodological reasons; a robust verification method 2 ology should provide rules for deducing properties of programs from the properties of their con-stituent modules. Indeed, efforts to develop modular verification frameworks were undertaken in the mid 1980s <ref> [Pnu85] </ref>. A key observation, see [Lam83, Jon83], is that in modular verification the specification should include two parts. One part describes the desired behavior of the module. The other part describes the assumed behavior of the system within which the module is interacting. <p> The meaning of such a pair is that all the computations of the module are guaranteed to satisfy , assuming that all the computations of the environment satisfy '. As observed in <ref> [Pnu85] </ref>, in this case the assume-guarantee pair h'; i can be combined to a single linear temporal logic formula ' ! .
Reference: [QS81] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Proc. 5th International Symp. on Programming, </booktitle> <volume> volume 137, </volume> <pages> pages 337-351. </pages> <note> Springer-Verlag, Lecture Notes in Computer Science, </note> <year> 1981. </year>
Reference-contexts: One of the most significant developments in this area is the dis covery of algorithmic methods for verifying temporal-logic properties of finite-state programs fl Address: EECS Department, Berkeley CA 94720-1770, U.S.A. Email: orna@eecs.berkeley.edu y Address: Department of Computer Science, Houston, TX 77251-1892, U.S.A. Email: vardi@cs.rice.edu 1 <ref> [CES86, LP85, QS81] </ref>. This derives its significance both from the fact that many synchroniza-tion and communication protocols can be modeled as finite-state programs, as well as from the great ease of use of fully algorithmic methods.
Reference: [RS59] <author> M.O. Rabin and D. Scott. </author> <title> Finite automata and their decision problems. </title> <journal> IBM J. of Research and Development, </journal> <volume> 3 </volume> <pages> 115-125, </pages> <year> 1959. </year>
Reference-contexts: Per Theorem 2.2, we construct a Buchi automaton A ' = h2 AP ; S; ; S 0 ; F i such that L (A ' ) is exactly the set of computations satisfying the formula '. We then apply to A ' the classical subset construction of <ref> [RS59] </ref>, that is, we extend to a mapping from 2 S fi 2 AP to 2 S as follows. (X; a) = ft 2 S : t 2 (s; a) for some s 2 Xg: We now combine the subset transition diagram of A ' with M .
Reference: [Saf89] <author> S. Safra. </author> <title> Complexity of automata on infinite objects. </title> <type> PhD thesis, </type> <institution> Weizmann Institute of Science, Rehovot, Israel, </institution> <year> 1989. </year>
Reference-contexts: By <ref> [Saf89] </ref>, the automaton A 8 (') is of size 2 2 O (j'j) . For a set s sf ('), we say that s is consistent iff the following four conditions hold: 1. For every p 2 AP , if p 2 s, then :p 62 s. 2.
Reference: [Sav70] <author> W.J. Savitch. </author> <title> Relationship between nondeterministic and deterministic tape complexities. </title> <journal> J. on Computer and System Sciences, </journal> <volume> 4 </volume> <pages> 177-192, </pages> <year> 1970. </year>
Reference-contexts: Thus, assuming all values detected by recursion are already assigned, determining whether q 00 is immediately reachable from q 0 can be done in space O (log 2 n). It is known, by [Jon75], that the graph accessibility problem is in NLOGSPACE. Thus, by Savitch's Theorem <ref> [Sav70] </ref>, checking that q 00 is accessible from q 0 can be done deterministically in space O (log 2 n). Now, to check whether q 00 is reachable from q 0 , we restrict the graph accessibility test, replacing immediate accessibility with immediate reachability.
Reference: [SC85] <author> A.P. Sistla and E.M. Clarke. </author> <title> The complexity of propositional linear temporal logic. </title> <journal> J. ACM, </journal> <volume> 32 </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: For a branching temporal logic such as CTL, model-checking algorithms run in time O (nm) [CES86], while, for linear temporal logic such as LTL, model-checking algorithms run in time n2 O (m) [LP85]. Since model checking with respect to a linear temporal logic formula is PSPACE-complete <ref> [SC85] </ref>, the latter bound probably cannot be improved. The difference in the complexity of linear and branching model checking has been viewed as an argument in favor of the branching paradigm. Model checking suffers, however, from the so-called state-explosion problem. <p> To prove the PSPACE lower bound for the implication problem for 8CTL, we prove that the satisfiability problem for 8CTL is PSPACE-hard. The result then follows from Lemma 4.1. We prove hardness in PSPACE by a reduction from LTL satisfiability, proved to be PSPACE-hard in <ref> [SC85] </ref>. Given an LTL formula ~, let ~ A be the 8CTL formula obtained from ~ by preceding each temporal operator with the path quantifier A. For example, if ~ = F Xp then ~ A = AF AXp. <p> Thus, the implication ' ! is valid iff h'iM AP h i. The complexity of the reduction depends on the size of M AP . We show that for both 8CTL and 8CTL ? , the size of M AP is fixed. The PSPACE-hardness proof in <ref> [SC85] </ref> uses temporal formulas with an unbounded number of primitive propositions. By using a Turing machine M that accepts a PSPACE-complete language, it is possible to bound the number of primitive proposition used to the size of the working alphabet of M . <p> in one state by the truth values of a single primitive proposition along log m states, it follows that satisfiability of temporal formulas with a single primitive proposition is also PSPACE-hard. 32 Since the satisfiability problem for LTL is PSPACE-hard already for formulas with a fixed number of atomic propositions <ref> [SC85] </ref>, so does the implication problem for 8CTL. Thus, the size of M AP is fixed. Also, since we took, in the reduction in the proof of Theorem 4.5, a fixed Turing machine, the set of atomic propositions required for defining ~ there is fixed.
Reference: [SZ93] <author> A.P. Sistla and L.D. Zuck. </author> <title> Reasoning in a restricted temporal logic. </title> <journal> Information and Computation, </journal> <volume> 102(2) </volume> <pages> 167-195, </pages> <year> 1993. </year> <month> 44 </month>
Reference-contexts: It will be interesting to find other fragments of LTL (perhaps the fragment studied in <ref> [SZ93] </ref>) for which we can obtain such a complexity bound. We note that it is argued in [LP85] that an exponential time complexity in the size of the specification might be tolerable in practical applications.
Reference: [VS85] <author> M.Y. Vardi and L. Stockmeyer. </author> <title> Improved upper and lower bounds for modal logics of programs. </title> <booktitle> In Proc 17th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 240-251, </pages> <year> 1985. </year>
Reference-contexts: We use here automata-theoretic techniques for CTL ? <ref> [VS85, EJ88] </ref> to construct maximal models for 8CTL ? formulas. While maximal models for 8CTL involve an exponential blow-up, maximal models for 8CTL ? involve a doubly exponential blow-up. The second technique is the automata-theoretic framework to branching-time model checking introduced in [BVW94]. <p> To do this, we should be able to point simultaneously on two (exponentially far) points in the computations. The way to do it, as suggested in <ref> [VS85] </ref>, is by marking one of the two positions with a "pebble", as explained below. Consider the bold computation in the figure below. Each of its nodes branches into a pale suffix.
Reference: [VW86a] <author> M.Y. Vardi and P. Wolper. </author> <title> An automata-theoretic approach to automatic program verification. </title> <booktitle> In Proceedings of the First Symposium on Logic in Computer Science, </booktitle> <pages> pages 322-331, </pages> <address> Cambridge, </address> <month> June </month> <year> 1986. </year>
Reference-contexts: We bring to bear on the problem the automata-theoretic techniques that were developed for linear and branching temporal logics <ref> [VW86a, BVW94] </ref>. The semantics of the assume-guarantee specification is defined in terms of the computation tree of the module.
Reference: [VW86b] <author> M.Y. Vardi and P. Wolper. </author> <title> Automata-theoretic techniques for modal logics of programs. </title> <journal> Journal of Computer and System Science, </journal> <volume> 32(2) </volume> <pages> 182-221, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: We bring to bear on the problem the automata-theoretic techniques that were developed for linear and branching temporal logics [VW86a, BVW94]. The semantics of the assume-guarantee specification is defined in terms of the computation tree of the module. Using the 4 automata-theoretic framework for linear temporal logics <ref> [VW86b] </ref>, we show how the compu-tation tree, which is infinite, can be collapsed to a finite module, while retaining the relevant information from the computation tree. This amounts to annotating the states of the module with information about the linear temporal assumption. <p> We can easily define M 00 (hG; Bi; hG 0 ; B 0 i), as in the product of two Buchi automata, by augmenting each state of W 00 with a Boolean flag <ref> [VW86b] </ref>.
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: According to this view, each module corresponds to a language over the alphabet 2 AP and can be associated with an automaton. A similar connection has been established between LTL formulas and Buchi automata: Theorem 2.2 <ref> [VW94] </ref> Given an LTL formula , there exists a Buchi automaton A = h2 AP ; Q; ffi; Q 0 ; F i, of size 2 O (j j) , such that L (A ) is exactly the set of computations satisfying . 10 2.4 Alternating Tree Automata An infinite tree <p> That is, A 8 (') nondeterministically guesses a location i and a formula A~ and then proceeds as the Buchi !-automaton of :~. By <ref> [VW94] </ref>, such A 8 (') of size 2 O (j'j) exists. Note that though ~ is a path formula of a branching temporal logic, we interpret it here over linear sequences.
Reference: [Wol89] <author> P. Wolper. </author> <title> On the relation of programs and computations to models of temporal logic. </title> <editor> In B. Banieqbal, H. Barringer, and A. Pnueli, editors, </editor> <booktitle> Proc. Temporal Logic in Specification, </booktitle> <volume> volume 398, </volume> <pages> pages 75-123. </pages> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <month> 45 </month>
Reference-contexts: Hence the name model checking for the verification methods derived from this viewpoint. Surveys can be found in <ref> [CG87, Wol89] </ref>. We distinguish between two types of temporal logics: linear and branching [Lam80]. In linear temporal logics, each moment in time has a unique possible future, while in branching temporal logics, each moment in time may split into several possible futures.
References-found: 41

