URL: http://www.cs.toronto.edu/~csc2532h/cut.ps.Z
Refering-URL: http://www.cs.toronto.edu/~csc2532h/
Root-URL: http://www.cs.toronto.edu
Email: Email: @cs.toronto.edu  
Phone: Tel. (416) 978 6277 Fax (416) 978 1455  
Title: A Situation Calculus Semantics for the Prolog Cut Operator  
Author: Fangzhen Lin 
Keyword: Semantics of logic programs. Cut. The situation calculus. Control strategies. Negation as failure.  
Address: Toronto, Canada M5S 1A4  
Affiliation: Department of Computer Science University of Toronto  
Abstract: Given a definite logic program with cut, we proceed in two steps to give it a semantics. First, we delete cut from the program, and construct the basic action theory for the resulting cut-free program in the situation calculus according to (Lin and Reiter [3]). We then formalize the effects of cut by adding to the basic action theory a situation calculus sentence that characterizes the set of situations (derivations) that are not eliminated by cut. We show that our semantics is well-behaved when the logic program is properly stratified. We also show that according to this semantics, the usual implementation of the negation-as-failure operator using cut is prov ably correct. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Gelfond and V. Lifschitz. </author> <title> The stable model semantics for logic programming. </title> <booktitle> In Proc. Fifth International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: For this program, our semantics yields equivalent results as that of the stable model semantics of (Gelfond and Lifschitz <ref> [1] </ref>) for logic programs with negation. Our following theorem shows that this equivalence holds for arbitrary normal programs as well. Let P be a logic program with negation but without cut. Suppose that for each fluent F in P , F 0 is a new fluent of the same arity.
Reference: [2] <author> C. C. Green. </author> <title> Application of theorem proving to problem solving. </title> <booktitle> In Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI-69), </booktitle> <pages> pages 219-239, </pages> <year> 1969. </year>
Reference-contexts: A substitution oe is an answer for G iff D j= (9s)Goe [s], where Goe is the goal resulting from G by simultaneously substituting for its variables according to oe. Therefore query answering in logic programs literally becomes planning in the style of (Green <ref> [2] </ref>) in the situation calculus. This semantics has some nice properties. It is closely related to a recent proposal by Wallace [9], and generalizes the Clark completion semantics. For details, see (Lin and Reiter [3]).
Reference: [3] <author> F. Lin and R. Reiter. </author> <title> Rules as actions: A situation calculus semantics for logic programs. </title> <note> Submitted to this symposium. </note>
Reference-contexts: First, we ignore cut, and delete all occurrences of ! in P . This will give us a program that does not mention !, so a situation calculus action theory D for it can be constructed according to (Lin and Reiter <ref> [3] </ref>). In D, situations are like proofs and derivations. However, due to the presence of !, some situations may not be reachable. A logical characterization of cut is then achieved by adding to D a situation calculus sentence that axiomatizes the set of reachable situations. <p> This paper is organized as follows. Section 2 briefly reviews the basic concepts in the situation calculus and logic programming. Section 3 reviews the situation calculus semantics of (Lin and Reiter <ref> [3] </ref>) for cut-free logic programs. Section 4 considers the semantics of cut. Section 5 proves some properties of our semantics for cut. <p> It is basically a review of that in (Lin and Reiter <ref> [3] </ref>). We mentioned that the first step in our efforts to provide a semantics for cut is to delete it from the underlying program. <p> Therefore query answering in logic programs literally becomes planning in the style of (Green [2]) in the situation calculus. This semantics has some nice properties. It is closely related to a recent proposal by Wallace [9], and generalizes the Clark completion semantics. For details, see (Lin and Reiter <ref> [3] </ref>). <p> A 0 Suppose that for each fluent F , the action A F is ordered before the action A 0 F . Theorem 2 Let E be the extended action theory of P 0 , and D the action theory for P as defined in (Lin and Reiter <ref> [3] </ref>). For fluent F in P , and any tuple ~ t of terms of sort object, we have D j= (9s)F ( ~ t; s) iff E j= (9s):Accessible (s) ^ F ( ~ t; s). <p> From this theorem, we conclude that the usual implementation of negation using cut is correct with respect to the semantics given in (Lin and Reiter <ref> [3] </ref>). As noted in (Lin and Reiter [3]), the semantics given there for logic programs with negation yields the same results as that given in (Wallace [9]). The latter has been shown to be equivalent to the stable model semantics when only Herbrand models are considered. <p> From this theorem, we conclude that the usual implementation of negation using cut is correct with respect to the semantics given in (Lin and Reiter <ref> [3] </ref>). As noted in (Lin and Reiter [3]), the semantics given there for logic programs with negation yields the same results as that given in (Wallace [9]). The latter has been shown to be equivalent to the stable model semantics when only Herbrand models are considered. <p> The recursive nature of the accessibility axiom (12) certainly supports this point of view. On the other hand, in view of Theorem 1, the use of cut can be made safe if we insist on stratified programs. This paper also supports the claims made in (Lin and Reiter <ref> [3] </ref>) that the general framework set out there is useful for formalizing search control operators, and it is worthwhile to go beyond the proposal of Wallace [9], and introduce actions and their axiomatizations in the situation calculus.
Reference: [4] <author> F. Lin and R. Reiter. </author> <title> State constraints revisited. </title> <journal> Journal of Logic and Computation, Special Issue on Actions and Processes, </journal> <volume> 4(5) </volume> <pages> 655-678, </pages> <year> 1994. </year>
Reference-contexts: So technically, there is no real need for this predicate in this paper. We keep it however in order to be consistent with the general framework of (Reiter [7] and Lin and Reiter <ref> [4] </ref>). * A binary predicate (partial order) &lt; over states. Following convention, we write &lt; in infix form. By s &lt; s 0 we mean that s 0 can be obtained from s by a sequence of executable actions. <p> The axioms (4) and (5) define &lt; inductively. Generally, s s 0 if s 0 can be obtained from s by performing some executable actions. However, since we 2 Except for the one about &lt;, these axioms are taken from (Lin and Reiter <ref> [4] </ref>), which also proves some useful properties about them. 3 In this paper, free variables in displayed formulas are assumed to be universally quantified. 4 For a detailed discussion of the use of induction in the situation calculus, see (Reiter [8]). 2 have assumed (8a; s)P oss (a; s), the partial
Reference: [5] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1987. </year>
Reference-contexts: This is because by postulating (8s)![s], occurrences of cut are effectively removed. Example 1 Consider the following well-known example of an efficient encoding of max (x; y; z) (z is the maximum of fx; yg) using ! (Lloyd <ref> [5] </ref>): A 1 (x; y; z): max (x,y,z) :- le (x,y) & ! & z=y. B 1 (x; y): le (x,y) :- x=1 & y=2. B 3 (x; y): le (x,y) :- x=2 & y=2.
Reference: [6] <author> J. McCarthy and P. Hayes. </author> <title> Some philosophical problems from the standpoint of artificial intelligence. </title> <editor> In B. Meltzer and D. Michie, editors, </editor> <booktitle> Machine Intelligence 4, </booktitle> <pages> pages 463-502. </pages> <publisher> Edinburgh University Press, Edinburgh, </publisher> <year> 1969. </year>
Reference-contexts: Section 6 concludes this paper. 2 Logical Preliminaries 2.1 The Language of the Situation Calculus The language L of the situation calculus (McCarthy and Hayes <ref> [6] </ref>) is a many-sorted first-order one with equality. We assume the following sorts: state for situations, action for actions, and object for everything else. <p> We also write &lt; in infix form. By s &lt; s 0 we mean that s can be obtained from s 0 by deleting some of its actions. Similarly, s v s 0 stands for s &lt; s 0 _ s = s 0 . Following <ref> [6] </ref>, we define fluents to be predicate symbols of arity object n fi state, n 0. 2.2 The Discrete Situation Calculus We shall consider only the discrete situation calculus with the following foundational axioms: 2 3 S 0 6= do (a; s); (1) (8P )[P (S 0 ) ^ (8a; s)(P
Reference: [7] <author> R. Reiter. </author> <title> The frame problem in the situation calculus: a simple solution (sometimes) and a completeness result for goal regression. </title> <editor> In V. Lifschitz, editor, </editor> <booktitle> Artificial Intelligence and Mathematical Theory of Computation: Papers in Honor of John McCarthy, </booktitle> <pages> pages 418-420. </pages> <publisher> Academic Press, </publisher> <address> San Diego, CA, </address> <year> 1991. </year>
Reference-contexts: In this paper we shall assume that actions are always executable, i.e. (8a; s)P oss (a; s). So technically, there is no real need for this predicate in this paper. We keep it however in order to be consistent with the general framework of (Reiter <ref> [7] </ref> and Lin and Reiter [4]). * A binary predicate (partial order) &lt; over states. Following convention, we write &lt; in infix form. By s &lt; s 0 we mean that s 0 can be obtained from s by a sequence of executable actions. <p> We then have the following successor state axiom (Reiter <ref> [7] </ref>) for F : F (~x; do (a; s)) j fa = A 1 (~x) ^ (9 ~y 1 )G 1 [s] _ _ Notice the similarity between this axiom and Clark's completion of the predicate F in P .
Reference: [8] <author> R. Reiter. </author> <title> Proving properties of states in the situation calculus. </title> <journal> Artificial Intelligence, </journal> <volume> 64 </volume> <pages> 337-351, </pages> <year> 1993. </year>
Reference-contexts: about &lt;, these axioms are taken from (Lin and Reiter [4]), which also proves some useful properties about them. 3 In this paper, free variables in displayed formulas are assumed to be universally quantified. 4 For a detailed discussion of the use of induction in the situation calculus, see (Reiter <ref> [8] </ref>). 2 have assumed (8a; s)P oss (a; s), the partial order &lt; in this paper reduces to the "prefix" relation: Given a state S = do (ff n ; do (ff n1 ; :::; do (ff 1 ; S 0 ):::)), S 0 S iff there is a 1 k
Reference: [9] <author> M. G. Wallace. </author> <title> Tight, consistent, and computable completions for unrestricted logic programs. </title> <journal> Journal of Logic Programming, </journal> <volume> 15 </volume> <pages> 243-273, </pages> <year> 1993. </year> <month> 15 </month>
Reference-contexts: Therefore query answering in logic programs literally becomes planning in the style of (Green [2]) in the situation calculus. This semantics has some nice properties. It is closely related to a recent proposal by Wallace <ref> [9] </ref>, and generalizes the Clark completion semantics. For details, see (Lin and Reiter [3]). <p> As noted in (Lin and Reiter [3]), the semantics given there for logic programs with negation yields the same results as that given in (Wallace <ref> [9] </ref>). The latter has been shown to be equivalent to the stable model semantics when only Herbrand models are considered. <p> This paper also supports the claims made in (Lin and Reiter [3]) that the general framework set out there is useful for formalizing search control operators, and it is worthwhile to go beyond the proposal of Wallace <ref> [9] </ref>, and introduce actions and their axiomatizations in the situation calculus.
References-found: 9

