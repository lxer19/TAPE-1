URL: http://www.research.digital.com/SRC/personal/Rustan_Leino/papers/krml65.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Rustan_Leino/home.html
Root-URL: http://www.research.digital.com
Email: rustan@pa.dec.com  
Title: Ecstatic: An object-oriented programming language with an axiomatic semantics  
Author: K. Rustan M. Leino 
Address: 130 Lytton Ave., Palo Alto, CA 94301, U.S.A.  
Affiliation: Digital Equipment Corporation Systems Research Center  
Date: 16 December 1996  
Note: KRML 65 -0  
Abstract: This paper appears in the Proceedings of the 4th International Workshop on Foundations of Object-Oriented Languages, January 1997. Republished here by permission. Abstract. This paper describes a small object-oriented programming language and its axiomatic semantics. The language includes common object-oriented features like methods and subtyping. Objects are implicitly references, and the semantics handles the aliasing that arises. The paper formalizes in first-order logic what it means for a method implementation to meet its specification. 
Abstract-found: 1
Intro-found: 1
Reference: [0] <institution> Extended Static Checking home page, Digital Equipment Corporation, Systems Research Center. </institution> <note> On the Web at http://www.research.digital.com/ SRC/esc/Esc.html. </note>
Reference-contexts: The Ecstatic language grew from work on the Modula-3 Extended Static Checker (ESC), a static analysis tool for detecting errors like nil -dereferencing, array index out-of-bounds errors, deadlocks, and race conditions <ref> [0, 3] </ref>. ESC translates Modula-3 annotated with specifications into verification conditions that are then passed to a mechanical theorem prover called Simplify [0]. Ecstatic's prescription of verification conditions is similar to that used by ESC. <p> ESC translates Modula-3 annotated with specifications into verification conditions that are then passed to a mechanical theorem prover called Simplify <ref> [0] </ref>. Ecstatic's prescription of verification conditions is similar to that used by ESC. In fact, I have written a checker for Ecstatic that parses and type-checks Ecstatic programs, generates the verification conditions, and passes them to Simplify. <p> an endeavor includes allowing the declaration of abstract data fields that are functions KRML 65 -40 of concrete ones, and appropriately rewriting the abstract fields that occur in pre- and postconditions and modifies list. (To get an idea of how this is done in ESC, see the ESC home page <ref> [0] </ref> or my thesis [10].) Once that is done, the semantics of the language remains unchanged. 6 Summary and conclusion I have described a simple language for writing object-oriented programs. The language uses four kinds of declarations: types, data fields, methods specifications, and method implementations.
Reference: [1] <author> Martjn Abadi and K. Rustan M. Leino. </author> <title> A logic of object-oriented programs. </title> <note> To appear in the proceedings of TAPSOFT/FASE'97, </note> <year> 1997. </year>
Reference-contexts: However, that semantics also KRML 65 -1 assumes the absence of aliasing. My thesis shows how to translate features of object-oriented languages into Dijkstra's guarded commands, for which weakest preconditions are defined [10]. Abadi and I have written a Hoare-like logic for object-oriented programs <ref> [1] </ref>. The logic handles methods, subtyping, and aliasing, but excludes recursive data types. The Ecstatic language allows recursive data structures.
Reference: [2] <author> Lance Berc. Re: Angles and angels. </author> <note> Posting to src.writing by berc@ pa.dec.com, 13 April 1995, </note> <institution> 23:33:48 -0700, Digital Equipment Corporation Systems Research Center. </institution>
Reference-contexts: Acknowledgements I'm grateful to Dave Detlefs, Allan Heydon, Greg Nelson, Jim Saxe, Raymie Stata, and Mark Vandevoorde for valuable comments on different versions of this paper. The name of the language was inspired by a news group posting by Lance Berc <ref> [2] </ref>. KRML 65 -41
Reference: [3] <author> David L. Detlefs. </author> <title> An overview of the Extended Static Checking system. </title> <booktitle> In Proceedings of The First Workshop on Formal Methods in Software Practice, pages 19. ACM SIGSOFT, </booktitle> <month> January </month> <year> 1996. </year>
Reference-contexts: The Ecstatic language grew from work on the Modula-3 Extended Static Checker (ESC), a static analysis tool for detecting errors like nil -dereferencing, array index out-of-bounds errors, deadlocks, and race conditions <ref> [0, 3] </ref>. ESC translates Modula-3 annotated with specifications into verification conditions that are then passed to a mechanical theorem prover called Simplify [0]. Ecstatic's prescription of verification conditions is similar to that used by ESC.
Reference: [4] <author> Edsger W. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1976. </year>
Reference-contexts: Examples of axiomatic semantics for imperative languages are Hoare logic [5] and Dijkstra's weakest-precondition calculus <ref> [4] </ref>, both of which have achieved considerable success in the last decades. Reasoning using an axiomatic semantics is done at a higher level than with an operational semantics. For example, reasoning about a method invocation is done by reasoning about the method's specification rather than by examining its implementations. <p> variable) x to something like x :53 :6 where 53 and 6 are the line and column in the program text at which x is declared. (See Section 4.4 for an example.) 3.0 Verification conditions The formal meaning of commands is based on Dijkstra's weakest liberal preconditions ( wlp ) <ref> [4] </ref>. <p> This section describes in detail how a verification condition is generated from the program text. In principle, the formula P ) wlp:S :R expresses that a command S meets a specification whose precondition is P and whose postcondition is R <ref> [4] </ref>. However, this ignores an important part of a method specification, the modifies list, which together with the postcondition prescribe the method's effect. To account for the modifies list, it is rewritten into a so-called postcondition contribution, which constrains modifications of fields according to the modifies list.
Reference: [5] <author> C. A. R. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10):576580,583, </volume> <month> October </month> <year> 1969. </year>
Reference-contexts: The paper formalizes in first-order logic what it means for a method implementation to meet its specification. 0 Introduction In the cornucopia of object-oriented programming languages, one is hard-pressed to find a language with an axiomatic semantics. Examples of axiomatic semantics for imperative languages are Hoare logic <ref> [5] </ref> and Dijkstra's weakest-precondition calculus [4], both of which have achieved considerable success in the last decades. Reasoning using an axiomatic semantics is done at a higher level than with an operational semantics.
Reference: [6] <author> Kevin Lano and Howard Haughton. </author> <title> Object-Oriented Specification Case Studies. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1994. </year>
Reference-contexts: The logic handles methods, subtyping, and aliasing, but excludes recursive data types. The Ecstatic language allows recursive data structures. The present work distinguishes itself from object-oriented specification languages like Larch/C++ [7] and those surveyed by Lano and Haughton <ref> [6] </ref> in that the semantics of Ecstatic is explicit about the connection between method specifications and implementations: the semantics precisely prescribes a verification condition, an untyped first-order predicate that formally expresses the implementation meets its specification.
Reference: [7] <author> Gary T. Leavens. </author> <title> Larch/C++ reference manual, draft, $Revision: </title> <address> 4.16$, </address> <month> 16 July </month> <year> 1996. </year> <note> On the Web at http://www.cs.iastate.edu/leavens/ larchc++manual/lcpp toc.html, </note> <year> 1996. </year>
Reference-contexts: Abadi and I have written a Hoare-like logic for object-oriented programs [1]. The logic handles methods, subtyping, and aliasing, but excludes recursive data types. The Ecstatic language allows recursive data structures. The present work distinguishes itself from object-oriented specification languages like Larch/C++ <ref> [7] </ref> and those surveyed by Lano and Haughton [6] in that the semantics of Ecstatic is explicit about the connection between method specifications and implementations: the semantics precisely prescribes a verification condition, an untyped first-order predicate that formally expresses the implementation meets its specification.
Reference: [8] <author> Gary Todd Leavens. </author> <title> Verifying Object-Oriented Programs that Use Subtypes. </title> <type> PhD thesis, </type> <institution> MIT Laboratory for Computer Science, </institution> <month> February </month> <year> 1989. </year> <note> Available as Technical Report MIT/LCS/TR-439. </note>
Reference-contexts: Objects are references to data fields and methods, and the semantics handles the aliasing among these references. Some efforts have been directed at providing an axiomatic semantics for an object-oriented language. In his thesis, Leavens gave verification rules for a small language with objects <ref> [8] </ref>. However, those rules apply only to programs without aliasing. Nau-mann has given a predicate-transformer semantics for a programming language that includes record extension and procedure type variables [12]. However, that semantics also KRML 65 -1 assumes the absence of aliasing.
Reference: [9] <author> K. Rustan M. Leino. </author> <title> Modeling subtypes with only one object type. </title> <type> KRML 55, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: To do so, the logical theory underlying the data type may need to be included. A very useful data type is (open) arrays, which can be added to the language as described in KRML 55 <ref> [9] </ref>. A useful shorthand that can easily be defined is a block statement where variables list their initial values.
Reference: [10] <author> K. Rustan M. Leino. </author> <title> Toward Reliable Modular Programs. </title> <type> PhD thesis, </type> <institution> California Institute of Technology, </institution> <year> 1995. </year> <note> Available as Technical Report Caltech-CS-TR-95-03. KRML 65 -42 </note>
Reference-contexts: However, that semantics also KRML 65 -1 assumes the absence of aliasing. My thesis shows how to translate features of object-oriented languages into Dijkstra's guarded commands, for which weakest preconditions are defined <ref> [10] </ref>. Abadi and I have written a Hoare-like logic for object-oriented programs [1]. The logic handles methods, subtyping, and aliasing, but excludes recursive data types. The Ecstatic language allows recursive data structures. <p> This wlp is like Dijkstra's, except that it forbids run-time errors <ref> [10] </ref>. The proof obligation for a method implementation is that it meet its specification. <p> However, the big problem is that it seems desirable to let a subtype enlarge the modifies list of a method, so that the subtype can modify the additional fields it introduces. This problem can be solved by data abstraction and abstractional dependencies <ref> [10] </ref>, which can be layered on top of Ecstatic. <p> the declaration of abstract data fields that are functions KRML 65 -40 of concrete ones, and appropriately rewriting the abstract fields that occur in pre- and postconditions and modifies list. (To get an idea of how this is done in ESC, see the ESC home page [0] or my thesis <ref> [10] </ref>.) Once that is done, the semantics of the language remains unchanged. 6 Summary and conclusion I have described a simple language for writing object-oriented programs. The language uses four kinds of declarations: types, data fields, methods specifications, and method implementations.
Reference: [11] <author> B.H. Liskov and J.M. Wing. </author> <title> A behavioral notion of subtyping. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6):18111841, </volume> <month> November </month> <year> 1994. </year>
Reference-contexts: Also, compared to many common notions of subtyping (see, for example, Liskov and Wing <ref> [11] </ref>), subtyping in Ecstatic is very simple: it is simply an ordering among the names of types. More importantly, the present language is given a precise axiomatic semantics.
Reference: [12] <author> David A. Naumann. </author> <title> Predicate transformer semantics of an Oberon-like language. </title> <editor> In E.-R. Olderog, editor, </editor> <booktitle> Proceedings of the IFIP WG2.1/WG2.2/WG2.3 Working Conference on Programming Concepts, Methods, and Calculi, </booktitle> <address> San Miniato, Italy, </address> <month> 610 June </month> <year> 1994, </year> <pages> pages 467487. </pages> <publisher> Elsevier, </publisher> <year> 1994. </year>
Reference-contexts: In his thesis, Leavens gave verification rules for a small language with objects [8]. However, those rules apply only to programs without aliasing. Nau-mann has given a predicate-transformer semantics for a programming language that includes record extension and procedure type variables <ref> [12] </ref>. However, that semantics also KRML 65 -1 assumes the absence of aliasing. My thesis shows how to translate features of object-oriented languages into Dijkstra's guarded commands, for which weakest preconditions are defined [10]. Abadi and I have written a Hoare-like logic for object-oriented programs [1].
Reference: [13] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. Series in Innovative Technology. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: The organization of this paper is as follows. Section 1 on declarations describes the major building blocks of the language; Section 2 on commands and expressions describes the smaller building blocks of the language. These sections provide a language definition roughly at the level of the Modula-3 definition <ref> [13] </ref>: it defines syntax, type-checking, and an operational description that includes checked run-time errors. Section 3 gives the axiomatic semantics of the language, and prescribes how verification conditions are generated.
References-found: 14

