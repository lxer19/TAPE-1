URL: http://www.research.digital.com/SRC/personal/monika/papers/monika-icalp95.ps.gz
Refering-URL: http://www.research.digital.com/SRC/personal/monika/papers.html
Root-URL: http://www.research.digital.com
Title: A Static 2-Approximation Algorithm for Vertex Connectivity and Imcremental Approximation Algorithms for Edge and Vertex
Author: Monika Rauch Henzinger p 
Note: n; This  
Address: Center,130 Lytton Avenue Palo Alto, CA 94301  
Affiliation: Digital Systems Research  
Abstract: This paper presents insertions-only algorithms for maintaining the exact and/or approximate size of the minimum edge cut and the minimum vertex cut of a graph. The algorithms output the approximate or exact size k in time O(1) and a cut of size k in time linear in its size. For the minimum edge cut problem and for any 0 &lt; * 1, the amortized time per insertion is O(1=* 2 ) for a (2 + *)-approximation, O((log )((log n)=*) 2 ) for a (1 + *)-approximation, and O( log n) for the exact size, where n is the number of nodes in the graph and is the size of the minimum cut. The (2 + *)-approximation algorithm and the exact algorithm are deterministic, the (1 + *)-approximation algorithm is randomized. We also present a static 2-approximation algorithm for the size of the minimum vertex cut in a graph, which takes time O(n 2 min( p n; )). We give an insertions-only algorithm for maintaining a (2 + *)-approximation of the minimum vertex cut with amortized insertion time O(n=*). 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> J. Cheriyan, M. Y. Kao, and R. Thurimella, </author> <title> "Scan-first search and sparse certificates|an improved parallel algorithm for k-vertex connectivity", </title> <journal> SIAM Journal on Computing, </journal> <volume> 22, </volume> <year> 1993, </year> <pages> 157-174. </pages>
Reference-contexts: 1 Introduction Computing the connectivity of a graph is a fundamental problem that has achieved a lot of attention (see for example <ref> [1, 2, 6, 8, 9, 10, 11, 15, 16, 18, 20] </ref>). In this paper we study the problem of maintaining the connectivity of the graph during modifications of the graph. Let G = (V; E) be an undirected, unweighted multigraph.
Reference: 2. <author> E. A. Dinic, A. V. Karzanov, </author> <title> and M.V. Lomonosov, "A structure of the system of all minimal cuts of a graph", in: Studies in Discrete Optimization, </title> <editor> A. A. Fridman ed., </editor> <publisher> "Nauka", </publisher> <address> Moscow, </address> <year> 1976, </year> <note> 290-306 (in Russian). </note>
Reference-contexts: 1 Introduction Computing the connectivity of a graph is a fundamental problem that has achieved a lot of attention (see for example <ref> [1, 2, 6, 8, 9, 10, 11, 15, 16, 18, 20] </ref>). In this paper we study the problem of maintaining the connectivity of the graph during modifications of the graph. Let G = (V; E) be an undirected, unweighted multigraph. <p> If an insertion increments the size of one of these cuts, it is no longer minimum. Thus, the current solution is correct as long as there still exists a minimum cut whose size has not been increased. To store all minimum edge cuts we use the cactus tree representation <ref> [2] </ref>.
Reference: 3. <author> Ye. Dinitz, Z. Nutov, </author> <title> "A 2-level cactus model for the system of minimum and minimum+1 edge-cuts in a graph and its incremental maintenance", </title> <note> to appear in Proc. 27nd Symp. on Theory of Computing, </note> <year> 1995. </year>
Reference-contexts: Our algorithms achieve exponential improvements. He also gives a fully dynamic algorithm that maintains a p 1 + 2=*-approximation algorithm in ~ O (n 1=2+* ) time per edge insertions and deletions. (4) Recently, Dinitz and Nutov <ref> [3] </ref> gave an algorithm that maintains all cuts of size or + 1.
Reference: 4. <author> Ye. Dinitz and J. Westbrook, </author> <title> "Maintaining the Classes 4-Edge-Connectivity of a Graph On-Line", </title> <type> Technical Report # 871, </type> <institution> Dep. of Comp. Sci., Techmion, </institution> <year> 1995, </year> <month> 47p. </month>
Reference-contexts: This technique was introduced by Karger [16] in his static algorithm, which needs time O (m + n ((log n)=*) 3 ) to compute a (1 + *)- approximation of . Related results: (1) For any fixed k, Dinitz and Westbrook <ref> [4] </ref> give an algorithm that supports Same-k-Component? queries and edge insertions in a (k-1)-edge-connected graph. <p> This idea was developped independently also by Dinitz and Westbrook <ref> [4] </ref>. The algorithm is given below. We denote by G 0 = (V 0 ; E 0 ) with n 0 = jV 0 j and m 0 = jE 0 j the graph resulting from the contractions. <p> If is even, two simple cycles of G c have at most one common node, every edge that does not belong to a cycle has weight , and every edge that belongs to a cycle has weight =2. As observed by Dinitz and Westbrook <ref> [4] </ref>, given a cactus-tree the data structure of [12, 17] can maintain the cactus tree for a fixed value of such that the total time for u insertions is O (u + n). Determining if there exists a minimum cut whose size has not been increased takes constant time.
Reference: 5. <author> D. Eppstein, Z. Galil, G. F. Italiano, A. Nissenzweig, </author> <title> "Sparsification ATechnique for Speeding up Dynamic Graph Algorithms" Proc. </title> <booktitle> 33rd Symp. on Foundations of Computer Science, </booktitle> <year> 1992, </year> <pages> 60-69. </pages>
Reference-contexts: It takes time O (q + n) with a preprocessing time of O (m 0 + k 2 n log (n=k)), where q is the total number of operations. (2) For any fixed k, Eppstein et. al <ref> [5] </ref> give a fully dynamic algorithm that tests if the whole graph is k-edge-connected in O (1) time.
Reference: 6. <author> S. </author> <title> Even, "An algorithm for determining whether the connectivity of a graph is at least k" SIAM Journal on Computing, </title> <type> 4, </type> <year> 1975, </year> <pages> 393-396. 23 </pages>
Reference-contexts: 1 Introduction Computing the connectivity of a graph is a fundamental problem that has achieved a lot of attention (see for example <ref> [1, 2, 6, 8, 9, 10, 11, 15, 16, 18, 20] </ref>). In this paper we study the problem of maintaining the connectivity of the graph during modifications of the graph. Let G = (V; E) be an undirected, unweighted multigraph.
Reference: 7. <author> S. Even, G. Itkis, S. Rajsbaum. </author> <title> "On mixed connectivity certificates", </title> <booktitle> Algorithms - ESA'95, Proc. 3rd European Symp., </booktitle> <publisher> Springer-Verlag, LNCS 979, </publisher> <year> 1995, </year> <pages> 1-16. </pages>
Reference-contexts: We want to prove Lemma 13 and 14. We first present DA and show two properties of DA. Using a further lemma of [20], we then prove Lemma 13. The proof of Lemma 14 follows. Lemma 14 and Lemma 23 has been shown independently in <ref> [7] </ref>. In DA, whenever a node is added to a forest F i , the edge is also given an direction. The Decomposition Algorithm [20] 1.
Reference: 8. <author> S. Even and R. E. Tarjan, </author> <title> "Network flow and testing graph connectivity", </title> <journal> SIAM Journal on Computing, </journal> <volume> 4, </volume> <year> 1975, </year> <pages> 507-518. </pages>
Reference-contexts: 1 Introduction Computing the connectivity of a graph is a fundamental problem that has achieved a lot of attention (see for example <ref> [1, 2, 6, 8, 9, 10, 11, 15, 16, 18, 20] </ref>). In this paper we study the problem of maintaining the connectivity of the graph during modifications of the graph. Let G = (V; E) be an undirected, unweighted multigraph. <p> Our algorithm uses ideas from [18]. Even and Tarjan <ref> [8] </ref> give an algorithm to compute the minimum vertex cut (a; b) between the nodes a and b in time c (min (m p n; m)) for some constant c, which we call the pair algorithm (PA (a,b)).
Reference: 9. <author> H. N. Gabow, </author> <title> "A matroid approach to finding edge connectivity and packing ar-borescences" Proc. </title> <booktitle> 23rd Symp. on Theory of Computing, </booktitle> <year> 1991, </year> <pages> 112-122. </pages>
Reference-contexts: 1 Introduction Computing the connectivity of a graph is a fundamental problem that has achieved a lot of attention (see for example <ref> [1, 2, 6, 8, 9, 10, 11, 15, 16, 18, 20] </ref>). In this paper we study the problem of maintaining the connectivity of the graph during modifications of the graph. Let G = (V; E) be an undirected, unweighted multigraph. <p> Any incremental algorithm with amortized time t (n; m) = o ( log (n=)) per insertion leads to a static minimum cut algorithm with time O (m+nt (n; m)), which would improve the current best deterministic bound of O (m + 2 n log (n=)) <ref> [9] </ref>: The static algorithm is created from the incremental algorithm by (1) computing a 3-approximation of the minimum edge cut, (2) computing a subgraph of the graph with the same minimum cut but at most 3n edge, and (3) adding all edges of this subgraph to an initially empty graph. <p> It is an incremental version of Matula's static (2 + *)-approximation algorithm [18], which takes time O (m=*). If the initial graph is empty, our amortized time per operation is O (1=* 2 ). The second algorithm is an incremental version of Gabow's (exact) minimum edge cut algorithm <ref> [9] </ref>, which computes the size of the minimum edge cut in time O (m + 2 n log (n 2 =(m + 1))) = O (m + 2 n log (n=( + 1))). <p> A Fully Dynamic Algorithm Updating I () after an edge deletion requires the recomputation of one subgraph (to be precise, one spanning tree) of the complete intersection and takes time O (m log (n=)) <ref> [9] </ref>. To obtain an insertions and deletions algorithm, we execute Step 3 (except for incrementing ) after each deletion. Theorem 9. Let G be a multigraph with n nodes that is initially without edges.
Reference: 10. <author> H. N. Gabow, </author> <title> "Applications of a poset representation to edge connectivity and graph rigidity" Proc. </title> <booktitle> 32nd Symp. on Foundations of Computer Science, </booktitle> <year> 1991, </year> <pages> 812-821. </pages>
Reference-contexts: 1 Introduction Computing the connectivity of a graph is a fundamental problem that has achieved a lot of attention (see for example <ref> [1, 2, 6, 8, 9, 10, 11, 15, 16, 18, 20] </ref>). In this paper we study the problem of maintaining the connectivity of the graph during modifications of the graph. Let G = (V; E) be an undirected, unweighted multigraph. <p> Determining if there exists a minimum cut whose size has not been increased takes constant time. To quickly compute the cactus tree representation of a multigraph we use an algorithm by Gabow <ref> [10] </ref>. The algorithm computes first a subgraph of G, called a complete -intersection or I (), with at most n edges, and uses the complete -intersection to compute the cactus tree.
Reference: 11. <author> Z. Galil, </author> <title> "Finding the vertex connectivity of graphs", </title> <journal> SIAM Journal on Computing, </journal> <year> 1980, </year> <pages> 197-199. </pages>
Reference-contexts: 1 Introduction Computing the connectivity of a graph is a fundamental problem that has achieved a lot of attention (see for example <ref> [1, 2, 6, 8, 9, 10, 11, 15, 16, 18, 20] </ref>). In this paper we study the problem of maintaining the connectivity of the graph during modifications of the graph. Let G = (V; E) be an undirected, unweighted multigraph. <p> Even and Tarjan [8] give an algorithm to compute the minimum vertex cut (a; b) between the nodes a and b in time c (min (m p n; m)) for some constant c, which we call the pair algorithm (PA (a,b)). The exact minimum vertex cut algorithm <ref> [11] </ref> makes O ( 2 + n) calls to PA. Let ffi 2 be bffi=2c. The basic approach of our algorithm is to reduce the number of calls to PA to dn=ffi 2 e using the following two observations: 1.
Reference: 12. <author> Z. Galil and G. P. </author> <title> Italiano, "Maintaining the 3-edge-connected components of a graph on-line", </title> <journal> SIAM Journal on Computing, </journal> <year> 1993, </year> <pages> 11-28. </pages>
Reference-contexts: If is a constant, our running time is close to the running time of the best "special purpose" algorithms: Determining if two nodes are connected, 2-edge-connected, or 3-edge-connected takes amortized time O (ff (m; n)) per insertion or query <ref> [22, 12, 17] </ref>. Gabow's algorithm implies a fully dynamic algorithm which allows insertions and deletions of edges in worst-case time O (m log (n=)). <p> As observed by Dinitz and Westbrook [4], given a cactus-tree the data structure of <ref> [12, 17] </ref> can maintain the cactus tree for a fixed value of such that the total time for u insertions is O (u + n). Determining if there exists a minimum cut whose size has not been increased takes constant time.
Reference: 13. <author> A. Ya. Gordon, </author> <title> "One algorithm for the solution of the minimax assignment problem", Studies in Discrete Optimization, </title> <editor> A. A. Fridman (Ed.), </editor> <publisher> Nauka, </publisher> <address> Moscow, </address> <year> 1976, </year> <note> 327-333 (in Russian). </note>
Reference-contexts: For each b j we incremently maintain the maximum flow from a to b j by augmenting the breadth-first search tree. Thus, for any j the total time spent for incrementing the maximum flow from a to b j by 1 is O (m + n) (see also <ref> [13] </ref>). The algorithm recomputes every new solution from scratch. We denote by ffi the minimum degree in the current graph, and by ffi 0 the minimum degree in the graph during the last recomputation.
Reference: 14. <author> F. Harary, </author> <title> "Graph Theory", </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1969. </year>
Reference-contexts: We contract a forest F if we contract all edges of G that are in F . We use the following fact repeatedly: If a graph is k-edge connected, it contains (kn) edges: Lemma 1. <ref> [14] </ref> If a n-node (multi)graph is k-edge connected, then it contains at least kn=2 edges. 4 Incremental Algorithms for the Minimum Edge Cut 4.1 An Incremental (2 + *)-Approximation Using the generic algorithm of Section 2 we create an incremental algorithm that maintains a (2 + *)-approximation of the minimum cut.
Reference: 15. <author> D. Karger, </author> <title> "Using randomized sparsification to approximate minimum cuts" Proc. </title> <booktitle> 5th Symp. on Discrete Algorithms, </booktitle> <year> 1994, </year> <pages> 424-432. </pages>
Reference-contexts: 1 Introduction Computing the connectivity of a graph is a fundamental problem that has achieved a lot of attention (see for example <ref> [1, 2, 6, 8, 9, 10, 11, 15, 16, 18, 20] </ref>). In this paper we study the problem of maintaining the connectivity of the graph during modifications of the graph. Let G = (V; E) be an undirected, unweighted multigraph. <p> The times per edge insertion or deletion is O (k 2 n log (n=k)). (3) Karger <ref> [15] </ref> gives a randomized algorithm, which maintains a p 1 + 2=*-approximation of the minimum edge cut in expected time ~ O (n * ) per insertion. <p> Karger <ref> [15] </ref> pointed out that dynamically approximating connectivity can be reduced to dynamically maintaining exact connectivity in O (log n)-connected graph using randomized sparsification. <p> We build G (p) incrementally by sampling each edge with probability p when it is inserted. The following lemma shows that the resulting incremental algorithm maintains a (1 + *)-approximation of the minimum cut with high probability. Lemma 10. <ref> [15] </ref> Let G be any graph with minimum cut and let p = 2 (d + 2)(ln n)=(* 2 ) for any * 1. 1. With probability 1O (1=n d ) the size of the minimum cut in G (p) is fi ((log n)=* 2 ). 2.
Reference: 16. <author> D. Karger, </author> <title> "Random sampling in cut, flow, and network design problems", </title> <booktitle> Proc. 26rd Symp. on Theory of Computing, </booktitle> <year> 1994, </year> <pages> 648-657. </pages>
Reference-contexts: 1 Introduction Computing the connectivity of a graph is a fundamental problem that has achieved a lot of attention (see for example <ref> [1, 2, 6, 8, 9, 10, 11, 15, 16, 18, 20] </ref>). In this paper we study the problem of maintaining the connectivity of the graph during modifications of the graph. Let G = (V; E) be an undirected, unweighted multigraph. <p> Thus, if the initial graph is empty, the amortized expected time per insertion is O (log 2 n (log )=* 2 ). This technique was introduced by Karger <ref> [16] </ref> in his static algorithm, which needs time O (m + n ((log n)=*) 3 ) to compute a (1 + *)- approximation of . Related results: (1) For any fixed k, Dinitz and Westbrook [4] give an algorithm that supports Same-k-Component? queries and edge insertions in a (k-1)-edge-connected graph.
Reference: 17. <author> H. La Poutre, </author> <title> "Maintenance of 2- and 3-connected components of graphs, Part II: 2- and 3-edge-connected components and 2-vertex-connected components", </title> <institution> Tech.Rep. RUU-CS-90-27, Utrecht University, </institution> <year> 1990. </year>
Reference-contexts: If is a constant, our running time is close to the running time of the best "special purpose" algorithms: Determining if two nodes are connected, 2-edge-connected, or 3-edge-connected takes amortized time O (ff (m; n)) per insertion or query <ref> [22, 12, 17] </ref>. Gabow's algorithm implies a fully dynamic algorithm which allows insertions and deletions of edges in worst-case time O (m log (n=)). <p> As observed by Dinitz and Westbrook [4], given a cactus-tree the data structure of <ref> [12, 17] </ref> can maintain the cactus tree for a fixed value of such that the total time for u insertions is O (u + n). Determining if there exists a minimum cut whose size has not been increased takes constant time.
Reference: 18. <author> D. W. Matula, </author> <title> "A linear time 2+* approximation algorithm for edge connectivity" Proc. </title> <booktitle> 4th Symp. on Discrete Algorithms, </booktitle> <year> 1993, </year> <pages> 500-504. </pages>
Reference-contexts: 1 Introduction Computing the connectivity of a graph is a fundamental problem that has achieved a lot of attention (see for example <ref> [1, 2, 6, 8, 9, 10, 11, 15, 16, 18, 20] </ref>). In this paper we study the problem of maintaining the connectivity of the graph during modifications of the graph. Let G = (V; E) be an undirected, unweighted multigraph. <p> Step (1) takes time O (m) using Matula's 3-approximation <ref> [18] </ref>, Step (2) takes time O (m + n) using the algorithm of Nagamochi and Ibaraki [20], and Step (3) takes time O (nt (n; m)) using the incremental algorithm. Minimum Edge Cuts. <p> The first algorithm maintains a (2 + *)-approximation of in total time O ((m 0 + n)=* + m 1 =* 2 ) for any 1 * &gt; 0. It is an incremental version of Matula's static (2 + *)-approximation algorithm <ref> [18] </ref>, which takes time O (m=*). If the initial graph is empty, our amortized time per operation is O (1=* 2 ). <p> Our algorithm uses ideas from <ref> [18] </ref>. Even and Tarjan [8] give an algorithm to compute the minimum vertex cut (a; b) between the nodes a and b in time c (min (m p n; m)) for some constant c, which we call the pair algorithm (PA (a,b)).
Reference: 19. <author> K. Menger, "Zur allgemeinen Kurventheorie", </author> <title> Fund. </title> <journal> Math. </journal> <volume> 10, </volume> <year> 1927, </year> <pages> 96-115. </pages>
Reference-contexts: An edge cut C separates x and y if x and y belong to different connected components of G n C. A minimum edge cut is a cut of minimum size. By Menger's theorem <ref> [19] </ref>, (a) ? Maiden Name: Monika H. Rauch. This research was supported by an NSF CAREER Award. the size of the minimum edge cut is (G), and (b) the size of the minimum edge cut separating x and y is (G; x; y). <p> A vertex cut C separates x and y if x and y belong to different connected components of GnC. A minimum vertex cut is a vertex cut of minimum size. By Menger's theorem <ref> [19] </ref>, (a) the size of the minimum vertex cut is (G) if (G) &lt; jV j 1, and (b) the size of the minimum vertex cut separating two nonadjacent vertices x and y is (G; x; y). Note that k-vertex connectivity implies k-edge connectivity, but not vice versa.
Reference: 20. <author> H. Nagamochi and T. Ibaraki, </author> <title> "Linear time algorithms for finding a sparse k-connected spanning subgraph of a k-connected graph", </title> <type> Algorithmica 7, </type> <year> 1992, </year> <pages> 583-596. </pages>
Reference-contexts: 1 Introduction Computing the connectivity of a graph is a fundamental problem that has achieved a lot of attention (see for example <ref> [1, 2, 6, 8, 9, 10, 11, 15, 16, 18, 20] </ref>). In this paper we study the problem of maintaining the connectivity of the graph during modifications of the graph. Let G = (V; E) be an undirected, unweighted multigraph. <p> Step (1) takes time O (m) using Matula's 3-approximation [18], Step (2) takes time O (m + n) using the algorithm of Nagamochi and Ibaraki <ref> [20] </ref>, and Step (3) takes time O (nt (n; m)) using the incremental algorithm. Minimum Edge Cuts. We give incremental algorithms that maintain the exact size, (1 + *)-, or (2 + *)-approximate size of the minimum edge cut. <p> If two nodes are connected in F i , they are i-edge connected. Nagamochi and Ibaraki <ref> [20] </ref> give a linear time algorithm (referred to as decomposition algorithm (DA)) that computes a special msfd, called DA-msfd, of order m in time O (m + n). A DA-msfd fulfills the following additional conditions [20]: If G is a graph then, (1) G is k-vertex connected iff F 1 [ <p> Nagamochi and Ibaraki <ref> [20] </ref> give a linear time algorithm (referred to as decomposition algorithm (DA)) that computes a special msfd, called DA-msfd, of order m in time O (m + n). A DA-msfd fulfills the following additional conditions [20]: If G is a graph then, (1) G is k-vertex connected iff F 1 [ : : : [ F k is k-vertex connected. <p> O ((s; t)) per insertion if the algorithm starts with an empty graph. 19 6 Appendix A Let G be a graph without multiple edges. We want to prove Lemma 13 and 14. We first present DA and show two properties of DA. Using a further lemma of <ref> [20] </ref>, we then prove Lemma 13. The proof of Lemma 14 follows. Lemma 14 and Lemma 23 has been shown independently in [7]. In DA, whenever a node is added to a forest F i , the edge is also given an direction. The Decomposition Algorithm [20] 1. <p> a further lemma of <ref> [20] </ref>, we then prove Lemma 13. The proof of Lemma 14 follows. Lemma 14 and Lemma 23 has been shown independently in [7]. In DA, whenever a node is added to a forest F i , the edge is also given an direction. The Decomposition Algorithm [20] 1. E 1 = E 2 = : : : = E m = ;, every node and every edge in G is unscanned. 2. for all v 2 V do r (v) = 0. 3. while there exists an unscanned node do 4. <p> After scanning the first such edge, r (x) is incremented to i + 1, but for each unscanned edge fx; yg, r (y) i. Thus, r (x) cannot be incremented again, i.e. x cannot become the root of another tree. In <ref> [20] </ref> the following properties of DA are proven: Lemma 25. 1. <p> If a node s of S has an outgoing edge into Y in F l immediatelly after s j was scanned, then 1. by Lemma 3.2 of <ref> [20] </ref>, s does not have an incoming edge from X in F l immediatelly after s j was scanned, and 21 2. by Lemma 2.2 of [20], then r (s) was at least l when s was scanned, and thus is at least l immediatelly after s j was scanned. <p> s of S has an outgoing edge into Y in F l immediatelly after s j was scanned, then 1. by Lemma 3.2 of <ref> [20] </ref>, s does not have an incoming edge from X in F l immediatelly after s j was scanned, and 21 2. by Lemma 2.2 of [20], then r (s) was at least l when s was scanned, and thus is at least l immediatelly after s j was scanned.
Reference: 21. <author> D. D. Sleator, R. E. Tarjan, </author> <title> "A data structure for dynamic trees" J. </title> <journal> Comput. System Sci. </journal> <volume> 24, </volume> <year> 1983, </year> <pages> 362-381. </pages>
Reference: 22. <author> J. Westbrook and R. E. Tarjan, </author> <title> "Maintaining bridge-connected and biconnected components on-line", </title> <type> Algorithmica (7) 5/6, </type> <year> 1992, </year> <pages> 433-464. </pages>
Reference-contexts: If is a constant, our running time is close to the running time of the best "special purpose" algorithms: Determining if two nodes are connected, 2-edge-connected, or 3-edge-connected takes amortized time O (ff (m; n)) per insertion or query <ref> [22, 12, 17] </ref>. Gabow's algorithm implies a fully dynamic algorithm which allows insertions and deletions of edges in worst-case time O (m log (n=)).
Reference: 23. <author> H. Whitney, </author> <title> "Non-separable and planar graphs", </title> <journal> Trans. Amer. Math. Soc. </journal> <volume> 34, </volume> <year> 1932, </year> <month> 339-362. </month> <title> This article was processed using the L A T E X macro package with LLNCS style 24 </title>
References-found: 23

