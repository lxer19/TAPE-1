URL: http://www.cs.ucdavis.edu/~pandey/europar.ps
Refering-URL: http://www.cs.ucdavis.edu/~pandey/cyes.html
Root-URL: http://www.cs.ucdavis.edu
Phone: 2  
Title: Support for Implementation of Evolutionary Concurrent Systems in Concurrent Programming Languages  
Author: Raju Pandey and J. C. Browne 
Address: CA 95616  Austin, TX 78712  
Affiliation: 1 Computer Science Department, University of California, Davis,  Department of Computer Sciences, The University of Texas,  
Abstract: In many concurrent programming languages, concurrent programs are difficult to extend and modify: small changes in a concurrent program may require re-implementations of a large number of its components. In this paper a novel concurrent program composition mechanism is presented in which implementations of computations and synchronizations are completely separated. Separation of implementations facilitates extensions and modifications of programs by allowing one to change implementations of both computations and synchronizations. The paper also describes a concurrent programming model and a programming lan guage that support the proposed approach.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Gregory R. Andrews. </author> <title> Concurrent Programming. </title> <publisher> The Benjamin/Cummings Publishing Company, </publisher> <address> Redwood City, CA, </address> <year> 1991. </year>
Reference-contexts: Example 2.1. (Extensibility and Modifiability of Concurrent Programs). Below we show a concurrent program, examprog1, that is composed from two components: producer and consumer. The producer component repeatedly produces data, which are consumed by the consumer component. The components interact through the send and receive primitives over a mailbox <ref> [1] </ref> in which programs can deposit and retrieve information in a FIFO manner.
Reference: 2. <author> Toby Bloom. </author> <title> Evaluating Synchronization Schemes. </title> <booktitle> In Proc. 7th Symposium on Operating Systems Principles, </booktitle> <pages> pages 24-32. </pages> <publisher> ACM, </publisher> <year> 1979. </year>
Reference-contexts: Event ordering constraint expressions differ from Path Expressions in that they are used to specify the ordering constraints that must be satisfied. Path Expressions, on the other hand, are used to specify the valid sequences of operations through a regular expression. Further, Bloom <ref> [2] </ref> shows that path expressions do not adequately support modular development of interaction specifications because path expressions do not contain general mechanisms for directly representing states of objects, and for specifying interactions that depend on the states.
Reference: 3. <author> Peter A. Buhr and Richard A. Strossbosscher. </author> <title> C++ Annotated Reference Manual. </title> <type> Technical Report Version 3.7, </type> <institution> University of Waterloo, Waterloo, </institution> <address> Ontario, Canada, N2L 3G1, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Most of this work has focussed on developing methodologies, languages, and tools for implementing concurrent programs. Most languages have added constructs for specifying concurrency and synchronization in a base languages. An extensive survey of these constructs is given in [19]. Examples of synchronization mechanisms are: semaphores <ref> [5, 3] </ref>, write-once-read-many variables [6], data flow based data dependencies [13], signal variables, enable-based approaches [11, 18, 25, 17, 7, 12], disable based approaches [9], and behavior abstraction based approaches [14, 15]. Our proposed interaction specification mechanism differs from most approaches in that it is declarative, and compositional.
Reference: 4. <author> R. H. Campbell and A. N. Habermann. </author> <title> The Specification of Process Synchronization by Path Expressions. </title> <booktitle> In Lecture Notes on Computer Sciences, </booktitle> <volume> volume 16, </volume> <pages> pages 89-102. </pages> <publisher> Springer Verlag, </publisher> <year> 1974. </year>
Reference-contexts: It supports abstractions for defining interaction behaviors. The abstractions can be modified and extended in isolation from other abstractions. Further, they can composed with other computational abstractions in many different ways to construct powerful program abstractions. An example of a declarative mechanism is Path Expression <ref> [4] </ref>. Event ordering constraint expressions differ from Path Expressions in that they are used to specify the ordering constraints that must be satisfied. Path Expressions, on the other hand, are used to specify the valid sequences of operations through a regular expression.
Reference: 5. <author> R. Chandra, A. Gupta, and J. L. Hennessy. </author> <title> COOL: A Language for Parallel Programming. </title> <booktitle> In Languages and Compilers for Parallel Computing Conference, </booktitle> <pages> pages 126-147. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Most of this work has focussed on developing methodologies, languages, and tools for implementing concurrent programs. Most languages have added constructs for specifying concurrency and synchronization in a base languages. An extensive survey of these constructs is given in [19]. Examples of synchronization mechanisms are: semaphores <ref> [5, 3] </ref>, write-once-read-many variables [6], data flow based data dependencies [13], signal variables, enable-based approaches [11, 18, 25, 17, 7, 12], disable based approaches [9], and behavior abstraction based approaches [14, 15]. Our proposed interaction specification mechanism differs from most approaches in that it is declarative, and compositional.
Reference: 6. <author> K. Mani Chandy and Carl Kesselman. </author> <title> Compositional C++: Compositional Parallel Programming. </title> <type> Technical Report Caltech-CS-TR-92-13, Cal Tech, </type> <year> 1992. </year>
Reference-contexts: Most languages have added constructs for specifying concurrency and synchronization in a base languages. An extensive survey of these constructs is given in [19]. Examples of synchronization mechanisms are: semaphores [5, 3], write-once-read-many variables <ref> [6] </ref>, data flow based data dependencies [13], signal variables, enable-based approaches [11, 18, 25, 17, 7, 12], disable based approaches [9], and behavior abstraction based approaches [14, 15]. Our proposed interaction specification mechanism differs from most approaches in that it is declarative, and compositional.
Reference: 7. <author> D. Dechouchant, S. Krakowiak, M. Meyesmbourg, M. Riveill, and X. Rousset de Pina. </author> <title> A Synchronization Mechanism for Typed Objects in a Distributed Systems. </title> <booktitle> In Workshop on Object-based Concurrent Programming, </booktitle> <pages> pages 105-107. </pages> <booktitle> ACM SIGPLAN, ACM, </booktitle> <month> Sept. </month> <year> 1989. </year>
Reference-contexts: Most languages have added constructs for specifying concurrency and synchronization in a base languages. An extensive survey of these constructs is given in [19]. Examples of synchronization mechanisms are: semaphores [5, 3], write-once-read-many variables [6], data flow based data dependencies [13], signal variables, enable-based approaches <ref> [11, 18, 25, 17, 7, 12] </ref>, disable based approaches [9], and behavior abstraction based approaches [14, 15]. Our proposed interaction specification mechanism differs from most approaches in that it is declarative, and compositional. It supports abstractions for defining interaction behaviors.
Reference: 8. <author> Ian T. Foster. </author> <title> Information Hiding in Parallel Programs. </title> <type> Technical Report MCS-P290-0292, </type> <institution> Argonne National laboratory, </institution> <year> 1992. </year>
Reference-contexts: However, the focus here is on re-usability of object and coordination constraints, and not on the modifiability and extensibility of concurrent programs in general. Foster <ref> [8] </ref> also introduces the notion of separation of implementations of architectural elements from task implementations in order to support re-usability of implementations of the architectural specifications, and portability of concurrent programs. However, in the proposed approach, specifications of synchronization is not separated from computations.
Reference: 9. <author> Svend Frolund. </author> <title> Inheritance of Synchronization Constraints in Concurrent Object--Oriented Programming Languages. </title> <booktitle> In ECOOP '92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 185-196. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: An extensive survey of these constructs is given in [19]. Examples of synchronization mechanisms are: semaphores [5, 3], write-once-read-many variables [6], data flow based data dependencies [13], signal variables, enable-based approaches [11, 18, 25, 17, 7, 12], disable based approaches <ref> [9] </ref>, and behavior abstraction based approaches [14, 15]. Our proposed interaction specification mechanism differs from most approaches in that it is declarative, and compositional. It supports abstractions for defining interaction behaviors. The abstractions can be modified and extended in isolation from other abstractions.
Reference: 10. <author> Svend Frolund and Gul Agha. </author> <title> A Language Framework for Multi-Object Coordination. </title> <booktitle> In Proceedings of the ECOOP'93, </booktitle> <pages> pages 346-360, </pages> <year> 1993. </year>
Reference-contexts: However, focus here has mostly been on resolving a specific instance of the program composition anomaly. It has not been studied within the general context of concurrent program composition. Svend and Agha <ref> [10] </ref> also use the notion of separation of implementations of object and coordination constraints in order to define a distributed coordination structure. However, the focus here is on re-usability of object and coordination constraints, and not on the modifiability and extensibility of concurrent programs in general.
Reference: 11. <author> Narain H. Gehani. </author> <title> Capsules: A Shared Memory Access Mechanism for Concurrent C/C++. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 4(7) </volume> <pages> 795-810, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Most languages have added constructs for specifying concurrency and synchronization in a base languages. An extensive survey of these constructs is given in [19]. Examples of synchronization mechanisms are: semaphores [5, 3], write-once-read-many variables [6], data flow based data dependencies [13], signal variables, enable-based approaches <ref> [11, 18, 25, 17, 7, 12] </ref>, disable based approaches [9], and behavior abstraction based approaches [14, 15]. Our proposed interaction specification mechanism differs from most approaches in that it is declarative, and compositional. It supports abstractions for defining interaction behaviors.
Reference: 12. <author> J. E. Grass and R. H. Campbell. Mediators: </author> <title> A Synchronization Mechanism. </title> <booktitle> In Sixth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 468-477, </pages> <year> 1986. </year>
Reference-contexts: Most languages have added constructs for specifying concurrency and synchronization in a base languages. An extensive survey of these constructs is given in [19]. Examples of synchronization mechanisms are: semaphores [5, 3], write-once-read-many variables [6], data flow based data dependencies [13], signal variables, enable-based approaches <ref> [11, 18, 25, 17, 7, 12] </ref>, disable based approaches [9], and behavior abstraction based approaches [14, 15]. Our proposed interaction specification mechanism differs from most approaches in that it is declarative, and compositional. It supports abstractions for defining interaction behaviors.
Reference: 13. <author> Andrew S. Grimshaw. </author> <title> Easy-to-Use Object-Oriented Parallel Processing with Men-tat. </title> <journal> IEEE Computer, </journal> <volume> 26(6) </volume> <pages> 39-51, </pages> <year> 1993. </year>
Reference-contexts: Most languages have added constructs for specifying concurrency and synchronization in a base languages. An extensive survey of these constructs is given in [19]. Examples of synchronization mechanisms are: semaphores [5, 3], write-once-read-many variables [6], data flow based data dependencies <ref> [13] </ref>, signal variables, enable-based approaches [11, 18, 25, 17, 7, 12], disable based approaches [9], and behavior abstraction based approaches [14, 15]. Our proposed interaction specification mechanism differs from most approaches in that it is declarative, and compositional. It supports abstractions for defining interaction behaviors.
Reference: 14. <author> Dennis Kafura and Keung Lee. </author> <title> Inheritance in Actor based Concurrent Object-Oriented Languages. </title> <booktitle> In Proceedings ECOOP'89, </booktitle> <pages> pages 131-145. </pages> <publisher> Cambridge University Press, </publisher> <year> 1989. </year>
Reference-contexts: In the case of inheritance anomaly, interaction behavior of inherited methods can be extended and/or modified by defining interaction behaviors in a subclass [21]. The inheritance anomaly has been studied in great detail and many solutions <ref> [14, 26, 23, 25] </ref> have been proposed. Most of these solutions are based on the separation of synchronization constraints from the method specifications as well. Separation of implementations facilitates programming language design as well. <p> An extensive survey of these constructs is given in [19]. Examples of synchronization mechanisms are: semaphores [5, 3], write-once-read-many variables [6], data flow based data dependencies [13], signal variables, enable-based approaches [11, 18, 25, 17, 7, 12], disable based approaches [9], and behavior abstraction based approaches <ref> [14, 15] </ref>. Our proposed interaction specification mechanism differs from most approaches in that it is declarative, and compositional. It supports abstractions for defining interaction behaviors. The abstractions can be modified and extended in isolation from other abstractions.
Reference: 15. <author> Satoshi Matsuoka. </author> <title> Language Features for Re-use and Extensibility in Concurrent Object-Oriented Programming. </title> <type> PhD thesis, </type> <institution> The University of Tokyo, </institution> <address> Japan, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: An extensive survey of these constructs is given in [19]. Examples of synchronization mechanisms are: semaphores [5, 3], write-once-read-many variables [6], data flow based data dependencies [13], signal variables, enable-based approaches [11, 18, 25, 17, 7, 12], disable based approaches [9], and behavior abstraction based approaches <ref> [14, 15] </ref>. Our proposed interaction specification mechanism differs from most approaches in that it is declarative, and compositional. It supports abstractions for defining interaction behaviors. The abstractions can be modified and extended in isolation from other abstractions.
Reference: 16. <author> Satoshi Matsuoka, Keniro Taura, and Akinori Yonezawa. </author> <title> Highly Efficient and Encapsulated Re-use of Synchronization Code in Concurrent Object-Oriented Languages. </title> <booktitle> In OOPSLA'93, </booktitle> <pages> pages 109-126. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: However, such a composition requires changes in the abstraction (AtBuf). Inheritance anomaly: The second problem, termed the inheritance anomaly <ref> [16] </ref>, arises due to the diverse synchronization requirements of a class and its subclasses. Example 2.3. (Inheritance anomaly). Let class NBuf extend class AtBuf by defining a new method GetLst. Method GetLst interacts with Read and Write of AtBuf. This implies that synchronization properties of Read and Write change. <p> Separation of implementation of computational and interaction behaviors has been proposed for the resolution of the inheritance anomaly <ref> [16] </ref>. However, focus here has mostly been on resolving a specific instance of the program composition anomaly. It has not been studied within the general context of concurrent program composition.
Reference: 17. <author> Ciaran McHale, Bridget Walsh, Sean Baker, and Alexis Donnelly. </author> <title> Scheduling Predicates. </title> <booktitle> In Object-Based Concurrent Computing Workshop, ECOOP'91, </booktitle> <volume> LNCS 612, </volume> <pages> pages 177-193. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Most languages have added constructs for specifying concurrency and synchronization in a base languages. An extensive survey of these constructs is given in [19]. Examples of synchronization mechanisms are: semaphores [5, 3], write-once-read-many variables [6], data flow based data dependencies [13], signal variables, enable-based approaches <ref> [11, 18, 25, 17, 7, 12] </ref>, disable based approaches [9], and behavior abstraction based approaches [14, 15]. Our proposed interaction specification mechanism differs from most approaches in that it is declarative, and compositional. It supports abstractions for defining interaction behaviors.
Reference: 18. <author> Christian Neusius. </author> <title> Synchronizing Actions. </title> <booktitle> In ECOOP '91, </booktitle> <pages> pages 118-132. </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Most languages have added constructs for specifying concurrency and synchronization in a base languages. An extensive survey of these constructs is given in [19]. Examples of synchronization mechanisms are: semaphores [5, 3], write-once-read-many variables [6], data flow based data dependencies [13], signal variables, enable-based approaches <ref> [11, 18, 25, 17, 7, 12] </ref>, disable based approaches [9], and behavior abstraction based approaches [14, 15]. Our proposed interaction specification mechanism differs from most approaches in that it is declarative, and compositional. It supports abstractions for defining interaction behaviors.
Reference: 19. <author> Raju Pandey. </author> <title> A Compositional Approach to Concurrent Programming. </title> <type> PhD thesis, </type> <institution> The University of Texas at Austin, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: It has been used to define a compositional model for concurrent object-oriented languages [21], and a concurrent object-oriented programming language, CYES-C++ [22]. Due to the lack of space, we outline only the fundamental aspects of the model and the language. The details can be found in <ref> [19] </ref>. 4.1 Representation of computational behavior Given that implementations of components do not include implementations of interaction behaviors, the question is: how are component programs implemented so that their interaction behaviors can be specified in a concurrent program? The execution behavior of a component is to repeatedly execute operations, and occasionally <p> Most of this work has focussed on developing methodologies, languages, and tools for implementing concurrent programs. Most languages have added constructs for specifying concurrency and synchronization in a base languages. An extensive survey of these constructs is given in <ref> [19] </ref>. Examples of synchronization mechanisms are: semaphores [5, 3], write-once-read-many variables [6], data flow based data dependencies [13], signal variables, enable-based approaches [11, 18, 25, 17, 7, 12], disable based approaches [9], and behavior abstraction based approaches [14, 15].
Reference: 20. <author> Raju Pandey and James C. Browne. </author> <title> Event-based Composition of Concurrent Programs. </title> <booktitle> In Workshop on Languages and Compilers for Parallel Computation, Lecture Notes in Computer Science 768. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The design of CYES-C++(Section 4.3) clearly benefited from this approach. 4 Support for Concurrent Programming We now describe a concurrent programming model and a programming language that support the proposed programming methodology. We first present a model of concurrent computation, called the C-YES model <ref> [20] </ref>. The C-YES model defines representation mechanisms for computational and interaction behaviors. It has been used to define a compositional model for concurrent object-oriented languages [21], and a concurrent object-oriented programming language, CYES-C++ [22].
Reference: 21. <author> Raju Pandey and James C. Browne. </author> <title> A Compositional Approach to Concurrent Object-Oriented Programming. </title> <booktitle> In IEEE International Conference on Computer Languages. </booktitle> <publisher> IEEE Press, </publisher> <month> May </month> <year> 1994. </year>
Reference-contexts: Separation also forms the basis for the resolution of the aggregation and inheritance anomalies. In the case of inheritance anomaly, interaction behavior of inherited methods can be extended and/or modified by defining interaction behaviors in a subclass <ref> [21] </ref>. The inheritance anomaly has been studied in great detail and many solutions [14, 26, 23, 25] have been proposed. Most of these solutions are based on the separation of synchronization constraints from the method specifications as well. Separation of implementations facilitates programming language design as well. <p> We first present a model of concurrent computation, called the C-YES model [20]. The C-YES model defines representation mechanisms for computational and interaction behaviors. It has been used to define a compositional model for concurrent object-oriented languages <ref> [21] </ref>, and a concurrent object-oriented programming language, CYES-C++ [22]. Due to the lack of space, we outline only the fundamental aspects of the model and the language.
Reference: 22. <author> Raju Pandey and James C. Browne. </author> <title> Support for Extensibility and Reusability in Concurrent Object-Oriented Programming Languages. </title> <booktitle> In Proceedings of the International Parallel Processing Symposium, </booktitle> <pages> pages 241-248. </pages> <publisher> IEEE, </publisher> <year> 1996. </year>
Reference-contexts: We first present a model of concurrent computation, called the C-YES model [20]. The C-YES model defines representation mechanisms for computational and interaction behaviors. It has been used to define a compositional model for concurrent object-oriented languages [21], and a concurrent object-oriented programming language, CYES-C++ <ref> [22] </ref>. Due to the lack of space, we outline only the fundamental aspects of the model and the language. <p> In our research, we combined it with the object-oriented model [27] in order to design a concurrent extension of C++ [24], called CYES-C++ <ref> [22] </ref>. The design of CYES-C++ is facilitated, and in parts driven, by the notion of separation. In CYES-C++, both computations and interactions are defined as abstractions. CYES-C++ supports powerful concurrent programming abstractions by extending existing C++ abstractions that combine computational and interaction behavior abstractions in different ways. <p> In CYES-C++, both computations and interactions are defined as abstractions. CYES-C++ supports powerful concurrent programming abstractions by extending existing C++ abstractions that combine computational and interaction behavior abstractions in different ways. We briefly enumerate them below (See <ref> [22] </ref> for detail): Concurrent class: CYES-C++extends the notion of a C++ class in order to define concurrent objects. In CYES-C++, a concurrent object is represented as a composition of a set of methods and a set of event ordering constraint expressions. <p> States in event ordering constraints expressions can be easily captured through event sets <ref> [22] </ref>. 6 Conclusion and Status Concurrent programs can be easily modified and extended if implementations of both computational and interaction behaviors are separated. Separation supports encapsulation of implementations of both computational and interaction behaviors.
Reference: 23. <author> S. Crespi Reghizzi and G. Galli de Paratesi. </author> <title> Definition of Reusable Concurrent Software Components. </title> <booktitle> In ECOOP '91, </booktitle> <pages> pages 148-165. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: In the case of inheritance anomaly, interaction behavior of inherited methods can be extended and/or modified by defining interaction behaviors in a subclass [21]. The inheritance anomaly has been studied in great detail and many solutions <ref> [14, 26, 23, 25] </ref> have been proposed. Most of these solutions are based on the separation of synchronization constraints from the method specifications as well. Separation of implementations facilitates programming language design as well.
Reference: 24. <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison Wesley, </publisher> <address> Second Edition edition, </address> <year> 1991. </year>
Reference-contexts: In our research, we combined it with the object-oriented model [27] in order to design a concurrent extension of C++ <ref> [24] </ref>, called CYES-C++ [22]. The design of CYES-C++ is facilitated, and in parts driven, by the notion of separation. In CYES-C++, both computations and interactions are defined as abstractions. CYES-C++ supports powerful concurrent programming abstractions by extending existing C++ abstractions that combine computational and interaction behavior abstractions in different ways.
Reference: 25. <author> Laurent Thomas. </author> <title> Extensibility and Reuse of Object-Oriented Synchronization Components. </title> <booktitle> In Parallel Architecture and Languages Europe, </booktitle> <volume> LNCS 605, </volume> <pages> pages 261-275. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In the case of inheritance anomaly, interaction behavior of inherited methods can be extended and/or modified by defining interaction behaviors in a subclass [21]. The inheritance anomaly has been studied in great detail and many solutions <ref> [14, 26, 23, 25] </ref> have been proposed. Most of these solutions are based on the separation of synchronization constraints from the method specifications as well. Separation of implementations facilitates programming language design as well. <p> Most languages have added constructs for specifying concurrency and synchronization in a base languages. An extensive survey of these constructs is given in [19]. Examples of synchronization mechanisms are: semaphores [5, 3], write-once-read-many variables [6], data flow based data dependencies [13], signal variables, enable-based approaches <ref> [11, 18, 25, 17, 7, 12] </ref>, disable based approaches [9], and behavior abstraction based approaches [14, 15]. Our proposed interaction specification mechanism differs from most approaches in that it is declarative, and compositional. It supports abstractions for defining interaction behaviors.
Reference: 26. <author> Chris Tomlinson and Vineet Singh. </author> <title> Inheritance and Synchronization with Enabled Sets. </title> <booktitle> In OOPSLA '89 Conference on Object-Oriented Programming, </booktitle> <pages> pages 103-112. </pages> <publisher> ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: In the case of inheritance anomaly, interaction behavior of inherited methods can be extended and/or modified by defining interaction behaviors in a subclass [21]. The inheritance anomaly has been studied in great detail and many solutions <ref> [14, 26, 23, 25] </ref> have been proposed. Most of these solutions are based on the separation of synchronization constraints from the method specifications as well. Separation of implementations facilitates programming language design as well.
Reference: 27. <author> Peter Wegner. </author> <title> Dimensions of Object-Based Language Design. In OOPSLA'87, page 168. </title> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: In our research, we combined it with the object-oriented model <ref> [27] </ref> in order to design a concurrent extension of C++ [24], called CYES-C++ [22]. The design of CYES-C++ is facilitated, and in parts driven, by the notion of separation. In CYES-C++, both computations and interactions are defined as abstractions.
References-found: 27

