URL: http://www.cs.toronto.edu/~chechik/courses97/csc2108/projects/web/6.ps.gz
Refering-URL: http://www.cs.toronto.edu/~chechik/courses97/csc2108/projects/web/
Root-URL: 
Title: Formal Methods: More Than Just Proofs.  
Author: Danny House 
Abstract: In this report we argue that formal methods are well on their way to becoming a routine part of every project. Industry appears to accept that verification via proof can be useful, but not enough to embraced widely. The theme of this report is that there is much more to gain from formal methods: specifically, support for reuse, implementation, and testing. By considering all of these uses taken together we perform a qualitative cost/benefit analysis of formal methods that uses compilers as the standard of comparison. We then propose a systematic integration of these uses to obtain a software development support system that would not be possible without formal methods. 
Abstract-found: 1
Intro-found: 1
Reference: [0] <author> E. M. Clarke, E. A. Emerson and A. P. </author> <title> Sistla , Automatic Verification of FiniteState Concurrent systems Using Temporal Logic Specifications, </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 8, no. 2, </volume> <pages> pp. 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: We need to know the empirical data about the environment. For example: What objects will we model? What are their characteristics? What do we want to do with them? What do we need to know to use a compiler? 2 CTL (computation tree logic, <ref> [0] </ref>) allows us to say things like no matter what happens next, the elevator door will be closed formally as AX (doorClosed). Formal Methods: More Than Just Proofs Page 4 1. We must know what a program is.
Reference: [1] <author> Brian James Bauer and David Lorge Parnas , "Applying Mathematical Software Documentation: </author> <title> an Experience Report", </title> <booktitle> COMPASS 95, Proceedings of the Tenth Annual Conference on Computer Assurance, IEEE, </booktitle> <address> New York, NY, USA, </address> <year> 1995, </year> <note> ix+285 pp. p273-285. </note>
Reference-contexts: It will take a while, but eventually this cost will be irrelevant compared to the cost of personnel. From above, the same skills are needed for both, and so the same number of people with sufficient talent is available. Bauer and Parnas <ref> [1] </ref> provide support for this claim in the form of an example of formal methods being used by a fourth year undergraduate Formal Methods: More Than Just Proofs Page 5 computer engineering student with no prior exposure to them.
Reference: [2] <institution> Anthony Hall , "Seven Myths of Formal Methods", IEEE Software, </institution> <month> September </month> <year> 1990, </year> <journal> Vol. </journal> <volume> 7, No 5, </volume> <pages> pages 11-19. </pages>
Reference-contexts: Bauer and Parnas [1] provide support for this claim in the form of an example of formal methods being used by a fourth year undergraduate Formal Methods: More Than Just Proofs Page 5 computer engineering student with no prior exposure to them. Hall <ref> [2] </ref> claims that "people with only highschool math training can write excellent formal specifications", and that as little as three weeks training is enough to use the basic math and a specific formal notation.
Reference: [3] <author> J.-R. </author> <title> Abrial , "The B-Book: Assigning Programs to Meaning, </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, </address> <year> 1996. </year>
Reference-contexts: C code can be generated directly from low level designs in B, SDL, ObjecTime, and other notations. Bicarregui et. al. describe a specific application of this in [5], where they use B. (B represents specifications as abstract state machines <ref> [3] </ref> [4].) Any plan can be viewed as a type of code for a suitable machine, so a system that generates plans should be adaptable to the code generation task.
Reference: [4] <institution> B-Core (UK) Ltd, </institution> <note> B-Toolkit User's Manual, Version 3.0., </note> <year> 1996. </year> <title> For details, </title> <type> contact Ib Sorensen, </type> <institution> B Core (UK) Ltd, Magdalen Centre, Robert Robinson Avenue, The Oxford Science park, Oxford 0X4 4GA. Tel.: </institution> <note> +44 865 784520. Email: Ib.Sorensen@comlab.ox.ac.uk. WWW: http://www.b-core.com/. </note>
Reference-contexts: C code can be generated directly from low level designs in B, SDL, ObjecTime, and other notations. Bicarregui et. al. describe a specific application of this in [5], where they use B. (B represents specifications as abstract state machines [3] <ref> [4] </ref>.) Any plan can be viewed as a type of code for a suitable machine, so a system that generates plans should be adaptable to the code generation task.
Reference: [5] <author> Juan Bicarregui, Jeremy Dick, Brian Matthews, </author> <title> Eoin Woods , "Making the most of formal specification through animation, testing and proof", </title> <booktitle> Science of Computer Programming, </booktitle> <volume> vol. 29, no. </volume> <pages> 1-2, pp. 53-78, </pages> <month> July </month> <year> 1997. </year>
Reference-contexts: It appears that this is not just possible; it is being done now. C code can be generated directly from low level designs in B, SDL, ObjecTime, and other notations. Bicarregui et. al. describe a specific application of this in <ref> [5] </ref>, where they use B. (B represents specifications as abstract state machines [3] [4].) Any plan can be viewed as a type of code for a suitable machine, so a system that generates plans should be adaptable to the code generation task. <p> In fact, as described in the section on formal methods and reliability, existing tools provide better coverage and reliability than humans in some cases. Tools for generating test cases already exist. In [10] test kernels were computed using TVeda-V3, which uses both symbolic computation and reachability analysis. In <ref> [5] </ref> the test cases were generated from VDM using VAT [11]. (Being a prototype research tool, a 1400 line specification was enough to make VAT 'struggle'. It is not clear how well it will scale up.) In [9], the test class generation was supported by DST Z-Tools. <p> It is generally agreed that formal specifications catch mistakes both in understanding what the customer wants, and in designs (especially if proofs are used). Proofs of conformance between specifications and annotated implementations have also been explored [17]. Gains can also come from better test suites. Bicarregui et. al. <ref> [5] </ref> report better coverage through automated test domain generation.
Reference: [6] <editor> Talal Maghrabi and Forouzan Golshani , "Automatic Program Generation Using Sequent Calculus", </editor> <booktitle> Proceedings of the 1992 ACM Computer Science Conference, </booktitle> <address> xviii + 574pp, p73-81, </address> <year> 1992. </year>
Reference-contexts: In <ref> [6] </ref> Maghrabi and Formal Methods: More Than Just Proofs Page 6 Golshani demonstrate how a program can be generated in parallel to the steps in a proof in the sequent calculus. They only restrict the specification to being a well-formed formula of first-order logic.
Reference: [7] <author> R. Waldinger and R. Lee , "PROW: </author> <title> A Step Toward Automatic Program Writing", </title> <booktitle> Proceedings of IJCAI, </booktitle> <pages> pp. 241-252, </pages> <year> 1969. </year>
Reference-contexts: They only restrict the specification to being a well-formed formula of first-order logic. Their target language is a subset of Prolog. Coupled with a Prolog compiler we are nearly done. PROW <ref> [7] </ref> and QA3 [8] are resolution-based systems that also generate code. Lots of special purpose languages with corresponding code generators are written every year, and when they are well conceived, they reduce the software engineering task just a little more.
Reference: [8] <author> C. </author> <title> Green , "Application of Theorem Proving to Problem Solving", </title> <booktitle> Proceedings of IJCAI, </booktitle> <pages> pp. 219-239, </pages> <year> 1969. </year>
Reference-contexts: They only restrict the specification to being a well-formed formula of first-order logic. Their target language is a subset of Prolog. Coupled with a Prolog compiler we are nearly done. PROW [7] and QA3 <ref> [8] </ref> are resolution-based systems that also generate code. Lots of special purpose languages with corresponding code generators are written every year, and when they are well conceived, they reduce the software engineering task just a little more.
Reference: [9] <editor> Hans-Martin Horcher , "Improving Software Tests using Z Specifications", in J.P. Bowen and M.G. Hinchey, eds,, </editor> <booktitle> Proc. ZUM'95, Lecture Notes in Computer Science 967, </booktitle> <publisher> (Springer, </publisher> <address> Berlin 1995). </address>
Reference-contexts: Not only will this yield direct time savings, it will improve employee morale and reduce staff turnover, improving productivity in an indirect manner. An additional benefit comes during maintenance, as these tools reduce the cost of regression testing <ref> [9] </ref>. In fact, as described in the section on formal methods and reliability, existing tools provide better coverage and reliability than humans in some cases. Tools for generating test cases already exist. In [10] test kernels were computed using TVeda-V3, which uses both symbolic computation and reachability analysis. <p> In [5] the test cases were generated from VDM using VAT [11]. (Being a prototype research tool, a 1400 line specification was enough to make VAT 'struggle'. It is not clear how well it will scale up.) In <ref> [9] </ref>, the test class generation was supported by DST Z-Tools. Some other tools of this sort are TAOS and SDL. Even when direct generation of tests is still too difficult, the use of a test oracle or test checker will improve productivity.
Reference: [10] <author> Jean-Claude Fernandez , Claude Jard, Thierry Jeron, and Cesar Viho, </author> <title> "An experiment in automatic generation of test suites for protocols with verification technology", </title> <booktitle> Science of Computer Programming, </booktitle> <volume> vol. 29, no. </volume> <pages> 1-2, </pages> <address> pp.123-146, </address> <month> July </month> <year> 1997. </year> <title> Formal Methods: More Than Just Proofs Page 12 </title>
Reference-contexts: An additional benefit comes during maintenance, as these tools reduce the cost of regression testing [9]. In fact, as described in the section on formal methods and reliability, existing tools provide better coverage and reliability than humans in some cases. Tools for generating test cases already exist. In <ref> [10] </ref> test kernels were computed using TVeda-V3, which uses both symbolic computation and reachability analysis. In [5] the test cases were generated from VDM using VAT [11]. (Being a prototype research tool, a 1400 line specification was enough to make VAT 'struggle'. <p> Fernandez et. al. <ref> [10] </ref> compared their generated tests to a suite of preexisting hand written tests addressing the same features. Both the handwritten and machine-generated tests were expressed in the same test scripting language.
Reference: [11] <author> A.J.J. Dick and A. </author> <title> Faivre , "Automating the generation and sequencing of test cases from model-based specifications", </title> <editor> in: J.C.P. Woodcock and P.G. Larsen, eds., </editor> <booktitle> "Proceedings of FME'93: IndustrialStrength Formal Methods", lecture Notes in Computer Science, </booktitle> <volume> Vol. </volume> <publisher> 670 (Springer, </publisher> <address> Berlin, </address> <year> 1993) </year> <month> 268-284. </month>
Reference-contexts: Tools for generating test cases already exist. In [10] test kernels were computed using TVeda-V3, which uses both symbolic computation and reachability analysis. In [5] the test cases were generated from VDM using VAT <ref> [11] </ref>. (Being a prototype research tool, a 1400 line specification was enough to make VAT 'struggle'. It is not clear how well it will scale up.) In [9], the test class generation was supported by DST Z-Tools. Some other tools of this sort are TAOS and SDL.
Reference: [12] <institution> Erich Mikk , "Compilation of Z Specifications into C for Automatic Test Result Evaluation", </institution> <note> in J.P. </note> <editor> Bowen and M.G. Hinchey, eds,, </editor> <booktitle> Proc. ZUM'95, Lecture Notes in Computer Science 967, </booktitle> <publisher> (Springer, </publisher> <address> Berlin 1995). </address>
Reference-contexts: Tools for generating test checkers already exist; for example, a predicate compiler for Z is described in <ref> [12] </ref>. Certainly, these tools can still be improved a lot, but the gains in productivity are already real, and can only increase. Formal Methods: More Than Just Proofs Page 7 3.3.3 Formal Methods in Software Reuse If reuse can be made easier then designs can be created quicker.
Reference: [13] <institution> Arun Sen , "The Role of Opportunism in the Software Design Reuse Process", </institution> <note> IEEE Transactions on Software Engineering, </note> <editor> vol. </editor> <volume> 23, no. 7, </volume> <pages> pp. 418-436, </pages> <month> July </month> <year> 1997. </year>
Reference-contexts: To reuse existing software engineering products, the developer must perform several tasks: analyze the problem, find objects worth reusing, understand the objects found, select the best objects, adapt the objects, justify the choices made, evaluate the result, and record the choices and adaptations <ref> [13] </ref>. Formal methods can contribute significantly to all of these except recording the choices and adaptations (which should be straight forward). Large libraries of reusable components already exist. <p> In this case the classification should come for free. This begs the question: which formal notation should be used? As we shall see, using just one notation would help in many ways. In <ref> [13] </ref>, problem analysis means choosing descriptors as a basis for search. This includes the map from the notation of the problem to the notation of the repository. Ideally, there should be a straight forward map between these notations.
Reference: [14] <author> P. </author> <booktitle> Cashin , "BNR Remains at the Forefront of Computing Technology", Telesis, </booktitle> <volume> vol. 92, </volume> <pages> pp. 73-75, </pages> <year> 1991. </year>
Reference-contexts: Formal methods can contribute significantly to all of these except recording the choices and adaptations (which should be straight forward). Large libraries of reusable components already exist. Nortell has a library of about 16 million lines of code <ref> [14] </ref> and IBM has a library of more than 1,200 components [15]. In either choice of units, that is a lot for a designer to learn.
Reference: [15] <author> Rym Mili, Ali Mili, and Roland T. </author> <title> Mittermeir , "Storing and Retrieving Software Components: A Refinement Based System", </title> <journal> IEEE Transactions on Software Engineering vol. </journal> <volume> 23, no. 7, </volume> <pages> pp. 445-460, </pages> <month> July </month> <year> 1997. </year>
Reference-contexts: Formal methods can contribute significantly to all of these except recording the choices and adaptations (which should be straight forward). Large libraries of reusable components already exist. Nortell has a library of about 16 million lines of code [14] and IBM has a library of more than 1,200 components <ref> [15] </ref>. In either choice of units, that is a lot for a designer to learn. In [15], it is suggested that these components should be classified by hand using formal methods, so that we look for objects worth reusing by searching for specifications that unify with one or more goals in <p> Large libraries of reusable components already exist. Nortell has a library of about 16 million lines of code [14] and IBM has a library of more than 1,200 components <ref> [15] </ref>. In either choice of units, that is a lot for a designer to learn. In [15], it is suggested that these components should be classified by hand using formal methods, so that we look for objects worth reusing by searching for specifications that unify with one or more goals in the problem. There is a further suggestion in [15] as to how the search might be <p> In <ref> [15] </ref>, it is suggested that these components should be classified by hand using formal methods, so that we look for objects worth reusing by searching for specifications that unify with one or more goals in the problem. There is a further suggestion in [15] as to how the search might be performed efficiently. As an aside, there are problems with how the components are to be classified. In [15], the provider of each component is required to anticipate the way in which the component will be used, then specify the properties that correspond to <p> There is a further suggestion in <ref> [15] </ref> as to how the search might be performed efficiently. As an aside, there are problems with how the components are to be classified. In [15], the provider of each component is required to anticipate the way in which the component will be used, then specify the properties that correspond to the intended use. This seems to add opportunities for error while expecting the provider to have oracular power. <p> that will: 1. generate test cases, 2. come with a rich set of reusable objects, each of having a formal specification in the chosen notation, Formal Methods: More Than Just Proofs Page 10 3. support the search for reusable objects via the use of unification and the algorithms described in <ref> [15] </ref>, and a natural user interface to restrict the search to objects that unify with a user specified sub-problem, 4. adapt reusable objects as described in [16], 5. accept the introduction of new objects, so long as they have specifications in the chosen notation, 6. prevent the assembly of components that
Reference: [16] <author> Gordon S. </author> <title> Novak Jr ., "Software Reuse by Specialization of Generic Procedures through Views", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 23, no. 7, </volume> <pages> pp. 401-417, </pages> <month> July </month> <year> 1997. </year>
Reference-contexts: Yet another way is to rewrite and optimize the object for its new chore. Rewriting and Formal Methods: More Than Just Proofs Page 8 optimizing gives efficient code, but is expensive in human time and suffers from a greater risk of human error. <ref> [16] </ref> takes an approach to adaptation that is half way between these last two. The generic object is specified using a high level description that allows the compiler to rewrite it. <p> Methods: More Than Just Proofs Page 10 3. support the search for reusable objects via the use of unification and the algorithms described in [15], and a natural user interface to restrict the search to objects that unify with a user specified sub-problem, 4. adapt reusable objects as described in <ref> [16] </ref>, 5. accept the introduction of new objects, so long as they have specifications in the chosen notation, 6. prevent the assembly of components that are not compatible (design-time type checking), 7. track requirements of the system being developed and how the design refines them, 8. generate the final code, and
Reference: [17] <editor> Marsha Chechik and John Gannon , "Automatic Analysis of Consistency between Implementations and Requirements: </editor> <title> A Case Study", </title> <booktitle> COMPASS 95, Proceedings of the Tenth Annual Conference on Computer Assurance, IEEE, </booktitle> <address> New York, NY, USA, </address> <year> 1995, </year> <pages> ix+285 pp. 123-31. </pages>
Reference-contexts: Improved reliability can come in several forms. It is generally agreed that formal specifications catch mistakes both in understanding what the customer wants, and in designs (especially if proofs are used). Proofs of conformance between specifications and annotated implementations have also been explored <ref> [17] </ref>. Gains can also come from better test suites. Bicarregui et. al. [5] report better coverage through automated test domain generation.
References-found: 18

