URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1995/TR53.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Email: E-mail: fmanivann,singhalg@cis.ohio-state.edu  
Title: Comprehensive Low-overhead Process Recovery Based on Quasi-synchronous Checkpointing  
Author: D. Manivannan and M. Singhal 
Keyword: Distributed checkpointing, failure recovery, fault-tolerance.  
Address: Columbus, OH 43210.  
Affiliation: Distributed Systems Research Group, Department of Computer and Information Science, The Ohio State University,  
Abstract: In this paper, we propose a low-overhead recovery algorithm based on a quasi-synchronous checkpointing algorithm. The checkpointing algorithm preserves process autonomy by allowing them to take checkpoints asynchronously and uses communication-induced checkpoint coordination for the progression of the recovery line which helps bound rollback propagation during a recovery. Thus, it has the easeness and low overhead of asynchronous checkpointing and the recovery time advantages of synchronous checkpointing. There is no extra message overhead involved during checkpointing and the additional checkpointing overhead is nominal. The checkpointing algorithm ensures the existence of a recovery line consistent with the latest checkpoint of any process all the time. The recovery algorithm exploits this feature to restore the system to a state consistent with the latest checkpoint of a failed process, in the event of a failure. The recovery algorithm has no domino effect and a failed process needs only to rollback to its latest checkpoint and request the other processes to roll back to a consistent checkpoint. It uses selective pessimistic message logging at the receiver end to handle the messages lost due to rollback. Neither the recovery algorithm nor the checkpointing algorithm requires the channels to be FIFO. We do not use vector timestamps for determining dependency between checkpoints which result in high message overhead during failure-free operation if the number of processes is large. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Acharya, B. R. Badrinath, and T. Imielinski. </author> <title> "Checkpointing Distributed Applications on Mobile Computing Systems". </title> <type> Technical report, </type> <institution> Department of Computer Science, Rutgers University, </institution> <year> 1994. </year>
Reference-contexts: This causes processes to suspend the normal computation for making checkpoint decisions which may greatly increase the overhead during normal computation. The QSA does not cause any such overhead and avoids domino effect completely during recovery. In Acharya et al.'s <ref> [1] </ref> asynchronous checkpointing algorithm for mobile computing systems, a process takes a checkpoint 27 whenever a message reception is preceded by a message transmission.
Reference: [2] <author> R. Attar, P. A. Bernstein, and N. Goodman. </author> <title> "Site Initialization, Recovery, and Backup in a Distributed Database System". </title> <journal> IEEE Trans. on Software Engineering, </journal> <pages> pages 645-650, </pages> <month> November </month> <year> 1984. </year>
Reference-contexts: Since processes roll back to a global checkpoint under BRA, orphan messages do not arise. Messages received while a process is down are buffered and are delivered to the process after recovery. This can be achieved with a front-end processor or message spooling <ref> [2] </ref>. Thus, we need only handle the following types of messages: delayed messages that are received after a failed process recovers from failure, messages lost because of rollback, and duplicate messages.
Reference: [3] <author> B. Bhargava and P. Leu. </author> <title> "Concurrent Robust Checkpointing and Recovery in Distributed Systems". </title> <booktitle> In Proc. of 4 th IEEE Int. Conf. Data Eng., </booktitle> <pages> pages 154-163, </pages> <month> February </month> <year> 1988. </year> <month> 29 </month>
Reference-contexts: latest checkpoint of the failed process is greater than the sequence numbers of the latest checkpoints of all the other processes, then no process other than the failed process needs to roll back; they only need to take a checkpoint. 6 Comparison With Existing Work The checkpointing algorithms proposed in <ref> [10, 3] </ref> have a two-phase structure. This causes processes to suspend the normal computation for making checkpoint decisions which may greatly increase the overhead during normal computation. The QSA does not cause any such overhead and avoids domino effect completely during recovery.
Reference: [4] <author> B. Bhargava and S. R. Lian. </author> <title> "Independent Checkpointing and Concurrent Rollback for Recovery in Distributed Systems-An Optimistic Approach.". </title> <booktitle> In Proc. 7 th IEEE Symp. Reliable Distributed Syst., </booktitle> <pages> pages 3-12, </pages> <year> 1988. </year>
Reference-contexts: In the literature, several checkpointing schemes have been proposed for distributed systems. They can be broadly classified into two categories asynchronous and synchronous. In asynchronous checkpointing <ref> [4, 11, 22] </ref>, processes take checkpoints periodically without any coordination with others. To recover from a failure, a process communicates with other 2 processes to determine if their local states are causally related.
Reference: [5] <author> Luis Moura e Silva and Jouao Gabriel Silva. </author> <title> "Global Checkpointing for Distributed Programs". </title> <booktitle> In Proc. Symp. Reliable Distributed Systems, </booktitle> <pages> pages 155-162, </pages> <year> 1992. </year>
Reference-contexts: In synchronous checkpointing schemes, domino-free recovery is achieved by sacrificing process autonomy and incurring extra message overhead during checkpointing. In this approach, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [5, 10, 12, 13] </ref>. The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time.
Reference: [6] <author> D. B. Johnson and W. Zwaenepoel. </author> <title> "Recovery in Distributed Systems Using Optimistic Message Logging and Checkpointing". </title> <journal> Journal of Algorithms, </journal> <volume> 11(3) </volume> <pages> 462-491, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: To reduce domino effect, Kim et al. [9], Venkatesh et al. [20], and Xu et al. [25] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [6, 7, 18, 19, 24] </ref> and message reordering [23] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. Thus, storage requirement may be large. <p> However, their approach has higher checkpointing overhead since processes do not skip basic checkpoints if they have taken forced checkpoints. Many of the existing recovery algorithms use vector timestamps <ref> [16, 6, 15, 18, 17, 19] </ref> to track dependency between checkpoints and events. Vector timestamps generally result in high message overhead during failure-free operation. The optimistic recovery algorithm proposed by Strom and Yemini [19] suffers from domino effect. <p> Smith and Johnson [17] proposed an asynchronous recovery algorithm for multiple process failures; however, the size of the vector timestamp is O (N 2 fl f ) where f is the maximum number of failures of any single process. Johnson and Zwaenepoel <ref> [6] </ref> proposed a centralized protocol to optimistically recover the maximum recoverable state. Our recovery algorithm does not require vector timestamps. Channels need not be FIFO. Recovery is fully asynchronous. Recovery requires only one rollback message to be sent to the other processes.
Reference: [7] <author> T. T-Y. Juang and S. Venkatesan. </author> <title> "Crash Recovery with Little Overhead". </title> <booktitle> In Proc. of 11 th International Conf. on Distributed Comput. Syst., </booktitle> <pages> pages 454-461, </pages> <year> 1991. </year>
Reference-contexts: To reduce domino effect, Kim et al. [9], Venkatesh et al. [20], and Xu et al. [25] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [6, 7, 18, 19, 24] </ref> and message reordering [23] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. Thus, storage requirement may be large.
Reference: [8] <author> Junguk L. Kim and Taesoon Park. </author> <title> "An Efficient Protocol for Checkpointing recovery in Distributed Systems". </title> <journal> IEEE Trans. on Parallel and Distributed Systems, </journal> <volume> 4(8) </volume> <pages> 955-960, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Process execution may have to be suspended during the checkpointing coordination as in <ref> [8, 10] </ref>, resulting in performance degradation. 1 A globally consistent set of checkpoints. 3 Paper Objectives In this paper, we first present a quasi-synchronous checkpointing algorithm which has the easeness and low overhead of asynchronous checkpointing and the recovery time advantages of synchronous checkpointing.
Reference: [9] <author> K. H Kim. </author> <title> "A Scheme for Coordinated Execution of Independently Designed Recoverable Distributed Processes". </title> <booktitle> In Proc. of 16 th IEEE Symp. Fault-Tolerant Comput., </booktitle> <pages> pages 130-135, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: This approach allows maximum process autonomy and has low checkpointing overhead. However, this approach may suffer from the domino effect, in which the processes roll back repeatedly while determining a consistent set of checkpoints. To reduce domino effect, Kim et al. <ref> [9] </ref>, Venkatesh et al. [20], and Xu et al. [25] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging [6, 7, 18, 19, 24] and message reordering [23] have been suggested in the literature to cope with the domino effect.
Reference: [10] <author> R. Koo and S. Toueg. </author> <title> "Checkpointing and Roll-back Recovery for Distributed Systems". </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> SE-13(1):23-31, </volume> <month> January </month> <year> 1987. </year>
Reference-contexts: In synchronous checkpointing schemes, domino-free recovery is achieved by sacrificing process autonomy and incurring extra message overhead during checkpointing. In this approach, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [5, 10, 12, 13] </ref>. The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. <p> The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time. Process execution may have to be suspended during the checkpointing coordination as in <ref> [8, 10] </ref>, resulting in performance degradation. 1 A globally consistent set of checkpoints. 3 Paper Objectives In this paper, we first present a quasi-synchronous checkpointing algorithm which has the easeness and low overhead of asynchronous checkpointing and the recovery time advantages of synchronous checkpointing. <p> latest checkpoint of the failed process is greater than the sequence numbers of the latest checkpoints of all the other processes, then no process other than the failed process needs to roll back; they only need to take a checkpoint. 6 Comparison With Existing Work The checkpointing algorithms proposed in <ref> [10, 3] </ref> have a two-phase structure. This causes processes to suspend the normal computation for making checkpoint decisions which may greatly increase the overhead during normal computation. The QSA does not cause any such overhead and avoids domino effect completely during recovery.
Reference: [11] <author> K.Tsuruoka, A. Kaneko, and Y. Nishihara. </author> <title> "Dynamic Recovery Schemes for Distributed Process". </title> <booktitle> In Proceedings of IEEE 2nd Symp. on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pages 124-130, </pages> <year> 1981. </year>
Reference-contexts: In the literature, several checkpointing schemes have been proposed for distributed systems. They can be broadly classified into two categories asynchronous and synchronous. In asynchronous checkpointing <ref> [4, 11, 22] </ref>, processes take checkpoints periodically without any coordination with others. To recover from a failure, a process communicates with other 2 processes to determine if their local states are causally related.
Reference: [12] <author> T. H. Lai and T. H. Yang. </author> <title> "On Distributed Snapshots". </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 153-158, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: In synchronous checkpointing schemes, domino-free recovery is achieved by sacrificing process autonomy and incurring extra message overhead during checkpointing. In this approach, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [5, 10, 12, 13] </ref>. The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time.
Reference: [13] <author> K. Li, J. F. Naughton, and J. S. Plank. </author> <title> "Checkpointing Multicomputer Applications". </title> <booktitle> In Proc. 10 th Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 2-11, </pages> <year> 1991. </year>
Reference-contexts: In synchronous checkpointing schemes, domino-free recovery is achieved by sacrificing process autonomy and incurring extra message overhead during checkpointing. In this approach, processes synchronize their checkpointing activities so that a globally consistent set of checkpoints is always maintained in the system <ref> [5, 10, 12, 13] </ref>. The storage requirement for the checkpoints is minimum because each process keeps only one checkpoint in the stable storage at any given time.
Reference: [14] <author> D. Manivannan and M. Singhal. </author> <title> "A Quasi-synchronous Algorithm for Checkpointing in Distributed Systems". </title> <type> Technical Report OSU-CISRC-10/95-TR43, </type> <institution> The Ohio State University, Department of Computer and Information Science, </institution> <year> 1995. </year>
Reference-contexts: The results of the analysis in these two cases are given in Assertions 1 and 2, respectively below. The proofs of these assertions can be found in <ref> [14] </ref>. Assertion 1: Assume that under a basic checkpointing pattern, each process takes a basic checkpoint at the end of every x time units, and the local clocks of the processes can drift by at most ffi where ffi &lt; 1 2 fl x.
Reference: [15] <author> S. L. Peterson and Phil Kearns. </author> <title> "Rollback Based on Vector Time". </title> <booktitle> In Proc. 12 th Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 68-77, </pages> <year> 1993. </year>
Reference-contexts: The use of checkpoints on a stable storage and rollback-recovery protocols are well established techniques for dealing with process failures in a distributed system. When a failure occurs, a rollback protocol uses the checkpoints and message logs to restore the system to a consistent global state <ref> [15] </ref>. By a consistent global state we mean that if the receipt operation of a message has been recorded in the state of some process, then the send operation of that message must have been recorded also. In the literature, several checkpointing schemes have been proposed for distributed systems. <p> However, their approach has higher checkpointing overhead since processes do not skip basic checkpoints if they have taken forced checkpoints. Many of the existing recovery algorithms use vector timestamps <ref> [16, 6, 15, 18, 17, 19] </ref> to track dependency between checkpoints and events. Vector timestamps generally result in high message overhead during failure-free operation. The optimistic recovery algorithm proposed by Strom and Yemini [19] suffers from domino effect. <p> Vector timestamps generally result in high message overhead during failure-free operation. The optimistic recovery algorithm proposed by Strom and Yemini [19] suffers from domino effect. The recovery protocols based on vector clock proposed by Peterson and Kearns <ref> [15] </ref> is synchronous and tolerates single process failure. It requires the channels to be FIFO. Recovery proposed by Sistla and Welch [18] is synchronous for single process failure, requires the channels to be FIFO and uses vector timestamps.
Reference: [16] <author> Golden G. Richard. </author> <title> "Techniques for Process Recovery in Message Passing and Distributed Shared Memory Systems". </title> <type> PhD thesis, </type> <institution> The Ohio State University, </institution> <year> 1994. </year>
Reference-contexts: However, their approach has higher checkpointing overhead since processes do not skip basic checkpoints if they have taken forced checkpoints. Many of the existing recovery algorithms use vector timestamps <ref> [16, 6, 15, 18, 17, 19] </ref> to track dependency between checkpoints and events. Vector timestamps generally result in high message overhead during failure-free operation. The optimistic recovery algorithm proposed by Strom and Yemini [19] suffers from domino effect.
Reference: [17] <author> David B. Johnson Sean W. Smith and J. D. Tygar. </author> <title> "Completely Asynchronous Optimistic recovery with Minimal Rollbacks". </title> <booktitle> In Proc. of 25 th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 361-370. </pages> <publisher> IEEE, </publisher> <year> 1995. </year> <month> 30 </month>
Reference-contexts: However, their approach has higher checkpointing overhead since processes do not skip basic checkpoints if they have taken forced checkpoints. Many of the existing recovery algorithms use vector timestamps <ref> [16, 6, 15, 18, 17, 19] </ref> to track dependency between checkpoints and events. Vector timestamps generally result in high message overhead during failure-free operation. The optimistic recovery algorithm proposed by Strom and Yemini [19] suffers from domino effect. <p> It requires the channels to be FIFO. Recovery proposed by Sistla and Welch [18] is synchronous for single process failure, requires the channels to be FIFO and uses vector timestamps. Smith and Johnson <ref> [17] </ref> proposed an asynchronous recovery algorithm for multiple process failures; however, the size of the vector timestamp is O (N 2 fl f ) where f is the maximum number of failures of any single process.
Reference: [18] <author> A. P. Sistla and J. L. Welch. </author> <title> "Efficient Distributed Recovery Using Message Logging". </title> <booktitle> In Proc. of 8 th ACM Symp. Principles Distributed Comput., </booktitle> <pages> pages 223-238, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: To reduce domino effect, Kim et al. [9], Venkatesh et al. [20], and Xu et al. [25] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [6, 7, 18, 19, 24] </ref> and message reordering [23] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. Thus, storage requirement may be large. <p> However, their approach has higher checkpointing overhead since processes do not skip basic checkpoints if they have taken forced checkpoints. Many of the existing recovery algorithms use vector timestamps <ref> [16, 6, 15, 18, 17, 19] </ref> to track dependency between checkpoints and events. Vector timestamps generally result in high message overhead during failure-free operation. The optimistic recovery algorithm proposed by Strom and Yemini [19] suffers from domino effect. <p> The optimistic recovery algorithm proposed by Strom and Yemini [19] suffers from domino effect. The recovery protocols based on vector clock proposed by Peterson and Kearns [15] is synchronous and tolerates single process failure. It requires the channels to be FIFO. Recovery proposed by Sistla and Welch <ref> [18] </ref> is synchronous for single process failure, requires the channels to be FIFO and uses vector timestamps.
Reference: [19] <author> R. E. Strom and S. Yemini. </author> <title> "Optimistic Recovery in Distributed Systems". </title> <journal> ACM Trans. Comput. Syst., </journal> <volume> 3(3) </volume> <pages> 204-226, </pages> <month> August </month> <year> 1985. </year>
Reference-contexts: We assume that messages are not lost, altered or spuriously introduced. No assumption is made about the FIFO nature of the channels. Processes are fail-stop. All failures are detected immediately and result in halting failed processes and initiating recovery action <ref> [19] </ref>. A process can be inactive due to failure for an arbitrarily long, but finite time. In a distributed system, the states of processes depend on one another due to inter-process communication. <p> To reduce domino effect, Kim et al. [9], Venkatesh et al. [20], and Xu et al. [25] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [6, 7, 18, 19, 24] </ref> and message reordering [23] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. Thus, storage requirement may be large. <p> However, their approach has higher checkpointing overhead since processes do not skip basic checkpoints if they have taken forced checkpoints. Many of the existing recovery algorithms use vector timestamps <ref> [16, 6, 15, 18, 17, 19] </ref> to track dependency between checkpoints and events. Vector timestamps generally result in high message overhead during failure-free operation. The optimistic recovery algorithm proposed by Strom and Yemini [19] suffers from domino effect. <p> Many of the existing recovery algorithms use vector timestamps [16, 6, 15, 18, 17, 19] to track dependency between checkpoints and events. Vector timestamps generally result in high message overhead during failure-free operation. The optimistic recovery algorithm proposed by Strom and Yemini <ref> [19] </ref> suffers from domino effect. The recovery protocols based on vector clock proposed by Peterson and Kearns [15] is synchronous and tolerates single process failure. It requires the channels to be FIFO.
Reference: [20] <author> K. Venkatesh and T. Radhakrishnan. </author> <title> "Optimal Checkpointing and Local Encoding for Domino-free Rollback Recovery". </title> <journal> Information Processing Letters, </journal> <volume> 25 </volume> <pages> 295-303, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: This approach allows maximum process autonomy and has low checkpointing overhead. However, this approach may suffer from the domino effect, in which the processes roll back repeatedly while determining a consistent set of checkpoints. To reduce domino effect, Kim et al. [9], Venkatesh et al. <ref> [20] </ref>, and Xu et al. [25] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging [6, 7, 18, 19, 24] and message reordering [23] have been suggested in the literature to cope with the domino effect.
Reference: [21] <author> Y. M. Wang and W. K. Fuchs. </author> <title> "Lazy checkpoint Coordination for Bounding Rollback Propagation". </title> <type> Technical Report CRHC-92-26, </type> <institution> Coordinated Science Laboratory, University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: This might force the processes to take as many checkpoints as the number of messages if the message reception and transmission are interleaved, resulting in high checkpointing overhead. Wang et al. <ref> [21] </ref> proposed lazy checkpoint coordination for bounding rollback propagation. Like our approach, their technique requires the checkpoint number being piggybacked on the computation messages so that the receiving processes can take an extra checkpoint when required.
Reference: [22] <author> Y. M. Wang and W. K. Fuchs. </author> <title> "Optimistic Message Logging for Independent Check-pointing in Message Passing Systems". </title> <booktitle> In Proc. Symp. on Reliable Distributed Systems, </booktitle> <pages> pages 147-154, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: In the literature, several checkpointing schemes have been proposed for distributed systems. They can be broadly classified into two categories asynchronous and synchronous. In asynchronous checkpointing <ref> [4, 11, 22] </ref>, processes take checkpoints periodically without any coordination with others. To recover from a failure, a process communicates with other 2 processes to determine if their local states are causally related.
Reference: [23] <author> Y. M. Wang and W. K. Fuchs. </author> <title> "Scheduling Message Processing for Reducing Rollback Propagation". </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 204-211, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: To reduce domino effect, Kim et al. [9], Venkatesh et al. [20], and Xu et al. [25] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging [6, 7, 18, 19, 24] and message reordering <ref> [23] </ref> have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. Thus, storage requirement may be large.
Reference: [24] <author> Y. M. Wang, Y. Huang, and W. K. Fuchs. </author> <title> "Progressive Retry for Software Recovery in Distributed Systems". </title> <booktitle> In Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pages 138-144, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: To reduce domino effect, Kim et al. [9], Venkatesh et al. [20], and Xu et al. [25] use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging <ref> [6, 7, 18, 19, 24] </ref> and message reordering [23] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process. Thus, storage requirement may be large.
Reference: [25] <author> Jian Xu and Robert H. B. Netzer. </author> <title> "Adaptive Independent Checkpointing for Reducing Rollback Propagation". </title> <booktitle> In 5 th IEEE Symposium on Parallel and Distributed Processing, </booktitle> <month> December </month> <year> 1993. </year> <month> 31 </month>
Reference-contexts: However, this approach may suffer from the domino effect, in which the processes roll back repeatedly while determining a consistent set of checkpoints. To reduce domino effect, Kim et al. [9], Venkatesh et al. [20], and Xu et al. <ref> [25] </ref> use the dependency tracking and insert checkpoints before processing a new message that introduces dependency. Message logging [6, 7, 18, 19, 24] and message reordering [23] have been suggested in the literature to cope with the domino effect. Asynchronous checkpointing requires multiple checkpoints to be stored at each process.
References-found: 25

