URL: ftp://ftp.cs.virginia.edu/pub/techreports/CS-90-35.ps.Z
Refering-URL: ftp://ftp.cs.virginia.edu/pub/techreports/README.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: FLECS: A Tool for Rapid Prototyping of Mechanisms in Success/Failure Based Languages  
Author: Mark W. Bailey Janalee OBagy 
Abstract: Computer Science Report No. CS-90-35 July 1990 
Abstract-found: 1
Intro-found: 1
Reference: [All88] <author> Lloyd Allison. </author> <title> Continuations Implement Generators and Streams. </title> <type> Technical Report 88/112, </type> <institution> Department of Computer Science, Monash University, </institution> <month> August </month> <year> 1988. </year>
Reference: [Dyb87] <author> R. Kent Dybvig. </author> <title> The SCHEME Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference: [GG83] <author> Ralph E. Griswold and Madge T. Griswold. </author> <title> The Icon Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1983. </year>
Reference-contexts: The language also supports user-defined generators as an extension of the usual procedural abstraction. In the next few sections, we will present a brief overview of the language. For a more complete description, see <ref> [GG83] </ref>. 2.1 Success/Failure In Icon, the evaluation of an expression may or may not produce a value. An expression that does not produce a value is said to fail, while an expression that produces a value is said to succeed.
Reference: [GG86] <author> Ralph E. Griswold and Madge T. Griswold. </author> <title> The Implementation of the Icon Programming Language. </title> <publisher> Princeton University Press, </publisher> <year> 1986. </year>
Reference-contexts: Therefore, we are interested in extending, or changing the Icon language [Gri82][GG83] to reect these innovations in language design. Icon is distributed with a exible interpreter and run-time system. This exibility is seen most notably in the ease with which one may to add new types and run-time operations <ref> [GG86] </ref> and change syntax [GW90]. However, using the Icon system to experiment with language extensions that have pervasive semantic implications, such as scoping or adding first-class procedures, requires extensive modifications to the run-time system. The Icon implementation is large, consisting of over 40,000 lines of C.
Reference: [Gri82] <author> Ralph E. Griswold. </author> <title> The evaluation of expressions in Icon. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(4): </volume> <pages> 563-584, </pages> <month> October </month> <year> 1982. </year>
Reference-contexts: In an effort to achieve this goal, we have designed an interpreter for a subset of Icon. An interpreter is a natural choice since we would like the language implementation to be quickly modifiable. Unlike other interpreters for Icon <ref> [Gri82] </ref> [OG87], ours is written in a form called continuation-passing-style [Ste76]. This describes Icons goal-directed evaluation in terms of continuations, which in many ways is closer to its formal denotational description [Gud86]. Our FLECS: A Tool for Rapid Prototyping of Mechanisms in Success/Failure Based Languages Mark W. <p> If the condition (i &lt; j) is satisfied, the expression will evaluate to j. Otherwise, the expression will fail. The keyword &fail is an expression that always fails. The use of success and failure in Icon subsumes the role of boolean values in other languages <ref> [Gri82] </ref>. As such, Icon does not support a built-in boolean type. Where boolean expressions are used to decide the direction of execution in other languages, Icon uses success and failure. <p> In this case, the if control structure chooses which branch, the then or the else, should be evaluated based on the success or failure of the control clause. This example illustrates why it is said that success and failure direct the evaluation of expressions in Icon <ref> [Gri82] </ref>. Success and failure based evaluation is concise and expressive. For example, in other languages, exceptions are frequently signalled by returning a special value outside the semantic range of the function. Common examples occur with I/O where such conditions as end-of-file need to be signalled.
Reference: [Gri90] <author> Ralph E. Griswold. </author> <title> Version 8 of Icon, </title> <type> Technical Report 90-1d, </type> <institution> University of Arizona, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: The implemented language is a subset of the Icon Version 8 distribution <ref> [Gri90] </ref>. Features not implemented in the language include many of the types and most of the run-time routines. In addition, for ease of implementation, the syntax of the language has been moderately altered. Appendix A provides the grammar for the syntax of the supported features.
Reference: [GW90] <author> Ralph E. Griswold, and Kenneth Walker. </author> <title> Building Variant Translators for Version 8 of Icon, </title> <type> Technical Report 90-4a, </type> <institution> University of Arizona, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: Icon is distributed with a exible interpreter and run-time system. This exibility is seen most notably in the ease with which one may to add new types and run-time operations [GG86] and change syntax <ref> [GW90] </ref>. However, using the Icon system to experiment with language extensions that have pervasive semantic implications, such as scoping or adding first-class procedures, requires extensive modifications to the run-time system. The Icon implementation is large, consisting of over 40,000 lines of C.
Reference: [Gud86] <author> David Gudeman, </author> <title> A Continuation Semantics For Icon Expressions. </title> <type> Technical Report 86-15, </type> <institution> Department of Computer Science, University of Arizona, </institution> <month> April </month> <year> 1986. </year>
Reference-contexts: Unlike other interpreters for Icon [Gri82] [OG87], ours is written in a form called continuation-passing-style [Ste76]. This describes Icons goal-directed evaluation in terms of continuations, which in many ways is closer to its formal denotational description <ref> [Gud86] </ref>. Our FLECS: A Tool for Rapid Prototyping of Mechanisms in Success/Failure Based Languages Mark W. Bailey Janalee OBagy mark@virginia.edu Department of Computer Science University of Virginia Charlottesville, VA 22903 Our goal is to provide a prototyping tool that facilitates the addition of new language mechanisms in success/failure based languages. <p> To better understand its implementation, let us first look at the definition of if for Scheme given in [Haynes86]: 1 For a formal description of Icon in terms of denotational semantics, see <ref> [Gud86] </ref>. (define (eval exp env sk fk) (cond ((number? exp) (sk exp)) ((string? exp) (sk exp)) ((&fail? exp) (fk)) ((symbol? exp) (sk (lookup exp env))) ((if? exp) (eval-if exp env sk fk)) . . (define meaning . . [('if predicate-exp then-exp else-exp) (meaning predicate-exp r (lambda (v) (if v (meaning then-exp
Reference: [Hay87] <author> Christopher T. Haynes. </author> <title> Logic continuations. </title> <journal> The Journal of Logic Programming, </journal> <volume> 4(2) </volume> <pages> 157-176, </pages> <month> June </month> <year> 1987. </year>
Reference: [HF86] <author> Christopher T. Haynes, Daniel P. Friedman, and Mitchell Wand. </author> <title> Obtaining coroutines with continuations. </title> <journal> Computer Languages, </journal> 11(3/4):143-153, 1986. 
Reference-contexts: Note that the author named the main evaluation function meaning rather than the usual eval. 4 Implementation Description This section describes the implementation of our interpreter. As described above, this interpreter is a recursive CPS interpreter based on the <ref> [HF86] </ref> interpreter for Scheme. The description incrementally improves the design of the interpreter until the final version is reached. The complete implementation may be found in appendix B. 4.1 Success and Failure The simplest expressions in Icon are conditional and monogenic expressions. Examples of such include strings, numbers, and variables. <p> The complete implementation may be found in appendix B. 4.1 Success and Failure The simplest expressions in Icon are conditional and monogenic expressions. Examples of such include strings, numbers, and variables. For our interpreter, these expressions represent the basis case for its recursive definition. <ref> [HF86] </ref> (define (fact n k) (if (eq? 0 n) (k 1) (fact (- n 1) (lambda (v) (k (* v n)))) )) (define meaning (lambda (e r k); e = expression, r = environment, k = continuation (if (symbol? e) (k (deref (r identifier))) (match e [('quote literal) literal] [('if predicate-exp <p> The parameter list has the form: ((arg 1 arg 2 ... arg n ) k) where k represents the resumption continuation for the right-most parameter. This technique is also used by <ref> [HF86] </ref>. The recursive call to eval-actuals is made by the success continuation to eval. eval passes a list (parm) containing the value of the evaluated parameter and its resumption continuation. During any particular invocation of eval-actuals, the interpreter dispatches the evaluation of a single parameter. <p> The definition of each function is prepended by the code necessary to perform these bindings. This method is also used by <ref> [HF86] </ref>. 4.5 Return, Suspend and Fail During the evaluation of an expression, the interpreter must choose where program execution (evaluation) will continue. <p> We can add a powerful control structure to such an interpreter by allowing the programmer to access these (already built) continuations. Scheme provides a function, called call-with-current-continuation (call/cc), that provides a general control abstraction to the programmer by giving access to internal continuations. <ref> [HF86] </ref> succinctly describes the operation of call/cc in Scheme: The function [call/cc] must be passed a function of one argument. This argument is in turn passed the current continuation, which is the continuation of the call/cc application, represented as a functional object of one argument.
Reference: [HF87] <author> Christopher T. Haynes and Daniel P. Friedman. </author> <title> Embedding continuations in procedural objects. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(4) </volume> <pages> 582-598, </pages> <month> October </month> <year> 1987. </year>
Reference: [KH89] <author> Richard Kelsey and Paul Hudak. </author> <title> Realistic compilation by program transformation. </title> <booktitle> In Principles of Programming Languages. </booktitle> <pages> pages 281-292, </pages> <year> 1989. </year>
Reference: [OG87] <author> Janalee OBagy and Ralph E. Griswold. </author> <title> A recursive interpreter for the icon programming language. </title> <booktitle> In SIGPLAN 87 Symposium on Interpreters and Interpretive Techniques, </booktitle> <pages> pages 138-149, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: In an effort to achieve this goal, we have designed an interpreter for a subset of Icon. An interpreter is a natural choice since we would like the language implementation to be quickly modifiable. Unlike other interpreters for Icon [Gri82] <ref> [OG87] </ref>, ours is written in a form called continuation-passing-style [Ste76]. This describes Icons goal-directed evaluation in terms of continuations, which in many ways is closer to its formal denotational description [Gud86]. Our FLECS: A Tool for Rapid Prototyping of Mechanisms in Success/Failure Based Languages Mark W.
Reference: [Ree86] <editor> Jonathan A. Rees and William Clinger, eds. </editor> <title> The revised 3 report on the algorithmic language scheme. </title> <journal> SIGPLAN Notices 21, </journal> <volume> 12, </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: Section 4 presents the implementation details of the interpreter. Section 5 details the addition of a very general control abstraction as a demonstration of the interpreters exibility. While an overview of Icon has been provided, it is assumed that the reader has a working knowledge of Scheme <ref> [Ree86] </ref>. 2 An Overview of Icon Icon is a general purpose expression-based programming language. Its predecessor, SNOBOL4, provided a backtracking mechanism during pattern matching for matching strings only. Icon has further incorporated goal-directed evaluation into the entire language with the introduction of success and failure of expressions.
Reference: [Ste76] <author> Guy Lewis Steele Jr. </author> <title> LAMBDA: The Ultimate Declarative. </title> <type> AI Memo 379, </type> <institution> MIT AI Lab, </institution> <month> Novem-ber </month> <year> 1976. </year>
Reference-contexts: In an effort to achieve this goal, we have designed an interpreter for a subset of Icon. An interpreter is a natural choice since we would like the language implementation to be quickly modifiable. Unlike other interpreters for Icon [Gri82] [OG87], ours is written in a form called continuation-passing-style <ref> [Ste76] </ref>. This describes Icons goal-directed evaluation in terms of continuations, which in many ways is closer to its formal denotational description [Gud86]. Our FLECS: A Tool for Rapid Prototyping of Mechanisms in Success/Failure Based Languages Mark W. <p> Every expression has a continuation that represents the remaining computation of the program. A continuation may be viewed as a function of one argument. The argument is required because the current expressions value may affect the control of the remaining computation. Further information on continuations may be found in <ref> [Ste76] </ref> [Ste78][Dyb87][Hay87]. 3.2 Continuation-passing Style The interpreter described in this report is written in CPSa style of programming in which continuations are given explicitly to direct control ow. This implementation technique is known as the continuation-passing style (CPS) [Ste76]. <p> Further information on continuations may be found in <ref> [Ste76] </ref> [Ste78][Dyb87][Hay87]. 3.2 Continuation-passing Style The interpreter described in this report is written in CPSa style of programming in which continuations are given explicitly to direct control ow. This implementation technique is known as the continuation-passing style (CPS) [Ste76]. The use of CPS for this implementation is what will make the modeling of complex and varied control ow simpler and thereby meet the goal of this work. CPS is not specific to interpreters and can be demonstrated by transforming a simple function to CPS. <p> An interesting consequence of converting the definition of fact is that the new definition is tail-recursive, even though the original definition was not. This is true of all functions written in CPS <ref> [Ste76] </ref>. Further, the only computation that is actually done in fact is the calculation of the new actuals for the recursive call to fact. All other computations are done in the newly constructed continuation after the basis case calls its continuation.
Reference: [Ste78] <author> Guy Lewis Steele Jr. RABBIT: </author> <title> a compiler for Scheme. AI Memo 452, </title> <publisher> MIT, </publisher> <month> January </month> <year> 1978. </year> <month> - 19 </month> - 
Reference-contexts: This context may be represented as a procedure that embodies the state of the program at a given point. The procedure may subsequently be called to continue at the point previously saved. Thus the control context is known as the computations continuation <ref> [Ste78] </ref>. Every expression has a continuation that represents the remaining computation of the program. A continuation may be viewed as a function of one argument. The argument is required because the current expressions value may affect the control of the remaining computation.
References-found: 16

