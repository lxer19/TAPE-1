URL: ftp://ftp.cs.ucsb.edu/pub/faculty/su/pods94-jcss.ps
Refering-URL: ftp://ftp.cs.ucsb.edu/pub/faculty/su/pods94.html
Root-URL: http://www.cs.ucsb.edu
Email: stephane.grumbach@inria.fr  su@cs.ucsb.edu  
Title: Finitely Representable Databases  
Author: Stephane Grumbach Jianwen Su flfl 
Date: February 6, 1995 Revised: October 11, 1996 Revised: March 21, 1997  
Address: Rocquencourt BP 105 78153 Le Chesnay, France  Santa Barbara, CA 93106, USA  
Affiliation: I.N.R.I.A.  Computer Science Department University of California  
Abstract: We study infinite but finitely representable databases based on constraints, motivated by new database applications such as those involving spatio-temporal information. We introduce a general definition of finite representation, and define the concept of a query as a generalization of a query over relational databases. We investigate the theory of finitely representable models and prove that it differs from both classical model theory and finite model theory. In particular, we show the failure of most of the well known theorems of logic (compactness, completeness, etc.). An important consequence is that properties such as query satisfiability and containment are undecidable. We illustrate the use of Ehrenfeucht-Frasse games on the expressive power of query languages over finitely representable databases. As a case study, we focus on queries over dense order constraint databases. We consider in particular order-generic queries which are mappings closed under order-preserving bijections, and topological queries, mappings closed under homeomorphisms. We prove that many interesting queries such as topological connectivity are not first-order definable with dense order constraints. We then consider an inflationary fixpoint query language, and prove that it captures exactly all PTIME order-generic queries. Finally, we give a rapid survey of recent results for more general contexts, such as polynomial constraints. y An extended abstract of this paper appeared as [GS94]. fl Work supported in part by Esprit Project BRA AMUSING. flfl Work supported in part by NSF grants IRI-9109520 and IRI-9117094 and NASA grant NAGW-3888. A part of work was done while visiting I.N.R.I.A. 
Abstract-found: 1
Intro-found: 1
Reference: [ACGK94] <author> F. Afrati, S. Cosmadakis, S. Grumbach, and G. Kuper. </author> <title> Expressiveness of linear vs. polynomial constraints in database query languages. </title> <booktitle> In Proc. Workshop on the Principles and Practice of Constraint Programming, </booktitle> <year> 1994. </year>
Reference-contexts: They are quite intuitive when the language does not contain arithmetic operations, and is restricted to equality and an order relation. Once arithmetic is allowed, the combinatorics becomes rather tedious, though in some cases, proofs can still be carried out <ref> [ACGK94] </ref>. Complexity theoretic arguments are efficient to prove non-definability results. It has been shown that some rather low upper bounds, in terms of Boolean circuits, of the relational algebra over finite structures carry over in the case of finitely representable structures.
Reference: [AHV95] <author> S. Abiteboul, R. Hull, and V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The classical network, hierarchical, and relational models [Ull82] are suitable for conventional database applications such as business applications. Extensions to structured data types, such as nested relations, complex objects, and object-oriented models, allow the modeling of more complex semantic relationships between data items <ref> [AHV95] </ref>. On the other hand, the ever increasing computational power enables the management and manipulation of wider collections of data and information from the real world. The information fundamental to new applications (e.g. scientific, geographical, digital map/image libraries, etc.) involve among other things numerical quantities, time, spatial shapes, etc. <p> We first review the DATALOG : language, discuss a few example of queries, and then prove the PTIME characterization result. 32 The language DATALOG : was originally introduced in [KKR95]. A DATALOG : query has the same syntax as Datalog <ref> [AHV95] </ref> except that negation and constraints involving 6 are allowed in the body of its rules. <p> Finally a subtle point under the inflationary semantics is to delay the connectivity check until the computation of Conn is completed. This can be dealt with using the timestamp technique described in <ref> [AHV95] </ref> (in the proof of Lemma 14.4.4). ut Note that in the above example, the number of sweeps needed in the DATALOG : program is roughly the number of necessary turns the input relation contains, which depends on the number of constraints in the input. <p> Clearly, simulating the moves of the Turing machine M in DATALOG : can be done in the standard way (e.g., [CH80, Var82, Imm86, HS91, HS93]; see also <ref> [AHV95] </ref>). The main difficulties of the proof are the encoding and decoding steps. We next show how this can be done in DATALOG : . Intuitively, the encoding relies on a syntactic normal form of the instances.
Reference: [Ajt83] <author> M. Ajtai. </author> <title> S 1 1 formulae on finite structures. </title> <journal> Ann. of Pure and Applied Logic, </journal> <volume> 24 </volume> <pages> 1-48, </pages> <year> 1983. </year>
Reference-contexts: The reduction is again obviously in AC 0 . ut It is interesting to note here that for the case where k &gt; 3, the proof can be done by an alternative AC 0 reduction from the Boolean function PARITY that is known to be outside of AC 0 <ref> [FSS84, Ajt83] </ref>. The PARITY function takes as input n Boolean variables and returns true if an even number of variables have the value 1, and false otherwise. Suppose x 1 ; :::; x n are input Boolean variables for PARITY. Again we fix k and consider a 3-dimensional subspace.
Reference: [AV91] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43(1) </volume> <pages> 62-124, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Let PTIME Q be the set of all 6-generic queries computable in PTIME. We show that DATALOG : captures the set of all queries in PTIME Q . This extends the result that inflationary DATALOG : captures all relational queries in the context of finite databases <ref> [AV91] </ref>. 35 q (a 0 ; b 0 ) p (a 1 ; b 1 ) p T (a 4 ; b 4 ) p (a 5 ; b 5 ) (a 6 ; b 6 ) p p (a 7 ; b 7 ) Theorem 6.6 DATALOG : = PTIME
Reference: [BDLW96] <author> M. Benedikt, G. Dong, L. Libkin, and L. Wong. </author> <title> Relational expressive power of constraint query languages. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <year> 1996. </year>
Reference-contexts: Finally, we prove that inflationary Datalog with negation expresses exactly the set of all dense-order queries computable in PTIME. This give a complete characterization of the complexity class, extending the classical result for relational queries [Var82, Imm86]. More recently, Benedikt, Dong, Libkin, and Wong <ref> [BDLW96] </ref> used nonstandard techniques to obtain some significant generalization of non-definability results for constraint query languages. They proved that the parity query is not expressible by first-order constraint languages with o-minimal arithmetic. <p> In this paper, we only consider the genericity notion in the original form, though the results can be generalized to include constants. Genericity reflects logical data independence [Ull82] in database systems. Constraint databases give raise to new concepts of genericity <ref> [PVV94, BDLW96] </ref> that also reflect logical independence to various degrees. In the absence of a universal concept of genericity, we first adopt a general definition of a query which does not have any consistency criterion. Definition 4.1 Let A be an L-structure, a schema, and R a k-ary relation symbol. <p> Nevertheless, a weaker result holds. More recently, it 24 was shown that each L = -generic query in L fi is definable with the equality and the order relation only (i.e., in L 6 ) <ref> [BDLW96] </ref>, which improves a similar result on the linear language (L fi without the multiplication fi) proved earlier in [PVV95, ST96]. These results have important consequences on the expressive power of the languages with respect to relational queries. <p> is known that AC 0 TC 0 NC 1 and it is generally believed that the inclusion is strict. 41 Expressive Power The most significant result on the expressive power of constraint languages is that parity and transitive closure over finite databases are not expressible in FO (6; +; fi) <ref> [BDLW96, BL96] </ref>, which extends Lemma 5.6. The proof uses a novel technique from nonstandard analysis. Prior to this result, it was proved that the parity and transitive queries are not expressible in FO (6; +) [GST94, PVV95, ST96] using different techniques. <p> the range of variables is restricted to the set of all elements occurring in the database and the query itself.) It is now known that (1) FO FO adom [HS94], (2) FO (6; +) FO (6; +) adom [PVV95], and (3) FO (6; +; fi) FO (6; +; fi) adom <ref> [BDLW96, BL96] </ref>. As far as queries over general finitely representable databases are concerned, [GS96a] uses first-order reductions to prove that all queries in Item 2 of Theorem 5.3 are not definable in FO (6; +; fi).
Reference: [BKR86] <author> M. Ben-Or, D. Kozen, and J. Reif. </author> <title> The complexity of elementary algebra and geometry. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 32(2) </volume> <pages> 251-264, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: The NC result follows from the decidability of the theory of real closed fields [Tar51] and its tractability for the case of a fixed number of variables <ref> [BKR86, Ren92] </ref>. While this remains the best known upper-bound, there are several improvements in various subcases, depending on whether the input database is finite or consists of only linear constraints (i.e. fi does not occur), and whether the query language contains the multiplication.
Reference: [BL96] <author> M. Benedikt and L. Libkin. </author> <title> On the structure of queries in constraint query languages. </title> <booktitle> In Proc. 11th Annual IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1996. </year>
Reference-contexts: The results for the restricted cases are summarized in the following table. FO (6; +) FO (6; +; fi) Finite databases AC 0 [GST94] TC 0 <ref> [BL96] </ref> Linear constraint databases NC 1 [GS96a] NC [KKR95] The AC 0 result for FO (6; +) for finite databases follows from a result in [GST94] that establishes the AC 0 bound for a subclass of linear constraint databases. <p> This technique was further extended to show the NC 1 bound for the general case in [GS96a]. On the other hand, Benedikt and Libkin <ref> [BL96] </ref> studied finite databases and proved the TC 0 bound for queries in FO (6; +; fi). The class TC 0 extends AC 0 with threshold gates. <p> is known that AC 0 TC 0 NC 1 and it is generally believed that the inclusion is strict. 41 Expressive Power The most significant result on the expressive power of constraint languages is that parity and transitive closure over finite databases are not expressible in FO (6; +; fi) <ref> [BDLW96, BL96] </ref>, which extends Lemma 5.6. The proof uses a novel technique from nonstandard analysis. Prior to this result, it was proved that the parity and transitive queries are not expressible in FO (6; +) [GST94, PVV95, ST96] using different techniques. <p> the range of variables is restricted to the set of all elements occurring in the database and the query itself.) It is now known that (1) FO FO adom [HS94], (2) FO (6; +) FO (6; +) adom [PVV95], and (3) FO (6; +; fi) FO (6; +; fi) adom <ref> [BDLW96, BL96] </ref>. As far as queries over general finitely representable databases are concerned, [GS96a] uses first-order reductions to prove that all queries in Item 2 of Theorem 5.3 are not definable in FO (6; +; fi).
Reference: [CGK96] <author> J. Chomicki, D. Q. Goldin, and G. M. Kuper. </author> <title> Variable independence and aggregation closure. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <year> 1996. </year>
Reference-contexts: Low upper bounds of the data complexity for both the relational calculus and inflationary Datalog with negation over constraint databases have been obtained in [KKR95]. This shows the feasibility of this approach, which has been pursued in <ref> [Rev90, Kup93a, KG94, PVV94, KPV95, VGV95, CGK96, GS96b] </ref>. The goal of this paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages and the corresponding model theory. <p> In spite of the seeming advantages, constraint databases are still in the theoretical investigation stage. Indeed many questions need to be answered before efficient implementation can become possible, including dealing with finite precision arithmetic [GS96b], aggregate functions <ref> [Kup93a, CGK96] </ref>, indexing [KRVV93], etc. 42 Acknowledgments The authors wish to thank Victor Vianu and the referees for helpful comments.
Reference: [CH80] <author> A. K. Chandra and D. Harel. </author> <title> Computable queries for relational data bases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-78, </pages> <year> 1980. </year>
Reference-contexts: of query languages for infinite recursive databases were reported by Hirst and Harel in [HH93], where two classes of recursive databases are considered, and it is shown that: (1) Quantifier-free first-order logic is complete on the class of all recursive databases, and (2) a version of Chandra and Harel's QL <ref> [CH80] </ref> is complete on highly symmetric databases. The first result of [HH93] indicates that the class of recursive structures is much too general for database purposes, since quantifier-free first-order logic is already complete for this class. Therefore, many basic queries are simply not computable (projection, graph connectivity, etc.). <p> Specifically, this paper makes the following contributions. First, the notion of a finitely representable database is precisely defined in any context. Second, we define the notions of Boolean and non-Boolean queries and show that they generalize the classical notion of query introduced by Chandra and Harel <ref> [CH80, CH82] </ref>. It is further established that the quantifier elimination property of the theory of a first-order structure is a necessary and sufficient condition for a first-order formula to define a (non-)Boolean query. <p> We then study when a logic, such as first-order logic, can be used as a query language, and define the data complexity of a query as a function of the input database size. The notion of a (relational) database query was originally introduced by Chandra and Harel <ref> [CH80, CH82] </ref> as a mapping q from finite structures over a given signature to finite relations of a fixed arity, which is partial recursive and satisfies the following consistency criterion: If two structures over , I and J, are isomorphic by an isomorphism , then the answers q (I) and q <p> In other words, it was shown that PTIME relational input/output inflationary DATALOG : PTIME dense-order input/input = PTIME Q . In our result, PTIME Q denotes a set of queries over dense-order constraint databases, and not over relational databases as defined in <ref> [CH80] </ref>. The remainder of the section is devoted to the proof of Theorem 6.6. Let Q be a PTIME 6-generic query and M be the Turing machine with a one way infinite tape that computes Q. We construct a DATALOG : program P Q that simulates M . <p> Clearly, simulating the moves of the Turing machine M in DATALOG : can be done in the standard way (e.g., <ref> [CH80, Var82, Imm86, HS91, HS93] </ref>; see also [AHV95]). The main difficulties of the proof are the encoding and decoding steps. We next show how this can be done in DATALOG : . Intuitively, the encoding relies on a syntactic normal form of the instances.
Reference: [CH82] <author> A. K. Chandra and D. Harel. </author> <title> Structure and complexity of relational queries. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(1) </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: Specifically, this paper makes the following contributions. First, the notion of a finitely representable database is precisely defined in any context. Second, we define the notions of Boolean and non-Boolean queries and show that they generalize the classical notion of query introduced by Chandra and Harel <ref> [CH80, CH82] </ref>. It is further established that the quantifier elimination property of the theory of a first-order structure is a necessary and sufficient condition for a first-order formula to define a (non-)Boolean query. <p> We then study when a logic, such as first-order logic, can be used as a query language, and define the data complexity of a query as a function of the input database size. The notion of a (relational) database query was originally introduced by Chandra and Harel <ref> [CH80, CH82] </ref> as a mapping q from finite structures over a given signature to finite relations of a fixed arity, which is partial recursive and satisfies the following consistency criterion: If two structures over , I and J, are isomorphic by an isomorphism , then the answers q (I) and q
Reference: [CK73] <author> C. C. Chang and H. J. Keisler. </author> <title> Model Theory, </title> <booktitle> volume 73 of Studies in Logic. </booktitle> <publisher> North-Holland, </publisher> <year> 1973. </year>
Reference-contexts: The structure Q satisfies the theory of dense order without endpoints. It is complete and admits the elimination of quantifiers <ref> [CK73] </ref>. More formally, Theorem 2.1 [CK73] For each formula ' in L 6 , there exists a quantifier-free formula in L 6 such that Q logically implies the equivalence of ' and . <p> The structure Q satisfies the theory of dense order without endpoints. It is complete and admits the elimination of quantifiers <ref> [CK73] </ref>. More formally, Theorem 2.1 [CK73] For each formula ' in L 6 , there exists a quantifier-free formula in L 6 such that Q logically implies the equivalence of ' and . The structure R satisfies the theory of ordered real closed fields which is also complete and admits the elimination of quantifiers [Tar51]. <p> The set Zof integers for instance is not L 6 - representable over Q since each quantifier-free formula in L 6 represents a finite union of intervals over Q (a consequence of Lemma 1.5.2 of <ref> [CK73] </ref>). In fact, the same holds for R. 8 Proposition 2.9 Each L fi -representable monadic relation over R defines a finite set of intervals over R. Proof: Consider an L fi -representable monadic relation represented by a quantifier-free formula in disjunctive normal form. <p> Then the result follows from the decidability of the theory of A. ut The theory of dense order without endpoints and the theory of real closed fields mentioned above are recursive <ref> [CK73] </ref>. Therefore, validity over finitely representable databases over, for instance, Q and R, is co-r.e. It follows from Theorem 3.4 that it is not r.e. <p> Does every formula define an (L-)generic query with respect to Definition 4.2? Question Q1 is related to the quantifier elimination property of first-order theories. For the contexts Q and R considered here, their theories admit quantifier elimination and equivalent quantifier-free formulas can be effectively obtained <ref> [CK73, Tar51] </ref>. It is not always the case as shown in the following example. Example 4.8 The theory of hN; 6; +i (a.k.a. Presburger arithmetic) does not admit quantifier elimination. <p> Recall that Q is a model of the theory of dense orders without endpoints. The theory is decidable and admits quantifier elimination procedures <ref> [CK73] </ref>. Let R 6 = (R; 6) be the structure of the real dense order.
Reference: [Cod70] <author> E. F. Codd. </author> <title> A relational model of data for large shared data banks. </title> <journal> Communications of ACM, </journal> <volume> 13(6) </volume> <pages> 377-387, </pages> <year> 1970. </year>
Reference-contexts: Our framework follows and generalizes the pioneer work by Kanellakis, Kuper, and Revesz [KKR95] who introduced constraint query languages. The novel idea there is to generalize the relations of the relational model <ref> [Cod70] </ref> by defining generalized tuples as conjunctions of constraints. For instance, the formula x 2 + y 2 = 1 ^ x 6 0 defines a binary generalized tuple. A generalized, or finitely representable, relation is then a finite set (disjunction) of such tuples. <p> A k-ary finitely representable relation (or generalized relation [KKR95]) is a finite set of k-ary generalized tuples. In this framework, a tuple [a; b] of the classical relational model <ref> [Cod70] </ref> is an abbreviation of the formula (x = a ^ y = b) involving only the equality symbol and constants. A finitely representable database I over is a collection of finitely representable relations, each associated to a relation name in the schema.
Reference: [Col75] <author> G. E. Collins. </author> <title> Quantifier elimination for real closed fields by cylindric decompositions. </title> <booktitle> In Proc. 2nd GI Conf. Automata Theory and Formal Languages, volume 35 of Lecture Notes in Computer Science, </booktitle> <pages> pages 134-83. </pages> <publisher> Springer-Verlag, </publisher> <year> 1975. </year> <month> 43 </month>
Reference-contexts: The results for monadic relations admit some generalizations to arbitrary arities. In particular, it can be verified for instance that the number of connected components of an L fi -representable k-ary relation is finite. The proof follows from the cylindrical algebraic decomposition of <ref> [Col75] </ref> (see also [Tar51, Ren92]). 3 Finitely Representable Model Theory In this section, we analyze the differences between finite model theory, finitely representable model theory, and classical model theory.
Reference: [Com88] <author> K. J. Compton. </author> <title> 0-1 laws in logic and combinatorics. </title> <editor> In I. Rival, editor, </editor> <booktitle> NATO Adv. Study Inst. on Algorithms and Order, </booktitle> <pages> pages 353-383. </pages> <address> D. </address> <publisher> Reidel, </publisher> <year> 1988. </year>
Reference-contexts: This fails in presence of an order, since every neighborhood based on Gaifman's distance contains the whole domain. Techniques based on asymptotic probabilities of the truth of sentences also fail in presence of an order or arithmetic. Some results were obtained for very specific languages (see <ref> [Com88] </ref>). They do not carry over in the general case.
Reference: [DMM94] <author> L. Van den Dries, A. Macintyre, and D. </author> <title> Marker. The elementary theory of restricted analytic fields with exponentiation. </title> <journal> Annals of Mathematics, </journal> <year> 1994. </year>
Reference-contexts: Third, we examine the theory of finitely representable models and prove that the compactness 3 and the completeness theorems of classical first-order logic fail for finitely representable models under o-minimal context structures <ref> [DMM94] </ref>. We also show that satisfiability is not recursive, and that if the context is decidable, validity over finitely representable models is co-r.e. Consequently, the basic properties including query satisfiability, containment, and equivalence are undecidable. <p> The result holds since each monadic relation is a finite union of tuples, which in turn is a finite set of intervals. ut This property holds more generally for o-minimal signatures <ref> [DMM94] </ref>, such as for instance reals with exponentiation. The results for monadic relations admit some generalizations to arbitrary arities. In particular, it can be verified for instance that the number of connected components of an L fi -representable k-ary relation is finite. <p> We now prove the failure of the Compactness theorem for o-minimal context structures. Assume that L is a first-order language with an order predicate. Let A be an L-structure of an ordered domain A. The language L is o-minimal <ref> [DMM94] </ref> over A if every subset of A definable in L over A is a finite union of 9 intervals. We say in the sequel that the context structure is o-minimal.
Reference: [Dri82] <author> L. Van den Dries. </author> <title> Remarks on Tarski's problem concerning (r; +; fi; exp). </title> <booktitle> In Logic Colloquium, </booktitle> <publisher> North-Holland, </publisher> <address> 1982. </address> <publisher> Elsevier. </publisher>
Reference-contexts: In particular, Van den Dries showed that the extension of the theory of real closed fields to a language with an exponential function, f=; 6; +; fi; e x ; 0; 1g, does not admit a quantifier elimination procedure <ref> [Dri82] </ref>. For Question Q2, we first consider the case of Boolean query expressions, and show that they define generic queries. 18 Proposition 4.9 Let A be an L-structure, and a database schema.
Reference: [EFT84] <author> H. D. Ebbinghaus, J. Flum, and W. Thomas. </author> <title> Mathematical Logic. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Finally, open problems are discussed in Section 8. 2 Finitely Representable Databases In this section, we review the basic notions of first-order languages, structures, and theories (for more details see <ref> [End72, EFT84] </ref>), and introduce finitely representable models. Throughout the whole paper, we consider 4 only countable first-order languages with equality. 2.1 First-Order Languages, Structures, and Theories A first-order language is a set consisting of predicate, function, and constant symbols.
Reference: [Ehr61] <author> A. Ehrenfeucht. </author> <title> An application of games to the completeness problem for formalized theories. </title> <journal> Fund. Math, </journal> <volume> 49, </volume> <year> 1961. </year>
Reference-contexts: In particular, none of the previous tools are known to be applicable in the presence of some regular mathematical structure such as an order relation for instance. Indeed, the presence of a total order implies the collapse of Gaifman's distance. Ehrenfeucht-Frasse games <ref> [Fra54, Ehr61] </ref> are among the few tools which apply to finitely representable structures. They are quite intuitive when the language does not contain arithmetic operations, and is restricted to equality and an order relation.
Reference: [End72] <author> H. B. Enderton. </author> <title> A Mathematical Introduction to Logic. </title> <publisher> Academic Press, Inc., </publisher> <year> 1972. </year>
Reference-contexts: Finally, open problems are discussed in Section 8. 2 Finitely Representable Databases In this section, we review the basic notions of first-order languages, structures, and theories (for more details see <ref> [End72, EFT84] </ref>), and introduce finitely representable models. Throughout the whole paper, we consider 4 only countable first-order languages with equality. 2.1 First-Order Languages, Structures, and Theories A first-order language is a set consisting of predicate, function, and constant symbols. <p> Example 4.8 The theory of hN; 6; +i (a.k.a. Presburger arithmetic) does not admit quantifier elimination. For example, the set of even numbers defined by the formula (x) 9z (x = z + z) is not definable by a quantifier-free formula <ref> [End72] </ref>. ut It should be noted that the functions allowed in the language play a fundamental role in the quantifier elimination procedure.
Reference: [Fag76] <author> R. Fagin. </author> <title> Probabilities on finite models. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 41(1) </volume> <pages> 50-58, </pages> <year> 1976. </year>
Reference-contexts: The failure of the main theorems of classical model theory suggests the need to develop new techniques for studying finitely representable structures. Powerful tools have been developed for finite model theory, such as the locality property of Gaifman [Gai81], or the 0/1 laws by Fagin <ref> [Fag76] </ref>, however, the model theory of finitely representable structures differs from finite model theory. In particular, none of the previous tools are known to be applicable in the presence of some regular mathematical structure such as an order relation for instance.
Reference: [Fag93] <author> R. Fagin. </author> <title> Finite model theory a personal perspective. </title> <journal> Theoretical Computer Science, </journal> <volume> 116(1) </volume> <pages> 3-31, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Specifically, we study first-order logic when the semantics is restricted to finitely representable models. We prove that the model theory of finitely representable structures differs strongly from the classical model theory of all structures. In particular, like in the case of finite model theory (see the survey by Fagin <ref> [Fag93] </ref>), most of the classical theorems of logic including the compactness and the completeness theorems fail for finitely representable structures. This phenomenon holds for various 2 strong restrictions on the class of structures. <p> We shall see that the theory of finitely representable models differs from classical model theory, and prove that, as for finite model theory <ref> [Fag93] </ref>, the compactness theorem fails, and the validity over finitely representable models is in general co-r.e. (co-recursively enumerable) and not r.e. The finitely representable model theory also differs from the metafinite model theory [GG94], which is restricted to finite structures in an infinite mathematical context. <p> It follows from Church's Theorem that, as soon as the language contains some relation symbol that is not unary, the set of valid first-order sentences is not co-r.e. The contrary holds for finite model theory <ref> [Fag93] </ref>. The set of first-order sentences valid over finite structures is co-r.e. and Trakhtenbrot proved [Tra50] that it is not r.e. A similar phenomenon holds for finitely representable models. We first prove the following.
Reference: [Fra54] <author> R. Frasse. </author> <title> Sur les classifications des systemes de relations. </title> <type> Publ. </type> <institution> Sci. Univ Alger, I:1, </institution> <year> 1954. </year>
Reference-contexts: In particular, none of the previous tools are known to be applicable in the presence of some regular mathematical structure such as an order relation for instance. Indeed, the presence of a total order implies the collapse of Gaifman's distance. Ehrenfeucht-Frasse games <ref> [Fra54, Ehr61] </ref> are among the few tools which apply to finitely representable structures. They are quite intuitive when the language does not contain arithmetic operations, and is restricted to equality and an order relation.
Reference: [FSS84] <author> M. Furst, J. B. Saxe, and M. Sipser. </author> <title> Parity, circuits, and the polynomial-time hierarchy. </title> <journal> Math. Syst. Theory, </journal> <volume> 17 </volume> <pages> 13-27, </pages> <year> 1984. </year>
Reference-contexts: The reductions can be done in AC 0 . Since MAJORITY 25 1 2 3 4 5 6 2 4 6 is not in AC 0 <ref> [FSS84] </ref> while FO AC 0 (Theorem 5.2), it follows that the region connectivity, and the at least and exactly one hole queries are not definable in FO. Formally, we should consider a relational majority problem corresponding to the problem on Boolean variables. The correspondence is straightforward. <p> The reduction is again obviously in AC 0 . ut It is interesting to note here that for the case where k &gt; 3, the proof can be done by an alternative AC 0 reduction from the Boolean function PARITY that is known to be outside of AC 0 <ref> [FSS84, Ajt83] </ref>. The PARITY function takes as input n Boolean variables and returns true if an even number of variables have the value 1, and false otherwise. Suppose x 1 ; :::; x n are input Boolean variables for PARITY. Again we fix k and consider a 3-dimensional subspace. <p> Proof: The proof is based on reductions from the Boolean function HALF which outputs 1 if exactly half of its inputs have the value 1 and the other half 0. It can be verified that using HALF gates, one can 28 compute MAJORITY by circuits of constant depth <ref> [FSS84] </ref>, which means MAJORITY reduces to HALF via AC 0 reductions. Therefore HALF is not in AC 0 .
Reference: [Gai81] <author> H. Gaifman. </author> <title> On local and non local properties. </title> <editor> In J. Stern, editor, </editor> <booktitle> Proc. Herbrand Symposium Logic Colloquium, </booktitle> <pages> pages 105-135. </pages> <publisher> North Holland, </publisher> <year> 1981. </year>
Reference-contexts: The failure of the main theorems of classical model theory suggests the need to develop new techniques for studying finitely representable structures. Powerful tools have been developed for finite model theory, such as the locality property of Gaifman <ref> [Gai81] </ref>, or the 0/1 laws by Fagin [Fag76], however, the model theory of finitely representable structures differs from finite model theory. In particular, none of the previous tools are known to be applicable in the presence of some regular mathematical structure such as an order relation for instance. <p> Gaifman <ref> [Gai81] </ref> proved that first-order logic was local in a topological sense. This fails in presence of an order, since every neighborhood based on Gaifman's distance contains the whole domain. Techniques based on asymptotic probabilities of the truth of sentences also fail in presence of an order or arithmetic.
Reference: [GG94] <author> E. Gradel and Y. Gurevich. </author> <title> Metafinite model theory. </title> <editor> In D. Leivant, editor, </editor> <booktitle> Logic and Computational Complexity, number 960 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1994. </year>
Reference-contexts: This phenomenon holds for various 2 strong restrictions on the class of structures. In particular, the model theory of recursive structures, studied in [HH94], also differs strongly from classical model theory. Finitely representable structures present also similarities with meta-finite structures <ref> [GG94] </ref>. In this later case though the structures combine an infinite mathematical context with a finite structure. The failure of the main theorems of classical model theory suggests the need to develop new techniques for studying finitely representable structures. <p> The finitely representable model theory also differs from the metafinite model theory <ref> [GG94] </ref>, which is restricted to finite structures in an infinite mathematical context. Nevertheless, their model theory offers some similarities. We prove the failure of important results of model theory in the case of finitely representable models under some context structures. <p> Some results were obtained for very specific languages (see [Com88]). They do not carry over in the general case. Gradel and Gurevich presented some results in this direction for metafinite structures <ref> [GG94] </ref>. 13 4 Queries and Query Languages We now define the fundamental concept of a query and introduce various subclasses of queries generalizing the classical generic relational queries, such as order-generic or topological queries. We illustrate the definitions with examples from various fields, including geometry and graph theory.
Reference: [GS94] <author> S. Grumbach and J. Su. </author> <title> Finitely representable databases (extended abstract). </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <year> 1994. </year>
Reference: [GS95] <author> S. Grumbach and J. Su. </author> <title> Dense order constraint databases. </title> <booktitle> In Proc. 14th ACM Symp. on Principles of Database Systems, </booktitle> <address> San Jose, </address> <month> May </month> <year> 1995. </year>
Reference-contexts: It is suitable for expressing geometrical and topological queries, as shown by the examples. Like for the relational model, equivalent algebras were proposed [KG94, PVV94, GST94]. More powerful languages such as Datalog have also been studied <ref> [KKR95, GS95] </ref>. Practical implementation issues, such as indexing of finitely representable databases [KRVV93], have been considered, but are still among the most fundamental research issues in this field.
Reference: [GS96a] <author> S. Grumbach and J. Su. </author> <title> Queries with arithmetical constraints. </title> <booktitle> Theoretical Computer Science, </booktitle> <year> 1996. </year> <note> (To appear) (An extended abstract appeared in Proc. Int. Conf. on Principles and Practice of Constraint Programming (CP95) under the title First-order Definability over Constraint Databases). </note>
Reference-contexts: They proved that the parity query is not expressible by first-order constraint languages with o-minimal arithmetic. These negative results were used to further establish the non-definability of interesting topological queries by means of first-order reductions in <ref> [GS96a] </ref>. These queries include the ones considered in this paper and also the minimal spanning tree query that was raised as an open problem in [KKR95]. We give a brief survey of these recent results on complexity and expressive power in Section 7. The paper is organized as follows. <p> In terms of the proof techniques, the non-definability results are mostly shown by a combination of data complexity results and AC 0 -reductions. (Alternative first-order 21 reductions were used in <ref> [GS96a] </ref>.) We also illustrate the use of Ehrenfeucht-Frasse games in proving the language equivalence and non-definability results. Recall that Q is a model of the theory of dense orders without endpoints. The theory is decidable and admits quantifier elimination procedures [CK73]. <p> In particular, since the parity of the cardinality of a relation and the graph transitive closure are not expressible in L 6 by Theorem 5.3 (iv), it follows that they are not expressible in L fi . Moreover, in <ref> [GS96a] </ref>, first-order reductions [Imm87] were used to show that many queries including the minimum spanning tree are not expressible in L fi . Lemma 5.4 The queries convexity and k-convex covering for each k &gt; 0 are definable in FO. <p> The results for the restricted cases are summarized in the following table. FO (6; +) FO (6; +; fi) Finite databases AC 0 [GST94] TC 0 [BL96] Linear constraint databases NC 1 <ref> [GS96a] </ref> NC [KKR95] The AC 0 result for FO (6; +) for finite databases follows from a result in [GST94] that establishes the AC 0 bound for a subclass of linear constraint databases. This technique was further extended to show the NC 1 bound for the general case in [GS96a]. <p> 1 <ref> [GS96a] </ref> NC [KKR95] The AC 0 result for FO (6; +) for finite databases follows from a result in [GST94] that establishes the AC 0 bound for a subclass of linear constraint databases. This technique was further extended to show the NC 1 bound for the general case in [GS96a]. On the other hand, Benedikt and Libkin [BL96] studied finite databases and proved the TC 0 bound for queries in FO (6; +; fi). The class TC 0 extends AC 0 with threshold gates. <p> As far as queries over general finitely representable databases are concerned, <ref> [GS96a] </ref> uses first-order reductions to prove that all queries in Item 2 of Theorem 5.3 are not definable in FO (6; +; fi).
Reference: [GS96b] <author> S. Grumbach and J. Su. </author> <title> Towards practical constraint databases. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <year> 1996. </year> <month> 44 </month>
Reference-contexts: Low upper bounds of the data complexity for both the relational calculus and inflationary Datalog with negation over constraint databases have been obtained in [KKR95]. This shows the feasibility of this approach, which has been pursued in <ref> [Rev90, Kup93a, KG94, PVV94, KPV95, VGV95, CGK96, GS96b] </ref>. The goal of this paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages and the corresponding model theory. <p> In spite of the seeming advantages, constraint databases are still in the theoretical investigation stage. Indeed many questions need to be answered before efficient implementation can become possible, including dealing with finite precision arithmetic <ref> [GS96b] </ref>, aggregate functions [Kup93a, CGK96], indexing [KRVV93], etc. 42 Acknowledgments The authors wish to thank Victor Vianu and the referees for helpful comments.
Reference: [GST94] <author> S. Grumbach, J. Su, and C. Tollu. </author> <title> Linear constraint query languages: Expressive power and complexity. In Logic and Computational Complexity: </title> <booktitle> International Workshop LCC '94. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The relational calculus over finitely representable relations constitutes a constraint query language which admits an efficient bottom-up and declarative semantics. It is suitable for expressing geometrical and topological queries, as shown by the examples. Like for the relational model, equivalent algebras were proposed <ref> [KG94, PVV94, GST94] </ref>. More powerful languages such as Datalog have also been studied [KKR95, GS95]. Practical implementation issues, such as indexing of finitely representable databases [KRVV93], have been considered, but are still among the most fundamental research issues in this field. <p> The result was recently extended to classes of linear constraint databases, called k-bounded, where the number of occurrences of the addition symbol in each constraint is bounded <ref> [GST94] </ref>. Since numerous examples of interesting queries, such as graph connectivity or region connectivity, are not in AC 0 , they are not expressible in first-order logic with dense-order, or linear constraints. We also investigate other criteria such as the invariance of the properties. <p> Indeed, any model of S must contain an infinite sequence of disjoint closed segments. By o-minimality, it is not definable in L, and therefore not finitely representable. ut The failure of the Compactness Theorem for restricted classes of models of interest in computer science was also investigated in <ref> [HH94, GST94] </ref>. Theorem 3.2 admits an immediate corollary, namely the failure of the Completeness Theorem. Corollary 3.3 The Completeness Theorem fails for finitely representable models in an o-minimal context. After the Compactness Theorem, another fundamental corollary of the Completeness Theorem fails. <p> Due to their equivalence, we only use FO in the formal statements and proofs in the remainder of the section. The data complexity of FO queries has been studied in <ref> [KKR95, KG94, GST94] </ref>. In [KG94], Kanellakis and Goldin showed an AC 0 upper-bound for FO queries on normalized inputs. This result is further extended in [GST94] to an extension of FO with the addition operation. <p> The data complexity of FO queries has been studied in [KKR95, KG94, GST94]. In [KG94], Kanellakis and Goldin showed an AC 0 upper-bound for FO queries on normalized inputs. This result is further extended in <ref> [GST94] </ref> to an extension of FO with the addition operation. Theorem 5.2 ([KG94, GST94]) The data complexity of each query in FO is in AC 0 . <p> This encoding itself is not in AC 0 . An algebra working on the representation in terms of finite relations was developed which simulates first-order operations on the dense-order constraint databases. This algebra is shown to be in AC 0 . An alternative proof is given in <ref> [GST94] </ref>, which does not require an encoding in terms of finite relations, and moreover the AC 0 upper bound applies to a wider class. We now study the definability of numerous queries in the first-order query language for dense-order constraint databases. <p> The results for the restricted cases are summarized in the following table. FO (6; +) FO (6; +; fi) Finite databases AC 0 <ref> [GST94] </ref> TC 0 [BL96] Linear constraint databases NC 1 [GS96a] NC [KKR95] The AC 0 result for FO (6; +) for finite databases follows from a result in [GST94] that establishes the AC 0 bound for a subclass of linear constraint databases. <p> FO (6; +) FO (6; +; fi) Finite databases AC 0 <ref> [GST94] </ref> TC 0 [BL96] Linear constraint databases NC 1 [GS96a] NC [KKR95] The AC 0 result for FO (6; +) for finite databases follows from a result in [GST94] that establishes the AC 0 bound for a subclass of linear constraint databases. This technique was further extended to show the NC 1 bound for the general case in [GS96a]. <p> The proof uses a novel technique from nonstandard analysis. Prior to this result, it was proved that the parity and transitive queries are not expressible in FO (6; +) <ref> [GST94, PVV95, ST96] </ref> using different techniques.
Reference: [HH93] <author> T. Hirst and D. Harel. </author> <title> Completeness results of recursive data bases. </title> <booktitle> In Proc. 12th ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 244-252, </pages> <year> 1993. </year>
Reference-contexts: There has been little investigation on infinite databases in the past. General results on the completeness of query languages for infinite recursive databases were reported by Hirst and Harel in <ref> [HH93] </ref>, where two classes of recursive databases are considered, and it is shown that: (1) Quantifier-free first-order logic is complete on the class of all recursive databases, and (2) a version of Chandra and Harel's QL [CH80] is complete on highly symmetric databases. The first result of [HH93] indicates that the <p> and Harel in <ref> [HH93] </ref>, where two classes of recursive databases are considered, and it is shown that: (1) Quantifier-free first-order logic is complete on the class of all recursive databases, and (2) a version of Chandra and Harel's QL [CH80] is complete on highly symmetric databases. The first result of [HH93] indicates that the class of recursive structures is much too general for database purposes, since quantifier-free first-order logic is already complete for this class. Therefore, many basic queries are simply not computable (projection, graph connectivity, etc.).
Reference: [HH94] <author> T. Hirst and D. Harel. </author> <title> Recursive model theory, 1994. </title> <type> Draft. </type>
Reference-contexts: This phenomenon holds for various 2 strong restrictions on the class of structures. In particular, the model theory of recursive structures, studied in <ref> [HH94] </ref>, also differs strongly from classical model theory. Finitely representable structures present also similarities with meta-finite structures [GG94]. In this later case though the structures combine an infinite mathematical context with a finite structure. <p> Indeed, any model of S must contain an infinite sequence of disjoint closed segments. By o-minimality, it is not definable in L, and therefore not finitely representable. ut The failure of the Compactness Theorem for restricted classes of models of interest in computer science was also investigated in <ref> [HH94, GST94] </ref>. Theorem 3.2 admits an immediate corollary, namely the failure of the Completeness Theorem. Corollary 3.3 The Completeness Theorem fails for finitely representable models in an o-minimal context. After the Compactness Theorem, another fundamental corollary of the Completeness Theorem fails.
Reference: [HS91] <author> R. Hull and J. Su. </author> <title> On the expressive power of database queries with intermediate types. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43(1) </volume> <pages> 219-267, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Clearly, simulating the moves of the Turing machine M in DATALOG : can be done in the standard way (e.g., <ref> [CH80, Var82, Imm86, HS91, HS93] </ref>; see also [AHV95]). The main difficulties of the proof are the encoding and decoding steps. We next show how this can be done in DATALOG : . Intuitively, the encoding relies on a syntactic normal form of the instances. <p> The steps are expressible in DATALOG : . The program P comp simulating M 's moves is done in the standard way (for example, see <ref> [HS91, HS93] </ref>). Finally, the program P decode will first use the automorphism relation S to obtain a finite representation of the answer 1 (Q ((I ))) = Q (I ) from the encoded output on the Turing tape, and then construct a constraint relation from its relational representation directly.
Reference: [HS93] <author> R. Hull and J. Su. </author> <title> Algebraic and calculus query languages for recursively typed complex objects. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 47(1) </volume> <pages> 121-56, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: Clearly, simulating the moves of the Turing machine M in DATALOG : can be done in the standard way (e.g., <ref> [CH80, Var82, Imm86, HS91, HS93] </ref>; see also [AHV95]). The main difficulties of the proof are the encoding and decoding steps. We next show how this can be done in DATALOG : . Intuitively, the encoding relies on a syntactic normal form of the instances. <p> The steps are expressible in DATALOG : . The program P comp simulating M 's moves is done in the standard way (for example, see <ref> [HS91, HS93] </ref>). Finally, the program P decode will first use the automorphism relation S to obtain a finite representation of the answer 1 (Q ((I ))) = Q (I ) from the encoded output on the Turing tape, and then construct a constraint relation from its relational representation directly.
Reference: [HS94] <author> R. Hull and J. Su. </author> <title> Domain independence and the relational calculus. </title> <journal> Acta Informatica, </journal> <volume> 31(6) </volume> <pages> 513-524, </pages> <year> 1994. </year>
Reference-contexts: expressive power of a first-order language under the natural semantics and under the active domain semantics. (In the active domain semantics the range of variables is restricted to the set of all elements occurring in the database and the query itself.) It is now known that (1) FO FO adom <ref> [HS94] </ref>, (2) FO (6; +) FO (6; +) adom [PVV95], and (3) FO (6; +; fi) FO (6; +; fi) adom [BDLW96, BL96].
Reference: [Hul86] <author> R. Hull. </author> <title> Relative information capacity of simple relational schemata. </title> <journal> SIAM Journal on Computing, </journal> <volume> 15(3) </volume> <pages> 856-886, </pages> <year> 1986. </year>
Reference-contexts: This criterion was then called genericity in the database literature. We will speak in the sequel of relational genericity to distinguish it from alternative definitions. Relational genericity was later generalized to C-genericity by Hull <ref> [Hul86] </ref> to allow the use of a set C of constants (which are left fixed by the isomorphisms) in a query expression. In this paper, we only consider the genericity notion in the original form, though the results can be generalized to include constants. <p> Although not explored in this paper, the above two propositions can be generalized to formulas (sentences) ' containing constants by allowing only automorphisms that are the identity on the constants in '. Such an extension naturally generalizes the concept of C-genericity <ref> [Hul86] </ref>. 4.2 Data Complexity The data complexity of queries is defined based on computational devices and standard encodings of the input/output. Intuitively, the time (space) data complexity of a query is the time (space) needed in evaluating the query with respect to the size of the input database instance.
Reference: [Imm86] <author> N. Immerman. </author> <title> Relational queries computable in polynomial time. </title> <journal> Inf. and Control, </journal> <volume> 68 </volume> <pages> 86-104, </pages> <year> 1986. </year>
Reference-contexts: However, all queries except the homeomorphism, are expressible in inflationary Datalog with negation. Finally, we prove that inflationary Datalog with negation expresses exactly the set of all dense-order queries computable in PTIME. This give a complete characterization of the complexity class, extending the classical result for relational queries <ref> [Var82, Imm86] </ref>. More recently, Benedikt, Dong, Libkin, and Wong [BDLW96] used nonstandard techniques to obtain some significant generalization of non-definability results for constraint query languages. They proved that the parity query is not expressible by first-order constraint languages with o-minimal arithmetic. <p> Clearly, simulating the moves of the Turing machine M in DATALOG : can be done in the standard way (e.g., <ref> [CH80, Var82, Imm86, HS91, HS93] </ref>; see also [AHV95]). The main difficulties of the proof are the encoding and decoding steps. We next show how this can be done in DATALOG : . Intuitively, the encoding relies on a syntactic normal form of the instances. <p> The two steps are done similarly to the encoding process but in the reverse order. ut Except for technical differences in the encoding/decoding steps, the above proof follows the same ideas as for the relational case <ref> [Var82, Imm86] </ref>. We note here that in this paper the complexity classes of queries are defined based on Turing machines computing answers. An alternative definition is to define complexity (classes) of queries based on testing whether a tuple is in the answer.
Reference: [Imm87] <author> N. Immerman. </author> <title> Languages that capture complexity classes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 16(4) </volume> <pages> 760-778, </pages> <year> 1987. </year>
Reference-contexts: In particular, since the parity of the cardinality of a relation and the graph transitive closure are not expressible in L 6 by Theorem 5.3 (iv), it follows that they are not expressible in L fi . Moreover, in [GS96a], first-order reductions <ref> [Imm87] </ref> were used to show that many queries including the minimum spanning tree are not expressible in L fi . Lemma 5.4 The queries convexity and k-convex covering for each k &gt; 0 are definable in FO. Proof: We first show that the convexity query is expressible in FO.
Reference: [KG94] <author> P. C. Kanellakis and D. Q. Goldin. </author> <title> Constraint programming and database query languages. </title> <booktitle> In Proc. 2nd Conference on Theoretical Aspects of Computer Software (TACS), volume 789 of Lecture notes in computer science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The relational calculus over finitely representable relations constitutes a constraint query language which admits an efficient bottom-up and declarative semantics. It is suitable for expressing geometrical and topological queries, as shown by the examples. Like for the relational model, equivalent algebras were proposed <ref> [KG94, PVV94, GST94] </ref>. More powerful languages such as Datalog have also been studied [KKR95, GS95]. Practical implementation issues, such as indexing of finitely representable databases [KRVV93], have been considered, but are still among the most fundamental research issues in this field. <p> Low upper bounds of the data complexity for both the relational calculus and inflationary Datalog with negation over constraint databases have been obtained in [KKR95]. This shows the feasibility of this approach, which has been pursued in <ref> [Rev90, Kup93a, KG94, PVV94, KPV95, VGV95, CGK96, GS96b] </ref>. The goal of this paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages and the corresponding model theory. <p> For example, it was first shown that the data complexity of first-order logic over dense-order constraint databases in some normal form is in AC 0 <ref> [KG94] </ref>. The result was recently extended to classes of linear constraint databases, called k-bounded, where the number of occurrences of the addition symbol in each constraint is bounded [GST94]. <p> Due to their equivalence, we only use FO in the formal statements and proofs in the remainder of the section. The data complexity of FO queries has been studied in <ref> [KKR95, KG94, GST94] </ref>. In [KG94], Kanellakis and Goldin showed an AC 0 upper-bound for FO queries on normalized inputs. This result is further extended in [GST94] to an extension of FO with the addition operation. <p> Due to their equivalence, we only use FO in the formal statements and proofs in the remainder of the section. The data complexity of FO queries has been studied in [KKR95, KG94, GST94]. In <ref> [KG94] </ref>, Kanellakis and Goldin showed an AC 0 upper-bound for FO queries on normalized inputs. This result is further extended in [GST94] to an extension of FO with the addition operation. Theorem 5.2 ([KG94, GST94]) The data complexity of each query in FO is in AC 0 . <p> This result is further extended in [GST94] to an extension of FO with the addition operation. Theorem 5.2 ([KG94, GST94]) The data complexity of each query in FO is in AC 0 . The proof of the AC 0 upper bound (see <ref> [KG94] </ref> for details) is done by an encoding of the dense-order constraint relations into finite relations. This encoding itself is not in AC 0 . An algebra working on the representation in terms of finite relations was developed which simulates first-order operations on the dense-order constraint databases. <p> Remark: A similar statement can be found in [KKR95] and also in <ref> [KG94] </ref>, but its meaning is different. What was proved there was that (inflationary) DATALOG : can express any relational database query computable in PTIME (Theorem 3.15 of [KKR95]). A relational database query is a mapping from finite relational databases to finite relations. <p> Example 6.8 Consider the primitive tuple t = 0 &lt; x 1 &lt; 5 ^ 0 &lt; x 2 &lt; x 1 ^ x 3 &lt; 3 over variables x 1 ; x 2 ; x 3 . It can be represented in the following tabular form <ref> [KG94] </ref>: x 1 x 2 x 3 u 5 +1 3 &lt; = ? where l (u) are the lower (respectively upper) bounds for the variables and the matrix = fu i;j g indicates the relationships among the variables. <p> A tuple t is prime if it is primitive and tighter than each primitive tuple equivalent to t. It was shown that for each primitive tuple, there always exists a unique prime tuple equivalent to it <ref> [KG94] </ref>. For example, the tuple t in Example 6.8 is not prime; the equivalent prime tuple is 0 &lt; x 1 &lt; 5 ^ 0 &lt; x 2 &lt; 5 ^ x 3 &lt; 3 ^ x 2 &lt; x 1 Prime primitive tuples are also called canonical tuples in [KG94]. <p> <ref> [KG94] </ref>. For example, the tuple t in Example 6.8 is not prime; the equivalent prime tuple is 0 &lt; x 1 &lt; 5 ^ 0 &lt; x 2 &lt; 5 ^ x 3 &lt; 3 ^ x 2 &lt; x 1 Prime primitive tuples are also called canonical tuples in [KG94]. 2 We wrote a &lt; x ^ x &lt; b as a &lt; x &lt; b as usual. 37 Definition 6.9 Let R be a k-ary relation.
Reference: [KKR95] <author> P. Kanellakis, G. Kuper, and P. Revesz. </author> <title> Constraint query languages. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 51(1) </volume> <pages> 26-52, </pages> <year> 1995. </year> <note> (An extended abstract appeard in Proc. PODS '90). </note>
Reference-contexts: A new generation of data models for infinite collections of data items based on constraints is emerging in the literature since the seminal paper by Kanellakis, Kuper and Revesz <ref> [KKR95] </ref>. We believe that two fundamental principles should govern the choice of data models and query languages for infinite collections of data: Infinite databases should admit finite representations, and a reasonable set of queries should be tractable. <p> We concentrate on infinite databases that are finitely representable by first-order formulas in some logic language under the context of a first-order structure (such as rational numbers with the natural order or the real closed field). Our framework follows and generalizes the pioneer work by Kanellakis, Kuper, and Revesz <ref> [KKR95] </ref> who introduced constraint query languages. The novel idea there is to generalize the relations of the relational model [Cod70] by defining generalized tuples as conjunctions of constraints. For instance, the formula x 2 + y 2 = 1 ^ x 6 0 defines a binary generalized tuple. <p> It is suitable for expressing geometrical and topological queries, as shown by the examples. Like for the relational model, equivalent algebras were proposed [KG94, PVV94, GST94]. More powerful languages such as Datalog have also been studied <ref> [KKR95, GS95] </ref>. Practical implementation issues, such as indexing of finitely representable databases [KRVV93], have been considered, but are still among the most fundamental research issues in this field. <p> Different types of constraints have been considered in the literature including over dense or discrete ordered domains and involving various arithmetic operations, such as dense order equations and inequalities, linear equations and inequalities, real polynomial equations and inequalities, etc. The first fundamental observation of <ref> [KKR95] </ref> is that the relational calculus can be used as a query language as soon as the constraints are based on a decidable theory which admits the elimination of quantifiers. The evaluation of a (first-order) query is then done by quantifier elimination. The second fundamental observation of [KKR95] is that, although <p> fundamental observation of <ref> [KKR95] </ref> is that the relational calculus can be used as a query language as soon as the constraints are based on a decidable theory which admits the elimination of quantifiers. The evaluation of a (first-order) query is then done by quantifier elimination. The second fundamental observation of [KKR95] is that, although the decision problem of the theories underlying the constraints used (e.g. dense order without endpoints) may be high, the data complexity of the query language remains tractable. <p> The data complexity is measured with respect to the size of the input database defined as the length of its finite representation. Low upper bounds of the data complexity for both the relational calculus and inflationary Datalog with negation over constraint databases have been obtained in <ref> [KKR95] </ref>. This shows the feasibility of this approach, which has been pursued in [Rev90, Kup93a, KG94, PVV94, KPV95, VGV95, CGK96, GS96b]. The goal of this paper is to investigate the expressive power of query languages over finitely representable databases. <p> These negative results were used to further establish the non-definability of interesting topological queries by means of first-order reductions in [GS96a]. These queries include the ones considered in this paper and also the minimal spanning tree query that was raised as an open problem in <ref> [KKR95] </ref>. We give a brief survey of these recent results on complexity and expressive power in Section 7. The paper is organized as follows. In Section 2, we briefly review first-order logic and formally define finitely representable databases. <p> A (database) schema is a finite set of relation symbols such that " L = ;. We always assume that the schema is disjoint from the first-order language, and we distinguish between logical predicates (such as =; 6) in L, and relations in . Kanellakis, Kuper and Revesz <ref> [KKR95] </ref> introduced the concept of a k-ary generalized tuple, which is a conjunction of atomic formulas in L with k variables. <p> For instance in the context of the real numbers, the expression (x fi x + y fi y = 1) ^ (x 6 0) is a binary generalized tuple in L fi representing a half circle in the real plane. A k-ary finitely representable relation (or generalized relation <ref> [KKR95] </ref>) is a finite set of k-ary generalized tuples. In this framework, a tuple [a; b] of the classical relational model [Cod70] is an abbreviation of the formula (x = a ^ y = b) involving only the equality symbol and constants. <p> and 6-genericity can be easily established by reductions from the satisfiability problems, where the reductions are simply to pad an input query with a non-relational generic or non-order generic query. ut In particular, Theorem 4.12 indicates that the properties listed above are undecidable in the first-order constraint query language of <ref> [KKR95] </ref> over R. <p> Due to their equivalence, we only use FO in the formal statements and proofs in the remainder of the section. The data complexity of FO queries has been studied in <ref> [KKR95, KG94, GST94] </ref>. In [KG94], Kanellakis and Goldin showed an AC 0 upper-bound for FO queries on normalized inputs. This result is further extended in [GST94] to an extension of FO with the addition operation. <p> returns true if the two relations are k-homeomorphic and false otherwise. (Two point sets in the k-dimensional rational space Q k are k-homeomorphic if there is a bi-continuous bijection on Q k which maps one to the other.) There are numerous other interesting queries such as the minimal spanning tree <ref> [KKR95] </ref>, and various tests such as translation, (direct) isometry, similarity, or affinity of two point sets in Q 2 [PVV94]. However, these queries do not commute with automorphisms of Q and are not order-generic. The main definability results concerning first-order can now be stated. <p> The proof technique involves a novel use of a normal form for dense-order constraint databases. We first review the DATALOG : language, discuss a few example of queries, and then prove the PTIME characterization result. 32 The language DATALOG : was originally introduced in <ref> [KKR95] </ref>. A DATALOG : query has the same syntax as Datalog [AHV95] except that negation and constraints involving 6 are allowed in the body of its rules. <p> In an iteration, all rules (FO queries) are executed; the union of the result of a rule and the relation of its head predicate is stored in the same head relation. The iteration is repeated until the head relations reach a fixpoint. It was shown in <ref> [KKR95] </ref> that the query evaluation process stops after a finite number of iterations for each database instance and consequently the output of a query is always an L 6 -representable relation. In other words, DATALOG : can be evaluated bottom-up and in closed form. <p> Theorem 6.1 Every constant-free query in DATALOG : is 6-generic. If 6-genericity is generalized to include constants, it can be easily shown that DATALOG : (possibly with constants) satisfies the generalized 6-genericity property. The data complexity of DATALOG : queries has been studied by Kanellakis, Kuper, and Revesz in <ref> [KKR95] </ref>, where it is shown that the data complexity of DATALOG : is in PTIME. Theorem 6.2 ([KKR95]) The data complexity of each DATALOG : query is in PTIME. <p> Remark: A similar statement can be found in <ref> [KKR95] </ref> and also in [KG94], but its meaning is different. What was proved there was that (inflationary) DATALOG : can express any relational database query computable in PTIME (Theorem 3.15 of [KKR95]). A relational database query is a mapping from finite relational databases to finite relations. <p> Remark: A similar statement can be found in <ref> [KKR95] </ref> and also in [KG94], but its meaning is different. What was proved there was that (inflationary) DATALOG : can express any relational database query computable in PTIME (Theorem 3.15 of [KKR95]). A relational database query is a mapping from finite relational databases to finite relations. In other words, it was shown that PTIME relational input/output inflationary DATALOG : PTIME dense-order input/input = PTIME Q . <p> We can now loop through adom (I) and define (a) for each a 2 adom (I ), and use another loop to generate bin ((a)). The details are tedious. ut Proof of Theorem 6.6: The inclusion of inflationary DATALOG : in PTIME Q has been shown in <ref> [KKR95] </ref>: each query in DATALOG : expresses a query over dense order databases and can be computed in PTIME. We only prove the converse inclusion. Let Q be a query over dense order constraints computable in polynomial time and M be a Turing machine that computes Q. <p> In this section we give a brief survey of the results related to complexity and expressive power. Data Complexity The data complexity of the first-order query language L fi , denoted here FO (6; +; fi), for R was shown to be in NC <ref> [KKR95] </ref>. The NC result follows from the decidability of the theory of real closed fields [Tar51] and its tractability for the case of a fixed number of variables [BKR86, Ren92]. <p> The results for the restricted cases are summarized in the following table. FO (6; +) FO (6; +; fi) Finite databases AC 0 [GST94] TC 0 [BL96] Linear constraint databases NC 1 [GS96a] NC <ref> [KKR95] </ref> The AC 0 result for FO (6; +) for finite databases follows from a result in [GST94] that establishes the AC 0 bound for a subclass of linear constraint databases. This technique was further extended to show the NC 1 bound for the general case in [GS96a]. <p> Furthermore, the minimum spanning tree query was also shown not expressible in FO (6; +; fi), which resolved an open problem raised in <ref> [KKR95] </ref>. 8 Final Remarks and Open Problems We introduced the theory of finitely representable models, and analyzed the differences with finite model theory and classical model theory. Most of the fundamental classical theorems (completeness and compactness) of model theory were shown to fail in the context of finitely representable structures.
Reference: [KPV95] <author> B. Kuijpers, J. Paredaens, and J. Van den Bussche. </author> <title> Lossless representation of topological spatial data. </title> <editor> In M. J. Egenhofer and J. R. Herring, editors, </editor> <booktitle> Advances in Spatial Databases, 4th Int. Symp., SSD'95, </booktitle> <pages> pages 1-13. </pages> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: Low upper bounds of the data complexity for both the relational calculus and inflationary Datalog with negation over constraint databases have been obtained in [KKR95]. This shows the feasibility of this approach, which has been pursued in <ref> [Rev90, Kup93a, KG94, PVV94, KPV95, VGV95, CGK96, GS96b] </ref>. The goal of this paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages and the corresponding model theory.
Reference: [KRVV93] <author> P. Kanellakis, S. Ramaswamy, D. Vengroff, and J. Vitter. </author> <title> Indexing for data models with constraints and classes. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 233-243, </pages> <year> 1993. </year>
Reference-contexts: It is suitable for expressing geometrical and topological queries, as shown by the examples. Like for the relational model, equivalent algebras were proposed [KG94, PVV94, GST94]. More powerful languages such as Datalog have also been studied [KKR95, GS95]. Practical implementation issues, such as indexing of finitely representable databases <ref> [KRVV93] </ref>, have been considered, but are still among the most fundamental research issues in this field. <p> In spite of the seeming advantages, constraint databases are still in the theoretical investigation stage. Indeed many questions need to be answered before efficient implementation can become possible, including dealing with finite precision arithmetic [GS96b], aggregate functions [Kup93a, CGK96], indexing <ref> [KRVV93] </ref>, etc. 42 Acknowledgments The authors wish to thank Victor Vianu and the referees for helpful comments.
Reference: [Kup90] <author> G. M. Kuper. </author> <title> On the expressive power of the relational calculus with arithmetic constraints. </title> <booktitle> In Proc. Int. Conf. on Database Theory, </booktitle> <pages> pages 202-211, </pages> <year> 1990. </year> <month> 45 </month>
Reference-contexts: We now prove Theorem 5.3. The proof for (iii) is obvious. For example, the connectivity of one dimensional regions holds if the input consists of at most one interval. The other cases are established through a series of lemmas (Lemma 5.4 to Lemma 5.7). In <ref> [Kup90] </ref>, finite databases and L = -generic queries over the structure R of real numbers were considered. It was claimed that each L = -generic query in L fi is definable using only equality, i.e., in L = . Unfortunately, this result does not hold [Via93, Kup93b].
Reference: [Kup93a] <author> G. M. Kuper. </author> <title> Aggregation in constraint databases. </title> <booktitle> In Proc. Workshop on the Principles and Practice of Constraint Programming, </booktitle> <pages> pages 176-183, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Low upper bounds of the data complexity for both the relational calculus and inflationary Datalog with negation over constraint databases have been obtained in [KKR95]. This shows the feasibility of this approach, which has been pursued in <ref> [Rev90, Kup93a, KG94, PVV94, KPV95, VGV95, CGK96, GS96b] </ref>. The goal of this paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages and the corresponding model theory. <p> In spite of the seeming advantages, constraint databases are still in the theoretical investigation stage. Indeed many questions need to be answered before efficient implementation can become possible, including dealing with finite precision arithmetic [GS96b], aggregate functions <ref> [Kup93a, CGK96] </ref>, indexing [KRVV93], etc. 42 Acknowledgments The authors wish to thank Victor Vianu and the referees for helpful comments.
Reference: [Kup93b] <author> G. M. Kuper. </author> <type> Personal communications, </type> <year> 1993. </year>
Reference-contexts: In [Kup90], finite databases and L = -generic queries over the structure R of real numbers were considered. It was claimed that each L = -generic query in L fi is definable using only equality, i.e., in L = . Unfortunately, this result does not hold <ref> [Via93, Kup93b] </ref>. A simple counterexample due to Gurevich can be found in ([AHV95], Exercise 17.27, page 462), where a variant of the parity query (which is generic) was expressible with an order but inexpressible without it. Nevertheless, a weaker result holds.
Reference: [PSV96] <author> C. H. Papadimitriou, D. Suciu, and V. Vianu. </author> <title> Topological queries in spatial databases. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <year> 1996. </year>
Reference-contexts: isolated point (15; 90) in the image (R) can now be separated from the other two segments of (R) by a straight line, namely y = x + 101 (Figure 1 (b)). ut Finally, we consider another interesting class of queries, topological queries, which are queries invariant under topological transformations <ref> [PVV94, PSV96] </ref>. Definition 4.6 Let A be an L-structure, a database schema and R a k-ary relation symbol.
Reference: [PVV94] <author> J. Paredaens, J. Van den Bussche, and D. Van Gucht. </author> <title> Towards a theory of spatial database queries. </title> <booktitle> In Proc. 13th ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 279-88, </pages> <year> 1994. </year>
Reference-contexts: The relational calculus over finitely representable relations constitutes a constraint query language which admits an efficient bottom-up and declarative semantics. It is suitable for expressing geometrical and topological queries, as shown by the examples. Like for the relational model, equivalent algebras were proposed <ref> [KG94, PVV94, GST94] </ref>. More powerful languages such as Datalog have also been studied [KKR95, GS95]. Practical implementation issues, such as indexing of finitely representable databases [KRVV93], have been considered, but are still among the most fundamental research issues in this field. <p> Low upper bounds of the data complexity for both the relational calculus and inflationary Datalog with negation over constraint databases have been obtained in [KKR95]. This shows the feasibility of this approach, which has been pursued in <ref> [Rev90, Kup93a, KG94, PVV94, KPV95, VGV95, CGK96, GS96b] </ref>. The goal of this paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages and the corresponding model theory. <p> We also investigate other criteria such as the invariance of the properties. There are interesting classes of queries that commute with groups of operations, such as permutations, rotations, translations, etc. This subject was explored in detail in <ref> [PVV94] </ref>. We prove that the class of first-order queries definable by dense-order constraints commute with the automorphisms of hQ; 6i. We illustrate these proof techniques on queries from computational geometry [Yao90], graph theory, and geographical databases. We study their definability in first-order and fixpoint logics over finitely representable databases. <p> In this paper, we only consider the genericity notion in the original form, though the results can be generalized to include constants. Genericity reflects logical data independence [Ull82] in database systems. Constraint databases give raise to new concepts of genericity <ref> [PVV94, BDLW96] </ref> that also reflect logical independence to various degrees. In the absence of a universal concept of genericity, we first adopt a general definition of a query which does not have any consistency criterion. Definition 4.1 Let A be an L-structure, a schema, and R a k-ary relation symbol. <p> A natural way to generalize the concept of genericity for queries over constraint databases is to consider the set of morphisms which commute with the queries. This approach was pursued in <ref> [PVV94] </ref>. In the classical case, queries commute with automorphisms of the context structure, which is the domain with the equality predicate. So the set of morphisms which commute with the queries is the set of all permutations of the domain. <p> isolated point (15; 90) in the image (R) can now be separated from the other two segments of (R) by a straight line, namely y = x + 101 (Figure 1 (b)). ut Finally, we consider another interesting class of queries, topological queries, which are queries invariant under topological transformations <ref> [PVV94, PSV96] </ref>. Definition 4.6 Let A be an L-structure, a database schema and R a k-ary relation symbol. <p> However, the example of P ab raised an interesting question of whether an appropriate context structure can be found such that the class of topological queries coincides with the class of generic queries. This question is also relevant for other genericity notions considered in <ref> [PVV94] </ref>. 4.1 Query Languages Let L be a first-order language and a schema disjoint from L. <p> Q k are k-homeomorphic if there is a bi-continuous bijection on Q k which maps one to the other.) There are numerous other interesting queries such as the minimal spanning tree [KKR95], and various tests such as translation, (direct) isometry, similarity, or affinity of two point sets in Q 2 <ref> [PVV94] </ref>. However, these queries do not commute with automorphisms of Q and are not order-generic. The main definability results concerning first-order can now be stated.
Reference: [PVV95] <author> J. Paredaens, J. Van den Bussche, and D. Van Gucht. </author> <title> First-order queries on finite structures over the reals. </title> <booktitle> In Proc. IEEE Symposium on Logic In Computer Science, </booktitle> <year> 1995. </year>
Reference-contexts: More recently, it 24 was shown that each L = -generic query in L fi is definable with the equality and the order relation only (i.e., in L 6 ) [BDLW96], which improves a similar result on the linear language (L fi without the multiplication fi) proved earlier in <ref> [PVV95, ST96] </ref>. These results have important consequences on the expressive power of the languages with respect to relational queries. <p> The proof uses a novel technique from nonstandard analysis. Prior to this result, it was proved that the parity and transitive queries are not expressible in FO (6; +) <ref> [GST94, PVV95, ST96] </ref> using different techniques. <p> semantics and under the active domain semantics. (In the active domain semantics the range of variables is restricted to the set of all elements occurring in the database and the query itself.) It is now known that (1) FO FO adom [HS94], (2) FO (6; +) FO (6; +) adom <ref> [PVV95] </ref>, and (3) FO (6; +; fi) FO (6; +; fi) adom [BDLW96, BL96]. As far as queries over general finitely representable databases are concerned, [GS96a] uses first-order reductions to prove that all queries in Item 2 of Theorem 5.3 are not definable in FO (6; +; fi).
Reference: [Ren92] <author> J. Renegar. </author> <title> On the computational complexity and geometry of the first-order theory of the reals. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 13 </volume> <pages> 255-352, </pages> <year> 1992. </year>
Reference-contexts: The results for monadic relations admit some generalizations to arbitrary arities. In particular, it can be verified for instance that the number of connected components of an L fi -representable k-ary relation is finite. The proof follows from the cylindrical algebraic decomposition of [Col75] (see also <ref> [Tar51, Ren92] </ref>). 3 Finitely Representable Model Theory In this section, we analyze the differences between finite model theory, finitely representable model theory, and classical model theory. <p> The NC result follows from the decidability of the theory of real closed fields [Tar51] and its tractability for the case of a fixed number of variables <ref> [BKR86, Ren92] </ref>. While this remains the best known upper-bound, there are several improvements in various subcases, depending on whether the input database is finite or consists of only linear constraints (i.e. fi does not occur), and whether the query language contains the multiplication.
Reference: [Rev90] <author> P. Z. Revesz. </author> <title> A closed form for datalog queries with integer order. </title> <booktitle> In Proc. Int. Conf. on Database Theory, </booktitle> <pages> pages 187-201, </pages> <year> 1990. </year>
Reference-contexts: Low upper bounds of the data complexity for both the relational calculus and inflationary Datalog with negation over constraint databases have been obtained in [KKR95]. This shows the feasibility of this approach, which has been pursued in <ref> [Rev90, Kup93a, KG94, PVV94, KPV95, VGV95, CGK96, GS96b] </ref>. The goal of this paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages and the corresponding model theory.
Reference: [ST96] <author> A. P. Stolboushkin and M. A. Taitslin. </author> <title> Linear vs. order constrained queries over rational databases. </title> <booktitle> In Proc. ACM Symp. on Principles of Database Systems, </booktitle> <year> 1996. </year>
Reference-contexts: More recently, it 24 was shown that each L = -generic query in L fi is definable with the equality and the order relation only (i.e., in L 6 ) [BDLW96], which improves a similar result on the linear language (L fi without the multiplication fi) proved earlier in <ref> [PVV95, ST96] </ref>. These results have important consequences on the expressive power of the languages with respect to relational queries. <p> The proof uses a novel technique from nonstandard analysis. Prior to this result, it was proved that the parity and transitive queries are not expressible in FO (6; +) <ref> [GST94, PVV95, ST96] </ref> using different techniques.
Reference: [Tar51] <author> A. Tarski. </author> <title> A Decision Method for Elementary Algebra and Geometry. </title> <institution> University of California Press, Berkeley, California, </institution> <year> 1951. </year>
Reference-contexts: The structure R satisfies the theory of ordered real closed fields which is also complete and admits the elimination of quantifiers <ref> [Tar51] </ref>. More formally, Tarski proved that: 5 Theorem 2.2 [Tar51] For each formula ' in the language f=; 6; +; fi; 0; 1g, there exists a quantifier-free formula in the same language such that the equivalence of ' and holds in the real field. <p> The structure R satisfies the theory of ordered real closed fields which is also complete and admits the elimination of quantifiers <ref> [Tar51] </ref>. More formally, Tarski proved that: 5 Theorem 2.2 [Tar51] For each formula ' in the language f=; 6; +; fi; 0; 1g, there exists a quantifier-free formula in the same language such that the equivalence of ' and holds in the real field. We assume that the associated languages contain a constant symbol for each rational number. <p> The results for monadic relations admit some generalizations to arbitrary arities. In particular, it can be verified for instance that the number of connected components of an L fi -representable k-ary relation is finite. The proof follows from the cylindrical algebraic decomposition of [Col75] (see also <ref> [Tar51, Ren92] </ref>). 3 Finitely Representable Model Theory In this section, we analyze the differences between finite model theory, finitely representable model theory, and classical model theory. <p> Does every formula define an (L-)generic query with respect to Definition 4.2? Question Q1 is related to the quantifier elimination property of first-order theories. For the contexts Q and R considered here, their theories admit quantifier elimination and equivalent quantifier-free formulas can be effectively obtained <ref> [CK73, Tar51] </ref>. It is not always the case as shown in the following example. Example 4.8 The theory of hN; 6; +i (a.k.a. Presburger arithmetic) does not admit quantifier elimination. <p> Data Complexity The data complexity of the first-order query language L fi , denoted here FO (6; +; fi), for R was shown to be in NC [KKR95]. The NC result follows from the decidability of the theory of real closed fields <ref> [Tar51] </ref> and its tractability for the case of a fixed number of variables [BKR86, Ren92].
Reference: [Tra50] <author> B. A. Trakhtenbrot. </author> <title> The impossibilty of an algorithm for the decision problem for finite models. </title> <journal> Doklady Akademii Nauk SSR, </journal> <volume> 70 </volume> <pages> 569-572, </pages> <year> 1950. </year>
Reference-contexts: The contrary holds for finite model theory [Fag93]. The set of first-order sentences valid over finite structures is co-r.e. and Trakhtenbrot proved <ref> [Tra50] </ref> that it is not r.e. A similar phenomenon holds for finitely representable models. We first prove the following. Theorem 3.4 Let A be an o-minimal L-structure with an ordered domain A, and be a schema containing at least one relation symbol with arity &gt; 2.
Reference: [Ull82] <author> J. D. Ullman. </author> <title> Principles of Database Systems (2nd edition). </title> <publisher> Computer Science Press, </publisher> <address> Potomac, Maryland, </address> <year> 1982. </year>
Reference-contexts: 1 Introduction Until recently, most data models and query languages have been designed for the modeling and the manipulation of finite collections of simple and uninterpreted data items. The classical network, hierarchical, and relational models <ref> [Ull82] </ref> are suitable for conventional database applications such as business applications. Extensions to structured data types, such as nested relations, complex objects, and object-oriented models, allow the modeling of more complex semantic relationships between data items [AHV95]. <p> In this paper, we only consider the genericity notion in the original form, though the results can be generalized to include constants. Genericity reflects logical data independence <ref> [Ull82] </ref> in database systems. Constraint databases give raise to new concepts of genericity [PVV94, BDLW96] that also reflect logical independence to various degrees. In the absence of a universal concept of genericity, we first adopt a general definition of a query which does not have any consistency criterion.
Reference: [Var82] <author> M. Vardi. </author> <title> Relational queries computable in polynomial time. </title> <booktitle> In Proc. 14th ACM Symp. on Theory of Computing, </booktitle> <pages> pages 137-146, </pages> <year> 1982. </year>
Reference-contexts: However, all queries except the homeomorphism, are expressible in inflationary Datalog with negation. Finally, we prove that inflationary Datalog with negation expresses exactly the set of all dense-order queries computable in PTIME. This give a complete characterization of the complexity class, extending the classical result for relational queries <ref> [Var82, Imm86] </ref>. More recently, Benedikt, Dong, Libkin, and Wong [BDLW96] used nonstandard techniques to obtain some significant generalization of non-definability results for constraint query languages. They proved that the parity query is not expressible by first-order constraint languages with o-minimal arithmetic. <p> Clearly, simulating the moves of the Turing machine M in DATALOG : can be done in the standard way (e.g., <ref> [CH80, Var82, Imm86, HS91, HS93] </ref>; see also [AHV95]). The main difficulties of the proof are the encoding and decoding steps. We next show how this can be done in DATALOG : . Intuitively, the encoding relies on a syntactic normal form of the instances. <p> The two steps are done similarly to the encoding process but in the reverse order. ut Except for technical differences in the encoding/decoding steps, the above proof follows the same ideas as for the relational case <ref> [Var82, Imm86] </ref>. We note here that in this paper the complexity classes of queries are defined based on Turing machines computing answers. An alternative definition is to define complexity (classes) of queries based on testing whether a tuple is in the answer.
Reference: [Vau60] <author> R. L. Vaught. </author> <title> Sentences true in all constructive models. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 25(1) </volume> <pages> 39-53, </pages> <month> March </month> <year> 1960. </year>
Reference-contexts: It follows from Theorem 3.4 that it is not r.e. We next give an alternative proof that the set of first-order sentences valid over finitely representable models in the context of N is not r.e. based on Vaught's result <ref> [Vau60] </ref> on the validity of sentences over different classes of structures. Theorem 3.6 Let be a schema containing at least one relation symbol with arity &gt; 2. The set of sentences in L = [ valid over L = -representable models with respect to N and is not r.e. <p> Proof: The proof is based on Vaught's result. Let V r:e: (respectively V fin ) be the set of sentences true in all r.e. (respectively finite) structures. Vaught <ref> [Vau60] </ref> showed that for each set of sentences V , if V r:e: V V fin , then V is not r.e. Now, let V N be the set of sentences valid over finitely representable models with respect to N and .
Reference: [VGV95] <author> L. Vandeurzen, M. Gyssens, and D. Van Gucht. </author> <title> On the desirability and limitations of linear spatial database models. </title> <booktitle> In Advances in Spatial Databases, 4th Int. Symp., SSD'95, </booktitle> <pages> pages 14-28. </pages> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: Low upper bounds of the data complexity for both the relational calculus and inflationary Datalog with negation over constraint databases have been obtained in [KKR95]. This shows the feasibility of this approach, which has been pursued in <ref> [Rev90, Kup93a, KG94, PVV94, KPV95, VGV95, CGK96, GS96b] </ref>. The goal of this paper is to investigate the expressive power of query languages over finitely representable databases. For that purpose, we study the underlying logic of constraint query languages and the corresponding model theory.
Reference: [Via93] <author> V. Vianu. </author> <type> Personal communications, </type> <year> 1993. </year>
Reference-contexts: In [Kup90], finite databases and L = -generic queries over the structure R of real numbers were considered. It was claimed that each L = -generic query in L fi is definable using only equality, i.e., in L = . Unfortunately, this result does not hold <ref> [Via93, Kup93b] </ref>. A simple counterexample due to Gurevich can be found in ([AHV95], Exercise 17.27, page 462), where a variant of the parity query (which is generic) was expressible with an order but inexpressible without it. Nevertheless, a weaker result holds.
Reference: [Yao90] <author> F. F. Yao. </author> <title> Computational geometry. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume A, chapter 7, </booktitle> <pages> pages 343-389. </pages> <publisher> North Holland, </publisher> <year> 1990. </year> <month> 46 </month>
Reference-contexts: This subject was explored in detail in [PVV94]. We prove that the class of first-order queries definable by dense-order constraints commute with the automorphisms of hQ; 6i. We illustrate these proof techniques on queries from computational geometry <ref> [Yao90] </ref>, graph theory, and geographical databases. We study their definability in first-order and fixpoint logics over finitely representable databases. We show in particular the non first-order definability of the connectivity of an area in the context of a dense order.
References-found: 59

