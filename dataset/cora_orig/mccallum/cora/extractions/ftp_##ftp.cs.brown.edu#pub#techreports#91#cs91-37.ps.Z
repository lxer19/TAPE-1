URL: ftp://ftp.cs.brown.edu/pub/techreports/91/cs91-37.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-91-37.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> A.V. Aho, R. Sethi, and J. D. Ullman. </author> <title> Code Optimization in Compilers, </title> <booktitle> Principles, Techniques, and Tools, </booktitle> <pages> pages 585-722, </pages> <publisher> Addison-Wesley (1988). </publisher>
Reference: [2] <author> M. S. Hecht. </author> <title> Flow Analysis of Computer Programs, </title> <publisher> Elsevier North-Holland. </publisher> <year> (1977) </year>
Reference: [3] <author> John T. Stasko.TANGO: </author> <title> A Framework and System for Algorithm Animation. </title> <institution> Brown University Computer Science Department Technical Report CS-89-30. </institution> <month> (May </month> <year> 1989) </year>
Reference-contexts: 1 Introduction There have been many quite different approaches to algorithm animation and data visualization in the past. Systems like BALSA [4], TANGO <ref> [3] </ref>, Incense, FIELD/DISP [5], and UWPI [10] all show great potential in this field. However, all these systems have their drawbacks. Algorithm animation systems like BALSA and TANGO generate nice animations, but users are required to modify the original program and code the animation scenes by hand. <p> Another commonly used method is to ask the programmer to insert code manually, as in BALSA [4] and TANGO <ref> [3] </ref>. The disadvantage of the first method is that the debugger is a low level primitive tool. When it is not running in the interpretive mode, the user has to manually specify all the places where the value of certain variables should be reported.
Reference: [4] <author> Marc. H. Brown. </author> <title> Algorithm Animation. </title> <institution> Brown University Computer Science Department Technical Report CS-87-05. </institution> <month> (April </month> <year> 1987) </year>
Reference-contexts: 1 Introduction There have been many quite different approaches to algorithm animation and data visualization in the past. Systems like BALSA <ref> [4] </ref>, TANGO [3], Incense, FIELD/DISP [5], and UWPI [10] all show great potential in this field. However, all these systems have their drawbacks. Algorithm animation systems like BALSA and TANGO generate nice animations, but users are required to modify the original program and code the animation scenes by hand. <p> For example, node^.next^.next is considered as a trivial generalized alias of node. Complex names can be formed by using ^, [ ], and . together. For example, node1^.- field1^.field2 <ref> [4] </ref> is legal in Pascal. But all these names can be recognized easily, and they are generalized aliases of their parent names. Therefore, they will not be treated explicitly in the following discussion. In C, the address arithmetic is allowed. <p> One commonly used method is to load a specially compiled program into a debugger, and then use the debugger to monitor the behavior of variables, as in FIELD/DISP [5] and Incense [15]. Another commonly used method is to ask the programmer to insert code manually, as in BALSA <ref> [4] </ref> and TANGO [3]. The disadvantage of the first method is that the debugger is a low level primitive tool. When it is not running in the interpretive mode, the user has to manually specify all the places where the value of certain variables should be reported.
Reference: [5] <author> Steven P. Reiss, </author> <title> Interacting with the FIELD environment, </title> <note> Software Practice and Experience 20(S1) pages 89-115 (June 1990) </note>
Reference-contexts: 1 Introduction There have been many quite different approaches to algorithm animation and data visualization in the past. Systems like BALSA [4], TANGO [3], Incense, FIELD/DISP <ref> [5] </ref>, and UWPI [10] all show great potential in this field. However, all these systems have their drawbacks. Algorithm animation systems like BALSA and TANGO generate nice animations, but users are required to modify the original program and code the animation scenes by hand. <p> One commonly used method is to load a specially compiled program into a debugger, and then use the debugger to monitor the behavior of variables, as in FIELD/DISP <ref> [5] </ref> and Incense [15]. Another commonly used method is to ask the programmer to insert code manually, as in BALSA [4] and TANGO [3]. The disadvantage of the first method is that the debugger is a low level primitive tool.
Reference: [6] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> Proc. SIGP-LAN89 Symp. on Compiler Construction. (June 1989) Published as SIGPLAN Notices Vol. </booktitle> <volume> 24, No. </volume> <pages> 7. </pages>
Reference: [7] <author> N. D. Jones and S. S. Muchnick. </author> <title> Flow analysis and optimization of LISP-like structures. </title> <editor> In S. S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis, </title> <booktitle> chapter 4, </booktitle> <pages> pages 102-131. </pages> <publisher> Prentice Hall. </publisher> <year> (1981) </year>
Reference-contexts: To build an interactive environment, there are also incremental algorithms available [11] 2.4.3 Approach 3: Use Storage Shape Graph The third approach is to use algorithms which are originally designed to detect conflicts between structure accesses <ref> [7] </ref> [9] [14]. These methods also use CFG to represent programs. But at each node of the CFG, the possible configuration of the heap allocated data structures is summarized by a graph, called the Storage Shape Graph (SSG) or Alias Graph.
Reference: [8] <author> Franco P. Preparata and Michael lan Shamos. </author> <title> Computational Geometry, an Introduction, </title> <publisher> Springer-Verlag. </publisher> <pages> pages 15-17 (1985) </pages>
Reference: [9] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> Proc. SIGP-LAN88 Symp. on Compiler Construction, </booktitle> <pages> pages 21-34 (July, </pages> <note> 1988) Published as SIGPLAN Notices Vol. 23, No. 7. </note>
Reference-contexts: To build an interactive environment, there are also incremental algorithms available [11] 2.4.3 Approach 3: Use Storage Shape Graph The third approach is to use algorithms which are originally designed to detect conflicts between structure accesses [7] <ref> [9] </ref> [14]. These methods also use CFG to represent programs. But at each node of the CFG, the possible configuration of the heap allocated data structures is summarized by a graph, called the Storage Shape Graph (SSG) or Alias Graph.
Reference: [10] <author> Robert. R. Henry, Kenneth. M. Whaley, and Bruce Forstall. </author> <title> The University of Washington Illustrating Compiler. Pro. </title> <booktitle> of the ACM SIGPLAN90 Conference on Programming Language, Design and Implementation, </booktitle> <pages> pages 223-233. </pages> <month> (June, </month> <year> 1990) </year>
Reference-contexts: 1 Introduction There have been many quite different approaches to algorithm animation and data visualization in the past. Systems like BALSA [4], TANGO [3], Incense, FIELD/DISP [5], and UWPI <ref> [10] </ref> all show great potential in this field. However, all these systems have their drawbacks. Algorithm animation systems like BALSA and TANGO generate nice animations, but users are required to modify the original program and code the animation scenes by hand.
Reference: [11] <author> M. Burke. </author> <title> An interval-Based Approach to Exhaustive and Incremental Interprocedual Data-Flow Analysis. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> Vol. 12, No. 3, </volume> <pages> pages 341-395. </pages> <month> (July, </month> <year> 1990) </year>
Reference-contexts: To improve the efficiency, interval analysis and basic blocks can be used [12]. To deal with separate compilation, summary information describing the effect of functions in a file can be used. To build an interactive environment, there are also incremental algorithms available <ref> [11] </ref> 2.4.3 Approach 3: Use Storage Shape Graph The third approach is to use algorithms which are originally designed to detect conflicts between structure accesses [7] [9] [14]. These methods also use CFG to represent programs.
Reference: [12] <author> R. Tarjan. </author> <title> Testing flow graph reducibility. Compute. </title> <journal> Syst. Sci. </journal> <volume> 9, 3, </volume> <pages> pages 355-365. </pages> <month> (Dec. </month> <year> 1974) </year>
Reference-contexts: There are many different algorithms available, some of which are more general, some more precise, and some more efficient. To improve the efficiency, interval analysis and basic blocks can be used <ref> [12] </ref>. To deal with separate compilation, summary information describing the effect of functions in a file can be used.
Reference: [13] <author> J. P. Banning. </author> <title> A Method for determining the Side Effects of Procedure Calls. </title> <type> Ph.D. Dissertation, </type> <institution> STAN-CS-78-676, Stanford University. </institution> <month> (August, </month> <year> 1978) </year>
Reference-contexts: Aliases detection is an well-known problem in the field of compiler design, and the techniques to deal with it are quite mature. There are individual methods to find aliases in a program <ref> [13] </ref>, and frameworks to solve the general data-flow problem [1][2][11]. These methods build a control flow graph (CFG) from a program, in which a node represents a statement or a segment of code, and an edge represents a possible transfer of control between segments of code.
Reference: [14] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of Pointers and Structures. </title> <booktitle> Proc. 35 SIGPLAN90 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310. </pages> <month> (June, </month> <year> 1990) </year>
Reference-contexts: To build an interactive environment, there are also incremental algorithms available [11] 2.4.3 Approach 3: Use Storage Shape Graph The third approach is to use algorithms which are originally designed to detect conflicts between structure accesses [7] [9] <ref> [14] </ref>. These methods also use CFG to represent programs. But at each node of the CFG, the possible configuration of the heap allocated data structures is summarized by a graph, called the Storage Shape Graph (SSG) or Alias Graph.
Reference: [15] <author> Brad A. Myers. INCENSE: </author> <title> A system for displaying data structures. </title> <journal> Computer Graphics, </journal> <volume> Vol 17, No. 3, </volume> <pages> pages 115-125. </pages> <month> (July, </month> <year> 1983) </year>
Reference-contexts: One commonly used method is to load a specially compiled program into a debugger, and then use the debugger to monitor the behavior of variables, as in FIELD/DISP [5] and Incense <ref> [15] </ref>. Another commonly used method is to ask the programmer to insert code manually, as in BALSA [4] and TANGO [3]. The disadvantage of the first method is that the debugger is a low level primitive tool.
Reference: [16] <author> Brad A. Myers, Ravinder Chandhok, and Atul Sareen. </author> <title> Automatic Data Visualization for Novice Pascal Programmers. </title> <booktitle> In IEEE Computer Society Workshop on Visual Languages, </booktitle> <pages> pages 192-198, </pages> <address> Pittsburgh, PA. </address> <month> (Oct., </month> <year> 1988) </year>
Reference: [17] <author> ANSI (American National Standards Institute), </author> <title> AMerican National Standard for Information Processing Systems - Programmers Hierarchical Interactive Graphics System (PHIGS) Functional Description, Archive File Format, Clear-Text Encoding of Archive File, ANSI, X3.144-1988, ANSI, </title> <address> New York, </address> <year> (1988) </year>
Reference-contexts: However, when performing this kind of animation, a system like TANGO degenerates to a drawing package. Actually, this kind of simulation is more suitable for simple but efficient drawing packages like PHIGS <ref> [17] </ref> and SRGP [19]. 34
Reference: [18] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen. </author> <title> Object-Oriented Modeling and Design Prentice Hall, </title> <publisher> Inc. </publisher> <year> (1991) </year>
Reference-contexts: The class diagram of the image objects is shown in Fig. 8. Here, the Object Modeling Technique (OMT) notations proposed by <ref> [18] </ref> are used. The key point of this design is to distinguish between address images and value images. Each address image is associated with a data object in the algorithm process. Their positions may depend on each other. Each value image is associated with an address object.
Reference: [19] <author> James D. Foley, Andries vanDam, Steven K. Feiner, and John F. Hughes. </author> <title> Computer Graphics: Principles and Practice Second Edition. </title> <publisher> Addison-Wesley. </publisher> <pages> pages 25-66. </pages> <year> (1990) </year>
Reference-contexts: However, when performing this kind of animation, a system like TANGO degenerates to a drawing package. Actually, this kind of simulation is more suitable for simple but efficient drawing packages like PHIGS [17] and SRGP <ref> [19] </ref>. 34
Reference: [20] <author> Robert C. Zeleznik, D. Brookshire Conner, Matthias M. Wloka, Daniel G. Aliaga, Nathan T. Huang, Philip M. Hubbard, Brian Knep, Henry Kaufman, John Hughes, and Andries van Dam. </author> <title> An Object-Oriented Framework for the Integration of Interactive Animation Techniques. </title> <booktitle> Proceedings of the ACM SIGGRAPH, Computer Graphics. </booktitle> <volume> Vol. 25, No. </volume> <month> 4 (Aug., </month> <year> 1991) </year>
Reference-contexts: Basically, a single interpolation algorithm is used for all interpolations. The interpolation of a structured data object is done by interpolating each of its elements. As in some graphic animation systems <ref> [20] </ref>, we can support multiple interpolation methods and let users choose one among them. 7 Conclusion The framework proposed here is different from other data visualization systems and algorithm animation systems in three aspects. First, it uses a preprocessor to find interesting points of a program and insert code automatically.
References-found: 20

