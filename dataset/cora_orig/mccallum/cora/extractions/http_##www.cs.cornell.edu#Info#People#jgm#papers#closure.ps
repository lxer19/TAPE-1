URL: http://www.cs.cornell.edu/Info/People/jgm/papers/closure.ps
Refering-URL: http://www.cs.cornell.edu/Info/People/jgm/tilt.html
Root-URL: 
Title: Typed Closure Conversion  
Author: Yasuhiko Minamide Greg Morrisett Robert Harper 
Note: Also published as Fox Memorandum CMU-CS-FOX-95-05 1 This research was performed while the author was visiting the Fox Project at Carnegie Mellon University; current address: Research  
Address: Pittsburgh, PA 15213  Kyoto 606-01, JAPAN.  
Affiliation: School of Computer Science Carnegie Mellon University  Institute for Mathematical Sciences, Kyoto University,  
Date: July 1995  
Pubnum: CMU-CS-95-171  
Abstract: This research was sponsored in part by the Advanced Research Projects Agency CSTO under the title "The Fox Project: Advanced Languages for Systems Software", ARPA Order No. C533, issued by ESC/ENS under Contract No. F19628-95-C-0050, and in part by the National Science Foundation under Grant No. CCR-9502674.. The views and conclusions contained in this document are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the Advanced Research Projects Agency or the U.S. Government. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the National Science Foundation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Abadi, L. Cardelli, P.-L. Curien, and J.-J.Levy. </author> <title> Explicit substitutions. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1990. </year>
Reference: [2] <author> A. W. Appel. </author> <title> Runtime tags aren't necessary. </title> <journal> Journal of Lisp and Symbolic Computation, </journal> <volume> 2 </volume> <pages> 153-162, </pages> <year> 1989. </year>
Reference-contexts: This can be used, for example, to support calling conventions where the environment is unboxed (i.e., placed in registers). As another example, tag-free garbage collection <ref> [5, 2, 37, 24] </ref> relies upon type information being associated with closures so that the shape of values in the environment can be reconstructed during garbage collection. In essence, garbage collection, like typecase, is a non-parametric operation that is allowed to examine types and select code according to the type.
Reference: [3] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference: [4] <author> A. W. Appel and T. Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1989. </year>
Reference: [5] <author> D. E. Britton. </author> <title> Heap storage management for the programming language Pascal. </title> <type> Master's thesis, </type> <institution> University of Arizona, </institution> <year> 1975. </year>
Reference-contexts: This can be used, for example, to support calling conventions where the environment is unboxed (i.e., placed in registers). As another example, tag-free garbage collection <ref> [5, 2, 37, 24] </ref> relies upon type information being associated with closures so that the shape of values in the environment can be reconstructed during garbage collection. In essence, garbage collection, like typecase, is a non-parametric operation that is allowed to examine types and select code according to the type.
Reference: [6] <author> L. Cardelli. </author> <title> The functional abstract machine. </title> <journal> Polymorphism, </journal> <volume> 1(1), </volume> <year> 1983. </year>
Reference: [7] <editor> C. Cousineau, P.-L. Curien, and M. Mauny. </editor> <booktitle> The categorical abstract machine. In Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 50-64, </pages> <year> 1985. </year>
Reference: [8] <author> H. Friedman. </author> <title> Equality between functionals. </title> <editor> In R. Parikh, editor, </editor> <booktitle> Logic Colloquium '75. </booktitle> <address> Norh-Holland, </address> <year> 1975. </year>
Reference: [9] <author> J. Hannan. </author> <title> A type system for closure conversion. </title> <booktitle> In The Workshop on Types for Program Analysis, </booktitle> <year> 1995. </year>
Reference: [10] <author> R. Harper and M. Lillibridge. </author> <title> Explicit polymorphism and CPS conversion. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1993. </year> <month> 37 </month>
Reference: [11] <author> R. Harper and M. Lillibridge. </author> <title> A type-theoretic approach to higher-order modules. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 123-137, </pages> <year> 1994. </year>
Reference-contexts: In short, we need a mixed-phase data structure that does not hide its type component. This same problem has been encountered in the study of the ML-like module systems [12, 21, 22]. Recent solutions are based on the idea of translucent sums <ref> [11] </ref> or manifest types [20], which provide the power of both existentials (weak sums), and transparent sums (strong sums). <p> As in the simply-typed case we have obtained an "object oriented" representation of polymorphic closures by exploiting a combination of the type systems proposed by Pierce and Turner [27] for objects and by Harper and Lillibridge <ref> [11] </ref> for modules. 5 A Formal Account of Polymorphic Closure Conversion In this section, we present closure conversion for the predicative subset of the second order - calculus.
Reference: [12] <author> R. Harper, D. MacQueen, and R. Milner. </author> <title> Standard ML. </title> <type> Technical Report ECS-LFCS-86-2, </type> <institution> Laboratory for the Foundations of Computer Science, Edinburgh University, </institution> <month> Mar. </month> <year> 1986. </year>
Reference-contexts: In short, we need a mixed-phase data structure that does not hide its type component. This same problem has been encountered in the study of the ML-like module systems <ref> [12, 21, 22] </ref>. Recent solutions are based on the idea of translucent sums [11] or manifest types [20], which provide the power of both existentials (weak sums), and transparent sums (strong sums).
Reference: [13] <author> R. Harper and J. C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 15(2), </volume> <year> 1993. </year>
Reference-contexts: Our type-based closure conversion makes the type information needed to support such non-parametric operations explicit. This provides further evidence that the treatment of closures as existentials is type-theoretically proper. 4 Overview of Polymorphic Closure Conversion Closure conversion for a language with ML-style (i.e., predicative <ref> [13] </ref>), explicit polymorphism follows a similar pattern to the simply-typed case, but with the additional complication that we must account for free type variables as well as free value variables in the code of an abstraction, and both value abstractions (-terms) and type abstractions (fl-terms) induce the creation of closures. <p> It has been argued that the predicative fragment captures the "essence" of ML-style polymorphism, since there is a stratification between monotypes (types not involving a quantifier) and polytypes, and instantiation of type variables is restricted to monotypes <ref> [13] </ref>. These restrictions make it easy to use logical relations to argue correctness in the same fashion as we did for the simply-typed -calculus. <p> A typing judgement is derived from the standard typing rules of the second-order -calculus (see for example <ref> [13, 14] </ref>).
Reference: [14] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 130-141, </pages> <year> 1995. </year>
Reference-contexts: However, in implementations where abstract types are not treated in a uniform matter, a representation of the type of the environment must remain as part of the data structure at runtime. In particular, the calculus described by Harper and Morrisett <ref> [14] </ref> supports a typecase mechanism that allows the abstract type to be examined and different code can be selected according to this type. This can be used, for example, to support calling conventions where the environment is unboxed (i.e., placed in registers). <p> A typing judgement is derived from the standard typing rules of the second-order -calculus (see for example <ref> [13, 14] </ref>).
Reference: [15] <author> T. Johnsson. </author> <title> Lambda lifting: Transforming programs to recursive equations. </title> <booktitle> In Functional Programming Language and Computer Architecture, </booktitle> <volume> LNCS 201, </volume> <pages> pages 190-203. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference: [16] <author> R. Kelsey and P. Hudak. </author> <title> Realistic compilation by program translation -detailed summary -. In ACM Symp. </title> <booktitle> on Principles of Programming Languages, </booktitle> <pages> pages 281-292, </pages> <year> 1989. </year>
Reference: [17] <author> D. Kranz et al. </author> <title> Orbit: An optimizing compiler for Scheme. </title> <booktitle> In Proc. of the SIGPLAN '86 Symp. on Compiler Construction, </booktitle> <year> 1986. </year>
Reference: [18] <author> P. Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer Journal, </journal> <volume> 6 </volume> <pages> 308-320, </pages> <year> 1964. </year>
Reference: [19] <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1992. </year>
Reference: [20] <author> X. Leroy. </author> <title> Manifest types, modules, and separate compilation. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 109-122, </pages> <year> 1994. </year>
Reference-contexts: In short, we need a mixed-phase data structure that does not hide its type component. This same problem has been encountered in the study of the ML-like module systems [12, 21, 22]. Recent solutions are based on the idea of translucent sums [11] or manifest types <ref> [20] </ref>, which provide the power of both existentials (weak sums), and transparent sums (strong sums).
Reference: [21] <author> D. MacQueen. </author> <title> Modules for Standard ML. </title> <booktitle> In Proc. ACM Conf. Lisp and Functional Programming, </booktitle> <pages> pages 198-207, </pages> <year> 1984. </year> <note> Revised version appears in [12]. </note>
Reference-contexts: In short, we need a mixed-phase data structure that does not hide its type component. This same problem has been encountered in the study of the ML-like module systems <ref> [12, 21, 22] </ref>. Recent solutions are based on the idea of translucent sums [11] or manifest types [20], which provide the power of both existentials (weak sums), and transparent sums (strong sums).
Reference: [22] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In short, we need a mixed-phase data structure that does not hide its type component. This same problem has been encountered in the study of the ML-like module systems <ref> [12, 21, 22] </ref>. Recent solutions are based on the idea of translucent sums [11] or manifest types [20], which provide the power of both existentials (weak sums), and transparent sums (strong sums).
Reference: [23] <author> J. C. Mitchell and G. D. Plotkin. </author> <title> Abstract types have existential type. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 10(3), </volume> <year> 1988. </year>
Reference: [24] <author> G. Morrisett, M. Felleisen, and R. Harper. </author> <title> Abstract models of memory management. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 66-77, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: This can be used, for example, to support calling conventions where the environment is unboxed (i.e., placed in registers). As another example, tag-free garbage collection <ref> [5, 2, 37, 24] </ref> relies upon type information being associated with closures so that the shape of values in the environment can be reconstructed during garbage collection. In essence, garbage collection, like typecase, is a non-parametric operation that is allowed to examine types and select code according to the type.
Reference: [25] <author> R. Morrison, A. Dearle, R. Connor, and A. L. Brown. </author> <title> An ad hoc approach to the implementation of polymorphism. </title> <journal> ACM Transaction on Programming Languages and Systems, </journal> <volume> 13(3), </volume> <year> 1991. </year>
Reference: [26] <author> A. Ohori. </author> <title> A compilation method for ML-style polymorphic record calculi. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1992. </year>
Reference: [27] <author> B. C. Pierce and D. N. Turner. </author> <title> Simple type-theoretic foundations for object-oriented programming. </title> <journal> Journal of Functional Programming, </journal> <volume> 4(2) </volume> <pages> 207-247, </pages> <month> Apr. </month> <year> 1994. </year> <note> A preliminary version appeared in Principles of Programming Languages, </note> <year> 1993, </year> <title> and as University of Edinburgh technical report ECS-LFCS-92-225, under the title "Object-Oriented Programming Without Recursive Types". </title> <type> 38 </type>
Reference-contexts: As in the simply-typed case we have obtained an "object oriented" representation of polymorphic closures by exploiting a combination of the type systems proposed by Pierce and Turner <ref> [27] </ref> for objects and by Harper and Lillibridge [11] for modules. 5 A Formal Account of Polymorphic Closure Conversion In this section, we present closure conversion for the predicative subset of the second order - calculus.
Reference: [28] <author> G. D. Plotkin. </author> <title> Lambda-definability in the full type hierarchy. In To H.B.Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism. </title> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference: [29] <author> U. S. Reddy. </author> <title> Objects as closures. </title> <booktitle> In Proc. ACM Conf. Lisp and Functional Programming, </booktitle> <year> 1988. </year>
Reference: [30] <author> J. C. Reynolds. </author> <title> Definitional interpreters for higher-order programming languages. </title> <booktitle> In Proceedings of the Annual ACM Conference, </booktitle> <pages> pages 717-740, </pages> <year> 1972. </year>
Reference: [31] <author> Z. Shao and A. W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In Proc. ACM Conf. Lisp and Functional Programming, </booktitle> <year> 1994. </year>
Reference: [32] <author> Z. Shao and A. W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In Programming Language Design and Its implemenation, </booktitle> <pages> pages 116-129, </pages> <year> 1995. </year>
Reference: [33] <author> R. Statman. </author> <title> Completeness, invariance, </title> <journal> and lambda-definability. Journal of Symbolic Logic, </journal> <volume> 47 </volume> <pages> 17-26, </pages> <year> 1982. </year>
Reference: [34] <author> R. Statman. </author> <title> Logical relations and the typed -calculus. </title> <journal> Information and Control, </journal> <volume> 65, </volume> <year> 1985. </year>
Reference: [35] <author> G. L. Steele Jr. Rabbit: </author> <title> A compiler for Scheme. </title> <type> Master's thesis, </type> <institution> MIT, </institution> <year> 1978. </year>
Reference: [36] <author> W. W. Tait. </author> <title> Intensional interpretation of functionals of finite type. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 32(2), </volume> <year> 1967. </year>
Reference: [37] <author> A. Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. ACM Conf. Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: This can be used, for example, to support calling conventions where the environment is unboxed (i.e., placed in registers). As another example, tag-free garbage collection <ref> [5, 2, 37, 24] </ref> relies upon type information being associated with closures so that the shape of values in the environment can be reconstructed during garbage collection. In essence, garbage collection, like typecase, is a non-parametric operation that is allowed to examine types and select code according to the type.
Reference: [38] <author> M. Wand and P. Steckler. </author> <title> Selective and lightweight closure conversion. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1994. </year> <month> 39 </month>
References-found: 38

