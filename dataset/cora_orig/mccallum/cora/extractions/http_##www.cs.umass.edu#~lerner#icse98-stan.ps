URL: http://www.cs.umass.edu/~lerner/icse98-stan.ps
Refering-URL: http://www.cs.umass.edu/~lerner/publications.html
Root-URL: 
Title: Experience Using the JIL Process Programming Language to Specify Design Processes  
Author: Stanley M. Sutton Jr., Barbara Staudt Lerner, and Leon J. Osterweil 
Address: Amherst, Massachusetts 01003  
Affiliation: Computer Science Department University of Massachusetts  
Abstract: Software design is a complex process that requires significant human involvement, collaboration, and coordinated use of tools and artifacts. Software design methods describe software design in general terms but neglect many details that are important to executing specific design processes. A process program that defines a design process clearly and precisely should be an important aid to supporting and reasoning about the process. The demands placed on a process programming language in defining a software design process are great, including the need for flexible control flow, error handling, resource management, agent coordination, and artifact consistency management. This paper describes the use of JIL, a process programming language, in the definition of a process supporting Booch object-oriented design. The paper illustrates the need for precision and clarity in defining software processes, and it indicates how various of the features of JIL are effective in meeting these needs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Sergio Bandinelli, Alfonso Fuggetta, and San-dro Grigolli. </author> <title> Process modeling in-the-large with SLANG. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 75-83. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1993. </year> <note> Submitted to ICSE '98 10 </note>
Reference-contexts: Workflow languages tend to be higher level but relatively limited computationally. For example, they typically lack support for some important kinds of process semantics (e.g., exception handling). Many languages have been proposed for software process programming, but many of these bear close resemblance to programming languages (e.g., <ref> [4, 14, 10, 9, 8, 1] </ref>) or to workflow languages (e.g., [6, 2]), and thus they tend to suffer from the same limitations. In this section, we elaborate on selected aspects of design processes with examples from BOOD, providing explanation of how JIL supports these aspects of the design process.
Reference: [2] <author> Gregory A. Bolcer and Richard N. Taylor. Endeav--ors: </author> <title> A process system integration infrastructure. </title> <booktitle> In Proc. of the Fourth International Conference on the Software Process, </booktitle> <pages> pages 76 - 85. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1996. </year>
Reference-contexts: For example, they typically lack support for some important kinds of process semantics (e.g., exception handling). Many languages have been proposed for software process programming, but many of these bear close resemblance to programming languages (e.g., [4, 14, 10, 9, 8, 1]) or to workflow languages (e.g., <ref> [6, 2] </ref>), and thus they tend to suffer from the same limitations. In this section, we elaborate on selected aspects of design processes with examples from BOOD, providing explanation of how JIL supports these aspects of the design process.
Reference: [3] <author> G. Booch. </author> <title> Object-Oriented Analysis and Design with Applications. </title> <publisher> Benjamin Cummings, </publisher> <address> Redwood City, CA, </address> <note> second edition edition, </note> <year> 1994. </year>
Reference-contexts: Numerous researchers have proposed object-oriented design methods to help designers approach design processes in a systematic fashion with the goal of achieving higher quality designs as a result <ref> [3, 11, 5, 19, 7] </ref>. Numerous tools, such as Rational Rose, Graphical Designer, and Paradigm Plus 1 have been developed to support these methods, 1 Rational Rose-http://www.rational.com/products/rose/; Graphical Designer-http://www.advancedsw.com/; Paradigm Plus-http://www.platinum.com/products/appdev/pplus - ps.htm. <p> Moreover, the users of a process must feel that it is providing support and guidance rather than authoritarian control. In this paper, we use Booch Object Oriented Design (BOOD) <ref> [3] </ref> as an example method to demonstrate how the constructs in JIL provide the functionality to meet the demands of design process specification. <p> This is typically an embedding of substep invocations into traditional programming constructs. 2 2 Note that activity as used in this paper generally refers to a JIL language construct, not to elements of a design method as in Booch <ref> [3] </ref>. Submitted to ICSE '98 2 STEP Booch_Process IS OBJECTS Req_file: FILE; Data_dictionary: DICTIONARY; Interface_file: FILE; ... STEPS: Identify_Classes_and_Objects; Identify_Class_and_Object_Semantics; Identify_Class_and_Object_Relationships; Implement_Classes_and_Objects; Propagate_Requirements_Update; ACTIVITY: Booch_Process_Activity; REACTIONS: Booch_Process_Reactions; PRECONDITIONS: FROM Requirements_Constraints USE Approved (Requirements_File); ... POSTCONDITIONS: FROM Design_Constraints USE Interface_Files_Complete ( Data_Dictionary, Interface_Files); ...
Reference: [4] <author> Don Cohen. </author> <title> AP5 Manual. </title> <institution> Univ. of Southern Cali-fornia, Information Sciences Institute, </institution> <month> March </month> <year> 1988. </year>
Reference-contexts: Workflow languages tend to be higher level but relatively limited computationally. For example, they typically lack support for some important kinds of process semantics (e.g., exception handling). Many languages have been proposed for software process programming, but many of these bear close resemblance to programming languages (e.g., <ref> [4, 14, 10, 9, 8, 1] </ref>) or to workflow languages (e.g., [6, 2]), and thus they tend to suffer from the same limitations. In this section, we elaborate on selected aspects of design processes with examples from BOOD, providing explanation of how JIL supports these aspects of the design process.
Reference: [5] <author> D. Coleman, P. Arnold, S. Bodoff, C. Dollin, H. Gilchrist, F. Hayes, and P. Jeremaes. </author> <title> Object-Oriented Development: The FUSION Method. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1994. </year>
Reference-contexts: Numerous researchers have proposed object-oriented design methods to help designers approach design processes in a systematic fashion with the goal of achieving higher quality designs as a result <ref> [3, 11, 5, 19, 7] </ref>. Numerous tools, such as Rational Rose, Graphical Designer, and Paradigm Plus 1 have been developed to support these methods, 1 Rational Rose-http://www.rational.com/products/rose/; Graphical Designer-http://www.advancedsw.com/; Paradigm Plus-http://www.platinum.com/products/appdev/pplus - ps.htm.
Reference: [6] <author> Christer Fernstrom. </author> <title> PROCESS WEAVER: Adding process support to UNIX. </title> <booktitle> In Proc. of the Second International Conference on the Software Process, </booktitle> <pages> pages 12 - 26, </pages> <year> 1993. </year>
Reference-contexts: For example, they typically lack support for some important kinds of process semantics (e.g., exception handling). Many languages have been proposed for software process programming, but many of these bear close resemblance to programming languages (e.g., [4, 14, 10, 9, 8, 1]) or to workflow languages (e.g., <ref> [6, 2] </ref>), and thus they tend to suffer from the same limitations. In this section, we elaborate on selected aspects of design processes with examples from BOOD, providing explanation of how JIL supports these aspects of the design process.
Reference: [7] <author> I. Jacobson, M. Christerson, P. Jonsson, and G. Overgaard. </author> <title> Object-Oriented Software Engineering: A Use Case Driven Approach. </title> <publisher> ACM Press, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Numerous researchers have proposed object-oriented design methods to help designers approach design processes in a systematic fashion with the goal of achieving higher quality designs as a result <ref> [3, 11, 5, 19, 7] </ref>. Numerous tools, such as Rational Rose, Graphical Designer, and Paradigm Plus 1 have been developed to support these methods, 1 Rational Rose-http://www.rational.com/products/rose/; Graphical Designer-http://www.advancedsw.com/; Paradigm Plus-http://www.platinum.com/products/appdev/pplus - ps.htm.
Reference: [8] <author> G. Junkermann, B. Peuschel, W. Schafer, and S Wolf. MERLIN: </author> <title> Supporting cooperation in software development through a knowledge-based environment. </title> <editor> In A. Finkelstein, J. Kramer, and B. Nuseibeh, editors, </editor> <booktitle> Software Process Modelling and Technology, </booktitle> <pages> pages 103 - 129. </pages> <publisher> John Wiley & Sons Inc., </publisher> <year> 1994. </year>
Reference-contexts: Workflow languages tend to be higher level but relatively limited computationally. For example, they typically lack support for some important kinds of process semantics (e.g., exception handling). Many languages have been proposed for software process programming, but many of these bear close resemblance to programming languages (e.g., <ref> [4, 14, 10, 9, 8, 1] </ref>) or to workflow languages (e.g., [6, 2]), and thus they tend to suffer from the same limitations. In this section, we elaborate on selected aspects of design processes with examples from BOOD, providing explanation of how JIL supports these aspects of the design process.
Reference: [9] <author> Gail E. Kaiser, Naser S. Barghouti, and Michael H. Sokolsky. </author> <title> Experience with process modeling in the marvel software development environment kernel. </title> <editor> In Bruce Shriver, editor, </editor> <booktitle> 23rd Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 131-140, </pages> <address> Kona HI, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: Workflow languages tend to be higher level but relatively limited computationally. For example, they typically lack support for some important kinds of process semantics (e.g., exception handling). Many languages have been proposed for software process programming, but many of these bear close resemblance to programming languages (e.g., <ref> [4, 14, 10, 9, 8, 1] </ref>) or to workflow languages (e.g., [6, 2]), and thus they tend to suffer from the same limitations. In this section, we elaborate on selected aspects of design processes with examples from BOOD, providing explanation of how JIL supports these aspects of the design process.
Reference: [10] <author> Takuya Katayama. </author> <title> A hierarchical and functional software process description and its enaction. </title> <booktitle> In Proc. of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 343 - 353. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference-contexts: Workflow languages tend to be higher level but relatively limited computationally. For example, they typically lack support for some important kinds of process semantics (e.g., exception handling). Many languages have been proposed for software process programming, but many of these bear close resemblance to programming languages (e.g., <ref> [4, 14, 10, 9, 8, 1] </ref>) or to workflow languages (e.g., [6, 2]), and thus they tend to suffer from the same limitations. In this section, we elaborate on selected aspects of design processes with examples from BOOD, providing explanation of how JIL supports these aspects of the design process.
Reference: [11] <author> J. Rumbaugh, M. Blaha, W. Premerlani, F. Eddy, and W. Lorensen. </author> <title> Object-Oriented Modeling and Design. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: Numerous researchers have proposed object-oriented design methods to help designers approach design processes in a systematic fashion with the goal of achieving higher quality designs as a result <ref> [3, 11, 5, 19, 7] </ref>. Numerous tools, such as Rational Rose, Graphical Designer, and Paradigm Plus 1 have been developed to support these methods, 1 Rational Rose-http://www.rational.com/products/rose/; Graphical Designer-http://www.advancedsw.com/; Paradigm Plus-http://www.platinum.com/products/appdev/pplus - ps.htm.
Reference: [12] <author> Xiping Song and Leon J. Osterweil. </author> <title> Engineering software design processes to guide process execution. </title> <booktitle> In Proc. of the Third International Conference on the Software Process, </booktitle> <pages> pages 135 - 152, </pages> <year> 1994. </year>
Reference-contexts: They do not aim to support the processes by which these artifacts are developed, evaluated, and evolved. A process program can provide the framework that allows such tools to be used effectively within the guidelines of these methods <ref> [12] </ref>. Even when a specific method is used, object-oriented design remains an activity that is inherently iterative, has a flexible flow of control, and, perhaps most importantly, is largely driven by human innovation.
Reference: [13] <author> Xiping Song and Leon J. Osterweil. </author> <title> Experience with an approach to comparing software design methodologies. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 20(5) </volume> <pages> 364-384, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: In effect, they define generic process architectures <ref> [13] </ref>. Design methods also typically emphasize nominal behavior, that is, they describe how the design process would proceed under ideal conditions. They tend to omit aspects related to handling errors, propagating changes, and accommodating inconsistencies.
Reference: [14] <author> Stanley M. Sutton, Jr., Dennis Heimbigner, and Leon J. Osterweil. APPL/A: </author> <title> A language for software-process programming. </title> <journal> ACM Trans. on Software Engineering and Methodology, </journal> <volume> 4(3) </volume> <pages> 221-286, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Workflow languages tend to be higher level but relatively limited computationally. For example, they typically lack support for some important kinds of process semantics (e.g., exception handling). Many languages have been proposed for software process programming, but many of these bear close resemblance to programming languages (e.g., <ref> [4, 14, 10, 9, 8, 1] </ref>) or to workflow languages (e.g., [6, 2]), and thus they tend to suffer from the same limitations. In this section, we elaborate on selected aspects of design processes with examples from BOOD, providing explanation of how JIL supports these aspects of the design process.
Reference: [15] <author> Stanley M. Sutton, Jr. and Leon J. Osterweil. </author> <title> The design of a next-generation process language. </title> <type> Technical Report CMPSCI Technical Report 96-30, </type> <institution> University of Massachusetts at Amherst, Computer Science Department, </institution> <address> Amherst, Mas-sachusetts 01003, </address> <month> May </month> <year> 1996. </year> <note> revised January, </note> <year> 1997. </year>
Reference-contexts: The Julia process-execution engine is designed to support the execution of JIL process programs (JIL stands for Julia Input Language). Julia will provide a variety of services related to the execution of JIL process programs and management of JIL processes. The Julia architecture is discussed in more detail in <ref> [15] </ref>; relevant aspects are discussed here where appropriate. 4 Supporting Design Processes Design methods are typically described in relatively general terms, omitting many details so as to be adaptable to, and adoptable by, a wide variety of organizations and projects. In effect, they define generic process architectures [13].
Reference: [16] <author> Stanley M. Sutton, Jr. and Leon J. Osterweil. </author> <title> The design of a next-generation process language. </title> <booktitle> In Proceedings of the Joint 6th European Software Engineering Conference and the 5th ACM SIGSOFT Symposium on the Foundations of Software Engineering. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: A major obstacle in presenting demonstrably effective processes has been the lack of languages that are adequate vehicles for this. In our past work we have presented languages designed to support the clear and precise exposition of process. Most recently we have proposed that the JIL <ref> [16] </ref> process programming language incorporates a mix of features and abstractions that seem to offer promise of supporting the clear and precise exposition of complex This work was supported by the Advanced Research Projects Agency under grant F30602-94-C-0137 and F30602-97-2-0032. software process ideas. <p> The value of these capabilities increases with more complex designs and larger design teams. 3 Overview of JIL JIL <ref> [16] </ref> is a process-programming language intended to support the development of high-level process abstractions through a collection of powerful and easy to use semantic constructs. JIL represents processes as compositions of steps. The specification of a step is defined in terms of a number of elements. <p> The following is an example of a handler that copes with the failure to acquire a needed resource during the initialization of a step: HANDLE Resource_Acquisition_Error BY IF Resource_Of ( Resource_Acquisition_Error) = Design_Tool THEN AWAIT EVENT Resource_Available (Design_Tool); CONTINUE; END IF; END HANDLE; (Additional structured forms of handler are defined <ref> [16] </ref>.) Besides resource management errors, exception handlers are also useful for dealing with typical programming errors and with exceptions raised by violations of consistency conditions on design artifacts or process state (discussed in Section 4.4). If a step handles an exception successfully, the step may be terminated successfully or retried.
Reference: [17] <author> Stanley M. Sutton, Jr. and Leon J. Osterweil. </author> <booktitle> Programming parallel workflows in JIL. In Proceedings of the 9th International Conference on Parallel and Distributed Computing and Systems, </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: The JIL command syntax includes familiar forms of iteration and branching statements. JIL also adds a PARALLEL command and commands by which substeps can be invoked as threads or separate programs. (The programming of parallel workflows in JIL is discussed at length in <ref> [17] </ref>.) An example of an activity body representing an implementation for step Identify Classes And Objects is presented in Figure 2. The process program for this activity, although more complex than the examples of step execution constraints, is still straightforward.
Reference: [18] <author> Peri L. Tarr and Lori A. Clarke. PLEIADES: </author> <title> An Object Management System for Software Engineering Environments. </title> <booktitle> In Proceedings of the First ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 56-70. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> December </month> <year> 1993. </year>
Reference-contexts: In this section, we briefly discuss artifact definition and illustrate the way in which JIL integrates artifact consistency management into the executable aspects of process programs. 4.4.1 Artifact Definition In JIL, artifact definition and management is done using Pleiades <ref> [18] </ref>, a persistent object management system. Artifacts are decomposed into collections of interrelated objects. This decomposition allows for simple concurrent manipulation of an artifact by allowing designers to work on nonintersecting sets of objects.
Reference: [19] <author> R. Wirfs-Brock, B. Wilkerson, and L. Weiner. </author> <title> Designing Object-Oriented Software. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1990. </year> <note> Submitted to ICSE '98 11 </note>
Reference-contexts: Numerous researchers have proposed object-oriented design methods to help designers approach design processes in a systematic fashion with the goal of achieving higher quality designs as a result <ref> [3, 11, 5, 19, 7] </ref>. Numerous tools, such as Rational Rose, Graphical Designer, and Paradigm Plus 1 have been developed to support these methods, 1 Rational Rose-http://www.rational.com/products/rose/; Graphical Designer-http://www.advancedsw.com/; Paradigm Plus-http://www.platinum.com/products/appdev/pplus - ps.htm.
References-found: 19

