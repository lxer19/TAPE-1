URL: http://www.cs.jhu.edu/~sullivan/onlinedata.ps
Refering-URL: http://www.cs.jhu.edu/~sullivan/ftdownload.html
Root-URL: http://www.cs.jhu.edu
Title: On-line Error Monitoring for Several Data Structures  
Author: Jonathan D. Bright Gregory F. Sullivan 
Address: Murray Hill, New Jersey 07974  Baltimore, Maryland 21218  
Affiliation: AT&T Bell Laboratories,  Computer Science Department, Johns Hopkins University  
Abstract: We present several examples of programs which efficiently monitor the answers from queries performed on data structures to determine if any errors are present. Our paper includes the first efficient on-line error monitor for a data structure designed to perform nearest neighbor queries. Applications of nearest neighbor queries are extensive and include learning, categorization, speech processing, and data compression. Our paper also discusses on-line error monitors for priority queues and splittable priority queues. On-line error monitors immediately detect if an error is present in the answer to a query. An error monitor which is not on-line may delay the time of detection until a later query is being processed which may allow the error to propagate or may cause irreversible state changes. On-line monitors can allow a more rapid and accurate response to an error. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Amato, N. M., Loui, M. C., </author> <title> "Checking Linked Data Structures," </title> <booktitle> Dig. 24th FTCS, </booktitle> <year> 1994, </year> <pages> pp. 164-173. </pages>
Reference-contexts: richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers [4, 5], algorithm-based methods [12, 16], robust data structures [13, 14, 24, 25, 26], certification trails [20, 21, 22, 23, 27], and other methods <ref> [1] </ref>. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries. For many programs a substantial fraction of the intricate error-prone code resides in the routines associated with data structure access.
Reference: [2] <author> Arya, S., Mount D. M., Netanyahu, N. S., Silver-man, R., and Wu, A., </author> <title> "An Optimal Algorithm for Approximate Nearest-Neighbor Searching", </title> <booktitle> Proc. 5th Ann. Symp. Disc. Alg., </booktitle> <year> 1994, </year> <pages> pp. 573-582. </pages>
Reference-contexts: The final data structure we discuss is called a multidi-mensional search tree. Multidimensional search trees have a variety of uses, and in this paper we discuss checking the correctness of nearest neighbor queries, and a recently introduced variant called approximate nearest neighbor queries <ref> [6, 8, 2] </ref>. Applications of nearest neighbor queries are extensive and include learning, categorization, speech processing, and data compression [8, 11]. For the case of approximate nearest neighbor queries, the second phase checker program runs in only O (1) time per operation.
Reference: [3] <author> Avizienis, A., </author> <title> "The N-version approach to fault tolerant software," </title> <journal> Trans. Soft. Eng., v. </journal> <volume> 11, </volume> <pages> pp. 1491-1501, </pages> <year> 1985. </year>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming <ref> [3] </ref>, program checkers [4, 5], algorithm-based methods [12, 16], robust data structures [13, 14, 24, 25, 26], certification trails [20, 21, 22, 23, 27], and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries.
Reference: [4] <author> Blum, M., and Kannan, S., </author> <title> "Designing Programs that Check their Work", </title> <booktitle> Proc. 21st STOC, </booktitle> <year> 1989, </year> <pages> pp. 86-97. </pages>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers <ref> [4, 5] </ref>, algorithm-based methods [12, 16], robust data structures [13, 14, 24, 25, 26], certification trails [20, 21, 22, 23, 27], and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries.
Reference: [5] <author> Bright, J., and Sullivan, G., </author> <title> "Checking Mergeable Priority Queues," </title> <booktitle> Dig. 24th FTCS, </booktitle> <pages> pp. 144-153. </pages>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers <ref> [4, 5] </ref>, algorithm-based methods [12, 16], robust data structures [13, 14, 24, 25, 26], certification trails [20, 21, 22, 23, 27], and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries. <p> Checkers which are also referred to as error monitors in this paper have been developed for priority queues, the union/find data type, and most recently mergeable priority queues and have been shown to require only O (n) time to check a sequence of n operations <ref> [5, 21, 23] </ref>.
Reference: [6] <author> Callahan, P. C., and Kosaraju, S. R., </author> <title> "A Decomposition of Multi-Dimensional Point-sets with Applications to k-nearest-neighbors and n-body Potential Fields," </title> <booktitle> Proc. 24th ACM STOC, </booktitle> <year> 1992, </year> <pages> pp. 546-556. </pages>
Reference-contexts: The final data structure we discuss is called a multidi-mensional search tree. Multidimensional search trees have a variety of uses, and in this paper we discuss checking the correctness of nearest neighbor queries, and a recently introduced variant called approximate nearest neighbor queries <ref> [6, 8, 2] </ref>. Applications of nearest neighbor queries are extensive and include learning, categorization, speech processing, and data compression [8, 11]. For the case of approximate nearest neighbor queries, the second phase checker program runs in only O (1) time per operation. <p> Others do not, and for these we do not need to compute the Inner labels. A theoretically interesting method for choosing the splitting hyperplane at each internal node was developed by Callahan and Kosaraju <ref> [6] </ref>, and the resulting decomposition is called the fair split tree. A fair split tree can be built in O (n log n) time on a data set containing n points.
Reference: [7] <author> Cormen, T. H., Leiserson, C. E., and Rivest, R. L., </author> <title> Introduction to Algorithms, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The leaves of the two-three tree in left to right order correspond to the elements of S in sorted order. The operations insert, delete, deletemin, min , predecessor , successor , and split are all handled using standard two-three tree operations <ref> [7] </ref>. We now discuss the certification trail output by CertSSDS 1 . The operations min, deletemin, makeset, predecessor, successor and delete all have nil for a certification trail. The certification trail for the operation insert ((it ; val ); S ) is pred ((it ; val ); S ). <p> Their most powerful result achieves constant time for both update and query operations on a list. The authors also present much a simpler algorithm which achieves constant running time per operation in an amortized <ref> [7] </ref> sense. The reader the should consult [9] for details on these algorithms, and also heuristics that will likely work well in practice.
Reference: [8] <author> Dasarathy, B. V., </author> <title> "Nearest Neighbor (NN) Norms: NN Pattern Classification Techniques", </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: The final data structure we discuss is called a multidi-mensional search tree. Multidimensional search trees have a variety of uses, and in this paper we discuss checking the correctness of nearest neighbor queries, and a recently introduced variant called approximate nearest neighbor queries <ref> [6, 8, 2] </ref>. Applications of nearest neighbor queries are extensive and include learning, categorization, speech processing, and data compression [8, 11]. For the case of approximate nearest neighbor queries, the second phase checker program runs in only O (1) time per operation. <p> Applications of nearest neighbor queries are extensive and include learning, categorization, speech processing, and data compression <ref> [8, 11] </ref>. For the case of approximate nearest neighbor queries, the second phase checker program runs in only O (1) time per operation. There are a variety of techniques in the fault tolerance area which are related to program checkers and certification trails and we will now briefly discuss three.
Reference: [9] <author> Dietz, P. F., and Sleator, D. D., </author> <title> "Two Algorithms for Maintaining Order in a List," </title> <booktitle> Proc. 19th ACM STOC, </booktitle> <year> 1987, </year> <pages> pp. 365-372. </pages>
Reference-contexts: All the doubly linked lists are combined into a single doubly linked list with special `marker' nodes. The set name fields are omitted from the nodes. Below we show how to use the powerful list ordering result of Dietz and Sleator <ref> [9] </ref> to perform tests which prevent the incorrect insertion problem described above. The two phases of the full solution are described below by the algorithms CertSSDS 1 and CertSSDS 2 . Procedure CertSSDS 1 : we represent the elements of a set S as a two-three tree. <p> The only difficulty occurs in CertSSDS 2 when we need to perform checks such as determining whether the pointer where [it 0 ] falls be tween the pointers start (S ) and end (S ) in L. For this we use a result of Dietz and Sleator <ref> [9] </ref> which allows one to perform a sequence of insert and delete oper ations on a linked list, intermixed with queries of the following form: given pointers to two elements of the linked list, determine the relative order of the elements pointed to. <p> Their most powerful result achieves constant time for both update and query operations on a list. The authors also present much a simpler algorithm which achieves constant running time per operation in an amortized [7] sense. The reader the should consult <ref> [9] </ref> for details on these algorithms, and also heuristics that will likely work well in practice.
Reference: [10] <author> Guibas, L., Hershberger, J., Leven, D., Sharir, M., Tarjan, R. E., </author> <title> "Linear Time Algorithms for Visibility and Shortest Path Problems Inside Triangulated Simple Polygons," </title> <booktitle> Algorithmica 2 (1987), </booktitle> <pages> 209-223. </pages>
Reference-contexts: The splitting strategy chosen affects the structure of the tree, and also the running time of query procedures on the tree. When a particular splitting strategy produces a highly unbalanced tree, it may be necessary to artificially balance the tree using a centroid decomposition <ref> [10] </ref> or some other technique. Such restructuring is necessary in only unusual circumstances. However, while different splitting strategies can lead to different running times for the query algorithms, the correctness of a query algorithm does not, in general, depend on the splitting strategy chosen.
Reference: [11] <author> Gersho, A., and Gray, R. M., </author> <title> "Vector Quantization and Signal Compression", </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston 1993. </address>
Reference-contexts: Applications of nearest neighbor queries are extensive and include learning, categorization, speech processing, and data compression <ref> [8, 11] </ref>. For the case of approximate nearest neighbor queries, the second phase checker program runs in only O (1) time per operation. There are a variety of techniques in the fault tolerance area which are related to program checkers and certification trails and we will now briefly discuss three.
Reference: [12] <author> Huang, K.-H., and Abraham, J., </author> <title> "Algorithm-based Fault Tolerance for Matrix Operations," </title> <journal> IEEE TOC, pp. </journal> <volume> 518-529, vol. C-33, </volume> <month> June, </month> <year> 1984. </year>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers [4, 5], algorithm-based methods <ref> [12, 16] </ref>, robust data structures [13, 14, 24, 25, 26], certification trails [20, 21, 22, 23, 27], and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries.
Reference: [13] <author> Kanawati, N. A., Kanawati, G. A., Abraham, J. A., </author> <title> "A Modular Robust Binary Tree," </title> <address> DCCA-4, </address> <month> Jan-uary </month> <year> 1994. </year>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers [4, 5], algorithm-based methods [12, 16], robust data structures <ref> [13, 14, 24, 25, 26] </ref>, certification trails [20, 21, 22, 23, 27], and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries. <p> The programs discussed in this paper can function as acceptance tests. Finally, we mention the notion of a repairable or robust data structure <ref> [13, 14, 24, 25, 26] </ref>. In this technique, a data structure is augmented with additional information, such as redundant values and links.
Reference: [14] <author> Kant, K., and Ravichandran, A., </author> <title> "Synthesizing Robust Data Structures An Introduction," </title> <journal> IEEE TOC, pp. </journal> <volume> 161-173, vol. 39, </volume> <month> Feb., </month> <year> 1990. </year>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers [4, 5], algorithm-based methods [12, 16], robust data structures <ref> [13, 14, 24, 25, 26] </ref>, certification trails [20, 21, 22, 23, 27], and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries. <p> The programs discussed in this paper can function as acceptance tests. Finally, we mention the notion of a repairable or robust data structure <ref> [13, 14, 24, 25, 26] </ref>. In this technique, a data structure is augmented with additional information, such as redundant values and links.
Reference: [15] <author> Mahmood, A., McCluskey, E., </author> <title> "Concurrent Error Detection Using Watchdog Processors a Survey," </title> <journal> IEEE TOC, pp. </journal> <volume> 160-174, vol. 37, </volume> <month> Feb., </month> <year> 1988. </year>
Reference-contexts: Some fault tolerance techniques, such as watchdog monitor processors <ref> [15] </ref>, are very effective at detecting program failures, but can be ineffective at detecting failures which lead only to incorrect output.
Reference: [16] <author> Nair, V. S. S., and Abraham, J. A., </author> <title> "General Linear Codes for Fault-tolerant Matrix Operations on Processor Arrays," </title> <booktitle> Dig. 18th FTCS, </booktitle> <year> 1988, </year> <pages> pp. 180-185. </pages>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers [4, 5], algorithm-based methods <ref> [12, 16] </ref>, robust data structures [13, 14, 24, 25, 26], certification trails [20, 21, 22, 23, 27], and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries.
Reference: [17] <author> Preparata, F. P., and Shamos, M. I., </author> <title> "Computational Geometry", </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: We now describe a general method for preprocessing a multi-dimensional point set. We assume that no two points have the same coordinate for any axis. The basic idea is to construct a multi-dimensional search tree <ref> [17] </ref>. Each node v in the tree has the labels Outer (v ) and Split (v ), which we define shortly. Each leaf node of the tree stores exactly one point in the data set. Let u be a node, which will be the root of the tree.
Reference: [18] <author> Randell, B., </author> <title> "System Structure for Software Fault Tolerance," </title> <journal> IEEE Trans. on Soft. Eng., </journal> <volume> vol. 1, </volume> <pages> pp. 220-232, </pages> <month> June, </month> <year> 1975. </year>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks <ref> [18] </ref>, N-version programming [3], program checkers [4, 5], algorithm-based methods [12, 16], robust data structures [13, 14, 24, 25, 26], certification trails [20, 21, 22, 23, 27], and other methods [1]. <p> Generally, faults are detected with a high probability. If the number of faults that occur can be bounded by some small constant, then algorithm-based fault tolerance techniques will often be guaranteed to detect the error. The second idea that we discuss is that of an acceptance test <ref> [18] </ref>. In the acceptance test method, after a computation has been finished and before the answer has been output, some checks are performed on the result to determine if an error has occurred. If an error is detected then various steps can be taken to remedy the situation. <p> If an error is detected then various steps can be taken to remedy the situation. Acceptance tests are part of a larger scheme called recovery blocks <ref> [18] </ref>. One may structure a program so that it consists of a set of recovery blocks which may be disjoint or nested.
Reference: [19] <author> Schieber, B., and Vishkin, U., </author> <title> "On Finding Lowest Common Ancestors: Simplification and Paralleliza-tion," </title> <journal> SIAM J. Comp., </journal> <volume> vol. 17, </volume> <year> 1988, </year> <pages> 1253-1262. </pages>
Reference-contexts: To check the third condition, we assume that lowest common ancestor preprocessing has been performed on the tree (such preprocessing can be performed in O (n) time <ref> [19] </ref>). Then jAj fl jAj lowest common ancestor queries can verify that no node in A is an ancestor of another node in A (and hence no node in A is a descendant of another node in A).
Reference: [20] <author> Sullivan, G. F., and Masson, G. M., </author> <title> "Using Certification Trails to Achieve Software Fault Tolerance," </title> <booktitle> Dig. 20th FTCS, </booktitle> <year> 1990, </year> <pages> pp. 423-431. </pages>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers [4, 5], algorithm-based methods [12, 16], robust data structures [13, 14, 24, 25, 26], certification trails <ref> [20, 21, 22, 23, 27] </ref>, and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries. For many programs a substantial fraction of the intricate error-prone code resides in the routines associated with data structure access. <p> This basic idea was one of the motivations for the introduction of the certification trail technique <ref> [20, 23] </ref>. Here, a program which is called the first phase computes the answer to the problem, but is also modified to output additional information called a certification trail. A second phase program reads the input, the answer, and the certification trail. <p> This is a slight generalization of the result for a single instance of the search data structure which was implicit in an earlier paper <ref> [20] </ref>. Next we build on this result to design an error monitor for a splittable search data structure (SSDS). In addition to the operations above an SSDS supports the operation split. Note, this includes the functionality of a spittable priority queue. <p> When an error is detected a repair of the data structure could be automatically undertaken. 1.1 The Certification Trail Technique A formal description of the certification trail technique is given below. Note, this is a slight reformulation of the original certification trail definition <ref> [20] </ref> in which F 2 recom puted the output which was then compared to the output of F 1 instead of performing the comparison directly. <p> The certification trail technique has been applied to a wide variety of problems in computer science such as sorting, constructing convex hulls, finding minimum spanning trees, performing sequences of priority queue operations, constructing Huffman trees, finding the closest pair of points in a set, and many others <ref> [20, 21, 22, 23, 27] </ref>. The savings in running time for the second phase as compared to the second execution for two-version programming for these examples range from about 75% to about 90%.
Reference: [21] <author> Sullivan, G. F., and Masson, G. M., </author> <title> "Certification Trails for Data Structures," </title> <booktitle> 1991 FTCS, </booktitle> <pages> 240-247. </pages>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers [4, 5], algorithm-based methods [12, 16], robust data structures [13, 14, 24, 25, 26], certification trails <ref> [20, 21, 22, 23, 27] </ref>, and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries. For many programs a substantial fraction of the intricate error-prone code resides in the routines associated with data structure access. <p> Checkers which are also referred to as error monitors in this paper have been developed for priority queues, the union/find data type, and most recently mergeable priority queues and have been shown to require only O (n) time to check a sequence of n operations <ref> [5, 21, 23] </ref>. <p> The certification trail technique has been applied to a wide variety of problems in computer science such as sorting, constructing convex hulls, finding minimum spanning trees, performing sequences of priority queue operations, constructing Huffman trees, finding the closest pair of points in a set, and many others <ref> [20, 21, 22, 23, 27] </ref>. The savings in running time for the second phase as compared to the second execution for two-version programming for these examples range from about 75% to about 90%.
Reference: [22] <author> Sullivan, G. F., Wilson, D. S., and Masson, G. M., </author> <title> "Certification Trails and Software Design for Testability," </title> <booktitle> Proc. 1993 Inter. Test Conf., </booktitle> <pages> pp. 200-209. </pages>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers [4, 5], algorithm-based methods [12, 16], robust data structures [13, 14, 24, 25, 26], certification trails <ref> [20, 21, 22, 23, 27] </ref>, and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries. For many programs a substantial fraction of the intricate error-prone code resides in the routines associated with data structure access. <p> The certification trail technique has been applied to a wide variety of problems in computer science such as sorting, constructing convex hulls, finding minimum spanning trees, performing sequences of priority queue operations, constructing Huffman trees, finding the closest pair of points in a set, and many others <ref> [20, 21, 22, 23, 27] </ref>. The savings in running time for the second phase as compared to the second execution for two-version programming for these examples range from about 75% to about 90%.
Reference: [23] <author> Sullivan, G. F., Wilson, D. S., and Masson, G. M., </author> <title> "Certification of Computational Results," </title> <journal> IEEE TOC, </journal> <note> to appear. </note>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers [4, 5], algorithm-based methods [12, 16], robust data structures [13, 14, 24, 25, 26], certification trails <ref> [20, 21, 22, 23, 27] </ref>, and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries. For many programs a substantial fraction of the intricate error-prone code resides in the routines associated with data structure access. <p> Checkers which are also referred to as error monitors in this paper have been developed for priority queues, the union/find data type, and most recently mergeable priority queues and have been shown to require only O (n) time to check a sequence of n operations <ref> [5, 21, 23] </ref>. <p> This basic idea was one of the motivations for the introduction of the certification trail technique <ref> [20, 23] </ref>. Here, a program which is called the first phase computes the answer to the problem, but is also modified to output additional information called a certification trail. A second phase program reads the input, the answer, and the certification trail. <p> The certification trail technique has been applied to a wide variety of problems in computer science such as sorting, constructing convex hulls, finding minimum spanning trees, performing sequences of priority queue operations, constructing Huffman trees, finding the closest pair of points in a set, and many others <ref> [20, 21, 22, 23, 27] </ref>. The savings in running time for the second phase as compared to the second execution for two-version programming for these examples range from about 75% to about 90%.
Reference: [24] <author> Taylor, D. J., Morgan, D. E., Black, J. P., </author> <title> "Redundancy in Data Structures: Improving Software Fault Tolerance," </title> <journal> Trans. Soft. Eng., </journal> <pages> 585-594, </pages> <editor> v. </editor> <volume> 6, </volume> <year> 1980. </year>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers [4, 5], algorithm-based methods [12, 16], robust data structures <ref> [13, 14, 24, 25, 26] </ref>, certification trails [20, 21, 22, 23, 27], and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries. <p> The programs discussed in this paper can function as acceptance tests. Finally, we mention the notion of a repairable or robust data structure <ref> [13, 14, 24, 25, 26] </ref>. In this technique, a data structure is augmented with additional information, such as redundant values and links.
Reference: [25] <author> Taylor, D. J., Morgan, D. E., Black, J. P., </author> <title> "Redundancy in Data Structures: Some Theoretical Results," </title> <journal> Trans. Soft. Eng., </journal> <pages> 595-602, </pages> <editor> v. </editor> <volume> 6, </volume> <year> 1980. </year>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers [4, 5], algorithm-based methods [12, 16], robust data structures <ref> [13, 14, 24, 25, 26] </ref>, certification trails [20, 21, 22, 23, 27], and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries. <p> The programs discussed in this paper can function as acceptance tests. Finally, we mention the notion of a repairable or robust data structure <ref> [13, 14, 24, 25, 26] </ref>. In this technique, a data structure is augmented with additional information, such as redundant values and links.
Reference: [26] <author> Taylor, D., </author> <title> "Error Models for Robust Data Structures," </title> <booktitle> Dig. 20th FTCS, </booktitle> <year> 1990, </year> <pages> pp. 416-422. </pages>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers [4, 5], algorithm-based methods [12, 16], robust data structures <ref> [13, 14, 24, 25, 26] </ref>, certification trails [20, 21, 22, 23, 27], and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries. <p> The programs discussed in this paper can function as acceptance tests. Finally, we mention the notion of a repairable or robust data structure <ref> [13, 14, 24, 25, 26] </ref>. In this technique, a data structure is augmented with additional information, such as redundant values and links.
Reference: [27] <author> Wilson, D. S., Sullivan, G. F., and Masson, G. M., </author> <title> "Experimental Evaluation of Certification Trails Using Abstract-data-type Validation," </title> <booktitle> Proc. IEEE Comp. Soft. App. Conf., </booktitle> <year> 1992, </year> <pages> pp. 300-306. </pages>
Reference-contexts: 1 Introduction A richly diverse and still growing collection of techniques have been developed to perform software based fault tolerance including: recovery blocks [18], N-version programming [3], program checkers [4, 5], algorithm-based methods [12, 16], robust data structures [13, 14, 24, 25, 26], certification trails <ref> [20, 21, 22, 23, 27] </ref>, and other methods [1]. In this paper, we consider the problem of detecting errors in the answers given in response to data structure queries. For many programs a substantial fraction of the intricate error-prone code resides in the routines associated with data structure access. <p> The certification trail technique has been applied to a wide variety of problems in computer science such as sorting, constructing convex hulls, finding minimum spanning trees, performing sequences of priority queue operations, constructing Huffman trees, finding the closest pair of points in a set, and many others <ref> [20, 21, 22, 23, 27] </ref>. The savings in running time for the second phase as compared to the second execution for two-version programming for these examples range from about 75% to about 90%.
References-found: 27

