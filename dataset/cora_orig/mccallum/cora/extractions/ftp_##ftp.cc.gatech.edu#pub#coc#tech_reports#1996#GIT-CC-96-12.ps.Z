URL: ftp://ftp.cc.gatech.edu/pub/coc/tech_reports/1996/GIT-CC-96-12.ps.Z
Refering-URL: http://www.cs.gatech.edu/tech_reports/index.96.html
Root-URL: 
Email: frdk,ammar,calvertg@cc.gatech.edu  
Title: Protocol Portability through Module Encapsulation  
Author: Bobby Krupczak Ken Calvert Mostafa Ammar 
Note: This research is supported by a grant from the National Science Foundation (NCR-9305115)  
Address: Atlanta, GA 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Date: April 12, 1996  404.894.1404  
Pubnum: GIT-CC-96-12  
Abstract: Because protocol software is difficult and expensive to implement and test, it is often ported between systems, instead of being rewritten from scratch. Unfortunately, porting protocol software can be nearly as difficult as from-scratch development, due to inherent differences in subsystem design and services provided. Thus, protocol subsystems can have a profound effect on the portability of a protocol implementation. In this paper, we propose an approach permitting the incorporation of new protocols into a subsystem other than their native one, without the drawbacks or expense of porting and original development. Our approach is based on protocol module encapsulation, which allows unmodified protocol code developed for one protocol subsystem to be used within another. We relate our experiences designing, implementing, and measuring the performance of our protocol encapsulation modules, using an AppleTalk protocol stack as a baseline. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. B. Abbott and L. L. Peterson. </author> <title> A language-based approach to protocol implementation. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(1) </volume> <pages> 4-19, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: A substantial body of work, in the area of protocol conversion, has also focused on achieving protocol interoperability but has done so by addressing their visible output (e.g. headers and message formats) [10, 15, 5]. However, protocol conversion abstracts away from a protocol's implementation and its subsystem. Others <ref> [19, 24, 16, 20, 13, 21, 6, 28, 1] </ref> have focused on making the protocol subsystem better in terms of performance and ease of programming. However, protocol code portability is not addressed; further, by introducing new subsystems, they only add to the protocol portability problem.
Reference: [2] <author> Robert Allen and David Garlan. </author> <title> Formalizing architectural connection. </title> <booktitle> In ICSE-16. 16th International Conference on Software Engineering, </booktitle> <pages> pages 71-80. </pages>
Reference-contexts: Schmidt [25] describes the construction of C++ wrappers that hide the idiosyncrasies of UNIX IPC programming behind an object-oriented front. However, the underlying protocol implementations, or the subsystems in which they reside, are not considered. Module interconnection languages <ref> [23, 2, 22] </ref> have addressed module reuse through the application of formal methods to software interfaces and their specifications. They, however, have not examined system software or protocol implementations nor their performance implication.
Reference: [3] <author> Guillermo Arango and Rub en Prieto-D iaz. </author> <title> Domain analysis concepts and research directions. </title> <editor> In Guillermo Arango and Rub en Prieto-D iaz, editors, </editor> <booktitle> Domain Analysis and Software Systems Modeling, </booktitle> <pages> pages 9-26, </pages> <year> 1991. </year>
Reference-contexts: Module interconnection languages [23, 2, 22] have addressed module reuse through the application of formal methods to software interfaces and their specifications. They, however, have not examined system software or protocol implementations nor their performance implication. Lastly, there has been extensive work in the domain analysis area <ref> [3] </ref> but it tends to be very domain-specific. We are unaware of any analysis of the protocol and protocol subsystem domain.
Reference: [4] <author> AT&T. </author> <title> UNIX System V Network Programmer's Guide. </title> <publisher> Prentice-Hall Inc., </publisher> <year> 1987. </year>
Reference-contexts: In the Streams subsystem, all data and control operations are formatted as messages passed between protocols. These messages typically conform to standards or conventions which govern their syntax and semantics. The Transport Layer Interface (TLI) <ref> [4] </ref> is one commonly used convention. However, the BSD subsystem defines a set of function call arguments and operands that are passed to a protocol's user-request method. Consequently, the BSD protocol encapsulation module must translate between the different TLI messages and their corresponding BSD argument and operand formats.
Reference: [5] <author> K.L. Calvert and S.S. Lam. </author> <title> Adaptors for protocol conversion. </title> <booktitle> In Proceedings IEEE INFOCOM '90, </booktitle> <volume> volume 2, </volume> <pages> pages 552-60, </pages> <year> 1990. </year>
Reference-contexts: A substantial body of work, in the area of protocol conversion, has also focused on achieving protocol interoperability but has done so by addressing their visible output (e.g. headers and message formats) <ref> [10, 15, 5] </ref>. However, protocol conversion abstracts away from a protocol's implementation and its subsystem. Others [19, 24, 16, 20, 13, 21, 6, 28, 1] have focused on making the protocol subsystem better in terms of performance and ease of programming.
Reference: [6] <author> David D. Clark, Van Jacobson, John Romkey, and Howard Salwen. </author> <title> An analysis of TCP processing overhead. </title> <journal> IEEE Communications, </journal> <volume> 27(6) </volume> <pages> 23-29, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: A substantial body of work, in the area of protocol conversion, has also focused on achieving protocol interoperability but has done so by addressing their visible output (e.g. headers and message formats) [10, 15, 5]. However, protocol conversion abstracts away from a protocol's implementation and its subsystem. Others <ref> [19, 24, 16, 20, 13, 21, 6, 28, 1] </ref> have focused on making the protocol subsystem better in terms of performance and ease of programming. However, protocol code portability is not addressed; further, by introducing new subsystems, they only add to the protocol portability problem.
Reference: [7] <author> Russell J. Clark, Mostafa H. Ammar, and Kenneth L. Calvert. </author> <title> Multi-protocol architectures as a paradigm for achieving inter-operability. </title> <booktitle> In Proceedings of IEEE INFOCOM, </booktitle> <pages> pages 136-143, </pages> <year> 1993. </year>
Reference-contexts: However, little research has directly examined the protocol portability problem. In this section we review relevant work and analyze how it relates to our efforts aimed at reducing or eliminating the protocol portability problem. Clark et al <ref> [7, 8] </ref> address protocol interoperability by proposing an architecture in which protocols are mixed and matched until two communicating entities support a common protocol graph. They advocate that systems support as many protocols as possible but do not directly address the protocol portability problem.
Reference: [8] <author> Russell J. Clark, Kenneth L. Calvert, and Mostafa H. Ammar. </author> <title> On the use of directory services to support multi-protocol inter-operability. </title> <booktitle> In Proceedings of IEEE INFOCOM, </booktitle> <pages> pages 784-791, </pages> <year> 1994. </year>
Reference-contexts: However, little research has directly examined the protocol portability problem. In this section we review relevant work and analyze how it relates to our efforts aimed at reducing or eliminating the protocol portability problem. Clark et al <ref> [7, 8] </ref> address protocol interoperability by proposing an architecture in which protocols are mixed and matched until two communicating entities support a common protocol graph. They advocate that systems support as many protocols as possible but do not directly address the protocol portability problem.
Reference: [9] <author> S. H. Goldberg and J.A. </author> <title> Mouton. A base for portable communications software. </title> <journal> IBM Systems Journal, </journal> <volume> 30(3) </volume> <pages> 259-79, </pages> <year> 1991. </year>
Reference-contexts: However, protocol code portability is not addressed; further, by introducing new subsystems, they only add to the protocol portability problem. Indeed, a new release of the x-Kernel (version 3.3) introduces incompatibilities with previous versions which necessitate the porting of protocol software between them. In Base <ref> [9] </ref>, the authors directly address the protocol portability problem by shifting the focus away from the protocol implementation and to the protocol subsystem.
Reference: [10] <author> Paul E. Jr. Green. </author> <title> Protocol conversion. </title> <journal> IEEE Transactions on Communications, </journal> <volume> 34(3) </volume> <pages> 257-268, </pages> <month> March </month> <year> 1986. </year>
Reference-contexts: A substantial body of work, in the area of protocol conversion, has also focused on achieving protocol interoperability but has done so by addressing their visible output (e.g. headers and message formats) <ref> [10, 15, 5] </ref>. However, protocol conversion abstracts away from a protocol's implementation and its subsystem. Others [19, 24, 16, 20, 13, 21, 6, 28, 1] have focused on making the protocol subsystem better in terms of performance and ease of programming.
Reference: [11] <author> IEEE. </author> <title> Information technology-portable operating system interface (POSIX)-part 1: System application program interface (API) [C language. </title> <type> Technical Report Std 1003.1-1990, </type> <institution> IEEE/ANSI, </institution> <year> 1990. </year>
Reference-contexts: Further, they do not address how existing protocol software can be incorporated into this 3 new subsystem without the expense of porting or re-implementation. Various standards-based approaches (e.g POSIX <ref> [11, 12] </ref> and X/Open [29]) have addressed application-level portability across various operating systems. These standards focus on the definition of generic operating system and protocol-independent application programmer interfaces. In effect, these standards attempt to impose a common programming model and set of interfaces on application programmers.
Reference: [12] <author> IEEE. </author> <title> Information technology-portable operating system interface (POSIX)-protocol independent interfaces. </title> <note> Technical Report Draft 6.1 Std 1003.1g, IEEE/ANSI, </note> <year> 1995. </year>
Reference-contexts: Further, they do not address how existing protocol software can be incorporated into this 3 new subsystem without the expense of porting or re-implementation. Various standards-based approaches (e.g POSIX <ref> [11, 12] </ref> and X/Open [29]) have addressed application-level portability across various operating systems. These standards focus on the definition of generic operating system and protocol-independent application programmer interfaces. In effect, these standards attempt to impose a common programming model and set of interfaces on application programmers.
Reference: [13] <author> Jonathan Kay and Joseph Pasquale. </author> <title> The importance of non-data touching processing overheads in TCP/IP. </title> <booktitle> ACM SIGCOMM-1993 Symposium, </booktitle> <pages> pages 259-268, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: A substantial body of work, in the area of protocol conversion, has also focused on achieving protocol interoperability but has done so by addressing their visible output (e.g. headers and message formats) [10, 15, 5]. However, protocol conversion abstracts away from a protocol's implementation and its subsystem. Others <ref> [19, 24, 16, 20, 13, 21, 6, 28, 1] </ref> have focused on making the protocol subsystem better in terms of performance and ease of programming. However, protocol code portability is not addressed; further, by introducing new subsystems, they only add to the protocol portability problem.
Reference: [14] <author> Bobby Krupczak, Mostafa Ammar, and Ken Calvert. </author> <title> Multi-subsystem protocol architectures: Motivation and experience with an adapter-based approach. </title> <booktitle> In Proceedings of IEEE INFOCOM, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: This difficulty protocol portability problem has prevented the quick incorporation of new protocols and, in some cases, limited interoperability. The continuous introduction of new operating systems and accompanying protocol subsystems only exacerbates the problem as protocol programmers are forced to port or re-implement existing protocols. Our previous work <ref> [14] </ref> also examined the difficulties encountered when porting protocol implementations. That work, which focused on environments in which multiple protocol subsystems are supported, introduced a subsystem adapter module which allows protocol implementations residing in different subsystems to be combined into a single protocol graph (termed a multi-subsystem protocol graph). <p> Let us now consider the functionality required for our approach. Figure 1 depicts the design of a generic protocol encapsulation module, which essentially emulates a native protocol to the host subsystem, while 1 Previous work with multi-subsystem protocol architectures <ref> [14] </ref> examined the interaction between a protocol implementation and subsystems and their effect on protocol code portability; that work provides the basis for making the claim that porting protocol implementations is expensive, difficult, and time-consuming. 4 simultaneously emulating the target subsystem to the imported protocol. <p> We chose the Solaris 2.x operating environment (over SunOS 4.1.x) since the BSD subsystem does not exist within it. We also chose the combination of BSD, Streams and AppleTalk because we used them in a prior protocol-subsystem case study <ref> [14] </ref> and could build on its results. Finally, this environment solves a real problem, namely the need to incorporate BSD-coded protocols within the Streams subsystem. <p> We measure the performance of several aspects of our approach: the overall throughput obtained by the various protocol graphs, the protocol processing time incurred by the individual protocols, our encapsulation modules, and their sub-components. As a baseline, we compare (where appropriate) our results from those obtained in earlier work <ref> [14] </ref>. BSD (SunOS) Streams (Sol2) IMPORT1 IMPORT2 IMPORT3 All our measurements were taken on a Sun SPARCstation-LX running in single-user mode and were averaged over multiple samples within a 95% confidence interval of at most 10% of measured values. <p> The native Str (SunOS) and x-Kernel (SunOS) protocol graphs performed worst. The fact that the Str (Sol2) protocol graph performs better than Str (SunOS) is attributable to the considerable operating system and protocol subsystem tuning that Str (Sol2) has received. The poor performance <ref> [14] </ref> of Str (SunOS) is primarily attributable to the lack of tuning that the entire Streams subsystem underwent in SunOS 4.1.x while the poor performance of x-Kernel (SunOS) (using the x-Kernel version 3.2) is due the underlying threads package (SunOS LWP). <p> First, the protocols can be developed from scratch or, if available, their implementations for other subsystems can be ported. Second, the subsystems for which the additional protocols were originally developed can themselves be ported instead. Lastly, if both subsystems exist within the given host, then subsystem adaptation <ref> [14] </ref> could be used instead of protocol encapsulation. In this section, we compare these alternatives. Although it is impossible to provide an entirely quantitative analysis, this comparison and discussion does provide insight into the tradeoffs associated with each approach. <p> Further, subsystem porting reinforces the phenomenon of ships in the night because the level of integration between each subsystem is usually nil. Protocols in one subsystem cannot normally utilize the services of protocols in other subsystems without the introduction of additional code (e.g. subsystem adapters <ref> [14] </ref>). Another issue is that subsystem porting imposes the burden of additional testing; the newly ported subsystem must be tested along with the particular protocols in question. With protocol encapsulation, testing requirements are more constrained and are restricted to only those protocols being imported. <p> Encapsulation on the protocol-graph scale more closely resembles subsystem porting but is distinguishable because it requires less integration with the host operating system. 6.3 Subsystem Adaptation vs. Protocol Encapsulation In our previous work <ref> [14] </ref>, we addressed the difficulties encountered when porting protocol implementations and developed an approach which allowed protocol implementations residing in different subsystems to be combined into a single protocol graph (termed a multi-subsystem protocol graph). <p> These choices are depicted in Figure 9. (a) STRBSD1 (b) IMPORT1 The adapter in Figure 9a (see <ref> [14] </ref>) required approximately 1900 lines of C-code versus about 1200 lines of C-code for the protocol encapsulation module depicted in Figure 9b. This comparison is not exact, but does provide a rough measure of the implementation costs of each.
Reference: [15] <author> S.S. Lam. </author> <title> Protocol conversion. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(3) </volume> <pages> 353-62, </pages> <month> March </month> <year> 1988. </year> <month> 21 </month>
Reference-contexts: A substantial body of work, in the area of protocol conversion, has also focused on achieving protocol interoperability but has done so by addressing their visible output (e.g. headers and message formats) <ref> [10, 15, 5] </ref>. However, protocol conversion abstracts away from a protocol's implementation and its subsystem. Others [19, 24, 16, 20, 13, 21, 6, 28, 1] have focused on making the protocol subsystem better in terms of performance and ease of programming.
Reference: [16] <author> Samuel J. Leffler, Marshall Kirk McKusick, Michael J. Karels, and John S. Quaterman. </author> <title> The Design and Implementation of the 4.3 BSD UNIX Operating System. </title> <publisher> Addison-Wesley, </publisher> <address> 1st edition, </address> <year> 1989. </year>
Reference-contexts: Indeed, protocol code written for one system may be unusable in another. Because protocol software is complex and difficult implement and test, it is usually developed within protocol subsystems (e.g. Streams [24], BSD <ref> [16] </ref>, or the x-Kernel [19]). When a new protocol needs to be added to a system, an existing implementation is often ported, instead of developing a new one from scratch. In fact, empirical evidence indicates that many of today's Internet protocol implementations are still derived from the original BSD implementation. <p> A substantial body of work, in the area of protocol conversion, has also focused on achieving protocol interoperability but has done so by addressing their visible output (e.g. headers and message formats) [10, 15, 5]. However, protocol conversion abstracts away from a protocol's implementation and its subsystem. Others <ref> [19, 24, 16, 20, 13, 21, 6, 28, 1] </ref> have focused on making the protocol subsystem better in terms of performance and ease of programming. However, protocol code portability is not addressed; further, by introducing new subsystems, they only add to the protocol portability problem.
Reference: [17] <author> Sun Microsystems. </author> <title> STREAMS Programmer's Guide. Sun Microsystems, </title> <publisher> Inc., </publisher> <month> August </month> <year> 1994. </year>
Reference-contexts: When invoked, BSD protocols typically initialize internal state tables and perform control operations to other protocols (e.g. determining a lower-layer address). While Streams does not define an initialization method, the Solaris 2.x Device Driver and Device Kernel Interfaces (DDI/DKI) <ref> [17, 18] </ref> do. Therefore, it is straightforward to map between them. Because BSD protocols can also refer to each other via the BSD subsystem's protocol switch table, the BSD protocol encapsulation module also defines and maintains one as well.
Reference: [18] <author> Sun Microsystems. </author> <title> Writing Device Drivers. Sun Microsystems, </title> <publisher> Inc., </publisher> <month> August </month> <year> 1994. </year>
Reference-contexts: When invoked, BSD protocols typically initialize internal state tables and perform control operations to other protocols (e.g. determining a lower-layer address). While Streams does not define an initialization method, the Solaris 2.x Device Driver and Device Kernel Interfaces (DDI/DKI) <ref> [17, 18] </ref> do. Therefore, it is straightforward to map between them. Because BSD protocols can also refer to each other via the BSD subsystem's protocol switch table, the BSD protocol encapsulation module also defines and maintains one as well.
Reference: [19] <author> S. W. O'Malley and L. L. Peterson. </author> <title> A dynamic network architecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10 </volume> <pages> 110-143, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Indeed, protocol code written for one system may be unusable in another. Because protocol software is complex and difficult implement and test, it is usually developed within protocol subsystems (e.g. Streams [24], BSD [16], or the x-Kernel <ref> [19] </ref>). When a new protocol needs to be added to a system, an existing implementation is often ported, instead of developing a new one from scratch. In fact, empirical evidence indicates that many of today's Internet protocol implementations are still derived from the original BSD implementation. <p> A substantial body of work, in the area of protocol conversion, has also focused on achieving protocol interoperability but has done so by addressing their visible output (e.g. headers and message formats) [10, 15, 5]. However, protocol conversion abstracts away from a protocol's implementation and its subsystem. Others <ref> [19, 24, 16, 20, 13, 21, 6, 28, 1] </ref> have focused on making the protocol subsystem better in terms of performance and ease of programming. However, protocol code portability is not addressed; further, by introducing new subsystems, they only add to the protocol portability problem.
Reference: [20] <author> Christos Papadopoulos and Gurudatta Parulkar. </author> <title> Experimental evaluation of SunOS IPC and TCP/IP protocol implementation. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(2) </volume> <pages> 199-216, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: A substantial body of work, in the area of protocol conversion, has also focused on achieving protocol interoperability but has done so by addressing their visible output (e.g. headers and message formats) [10, 15, 5]. However, protocol conversion abstracts away from a protocol's implementation and its subsystem. Others <ref> [19, 24, 16, 20, 13, 21, 6, 28, 1] </ref> have focused on making the protocol subsystem better in terms of performance and ease of programming. However, protocol code portability is not addressed; further, by introducing new subsystems, they only add to the protocol portability problem.
Reference: [21] <author> Craig Partridge and Stephen Pink. </author> <title> A faster UDP. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(4) </volume> <pages> 429-440, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: A substantial body of work, in the area of protocol conversion, has also focused on achieving protocol interoperability but has done so by addressing their visible output (e.g. headers and message formats) [10, 15, 5]. However, protocol conversion abstracts away from a protocol's implementation and its subsystem. Others <ref> [19, 24, 16, 20, 13, 21, 6, 28, 1] </ref> have focused on making the protocol subsystem better in terms of performance and ease of programming. However, protocol code portability is not addressed; further, by introducing new subsystems, they only add to the protocol portability problem.
Reference: [22] <author> James M. Purtilo and Joanne M. Atlee. </author> <title> Module reuse by interface adaptation. </title> <journal> Software Practice and Experience, </journal> <volume> 21(6) </volume> <pages> 539-556, </pages> <year> 1991. </year>
Reference-contexts: Schmidt [25] describes the construction of C++ wrappers that hide the idiosyncrasies of UNIX IPC programming behind an object-oriented front. However, the underlying protocol implementations, or the subsystems in which they reside, are not considered. Module interconnection languages <ref> [23, 2, 22] </ref> have addressed module reuse through the application of formal methods to software interfaces and their specifications. They, however, have not examined system software or protocol implementations nor their performance implication.
Reference: [23] <author> M.D. Rice and S.B. Seidman. </author> <title> A formal model for module interconnection langugages. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(1) </volume> <pages> 88-101, </pages> <month> January </month> <year> 1994. </year>
Reference-contexts: Schmidt [25] describes the construction of C++ wrappers that hide the idiosyncrasies of UNIX IPC programming behind an object-oriented front. However, the underlying protocol implementations, or the subsystems in which they reside, are not considered. Module interconnection languages <ref> [23, 2, 22] </ref> have addressed module reuse through the application of formal methods to software interfaces and their specifications. They, however, have not examined system software or protocol implementations nor their performance implication.
Reference: [24] <author> D. M. Ritchie. </author> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 311-324, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: Indeed, protocol code written for one system may be unusable in another. Because protocol software is complex and difficult implement and test, it is usually developed within protocol subsystems (e.g. Streams <ref> [24] </ref>, BSD [16], or the x-Kernel [19]). When a new protocol needs to be added to a system, an existing implementation is often ported, instead of developing a new one from scratch. <p> A substantial body of work, in the area of protocol conversion, has also focused on achieving protocol interoperability but has done so by addressing their visible output (e.g. headers and message formats) [10, 15, 5]. However, protocol conversion abstracts away from a protocol's implementation and its subsystem. Others <ref> [19, 24, 16, 20, 13, 21, 6, 28, 1] </ref> have focused on making the protocol subsystem better in terms of performance and ease of programming. However, protocol code portability is not addressed; further, by introducing new subsystems, they only add to the protocol portability problem.
Reference: [25] <author> D.C. Schmidt. </author> <title> A C++ wrapper for unix I/O multiplexing: the object-oriented design and implementation of the reactor. C++ Report, </title> <booktitle> 5(7) </booktitle> <pages> 32-43, </pages> <year> 1993. </year>
Reference-contexts: The software engineering community has examined similar problems. For example, wrapper technology has been proposed as a means of retrofitting older, existing software so that it is usable in new programming environments. Schmidt <ref> [25] </ref> describes the construction of C++ wrappers that hide the idiosyncrasies of UNIX IPC programming behind an object-oriented front. However, the underlying protocol implementations, or the subsystems in which they reside, are not considered.
Reference: [26] <author> Douglas C. Schmidt and Tatsuya Suda. </author> <title> Transport system architecture services for high-performance communications systems. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 11(4) </volume> <pages> 489-506, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Examples of the functions of such interfaces are opening and closing a session, and sending and receiving data. The protocol model also defines the manner in which protocol entities like messages, layers, connections, and buffers are bound to the underlying unit of scheduling, called a subsystem's process architecture <ref> [26] </ref>. Consequently, protocol encapsulation modules must also translate between the respective process architectures. Example process architectures include horizontal (scheduling protocol layers) and vertical (scheduling connections or messages). The protocol model also defines protocol graph connectivity options, which include support for layering, graph construction, and graph alteration.
Reference: [27] <author> Gursharan S. Sidhu, Richard F. Andrews, and Alan B. Oppenheimer. </author> <title> Inside AppleTalk. </title> <publisher> Addison-Wesley, </publisher> <address> 1st edition, </address> <year> 1989. </year>
Reference-contexts: We first motivate our choice of the BSD and Streams subsystems and then discuss our approach's application to the environment we chose. Our work was conducted in an environment consisting of Solaris 2.4, the Streams and BSD subsystems, and an AppleTalk <ref> [27] </ref> implementation. We chose this environment for several reasons. First, the AppleTalk suite of protocols provide a set of services similar to the Internet family and is in widespread use. Second, the AppleTalk protocol suite is not biased towards or against the BSD and Streams subsystems.
Reference: [28] <author> C. A. Thekkath, T. D. Nguyen, E. Moy, and E. D. Lazowska. </author> <title> Implementing network protocols at user level. </title> <journal> IEEE/ACM Transactions on Networking, </journal> <volume> 1(5) </volume> <pages> 554-565, </pages> <month> October </month> <year> 1993. </year>
Reference-contexts: A substantial body of work, in the area of protocol conversion, has also focused on achieving protocol interoperability but has done so by addressing their visible output (e.g. headers and message formats) [10, 15, 5]. However, protocol conversion abstracts away from a protocol's implementation and its subsystem. Others <ref> [19, 24, 16, 20, 13, 21, 6, 28, 1] </ref> have focused on making the protocol subsystem better in terms of performance and ease of programming. However, protocol code portability is not addressed; further, by introducing new subsystems, they only add to the protocol portability problem.
Reference: [29] <author> X/Open. </author> <title> X/Open transport interface (XTI), </title> <type> version 2. Technical Report C318, </type> <institution> X/Open, </institution> <month> August </month> <year> 1993. </year> <title> Becomes C523 Networking Services, </title> <note> Issue 4, Version 2 12/96. 22 </note>
Reference-contexts: Further, they do not address how existing protocol software can be incorporated into this 3 new subsystem without the expense of porting or re-implementation. Various standards-based approaches (e.g POSIX [11, 12] and X/Open <ref> [29] </ref>) have addressed application-level portability across various operating systems. These standards focus on the definition of generic operating system and protocol-independent application programmer interfaces. In effect, these standards attempt to impose a common programming model and set of interfaces on application programmers.
References-found: 29

