URL: http://www.cs.gatech.edu/computing/Telecomm/playground/dsa/pldai.ps
Refering-URL: http://www.cs.gatech.edu/computing/Telecomm/playground/dsa/index.html
Root-URL: 
Email: clayton@cc.gatech.edu calvert@cc.gatech.edu  
Phone: 404 894 1155 404 894 9107  
Title: Augmenting the Proebsting-Watterson Filter Fusion Algorithm  
Author: R. Clayton K. Calvert 
Date: February 5, 1997  
Address: 801 Atlantic Avenue 250 14th Street Atlanta, Georgia 30332-0280 Atlanta, Georgia 30318-0490  
Affiliation: Networking and Telecommunications Group, College of Computing Georgia Institute of Technology  
Abstract: A sequence of processes connected by data streams can be executed using multiple threads, but, given current hardware, are more efficiently executed with a single thread. The Proebsting-Watterson filter fusion algorithm combines adjacent processes into a single process, making it possible to convert a pipeline into a single block of code. This paper reports on work augmenting the Proebsting-Watterson filter fusion algorithm to generate code easier to optimize, and then describes some of the optimizations needed. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Abbott, M. B. and L. L. Peterson (1993, </author> <month> October). </month> <title> Increasing network throughput by integrating protocol layers. </title> <journal> IEEE/ACM Transactions on Networking 1 (5), </journal> <pages> 600-610. </pages>
Reference: <author> Braun, T. and C. </author> <month> Diot </month> <year> (1995). </year> <title> Protocol implementation using integrated layer processing. </title> <booktitle> In SIGCOMM '95 Conference Proceedings. </booktitle> <publisher> ACM Press. </publisher>
Reference: <author> Calvert, K. L. </author> <year> (1993, </year> <month> 19-22 October). </month> <title> Beyond layering: Modularity considerations for protocol architectures. </title> <booktitle> In International Conference on Network Protocols, </booktitle> <address> San Francisco, Calif., </address> <pages> pp. 90-97. </pages> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: It seems plausible that truly optimized code will need to account for all possibilities, including potential control flow. Towards that end, we are currently looking into hosting the filter fusion algorithm in the Transport and Up protocol environment <ref> (Calvert 1993) </ref>. 6 Conclusions The usual methods of implementing communications protocols result in code with degraded execution performance. Structuring protocol computations as processes transforming streams of data is a promising alternative implementation method.
Reference: <author> Clark, D. D. and D. L. </author> <month> Tennenhouse </month> <year> (1990, </year> <month> 24-27 September). </month> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In SIGCOMM '90 Symposium on Communication Architectures and Protocols, Philadelphia, Penn., </booktitle> <pages> pp. 200-208. </pages> <publisher> ACM Press. </publisher>
Reference: <author> Clark, I. A. </author> <year> (1978). </year> <title> STREMA: Specifying application processes using streams. </title> <journal> The Computer Journal 21 (1), </journal> <pages> 25-30. </pages>
Reference-contexts: 1 Introduction Organizing computations as transformations over data streams has long been considered an attractive approach to programming, be it scientific programming (Kelly, Lochbaum, and Vys-sotsky 1961), business data processing <ref> (Clark 1978) </ref>, or systems programming (Kahn 1974). A paper by Clark and Tennenhouse (1990) directed attention towards developing new models for implementing communication protocol software.
Reference: <author> Clayton, R. and K. </author> <month> Calvert </month> <year> (1995, </year> <month> 11-12 Decem-ber). </month> <title> Structuring protocols with data streams. </title> <booktitle> In Proceedings of the Second International Workshop on High Performance Protocol Architectures, </booktitle> <address> Sydney, Australia. </address>
Reference-contexts: Second, the encapsulation implied by layering frustrates optimizations along the whole of the protocol implementation, which is a problem for general purpose protocols because they include more function, and more cost, than any particular application needs (Saltzer, Reed, and Clark 1984). Data stream computations are a possible model <ref> (Clayton and Calvert 1995) </ref> for solving the problems identified by Clark and Tennenhouse. Data stream computations as a notation closely correspond to protocol code specifications. The regular and simple structure of data stream computations leads to the possibility of transforming them into efficiently executing code (Waters 1991).
Reference: <author> Dijkstra, E. W. </author> <year> (1976). </year> <title> A Discipline of Programming. </title> <booktitle> Prentice-Hall Series in Automatic Computation. </booktitle> <address> Englewood Cliffs, N.J.: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: Pushing F 1 through C 1 (to continue with the notation introduced in Section 3.2.1) is now a bit more complicated because F 1 can be an arbitrary predicate. Fortunately there is theory around to help with this task; either program inversion (Gries 1981) or weakest preconditions <ref> (Dijkstra 1976) </ref> provide enough mechanism to help move F 1 through C 1 . In addition, the simplicity of the code in C 1 (just assignment statements with no function or procedure calls) makes the actual manipulations easy to implement despite the potential complexity of F 1 .
Reference: <author> Gries, D. </author> <year> (1981). </year> <booktitle> The Science of Programming. </booktitle>
Reference-contexts: Pushing F 1 through C 1 (to continue with the notation introduced in Section 3.2.1) is now a bit more complicated because F 1 can be an arbitrary predicate. Fortunately there is theory around to help with this task; either program inversion <ref> (Gries 1981) </ref> or weakest preconditions (Dijkstra 1976) provide enough mechanism to help move F 1 through C 1 .
Reference: <institution> New York, </institution> <address> N.Y.: </address> <publisher> Springer-Verlag. </publisher>
Reference: <author> Guibas, L. J. and D. K. </author> <title> Wyatt (1978, 23-25 Jan-uary). Compilation and delayed evaluation in APL. </title> <booktitle> In Conference Record of the Fifth Annual ACM Symposium onPrinciples of Programming Languages, </booktitle> <address> Tucson, </address> <publisher> Ariz., </publisher> <pages> pp. 1-8. </pages> <note> 9 Kahn, </note> <author> G. </author> <year> (1974). </year> <title> The semantics of a simple lan-guage for parallel programming. </title> <booktitle> In Information Processing 74, Amsterdam, The Nether-lands, </booktitle> <pages> pp. 471-475. </pages> <publisher> IFIP: North Holland. </publisher>
Reference: <author> Kelly, Jr., J. L., C. Lochbaum, and V. A. </author> <month> Vyssot-sky </month> <year> (1961, </year> <month> May). </month> <title> A block diagram compiler. </title> <journal> Bell System Technical Journal 40, </journal> <pages> 669-676. </pages>
Reference-contexts: 1 Introduction Organizing computations as transformations over data streams has long been considered an attractive approach to programming, be it scientific programming <ref> (Kelly, Lochbaum, and Vys-sotsky 1961) </ref>, business data processing (Clark 1978), or systems programming (Kahn 1974). A paper by Clark and Tennenhouse (1990) directed attention towards developing new models for implementing communication protocol software.
Reference: <author> Lee, E. A. and D. G. </author> <title> Messerschmitt (1987, Jan-uary). Static scheduling of synchronous data flow programs for digital signal processing. </title> <journal> IEEE Transactions on Computers C-36 (1), </journal> <pages> 24-35. </pages>
Reference-contexts: Those using data stream computations in real-time programming, while interested in efficiency, are more interested in deterministic scheduling <ref> (Lee and Messerschmitt 1987) </ref>. Waters' work on has resulted in techniques for translating stream expressions into efficient code, but does require some modifications to get over the restrictions 8 imposed on the kinds of computations that can be expressed with data streams.
Reference: <author> Mosberger, D., L. L. Peterson, and S. </author> <month> O'Malley </month> <year> (1995). </year> <title> Protocol latency: MIPS and reality. </title> <type> Technical Report TR 95-02, </type> <institution> Department of Computer Science, University of Arizona, Tuc-son, Ariz. </institution>
Reference: <author> Proebsting, T. A. and S. A. </author> <title> Watterson (1996). Filter fusion. </title> <booktitle> In Symposium on Principles of Programming Languages, St. Petersburg, Flordia, </booktitle> <pages> pp. 119-129. </pages>
Reference-contexts: used to run regression tests the correctness of the code generated by the compiler (each number in parentheses indicates the length of a pipeline related to the test): * ai (8, 10): text/binary integer conversion. * bin/snmp (1, 1): binary/ASN.1 conversion. 6 * byte swapping (2, 4): the example from <ref> (Proebsting and Watterson 1996) </ref>. * id (2, 3, 4): copy input to output. * mi (1, 2, 3): the MD message digest family, i 2 f2; 4; 5g. (there is one pipleline missing from m2).
Reference: <author> Saltzer, J. H., D. P. Reed, and D. D. Clark (1984, </author> <month> November). </month> <title> End-to-end arguments in system design. </title> <journal> ACM Transactions on Computer Systems 2 (4), </journal> <pages> 277-288. </pages>
Reference-contexts: Second, the encapsulation implied by layering frustrates optimizations along the whole of the protocol implementation, which is a problem for general purpose protocols because they include more function, and more cost, than any particular application needs <ref> (Saltzer, Reed, and Clark 1984) </ref>. Data stream computations are a possible model (Clayton and Calvert 1995) for solving the problems identified by Clark and Tennenhouse. Data stream computations as a notation closely correspond to protocol code specifications.
Reference: <author> Stallman, R. M. </author> <year> (1995, </year> <month> 14 June). </month> <title> Using and Porting GNU CC (ver. </title> <address> 2.7). Cambridge, Mass.: </address> <publisher> Free Software Foundation. </publisher>
Reference-contexts: B C , at the end of its execution, branches indirect through the target variables as directed by its test (if any). The data stream compiler produces ANSI C code as extended by the GNU C compiler <ref> (Stallman 1995) </ref>, which makes the necessary address operations available within C without the need for assembler. The simple subroutine transformation results in a (more or less) legitimate flow graph, raising an interesting phase ordering issue.
Reference: <author> Wadler, P. </author> <year> (1990). </year> <title> Deforestation: Transforming programs to eliminate trees. </title> <booktitle> Theoretical Computer Science 73 (2), </booktitle> <pages> 231-248. </pages>
Reference: <author> Waters, R. C. </author> <year> (1991, </year> <month> January). </month> <title> Automatic transformation of series expressions into loops. </title> <booktitle> ACM Transactions on Programming Languages and Systems 13 (1), </booktitle> <pages> 52-98. 10 </pages>
Reference-contexts: Data stream computations as a notation closely correspond to protocol code specifications. The regular and simple structure of data stream computations leads to the possibility of transforming them into efficiently executing code <ref> (Waters 1991) </ref>. Finally, the data stream model is one that could plausibly be made available to the applications programmer, allowing the application to subsume its protocol processing.
References-found: 18

