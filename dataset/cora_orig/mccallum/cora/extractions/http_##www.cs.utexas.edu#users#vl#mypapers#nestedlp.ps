URL: http://www.cs.utexas.edu/users/vl/mypapers/nestedlp.ps
Refering-URL: http://www.cs.utexas.edu/users/vl/papers.html
Root-URL: 
Title: Nested Expressions in Logic Programs  
Author: Vladimir Lifschitz, Lappoon R. Tang and Hudson Turner 
Address: Austin, TX 78712, USA  
Affiliation: Department of Computer Sciences University of Texas at Austin  
Abstract: We extend the answer set semantics to a class of programs with nested expressions permitted in the bodies and heads of rules. These expressions are formed from literals using negation as failure, conjunction (,) and disjunction (;) that can be nested arbitrarily. Conditional expressions are introduced as abbreviations. The study of equivalent transformations of programs with nested expressions shows that any such program is equivalent to a set of disjunctive rules, possibly with negation as failure in the heads. The generalized answer set semantics is related to the Lloyd-Topor generalization of Clark's completion and to the logic of minimal belief and negation as failure. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Alferes, J.; Leite, J.; Pereira, L.; Przymusinska, H.; and Przymusinski, T. </author> <year> 1998. </year> <note> Dynamic logic programming. In Proc. KR-98. To appear. </note>
Reference-contexts: expression of the form F G 1 In (Lifschitz 1996), the vertical bar is used instead of the semicolon to separate literals in the head of a rule. 2 This feature was found to be useful in abductive logic programming (Inoue & Sakama 1994) and in the theory of updates <ref> (Alferes et al. 1998) </ref>. where F and G are formulas, called the head and the body of the rule.
Reference: <author> Apt, K.; Blair, H.; and Walker, A. </author> <year> 1988. </year> <title> Towards a theory of declarative knowledge. </title> <editor> In Minker, J., ed., </editor> <booktitle> Foundations of Deductive Databases and Logic Programming. </booktitle> <address> San Mateo, CA: </address> <publisher> Morgan Kaufmann. </publisher> <pages> 89-148. </pages>
Reference-contexts: Relation to the Lloyd-Topor Semantics The review of the Lloyd-Topor semantics below differs from its description in (Lloyd & Topor 1984) in two ways. First, it is restricted to the propositional case. Second, it is stated in terms of "supported models" <ref> (Apt, Blair, & Walker 1988) </ref> instead of completion, which allows us to extend the theory to infinite programs. For finite programs, the two definitions are equivalent. A (propositional) Lloyd-Topor rule is an expression of the form p F where p is an atom and F is a propositional formula.
Reference: <author> Chen, W., and Warren, D. </author> <year> 1998. </year> <title> Computation of stable models and its integration with logical query processing. </title> <journal> IEEE Transactions on Knowledge and Data Engineering. </journal> <note> To appear. </note>
Reference-contexts: In (Dimopoulos, Nebel, & Koehler 1997), SMODELS is used as a basis for an efficient planning algorithm. The extension of the answer set semantics proposed below can serve as a specification for extending SMODELS, or the system described in <ref> (Chen & Warren 1998) </ref>, to programs with nested expressions.
Reference: <author> Clark, K. </author> <year> 1978. </year> <title> Negation as failure. </title> <editor> In Gallaire, H., and Minker, J., eds., </editor> <booktitle> Logic and Data Bases. </booktitle> <address> New York: </address> <publisher> Plenum Press. </publisher> <pages> 293-322. </pages>
Reference-contexts: For these reasons, the use of nested expressions is standard practice in Prolog programming. The first declarative semantics for logic programs with nested expressions was proposed by Lloyd and Topor (1984), who extended the completion semantics of <ref> (Clark 1978) </ref> to programs with arbitrary first-order formulas in the bodies of rules. In this note, we propose a semantics for programs with nested expressions that is based on the answer set ("stable model") approach (Gelfond & Lifschitz 1991).
Reference: <author> Dimopoulos, Y.; Nebel, B.; and Koehler, J. </author> <year> 1997. </year> <title> Encoding planning problems in non-monotonic logic programs. </title> <booktitle> In Proc. </booktitle> <address> ECP-97. </address>
Reference-contexts: In <ref> (Dimopoulos, Nebel, & Koehler 1997) </ref>, SMODELS is used as a basis for an efficient planning algorithm. The extension of the answer set semantics proposed below can serve as a specification for extending SMODELS, or the system described in (Chen & Warren 1998), to programs with nested expressions.
Reference: <author> Fages, F. </author> <year> 1994. </year> <title> Consistency of Clark's completion and existence of stable models. </title> <booktitle> Journal of Methods of Logic in Computer Science 1 </booktitle> <pages> 51-60. </pages>
Reference-contexts: This is not surprising in view of the fact that the result of this replacement is a tight program (see (Lifschitz 1996), and the result from <ref> (Fages 1994) </ref> reproduced there as Proposition 3.5). Relation to MBNF In the propositional fragment of the logic of minimal belief and negation as failure (MBNF) (Lifschitz 1994), formulas are built from atoms using propositional connectives and two modal operators: B ("minimal belief") and not .
Reference: <author> Gelfond, M., and Lifschitz, V. </author> <year> 1991. </year> <title> Classical negation in logic programs and disjunctive databases. </title> <booktitle> New Generation Computing 9 </booktitle> <pages> 365-385. </pages>
Reference-contexts: In this note, we propose a semantics for programs with nested expressions that is based on the answer set ("stable model") approach <ref> (Gelfond & Lifschitz 1991) </ref>. <p> This definition of a rule generalizes the syntax of rules in the sense of <ref> (Gelfond & Lifschitz 1991) </ref>, and even of "disjunctive rules" (5). (We understand the head of (5) as ? if l = 0, and understand the body as &gt; if n = l.) For any formulas F , G and H, F ! G; H stands for the formula (F; G); (not <p> For instance, the result of replacing the first occurrence of p in (6) by (q; r) is a formula, but the result of applying the same operation to the second occurrence is not. Semantics Recall that the definition of an answer set <ref> (Gelfond & Lifschitz 1991) </ref> consists of two parts. First this concept is defined for the "basic" case of programs that do not contain negation as failure.
Reference: <author> Herre, H., and Wagner, G. </author> <year> 1997. </year> <title> Stable models are generated by a stable chain. </title> <journal> Journal of Logic Programming 30 </journal> <pages> 165-177. </pages>
Reference: <author> Inoue, K., and Sakama, C. </author> <year> 1994. </year> <title> On positive occurrences of negation as failure. </title> <booktitle> In Proc. Fourth Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> 293-304. </pages>
Reference-contexts: A rule is an expression of the form F G 1 In (Lifschitz 1996), the vertical bar is used instead of the semicolon to separate literals in the head of a rule. 2 This feature was found to be useful in abductive logic programming <ref> (Inoue & Sakama 1994) </ref> and in the theory of updates (Alferes et al. 1998). where F and G are formulas, called the head and the body of the rule.
Reference: <author> Lifschitz, V., and Woo, T. </author> <year> 1992. </year> <title> Answer sets in general nonmonotonic reasoning (preliminary report). </title>
Reference-contexts: The translation of any program is an MBNF theory of the special type studied in <ref> (Lifschitz & Woo 1992) </ref>|a "theory with protected literals." This means that every occurrence of an atom in an axiom of this theory is a part of an expression of the form BL or not L, where L is a literal.
Reference: <editor> In Nebel, B.; Rich, C.; and Swartout, W., eds., </editor> <booktitle> Proc. Third Int'l Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> 603-614. </pages>
Reference: <author> Lifschitz, V. </author> <year> 1994. </year> <title> Minimal belief and negation as failure. </title> <booktitle> Artificial Intelligence 70 </booktitle> <pages> 53-72. </pages>
Reference-contexts: Relation to MBNF In the propositional fragment of the logic of minimal belief and negation as failure (MBNF) <ref> (Lifschitz 1994) </ref>, formulas are built from atoms using propositional connectives and two modal operators: B ("minimal belief") and not . An MBNF theory is a set of formulas (axioms) in this language. <p> As an example, note that, in application to (4), gives the formula :not p ^ not ? Bp : This translation is essentially an extension of the translation from Section 5 of <ref> (Lifschitz 1994) </ref> to programs with nested expressions. <p> Recall that models of a propositional MBNF theory are defined as the pairs (I; S), where I is an interpretation and S is a set of interpretations, that satisfy a certain fixpoint condition (see <ref> (Lifschitz 1994) </ref>, Section 4). The following theorem establishes a correspondence between the answer sets for a program and the models of the MBNF theory . For any set X of literals, by Mod (X) we denote the set of interpretations that satisfy all members of X. Proposition 8.
Reference: <author> Lifschitz, V. </author> <year> 1996. </year> <title> Foundations of logic programming. </title> <editor> In Brewka, G., ed., </editor> <booktitle> Principles of Knowledge Representation. </booktitle> <publisher> CSLI Publications. </publisher> <pages> 69-128. </pages>
Reference-contexts: Then we turn to the study of equivalent transformations of programs with nested expressions, and show that any such program can be equivalently transformed into a set of "disjunctive rules" in the sense of Section 5.1 of <ref> (Lifschitz 1996) </ref>|expressions of the form L 1 ; : : : ; L k ; not L k+1 ; : : : ; not L l ; (5) where 0 k l m n and all L i are literals. 1 A somewhat unorthodox feature of (5) is the possibility of <p> Elementary formulas are literals and the symbols ? ("false") and &gt; ("true"). Formulas are built from elementary formulas using the unary connective not and the binary connectives ; (conjunction) and ; (disjunction). A rule is an expression of the form F G 1 In <ref> (Lifschitz 1996) </ref>, the vertical bar is used instead of the semicolon to separate literals in the head of a rule. 2 This feature was found to be useful in abductive logic programming (Inoue & Sakama 1994) and in the theory of updates (Alferes et al. 1998). where F and G are <p> Proposition 1. For a program whose rules have the form (5), the definition of an answer set given above is equivalent to the definition from <ref> (Lifschitz 1996) </ref>. Equivalent Transformations In this section we describe several equivalent transformations of programs with nested expressions. These transformations can turn any program into an equivalent program whose rules have the form (5). Equivalence can be understood here as a condition stronger than merely having the same answer sets. <p> This is not surprising in view of the fact that the result of this replacement is a tight program (see <ref> (Lifschitz 1996) </ref>, and the result from (Fages 1994) reproduced there as Proposition 3.5). <p> Appendix. Proofs of Theorems Proof of Proposition 1 Proposition 1. For a program whose rules have the form (5), the definition of an answer set given above is equivalent to the definition from <ref> (Lifschitz 1996) </ref>. The definition of an answer set in (Lifschitz 1996) differs from the one given above in two ways: the definition of closure under a basic program is different, and the definition of the reduct is different. Proposition 1 follows from two lemmas: Lemma 1. <p> Appendix. Proofs of Theorems Proof of Proposition 1 Proposition 1. For a program whose rules have the form (5), the definition of an answer set given above is equivalent to the definition from <ref> (Lifschitz 1996) </ref>. The definition of an answer set in (Lifschitz 1996) differs from the one given above in two ways: the definition of closure under a basic program is different, and the definition of the reduct is different. Proposition 1 follows from two lemmas: Lemma 1. <p> X is closed under in the sense of this paper iff X is closed under in the sense of <ref> (Lifschitz 1996) </ref>. Lemma 2. Let be a program whose rules have the form (5), and let X, Y be logically closed sets of literals. Y is closed under X iff Y is closed under the reduct of relative to X in the sense of (Lifschitz 1996). (According to the first lemma, <p> closed under in the sense of <ref> (Lifschitz 1996) </ref>. Lemma 2. Let be a program whose rules have the form (5), and let X, Y be logically closed sets of literals. Y is closed under X iff Y is closed under the reduct of relative to X in the sense of (Lifschitz 1996). (According to the first lemma, there is no need to distinguish between the two meanings of "closed under" in the statement of the second lemma.) The proofs of both lemmas use the following observation: for any logically closed set X of literals and for any literal L, X j= <p> On the other hand, X is closed under in the sense of <ref> (Lifschitz 1996) </ref> iff, for every rule (16) in , X includes at least one of the literals L 1 ; : : : ; L k provided that X includes L k+1 ; : : : ; L m . Since X is logically closed, these conditions are equivalent. <p> On the other hand, the reduct of relative to X in the sense of <ref> (Lifschitz 1996) </ref> is defined as the program obtained from by * deleting every rule (5) such that at least one of L k+1 ; : : : ; L l is not in X, or at least one of L m+1 ; : : : ; L n is in X,
Reference: <author> Lin, F., and Shoham, Y. </author> <year> 1992. </year> <title> A logic of knowledge and justified assumptions. </title> <booktitle> Artificial Intelligence 57 </booktitle> <pages> 271-289. </pages>
Reference: <author> Lloyd, J., and Topor, R. </author> <year> 1984. </year> <title> Making Prolog more expressive. </title> <journal> Journal of Logic Programming 3 </journal> <pages> 225-240. </pages>
Reference-contexts: Program (4) does not satisfy condition (ii), and one of its two answer sets is a subset of the other. Relation to the Lloyd-Topor Semantics The review of the Lloyd-Topor semantics below differs from its description in <ref> (Lloyd & Topor 1984) </ref> in two ways. First, it is restricted to the propositional case. Second, it is stated in terms of "supported models" (Apt, Blair, & Walker 1988) instead of completion, which allows us to extend the theory to infinite programs. For finite programs, the two definitions are equivalent.
Reference: <author> Niemela, I., and Simons, P. </author> <year> 1996. </year> <title> Efficient implementation of the well-founded and stable model semantics. </title> <booktitle> In Proc. Joint Int'l Conf. and Symp. on Logic Programming, </booktitle> <pages> 289-303. </pages>
Reference-contexts: The role of logic programs under the answer set semantics as a knowledge representation language has been growing in recent years, as evidenced, for instance, by its use for specifying planning problems (Subrahmanian & Zaniolo 1995) and by the development of software systems for computing answer sets, such as SMODELS <ref> (Niemela & Simons 1996) </ref>. In (Dimopoulos, Nebel, & Koehler 1997), SMODELS is used as a basis for an efficient planning algorithm.
Reference: <author> Pearce, D. </author> <year> 1997. </year> <title> A new logical characterization of stable models and answer sets. </title> <editor> In Dix, J.; Pereira, L.; and Przymusinski, T., eds., </editor> <booktitle> Non-Monotonic Extensions of Logic Programming (Lecture Notes in Artificial Intelligence 1216), </booktitle> <pages> 57-70. </pages> <publisher> Springer-Verlag. </publisher>
Reference: <author> Subrahmanian, V., and Zaniolo, C. </author> <year> 1995. </year> <title> Relating stable models and AI planning domains. </title> <booktitle> In Proc. </booktitle> <address> ICLP-95. </address>
Reference-contexts: The role of logic programs under the answer set semantics as a knowledge representation language has been growing in recent years, as evidenced, for instance, by its use for specifying planning problems <ref> (Subrahmanian & Zaniolo 1995) </ref> and by the development of software systems for computing answer sets, such as SMODELS (Niemela & Simons 1996). In (Dimopoulos, Nebel, & Koehler 1997), SMODELS is used as a basis for an efficient planning algorithm.
References-found: 18

