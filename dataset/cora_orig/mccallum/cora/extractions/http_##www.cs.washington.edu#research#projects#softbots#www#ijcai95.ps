URL: http://www.cs.washington.edu/research/projects/softbots/www/ijcai95.ps
Refering-URL: http://www.cs.washington.edu/research/projects/softbots/www/bib.html
Root-URL: 
Email: neal@cs.washington.edu, etzioni@cs.washington.edu  
Phone: (206) 616-1849 FAX: (206) 543-2969  
Title: A Sound and Fast Goal Recognizer  
Author: Neal Lesh and Oren Etzioni 
Address: Seattle, WA 98195  
Affiliation: Department of Computer Science and Engineering University of Washington,  
Abstract: tified, but not yet practical. "Scruffy" systems | heuristic, domain specific, but practical. In contrast, we describe a goal recognition module that is provably sound and polynomial-time and that performs well in a real domain. Our goal recognizer observes actions executed by a human, and repeatedly prunes inconsistent actions and goals from a graph representation of the domain. We report on experiments on human subjects in the Unix domain that demonstrate our algorithm to be fast in practice. The average time to process an observed action with an initial set of 249 goal schemas and 22 action schemas was 1.4 cpu seconds on a SPARC-10.
Abstract-found: 1
Intro-found: 1
Reference: [ Bauer et al., 1993 ] <author> M. Bauer, S. Biundo, D. Dengler, J. Kohler, and Paul G. </author> <title> Phi-a logic-based tool for intelligent help systems. </title> <booktitle> In Proceedings of the 13th International Joint Conference on Artificial Intelligence. </booktitle> <year> 1993. </year>
Reference-contexts: His system is sound and complete on restricted classes of plan hierarchies unlike ours which approximates consistency relationships based on an exponentially large plan space. <ref> [ Bauer et al., 1993 ] </ref> 's definition of when a plan can be refined to include actions resembles our definition of a plan being consistent with actions, but their computational approach is quite different from ours. 7 Critique and future work Our algorithm requires polynomial time in size of the
Reference: [ Charniak and Goldman, 1991 ] <author> E. Charniak and R. Gold-man. </author> <title> A probablistic model of plan recognition. </title> <booktitle> In Proc. 9th Nat. Conf. on A.I., </booktitle> <volume> volume 1, </volume> <pages> pages 160-5, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: Her system does not consider all allowable plans, as ours does, but instead searches for a good explanatory plan. There is some work on trying to select the best or most probable plan or combination of plans (e.g. <ref> [ Charniak and Goldman, 1991 ] </ref> ).
Reference: [ Etzioni et al., 1992 ] <author> O. Etzioni, S. Hanks, D. Weld, D. Draper, N. Lesh, and M. Williamson. </author> <title> An Approach to Planning with Incomplete Information. </title> <booktitle> In Proc. 3rd Int. Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: The system is given, as input, an arbitrary subset of the actor's beliefs. The more of the actor's beliefs the system is given, the more goals it can prove inconsistent. 3.1 Planning language Our formulation is general enough to accommodate many planning languages. We use UWL <ref> [ Etzioni et al., 1992 ] </ref> , an extension of the STRIPS language, because it can express information-gathering goals and actions with sensory effects. This is necessary to distinguish between Unix commands such as pwd and cd. In UWL, states are sets of literals.
Reference: [ Etzioni, 1991 ] <author> Oren Etzioni. </author> <title> STATIC: A problem-space compiler for prodigy. </title> <booktitle> In Proc. 9th Nat. Conf. on A.I., </booktitle> <year> 1991. </year>
Reference-contexts: To determine consistency, we must reason about all plans for each candidate goal. To reason tractably, we borrow techniques for constructing and manipulating graph representations of planning problems, originally developed to produce search control for generative planners <ref> [ Etzioni, 1991; Smith and Peot, 1993 ] </ref> . By analyzing interactions among the actions, action schemas, and goal schemas in our consistency graphs (defined below), we detect cases where no valid plan exists for a goal.
Reference: [ Goodman and Litman, 1992 ] <author> B. Goodman and D. Litman. </author> <title> On the interaction between plan recognition and intelligent interfaces. In User Modeling and User Adapted Interaction, </title> <journal> volume 2, </journal> <volume> no. </volume> <pages> 1-2, pages 83-115, </pages> <year> 1992. </year>
Reference-contexts: We have focused on identifying the actor's goal. There are several potential applications for an effective goal recognizer. Goal recognition is useful for enhancing intelligent user in terfaces <ref> [ Goodman and Litman, 1992 ] </ref> . Furthermore, a goal recognizer would allow an autonomous agent to provide useful services to the people it interacts with, such as completing their current tasks and offering advice on how to better achieve future goals. This paper describes a goal recognition module.
Reference: [ Kautz, 1987 ] <author> H. Kautz. </author> <title> A Formal Theory Of Plan Recognition. </title> <type> PhD thesis, </type> <institution> University of Rochester, </institution> <year> 1987. </year>
Reference-contexts: 1 Introduction and motivation Plan recognition (e.g. <ref> [ Kautz, 1987; Pollack, 1990 ] </ref> ) is the task of identifying an actor's plan and goal given a partial view of that actor's behavior. We have focused on identifying the actor's goal. There are several potential applications for an effective goal recognizer.
Reference: [ Lesh and Etzioni, 1995 ] <author> N. Lesh and O. Etzioni. </author> <title> A sound, fast, and empirically-tested goal recognizer based on version spaces. </title> <type> Technical report, Draft. </type> <institution> University of Wash-ington, </institution> <year> 1995. </year>
Reference-contexts: This goal recognizer is provably sound and runs in polynomial time. In this section, we present our theorems and provide intuitions for why they are true. The full proofs are in <ref> [ Lesh and Etzioni, 1995 ] </ref> . In section 5, we validate our algorithm using data gathered in the Unix domain. Our goal recognizer constructs and manipulates a single consistency graph based on the input . <p> We view our goal recognizer, which quickly prunes out the inconsistent goals, as a useful module. The next step might be to assign probabilities to the remaining goals. In <ref> [ Lesh and Etzioni, 1995 ] </ref> we propose a very different solution based on version spaces [ Mitchell, 1982 ] . We view goals as hypotheses. When a single, strongest consistent goal-hypothesis exists, we know that achieving this goal will benefit the actor. <p> A more sophisticated algorithm, described in <ref> [ Lesh and Etzioni, 1995 ] </ref> , runs in time linear in the number of input goals (though still polynomial in jflj). But reasonable goal spaces may be exponentially large in relevant features of the domain, such as the number of predicates. <p> Our solution is based on version spaces [ Mitchell, 1982 ] . We view goals as hypotheses and explicitly compute only the strongest consistent hypotheses and the weakest consistent hypotheses. These two boundaries compactly represent the set of all consistent goals. In <ref> [ Lesh and Etzioni, 1995 ] </ref> , we identify a class of goals such that we can determine the consistency of 2 n goals by explicitly computing consistency on only n goals.
Reference: [ Mitchell, 1982 ] <author> T. Mitchell. </author> <title> Generalization as search. </title> <journal> Artificial Intelligence, </journal> <volume> 18 </volume> <pages> 203-226, </pages> <month> March </month> <year> 1982. </year>
Reference-contexts: We view our goal recognizer, which quickly prunes out the inconsistent goals, as a useful module. The next step might be to assign probabilities to the remaining goals. In [ Lesh and Etzioni, 1995 ] we propose a very different solution based on version spaces <ref> [ Mitchell, 1982 ] </ref> . We view goals as hypotheses. When a single, strongest consistent goal-hypothesis exists, we know that achieving this goal will benefit the actor. Due to space limitations, we describe a special case of this approach, subset convergence, that works well on these problems. <p> But reasonable goal spaces may be exponentially large in relevant features of the domain, such as the number of predicates. Our solution is based on version spaces <ref> [ Mitchell, 1982 ] </ref> . We view goals as hypotheses and explicitly compute only the strongest consistent hypotheses and the weakest consistent hypotheses. These two boundaries compactly represent the set of all consistent goals.
Reference: [ Pollack, 1990 ] <author> M. Pollack. </author> <title> Plans as Complex Mental Attitudes, </title> <address> pages 77-101. </address> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction and motivation Plan recognition (e.g. <ref> [ Kautz, 1987; Pollack, 1990 ] </ref> ) is the task of identifying an actor's plan and goal given a partial view of that actor's behavior. We have focused on identifying the actor's goal. There are several potential applications for an effective goal recognizer. <p> We believe, however, that people rarely interleave large numbers of plans. If we assume that actors only pursue at most, say, 3 or 4 goals simultaneously then our technique, which can terminate at G 3 or G 4 , becomes polynomial and sound. There has been some work (e.g. <ref> [ Pollack, 1990 ] </ref> ) on recognizing invalid plans. We allow some invalid plans, because we allow all plans which could achieve the goal based on the actor's incomplete model of the world. Some of these plans will not achieve the goal when executed from the actual world state.
Reference: [ Smith and Peot, 1993 ] <author> D. Smith and M. Peot. </author> <title> Postponing threats in partial-order planning. </title> <booktitle> In Proc. 11th Nat. Conf. on A.I., </booktitle> <pages> pages 500-506, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: To determine consistency, we must reason about all plans for each candidate goal. To reason tractably, we borrow techniques for constructing and manipulating graph representations of planning problems, originally developed to produce search control for generative planners <ref> [ Etzioni, 1991; Smith and Peot, 1993 ] </ref> . By analyzing interactions among the actions, action schemas, and goal schemas in our consistency graphs (defined below), we detect cases where no valid plan exists for a goal.
Reference: [ Vilain, 1990 ] <author> M. Vilain. </author> <title> Getting serious about parsing plans: a grammatical analysis of plan recognition. </title> <booktitle> In Proc. 8th Nat. Conf. on A.I., </booktitle> <pages> pages 190-197, </pages> <year> 1990. </year>
Reference-contexts: re search; our recognizer can produce the consistent goals which can then be subjected to more expensive probabilistic analysis. [ Weida and Litman, 1992 ] extend term subsumption to include plan recognition, motivated by the need to organize large numbers of plans, much like our desire to handle large domains. <ref> [ Vilain, 1990 ] </ref> describes a polynomial-time plan recognizer based on grammatical parsing.
Reference: [ Weida and Litman, 1992 ] <author> R. Weida and D. Litman. </author> <title> Terminological Reasoning with Constraint Networks and an Application to Plan Recognition. </title> <booktitle> In Proc. 3rd Int. Conf. on Principles of Knowledge Representation and Reasoning, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: There is some work on trying to select the best or most probable plan or combination of plans (e.g. [ Charniak and Goldman, 1991 ] ). Our work complements this re search; our recognizer can produce the consistent goals which can then be subjected to more expensive probabilistic analysis. <ref> [ Weida and Litman, 1992 ] </ref> extend term subsumption to include plan recognition, motivated by the need to organize large numbers of plans, much like our desire to handle large domains. [ Vilain, 1990 ] describes a polynomial-time plan recognizer based on grammatical parsing.
References-found: 12

