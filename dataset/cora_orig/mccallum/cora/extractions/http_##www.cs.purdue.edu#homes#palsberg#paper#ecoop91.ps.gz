URL: http://www.cs.purdue.edu/homes/palsberg/paper/ecoop91.ps.gz
Refering-URL: http://www.cs.purdue.edu/homes/palsberg/publications.html
Root-URL: http://www.cs.purdue.edu
Email: palsberg@daimi.aau.dk mis@daimi.aau.dk  
Title: What is Type-Safe Code Reuse?  
Author: Jens Palsberg Michael I. Schwartzbach 
Address: Ny Munkegade DK-8000 -Arhus C, Denmark  
Affiliation: Computer Science Department Aarhus University  
Note: In Proc. ECOOP'91, Springer-Verlag (LNCS 512), pages 325-341.  
Abstract: Subclassing is reuse of class definitions. It is usually tied to the use of class names, thus relying on the order in which the particular classes in a program are created. This is a burden, however, both when programming and in theoretical studies. This paper presents a structural notion of subclassing for typed languages. It is a direct abstraction of the Smalltalk interpreter and the separate compilation technique of Modula. We argue that it is the most general mechanism which can be supported by the implementation while relying on the type-correctness of superclasses. In short, it captures type-safe code reuse.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In Gilles Kahn, David Mac-Queen, and Gordon Plotkin, editors, </editor> <booktitle> Semantics of Data Types, </booktitle> <pages> pages 51-68. </pages> <publisher> Springer-Verlag (LNCS 173), </publisher> <year> 1984. </year>
Reference-contexts: The point is that if all classes and subclass relations are given a priori| independently of the programmer's definitions|then they are easier to deal with mathematically. This idea lies behind almost all theories which study types independently of particular programs, see for example <ref> [1, 2, 5] </ref>. In this paper we derive a structural subclassing mechanism from existing implementation techniques; this a sound basis for theoretical investigations of subclass-ing and subtyping in object-oriented programming. We have already reported some of these investigations in other papers [13, 12], see the overview in figure 3.
Reference: [2] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction, and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: The point is that if all classes and subclass relations are given a priori| independently of the programmer's definitions|then they are easier to deal with mathematically. This idea lies behind almost all theories which study types independently of particular programs, see for example <ref> [1, 2, 5] </ref>. In this paper we derive a structural subclassing mechanism from existing implementation techniques; this a sound basis for theoretical investigations of subclass-ing and subtyping in object-oriented programming. We have already reported some of these investigations in other papers [13, 12], see the overview in figure 3.
Reference: [3] <author> William Cook, Walter Hill, and Peter Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In Seventeenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 125-135, </pages> <year> 1990. </year>
Reference-contexts: Our reason for introducing this extra flexibility is the following. When an instance of for example a list class is created by a method of the list class itself, see figure 4, then the occurrence of list in new list is a recursive one <ref> [3] </ref>. class list . . . new list . . . end list In Eiffel, this recurrence can be made explicit by writing like Current instead of list. Analogously, in Smalltalk, one can write self class.
Reference: [4] <author> William Cook and Jens Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <journal> Information and Computation, </journal> <volume> 114(2) </volume> <pages> 329-350, </pages> <year> 1994. </year> <note> Also in Proc. </note> <editor> OOPSLA'89, </editor> <booktitle> ACM SIGPLAN Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 433-443, </pages> <address> New Orleans, Louisiana, </address> <month> October </month> <year> 1989. </year>
Reference-contexts: This operation returns an object pointer to a record with fields initialized by the arguments. Again, the number of instance variables is statically known by the compiler. 3.2 Inheritance The concept of inheritance allows the construction of subclasses by adding variables and methods, and by replacing method bodies <ref> [4] </ref>. At run-time an important new structure is introduced: the class table, which for each class C describes its superclass, its number of instance variables, and its method dictionary associating code addresses to method names.
Reference: [5] <author> Scott Danforth and Chris Tomlinson. </author> <title> Type theories and object-oriented programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 20(1) </volume> <pages> 29-72, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: The point is that if all classes and subclass relations are given a priori| independently of the programmer's definitions|then they are easier to deal with mathematically. This idea lies behind almost all theories which study types independently of particular programs, see for example <ref> [1, 2, 5] </ref>. In this paper we derive a structural subclassing mechanism from existing implementation techniques; this a sound basis for theoretical investigations of subclass-ing and subtyping in object-oriented programming. We have already reported some of these investigations in other papers [13, 12], see the overview in figure 3.
Reference: [6] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80|The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Previous research tends to suggest new type systems for languages with inheritance, but to ignore compilation. This paper takes a radically different approach: We analyze the Smalltalk <ref> [6] </ref> interpreter together with a well-known technique for separate compilation of Modula modules, extend them, and derive a general subclassing mechanism for type-safe code reuse.
Reference: [7] <author> Justin O. Graver and Ralph E. Johnson. </author> <title> A type system for Smalltalk. </title> <booktitle> In Seventeenth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 136-150, </pages> <year> 1990. </year>
Reference-contexts: Our analysis of the compilation technique is based on the assumptions that types are finite sets of classes and that variables can only contain instances of the declared classes <ref> [7, 8, 14] </ref>. 2.2 Structural subclassing Subclassing is usually tied to the use of class names. This means that a class is a subclass of only its ancestors in the explicitly created class hierarchy. In other words, a superclass must be created before the subclass.
Reference: [8] <author> Justin Owen Graver. </author> <title> Type-Checking and Type-Inference for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> August </month> <year> 1989. </year> <note> UIUCD-R-89-1539. 17 </note>
Reference-contexts: Our analysis of the compilation technique is based on the assumptions that types are finite sets of classes and that variables can only contain instances of the declared classes <ref> [7, 8, 14] </ref>. 2.2 Structural subclassing Subclassing is usually tied to the use of class names. This means that a class is a subclass of only its ancestors in the explicitly created class hierarchy. In other words, a superclass must be created before the subclass.
Reference: [9] <author> Bent B. Kristensen, Ole Lehrmann Madsen, Birger Mtller-Pedersen, and Kristen Nygaard. </author> <title> The BETA programming language. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 7-48. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Our approach means that in recordlist the recursive occurrence of list is implicitly substituted by recordlist. But why, we ask, should only the class in some but not all new expressions be substitutable? By introducing class lookup, we remove this unpleasing asymmetry. The notion of virtual class in Beta <ref> [9, 10] </ref> is actually implemented by a variation of class lookup. 5 Let us now move on to a description of how to implement classes, inheritance, and instance creation. 3 Code Reuse We will describe interpreters for three languages of increasing complexity.
Reference: [10] <author> Ole Lehrmann Madsen and Birger Mtller-Pedersen. </author> <title> Virtual classes: A powerful mechanism in object-oriented programming. </title> <booktitle> In Proc. OOPSLA'89, Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 397-406. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Our approach means that in recordlist the recursive occurrence of list is implicitly substituted by recordlist. But why, we ask, should only the class in some but not all new expressions be substitutable? By introducing class lookup, we remove this unpleasing asymmetry. The notion of virtual class in Beta <ref> [9, 10] </ref> is actually implemented by a variation of class lookup. 5 Let us now move on to a description of how to implement classes, inheritance, and instance creation. 3 Code Reuse We will describe interpreters for three languages of increasing complexity.
Reference: [11] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, NJ, </address> <year> 1988. </year>
Reference-contexts: Finally, in section 5 we give an example. 2 Motivation It is a useful property of an object-oriented language to be statically typed and to allow separate compilation of classes. The languages C++ [16] and Eiffel <ref> [11] </ref> come close to achieving this, though the type systems of both have well-known loopholes. Similar to Modula [17] implementations, a compiler for these languages needs only some symbol table information about previously compiled classes. In particular, this is true of the superclass of the class being compiled. <p> Analogously, in Smalltalk, one can write self class. Now in a subclass of list, say recordlist, what kind of instance should be created? Meyer <ref> [11] </ref> argues that the programmer in some cases wants an instance of list and in others an instance of recordlist. In Eiffel, a statement corresponding to new list would cause the creation of the former, and new (like Current) the latter.
Reference: [12] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Genericity And Inheritance. </title> <institution> Computer Science Department, Aarhus University. PB-318, </institution> <year> 1990. </year>
Reference-contexts: This subclassing mechanism turns out to be exactly the one which we earlier have shown to be spanned by inheritance and type substitution (a new genericity mechanism) <ref> [13, 12] </ref>. Our analysis of the compilation technique is based on the assumptions that types are finite sets of classes and that variables can only contain instances of the declared classes [7, 8, 14]. 2.2 Structural subclassing Subclassing is usually tied to the use of class names. <p> In this paper we derive a structural subclassing mechanism from existing implementation techniques; this a sound basis for theoretical investigations of subclass-ing and subtyping in object-oriented programming. We have already reported some of these investigations in other papers <ref> [13, 12] </ref>, see the overview in figure 3. Originally, we simply defined the subclassing mechanism that we have now derived. It turned out to have many nice mathematical properties and it lead us to discover a new genericity mechanism (type substitution) which is a significant improvement compared to parameterized classes. <p> This relation will be a subset of / impl , it will satisfy all the requirements for being a structural subclassing concept, and it is|as far as the authors can see|the largest such one which is mathematically attractive. It should be noted that / tree generalizes inheritance <ref> [12] </ref>, and that it seems possible to define a restriction of the legal contexts so that in fact / impl = / tree . The required restriction on contexts is quite subtle: recursive classes may not be "unfolded" in the implementation. <p> This definition contains no mention of implementations; nevertheless, we can show that / tree / impl , see the following subsection. It is easy to see that / tree is reflexive, transitive, and independent of class names. Finally, / tree is decidable at compile-time using finite-state automata algorithmics <ref> [12] </ref>. Thus, it does satisfy our requirements of being an independent, structural subclass relation that is at the same time rooted in implementation practices. <p> Finally, / tree is decidable at compile-time using finite-state automata algorithmics [12]. Thus, it does satisfy our requirements of being an independent, structural subclass relation that is at the same time rooted in implementation practices. The above definition of / tree is the basis of the papers <ref> [13, 12] </ref>. 4.4 Formalities We now sketch a demonstration of the inclusion / tree / impl : Assume that T 1 / tree T 2 . We must construct fi, C 1 , C 2 with the appropriate properties. We shall in fact provide an inductive method for doing this.
Reference: [13] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Type substitution for object-oriented programming. </title> <booktitle> In Proc. OOPSLA/ECOOP'90, ACM SIGPLAN Fifth Annual Conference on Object-Oriented Programming Systems, Languages and Applications; European Conference on Object-Oriented Programming, </booktitle> <pages> pages 151-160, </pages> <address> Ottawa, Canada, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: This subclassing mechanism turns out to be exactly the one which we earlier have shown to be spanned by inheritance and type substitution (a new genericity mechanism) <ref> [13, 12] </ref>. Our analysis of the compilation technique is based on the assumptions that types are finite sets of classes and that variables can only contain instances of the declared classes [7, 8, 14]. 2.2 Structural subclassing Subclassing is usually tied to the use of class names. <p> In this paper we derive a structural subclassing mechanism from existing implementation techniques; this a sound basis for theoretical investigations of subclass-ing and subtyping in object-oriented programming. We have already reported some of these investigations in other papers <ref> [13, 12] </ref>, see the overview in figure 3. Originally, we simply defined the subclassing mechanism that we have now derived. It turned out to have many nice mathematical properties and it lead us to discover a new genericity mechanism (type substitution) which is a significant improvement compared to parameterized classes. <p> With our technique, an instance of recordlist will always be created|the choice that will most often be appropriate. The generality of Eiffel can be recovered, however, using opaque definitions <ref> [13] </ref>, but this will not concern us here. Our approach means that in recordlist the recursive occurrence of list is implicitly substituted by recordlist. But why, we ask, should only the class in some but not all new expressions be substitutable? By introducing class lookup, we remove this unpleasing asymmetry. <p> Finally, / tree is decidable at compile-time using finite-state automata algorithmics [12]. Thus, it does satisfy our requirements of being an independent, structural subclass relation that is at the same time rooted in implementation practices. The above definition of / tree is the basis of the papers <ref> [13, 12] </ref>. 4.4 Formalities We now sketch a demonstration of the inclusion / tree / impl : Assume that T 1 / tree T 2 . We must construct fi, C 1 , C 2 with the appropriate properties. We shall in fact provide an inductive method for doing this. <p> The incremental implementation shows that C and D should be subclass related. Indeed, we can specify D as explicitly being a subclass of C by using the standard syntax for inheritance together with the syntax for type substitution that we introduced in <ref> [13] </ref>, see figure 10. class C var x: integer method p (arg: boolean) . . . new object . . . new C . . . class D var x: integer method p (arg: boolean) . . . new boolean . . . new D . . . var y: integer
Reference: [14] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proc. OOPSLA'91, ACM SIGPLAN Sixth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 146-161, </pages> <address> Phoenix, Ari-zona, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Our analysis of the compilation technique is based on the assumptions that types are finite sets of classes and that variables can only contain instances of the declared classes <ref> [7, 8, 14] </ref>. 2.2 Structural subclassing Subclassing is usually tied to the use of class names. This means that a class is a subclass of only its ancestors in the explicitly created class hierarchy. In other words, a superclass must be created before the subclass.
Reference: [15] <author> Claus H. Pedersen. </author> <title> Extending ordinary inheritance schemes to include generalization. </title> <booktitle> In Proc. OOPSLA'89, ACM SIGPLAN Fourth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <pages> pages 407-418, </pages> <year> 1989. </year>
Reference-contexts: An obvious possibility is to implement it as a subclass of Device, see figure 1B. Pedersen <ref> [15] </ref> discusses the case where the programmer realizes that all three terminals actually are ANSI terminals, i.e., they support the ANSI-defined control sequences.
Reference: [16] <author> Bjarne Stroustrup. </author> <title> The C ++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Finally, in section 5 we give an example. 2 Motivation It is a useful property of an object-oriented language to be statically typed and to allow separate compilation of classes. The languages C++ <ref> [16] </ref> and Eiffel [11] come close to achieving this, though the type systems of both have well-known loopholes. Similar to Modula [17] implementations, a compiler for these languages needs only some symbol table information about previously compiled classes.
Reference: [17] <author> Niklaus Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1985. </year> <month> 18 </month>
Reference-contexts: The languages C++ [16] and Eiffel [11] come close to achieving this, though the type systems of both have well-known loopholes. Similar to Modula <ref> [17] </ref> implementations, a compiler for these languages needs only some symbol table information about previously compiled classes. In particular, this is true of the superclass of the class being compiled.
References-found: 17

