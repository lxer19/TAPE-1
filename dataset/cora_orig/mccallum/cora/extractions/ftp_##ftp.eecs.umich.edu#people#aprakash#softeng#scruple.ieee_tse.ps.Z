URL: ftp://ftp.eecs.umich.edu/people/aprakash/softeng/scruple.ieee_tse.ps.Z
Refering-URL: http://www.eecs.umich.edu/~aprakash/csrg_pub.html
Root-URL: http://www.cs.umich.edu
Email: Email: santanu@eecs.umich.edu, aprakash@eecs.umich.edu  
Title: A Framework for Source Code Search using Program Patterns  
Author: Santanu Paul Atul Prakash 
Keyword: Reverse engineering, software maintenance, software reengineering, program understanding, pattern matching, query language.  
Address: Ann Arbor, MI-48105  
Affiliation: Software Systems Research Laboratory Dept. of Electrical Engineering and Computer Science University of Michigan,  
Abstract: For maintainers involved in understanding and reengineer-ing large software, locating source code fragments that match certain patterns is a critical task. Existing solutions to the problem are few, and they either involve manual, painstaking scans of the source code using tools based on regular expressions, or the use of large, integrated software engineering environments that include simple pattern-based query processors in their toolkits. We present a framework in which pattern languages are used to specify interesting code features. The pattern languages are derived by extending the source programming language with pattern-matching symbols. We describe SCRUPLE, a finite state machine-based source code search tool, that efficiently implements this framework. We also present experimental performance results obtained from a SCRUPLE prototype, and the user interface of a source code browser built on top of SCRUPLE. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A.V. Aho, B.W. Kernighan, and P.J. Weinberger. </author> <title> The AWK Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Other tools that employ regular expressions for pattern matching include ed, sed, and awk. ed and sed [16] are text editors which allow find-replace facilities on regular expressions (which in the case of sed can span multiple lines), essentially treating the source code as a character stream. Awk <ref> [1] </ref> is a pattern matching and processing language that views its input as a stream of records. While the record abstraction is an improvement over character streams, it does not significantly help in source code search because records are inadequate for modeling the complexities in source code.
Reference: [2] <author> R. Al-Zoubi and A. Prakash. </author> <title> Software Change Analysis via Attributed Dependency Graphs. </title> <type> Technical Report CSE-TR-95-91, </type> <institution> Dept. of EECS, University of Michigan, </institution> <month> May </month> <year> 1991. </year> <note> Also in Software Maintenance, to appear. </note>
Reference-contexts: 1 Introduction There has been a growing interest in the software engineering community to develop techniques that help software engineers search through large amount of source code to locate relevant information <ref> [2, 3, 7, 10, 23, 28] </ref>. Facilities to search through source code can be useful in several situations: * Reengineering code: To reengineer software, a software engineer may need to detect the existence of repetitive code, so that it can be replaced with calls to a single procedure. <p> Similarly, the query language must permit nested and recursive patterns. As a result, the use of these tools makes queries unnatural, clumsy, and often impossible. 2.2 Browsers and program databases Omega [20], CIA [7], CIA++[10], Microscope [3], Rigi [23], and SCAN <ref> [2] </ref> are examples of tools that are designed especially for making queries on code and help with code browsing. They typically generate a program database consisting of entities such as file names, function names, and variable names, with well-defined relations between them. <p> The program source code is transformed by a source parser into a data structure called the attributed syntax tree (AST), which is based on the attributed dependency graph model described in <ref> [2] </ref>. The pattern (or query) specified by the user is transformed by a pattern parser into an automaton called code pattern automaton (CPA). CPAs are special-purpose nondeterministic finite state automata. The formal definition of a CPA is given in section 5.2. <p> Using our PL/AS prototype, we have shown that the pattern language of SCRUPLE is powerful enough to make queries similar to those possible using other browsing sys 10 tems such as CIA [7] and SCAN <ref> [2] </ref>, in addition to expressing a wide range of structural queries that are impossible using other systems. The tests described in this section were conducted on a 9,600 line PL/AS program using a Sun SPARC station. A suite of five queries was used. <p> vari able is being incremented: $v 1 = $v 1 + #; * Q5: Find a sequence of three consecutive IF statements: IF # THEN @; IF # THEN @; IF # THEN @; Q1 and Q2 are examples of simple queries supported by systems like grep, CIA, SCAN, etc. <ref> [2, 7, 10] </ref>. Q3, Q4, and Q5 are examples of queries that SCRUPLE is adept at handling, but are not handled easily by other tools. <p> Automatic generation of SCRUPLE implementations for different programming languages is also under investigation [25]. Extensions to the current SCRUPLE system are being considered. A library of frequently used patterns, including those available on other program browsing systems <ref> [2, 7, 10] </ref>, will enhance the utility of SCRUPLE. Alternative ways of letting the user navigate through the match set are being considered. We also wish to introduce a general mechanism for query composition using which more complex queries can be constructed out of simpler ones.
Reference: [3] <author> J. Ambras and V. O'Day. </author> <title> Microscope: A Program Analysis System. </title> <booktitle> In Proc. of the 20th Hawaii International Conference on System Sciences, </booktitle> <pages> pages 460-468, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction There has been a growing interest in the software engineering community to develop techniques that help software engineers search through large amount of source code to locate relevant information <ref> [2, 3, 7, 10, 23, 28] </ref>. Facilities to search through source code can be useful in several situations: * Reengineering code: To reengineer software, a software engineer may need to detect the existence of repetitive code, so that it can be replaced with calls to a single procedure. <p> Similarly, the query language must permit nested and recursive patterns. As a result, the use of these tools makes queries unnatural, clumsy, and often impossible. 2.2 Browsers and program databases Omega [20], CIA [7], CIA++[10], Microscope <ref> [3] </ref>, Rigi [23], and SCAN [2] are examples of tools that are designed especially for making queries on code and help with code browsing. They typically generate a program database consisting of entities such as file names, function names, and variable names, with well-defined relations between them.
Reference: [4] <author> H.L. Berghel and D.L. Sallach. </author> <title> Measurements of Program Similarity in identical tasking environments. </title> <journal> SIGPLAN Notices, </journal> <volume> 19(8), </volume> <year> 1984. </year>
Reference-contexts: In contrast, our scheme takes a structural approach to source code search, while supporting many of the features of the abovementioned systems. 2.3 Tools to detect plagiarism Tools that detect plagiarism in programs (the problem is relevant in the case of student assignments) <ref> [4] </ref> [11] [21] are usually based on software metrics such as Halstead's [12]. Another category of tools [14] utilize the static execution tree (the call graph) of a program to determine the `fingerprint' of a program, and use the latter to decide whether it has been copied from another program. <p> The performance of the SCRUPLE system could also be improved by using additional node attributes to record program fingerprints [14], metric informations <ref> [4, 12] </ref>, etc. 6 Experimental Results for PL/AS. The interface provides commands for selecting a file on which matching is to be done, passing the file to SCRUPLE for parsing, creating and editing patterns, and searching for matches.
Reference: [5] <author> R.S. Boyer and J.S. Moore. </author> <title> A fast string searching algorithm. </title> <journal> Communications of the ACM, </journal> 20(10) 762-772, 1977. 
Reference-contexts: The binding table for a given exploration stores only the bindings relevant to the exploration. We point out here that traditional and efficient pattern matching algorithms such as the Knuth, Morris and Pratt algorithm [17], the Boyer and Moore algorithm <ref> [5] </ref>, and the Rabin and Karp algorithm [15] were not used to solve our problem because they do not match regular expressions. 5.4 Performance Issues Managing the bindings of named wildcards causes problems in terms of algorithm complexity.
Reference: [6] <author> R. Brooks. </author> <title> Towards a Theory of Comprehension of Computer Programs. </title> <journal> International Journal of Man Machine Studies, </journal> <volume> 18 </volume> <pages> 543-554, </pages> <year> 1983. </year>
Reference-contexts: similar algorithm since those sections could have the same bug. * Understanding programs: To understand programs, programmers often make a hypothesis (enlightened or otherwise) a bout what the program does, scrutinize the source code to confirm the hypothesis, and revise the hypothesis based on what is discovered during the scrutiny <ref> [6] </ref>.
Reference: [7] <author> Y. Chen, M.Y. Nishimoto, and C.V. Ramamoor-thy. </author> <title> The C Information Abstraction System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(3) </volume> <pages> 325-334, </pages> <month> March </month> <year> 1990. </year>
Reference-contexts: 1 Introduction There has been a growing interest in the software engineering community to develop techniques that help software engineers search through large amount of source code to locate relevant information <ref> [2, 3, 7, 10, 23, 28] </ref>. Facilities to search through source code can be useful in several situations: * Reengineering code: To reengineer software, a software engineer may need to detect the existence of repetitive code, so that it can be replaced with calls to a single procedure. <p> For source code search, the source code should be modeled using its abstract syntax representation. Similarly, the query language must permit nested and recursive patterns. As a result, the use of these tools makes queries unnatural, clumsy, and often impossible. 2.2 Browsers and program databases Omega [20], CIA <ref> [7] </ref>, CIA++[10], Microscope [3], Rigi [23], and SCAN [2] are examples of tools that are designed especially for making queries on code and help with code browsing. They typically generate a program database consisting of entities such as file names, function names, and variable names, with well-defined relations between them. <p> Using our PL/AS prototype, we have shown that the pattern language of SCRUPLE is powerful enough to make queries similar to those possible using other browsing sys 10 tems such as CIA <ref> [7] </ref> and SCAN [2], in addition to expressing a wide range of structural queries that are impossible using other systems. The tests described in this section were conducted on a 9,600 line PL/AS program using a Sun SPARC station. A suite of five queries was used. <p> vari able is being incremented: $v 1 = $v 1 + #; * Q5: Find a sequence of three consecutive IF statements: IF # THEN @; IF # THEN @; IF # THEN @; Q1 and Q2 are examples of simple queries supported by systems like grep, CIA, SCAN, etc. <ref> [2, 7, 10] </ref>. Q3, Q4, and Q5 are examples of queries that SCRUPLE is adept at handling, but are not handled easily by other tools. <p> Automatic generation of SCRUPLE implementations for different programming languages is also under investigation [25]. Extensions to the current SCRUPLE system are being considered. A library of frequently used patterns, including those available on other program browsing systems <ref> [2, 7, 10] </ref>, will enhance the utility of SCRUPLE. Alternative ways of letting the user navigate through the match set are being considered. We also wish to introduce a general mechanism for query composition using which more complex queries can be constructed out of simpler ones.
Reference: [8] <author> J.R. Cordy, C.D. Halpern-Hamu, and E. Promislow. TXL: </author> <title> A Rapid Prototyping System for Programming Language Dialects. </title> <journal> Computer Languages, </journal> <volume> 16(1) </volume> <pages> 97-107, </pages> <year> 1991. </year>
Reference-contexts: The purpose is to automate software tasks such as development, modification, and correction. Transformations are specified using rules. The left-hand side of a rule is a code pattern. The right-hand side consists of actions that must be performed if the left hand side matches. The TXL system <ref> [8] </ref> converts code written in a dialect language into code in the base language. This is accomplished by transforming the parse tree derived using the dialect grammar into a parse tree of the base language grammar, and extracting a new program from the latter.
Reference: [9] <author> D. Garlan, L. Cai, </author> <title> and R.L. Nord. A Transformational Approach to Generating Application-specific Environments. </title> <booktitle> In Proceedings of SIGSOFT, </booktitle> <year> 1992. </year>
Reference-contexts: Apparently, a recursive tree matching algorithm is employed by the tree transformer. The specifics of the algorithm and its complexity are unavailable. The ASCENT system <ref> [9] </ref> generates program transformers to convert programs written in an application-specific language into those written in a general-purpose language, by transforming parse trees. In contrast to the implicit tree matching in the above systems, the REFINE system [28] offers an explicit pattern-based query language to manipulate source code [18].
Reference: [10] <author> J.E. Grass. </author> <title> Object-Oriented Design Archaeology with CIA++. </title> <journal> Computing Systems: The Journal of the USENIX Association, </journal> <volume> 5(1) </volume> <pages> 5-67, </pages> <month> Winter </month> <year> 1992. </year>
Reference-contexts: 1 Introduction There has been a growing interest in the software engineering community to develop techniques that help software engineers search through large amount of source code to locate relevant information <ref> [2, 3, 7, 10, 23, 28] </ref>. Facilities to search through source code can be useful in several situations: * Reengineering code: To reengineer software, a software engineer may need to detect the existence of repetitive code, so that it can be replaced with calls to a single procedure. <p> vari able is being incremented: $v 1 = $v 1 + #; * Q5: Find a sequence of three consecutive IF statements: IF # THEN @; IF # THEN @; IF # THEN @; Q1 and Q2 are examples of simple queries supported by systems like grep, CIA, SCAN, etc. <ref> [2, 7, 10] </ref>. Q3, Q4, and Q5 are examples of queries that SCRUPLE is adept at handling, but are not handled easily by other tools. <p> Automatic generation of SCRUPLE implementations for different programming languages is also under investigation [25]. Extensions to the current SCRUPLE system are being considered. A library of frequently used patterns, including those available on other program browsing systems <ref> [2, 7, 10] </ref>, will enhance the utility of SCRUPLE. Alternative ways of letting the user navigate through the match set are being considered. We also wish to introduce a general mechanism for query composition using which more complex queries can be constructed out of simpler ones.
Reference: [11] <author> S. Grier. </author> <title> A Tool that detects plagiarism in Pascal Programs. </title> <journal> SIGSCE Bulletin, </journal> <volume> 13(1), </volume> <year> 1981. </year>
Reference-contexts: In contrast, our scheme takes a structural approach to source code search, while supporting many of the features of the abovementioned systems. 2.3 Tools to detect plagiarism Tools that detect plagiarism in programs (the problem is relevant in the case of student assignments) [4] <ref> [11] </ref> [21] are usually based on software metrics such as Halstead's [12]. Another category of tools [14] utilize the static execution tree (the call graph) of a program to determine the `fingerprint' of a program, and use the latter to decide whether it has been copied from another program.
Reference: [12] <author> M.H. Halstead. </author> <title> Elements of Software Science. </title> <publisher> Elsevier North-Holland, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: a structural approach to source code search, while supporting many of the features of the abovementioned systems. 2.3 Tools to detect plagiarism Tools that detect plagiarism in programs (the problem is relevant in the case of student assignments) [4] [11] [21] are usually based on software metrics such as Halstead's <ref> [12] </ref>. Another category of tools [14] utilize the static execution tree (the call graph) of a program to determine the `fingerprint' of a program, and use the latter to decide whether it has been copied from another program. <p> The performance of the SCRUPLE system could also be improved by using additional node attributes to record program fingerprints [14], metric informations <ref> [4, 12] </ref>, etc. 6 Experimental Results for PL/AS. The interface provides commands for selecting a file on which matching is to be done, passing the file to SCRUPLE for parsing, creating and editing patterns, and searching for matches.
Reference: [13] <author> J.E. Hopcroft and J.D. Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: The input to the CPA is an AST. Ordi nary finite state machines cannot be run with a syntax tree as input, and must be extended. The definition of a CPA evolves from that of a classical nondeterministic finite state machine <ref> [13] </ref>. Two key extensions to the classical model are introduced. First, the input alphabet consists of syntactic elements of the source code, i.e., nodes of the AST (terminals and nonterminals).
Reference: [14] <author> H.T. Jankowitz. </author> <title> Detecting Plagiarism in Student Pas-cal Programs. </title> <journal> The Computer Journal, </journal> <volume> 31(1), </volume> <year> 1988. </year>
Reference-contexts: Another category of tools <ref> [14] </ref> utilize the static execution tree (the call graph) of a program to determine the `fingerprint' of a program, and use the latter to decide whether it has been copied from another program. <p> The performance of the SCRUPLE system could also be improved by using additional node attributes to record program fingerprints <ref> [14] </ref>, metric informations [4, 12], etc. 6 Experimental Results for PL/AS. The interface provides commands for selecting a file on which matching is to be done, passing the file to SCRUPLE for parsing, creating and editing patterns, and searching for matches.
Reference: [15] <author> R.M. Karp and M.O. Rabin. </author> <title> Efficient randomized pattern matching algorithm. </title> <type> Technical Report TR-31-81, </type> <institution> Aiken Computation Lab., Harvard University, </institution> <year> 1981. </year>
Reference-contexts: The binding table for a given exploration stores only the bindings relevant to the exploration. We point out here that traditional and efficient pattern matching algorithms such as the Knuth, Morris and Pratt algorithm [17], the Boyer and Moore algorithm [5], and the Rabin and Karp algorithm <ref> [15] </ref> were not used to solve our problem because they do not match regular expressions. 5.4 Performance Issues Managing the bindings of named wildcards causes problems in terms of algorithm complexity.
Reference: [16] <author> B.W. Kernighan and R. Pike. </author> <title> The UNIX Programming Environment. </title> <publisher> Prentice-Hall, </publisher> <year> 1984. </year>
Reference-contexts: Comparison with Other Tools 2.1 Tools based on regular expressions Why don't we just use the tools of the grep family in UNIX to specify patterns and extract the matches from the source code? Both grep and egrep can match regular expressions, which is a powerful mechanism for pattern matching <ref> [16] </ref>. They both, however, have the following limitations that make them unsuitable for our purposes: * Writing certain code specifications using grep can be difficult, and sometimes impossible. <p> This is a serious drawback in the context of source code search where most meaningful patterns of code span multiple lines. Other tools that employ regular expressions for pattern matching include ed, sed, and awk. ed and sed <ref> [16] </ref> are text editors which allow find-replace facilities on regular expressions (which in the case of sed can span multiple lines), essentially treating the source code as a character stream. Awk [1] is a pattern matching and processing language that views its input as a stream of records.
Reference: [17] <author> D.E. Knuth, J.H. Morris, and V.R. Pratt. </author> <title> Fast pattern matching in strings. </title> <journal> SIAM Journal of Computing, </journal> <volume> 6(2) </volume> <pages> 323-350, </pages> <year> 1977. </year>
Reference-contexts: The binding table for a given exploration stores only the bindings relevant to the exploration. We point out here that traditional and efficient pattern matching algorithms such as the Knuth, Morris and Pratt algorithm <ref> [17] </ref>, the Boyer and Moore algorithm [5], and the Rabin and Karp algorithm [15] were not used to solve our problem because they do not match regular expressions. 5.4 Performance Issues Managing the bindings of named wildcards causes problems in terms of algorithm complexity.
Reference: [18] <author> G.B. Kotik and L.Z. Markosian. </author> <title> Automating Software Analysis and Testing Using a Program Transformation System. </title> <booktitle> In Proceedings of ACM SIGSOFT, </booktitle> <pages> pages 75-84, </pages> <year> 1989. </year>
Reference-contexts: In contrast to the implicit tree matching in the above systems, the REFINE system [28] offers an explicit pattern-based query language to manipulate source code <ref> [18] </ref>. Program reengineering systems [19] have used REFINE to write program transformation rules. The lefthand side of these rules are usually source code patterns written using the REFINE pattern language. The REFINE source code model used is based on the abstract syntax of the programming language.
Reference: [19] <author> W. Kozaczynsky, J. Ning, and A. Engberts. </author> <title> Program Concept Recognition and Transformation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(12) </volume> <pages> 1065-1075, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Tools that employ automatic program transformation techniques for re-engineering have identified source code search as their primary performance bottleneck as well <ref> [19] </ref>. * Making queries on programs: A software developer may need to locate all lines in which a procedure is called (for instance, when the procedure interface is to be changed), a variable is modified (when it is found to have incorrect value), etc. <p> give a greater degree of control over the type of matching desired, and allow matching over a part of the program (such as a procedure, declarations, or statements) rather than a matching between two programs. 2.4 Program Transformation Tools Systems have been developed to manipulate source code through program transformation <ref> [19] </ref>. The purpose is to automate software tasks such as development, modification, and correction. Transformations are specified using rules. The left-hand side of a rule is a code pattern. The right-hand side consists of actions that must be performed if the left hand side matches. <p> In contrast to the implicit tree matching in the above systems, the REFINE system [28] offers an explicit pattern-based query language to manipulate source code [18]. Program reengineering systems <ref> [19] </ref> have used REFINE to write program transformation rules. The lefthand side of these rules are usually source code patterns written using the REFINE pattern language. The REFINE source code model used is based on the abstract syntax of the programming language. <p> Our experience with SCRUPLE shows that it is also an effective tool for expressing queries that are typical in a software maintenance or reengineering situation. Authors of program transformation systems for code reengineer-ing <ref> [19] </ref> have independently arrived at similar conclusions 11 about REFINE-like pattern languages. We interpret this as a reaffirmation of our work in SCRUPLE, where the goal is to build a powerful pattern language. 7 Conclusion We have described a framework for specifying high-level patterns in terms of programming language constructs.
Reference: [20] <author> M.A. Linton. </author> <title> Implementing Relational Views of Programs. </title> <booktitle> In Proc. of ACM SIGSOFT/SIGPLAN Software Engineering Symposium, </booktitle> <month> May </month> <year> 1984. </year> <title> Practical Software Development Environment. </title>
Reference-contexts: For source code search, the source code should be modeled using its abstract syntax representation. Similarly, the query language must permit nested and recursive patterns. As a result, the use of these tools makes queries unnatural, clumsy, and often impossible. 2.2 Browsers and program databases Omega <ref> [20] </ref>, CIA [7], CIA++[10], Microscope [3], Rigi [23], and SCAN [2] are examples of tools that are designed especially for making queries on code and help with code browsing.
Reference: [21] <author> N.H. Madhavji. </author> <title> Compare: A Collusion Detector for Pascal. </title> <journal> Technique et Science Informatiques, </journal> <volume> 4(6) </volume> <pages> 489-498, </pages> <month> November </month> <year> 1985. </year>
Reference-contexts: In contrast, our scheme takes a structural approach to source code search, while supporting many of the features of the abovementioned systems. 2.3 Tools to detect plagiarism Tools that detect plagiarism in programs (the problem is relevant in the case of student assignments) [4] [11] <ref> [21] </ref> are usually based on software metrics such as Halstead's [12]. Another category of tools [14] utilize the static execution tree (the call graph) of a program to determine the `fingerprint' of a program, and use the latter to decide whether it has been copied from another program.
Reference: [22] <author> T.J. Mccabe. </author> <title> A Complexity Measure. </title> <journal> IEEE Transactions on Software Engineering, </journal> <pages> pages 308-320, </pages> <month> De-cember </month> <year> 1976. </year>
Reference-contexts: Pattern: if # @; if # @; if # @; The goal could be to locate code sections with high cyclomatic complexity <ref> [22] </ref>; in this case there are eight possible paths through the source code. * Query: Find a set of declarations, one of which is a declaration of a variable maxval of type int.
Reference: [23] <author> H.A. Muller, </author> <title> B.D. Corrie, and S.R. Tilley. Spatial and Visual Representations of Software Structures: A model for reverse engineering. </title> <type> Technical Report TR-74.086, </type> <institution> IBM Canada Ltd., </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: 1 Introduction There has been a growing interest in the software engineering community to develop techniques that help software engineers search through large amount of source code to locate relevant information <ref> [2, 3, 7, 10, 23, 28] </ref>. Facilities to search through source code can be useful in several situations: * Reengineering code: To reengineer software, a software engineer may need to detect the existence of repetitive code, so that it can be replaced with calls to a single procedure. <p> Similarly, the query language must permit nested and recursive patterns. As a result, the use of these tools makes queries unnatural, clumsy, and often impossible. 2.2 Browsers and program databases Omega [20], CIA [7], CIA++[10], Microscope [3], Rigi <ref> [23] </ref>, and SCAN [2] are examples of tools that are designed especially for making queries on code and help with code browsing. They typically generate a program database consisting of entities such as file names, function names, and variable names, with well-defined relations between them.
Reference: [24] <author> S. Paul. SCRUPLE: </author> <title> A Re-engineer's Tool for Source Code Search. </title> <booktitle> In Proc. of the CAS Conference. </booktitle> <institution> IBM Canada Ltd. Laboratory, Centre for Advanced Studies, </institution> <year> 1992. </year>
Reference-contexts: To illustrate our approach, we give an overview of the pattern symbols in a sample pattern language for C. More detailed descriptions of the pattern language are available in <ref> [26, 24] </ref>. 4.1 Wildcards for Syntactic Entities Queries about source code (written in imperative languages) often pertain to the programming language constructs such as statements, variable declarations, type declarations, expressions, functions, etc. To make such queries possible, we introduce pattern symbols for such constructs. Table 1 lists these pattern symbols.
Reference: [25] <author> S. Paul. </author> <title> Theory and Design of Source Code Query Systems. </title> <type> PhD thesis, </type> <institution> University of Michigan, </institution> <year> 1994. </year> <note> In preparation. </note>
Reference-contexts: maxstore) $v_3 = $v_2 [#]; maxstore = int_arr [i]; * - *- return (maxstore); - Pattern Match while ($v_1&lt;25) do $v_3 [$v_1] = $f_5 ($v_1); squares [x] = squareof (x); $v_1++; x++; while (x &lt; 25); from a high-level description of the abstract syntax of the source code programming language <ref> [25, 28] </ref>. We now describe the SCRUPLE architecture in some more detail. 5.1 AST: Attributed Syntax Trees The source parser compiles the source code (on which the search is to be carried out) into an AST. <p> The problem of semantic equivalence is difficult, and starting with simple programming constructs may be a useful approach. Automatic generation of SCRUPLE implementations for different programming languages is also under investigation <ref> [25] </ref>. Extensions to the current SCRUPLE system are being considered. A library of frequently used patterns, including those available on other program browsing systems [2, 7, 10], will enhance the utility of SCRUPLE. Alternative ways of letting the user navigate through the match set are being considered.
Reference: [26] <author> S. Paul and A. Prakash. </author> <title> Source Code Retrieval Using Program Patterns. </title> <booktitle> In Proc. of the 5th International Conference on Computer Aided Software Engineering, </booktitle> <pages> pages 95-105, </pages> <year> 1992. </year>
Reference-contexts: To illustrate our approach, we give an overview of the pattern symbols in a sample pattern language for C. More detailed descriptions of the pattern language are available in <ref> [26, 24] </ref>. 4.1 Wildcards for Syntactic Entities Queries about source code (written in imperative languages) often pertain to the programming language constructs such as statements, variable declarations, type declarations, expressions, functions, etc. To make such queries possible, we introduce pattern symbols for such constructs. Table 1 lists these pattern symbols.
Reference: [27] <author> D. Perry. </author> <title> Software Interconnection Models. </title> <booktitle> In Proceedings of the 9th International Conference on Software Engineering, </booktitle> <year> 1987. </year>
Reference-contexts: The entities can be functions, declarations, statements, expressions, or other terminals and nonterminals of the source code language grammar. The use of abstract syntax representations in software engineering has been documented in <ref> [27] </ref>. 5.2 CPA: Code Pattern Automata The pattern parser compiles a user-specified pattern into a CPA, an extended nondeterministic finite state automaton. Finite state automata are a good basis for designing efficient pattern detection algorithms.
Reference: [28] <institution> Reasoning Systems, </institution> <address> Palo Alto, CA. </address> <note> REFINE User's Guide, </note> <year> 1989. </year>
Reference-contexts: 1 Introduction There has been a growing interest in the software engineering community to develop techniques that help software engineers search through large amount of source code to locate relevant information <ref> [2, 3, 7, 10, 23, 28] </ref>. Facilities to search through source code can be useful in several situations: * Reengineering code: To reengineer software, a software engineer may need to detect the existence of repetitive code, so that it can be replaced with calls to a single procedure. <p> The ASCENT system [9] generates program transformers to convert programs written in an application-specific language into those written in a general-purpose language, by transforming parse trees. In contrast to the implicit tree matching in the above systems, the REFINE system <ref> [28] </ref> offers an explicit pattern-based query language to manipulate source code [18]. Program reengineering systems [19] have used REFINE to write program transformation rules. The lefthand side of these rules are usually source code patterns written using the REFINE pattern language. <p> maxstore) $v_3 = $v_2 [#]; maxstore = int_arr [i]; * - *- return (maxstore); - Pattern Match while ($v_1&lt;25) do $v_3 [$v_1] = $f_5 ($v_1); squares [x] = squareof (x); $v_1++; x++; while (x &lt; 25); from a high-level description of the abstract syntax of the source code programming language <ref> [25, 28] </ref>. We now describe the SCRUPLE architecture in some more detail. 5.1 AST: Attributed Syntax Trees The source parser compiles the source code (on which the search is to be carried out) into an AST.
Reference: [29] <author> R. Sedgewick. </author> <title> Algorithms in C, chapter 20. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Typically, N &gt;> M , hence the algorithm is O (N 2 ). This is of the same worst-case complexity, in the length of the input, as algorithms used to match regular expressions in text strings <ref> [29] </ref>. When the pattern has named wildcards, the interpreter 9 uses binding tables to keep track of the bindings between named wildcards in the pattern and actual names seen in the source code.
Reference: [30] <author> D. Swanberg, C.F. Shu, and R. Jain. </author> <title> Knowledge Guided Parsing in Video Databases. </title> <booktitle> In Image and Video Processing Conference; Symposium on Electronic Imaging: Science & Technology, volume 1908, </booktitle> <pages> pages 13-24, </pages> <address> San Jose, California, </address> <month> February </month> <year> 1993. </year> <month> IS&T/SPIE. </month>
Reference-contexts: In distributed debugging, the domain of search is the event history of executing processes, and queries can be expressed as patterns of communication behavior between these processes. In multimedia databases, data is often parsed according to a simple grammar. In the case of a video database of CNN newsclips <ref> [30] </ref>, clips are organized into higher level syntactic entities like stories, episodes, and so on. For the purposes of querying, the video database can be likened to a syntax tree of clips, stories, and episodes, and pattern matching techniques similar to SCRUPLE can be applied.

References-found: 30

