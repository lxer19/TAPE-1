URL: http://www.cs.cmu.edu/afs/cs/user/birkedal/pub/tacs97.ps.gz
Refering-URL: http://www.cs.cmu.edu/afs/cs/user/birkedal/www/papers.html
Root-URL: 
Email: birkedal@cs.cmu.edu and rwh@cs.cmu.edu  
Title: Relational Interpretations of Recursive Types in an Operational Setting (Summary)  
Author: Lars Birkedal and Robert Harper 
Affiliation: School of Computer Science, Carnegie Mellon University  
Abstract: Relational interpretations of type systems are a useful tool for establishing properties of programming languages. For languages with recursive types the existence of a relational interpretation is often difficult to establish. The most well-known approach is to pass to a domain-theoretic model of the language, using the structure of the domain to define a suitable system of relations. Here we study the construction of relational interpretations for an ML-like language with recursive functions and recursive types in a purely operational setting. The construction is an adaptation of results of Pitts on relational properties of domains to an operational setting, making use of techniques introduced by Mason, Smith, and Talcott for proving operational equivalence of expressions. To illustrate the method we give a relational proof of correctness of the continuation-passing transformation used in some compilers for functional languages.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Martn Abadi, Luca Cardelli, Benjamin Pierce, and Gordon Plotkin. </author> <title> Dynamic typing in a statically typed language. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2) </volume> <pages> 237-268, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: The method of establishing the minimal invariant property given here is based on the work of Mason, Smith, and Talcott [15]. (See also Abadi, et. al. <ref> [1] </ref>.) Specifically, we define a family of typed finitary projection operations corresponding to the projections in a domain model of the language, and prove that the "infini-tary" projection operation on the recursive type is the identity up to operational equivalence.
Reference: 2. <author> Lars Birkedal and Robert Harper. </author> <title> Relational interpretations of recursive types in an operational setting. </title> <type> Unpublished manuscript. </type>
Reference-contexts: The constructed relations can be seen to provide a notion of equality of terms | and will therefore be called "relations for equality" | and can in fact be used to reason about contextual equivalence <ref> [2] </ref>. However, we will not pursue that direction in this extended abstract. Instead we shall view these two sections as providing the necessary understanding for constructing a relational interpretation, which we then use to show the correctness of cps transformation in Section 6.
Reference: 3. <author> William Clinger and Jonathan Rees. </author> <title> Revised 4 report on the algorithmic language Scheme. LISP Pointers, </title> <address> IV(3):1-55, July-Sep. </address> <year> 1991. </year>
Reference: 4. <author> Bruce Duba, Robert Harper, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <booktitle> In Eighteenth ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1991. </year>
Reference: 5. <author> Andrzej Filinski. </author> <title> Controlling Effects. </title> <institution> CMU-CS-96-119, School of Computer Science, Carnegie Mellon University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Both of these extensions are important directions for further research. The treatment of cps conversion given here invites generalization to an arbitrary syntactically-definable monad for the language. Filinski's dissertation <ref> [5] </ref> is a first step towards a general theory of representation of computational effects. Filinski's work suggests that one could give a fairly general correctness proof along the lines suggested here for a wide variety of definable effects.
Reference: 6. <author> Michael J. Fischer. </author> <title> Lambda-calculus schemata. </title> <journal> LISP and Symbolic Computation, </journal> 6(3/4):259-288, November 1993. 
Reference: 7. <author> Peter Freyd. </author> <title> Algebraically complete categories. </title> <editor> In A. Carboni, M. C. Pedicchio, and G. Rosolini, editors, </editor> <booktitle> Category Theory. Proceedings, Como 1990, volume 1488 of Lecture Notes in Mathematics, </booktitle> <pages> pages 95-104. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference: 8. <author> Peter Freyd. </author> <title> Recursive types reduced to inductive types. </title> <booktitle> In Proceedings of the fifth IEEE Conference on Logic in Computer Science, </booktitle> <pages> pages 498-507, </pages> <year> 1990. </year>
Reference: 9. <author> Peter Freyd. </author> <title> Remarks on algebraically compact categories. </title> <editor> In M. P. Fourman, P.T. Johnstone, and A. M. Pitts, editors, </editor> <booktitle> Applications of Categories in Computer Science. Proceedings of the LMS Symposium, Durham 1991, volume 177 of London Mathematical Society Lecture Note Series, </booktitle> <pages> pages 95-106. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference: 10. <author> Jean-Yves Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieure. </title> <type> PhD thesis, </type> <institution> Universite Paris VII, </institution> <year> 1972. </year>
Reference-contexts: The construction of relational interpretations of type systems often raises interesting technical problems. For example, Girard's proof of strong normalization for the second-order -calculus <ref> [10] </ref> may be understood as a relational interpretation for a type system with impredicative type quantification. In this paper we are concerned with the construction of relational interpretations for an ML-like language L with recursive functions and one recursive type.
Reference: 11. <author> Carl A. Gunter. </author> <title> Semantics of Programming Languages. Structures and Techniques. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: This is opposed to introducing new labelled expressions and new notions of reduction for labelled expressions as, e.g., done by Gunter <ref> [11] </ref>. We will only consider contexts involving parameters of type t 1 * t 2 . We write Cfpg for such a context whose parameters are included in the list p.
Reference: 12. <author> Robert Harper, Bruce Duba, and David MacQueen. </author> <title> Typing first-class continuations in ML. </title> <journal> Journal of Functional Programming, </journal> <volume> 3(4) </volume> <pages> 465-484, </pages> <month> October </month> <year> 1993. </year>
Reference: 13. <author> D. J. Howe. </author> <title> Equality in lazy computation systems. </title> <booktitle> In 4th Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 198-203. </pages> <publisher> IEEE Computer Society Press, </publisher> <address> Washington, </address> <year> 1989. </year>
Reference-contexts: It turns out that for the language considered here experimental equivalence coincides with contextual equivalence (in the sense of Morris [20] and Plotkin [24]) and with bisimulation equivalence (in the sense of Howe <ref> [13] </ref> and Pitts [21]). So the choice of relation is a matter of technique, rather than of semantics. It would be interesting to see whether the characterization of operational equivalence as a bisimulation might lead to a more concise or insightful proof of minimal invariance.
Reference: 14. <author> Stren Lassen. </author> <title> Relational reasoning about contexts. </title> <type> Unpublished manuscript. </type>
Reference-contexts: Mason, Smith, and Talcott work with an untyped language that includes primitive "run-time type checking" operations such as testing whether or not a value represents a function. (Lassen considers a similar language for which a minimal invariant property is established <ref> [14] </ref>.) The account given here generalizes their work to the case of a typed language with a recursive type. Their run-time type checking primitives emerge as compositions of recursive unrolling and simple case analyses derived from the description of their untyped value space as a recursive type equation.
Reference: 15. <author> Ian A. Mason, Scott F. Smith, and Carolyn L. Talcott. </author> <title> From operational semantics to domain theory. </title> <journal> Information and Computation, </journal> <note> 1995. To Appear. </note>
Reference-contexts: The choice of operational equivalence is guided by the requirements of the proof. Candidates for operational equivalence include contextual equivalence [20,23] (coincidence of evaluation in all program contexts), bisimilarity [13,21] (existence of a correspondence between evaluation steps), and experimental equivalence <ref> [15] </ref> (coincidence of closed instances in all evaluation contexts). It turns out that all three notions coincide for the language L, so our decision to work with experimental equivalence is entirely pragmatic | it supported a relatively straightforward proof of the critical minimal invariant property for L. <p> Then in Section 3 we define the notion of operational equivalence, with which we shall be working in the remainder of the paper. The main result of this section is the proof of syntactic minimal invariance based on a technique introduced by Mason, Talcott, and Smith <ref> [15] </ref>. In Section 4 we define a universe of admissible relations over operational equivalence classes of closed expressions. We also define relational operators corresponding to the type constructors of the language and show that they preserve admissibility. <p> This theorem (Theorem 31) is remi niscent of the CIU Theorem of Mason, Smith and Talcott <ref> [15] </ref>. Definition 30 (Contextual Approximation and Equivalence). <p> As explained by Mason, Smith, and Talcott <ref> [15] </ref> arbitrary chains of terms do not always have a least upper bound. This leads Mason, Smith, and Talcott to develop a notion of ordering between sets of terms, for which arbitrary chains do have a least upper bound, [15, Lemma 4.31]. <p> As explained by Mason, Smith, and Talcott [15] arbitrary chains of terms do not always have a least upper bound. This leads Mason, Smith, and Talcott to develop a notion of ordering between sets of terms, for which arbitrary chains do have a least upper bound, <ref> [15, Lemma 4.31] </ref>. Here, however, we shall only ever consider chains of the form CfF 0 g CfF 1 g CfF 2 g for some given closed fix-term F and thus the chains, which we shall consider, will always have a least upper bound. <p> Hence we do not need to develop more complicated notions of approximation a la the set ordering developed by Mason, Smith, and Talcott <ref> [15] </ref>. 3.2 Syntactic Projections In this section we introduce syntactic projection terms which are the syntactic counterpart of the semantic projection functions known from domain theory. These syntactic projections will be used in the construction of the desired relations in Section 5. Let be a variable. <p> We shall employ an idea of Mason, Smith, and Talcott <ref> [15] </ref>. We first establish the idempotency of 1 t and 1 . We proceed by establish ing lemmas for i t and i and then use compactness of evaluation to get the desired results. Lemma 43. <p> The method of establishing the minimal invariant property given here is based on the work of Mason, Smith, and Talcott <ref> [15] </ref>. (See also Abadi, et. al. [1].) Specifically, we define a family of typed finitary projection operations corresponding to the projections in a domain model of the language, and prove that the "infini-tary" projection operation on the recursive type is the identity up to operational equivalence.
Reference: 16. <author> Albert R. Meyer and Mitchell Wand. </author> <title> Continuation semantics in typed lambda calculi (summary). </title> <editor> In Rohit Parikh, editor, </editor> <booktitle> Logics of Programs, volume 193 of Lecture Notes in Computer Science, </booktitle> <pages> pages 219-224. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The target language, L fl , is the variant of L obtained by replacing the single recursive type by another recursive type fl obtained from by a transformation on types similar to that given by Meyer and Wand <ref> [16] </ref>. We let Type denote the set of type expressions of L , that is Type = Type. The set of target type expressions, denoted Type fl , is defined exactly as Type, but with fl for . <p> Reynolds [25] gives a proof for an untyped language that relies on the construction of a system of relations over a domain model of the language. The construction is based directly on the inverse limit construction of the domain model itself. Meyer and Wand <ref> [16] </ref> give a proof for the simply-typed -calculus without recursive functions or recursive types. Their argument also relies on a relational interpretation of types over a model of the language. 8 Conclusion We have outlined a method for constructing relational interpretations of recursive types in an operational setting.
Reference: 17. <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In this paper we are concerned with the construction of relational interpretations for an ML-like language L with recursive functions and one recursive type. The operational semantics of the language specifies an "eager" or "call-by-value" evaluation strategy, as in Standard ML <ref> [17] </ref>. We make no restrictions on the occurrence of the recursively-defined type in its definition | both positive and negative occurrences are permitted. This complicates the construction of a relational interpretation of the language. ? Preprint of an article to appear in TACS '97.
Reference: 18. <author> John C. Mitchell. </author> <title> Type systems for programming languages. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. </volume> <editor> B, </editor> <title> Formal Models and Semantics, </title> <booktitle> chapter 8, </booktitle> <pages> pages 366-458. </pages> <publisher> Elsevier Science Publishers B.V., </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction The interpretation of types as relations is a fundamental technique in the study of type systems (see, for example, Mitchell's survey <ref> [18] </ref> and monograph [19] for examples and references to the literature). The general idea is to associate to each type a relation over a suitable value space in such a way that well-typed terms are related appropriately by the interpretation.
Reference: 19. <author> John C. Mitchell. </author> <booktitle> Foundations for Programming Languages. Foundations of Computing. </booktitle> <publisher> MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction The interpretation of types as relations is a fundamental technique in the study of type systems (see, for example, Mitchell's survey [18] and monograph <ref> [19] </ref> for examples and references to the literature). The general idea is to associate to each type a relation over a suitable value space in such a way that well-typed terms are related appropriately by the interpretation. The construction of relational interpretations of type systems often raises interesting technical problems.
Reference: 20. <author> James H. Morris. </author> <title> Lambda Calculus Models of Programming Languages. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <year> 1968. </year>
Reference-contexts: The choice of experimental equivalence as our notion of operational equivalence is entirely pragmatic | it facilitated a proof of the minimal invariant property. It turns out that for the language considered here experimental equivalence coincides with contextual equivalence (in the sense of Morris <ref> [20] </ref> and Plotkin [24]) and with bisimulation equivalence (in the sense of Howe [13] and Pitts [21]). So the choice of relation is a matter of technique, rather than of semantics.
Reference: 21. <author> Andrew M. Pitts. </author> <title> Operationally-based theories of program equivalence. </title> <booktitle> In In Proc. of Summer School on Semantics and Logics of Computation. </booktitle> <institution> ESPRIT CLiCS-II. University of Cambridge. Isaac Newton Institute for Mathematical Sciences., </institution> <month> September </month> <year> 1995. </year>
Reference-contexts: Finally, we show that to fill a context is a continous operation with respect to the approximation pre-order. We shall only be concerned with closed fix-terms, as this suffices for our purposes. Our development of compactness of evaluation follows the approach of Pitts <ref> [21, Section 5] </ref> quite closely but there are some technical differences due to the fact that we use a reduction semantics rather than a natural semantics as employed by Pitts. <p> It turns out that for the language considered here experimental equivalence coincides with contextual equivalence (in the sense of Morris [20] and Plotkin [24]) and with bisimulation equivalence (in the sense of Howe [13] and Pitts <ref> [21] </ref>). So the choice of relation is a matter of technique, rather than of semantics. It would be interesting to see whether the characterization of operational equivalence as a bisimulation might lead to a more concise or insightful proof of minimal invariance. <p> Finally, the relational interpretation of types given in Section 5 may be used to provide a "logical" characterization of operational equivalence. In his development of a theory of program equivalence for a lazy language with infinite streams <ref> [21] </ref> Pitts uses a characterization of operational equivalence at stream types that corresponds to the "logical" equivalence determined by the definition of streams as a recursive type. It would be interesting to work out a general account of logical equivalence and to re-consider some of Pitts's examples using it.
Reference: 22. <author> Andrew M. Pitts. </author> <title> Relational properties of domains. </title> <journal> Information and Computation, </journal> <volume> 127(2) </volume> <pages> 66-90, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Another disadvantage is that the interpretation is defined for a specific model, and it is not clear to what extent the result applies to other models of the language. The question of generality was recently addressed by Pitts <ref> [22] </ref>, who exploited Freyd's analysis of solutions of recursive domain equations [8,7,9] to construct relational interpretations over domain models of recursive types. <p> It turns out that all three notions coincide for the language L, so our decision to work with experimental equivalence is entirely pragmatic | it supported a relatively straightforward proof of the critical minimal invariant property for L. Relational interpretations of types have a number of applications. Pitts <ref> [22] </ref> uses relations to characterize the approximation relation in minimal domain models of FPC and to give a proof of adequacy of the denotational semantics for FPC in a minimal domain model relative to an operational semantics for it. <p> The 1 term corresponds to the least fixed point fix (ffi) of the continuous function ffi (e) = iF (e; e)i 1 in <ref> [22, Definition 3.2] </ref>. We shall show that 1 is experimen tally equivalent to the identity function (more precisly, the term x::x); this corresponds to the minimal invariant property in [22, Definition 3.2]. Example 35. Assume t = 1 + . <p> term corresponds to the least fixed point fix (ffi) of the continuous function ffi (e) = iF (e; e)i 1 in <ref> [22, Definition 3.2] </ref>. We shall show that 1 is experimen tally equivalent to the identity function (more precisly, the term x::x); this corresponds to the minimal invariant property in [22, Definition 3.2]. Example 35. Assume t = 1 + . Intuitively, our recursive type then corresponds to the type of natural numbers. <p> By Lemma 56, also jej 7! fl fl, as required. ut We are now in a position to establish the following theorem, which we refer to as the syntactic minimal invariant property by analogy to the domain-theoretic work of Pitts <ref> [22] </ref>. Theorem 58 (Syntactic Minimal Invariance). ` 1 x::x : * 4 Relations In this and the following section we shall show how to construct a relational interpretation of types over an operational semantics. <p> To interpret the different type constructors we, of course, make use of the corresponding relational constructors defined in the previous section. Our construction follows along the lines of Pitts <ref> [22] </ref>. Definition 69. <p> 2 N g a the cofinal set) and the facts that fixf (x:t 1 ):e + and fixf (x:t 1 fl ):e 0 +. ut This completes the construction of relations for CPS correctness. 7 Related Work Much of our work derives from Pitts's work on relational properties of domains <ref> [22] </ref>. Pitts's innovation was to observe that relational interpretations can be constructed based only on the minimal invariant property of a domain model.
Reference: 23. <author> Gordon Plotkin. </author> <title> Call-by-name, call-by-value, and the lambda calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 125-159, </pages> <year> 1975. </year>
Reference: 24. <author> Gordon Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5 </volume> <pages> 223-257, </pages> <year> 1977. </year>
Reference-contexts: The choice of experimental equivalence as our notion of operational equivalence is entirely pragmatic | it facilitated a proof of the minimal invariant property. It turns out that for the language considered here experimental equivalence coincides with contextual equivalence (in the sense of Morris [20] and Plotkin <ref> [24] </ref>) and with bisimulation equivalence (in the sense of Howe [13] and Pitts [21]). So the choice of relation is a matter of technique, rather than of semantics.
Reference: 25. <author> John C. Reynolds. </author> <title> On the relation between direct and continuation semantics. </title> <editor> In J. Loeckx, editor, </editor> <booktitle> Proceedings of the Second Colloquium on Automata, Languages and Programming, Saarbrucken, volume 174 of Lecture Notes in Computer Science, </booktitle> <pages> pages 141-156. </pages> <publisher> Springer-Verlag, </publisher> <year> 1974. </year>
Reference-contexts: In particular, we consider the correctness of the translation into continuation-passing style [6,23], called the cps transform. The proof relies on the construction of a relational interpretation of L that establishes a correspondence between the evaluation of a program and its continuation-passing transform. The result generalizes Reynolds's proof <ref> [25] </ref> of the relation between direct and continuation semantics for an untyped language to the case of a typed language with a recursive type (which could be taken to be the recursive type corresponding to the untyped -calculus). <p> Their run-time type checking primitives emerge as compositions of recursive unrolling and simple case analyses derived from the description of their untyped value space as a recursive type equation. Several proofs of correctness of the cps transformation have been given in the literature. Reynolds <ref> [25] </ref> gives a proof for an untyped language that relies on the construction of a system of relations over a domain model of the language. The construction is based directly on the inverse limit construction of the domain model itself.
References-found: 25

