URL: ftp://ftp.ics.hawaii.edu/pub/tr/ics-tr-94-12.ps.Z
Refering-URL: ftp://ftp.ics.hawaii.edu/pub/tr/INDEX.html
Root-URL: 
Email: corbett@hawaii.edu  avrunin@math.umass.edu  
Title: Towards Scalable Compositional Analysis  
Author: James C. Corbett George S. Avrunin 
Address: Honolulu, HI 96822  Amherst, MA 01003-4515  
Affiliation: Department of Information and Computer Science University of Hawaii at Manoa  Department of Mathematics and Statistics University of Massachusetts at Amherst  
Abstract: Due to the state explosion problem, analysis of large concurrent programs will undoubtedly require compositional techniques. Existing compositional techniques are based on the idea of replacing complex subsystems with simpler processes with the same interfaces to their environments, and using the simpler processes to analyze the full system. Most algorithms for proving equivalence between two processes, however, require enumerating the states of both processes. When part of a concurrent system consists of many highly coupled processes, it may not be possible to decompose the system into components that are both small enough to enumerate and have simple interfaces with their environments. In such cases, analysis of the systems by standard methods will be infeasible. In this paper, we describe a technique for proving trace equivalence of deterministic and divergence-free systems without enumerating their states. (For deterministic systems, essentially all the standard notions of process equivalence collapse to trace equivalence, so this technique also establishes failures equivalence, observational equivalence, etc.) Our approach is to generate necessary conditions for the existence of a trace of one system that is not a trace of the other; if the necessary conditions cannot be satisfied the systems are equivalent. We have implemented the technique and used it to establish the equivalence of some systems with state spaces too large for enumeration to be practical. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. S. Avrunin, U. A. Buy, and J. C. Corbett. </author> <title> Integer programming in the analysis of concurrent systems. </title> <editor> In K. G. Larsen and A. Skou, editors, </editor> <booktitle> Computer Aided Verification, 3rd International Workshop Proceedings, volume 575 of Lecture Notes in Computer Science, </booktitle> <pages> pages 92-102, </pages> <address> Aalborg, Denmark, July 1991. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: If these conditions cannot be satisfied, we may conclude that the equivalence holds. The necessary conditions are similar to those used in the constrained expression method for concurrent systems analysis <ref> [1, 2] </ref>. The use of necessary conditions results in a conservative analysis: the technique will never report that inequivalent processes are equivalent, but it may sometimes be unable to verify an equivalence that does hold. Our technique is currently restricted to processes that are deterministic and divergence-free. <p> refers to the states and transitions of the component processes S 1 ; : : : ; S m and I 1 ; : : : ; I n . 3.1 Basic Inequality Necessary Condition Approach To generate the necessary conditions, we adapt the basic integer programming technique described in <ref> [1, 2] </ref>. Given a set of communicating processes, that technique uses necessary conditions, in the form of linear inequalities, to either help find a trace with certain properties or prove that no such trace could exist. <p> It is easy to see that this system of inequalities has no integral solutions, establishing that no such trace exists. More detailed descriptions of this technique can be found in <ref> [1, 2] </ref>, along with the results of some experiments applying it to analyze various concurrent systems.
Reference: [2] <author> G. S. Avrunin, U. A. Buy, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: If these conditions cannot be satisfied, we may conclude that the equivalence holds. The necessary conditions are similar to those used in the constrained expression method for concurrent systems analysis <ref> [1, 2] </ref>. The use of necessary conditions results in a conservative analysis: the technique will never report that inequivalent processes are equivalent, but it may sometimes be unable to verify an equivalence that does hold. Our technique is currently restricted to processes that are deterministic and divergence-free. <p> refers to the states and transitions of the component processes S 1 ; : : : ; S m and I 1 ; : : : ; I n . 3.1 Basic Inequality Necessary Condition Approach To generate the necessary conditions, we adapt the basic integer programming technique described in <ref> [1, 2] </ref>. Given a set of communicating processes, that technique uses necessary conditions, in the form of linear inequalities, to either help find a trace with certain properties or prove that no such trace could exist. <p> It is easy to see that this system of inequalities has no integral solutions, establishing that no such trace exists. More detailed descriptions of this technique can be found in <ref> [1, 2] </ref>, along with the results of some experiments applying it to analyze various concurrent systems. <p> We then, however, apply integer linear programming (ILP), which is an NP-hard problem for which we use an exponential-time decision procedure. Despite the complexity of ILP, our experience with these kinds of inequality systems <ref> [2] </ref> suggests that they are easier to solve than the general case, probably because a large part of the systems are network flow equations (pure network flow systems can be solved in polynomial time). <p> Here, we describe experiments on two scalable examples. To conduct these experiments, we modified the Inequality Necessary Condition Analyzer (INCA), an analysis tool for concurrent and real-time systems that is descended from the constrained expression toolset <ref> [2] </ref>. INCA takes as input a set of specification and implementation tasks specified in an Ada-like design language. The tool translates the tasks into FSAs and then produces an inequality system using the algorithm in Figure 2.
Reference: [3] <author> G. S. Avrunin, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated derivation of time bounds in uniprocessor concurrent systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <note> to appear. Available for anonymous ftp on ext.math.umass.edu. </note>
Reference-contexts: More detailed descriptions of this technique can be found in [1, 2], along with the results of some experiments applying it to analyze various concurrent systems. The technique has been extended to verify general safety and liveness properties [8, 10] and timing properties <ref> [3, 9] </ref>. 3.2 Necessary Conditions for the Existence of a Bad Pair Using this basic technique, we generate the necessary conditions for the existence of a bad pair as follows (see Figure 2 for a more formal presentation).
Reference: [4] <author> A. Bouli and R. de Simone. </author> <title> Symbolic bisimulation min-imisation. </title> <booktitle> In v. Bochmann and Probst [17], </booktitle> <pages> pages 96-108. </pages>
Reference-contexts: The only other non-enumerative equivalence techniques we know of use Ordered Binary Decision Diagrams (OBDDs) to represent the states. Examples of this work are <ref> [4] </ref> and [12]. The successful application of OBDD-based methods depends heavily on finding a good ordering for the state variables. While some heuristics exist, especially for models of certain digital circuits, the successful application of these methods to concurrent software systems with highly coupled tasks remains extremely problematic.
Reference: [5] <author> S. C. Cheung and J. Kramer. </author> <title> Enhancing compositional reachability analysis with context constraints. </title> <editor> In D. Notkin, editor, </editor> <booktitle> Proceedings of the First ACM SIG-SOFT Symposium on the Foundations of Software Engineering, </booktitle> <month> Dec. </month> <year> 1993. </year> <note> Appeared as ACM Software Engineering Notes, volume 18, </note> <month> December </month> <year> 1993. </year>
Reference-contexts: Analysis of very large programs will undoubtedly require compositional techniques, which exploit the modularity of the program to reduce the complexity of the analysis. Several techniques for compositional reachability analysis have already been proposed (e.g., <ref> [5, 6, 19] </ref>). The basic strategy of these techniques is to divide a large system into smaller subsystems, verify each subsystem, and then combine the results of these analyses to verify the full system.
Reference: [6] <author> E. Clarke, D. Long, and K. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In Proceedings of the Fourth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 353-362, </pages> <year> 1989. </year>
Reference-contexts: Analysis of very large programs will undoubtedly require compositional techniques, which exploit the modularity of the program to reduce the complexity of the analysis. Several techniques for compositional reachability analysis have already been proposed (e.g., <ref> [5, 6, 19] </ref>). The basic strategy of these techniques is to divide a large system into smaller subsystems, verify each subsystem, and then combine the results of these analyses to verify the full system.
Reference: [7] <author> R. Cleaveland, J. Parrow, and B. Steffen. </author> <title> The Concur-rency Workbench: A semantics based tool for the verification of concurrent systems. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 15(1) </volume> <pages> 36-72, </pages> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: In any case, most existing algorithms for testing equivalences <ref> [7, 13] </ref> must enumerate the states of both processes. Existing enumeration-based tools are limited to systems having about 10 6 states. In this paper, we consider the eventual application of compositional techniques to very large and complex programs.
Reference: [8] <author> J. C. Corbett. </author> <title> Verifying general safety and liveness properties with integer programming. </title> <booktitle> In v. Bochmann and Probst [17], </booktitle> <pages> pages 357-369. </pages>
Reference-contexts: More detailed descriptions of this technique can be found in [1, 2], along with the results of some experiments applying it to analyze various concurrent systems. The technique has been extended to verify general safety and liveness properties <ref> [8, 10] </ref> and timing properties [3, 9]. 3.2 Necessary Conditions for the Existence of a Bad Pair Using this basic technique, we generate the necessary conditions for the existence of a bad pair as follows (see Figure 2 for a more formal presentation). <p> Our method only applies, then, in the case in which both S and I are divergence-free (note that the component processes I 1 ; : : : ; I n and S 1 ; : : : ; S m need not be divergence-free). The techniques of <ref> [8] </ref> can be used to prove that S and I are divergence free without enumerating their states. Theorem If S and I are divergence-free and the inequality system generated by the algorithm in Figure 2 has no integral solutions, no bad pair exists for S and I . <p> In our experience with these conditions, we have found that they are strong enough to verify equivalences of interesting systems, although a much more extensive empirical investigation would be necessary to characterize their applicability in general. In addition, we note that the technique of <ref> [8] </ref> can be used to eliminate some spurious solutions. That technique involves splitting the trace into segments, using the basic technique to generate an inequality system for each segment, and then connecting the inequality systems together to form necessary conditions for the entire trace.
Reference: [9] <author> J. C. Corbett and G. S. Avrunin. </author> <title> A practical method for bounding the time between events in concurrent real-time systems. </title> <editor> In T. Ostrand and E. Weyuker, editors, </editor> <booktitle> Proceedings of the 1993 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 110-116, </pages> <address> Cambridge, MA, </address> <month> June </month> <year> 1993. </year> <note> ACM Press (Proceedings appeared in Software Engineering Notes, 18(3)). An updated version is available for anonymous ftp on ext.math.umass.edu. </note>
Reference-contexts: More detailed descriptions of this technique can be found in [1, 2], along with the results of some experiments applying it to analyze various concurrent systems. The technique has been extended to verify general safety and liveness properties [8, 10] and timing properties <ref> [3, 9] </ref>. 3.2 Necessary Conditions for the Existence of a Bad Pair Using this basic technique, we generate the necessary conditions for the existence of a bad pair as follows (see Figure 2 for a more formal presentation).
Reference: [10] <author> J. C. Corbett and G. S. Avrunin. </author> <title> Using integer programming to verify general safety and liveness properties. Formal Methods in System Design, </title> <note> to appear. </note>
Reference-contexts: More detailed descriptions of this technique can be found in [1, 2], along with the results of some experiments applying it to analyze various concurrent systems. The technique has been extended to verify general safety and liveness properties <ref> [8, 10] </ref> and timing properties [3, 9]. 3.2 Necessary Conditions for the Existence of a Bad Pair Using this basic technique, we generate the necessary conditions for the existence of a bad pair as follows (see Figure 2 for a more formal presentation).
Reference: [11] <editor> C. Courcoubetis, editor. </editor> <booktitle> Computer Aided Verification, 5th International Conference, volume 697 of Lecture Notes in Computer Science, </booktitle> <address> Elounda, Greece, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference: [12] <author> J. C. Fernandez, A. Kerbrat, and L. Mounier. </author> <title> Symbolic equivalence checking. </title> <booktitle> In Courcoubetis [11], </booktitle> <pages> pages 85-96. </pages>
Reference-contexts: The only other non-enumerative equivalence techniques we know of use Ordered Binary Decision Diagrams (OBDDs) to represent the states. Examples of this work are [4] and <ref> [12] </ref>. The successful application of OBDD-based methods depends heavily on finding a good ordering for the state variables. While some heuristics exist, especially for models of certain digital circuits, the successful application of these methods to concurrent software systems with highly coupled tasks remains extremely problematic.
Reference: [13] <author> P. C. Kanellakis and S. A. Smolka. </author> <title> CCS expressions, finite state processes, and three problems of equivalence. </title> <journal> Information and Computation, </journal> <volume> 86 </volume> <pages> 43-68, </pages> <year> 1990. </year>
Reference-contexts: In any case, most existing algorithms for testing equivalences <ref> [7, 13] </ref> must enumerate the states of both processes. Existing enumeration-based tools are limited to systems having about 10 6 states. In this paper, we consider the eventual application of compositional techniques to very large and complex programs.
Reference: [14] <author> D. May and P. Thompson. </author> <title> Transputers and routers: Components for concurrent machines. </title> <editor> In T. L. Kunii and D. May, editors, </editor> <booktitle> Proceedings of the Third Trans-puter/Occam International Conference, </booktitle> <address> Tokyo, May 1990. </address> <publisher> IOS Press. </publisher>
Reference-contexts: The two rows for each size represent the analyses for conditions (i) and (ii) of Definition 4, respectively. The second example is adapted from a real world problem reported in <ref> [14] </ref> and recently studied in the concurrency and distribution track of the Sixth International Workshop on Software Specification and Design. This router problem models a communication network with M input ports, each connected to a sender, and N output ports, each connected to a receiver.
Reference: [15] <author> B. A. Murtagh and M. A. Saunders. </author> <note> MINOS 5.4 user's guide (preliminary). Systems Optimization Laboratory Technical Report 83-20R, </note> <institution> Stanford University, </institution> <year> 1993. </year> <month> Revised March </month> <year> 1993. </year>
Reference-contexts: The tool translates the tasks into FSAs and then produces an inequality system using the algorithm in Figure 2. The inequality system is solved using an integer linear programming tool based on the MINOS optimization package <ref> [15] </ref> and INCA then interprets the solution, if any. All times we report are in CPU seconds on a SPARCstation 10 Model 41 with 64MB of memory and include both user and system time. The first example is a scaled version of the compositional buffer example shown in Figure 3.
Reference: [16] <author> L. Osterweil and L. Clarke. </author> <title> A proposed testing and analysis research initiative. </title> <journal> IEEE Software, </journal> <pages> pages 89-96, </pages> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Concurrent software is notoriously difficult to design and debug. Since such software is increasingly a part of safety critical systems, methods and tools for assuring its reliability are badly needed <ref> [16] </ref>. One of the most error-prone aspects of a concurrent system is the design of the communication protocol used by its cooperating agents. Fortunately, formal methods exist for aiding developers with the design and verification of communication protocols.
Reference: [17] <editor> G. v. Bochmann and D. K. Probst, editors. </editor> <booktitle> Computer Aided Verification, 4th International Workshop, volume 663 of Lecture Notes in Computer Science, </booktitle> <address> Montreal, Canada, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference: [18] <author> A. Valmari. </author> <title> On-the-fly verification with stubborn sets. </title> <booktitle> In Courcoubetis [11], </booktitle> <pages> pages 397-408. </pages>
Reference-contexts: When processes are composed, some of their actions cease to be interesting from an external point of view. In most process algebras, such actions are hidden by a special operator that renames them to a special invisible action t . Here, we take the approach of Valmari <ref> [18] </ref> and specify a set vis of visible actions (unmatched communications). Only the visible actions of a process are considered when proving equivalence. <p> In our technique, we do not construct P but work from its components P 1 ; : : : ; P n , and therefore need to distinguish between com and int . The following definitions are adapted from <ref> [18] </ref>.
Reference: [19] <author> W. J. Yeh and M. Young. </author> <title> Compositional reachabil-ity analysis using process algebra. </title> <booktitle> In Proceedings of the Symposium on Testing, Analysis, and Verification (TAV4), </booktitle> <pages> pages 178-187, </pages> <address> New York, </address> <month> Oct. </month> <year> 1991. </year> <journal> ACM SIGSOFT, Association for Computing Machinery. </journal> <volume> 9 </volume>
Reference-contexts: Analysis of very large programs will undoubtedly require compositional techniques, which exploit the modularity of the program to reduce the complexity of the analysis. Several techniques for compositional reachability analysis have already been proposed (e.g., <ref> [5, 6, 19] </ref>). The basic strategy of these techniques is to divide a large system into smaller subsystems, verify each subsystem, and then combine the results of these analyses to verify the full system.
References-found: 19

