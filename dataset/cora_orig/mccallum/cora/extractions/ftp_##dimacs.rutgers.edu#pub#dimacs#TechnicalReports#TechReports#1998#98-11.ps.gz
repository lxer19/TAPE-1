URL: ftp://dimacs.rutgers.edu/pub/dimacs/TechnicalReports/TechReports/1998/98-11.ps.gz
Refering-URL: http://dimacs.rutgers.edu/TechnicalReports/1998.html
Root-URL: http://www.cs.rutgers.edu
Title: Generalized Fibonacci Trees in Unequal Costs Coding Problems  
Author: by Julia Abrahams 
Address: 96 Frelinghuysen Rd. Piscataway, NJ 08854-8018  
Affiliation: Rutgers University  
Note: Nonexhaustive  DIMACS is a partnership of Rutgers University, Princeton University, AT&T Labs-Research, Bell Labs and Bellcore. DIMACS is an NSF Science and Technology Center, funded under contract STC-91-19999; and also receives support from the New Jersey Commission on Science and Technology.  
Pubnum: DIMACS  
Abstract: DIMACS Technical Report 98-11 February 1998 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Abrahams, </author> <title> "Varn codes and generalized Fibonacci trees", </title> <journal> Fibonacci Quart., </journal> <volume> 33, </volume> <year> (1995): </year> <pages> 21-25. </pages>
Reference-contexts: 1. INTRODUCTION AND BACKGROUND Fibonacci trees and exhaustive generalized Fibonacci trees have been introduced and studied in connection with a particular unequal costs coding application by Horibe [6], Chang [2], and the author <ref> [1] </ref>. <p> For r = 2, c (1) = 1, c (2) = 2, these trees are Horibe's Fibonacci trees [6]. The exhaustive generalized Fibonacci trees when interpreted as code trees solve Varn's [10] unequal costs coding problem under the requirement that the code trees be exhaustive <ref> [1] </ref>. In particular, each of the c (i), now interpreted as the cost of the corresponding code symbol, is associated with one of the r code symbols which label the code tree branches successively in left to right order. <p> In the binary case, all code trees are exhaustive, and the exhaustive case for all r has been treated previously by the author <ref> [1] </ref>. The nonexhaustive approach reduces to the exhaustive approach for binary problems. We can permit r to be arbitrarily large and thus include the case of r infinite in the limit although the limiting case will never be achieved. <p> The kth exhaustive generalized Fibonacci tree S (k) is also obtained in <ref> [1] </ref> by using the concept of leaf node "types", essentially a mechanism for keeping track of the relative cost of each leaf node until it is the lowest cost leaf node and the next one to split in Varn's exhaustive algorithm.
Reference: [2] <author> D. K. Chang, </author> <title> "On Fibonacci k-ary trees", </title> <journal> Fibonacci Quart., </journal> <volume> 24, </volume> <year> (1986): </year> <pages> 258-262. </pages>
Reference-contexts: 1. INTRODUCTION AND BACKGROUND Fibonacci trees and exhaustive generalized Fibonacci trees have been introduced and studied in connection with a particular unequal costs coding application by Horibe [6], Chang <ref> [2] </ref>, and the author [1].
Reference: [3] <author> S.-N. Choi and M.J. Golin. </author> <title> "Lopsided trees: analyses, algorithms, and applications (extended abstract)", </title> <institution> Hong Kong University of Science and Technology Computer Sci. Dept. </institution> <note> Preprint (1994). </note>
Reference-contexts: The nonexhaustive algorithms for the minimum average cost trees of Varn [10], Perl et al. [8], Cot [4], Golin and Young [5], and Choi and Golin <ref> [3] </ref> are all rather complicated. Perl, Garey, and Even's [8] algorithm for the minimax tree is simpler than any of the minimum average cost algorithms. A new leaf node can be added to a tree by either "branching" or "adding".
Reference: [4] <author> N. Cot, </author> <title> "Characterization and Design of Optimal Prefix Codes", </title> <institution> Stanford Electrical Eng. Dept. </institution> <type> Thesis, </type> <year> (1977). </year>
Reference-contexts: Clearly the resulting tree is also a minimax exhaustive tree because splitting any other node besides the least cost node will create a leaf node of greater cost. The nonexhaustive algorithms for the minimum average cost trees of Varn [10], Perl et al. [8], Cot <ref> [4] </ref>, Golin and Young [5], and Choi and Golin [3] are all rather complicated. Perl, Garey, and Even's [8] algorithm for the minimax tree is simpler than any of the minimum average cost algorithms. A new leaf node can be added to a tree by either "branching" or "adding". <p> For example, consider costs c (1) = c (2) = 2; c (3) = 5, as in <ref> [4] </ref>, and compare ((4+4)+(4+4)), the minimax tree of maximum codeword cost 4 but average cost 16/4 which is obtained by deleting 3 highest cost leaf nodes from the exhaustive generalized Fibonacci tree ((4+4+7)+(4+4+7)+5), with ((4+4)+2+5), the minimum average cost tree of maximum codeword cost 5 but average cost 15/4 which is
Reference: [5] <author> M.J. Golin and N. Young, </author> <title> "Prefix codes: equiprobable words, unequal letter costs", </title> <journal> SIAM J. Comput., </journal> <volume> 25, </volume> <year> (1996): </year> <pages> 1281-1292. </pages>
Reference-contexts: Clearly the resulting tree is also a minimax exhaustive tree because splitting any other node besides the least cost node will create a leaf node of greater cost. The nonexhaustive algorithms for the minimum average cost trees of Varn [10], Perl et al. [8], Cot [4], Golin and Young <ref> [5] </ref>, and Choi and Golin [3] are all rather complicated. Perl, Garey, and Even's [8] algorithm for the minimax tree is simpler than any of the minimum average cost algorithms. A new leaf node can be added to a tree by either "branching" or "adding". <p> The example c (1) = c (2) = 2; c (3) = 5, as in <ref> [5] </ref>, satisfies the sufficient conditions (1) or (2) however not the comparison conditions even for small N . The tree ((4+4)+2+5) is minimum average cost but ((4+4)+(4+4)) is minimax.
Reference: [6] <author> Y. Horibe, </author> <title> "Notes on Fibonacci trees and their optimality", </title> <journal> Fibonacci Quart., </journal> <volume> 21, </volume> <year> (1983): </year> <note> 118- 128. </note>
Reference-contexts: 1. INTRODUCTION AND BACKGROUND Fibonacci trees and exhaustive generalized Fibonacci trees have been introduced and studied in connection with a particular unequal costs coding application by Horibe <ref> [6] </ref>, Chang [2], and the author [1]. <p> The term "exhaustive" indicates that each internal node of the r-ary tree has exactly r descendants. For r = 2, c (1) = 1, c (2) = 2, these trees are Horibe's Fibonacci trees <ref> [6] </ref>. The exhaustive generalized Fibonacci trees when interpreted as code trees solve Varn's [10] unequal costs coding problem under the requirement that the code trees be exhaustive [1]. <p> The equivalence between the recursive construction and the construction by the method of types, as well as the fact that the type associated with a leaf node in S (k c (i)) is unchanged in S (k), was proved by Horibe <ref> [6] </ref> for r = 2; c (1) = 1; c (2) = 2, and the argument goes through to the general case straightforwardly.
Reference: [7] <author> Y.N. Patt, </author> <title> "Variable length tree structures having minimum average search time", </title> <journal> Comm. ACM, </journal> <volume> 12, </volume> <year> (1969): </year> <pages> 72-76. </pages>
Reference-contexts: A number of authors in addition to Varn have addressed the nonexhaustive unequal costs coding problem for equiprobable source symbols from the algorithmic point of view for general sets of costs [3,4,5,8] or for specific cost assignments <ref> [7] </ref> or have obtained bounds on the resulting minimum average cost [9]. The term "nonexhaustive" indicates that each internal node of the tree has at least 2 and at most r descendants. <p> This is the case for Ex. b, and the nonexhaustive minimax trees of Table 2 are the same as the nonexhaustive minimum average cost trees of [10] for the same, small, alphabet sizes. It is also the case for Patt's <ref> [7] </ref> costs, c (i) = i, i = 1; 2; :::, when N is an integer power of 2, and his paper includes the recursive tree sequence structure.
Reference: [8] <author> Y. Perl, M. R. Garey, and S. </author> <title> Even, "Efficient generation of optimal prefix code: equiprobable words using unequal cost letters", </title> <journal> JACM, </journal> <volume> 22, </volume> <year> (1975): </year> <pages> 202-214. </pages>
Reference-contexts: It is not hard to see that in the exhaustive case, Varn's algorithm finds optimum code trees in both senses, that is, the minimum average codeword cost tree is also the minimax tree. But this is not the case for nonexhaustive codes. Perl et al. <ref> [8] </ref> give a simple algorithm for the minimax problem as a "remark" in their paper otherwise concerned with the minimum average codeword cost case. So, as we'll see, it is the minimax version of Varn's problem which has the Fibonacci-like structure. <p> Clearly the resulting tree is also a minimax exhaustive tree because splitting any other node besides the least cost node will create a leaf node of greater cost. The nonexhaustive algorithms for the minimum average cost trees of Varn [10], Perl et al. <ref> [8] </ref>, Cot [4], Golin and Young [5], and Choi and Golin [3] are all rather complicated. Perl, Garey, and Even's [8] algorithm for the minimax tree is simpler than any of the minimum average cost algorithms. <p> The nonexhaustive algorithms for the minimum average cost trees of Varn [10], Perl et al. <ref> [8] </ref>, Cot [4], Golin and Young [5], and Choi and Golin [3] are all rather complicated. Perl, Garey, and Even's [8] algorithm for the minimax tree is simpler than any of the minimum average cost algorithms. A new leaf node can be added to a tree by either "branching" or "adding". <p> Note that leaf nodes of type of greatest index are the highest cost leaf nodes. In the demonstration, rather than use Perl, Garey, and Even's optimal minimax algorithm <ref> [8] </ref>, we'll use a new optimal minimax algorithm which is in the same spirit as Varn's original algorithm [10] for optimality in the sense of minimum average cost. The algorithm will follow from Theorem 2, and is contained in the corollary to Theorem 2. <p> Proof of Theorem 4: The proof is an immediate consequence of Theorems 1 and 3. 2 Under certain conditions, minimax code trees are also minimum average cost code trees. The algorithm of Perl et al. <ref> [8] </ref> for minimum average cost trees involves two stages, extension and mending, and their algorithm for minimax trees is a variant of the extension stage. <p> A sufficient condition on the code symbol costs for the mending stage to be unnecessary in the minimum average cost problem is that any of the following three (in)equalities holds <ref> [8] </ref>: (1) r 3; (2) c (1) + c (2) c (3); (3) c (3) = c (4) = ::: = c (r).
Reference: [9] <author> S.A. Savari, </author> <title> "Some notes on Varn coding", </title> <journal> IEEE Trans. Inform. Th., </journal> <volume> 40, </volume> <year> (1994): </year> <pages> 181-186. </pages>
Reference-contexts: A number of authors in addition to Varn have addressed the nonexhaustive unequal costs coding problem for equiprobable source symbols from the algorithmic point of view for general sets of costs [3,4,5,8] or for specific cost assignments [7] or have obtained bounds on the resulting minimum average cost <ref> [9] </ref>. The term "nonexhaustive" indicates that each internal node of the tree has at least 2 and at most r descendants. A nonexhaustive code tree can have lower average codeword cost than if the exhaustive requirement is imposed, hence the interest in the nonexhaustive case.
Reference: [10] <author> B. F. Varn, </author> <title> "Optimal variable length codes (arbitrary symbol cost and equal code word probabilities)", </title> <journal> Inform. Contr., </journal> <volume> 19,(1971): </volume> <month> 289-301. </month> <title> AMS Classification Numbers: 11B39, Fibonacci and Lucas numbers and polynomials and generalizations; 94A45, Prefix, length-variable, comma-free codes. </title>
Reference-contexts: The term "exhaustive" indicates that each internal node of the r-ary tree has exactly r descendants. For r = 2, c (1) = 1, c (2) = 2, these trees are Horibe's Fibonacci trees [6]. The exhaustive generalized Fibonacci trees when interpreted as code trees solve Varn's <ref> [10] </ref> unequal costs coding problem under the requirement that the code trees be exhaustive [1]. <p> Perl et al. [8] give a simple algorithm for the minimax problem as a "remark" in their paper otherwise concerned with the minimum average codeword cost case. So, as we'll see, it is the minimax version of Varn's problem which has the Fibonacci-like structure. In the exhaustive case, Varn's <ref> [10] </ref> algorithm constructs the minimum average codeword cost tree of N leaf nodes, where (N 1)=(r1) is an integer, as follows. <p> Clearly the resulting tree is also a minimax exhaustive tree because splitting any other node besides the least cost node will create a leaf node of greater cost. The nonexhaustive algorithms for the minimum average cost trees of Varn <ref> [10] </ref>, Perl et al. [8], Cot [4], Golin and Young [5], and Choi and Golin [3] are all rather complicated. Perl, Garey, and Even's [8] algorithm for the minimax tree is simpler than any of the minimum average cost algorithms. <p> The minimax algorithm is to branch or add, creating the least cost next leaf node at each stage. While Varn's <ref> [10] </ref> original problem statement and algorithms assumed arbitrary positive costs, the recursive method described here applies to arbitrary positive integer code symbol costs c (1) c (2) : : : c (r), ordered without loss of generality, whose greatest common divisor is 1. <p> Note that leaf nodes of type of greatest index are the highest cost leaf nodes. In the demonstration, rather than use Perl, Garey, and Even's optimal minimax algorithm [8], we'll use a new optimal minimax algorithm which is in the same spirit as Varn's original algorithm <ref> [10] </ref> for optimality in the sense of minimum average cost. The algorithm will follow from Theorem 2, and is contained in the corollary to Theorem 2. <p> Lemma (Varn <ref> [10] </ref>) Let S 0 be an exhaustive tree with N S leaf nodes and M nonroot interior nodes where N S = (M + 1)r M . Denote the costs of the M nonroot interior nodes of S 0 by z 1 z 2 ::: z M . <p> This is the case for Ex. b, and the nonexhaustive minimax trees of Table 2 are the same as the nonexhaustive minimum average cost trees of <ref> [10] </ref> for the same, small, alphabet sizes. It is also the case for Patt's [7] costs, c (i) = i, i = 1; 2; :::, when N is an integer power of 2, and his paper includes the recursive tree sequence structure.
References-found: 10

