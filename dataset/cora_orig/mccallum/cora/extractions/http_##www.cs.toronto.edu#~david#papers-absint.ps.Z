URL: http://www.cs.toronto.edu/~david/papers-absint.ps.Z
Refering-URL: http://www.cs.toronto.edu/~david/papers.html
Root-URL: 
Email: david@cs.toronto.edu  
Title: Constraint Databases and Program Analysis using Abstract Interpretation  
Author: David Toman 
Address: Toronto, Ontario, Canada M5S 1A4  
Affiliation: Department of Computer Science, University of Toronto  
Abstract: In this paper we discuss a connection between two seemingly distant research areas in computer science: constraint databases and abstract interpretation. We show that while the goals of research in the respective communities are different, the used techniques are often based on similar common foundations. We substantiate this claim by showing that abstract interpretation of a standard (Algol-like) programming language with respect to its natural semantics can be equivalently thought of as querying a constraint deductive database. On the other hand the constraint database community can often benefit from the sophisticated techniques developed for computing abstract properties of programs, e.g., for query termination analysis or approximate query evaluation.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Abiteboul, S., Hull, R., Vianu, V. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The evaluation of a Datalog C program is then performed with respect to the class of constraint interpretations|finite sets of constraints associated with literals. Bottom-up query evaluation <ref> [1] </ref> is based on iterating a constraint variant of the immediate consequence operator: Definition 2.4 (Immediate Consequence Operator) Let I be a C-interpretation and P a Datalog C program. <p> [1::n] of int) = f := 0; while f = 0 do f := 1; if a [i] a [i + 1] then f := 0; fi od Note that this program conforms to the grammar in Figure 1: the array a [1::n] is a shorthand for n variables a <ref> [1] </ref>; : : : ; a [n] and similarly the for i := 1 to n 1 do : : : od construction a shorthand for n 1 instances of its body with appropriately substituted variable names. Fig. 3. <p> The result is hardly surprising: the individual variables a [i] are related by the constraint a <ref> [1] </ref> &lt; a [2] &lt; : : : &lt; a [n] 3 . <p> Then we can discover that, e.g., if the input array is sorted then each cell of the output array depends only on its value in the input array and thus the sortn computes an identity. 3 The actual answer may also contain constraints implied by the above answer, e.g., a <ref> [1] </ref> + 1 &lt; a [3] or a [2] + 3 &lt; a [6]. 4.1 Shortcomings of the Proposed Method Precision of Constraint Approximation. In our proposal we approximate the semantic functions in the natural semantic rules by elements of the chosen constraint class.
Reference: 2. <editor> Abramski, S., Hankin, C. (eds.) </editor> <title> Abstract Interpretation of Declarative Languages. </title> <publisher> Ellis Horwood, </publisher> <year> 1987. </year>
Reference-contexts: The result is hardly surprising: the individual variables a [i] are related by the constraint a [1] &lt; a <ref> [2] </ref> &lt; : : : &lt; a [n] 3 . <p> input array is sorted then each cell of the output array depends only on its value in the input array and thus the sortn computes an identity. 3 The actual answer may also contain constraints implied by the above answer, e.g., a [1] + 1 &lt; a [3] or a <ref> [2] </ref> + 3 &lt; a [6]. 4.1 Shortcomings of the Proposed Method Precision of Constraint Approximation. In our proposal we approximate the semantic functions in the natural semantic rules by elements of the chosen constraint class. <p> The rigorous development of the abstract interpretation area starts with the seminal work [6], many references can be found in <ref> [2, 8] </ref>, or more recently in [25, 26], where the connection of natural semantics and abstract interpretation was studied in detail. For survey of the research in the area of constraint databases we refer to an excellent survey [23].
Reference: 3. <author> Codish, M., Demoen, B. </author> <title> Analysing Logic Programs Using `Prop'-ositional Logic Programs and a Magic Wand. </title> <booktitle> Proc. 1994 International Logic Programming Symposium, </booktitle> <publisher> MIT Press, </publisher> <pages> 114-129, </pages> <year> 1994. </year>
Reference-contexts: Note also that we are interested in analyzing general programming languages rather than (constraint) logic programs <ref> [3, 4] </ref>. There are several advantages of our approach: The constraint approach hides the distinction between the forward and the backward forms [8] of abstract interpretation. This is an immediate consequence of approximating the semantic functions by constraints (relations) and the bidirectional character of logic programs. <p> e.g., if the input array is sorted then each cell of the output array depends only on its value in the input array and thus the sortn computes an identity. 3 The actual answer may also contain constraints implied by the above answer, e.g., a [1] + 1 &lt; a <ref> [3] </ref> or a [2] + 3 &lt; a [6]. 4.1 Shortcomings of the Proposed Method Precision of Constraint Approximation. In our proposal we approximate the semantic functions in the natural semantic rules by elements of the chosen constraint class.
Reference: 4. <author> Codognet P., File, G. </author> <title> Computations, Abstractions, and Constraints in Logic Programming. </title> <booktitle> Proc. IEEE Conference on Computer Languages, </booktitle> <pages> 155-164, </pages> <year> 1992. </year>
Reference-contexts: Note also that we are interested in analyzing general programming languages rather than (constraint) logic programs <ref> [3, 4] </ref>. There are several advantages of our approach: The constraint approach hides the distinction between the forward and the backward forms [8] of abstract interpretation. This is an immediate consequence of approximating the semantic functions by constraints (relations) and the bidirectional character of logic programs.
Reference: 5. <author> Cousot, P., Cousot, R. </author> <title> Static Determination of Dynamic Properties of Programs. </title> <booktitle> in Proc. 2nd Int. Symposium on Programming, </booktitle> <year> 1976. </year>
Reference-contexts: Slow convergence. The above problem is intimately connected with the approaches that try to speed up the convergence of the fixpoint computation. The main idea is to use a widening operator <ref> [5] </ref> to approximate disjunctions of constraints by a single more general constraint. This way, besides potentially avoiding the exponential bowup, we can move up in the subsumption ordering faster and thus we may reduce the number of iterations needed to reach the fixpoint.
Reference: 6. <author> Cousot, P., Cousot, R. </author> <title> Abstract Interpretation: a unified lattice model for static analysis of programs. </title> <booktitle> In Proc. 4th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> 238-252, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Abstract Interpretation provides a canonical approach to the analysis of data-flow properties of programs <ref> [6] </ref>. It is based on semantic approximation: the domain of concrete values manipulated by the analyzed program is replaced by a domain of abstract values|descriptions of whole sets of concrete values. <p> The connection between the domain of concrete and abstract values is usually formalized by two maps: the abstraction (ff) and the concretization (fl) that form an adjoint pair of functions <ref> [6] </ref>. That is, for every set of concrete values x, x fl (ff (x)), and for every abstract value y, y = ff (fl (y)). <p> The finite ascending chain condition is used to guarantee finiteness such analysis. For details see <ref> [6, 7, 8] </ref>. 2.3 Constraint Databases It is not surprising that constraints have been used in place of the abstract values [8, 9, 21, 25]. They provide a natural and compact descriptions of properties of values. <p> each cell of the output array depends only on its value in the input array and thus the sortn computes an identity. 3 The actual answer may also contain constraints implied by the above answer, e.g., a [1] + 1 &lt; a [3] or a [2] + 3 &lt; a <ref> [6] </ref>. 4.1 Shortcomings of the Proposed Method Precision of Constraint Approximation. In our proposal we approximate the semantic functions in the natural semantic rules by elements of the chosen constraint class. We do not need any external functions operating on the constraint class for this purpose. <p> The rigorous development of the abstract interpretation area starts with the seminal work <ref> [6] </ref>, many references can be found in [2, 8], or more recently in [25, 26], where the connection of natural semantics and abstract interpretation was studied in detail. For survey of the research in the area of constraint databases we refer to an excellent survey [23]. <p> In the deductive databases community a considerable effort has been directed towards including negation in the otherwise positive Horn clauses. Can negation (stratified, well-founded, stable, etc.) be used to enhance the capabilities of abstract interpretation, e.g., in the case of coinductive types and greatest fixpoints <ref> [6, 25] </ref>?
Reference: 7. <author> Cousot, P., Cousot, R. </author> <title> Systematic design of program analysis frameworks. </title> <booktitle> In Proc. 6th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> 269-282, </pages> <year> 1989. </year>
Reference-contexts: The finite ascending chain condition is used to guarantee finiteness such analysis. For details see <ref> [6, 7, 8] </ref>. 2.3 Constraint Databases It is not surprising that constraints have been used in place of the abstract values [8, 9, 21, 25]. They provide a natural and compact descriptions of properties of values.
Reference: 8. <author> Cousot, P., Cousot, R. </author> <title> Abstract Interpretation and Application to Logic Programs. </title> <journal> J. Logic Programming, </journal> <volume> 13 </volume> <pages> 103-179, </pages> <year> 1992. </year>
Reference-contexts: Note also that we are interested in analyzing general programming languages rather than (constraint) logic programs [3, 4]. There are several advantages of our approach: The constraint approach hides the distinction between the forward and the backward forms <ref> [8] </ref> of abstract interpretation. This is an immediate consequence of approximating the semantic functions by constraints (relations) and the bidirectional character of logic programs. The semantic rules instantiated with the actual text of the analyzed program yield a set of constraint Datalog clauses. <p> The finite ascending chain condition is used to guarantee finiteness such analysis. For details see <ref> [6, 7, 8] </ref>. 2.3 Constraint Databases It is not surprising that constraints have been used in place of the abstract values [8, 9, 21, 25]. They provide a natural and compact descriptions of properties of values. <p> The finite ascending chain condition is used to guarantee finiteness such analysis. For details see [6, 7, 8]. 2.3 Constraint Databases It is not surprising that constraints have been used in place of the abstract values <ref> [8, 9, 21, 25] </ref>. They provide a natural and compact descriptions of properties of values. Moreover, they are naturally equipped with the appropriate boolean 1 First-order programming languages can be encoded using standard Prolog terms. However, higher-order languages may require co-inductive data types to represent closures [25]. <p> The rigorous development of the abstract interpretation area starts with the seminal work [6], many references can be found in <ref> [2, 8] </ref>, or more recently in [25, 26], where the connection of natural semantics and abstract interpretation was studied in detail. For survey of the research in the area of constraint databases we refer to an excellent survey [23].
Reference: 9. <author> Cousot, P., Halbwachs, N. </author> <title> Automatic Discovery of Linear Restraints Among Variables of a Program. </title> <booktitle> Proc. ACM Symp. on Principles of Programming Languages, </booktitle> <pages> 84-96, </pages> <year> 1978. </year>
Reference-contexts: In our proposal the sequential composi-tion is modeled by a conjunction and subsequent quantifier elimination applied on the constraints that approximate the original semantic functions involved in the composition. This is also the main difference from the relational abstract interpretations proposed in, e.g., <ref> [9, 17, 18, 19, 28] </ref>, where constraints are often used to capture the static abstract relationships among variables rather then the dynamic behavior of the analyzed program. Note also that we are interested in analyzing general programming languages rather than (constraint) logic programs [3, 4]. <p> The finite ascending chain condition is used to guarantee finiteness such analysis. For details see [6, 7, 8]. 2.3 Constraint Databases It is not surprising that constraints have been used in place of the abstract values <ref> [8, 9, 21, 25] </ref>. They provide a natural and compact descriptions of properties of values. Moreover, they are naturally equipped with the appropriate boolean 1 First-order programming languages can be encoded using standard Prolog terms. However, higher-order languages may require co-inductive data types to represent closures [25]. <p> However, higher-order languages may require co-inductive data types to represent closures [25]. These can be conveniently encoded by rational trees of Prolog-II. structure. However, the semantic operations on the constraints prescribed by the semantics are commonly defined as external functions operating on the constraint class <ref> [9] </ref>. In our approach we use constraints to approximate the semantic functions defined by the natural semantics. This way the whole abstract interpretation can be reduced to a deductive query over a constraint database built out of the analyzed program. <p> The result is a &lt; b or a = b, i.e., the last element of the output array is at least as big as the first element of the input array. The results of the first and second query can be obtained using standard abstract interpretation techniques <ref> [9, 10, 11] </ref>; the first query corresponds to a forward analysis while the second one to a backward analysis. However, we do not know about any abstract interpretation analysis proposal that can come up with the result of the third query.
Reference: 10. <author> Granger, P. </author> <title> Static analysis of arithmetical congruences. </title> <journal> International Journal of Computer Mathematics,165-199, </journal> <year> 1989. </year>
Reference-contexts: The result is a &lt; b or a = b, i.e., the last element of the output array is at least as big as the first element of the input array. The results of the first and second query can be obtained using standard abstract interpretation techniques <ref> [9, 10, 11] </ref>; the first query corresponds to a forward analysis while the second one to a backward analysis. However, we do not know about any abstract interpretation analysis proposal that can come up with the result of the third query.
Reference: 11. <institution> Static analysis of linear congruences among variables of a program. </institution> <type> Tech. Rep. </type> <institution> LIX, Paris, France, </institution> <year> 1990. </year>
Reference-contexts: The result is a &lt; b or a = b, i.e., the last element of the output array is at least as big as the first element of the input array. The results of the first and second query can be obtained using standard abstract interpretation techniques <ref> [9, 10, 11] </ref>; the first query corresponds to a forward analysis while the second one to a backward analysis. However, we do not know about any abstract interpretation analysis proposal that can come up with the result of the third query.
Reference: 12. <author> Gunter C.A. </author> <title> Semantics of Programming Languages. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: To facilitate examples in this paper we define a natural big-step operational semantics for a simple imperative Algol-like language (we follow an introductory example in <ref> [12] </ref>). The syntax of this language is summarized by the grammar in Figure 1. Then we introduce the basic ideas of the standard abstract interpretation. In the end of the section we introduce deductive constraint databases and show a few elementary properties of queries over such databases. <p> Also, we do not want to bury a quite simple and natural idea in heaps of cumbersome notation that would be necessary to prove all the claims formally. 2.1 Natural Semantics We define the concrete semantics of our simple imperative language using a finite set of Natural Semantics rules <ref> [12] </ref> of the form 1 ` e 1 + v 1 : : : k ` e k + v k 0 ` E + v 0 ` skip + 0 0 ` C 1 + 1 1 ` C 2 + 2 0 ` B + tt 0 ` C <p> The trouble with such a definition is that the meaning of the while loop is defined in terms of itself. Domain theory <ref> [12, 24] </ref> allows us to break this loop by defining the meaning of such a construction as a limit of its approximations. The existence and choice of the appropriate limit is discussed in length in numerous books on semantics of programming languages, e.g., [12, 24]. <p> Domain theory <ref> [12, 24] </ref> allows us to break this loop by defining the meaning of such a construction as a limit of its approximations. The existence and choice of the appropriate limit is discussed in length in numerous books on semantics of programming languages, e.g., [12, 24]. In general, we can compute the semantic value of a while loop as the (least) fixpoint obtained by unfolding the corresponding natural semantic rules. <p> Note that given a program in our simple imperative language the instances of the natural semantic rules derived from this program yield a finite set of Horn clauses <ref> [12, 25] </ref>. This observation leads immediately to the definition of a simple interpreter for the language as a set of Horn clauses, e.g., in Prolog-II 1 . Collection Semantics.
Reference: 13. <editor> Henkin, L., Monk, J.D., Tarski, A. </editor> <title> Cylindric Algebras. Part I, II. </title> <booktitle> Studies in Logic and Foundations of Mathematics, vols. </booktitle> <volume> 64, </volume> <pages> 115, </pages> <address> North Holland 1971, </address> <year> 1985. </year>
Reference-contexts: However, there are still more fundamental questions to be answered, e.g.: 1. Our Abstract Interpretation method uses a considerably more complex domain of abstract values: besided the usual joins and meets of abstract values the structure also contains the cylindrification operations (projections) <ref> [13] </ref> used to eliminate variables from constraints. How can we benefit from this additional structure of the abstract values? How do these additional operations affect the abstract interpretation itself? 2.
Reference: 14. <editor> Jones, N.D., Muchnick, S.S. </editor> <title> Flow analysis and optimization of LISP-like structures. </title> <booktitle> In Proc. 6th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> 244-256, </pages> <year> 1979. </year>
Reference-contexts: Note that both the attribute-independent and the relational abstract interpretation techniques <ref> [14, 19, 28] </ref> follow this pattern; the difference between these two approaches is the arity of the constraints used to approximate the concrete values: unary vs. n-ary.
Reference: 15. <author> Kanellakis, P. C., Kuper, G. M., Revesz, </author> <title> P.Z . Constraint Query Languages. </title> <journal> Journal of Computer and System Sciences 51(1) </journal> <pages> 26-52, </pages> <year> 1995. </year>
Reference-contexts: Constraint Subsumption C : C fi C ! bool that satisfies the condition C 1 C C 2 implies C 1 C 2 Finite sets of elements of C are used to represent possibly infinite relations stored in the constraint database <ref> [15] </ref>. Query evaluation over such a database is based on the operations defined on the constraint class: the first two operations are the equivalents of relational algebra join and projection.
Reference: 16. <author> Lloyd, J. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Moreover, constraint compactness of C guarantees termination of Datalog C queries, in particular the query A (P ) j= main (C). The result then follows from equivalence between the fixpoint bottom-up evaluation and resolution on constraint compact classes <ref> [16, 31] </ref>. The minimality follows from Definition 3.1 and the properties of bottom-up query evaluation. We apply the proposed technique to programs in our simple imperative language as follows: first we determine a finite portion of the store vector referenced in the analyzed program P .
Reference: 17. <author> Marriott, K., Sondergaard, H. </author> <title> Analysis of Constraint Logic Programs. </title> <booktitle> Proc. NA-CLP 1990, </booktitle> <pages> 531-547. </pages>
Reference-contexts: In our proposal the sequential composi-tion is modeled by a conjunction and subsequent quantifier elimination applied on the constraints that approximate the original semantic functions involved in the composition. This is also the main difference from the relational abstract interpretations proposed in, e.g., <ref> [9, 17, 18, 19, 28] </ref>, where constraints are often used to capture the static abstract relationships among variables rather then the dynamic behavior of the analyzed program. Note also that we are interested in analyzing general programming languages rather than (constraint) logic programs [3, 4].
Reference: 18. <author> Marriot, K., Stuckey, P. J. </author> <title> Approximating interactions between linear arithmetic constraints. </title> <booktitle> Proc. 1994 International Logic Programming Symposium, </booktitle> <publisher> MIT Press, </publisher> <year> 1994, </year> <pages> 571-585. </pages>
Reference-contexts: In our proposal the sequential composi-tion is modeled by a conjunction and subsequent quantifier elimination applied on the constraints that approximate the original semantic functions involved in the composition. This is also the main difference from the relational abstract interpretations proposed in, e.g., <ref> [9, 17, 18, 19, 28] </ref>, where constraints are often used to capture the static abstract relationships among variables rather then the dynamic behavior of the analyzed program. Note also that we are interested in analyzing general programming languages rather than (constraint) logic programs [3, 4].
Reference: 19. <author> Mycroft, A., Jones, </author> <title> N.D. A relational framework for abstract interpretation. In Programs as Data Objects, </title> <publisher> LNCS 217, </publisher> <pages> 156-171, </pages> <year> 1985. </year>
Reference-contexts: In our proposal the sequential composi-tion is modeled by a conjunction and subsequent quantifier elimination applied on the constraints that approximate the original semantic functions involved in the composition. This is also the main difference from the relational abstract interpretations proposed in, e.g., <ref> [9, 17, 18, 19, 28] </ref>, where constraints are often used to capture the static abstract relationships among variables rather then the dynamic behavior of the analyzed program. Note also that we are interested in analyzing general programming languages rather than (constraint) logic programs [3, 4]. <p> Note that both the attribute-independent and the relational abstract interpretation techniques <ref> [14, 19, 28] </ref> follow this pattern; the difference between these two approaches is the arity of the constraints used to approximate the concrete values: unary vs. n-ary.
Reference: 20. <author> Naughton, J.F., Ramakrishnan, R., Sagiv, Y., Ullman, J.D. </author> <title> Argument Reduction by Factoring. </title> <booktitle> in Proc. Intl. Conf. on Very Large Data Bases, </booktitle> <year> 1989. </year>
Reference-contexts: The choice of abstract values corresponds to the choice of an appropriate constraint class [23]. In addition, the choice of a constraint-compact class [31] guarantees finiteness of the analysis. The use of database technology, e.g., query optimization techniques <ref> [20, 32] </ref> or goal oriented query evaluation procedures [31], allows us to analyze relatively large programs. Indeed, the database techniques are inherently tar geted towards fairly large data sets.
Reference: 21. <author> Palsberg, j. </author> <title> Closure Analysis in Constraint Form. </title> <booktitle> In Proc. </booktitle> <address> CAAP'94 , 276-290, </address> <year> 1994. </year> <note> (to appear in ACM Transactions on Programming Languages and Sytems). </note>
Reference-contexts: The finite ascending chain condition is used to guarantee finiteness such analysis. For details see [6, 7, 8]. 2.3 Constraint Databases It is not surprising that constraints have been used in place of the abstract values <ref> [8, 9, 21, 25] </ref>. They provide a natural and compact descriptions of properties of values. Moreover, they are naturally equipped with the appropriate boolean 1 First-order programming languages can be encoded using standard Prolog terms. However, higher-order languages may require co-inductive data types to represent closures [25]. <p> Similar effect can be achieved using set-order constraints [29]. Small Step Semantics. We have also assumed that the semantics of the given programming language is given by a set of natural semantic rules. However, the abstract interpretation technology can be applied to a small-step operational semantics as well <ref> [21, 26] </ref>. The abstract interpretation defined in [21] uses the set-order constraints to specify a closure analysis of untyped -calculus. 6 Conclusion and Future Work In this paper we made a first step towards combining results in the areas of constraint databases and abstract interpretation based program analysis. <p> Small Step Semantics. We have also assumed that the semantics of the given programming language is given by a set of natural semantic rules. However, the abstract interpretation technology can be applied to a small-step operational semantics as well [21, 26]. The abstract interpretation defined in <ref> [21] </ref> uses the set-order constraints to specify a closure analysis of untyped -calculus. 6 Conclusion and Future Work In this paper we made a first step towards combining results in the areas of constraint databases and abstract interpretation based program analysis.
Reference: 22. <author> Revesz, P. Z. </author> <title> A Closed Form Evaluation for Datalog Queries with Integer (Gap)- Order Constraints. </title> <journal> Theoretical Computer Science, </journal> <volume> vol. 116, no. 1, </volume> <pages> 117-149, </pages> <year> 1993. </year>
Reference-contexts: Then the carrier of the class of Integer Gap-Order Constraints is generated from the set C 0 = fp &lt; x; x = y; x &lt; y; x &lt; r : p; r 2 Ag: The appropriate constraint operations on this class are defined in <ref> [22] </ref> and are based on a graph representation of the gap-order constraints. There are several other classes of constraints used in constraint databases, e.g, the dense order constraints, the equality constraints, or the set-order constraints. For detailed exposition see [23]. <p> Similarly we can define top-down evaluation procedures based on the constraint operations [31]. The following definition states a fundamental property of constraint classes on which the finiteness arguments for bottom-up query evaluation procedures are implicitly based <ref> [22, 29, 30, 32] </ref>: Definition 2.5 (Constraint-compact Constraint Class) Let C be a class of constraints.
Reference: 23. <author> Revesz, P. </author> <title> Constraint Query Languages. A Survey. </title> <type> (unpublished manuscript), </type> <year> 1995. </year>
Reference-contexts: Thus we can automatically generate an executable specification of an abstract interpreter from the source text of the given program. The choice of abstract values corresponds to the choice of an appropriate constraint class <ref> [23] </ref>. In addition, the choice of a constraint-compact class [31] guarantees finiteness of the analysis. The use of database technology, e.g., query optimization techniques [20, 32] or goal oriented query evaluation procedures [31], allows us to analyze relatively large programs. <p> There are several other classes of constraints used in constraint databases, e.g, the dense order constraints, the equality constraints, or the set-order constraints. For detailed exposition see <ref> [23] </ref>. <p> For survey of the research in the area of constraint databases we refer to an excellent survey <ref> [23] </ref>. In the remainder of this section we want to point out two other possibilities of application of constraint technology to abstract interpretation: Higher-order Languages. In the whole paper we have only considered an imperative (first-order) language.
Reference: 24. <author> Schmidt, D.A. </author> <title> Denotational Semantics: A methodology for Language Development. </title> <publisher> Allyn and Bacon, </publisher> <year> 1986. </year>
Reference-contexts: The trouble with such a definition is that the meaning of the while loop is defined in terms of itself. Domain theory <ref> [12, 24] </ref> allows us to break this loop by defining the meaning of such a construction as a limit of its approximations. The existence and choice of the appropriate limit is discussed in length in numerous books on semantics of programming languages, e.g., [12, 24]. <p> Domain theory <ref> [12, 24] </ref> allows us to break this loop by defining the meaning of such a construction as a limit of its approximations. The existence and choice of the appropriate limit is discussed in length in numerous books on semantics of programming languages, e.g., [12, 24]. In general, we can compute the semantic value of a while loop as the (least) fixpoint obtained by unfolding the corresponding natural semantic rules.
Reference: 25. <author> Schmidt, D.A. </author> <title> Natural-semantics-based abstract interpretation. </title> <booktitle> In Proc. Static Analysis Symposium, </booktitle> <volume> LNCS 983, </volume> <pages> 1-18, </pages> <year> 1995. </year>
Reference-contexts: Note that given a program in our simple imperative language the instances of the natural semantic rules derived from this program yield a finite set of Horn clauses <ref> [12, 25] </ref>. This observation leads immediately to the definition of a simple interpreter for the language as a set of Horn clauses, e.g., in Prolog-II 1 . Collection Semantics. <p> The finite ascending chain condition is used to guarantee finiteness such analysis. For details see [6, 7, 8]. 2.3 Constraint Databases It is not surprising that constraints have been used in place of the abstract values <ref> [8, 9, 21, 25] </ref>. They provide a natural and compact descriptions of properties of values. Moreover, they are naturally equipped with the appropriate boolean 1 First-order programming languages can be encoded using standard Prolog terms. However, higher-order languages may require co-inductive data types to represent closures [25]. <p> They provide a natural and compact descriptions of properties of values. Moreover, they are naturally equipped with the appropriate boolean 1 First-order programming languages can be encoded using standard Prolog terms. However, higher-order languages may require co-inductive data types to represent closures <ref> [25] </ref>. These can be conveniently encoded by rational trees of Prolog-II. structure. However, the semantic operations on the constraints prescribed by the semantics are commonly defined as external functions operating on the constraint class [9]. <p> The rigorous development of the abstract interpretation area starts with the seminal work [6], many references can be found in [2, 8], or more recently in <ref> [25, 26] </ref>, where the connection of natural semantics and abstract interpretation was studied in detail. For survey of the research in the area of constraint databases we refer to an excellent survey [23]. <p> In the whole paper we have only considered an imperative (first-order) language. However, the abstract interpretation techniques can also be applied to higher-order programming languages, e.g., PCF [27]. Here the situation is more complicated: besides abstractions for ground types we also need to abstract function types <ref> [25] </ref>. This goal is often achieved by defining a domain of values based on closures which in turn lead to a natural nesting of such closures inside each other. In [25] an abstract interpretation technique was developed to analyze such programs. Similar effect can be achieved using set-order constraints [29]. <p> Here the situation is more complicated: besides abstractions for ground types we also need to abstract function types <ref> [25] </ref>. This goal is often achieved by defining a domain of values based on closures which in turn lead to a natural nesting of such closures inside each other. In [25] an abstract interpretation technique was developed to analyze such programs. Similar effect can be achieved using set-order constraints [29]. Small Step Semantics. We have also assumed that the semantics of the given programming language is given by a set of natural semantic rules. <p> In the deductive databases community a considerable effort has been directed towards including negation in the otherwise positive Horn clauses. Can negation (stratified, well-founded, stable, etc.) be used to enhance the capabilities of abstract interpretation, e.g., in the case of coinductive types and greatest fixpoints <ref> [6, 25] </ref>?
Reference: 26. <author> Schmidt, D.A. </author> <title> Abstract Interpretation of Small-Step Semantics. </title> <booktitle> Presented at 5th LOMAPS Workshop on Analysis and Verification of Multiple-Agent Languages, </booktitle> <address> Stockholm, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: The rigorous development of the abstract interpretation area starts with the seminal work [6], many references can be found in [2, 8], or more recently in <ref> [25, 26] </ref>, where the connection of natural semantics and abstract interpretation was studied in detail. For survey of the research in the area of constraint databases we refer to an excellent survey [23]. <p> Similar effect can be achieved using set-order constraints [29]. Small Step Semantics. We have also assumed that the semantics of the given programming language is given by a set of natural semantic rules. However, the abstract interpretation technology can be applied to a small-step operational semantics as well <ref> [21, 26] </ref>. The abstract interpretation defined in [21] uses the set-order constraints to specify a closure analysis of untyped -calculus. 6 Conclusion and Future Work In this paper we made a first step towards combining results in the areas of constraint databases and abstract interpretation based program analysis.
Reference: 27. <author> Scott, </author> <title> D.S. An Alternative to CUCH, ISWIM, OHWY. </title> <type> unpublished manuscript, </type> <year> 1969. </year>
Reference-contexts: In the whole paper we have only considered an imperative (first-order) language. However, the abstract interpretation techniques can also be applied to higher-order programming languages, e.g., PCF <ref> [27] </ref>. Here the situation is more complicated: besides abstractions for ground types we also need to abstract function types [25]. This goal is often achieved by defining a domain of values based on closures which in turn lead to a natural nesting of such closures inside each other.
Reference: 28. <author> Sondergaard, H. </author> <title> An Application of Abstract Interpretation of Logic Programs: Occur Check Reduction. </title> <booktitle> Proc. ESOP 1986, </booktitle> <pages> 327-338. </pages>
Reference-contexts: In our proposal the sequential composi-tion is modeled by a conjunction and subsequent quantifier elimination applied on the constraints that approximate the original semantic functions involved in the composition. This is also the main difference from the relational abstract interpretations proposed in, e.g., <ref> [9, 17, 18, 19, 28] </ref>, where constraints are often used to capture the static abstract relationships among variables rather then the dynamic behavior of the analyzed program. Note also that we are interested in analyzing general programming languages rather than (constraint) logic programs [3, 4]. <p> Note that both the attribute-independent and the relational abstract interpretation techniques <ref> [14, 19, 28] </ref> follow this pattern; the difference between these two approaches is the arity of the constraints used to approximate the concrete values: unary vs. n-ary.
Reference: 29. <author> Srivastava, D., Ramakrishnan, R., Revesz, P. Z. </author> <title> Constraint Objects. </title> <booktitle> Proc. Intl. Workshop on Principles and Practice of Constraint Programming, </booktitle> <pages> 218-228, </pages> <year> 1994. </year>
Reference-contexts: Similarly we can define top-down evaluation procedures based on the constraint operations [31]. The following definition states a fundamental property of constraint classes on which the finiteness arguments for bottom-up query evaluation procedures are implicitly based <ref> [22, 29, 30, 32] </ref>: Definition 2.5 (Constraint-compact Constraint Class) Let C be a class of constraints. <p> This goal is often achieved by defining a domain of values based on closures which in turn lead to a natural nesting of such closures inside each other. In [25] an abstract interpretation technique was developed to analyze such programs. Similar effect can be achieved using set-order constraints <ref> [29] </ref>. Small Step Semantics. We have also assumed that the semantics of the given programming language is given by a set of natural semantic rules. However, the abstract interpretation technology can be applied to a small-step operational semantics as well [21, 26].
Reference: 30. <author> Toman, D., Chomicki, J., Rogers D. S. </author> <title> Datalog with Integer Periodicity Constraints. </title> <booktitle> Proc. 1994 International Logic Programming Symposium, </booktitle> <publisher> MIT Press, </publisher> <year> 1994, </year> <pages> 189-203. </pages>
Reference-contexts: Similarly we can define top-down evaluation procedures based on the constraint operations [31]. The following definition states a fundamental property of constraint classes on which the finiteness arguments for bottom-up query evaluation procedures are implicitly based <ref> [22, 29, 30, 32] </ref>: Definition 2.5 (Constraint-compact Constraint Class) Let C be a class of constraints.
Reference: 31. <author> Toman, D. </author> <title> Top-Down beats Bottom-Up for Constraint Based Extensions of Dat-alog. </title> <booktitle> Proc. 1995 International Logic Programming Symposium, </booktitle> <publisher> MIT Press, </publisher> <year> 1995, </year> <pages> 98-112. </pages>
Reference-contexts: Thus we can automatically generate an executable specification of an abstract interpreter from the source text of the given program. The choice of abstract values corresponds to the choice of an appropriate constraint class [23]. In addition, the choice of a constraint-compact class <ref> [31] </ref> guarantees finiteness of the analysis. The use of database technology, e.g., query optimization techniques [20, 32] or goal oriented query evaluation procedures [31], allows us to analyze relatively large programs. Indeed, the database techniques are inherently tar geted towards fairly large data sets. <p> The choice of abstract values corresponds to the choice of an appropriate constraint class [23]. In addition, the choice of a constraint-compact class <ref> [31] </ref> guarantees finiteness of the analysis. The use of database technology, e.g., query optimization techniques [20, 32] or goal oriented query evaluation procedures [31], allows us to analyze relatively large programs. Indeed, the database techniques are inherently tar geted towards fairly large data sets. <p> The individual literals are interpreted by finite sets of constraint atoms|constraint counterparts of sets of ground tuples <ref> [31] </ref>. In the rest of the paper we slightly abuse the notation and denote the constraint atoms by A (C) where A is a predicate symbol and C 2 C. <p> The variables in the constraint atoms are renamed using the variable names in the associated atoms of the clause. Similarly we can define top-down evaluation procedures based on the constraint operations <ref> [31] </ref>. The following definition states a fundamental property of constraint classes on which the finiteness arguments for bottom-up query evaluation procedures are implicitly based [22, 29, 30, 32]: Definition 2.5 (Constraint-compact Constraint Class) Let C be a class of constraints. <p> Theorem 2.6 <ref> [31] </ref> Let C be a constraint compact constraint class and P an ar-bitrary Datalog C program. Then the associated immediate consequence operator T C P has a finite closure ordinal. <p> Moreover, constraint compactness of C guarantees termination of Datalog C queries, in particular the query A (P ) j= main (C). The result then follows from equivalence between the fixpoint bottom-up evaluation and resolution on constraint compact classes <ref> [16, 31] </ref>. The minimality follows from Definition 3.1 and the properties of bottom-up query evaluation. We apply the proposed technique to programs in our simple imperative language as follows: first we determine a finite portion of the store vector referenced in the analyzed program P .
Reference: 32. <author> Ullman J. D. </author> <title> Principles of Database and Knowledge-base Systems, </title> <booktitle> Vol. 1,2. Computer Science Systems, </booktitle> <year> 1989. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: The choice of abstract values corresponds to the choice of an appropriate constraint class [23]. In addition, the choice of a constraint-compact class [31] guarantees finiteness of the analysis. The use of database technology, e.g., query optimization techniques <ref> [20, 32] </ref> or goal oriented query evaluation procedures [31], allows us to analyze relatively large programs. Indeed, the database techniques are inherently tar geted towards fairly large data sets. <p> Similarly we can define top-down evaluation procedures based on the constraint operations [31]. The following definition states a fundamental property of constraint classes on which the finiteness arguments for bottom-up query evaluation procedures are implicitly based <ref> [22, 29, 30, 32] </ref>: Definition 2.5 (Constraint-compact Constraint Class) Let C be a class of constraints.
References-found: 32

