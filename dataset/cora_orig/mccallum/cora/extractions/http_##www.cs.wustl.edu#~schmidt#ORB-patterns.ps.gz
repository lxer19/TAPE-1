URL: http://www.cs.wustl.edu/~schmidt/ORB-patterns.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/tri-dove.html
Root-URL: 
Email: fschmidt,cleelandg@cs.wustl.edu  
Phone: (314) 935-7538  
Title: Applying Patterns to Develop Extensible ORB Middleware  
Author: Douglas C. Schmidt and Chris Cleeland Linda Rising. 
Note: This article has been submitted to the IEEE Communications Magazine Special Issue on Design Patterns edited by  
Address: St. Louis, MO 63130, USA  
Affiliation: Department of Computer Science Washington University  
Abstract: Distributed object computing forms the basis for next-generation application middleware. At the heart of distributed object computing are Object Request Brokers (ORBs), which automate many tedious and error-prone distributed programming tasks. This article presents a case study of key design patterns needed to develop ORBs that can be dynamically configured and evolved for specific application requirements and system characteristics. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Johnson, </author> <title> Frameworks = Patterns + Components, </title> <journal> Commu nications of the ACM, </journal> <volume> vol. 40, </volume> <month> Oct. </month> <year> 1997. </year>
Reference-contexts: 1 Introduction Four trends are shaping the future of commercial software development. First, the software industry is moving away from programming applications from scratch to integrating applications using reusable components <ref> [1] </ref> such as ActiveX and Java Beans. Second, there is great demand for distribution technology that provides remote method invocation or message-oriented middleware to simplify application collaboration within and across local area and wide area networks [2].
Reference: [2] <author> S. Landis and S. Maffeis, </author> <title> Building Reliable Distributed Sys tems with CORBA, </title> <booktitle> Theory and Practice of Object Systems, </booktitle> <month> Apr. </month> <year> 1997. </year>
Reference-contexts: Second, there is great demand for distribution technology that provides remote method invocation or message-oriented middleware to simplify application collaboration within and across local area and wide area networks <ref> [2] </ref>. Third, there are increasing efforts to define standard software infrastructures such as CORBA that allow applications to interwork seemlessly throughout heterogeneous environments [3]. Finally, next-generation distributed applications such as video-on-demand, teleconferencing, and avionics require Quality of Service (QoS) guarantees for latency, bandwidth, and reliability [4].
Reference: [3] <author> S. Vinoski, </author> <title> CORBA: Integrating Diverse Applications Within Distributed Heterogeneous Environments, </title> <journal> IEEE Communications Magazine, </journal> <volume> vol. 14, </volume> <month> February </month> <year> 1997. </year>
Reference-contexts: Third, there are increasing efforts to define standard software infrastructures such as CORBA that allow applications to interwork seemlessly throughout heterogeneous environments <ref> [3] </ref>. Finally, next-generation distributed applications such as video-on-demand, teleconferencing, and avionics require Quality of Service (QoS) guarantees for latency, bandwidth, and reliability [4]. A key software technology supporting these trends is distributed object computing (DOC) middleware. <p> can be customized dynamically to meet specific application QoS requirements and network/endsystem characteristics. 1 2 Overview of CORBA and TAO This section outlines the CORBA reference model and describes the enhancements that TAO provides for real-time systems. 2.1 Overview of the CORBA ORB Reference Model CORBA Object Request Brokers (ORBs) <ref> [3] </ref> allow clients to invoke operations on distributed objects without concern for: * Object location: CORBA objects can be co-located with the client or distributed remotely on a server, without affecting their implementation or use; * Programming language: The languages supported by CORBA include C, C++, Java, Ada95, COBOL, and Smalltalk,
Reference: [4] <author> J. A. Zinky, D. E. Bakken, and R. Schantz, </author> <title> Architectural Sup port for Quality of Service for CORBA Objects, </title> <journal> Theory and Practice of Object Systems, </journal> <volume> vol. 3, no. 1, </volume> <year> 1997. </year>
Reference-contexts: Third, there are increasing efforts to define standard software infrastructures such as CORBA that allow applications to interwork seemlessly throughout heterogeneous environments [3]. Finally, next-generation distributed applications such as video-on-demand, teleconferencing, and avionics require Quality of Service (QoS) guarantees for latency, bandwidth, and reliability <ref> [4] </ref>. A key software technology supporting these trends is distributed object computing (DOC) middleware. DOC middle-fl This research is supported in part by grants from Boeing, NSF grant NCR-9628218, Siemens, and Sprint. ware facilitates the collaboration of local and remote application components in heterogeneous distributed environments.
Reference: [5] <author> Object Management Group, </author> <title> The Common Object Request Bro ker: Architecture and Specification, </title> <editor> 2.2 ed., </editor> <month> Feb. </month> <year> 1998. </year>
Reference-contexts: In particular, DOC middleware automates common network programming tasks such as object location, object activation, parameter marshaling, fault recovery, and security. At the heart of DOC middleware are Object Request Brokers (ORBs), such as CORBA <ref> [5] </ref>, DCOM [6], and Java RMI [7]. This article describes how design patterns have been used to develop dynamically configurable ORB middleware that can be extended and maintained more easily than statically configured middleware. A pattern represents a recurring solution to a software development problem within a particular context [8]. <p> ORB Core: When a client invokes an operation on a servant, the ORB Core is responsible for delivering the request to the servant and returning a response, if any, to the client. For servants executing remotely, a CORBA-compliant <ref> [5] </ref> ORB Core communicates via the Internet Inter-ORB Protocol (IIOP), a version of the General Inter-ORB Protocol (GIOP) which runs atop the TCP transport protocol. An ORB Core is typically implemented as a run-time library linked into client and server applications. <p> Clients making requests need not know whether the server ORB uses static skeletons or dynamic skeletons. Object Adapter: An Object Adapter associates a servant with an ORB, demultiplexes incoming requests to the servant, and dispatches the appropriate operation upcall on that servant. Recent CORBA portability enhancements <ref> [5] </ref> define the Portable Object Adapter (POA), which supports multiple nested POAs per ORB. 2.2 Overview of TAO The TAO ORB endsystem contains the network interface, operating system, communication protocol, and CORBA middleware components and features shown in Figure 2. TAO is based on the standard OMG CORBA reference model [5], <p> <ref> [5] </ref> define the Portable Object Adapter (POA), which supports multiple nested POAs per ORB. 2.2 Overview of TAO The TAO ORB endsystem contains the network interface, operating system, communication protocol, and CORBA middleware components and features shown in Figure 2. TAO is based on the standard OMG CORBA reference model [5], with the following enhancements designed to overcome the shortcomings of conventional ORBs [17] for high-performance and real-time applications: Real-time IDL Stubs and Skeletons: TAO's IDL stubs and skeletons efficiently marshal and demarshal operation parameters, respectively [18].
Reference: [6] <author> D. </author> <title> Box, Essential COM. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1997. </year>
Reference-contexts: In particular, DOC middleware automates common network programming tasks such as object location, object activation, parameter marshaling, fault recovery, and security. At the heart of DOC middleware are Object Request Brokers (ORBs), such as CORBA [5], DCOM <ref> [6] </ref>, and Java RMI [7]. This article describes how design patterns have been used to develop dynamically configurable ORB middleware that can be extended and maintained more easily than statically configured middleware. A pattern represents a recurring solution to a software development problem within a particular context [8].
Reference: [7] <author> A. Wollrath, R. Riggs, and J. Waldo, </author> <title> A Distributed Object Model for the Java System, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: In particular, DOC middleware automates common network programming tasks such as object location, object activation, parameter marshaling, fault recovery, and security. At the heart of DOC middleware are Object Request Brokers (ORBs), such as CORBA [5], DCOM [6], and Java RMI <ref> [7] </ref>. This article describes how design patterns have been used to develop dynamically configurable ORB middleware that can be extended and maintained more easily than statically configured middleware. A pattern represents a recurring solution to a software development problem within a particular context [8].
Reference: [8] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Pat terns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: This article describes how design patterns have been used to develop dynamically configurable ORB middleware that can be extended and maintained more easily than statically configured middleware. A pattern represents a recurring solution to a software development problem within a particular context <ref> [8] </ref>. Patterns help to alleviate the continual re-discovery and re-invention of software concepts and components by documenting proven solutions to standard software development problems [9]. For instance, patterns are useful for documenting the structure and participants in common communication software micro-architectures like Reactors [10], Active Objects [11], and Brokers [12]. <p> How can we avoid accessing low-level system mechanisms when implementing an ORB? Solution ! the Wrapper Facade pattern: An effective way to avoid accessing system mechanisms directly is to use the Wrapper Facade pattern. This pattern is a variant of the Facade pattern <ref> [8] </ref>. The intent of the Facade pattern is to simplify the interface for a subsystem. The intent of the Wrapper Facade pattern is more specific: it provides typesafe, modular, and portable class interfaces that encapsulate lower-level, stand-alone system mechanisms such as sockets, select, and Pthreads. <p> and transparent to other ORB components and (2) encapsulate the state and behavior of each strategy so that changes to one component do not permeate throughout an ORB haphazardly? Solution ! the Strategy pattern: An effective way to support multiple transparently pluggable ORB strategies is to apply the Strategy pattern <ref> [8] </ref>. This pattern factors out similarity among algorithmic alternatives and explicitly associates the name of a strategy with its algorithm and state. Moreover, the Strategy pattern removes lexical dependencies on strategy implementations since applications access specialized behaviors only through common base class interfaces. <p> How can a highly-configurable ORB reduce the complexities required in managing its myriad of strategies, as well as enforce semantic consistency when combining discrete strategies? Solution ! the Abstract Factory pattern: An effective way to consolidate multiple ORB strategies into semantically compatible configurations is to apply the Abstract Factory pattern <ref> [8] </ref>. This pattern provides a single access point that integrates all strategies used to configure an ORB. Concrete subclasses then aggregate semantically compatible application-specific or domain-specific strategies, which can be replaced en masse in semantically meaningful ways. <p> In general, the Abstract Factory pattern should be used when an application needs to consolidate the configuration of many strategies, each having multiple alternatives that must vary together. Using the Abstract Factory pattern in TAO: All of TAO's ORB strategies are consolidated into two abstract factories implemented as Singletons <ref> [8] </ref>. One factory encapsulates client-specific strategies, while the factory shown in Figure 10 encapsulates server-specific strategies. These abstract factories encapsulate concurrency strategies in both the client and the server, and request demultiplexing, scheduling, and dispatch strategies in the server.
Reference: [9] <author> D. C. Schmidt, </author> <title> Experience Using Design Patterns to Develop Reuseable Object-Oriented Communication Software, </title> <journal> Communications of the ACM (Special Issue on Object-Oriented Experiences), </journal> <volume> vol. 38, </volume> <month> October </month> <year> 1995. </year>
Reference-contexts: A pattern represents a recurring solution to a software development problem within a particular context [8]. Patterns help to alleviate the continual re-discovery and re-invention of software concepts and components by documenting proven solutions to standard software development problems <ref> [9] </ref>. For instance, patterns are useful for documenting the structure and participants in common communication software micro-architectures like Reactors [10], Active Objects [11], and Brokers [12].
Reference: [10] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, </editor> <booktitle> eds.), </booktitle> <pages> pp. 529545, </pages> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Patterns help to alleviate the continual re-discovery and re-invention of software concepts and components by documenting proven solutions to standard software development problems [9]. For instance, patterns are useful for documenting the structure and participants in common communication software micro-architectures like Reactors <ref> [10] </ref>, Active Objects [11], and Brokers [12]. These patterns are generalizations of object-structures that have been used successfully to build flexible and efficient event-driven and concurrent communication software such as ORB middleware. <p> TAO is a freely available, highly extensible ORB targeted for applications with real-time quality of service (QoS) requirements. These applications include avionics mission computers [14], telecommunication switch management systems <ref> [10] </ref>, and electronic medical imaging systems [15]. <p> How then can an ORB implementation decouple itself from a specific event demultiplexing mechanism and decouple its demultiplexing code from its handling code? Solution ! the Reactor pattern: An effective way to reduce coupling and increase the extensibility of an ORB Core is to apply the Reactor pattern <ref> [10] </ref>. This pattern supports synchronous demultiplexing and dispatching of multiple event handlers, which are triggered by events that can arrive concurrently from multiple sources. The Reactor pattern simplifies event-driven applications by integrating the demultiplexing of events and the dispatching of their corresponding event handlers. <p> In addition, the techniques required to robustly terminate servants that execute concurrently in multiple threads are complicated, non-portable, and nonintuitive. * Non-extensible: The choice of an ORB concurrency strategy depends largely on external factors like application requirements and network/endsystem characteristics. For instance, Reactive single-threading <ref> [10] </ref> is an appropriate strategy for short duration, compute-bound requests on a uniprocessor. If these external factors change, however, it is important that an ORB can be extended to handle alternative con-currency strategies such as thread-per-request, thread pool, or thread-per-priority.
Reference: [11] <author> R. G. Lavender and D. C. Schmidt, </author> <title> Active Object: an Ob ject Behavioral Pattern for Concurrent Programming, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien, J. Vlissides, and N. Kerth, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: Patterns help to alleviate the continual re-discovery and re-invention of software concepts and components by documenting proven solutions to standard software development problems [9]. For instance, patterns are useful for documenting the structure and participants in common communication software micro-architectures like Reactors [10], Active Objects <ref> [11] </ref>, and Brokers [12]. These patterns are generalizations of object-structures that have been used successfully to build flexible and efficient event-driven and concurrent communication software such as ORB middleware. <p> How then can an ORB support a simple, extensible, and portable concur-rency mechanism? Solution ! the Active Object pattern: An effective way to increase the portability, correctness, and extensibility of ORB concurrency strategies is to apply the Active Object pattern 7 <ref> [11] </ref>. This pattern provides a higher-level concurrency architecture that decouples (1) the thread that initially receives and processes a client request from (2) the thread that ultimately executes the request. While Wrapper Facades provide the basis for portability, they are simply a thin syntactic veneer over the low-level system APIs.
Reference: [12] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: Patterns help to alleviate the continual re-discovery and re-invention of software concepts and components by documenting proven solutions to standard software development problems [9]. For instance, patterns are useful for documenting the structure and participants in common communication software micro-architectures like Reactors [10], Active Objects [11], and Brokers <ref> [12] </ref>. These patterns are generalizations of object-structures that have been used successfully to build flexible and efficient event-driven and concurrent communication software such as ORB middleware. To focus the discussion, this article presents a case study that illustrates how we have applied patterns to develop The ACE ORB (TAO) [13].
Reference: [13] <author> D. C. Schmidt, D. L. Levine, and S. Mungee, </author> <title> The Design and Performance of Real-Time Object Request Brokers, </title> <journal> Computer Communications, </journal> <volume> vol. 21, </volume> <pages> pp. 294324, </pages> <month> Apr. </month> <year> 1998. </year>
Reference-contexts: These patterns are generalizations of object-structures that have been used successfully to build flexible and efficient event-driven and concurrent communication software such as ORB middleware. To focus the discussion, this article presents a case study that illustrates how we have applied patterns to develop The ACE ORB (TAO) <ref> [13] </ref>. TAO is a freely available, highly extensible ORB targeted for applications with real-time quality of service (QoS) requirements. These applications include avionics mission computers [14], telecommunication switch management systems [10], and electronic medical imaging systems [15]. <p> TAO's Object Adapter uses perfect hashing and active demultiplexing [20] optimizations to dispatch servant operations in constant O (1) time. ORB QoS Interface: TAO's QoS interface is designed to map real-time processing requirements to ORB endsys-tem/network resources <ref> [13] </ref>. Common real-time processing requirements include bounding end-to-end latency and meeting periodic scheduling deadlines. Common ORB endsys-tem/network resources include CPU, memory, network connections and storage devices. Real-time ORB Core: The ORB Core delivers client requests to the Object Adapter and returns responses (if any) to clients. <p> An ORB Core is not limited to running over IIOP and TCP transports, however. For instance, while TCP can transfer GIOP requests reliably, its flow control and congestion control algorithms may preclude its use as a real-time protocol <ref> [13] </ref>. Likewise, it may be more efficient to use a shared memory transport mechanism when clients and servants are co-located on the same endsystem. Thus, an ideal ORB Core must be flexible in its support of multiple transport mechanisms.
Reference: [14] <author> T. H. Harrison, D. L. Levine, and D. C. Schmidt, </author> <title> The De sign and Performance of a Real-time CORBA Event Service, </title> <booktitle> in Proceedings of OOPSLA '97, </booktitle> <address> (Atlanta, GA), </address> <publisher> ACM, </publisher> <month> October </month> <year> 1997. </year>
Reference-contexts: To focus the discussion, this article presents a case study that illustrates how we have applied patterns to develop The ACE ORB (TAO) [13]. TAO is a freely available, highly extensible ORB targeted for applications with real-time quality of service (QoS) requirements. These applications include avionics mission computers <ref> [14] </ref>, telecommunication switch management systems [10], and electronic medical imaging systems [15]. <p> It is important to develop ORBs that manage concurrent processing efficiently. Concurrency allows long-running operations to execute simultaneously without impeding the progress of other operations. Likewise, preemptive multi-threading is crucial to minimize the dispatch latency of real-time systems <ref> [14] </ref>. Problem: In many ORBs, the concurrency architecture is programmed directly using the OS platform's multi-threading API, such as the POSIX Pthreads API [28]. However, there are several drawbacks to this approach: * Non-portable: Threading APIs tend to be very platform-specific. <p> Application Concurrency Scheduling Demultiplexing Protocol Avionics Thread-per-priority Rate-based Perfect hashing VME backplane Medical Imaging Thread-per-connection FIFO Active demultiplexing TCP/IP Table 1: Example Applications and their ORB Strategy Configurations request demultiplexing strategies (e.g., perfect hashing vs. active demultiplexing [30]) and scheduling strategies (i.e., FIFO vs. rate monotonic vs. earliest deadline first <ref> [14] </ref>) in its Object Adapter, as well as connection management strategies (e.g., process-wide cached connections vs. thread-specific cached connections) and handler concurrency strategies (e.g., Reactive vs. variations of Active Objects) in its ORB Core. 3.7 Consolidate ORB Strategies Using the Ab stract Factory Pattern Context: There are many potential strategy variants <p> Table 1 shows a simple example of the strategies used to create two configurations of TAO. One is an avionics application with hard real-time requirements <ref> [14] </ref> and the other is an electronic medical imaging application [15] with high throughput requirements.
Reference: [15] <author> I. Pyarali, T. H. Harrison, and D. C. Schmidt, </author> <title> Design and Performance of an Object-Oriented Framework for High-Performance Electronic Medical Imaging, </title> <booktitle> USENIX Computing Systems, </booktitle> <volume> vol. 9, </volume> <month> November/December </month> <year> 1996. </year>
Reference-contexts: TAO is a freely available, highly extensible ORB targeted for applications with real-time quality of service (QoS) requirements. These applications include avionics mission computers [14], telecommunication switch management systems [10], and electronic medical imaging systems <ref> [15] </ref>. <p> Table 1 shows a simple example of the strategies used to create two configurations of TAO. One is an avionics application with hard real-time requirements [14] and the other is an electronic medical imaging application <ref> [15] </ref> with high throughput requirements. In general, the forces that must be resolved to compose all ORB strategies correctly are the need to (1) ensure the configuration of semantically compatible strategies and (2) simplify the management of a large number of individual strategies.
Reference: [16] <author> E. Eide, K. Frei, B. Ford, J. Lepreau, and G. Lindstrom, </author> <month> Flick: </month>
Reference-contexts: Conversely, skeletons demarshal the packet-level representation back into typed data that is meaningful to an application. An IDL compiler automatically transforms OMG IDL definitions into an application programming language like C++ or Java. IDL compilers eliminate common sources of network programming errors and provide opportunities for automated compiler optimizations <ref> [16] </ref>. Dynamic Invocation Interface (DII): The DII allows a client to access the underlying request transport mechanisms provided by the ORB Core. The DII is useful when an application has no compile-time knowledge of the interface it is accessing.
References-found: 16

