URL: ftp://ftp.cs.washington.edu/homes/chambers/hierarchy.ps.Z
Refering-URL: http://www.cs.washington.edu/research/projects/cecil/www/Papers/hierarchy.html
Root-URL: 
Email: -jdean,grove,chambers-@cs.washington.edu  
Title: O p t i m i a t i o n o f O b
Author: Jeffrey Dean, David Grove, and Craig Chambers 
Address: Seattle, WA 98195-2350 USA  
Affiliation: Department of Computer Science and Engineering University of Washington  
Date: August 1995.  
Note: Appeared in ECOOP95,  
Abstract: Optimizing compilers for object-oriented languages apply static class analysis and other techniques to try to deduce precise information about the possible classes of the receivers of messages; if successful, dynamically-dispatched messages can be replaced with direct procedure calls and potentially further optimized through inline-expansion. By examining the complete inheritance graph of a program, which we call class hierarchy analysis, the compiler can improve the quality of static class information and thereby improve run-time performance. In this paper we present class hierarchy analysis and describe techniques for implementing this analysis effectively in both statically and dynamically-typed languages and also in the presence of multi-methods. We also discuss how class hierarchy analysis can be supported in an interactive programming environment and, to some extent, in the presence of separate compilation. Finally, we assess the bottom-line performance improvement due to class hierarchy analysis alone and in combination with two other competing optimizations, profile-guided receiver class prediction and method specialization.
Abstract-found: 1
Intro-found: 1
Reference: [Agesen & Hlzle 95] <author> Ole Agesen and Urs Hlzle. </author> <title> Type Feedback vs. Concrete Type Analysis: A Comparison of Optimization Techniques for Object-Oriented Languages. </title> <type> Technical Report TRCS 95-04, </type> <institution> Department of Computer Science, University of California, Santa Barbara, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Agesen and Hlzle have compared the effectiveness of profile-guided receiver class prediction alone to interprocedural class analysis alone for a suite of small-to-medium sized Self programs, but they did not report on the effectiveness of combining the two techniques <ref> [Agesen & Hlzle 95] </ref>. 5 Conclusions Class hierarchy analysis is a promising technique for eliminating dynamically-dispatched message sends automatically.
Reference: [Agesen e t a l . 93] <author> Ole Agesen, Jens Palsberg, and Michael I. Schwartzback. </author> <title> Type Inference of SELF: Analysis of Objects with Dynamic and Multiple Inheritance. </title> <booktitle> In Proceedings ECOOP 93, </booktitle> <month> July </month> <year> 1993. </year>
Reference: [Agrawal e t a l . 91] <author> Rakesh Agrawal, Linda G. DeMichiel, and Bruce G. Lindsay. </author> <title> Static Type Checking of Multi-Methods. </title> <booktitle> In Proceedings OOPSLA 91, </booktitle> <pages> pages 113128, </pages> <month> November </month> <year> 1991. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 26, number 11. </volume>
Reference: [AK e t a l . 89] <author> Hassan At-Kaci, Robert Boyer, Patrick Lincoln, and Roger Nasr. </author> <title> Efficient Implementation of Lattice Operations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(1):115146, </volume> <month> January </month> <year> 1989. </year>
Reference: [Bobrow e t a l . 88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, and D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> SIGPLAN Notices, 28(Special Issue), </journal> <month> September </month> <year> 1988. </year>
Reference: [Calder & Grunwald 94] <author> Brad Calder and Dirk Grunwald. </author> <title> Reducing Indirect Function Call Overhead in C++ Programs. </title> <booktitle> In Conference Record of POPL 94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, </booktitle> <pages> pages 397408, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: The profile information representing the expected receiver class distribution of particular messages or call sites can be hard-wired into the compiler [Deutsch & Schiffman 84, Chambers e t a l . 89], gathered and exploited on-line [Hlzle & Ungar 94], and/or gathered off-line and exploited via recompilation <ref> [Garrett e t a l . 94, Calder & Grunwald 94] </ref>. Method specialization can produce faster specialized versions of a method for particular inheriting subclasses; each specialized version can be optimized for the particular class or classes of the receiver for which the method is being specialized.
Reference: [Caseau 93] <author> Yves Caseau. </author> <title> Efficient Handling of Multiple Inheritance Hierarchies. </title> <booktitle> In Proceedings OOPSLA93, </booktitle> <pages> pages 271287, </pages> <month> October </month> <year> 1993. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 28, number 10. </volume>
Reference: [Chambers & Ungar 89] <author> Craig Chambers and David Ungar. </author> <title> Customization: Optimizing Compiler Technology for Self, A Dynamically-Typed Object-Oriented Programming Language. </title> <journal> SIGPLAN Notices, </journal> <volume> 24(7):146160, </volume> <month> July </month> <year> 1989. </year> <booktitle> In Proceedings of the ACM SIGPLAN 89 Conference on Programming Language Design and Implementation. </booktitle>
Reference: [Chambers & Ungar 90] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <journal> SIGPLAN Notices, </journal> <volume> 25(6):150164, </volume> <month> June </month> <year> 1990. </year> <booktitle> In Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Previous frameworks for static class analysis in dynamically-typed object-oriented languages have defined several representations for sets of classes <ref> [Chambers & Ungar 90] </ref>: Earlier frameworks focused on the singleton class set as the primary source of optimization: if the receiver of a message is a singleton class set, then the message lookup can be resolved at compile-time and replaced with a direct procedure call to the target method. <p> To measure the impact of class hierarchy analysis, we compiled the benchmark programs using the following set of compiler optimizations: unopt: No optimizations. std: Standard static intraprocedural analyses, including iterative intraprocedural class analysis, inlining, hard-wired class prediction for a small set of common messages, closure optimizations, extended splitting <ref> [Chambers & Ungar 90] </ref> and other standard intraprocedural optimizations such as CSE, constant folding and propagation, and dead code elimination. cha-ct-only: Standard (std) augmented by a limited usage of class hierarchy analysis.
Reference: [Chambers & Ungar 91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object Oriented Languages Practical. </title> <booktitle> In Proceedings OOPSLA 91, </booktitle> <pages> pages 115, </pages> <month> November </month> <year> 1991. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 26, number 11. </volume>
Reference-contexts: compiles by a factor of seven over a coarser-grained C++-style header file scheme, in the presence of class hierarchy analysis, and by a factor of two Cone (C) BitSet Method Set Applies-To Tuples Lookup Cache Entry Compiled Code . . . over the Self compilers previous state-of-the-art fine-grained dependency mechanism <ref> [Chambers & Ungar 91] </ref>. Of course, more recompilation occurs in the presence of class hierarchy analysis than would occur without it, but for these traces the number of files recompiled after a programming change is often no more than the number of files directly modified by the changes.
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Proceedings ECOOP 92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 33 56, </pages> <address> Utrecht, The Netherlands, July 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: We measure the run-time performance benefit and compile-time cost of class hierarchy analysis on several large programs written in Cecil <ref> [Chambers 92, Chambers 93] </ref>, a pure object-oriented language with multi-methods. Moreover, we also measure the run-time performance benefits and compile-time costs of profile-guided receiver class prediction and method specialization separately and in combination with class hierarchy analysis.
Reference: [Chambers 93] <author> Craig Chambers. </author> <title> The Cecil Language: Specification and Rationale. </title> <type> Technical Report TR-93-03-05, </type> <institution> Department of Computer Science and Engineering. University of Washington, </institution> <month> March </month> <year> 1993. </year>
Reference-contexts: We measure the run-time performance benefit and compile-time cost of class hierarchy analysis on several large programs written in Cecil <ref> [Chambers 92, Chambers 93] </ref>, a pure object-oriented language with multi-methods. Moreover, we also measure the run-time performance benefits and compile-time costs of profile-guided receiver class prediction and method specialization separately and in combination with class hierarchy analysis.
Reference: [Chambers e t a l . 89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An Efficient Implementation of SELF a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In Proceedings OOPSLA 89, </booktitle> <pages> pages 4970, </pages> <month> October </month> <year> 1989. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 24, number 10. </volume>
Reference-contexts: The profile information representing the expected receiver class distribution of particular messages or call sites can be hard-wired into the compiler <ref> [Deutsch & Schiffman 84, Chambers e t a l . 89] </ref>, gathered and exploited on-line [Hlzle & Ungar 94], and/or gathered off-line and exploited via recompilation [Garrett e t a l . 94, Calder & Grunwald 94].
Reference: [Chambers e t a l . 95] <author> Craig Chambers, Jeffrey Dean, and David Grove. </author> <title> A Framework for Selective Recompilation in the Presence of Complex Intermodule Dependencies. </title> <booktitle> In 17th International Conference on Software Engineering, </booktitle> <address> Seattle, WA, </address> <month> April </month> <year> 1995. </year>
Reference-contexts: In previous work, we have developed a framework for maintaining intermodule dependency information <ref> [Chambers e t a l . 95] </ref>. This framework is effective at representing the compilation dependencies introduced by class hierarchy analysis. In the dependency framework, intermodule dependencies are represented by a directed, acyclic graph structure. <p> The size of the dependency graph is about half as large as the executable for the program being compiled, which is acceptable in our program development environment; coarser-grained dependency graphs could be devised that save space at the cost of reduced selectivity. Further details are available elsewhere <ref> [Chambers e t a l . 95] </ref>. 2.4 Optimization of Incomplete Programs Class hierarchy analysis is most effective in situations where the compiler has access to the source code of the entire program, since the whole inheritance hierarchy can be examined and the locations of all method definitions can be determined;
Reference: [Dean e t a l . 95] <author> Jeffrey Dean, Craig Chambers, and David Grove. </author> <title> Selective Specialization for Object-Oriented Languages. </title> <journal> SIGPLAN Notices, </journal> <month> June </month> <year> 1995. </year> <booktitle> In Proceedings of the ACM SIGPLAN 95 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Specializations for a given source method can be produced obliviously for each inheriting subclass [Kilian 88, Chambers & Ungar 89, Lea 90, Lim & Stolcke 91] or they can be produced selectively for groups of inheriting subclasses guided by execution frequency profiles <ref> [Dean e t a l . 95] </ref>. Class hierarchy analysis is another idea for speeding messages. When the compiler compiles a method, it knows statically that the receiver of the method is some subclass S of the class C containing the method. <p> In previous work, we have developed a profile-guided algorithm that examines the potential targets of sends in a routine and derives a set of profitable specializations based on where in the class hierarchy these target routines are defined <ref> [Dean e t a l . 95] </ref>. This specialization algorithm detects call sites where class hierarchy analysis is insufficient to statically-bind message sends, and produces versions of methods specialized to truncated cones of the class hierarchy. <p> class hierarchy analysis for only the first receiver, to compare against cust-1. cust+cha: Standard augmented with both cust-k and class hierarchy analysis. selective: Standard augmented with class hierarchy analysis and a selective specialization algorithm that combines a profile-derived weighted call graph and class hierarchy analysis to select candidates for specialization <ref> [Dean e t a l . 95] </ref>. the benchmark programs compiled with these seven configurations. As expected, in most cases customization had a larger impact than class hierarchy analysis, speeding up programs by 48% to 87%. Combining class hierarchy analysis and naive customization (cust+cha) yielded only small additional benefits.
Reference: [Deutsch & Schiffman 84] <author> L. Peter Deutsch and Allan M. Schiffman. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297302, </pages> <address> Salt Lake City, Utah, </address> <month> January </month> <year> 1984. </year>
Reference-contexts: The profile information representing the expected receiver class distribution of particular messages or call sites can be hard-wired into the compiler <ref> [Deutsch & Schiffman 84, Chambers e t a l . 89] </ref>, gathered and exploited on-line [Hlzle & Ungar 94], and/or gathered off-line and exploited via recompilation [Garrett e t a l . 94, Calder & Grunwald 94].
Reference: [Dyl92] <author> Dylan, </author> <title> an Object-Oriented Dynamic Language, </title> <month> April </month> <year> 1992. </year> <institution> Apple Computer. </institution>
Reference-contexts: In a similar vein, Trellis [Schaffert e t a l . 85, Schaffert e t a l . 86] allows a class to be declared with the no_subtypes annotation and Dylan <ref> [Dyl92] </ref> allows a class to be sealed, both of which inform the compiler that no subclasses exist. These annotations allow the compiler to treat the class as a leaf class and compile all messages sent to objects statically known to be of the class as direct procedure calls.
Reference: [Fernandez 95] <author> Mary Fernandez. </author> <title> Simple and Effective Link-time Optimization of Modula-3 Programs. </title> <journal> SIGPLAN Notices, </journal> <month> June </month> <year> 1995. </year> <booktitle> In Proceedings of the ACM SIGPLAN 95 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: Static binding alone still provides significant performance improvements, particularly on modern RISC processors, where dynamically-dispatched message send implementations stall the hardware pipeline. Furthermore, some optimizing linkers are able to optimize static calls by inlining the target routines machine code at link time <ref> [Fernandez 95] </ref>, although the resulting code is not as optimized as what could be done in the compiler. Using class hierarchy analysis when compiling a library in isolation is more difficult, since the client program might create subclasses of library classes that override methods defined in the library. <p> Recent work by Fernandez has investigated using link-time optimization of Modula-3 programs to convert dynamic dispatches to statically bound calls when no overriding methods were defined <ref> [Fernandez 95] </ref>. This optimization is similar to class hierarchy analysis. An advantage of performing optimizations at link-time is that, because the optimizations operate on machine code, they can be applied to the whole program, including libraries for which source code is unavailable. However, there are two drawbacks of link-time optimizations.
Reference: [Gabriel e t a l . 91] <author> Richard P. Gabriel, Jon L. White, and Daniel G. Bobrow. </author> <title> CLOS: Integrating Object-Oriented and Functional Programming. </title> <journal> Communications of the ACM, </journal> <volume> 34(9):2838, </volume> <month> September </month> <year> 1991. </year>
Reference: [Garrett e t a l . 94] <author> Charlie Garrett, Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Measurement and Application of Dynamic Receiver Class Distributions. </title> <type> Technical Report UW-CS 94-03-05, </type> <institution> University of Washington, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: The profile information representing the expected receiver class distribution of particular messages or call sites can be hard-wired into the compiler [Deutsch & Schiffman 84, Chambers e t a l . 89], gathered and exploited on-line [Hlzle & Ungar 94], and/or gathered off-line and exploited via recompilation <ref> [Garrett e t a l . 94, Calder & Grunwald 94] </ref>. Method specialization can produce faster specialized versions of a method for particular inheriting subclasses; each specialized version can be optimized for the particular class or classes of the receiver for which the method is being specialized.
Reference: [Harbison 92] <author> Samuel P. Harbison. </author> <title> Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: For example, hybrid languages like C++ [Stroustrup 91], Modula-3 <ref> [Nelson 91, Harbison 92] </ref>, and CLOS [Bobrow e t a l. 88, Gabriel e t a l. 91] provide non-object-oriented built-in array data structures that are more efficient than would be a typical class-based extensible implementation using dynamically-dispatched fetch and store operations, Sather [Omohundro 94, Szypersky e t a l .
Reference: [Hlzle & Ungar 94] <author> Urs Hlzle and David Ungar. </author> <title> Optimizing Dynamically Dispatched Calls with Run-Time Type Feedback. </title> <journal> SIGPLAN Notices, </journal> <volume> 29(6):326 336, </volume> <month> June </month> <year> 1994. </year> <booktitle> In Proceedings of the ACM SIGPLAN 94 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: The profile information representing the expected receiver class distribution of particular messages or call sites can be hard-wired into the compiler [Deutsch & Schiffman 84, Chambers e t a l . 89], gathered and exploited on-line <ref> [Hlzle & Ungar 94] </ref>, and/or gathered off-line and exploited via recompilation [Garrett e t a l . 94, Calder & Grunwald 94].
Reference: [Hlzle 94] <author> Urs Hlzle. </author> <title> Adaptive Optimization for Self: Reconciling High Performance with Exploratory Programming. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: It is unclear whether or not adding class hierarchy analysis to a system that already performs profile-guided receiver class prediction would result in any significant improvements <ref> [Hlzle 94] </ref>.
Reference: [Johnson 92] <author> Ralph Johnson. </author> <title> Documenting Frameworks Using Patterns. </title> <booktitle> In Proceedings OOPSLA 92, </booktitle> <pages> pages 6376, </pages> <month> October </month> <year> 1992. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 27, number 10. </volume>
Reference-contexts: 1 Introduction Object-oriented languages foster the development of reusable, extensible class libraries and frameworks <ref> [Johnson 92] </ref>. For example, the InterViews graphics framework [Linton et al. 89] defines a collection of interacting base classes. The base classes define a set of messages that are to be defined or overridden in subclasses.
Reference: [Kilian 88] <author> Michael F. Kilian. </author> <title> Why Trellis/Owl Runs Fast. </title> <type> Unpublished manuscript, </type> <month> March </month> <year> 1988. </year>
Reference: [Lea 90] <editor> Doug Lea. Customization in C++. </editor> <booktitle> In Proceedings of the 1990 Usenix C++ Conference, </booktitle> <address> San Francisco, CA, </address> <month> April </month> <year> 1990. </year>
Reference: [Lim & Stolcke 91] <author> Chu-Cheow Lim and Andreas Stolcke. </author> <title> Sather Language Design and Performance Evaluation. </title> <type> Technical Report TR 91-034, </type> <institution> International Computer Science Institute, </institution> <month> May </month> <year> 1991. </year>
Reference: [Linton e t a l . 89] <author> M. A. Linton, J. M. Vlissides, and P. R. Calder. </author> <title> Composing User Interfaces with InterViews. </title> <journal> IEEE Computer, </journal> <volume> 2(2):822, </volume> <month> February </month> <year> 1989. </year>
Reference: [Nelson 91] <author> Greg Nelson. </author> <title> Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: For example, hybrid languages like C++ [Stroustrup 91], Modula-3 <ref> [Nelson 91, Harbison 92] </ref>, and CLOS [Bobrow e t a l. 88, Gabriel e t a l. 91] provide non-object-oriented built-in array data structures that are more efficient than would be a typical class-based extensible implementation using dynamically-dispatched fetch and store operations, Sather [Omohundro 94, Szypersky e t a l .
Reference: [Omohundro 94] <author> Stephen Omohundro. </author> <title> The Sather 1.0 Specification. </title> <booktitle> Unpublished manuscript from International Computer Science Institute, </booktitle> <address> Berkeley, CA, </address> <year> 1994. </year>
Reference-contexts: hybrid languages like C++ [Stroustrup 91], Modula-3 [Nelson 91, Harbison 92], and CLOS [Bobrow e t a l. 88, Gabriel e t a l. 91] provide non-object-oriented built-in array data structures that are more efficient than would be a typical class-based extensible implementation using dynamically-dispatched fetch and store operations, Sather <ref> [Omohundro 94, Szypersky e t a l . 93] </ref> allows the programmer to explicitly select where subtype polymorphism is allowed, trading away reusability for performance, and it is common practice in C++ programming to avoid virtual function calls along common execution paths, sometimes leading to contorted, hard-to-understand and hard-to-extend code.
Reference: [Oxhj e t a l . 92] <author> Nicholas Oxhj, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Making Type Inference Practical. </title> <editor> In O. Lehrmann Madsen, editor, </editor> <booktitle> Proceedings ECOOP 92, </booktitle> <volume> LNCS 615, </volume> <pages> pages 329349, </pages> <address> Utrecht, The Netherlands, July 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference: [Palsberg & Schwartzbach 91] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object Oriented Type Inference. </title> <booktitle> In Proceedings OOPSLA 91, </booktitle> <pages> pages 146161, </pages> <month> November </month> <year> 1991. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 26, number 11. </volume>
Reference: [Palsberg & Schwartzbach 94] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object Oriented Type Systems. </title> <publisher> John Wiley & Sons, </publisher> <year> 1994. </year>
Reference-contexts: of the class C, including C class hierarchy anal-ysis of method receiver; static type declarations supports static bind-ing of sends Class (C) representation rather than Cone (C) if C is a leaf class. (This framework for representing static class analysis information is similar to Palsberg and Schwartzbachs static type system <ref> [Palsberg & Schwartzbach 94] </ref>.) Cones tend to be concise summaries of sets of classes: in our implementation, when compiling a 52,000-line benchmark program with 957 classes, the average cone used for optimization purposes contained 12 concrete classes, and some cones included as many as 93 concrete classes.
Reference: [Plevyak & Chien 94] <author> John Plevyak and Andrew A. Chien. </author> <title> Precise Concrete Type Inference for Object-Oriented Languages. </title> <booktitle> In Proceedings OOPSLA 94, </booktitle> <pages> pages 324340, </pages> <address> Portland, Oregon, </address> <month> October </month> <year> 1994. </year>
Reference: [Schaffert e t a l . 85] <author> Craig Schaffert, Topher Cooper, and Carrie Wilpolt. </author> <title> Trellis Object-Based Environment, Language Reference Manual. </title> <type> Technical Report DEC-TR-372, </type> <institution> Digital Equipment Corporation, </institution> <month> November </month> <year> 1985. </year>
Reference: [Schaffert e t a l . 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Killian, and Carrie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In Proceedings OOPSLA 86, </booktitle> <pages> pages 916, </pages> <month> November </month> <year> 1986. </year> <journal> Published as ACM SIGPLAN Notices, </journal> <volume> volume 21, number 11. </volume>
Reference: [Srivastava 92] <author> Amitabh Srivastava. </author> <title> Unreachable Procedures in Object-Oriented Programming. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(4):355 364, </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: In contrast, class hierarchy analysis coupled with a selective invalidation mechanism supports incremental recompilation, fast linking, and compile-time optimization of call sites where source code of target methods is available. Srivastava has developed an algorithm to prune unreachable procedures from C++ programs at link-time <ref> [Srivastava 92] </ref>. Although the described algorithm is only used to prune code and not to optimize dynamic dispatches, it would be relatively simple to convert some virtual function calls into direct procedure calls using the basic infrastructure used to perform the procedure pruning.
Reference: [Stroustrup 91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language (second edition). </title> <address> Addision-Wesley, Reading, MA, </address> <year> 1991. </year>
Reference-contexts: However, in other domains, such as basic data structure libraries, numerical computing packages, rendering libraries, and trace-driven simulation frameworks, the cost of message passing can be too great, forcing the programmer to avoid object-oriented programming in the hot spots of their application. For example, hybrid languages like C++ <ref> [Stroustrup 91] </ref>, Modula-3 [Nelson 91, Harbison 92], and CLOS [Bobrow e t a l. 88, Gabriel e t a l. 91] provide non-object-oriented built-in array data structures that are more efficient than would be a typical class-based extensible implementation using dynamically-dispatched fetch and store operations, Sather [Omohundro 94, Szypersky e t
Reference: [Szypersky e t a l . 93] <author> Clemens Szypersky, Stephen Omohundro, and Stephan Murerzw. </author> <title> Engineering a Programming Language: The Type and Class System of Sather. </title> <type> Technical Report 93-064, </type> <institution> International Computer Science Institute, Berkeley, </institution> <address> CA, </address> <year> 1993. </year>
Reference-contexts: hybrid languages like C++ [Stroustrup 91], Modula-3 [Nelson 91, Harbison 92], and CLOS [Bobrow e t a l. 88, Gabriel e t a l. 91] provide non-object-oriented built-in array data structures that are more efficient than would be a typical class-based extensible implementation using dynamically-dispatched fetch and store operations, Sather <ref> [Omohundro 94, Szypersky e t a l . 93] </ref> allows the programmer to explicitly select where subtype polymorphism is allowed, trading away reusability for performance, and it is common practice in C++ programming to avoid virtual function calls along common execution paths, sometimes leading to contorted, hard-to-understand and hard-to-extend code.
References-found: 39

