URL: http://iacoma.cs.uiuc.edu/iacoma-papers/augmint/augmint.ps
Refering-URL: http://iacoma.cs.uiuc.edu/iacoma/augmint.html
Root-URL: http://www.cs.uiuc.edu
Email: farsharma,anguyen,torrellag@csrd.uiuc.edu  michael@cs.rochester.edu  carbajal@ssd.intel.com  
Title: Augmint A Multiprocessor Simulation Environment for Intel x86 architectures 1  
Author: Arun Sharma, Anthony-Trung Nguyen and Josep Torrellas Maged Michael John Carbajal 
Note: 1 Thanks to Dave Archer, Intel Corporation  
Date: March 28, 1996  
Address: Urbana, IL 61081  Rochester, NY 14627  Beaverton, OR  
Affiliation: Center for Supercomputing Research and Development, University of Illinois at Urbana-Champaign,  Department of Computer Science, University of Rochester,  Scalable systems division, Intel Corporation,  
Pubnum: CSRD Technical Report 1463  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> Jack E. Veenstra and Robert J. Fowler. </author> <title> MINT Tutorial and User Manual, </title> <type> Technical Report 452, </type> <institution> The University of Rochester, Computer Science Department, </institution> <month> August </month> <year> 1994. </year>
Reference-contexts: 1 Thanks to Dave Archer, Intel Corporation Abstract Augmint is a fast execution driven multiprocessor simulator for Intel x86 architectures. It is based on MINT <ref> [1] </ref>, but provides a user interface similar to that of Tangolite [2]. For the sake of simulation speed, processors are modelled as user level threads. <p> One is based on interpreting the machine instructions and making calls to the memory system simulator on memory references. This approach in general is very slow, since interpreting one machine instruction takes 10 to 100 times more time than executing it natively. However, some simulators like MINT <ref> [1] </ref> have taken a hybrid approach by executing straight line pieces of code, without memory references natively and interpreting instructions with memory references. 1 A more common approach is to augment the code, that is, to insert ad-ditional instructions at the memory reference points to drive the simulator. <p> Doctor, the augmenter, which takes as input an x86 assembly language file, inserts additional code at basic block beginnings and at memory reference points to drive the simulator and outputs an aug mented assembly language file. * The threads package: Large parts of the threads package from its predecessor MINT <ref> [1] </ref> remain unchanged. The most significant changes 2 are due to, changing the object code interpretation to compile time assembly language instrumentation. * The user interface: The simulator can be roughly divided into a front end and a back end. <p> The front end simulates the execution of multiple processes running on multiple processors in parallel and generates certain events of interest. The back end is user-defined and invoked every time a significant event occurs. This interface is exactly the same as that provided by MINT <ref> [1] </ref>. 1.4 Usage There are several steps involved in building the executable, as shown in macro library c.m4.augmint. A C compiler, in our case the GCC, compiles the resulting C code into x86 assembly code. In the next step, Doctor, the augmenter inserts appropriate code into the assembly file. <p> When there are no more tasks, the simulation ends. Threads are passive entities and one or more tasks are scheduled on their behalf. The user-defined backend may also create new tasks to handle the events. The MINT <ref> [1] </ref> user's guide deals with this topic in more detail. 1.7 The backend We have provided a very simple example backend along with the simulator. <p> A Windows NT 5 port is currently being worked on. Augmint combines the good features of both MINT <ref> [1] </ref> and Tangolite [2] and provides a software simulation environment that is fast, flexible and accurate. 4 Solaris is a trademark of Sun Microsystems Incorporated. 5 Windows NT is a trademark of Microsoft Corporation. 6 Appendix A Doctor A.0.1 Commandline doctor [ -cgV ] [ assembly-language-file ] A.0.2 Description Doctor is
Reference: [2] <author> Stephen R. Goldschmidt. </author> <title> Simulation of Multiprocessors: Accuracy and Performance, </title> <type> PhD Thesis, </type> <institution> Stanford University, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: 1 Thanks to Dave Archer, Intel Corporation Abstract Augmint is a fast execution driven multiprocessor simulator for Intel x86 architectures. It is based on MINT [1], but provides a user interface similar to that of Tangolite <ref> [2] </ref>. For the sake of simulation speed, processors are modelled as user level threads. <p> This approach has been used in Proteus [6], Tangolite <ref> [2] </ref> and Augmint. Such instrumentation can be done both at the executable level and the assembly level. Each method has its advantages and disadvantages. <p> A Windows NT 5 port is currently being worked on. Augmint combines the good features of both MINT [1] and Tangolite <ref> [2] </ref> and provides a software simulation environment that is fast, flexible and accurate. 4 Solaris is a trademark of Sun Microsystems Incorporated. 5 Windows NT is a trademark of Microsoft Corporation. 6 Appendix A Doctor A.0.1 Commandline doctor [ -cgV ] [ assembly-language-file ] A.0.2 Description Doctor is a 80x86 assembly
Reference: [3] <author> Stephen Alan Herrod. Tangolite: </author> <title> A Multiprocessor Simulation Environment, </title> <institution> Stanford University, </institution> <year> 1993. </year>
Reference: [4] <author> Stephen R. Goldschmidt and Helen Davis. </author> <title> Tango introduction and tutorial. </title> <type> Technical report CSL 40-910, </type> <institution> Stanford University, </institution> <month> January </month> <year> 1990. </year>
Reference: [5] <author> Stephen R. Goldschmidt and John L. Hennessy. </author> <title> The Accuracy Of Trace-driven Simulations Of Multiprocessors Stanford University technical report: </title> <address> CSL-TR-92-546, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: Moreover, a simulator is also expected to be non-interfering, in order to get highly accurate results. By spending a lot of time in simulating the system, in a great level of detail, the timing accuracy of the simulator is compromised. Goldschmidt and Hennessy <ref> [5] </ref> deal with these issues at length. Augmint deviates from the past work mainly in shifting the focus to CISC architectures. Most of the increased complexity was in writing the augmenter Doctor which now recognizes the complex and even implicit memory references in the Intel x86 assembly code.
Reference: [6] <author> Brewer, Eric A. Proteus: </author> <title> a high-performance parallel-architecture, </title> <institution> MIT. Lab. for Computer Science MIT/LCS/TR 516, </institution> <month> September </month> <year> 1991. </year>
Reference-contexts: This approach has been used in Proteus <ref> [6] </ref>, Tangolite [2] and Augmint. Such instrumentation can be done both at the executable level and the assembly level. Each method has its advantages and disadvantages. <p> Currently, a lot of time is spent on updating the simulated clock, which is represented as a double. Such an update is done at the end of each basic block and before entering the simulator thread. A possible optimization, discussed in the Proteus <ref> [6] </ref> user's guide, is to merge basic blocks together into bigger basic blocks wherever possible.
Reference: [7] <author> James R. Larus and Eric Schnarr. EEL: </author> <booktitle> Machine-Independent Executable Editing (SIGPLAN '95 Conference on Programming Languages Design and Impelementation (PLDI), </booktitle> <month> June </month> <year> 1995). </year>
Reference-contexts: On the other hand, instrumenting the executable, as has been done in the case of EEL <ref> [7] </ref> on the other hand does not suffer from this disadvantage. However, it needs a recomputation of the jump targets and labels.
Reference: [8] <author> Steven K. Reinhardt, Mark D. Hill, James R. Larus, Alvin R. Lebeck, James C. Lewis, David A. Wood. </author> <title> The Wisconsin Wind Tunnel: Virtual Prototyping of Parallel Computers, </title> <booktitle> (ACM SIGMETRICS, </booktitle> <month> May </month> <year> 1993). </year>
Reference-contexts: Finally, we examine trap driven simulation. In this approach, traps are set on memory locations by making use of error correction codes and the simulator takes control only during the traps. This approach has been used in WWT <ref> [8] </ref> and Tapeworm [9]. The advantage of trap driven simulation is that memory reference events, that do not miss in the simulated memory hierarchy do not cause a trap. As a result, the simulation is faster.
Reference: [9] <author> R. Uhlig, D. Nagle, T. Mudge, and S. Sechrest. </author> <title> "Trap-driven simulation with Tapeworm II," </title> <booktitle> 6th Int. Conf. on Architectural Support for Programming Languages and Operating Systems (ASPLOS-VI), </booktitle> <month> Oct. </month> <year> 1994, </year> <pages> pp. 132-144. </pages>
Reference-contexts: Finally, we examine trap driven simulation. In this approach, traps are set on memory locations by making use of error correction codes and the simulator takes control only during the traps. This approach has been used in WWT [8] and Tapeworm <ref> [9] </ref>. The advantage of trap driven simulation is that memory reference events, that do not miss in the simulated memory hierarchy do not cause a trap. As a result, the simulation is faster. However, since this approach is heavily dependent on the underlying architecture, it can not be used universally.
Reference: [10] <institution> Pentium processor manual 10 </institution>
Reference-contexts: Further, depending on the length of simulation time, the user may choose to use a smaller data type for the clock, to improve the simulation speed. 2 The default values have been taken from the Pentium processor manual <ref> [10] </ref> 3 Stack references are not augmented. 5 1.6 The threads package The threads package consists of a simulator thread, which initially schedules one application thread, viz appl main. When the initial application thread runs, it creates more threads.
References-found: 10

