URL: file://dream.dai.ed.ac.uk/pub/papers/PS/reln-ripp.ps.gz
Refering-URL: http://www.dai.ed.ac.uk:80/staff/personal_pages/bundy/projects/95-96/msc-project-proposal-reln-ripp.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Relational Rippling: A General Approach of a multiple phase process: typical proofs consist of mixed
Author: Vincent Lombart Alan Bundy 
Note: Relational rippling is often part  have been tested.  
Date: December 13, 1995  
Abstract: We propose a new version of rippling, called relational rippling. Rippling is a heuristic for guiding proof search, especially in the step cases of inductive proofs. Relational rippling is designed for representations in which value passing is by shared existential variables, as opposed to function nesting. Thus relational rippling can be used to guide reasoning about logic programs or circuits represented as relations. fl The first author is supported by the Belgian National Fund for Scientific Research, and his stay in Edinburgh is supported by HC&M Logic Program Synthesis and Transformation. Part of the research reported in this paper was conducted while the second author was a visitor at the Max Planck Institut fur Informatik in Saarbrucken. He would like to thank his hosts, Harald Ganzinger and David Basin for inviting him to MPI and making his stay so pleasant. We would also like to thank David Basin, Toby Walsh, Helen Lowe, Julian Richardson and members of the mathematical reasoning group at Edinburgh for discussions about earlier versions of the ideas described here. This work is part of a project supported by SERC grant GR/H/23610, ESPRIT BRP grant 6810 and ARC grant 438. 
Abstract-found: 1
Intro-found: 1
Reference: [ -Ahs & Wiggins, 1994] <author> -Ahs, T. and Wiggins, G. A., </author> <year> (1994). </year> <title> Relational rippling for logic program synthesis and transformation, </title> <note> Presented at the Fourth International Workshop on Logic Program Synthesis and Transformation; available as DAI research paper, forthcoming. [ -Ahs, 1995] -Ahs, </note> <author> T., </author> <year> (1995). </year> <note> Relational rippling (working title), Ph.L. Thesis, </note> <institution> Computing Science Department, Uppsala University, Swedn. </institution>
Reference: [Basin & Walsh, 1993] <author> Basin, D. and Walsh, T. </author> <year> (1993). </year> <title> Difference unification. </title> <booktitle> In Proceedings of the 13th IJCAI. International Joint Conference on Artificial 27 Intelligence. </booktitle> <institution> Also available as Technical Report MPI-I-92-247, Max--Planck-Institute fur Informatik. </institution>
Reference-contexts: It appears to be useful whenever a problem can be solved by reducing a syntactic difference between it and some previously solved problem. Rippling works by identifying the syntactic difference between the current problem and the previous one, <ref> [Basin & Walsh, 1993] </ref>, and then moving that difference through nested functions to a place where it no longer prevents a match between them. Following Boyer and Moore, [Boyer & Moore, 1979], this matching process is called fertilization. <p> This function is preventing matching the hypothesis against the goal. In inductive proofs, for instance, s 1 might be a step function inserted in the induction conclusion by the induction rule. To initialise rippling, the two formulae are difference matched, <ref> [Basin & Walsh, 1993] </ref>. We represent the resulting by annotating the goal. Those parts of the goal which differ from the hypothesis are put in boxes with a directional arrow. These are called wave-fronts. Any sub-expressions within these wave-fronts that do match the hypothesis are underlined. These are called wave-holes.
Reference: [Boyer & Moore, 1979] <author> Boyer, R. S. and Moore, J S. </author> <year> (1979). </year> <title> A Computational Logic. </title> <publisher> Academic Press, ACM monograph series. </publisher>
Reference-contexts: Rippling works by identifying the syntactic difference between the current problem and the previous one, [Basin & Walsh, 1993], and then moving that difference through nested functions to a place where it no longer prevents a match between them. Following Boyer and Moore, <ref> [Boyer & Moore, 1979] </ref>, this matching process is called fertilization. Rippling is predicated on the assumption that value passing is done via function nesting. But there is a popular alternative technique for value-passing: via existentially quantified shared variables. This is the technique used, for instance, in logic programming.
Reference: [Bundy & Welham, 1981] <author> Bundy, Alan and Welham, B. </author> <year> (1981). </year> <title> Using meta-level inference for selective application of multiple rewrite rules in algebraic manipulation. </title> <journal> Artificial Intelligence, </journal> <volume> 16(2) </volume> <pages> 189-212. </pages> <note> Also available from Edinburgh as DAI Research Paper 121. </note>
Reference-contexts: The only problem left is the choice of the existential variables to put in the wave-fronts, but that is easily derived from the wave-rule itself. Another way we have explored is a method similar to attraction in PRESS, <ref> [Bundy & Welham, 1981] </ref>. What links all the sub-expressions we want to gather together is one or more shared variables. Attraction was designed to bring together occurrences of some distinguished variables, and could thus be used.
Reference: [Bundy, 1988] <author> Bundy, Alan. </author> <year> (1988). </year> <title> The use of explicit plans to guide inductive proofs. </title> <editor> In Lusk, R. and Overbeek, R., (eds.), </editor> <booktitle> 9th Conference on Automated Deduction, </booktitle> <pages> pages 111-120. </pages> <note> Springer-Verlag. Longer version available from Edinburgh as DAI Research Paper No. 349. </note>
Reference-contexts: Purely relational phases, which we will call rippling-past are connected with functional phases by hybrid rippling, which involves the transfer from one type of value passing to the other. Our goal is to implement relational rippling in a proof planning environment, <ref> [Bundy, 1988] </ref>. Rippling-past is already implemented, as well as simple forms of hybrid rippling, but the latter still has to be implemented in its generality.
Reference: [Bundy et al, 1990] <author> Bundy, Alan, van Harmelen, F., Horn, C. and Smaill, A. </author> <year> (1990). </year> <title> The Oyster-Clam system. </title> <editor> In Stickel, M. E., (ed.), </editor> <booktitle> 10th International Conference on Automated Deduction, </booktitle> <pages> pages 647-648. </pages> <note> Springer-Verlag. Lecture Notes in Artificial Intelligence No. 449. Also available from Edinburgh as DAI Research Paper 507. </note>
Reference-contexts: This implementation entails devising relational rippling tactics to guide a proof editor like Oyster and devising methods to specify these tactics in a meta-logic for use by a proof planner like CL A M , <ref> [Bundy et al, 1990] </ref>. 1.1 Overview In x2 we give a brief introduction to functional rippling. In x3 we introduce value passing by shared existential variables. In x4 we introduce relational rippling by analogy to functional rippling. In x6 we define the invariant properties in relational rippling.
Reference: [Bundy et al, 1993] <author> Bundy, Alan, Stevens, A., van Harmelen, F., Ireland, A. and Smaill, A. </author> <year> (1993). </year> <title> Rippling: A heuristic for guiding inductive proofs. </title> <journal> Artificial Intelligence, </journal> <volume> 62 </volume> <pages> 185-253. </pages> <note> Also available from Edinburgh as DAI Research Paper No. 567. </note>
Reference-contexts: 1 Introduction Rippling is a heuristic technique for controlling search during automatic theorem proving, <ref> [Bundy et al, 1993] </ref>. It was originally developed for inductive theorem proving. Its role is to manipulate the induction conclusion to make it more like the induction hypothesis, thus enabling the hypothesis to prove the conclusion. <p> Note that wave-rule (4) has two skeletons: len (M ) and len (N ); the occurrence of len on the left contrib utes to both skeletons. These wave-rules are drawn from recursive definitions, transitive laws, distributive laws and other axioms and lemmas. For more discussion about rippling see <ref> [Bundy et al, 1993] </ref> and for a formal definition see [?]. 3 Value Passing via Shared Variables Wave-rule (3) comes from the step case of a recursive definition of rev, namely: rev ([HjT ]) = app (rev (T ); [H]) as it might be in a functional programming language.
Reference: [Ireland & Bundy, 1995] <author> Ireland, A. and Bundy, A. </author> <year> (1995). </year> <title> Productive use of failure in inductive proof. </title> <type> Research Paper 716, </type> <institution> Dept. of Artificial Intelligence, University of Edinburgh, </institution> <note> In JAR 16 (1-2). </note>
Reference-contexts: This reduction in the search space seems not to exclude the required proofs. Even when relational rippling fails, an analysis of the failure can suggest how to patch the proof, cf. <ref> [Ireland & Bundy, 1995] </ref>. 26 It remains to complete the implementation of the proposals made here and to test them more extensively. Unfortunately, time has not yet permitted this work to be completed.
Reference: [Lombart & Deville, 1994] <author> Lombart, V. and Deville, Y. </author> <month> (November </month> <year> 1994). </year> <note> Rippling on relational structures. Research report, Available as research report RR94-16, </note> <institution> Departement d'ingenierie informatique, Universite cath-olique de Louvain, Belgium. </institution>
Reference-contexts: ; Y Z ) ^ +(X ; Y Z ; XY Z ) app (X; Y; Z ) ! len ( Z ; K ) =) 9I; J : len (X ; I ) ^ len (Y ; J ) ^ +(I ; J ; K ) 8.5 Restricted initialization <ref> [Lombart & Deville, 1994] </ref> have an alternative initialization process, but this has restricted application. <p> ) (37) 10.4.2 Lemma We will first prove a necessary lemma: r fl (N; A; C) ^ r (A; B) ! 9D : r fl (N; B; D) ^ r (C; D) This is proved by induction on N , with the induction conclusion after introduction of the wave-front (see <ref> [Lombart & Deville, 1994] </ref> for details): 9N 0 : succ (N N N N A C A B " ! 9D : 9N 0 : succ (N N N N B D C D " Applying the definition of transitive closure (36) gives: 9V : r (A ; V ) ^ <p> D 0 ) ! 9D : 9V : r (Z; V ) ^ r fl (M; Y; D) ^ r fl (N; V; D) which should be readily provable by symbolic evaluation. 11 Implementation Notes The rippling-past process has been implemented, and is currently used with the restricted initialization of <ref> [Lombart & Deville, 1994] </ref> to get fully relational proofs. The other parts of the process should follow soon. <p> In this paper we have attempted to give the required theoretical account, which has guided our implementation. 2 the choice of the wave-front is arbitrary, but the other choice is not useful here 25 12.1 Lombart & Deville In <ref> [Lombart & Deville, 1994] </ref>, Lombart and Deville propose a version of relational rippling developed by analogy with functional rippling. Initially, they limited themselves to relational reasoning which was a direct translation of functional reasoning | what we will call the pseudo-functional case. <p> The directionality annotations they had developed are now dynamically added. The rippling-past process on which they focus has be embedded between either an initialization or rippling-out phase, and a final rippling-out. A termination measure has been defined. The annotations used in <ref> [Lombart & Deville, 1994] </ref> are slightly different from those proposed here: the wave-fronts do not include the existential quantifiers, and the directionalities are implicit (because they are statically fixed), but this is only syntactic sugar.
Reference: [Parkes, 1994] <author> Parkes, A. J. </author> <year> (1994). </year> <title> Generator induction for relational proofs, logic programming and reasoning about database systems. </title> <institution> MSc dissertation, Dept. of Artificial Intelligence, University of Edinburgh. </institution>
Reference-contexts: We want to prove: anc 1 (X; Y ) $ anc 2 (X; Y ) An interactive proof using an extended Whelk can be found in x5.3 in <ref> [Parkes, 1994] </ref>[pp 49-61]. The proof is divided into two halves. 10.3.1 anc 1 implies anc 2 We consider first the simpler half, that: anc 1 (X; Y ) ! anc 2 (X; Y ). Using the generator induction rule given in [Parkes, 1994] the step case is: par ( old ; <p> an extended Whelk can be found in x5.3 in <ref> [Parkes, 1994] </ref>[pp 49-61]. The proof is divided into two halves. 10.3.1 anc 1 implies anc 2 We consider first the simpler half, that: anc 1 (X; Y ) ! anc 2 (X; Y ). Using the generator induction rule given in [Parkes, 1994] the step case is: par ( old ; mid); anc 2 (mid; Y oung) ` anc 2 ( old mid ; Y oung Y oung )(29) The step cases of the recursive definitions of anc 1 and anc 2 give rise to the following two initialising wave-rules: par ( <p> Using the generator induction rule given in <ref> [Parkes, 1994] </ref> the step case is: anc 1 ( old ; mid); anc 1 (mid; Y oung) ` anc 1 ( old old ; Y oung Y oung )(32) Unfortunately, initialising wave-rule (30) cannot be applied to (32) because the condition of the wave-rule is not true. <p> consider the proof of this new conjecture in the next section. 10.3.3 The Transitivity of anc 1 So to complete the proof we must prove: anc 1 (Old; M id) ^ anc 1 (M id; Y oung) ! anc 1 (Old; Y oung) Using the generator induction rule given in <ref> [Parkes, 1994] </ref> the step case is: par ( old ; mid); anc 1 (young; Z) ! anc 1 (mid; Z) ` anc 1 (young young ; Z ) ! anc 1 ( old ; Z ) This proof is very easy.
Reference: [Walsh et al, 1992] <author> Walsh, T., Nunes, A. and Bundy, Alan. </author> <year> (1992). </year> <title> The use of proof plans to sum series. </title> <editor> In Kapur, D., (ed.), </editor> <booktitle> 11th Conference on Automated Deduction, </booktitle> <pages> pages 325-339. </pages> <address> Springer Verlag. </address> <note> Lecture Notes in Computer Science No. 607. Also available from Edinburgh as DAI Research Paper 563. 28 </note>
Reference-contexts: It was originally developed for inductive theorem proving. Its role is to manipulate the induction conclusion to make it more like the induction hypothesis, thus enabling the hypothesis to prove the conclusion. More recently, it has been used to guide non-inductive proofs, namely series summation, <ref> [Walsh et al, 1992] </ref>, and limit theorems, [?]. It appears to be useful whenever a problem can be solved by reducing a syntactic difference between it and some previously solved problem.
References-found: 11

