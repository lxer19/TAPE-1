URL: http://american.cs.ucdavis.edu/publications/ijpp96.ps
Refering-URL: http://american.cs.ucdavis.edu/ArchLabPersonnel/Farrens/PubList.html
Root-URL: http://www.cs.ucdavis.edu
Email: (tyson@cs.ucr.edu) (farrens@cs.ucdavis.edu)  
Title: d d Evaluating the Effects of Predicated Execution on Branch Prediction  
Author: Gary Tyson Matthew Farrens 
Keyword: Predication, Branch Prediction, PA-RISC, Alpha, ATOM, Pentium, PowerPC  
Note: This work was supported by National Science Foundation Grants CCR-87-06722, CCR-90-11535, CCR-94-03651, CCR-92-13627, MIP-92-57259, and grants from the  
Address: Riverside, CA 92521 Davis, CA 95616  1  
Affiliation: Department of Computer Science Department of Computer Science University of California, Riverside University of California, Davis  SUN Microsystems and Tektronix corporations.  
Abstract: As microprocessor designs move towards deeper pipelines and support for multiple instruction issue, steps must be taken to alleviate the negative impact of branch operations on processor performance. One approach is to use branch prediction hardware and perform speculative execution of the instructions following an unresolved branch. Another technique is to eliminate certain branch instructions altogether by translating the instructions following a forward branch into predicate form. Both these techniques are employed in many current processor designs. This paper investigates the relationship between branch prediction techniques and branch predication. In particular, we are interested in how using predication to remove a certain class of poorly predicted branches affects the prediction accuracy of the remaining branches. A variety of existing predication models for eliminating branch operations are presented, and the effect that eliminating branches has on branch prediction schemes ranging from simple prediction mechanisms to the newer more sophisticated branch predictors is studied. We also examine the impact of predication on basic block size, and how the two techniques used together affect overall processor performance. 
Abstract-found: 1
Intro-found: 1
Reference: [AlAv93] <author> D. Alpert and D. Avnon, </author> <title> ``Architecture of the Pentium Microprocessor'', </title> <booktitle> IEEE Micro(June 1993), </booktitle> <pages> pp. 11-21. </pages>
Reference-contexts: The entry is later updated to reflect the actual condition of the branch. - 3 - d d 2.4. Pentium and PowerPC 604 (2-bit counter) The prediction approach used by the Pentium processor <ref> [AlAv93] </ref> features a 256 entry Branch Target Buffer (BTB). Each BTB entry contains the target address of the branch and a two bit counter used to store previous branch activity associated with that address. The BTB is 4-way set associative and uses a random replacement strategy.
Reference: [AADM93] <author> T. Asprey, G. S. Averill, E. DeLano, R. Mason, B. Weiner and J. Yetter, </author> <title> ``Performance Features of the PA7100 Microprocessor'', </title> <booktitle> IEEE Micro(June 1993), </booktitle> <pages> pp. 22-35. </pages>
Reference-contexts: Branch Always The simplest (and least accurate) of schemes predicts that all branches will be taken the processor will always attempt to fetch instructions from the target of the branch. 2.2. HP Precision Architecture (Branch Backwards) The Hewlett Packard Precision RISC Architecture (PA-RISC) <ref> [AADM93] </ref> uses a static prediction method for calculating the direction of instruction flow across branches termed Branch Backward. In this scheme, all backward branches are predicted to be taken, and all forward branches are predicted to be not taken.
Reference: [CMCW91] <author> P. P. Chang, S. A. Mahlke, W. Y. Chen, N. J. Warter and W. Hwu, </author> <title> ``IMPACT: An Architectural Framework for Multiple-Instruction-Issue Processors'', </title> <booktitle> Proceedings of the Eighteenth Annual International Symposium on Computer Architecture, </booktitle> <address> Toronto, Canada (May 27-30, </address> <year> 1991), </year> <pages> pp. 266-275. </pages>
Reference-contexts: Although vector machines like the CRAY [Russ78] have long supported a type of predicated execution with their vector masks, most research on this subject is more recent <ref> [CMCW91, DeHB89] </ref>. Branch prediction and predication can also be used together in a complimentary fashion.
Reference: [DeHB89] <author> J. C. Dehnert, P. Y. T. Hsu and J. P. Bratt, </author> <title> ``Overlapped Loop Support for the Cydra 5'', </title> <booktitle> Proceedings of the 17th Annual Symposium on Computer Architecture(May 1989), </booktitle> <pages> pp. 26-38. </pages>
Reference-contexts: Although vector machines like the CRAY [Russ78] have long supported a type of predicated execution with their vector masks, most research on this subject is more recent <ref> [CMCW91, DeHB89] </ref>. Branch prediction and predication can also be used together in a complimentary fashion.
Reference: [FiFr92] <author> J. A. Fisher and S. M. Freudenberger, </author> <title> ``Predicting Conditional Branch Directions from Previous Runs of a Program'', </title> <booktitle> Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <address> Boston, MA (October 12-15, </address> <year> 1992), </year> <pages> pp. 85-95. </pages>
Reference-contexts: The effectiveness of this technique is clearly dependent on the accuracy of the prognostication, and improving the accuracy has been an active area of research for many years [Smit81] [LeS84] <ref> [FiFr92] </ref> [YeP93]. There are two main approaches for predicting branches static schemes, which predict at compile time, and dynamic schemes, which use hardware to try to capture the dynamic behavior of branches.
Reference: [HePa90] <author> J. Hennessy and D. Patterson, </author> <title> Computer Architecture: A Quantitative Approach, </title> <publisher> Morgan Kaufman, </publisher> <address> San Mateo, California, </address> <year> (1990). </year>
Reference: [HePa96] <author> J. Hennessy and D. Patterson, </author> <title> Computer Architecture: A Quantitative Approach (second edition), </title> <publisher> Morgan Kaufman, </publisher> <address> San Francisco, California, </address> <year> (1996). </year>
Reference-contexts: Also of note is the percentage of branches taken; almost all backward branches are taken, while many forward branches are not taken. This is as expected <ref> [HePa96] </ref>. Of the forward branches, those between distance 1 and 12 show the greatest frequency of execution. separated into three components: the prediction accuracy of all backward branches, the accuracy of branches in the range 0-12, and the accuracy of forward branches of distance 13 or more.
Reference: [LeS84] <author> J. K. L. Lee and A. J. Smith, </author> <title> ``Branch Prediction Strategies and Branch Target Buffer Design'', </title> <journal> Computer, </journal> <volume> vol. 17, no. </volume> <month> 1 (January </month> <year> 1984), </year> <pages> pp. 6-22. </pages>
Reference-contexts: This information is used by the instruction fetch logic in order to determine which instruction pathway to continue fetching from. The effectiveness of this technique is clearly dependent on the accuracy of the prognostication, and improving the accuracy has been an active area of research for many years [Smit81] <ref> [LeS84] </ref> [FiFr92] [YeP93]. There are two main approaches for predicting branches static schemes, which predict at compile time, and dynamic schemes, which use hardware to try to capture the dynamic behavior of branches.
Reference: [MHBG94] <author> S. A. Mahlke, R. E. Hank, R. A. Bringmann, J. C. Gyllenhaal, D. M. Gallagher and W. W. Hwu, </author> <title> ``Characterizing the Impact of Predicated Execution on Branch Prediction'', </title> <booktitle> Proceedings of the 27th Annual International Symposium on Microarchitecture, </booktitle> <address> San Jose, Ca. </address> <month> (November 30 - December 2, </month> <year> 1994), </year> <pages> pp. 217-227. </pages>
Reference-contexts: Using these two transformations together, the compiler can modify a small loop containing a maze of if-then-else conditionals into a long sequence of predicated instructions that can then be more efficiently scheduled to fill instruction slots. 5.4. Other Scheduling Issues In <ref> [MHBG94] </ref>, the effect of predication on branch prediction during hyperblock formation was studied. A hyperblock is a collection of basic blocks which has a single entry point and one or more exit points.
Reference: [McLe93] <author> E. McLellan, </author> <title> ``The Alpha AXP Architecture and 21064 Processor'', </title> <booktitle> IEEE Micro(June 1993), </booktitle> <pages> pp. 35-47. </pages>
Reference-contexts: This scheme outperforms branch always in applications that contain forward branches that are not taken more often than they are taken. 2.3. Alpha (Branch Backwards and 1-bit) The Alpha processor <ref> [McLe93, Site92] </ref> supports three different prediction methods: opcode specified hints, a branch backward strategy, and a one bit branch history table. While a given implementation of the Alpha architecture may use any or all of these methods, in this study only the last two were modeled.
Reference: [PnSo94] <author> D. N. Pnevmatikatos and G. S. Sohi, </author> <title> ``Guarded Execution and Branch Prediction in Dynamic ILP Processors'', </title> <booktitle> Proceedings of the 21st Annual International Symposium on Computer Architecture, </booktitle> <address> Chicago, Illinois (April 18-21, </address> <year> 1994), </year> <pages> pp. 120-129. </pages>
Reference-contexts: Another way is to introduce a special instruction which controls the conditional execution of some number of instructions following the special instruction. An example of this approach is seen in the guarded execution model proposed by Pnevmatikatos and Sohi <ref> [PnSo94] </ref>. This section concludes by presenting an overview of 4 different existing predication models; the one used in the Alpha, the one used in the PA-RISC, the guarded execution model, and the one used by the Cydra 5. <p> Guarded Execution Model Pnevmatikatos and Sohi <ref> [PnSo94] </ref> propose the use of a guard instruction to control the execution of a sequence of instructions. A guard instruction specifies two things a condition register and a mask value to indicate which of the following instructions are dependent on the contents of that condition register.
Reference: [RYY89] <author> B. R. Rau, D. W. L. Yen, W. Yen and R. A. Towle, </author> <title> ``The Cydra 5 Departmental Supercomputer'', </title> <booktitle> IEEE Computer(Jan 1989), </booktitle> <pages> pp. 12-35. </pages>
Reference-contexts: In the unrestricted predication model, on the other hand, all instructions can be predicated. This can be accomplished in a number of ways. One way is to include an additional operand field for each instruction, as was done in the Cydra 5 <ref> [RYY89] </ref>. Another way is to introduce a special instruction which controls the conditional execution of some number of instructions following the special instruction. An example of this approach is seen in the guarded execution model proposed by Pnevmatikatos and Sohi [PnSo94]. <p> Cydra 5 The Cydra 5 system <ref> [RYY89] </ref> supports the most general form of predicated execution. Each Cydra 5 operation can be predicated by specifying which of the 128 boolean predicate registers contains the desired execution condition.
Reference: [Russ78] <author> R. M. Russell, </author> <title> ``The CRAY-1 Computer System'', </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. </volume> <month> 1 (January </month> <year> 1978), </year> <pages> pp. 63-72. </pages>
Reference-contexts: This is a promising area of research because, in addition to removing the branch itself from the instruction stream, it potentially provides the additional benefit of improving scheduling capability. Although vector machines like the CRAY <ref> [Russ78] </ref> have long supported a type of predicated execution with their vector masks, most research on this subject is more recent [CMCW91, DeHB89]. Branch prediction and predication can also be used together in a complimentary fashion. <p> Support for multiple guards can be provided by allowing additional guard instructions to modify those entries in the scalar mask that have not been previously marked for elimination. This approach is reminiscent of the vector mask register approach used on earlier vector processors <ref> [Russ78] </ref>, with the bit mask controlling the issue of a sequence of instructions in the instruction stream instead of the ALU operations in vector instruction. It is unclear how the nullification capability or the guarded branch instruction will migrate to multi-issue implementations.
Reference: [Site92] <author> R. L. </author> <title> Sites, ``Alpha Architecture Reference manual'', </title> <publisher> Digital Press(1992). </publisher>
Reference-contexts: This scheme outperforms branch always in applications that contain forward branches that are not taken more often than they are taken. 2.3. Alpha (Branch Backwards and 1-bit) The Alpha processor <ref> [McLe93, Site92] </ref> supports three different prediction methods: opcode specified hints, a branch backward strategy, and a one bit branch history table. While a given implementation of the Alpha architecture may use any or all of these methods, in this study only the last two were modeled.
Reference: [Smit81] <author> J. E. Smith, </author> <title> ``A Study of Branch Prediction Strategies'', </title> <booktitle> Proceedings of the Eighth Annual International Symposium on Computer Architecture, </booktitle> <address> Minneapolis, Minnesota (May 1981), </address> <pages> pp. 135-148. </pages>
Reference-contexts: This information is used by the instruction fetch logic in order to determine which instruction pathway to continue fetching from. The effectiveness of this technique is clearly dependent on the accuracy of the prognostication, and improving the accuracy has been an active area of research for many years <ref> [Smit81] </ref> [LeS84] [FiFr92] [YeP93]. There are two main approaches for predicting branches static schemes, which predict at compile time, and dynamic schemes, which use hardware to try to capture the dynamic behavior of branches.
Reference: [SrEu94] <author> A. Srivastava and A. Eustace, </author> <title> ``ATOM: A System for Building Customized Program Analysis Tools'', </title> <booktitle> Proceedings of the ACM SIGPLAN Notices 1994 Conference on Programming Languages and Implementations(June 1994), </booktitle> <pages> pp. 196-205. </pages>
Reference-contexts: The Simulation Environment The benchmarks selected for this experiment were the fourteen floating point and five of the integer programs from the SPEC92 suite of programs. Each program was compiled on an Alpha based DEC 3000/400 workstation, using the native compiler and -O2 -non_shared compiler flags. The ATOM <ref> [SrEu94] </ref> toolkit was used to generate and help analyze the data gathered for this study.
Reference: [TFRP95] <author> G. Tyson, M. Farrens, K. Rich and A. Pleszkun, </author> <title> ``Reducing the Branch Penalty of Mispredicted Short Forward Branches'', </title> <institution> Computer Science Department Technical Report CSE-95-7, University of - 23 - d d California - Davis, Davis, </institution> <note> Ca 95616 (August 1995). </note>
Reference-contexts: However, many future processor implementations will need to execute instruction sets that do not support predication. In <ref> [TFRP95] </ref> we explore the feasibility of modifying the method used to recover from mispredicted branches to allow the branch penalty to be reduced in much the same manner as predication without the necessity of predicates. In [TFRP95], a mechanism is presented by which those short forward branches that are incorrectly predicted <p> In <ref> [TFRP95] </ref> we explore the feasibility of modifying the method used to recover from mispredicted branches to allow the branch penalty to be reduced in much the same manner as predication without the necessity of predicates. In [TFRP95], a mechanism is presented by which those short forward branches that are incorrectly predicted to be NOT-TAKEN can be flushed in a manner which reduces the penalty to that of predication (the number of instructions from the branch to the target).
Reference: [YeP91] <author> T. Yeh and Y. Patt, </author> <title> ``Two-Level Adaptive Training Branch Prediction'', </title> <booktitle> Proceedings of the 24th Annual International Symposium on Microarchitecture, </booktitle> <address> Albuquerque, New Mexico (November 18-20, </address> <year> 1991), </year> <pages> pp. 51-61. </pages>
Reference-contexts: If the history table value predicts not taken, then the branch address is removed from the BTB (if it currently resides there). 2.5. Two Level Adaptive The final branch prediction strategy modeled is the two level adaptive strategy developed by Yeh and Patt, and first presented in <ref> [YeP91] </ref>. This strategy requires considerably more hardware resources than the other methods, but also provides substantially greater branch prediction accuracy. This scheme features a set of branch history registers in addition to a branch history pattern table.
Reference: [YeP93] <author> T. Yeh and Y. Patt, </author> <title> ``A Comparison of Dynamic Branch Predictors that use Two Levels of Branch History'', </title> <booktitle> Proceedings of the Twentieth Annual International Symposium on Computer Architecture, </booktitle> <address> San Diego, CA (May 16-19, </address> <year> 1993), </year> <pages> pp. </pages> <month> 257-266. </month> <title> [94] ``PowerPC 601 RISC Microprocessor Users's Manual Addendum for 604'', </title> <institution> Motorola / IBM Microelectronics(1993, </institution> <year> 1994). </year> <month> - 24 </month> - 
Reference-contexts: The effectiveness of this technique is clearly dependent on the accuracy of the prognostication, and improving the accuracy has been an active area of research for many years [Smit81] [LeS84] [FiFr92] <ref> [YeP93] </ref>. There are two main approaches for predicting branches static schemes, which predict at compile time, and dynamic schemes, which use hardware to try to capture the dynamic behavior of branches.
References-found: 19

