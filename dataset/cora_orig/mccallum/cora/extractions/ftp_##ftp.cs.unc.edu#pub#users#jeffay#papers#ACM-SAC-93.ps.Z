URL: ftp://ftp.cs.unc.edu/pub/users/jeffay/papers/ACM-SAC-93.ps.Z
Refering-URL: http://www.cs.unc.edu/Research/real-time.html
Root-URL: http://www.cs.unc.edu
Title: The Real-Time Producer/Consumer Paradigm: A paradigm for the construction of efficient, predictable real-time systems  
Author: Kevin Jeffay 
Address: Chapel Hill  
Affiliation: University of North Carolina at  
Date: February, 1993, pp.796-804.  
Note: In: Proc. of the 1993 ACM/SIGAPP Symposium on Applied Computing, Indianapolis, IN,  
Abstract: A concurrent programming system for constructing hard-real-time applications is described. The system is based on a novel semantics of inter-process communication called the real-time producer/consumer (RTP/C) paradigm. Process interactions are modeled as producer/ consumer systems with a timing constraint on the rate at which the consumer must service the producer. The RTP/C paradigm provides a framework both for expressing processor-time-dependent computations and for reasoning about the real-time behavior of programs. A formal model of processor and resource allocation is used to determine necessary and sufficient conditions for realizing the RTP/C semantics of a program. The design of an interactive graphics system illustrates the use of the system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Andrews, G.R., Schneider, </author> <title> F.B., Concepts and Notations for Concurrent Programming, </title> <journal> Computing Surveys, </journal> <volume> 15, 1, </volume> <month> (March </month> <year> 1983), </year> <pages> pp. 3-43. </pages>
Reference-contexts: For example, a canonical solution is to impose a circularly linked list of buffers between the two processes and synchronize access to the buffers by a monitor and pair of condition variables as outlined (in an abbreviated form) in Figure 2.1 <ref> [1] </ref>. In this scenario the producer will wait for the consumer when all the buffers are full. Similarly, the consumer will wait for the producer if the buffers are all empty. In this manner, all data objects deposited by the producer are eventually removed and consumed by the consumer. <p> A simplified conceptual schema for an internal process is process P loop Accept ( in_mesg) &lt;compute&gt; Emit (out_mesg, channel1) &lt;compute&gt; Emit (out_mesg, channel2) : end loop end P1 Communication and synchronization in our system are based on the client/server paradigm of message passing <ref> [1] </ref>. A process has a single input port and a set of output ports. A process repeatedly accepts a message on its input port, processes the message possibly emitting messages to other processes and then attempts to accept another input message. Message passing is asynchronous.
Reference: [2] <author> Baker, </author> <title> T.P., A Stack-Based Resource Allocation Policy for Real-Time Processes, </title> <booktitle> Proc. IEEE Real-Time Systems Symp., </booktitle> <address> Orlando, FL, </address> <month> December </month> <year> 1990, </year> <pages> pp 191-200. </pages>
Reference-contexts: Since processes execute to completion, we may execute all processes on a single run-time stack. This greatly improves memory utilization and reduces context switching overhead. This is similar to Bakers stack allocation policy <ref> [2] </ref>. Analyzing RTP/C Programs The RTP/C paradigm enables two types of analysis of real-time behaviors: assessments real-time latency, and real-time throughput. Real-time throughput is inherent in the RTP/C model. Latency refers to the time required for sequences of messages to propagate through a process graph.
Reference: [3] <author> Baker, </author> <title> T.P., Shaw, A.C., The Cyclic Executive Model and Ada, </title> <booktitle> Real-Time Systems, </booktitle> <volume> 1, 1, </volume> <month> (June </month> <year> 1989), </year> <pages> pp. 7-26. </pages>
Reference-contexts: We provide evidence by way of example that the RTP/C paradigm yields a flexible methodology for constructing, and predicting the performance of, data-flow applications and hence represents an advance over existing methods such as cyclic executives <ref> [3] </ref>. To date, the RTP/C paradigm has been used as the basis for the design and construction of three real-time applications: an interactive 3-D graphics system, a HiPPI data-link interface, and a distributed workstation-based conferencing system using digital audio and video [7].
Reference: [4] <author> Berry, G., Cosserat, L., </author> <title> The ESTEREL Synchronous Programming Language and its Mathematical Semantics, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> 197, </volume> <pages> pp. 389-448. </pages>
Reference-contexts: Numerous programming languages and systems have been proposed for the development of real-time systems. Most of these language, most notably languages such as Ada, do not deal with time in any fundamental manner. Notable exceptions include languages such as Real-Time Euclid [9], Concord/FLEX [10], and ESTEREL <ref> [4] </ref>. Real-Time Euclid is an extension of Concurrent Euclid that adds the ability to specify periodic and event driven timing constraints as well as exception handling mechanisms. FLEX is a language for specifying imprecise computations; a computation that is described by a monotonically increasing value function (of time).
Reference: [5] <author> Chung, J.C., et al., </author> <title> Exploring Virtual Worlds with Head-Mounted Displays, Non-Holographic True 3-Dimensional Display Technologies, </title> <booktitle> SPIE Proceedings, </booktitle> <address> Los Angeles, CA, </address> <month> January </month> <year> 1989. </year>
Reference-contexts: Using the RTP/C Paradigm The following example illustrates the use of the RTP/C programming system. We have used a prototype of the programming system to re-implement an interactive graphics system used for research in virtual worlds <ref> [5] </ref>. The graphics system is a head-mounted display system consisting of a helmet with miniature television monitors embedded in it, and tracking hardware for the helmet and for a handheld pointing device. A computer generated image of a 3-dimensional virtual world is displayed in the helmet.
Reference: [6] <author> Jeffay, K. et al., YARTOS: </author> <title> Kernel support for efficient, predictable real-time systems, in Real-Time Programming, </title> <editor> W. Halang and K. Ramamritham, eds., </editor> <publisher> Pergamon Press, Oxford, </publisher> <address> UK, </address> <year> 1992. </year>
Reference-contexts: Implementation The programming system we have described is currently implemented as a set of extensions to the C programming language. A runtime system that implements both our process model and scheduling discipline has been constructed <ref> [6] </ref>. The runtime system is a bare machine operating system kernel (or micro-kernel) that executes on IBM PS/2 computers. The kernel, contains routines to create processes, data repositories, and communication channels, bind ports of processes to channels, send and receive messages, and invoke operations on data repositories.
Reference: [7] <author> Jeffay, K., et al., </author> <title> Kernel Support for Live Digital Audio and Video, </title> <journal> Computer Communications, </journal> <volume> 15, 6, </volume> <booktitle> (July/August 1992) pp. </booktitle> <pages> 388-395. </pages> . 
Reference-contexts: To date, the RTP/C paradigm has been used as the basis for the design and construction of three real-time applications: an interactive 3-D graphics system, a HiPPI data-link interface, and a distributed workstation-based conferencing system using digital audio and video <ref> [7] </ref>. In each case the real-time processing requirements of the application were concisely represented using the RTP/C paradigm. <p> Moreover, it provides a framework for the analysis of interesting and important real-time program behaviors. The system has been applied to an interactive graphics system, a HiPPI data-link controller, and is being used in the development of a computer-based conferencing system using digital audio and video <ref> [7] </ref>.
Reference: [8] <author> Jeffay, K., </author> <title> Scheduling Sporadic Tasks With Shared Resources in Real-Time Systems, </title> <booktitle> Proc. IEEE Real-Time Sys. Symp., </booktitle> <address> Phoenix, AZ, </address> <month> December </month> <year> 1992, </year> <pages> pp. 89-99. </pages>
Reference-contexts: A RTP/C program is modeled formally as a set of sporadic tasks that share a set of serially reusable single unit resources. The conditions under which it will be possible to correctly implement an arbitrary RTP/C program have been reported in <ref> [8] </ref>. This allows a programmer to easily test if the desired real-time behavior of a program will be realized at runtime. The RPT/C paradigm is not a panacea for the problems of real-time computing. <p> With respect to the sporadic tasking model, we have developed an optimal algorithm for sequencing sporadic tasks on a single processor <ref> [8] </ref>. <p> First, whenever a process P enters a critical section, the process has its priority elevated in such a manner that for the duration of the critical section, no other process that requires access to the same critical section will be able to preempt the resident process <ref> [8] </ref>. This is similar to the concept of a priority ceiling in priority inheritance protocols [13]. Because of this fact, the kernel need not provide any special locking facilities for critical sections.
Reference: [9] <author> Kligerman, E., Stoyenko, </author> <title> A.D., Real-Time Euclid: A Language for Reliable Real-Time Systems, </title> <journal> IEEE Trans on Soft. Eng., </journal> <volume> 12, 9, </volume> <month> (September </month> <year> 1986), </year> <pages> pp. 941-949. </pages>
Reference-contexts: Numerous programming languages and systems have been proposed for the development of real-time systems. Most of these language, most notably languages such as Ada, do not deal with time in any fundamental manner. Notable exceptions include languages such as Real-Time Euclid <ref> [9] </ref>, Concord/FLEX [10], and ESTEREL [4]. Real-Time Euclid is an extension of Concurrent Euclid that adds the ability to specify periodic and event driven timing constraints as well as exception handling mechanisms.
Reference: [10] <author> Lin, K.-J. et al., </author> <title> Concord: A System of Imprecise Computations, </title> <booktitle> Proc. of the IEEE COMPSAC '87, </booktitle> <address> Tokyo, Japan, </address> <month> October </month> <year> 1987. </year>
Reference-contexts: Numerous programming languages and systems have been proposed for the development of real-time systems. Most of these language, most notably languages such as Ada, do not deal with time in any fundamental manner. Notable exceptions include languages such as Real-Time Euclid [9], Concord/FLEX <ref> [10] </ref>, and ESTEREL [4]. Real-Time Euclid is an extension of Concurrent Euclid that adds the ability to specify periodic and event driven timing constraints as well as exception handling mechanisms.
Reference: [11] <author> Liu, C.L., Layland, J.W., </author> <title> Scheduling Algorithms for Multiprogramming in a Hard-Real-Time Environment, </title> <journal> J. ACM, </journal> <volume> 20, 1, </volume> <month> (January </month> <year> 1973), </year> <pages> pp. 46-61. </pages>
Reference-contexts: A sporadic task is a sequential program that is invoked repeatedly, with a lower bound on the inter-invocation time, and with a deadline for the completion of each invocation. A sporadic task is a generalization of the more commonly studied periodic task <ref> [11] </ref>. Informally, a task corresponds to a process. If a process receives messages from n producers then we associate n (identical) tasks with the process. Tasks are invoked whenever a message is produced on a channel connected to the process corresponding to the task. <p> The algorithm is a variation of the well-known earliest deadline first (E DF ) scheduling algorithm; a preemptive priority driven scheduling algorithm with dynamic priority assignment <ref> [11] </ref>. Although the scheduling policy used is optimal, it is still quite possible to write a program which, when compiled into a set of tasks, cannot be scheduled (i.e., the tasks cannot be guaranteed to meet their deadlines). <p> Loosely speaking, the right hand side of condition (2) condition is an upper bound on the time that a task will be delayed while waiting to gain access to a critical section when scheduled according to an optimal 1 Necessary and sufficient conditions are proved in <ref> [11] </ref>. A simpler formulation is presented here for brevity. discipline. Under all circumstances this bound must be less than or equal to the inter-arrival time (or a fraction thereof) of messages on channel i.
Reference: [12] <author> Park, C., Shaw, </author> <title> A.C., Experiments With a Program Timing Tool Based On Source-Level Timing Schema, </title> <journal> IEEE Computer, </journal> <volume> 24, 5, </volume> <month> (May </month> <year> 1991), </year> <pages> pp. 48-57. </pages>
Reference-contexts: Measurements are currently done by hand although we anticipate that automated tools will be available to aid in this process (e.g., <ref> [12] </ref>). The rates and execution times of processes are tested against the schedulability conditions listed above.
Reference: [13] <author> Sha, L. et al., </author> <title> Priority Inheritance Protocols: An approach to real-time synchronization, </title> <journal> IEEE Trans. on Computers, </journal> <volume> 39, 9, </volume> <month> (September </month> <year> 1990), </year> <pages> pp. 1175-1185. </pages>
Reference-contexts: This is similar to the concept of a priority ceiling in priority inheritance protocols <ref> [13] </ref>. Because of this fact, the kernel need not provide any special locking facilities for critical sections. The second property is that if a process P is preempted, it is the case that any process that executes while P is preempted, is guaranteed to complete execution before P is resumed.
Reference: [14] <author> Wirth, N., </author> <title> Toward a discipline of real-time programming, </title> <journal> Comm. of the ACM, </journal> <volume> 20, </volume> <month> 8 (August </month> <year> 1977), </year> <pages> 577-583. </pages>
Reference-contexts: In this case we must ensure that all data produced by the producer is consumed by the consumer in the absence of the wait statement in the Deposit routine in the monitor in Figure 2.1 <ref> [14] </ref>. Now, if the consumer is not fast enough, data from this external producer will be lost. In this case, knowledge of the semantics of synchronization, and the buffering algorithms in the monitor, are no longer sufficient to determine if all data deposited will be consumed.
References-found: 14

