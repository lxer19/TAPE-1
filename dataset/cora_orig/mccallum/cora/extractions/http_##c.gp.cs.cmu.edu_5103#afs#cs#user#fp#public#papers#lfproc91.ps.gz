URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/papers/lfproc91.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/papers/
Root-URL: http://www.cs.cmu.edu
Email: Internet: fp@cs.cmu.edu  
Title: Logic Programming in the LF Logical Framework  
Author: Frank Pfenning 
Date: February 1991  
Note: Revised draft for the Proceedings of the First Workshop on Logical Frameworks  Contents  
Address: Pittsburgh, Pennsylvania 15213-3890  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Peter B. Andrews. </author> <title> On connections and higher-order logic. </title> <journal> Journal of Automated Reasoning, </journal> <volume> 5 </volume> <pages> 257-291, </pages> <year> 1989. </year>
Reference-contexts: While this unification algorithm has proven quite useful in the context of automated theorem proving <ref> [1, 13] </ref>, as the basis for a a logic programming language it has some drawbacks. In particular, the potentially high branching factor and the possibility of non-termination make it difficult to exploit the full power of Huet's algorithm in a safe and predictable way.
Reference: [2] <author> Arnon Avron, Furio A. Honsell, and Ian A. Mason. </author> <title> Using typed lambda calculus to implement formal systems on a machine. </title> <type> Technical Report ECS-LFCS-87-31, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: 1 Introduction In [12], Harper, Honsell, and Plotkin present LF (the Logical Framework) as a general framework for the definition of logics. LF provides a uniform way of encoding a logical language, its inference rules and its proofs. In <ref> [2] </ref>, Avron, Honsell, and Mason give a variety of examples for encoding logics in LF. In this paper we describe Elf, a meta-language intended for environments dealing with deductive systems represented in LF. <p> For more details, the reader is referred to [12]. A number of examples of representations of logical systems in LF can be found in <ref> [2] </ref>. The LF calculus is a three-level calculus for objects, families, and kinds. Families are classified by kinds, and objects are classified by types, that is, families of kind Type.
Reference: [3] <author> Thierry Coquand. </author> <title> An algorithm for testing conversion in Type Theory In Gerard Huet and Gordon D. </title> <editor> Plotkin, editors, </editor> <title> Logical Frameworks. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year> <note> To appear. Logic Programming in the LF Logical Framework 24 </note>
Reference-contexts: The notion of definitional equality we consider here is fi-conversion. Harper et al. [12] formulate definitional equality only with fi-conversion and conjecture that the system resulting from adding the -rule would have the properties we list below. This has recently been proved by Coquand <ref> [3] </ref> and independently by Salvesen [30]. For practical purposes the formulation including the -rule is superior, since every term has an equivalent canonical form. Thus, for us, is the least congruence generated by fi-conversions in the usual manner. <p> x:A ` M : B ` M : x:A:B ` N : A ` M : A A A 0 ` A 0 : Type ` M : A 0 We state a selection of the crucial properties of the LF type theory as given and proven in [12] and <ref> [3] </ref>. 1. (Unicity of Types) If ` M : A and ` M : A 0 then A A 0 . 2. (Strong Normalization) If ` M : A then M is strongly normalizing. 3. (Canonical Forms for Types) If ` A : Type then A u 1 :A 1 .
Reference: [4] <author> Gilles Dowek. </author> <title> A proof synthesis algorithm for a mathematical vernacular in a restriction of the Calculus of Constructions. </title> <type> Unpublished manuscript, </type> <month> January </month> <year> 1991. </year>
Reference-contexts: It is possible to construct such a meta-logic for unification over a number of different term languages and type theories, but a further exploration of this possibility is beyond the scope of this paper. Miller's mixed prefixes [20] and the existential variables considered by Dowek <ref> [4] </ref> perform a function similar to our unification logic.
Reference: [5] <author> Conal Elliott. </author> <title> Higher-order unification with dependent types. </title> <booktitle> In Rewriting Techniques and Applications, </booktitle> <pages> pages 121-136. </pages> <publisher> Springer-Verlag LNCS 355, </publisher> <month> April </month> <year> 1989. </year>
Reference-contexts: This result notwithstanding, a complete pre-unification algorithm for the simply-typed -calculus with generally good operational Logic Programming in the LF Logical Framework 8 behavior has been devised by Huet [15]. Extensions to LF have been developed independently by Elliott <ref> [5, 7] </ref> and Pym [28]. "Pre-unification" here refers to the fact that the algorithm will not enumerate unifiers, but simply reduce the original problem to a satisfiable set of constraints (so-called flex-flex pairs) whose unifiers are difficult to enumerate. <p> If we also maintain an approximate well-typedness condition <ref> [5] </ref> we can show termination of unification. Approximate well-typedness is necessary in order to guarantee termination of successive applications of the fi-reduction transformations.
Reference: [6] <author> Conal Elliott and Frank Pfenning. eLP: </author> <title> A Common Lisp implementation of Prolog in the Ergo Support System. Available via ftp over the Internet, </title> <month> October </month> <year> 1989. </year> <title> Send mail to elp-request@cs.cmu.edu on the Internet for further information. </title>
Reference-contexts: Thus Huet's algorithm and extended L unification as presented here are in some sense incomparable: each will Logic Programming in the LF Logical Framework 10 postpone some equations as constraints which could have been solved by the other algorithm. In the eLP implementation of Prolog <ref> [6] </ref> a combination of the two algorithms is used.
Reference: [7] <author> Conal M. Elliott. </author> <title> Extensions and Applications of Higher-Order Unification. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> May </month> <year> 1990. </year> <note> Available as Technical Report CMU-CS-90-134. </note>
Reference-contexts: This result notwithstanding, a complete pre-unification algorithm for the simply-typed -calculus with generally good operational Logic Programming in the LF Logical Framework 8 behavior has been devised by Huet [15]. Extensions to LF have been developed independently by Elliott <ref> [5, 7] </ref> and Pym [28]. "Pre-unification" here refers to the fact that the algorithm will not enumerate unifiers, but simply reduce the original problem to a satisfiable set of constraints (so-called flex-flex pairs) whose unifiers are difficult to enumerate. <p> Huet [15] has shown for the simply-typed -calculus that such equations (Huet calls them flex-flex) can always be unified, but that enumeration of all unifiers of such problems is very undirected. This analysis has been extended to LF by Elliott <ref> [7] </ref>. Here some flexible-flexible pairs can be solved completely, but other unification problems for which Elliott's algorithm would have enumerated solutions or failed, will be postponed. <p> Here, it is not possible to maintain such a strong invariant due to the dependent types. Instead, we maintain the rather technical invariant that F is acceptable. The Definitions 4.37 and 4.38 in <ref> [7] </ref> can be transcribed into this setting. Following the ideas of Elliott it is then possible to show that if F ! F 0 and F is acceptable, then F 0 is acceptable. Initially, acceptability is established by type-checking.
Reference: [8] <author> Amy Felty. </author> <title> Specifying and Implementing Theorem Provers in a Higher-Order Logic Programming Language. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <month> July </month> <year> 1989. </year>
Reference-contexts: Often one can take what authors bill as an "algorithmic" version of an inference system and implement it in Elf with very little additional work. Moreover, it is possible to implement tactics and tacticals in Elf along the lines proposed by Felty <ref> [8] </ref>. Such tactics are also often easier to write and understand than tactics written in a functional style, since they inherit a notion of meta-variable (the logic variable, in logic programming terminology), a notion of unification, and nondeterminism and backtracking in a uniform way from the underlying logic programming language. <p> Elf gives meta-programs a much more declarative flavor, and programs tend to be easier to read and have more predictable behavior than tactics. Moreover, tactics can easily be defined within Elf (similarly to Felty's formulation <ref> [8] </ref>). Finally, by programming directly Logic Programming in the LF Logical Framework 15 in a language with dependent types, static typechecking can make stronger correctness guarantees than functional meta-languages without dependent types (such as ML, for example).
Reference: [9] <author> Amy Felty and Dale Miller. </author> <title> Encoding a dependent-type -calculus in a logic programming language. In M.E. </title> <editor> Stickel, editor, </editor> <booktitle> 10th International Conference on Automated Deduction, </booktitle> <address> Kaiserslautern, Germany, </address> <pages> pages 221-235. </pages> <publisher> Springer-Verlag LNCS 449, </publisher> <month> July </month> <year> 1990. </year>
Reference-contexts: The way dependent types can be used to impose constraints on logic variables is one of the attractive features of Elf. The feature is missing if one follows the proposal by Felty & Miller <ref> [9] </ref> to interpret LF signatures in Hereditary Harrop logic.
Reference: [10] <author> Warren D. Goldfarb. </author> <title> The undecidability of the second-order unification problem. </title> <journal> Theoretical Computer Science, </journal> <volume> 13 </volume> <pages> 225-230, </pages> <year> 1981. </year>
Reference-contexts: the level of formulas must, of course, substitute into the types attached to the meta-quantifiers and, as before, rename variables when necessary. 3.4 A Generalization of L Unification to LF The general problem of higher-order unification is undecidable even for the second-order simply-typed -calculus with only one binary function constant <ref> [10] </ref>. This result notwithstanding, a complete pre-unification algorithm for the simply-typed -calculus with generally good operational Logic Programming in the LF Logical Framework 8 behavior has been devised by Huet [15].
Reference: [11] <author> Michael J. Gordon, Robin Milner, and Christopher P. </author> <title> Wadsworth. </title> <publisher> Edinburgh LCF. Springer-Verlag LNCS 78, </publisher> <year> 1979. </year>
Reference-contexts: This creates the possibility of deriving verified meta-programs through theorem proving in Elf (see Knoblock & Constable [18] or Allen et al. [14] for other approaches). Elf is quite different in look and feel to the standard meta-programming methodology of writing tactics and tacticals in ML <ref> [11] </ref>. On the positive side, Elf programs tend to be more declarative and easier to understand. Often one can take what authors bill as an "algorithmic" version of an inference system and implement it in Elf with very little additional work.
Reference: [12] <author> Robert Harper, Furio Honsell, and Gordon Plotkin. </author> <title> A framework for defining logics. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <pages> pages 194-204. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1987. </year> <note> An extended and revised version is available as Technical Report CMU-CS-89-173, </note> <institution> School of Computer Science, Carnegie Mellon University. </institution>
Reference-contexts: 1 Introduction In <ref> [12] </ref>, Harper, Honsell, and Plotkin present LF (the Logical Framework) as a general framework for the definition of logics. LF provides a uniform way of encoding a logical language, its inference rules and its proofs. <p> We conclude the paper with speculation about future work. 2 The LF Logical Framework We review here only the basic definitions and properties of the LF Logical Framework. For more details, the reader is referred to <ref> [12] </ref>. A number of examples of representations of logical systems in LF can be found in [2]. The LF calculus is a three-level calculus for objects, families, and kinds. Families are classified by kinds, and objects are classified by types, that is, families of kind Type. <p> We also use the customary abbreviation A ! B and sometimes B A for x:A:B when x does not appear free in B. The notion of definitional equality we consider here is fi-conversion. Harper et al. <ref> [12] </ref> formulate definitional equality only with fi-conversion and conjecture that the system resulting from adding the -rule would have the properties we list below. This has recently been proved by Coquand [3] and independently by Salvesen [30]. <p> objects. ; x:A ` M : B ` M : x:A:B ` N : A ` M : A A A 0 ` A 0 : Type ` M : A 0 We state a selection of the crucial properties of the LF type theory as given and proven in <ref> [12] </ref> and [3]. 1. (Unicity of Types) If ` M : A and ` M : A 0 then A A 0 . 2. (Strong Normalization) If ` M : A then M is strongly normalizing. 3. (Canonical Forms for Types) If ` A : Type then A u 1 :A <p> However, the restricted subset disallows important LF representation techniques. For example, the natural rule for universal elimination in an encoding of first-order logic (see <ref> [12] </ref>) 8E : F :i ! o : x:i : true (8 F ) ! true (F x) would not satisfy Miller's restriction once generalized to LF from the simply-typed -calculus, since the variable x (which is subject to instantiation during Elf search) appears in an argument to F , which
Reference: [13] <author> Leen Helmink and Rene Ahn. </author> <title> Goal directed proof construction in type theory. </title> <editor> In Gerard Huet and Gordon D. Plotkin, editors, </editor> <title> Logical Frameworks. </title> <publisher> Cambridge University Press, </publisher> <year> 1991. </year> <note> To appear. </note>
Reference-contexts: While this unification algorithm has proven quite useful in the context of automated theorem proving <ref> [1, 13] </ref>, as the basis for a a logic programming language it has some drawbacks. In particular, the potentially high branching factor and the possibility of non-termination make it difficult to exploit the full power of Huet's algorithm in a safe and predictable way.
Reference: [14] <author> Douglas J. Howe. </author> <title> Computational metatheory in Nuprl. </title> <editor> In Ewing Lusk and Ross Overbeek, editors, </editor> <booktitle> 9th International Conference on Automated Deduction, </booktitle> <address> Argonne, </address> <publisher> Illinois, </publisher> <pages> pages 238-257, </pages> <address> Berlin, </address> <month> May </month> <year> 1988. </year> <note> Springer-Verlag LNCS 310. </note>
Reference-contexts: Secondly, the partial correctness of many meta-programs with respect to a given logic can be expressed and proved by Elf itself (see the example in Section 5). This creates the possibility of deriving verified meta-programs through theorem proving in Elf (see Knoblock & Constable [18] or Allen et al. <ref> [14] </ref> for other approaches). Elf is quite different in look and feel to the standard meta-programming methodology of writing tactics and tacticals in ML [11]. On the positive side, Elf programs tend to be more declarative and easier to understand.
Reference: [15] <author> Gerard Huet. </author> <title> A unification algorithm for typed -calculus. </title> <journal> Theoretical Computer Science, </journal> <volume> 1 </volume> <pages> 27-57, </pages> <year> 1975. </year>
Reference-contexts: This result notwithstanding, a complete pre-unification algorithm for the simply-typed -calculus with generally good operational Logic Programming in the LF Logical Framework 8 behavior has been devised by Huet <ref> [15] </ref>. Extensions to LF have been developed independently by Elliott [5, 7] and Pym [28]. "Pre-unification" here refers to the fact that the algorithm will not enumerate unifiers, but simply reduce the original problem to a satisfiable set of constraints (so-called flex-flex pairs) whose unifiers are difficult to enumerate. <p> The term Uvar in the names of the rules stands for universal variable. In first-order unification, unifying a variable x with itself or another variable is of course trivial| here possible arguments add complications. Huet <ref> [15] </ref> has shown for the simply-typed -calculus that such equations (Huet calls them flex-flex) can always be unified, but that enumeration of all unifiers of such problems is very undirected. This analysis has been extended to LF by Elliott [7]. <p> Gvar-Const M has the form c M 1 . . . M m for a constant c : v 1 :B 1 . . . v m :B m :B. In this case we perform an imitation <ref> [15] </ref>. <p> M m for a y universally quantified outside of x. Here an analogous transition applies (replace c by y in Gvar-Const). Gvar-Uvar-Inside M has the form y (i) M 1 . . . M m for 1 i n. In this case we perform a projection <ref> [15] </ref>. <p> Theorem (Precompleteness of Unification) If `` F and F =) F 0 then `` F 0 . A brief aside: in the implementation, the rules dealing with generalized variables are combined into a form of generalized occurs-check which performs three functions: the usual occurs-check along rigid paths <ref> [15] </ref>, the dependency check, which also might lead to failure, and finally it generates constraints (equations which cannot be reduced further) from flexible subformulas which are not generalized variables. If we also maintain an approximate well-typedness condition [5] we can show termination of unification.
Reference: [16] <author> Gerard Huet. </author> <title> The calculus of constructions, documentation and user's guide. Rapport technique 110, </title> <institution> INRIA, Rocquencourt, France, </institution> <year> 1989. </year>
Reference-contexts: We are guaranteed that P is an equivalence proof for M and N only when this translation succeeds. 5.5 Type Reconstruction for Elf The method of type reconstruction for Elf is different from what is used in LEGO [27] or the implementation of the Calculus of Constructions at INRIA <ref> [16] </ref> in that (1) argument synthesis and type and term reconstruction are completely decoupled, and (2) there is no restriction on which types and terms can be omitted in the input. We only sketch the algorithm here.
Reference: [17] <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the Fourteenth Annual ACM Symposium on Principles of Programming Languages, Munich, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1987. </year> <title> Logic Programming in the LF Logical Framework 25 </title>
Reference-contexts: Due to the nature of LF, both of these differ significantly from first-order logic programming languages. In particular, proof search and unification become intertwined and unification is no longer a simple subroutine. This phenomenon is already familiar from constraint logic programming <ref> [17, 24] </ref>, but Elf has at least one additional complication: goals are identified with logic variables (see Section 4). This set of circumstances calls for a new approach to describe the operational semantics of Elf.
Reference: [18] <author> Todd B. Knoblock and Robert L. Constable. </author> <title> Formalized metareasoning in type theory. </title> <booktitle> In First Annual Symposium on Logic in Computer Science, </booktitle> <address> Cambridge, Massachusetts, </address> <pages> pages 237-248. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: Secondly, the partial correctness of many meta-programs with respect to a given logic can be expressed and proved by Elf itself (see the example in Section 5). This creates the possibility of deriving verified meta-programs through theorem proving in Elf (see Knoblock & Constable <ref> [18] </ref> or Allen et al. [14] for other approaches). Elf is quite different in look and feel to the standard meta-programming methodology of writing tactics and tacticals in ML [11]. On the positive side, Elf programs tend to be more declarative and easier to understand.
Reference: [19] <author> Alberto Martelli and Ugo Montanari. </author> <title> An efficient unification algorithm. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(2) </volume> <pages> 258-282, </pages> <month> April </month> <year> 1982. </year>
Reference-contexts: This allows the natural specification and manipulation of unsolved equations as constraints. 3.1 A First-Order Unification Logic with Quantifier Dependencies The unification logic arises most naturally from a generalization of the usual view of unification as transformations of a set of equations <ref> [19, 31] </ref>. There we are given set of equations with some free variables. This set is unifiable if there is a substitution for the free variables such that all the equations become true.
Reference: [20] <author> Dale Miller. </author> <title> Unification under a mixed prefix. </title> <journal> Journal of Symbolic Computation, </journal> <note> 1991. To appear. </note>
Reference-contexts: It is possible to construct such a meta-logic for unification over a number of different term languages and type theories, but a further exploration of this possibility is beyond the scope of this paper. Miller's mixed prefixes <ref> [20] </ref> and the existential variables considered by Dowek [4] perform a function similar to our unification logic.
Reference: [21] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <editor> In Peter Schroeder-Heister, editor, </editor> <booktitle> Extensions of Logic Programming, </booktitle> <pages> pages 153-281. </pages> <publisher> Springer-Verlag LNCS 475, </publisher> <year> 1991. </year>
Reference-contexts: However, inspired by Miller's Logic Programming in the LF Logical Framework 3 work on L <ref> [21] </ref>, we design an algorithm which solves the "easy" unification problems (without branching, for example) and postpones all other equalities which may arise as constraints. <p> Observing the actual practice of programming, both in Prolog and Elf, it is noticable that almost all defensible uses of unification are deterministic. Based on this observation, Miller designed a syntactically restricted logic programming language L <ref> [21] </ref> in which it is guaranteed that only deterministic unification problems arise during program execution. However, the restricted subset disallows important LF representation techniques.
Reference: [22] <author> Dale Miller, Gopalan Nadathur, Frank Pfenning, and Andre Scedrov. </author> <title> Uniform proofs as a foundation for logic programming. </title> <journal> Journal of Pure and Applied Logic, </journal> <note> 1988. To appear. Available as Ergo Report 88-055, </note> <institution> School of Computer Science, Carnegie Mellon University, Pittsburgh. </institution>
Reference-contexts: The basic idea behind Elf is to unify logic definition (in the style of LF) with logic programming (in the style of Prolog, see <ref> [22, 24] </ref>). It achieves this unification by giving types an operational interpretation, much the same way that Prolog gives certain formulas (Horn-clauses) an operational interpretation. An alternative approach to logic programming in LF has been developed independently by Pym [28]. <p> N n M 2 a M 1 . . . M n ! N 1 : : : The soundness theorem below is the crucial theorem in the context of logic programming. It has been argued elsewhere <ref> [22] </ref> that non-deterministic completeness is also an important criterion to consider. Here, completeness fails (even non-deterministically), due to the incompleteness of unification. On the other hand, there is an analogue to the precompleteness theorem in Section 3.5 which is beyond the scope of this paper.
Reference: [23] <author> Dale Miller, Gopalan Nadathur, and Andre Scedrov. </author> <title> Hereditary Harrop formulas and uniform proof systems. </title> <booktitle> In Second Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 98-105. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1987. </year>
Reference: [24] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Robert A. Kowalski and Kenneth A. Bowen, editors, </editor> <booktitle> Logic Programming: Proceedings of the Fifth International Conference and Symposium, </booktitle> <volume> Volume 1, </volume> <pages> pages 810-827, </pages> <address> Cambridge, Massachusetts, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: The basic idea behind Elf is to unify logic definition (in the style of LF) with logic programming (in the style of Prolog, see <ref> [22, 24] </ref>). It achieves this unification by giving types an operational interpretation, much the same way that Prolog gives certain formulas (Horn-clauses) an operational interpretation. An alternative approach to logic programming in LF has been developed independently by Pym [28]. <p> Due to the nature of LF, both of these differ significantly from first-order logic programming languages. In particular, proof search and unification become intertwined and unification is no longer a simple subroutine. This phenomenon is already familiar from constraint logic programming <ref> [17, 24] </ref>, but Elf has at least one additional complication: goals are identified with logic variables (see Section 4). This set of circumstances calls for a new approach to describe the operational semantics of Elf.
Reference: [25] <author> Lawrence C. Paulson and Tobias Nipkow. </author> <title> Isabelle tutorial and user's manual. </title> <type> Technical Report 189, </type> <institution> Computer Laboratory, University of Cambridge, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: The Isabelle system <ref> [25] </ref> also provides support for meta-variables and higher-order unification in tactics, but they are generally not as accessible as in Elf.
Reference: [26] <author> Frank Pfenning. </author> <title> Elf: A language for logic definition and verified meta-programming. </title> <booktitle> In Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 313-322. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: These proofs are left to a future paper. A preliminary account of Elf can be found in <ref> [26] </ref>. The range of applications of Elf includes theorem proving and proof transformation in various logics, definition and execution of structured operational and natural semantics for programming languages, type checking and type inference, etc. <p> The key idea is to develop an explicit meta-logic for LF, not to prove properties about LF, but to Logic Programming in the LF Logical Framework 5 describe the operational behavior of Elf. This meta-logic was called state logic in <ref> [26] </ref>, since it is used to describe the states of an abstract interpreter for Elf. An alternative approach was taken by Pym & Wallen [29] who give a sequent presentation for LF which allows free meta-variables to appear in the sequents. <p> On the other hand, there is an analogue to the precompleteness theorem in Section 3.5 which is beyond the scope of this paper. But the practical importance of such (pre)completeness theorems is not clear: an early version of Elf as described in <ref> [26] </ref> based on Elliott's unification algo rithm was non-deterministically complete, but in practice less useful than the version we describe here. <p> This is more or less forced, as Elf, unlike Prolog, will deliver proofs, not just substitutions. On the other hand, we try to be circumspect and only incorporate extensions which in some sense appear necessary. The addition of -types (strong sums) as first envisioned in <ref> [26] </ref> has not been necessary as anticipated and has, for the moment at least, been abandoned. It is possible, however, to include some search control operators in Elf programs without destroying the basic promise to deliver proofs for the original query.
Reference: [27] <author> Randy Pollack. </author> <title> Implicit syntax. Unpublished notes to a talk given at the First Workshop on Logical Frameworks in Antibes, </title> <month> May </month> <year> 1990. </year>
Reference-contexts: We are guaranteed that P is an equivalence proof for M and N only when this translation succeeds. 5.5 Type Reconstruction for Elf The method of type reconstruction for Elf is different from what is used in LEGO <ref> [27] </ref> or the implementation of the Calculus of Constructions at INRIA [16] in that (1) argument synthesis and type and term reconstruction are completely decoupled, and (2) there is no restriction on which types and terms can be omitted in the input. We only sketch the algorithm here.
Reference: [28] <author> David Pym. </author> <title> Proofs, Search and Computation in General Logic. </title> <type> PhD thesis, </type> <institution> University of Edinburgh, </institution> <year> 1990. </year> <note> Available as CST-69-90, also published as ECS-LFCS-90-125. </note>
Reference-contexts: It achieves this unification by giving types an operational interpretation, much the same way that Prolog gives certain formulas (Horn-clauses) an operational interpretation. An alternative approach to logic programming in LF has been developed independently by Pym <ref> [28] </ref>. Here are some of the salient characteristics of our unified approach to logic definition and meta-programming. First of all, the Elf search process automatically constructs terms that can represent object-logic proofs, and thus a program need not construct them explicitly. <p> This result notwithstanding, a complete pre-unification algorithm for the simply-typed -calculus with generally good operational Logic Programming in the LF Logical Framework 8 behavior has been devised by Huet [15]. Extensions to LF have been developed independently by Elliott [5, 7] and Pym <ref> [28] </ref>. "Pre-unification" here refers to the fact that the algorithm will not enumerate unifiers, but simply reduce the original problem to a satisfiable set of constraints (so-called flex-flex pairs) whose unifiers are difficult to enumerate.
Reference: [29] <author> David Pym and Lincoln Wallen. </author> <title> Investigations into proof-search in a system of first-order dependent function types. In M.E. </title> <editor> Stickel, editor, </editor> <booktitle> 10th International Conference on Automated Deduction, </booktitle> <address> Kaiserslautern, Germany, </address> <pages> pages 236-250. </pages> <publisher> Springer-Verlag LNCS 449, </publisher> <month> July </month> <year> 1990. </year>
Reference-contexts: This meta-logic was called state logic in [26], since it is used to describe the states of an abstract interpreter for Elf. An alternative approach was taken by Pym & Wallen <ref> [29] </ref> who give a sequent presentation for LF which allows free meta-variables to appear in the sequents. We begin with the discussion of unification which will be extended to a logic strong enough to describe the complete state of the interpreter in Section 4.
Reference: [30] <author> Anne Salvesen. </author> <title> The Church-Rosser theorem for LF with fi-reduction. Unpublished notes to a talk given at the First Workshop on Logical Frameworks in Antibes, </title> <month> May </month> <year> 1990. </year>
Reference-contexts: The notion of definitional equality we consider here is fi-conversion. Harper et al. [12] formulate definitional equality only with fi-conversion and conjecture that the system resulting from adding the -rule would have the properties we list below. This has recently been proved by Coquand [3] and independently by Salvesen <ref> [30] </ref>. For practical purposes the formulation including the -rule is superior, since every term has an equivalent canonical form. Thus, for us, is the least congruence generated by fi-conversions in the usual manner.
Reference: [31] <author> Wayne Snyder and Jean H. Gallier. </author> <title> Higher-order unification revisited: Complete sets of transformations. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 8 </volume> <pages> 101-140, </pages> <year> 1989. </year>
Reference-contexts: This allows the natural specification and manipulation of unsolved equations as constraints. 3.1 A First-Order Unification Logic with Quantifier Dependencies The unification logic arises most naturally from a generalization of the usual view of unification as transformations of a set of equations <ref> [19, 31] </ref>. There we are given set of equations with some free variables. This set is unifiable if there is a substitution for the free variables such that all the equations become true.
References-found: 31

