URL: http://www.cs.indiana.edu/database/Coral/coral.implementation.ps
Refering-URL: http://www.cs.indiana.edu/database/Coral/Coral.html
Root-URL: http://www.cs.indiana.edu
Title: Implementation of the CORAL Deductive Database System  
Author: Raghu Ramakrishnan Divesh Srivastava S. Sudarshan Praveen Seshadri 
Address: Wisconsin, Madison  Wisconsin, Madison  Murray Hill.  Wisconsin, Madison  
Affiliation: Univ. of  Univ. of  AT&T Bell Labs,  Univ. of  
Abstract: CORAL is a deductive database system that provides a modular, declarative query language/programming language [RSS92b]. We describe the architecture and implementation of CORAL in this paper. In comparison to other related systems such as Aditi, EKS-V1, LDL, LOLA and Nail-Glue, CORAL provides a considerably richer language, and supports a much wider range of optimization techniques. There were two distinct problems to address in the design of CORAL: (1) To integrate the different optimization techniques in the implementation, and (2) To give users access to the full power of the CORAL implementation. The first problem is solved in CORAL by dividing evaluation into a number of distinct sub-tasks, and providing a clean interface between the subtasks; relevant optimization techniques can be (almost) independently applied to each subtask. The module structure is a key to solving the second problem. The interface between modules is kept at a high level; evaluation techniques can be chosen on a per-module basis, and modules with different evaluation techniques can interact in a nearly transparent fashion. CORAL is integrated with C++, and users can program in a combination of declarative CORAL and extended C++. Further, the CORAL implementation is itself C++ code, and provides a variety of high-level primitives that allow a C++ programmer to make use of or extend the data-representation and the query evaluation system. This provides a high degree of extensibility. 
Abstract-found: 1
Intro-found: 1
Reference: [Ban85] <author> Francois Bancilhon. </author> <title> Naive evaluation of recursively defined relations. </title> <editor> In Brodie and Mylopou-los, editors, </editor> <title> On Knowledge Base Management Systems | Integrating Database and AI Systems. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: Bottom-up evaluation iterates on a set of rules, repeatedly evaluating them until a fixpoint is reached. In order to perform incremental evaluation of rules across multiple iterations, CORAL uses the Seminaive evaluation technique <ref> [Ban85, BR87a, RSS90] </ref>.
Reference: [BR87a] <author> I. Balbin and K. Ramamohanarao. </author> <title> A generalization of the differential approach to recursive query evaluation. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(3), </volume> <month> September </month> <year> 1987. </year>
Reference-contexts: Bottom-up evaluation iterates on a set of rules, repeatedly evaluating them until a fixpoint is reached. In order to perform incremental evaluation of rules across multiple iterations, CORAL uses the Seminaive evaluation technique <ref> [Ban85, BR87a, RSS90] </ref>.
Reference: [BR87b] <author> Catriel Beeri and Raghu Ramakrishnan. </author> <title> On the power of Magic. </title> <booktitle> In Proceedings of the ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 269-283, </pages> <address> San Diego, California, </address> <month> March </month> <year> 1987. </year> <month> 23 </month>
Reference-contexts: If this is done on the original program, selections in a query are not utilized. Several program transformations have been proposed to `propagate' such selections, and many of these are implemented in CORAL. The default rewriting technique is Supplementary Magic Templates <ref> [BR87b, Ram88] </ref>. The rewriting can be tailored to propagate bindings across subgoals in a rule body using different subgoal orderings; CORAL uses a left-to-right ordering within the body of a rule by default.
Reference: [CD85] <author> J.H. Chang and A. M. Despain. </author> <title> Semi-intelligent backtracking of Prolog based on static data--dependency analysis. </title> <booktitle> In Proc. Symposium on Logic Programming, </booktitle> <pages> pages 10-21, </pages> <year> 1985. </year>
Reference-contexts: Intelligent Backtracking Both pipelining and materialization involve indexed nested-loops join in CORAL. (For materialization, this is local to the joins in a single rule; for pipelining, it is effectively global, and over the sequence of all rules in the current execution path.) CORAL tries to perform intelligent backtracking (see e.g., <ref> [CD85] </ref>) during rule execution in both cases. Get-first backtracking provides the ability to `jump back' over several levels of nesting if no matching facts are found for the predicate in an inner level.
Reference: [CDRS86] <author> Michael Carey, David DeWitt, Joel Richardson, and Eugene Shekita. </author> <title> Object and file management in the EXODUS extensible database system. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1986. </year>
Reference-contexts: Support for persistent relations is provided by interfacing with the EXODUS storage manager <ref> [CDRS86] </ref>. A unique feature of CORAL is that it provides a wide range of evaluation strategies (such as top-down, bottom-up, and their variants) and allows users to optionally tailor execution of a program through high-level annotations. The language is described in [RSS92b]. <p> CORAL is designed primarily as a single user main-memory database system, and can be used in a stand-alone mode. CORAL also allows persistent data to be stored either as text files, or in the EXODUS storage manager <ref> [CDRS86] </ref>. Data stored in files can be `consulted', at which point the data is converted into main-memory relations, with any specified indices; indices can also be created later. <p> CORAL currently supports in-memory hash-relations, as well as persistent relations (the latter by using the EXODUS storage manager <ref> [CDRS86] </ref>). CORAL supports multiple indices on relations, and provides methods for adding indices to an existing relation. The relation interface is designed to make the addition of new relation implementations (as subclasses of the generic class Relation relatively easy.
Reference: [CGK89] <author> D. Chimenti, R. Gamboa, and R. Krishnamurthy. </author> <title> Abstract machine for LDL. </title> <type> Technical Report ACT-ST-268-89, </type> <institution> MCC, Austin, TX, </institution> <year> 1989. </year>
Reference-contexts: Intelligent backtracking for pipelined evaluation is also done on a per-rule basis, although there is the potential for doing it on a global basis. We note that LDL also implements a form of intelligent backtracking <ref> [CGK89] </ref>.
Reference: [CGK + 90] <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 76-90, </pages> <year> 1990. </year>
Reference-contexts: Functor terms are important for data representation power; for instance, lists are important for representing structures such as sequences (e.g., DNA or stock quote sequences). Sequence data is expected to be an important application area for databases in the future. The current implementation of CORAL uses hash-consing <ref> [Got74, CGK + 90] </ref> to speed up unification of functor terms. Hash-consing essentially assigns unique identifiers to each (ground) functor term, such that two (ground) functor terms unify if and only if their unique identifiers are the same.
Reference: [FSS91] <author> B. Freitag, H. Schutz, and G. Specht. </author> <title> LOLA a logic language for deductive databases and its implementation. </title> <booktitle> In Proc. 2nd Int. Symp. on Database Systems for Advanced Applications (DASFAA), </booktitle> <year> 1991. </year>
Reference-contexts: In comparison to other deductive database systems such as Aditi [VRK + 90], EKS-V1 [VBKL90], LDL [TZ86], LOLA <ref> [FSS91] </ref> and Nail-Glue [MUVG86], CORAL supports a much wider range of optimization techniques. The power of these techniques is demonstrated in the performance section. We highlight several design decisions that allowed us to integrate (often unrelated) evaluation techniques and optimizations in a nearly seamless fashion. <p> For a module with just 3-4 rules, it is about 50% slower. (It is usually a simple matter to restructure a program to minimize the number of rules in a module to be evaluated with Ordered Search.) 12 Related Work Deductive database systems <ref> [VRK + 90, TZ86, VBKL90, MUVG86, FSS91, HCL + 90] </ref>, Prolog, and rule based systems such as RDL [KdMS90] are the most closely related to CORAL.
Reference: [Got74] <author> E. Goto. </author> <title> Monocopy and associative algorithms in an extended lisp. </title> <type> Technical Report 74-03, </type> <institution> Information Science Laboratory, Univ. of Tokyo, </institution> <address> Tokyo, Japan, </address> <month> May </month> <year> 1974. </year>
Reference-contexts: Functor terms are important for data representation power; for instance, lists are important for representing structures such as sequences (e.g., DNA or stock quote sequences). Sequence data is expected to be an important application area for databases in the future. The current implementation of CORAL uses hash-consing <ref> [Got74, CGK + 90] </ref> to speed up unification of functor terms. Hash-consing essentially assigns unique identifiers to each (ground) functor term, such that two (ground) functor terms unify if and only if their unique identifiers are the same.
Reference: [HCL + 90] <author> L.M. Haas, W. Chang, G.M. Lohman, J. McPherson, P.F. Wilms, G. Lapis, B. Lindsay, H. Pira-hesh, M. Carey, and E. Shekita. </author> <title> Starburst mid-flight: As the dust clears. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <pages> pages 143-160, </pages> <month> March </month> <year> 1990. </year> <note> Also available as IBM Research Report RJ7278, </note> <institution> San Jose, </institution> <address> CA, </address> <month> Jan. </month> <year> 1990. </year>
Reference-contexts: For a module with just 3-4 rules, it is about 50% slower. (It is usually a simple matter to restructure a program to minimize the number of rules in a module to be evaluated with Ordered Search.) 12 Related Work Deductive database systems <ref> [VRK + 90, TZ86, VBKL90, MUVG86, FSS91, HCL + 90] </ref>, Prolog, and rule based systems such as RDL [KdMS90] are the most closely related to CORAL.
Reference: [KdMS90] <author> G. Kiernan, C. de Maindreville, and E. Simon. </author> <title> Making deductive database a practical technology: a step forward. </title> <booktitle> In Proceedings of the ACM SIGMOD Conf. on Management of Data, </booktitle> <year> 1990. </year>
Reference-contexts: slower. (It is usually a simple matter to restructure a program to minimize the number of rules in a module to be evaluated with Ordered Search.) 12 Related Work Deductive database systems [VRK + 90, TZ86, VBKL90, MUVG86, FSS91, HCL + 90], Prolog, and rule based systems such as RDL <ref> [KdMS90] </ref> are the most closely related to CORAL. The use of the module structure and annotations to allow a combination of optimization techniques and programming styles is one of the important contributions of CORAL.
Reference: [KRS90] <author> D. Kemp, K. Ramamohanarao, and Z. Somogyi. Right-, </author> <title> left-, and multi-linear rule transformations that maintain context information. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <pages> pages 380-391, </pages> <address> Brisbane, Australia, </address> <year> 1990. </year>
Reference-contexts: Other selection-propagating rewriting techniques supported in CORAL include Magic Templates [Ram88], Supplementary Magic With GoalId Indexing [RS91], and Context Factoring <ref> [NRSU89, KRS90] </ref>. Supplementary Magic is a good general choice, although each technique is superior to the rest for some programs. For example, the GoalId Indexing variant is good for programs with many complex, especially non-ground, terms, and Factoring, while only applicable on some programs, is usually superior when applicable.
Reference: [MUVG86] <author> Katherine Morris, Jeffrey D. Ullman, and Allen Van Gelder. </author> <title> Design overview of the NAIL! system. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming, </booktitle> <year> 1986. </year>
Reference-contexts: In comparison to other deductive database systems such as Aditi [VRK + 90], EKS-V1 [VBKL90], LDL [TZ86], LOLA [FSS91] and Nail-Glue <ref> [MUVG86] </ref>, CORAL supports a much wider range of optimization techniques. The power of these techniques is demonstrated in the performance section. We highlight several design decisions that allowed us to integrate (often unrelated) evaluation techniques and optimizations in a nearly seamless fashion. <p> For a module with just 3-4 rules, it is about 50% slower. (It is usually a simple matter to restructure a program to minimize the number of rules in a module to be evaluated with Ordered Search.) 12 Related Work Deductive database systems <ref> [VRK + 90, TZ86, VBKL90, MUVG86, FSS91, HCL + 90] </ref>, Prolog, and rule based systems such as RDL [KdMS90] are the most closely related to CORAL.
Reference: [NRSU89] <author> Jeffrey F. Naughton, Raghu Ramakrishnan, Yehoshua Sagiv, and Jeffrey D. Ullman. </author> <title> Argument reduction through factoring. </title> <booktitle> In Proceedings of the Fifteenth International Conference on Very Large Databases, </booktitle> <pages> pages 173-182, </pages> <address> Amsterdam, The Netherlands, </address> <month> August </month> <year> 1989. </year>
Reference-contexts: Other selection-propagating rewriting techniques supported in CORAL include Magic Templates [Ram88], Supplementary Magic With GoalId Indexing [RS91], and Context Factoring <ref> [NRSU89, KRS90] </ref>. Supplementary Magic is a good general choice, although each technique is superior to the rest for some programs. For example, the GoalId Indexing variant is good for programs with many complex, especially non-ground, terms, and Factoring, while only applicable on some programs, is usually superior when applicable.
Reference: [Ram88] <author> Raghu Ramakrishnan. </author> <title> Magic Templates: A spellbinding approach to logic programs. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <pages> pages 140-159, </pages> <address> Seattle, Washington, </address> <month> August </month> <year> 1988. </year>
Reference-contexts: If this is done on the original program, selections in a query are not utilized. Several program transformations have been proposed to `propagate' such selections, and many of these are implemented in CORAL. The default rewriting technique is Supplementary Magic Templates <ref> [BR87b, Ram88] </ref>. The rewriting can be tailored to propagate bindings across subgoals in a rule body using different subgoal orderings; CORAL uses a left-to-right ordering within the body of a rule by default. <p> The rewriting can be tailored to propagate bindings across subgoals in a rule body using different subgoal orderings; CORAL uses a left-to-right ordering within the body of a rule by default. Other selection-propagating rewriting techniques supported in CORAL include Magic Templates <ref> [Ram88] </ref>, Supplementary Magic With GoalId Indexing [RS91], and Context Factoring [NRSU89, KRS90]. Supplementary Magic is a good general choice, although each technique is superior to the rest for some programs.
Reference: [RS91] <author> Raghu Ramakrishnan and S. Sudarshan. </author> <title> Top-Down vs. Bottom-Up Revisited. </title> <booktitle> In Proceedings of the International Logic Programming Symposium, </booktitle> <year> 1991. </year>
Reference-contexts: The rewriting can be tailored to propagate bindings across subgoals in a rule body using different subgoal orderings; CORAL uses a left-to-right ordering within the body of a rule by default. Other selection-propagating rewriting techniques supported in CORAL include Magic Templates [Ram88], Supplementary Magic With GoalId Indexing <ref> [RS91] </ref>, and Context Factoring [NRSU89, KRS90]. Supplementary Magic is a good general choice, although each technique is superior to the rest for some programs.
Reference: [RSS90] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Rule ordering in bottom-up fixpoint evaluation of logic programs. </title> <booktitle> In Proceedings of the Sixteenth International Conference on Very Large Databases, </booktitle> <month> August </month> <year> 1990. </year>
Reference-contexts: Bottom-up evaluation iterates on a set of rules, repeatedly evaluating them until a fixpoint is reached. In order to perform incremental evaluation of rules across multiple iterations, CORAL uses the Seminaive evaluation technique <ref> [Ban85, BR87a, RSS90] </ref>.
Reference: [RSS92a] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> Controlling the search in bottom-up evaluation. </title> <booktitle> In Joint Int'l Conf. and Symp. on Logic Programming 1992 (to appear), </booktitle> <year> 1992. </year>
Reference-contexts: We do not present details here for lack of space. 5.3 Ordered Search Ordered Search is an evaluation mechanism that orders the use of generated subgoals in a program. We do not present full details of Ordered Search here, but refer the reader to <ref> [RSS92a] </ref>.
Reference: [RSS92b] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <title> CORAL: Control, Relations and Logic. </title> <booktitle> In Proceedings of the International Conference on Very Large Databases, </booktitle> <year> 1992. </year> <month> 24 </month>
Reference-contexts: A unique feature of CORAL is that it provides a wide range of evaluation strategies (such as top-down, bottom-up, and their variants) and allows users to optionally tailor execution of a program through high-level annotations. The language is described in <ref> [RSS92b] </ref>. <p> Performance results are presented in Section 11, and directions for future work are indicated in Section 13. Related systems are discussed in Section 12. 2 Overview of the CORAL Declarative Language We present a brief summary of the CORAL declarative language in this section. The reader is referred to <ref> [RSS92b] </ref> for details. The query language supports general Horn clauses with complex terms (lists, ar 2 rays, Herbrand terms), set-grouping, aggregation, negation, and relations with tuples that contain (universally quantified) variables. <p> Annotations control query evaluation and also guide query optimization. This high-level representation is important, since it gives the user the power to control optimization and evaluation in a relatively abstract manner. A detailed description of the annotations provided by CORAL may be found in <ref> [RSS92b] </ref>; we mention some of them when discussing the query evaluation techniques. The query optimizer decides (on a per-module basis) whether to use one of two basic evaluation approaches, namely pipelining or materialization, which are discussed in Section 5. <p> For a summary of the virtual methods that constitute the abstract data type interface, see <ref> [RSS92b, RSSS92] </ref>. In addition to defining the abstract data type, the user can create builtin-predicates to manipulate (and possibly display in novel ways) objects belonging to the abstract data types. These builtin-predicates must be registered with the system; registration is accomplished by a single command. <p> We plan to support explicit transaction initiation and termination commands as part of the CORAL interface, so as to allow users greater flexibility in managing transactions. 11 Performance Results We presented some performance results comparing CORAL and LDL in <ref> [RSS92b] </ref>. We found that while LDL performed better on some non-recursive Datalog queries, in which the overheads of CORAL's more complex data representation become significant relative to other costs, CORAL is in general faster than LDL, sometimes by orders of magnitude. CORAL is also more stable in its performance characterictics.
Reference: [RSS92c] <author> Raghu Ramakrishnan, Divesh Srivastava, and S. Sudarshan. </author> <booktitle> Semi-naive implementation of save--module in CORAL. In preparation., </booktitle> <year> 1992. </year>
Reference-contexts: Details are available in <ref> [RSS92c] </ref>, but we omit them here for lack of space. 8.3 Lazy Evaluation In the traditional approach to bottom-up evaluation, all answers to a query are computed by iterating over rules till a fix-point is reached, and then returning all the answers.
Reference: [RSSS92] <author> Raghu Ramakrishnan, Praveen Seshadri, Divesh Srivastava, and S. Sudarshan. </author> <title> The CORAL user manual. </title> <year> 1992. </year>
Reference-contexts: For a summary of the virtual methods that constitute the abstract data type interface, see <ref> [RSS92b, RSSS92] </ref>. In addition to defining the abstract data type, the user can create builtin-predicates to manipulate (and possibly display in novel ways) objects belonging to the abstract data types. These builtin-predicates must be registered with the system; registration is accomplished by a single command.
Reference: [SR92] <author> S. Sudarshan and Raghu Ramakrishnan. </author> <title> Optimizations of bottom-up evaluation with non-ground terms. </title> <note> In preparation, </note> <year> 1992. </year>
Reference-contexts: Indexing is used in two ways: (1) to retrieve matching tuples in a join, and (2) to check for duplicates. As discussed in <ref> [SR92] </ref>, Supplementary Magic Templates with GoalId indexing can deal satisfactorily with the first situtation, even in the presence of non-ground terms. Indexing for eliminating duplicates remains a hard problem. <p> Indexing for eliminating duplicates remains a hard problem. In addition to creating indexing problems, non-ground terms cause some additional unifications to be performed; these can cause bottom-up evaluation to be asymptotically inferior to top-down evaluation unless some additional optimizations are implemented <ref> [SR92] </ref>. While a detailed discussion of these issues is beyond the scope of this paper, we note that the optimizations of [SR92], which ensure that CORAL asymptotically dominates (upto a log factor) Prolog implementations even for programs with non-ground terms, are implemented in CORAL. 4 We view the support for non-ground <p> indexing problems, non-ground terms cause some additional unifications to be performed; these can cause bottom-up evaluation to be asymptotically inferior to top-down evaluation unless some additional optimizations are implemented <ref> [SR92] </ref>. While a detailed discussion of these issues is beyond the scope of this paper, we note that the optimizations of [SR92], which ensure that CORAL asymptotically dominates (upto a log factor) Prolog implementations even for programs with non-ground terms, are implemented in CORAL. 4 We view the support for non-ground terms as an essential first step toward the support of constraint facts such as p (X,Y) where X &lt; Y . <p> Materialized evaluation (with Supplementary Magic; Factoring is not applicable) takes 2.5 s for appending two (ground) lists of lenth 400, and 17s for length 2400; pipelining takes 1.6s and 12.5s, respectively. For lists that contain non-ground terms, the optimizations of <ref> [SR92, Sud92] </ref> are critical for materialized evaluation.
Reference: [SRSS92] <author> Divesh Srivastava, Raghu Ramakrishnan, Praveen Seshadri, and S. Sudarshan. </author> <title> CORAL++: Adding object-orientation to CORAL. </title> <note> Submitted for publication., </note> <year> 1992. </year>
Reference-contexts: Third, we will add an explanation-based debugging package (which is currently being implemented using CORAL and the extended C++ interface). Finally, we will make some language extensions, notably ordered scans and relations-as-arrays, and implement a proposal to add object-orientation to CORAL <ref> [SRSS92] </ref>. Acknowledgements We would like to acknowledge the contributions of the following people to the CORAL system. Per Bothner, who was largely responsible for the initial implementation of CORAL that served as the basis for subsequent development, was a major early contributor.
Reference: [Sud92] <author> S. Sudarshan. </author> <title> Optimizing Bottom-Up Evaluation for Deductive Databases. </title> <type> PhD thesis, </type> <institution> University of Wisconsin, Madison, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: This involves an increased cost in looking up the variable environment. CORAL uses such a technique for structure sharing of non-ground facts as well as reducing unification costs for non-ground facts <ref> [Sud92] </ref>. We do not present details here for lack of space. 5.3 Ordered Search Ordered Search is an evaluation mechanism that orders the use of generated subgoals in a program. We do not present full details of Ordered Search here, but refer the reader to [RSS92a]. <p> Materialized evaluation (with Supplementary Magic; Factoring is not applicable) takes 2.5 s for appending two (ground) lists of lenth 400, and 17s for length 2400; pipelining takes 1.6s and 12.5s, respectively. For lists that contain non-ground terms, the optimizations of <ref> [SR92, Sud92] </ref> are critical for materialized evaluation.
Reference: [TZ86] <author> Shalom Tsur and Carlo Zaniolo. </author> <title> LDL: A logic-based data-language. </title> <booktitle> In Proceedings of the Twelfth International Conference on Very Large Data Bases, </booktitle> <pages> pages 33-41, </pages> <address> Kyoto, Japan, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: In comparison to other deductive database systems such as Aditi [VRK + 90], EKS-V1 [VBKL90], LDL <ref> [TZ86] </ref>, LOLA [FSS91] and Nail-Glue [MUVG86], CORAL supports a much wider range of optimization techniques. The power of these techniques is demonstrated in the performance section. We highlight several design decisions that allowed us to integrate (often unrelated) evaluation techniques and optimizations in a nearly seamless fashion. <p> For a module with just 3-4 rules, it is about 50% slower. (It is usually a simple matter to restructure a program to minimize the number of rules in a module to be evaluated with Ordered Search.) 12 Related Work Deductive database systems <ref> [VRK + 90, TZ86, VBKL90, MUVG86, FSS91, HCL + 90] </ref>, Prolog, and rule based systems such as RDL [KdMS90] are the most closely related to CORAL.
Reference: [VBKL90] <author> L. Vieille, P. Bayer, V. Kuchenhoff, and A. Lefebvre. EKS-V1, </author> <title> a short overview. </title> <booktitle> In AAAI-90 Workshop on Knowledge Base Management Systems, </booktitle> <year> 1990. </year>
Reference-contexts: In comparison to other deductive database systems such as Aditi [VRK + 90], EKS-V1 <ref> [VBKL90] </ref>, LDL [TZ86], LOLA [FSS91] and Nail-Glue [MUVG86], CORAL supports a much wider range of optimization techniques. The power of these techniques is demonstrated in the performance section. We highlight several design decisions that allowed us to integrate (often unrelated) evaluation techniques and optimizations in a nearly seamless fashion. <p> For a module with just 3-4 rules, it is about 50% slower. (It is usually a simple matter to restructure a program to minimize the number of rules in a module to be evaluated with Ordered Search.) 12 Related Work Deductive database systems <ref> [VRK + 90, TZ86, VBKL90, MUVG86, FSS91, HCL + 90] </ref>, Prolog, and rule based systems such as RDL [KdMS90] are the most closely related to CORAL.
Reference: [VRK + 90] <author> Jayen Vaghani, Kotagiri Ramamohanarao, David Kemp, Zoltan Somogyi, and Peter Stuckey. </author> <title> The Aditi deductive database system. </title> <booktitle> In Proceedings of the NACLP'90 Workshop on Deductive Database Systems, </booktitle> <year> 1990. </year> <month> 25 </month>
Reference-contexts: In comparison to other deductive database systems such as Aditi <ref> [VRK + 90] </ref>, EKS-V1 [VBKL90], LDL [TZ86], LOLA [FSS91] and Nail-Glue [MUVG86], CORAL supports a much wider range of optimization techniques. The power of these techniques is demonstrated in the performance section. <p> For a module with just 3-4 rules, it is about 50% slower. (It is usually a simple matter to restructure a program to minimize the number of rules in a module to be evaluated with Ordered Search.) 12 Related Work Deductive database systems <ref> [VRK + 90, TZ86, VBKL90, MUVG86, FSS91, HCL + 90] </ref>, Prolog, and rule based systems such as RDL [KdMS90] are the most closely related to CORAL.
References-found: 27

