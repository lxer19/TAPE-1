URL: http://www.cse.ogi.edu/cse509/papers/Anderson-92-12.ps
Refering-URL: http://www.cse.ogi.edu/cse509/References.html
Root-URL: http://www.cse.ogi.edu
Title: Object-Oriented Programming Language for Distributed Computers  
Author: Birger Andersen 
Address: Universitetsparken 1 2100 Copenhagen, Denmark  
Affiliation: Department of Computer Science University of Copenhagen  University of Copenhagen.  
Note: A General, Grain-Size Adaptable,  Partial Ph.D. Dissertation 1  
Email: E-mail: birger@diku.dk,  
Phone: Fax: +45 35 32 14 01, Phone: +45 35 32 18 18  
Degree: requirements for the degree of Doctor of Philosophy,  
Date: November 1992  
Abstract: DIKU Report no. 92/12 
Abstract-found: 1
Intro-found: 1
Reference: [Agha 86a] <author> Gul Agha. </author> <title> ACTORS: A Model of Concurrent Computation in Distributed Systems. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: The object-oriented language Cantor [Athas 87a, 87b, 88] has fine-grained parallelism, but Cantor is intended for scientific calculations and not really meant as a high level language. The LISP based object-oriented Actor languages have implicit fine-grained parallelism <ref> [Agha 86a, 86b, 87, 88; Lieberman 86, 87] </ref>, but LISP based languages are not very general due to their way of handling large mutable data structures that need to be generally accessible. They need to be passed as value parameters and this is not acceptable for writing, e.g., operating systems.
Reference: [Agha 86b] <author> Gul Agha. </author> <title> An overview of Actor languages. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(10) </volume> <pages> 58-67, </pages> <month> October </month> <year> 1986. </year>
Reference: [Agha 87] <author> Gul Agha and Carl Hewitt. </author> <title> Actors: A conceptual foundation for concurrent objectoriented programming. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 49-74, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Therefore, object definitions must have a very general syntax and semantics. Some inspiration is found in Actors <ref> [Agha 87] </ref>, Beta [Kristensen 87, 91], Emerald [Black 86, 87; Hutchinson 87a, 87b; Raj 91], Self [Ungar 87], and Smalltalk [Goldberg 89]. Reducible parallelism at many levels For simplicity reasons, the same language construct/mechanism should facilitate generation of fine-grained as well as medium-grained and coarse-grained parallelism. <p> Inheritance and delegation Almost any object-oriented programming language is either inheritance based or delegation based. The best known inheritance based languages are Simula [Birtwistle 79] and Smalltalk [Goldberg 89]. Inheritance is for example discussed in [Snyder 86; Meyer 86]. The best known delegation based language is Actors <ref> [Agha 87] </ref>.
Reference: [Agha 88] <author> Gul Agha. </author> <title> Foundational issues in concurrent computing. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on Object-Based Concurrent Programming, </booktitle> <month> September </month> <year> 1988. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(4) </volume> <pages> 60-65, </pages> <month> April </month> <year> 1989. </year>
Reference: [America 87] <author> Pierre America. POOL-T: </author> <title> A parallel objectoriented language. </title> <editor> In Akinori Yonezawa and Mario Tokoro, editors, </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pages 199-220, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference: [Andersen 91a] <author> Birger Andersen. </author> <title> Ellie Language Definition Report. </title> <type> Ph.D. thesis (partial), DIKU Report no. 91/3, </type> <institution> Department of Computer Science, University of Copenhagen, Denmark, </institution> <month> June </month> <year> 1991 </year> <month> (2nd ed.). </month> <journal> Also ACM SIGPLAN Notices, </journal> <volume> 25(11) </volume> <pages> 45-64, </pages> <month> November </month> <year> 1990 </year> <month> (1st ed.). </month>
Reference-contexts: In Ellie, this technique is also incorporated to deal with the flexibility against efficiency conflict. The exact definition of conformity 8 typing in Emerald can be found in [Hutchinson 87a]. The definition in Ellie can be found in <ref> [Andersen 91a] </ref>. 1.3.3 Grain-Size Adaption The terms fine-grained, medium-grained, and coarse-grained are generally used for describing levels of parallelism, i.e., grainsizes. If processes are fine-grained then they communicate with each other whenever they have executed a few machine instructions. Medium-grained and coarse-grained processes communicate less frequently. <p> Grain-Size Adaption in the Fine-Grained Object-Oriented Language Ellie The first report defines the Ellie language in details by means of a context free grammar and small examples. The definition of Ellie is informal but complete. The report can also be used as an tutorial introduction to Ellie <ref> [Andersen 91a] </ref>. The second report concentrates on the fine-grained parallelism and the synchronization principle in Ellie. Fine-grained programming examples are investigated and adaption schemes are briefly discussed [Andersen 91c]. The last report contains a language overview demonstrating the flexibility of Ellie. <p> This approach has to my knowledge not yet been applied in a high level environment comparable to Ellie. The usual approach is detection of potential parallelism in sequential programs and not the opposite. 14 Chapter 3 Conclusion The dissertation consist of this main report and three research reports <ref> [Andersen 91a, 91c, 91d] </ref>. This last chapter concludes the dissertation by discussing the realization of the goals of the language design and the grain-size adaption approach. <p> Da der ventes meget finkornede 18 parallelle datamater pfi markedet i fremtiden, mfi Ellie sfiledes samtidig give mulighed for fin-kornet parallelisme. Afhandlingen omfatter udover denne sammenfattende rapport tre rapporter. I <ref> [Andersen 91a] </ref> beskrives resultatet af udviklingen af Ellie ved en detaljeret sprogdefinition, der omfatter bfide syntaks og uformel semantik. Desuden gives eksempler pfi anvendelser, sfiledes at rapporten ogsfi kan bruges til at stte sig ind i Ellie. I [Andersen 91c] beskrives srligt de finkornede parallelle egenskaber ved Ellie.
Reference: [Andersen 91b] <author> Birger Andersen. Ellie AGeneral, </author> <title> Fine-Grained, First Class Object Based Language. </title> <institution> Research Paper, Department of Computer Science, University of Copenhagen, Denmark, </institution> <month> October </month> <year> 1991. </year> <note> To appear in Journal of Object-Oriented Programming. </note>
Reference-contexts: The idea of functions and operations originate from Emerald where immutable (constant) objects can only deliver functions as a service, i.e., not operations. 5. The language overview part of this report is also available as <ref> [Andersen 91b] </ref>. 10 Chapter 2 The Dissertation In this dissertation only few assumptions about the hardware and the system kernel of the distributed parallel computer are taken. Otherwise, the Ellie language would be too dependent of specific computers.
Reference: [Andersen 91c] <author> Birger Andersen. </author> <title> Fine-Grained Parallelism in Ellie. </title> <type> Ph.D. thesis (partial), DIKU Report no. 91/4, </type> <institution> Department of Computer Science, University of Copenhagen, Denmark, </institution> <month> June </month> <year> 1991. </year> <note> Also to appear in Journal of Object-Oriented Programming. </note>
Reference-contexts: A fine-grained parallel computer is one that supports fine-grained objects and fine-grained parallelism efficiently. Language and computer grainsizes are further discussed in <ref> [Stone 87; Gupta 88; Kruatrachue 88; McCreary 89; Andersen 91c, 91d] </ref>. <p> The definition of Ellie is informal but complete. The report can also be used as an tutorial introduction to Ellie [Andersen 91a]. The second report concentrates on the fine-grained parallelism and the synchronization principle in Ellie. Fine-grained programming examples are investigated and adaption schemes are briefly discussed <ref> [Andersen 91c] </ref>. The last report contains a language overview demonstrating the flexibility of Ellie. However, the main part of it deals with techniques for reducing fine-grained processes to more coarse-grained processes. Generation of efficient code is also discussed. <p> Afhandlingen omfatter udover denne sammenfattende rapport tre rapporter. I [Andersen 91a] beskrives resultatet af udviklingen af Ellie ved en detaljeret sprogdefinition, der omfatter bfide syntaks og uformel semantik. Desuden gives eksempler pfi anvendelser, sfiledes at rapporten ogsfi kan bruges til at stte sig ind i Ellie. I <ref> [Andersen 91c] </ref> beskrives srligt de finkornede parallelle egenskaber ved Ellie. Endelig introduceres Ellie i [Andersen 91d] med eksempler, der viser den store fleksibilitet i sproget, hvorefter denne rapports hovedemnetilpasning af korn-strrelsen i Ellie programmer pfi oversttelsestidstuderes nje.
Reference: [Andersen 91d] <author> Birger Andersen. </author> <title> Grain-Size Adaption in the Fine-Grained ObjectOriented Language Ellie. </title> <type> Ph.D. thesis (partial), DIKU Report no. 91/5, </type> <institution> Department of Computer Science, University of Copenhagen, Denmark, </institution> <note> June 1992 (2nd ed.). </note>
Reference-contexts: However, the main part of it deals with techniques for reducing fine-grained processes to more coarse-grained processes. Generation of efficient code is also discussed. At last, some experiments show how to handle grainsize measurements and how to use them for grain-size adaption <ref> [Andersen 91d] </ref>. 5 An Ellie kernel implemented by Bjarne Hansen is presented in his Master thesis [Hansen 91]. A simple Ellie compiler and an Ellie virtual code interpreter have been implemented by myself. 4. <p> Still, there is a demand for mobility if an entire long lived and running system needs to be moved to a new computer. 16 Adaption implementation The adaption analyzer and the code optimizer need to be implemented in the Ellie compiler to fully investigate the ideas suggested in <ref> [Andersen 91d] </ref>. Garbage collection Currently, the Ellie kernel generates garbage, i.e., unreachable dead objects, that can not be collected. Only few objects free memory when their processes terminate. The transputer network can be filled with garbage in less than 30 sec. <p> Desuden gives eksempler pfi anvendelser, sfiledes at rapporten ogsfi kan bruges til at stte sig ind i Ellie. I [Andersen 91c] beskrives srligt de finkornede parallelle egenskaber ved Ellie. Endelig introduceres Ellie i <ref> [Andersen 91d] </ref> med eksempler, der viser den store fleksibilitet i sproget, hvorefter denne rapports hovedemnetilpasning af korn-strrelsen i Ellie programmer pfi oversttelsestidstuderes nje.
Reference: [Andrews 82] <author> Gregory R. Andrews. </author> <title> The distributed programming language SR mechanisms, design and implementation. </title> <journal> Software - Practice and Experience, </journal> <volume> 12(8) </volume> <pages> 719-753, </pages> <month> August </month> <year> 1982. </year> <month> 21 </month>
Reference: [Athas 87a] <author> William C. Athas. </author> <title> Fine Grain Concurrent Computations. </title> <type> Ph.D. thesis, Technical Report 5242, </type> <institution> Department of Computer Science, California Institute of Technology, Pasadena, California, </institution> <month> May </month> <year> 1987. </year>
Reference-contexts: Because fine-grained low cost computers are becoming available, general languages supporting fine-grained parallel programming must be able to exploit the capabilities of such computers. The object-oriented language Cantor <ref> [Athas 87a, 87b, 88] </ref> has fine-grained parallelism, but Cantor is intended for scientific calculations and not really meant as a high level language.
Reference: [Athas 87b] <author> William C. Athas and Charles L. Seitz. </author> <title> The Cantor User Report, Version 2.0. </title> <type> Technical Report 5232, </type> <institution> Department of Computer Science, California Institute of Technology, Pasadena, California, </institution> <month> January </month> <year> 1987. </year>
Reference: [Athas 88] <author> William C. Athas and Charles L. Seitz. </author> <title> Multicomputers: Message-passing concurrent computers. </title> <journal> IEEE Computer, </journal> <volume> 21(8) </volume> <pages> 9-24, </pages> <month> August </month> <year> 1988. </year>
Reference: [Barnes 84] <author> J.G.P. Barnes. </author> <booktitle> Programming in Ada, 2nd ed.. </booktitle> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Massachusetts, </address> <year> 1984. </year>
Reference-contexts: Medium-grained and coarse-grained processes communicate less frequently. For example, coarse-grained processes may be programs executing at workstations on a local area network. During the last 15 years a number of parallel languages have been proposed. This range includes languages such as Concurrent Pascal [Brinch Hansen 75, 77], Ada <ref> [Barnes 84] </ref>, Emerald [Hutchinson 87a, 87b; Raj 91], Concurrent Smalltalk [Yokote 86], ABCL/1 [Shibayama 87; Yonezawa 86], Argus [Liskov 88], NIL [Strom 83], and Joyce [Brinch Hansen 87a, 87b].
Reference: [Bershad 88] <author> Brian N. Bershad, Edward D. Lazowska, and Henry M. Levy. </author> <title> PRESTO: A system for objectoriented parallel programming. </title> <journal> Software Practice and Experience, </journal> <volume> 18(8) </volume> <pages> 713-732, </pages> <month> August </month> <year> 1988. </year>
Reference: [Birtwistle 79] <author> Graham M. Birtwistle, Ole-Johan Dahl, Bjrn Myhrhaug, and Kristen Nygaard. </author> <title> SIMULA BEGIN. </title> <institution> Studentlitteratur, Lund, Sweden, </institution> <year> 1979. </year>
Reference-contexts: The flexible concept of conformity type checking known from Emerald is incorporated in Ellie [Black 86, 87; Hutchinson 87a, 87b]. Inheritance and delegation Almost any object-oriented programming language is either inheritance based or delegation based. The best known inheritance based languages are Simula <ref> [Birtwistle 79] </ref> and Smalltalk [Goldberg 89]. Inheritance is for example discussed in [Snyder 86; Meyer 86]. The best known delegation based language is Actors [Agha 87].
Reference: [Black 86] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object structure in the Emerald system. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <month> October </month> <year> 1986. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 78-86, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Hereby, efficient code can be generated in most cases. This has been incorporated in the design of Emerald with success <ref> [Black 86, 87; Hutchinson 87a, 87b] </ref>. The strength of conformity typing compared to strong typing is, however, the flexibility. A type can be used instead of another type, e.g., the defined type of a variable in an assignment, when the actual type conforms to the original one. <p> Therefore, object definitions must have a very general syntax and semantics. Some inspiration is found in Actors [Agha 87], Beta [Kristensen 87, 91], Emerald <ref> [Black 86, 87; Hutchinson 87a, 87b; Raj 91] </ref>, Self [Ungar 87], and Smalltalk [Goldberg 89]. Reducible parallelism at many levels For simplicity reasons, the same language construct/mechanism should facilitate generation of fine-grained as well as medium-grained and coarse-grained parallelism. The only way to generate parallelism is to create processes. <p> The flexible concept of conformity type checking known from Emerald is incorporated in Ellie <ref> [Black 86, 87; Hutchinson 87a, 87b] </ref>. Inheritance and delegation Almost any object-oriented programming language is either inheritance based or delegation based. The best known inheritance based languages are Simula [Birtwistle 79] and Smalltalk [Goldberg 89]. Inheritance is for example discussed in [Snyder 86; Meyer 86]. <p> The idea of including immutable (constant) objects in other objects has been implemented in the distributed Emerald system <ref> [Black 86; Raj 91] </ref>. Emerald 12 also includes objects only accessed by one object into that object. Other methods for reducing the grain-size is also investigated.
Reference: [Black 87] <author> Andrew Black, Norman Hutchinson, Eric Jul, Henry Levy, and Larry Carter. </author> <title> Distribution and abstract types in Emerald. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(1) </volume> <pages> 65-76, </pages> <month> January </month> <year> 1987. </year> <note> Also Technical Report 86-02-04, </note> <institution> Department of Computer Science, University of Washington. </institution>
Reference: [Brinch Hansen 75] <author> Per Brinch Hansen. </author> <title> The programming language Concurrent Pascal. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 1(2) </volume> <pages> 199-207, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: Medium-grained and coarse-grained processes communicate less frequently. For example, coarse-grained processes may be programs executing at workstations on a local area network. During the last 15 years a number of parallel languages have been proposed. This range includes languages such as Concurrent Pascal <ref> [Brinch Hansen 75, 77] </ref>, Ada [Barnes 84], Emerald [Hutchinson 87a, 87b; Raj 91], Concurrent Smalltalk [Yokote 86], ABCL/1 [Shibayama 87; Yonezawa 86], Argus [Liskov 88], NIL [Strom 83], and Joyce [Brinch Hansen 87a, 87b].
Reference: [Brinch Hansen 77] <author> Per Brinch Hansen. </author> <title> The Architecture of Concurrent Programming. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1977. </year>
Reference: [Brinch Hansen 78] <author> Per Brinch Hansen. </author> <title> Distributed processes: A concurrent programming concept. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 934-941, </pages> <month> November </month> <year> 1978. </year> <month> 22 </month>
Reference: [Brinch Hansen 87a] <author> Per Brinch Hansen. </author> <title> Joyce a programming language for distributed systems. </title> <journal> Software Practice and Experience, </journal> <volume> 17(1) </volume> <pages> 29-50, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: This range includes languages such as Concurrent Pascal [Brinch Hansen 75, 77], Ada [Barnes 84], Emerald [Hutchinson 87a, 87b; Raj 91], Concurrent Smalltalk [Yokote 86], ABCL/1 [Shibayama 87; Yonezawa 86], Argus [Liskov 88], NIL [Strom 83], and Joyce <ref> [Brinch Hansen 87a, 87b] </ref>. These languages are all intended to be general languages although they are slightly different in their support of dynamic parallelism, and in their selection of communication model, etc. Nevertheless, in their support of one level of parallelism onlyusually coarse-grainedthese languages are not very general.
Reference: [Brinch Hansen 87b] <author> Per Brinch Hansen. </author> <title> A Joyce implementation. </title> <journal> Software - Practice and Experience, </journal> <volume> 17(4) </volume> <pages> 267-276, </pages> <month> April </month> <year> 1987. </year>
Reference: [Campbell 74] <author> R.H. </author> <title> Campbell and A.N. Habermann. The specification of process synchronization by path expressions in operating systems. </title> <booktitle> In Operating Systems Proceedings, </booktitle> <month> April </month> <year> 1974. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> (16):89-102, Springer-Verlag, 1974. 
Reference-contexts: Therefore, the role of side-effects is considered. Synchronization mechanism The processes created will normally have to synchronize to communicate and share resources. For simplicity reasons, I introduce one simple mechanism robust enough to handle all levels of parallelism. Inspiration is found in monitors [Hoare 74] and path expressions <ref> [Campbell 74] </ref>. The later allows an object to define a syntax for the order of message acceptance.
Reference: [Dally 88] <author> William J. Dally and Andrew A. Chien. </author> <title> Object-oriented concurrent programming in CST. </title> <booktitle> In Proceedings of the ACM SIGPLAN Workshop on Object-Based Concurrent Programming, </booktitle> <month> September </month> <year> 1988. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(4) </volume> <pages> 28-31, </pages> <month> April </month> <year> 1989. </year>
Reference: [Goldberg 89] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Massachu-setts, </address> <year> 1989. </year>
Reference-contexts: In the literature, objects of the same kind as instance objects are said to be first class objects. As far as I know, the idea of having first class objects only has not been applied in any other object-oriented programming language. For example, in Smalltalk <ref> [Goldberg 89] </ref>, types and methods are not objects implying that they can not be passed as parameters. In Emerald [Hutchinson 87a, 87b; Raj 91], methods and control structures are not objects either. <p> Therefore, object definitions must have a very general syntax and semantics. Some inspiration is found in Actors [Agha 87], Beta [Kristensen 87, 91], Emerald [Black 86, 87; Hutchinson 87a, 87b; Raj 91], Self [Ungar 87], and Smalltalk <ref> [Goldberg 89] </ref>. Reducible parallelism at many levels For simplicity reasons, the same language construct/mechanism should facilitate generation of fine-grained as well as medium-grained and coarse-grained parallelism. The only way to generate parallelism is to create processes. <p> The flexible concept of conformity type checking known from Emerald is incorporated in Ellie [Black 86, 87; Hutchinson 87a, 87b]. Inheritance and delegation Almost any object-oriented programming language is either inheritance based or delegation based. The best known inheritance based languages are Simula [Birtwistle 79] and Smalltalk <ref> [Goldberg 89] </ref>. Inheritance is for example discussed in [Snyder 86; Meyer 86]. The best known delegation based language is Actors [Agha 87].
Reference: [Gupta 88] <author> Anoop Gupta and Andrew Tucker. </author> <title> Exploiting variable grain parallelism at runtime. </title> <booktitle> In Proceedings of the ACM/SIGPLAN Conference on Parallel Programming: Experience with Applications, Languages and Systems, </booktitle> <month> July </month> <year> 1988. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(9) </volume> <pages> 212-221, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: A fine-grained parallel computer is one that supports fine-grained objects and fine-grained parallelism efficiently. Language and computer grainsizes are further discussed in <ref> [Stone 87; Gupta 88; Kruatrachue 88; McCreary 89; Andersen 91c, 91d] </ref>.
Reference: [Hansen 91] <author> Bjarne Hansen. </author> <title> Object Activation in a Transputer Implementation of the Ellie Language. M.Sc. </title> <type> thesis, DIKU Report no. 91/6, </type> <institution> Department of Computer Science, University of Copen-hagen, Denmark, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Generation of efficient code is also discussed. At last, some experiments show how to handle grainsize measurements and how to use them for grain-size adaption [Andersen 91d]. 5 An Ellie kernel implemented by Bjarne Hansen is presented in his Master thesis <ref> [Hansen 91] </ref>. A simple Ellie compiler and an Ellie virtual code interpreter have been implemented by myself. 4. The idea of functions and operations originate from Emerald where immutable (constant) objects can only deliver functions as a service, i.e., not operations. 5. <p> Denne fortolkes af en distribueret fortolker pfi et netvrk bestfiende af 17 INMOS transputere. Fortolkeren er en del af en kerne, der for strstedelen blev designet og implementeret af Bjarne Hansen <ref> [Hansen 91] </ref>. Hele systemet er simpelt og der mangler f.eks. spildopsamling. Ellie systemets hovedformfil har vret at teste valgte principper i Ellie, herunder synkroniseringsprincipper, der ogsfi er nye, og foretage eksperimenter med programmer, der indeholder forskellige korn-strrelser pfi processer.
Reference: [Hoare 74] <author> C.A.R. Hoare. </author> <title> Monitors: An operating system structuring concept. </title> <journal> Communications of the ACM, </journal> <volume> 17(10) </volume> <pages> 549-557, </pages> <month> October </month> <year> 1974. </year>
Reference-contexts: Therefore, the role of side-effects is considered. Synchronization mechanism The processes created will normally have to synchronize to communicate and share resources. For simplicity reasons, I introduce one simple mechanism robust enough to handle all levels of parallelism. Inspiration is found in monitors <ref> [Hoare 74] </ref> and path expressions [Campbell 74]. The later allows an object to define a syntax for the order of message acceptance.
Reference: [Hoare 78] <author> C.A.R. Hoare. </author> <title> Communicating sequential processes. </title> <journal> Communications of the ACM, </journal> <volume> 21(8) </volume> <pages> 666-677, </pages> <month> August </month> <year> 1978. </year>
Reference-contexts: This approach is studied and evaluated by examples and experiments. Closest related to my grain-size reduction approach is a work described in [Kruatrachue 88]. That work concerns a simple static situation, e.g., that of the transputer language Occam [Pountain 88] based on CSP <ref> [Hoare 78] </ref>, where all processes are known and, thus, can be analyzed completely at compile-timea situation not comparable to Ellie. However, inspiration can be found from that work. 1.4 Organization The dissertation consists of four reports. This main report includes precision of the main goals, ideas, and issues.
Reference: [Hutchinson 87a] <author> Norman C. Hutchinson. </author> <title> Emerald: An Object-Based Language for Distributed Programming. </title> <type> Ph.D. thesis, Technical Report 87-01-01, </type> <institution> Department of Computer Science, University of Washington, </institution> <address> Seattle, Washington, </address> <month> January </month> <year> 1987. </year> <month> 23 </month>
Reference-contexts: As far as I know, the idea of having first class objects only has not been applied in any other object-oriented programming language. For example, in Smalltalk [Goldberg 89], types and methods are not objects implying that they can not be passed as parameters. In Emerald <ref> [Hutchinson 87a, 87b; Raj 91] </ref>, methods and control structures are not objects either. <p> Hereby, efficient code can be generated in most cases. This has been incorporated in the design of Emerald with success <ref> [Black 86, 87; Hutchinson 87a, 87b] </ref>. The strength of conformity typing compared to strong typing is, however, the flexibility. A type can be used instead of another type, e.g., the defined type of a variable in an assignment, when the actual type conforms to the original one. <p> In Emerald, conformity checks can explicitly be moved to run-time, hereby obtaining the full flexibility of languages with run-time type checking. In Ellie, this technique is also incorporated to deal with the flexibility against efficiency conflict. The exact definition of conformity 8 typing in Emerald can be found in <ref> [Hutchinson 87a] </ref>. The definition in Ellie can be found in [Andersen 91a]. 1.3.3 Grain-Size Adaption The terms fine-grained, medium-grained, and coarse-grained are generally used for describing levels of parallelism, i.e., grainsizes. If processes are fine-grained then they communicate with each other whenever they have executed a few machine instructions. <p> For example, coarse-grained processes may be programs executing at workstations on a local area network. During the last 15 years a number of parallel languages have been proposed. This range includes languages such as Concurrent Pascal [Brinch Hansen 75, 77], Ada [Barnes 84], Emerald <ref> [Hutchinson 87a, 87b; Raj 91] </ref>, Concurrent Smalltalk [Yokote 86], ABCL/1 [Shibayama 87; Yonezawa 86], Argus [Liskov 88], NIL [Strom 83], and Joyce [Brinch Hansen 87a, 87b]. <p> Therefore, object definitions must have a very general syntax and semantics. Some inspiration is found in Actors [Agha 87], Beta [Kristensen 87, 91], Emerald <ref> [Black 86, 87; Hutchinson 87a, 87b; Raj 91] </ref>, Self [Ungar 87], and Smalltalk [Goldberg 89]. Reducible parallelism at many levels For simplicity reasons, the same language construct/mechanism should facilitate generation of fine-grained as well as medium-grained and coarse-grained parallelism. The only way to generate parallelism is to create processes. <p> The flexible concept of conformity type checking known from Emerald is incorporated in Ellie <ref> [Black 86, 87; Hutchinson 87a, 87b] </ref>. Inheritance and delegation Almost any object-oriented programming language is either inheritance based or delegation based. The best known inheritance based languages are Simula [Birtwistle 79] and Smalltalk [Goldberg 89]. Inheritance is for example discussed in [Snyder 86; Meyer 86].
Reference: [Hutchinson 87b] <author> Norman C. Hutchinson, Rajendra K. Raj, Andrew P. Black, Henry M. Levy, and Eric Jul. </author> <title> The Emerald Programming Language. </title> <type> DIKU Report no. 87/22, </type> <institution> Department of Computer Science, University of Copenhagen, Denmark, </institution> <month> October </month> <year> 1987. </year> <note> Also Technical Report 87-10-07, </note> <institution> Department of Computer Science, University of Washington. </institution>
Reference: [Ishikawa 86] <author> Yutaka Ishikawa and Mario Tokoro. </author> <title> A concurrent object-oriented knowledge representation language Orient84/K: Its features and implementation. </title> <booktitle> In Proceedings of the ACM Conference on ObjectOriented Programming Systems, Languages, and Applications, </booktitle> <month> October </month> <year> 1986. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 232-241, </pages> <month> November </month> <year> 1986. </year>
Reference: [Krakowiak 90] <author> S. Krakowiak, M. Meysembourg, H. Nguyen Van, M. Riveill, C. Roisin, and X. Rousset de Pina. </author> <title> Design and implementation of an object-oriented, strongly typed language for distributed applications. </title> <journal> Journal of ObjectOriented Programming, </journal> <volume> 3(3) </volume> <pages> 11-22, </pages> <month> October </month> <year> 1990. </year>
Reference: [Kruatrachue 88] <author> Boontee Kruatrachue and Ted Lewis. </author> <title> Grain Size Determination for Parallel Processing. </title> <journal> IEEE Software, </journal> (1):23-32, January 1988. 
Reference-contexts: A fine-grained parallel computer is one that supports fine-grained objects and fine-grained parallelism efficiently. Language and computer grainsizes are further discussed in <ref> [Stone 87; Gupta 88; Kruatrachue 88; McCreary 89; Andersen 91c, 91d] </ref>. <p> This approach is studied and evaluated by examples and experiments. Closest related to my grain-size reduction approach is a work described in <ref> [Kruatrachue 88] </ref>. That work concerns a simple static situation, e.g., that of the transputer language Occam [Pountain 88] based on CSP [Hoare 78], where all processes are known and, thus, can be analyzed completely at compile-timea situation not comparable to Ellie.
Reference: [Kristensen 87] <author> Bent Bruun Kristensen, Ole Lehrmann Madsen, Birger Mller-Pedersen, and Kristen Nygaard. </author> <title> The Beta programming language. </title> <editor> In Bruce Shriver and Peter Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pages 7-48, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Therefore, object definitions must have a very general syntax and semantics. Some inspiration is found in Actors [Agha 87], Beta <ref> [Kristensen 87, 91] </ref>, Emerald [Black 86, 87; Hutchinson 87a, 87b; Raj 91], Self [Ungar 87], and Smalltalk [Goldberg 89]. Reducible parallelism at many levels For simplicity reasons, the same language construct/mechanism should facilitate generation of fine-grained as well as medium-grained and coarse-grained parallelism.
Reference: [Kristensen 91] <author> Bent Bruun Kristensen, Ole Lehrmann Madsen, Birger Mller-Pedersen, and Kristen Nygaard. </author> <title> Object Oriented Programming in the BETA Programming Language. Book in draft, </title> <institution> Computer Science Department, Aarhus University, Denmark, </institution> <month> September </month> <year> 1991. </year>
Reference: [Lieberman 86] <author> Henry Lieberman. </author> <title> Using prototypical objects to implement shared behavior in object oriented systems. </title> <booktitle> In Proceedings of the ACM Conference on ObjectOriented Programming Systems, Languages, and Applications, </booktitle> <month> October </month> <year> 1986. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 214-223, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: The object-oriented language Cantor [Athas 87a, 87b, 88] has fine-grained parallelism, but Cantor is intended for scientific calculations and not really meant as a high level language. The LISP based object-oriented Actor languages have implicit fine-grained parallelism <ref> [Agha 86a, 86b, 87, 88; Lieberman 86, 87] </ref>, but LISP based languages are not very general due to their way of handling large mutable data structures that need to be generally accessible. They need to be passed as value parameters and this is not acceptable for writing, e.g., operating systems.
Reference: [Lieberman 87] <author> Henry Lieberman. </author> <title> Concurrent object-oriented programming in Act 1. </title> <editor> In Akinori Yonezawa and Mario Tokoro, editors, </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pages 9-36, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference: [Liskov 88] <author> Barbara Liskov. </author> <title> Distributed programming in Argus. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 300-312, </pages> <month> March </month> <year> 1988. </year> <month> 24 </month>
Reference-contexts: During the last 15 years a number of parallel languages have been proposed. This range includes languages such as Concurrent Pascal [Brinch Hansen 75, 77], Ada [Barnes 84], Emerald [Hutchinson 87a, 87b; Raj 91], Concurrent Smalltalk [Yokote 86], ABCL/1 [Shibayama 87; Yonezawa 86], Argus <ref> [Liskov 88] </ref>, NIL [Strom 83], and Joyce [Brinch Hansen 87a, 87b]. These languages are all intended to be general languages although they are slightly different in their support of dynamic parallelism, and in their selection of communication model, etc.
Reference: [McCreary 89] <author> C. McCreary and H. Gill. </author> <title> Automatic Determination of Grain Size for Efficient Parallel Processing. </title> <journal> Communications of the ACM, </journal> <volume> 32(9) </volume> <pages> 1073-1078, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: A fine-grained parallel computer is one that supports fine-grained objects and fine-grained parallelism efficiently. Language and computer grainsizes are further discussed in <ref> [Stone 87; Gupta 88; Kruatrachue 88; McCreary 89; Andersen 91c, 91d] </ref>.
Reference: [Meyer 86] <author> Bertrand Meyer. </author> <title> Genericity versus inheritance. </title> <booktitle> In Proceedings of the ACM Conference on ObjectOriented Programming Systems, Languages, and Applications, </booktitle> <month> October </month> <year> 1986. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 391-405, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Inheritance and delegation Almost any object-oriented programming language is either inheritance based or delegation based. The best known inheritance based languages are Simula [Birtwistle 79] and Smalltalk [Goldberg 89]. Inheritance is for example discussed in <ref> [Snyder 86; Meyer 86] </ref>. The best known delegation based language is Actors [Agha 87].
Reference: [Oldehoeft 88] <author> Rodney R. Oldehoeft and David C. Cann. </author> <title> Applicative parallelism on a shared-memory multiprocessor. </title> <journal> IEEE Software, </journal> (1):62-70, January 1988. 
Reference-contexts: They need to be passed as value parameters and this is not acceptable for writing, e.g., operating systems. However, these languages have great advantages in artificial intelligence and symbolic processing. Pure functional languages have the advantage of easy implicit parallel evaluation of expressions without side-effects as demonstrated in SISAL <ref> [Oldehoeft 88] </ref>, whereas the semantics of typical procedural languages do not allow implicit parallel execution. A compiler may deduce some fine-grained parallelism not interfering with the sequential semantics but this will rarely be enough, if hundreds or thousands of processors are available.
Reference: [Pountain 88] <author> D. Pountain and D. </author> <month> May. </month> <title> A Tutorial Introduction to Occam Programming. </title> <publisher> BSP Professional Books, </publisher> <year> 1988. </year>
Reference-contexts: This approach is studied and evaluated by examples and experiments. Closest related to my grain-size reduction approach is a work described in [Kruatrachue 88]. That work concerns a simple static situation, e.g., that of the transputer language Occam <ref> [Pountain 88] </ref> based on CSP [Hoare 78], where all processes are known and, thus, can be analyzed completely at compile-timea situation not comparable to Ellie. However, inspiration can be found from that work. 1.4 Organization The dissertation consists of four reports.
Reference: [Raj 91] <author> Rajendra K. Raj, Ewan Tempero, Henry M. Levy, Andrew P. Black, Norman C. Hutchinson, and Eric Jul. </author> <title> Emerald: A general-purpose programming language. </title> <journal> Software Practice and Experience, </journal> <volume> 21(1) </volume> <pages> 91-118, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: As far as I know, the idea of having first class objects only has not been applied in any other object-oriented programming language. For example, in Smalltalk [Goldberg 89], types and methods are not objects implying that they can not be passed as parameters. In Emerald <ref> [Hutchinson 87a, 87b; Raj 91] </ref>, methods and control structures are not objects either. <p> For example, coarse-grained processes may be programs executing at workstations on a local area network. During the last 15 years a number of parallel languages have been proposed. This range includes languages such as Concurrent Pascal [Brinch Hansen 75, 77], Ada [Barnes 84], Emerald <ref> [Hutchinson 87a, 87b; Raj 91] </ref>, Concurrent Smalltalk [Yokote 86], ABCL/1 [Shibayama 87; Yonezawa 86], Argus [Liskov 88], NIL [Strom 83], and Joyce [Brinch Hansen 87a, 87b]. <p> Therefore, object definitions must have a very general syntax and semantics. Some inspiration is found in Actors [Agha 87], Beta [Kristensen 87, 91], Emerald <ref> [Black 86, 87; Hutchinson 87a, 87b; Raj 91] </ref>, Self [Ungar 87], and Smalltalk [Goldberg 89]. Reducible parallelism at many levels For simplicity reasons, the same language construct/mechanism should facilitate generation of fine-grained as well as medium-grained and coarse-grained parallelism. The only way to generate parallelism is to create processes. <p> The idea of including immutable (constant) objects in other objects has been implemented in the distributed Emerald system <ref> [Black 86; Raj 91] </ref>. Emerald 12 also includes objects only accessed by one object into that object. Other methods for reducing the grain-size is also investigated.
Reference: [Shibayama 87] <author> Etsuya Shibayama and Akinori Yonezawa. </author> <title> Distributed computing in ABCL/1. </title> <editor> In Akinori Yonezawa and Mario Tokoro, editors, </editor> <booktitle> Object-Oriented Concurrent Programming, </booktitle> <pages> pages 91-128, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: During the last 15 years a number of parallel languages have been proposed. This range includes languages such as Concurrent Pascal [Brinch Hansen 75, 77], Ada [Barnes 84], Emerald [Hutchinson 87a, 87b; Raj 91], Concurrent Smalltalk [Yokote 86], ABCL/1 <ref> [Shibayama 87; Yonezawa 86] </ref>, Argus [Liskov 88], NIL [Strom 83], and Joyce [Brinch Hansen 87a, 87b]. These languages are all intended to be general languages although they are slightly different in their support of dynamic parallelism, and in their selection of communication model, etc.
Reference: [Snyder 86] <author> Alan Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proceedings of the ACM Conference on ObjectOriented Programming Systems, Languages, and Applications, </booktitle> <month> October </month> <year> 1986. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 38-45, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: Inheritance and delegation Almost any object-oriented programming language is either inheritance based or delegation based. The best known inheritance based languages are Simula [Birtwistle 79] and Smalltalk [Goldberg 89]. Inheritance is for example discussed in <ref> [Snyder 86; Meyer 86] </ref>. The best known delegation based language is Actors [Agha 87].
Reference: [Stone 87] <author> Harold S. Stone. </author> <title> High-Performance Computer Architecture. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Massachusetts, </address> <year> 1987. </year>
Reference-contexts: A fine-grained parallel computer is one that supports fine-grained objects and fine-grained parallelism efficiently. Language and computer grainsizes are further discussed in <ref> [Stone 87; Gupta 88; Kruatrachue 88; McCreary 89; Andersen 91c, 91d] </ref>.
Reference: [Strom 83] <author> Robert E. Strom and Shaula Yemini. </author> <title> NIL: An integrated language and system for distributed programming. </title> <booktitle> In Proceedings of the SIGPLAN'83 Symposium on Programming Language Issues in Software Systems, </booktitle> <month> June </month> <year> 1983. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 18(6) </volume> <pages> 73-82, </pages> <month> June </month> <year> 1983. </year>
Reference-contexts: During the last 15 years a number of parallel languages have been proposed. This range includes languages such as Concurrent Pascal [Brinch Hansen 75, 77], Ada [Barnes 84], Emerald [Hutchinson 87a, 87b; Raj 91], Concurrent Smalltalk [Yokote 86], ABCL/1 [Shibayama 87; Yonezawa 86], Argus [Liskov 88], NIL <ref> [Strom 83] </ref>, and Joyce [Brinch Hansen 87a, 87b]. These languages are all intended to be general languages although they are slightly different in their support of dynamic parallelism, and in their selection of communication model, etc.
Reference: [Ungar 87] <author> David Ungar and Randall B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <month> October </month> <year> 1987. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 22(12) </volume> <pages> 227-242, </pages> <month> December </month> <year> 1987. </year> <month> 25 </month>
Reference-contexts: Therefore, object definitions must have a very general syntax and semantics. Some inspiration is found in Actors [Agha 87], Beta [Kristensen 87, 91], Emerald [Black 86, 87; Hutchinson 87a, 87b; Raj 91], Self <ref> [Ungar 87] </ref>, and Smalltalk [Goldberg 89]. Reducible parallelism at many levels For simplicity reasons, the same language construct/mechanism should facilitate generation of fine-grained as well as medium-grained and coarse-grained parallelism. The only way to generate parallelism is to create processes.
Reference: [Ungar 88] <author> David Ungar and Frank Jackson. </author> <title> Tenuring policies for generation-based storage reclamation. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <month> September </month> <year> 1988. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(11) </volume> <pages> 1-17, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: Only few objects free memory when their processes terminate. The transputer network can be filled with garbage in less than 30 sec. Obviously, a garbage collector must be implemented and it seems reasonable to use a generation based approach <ref> [Ungar 88] </ref> because lifetimes of objects generally increase when their grainsizes increase. If the compiler can supply the garbage collector and memory allocator with grain-size information, it may be possible to discover a new interesting approach.
Reference: [Yokote 86] <author> Yasuhiko Yokote and Mario Tokoro. </author> <title> The design and implementation of ConcurrentSmalltalk. </title> <booktitle> In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <month> October </month> <year> 1986. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 331-340, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: During the last 15 years a number of parallel languages have been proposed. This range includes languages such as Concurrent Pascal [Brinch Hansen 75, 77], Ada [Barnes 84], Emerald [Hutchinson 87a, 87b; Raj 91], Concurrent Smalltalk <ref> [Yokote 86] </ref>, ABCL/1 [Shibayama 87; Yonezawa 86], Argus [Liskov 88], NIL [Strom 83], and Joyce [Brinch Hansen 87a, 87b]. These languages are all intended to be general languages although they are slightly different in their support of dynamic parallelism, and in their selection of communication model, etc.
Reference: [Yokote 87] <author> Yasuhiko Yokote and Akinori Yonezawa. </author> <title> Concurrent programming in ConcurrentSmalltalk. </title> <editor> In Akinori Yonezawa and Mario Tokoro, editors, </editor> <booktitle> ObjectOriented Concurrent Programming, </booktitle> <pages> pages 129-158, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference: [Yonezawa 86] <author> Akinori Yonezawa, Jean-Pierre Briot, and Etsuya Shibayama. </author> <booktitle> Object-oriented concurrent programming in ABCL/1. In Proceedings of the ACM Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <month> October </month> <year> 1986. </year> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 258-268, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: During the last 15 years a number of parallel languages have been proposed. This range includes languages such as Concurrent Pascal [Brinch Hansen 75, 77], Ada [Barnes 84], Emerald [Hutchinson 87a, 87b; Raj 91], Concurrent Smalltalk [Yokote 86], ABCL/1 <ref> [Shibayama 87; Yonezawa 86] </ref>, Argus [Liskov 88], NIL [Strom 83], and Joyce [Brinch Hansen 87a, 87b]. These languages are all intended to be general languages although they are slightly different in their support of dynamic parallelism, and in their selection of communication model, etc.
Reference: [Yonezawa 87] <author> Akinori Yonezawa, Etsuya Shibayama, Toshihiro Takada, and Yasuaki Honda. </author> <title> Modelling and programming in an object-oriented concurrent language ABCL/1. </title> <editor> In Akinori Yonezawa and Mario Tokoro, editors, </editor> <booktitle> ObjectOriented Concurrent Programming, </booktitle> <pages> pages 55-89, </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
References-found: 55

