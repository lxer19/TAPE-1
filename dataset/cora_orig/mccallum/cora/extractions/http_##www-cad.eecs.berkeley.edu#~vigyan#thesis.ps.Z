URL: http://www-cad.eecs.berkeley.edu/~vigyan/thesis.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~vigyan/index.html
Root-URL: http://www.cs.berkeley.edu
Title: Design Replacements for Sequential Circuits  
Author: by Vigyan Singhal 
Degree: B.Tech. (Indian Institute of Technology, Kanpur) 1989 M.S. (University of California at Berkeley) 1994 A dissertation submitted in partial satisfaction of the requirements for the degree of Doctor of Philosophy in Computer Science in the GRADUATE DIVISION of the UNIVERSITY of CALIFORNIA at BERKELEY Committee in charge: Professor Robert K. Brayton, Chair Professor Alberto L. Sangiovanni-Vincentelli Professor Dorit L. Hochbaum  
Date: 1996  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> M. Abramovici and M. A. Breuer. </author> <title> On Redundancy and Fault Detection in Sequential Circuits. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 28(11) </volume> <pages> 864-865, </pages> <month> November </month> <year> 1979. </year>
Reference-contexts: However, for sequential circuits the notions of untestability and redundancy do not coincide: some faults that are untestable because they prevent initialization are not redundant and cannot be replaced by a constant value <ref> [1] </ref>. Thus, in order to classify a fault as redundant in a sequential circuit, a notion of design replacement is needed. A fault will be sequentially redundant if and only if the faulty circuit and the good circuit are related by this notion of design replacement.
Reference: [2] <author> M. Abramovici, M. A. Breuer, and A. D. Friedman. </author> <title> Digital System Testing and Testable Design. </title> <publisher> IEEE Press, </publisher> <address> New York, NY, </address> <year> 1990. </year>
Reference-contexts: This is indeed true for combinational circuits <ref> [2] </ref>: a single stuck-at fault can be replaced by a constant (the fault is redundant) if the fault is untestable.
Reference: [3] <author> A. Aziz, R. K. Brayton, F. Balarin, and V. Singhal. </author> <title> Timing-safe Replaceability for Combinational Designs. In TAU '95: </title> <booktitle> Intl. Workshop on Timing Issues in the Specification and Synthesis of Digital Systems, </booktitle> <pages> pages 121-127, </pages> <address> Seattle, WA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: the environment of the design. 1 The problem of characterizing the set of replacements for a combinational designs, where the design specification includes the delay characterization of all gates, so that a replacement design has the same set of timed input-output waveforms as the original design, has been tackled elsewhere <ref> [3] </ref>. CHAPTER 3. NOTIONS OF DESIGN REPLACEMENT 20 3.1 Combinational Replacement This notion characterizes combinational designs (i.e. no memory elements) which are valid replacements of existing combinational designs.
Reference: [4] <author> K. Bartlett, G. Borriello, and S. Raju. </author> <title> Timing Optimization of Multiphase Sequential Logic. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 10(1) </volume> <pages> 51-62, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: When retiming such latches, one problem that arises is to obtain the new initial values for the retimed latches. This problem has been raised peripherally in <ref> [4, 53] </ref> and in much more detail in [81]. It has been claimed that if reset latches are modeled using no-reset latches, that restricts the class of possible retimings. <p> We review two strategies for retiming initial states, and show that both can be duplicated even when using the reset transformation. The first strategy is to remap the initial state after each retiming move (as in <ref> [4] </ref>). We show how this can be achieved in our model in Section 8.2.1. However, this strategy, by virtue of being local, may make local decisions which may hinder a future retiming move down the line. <p> Recall that we also model junctions as single input multi-output gates. Bartlett et al. <ref> [4] </ref> describe the standard method for obtaining the new initial state if we retime reset latches across the gate F .
Reference: [5] <author> G. Berry and H. J. Touati. </author> <title> Optimized Controller Synthesis Using Esterel. </title> <booktitle> In Workshop Notes of Intl. Workshop on Logic Synthesis, </booktitle> <address> Tahoe City, CA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: CHAPTER 2. PRELIMINARIES 6 latches is switched on, it randomly starts up in one of the 2 t power-up states (a state corresponds to an assignment of binary values to each of the latches). Many sequential synthesis and verification studies (such as <ref> [21, 80, 17, 48, 5] </ref>) rely on the supposition that all latches are reset latches by assuming that there is a designated initial state for each design; such an initial state corresponds to a designated assignment of binary values to each of the latches and it is assumed that when the <p> First we review the latch removal techniques under the DIS assumption. 6.2.2.1 Removing redundant latches under the DIS assumption We briefly review the techniques in <ref> [6, 49, 5] </ref> for reducing the latches for circuits assuming DIS. Given the initial state s, we extract the set of states reachable from s (see [48] for example).
Reference: [6] <author> C. Berthet, O. Coudert, and J. C. Madre. </author> <title> New Ideas on Symbolic Manipulation of Finite State Machines. </title> <booktitle> In Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pages 224-227, </pages> <address> Cambridge, MA, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: First we review the latch removal techniques under the DIS assumption. 6.2.2.1 Removing redundant latches under the DIS assumption We briefly review the techniques in <ref> [6, 49, 5] </ref> for reducing the latches for circuits assuming DIS. Given the initial state s, we extract the set of states reachable from s (see [48] for example).
Reference: [7] <author> K. S. Brace, R. L. Rudell, and R. E. Bryant. </author> <title> Efficient Implementation of a BDD Package. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 40-45, </pages> <address> Orlando, FL, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: In this thesis, we are using a subset of the ISCAS89 benchmark circuits [12] to demonstrate the synthesis techniques. We use binary decision diagrams (BDDs) and a standard toolset (similar to the ones in <ref> [7, 51, 68] </ref>) to implement our algorithms. Because of limitations imposed by the use of the BDD package we use the subset of ISCAS89 circuits 2 2 We use the benchmark circuits supplied with the SIS package, version 1.2.
Reference: [8] <author> D. Brand, R. A. Bergamaschi, and L. Stok. </author> <title> Be Careful with Don't Cares. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 83-86, </pages> <address> San Jose, CA, </address> <month> November </month> <year> 1995. </year> <note> BIBLIOGRAPHY 155 </note>
Reference-contexts: Recently, CHAPTER 9. CONCLUSIONS 149 Brand et al. <ref> [8] </ref> used the term "safe replaceability" to denote replacement of designs in presence of a given environment (as in [83]); interestingly, they use the term "universal replacement" to mean precisely what we have defined as safe replacement. <p> This allowed us to show that retiming transformation do not affect the output of a conservative three-valued simulator. Recently another example of the semantics of a simulator affecting the replacement criterion was discussed by Brand et al. <ref> [8] </ref> who gave an example where for some input, a design produces an X. In our situation, this can happen, for example, if there are two power-up states such that for this input one state produces a 1 and the other state produces a 0. <p> This may happen because the simulator for the environment of the design may interpret the X's in a non-monotonic way (in <ref> [8] </ref>, they claim this happens with VHDL simulation, where, for example, the simulator evaluates both "X = 0" and "X = 1" to 0, whereas a monotonic simulator evaluates both of these to X).
Reference: [9] <author> Daniel Brand. IBM T. </author> <note> J. </note> <institution> Watson Research Center, Yorktown Heights, NY, </institution> <type> Personal communication, </type> <year> 1995. </year>
Reference-contexts: For example, when a gate-level netlist is passed on to a synthesis tool for optimization, such a netlist is almost always 2 combinational, i.e. without any memory elements; the design is often cut at latch boundaries before passing to a synthesis tool <ref> [9] </ref>. For example, one problem with some sequential synthesis methods in the literature is the assumption of a designated initial state for a design; often it is not possible to live with such as assumption for the optimization of an arbitrary sequential netlist in an industrial setting.
Reference: [10] <author> R. K. Brayton, G. D. Hachtel, C. T. McMullen, and A. L. Sangiovanni-Vincentelli. </author> <title> Logic Minimization Algorithms for VLSI Synthesis. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1984. </year>
Reference-contexts: At any intermediate node of a network there is a local function f i : B r ! B, where r is the cardinality of the support. Node simplification is the process of optimizing a Boolean network by using don't cares in conjunction with a two level minimizer <ref> [10] </ref> to optimize the functions at the nodes. These don't cares arise in several ways: * Because of the structure of the network, only a certain subset of B r may be generated CHAPTER 5. SYNTHESIS AND VERIFICATION FOR SAFE REPLACEABILITY 51 by assignments to the inputs.
Reference: [11] <author> R. K. Brayton, G. D. Hachtel, and A. L. Sangiovanni-Vincentelli. </author> <title> Multilevel Logic Synthesis. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 78(2) </volume> <pages> 264-300, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: The nodes of the corresponding Boolean network represent the logical functionality of the modules. It has been observed that the area of the hardware implementation of a design is strongly correlated to the total number of literals in the factored form <ref> [11] </ref> representation of the functions at the logic nodes. Thus minimizing the function (with respect to the literal count) at the node constitutes a powerful synthesis technique. <p> SYNTHESIS AND VERIFICATION FOR SAFE REPLACEABILITY 51 by assignments to the inputs. This gives rise to satisfiability don't care (SDC) points for f i <ref> [11] </ref>. * For certain input assignments, the values taken by the primary outputs of N may be independent of the function computed by a node; these are observability don't care points (ODC) for that node [71]. * For certain input assignments the functionality of the node can be changed without destroying
Reference: [12] <author> F. Brglez, D. Bryan, and K. Kozminski. </author> <title> Combinational Profiles of Sequential Benchmark Circuits. </title> <booktitle> In Proc. Intl. Symposium on Circuits and Systems, </booktitle> <pages> pages 1929-1934, </pages> <address> Portland, OR, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: The smallest tSCC is the smallest set which qualifies as a core. Now we look at some example circuits to see the flexibility we have in choosing the core. In this thesis, we are using a subset of the ISCAS89 benchmark circuits <ref> [12] </ref> to demonstrate the synthesis techniques. We use binary decision diagrams (BDDs) and a standard toolset (similar to the ones in [7, 51, 68]) to implement our algorithms.
Reference: [13] <author> J. R. Burch, D. Dill, E. Wolf, and G. De Micheli. </author> <title> Modelling Hierarchical Combinational Circuits. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 612-617, </pages> <address> Santa Clara, CA, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: We will discuss this further in Chapter 2. For arbitrary sequential netlists, one notion that can used for replacement is the 1 Actually there is much debate over the notion of design replacement for combinational design (see, for example, <ref> [13, 52, 47, 77] </ref>). However, that controversy has its roots in designs which have cycles in the combinational parts of the circuit. Almost all real synchronous designs require at least one memory element in every cyclic path, and so we will restrict ourselves to this class of circuits. <p> The problem of combinational loops has also received some attention. Some people have identified classes of such circuits where these circuits can be replaced by "equivalent" circuits with no combinational loops [77]; others have endeavored to define the semantics of all circuits, including the ones with combinational loops <ref> [13, 85] </ref>. We presented our notion of safe replaceability in Chapter 4 and discussed design replacement on any arbitrary design, in the absence of any knowledge of the environment of a design.
Reference: [14] <author> E. Cerny and M. A. Marin. </author> <title> An Approach to Unified Methodology of Combinational Switching Circuits. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 27(8), </volume> <year> 1977. </year>
Reference-contexts: Let R ( ~ i; ~x; ~o; ~y) be a Boolean relation expressing all the flexibility in the choice of combinational logic for a sequential circuit. Cerny and Marin <ref> [14] </ref> demonstrate a close relationship between optimizing a Boolean network with respect to a given Boolean relation, and computing observability don't care sets. The starting network N must satisfy the relation R.
Reference: [15] <author> K.-T. Cheng. </author> <title> Redundancy Removal for Sequential Circuits Without Reset States. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 12(1) </volume> <pages> 13-24, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: A fault will be sequentially redundant if and only if the faulty circuit and the good circuit are related by this notion of design replacement. In this section, we present two notions of sequential redundancy (which defines a notion of design replacement)| the first, defined by <ref> [15] </ref> and subsequently used for logic optimization in [29], and the second, defined by [62] and later used for redundancy removal in [63]. 3.5.1 Cheng's notion of sequential redundancy Definition 3.5 A fault is sequentially redundant if for any input sequence, any output line and any state of the faulty circuit
Reference: [16] <author> K.-T. Cheng and H.-K. T. Ma. </author> <title> On the Over-Specification Problem in Sequential ATPG Algorithms. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 16-21, </pages> <address> Anaheim, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: There is an edge in E from one gate to another if an output of this gate 2 We should note here that if were using a conservative three-valued fault generator, we would not generate this 0 1 as a test sequence. However, as noted by <ref> [16] </ref>, that is a shortcoming of such a test generator, and in no way disqualifies 0 1 to be a test sequence. CHAPTER 7.
Reference: [17] <author> H. Cho, G. D. Hachtel, S.-W. Jeong, B. Plessier, E. Schwarz, and F. Somenzi. </author> <title> ATPG Aspects of FSM Verification. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 134-137, </pages> <address> Santa Clara, CA, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: CHAPTER 2. PRELIMINARIES 6 latches is switched on, it randomly starts up in one of the 2 t power-up states (a state corresponds to an assignment of binary values to each of the latches). Many sequential synthesis and verification studies (such as <ref> [21, 80, 17, 48, 5] </ref>) rely on the supposition that all latches are reset latches by assuming that there is a designated initial state for each design; such an initial state corresponds to a designated assignment of binary values to each of the latches and it is assumed that when the
Reference: [18] <author> H. Cho, G. D. Hachtel, E. Macii, B. Plessier, and F. Somenzi. </author> <title> Algorithms for Approximate FSM Traversal. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 25-30, </pages> <address> Dallas, TX, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: For some inexplicable reason, at least two of the benchmark circuits, s208 and s420 seem to be slightly different from the ones used by others <ref> [18, 50, 64] </ref>. CHAPTER 5.
Reference: [19] <author> H. Cho, G. D. Hachtel, and F. Somenzi. </author> <title> Redundancy Identification and Removal Based on Implicit State Enumeration. </title> <booktitle> In Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pages 77-80, </pages> <address> Cambridge, MA, </address> <month> October </month> <year> 1991. </year> <note> BIBLIOGRAPHY 156 </note>
Reference-contexts: For such designs, this is the notion of design equivalence used for logic synthesis [71], test pattern generation [31], redundancy removal <ref> [19] </ref> and sequential verification [21].
Reference: [20] <author> H. Cho, S.-W. Jeong, F. Somenzi, and C. Pixley. </author> <title> Synchronizing Sequences and Symbolic Traversal Techniques in Test Generation. </title> <journal> Journal of Electronic Testing: Theory and Applications, </journal> <volume> 4(12) </volume> <pages> 19-31, </pages> <year> 1993. </year>
Reference-contexts: Lemma 4.3 ((Lemma 2 in <ref> [20] </ref>)) Suppose that DFSM's M 0 and M 1 have no equivalent states then there is an input sequence such that for any states s 0 of M 0 and s 1 of M 1 , M 0 (s 0 ; ) 6= M 1 (s 1 ; ).
Reference: [21] <author> O. Coudert, C. Berthet, and J. C. Madre. </author> <title> Verification of Sequential Machines Based on Symbolic Execution. </title> <editor> In J. Sifakis, editor, </editor> <booktitle> Proc. of the Workshop on Automatic Verification Methods for Finite State Systems, volume 407 of Lecture Notes in Computer Science, </booktitle> <pages> pages 365-373, </pages> <address> Grenoble, France, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: CHAPTER 2. PRELIMINARIES 6 latches is switched on, it randomly starts up in one of the 2 t power-up states (a state corresponds to an assignment of binary values to each of the latches). Many sequential synthesis and verification studies (such as <ref> [21, 80, 17, 48, 5] </ref>) rely on the supposition that all latches are reset latches by assuming that there is a designated initial state for each design; such an initial state corresponds to a designated assignment of binary values to each of the latches and it is assumed that when the <p> For such designs, this is the notion of design equivalence used for logic synthesis [71], test pattern generation [31], redundancy removal [19] and sequential verification <ref> [21] </ref>.
Reference: [22] <author> O. Coudert and J. C. Madre. </author> <title> A Unified Framework for the Formal Verification of Sequential Circuits. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 126-129, </pages> <address> Santa Clara, CA, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: The image projection step in the algorithm in the figure can de done using a variety of algorithms (see <ref> [22, 80] </ref>, for example); we use the algorithm presented in [80]. CHAPTER 5. <p> (~x)) F (f t 0 +1 ; : : : ; f t ) return F g use a BDD minimization procedure, which heuristically finds an implementation which has the smallest support (we use a simpler version of the algorithm in [46]); alternately, we could have used bdd-generalized-cofactor (due to <ref> [22] </ref>) or any of many other BDD minimization algorithms with respect to a don't care set (see [76]). Since we are dealing with very small functions, in our application, the choice of the heuristic does not matter.
Reference: [23] <author> M. Damiani and G. De Micheli. </author> <title> Recurrence Equations and the Optimization of Synchronous Logic Circuits. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 556-561, </pages> <address> Anaheim, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: This leads to a much smaller BDD to express the relation U (~x; ~y) (instead of the relation P ( ~ i; ~o; ~y) in the previous chapter), and hence, faster multi-level resynthesis. We suspect that synchronous recurrence equations <ref> [23] </ref> also lead to delay replacements. <p> However, the experimental results presented there indicate that using synchronous recurrence equations is not very effective; our optimization method (using the SIS commands sweep; eliminate -1 followed by the optimization procedure described in this paper) produces smaller circuits using less CPU times than those reported in <ref> [23] </ref>. (Note that the CPU times indicated in Table 6.1 do not include the time used by the SIS preprocessing commands; however, for all the examples, that time is orders of magnitude lower than than the times reported for the sequential optimations in Table 6.1. <p> On the other hand, the CPU times reported in <ref> [23] </ref> are much greater than the CPU times reported in Table 6.1.) We performed an experiment on one of the benchmark circuits with a large number of onion rings (s526) to explore the tradeoffs between flexibility and the power-up delay allowed. The results are in Table 6.2.
Reference: [24] <author> M. Damiani and G. De Micheli. </author> <title> Synthesis and Optimization of Synchronous Logic Circuits from Recurrence Equations. </title> <booktitle> In Proc. European Conf. on Design Automation, </booktitle> <pages> pages 226-231, </pages> <address> Brussels, Belgium, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: So the reason given in Section 3.5.1, for searching for a new safe replacement condition, applies here as well. We will return to a discussion about the validity of retiming moves in Chapter 7. 3.7 Synchronous Recurrence Equations Damiani and De Micheli <ref> [24] </ref> proposed using synchronous recurrence equations (or synchronous relations as used by [79]) to capture don't care information in sequential circuits. A synchronous recurrence equation expresses the flexibility for a sequential circuit as a Boolean relation on finite sequences of inputs and outputs.
Reference: [25] <author> G. De Micheli, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Optimal State Assignment for Finite State Machines. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 4(7) </volume> <pages> 269-285, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: The problem of obtaining an "optimal" netlist, with respect to some cost function, is the state-encoding and FSM implementation problem. This is usually a provably intractable problem and many heuristics have been suggested to attack many variants of CHAPTER 2. PRELIMINARIES 10 minimization. this problem <ref> [25, 26, 74, 67] </ref>. This problem is orthogonal to the issues of this thesis. 2.3 Composition of designs Because we are interested in the problem of replacing designs without affecting the interaction with the environment designs, the issue of composing designs is crucial to this thesis. <p> We are preserving the state encodings of the states in our design, even though this is not required for safe replaceability. This is done to make our synthesis procedure tractable; state encoding is, in general, a hard problem <ref> [25, 26, 74, 67] </ref> and we do not attempt to solve it in this thesis.
Reference: [26] <author> S. Devadas and A. R. </author> <title> Newton. Exact Algorithms for Output Encoding, State Assignment and Four-Level Boolean Minimization. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 10(1) </volume> <pages> 13-27, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The problem of obtaining an "optimal" netlist, with respect to some cost function, is the state-encoding and FSM implementation problem. This is usually a provably intractable problem and many heuristics have been suggested to attack many variants of CHAPTER 2. PRELIMINARIES 10 minimization. this problem <ref> [25, 26, 74, 67] </ref>. This problem is orthogonal to the issues of this thesis. 2.3 Composition of designs Because we are interested in the problem of replacing designs without affecting the interaction with the environment designs, the issue of composing designs is crucial to this thesis. <p> We are preserving the state encodings of the states in our design, even though this is not required for safe replaceability. This is done to make our synthesis procedure tractable; state encoding is, in general, a hard problem <ref> [25, 26, 74, 67] </ref> and we do not attempt to solve it in this thesis.
Reference: [27] <author> E. B. Eichelberger. </author> <title> Hazard Detection in Combinational and Sequential Circuits. </title> <journal> IBM J. Res. and Devep., </journal> <pages> pages 90-99, </pages> <month> March </month> <year> 1965. </year>
Reference-contexts: Simulation is an important component of the IC design verification process. The most popular and fastest way of simulating gate-level designs is three-valued simulation [38]. It is assumed that all latches power up as X, meaning that the value is undetermined. Three-valued logic is well-known for gate-level elements <ref> [27] </ref>. Three-valued simulation results give the output sequences for a given input sequence.
Reference: [28] <author> A. El-Maleh, T. E. Marchok, J. Rajski, and W. Maly. </author> <title> On Test Set Preservation of Retimed Circuits. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 176-182, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1995. </year> <note> BIBLIOGRAPHY 157 </note>
Reference-contexts: We proved in this chapter that new test sequences can be obtained from old ones just by appending CHAPTER 9. CONCLUSIONS 151 an arbitrary prefix sequence of length n, where n is determined by the sequence of retiming moves. Later, El-Maleh et al. <ref> [28] </ref> correct their result from [55] and show that test vector sequences, which have been generated by conservative three-valued simulators, are preserved from the original circuit to the retimed circuit. <p> We note that this result follows from our result in Chapter 7 that retiming transformations do not affect the output of such simulators (Corollary 7.10). The preservation of test vector sequences is an important result because in <ref> [28] </ref> it is demostrated by experiments that generating test sequences for the retimed circuits may be much more expensive than generating them for the original circuits.
Reference: [29] <author> L. Entrena and K.-T. Cheng. </author> <title> Sequential Logic Optimization by Redundancy Addition and Removal. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 310-315, </pages> <address> Santa Clara, CA, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: In this section, we present two notions of sequential redundancy (which defines a notion of design replacement)| the first, defined by [15] and subsequently used for logic optimization in <ref> [29] </ref>, and the second, defined by [62] and later used for redundancy removal in [63]. 3.5.1 Cheng's notion of sequential redundancy Definition 3.5 A fault is sequentially redundant if for any input sequence, any output line and any state of the faulty circuit D 1 , the circuit D 1 produces
Reference: [30] <author> M. R. Garey and D. S. Johnson. </author> <title> Computers and Intractability. </title> <editor> W. H. </editor> <publisher> Freeman and Co., </publisher> <year> 1979. </year>
Reference-contexts: We have to store at most (1 + Q C ) states at each step. Since (; d) is a witness, all states in C must eventually die out proving the validity of the witness. Thus the complementary problem is in NPSPACE. By Savitch's theorem <ref> [69, 30] </ref>, the complementary problem is in PSPACE (i.e. a deterministic Turing machine can recognize it). Thus, safe replaceability is also in PSPACE. The proof of PSPACE-hardness is by transformation from the FINITE STATE AUTOMATA INTERSECTION problem, which is PSPACE-complete [42, 30]. <p> By Savitch's theorem [69, 30], the complementary problem is in PSPACE (i.e. a deterministic Turing machine can recognize it). Thus, safe replaceability is also in PSPACE. The proof of PSPACE-hardness is by transformation from the FINITE STATE AUTOMATA INTERSECTION problem, which is PSPACE-complete <ref> [42, 30] </ref>. FINITE STATE AUTOMATA INTERSECTION INSTANCE: Set D 1 ; D 2 ; : : : ; D n of deterministic finite automata or DFAs (see [35] for the definition of a DFA) having the same input alphabet . <p> We know from Remark 4.2 (in Chapter 4) that safe replaceability can be reduced to the language containment problem of NDFAs, which is also PSPACE-complete (since language equivalence is PSPACE-hard <ref> [41, 30] </ref>). Thus we can verify safe replaceability by the standard exponential-time algorithm for checking NDFA containment (L (D 1 ) L (D 2 )?) which determinizes D 2 , then complements it and then looks for an accepting string in the product of this automaton with D 1 .
Reference: [31] <author> A. Ghosh, S. Devadas, and A. R. </author> <title> Newton. Test Generation for Highly Sequential Circuits. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 362-365, </pages> <address> Santa Clara, CA, </address> <month> November </month> <year> 1989. </year>
Reference-contexts: For such designs, this is the notion of design equivalence used for logic synthesis [71], test pattern generation <ref> [31] </ref>, redundancy removal [19] and sequential verification [21].
Reference: [32] <author> A. Grasselli and F. Luccio. </author> <title> A Method for Minimizing the Number of Internal States in Incompletely Specified Sequential Networks. </title> <journal> IRE Transactions on Electronic Computers, </journal> <volume> EC-14(3):536-557, </volume> <month> June </month> <year> 1965. </year>
Reference-contexts: The problem of state minimization is orthogonal to our research; for its application in digital circuits, it has been studied in detail in <ref> [32, 65, 40] </ref>. For completely specified deterministic machines, the minimum state machine is unique and hence can be thought of as the canonical representation of the FSM. A netlist is an interconnection of elementary circuit elements connected by wires.
Reference: [33] <author> J. Grodstein, E. Lehman, H. Harkness, H. Touati, and B. Grundmann. </author> <title> Optimal Latch Mapping and Retiming within a Tree. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 242-245, </pages> <address> San Jose, CA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: We have shown that this problem can be avoided by retiming reset circuitry along with latches. In many design settings, latches are often combined with other combinational logic inside one library element <ref> [33] </ref>. It should be interesting to explore if during retiming, these elements can also be retimed as a whole, similar to how we retime a no-reset latch with its reset circuitry, together as one unit.
Reference: [34] <author> J. Hartmanis and R. E. Stearns. </author> <title> Algebraic Structure Theory of Sequential Machines. </title> <booktitle> Intl. Series in Applied Mathematics. </booktitle> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1966. </year>
Reference-contexts: course, from our perspective, as we have discussed in Chapter 2, such an assumption of a designated initial state is overly restrictive and unreasonable for many real circuits. 3.3 Machine Equivalence For sequential designs with no designated initial state, there is the classical notion of machine equivalence, for example in <ref> [34, page 23] </ref>: Definition 3.1 Two FSMs M 1 and M 2 are equivalent (M 1 M 2 ) if for each state s in M 1 there is a state t in M 2 such that s ~ t, and for each state t in M 2 there is a <p> Thus classical machine equivalence, that requires that every state in each design be equivalent to be some state in the other design <ref> [34] </ref>, is not necessary for safe replacement, although it is sufficient. Remark 2: Although the replacement design has to be compatible with the original design (same number of inputs and outputs), it does not have to have the same number of latches.
Reference: [35] <author> J. E. Hopcroft and J. D. Ullman. </author> <title> Introduction to Automata Theory, Languages and Computation. </title> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: Notice that, unlike the theory of finite automata (e.g. <ref> [35] </ref>), we do not need the notion of an initial state or final states to describe the language of a design. Now it is easy to see D 1 D 0 if and only if L D 1 L D 0 . <p> The proof of PSPACE-hardness is by transformation from the FINITE STATE AUTOMATA INTERSECTION problem, which is PSPACE-complete [42, 30]. FINITE STATE AUTOMATA INTERSECTION INSTANCE: Set D 1 ; D 2 ; : : : ; D n of deterministic finite automata or DFAs (see <ref> [35] </ref> for the definition of a DFA) having the same input alphabet .
Reference: [36] <author> M. A. Iyer, D. E. Long, and M. Abramovici. </author> <title> Identifying Sequential Redundancies Without Search. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <address> Las Vegas, NV, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: Recently, Iyer et al. <ref> [36] </ref> also used this notion of delay replacements for identifying redundancies in sequential circuits. In Chapter 7, we saw that retiming results in a delay replacement and not a safe replacement.
Reference: [37] <author> Seh-Woong Jeong. </author> <title> Binary Decision Diagrams and their Applications to Implicit Enumeration Techniques in Logic Synthesis. </title> <type> PhD thesis, </type> <institution> Department of Electrical and Computer Engineering, University of Colorado, Boulder, </institution> <address> CO 80309, </address> <year> 1992. </year>
Reference-contexts: Onion rings A 1 ; A 2 ; : : : are defined recursively: A 1 = Q D ; 1 This notion was earlier defined in [59]; the term "onion ring" was first used in <ref> [37] </ref>. CHAPTER 5. SYNTHESIS AND VERIFICATION FOR SAFE REPLACEABILITY 46 transitions are shown. For design D 4 in Figure 5.4, A 1 = f00; 01; 10; 11g; A 2 = A 3 = = A 1 = f01; 10; 11g. <p> States such as s 2 cannot re-appear after two clock cycles, no matter what inputs are given during the two cycles. The n-cycle ephemeral state sets form an "onion ring" structure in the STG <ref> [37] </ref>. The 1-cycle ephemeral states constitute onion ring 1, 2-cycle ephemeral states constitute onion ring 2, and so on. Since designs are finite state machines, for any design, there is a bound on the number of onion rings. <p> The design D 1 can be obtained by a fixed-point operation starting from D, because D 1 = D n , where n is the smallest number such that D n1 = D n . Using the terminology in <ref> [37] </ref>, this number n is the number of onion rings of the design D. D 1 is also the same as the outer-envelope (OE) of [60].
Reference: [38] <author> J. S. Jephson, R. P. McQuarrie, and R. E. Vogelsberg. </author> <title> A Three-Value Computer Design Verification System. </title> <journal> IBM J. Res. and Devep., </journal> <pages> pages 178-188, </pages> <year> 1969. </year>
Reference-contexts: We show that this is a general phenomena relating three valued simulation and retiming. Simulation is an important component of the IC design verification process. The most popular and fastest way of simulating gate-level designs is three-valued simulation <ref> [38] </ref>. It is assumed that all latches power up as X, meaning that the value is undetermined. Three-valued logic is well-known for gate-level elements [27]. Three-valued simulation results give the output sequences for a given input sequence.
Reference: [39] <author> T. Kam and P. A. Subramanyam. </author> <title> Comparing Layouts with HDL Models: A Formal Verification Technique. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 14(4) </volume> <pages> 503-509, </pages> <month> April </month> <year> 1995. </year> <note> BIBLIOGRAPHY 158 </note>
Reference-contexts: Getting such an abstraction from transistor-level designs to such nicely defined gate-level designs is an important area and a focus of many current researchers <ref> [39, 58, 78] </ref>. The problem of combinational loops has also received some attention.
Reference: [40] <author> T. Kam, T. Villa, R. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> A Fully Implicit Algorithm for Exact State Minimization. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <pages> pages 684-690, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The problem of state minimization is orthogonal to our research; for its application in digital circuits, it has been studied in detail in <ref> [32, 65, 40] </ref>. For completely specified deterministic machines, the minimum state machine is unique and hence can be thought of as the canonical representation of the FSM. A netlist is an interconnection of elementary circuit elements connected by wires.
Reference: [41] <author> S. C. Kleene. </author> <title> Representation of Events in Nerve Nets and Finite Automata. </title> <editor> In C. E. Shannon and M. McCarthy, editors, </editor> <booktitle> Automata Studies, number 34 in Annals of Mathematics Studies, </booktitle> <pages> pages 3-41. </pages> <publisher> Princeton University Press, </publisher> <address> Princeton, NJ, </address> <year> 1956. </year>
Reference-contexts: We know from Remark 4.2 (in Chapter 4) that safe replaceability can be reduced to the language containment problem of NDFAs, which is also PSPACE-complete (since language equivalence is PSPACE-hard <ref> [41, 30] </ref>). Thus we can verify safe replaceability by the standard exponential-time algorithm for checking NDFA containment (L (D 1 ) L (D 2 )?) which determinizes D 2 , then complements it and then looks for an accepting string in the product of this automaton with D 1 .
Reference: [42] <author> D. Kozen. </author> <title> Lower Bounds for Natural Proof Systems. </title> <booktitle> In Proc. Symp. on Foundations of Computer Science, </booktitle> <pages> pages 254-266, </pages> <address> Providence, RI, </address> <month> October </month> <year> 1977. </year>
Reference-contexts: By Savitch's theorem [69, 30], the complementary problem is in PSPACE (i.e. a deterministic Turing machine can recognize it). Thus, safe replaceability is also in PSPACE. The proof of PSPACE-hardness is by transformation from the FINITE STATE AUTOMATA INTERSECTION problem, which is PSPACE-complete <ref> [42, 30] </ref>. FINITE STATE AUTOMATA INTERSECTION INSTANCE: Set D 1 ; D 2 ; : : : ; D n of deterministic finite automata or DFAs (see [35] for the definition of a DFA) having the same input alphabet .
Reference: [43] <author> W. Kunz and P. R. Menon. </author> <title> Multi-Level Logic Optimization by Implication Analysis. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 6-13, </pages> <address> San Jose, CA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: In both implementations the combinational functionality of the design is identical, namely z = x. However, Netlist 2 creates a combinational cycle because of the environment D 0 . In fact, after making a design replacement, most logic synthesis tools <ref> [43, 72] </ref> either check that the replacement has not caused a combinational cycle or have constraints which prevent a combinational cycle during the synthesis procedure. 3.2 Identical Behavior from Initial State Most of the previous work on equivalence and replacement of sequential circuits assumes a designated initial state for the circuit.
Reference: [44] <author> R. P. Kurshan. </author> <title> Automata-Theoretic Verification of Coordinating Processes. </title> <publisher> Princeton University Press, </publisher> <year> 1995. </year>
Reference-contexts: As an aside we note that the language containment paradigm is also used to specify a relationship between the abstraction and the implementation in the process of formal specification and verification of digital systems <ref> [44] </ref>| an implementation satisfies the abstraction or the property if the language of the implementation is contained in the language of the abstraction or the property.
Reference: [45] <author> C. E. Leiserson and J. B. Saxe. </author> <title> Optimizing Synchronous Systems. </title> <journal> Journal of VLSI and Computer Systems, </journal> <volume> 1(1) </volume> <pages> 41-67, </pages> <month> Spring </month> <year> 1983. </year>
Reference-contexts: of the states in the outer-envelope are also inside the tSCC, i.e. there are at least exponentially more states inside the tSCC than those which lie inside the outer envelope but not in the tSCC. 103 Chapter 7 Validity of Retiming Transformations Retiming was first formulated by Leiserson and Saxe <ref> [45] </ref> in the context of systolic systems. When applied to digital circuits, retiming is an optimization step which moves the latches across the logic gates and in doing so changes the number of latches and the longest path delay between the latches. <p> Thus, 0 1 is no longer a test sequence for the retimed design D. 7.2 Background 7.2.1 Leiserson-Saxe Retiming Model Leiserson and Saxe introduced retiming <ref> [45] </ref> through a graph-theoretic model. A design is modeled as a finite edge-weighted directed graph G = (V; E). Each vertex in V represents either a gate in the design, a primary input or output, or a special dummy node called the host. <p> In the following, we will use the notion of delayed designs (from Definition 6.1) to study the effect of forward retiming moves. The notion of delayed design is similar to the notion of sufficiently old configuration used in <ref> [45] </ref> to show the validity of retiming moves. Proposition 7.4 If design C can be obtained from design D by a single forward retiming move across a non-justifiable element, then C 1 D. Proof. <p> The rest of the proof is identical to that of case (ii) in Proposition 7.2. 2 The Propositions 7.2 and 7.4 lead to the following corollary which is the primary correctness result proven by Leiserson and Saxe <ref> [45] </ref>: Corollary 7.5 (Lemma 1 in [45]) If C can be obtained from D using an arbitrary sequence of retiming moves, then there exists a non-negative finite integer k such that C k D. <p> The rest of the proof is identical to that of case (ii) in Proposition 7.2. 2 The Propositions 7.2 and 7.4 lead to the following corollary which is the primary correctness result proven by Leiserson and Saxe <ref> [45] </ref>: Corollary 7.5 (Lemma 1 in [45]) If C can be obtained from D using an arbitrary sequence of retiming moves, then there exists a non-negative finite integer k such that C k D. This result requires up to delay using the retimed design for a finite number of cycles after power-up. <p> This result requires up to delay using the retimed design for a finite number of cycles after power-up. Notice our short proof of the above lemma; in contrast, the proof given in <ref> [45] </ref> is about 4 pages long. However, in the proof of Lemma 1 in [45], the integer n was shown to be the equal to max v2V (lag (v)), i.e. the maximum number of forward retiming moves across any combinational element in the circuit (since lag (host) is 0, n is <p> This result requires up to delay using the retimed design for a finite number of cycles after power-up. Notice our short proof of the above lemma; in contrast, the proof given in <ref> [45] </ref> is about 4 pages long. However, in the proof of Lemma 1 in [45], the integer n was shown to be the equal to max v2V (lag (v)), i.e. the maximum number of forward retiming moves across any combinational element in the circuit (since lag (host) is 0, n is well-defined for a given retiming). <p> Recently, Iyer et al. [36] also used this notion of delay replacements for identifying redundancies in sequential circuits. In Chapter 7, we saw that retiming results in a delay replacement and not a safe replacement. As we showed in this chapter, and as <ref> [45] </ref> showed earlier, if C is a retimed circuit obtained from the original circuit D, C n D for some integer n which depends on the sequence of retiming moves. For a given sequence of retiming moves, we found a tighter bound for n than [45]. <p> in this chapter, and as <ref> [45] </ref> showed earlier, if C is a retimed circuit obtained from the original circuit D, C n D for some integer n which depends on the sequence of retiming moves. For a given sequence of retiming moves, we found a tighter bound for n than [45]. Designers often use conservative three-valued simulators to validate their designs. We showed that if three-valued simulators are used, retiming transformations do not affect the output of such simulators even though they may not be safe replacements (in the sense of Chapter 4).
Reference: [46] <author> B. Lin. </author> <title> Efficient Symbolic Support Manipulation. </title> <booktitle> In Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pages 513-516, </pages> <address> Cambridge, MA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: ^x) S (~x; ^x) (x j = f j (~x)) F (f t 0 +1 ; : : : ; f t ) return F g use a BDD minimization procedure, which heuristically finds an implementation which has the smallest support (we use a simpler version of the algorithm in <ref> [46] </ref>); alternately, we could have used bdd-generalized-cofactor (due to [22]) or any of many other BDD minimization algorithms with respect to a don't care set (see [76]). Since we are dealing with very small functions, in our application, the choice of the heuristic does not matter.
Reference: [47] <author> B. Lin, G. de Jong, and T. Kolks. </author> <title> Modeling and Optimization of Hierarchical Synchronous Circuits. </title> <booktitle> In Proc. European Design and Test Conf., </booktitle> <pages> pages 144-149, </pages> <address> Paris, France, </address> <month> March </month> <year> 1995. </year>
Reference-contexts: We will discuss this further in Chapter 2. For arbitrary sequential netlists, one notion that can used for replacement is the 1 Actually there is much debate over the notion of design replacement for combinational design (see, for example, <ref> [13, 52, 47, 77] </ref>). However, that controversy has its roots in designs which have cycles in the combinational parts of the circuit. Almost all real synchronous designs require at least one memory element in every cyclic path, and so we will restrict ourselves to this class of circuits.
Reference: [48] <author> B. Lin, H. J. Touati, and A. R. </author> <title> Newton. Don't Care Minimization of Multi-level Sequential Logic Networks. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 414-417, </pages> <address> Santa Clara, CA, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: CHAPTER 2. PRELIMINARIES 6 latches is switched on, it randomly starts up in one of the 2 t power-up states (a state corresponds to an assignment of binary values to each of the latches). Many sequential synthesis and verification studies (such as <ref> [21, 80, 17, 48, 5] </ref>) rely on the supposition that all latches are reset latches by assuming that there is a designated initial state for each design; such an initial state corresponds to a designated assignment of binary values to each of the latches and it is assumed that when the <p> Given the initial state s, we extract the set of states reachable from s (see <ref> [48] </ref> for example). Let C (~x) be the characteristic function of the set of reachable states, where ~x = fx 1 ; x 2 ; : : : ; x t g represent the t latches in the design.
Reference: [49] <author> Bill Lin. </author> <title> Synthesis of VLSI Design with Symbolic Techniques. </title> <type> PhD thesis, </type> <institution> Electronics Research Laboratory, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> November </month> <year> 1991. </year> <note> Memorandum No. UCB/ERL M91/105. </note>
Reference-contexts: First we review the latch removal techniques under the DIS assumption. 6.2.2.1 Removing redundant latches under the DIS assumption We briefly review the techniques in <ref> [6, 49, 5] </ref> for reducing the latches for circuits assuming DIS. Given the initial state s, we extract the set of states reachable from s (see [48] for example). <p> CHAPTER 6. DELAY REPLACEMENTS 96 Selecting the set of redundant latches Given a set C (~x), Lin <ref> [49] </ref> has given a heuristic of choosing an order of latches to test if a latch is redundant to obtain the set of redundant latches to select the set of latches ^x = fx t 0 +1 ; : : : ; x t g which satisfy the latch redundancy condition
Reference: [50] <author> D. E. Long, M. A. Iyer, and M. Abramovici. </author> <title> Identifying Sequentially Untestable Faults Using Illegal States. </title> <booktitle> In Proc. VLSI Test Symposium, </booktitle> <pages> pages 4-11, </pages> <address> Princeton, NJ, </address> <month> April </month> <year> 1995. </year> <note> BIBLIOGRAPHY 159 </note>
Reference-contexts: For some inexplicable reason, at least two of the benchmark circuits, s208 and s420 seem to be slightly different from the ones used by others <ref> [18, 50, 64] </ref>. CHAPTER 5.
Reference: [51] <author> David E. </author> <title> Long. BDD Manipulation Library. Public software. </title> <institution> Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> June </month> <year> 1993. </year> <month> ftp://emc.cs.cmu.edu/pub/bdd/bddlib.tar.Z. </month>
Reference-contexts: In this thesis, we are using a subset of the ISCAS89 benchmark circuits [12] to demonstrate the synthesis techniques. We use binary decision diagrams (BDDs) and a standard toolset (similar to the ones in <ref> [7, 51, 68] </ref>) to implement our algorithms. Because of limitations imposed by the use of the BDD package we use the subset of ISCAS89 circuits 2 2 We use the benchmark circuits supplied with the SIS package, version 1.2.
Reference: [52] <author> S. Malik. </author> <title> Analysis of Cyclic Combinational Circuits. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 13(7) </volume> <pages> 950-956, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: We will discuss this further in Chapter 2. For arbitrary sequential netlists, one notion that can used for replacement is the 1 Actually there is much debate over the notion of design replacement for combinational design (see, for example, <ref> [13, 52, 47, 77] </ref>). However, that controversy has its roots in designs which have cycles in the combinational parts of the circuit. Almost all real synchronous designs require at least one memory element in every cyclic path, and so we will restrict ourselves to this class of circuits. <p> For example, consider the delay assignments on the gates as shown in Figure 2.5. If we simulate this circuit with these delay assignments, assuming a standard event-driven simulator 2 , on the input 2 This is similar to the delay model used in <ref> [52] </ref> where the output of a t-delay gate changes instantly t time units after its input. It may be argued that a transistor-level implementation of this netlist may not behave exactly this way since gate outputs do not change instantly but change continuously in an analog manner.
Reference: [53] <author> S. Malik, E. M. Sentovich, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. Re-timing and Resynthesis: </author> <title> Optimization of Sequential Networks with Combinational Techniques. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 10(1) </volume> <pages> 74-84, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: CHAPTER 3. NOTIONS OF DESIGN REPLACEMENT 28 l 0 l 0 l 2 3.6 Retiming and Resynthesis Retiming and resynthesis <ref> [53] </ref> can be used to perform sequential optimization by alternating steps of moving of latches across combinational logic (retiming) and performing combinational resynthesis. Retiming seems to be able to work if latches do not have reset lines. However, consider once again the circuit in Figure 3.3. <p> When retiming such latches, one problem that arises is to obtain the new initial values for the retimed latches. This problem has been raised peripherally in <ref> [4, 53] </ref> and in much more detail in [81]. It has been claimed that if reset latches are modeled using no-reset latches, that restricts the class of possible retimings. <p> Also, we will show that it is possible that it some situations it adds less (or no) extra logic to achieve the retiming. The use of the reset transformation for obtaining a retiming for designs which cannot be retimed using local mapping of initial states was earlier suggested in <ref> [54, 53] </ref>. However, they thought that this restricts the space of retiming moves and adds unnecessary extra logic. For designs where reset latches can be retimed without adding additional logic, we showed in Section 8.2 that this false if we use the reset transformation.
Reference: [54] <author> Sharad Malik. </author> <title> Combinational Logic Optimization Techniques in Sequential Logic Synthesis. </title> <type> PhD thesis, </type> <institution> Electronics Research Laboratory, University of California, Berkeley, </institution> <address> CA 94720, </address> <month> November </month> <year> 1990. </year> <note> Memorandum No. UCB/ERL M90/115. </note>
Reference-contexts: This model even allows us to solve the problem for the case when it is not possible to retime the initial state without altering combinational logic (this solution had earlier been suggested by <ref> [54] </ref>). We prove the correctness of retiming the initial state using no-reset latches and we suggest an overall retiming strategy for use by a retiming tool. 8.1 Modeling Reset Latches We will deal with the validity of retiming transformations with the assumption that all latches are no-reset latches. <p> However, it has been pointed out to us [66] that once we transform an original design to a new design via such transformations we may no longer be able to retime the new design to designs which were retimed versions of the original design. In <ref> [54, page54] </ref> Malik also claims that making the reset circuitry explicit, as we suggest by our transformation, has two problems: (i) this results in less flexibility for retiming algorithms, and (ii) since latches CHAPTER 8. <p> Also, we will show that it is possible that it some situations it adds less (or no) extra logic to achieve the retiming. The use of the reset transformation for obtaining a retiming for designs which cannot be retimed using local mapping of initial states was earlier suggested in <ref> [54, 53] </ref>. However, they thought that this restricts the space of retiming moves and adds unnecessary extra logic. For designs where reset latches can be retimed without adding additional logic, we showed in Section 8.2 that this false if we use the reset transformation. <p> It should be interesting to explore if during retiming, these elements can also be retimed as a whole, similar to how we retime a no-reset latch with its reset circuitry, together as one unit. In Chapter 8, we also showed that modeling reset circuitry explicitly, suggested earlier <ref> [54] </ref>, provides an alternate strategy for retiming an initial state, for cases where such a retiming could not be achieved without adding additional logic.
Reference: [55] <author> T. E. Marchok, A. El-Maleh, W. Maly, and J. Rajski. </author> <title> Test Set Preservation under Retiming Transformation. </title> <type> Technical Report CMUCAD-94-23, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1994. </year> <booktitle> Presented at Intl. Test Synthesis Workshop, </booktitle> <address> Santa Barbara, CA, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: Marchok et al. <ref> [55] </ref> were the first to study the effect of retiming transformations on test sequences for single stuck-at faults. However, we show next that retiming may cause test sets to also change, contradicting their result: CHAPTER 7. VALIDITY OF RETIMING TRANSFORMATIONS 107 o 1 o 1 (Theorem 1 in [55]) The retiming <p> et al. <ref> [55] </ref> were the first to study the effect of retiming transformations on test sequences for single stuck-at faults. However, we show next that retiming may cause test sets to also change, contradicting their result: CHAPTER 7. VALIDITY OF RETIMING TRANSFORMATIONS 107 o 1 o 1 (Theorem 1 in [55]) The retiming transformation preserves testability with respect to a single stuck-at-fault test set. This theorem implies that if a test sequence uncovers a given stuck-at-fault in a circuit, then the same sequence can detect the same faults in a retimed version of the circuit. <p> Designers often use conservative three-valued simulators to validate their designs. We showed that if three-valued simulators are used, retiming transformations do not affect the output of such simulators even though they may not be safe replacements (in the sense of Chapter 4). In <ref> [55] </ref>, Marchok et al. studied the effect of retiming transformations on the test vector sequences for single stuck-at faults. We proved in this chapter that new test sequences can be obtained from old ones just by appending CHAPTER 9. <p> We proved in this chapter that new test sequences can be obtained from old ones just by appending CHAPTER 9. CONCLUSIONS 151 an arbitrary prefix sequence of length n, where n is determined by the sequence of retiming moves. Later, El-Maleh et al. [28] correct their result from <ref> [55] </ref> and show that test vector sequences, which have been generated by conservative three-valued simulators, are preserved from the original circuit to the retimed circuit. We note that this result follows from our result in Chapter 7 that retiming transformations do not affect the output of such simulators (Corollary 7.10).
Reference: [56] <author> Kenneth L. </author> <type> McMillan. </type> <institution> Cadence Berkeley Labs, Berkeley, CA. </institution> <type> Personal communication, </type> <year> 1995. </year>
Reference-contexts: To prove (b), it is sufficient to note that any implementation of D and D 0 will produce the same assignment to the wire connections between D and D 0 as long as there is no combinational loop in the composed implementation. 2 We show an example <ref> [56] </ref> where the design composition of STGs where one netlist implementation may cause a combinational cycle even though there exists another netlist CHAPTER 2. PRELIMINARIES 13 implementation where the composition does not yield a cycle.
Reference: [57] <author> I. M. Niven and H. S. Zuckerman. </author> <title> An Introduction to the Theory of Numbers. </title> <publisher> John Wiley & Sons, </publisher> <address> New York, NY, </address> <year> 1972. </year>
Reference-contexts: The proof of correctness is similar to the one above, and is omitted for brevity. 3 See <ref> [57, Chapter 8] </ref> for a proof, originally due to Tschebyschef, that p r &lt; dr log r where d is 8 log 2 . 67 Chapter 6 Delay Replacements We presented the notion of safe replaceability in Chapter 4.
Reference: [58] <author> M. Pandey, A. Jain, R. E. Bryant, D. Beatty, G. York, and S. Jain. </author> <title> Extraction of Finite State Machines from Transistor Netlists by Symbolic Simulation. </title> <booktitle> In Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pages 596-601, </pages> <address> Austin, TX, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: Getting such an abstraction from transistor-level designs to such nicely defined gate-level designs is an important area and a focus of many current researchers <ref> [39, 58, 78] </ref>. The problem of combinational loops has also received some attention.
Reference: [59] <author> C. Pixley. </author> <title> A Computational Theory and Implementation of Sequential Hardware Equivalence. </title> <editor> In E. M. Clarke and R. P. Kurshan, editors, </editor> <booktitle> Proc. of the Workshop on Computer-Aided Verification, volume 3 of DIMACS Series in Discrete Mathematics and Theoretical Computer Science, </booktitle> <pages> pages 293-320. </pages> <publisher> American Mathematical Society, </publisher> <month> June </month> <year> 1990. </year> <note> BIBLIOGRAPHY 160 </note>
Reference-contexts: NOTIONS OF DESIGN REPLACEMENT 21 M 1 such that s ~ t. 3.4 Sequential Hardware Equivalence Because the classical notion of FSM equivalence was thought to be too restrictive in the class of replacement designs it allowed, Pixley introduced the notion of sequential hardware equivalence <ref> [59, 60] </ref>. When a design with no-reset latches powers up, since the state it powers up in cannot be predicted, the desired input/output behavior is achieved from the design by driving a fixed initializing sequence of input vectors through the design after power-up. <p> Some natural choices are: * The set of all states Q D . * Any onion ring 1 of the design. Onion rings A 1 ; A 2 ; : : : are defined recursively: A 1 = Q D ; 1 This notion was earlier defined in <ref> [59] </ref>; the term "onion ring" was first used in [37]. CHAPTER 5. SYNTHESIS AND VERIFICATION FOR SAFE REPLACEABILITY 46 transitions are shown. For design D 4 in Figure 5.4, A 1 = f00; 01; 10; 11g; A 2 = A 3 = = A 1 = f01; 10; 11g. <p> Edges of the graph are labeled by a single input a 2 I. We presume that the equivalent state pairs of D 0 and D 1 have already been computed, see <ref> [59] </ref> (this is a procedure which is polynomial in the number of states of the two designs).
Reference: [60] <author> C. Pixley. </author> <title> A Theory and Implementation of Sequential Hardware Equivalence. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 11(12) </volume> <pages> 1469-1494, </pages> <month> De-cember </month> <year> 1992. </year>
Reference-contexts: NOTIONS OF DESIGN REPLACEMENT 21 M 1 such that s ~ t. 3.4 Sequential Hardware Equivalence Because the classical notion of FSM equivalence was thought to be too restrictive in the class of replacement designs it allowed, Pixley introduced the notion of sequential hardware equivalence <ref> [59, 60] </ref>. When a design with no-reset latches powers up, since the state it powers up in cannot be predicted, the desired input/output behavior is achieved from the design by driving a fixed initializing sequence of input vectors through the design after power-up. <p> Since designs are finite state machines, for any design, there is a bound on the number of onion rings. Elimination of all such ephemeral states for all clock cycles leaves a set of states, called the outer-envelope (OE) <ref> [60] </ref> or D 1 (Section 6.1 of this paper). Many well-crafted designs have ephemeral states due to the fact that binary encoding often leaves some states of the implementation without a corresponding state in the specified design. These states should be ephemeral. <p> Using the terminology in [37], this number n is the number of onion rings of the design D. D 1 is also the same as the outer-envelope (OE) of <ref> [60] </ref>. We refer to states in D 1 as the stable states of D, and the states in D n D 1 as the transient states of D.
Reference: [61] <author> Carl Pixley. </author> <title> Motorola, </title> <institution> Inc., Austin, TX. </institution> <type> Personal communication, </type> <year> 1993. </year>
Reference-contexts: Designs with unique minimal predecessors are therefore ones with unique tSCC's, or ones where all tSCC's are equivalent to each other. Most real designs have a single tSCC <ref> [61] </ref>. <p> The results for computing the various onion-rings and the tSCC appear in Table 5.1. Each of these designs has only one tSCC. This is in agreement with the thought that all useful designs have exactly one tSCC <ref> [61] </ref>; on the other hand, other people have argued that if we pick an arbitrary piece of logic from a larger design, this piece may have more than one tSCC even though the larger design has only one tSCC representing the steady-state behavior [66].
Reference: [62] <author> I. Pomeranz and S. M. Reddy. </author> <title> Classification of Faults in Synchronous Sequential Circuits. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 42(9) </volume> <pages> 1066-1077, </pages> <month> September </month> <year> 1993. </year>
Reference-contexts: In this section, we present two notions of sequential redundancy (which defines a notion of design replacement)| the first, defined by [15] and subsequently used for logic optimization in [29], and the second, defined by <ref> [62] </ref> and later used for redundancy removal in [63]. 3.5.1 Cheng's notion of sequential redundancy Definition 3.5 A fault is sequentially redundant if for any input sequence, any output line and any state of the faulty circuit D 1 , the circuit D 1 produces 1 (0) whenever the original circuit <p> However, in composition with design D 0 the composed design does have an initializing sequence 01 and is `well-behaved'. CHAPTER 3. NOTIONS OF DESIGN REPLACEMENT 26 CHAPTER 3. NOTIONS OF DESIGN REPLACEMENT 27 3.5.2 Pomeranz and Reddy's notion of sequential redundancy In <ref> [62] </ref> and [63], Pomeranz and Reddy classify faults into three categories. Faults are either detectable, partially detectable or redundant. They further sub-classify partially detectable faults into Type I faults and Type II faults. Their optimization procedure identifies Type II partially detectable and redundant faults and substitutes these faults by constants. <p> For such designs, any reasonable notion of design replacement will probably preserve the behavior of the tSCC; in fact, all other notions of design replacement that we discussed in Chapter 3 have this property; for example, for the problem of redundant fault removal, Pomeranz and Reddy have proved <ref> [62] </ref> that single stuck-at faults which are Type II partially detectable (see Section 3.5.2) create designs where the tSCC is equivalent to the tSCC of the original design.
Reference: [63] <author> I. Pomeranz and S. M. Reddy. </author> <title> On Removing Redundancies from Synchronous Sequential Circuits with Synchronizing Sequences. </title> <type> Technical Report 12-20-1993, </type> <institution> Electrical and Computer Engineering Department, University of Iowa, </institution> <address> Iowa City, IA 52242, </address> <year> 1993. </year>
Reference-contexts: In this section, we present two notions of sequential redundancy (which defines a notion of design replacement)| the first, defined by [15] and subsequently used for logic optimization in [29], and the second, defined by [62] and later used for redundancy removal in <ref> [63] </ref>. 3.5.1 Cheng's notion of sequential redundancy Definition 3.5 A fault is sequentially redundant if for any input sequence, any output line and any state of the faulty circuit D 1 , the circuit D 1 produces 1 (0) whenever the original circuit D 0 produces 1 (0) from all states <p> However, in composition with design D 0 the composed design does have an initializing sequence 01 and is `well-behaved'. CHAPTER 3. NOTIONS OF DESIGN REPLACEMENT 26 CHAPTER 3. NOTIONS OF DESIGN REPLACEMENT 27 3.5.2 Pomeranz and Reddy's notion of sequential redundancy In [62] and <ref> [63] </ref>, Pomeranz and Reddy classify faults into three categories. Faults are either detectable, partially detectable or redundant. They further sub-classify partially detectable faults into Type I faults and Type II faults. Their optimization procedure identifies Type II partially detectable and redundant faults and substitutes these faults by constants. <p> We presented our notion of safe replaceability in Chapter 4 and discussed design replacement on any arbitrary design, in the absence of any knowledge of the environment of a design. For redundancy identification in sequential circuits, Pomeranz and Reddy <ref> [63] </ref> have identified an equivalent notion, but in their algorithm for redundancy identification, they use a notion which allows them to classify more faults as redundant at the expense of making some initialization assumptions about the environment of the design. Recently, CHAPTER 9.
Reference: [64] <institution> Stefano Quer. Politecnico di Torino, Torino, Italy. </institution> <type> Personal communication, </type> <year> 1995. </year>
Reference-contexts: For some inexplicable reason, at least two of the benchmark circuits, s208 and s420 seem to be slightly different from the ones used by others <ref> [18, 50, 64] </ref>. CHAPTER 5.
Reference: [65] <author> J.-K. Rho, G. D. Hachtel, F. Somenzi, and R. M. </author> <title> Jacoby. Exact and Heuristic Algorithms for the Minimization of Incompletely Specified State Machines. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 13(2) </volume> <pages> 167-177, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: The problem of state minimization is orthogonal to our research; for its application in digital circuits, it has been studied in detail in <ref> [32, 65, 40] </ref>. For completely specified deterministic machines, the minimum state machine is unique and hence can be thought of as the canonical representation of the FSM. A netlist is an interconnection of elementary circuit elements connected by wires.
Reference: [66] <author> Richard L. </author> <type> Rudell. </type> <institution> Synopsys, Inc., Mountain View, CA. </institution> <type> Personal communication, </type> <year> 1995. </year>
Reference-contexts: all useful designs have exactly one tSCC [61]; on the other hand, other people have argued that if we pick an arbitrary piece of logic from a larger design, this piece may have more than one tSCC even though the larger design has only one tSCC representing the steady-state behavior <ref> [66] </ref>. In this thesis we are motivated by the problem of replacing arbitrary pieces of logic and thus we allow designs to have multiple tSCCs. CHAPTER 5. <p> For designs where some latches are reset latches we can transform these latches to no-reset latches using the transformation described in Chapter 2. However, it has been pointed out to us <ref> [66] </ref> that once we transform an original design to a new design via such transformations we may no longer be able to retime the new design to designs which were retimed versions of the original design.
Reference: [67] <author> A. Saldanha, T. Villa, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Satisfaction of Input and Output Encoding Constraints. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 13(5) </volume> <pages> 589-602, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: The problem of obtaining an "optimal" netlist, with respect to some cost function, is the state-encoding and FSM implementation problem. This is usually a provably intractable problem and many heuristics have been suggested to attack many variants of CHAPTER 2. PRELIMINARIES 10 minimization. this problem <ref> [25, 26, 74, 67] </ref>. This problem is orthogonal to the issues of this thesis. 2.3 Composition of designs Because we are interested in the problem of replacing designs without affecting the interaction with the environment designs, the issue of composing designs is crucial to this thesis. <p> We are preserving the state encodings of the states in our design, even though this is not required for safe replaceability. This is done to make our synthesis procedure tractable; state encoding is, in general, a hard problem <ref> [25, 26, 74, 67] </ref> and we do not attempt to solve it in this thesis. <p> However, without the designated initial state assumption, all 2 t encodings of an implementation (which has t latches) must satisfy the safe replacement condition with respect to the given behavioral-level specification. This will add additional constraints to the traditional problem of state encoding and implementation (see <ref> [67] </ref> for the traditional formulation). In [83], Watanabe and Brayton characterized the set of permissible design replacements for a given design with respect to a given environment. However, they also made the assumption of a designated initial state for both the environment as well as the design. CHAPTER 9.
Reference: [68] <author> J. V. Sanghavi, R. K. Ranjan, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> High Performance BDD Package Based on Exploiting Memory Hierarchy. </title> <booktitle> In Proc. of the Design Automation Conf., </booktitle> <address> Las Vegas, NV, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: In this thesis, we are using a subset of the ISCAS89 benchmark circuits [12] to demonstrate the synthesis techniques. We use binary decision diagrams (BDDs) and a standard toolset (similar to the ones in <ref> [7, 51, 68] </ref>) to implement our algorithms. Because of limitations imposed by the use of the BDD package we use the subset of ISCAS89 circuits 2 2 We use the benchmark circuits supplied with the SIS package, version 1.2.
Reference: [69] <author> W. J. Savitch. </author> <title> Relationship between Nondeterministic and Deterministic Tape Complexities. </title> <journal> Journal of Computer and System Sciences, </journal> <pages> pages 177-192, </pages> <year> 1970. </year>
Reference-contexts: We have to store at most (1 + Q C ) states at each step. Since (; d) is a witness, all states in C must eventually die out proving the validity of the witness. Thus the complementary problem is in NPSPACE. By Savitch's theorem <ref> [69, 30] </ref>, the complementary problem is in PSPACE (i.e. a deterministic Turing machine can recognize it). Thus, safe replaceability is also in PSPACE. The proof of PSPACE-hardness is by transformation from the FINITE STATE AUTOMATA INTERSECTION problem, which is PSPACE-complete [42, 30].
Reference: [70] <author> H. Savoj and R. K. Brayton. </author> <title> Observability Relations and Observability Don't Cares. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 518-521, </pages> <address> Santa Clara, CA, </address> <month> November </month> <year> 1991. </year>
Reference-contexts: We want to optimize this combinational part while maintaining the safe replacement condition. If we could express the flexibility in Definition 4.1 by a Boolean relation in ( ~ i; ~x; ~o; ~y), we could use known techniques <ref> [70] </ref> for minimizing multilevel networks, given a Boolean relation in terms of the inputs and outputs of the network, by treating ( ~ i; ~x) as the inputs and (~o; ~y) as the outputs of the combinational part of the network. <p> The only known method for minimizing multi-level networks under flexibility expressed by a Boolean relation <ref> [70] </ref> requires this restriction, as we shall see later in Section 5.1.4. <p> This means that we automatically remove redundant faults (which satisfy R) from the circuit. Note that we are able to detect these redundancies because we are computing the flexibility of each node just before minimizing it; if we had obtained compatible flexibility (as in <ref> [70] </ref>) for all nodes before minimizing them simultaneously we would not be able to claim this. <p> We will then use this relation to do multi-level resynthesis on our design. First, we informally describe the flexibility which will be specified later using a Boolean relation V. We note again that techniques for using a Boolean relation to do multilevel synthesis <ref> [70] </ref> require the relation to be such that the starting design satisfies the relation. The Boolean relation is such that the behavior of the states in D n (the "stable" states) is preserved. <p> This can be solved in two steps. First, we obtain any arbitrary multi-level network representing some F compatible with S. Then, one approach would be to use the techniques in <ref> [70] </ref> (like we used in Sections 5.1.4 and 6.2.1) to optimize this network maintaining compatibility with S.
Reference: [71] <author> H. Savoj, R. K. Brayton, and H. Touati. </author> <title> Extracting Local Don't Cares for Network Optimization. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 514-517, </pages> <address> Santa Clara, CA, </address> <month> November </month> <year> 1991. </year> <note> BIBLIOGRAPHY 161 </note>
Reference-contexts: For such designs, this is the notion of design equivalence used for logic synthesis <ref> [71] </ref>, test pattern generation [31], redundancy removal [19] and sequential verification [21]. <p> This gives rise to satisfiability don't care (SDC) points for f i [11]. * For certain input assignments, the values taken by the primary outputs of N may be independent of the function computed by a node; these are observability don't care points (ODC) for that node <ref> [71] </ref>. * For certain input assignments the functionality of the node can be changed without destroying safe replaceability; this flexibility, that we have described in the preceding sections, leads to the replaceability don't cares points (RDC). <p> This is in terms of primary inputs; we then project this set into the space comprised of the fan-ins of the node (as in <ref> [71] </ref>). These are used in conjunction with a subset of the satisfiability don't care set to optimize the function at u. The complete procedure to do the multi-level logic optimization is outlined is Figure 5.9.
Reference: [72] <author> E. M. Sentovich, K. J. Singh, C. Moon, H. Savoj, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Sequential Circuit Design Using Synthesis and Optimization. </title> <booktitle> In Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pages 328-333, </pages> <address> Cambridge, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: CHAPTER 3. NOTIONS OF DESIGN REPLACEMENT 20 3.1 Combinational Replacement This notion characterizes combinational designs (i.e. no memory elements) which are valid replacements of existing combinational designs. The notion of combinational replacement used in most logic synthesis tools (such as SIS <ref> [72] </ref>) is that the Boolean function (from f0; 1g m to f0; 1g n , if there are m input wires and n output wires) associated with the replacement design is the same as the Boolean function associated with the original design. <p> In both implementations the combinational functionality of the design is identical, namely z = x. However, Netlist 2 creates a combinational cycle because of the environment D 0 . In fact, after making a design replacement, most logic synthesis tools <ref> [43, 72] </ref> either check that the replacement has not caused a combinational cycle or have constraints which prevent a combinational cycle during the synthesis procedure. 3.2 Identical Behavior from Initial State Most of the previous work on equivalence and replacement of sequential circuits assumes a designated initial state for the circuit. <p> We saw in the previous chapter, in Section 3.1 that for combinational circuits, CHAPTER 4. SAFE REPLACEABILITY 32 there is an accepted notion of replacement equivalence which is used in logic synthesis tools such as SIS <ref> [72] </ref>. A circuit D is a valid replacement for circuit D, if for any input vector in B m , the output vector (in B n ) produced by D is identical to that produced by C. <p> time: we need to simplify nodes on an individual basis, and if the node is simplified, potentially all the BDDs for functions that the node fans out to must be recomputed. 5.1.5 Experiments and Analysis We have implemented the above method for sequential resynthesis in the SIS sequential synthesis system <ref> [72] </ref>. We have performed experiments on the same set of ISCAS89 benchmark examples that we chose for the experiments in Table 5.1. We report our experiments in Table 5.2.
Reference: [73] <author> E. M. Sentovich, V. Singhal, and R. K. Brayton. </author> <title> Multiple Boolean Relations. </title> <booktitle> In Workshop Notes of the Intl. Workshop on Logic Synthesis, </booktitle> <address> Tahoe City, CA, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: One property of Boolean relations is that the flexibility for each point in the domain space is independent of other points <ref> [73] </ref>. So, if the flexibility for safe replacement could be expressed by a Boolean relation, then every design corresponding to a flexibility choice for each of these 6 domain points would be a valid replacement (there are 2 6 such designs). <p> SYNTHESIS AND VERIFICATION FOR SAFE REPLACEABILITY 42 CHAPTER 5. SYNTHESIS AND VERIFICATION FOR SAFE REPLACEABILITY 43 relation in ( ~ i; ~x) fi (~o; ~y). One way to represent such flexibility would be through Multiple Boolean Relations <ref> [73] </ref>, which are arbitrary sets of Boolean relations. 5.1.1 Sufficient Condition for a Safe Replacement As we have just argued, the complete flexibility for safe replacement can be expressed by a multiple Boolean relation.
Reference: [74] <author> J.-J. Shen, Z. Hasan, and M. J. Ciesielski. </author> <title> State Assignment for General FSM Networks. </title> <booktitle> In Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pages 245-249, </pages> <address> Cambridge, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: The problem of obtaining an "optimal" netlist, with respect to some cost function, is the state-encoding and FSM implementation problem. This is usually a provably intractable problem and many heuristics have been suggested to attack many variants of CHAPTER 2. PRELIMINARIES 10 minimization. this problem <ref> [25, 26, 74, 67] </ref>. This problem is orthogonal to the issues of this thesis. 2.3 Composition of designs Because we are interested in the problem of replacing designs without affecting the interaction with the environment designs, the issue of composing designs is crucial to this thesis. <p> We are preserving the state encodings of the states in our design, even though this is not required for safe replaceability. This is done to make our synthesis procedure tractable; state encoding is, in general, a hard problem <ref> [25, 26, 74, 67] </ref> and we do not attempt to solve it in this thesis.
Reference: [75] <author> N. Shenoy and R. Rudell. </author> <title> Efficient Implementation of Retiming. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 226-233, </pages> <address> San Jose, CA, </address> <month> November </month> <year> 1994. </year>
Reference-contexts: In this manner, the number of latches can be reduced, and/or the cycle time of the circuit can be improved. Recent results by Shenoy and Rudell <ref> [75] </ref> have improved the efficiency of retiming so that circuits up to 50,000 equivalent gates can be retimed for minimum area under a delay constraint. This has sparked further interest in exploring the application of retiming as a general optimization step during logic synthesis.
Reference: [76] <author> T. R. Shiple, R. Hojati, A. L. Sangiovanni-Vincentelli, and R. K. Brayton. </author> <title> Heuristic Minimization of BDDs Using Don't Cares. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 225-231, </pages> <address> San Diego, CA, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: use a BDD minimization procedure, which heuristically finds an implementation which has the smallest support (we use a simpler version of the algorithm in [46]); alternately, we could have used bdd-generalized-cofactor (due to [22]) or any of many other BDD minimization algorithms with respect to a don't care set (see <ref> [76] </ref>). Since we are dealing with very small functions, in our application, the choice of the heuristic does not matter. The minimized BDD is converted to a similar looking network whose nodes are multiplexors controlled by the variable of the corresponding BDD node.
Reference: [77] <author> T. R. Shiple, V. Singhal, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Analysis of Combinational Cycles in Sequential Circuits. </title> <booktitle> In Proc. Intl. Symposium on Circuits and Systems, </booktitle> <address> Atlanta, GA, </address> <month> May </month> <year> 1996. </year>
Reference-contexts: We will discuss this further in Chapter 2. For arbitrary sequential netlists, one notion that can used for replacement is the 1 Actually there is much debate over the notion of design replacement for combinational design (see, for example, <ref> [13, 52, 47, 77] </ref>). However, that controversy has its roots in designs which have cycles in the combinational parts of the circuit. Almost all real synchronous designs require at least one memory element in every cyclic path, and so we will restrict ourselves to this class of circuits. <p> A real implementation (i.e., the hardware realization in silicon) of such a circuit may or many not oscillate for an indeterminate time. Issues regarding behavior of circuits with combinational loops have been dealt elsewhere <ref> [85, 77] </ref>. As stated in the previous section, in this thesis we assume that we never encounter a combinational loop. This means that we talk about composition of designs only when the composition does not create combinational loops. Few real gate-level designs have combinational cycles. <p> The problem of combinational loops has also received some attention. Some people have identified classes of such circuits where these circuits can be replaced by "equivalent" circuits with no combinational loops <ref> [77] </ref>; others have endeavored to define the semantics of all circuits, including the ones with combinational loops [13, 85]. We presented our notion of safe replaceability in Chapter 4 and discussed design replacement on any arbitrary design, in the absence of any knowledge of the environment of a design.
Reference: [78] <author> K. J. Singh and P. A. Subramanyam. </author> <title> Extracting RTL Models from Transistor Netlists. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 11-17, </pages> <address> San Jose, CA, </address> <month> November </month> <year> 1995. </year>
Reference-contexts: Getting such an abstraction from transistor-level designs to such nicely defined gate-level designs is an important area and a focus of many current researchers <ref> [39, 58, 78] </ref>. The problem of combinational loops has also received some attention.
Reference: [79] <author> V. Singhal, Y. Watanabe, and R. K. Brayton. </author> <title> Heuristic Minimization of Synchronous Relations. </title> <booktitle> In Proc. Intl. Conf. on Computer Design, </booktitle> <pages> pages 428-433, </pages> <address> Cambridge, MA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: We will return to a discussion about the validity of retiming moves in Chapter 7. 3.7 Synchronous Recurrence Equations Damiani and De Micheli [24] proposed using synchronous recurrence equations (or synchronous relations as used by <ref> [79] </ref>) to capture don't care information in sequential circuits. A synchronous recurrence equation expresses the flexibility for a sequential circuit as a Boolean relation on finite sequences of inputs and outputs. Any implementation that satisfies this synchronous recurrence equation is defined to be a valid replacement.
Reference: [80] <author> H. Touati, H. Savoj, B. Lin, R. K. Brayton, and A. L. Sangiovanni-Vincentelli. </author> <title> Implicit State Enumeration of Finite State Machines using BDD's. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 130-133, </pages> <address> Santa Clara, CA, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: CHAPTER 2. PRELIMINARIES 6 latches is switched on, it randomly starts up in one of the 2 t power-up states (a state corresponds to an assignment of binary values to each of the latches). Many sequential synthesis and verification studies (such as <ref> [21, 80, 17, 48, 5] </ref>) rely on the supposition that all latches are reset latches by assuming that there is a designated initial state for each design; such an initial state corresponds to a designated assignment of binary values to each of the latches and it is assumed that when the <p> The image projection step in the algorithm in the figure can de done using a variety of algorithms (see <ref> [22, 80] </ref>, for example); we use the algorithm presented in [80]. CHAPTER 5. <p> The image projection step in the algorithm in the figure can de done using a variety of algorithms (see [22, 80], for example); we use the algorithm presented in <ref> [80] </ref>. CHAPTER 5.
Reference: [81] <author> H. J. Touati and R. K. Brayton. </author> <title> Computing the Initial States of Retimed Circuits. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits, </journal> <volume> 12(1) </volume> <pages> 157-162, </pages> <month> January </month> <year> 1993. </year> <note> BIBLIOGRAPHY 162 </note>
Reference-contexts: As a final comment, note that our model of a synchronous circuit does not require a latch to have a set or reset line and does not require any notion of the initial state of the circuit. Hence, we avoid the problem pursued by Touati and Brayton <ref> [81] </ref> in retiming the initial state. 7.1 Retiming Violates Safe Replacement Here we show how a simple retiming move might change the behavior of a design with respect to the output of a simulator. Consider the circuit D and the retimed version C in Figure 7.1. <p> When retiming such latches, one problem that arises is to obtain the new initial values for the retimed latches. This problem has been raised peripherally in [4, 53] and in much more detail in <ref> [81] </ref>. It has been claimed that if reset latches are modeled using no-reset latches, that restricts the class of possible retimings. In this chapter, we show that, this is not the case and using no-reset latches and reset circuitry provides the most general model. <p> For a retiming move on a circuit with only reset latches, an equivalent initial state can be obtained by taking the forward (backward) image of the initial values for a forward (backward) retiming move <ref> [81] </ref>. The forward image is always deterministic but the backward image may be empty or may contain several solutions. If it is empty the retimed initial state cannot be obtained in straightforward say (see Section 8.3). <p> This is illustrated by the following example (from <ref> [81] </ref>): Consider the upper circuit in Figure 8.4. Each of the reset latches has a hardware initial value which is indicated on the latch. <p> However, it is clear from the STG of the lower circuit that no such state exists. The only way to achieve an equivalent design as the above design is by adding extra logic to the circuit; the solution, from <ref> [81] </ref>, is discussed in Section 8.3. There we will show we CHAPTER 8. RETIMING THE INITIAL STATE 129 can simulate retiming for this class of circuits if we transform the design reset latches to a design with only no-reset latches using the reset transformation. <p> For such situations it may be possible to determine the final initial state by looking at the entire set of retiming moves and analyzing their effect on the transition graph of the design <ref> [81] </ref>. <p> This problem arises because of reconvergence in the logic, and we could solve this if our retiming algorithm would have the ability to backtrack. However, a more elegant solution is provided in <ref> [81] </ref> where they analyze the global behavior of all latches, and thus directly find the value of the initial state for the entire sequence of retiming steps. First we review the procedure in [81]. <p> However, a more elegant solution is provided in <ref> [81] </ref> where they analyze the global behavior of all latches, and thus directly find the value of the initial state for the entire sequence of retiming steps. First we review the procedure in [81]. Their solution requires forward retiming across the host node (recall, from Section 7.2.1, that the host node is the node in the retiming graph that connects all outputs to all inputs). <p> In the previous section we had only shown the correctness of retiming the no-reset latches plus reset circuitry for retiming across combinational elements. After we review the procedure in <ref> [81] </ref>, we will prove that we can retime the no-reset latches plus reset circuitry across the host node also, so that we can simulate the results of [81]. <p> After we review the procedure in <ref> [81] </ref>, we will prove that we can retime the no-reset latches plus reset circuitry across the host node also, so that we can simulate the results of [81]. Later, at the end of this section we will explain the caveats of using this algorithm for obtaining a global retiming of the initial state. CHAPTER 8. RETIMING THE INITIAL STATE 134 CHAPTER 8. <p> CHAPTER 8. RETIMING THE INITIAL STATE 134 CHAPTER 8. RETIMING THE INITIAL STATE 135 Touati-Brayton's algorithm for determining new initial state for a retiming Here we describe the algorithm in <ref> [81] </ref> to obtain a new initial state for a given retiming for a circuit where all latches are reset latches. Recall, from Section 7.2.1, that a retiming graph contains a vertex for every combinational node plus an extra node, the host node. <p> We discussed an example illustrating such a situation in the previous section (Figure 8.4). Condition 8.1 is a sufficient condition for retiming the initial state, as we saw in Section 8.2.2. The second contribution of <ref> [81] </ref> is that for designs which do not satisfy this sufficient condition, a method is given for retiming the design; this method adds extra logic to achieve this. <p> We review their method, consider an alternative approach, and then argue why the second approach is more robust and for some designs more efficient than the approach of <ref> [81] </ref>. 8.3.1 Touati-Brayton's approach of modifying STG Touati and Brayton achieve the desired retiming by adding extra logic to the circuit. <p> Thus Condition 8.1 is satisfied for the modified design and we can apply the algorithm shown in previous section. To minimize the added logic, <ref> [81] </ref> chooses state s 2 in such a way that, among all reachable states from s 0 , the binary encoding of s 2 realizes the minimum Hamming distance from the binary encoding of s 0 . As as example, borrowed from [81], consider once again the retiming which we were <p> To minimize the added logic, <ref> [81] </ref> chooses state s 2 in such a way that, among all reachable states from s 0 , the binary encoding of s 2 realizes the minimum Hamming distance from the binary encoding of s 0 . As as example, borrowed from [81], consider once again the retiming which we were unable to achieve in Section 8.2 (Figure 8.4). With the method just explained, this retiming can be achieved as shown in Figure 8.8. Here, s0 is 01, s1 is 11 and s2 is 10. <p> Thus the two solutions are almost of identical cost. In the next section, in we can attain a slightly better solution. There are two advantages of this approach over the approach in <ref> [81] </ref>: * The biggest advantage is that this approach is more robust to the size of the designs. Since Touati-Brayton's algorithm requires the construction of the STG of the design, it is limited to the designs where this is possible. <p> In case it is not possible to retime the initial state, the reset circuitry can be left behind and just the no-reset retimed. We have argued in Section 8.3.2 that this approach is more robust and sometimes produces more efficient solutions than given in <ref> [81] </ref> for this class of retimings. We have shown how to retime the initial state when only some of the latches are reset latches and others are no-reset latches in Section 8.4. <p> This provides an alternate 1 That it may not be possible to verify this by exhaustive simulation in any reasonable amount of time is another issue altogether. CHAPTER 9. CONCLUSIONS 152 strategy to the algorithm in <ref> [81] </ref>. We also discussed how to obtain the retimed initial state in an environment with have a mixture of reset and no-reset latches. At the end of the chapter, we presented with an overall strategy for retiming latches for use by a synthesis tool.
Reference: [82] <institution> Tiziano Villa. University of California at Berkeley, Berkeley, CA. </institution> <type> Personal communication, </type> <year> 1995. </year>
Reference-contexts: DELAY REPLACEMENTS 86 away the original netlist structure in the process). Unfortunately, this strategy has been observed <ref> [82] </ref> to produce much larger circuits (in the number of literals) than the original circuit reinforcing the belief that the starting multi-level netlists are precious and if our synthesis procedure throws them away it becomes very hard to reconstruct as good a netlist just from the input-output functionality of a design.
Reference: [83] <author> Y. Watanabe and R. K. Brayton. </author> <title> The Maximum Set of Permissible Behaviors for FSM Networks. </title> <booktitle> In Proc. Intl. Conf. on Computer-Aided Design, </booktitle> <pages> pages 316-320, </pages> <address> Santa Clara, CA, </address> <month> November </month> <year> 1993. </year>
Reference-contexts: Recently, CHAPTER 9. CONCLUSIONS 149 Brand et al. [8] used the term "safe replaceability" to denote replacement of designs in presence of a given environment (as in <ref> [83] </ref>); interestingly, they use the term "universal replacement" to mean precisely what we have defined as safe replacement. In the first half of Chapter 5, we used our notion of safe replaceability to do sequential optimizations on gate-level designs. Many comments are in order here. <p> This will add additional constraints to the traditional problem of state encoding and implementation (see [67] for the traditional formulation). In <ref> [83] </ref>, Watanabe and Brayton characterized the set of permissible design replacements for a given design with respect to a given environment. However, they also made the assumption of a designated initial state for both the environment as well as the design. CHAPTER 9.
Reference: [84] <author> Y. Watanabe and R. K. Brayton. </author> <title> State Minimization of Pseudo Non-Deterministic FSM's. </title> <booktitle> In Proc. European Design and Test Conf., </booktitle> <pages> pages 184-191, </pages> <address> Paris, France, </address> <year> 1994. </year>
Reference-contexts: In [83], Watanabe and Brayton characterized the set of permissible design replacements for a given design with respect to a given environment. However, they also made the assumption of a designated initial state for both the environment as well as the design. CHAPTER 9. CONCLUSIONS 150 In <ref> [84] </ref>, they provided a solution to the problem of extracting an optimal implementation from this characterization of the set of permissible behaviors.
Reference: [85] <author> Elizabeth S. Wolf. </author> <title> Hierarchical Models of Synchronous Circuits for Formal Verification and Substitution. </title> <type> PhD thesis, </type> <institution> Stanford University, Computer Systems Laboratory, Stanford, </institution> <address> CA 94305-4055, </address> <year> 1995. </year> <note> Report No. CSL-TR-95-1557. </note>
Reference-contexts: A real implementation (i.e., the hardware realization in silicon) of such a circuit may or many not oscillate for an indeterminate time. Issues regarding behavior of circuits with combinational loops have been dealt elsewhere <ref> [85, 77] </ref>. As stated in the previous section, in this thesis we assume that we never encounter a combinational loop. This means that we talk about composition of designs only when the composition does not create combinational loops. Few real gate-level designs have combinational cycles. <p> The problem of combinational loops has also received some attention. Some people have identified classes of such circuits where these circuits can be replaced by "equivalent" circuits with no combinational loops [77]; others have endeavored to define the semantics of all circuits, including the ones with combinational loops <ref> [13, 85] </ref>. We presented our notion of safe replaceability in Chapter 4 and discussed design replacement on any arbitrary design, in the absence of any knowledge of the environment of a design.
References-found: 85

