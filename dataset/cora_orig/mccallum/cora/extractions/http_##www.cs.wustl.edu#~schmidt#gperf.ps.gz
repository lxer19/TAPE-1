URL: http://www.cs.wustl.edu/~schmidt/gperf.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/doc-center.html
Root-URL: http://www.cs.wustl.edu
Email: schmidt@cs.wustl.edu  
Title: GPERF A Perfect Hash Function Generator  
Author: Douglas C. Schmidt 
Address: St. Louis 63130  
Affiliation: Department of Computer Science Washington University,  
Web: http://www.cs.wustl.edu/schmidt/  
Abstract: This paper appeared in the C++ Report, Novem-ber/December, 1998. An earlier version of this paper appeared in the 2 nd USENIX C++ Conference in San Francisco, Cali-fornia, April 1990. Abstract gperf is a software-tool generating-tool designed to automate the generation of perfect hash functions. This paper describes the features, algorithms, and object-oriented design and implementation strategies incorporated in gperf. It also presents the results from an empirical comparison between gperf-generated recognizers and other popular techniques for reserved word lookup. gperf is distributed with the GNU libg++ library and is used to generate the keyword recogniz-ers for the GNU C/C++ compilers and the TAO CORBA IDL compiler. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Lesk and E. Schmidt, </author> <title> LEX ALexical Analyzer Generator. </title> <institution> Bell Laboratories, </institution> <address> Murray Hill, N.J., </address> <note> Unix Programmers Manual ed. </note>
Reference-contexts: Keywords are inserted into the set once, usually off-line at compile-time. gperf is a freely available perfect hash function generator written in C++ that automatically constructs perfect hash functions from a user-supplied list of keywords. It was designed in the spirit of utilities like lex <ref> [1] </ref> and yacc [2] to remove the drudgery associated with constructing time and space efficient keyword recognizers manually. gperf translates an n element list of user-specified keywords, called the keyfile, into source code containing a k ele ment lookup table and the following pair of functions: * hash uniquely maps keywords <p> To resolve this collision and generate a perfect hash function for C++ reserved words, an additional character must be added to the keysig, as follows: hash_value = asso_values [keyword [0]] + asso_values [keyword <ref> [1] </ref>] + asso_values [keyword [length - 1]] + length; Developers can control the generated hash function's contents using the "-k" option to explicitly specify the keyword index positions used as keysig elements by gperf. The default is "-k 1,$", where the '$' represents the keyword's final character. <p> 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 2, 9, 5, 1, 11, 0, 12, 2, 12, 5, 0, 0, 12, -; return asso_values [str [2]] + asso_values [str <ref> [1] </ref>]; - const struct months * is_month (const char *str, unsigned int len) - static const struct months wordlist [] = - -"september", 9, 30, 30-, -"june", 6, 30, 30-, -"april", 4, 30, 30-, -"january", 1, 31, 31-, -"march", 3, 31, 31-, -"december", 12, 31, 31-, -"july", 7, 31, 31-, -"august", <p> Figure 5 shows how the switch statement code appears if the months exam ple is generated with gperf's "-S 1" option. - const struct months *rw; switch (key) - case 0: rw = &wordlist [0]; break; case 1: rw = &wordlist <ref> [1] </ref>; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; <p> Note how gperf checks the len parameter and resulting hash function return value against the symbolic constants for MAX WORD LENGTH, MIN WORD LENGTH, 3 Note that C arrays start at 0, so str <ref> [1] </ref> is actually the second character. MAX HASH VALUE, and MIN HASH VALUE. This check quickly eliminates many non-month names from further consideration. If users know in advance that all input strings are valid keywords, gperf will suppress this addition checking with the "-O" option.
Reference: [2] <author> S. Johnson, </author> <title> YACC Yet another Compiler Compiler. </title> <institution> Bell Laboratories, </institution> <address> Murray Hill, N.J., </address> <note> Unix Programmers Manual ed. </note>
Reference-contexts: Keywords are inserted into the set once, usually off-line at compile-time. gperf is a freely available perfect hash function generator written in C++ that automatically constructs perfect hash functions from a user-supplied list of keywords. It was designed in the spirit of utilities like lex [1] and yacc <ref> [2] </ref> to remove the drudgery associated with constructing time and space efficient keyword recognizers manually. gperf translates an n element list of user-specified keywords, called the keyfile, into source code containing a k ele ment lookup table and the following pair of functions: * hash uniquely maps keywords in the keyfile <p> 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 2, 9, 5, 1, 11, 0, 12, 2, 12, 5, 0, 0, 12, -; return asso_values [str <ref> [2] </ref>] + asso_values [str [1]]; - const struct months * is_month (const char *str, unsigned int len) - static const struct months wordlist [] = - -"september", 9, 30, 30-, -"june", 6, 30, 30-, -"april", 4, 30, 30-, -"january", 1, 31, 31-, -"march", 3, 31, 31-, -"december", 12, 31, 31-, -"july", <p> Figure 5 shows how the switch statement code appears if the months exam ple is generated with gperf's "-S 1" option. - const struct months *rw; switch (key) - case 0: rw = &wordlist [0]; break; case 1: rw = &wordlist [1]; break; case 2: rw = &wordlist <ref> [2] </ref>; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break;
Reference: [3] <author> R. M. Stallman, </author> <title> Using and Porting GNU CC. Free Software Foundation, </title> <publisher> GCC 2.7.2 ed. </publisher>
Reference-contexts: It has been used to generate reserved keyword recognizers in lexical analyzers for several production and research compilers and language processing tools, including GNU C/C++ <ref> [3] </ref> and the TAO CORBA IDL compiler [4]. <p> switch statement code appears if the months exam ple is generated with gperf's "-S 1" option. - const struct months *rw; switch (key) - case 0: rw = &wordlist [0]; break; case 1: rw = &wordlist [1]; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist <ref> [3] </ref>; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break; <p> However, good C++ compilers generate assembly code implementing a binary-search-of-labels scheme if the switch statement's case labels are sparse compared to the range between the smallest and largest case labels <ref> [3] </ref>. This technique can save a great deal of space by not emitting un necessary empty array locations or jump-table slots.
Reference: [4] <author> A. Gokhale, D. C. Schmidt, and S. Moyer, </author> <title> Tools for Automating the Migration from DCE to CORBA, </title> <booktitle> in Proceedings of ISS 97: World Telecommunications Congress, </booktitle> <address> (Toronto, Canada), </address> <publisher> IEEE Communications Society, </publisher> <month> September </month> <year> 1997. </year>
Reference-contexts: It has been used to generate reserved keyword recognizers in lexical analyzers for several production and research compilers and language processing tools, including GNU C/C++ [3] and the TAO CORBA IDL compiler <ref> [4] </ref>. <p> exam ple is generated with gperf's "-S 1" option. - const struct months *rw; switch (key) - case 0: rw = &wordlist [0]; break; case 1: rw = &wordlist [1]; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist <ref> [4] </ref>; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist [11]; break; <p> The various features described in this paper enable it to achieve its goal, as evidenced by its use in the GNU compilers. In addition, gperf has been used in the following applications: * The TAO CORBA IDL compiler <ref> [4] </ref> uses gperf to generate the operation dispatching tables [21] used by server side skeletons. * A hash function for 15,400 Medical Subject Headings used to index journal article citations in MEDLINE, a large bibliographic database of the biomedical literature maintained by the National Library of Medicine.
Reference: [5] <author> D. E. Knuth, </author> <booktitle> The Art of Computer Programming, </booktitle> <volume> vol. </volume> <month> 1: </month> <title> Searching and Sorting. </title> <address> Reading, MA: </address> <publisher> Addison Wesley, </publisher> <year> 1973. </year>
Reference-contexts: Common examples include sorted and unsorted arrays and linked lists, AVL trees, optimal binary search trees, digital search tries, deterministic finite-state automata, and various hash table schemes, such as open addressing and bucket chaining <ref> [5] </ref>. Different static search structure implementations offer trade-offs between memory utilization and search time efficiency and predictability. For example, an n element sorted array is space efficient. However, the average- and worst-case time complexity for retrieval operations using binary search on a sorted array is proportional to O (log n) [5]. <p> <ref> [5] </ref>. Different static search structure implementations offer trade-offs between memory utilization and search time efficiency and predictability. For example, an n element sorted array is space efficient. However, the average- and worst-case time complexity for retrieval operations using binary search on a sorted array is proportional to O (log n) [5]. In contrast, chained hash table implementations locate a table entry in constant, i.e., O (1), time on the average. However, hashing typically incurs additional memory overhead for link pointers and/or unused hash table buckets. In addition, hashing exhibits O (n 2 ) worst-case performance [5]. <p> proportional to O (log n) <ref> [5] </ref>. In contrast, chained hash table implementations locate a table entry in constant, i.e., O (1), time on the average. However, hashing typically incurs additional memory overhead for link pointers and/or unused hash table buckets. In addition, hashing exhibits O (n 2 ) worst-case performance [5]. A minimal perfect hash function is a static search set implementation defined by the following two properties: The perfect property: Locating a table entry requires O (1) time, i.e., at most one string comparison is required to perform keyword recognition within the static search set. <p> The minimal property: The memory allocated to store the keywords is precisely large enough for the keyword set and no larger. Minimal perfect hash functions provide a theoretically optimal time and space efficient solution for static search sets <ref> [5] </ref>. However, they can be hard to generate efficiently due to the extremely large search space of potential perfect hashing functions. <p> This format style is useful for building keyword set recognizers that possess no associated attributes. For example, a perfect hash function for frequently occurring English words can efficiently filter out uninformative words, such as the, as, and this, from consideration in a key-word-in-context indexing application <ref> [5] </ref>. Again, as with lex and yacc, all text in the optional third auxiliary code section is included verbatim into the generated output file, starting immediately after the final %% and extending to the end of the keyfile. <p> 1" option. - const struct months *rw; switch (key) - case 0: rw = &wordlist [0]; break; case 1: rw = &wordlist [1]; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist <ref> [5] </ref>; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist [11]; break; default: return 0; - if (*str == <p> This class has been incorporated into the GNU libg++ stream library [19] and the ACE network programming tookit [17]. ACE Hash Table: This class provides a search set implemented via double hashing <ref> [5] </ref>. During program initialization gperf uses an instance of this class to detect keyfile entries that are guaranteed to produce duplicate hash values. These duplicates occur whenever keywords possess both identical keysigs and identical lengths, e.g., the double and delete collision described in Section 4.1.2.
Reference: [6] <author> C. R. Cook and R. R. Oldehoeft, </author> <title> A Letter Oriented Minimal Perfect Hashing Function, </title> <journal> SIGPLAN Notices, </journal> <volume> vol. 17, </volume> <pages> pp. 18 27, </pages> <month> Sept. </month> <year> 1982. </year>
Reference-contexts: There are two reasons for generating non-minimal hash functions: 1. Generation efficiency It is usually much faster to generate non-minimal perfect functions than to generate mini mal perfect hash functions <ref> [6, 7] </ref>. 2. Run-time efficiency Non-minimal perfect hash functions may also execute faster than minimal ones when searching for elements that are not in the table because the null entry will be located more frequently. This situation often occurs when recognizing programming language reserved words in a compiler [8]. <p> In the Figure 1 example, this auxiliary code provides a test driver that is conditionally included if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Strate gies Many articles describe perfect hashing [10, 7, 11, 12] and minimal perfect hashing algorithms <ref> [8, 13, 6, 14, 15] </ref>. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail. This section describes the data structures, algorithms, output format, and reusable components in gperf. gperf is written in 4,000 lines of C++ source code. <p> After experimenting with gperf on many keyfiles it appears that such worst-case behavior occurs infrequently in practice. Many perfect hash function generation algorithms <ref> [6, 7] </ref> are sensitive to the order in which keywords are considered. To mitigate the effect of ordering, gperf will optionally reorder keywords in the Key List if the "-o" command-line option is enabled. <p> switch (key) - case 0: rw = &wordlist [0]; break; case 1: rw = &wordlist [1]; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist <ref> [6] </ref>; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist [11]; break; default: return 0; - if (*str == *rw-&gt;name && !strcmp (str + 1, rw-&gt;name <p> Since gperf is open source software, however, it is straightforward to add enhancements and extensions. 6.1 Tradeoffs and Compromises Several other hash function generation algorithms utilize some form of backtracking when searching for a perfect or minimal perfect solution <ref> [6, 8, 9] </ref>. For example, Cichelli's [8] algorithm recursively attempts to find an associated values configuration that uniquely maps all n keywords to distinct integers in the range 1::n.
Reference: [7] <author> A. Tharp and M. </author> <title> Brain, Using Tries to Eliminate Pattern Collisions in Perfect Hashing, </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> vol. 6, no. 2, </volume> <pages> pp. 329347, </pages> <year> 1994. </year>
Reference-contexts: There are two reasons for generating non-minimal hash functions: 1. Generation efficiency It is usually much faster to generate non-minimal perfect functions than to generate mini mal perfect hash functions <ref> [6, 7] </ref>. 2. Run-time efficiency Non-minimal perfect hash functions may also execute faster than minimal ones when searching for elements that are not in the table because the null entry will be located more frequently. This situation often occurs when recognizing programming language reserved words in a compiler [8]. <p> In the Figure 1 example, this auxiliary code provides a test driver that is conditionally included if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Strate gies Many articles describe perfect hashing <ref> [10, 7, 11, 12] </ref> and minimal perfect hashing algorithms [8, 13, 6, 14, 15]. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail. <p> After experimenting with gperf on many keyfiles it appears that such worst-case behavior occurs infrequently in practice. Many perfect hash function generation algorithms <ref> [6, 7] </ref> are sensitive to the order in which keywords are considered. To mitigate the effect of ordering, gperf will optionally reorder keywords in the Key List if the "-o" command-line option is enabled. <p> &wordlist [0]; break; case 1: rw = &wordlist [1]; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist <ref> [7] </ref>; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist [11]; break; default: return 0; - if (*str == *rw-&gt;name && !strcmp (str + 1, rw-&gt;name + 1)) return rw; return 0; - <p> One approach is to replace gperf's current algorithm with more exhaustive approaches <ref> [9, 7] </ref>. Due to gperf's object-oriented program design, such modifications will not disrupt the overall program structure. The perfect hash function generation mod 12 ule, class Gen Perf, is independent from other program components; it represents only about 10 percent of gperf's overall lines of source code.
Reference: [8] <author> R. J. Cichelli, </author> <title> Minimal Perfect Hash Functions Made Simple, </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 1, </volume> <pages> pp. 1719, </pages> <year> 1980. </year>
Reference-contexts: Run-time efficiency Non-minimal perfect hash functions may also execute faster than minimal ones when searching for elements that are not in the table because the null entry will be located more frequently. This situation often occurs when recognizing programming language reserved words in a compiler <ref> [8] </ref>. Near-perfect hash functions: Near-perfect hash functions do not possess the perfect property since they allow nonunique keyword hash values [9] (they may or may not possess the minimal property, however). <p> In the Figure 1 example, this auxiliary code provides a test driver that is conditionally included if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Strate gies Many articles describe perfect hashing [10, 7, 11, 12] and minimal perfect hashing algorithms <ref> [8, 13, 6, 14, 15] </ref>. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail. This section describes the data structures, algorithms, output format, and reusable components in gperf. gperf is written in 4,000 lines of C++ source code. <p> Keysigs are multisets since they may contain multiple occurrences of certain characters. This approach differs from other perfect hash function generation techniques <ref> [8] </ref> that only consider first/last characters + length when computing a keyword's hash value. The hash function generated by gperf properly handles keywords shorter than a specified index position by skipping characters that exceed the keyword's length. <p> Many perfect hash function generation algorithms [6, 7] are sensitive to the order in which keywords are considered. To mitigate the effect of ordering, gperf will optionally reorder keywords in the Key List if the "-o" command-line option is enabled. This reordering is done in a two-stage pre-pass <ref> [8] </ref> before gperf invokes the main algorithm shown in values are already determined appear earlier in the list. <p> The reason for this apparent anomaly is that collisions begin earlier and frequently persist throughout the remainder of keyword processing <ref> [8, 9] </ref>. 4.3 Generated Output Format keyfile depicted in Figure 1. Execution time was negligible on a Sun SPARC 20 workstation, i.e., 0.0 user and 0.0 system time. <p> &wordlist [1]; break; case 2: rw = &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist <ref> [8] </ref>; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist [11]; break; default: return 0; - if (*str == *rw-&gt;name && !strcmp (str + 1, rw-&gt;name + 1)) return rw; return 0; - Since the months example is somewhat contrived, <p> Since gperf is open source software, however, it is straightforward to add enhancements and extensions. 6.1 Tradeoffs and Compromises Several other hash function generation algorithms utilize some form of backtracking when searching for a perfect or minimal perfect solution <ref> [6, 8, 9] </ref>. For example, Cichelli's [8] algorithm recursively attempts to find an associated values configuration that uniquely maps all n keywords to distinct integers in the range 1::n. <p> Since gperf is open source software, however, it is straightforward to add enhancements and extensions. 6.1 Tradeoffs and Compromises Several other hash function generation algorithms utilize some form of backtracking when searching for a perfect or minimal perfect solution [6, 8, 9]. For example, Cichelli's <ref> [8] </ref> algorithm recursively attempts to find an associated values configuration that uniquely maps all n keywords to distinct integers in the range 1::n. In his scheme, the algorithm backs up if computing the current keyword's hash value exceeds the minimal perfect table size constraint at any point during program execution.
Reference: [9] <author> M. Brain and A. Tharp, </author> <title> Near-perfect Hashing of Large Word Sets, </title> <journal> Software Practice and Experience, </journal> <volume> vol. 19, no. 10, </volume> <pages> pp. 967978, </pages> <year> 1989. </year>
Reference-contexts: This situation often occurs when recognizing programming language reserved words in a compiler [8]. Near-perfect hash functions: Near-perfect hash functions do not possess the perfect property since they allow nonunique keyword hash values <ref> [9] </ref> (they may or may not possess the minimal property, however). <p> The reason for this apparent anomaly is that collisions begin earlier and frequently persist throughout the remainder of keyword processing <ref> [8, 9] </ref>. 4.3 Generated Output Format keyfile depicted in Figure 1. Execution time was negligible on a Sun SPARC 20 workstation, i.e., 0.0 user and 0.0 system time. <p> &wordlist [2]; break; case 3: rw = &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist <ref> [9] </ref>; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist [11]; break; default: return 0; - if (*str == *rw-&gt;name && !strcmp (str + 1, rw-&gt;name + 1)) return rw; return 0; - Since the months example is somewhat contrived, the trade off between the array and <p> Since gperf is open source software, however, it is straightforward to add enhancements and extensions. 6.1 Tradeoffs and Compromises Several other hash function generation algorithms utilize some form of backtracking when searching for a perfect or minimal perfect solution <ref> [6, 8, 9] </ref>. For example, Cichelli's [8] algorithm recursively attempts to find an associated values configuration that uniquely maps all n keywords to distinct integers in the range 1::n. <p> One approach is to replace gperf's current algorithm with more exhaustive approaches <ref> [9, 7] </ref>. Due to gperf's object-oriented program design, such modifications will not disrupt the overall program structure. The perfect hash function generation mod 12 ule, class Gen Perf, is independent from other program components; it represents only about 10 percent of gperf's overall lines of source code.
Reference: [10] <author> R. Sprugnoli, </author> <title> Perfect hashing functions: A single probe retrieving method for static sets, </title> <journal> Communications of the ACM, </journal> <pages> pp. 841850, </pages> <month> Nov. </month> <year> 1977. </year>
Reference-contexts: In the Figure 1 example, this auxiliary code provides a test driver that is conditionally included if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Strate gies Many articles describe perfect hashing <ref> [10, 7, 11, 12] </ref> and minimal perfect hashing algorithms [8, 13, 6, 14, 15]. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail. <p> &wordlist [3]; break; case 4: rw = &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist <ref> [10] </ref>; break; case 11: rw = &wordlist [11]; break; default: return 0; - if (*str == *rw-&gt;name && !strcmp (str + 1, rw-&gt;name + 1)) return rw; return 0; - Since the months example is somewhat contrived, the trade off between the array and switch approach is not particularly obvious.
Reference: [11] <author> G. V. Cormack, R. Horspool, and M. Kaiserwerth, </author> <title> Practical Perfect Hashing, </title> <journal> Computer Journal, </journal> <volume> vol. 28, </volume> <pages> pp. 5458, </pages> <month> Jan. </month> <year> 1985. </year>
Reference-contexts: In the Figure 1 example, this auxiliary code provides a test driver that is conditionally included if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Strate gies Many articles describe perfect hashing <ref> [10, 7, 11, 12] </ref> and minimal perfect hashing algorithms [8, 13, 6, 14, 15]. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail. <p> &wordlist [4]; break; case 5: rw = &wordlist [5]; break; case 6: rw = &wordlist [6]; break; case 7: rw = &wordlist [7]; break; case 8: rw = &wordlist [8]; break; case 9: rw = &wordlist [9]; break; case 10: rw = &wordlist [10]; break; case 11: rw = &wordlist <ref> [11] </ref>; break; default: return 0; - if (*str == *rw-&gt;name && !strcmp (str + 1, rw-&gt;name + 1)) return rw; return 0; - Since the months example is somewhat contrived, the trade off between the array and switch approach is not particularly obvious.
Reference: [12] <author> M. Dietzfelbinger, A. Karlin, K. Mehlhorn, F. M. auf der Heid, H. Rohnert, and R. Tarjan, </author> <title> Dynamic Perfect Hashing: Upper and Lower Bounds, </title> <journal> SIAM Journal of Computing, </journal> <volume> vol. 23, </volume> <pages> pp. 738761, </pages> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: In the Figure 1 example, this auxiliary code provides a test driver that is conditionally included if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Strate gies Many articles describe perfect hashing <ref> [10, 7, 11, 12] </ref> and minimal perfect hashing algorithms [8, 13, 6, 14, 15]. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail.
Reference: [13] <author> G. Jaeschke, </author> <title> Reciprocal Hashing: A Method for Generating Minimal Perfect Hashing Functions, </title> <journal> Communications of the ACM, </journal> <volume> vol. 24, </volume> <pages> pp. 829833, </pages> <month> Dec. </month> <year> 1981. </year>
Reference-contexts: In the Figure 1 example, this auxiliary code provides a test driver that is conditionally included if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Strate gies Many articles describe perfect hashing [10, 7, 11, 12] and minimal perfect hashing algorithms <ref> [8, 13, 6, 14, 15] </ref>. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail. This section describes the data structures, algorithms, output format, and reusable components in gperf. gperf is written in 4,000 lines of C++ source code.
Reference: [14] <author> T. Sager, </author> <title> A Polynomial Time Generator for Minimal Perfect Hash Functions, </title> <journal> Communications of the ACM, </journal> <volume> vol. 28, </volume> <pages> pp. 523532, </pages> <month> Dec. </month> <year> 1985. </year>
Reference-contexts: In the Figure 1 example, this auxiliary code provides a test driver that is conditionally included if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Strate gies Many articles describe perfect hashing [10, 7, 11, 12] and minimal perfect hashing algorithms <ref> [8, 13, 6, 14, 15] </ref>. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail. This section describes the data structures, algorithms, output format, and reusable components in gperf. gperf is written in 4,000 lines of C++ source code.
Reference: [15] <author> C. C. Chang, </author> <title> A Scheme for Constructing Ordered Minimal Perfect Hashing Functions, </title> <journal> Information Sciences, </journal> <volume> vol. 39, </volume> <pages> pp. 187195, </pages> <year> 1986. </year>
Reference-contexts: In the Figure 1 example, this auxiliary code provides a test driver that is conditionally included if the DEBUG symbol is enabled when compiling the generated C or C++ code. 4 Design and Implementation Strate gies Many articles describe perfect hashing [10, 7, 11, 12] and minimal perfect hashing algorithms <ref> [8, 13, 6, 14, 15] </ref>. Few articles, however, describe the design and implementation of a general-purpose perfect hashing generator tool in detail. This section describes the data structures, algorithms, output format, and reusable components in gperf. gperf is written in 4,000 lines of C++ source code.
Reference: [16] <author> Bjarne Stroustrup, </author> <title> The C++ Programming Language, </title> <address> 3 rd Edi--tion. </address> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: This section describes the data structures, algorithms, output format, and reusable components in gperf. gperf is written in 4,000 lines of C++ source code. C++ was chosen as the implementation language since it supports data abstraction better than C, while maintaining C's efficiency and expressiveness <ref> [16] </ref>. gperf's three main phases for generating a perfect or near-perfect hash function are shown in Figure 2 and described below: january february ... december KEYFILE Asso_Values Key_List GPERF int hash (const char *str, unsigned int len) - C/C++ CODE 1.
Reference: [17] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: the str's first letter does not match any of the keywords in the lookup table. 4.4 Reusable Components and Patterns software architecture. gperf is constructed from reusable KEY LIST GGENEN PPERFERF AASSOSSO VVALUESALUES SSINGLETONINGLETON RREADEAD BBUFFERUFFER HHASHASH TTABLEABLE BBOOLOOL AARRAYRRAY GPERF COMPONENTS ACEACE COMPONENTSCOMPONENTS 8 components from the ACE framework <ref> [17] </ref>. Each compo-nent evolved bottom-up from special-purpose utilities into reusable software components. Several noteworthy reusable classes include the following components: ACE Bool Array: Earlier versions of gperf were instrumented with a run-time code profiler on large input key-files that evoke many collisions. <p> This class has been incorporated into the GNU libg++ stream library [19] and the ACE network programming tookit <ref> [17] </ref>. ACE Hash Table: This class provides a search set implemented via double hashing [5]. During program initialization gperf uses an instance of this class to detect keyfile entries that are guaranteed to produce duplicate hash values.
Reference: [18] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: This template automatically transforms a class into a Singleton using the Singleton and Adapter patterns <ref> [18] </ref>. The in set method efficiently detects duplicate keyword hash values for a given associated values configuration. It returns non-zero if a value is already in the set and zero other wise.
Reference: [19] <author> D. Lea, libg++, </author> <title> the GNU C++ Library, </title> <booktitle> in Proceedings of the 1 st C++ Conference, </booktitle> <address> (Denver, </address> <publisher> CO), </publisher> <pages> pp. 243256, </pages> <publisher> USENIX, </publisher> <month> Oct. </month> <year> 1988. </year>
Reference-contexts: A recursive auxiliary function, Read Buffer::rec read, ensures only one call is made to the new opeator for each input line read, i.e., there is no need to reallocate and resize buffers dynamically. This class has been incorporated into the GNU libg++ stream library <ref> [19] </ref> and the ACE network programming tookit [17]. ACE Hash Table: This class provides a search set implemented via double hashing [5]. During program initialization gperf uses an instance of this class to detect keyfile entries that are guaranteed to produce duplicate hash values. <p> The table's load factor is 0.39, the same as it is in cfront 3.0. patricia.exe: a PATRICIA trie recognizer, where PATRICIA stands for Practical Algorithm to Retrieve Information Coded in Alphanumeric. A complete PATRICA trie implementation is available in the GNU libg++ class library distribution <ref> [19] </ref>. binary.exe: a carefully coded binary search function that minimizes the number of complete string comparisons. comp-flex.exe: a flex-generated recognizer created with the default "-cem" options, providing the highest degree 10 Executable Input File Program ET++.in NIH.in g++.in idraw.in cfront.in libg++.in control.exe 38.8 j 1.00 15.4 j 1.00 15.2 j 1.00
Reference: [20] <author> J. Kegler, </author> <title> A Polynomial Time Generator for Minimal Perfect Hash Functions, </title> <journal> Communications of the ACM, </journal> <volume> vol. 29, no. 6, </volume> <pages> pp. 556557, </pages> <year> 1986. </year>
Reference-contexts: However, they are not necessarily advantageous for production applications unless the resulting executable code speed is competitive with typical alternative implementations. In fact, it has been argued that there are no circumstances where perfect hashing proves worthwhile, compared with other common static search set methods <ref> [20] </ref>. To compare the efficacy of the gperf-generated perfect hash functions against other common static search set implementations, seven test programs were developed and executed on six large input files. Each test program implemented the same function: a recognizer for the reserved words in GNU g++ .
Reference: [21] <author> A. Gokhale and D. C. Schmidt, </author> <title> Evaluating the Performance of Demultiplexing Strategies for Real-time CORBA, </title> <booktitle> in Proceedings of GLOBECOM '97, </booktitle> <address> (Phoenix, AZ), </address> <publisher> IEEE, </publisher> <month> November </month> <year> 1997. </year>
Reference-contexts: The various features described in this paper enable it to achieve its goal, as evidenced by its use in the GNU compilers. In addition, gperf has been used in the following applications: * The TAO CORBA IDL compiler [4] uses gperf to generate the operation dispatching tables <ref> [21] </ref> used by server side skeletons. * A hash function for 15,400 Medical Subject Headings used to index journal article citations in MEDLINE, a large bibliographic database of the biomedical literature maintained by the National Library of Medicine.
References-found: 21

