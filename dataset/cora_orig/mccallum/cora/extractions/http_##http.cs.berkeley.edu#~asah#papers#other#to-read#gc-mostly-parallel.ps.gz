URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/gc-mostly-parallel.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/to-read/
Root-URL: http://www.cs.berkeley.edu
Title: Mostly Parallel Garbage Collection  
Author: Hans-J. Boehm Alan J. Demers Scott Shenker 
Affiliation: Xerox PARC  
Abstract: We present a method for adapting garbage collectors designed to run sequentially with the client, so that they may run concurrently with it. We rely on virtual memory hardware to provide information about pages that have been updated or ``dirtied'' during a given period of time. This method has been used to construct a mostly parallel trace-and-sweep collector that exhibits very short pause times. Performance measurements are given. 
Abstract-found: 1
Intro-found: 1
Reference: [AppelEllisLi 88] <author> Appel, Andrew, John R. Ellis, and Kai Li, </author> <title> ``Real-time Concurrent Collection on Stock Multiprocessors'', </title> <booktitle> Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, SIGPLAN Notices 23, </booktitle> <volume> 7 (July 88), </volume> <pages> pp. 11-20. </pages>
Reference-contexts: Unlike our work, these algorithms rely heavily on mutator cooperation. Pointer updates, and in most cases read accesses, require the mutator to update collector data structures. These algorithms are practical on conventional hardware only under unusual circumstances. Baker's algorithm requires reliable pointer identification. Appel et al. <ref> [AppelEllisLi 88] </ref> present a parallel copying collector intended to run on conventional machines. Their scheme, like ours, takes advantage of virtual memory hardware. <p> Very recently, DeTreville [DeTreville 90] described a parallel trace-and-sweep collector which, like ours, uses virtual memory hardware instead of explicit mutator cooperation. His collector requires that slightly less work be performed while the mutator is stopped but, like the <ref> [AppelEllisLi 88] </ref> collector and unlike ours, it requires that the collector be notified on initial read accesses by the mutator. Furthermore, a single page may be protected and faulted more than once. <p> Mostly Parallel Copying Collectors It is possible to apply the same approach to obtain a mostly parallel copying collector. Unlike the <ref> [AppelEllisLi 88] </ref> collector, this approach requires only dirty bit information. Unfortunately, it also appears to require additional space to maintain explicit forwarding links. We assume that every object has an additional field called forward, which is set and examined only by the garbage collector. <p> The mutator continues to see only from-space objects. (In the <ref> [AppelEllisLi 88] </ref> collector, the mutator sees only to-space objects.) This concurrent collection process establishes the condition that if an object residing on a clean page has been copied, then every object it points to has also been copied. <p> We have not built such a collector, since it is not practical in our environment. An empirical performance comparison with the <ref> [AppelEllisLi 88] </ref> collector would be interesting. Our alternative is most likely to be attractive if the operating system provides inexpensive dirty bit access, but relatively expensive trap handling. Acknowledgements Bob Hagmann and Barry Hayes suggested some of the alternatives described in section 5.
Reference: [AppelLi 91] <author> Appel, Andrew W., and Kai Li, </author> <title> ``Virtual Memory Primitives for User Programs'', </title> <booktitle> Proceedings of the Fourth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <year> 1991. </year>
Reference-contexts: Comparable performance measurements would be useful, but difficult to obtain; they report few quantitative measurements, and those are on completely different hardware, with completely different mutators. An overview of various proposed uses of virtual memory primitives by user programs is given in <ref> [AppelLi 91] </ref>. 3. Sweeping Doesn't Matter The following discussion will center on the mark phase of the mark-sweep collector, that is on the process of tracing through and identifying reachable objects. The sweep phase does not have a significant impact on garbage collector pause times.
Reference: [Bartlett 89] <author> Bartlett, Joel F., </author> <title> ``Mostly-Copying Garbage Collection Picks Up Generations and C++'', </title> <note> DEC WRL Technical Note TN-12, </note> <month> October </month> <year> 1989. </year>
Reference-contexts: In the next section we formalize our mostly parallel technique for this case. There are a number of related collection algorithms that rely on copying live data and thus assume reliable pointer identification. These can generally be made to tolerate some uncertain pointer identifications using the technique of <ref> [Bartlett 89] </ref>. However, this can only accommodate a small number of uncertain pointers. It usually performs acceptably only if the uncertainty is limited to pointers in registers and on the stacks. Even then it may occasionally be problematic [DeTreville 90].
Reference: [BoehmWeiser 88] <author> Boehm, Hans-J. and Mark Weiser, </author> <title> ``Garbage Collection in an Uncooperative Environment'', </title> <journal> Software Practice & Experience 18, </journal> <month> 9 (Sept. </month> <year> 1988), </year> <pages> pp. 807-820. </pages>
Reference-contexts: Our second goal was to describe a particular implementation of a garbage collector that illustrates this idea. Combining the notion of mostly parallel tracing collection with our previous work on conservative <ref> [BoehmWeiser 88] </ref> and generational [DemersEtAl 90] collection, we have built a conservative, generational, mostly parallel collector. This collector is able to provide sophisticated garbage collection services to rather primitive languages like C which provide no pointer information. <p> Even then it may occasionally be problematic [DeTreville 90]. In our environment, every pointer identification is uncertain, including those from the heap, and this approach is not usable. The advantages of being able to accommodate uncertainty in pointer identification are described in <ref> [BoehmWeiser 88] </ref> and [DemersEtAl 90]. An analysis of the limitations of the technique under very adverse circumstances is given in [Wentworth 90]. [Zorn 90] demonstrates that noncopying trace-and-sweep collectors may, at times, outperform copying collectors (though the details of his trace-and-sweep collector are quite different from ours).
Reference: [Cheney 70] <author> Cheney, C., J., </author> <title> ``A Nonrecursive List Compacting Algorithm'', </title> <journal> Communications of the ACM 13, </journal> <month> 11 (November </month> <year> 1970), </year> <pages> pp. 677-678. </pages>
Reference-contexts: Unfortunately, it also appears to require additional space to maintain explicit forwarding links. We assume that every object has an additional field called forward, which is set and examined only by the garbage collector. The underlying collection algorithm can be either traditional breadth-first copying (cf. <ref> [Cheney 70] </ref>) or one that attempts to preserve better locality of reference (cf. [Moon 84]). The copying collector is invoked concurrently with the mutator. As usual, the collector copies all reachable objects residing in from-space to a previously unused region of memory referred to as to-space.
Reference: [CurtisRauen 90] <author> Curtis, P. and J. Rauen. </author> <title> A Module System for Scheme. </title> <booktitle> Proceedings of the 1990 ACM Conference on LISP and Functional Programming, </booktitle> <month> June </month> <year> 1990, </year> <pages> pp. 13-19. </pages>
Reference-contexts: Thus we resorted to running toy programs. But, since we are interested in the performance of the collector in a large single address space system, these toy programs are run in the same address space with the Cedar window system, the Tioga editor, a mailer, the SchemeXerox system <ref> [CurtisRauen 90] </ref>, and a typical complement of miscellaneous smaller tools. These summed to roughly 70,000 objects, between 9.5 and 10 megabytes of pointer-free allocated objects and between 2.5 and 3 megabytes of pointer-containing allocated objects, in a 20 megabyte heap.
Reference: [DemersEtAl 90] <author> Demers. A., M. Weiser, B. Hayes, H. Boehm, D. Bobrow, S. Shenker, </author> <title> ``Combining Generational and Conservative Garbage Collection: Framework and Implementations'', </title> <booktitle> Proceedings of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1990, </year> <pages> pp. 261-269. </pages>
Reference-contexts: Our second goal was to describe a particular implementation of a garbage collector that illustrates this idea. Combining the notion of mostly parallel tracing collection with our previous work on conservative [BoehmWeiser 88] and generational <ref> [DemersEtAl 90] </ref> collection, we have built a conservative, generational, mostly parallel collector. This collector is able to provide sophisticated garbage collection services to rather primitive languages like C which provide no pointer information. Collection pauses on a SparcStation II with 15 Megabytes of accessible objects are usually not noticeable. <p> Even then it may occasionally be problematic [DeTreville 90]. In our environment, every pointer identification is uncertain, including those from the heap, and this approach is not usable. The advantages of being able to accommodate uncertainty in pointer identification are described in [BoehmWeiser 88] and <ref> [DemersEtAl 90] </ref>. An analysis of the limitations of the technique under very adverse circumstances is given in [Wentworth 90]. [Zorn 90] demonstrates that noncopying trace-and-sweep collectors may, at times, outperform copying collectors (though the details of his trace-and-sweep collector are quite different from ours). <p> Since their algorithm also copies list structures breadth-first, and thus does not preserve locality in list structures, this may result in a flurry of such intervention at the beginning of a collection. <ref> [DemersEtAl 90] </ref> also describes a parallel collection algorithm based on virtual checkpoints implemented with a copy-on-write strategy. The algorithm described here does not incur the copying overhead, is typically easier to implement, and requires no additional memory. <p> For the next three sections, we will view garbage collection as the process of marking reachable objects. 4. Formal Statement In a previous paper <ref> [DemersEtAl 90] </ref> we formalized the notion of a partial collection, i.e. a collection that reclaims only a subset of all unreachable objects. We will not review that material here, except to note that these partial collections are characterized by the set T of threatened, i.e., potentially collectible, objects. <p> The previous discussion focused on a general notion of partial collection. We now turn to defining a particular generational version of a partial collection, which makes use of the mark bits for object age information. This collector is related to Collector I in <ref> [DemersEtAl 90] </ref>. Consider a partial collection where the set I is chosen to be the set of currently marked objects. Then, we know that condition C'' already holds and that steps 1-3 are unnecessary. <p> Since full collections are usually not disastrous, this problem can be tolerated. However, we are exploring modifications to the generational collection scheme similar to those in <ref> [DemersEtAl 90] </ref> that would improve this behavior without adding significantly to the required bookkeeping overhead. 7. Mostly Parallel Copying Collectors It is possible to apply the same approach to obtain a mostly parallel copying collector. Unlike the [AppelEllisLi 88] collector, this approach requires only dirty bit information.
Reference: [DeTreville 90] <author> DeTreville, John, </author> <title> ``Experience with Concurrent Garbage Collectors for Modula-2+'', </title> <institution> Digital Equipment Corporation, Systems Research Center, </institution> <note> Report No. 64. </note>
Reference-contexts: However, this can only accommodate a small number of uncertain pointers. It usually performs acceptably only if the uncertainty is limited to pointers in registers and on the stacks. Even then it may occasionally be problematic <ref> [DeTreville 90] </ref>. In our environment, every pointer identification is uncertain, including those from the heap, and this approach is not usable. The advantages of being able to accommodate uncertainty in pointer identification are described in [BoehmWeiser 88] and [DemersEtAl 90]. <p> The algorithm described here does not incur the copying overhead, is typically easier to implement, and requires no additional memory. Very recently, DeTreville <ref> [DeTreville 90] </ref> described a parallel trace-and-sweep collector which, like ours, uses virtual memory hardware instead of explicit mutator cooperation.
Reference: [DikstraEtAl 78] <author> Dijkstra, E. W., L. Lamport, A. Martin, C. Scholten, and E. Steffens, </author> <title> ``On-the-Fly Garbage Collection: An Exercise in Cooperation'', </title> <journal> Communications of the ACM 21, </journal> <volume> 11 (November 78), </volume> <pages> pp. 966-975. </pages>
Reference: [Gabriel 85] <author> Gabriel, Richard P., </author> <title> Performance and Evaluation of Lisp Systems, </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Overall, this probably also increased its running time relative to the other two, but decreased pause times. The two programs we consider here are five iterations of the Boyer benchmark, as compiled by SchemeXerox, and a simple allocator loop, written in C. The former is described in <ref> [Gabriel 85] </ref>, and is often (ab)used as a garbage collector benchmark. The version of the SchemeXerox compiler we used was rather preliminary. Thus the absolute execution times are considerably longer than they should be. One cause for this is that cons-cells are 16 bytes long.
Reference: [Moon 84] <author> Moon, D., </author> <title> ``Garbage Collection in Large Lisp Systems'', </title> <booktitle> Proceedings of the 1984 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pp. 235-246. </pages>
Reference-contexts: We assume that every object has an additional field called forward, which is set and examined only by the garbage collector. The underlying collection algorithm can be either traditional breadth-first copying (cf. [Cheney 70]) or one that attempts to preserve better locality of reference (cf. <ref> [Moon 84] </ref>). The copying collector is invoked concurrently with the mutator. As usual, the collector copies all reachable objects residing in from-space to a previously unused region of memory referred to as to-space. Links in to-space are updated to reflect the new locations of the objects.
Reference: [Rovner 84] <author> Rovner, Paul, </author> <title> ``On Adding Garbage Collection and Runtime Types to a Strongly-Typed, Statically Checked, Concurrent Language'', </title> <type> Report CSL-84-7, </type> <institution> Xerox Palo Alto Research Center. </institution>
Reference: [Steele 75] <author> Steele, Guy L., </author> <title> ``Multiprocessing Compactifying Garbage Collection'', </title> <journal> Communications of the ACM 18, </journal> <volume> 9 (September 75), </volume> <pages> pp. 495-508. </pages>
Reference-contexts: An analysis of the limitations of the technique under very adverse circumstances is given in [Wentworth 90]. [Zorn 90] demonstrates that noncopying trace-and-sweep collectors may, at times, outperform copying collectors (though the details of his trace-and-sweep collector are quite different from ours). Parallel noncopying collectors are described by Steele <ref> [Steele 75] </ref> and Dikstra et al. [DijkstraEtAl 78], among others. [Baker 78] presents a copying collection algorithm that is explicitly interleaved with mutator operations. Unlike our work, these algorithms rely heavily on mutator cooperation. Pointer updates, and in most cases read accesses, require the mutator to update collector data structures.
Reference: [Ungar 84] <author> Ungar, David, </author> <title> ``Generation Scavenging: a non-disruptive high performance storage reclamation algorithm'', </title> <booktitle> Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, SIGPLAN Notices 19, 5 (1984), </booktitle> <pages> pp. 157-167. </pages>
Reference-contexts: Appeared in Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation SIGPLAN Notices 26, 6, pp. 157-164. Generational garbage collectors concentrate on reclaiming recently allocated objects. Generational collectors have been implemented in a wide variety of systems and have achieved significantly reduced pause times <ref> [Ungar 84] </ref>. However, a generational collector still needs to run full collections occasionally in order to reclaim older objects. Thus, the problem of long pauses is not completely eliminated. Parallel collectors take an orthogonal approach to the problem of reducing collection pause time.
Reference: [Weiser 89] <author> Weiser, M., A. Demers, and C. Hauser, </author> <title> ``The Portable Common Runtime Approach to Interoperability'', </title> <booktitle> Proceedings of the 13th ACM Symposium on Operating System Principles (December 1989). </booktitle>
Reference-contexts: It is unknown whether this is a good choice. 6. Empirical results The mostly parallel generational collector described in the previous section has been in routine use on SPARCStations, as part of the Xerox Portable Common Runtime (PCR) and PCedar <ref> [Weiser 89] </ref>, for several months. This paper was edited on a system that uses it. The collector marking code has been quite heavily tuned and optimized. However, the same is not true for some other pieces of code run for our measurements. <p> (exclusive of collection) could have been reduced by about 50% by running a streamlined, less general, assembly coded allocator. (It could have been reduced still further if we were operating in a world in which there is no concurrency aside from the collector.) We used the PCR preemptive thread-scheduling facility <ref> [Weiser 89] </ref> to allow the collector to run concurrently with the mutator. All measurements were performed such that all threads were run by a single UNIX process. A page fault thus stopped all threads.
Reference: [Wentworth 90] <author> Wentworth, E. P., </author> <title> ``Pitfalls of Conservative Garbage Collection'', </title> <journal> Software Practice & Experience 20, </journal> <note> 7 (July 1990) pp. 719-727. </note>
Reference-contexts: The advantages of being able to accommodate uncertainty in pointer identification are described in [BoehmWeiser 88] and [DemersEtAl 90]. An analysis of the limitations of the technique under very adverse circumstances is given in <ref> [Wentworth 90] </ref>. [Zorn 90] demonstrates that noncopying trace-and-sweep collectors may, at times, outperform copying collectors (though the details of his trace-and-sweep collector are quite different from ours).
Reference: [Zorn 90] <author> Zorn, Benjamin, </author> <title> ``Comparing Mark-and-Sweep and Stop-and-Copy Garbage Collection'', </title> <booktitle> Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <month> June </month> <year> 1990, </year> <pages> pp. 87-98. </pages>
Reference-contexts: The advantages of being able to accommodate uncertainty in pointer identification are described in [BoehmWeiser 88] and [DemersEtAl 90]. An analysis of the limitations of the technique under very adverse circumstances is given in [Wentworth 90]. <ref> [Zorn 90] </ref> demonstrates that noncopying trace-and-sweep collectors may, at times, outperform copying collectors (though the details of his trace-and-sweep collector are quite different from ours).
References-found: 17

