URL: ftp://ftp.cs.cmu.edu/user/mootaz/papers/ftcs-92.ps
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs.cmu.edu/user/mootaz/ftp/html/pub.html
Root-URL: 
Title: Replicated Distributed Processes in Manetho  
Author: Elmootazbellah N. Elnozahy Willy Zwaenepoel 
Address: Houston, Texas  
Affiliation: Department of Computer Science Rice University  
Abstract: This paper presents the process-replication protocol of Manetho, a system whose goal is to provide efficient, application-transparent fault tolerance to long-running distributed computations. Manetho uses a new negative-acknowledgment multicast protocol to enforce the same receipt order of application messages among all replicas of a process. The protocol depends on a combination of antecedence graph maintenance, a form of sender-based message logging, and the fact that the receivers of each multicast execute the same deterministic program. This combination allows our protocol to avoid the delay in application message delivery that is common in existing negative-acknowledgment multicast protocols, without giving up the advantage of requiring only a small number of control messages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. Ahamad, P. Dasgupta, and R.J. LeBlanc. </author> <title> Fault-tolerant atomic computations in an object-based distributed system. </title> <journal> Distributed Computing, </journal> <volume> 4 </volume> <pages> 69-80, </pages> <year> 1990. </year>
Reference-contexts: Committing this transaction requires at least r additional multi-casts. In contrast, Manetho provides ordered multicast delivery with only one overhead multicast per application-multicast. The protocol of Ahamad et al. <ref> [1] </ref> uses transactions to structure the replicas. At commit time, only one replica succeeds while the remaining cohorts abort. This allows non-deterministic execution in each replica, but the application must be structured as a sequence of transactions. In contrast, Manetho adds replication to deterministic processes in an application-transparent manner.
Reference: [2] <author> P.A. Barrett, A.M. Hilborne, P. Verissimo, L. Rodrigues, P.G. Bond, D.T. Seaton, and N.A. Speirs. </author> <title> The Delta-4 extra performance architecture XPA. </title> <booktitle> In Proceedings of the 20th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 481-488, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: In contrast, Manetho adds replication to deterministic processes in an application-transparent manner. The idea of having a sequencer define the receipt order of a multicast was used in the multicast protocol of Chang and Maxemchuck [7], the Amoeba atomic broadcast protocol [16], and the Delta-4 XPA system <ref> [2] </ref>. The r-resilient protocol of Chang and Maxemchuck relies on negative-acknowledgment and leadership transfer to achieve reliable total ordering. However, a multicast must be delayed for r 1 leadership transfers before it can be delivered.
Reference: [3] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: Realizing that satisfying the agreement and order conditions is expensive, some researchers have introduced efficient multicast protocols that provide weaker ordering. An example is ISIS's CBCAST protocol which provides causal ordering <ref> [3] </ref>. However, CBCAST does not enforce identical receipt orders for two multicasts sent from two sources that are not causally related [21]. Another example is the Psync multicast protocol based on the context order [19]. <p> Delta-4 XPA relies on a special network adapter to provide the ordering and reliability, and to mask the overhead of acknowledgment messages from the application program. In contrast, Manetho does not depend on special network support. Both Manetho and the new implementation of ISIS's ABCAST <ref> [3] </ref> rely on a single site to define the multicast's receipt order. ABCAST relies on an underlying transport protocol that guarantees that messages are reliably delivered in FIFO order. This transport protocol is a major source of overhead in ISIS [3]. <p> Both Manetho and the new implementation of ISIS's ABCAST <ref> [3] </ref> rely on a single site to define the multicast's receipt order. ABCAST relies on an underlying transport protocol that guarantees that messages are reliably delivered in FIFO order. This transport protocol is a major source of overhead in ISIS [3]. In contrast, Manetho adopts weaker assumption about the network reliability. The context graph of the x -kernel's Psync protocol [19] is the basis of another general-purpose multicast protocol.
Reference: [4] <author> K.P. Birman. </author> <title> Replication and fault-tolerance in the ISIS system. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 79-86, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: In this paper, we concentrate on the process-replication aspects of Manetho; the rollback-recovery protocol has been published elsewhere [12]. In Manetho, process-replication follows the leader-cohort model <ref> [4, 7] </ref>.
Reference: [5] <author> K.P. Birman and T.A. Joseph. </author> <title> Reliable communication in the presence of failures. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(1) </volume> <pages> 47-76, </pages> <month> February </month> <year> 1987. </year>
Reference-contexts: Existing multicast protocols that satisfy the agreement and order conditions trade latency in delivery of multicast messages to the application program against the number of control messages. In positive-acknowledgment protocols, such as the original implementation of ABCAST of ISIS <ref> [5] </ref>, the receivers run an agreement protocol to determine the receipt order of each application-multicast. The multicast can be delivered as soon as its receipt order is agreed upon, at the expense of the overhead caused by the control messages that are used to reach agreement. <p> Manetho tolerates r 1 failures in each troupe, but it does not currently tolerate network partition. Manetho assumes that each troupe has access to a local group membership protocol that maintains a list of the members in the troupe <ref> [5, 9, 18] </ref>. The group membership protocol detects the changes in the troupe membership (due to failures and recoveries) and reliably notifies its members of such changes. The communication subsystem supports multicast addressing and unreliable multicast delivery.
Reference: [6] <author> K.M. Chandy and L. Lamport. </author> <title> Distributed snapshots: Determining global states of distributed systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 63-75, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: The recovering troupe executes up to its most recent "visible" state interval from before failure. This brings the troupe to a state consistent <ref> [6] </ref> with the other troupes in the system. 3 6.4 Protocol Description elected leader starts recovery by calling the procedure RECOVER with arguments p, S, INCNUM , AG and STATEINDEX . The recovering troupe's identifier is p. <p> Lemma 7 establishes the remaining safety property of the protocol: Theorem 1 Computation C is equivalent to some legal computation C 0 that starts from the same initial state. Proof Before any failure occurs in C, the state of the system is consistent <ref> [6] </ref>. After the failure of a troupe p, it recovers to a state consistent with the rest of the system, and no other troupe becomes inconsistent with the rest of the system because of p's failure, as shown by Lemma 7.
Reference: [7] <author> J. Chang and N.F. Maxemchuck. </author> <title> Reliable broadcast protocols. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 251-273, </pages> <month> August </month> <year> 1984. </year>
Reference-contexts: In this paper, we concentrate on the process-replication aspects of Manetho; the rollback-recovery protocol has been published elsewhere [12]. In Manetho, process-replication follows the leader-cohort model <ref> [4, 7] </ref>. <p> For example, the two-phase agreement protocol of this implementation of ABCAST requires r point-to-point messages and one overhead multicast to determine the receipt order of an application-multicast sent to r receivers. In contrast, negative-acknowledgment protocols <ref> [7, 17] </ref> attempt to reduce the number of control messages by piggybacking the ordering information on application-multicasts. <p> For example, the r-resilient protocol by Chang and Maxemchuck requires only one overhead message per application-multicast, but it cannot deliver a message to the application program until r 1 "token transfers" have occurred, each requiring one message <ref> [7] </ref>. Realizing that satisfying the agreement and order conditions is expensive, some researchers have introduced efficient multicast protocols that provide weaker ordering. An example is ISIS's CBCAST protocol which provides causal ordering [3]. <p> In contrast, Manetho adds replication to deterministic processes in an application-transparent manner. The idea of having a sequencer define the receipt order of a multicast was used in the multicast protocol of Chang and Maxemchuck <ref> [7] </ref>, the Amoeba atomic broadcast protocol [16], and the Delta-4 XPA system [2]. The r-resilient protocol of Chang and Maxemchuck relies on negative-acknowledgment and leadership transfer to achieve reliable total ordering. However, a multicast must be delayed for r 1 leadership transfers before it can be delivered.
Reference: [8] <author> E.C. Cooper. </author> <title> Replicated distributed programs. </title> <booktitle> In Proceedings of the 10th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 63-78, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: In this paper, we concentrate on the process-replication aspects of Manetho; the rollback-recovery protocol has been published elsewhere [12]. In Manetho, process-replication follows the leader-cohort model [4, 7]. Each application process is replicated by a troupe <ref> [8] </ref> that consists of a leader and r 1 cohorts, where each troupe member executes the same application fl This work was supported in part by NFS Grants CDA-8619893 and CCR-9116343, and by an IBM Graduate Fellowship. program. 1 Manetho assumes that the application process is deterministic in the sense that <p> The processes are deterministic and do not have real-time requirements. Each application process is replicated by a troupe <ref> [8] </ref> of r fail-stop [20] process replicas. Each replica has a distinct ordinal position within the troupe and executes the same application program. <p> We restrict the comparison to systems that operate in environments similar to the one assumed in this paper, namely, an unreliable asynchronous network and applications with no real-time requirements. CIRCUS was one of the earlier systems to support process-replication in an asynchronous network <ref> [8] </ref>. CIRCUS uses replicated remote procedure calls (RPCs) to implement inter-troupe communication. If no identical receipt order at each replica is required, a many-to-many RPC incurs between r + 1 to 2r multicasts.
Reference: [9] <author> F. Cristian. </author> <title> Agreeing on who is present and who is absent in a synchronous distributed system. </title> <booktitle> In Proceedings of the 18th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 206-211, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Manetho tolerates r 1 failures in each troupe, but it does not currently tolerate network partition. Manetho assumes that each troupe has access to a local group membership protocol that maintains a list of the members in the troupe <ref> [5, 9, 18] </ref>. The group membership protocol detects the changes in the troupe membership (due to failures and recoveries) and reliably notifies its members of such changes. The communication subsystem supports multicast addressing and unreliable multicast delivery.
Reference: [10] <author> F. Cristian, R. Aghili, R. Strong, and D. Dolev. </author> <title> Atomic broadcast: From simple message diffusion to byzantine agreement. </title> <booktitle> In Proceedings of the 15th International Symposium on Fault-Tolerant Computing, </booktitle> <month> June </month> <year> 1985. </year>
Reference-contexts: Section 8 compares our system with related work. Finally, Section 9 presents conclusions. 2 Why a New Multicast Protocol? To enforce consistency among troupe members in the absence of any information about the application program, the system requires a multicast protocol that satisfies the agreement and order conditions <ref> [10, 22] </ref>. The former condition requires that each troupe member receive the same set of messages, while the latter requires that each troupe member receive the messages in the same order.
Reference: [11] <author> E.N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> A low overhead rollback-recovery system with fast output commit. </title> <type> Technical Report TR91-152, </type> <institution> Rice University, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Nevertheless, an implementation of the antecedence graph shows that, by using incremental piggybacking, the cost of maintaining the graph is only a small fraction of the cost of receiving a message <ref> [11] </ref>. Furthermore, assuming that failures are rare, the recovery protocol will seldom have to be run. Acknowledgments We are indebted to J. Carter, A. Cox, K. Fletcher, P. Keleher, M. Mazina, H. Garcia-Molina, A. Schaffer, R. Schlichting, H.
Reference: [12] <author> E.N. Elnozahy and W. Zwaenepoel. Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback, and fast output commit. </title> <journal> IEEE Transactions on Computers Special Issue On Fault-Tolerant Computing, </journal> <volume> 41(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: 1 Introduction This paper presents the process-replication protocol of Manetho. The goal of the Manetho system is to provide efficient, application-transparent fault tolerance for long-running distributed applications <ref> [12] </ref>. The system uses a combination of process-replication and rollback-recovery: process-replication is used for server processes that are constrained by high availability requirements, and rollback-recovery is used for all other client processes. In this paper, we concentrate on the process-replication aspects of Manetho; the rollback-recovery protocol has been published elsewhere [12]. <p> <ref> [12] </ref>. The system uses a combination of process-replication and rollback-recovery: process-replication is used for server processes that are constrained by high availability requirements, and rollback-recovery is used for all other client processes. In this paper, we concentrate on the process-replication aspects of Manetho; the rollback-recovery protocol has been published elsewhere [12]. In Manetho, process-replication follows the leader-cohort model [4, 7]. <p> To maintain the consistency among the troupe members, it is sufficient that each of them receives the same application-multicasts in the same order. Manetho uses a new negative-acknowledgment, ordered-multicast protocol to implement inter-troupe multicasts. Manetho's multicast protocol depends on a combination of antecedence graph maintenance <ref> [12] </ref>, a form of sender-based message logging [14, 15], and the fact that a leader and its cohorts execute the same deterministic program. The graph at one troupe records the receipt order of application-multicasts in other troupes on which the local state of the troupe depends. <p> The notation m i denotes the i th application-multicast sent by troupe p. We will refer to this example throughout the paper. 4 Protocol Specification 4.1 The Antecedence Graph The directed, acyclic antecedence graph (AG) of a state interval p p i ), is defined recursively as follows <ref> [12] </ref>: i = 0: The graph consists of a node that represents p 0 with no incoming edges. <p> Provided that there is at least one surviving troupe member, the protocol elects a single leader and terminates [13]. If the initiator of the protocol fails, the protocol is restarted. 6.3 Phase Two: Troupe Recovery The recovery protocol is based on the following observation <ref> [12] </ref>: Define a state interval p i as visible outside of troupe p if the AG of the current state interval of some other troupe q contains a node that represents p Then, AG ( p i ) is a subgraph of the AG of the current and all subsequent state
Reference: [13] <author> H. Garcia-Molina. </author> <title> Elections in a distributed computing system. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 31(1) </volume> <pages> 48-59, </pages> <month> January </month> <year> 1982. </year>
Reference-contexts: The protocol is an adaptation of the invitation protocol <ref> [13] </ref> in which the winner of the election is the cohort that has the highest state interval index. * One cohort (or more) starts leader election by sending a recovery-multicast to the troupe. <p> The leader informs the cohorts of the new incarna tion number during synchronization. Provided that there is at least one surviving troupe member, the protocol elects a single leader and terminates <ref> [13] </ref>.
Reference: [14] <author> D.B. Johnson. </author> <title> Distributed System Fault Tolerance Using Message Logging and Checkpointing. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: Manetho uses a new negative-acknowledgment, ordered-multicast protocol to implement inter-troupe multicasts. Manetho's multicast protocol depends on a combination of antecedence graph maintenance [12], a form of sender-based message logging <ref> [14, 15] </ref>, and the fact that a leader and its cohorts execute the same deterministic program. The graph at one troupe records the receipt order of application-multicasts in other troupes on which the local state of the troupe depends. <p> The communication subsystem may deliver a multicast message to all, some, or none of the troupe members, and multicasts may be arbitrarily delayed. Each multicast message has a unique identifier. The execution of a troupe consists of a sequence of piecewise deterministic state intervals <ref> [14] </ref>, each started by the - - J J J^ J J m r m 2 m 1 1 q 1 1 p 2 0 0 p receipt of an application-multicast. Figure 1 shows the execution of three troupes and their state intervals.
Reference: [15] <author> D.B. Johnson and W. Zwaenepoel. </author> <title> Sender-based message logging. </title> <booktitle> In Proceedings of the 17th International Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 14-19, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Manetho uses a new negative-acknowledgment, ordered-multicast protocol to implement inter-troupe multicasts. Manetho's multicast protocol depends on a combination of antecedence graph maintenance [12], a form of sender-based message logging <ref> [14, 15] </ref>, and the fact that a leader and its cohorts execute the same deterministic program. The graph at one troupe records the receipt order of application-multicasts in other troupes on which the local state of the troupe depends.
Reference: [16] <author> M.F. Kaashoek and A.S. Tanenbaum. </author> <title> Group communication in the Amoeba distributed operating system. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 222-230, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: In contrast, Manetho adds replication to deterministic processes in an application-transparent manner. The idea of having a sequencer define the receipt order of a multicast was used in the multicast protocol of Chang and Maxemchuck [7], the Amoeba atomic broadcast protocol <ref> [16] </ref>, and the Delta-4 XPA system [2]. The r-resilient protocol of Chang and Maxemchuck relies on negative-acknowledgment and leadership transfer to achieve reliable total ordering. However, a multicast must be delayed for r 1 leadership transfers before it can be delivered.
Reference: [17] <author> P. M. Melliar-Smith, L.E. Moser, and V. Agrawala. </author> <title> Broadcast protocols for distributed systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 17-25, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: For example, the two-phase agreement protocol of this implementation of ABCAST requires r point-to-point messages and one overhead multicast to determine the receipt order of an application-multicast sent to r receivers. In contrast, negative-acknowledgment protocols <ref> [7, 17] </ref> attempt to reduce the number of control messages by piggybacking the ordering information on application-multicasts. <p> Such ordering can be provided in Psync by applying an ordering filter on the context graph, which delays the delivery of the application-multicast at each site for several application-multicasts [19]. The atomic broadcast protocol of Melliar-Smith et al. <ref> [17] </ref> uses no control messages during normal operation at the expense of a large delay in message delivery. This delay depends mainly on the rate of incoming application-broadcasts.
Reference: [18] <author> L.E. Moser, P. M. Melliar-Smith, and V. Agrawala. </author> <title> Membership algorithms for asynchronous distributed systems. </title> <booktitle> In Proceedings of the 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 480-489, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: Manetho tolerates r 1 failures in each troupe, but it does not currently tolerate network partition. Manetho assumes that each troupe has access to a local group membership protocol that maintains a list of the members in the troupe <ref> [5, 9, 18] </ref>. The group membership protocol detects the changes in the troupe membership (due to failures and recoveries) and reliably notifies its members of such changes. The communication subsystem supports multicast addressing and unreliable multicast delivery.
Reference: [19] <author> L.L. Peterson, N.C. Bucholz, and R.D. Schlichting. </author> <title> Preserving and using context information in interprocess communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(3) </volume> <pages> 217-246, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: An example is ISIS's CBCAST protocol which provides causal ordering [3]. However, CBCAST does not enforce identical receipt orders for two multicasts sent from two sources that are not causally related [21]. Another example is the Psync multicast protocol based on the context order <ref> [19] </ref>. Analogous to CBCAST, two multicasts that are not related by the context order may not have a unique receipt order. To enforce such a unique order, a deterministic filter function must be applied on top of the protocol, which delays the delivery of the application-multicast until several subsequent multicasts [19]. <p> <ref> [19] </ref>. Analogous to CBCAST, two multicasts that are not related by the context order may not have a unique receipt order. To enforce such a unique order, a deterministic filter function must be applied on top of the protocol, which delays the delivery of the application-multicast until several subsequent multicasts [19]. <p> ABCAST relies on an underlying transport protocol that guarantees that messages are reliably delivered in FIFO order. This transport protocol is a major source of overhead in ISIS [3]. In contrast, Manetho adopts weaker assumption about the network reliability. The context graph of the x -kernel's Psync protocol <ref> [19] </ref> is the basis of another general-purpose multicast protocol. Unlike our protocol, Psync does not guarantee the identical receipt ordering required by process-replication in the absence of information about the application's semantics. <p> Such ordering can be provided in Psync by applying an ordering filter on the context graph, which delays the delivery of the application-multicast at each site for several application-multicasts <ref> [19] </ref>. The atomic broadcast protocol of Melliar-Smith et al. [17] uses no control messages during normal operation at the expense of a large delay in message delivery. This delay depends mainly on the rate of incoming application-broadcasts.
Reference: [20] <author> R.D. Schlichting and F.B. Schneider. </author> <title> Fail-stop processors: An approach to designing fault-tolerant computing systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 1(3) </volume> <pages> 222-238, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: Manetho tolerates r 1 fail-stop <ref> [20] </ref> failures in each troupe, 2 but it does not currently tolerate network partition. Every application message between two application processes is translated internally into an application-multicast between the troupes implementing the two processes. <p> The processes are deterministic and do not have real-time requirements. Each application process is replicated by a troupe [8] of r fail-stop <ref> [20] </ref> process replicas. Each replica has a distinct ordinal position within the troupe and executes the same application program.
Reference: [21] <author> F. Schmuck. </author> <title> The Use of Efficient Broadcast Primitives in Asynchronous Distributed Systems. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1988. </year>
Reference-contexts: An example is ISIS's CBCAST protocol which provides causal ordering [3]. However, CBCAST does not enforce identical receipt orders for two multicasts sent from two sources that are not causally related <ref> [21] </ref>. Another example is the Psync multicast protocol based on the context order [19]. Analogous to CBCAST, two multicasts that are not related by the context order may not have a unique receipt order.
Reference: [22] <author> F.B. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-320, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Section 8 compares our system with related work. Finally, Section 9 presents conclusions. 2 Why a New Multicast Protocol? To enforce consistency among troupe members in the absence of any information about the application program, the system requires a multicast protocol that satisfies the agreement and order conditions <ref> [10, 22] </ref>. The former condition requires that each troupe member receive the same set of messages, while the latter requires that each troupe member receive the messages in the same order.
References-found: 22

