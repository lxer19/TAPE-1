URL: http://www.cs.toronto.edu/~vassos/research/publications/CHJT97/paper.ps.gz
Refering-URL: http://www.cs.toronto.edu/~vassos/research/list-of-publications.html
Root-URL: 
Title: On the robustness of the h r m hierarchy  
Author: Tushar Chandra Vassos Hadzilacos Prasad Jayanti Sam Toueg 
Date: January 12, 1998  
Abstract: m is a robust hierarchy. Roughly speaking, a hierarchy is robust if each type is "stronger" than any combination of lower level types. For certain models of binding between processes and objects, we prove here that h r m is not a robust hierarchy.
Abstract-found: 1
Intro-found: 1
Reference: [BGA94] <author> E. Borowsky, E. Gafni, and Y. Afek. </author> <title> Consensus power makes (some) sense. </title> <booktitle> In Pro ceedings of the 13th Annual Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 363-372, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Concurrently with the first appearance of our result [CHJT94], there appeared two papers proving the robustness of h r m in certain models <ref> [BGA94, PBN94] </ref>. Specifically, Borowsky, Gafni, and Afek show that if types must be deterministic and oblivious, each process may bind to several ports of the same object, and the process-to-port binding is transient, then h r m is robust [BGA94]. <p> Specifically, Borowsky, Gafni, and Afek show that if types must be deterministic and oblivious, each process may bind to several ports of the same object, and the process-to-port binding is transient, then h r m is robust <ref> [BGA94] </ref>. Peterson, Bazzi, and Neiger show that if types must be deterministic, each process may bind to several ports of the same object, but the process-to-port binding is permanent, then h r m is robust [PBN94]. 2 More nonrobustness results have appeared recently. <p> Their definition encompasses only oblivious types. The distinction between oblivious and nonoblivious types was made explicit by Kleinberg and Mullainathan [KM93]. The definitions given above are adapted from Bazzi, Neiger and Peterson [BNP94], Borowsky, Gafni and Afek <ref> [BGA94] </ref>, and Jayanti [Jay95]. 4 2.2 Processes and Objects A concurrent system consists of processes and objects. Processes, objects, and the concurrent system can all be formally modeled using I/O automata [LT88], as described by Herlihy [Her91]. Our approach here is more informal.
Reference: [BNP94] <author> R. Bazzi, G. Neiger, and G. Peterson. </author> <title> On the use of registers in achieving wait-free consensus. </title> <booktitle> In Proceedings of the 13th Annual Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 354-363, </pages> <year> 1994. </year> <month> 20 </month>
Reference-contexts: The notion of type (in the sense presented above) was first described by Herlihy and Wing [HW90]. Their definition encompasses only oblivious types. The distinction between oblivious and nonoblivious types was made explicit by Kleinberg and Mullainathan [KM93]. The definitions given above are adapted from Bazzi, Neiger and Peterson <ref> [BNP94] </ref>, Borowsky, Gafni and Afek [BGA94], and Jayanti [Jay95]. 4 2.2 Processes and Objects A concurrent system consists of processes and objects. Processes, objects, and the concurrent system can all be formally modeled using I/O automata [LT88], as described by Herlihy [Her91]. Our approach here is more informal.
Reference: [CHJT94] <author> T. Chandra, V. Hadzilacos, P. Jayanti, and S. Toueg. </author> <title> Wait-freedom vs. t-resiliency and the robustness of wait-free hierarchies. </title> <booktitle> In Proceedings of the 13th Annual Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 334-343, </pages> <year> 1994. </year>
Reference-contexts: Concurrently with the first appearance of our result <ref> [CHJT94] </ref>, there appeared two papers proving the robustness of h r m in certain models [BGA94, PBN94].
Reference: [CIL87] <author> B. Chor, A. Israeli, and M. Li. </author> <title> On processor coordination using asynchronous hardware. </title> <booktitle> In Proceedings of the 6th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 86-97, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: P 0 is a consensus protocol (for two processes) that uses only registers. This is well known to be impossible <ref> [CIL87, DDS87, LA87] </ref>. Let s be any state of the type booster. We claim that a booster object, initialised to state s and shared by only two processes, can be implemented using only registers. First we prove this claim for the easy case when s is not a fresh state. <p> By Theorems 1 and 2, it follows that there is an algorithm that solves consensus between two processes and uses only registers. This contradicts the well-known fact that no such algorithm exists <ref> [CIL87, DDS87, LA87] </ref>. We can now prove our main result: Theorem 3 If types may be nondeterministic and nonoblivious, for each of the binding schemes S and D, the hierarchy h r m is not robust.
Reference: [DDS87] <author> D. Dolev, C. Dwork, and L. Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> 34(1) </volume> <pages> 77-97, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: P 0 is a consensus protocol (for two processes) that uses only registers. This is well known to be impossible <ref> [CIL87, DDS87, LA87] </ref>. Let s be any state of the type booster. We claim that a booster object, initialised to state s and shared by only two processes, can be implemented using only registers. First we prove this claim for the easy case when s is not a fresh state. <p> By Theorems 1 and 2, it follows that there is an algorithm that solves consensus between two processes and uses only registers. This contradicts the well-known fact that no such algorithm exists <ref> [CIL87, DDS87, LA87] </ref>. We can now prove our main result: Theorem 3 If types may be nondeterministic and nonoblivious, for each of the binding schemes S and D, the hierarchy h r m is not robust.
Reference: [FLP85] <author> M. Fischer, N. Lynch, and M. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> JACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <year> 1985. </year>
Reference-contexts: B solves consensus among n processes if and only if h r m (B) n. As described in Section 2.1, type n-consensus, together with registers, can solve consensus among n processes. On the other hand, using standard techniques (specifically, the bivalence argument <ref> [FLP85, Her91] </ref>) it can be shown that there is no algorithm that solves consensus among n + 1 processes using only registers and objects that belong to deterministic types that have at most n ports.
Reference: [Her91] <author> M.P. Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM TOPLAS, </journal> <volume> 13(1) </volume> <pages> 124-149, </pages> <year> 1991. </year>
Reference-contexts: Watson, tushar@watson.ibm.com z University of Toronto, vassos@cs.utoronto.ca, partially supported by a grant from the Natural Sciences and Engineering Research Council of Canada. x Dartmouth College, prasad@cs.dartmouth.edu, supported by NSF RIA grant CCR-9410421 and Dartmouth College Startup grant. -Cornell University, sam@cs.cornell.edu, supported by NSF grant CCR-9102231. 1 of the remaining processes <ref> [Her91] </ref>. In this paper we are interested exclusively in linearisable and wait-free implementations. A type T is called n-universal if, for all types T 0 , an object of type T 0 , shared by n processes, can be implemented using only registers and objects of type T [Her91]. <p> remaining processes <ref> [Her91] </ref>. In this paper we are interested exclusively in linearisable and wait-free implementations. A type T is called n-universal if, for all types T 0 , an object of type T 0 , shared by n processes, can be implemented using only registers and objects of type T [Her91]. It turns out that, for all n, there is a type that is n-universal, but is not (n + 1)-universal [JT92]. Thus, types can differ in their ability to support implementations of other types. This observation has motivated research on classifying types into a hierarchy [Her91, Jay93]. <p> It turns out that, for all n, there is a type that is n-universal, but is not (n + 1)-universal [JT92]. Thus, types can differ in their ability to support implementations of other types. This observation has motivated research on classifying types into a hierarchy <ref> [Her91, Jay93] </ref>. A hierarchy assigns a level to each type, where a level is a positive integer or 1. It is intended that types at higher levels are more powerful, in their ability to implement types, than those at lower levels. <p> It is intended that types at higher levels are more powerful, in their ability to implement types, than those at lower levels. The type hierarchy that has received the most attention is the consensus hierarchy, also known as h r m <ref> [Her91, Jay93] </ref>. In this hierarchy, a type T is mapped to level n if and only if n is the maximum integer such that T is n-universal; if no such maximum exists, then T is mapped to 1. <p> Herlihy has shown that this problem plays a central role in wait-free implementations: if consensus for n processes can be solved using only objects of type T and registers, then T is n-universal <ref> [Her91] </ref>. Motivated by this fact, we define the n-consensus type. An object of this type allows a maximum of n processes to solve the consensus problem (see Section 2.1 for a precise specification of this type). <p> Processes, objects, and the concurrent system can all be formally modeled using I/O automata [LT88], as described by Herlihy <ref> [Her91] </ref>. Our approach here is more informal. An object is an instance of a type. <p> Herlihy established a fundamental link between the ability of a set of types to implement consensus, and their ability to implement other types. Theorem 1 (Herlihy <ref> [Her91] </ref>) Let B be any set of types that includes register. <p> B solves consensus among n processes if and only if h r m (B) n. As described in Section 2.1, type n-consensus, together with registers, can solve consensus among n processes. On the other hand, using standard techniques (specifically, the bivalence argument <ref> [FLP85, Her91] </ref>) it can be shown that there is no algorithm that solves consensus among n + 1 processes using only registers and objects that belong to deterministic types that have at most n ports.
Reference: [HW90] <author> M.P. Herlihy and J.M. Wing. </author> <title> Linearizability: A correctness condition for concurrent objects. </title> <journal> ACM TOPLAS, </journal> <volume> 12(3) </volume> <pages> 463-492, </pages> <year> 1990. </year>
Reference-contexts: , is it possible to implement an object of type T using only objects that belong to types in B? An implementation of an object type is linearisable if every operation of the implemented object type appears to take effect instantaneously at some point between its invocation and its response <ref> [HW90] </ref>. <p> We write n-consensus to denote the n-ported consensus type. The notion of type (in the sense presented above) was first described by Herlihy and Wing <ref> [HW90] </ref>. Their definition encompasses only oblivious types. The distinction between oblivious and nonoblivious types was made explicit by Kleinberg and Mullainathan [KM93]. <p> A key concept that enters into this definition is that of linearisability <ref> [HW90] </ref>. We begin with some motivation and intuition for this concept. The sequential specification of a type describes the behaviour of an object of that type when operations are applied to the object one-at-a-time, with no overlap.
Reference: [Jay93] <author> P. Jayanti. </author> <title> On the robustness of Herlihy's hierarchy. </title> <booktitle> In Proceedings of the 12th Annual Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: It turns out that, for all n, there is a type that is n-universal, but is not (n + 1)-universal [JT92]. Thus, types can differ in their ability to support implementations of other types. This observation has motivated research on classifying types into a hierarchy <ref> [Her91, Jay93] </ref>. A hierarchy assigns a level to each type, where a level is a positive integer or 1. It is intended that types at higher levels are more powerful, in their ability to implement types, than those at lower levels. <p> It is intended that types at higher levels are more powerful, in their ability to implement types, than those at lower levels. The type hierarchy that has received the most attention is the consensus hierarchy, also known as h r m <ref> [Her91, Jay93] </ref>. In this hierarchy, a type T is mapped to level n if and only if n is the maximum integer such that T is n-universal; if no such maximum exists, then T is mapped to 1. <p> the former is stronger than (can implement) the latter? Jayanti observed that the answer to this question is affirmative if h r m is robust: no object of a type at level n shared by n processes, can be implemented by any combination of types at levels strictly below n <ref> [Jay93] </ref>. In the same paper, Jayanti investigated h r m and some related hierarchies of types. He showed that the other hierarchies are not robust, but left open whether h r m is. It turns out that whether h r m is robust depends on how types are modeled.
Reference: [Jay95] <author> P. Jayanti. </author> <title> Solvability of consensus: composition breaks down for non-deterministic types. </title> <journal> SIAM Journal of Computing, </journal> <note> 1995. Accepted for publication. </note>
Reference-contexts: Their definition encompasses only oblivious types. The distinction between oblivious and nonoblivious types was made explicit by Kleinberg and Mullainathan [KM93]. The definitions given above are adapted from Bazzi, Neiger and Peterson [BNP94], Borowsky, Gafni and Afek [BGA94], and Jayanti <ref> [Jay95] </ref>. 4 2.2 Processes and Objects A concurrent system consists of processes and objects. Processes, objects, and the concurrent system can all be formally modeled using I/O automata [LT88], as described by Herlihy [Her91]. Our approach here is more informal. An object is an instance of a type.
Reference: [JT92] <author> P. Jayanti and S. Toueg. </author> <title> Some results on the impossibility, universality, and decidability of consensus. </title> <booktitle> In Proceedings of the 6th Workshop on Distributed Algorithms, </booktitle> <address> Haifa, Israel, </address> <month> November </month> <year> 1992. </year> <note> Appeared in Lecture Notes in Computer Science, Springer-Verlag, No: 647. </note>
Reference-contexts: It turns out that, for all n, there is a type that is n-universal, but is not (n + 1)-universal <ref> [JT92] </ref>. Thus, types can differ in their ability to support implementations of other types. This observation has motivated research on classifying types into a hierarchy [Her91, Jay93]. A hierarchy assigns a level to each type, where a level is a positive integer or 1.
Reference: [KM93] <author> J. Kleinberg and S. Mullainathan. </author> <title> Resource bounds and combinations of consensus objects. </title> <booktitle> In Proceedings of the 12th Annual Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: We write n-consensus to denote the n-ported consensus type. The notion of type (in the sense presented above) was first described by Herlihy and Wing [HW90]. Their definition encompasses only oblivious types. The distinction between oblivious and nonoblivious types was made explicit by Kleinberg and Mullainathan <ref> [KM93] </ref>. The definitions given above are adapted from Bazzi, Neiger and Peterson [BNP94], Borowsky, Gafni and Afek [BGA94], and Jayanti [Jay95]. 4 2.2 Processes and Objects A concurrent system consists of processes and objects.
Reference: [LA87] <author> M.C. Loui and H.H. Abu-Amara. </author> <title> Memory requirements for agreement among unreliable asynchronous processes. </title> <booktitle> Advances in computing research, </booktitle> <volume> 4 </volume> <pages> 163-183, </pages> <year> 1987. </year>
Reference-contexts: P 0 is a consensus protocol (for two processes) that uses only registers. This is well known to be impossible <ref> [CIL87, DDS87, LA87] </ref>. Let s be any state of the type booster. We claim that a booster object, initialised to state s and shared by only two processes, can be implemented using only registers. First we prove this claim for the easy case when s is not a fresh state. <p> By Theorems 1 and 2, it follows that there is an algorithm that solves consensus between two processes and uses only registers. This contradicts the well-known fact that no such algorithm exists <ref> [CIL87, DDS87, LA87] </ref>. We can now prove our main result: Theorem 3 If types may be nondeterministic and nonoblivious, for each of the binding schemes S and D, the hierarchy h r m is not robust.
Reference: [LH97] <author> Wai-Kau Lo and Vassos Hadzilacos. </author> <title> All of us are smarter than any of us: wait-free hierarchies are not robust. </title> <booktitle> In Proceedings of the 19th ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1997. </year>
Reference-contexts: Moran and Rappoport [MR96] strengthen our result by proving that h r m is not robust even if types must be deterministic, as long as each process must be permanently bound to at most one port of an object. Lo and Hadzilacos <ref> [LH97] </ref> prove that h r m is not robust if types can be nondeterministic, regardless of whether they are oblivious and of how processes may bind to ports. Schenk proves a result similar to the one in [LH97], but his result requires infinite nondeterminism and applies only for a stronger definition <p> Lo and Hadzilacos <ref> [LH97] </ref> prove that h r m is not robust if types can be nondeterministic, regardless of whether they are oblivious and of how processes may bind to ports. Schenk proves a result similar to the one in [LH97], but his result requires infinite nondeterminism and applies only for a stronger definition of wait-free implementation [Sch96]. 1.3 Overview of the proof In the consensus problem for n processes, each process is initially given an input from the natural numbers.
Reference: [LT88] <author> N. Lynch and M. Tuttle. </author> <title> An introduction to input/output automata. </title> <type> Technical Report MIT/LCS/TM-373, </type> <institution> MIT, MIT Laboratory for Computer Science, </institution> <year> 1988. </year>
Reference-contexts: The definitions given above are adapted from Bazzi, Neiger and Peterson [BNP94], Borowsky, Gafni and Afek [BGA94], and Jayanti [Jay95]. 4 2.2 Processes and Objects A concurrent system consists of processes and objects. Processes, objects, and the concurrent system can all be formally modeled using I/O automata <ref> [LT88] </ref>, as described by Herlihy [Her91]. Our approach here is more informal. An object is an instance of a type.
Reference: [MR96] <author> S. Moran and L. </author> <title> Rappoport. </title> <booktitle> On the robustness of h r m . In Proceedings of the 10th Workshop on Distributed Algorithms, </booktitle> <month> October </month> <year> 1996. </year>
Reference-contexts: Peterson, Bazzi, and Neiger show that if types must be deterministic, each process may bind to several ports of the same object, but the process-to-port binding is permanent, then h r m is robust [PBN94]. 2 More nonrobustness results have appeared recently. Moran and Rappoport <ref> [MR96] </ref> strengthen our result by proving that h r m is not robust even if types must be deterministic, as long as each process must be permanently bound to at most one port of an object.
Reference: [PBN94] <author> G. Peterson, R. Bazzi, and G. Neiger. </author> <title> A gap theorem for consensus types. </title> <booktitle> In Proceedings of the 13th Annual Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 344-353, </pages> <month> August </month> <year> 1994. </year>
Reference-contexts: Concurrently with the first appearance of our result [CHJT94], there appeared two papers proving the robustness of h r m in certain models <ref> [BGA94, PBN94] </ref>. Specifically, Borowsky, Gafni, and Afek show that if types must be deterministic and oblivious, each process may bind to several ports of the same object, and the process-to-port binding is transient, then h r m is robust [BGA94]. <p> Peterson, Bazzi, and Neiger show that if types must be deterministic, each process may bind to several ports of the same object, but the process-to-port binding is permanent, then h r m is robust <ref> [PBN94] </ref>. 2 More nonrobustness results have appeared recently. Moran and Rappoport [MR96] strengthen our result by proving that h r m is not robust even if types must be deterministic, as long as each process must be permanently bound to at most one port of an object.
Reference: [Sch96] <author> Eric Schenk. </author> <title> Computability and Complexity Results for Agreement Problems in Shared Memory Distributed Systems. </title> <type> PhD thesis, </type> <institution> University of Toronto, </institution> <year> 1996. </year> <month> 21 </month>
Reference-contexts: Schenk proves a result similar to the one in [LH97], but his result requires infinite nondeterminism and applies only for a stronger definition of wait-free implementation <ref> [Sch96] </ref>. 1.3 Overview of the proof In the consensus problem for n processes, each process is initially given an input from the natural numbers.
References-found: 18

