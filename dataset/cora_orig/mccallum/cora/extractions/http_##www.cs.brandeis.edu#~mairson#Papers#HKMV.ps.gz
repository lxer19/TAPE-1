URL: http://www.cs.brandeis.edu/~mairson/Papers/HKMV.ps.gz
Refering-URL: http://www.cs.brandeis.edu/~mairson/
Root-URL: http://www.cs.brandeis.edu
Title: Undecidable Boundedness Problems for Datalog Programs  
Author: Gerd G. Hillebrand Paris C. Kanellakis Harry G. Mairson Moshe Y. Vardi 
Date: October 11, 1994  
Abstract: A given Datalog program is bounded if its depth of recursion is independent of the input database. Deciding boundedness is a basic task for the analysis of database logic programs. The undecidability of Datalog boundedness was first demonstrated by Gaifman et al. We introduce new techniques for proving the undecidability of various kinds of boundedness, which allow us to considerably strengthen the results of Gaifman et al. In particular: (1) We use a new generic reduction technique to show that program boundedness is undecidable for arity 2 predicates, even with linear rules. (2) We use the mortality problem of Turing machines to show that uniform boundedness is undecidable for arity 3 predicates and for arity 1 predicates when 6= is also allowed. (3) By encoding all possible transitions of a two-counter machine in a single rule, we show that program (resp., predicate) boundedness is undecidable for two linear rules (resp., one rule and a projection), one initialization rule and small arity predicates (6 or 7).
Abstract-found: 1
Intro-found: 1
Reference: [A89] <author> S. Abiteboul, </author> <title> Boundedness of Single Rule Programs is Undecidable, </title> <journal> Information Processing Letters, </journal> <volume> 32 (1989), </volume> <pages> 281-289. </pages>
Reference-contexts: Program boundedness is also 0 1 -complete [GMSV87] and the known undecidability results with the smallest arity involve linear, 4-ary programs. The previous undecidability results with the smallest number of rules involved one nonlinear recursive rule and two initialization rules <ref> [A89] </ref>. Predicate boundedness is even harder; it is 0 2 -complete [CGKV88] because of the final projection. <p> We hope that some further refinement of either of the two proofs might be useful for settling the case of arity 2. 4. We show that program boundedness is undecidable for two linear recursive rules and one initialization rule. This improves the results of <ref> [A89] </ref> with respect to linearity and initialization, but adds one recursive "flood-halt rule". The proof is based on the flooding technique of [GMSV87] and a polymorphic encoding of many rules in one. The arity used is 6. 5. <p> Note that, linear, arity 4 is NP-hard [K88]; non-linear is also open. (2) Is program boundedness decidable for one linear rule, any initialization rules and any arity predicates? Note that, linear, arity 2 is NP-complete [V88]; some sufficient conditions for decidability appear in [HKMV91]; without linearity the problem is undecidable <ref> [A89] </ref>. Appendix: Ternary Datalog via the Halting Problem In this appendix, we give a proof of the undecidability of uniform boundedness for ternary Datalog programs along the lines of [GMSV87].
Reference: [AG89] <author> M. Ajtai, Y. Gurevich, </author> <title> Datalog versus First Order, </title> <booktitle> Proc. 30th IEEE Symp. on Foundations of Computer Science (1989), </booktitle> <pages> 142-148. </pages>
Reference-contexts: Boundedness is also a semantic property (i.e., it is preserved by pro-gram equivalence): a Datalog program is bounded iff it is equivalent to a positive existential first-order formula [NS91] iff it is equivalent, over finite structures, to a first-order formula <ref> [AG89] </ref>. Let us describe the problem, its status (see also [KA89]), and our contributions. 1.1 Basic Definitions Datalog Syntax: A (Datalog) program P is a finite set of rules. Here, a rule is a statement of the form p (X) :| '.
Reference: [CH85] <author> A.K. Chandra, D. Harel, </author> <title> Horn Clause Queries and Generalizations, </title> <journal> J. Logic Programming, </journal> <volume> 2 (1985), </volume> <pages> 1-15. </pages>
Reference-contexts: 1 Introduction It has been realized for some time that first-order database query languages are lacking in expressive power. This has led to the study of Datalog programs [K90, U89], which combine positive existential first-order formulas with recursion|see <ref> [CH85] </ref>. Analyzing the depth of recursion of these database logic programs has emerged as a fundamental problem, e.g., for parallel evaluation [CK86, K88, UV88] or for optimization [N89b].
Reference: [CGKV88] <author> S.S. Cosmadakis, H. Gaifman, P.C. Kanellakis, M.Y. Vardi, </author> <title> Decidable Optimization Problems for Database Logic Programs, </title> <booktitle> Proc. 20th ACM Symp. on Theory of Computing (1988), </booktitle> <pages> 477-490. </pages>
Reference-contexts: The previous undecidability results with the smallest number of rules involved one nonlinear recursive rule and two initialization rules [A89]. Predicate boundedness is even harder; it is 0 2 -complete <ref> [CGKV88] </ref> because of the final projection. Predicate boundedness (and thus program and uniform boundedness as well) is shown to be decidable for monadic programs in [CGKV88], which also contains a partial analysis of the complexity of this decision problem (see also [M90]). <p> Predicate boundedness is even harder; it is 0 2 -complete <ref> [CGKV88] </ref> because of the final projection. Predicate boundedness (and thus program and uniform boundedness as well) is shown to be decidable for monadic programs in [CGKV88], which also contains a partial analysis of the complexity of this decision problem (see also [M90]). <p> The proof technique is related to [GMSV87], but instead of simulating computations we just check whether a computation encoded in the database is a valid terminating computation. This result is optimal with respect to arity and linearity, since predicate (and thus program) boundedness is decidable for monadic programs <ref> [CGKV88] </ref>. 2. We show that uniform boundedness is undecidable for arity 1 linear programs with 6=. This resolves an open question of [GMSV87], where undecidability is shown for program boundedness. The proof is a reduction from the mortality problem for Tur-ing machines [H66]. <p> The proof is a reduction from the mortality problem for Tur-ing machines [H66]. It is a qualitatively different proof from the techniques used in [GMSV87]. (The mortality problem has recently been used to prove the undecidability of the semi-unification problem [KTU90].) Given the decidability results of <ref> [CGKV88] </ref> for monadic programs, this tight result illustrates the power of 6=. 3. We show that uniform boundedness is undecidable for arity 3 programs. This improves the arity from 5 to 3 (but leaves open arity 2). <p> Some other interesting open questions are: * To complete the arity classification: Is uniform boundedness decidable for arity 2 programs? Additional linearity and connectivity restrictions (even for arity 4) give us more challenging open problems. Tight complexity bounds are still open for the monadic case (see <ref> [CGKV88, M90] </ref>). * To complete the number of rules classification: (1) Is uniform boundedness decidable for linear single rule programs? Note that, linear, arity 4 is NP-hard [K88]; non-linear is also open. (2) Is program boundedness decidable for one linear rule, any initialization rules and any arity predicates? Note that, linear,
Reference: [CK86] <author> S.S. Cosmadakis, </author> <title> P.C. Kanellakis, Parallel Evaluation of Recursive Rule Queries, </title> <booktitle> Proc. 5th ACM Symp. on Principles of Database Systems (1986), </booktitle> <pages> 280-293. </pages>
Reference-contexts: This has led to the study of Datalog programs [K90, U89], which combine positive existential first-order formulas with recursion|see [CH85]. Analyzing the depth of recursion of these database logic programs has emerged as a fundamental problem, e.g., for parallel evaluation <ref> [CK86, K88, UV88] </ref> or for optimization [N89b]. <p> While predicate boundedness could in principle be harder than uniform boundedness, we do not know of any class of Datalog programs for which predicate boundedness is undecidable while uniform boundedness is decidable. In contrast, uniform equivalence of Datalog programs is decidable [S88] (first shown in <ref> [CK86] </ref> for one IDB predicate), while predicate equivalence is undecidable [Sh87].
Reference: [GMSV87] <author> H. Gaifman, H. Mairson, Y. Sagiv, M.Y. Vardi, </author> <title> Undecidable Optimization Problems for Database Logic Programs, </title> <booktitle> Proc. 2nd IEEE Symp. on Logic in Computer Science (1987), </booktitle> <pages> 106-115. </pages> <note> Full version in IBM Research Report RJ7386; also to appear in J. ACM, </note> <year> 1992. </year>
Reference-contexts: We use the terms predicate, program and uniform boundedness depending on the I/O convention. (Uniform boundedness is called strong boundedness in <ref> [GMSV87] </ref>.) 2 For the same set of rules, uniform boundedness ) program boundedness ) predicate boundedness, but the converses need not hold. Clearly, program boundedness means predicate boundedness for all IDB predicates. Thus, decidability of predicate boundedness implies decidability of program boundedness. <p> The first results about boundedness were positive: PTIME graph-theoretic decision procedures for subclasses of linear programs were proposed in [I86, N89a] and this focused attention on the problem. Unfortunately, as first shown in <ref> [GMSV87] </ref>, 3 boundedness is undecidable in general; more importantly, undecidability of boundedness entails undecidability for many other questions concerning recursion. Uniform boundedness is 0 1 -complete [GMSV87]; the previous undecidability results with the smallest arity involved linear, 5-ary programs [GMSV87]. <p> Unfortunately, as first shown in <ref> [GMSV87] </ref>, 3 boundedness is undecidable in general; more importantly, undecidability of boundedness entails undecidability for many other questions concerning recursion. Uniform boundedness is 0 1 -complete [GMSV87]; the previous undecidability results with the smallest arity involved linear, 5-ary programs [GMSV87]. <p> Unfortunately, as first shown in <ref> [GMSV87] </ref>, 3 boundedness is undecidable in general; more importantly, undecidability of boundedness entails undecidability for many other questions concerning recursion. Uniform boundedness is 0 1 -complete [GMSV87]; the previous undecidability results with the smallest arity involved linear, 5-ary programs [GMSV87]. With respect to the number of rules, there is some fixed linear program P with one IDB predicate (but considerably more than two recursive rules) such that uniform boundedness is undecidable for P [ fg for a variable initialization rule [GMSV87]. Program boundedness is also 0 1 -complete [GMSV87] and <p> results with the smallest arity involved linear, 5-ary programs <ref> [GMSV87] </ref>. With respect to the number of rules, there is some fixed linear program P with one IDB predicate (but considerably more than two recursive rules) such that uniform boundedness is undecidable for P [ fg for a variable initialization rule [GMSV87]. Program boundedness is also 0 1 -complete [GMSV87] and the known undecidability results with the smallest arity involve linear, 4-ary programs. The previous undecidability results with the smallest number of rules involved one nonlinear recursive rule and two initialization rules [A89]. <p> programs <ref> [GMSV87] </ref>. With respect to the number of rules, there is some fixed linear program P with one IDB predicate (but considerably more than two recursive rules) such that uniform boundedness is undecidable for P [ fg for a variable initialization rule [GMSV87]. Program boundedness is also 0 1 -complete [GMSV87] and the known undecidability results with the smallest arity involve linear, 4-ary programs. The previous undecidability results with the smallest number of rules involved one nonlinear recursive rule and two initialization rules [A89]. Predicate boundedness is even harder; it is 0 2 -complete [CGKV88] because of the final projection. <p> In particular, we present the following results|where the item numbers (plus one) correspond to the section numbers in the paper: 1. We show that program boundedness is undecidable for binary programs with linear rules, thereby extending the results of <ref> [GMSV87] </ref> from arity 4 to arity 2 programs. The proof technique is related to [GMSV87], but instead of simulating computations we just check whether a computation encoded in the database is a valid terminating computation. <p> We show that program boundedness is undecidable for binary programs with linear rules, thereby extending the results of <ref> [GMSV87] </ref> from arity 4 to arity 2 programs. The proof technique is related to [GMSV87], but instead of simulating computations we just check whether a computation encoded in the database is a valid terminating computation. This result is optimal with respect to arity and linearity, since predicate (and thus program) boundedness is decidable for monadic programs [CGKV88]. 2. <p> This result is optimal with respect to arity and linearity, since predicate (and thus program) boundedness is decidable for monadic programs [CGKV88]. 2. We show that uniform boundedness is undecidable for arity 1 linear programs with 6=. This resolves an open question of <ref> [GMSV87] </ref>, where undecidability is shown for program boundedness. The proof is a reduction from the mortality problem for Tur-ing machines [H66]. It is a qualitatively different proof from the techniques used in [GMSV87]. (The mortality problem has recently been used to prove the undecidability of the semi-unification problem [KTU90].) Given the <p> This resolves an open question of <ref> [GMSV87] </ref>, where undecidability is shown for program boundedness. The proof is a reduction from the mortality problem for Tur-ing machines [H66]. It is a qualitatively different proof from the techniques used in [GMSV87]. (The mortality problem has recently been used to prove the undecidability of the semi-unification problem [KTU90].) Given the decidability results of [CGKV88] for monadic programs, this tight result illustrates the power of 6=. 3. We show that uniform boundedness is undecidable for arity 3 programs. <p> The proof, which uses nonlinear rules, 4 is a refined version of the previous reduction from the mortality problem for Turing machines. In the appendix we give a different proof of this result along the lines of <ref> [GMSV87] </ref>. Using Turing machines instead of counter machines we simplify the proof in [GMSV87] and decrease the arity. Unlike the proof in [GMSV87], our proof uses nonlinear rules. <p> In the appendix we give a different proof of this result along the lines of <ref> [GMSV87] </ref>. Using Turing machines instead of counter machines we simplify the proof in [GMSV87] and decrease the arity. Unlike the proof in [GMSV87], our proof uses nonlinear rules. We hope that some further refinement of either of the two proofs might be useful for settling the case of arity 2. 4. <p> In the appendix we give a different proof of this result along the lines of <ref> [GMSV87] </ref>. Using Turing machines instead of counter machines we simplify the proof in [GMSV87] and decrease the arity. Unlike the proof in [GMSV87], our proof uses nonlinear rules. We hope that some further refinement of either of the two proofs might be useful for settling the case of arity 2. 4. We show that program boundedness is undecidable for two linear recursive rules and one initialization rule. <p> We show that program boundedness is undecidable for two linear recursive rules and one initialization rule. This improves the results of [A89] with respect to linearity and initialization, but adds one recursive "flood-halt rule". The proof is based on the flooding technique of <ref> [GMSV87] </ref> and a polymorphic encoding of many rules in one. The arity used is 6. 5. We show that predicate boundedness is undecidable for one linear recursive rule, one projection and one initialization rule. This exchanges the "flood-halt rule" for a projection. The arity used is 7. <p> We show that predicate boundedness is undecidable for one linear recursive rule, one projection and one initialization rule. This exchanges the "flood-halt rule" for a projection. The arity used is 7. This is an undecidability proof for a very simple set of connected rules|see <ref> [GMSV87] </ref> for a definition of connectivity and for a technique of proving undecidability under this restriction. 2 Undecidability of Boundedness for Binary Programs In [GMSV87], boundedness was proven undecidable by reduction from the halting problem for 2-counter machines. <p> The arity used is 7. This is an undecidability proof for a very simple set of connected rules|see <ref> [GMSV87] </ref> for a definition of connectivity and for a technique of proving undecidability under this restriction. 2 Undecidability of Boundedness for Binary Programs In [GMSV87], boundedness was proven undecidable by reduction from the halting problem for 2-counter machines. The idea was that the database encodes a prefix of the natural numbers, and the program simulates the computation of the machine. Here we take a different approach. <p> As our first result, we show that program boundedness is undecidable for query programs having two linear recursive rules and one initialization rule. 15 The reduction is from the halting problem for 2-counter machines (2CM), and follows the basic outline of the proof in <ref> [GMSV87] </ref>. The technical improvement is the polymorphic encoding of the entire transition function of the 2CM by a single linear recursion. A 2-counter machine (2CM) is a finite-state deterministic machine with two nonnegative counters. <p> Appendix: Ternary Datalog via the Halting Problem In this appendix, we give a proof of the undecidability of uniform boundedness for ternary Datalog programs along the lines of <ref> [GMSV87] </ref>. By using Turing machines instead of counter machines, the argument can be considerably simplified and the arity gets down to three. Our proof, however, uses nonlinear rules, unlike the construction in [GMSV87]. <p> we give a proof of the undecidability of uniform boundedness for ternary Datalog programs along the lines of <ref> [GMSV87] </ref>. By using Turing machines instead of counter machines, the argument can be considerably simplified and the arity gets down to three. Our proof, however, uses nonlinear rules, unlike the construction in [GMSV87]. We hope that a refinement of either of our two proofs will eventually resolve the undecidability of uniform boundedness for the binary case. The reduction we are going to present is from the halting problem for Turing machines. <p> First, the symbol and state fields can be merged, since both range over a finite domain. The resulting symbol/state combination can then be piggybacked onto the cell number using a technique described in the appendix of <ref> [GMSV87] </ref>: We assume that every "integer" in the database comes in as many "flavors" as there are symbol/state combinations. By putting the right "flavor" of cell into a TAPE (origin; time; cell) fact, we can then encode its symbol and state content. We now describe the details of P .
Reference: [G90] <author> I. </author> <title> Guessarian, Deciding Boundedness for Uniformly Connected Datalog Programs, </title> <booktitle> Proc. 3rd International Conf. on Database Theory (1990), Lecture Notes in Computer Science 470, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> 395-409. </pages>
Reference-contexts: Decision procedures are possible in some other special cases: e.g., [V88] shows the NP-completeness of the boundedness problem for arity 2 programs with one linear rule; also for chain rules and some of their generalizations we have decidability through context-free language finiteness tests <ref> [G90] </ref>. Other decidable cases appear: in [S85] for uniform boundedness of "typed template dependency" rules, in [NS91] which generalizes [I86, N89a], and in [HKMV91], which presents a decidability result for certain single-rule programs. 1.3 Our Contributions In this paper we concentrate on program arity and number of rules.
Reference: [H66] <author> P.K. Hooper, </author> <title> The Undecidability of the Turing Machine Immortality Problem, </title> <journal> Journal of Symbolic Logic, </journal> <volume> 31 (1966), </volume> <pages> 219-234. </pages>
Reference-contexts: We show that uniform boundedness is undecidable for arity 1 linear programs with 6=. This resolves an open question of [GMSV87], where undecidability is shown for program boundedness. The proof is a reduction from the mortality problem for Tur-ing machines <ref> [H66] </ref>. It is a qualitatively different proof from the techniques used in [GMSV87]. (The mortality problem has recently been used to prove the undecidability of the semi-unification problem [KTU90].) Given the decidability results of [CGKV88] for monadic programs, this tight result illustrates the power of 6=. 3. <p> We show that the presence of "6=" is sufficient to make uniform boundedness undecidable even for monadic programs. The proof is by reduction from the Turing machine mortality problem, which was shown to be undecidable in <ref> [H66] </ref>. The problem is defined as follows. Consider a deterministic Turing machine M operating on a two-way infinite tape.
Reference: [HKMV91] <author> G. Hillebrand, P.C. Kanellakis, H.G. Mairson, M.Y. </author> <title> Vardi Tools for Datalog Boundedness, </title> <booktitle> Proc. 10th ACM Symp. on Principles of Database Systems (1991), </booktitle> <pages> 1-12 </pages>
Reference-contexts: Datalog boundedness (i.e., whether the depth of recursion of a given program is a con stant independent of the input database) is interesting because it is the simplest case of fl The results presented here appeared in preliminary form in [V88] (Section 2 of this paper) and <ref> [HKMV91] </ref> (Sections 3-6 and the appendix of this paper). y Dept. of Computer Science, Brown University, Providence, RI 02912. Supported by ONR grant N00014 83-K-0146 ARPA Order No. 6320-1. z Dept. of Computer Science, Brown University, Providence, RI 02912. <p> Other decidable cases appear: in [S85] for uniform boundedness of "typed template dependency" rules, in [NS91] which generalizes [I86, N89a], and in <ref> [HKMV91] </ref>, which presents a decidability result for certain single-rule programs. 1.3 Our Contributions In this paper we concentrate on program arity and number of rules. We improve the state of-the-art on undecidable boundedness problems for Datalog programs and introduce a number of new techniques. <p> boundedness decidable for linear single rule programs? Note that, linear, arity 4 is NP-hard [K88]; non-linear is also open. (2) Is program boundedness decidable for one linear rule, any initialization rules and any arity predicates? Note that, linear, arity 2 is NP-complete [V88]; some sufficient conditions for decidability appear in <ref> [HKMV91] </ref>; without linearity the problem is undecidable [A89]. Appendix: Ternary Datalog via the Halting Problem In this appendix, we give a proof of the undecidability of uniform boundedness for ternary Datalog programs along the lines of [GMSV87].
Reference: [I86] <author> Y.E. Ioannidis, </author> <title> A Time Bound on the Materialization of Some Recursively Defined Views, </title> <journal> Algorithmica, </journal> <volume> 1 (1986), </volume> <pages> 361-385. </pages>
Reference-contexts: The first results about boundedness were positive: PTIME graph-theoretic decision procedures for subclasses of linear programs were proposed in <ref> [I86, N89a] </ref> and this focused attention on the problem. Unfortunately, as first shown in [GMSV87], 3 boundedness is undecidable in general; more importantly, undecidability of boundedness entails undecidability for many other questions concerning recursion. <p> Other decidable cases appear: in [S85] for uniform boundedness of "typed template dependency" rules, in [NS91] which generalizes <ref> [I86, N89a] </ref>, and in [HKMV91], which presents a decidability result for certain single-rule programs. 1.3 Our Contributions In this paper we concentrate on program arity and number of rules. We improve the state of-the-art on undecidable boundedness problems for Datalog programs and introduce a number of new techniques.
Reference: [K88] <author> P.C. Kanellakis, </author> <title> Logic Programming and Parallel Complexity, Foundations of Deductive Databases and Logic Programming, </title> <editor> J. Minker ed., </editor> <publisher> Morgan-Kaufmann 1988, </publisher> <pages> 547-586. </pages>
Reference-contexts: This has led to the study of Datalog programs [K90, U89], which combine positive existential first-order formulas with recursion|see [CH85]. Analyzing the depth of recursion of these database logic programs has emerged as a fundamental problem, e.g., for parallel evaluation <ref> [CK86, K88, UV88] </ref> or for optimization [N89b]. <p> Tight complexity bounds are still open for the monadic case (see [CGKV88, M90]). * To complete the number of rules classification: (1) Is uniform boundedness decidable for linear single rule programs? Note that, linear, arity 4 is NP-hard <ref> [K88] </ref>; non-linear is also open. (2) Is program boundedness decidable for one linear rule, any initialization rules and any arity predicates? Note that, linear, arity 2 is NP-complete [V88]; some sufficient conditions for decidability appear in [HKMV91]; without linearity the problem is undecidable [A89].
Reference: [K90] <author> P.C. Kanellakis, </author> <title> Elements of Relational Database Theory, </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. B, Chapter 17, </volume> <editor> J. van Leeuwen, A.R. Meyer, N. Nivat, M.S. Paterson, D. Perrin ed., </editor> <publisher> North-Holland 1990, </publisher> <pages> 1073-1157. </pages>
Reference-contexts: 1 Introduction It has been realized for some time that first-order database query languages are lacking in expressive power. This has led to the study of Datalog programs <ref> [K90, U89] </ref>, which combine positive existential first-order formulas with recursion|see [CH85]. Analyzing the depth of recursion of these database logic programs has emerged as a fundamental problem, e.g., for parallel evaluation [CK86, K88, UV88] or for optimization [N89b].
Reference: [KA89] <author> P.C. Kanellakis, S. Abiteboul, </author> <title> Database Theory Column, </title> <journal> SIGACT News, </journal> <volume> 20 (1989), </volume> <pages> 17-23. </pages>
Reference-contexts: Let us describe the problem, its status (see also <ref> [KA89] </ref>), and our contributions. 1.1 Basic Definitions Datalog Syntax: A (Datalog) program P is a finite set of rules. Here, a rule is a statement of the form p (X) :| '.
Reference: [KTU90] <author> A.J. Kfoury, J. Tiuryn, P. Urzyczyn, </author> <title> The Undecidability of the Semi--Unification Problem, </title> <booktitle> Proc. 22nd ACM Symp. on Theory of Computing (1990), </booktitle> <pages> 468-476. </pages>
Reference-contexts: The proof is a reduction from the mortality problem for Tur-ing machines [H66]. It is a qualitatively different proof from the techniques used in [GMSV87]. (The mortality problem has recently been used to prove the undecidability of the semi-unification problem <ref> [KTU90] </ref>.) Given the decidability results of [CGKV88] for monadic programs, this tight result illustrates the power of 6=. 3. We show that uniform boundedness is undecidable for arity 3 programs. This improves the arity from 5 to 3 (but leaves open arity 2).
Reference: [MUV84] <author> D. Maier, J.D. Ullman, M.Y. Vardi, </author> <title> On the Foundations of the Universal Relation Model, </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 9 (1984), </volume> <pages> 283-308. </pages>
Reference-contexts: (X; Y ) :| Knows (X; Z); Buys (Z; Y ): Buys (X; Y ) :| Likes (X; Y ): is inherently recursive (i.e., is not equivalent to any recursion-free program). 2 1.2 Previous Work An early definition and use of bounded recursion appeared in the context of universal relations <ref> [MUV84] </ref>. The first results about boundedness were positive: PTIME graph-theoretic decision procedures for subclasses of linear programs were proposed in [I86, N89a] and this focused attention on the problem.
Reference: [M90] <author> R. van der Meyden, </author> <title> Predicate Boundedness of Linear Monadic Datalog is in PSPACE, </title> <type> unpublished manuscript, </type> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Predicate boundedness (and thus program and uniform boundedness as well) is shown to be decidable for monadic programs in [CGKV88], which also contains a partial analysis of the complexity of this decision problem (see also <ref> [M90] </ref>). Decision procedures are possible in some other special cases: e.g., [V88] shows the NP-completeness of the boundedness problem for arity 2 programs with one linear rule; also for chain rules and some of their generalizations we have decidability through context-free language finiteness tests [G90]. <p> Some other interesting open questions are: * To complete the arity classification: Is uniform boundedness decidable for arity 2 programs? Additional linearity and connectivity restrictions (even for arity 4) give us more challenging open problems. Tight complexity bounds are still open for the monadic case (see <ref> [CGKV88, M90] </ref>). * To complete the number of rules classification: (1) Is uniform boundedness decidable for linear single rule programs? Note that, linear, arity 4 is NP-hard [K88]; non-linear is also open. (2) Is program boundedness decidable for one linear rule, any initialization rules and any arity predicates? Note that, linear,
Reference: [N89a] <author> J.F. Naughton, </author> <title> Data Independent Recursion in Deductive Databases, </title> <journal> J. Computer and System Sciences, </journal> <volume> 38 (1989), </volume> <pages> 259-289. </pages>
Reference-contexts: In contrast, uniform equivalence of Datalog programs is decidable [S88] (first shown in [CK86] for one IDB predicate), while predicate equivalence is undecidable [Sh87]. Example: To illustrate Datalog and boundedness consider the following canonical example <ref> [N89a] </ref>: Buys (X; Y ) :| Trendy (X ); Buys (Z; Y ): Buys (X; Y ) :| Likes (X; Y ): This example is program bounded since Buys (Z; Y ) can be changed to Likes (Z; Y ) to yield an equivalent recursion-free program. (It is also uniformly bounded.) <p> The first results about boundedness were positive: PTIME graph-theoretic decision procedures for subclasses of linear programs were proposed in <ref> [I86, N89a] </ref> and this focused attention on the problem. Unfortunately, as first shown in [GMSV87], 3 boundedness is undecidable in general; more importantly, undecidability of boundedness entails undecidability for many other questions concerning recursion. <p> Other decidable cases appear: in [S85] for uniform boundedness of "typed template dependency" rules, in [NS91] which generalizes <ref> [I86, N89a] </ref>, and in [HKMV91], which presents a decidability result for certain single-rule programs. 1.3 Our Contributions In this paper we concentrate on program arity and number of rules. We improve the state of-the-art on undecidable boundedness problems for Datalog programs and introduce a number of new techniques.
Reference: [N89b] <author> J.F. Naughton, </author> <title> Minimizing Function-free Recursive Definitions, </title> <journal> J. ACM, </journal> <volume> 36 (1989), </volume> <pages> 69-91. </pages>
Reference-contexts: This has led to the study of Datalog programs [K90, U89], which combine positive existential first-order formulas with recursion|see [CH85]. Analyzing the depth of recursion of these database logic programs has emerged as a fundamental problem, e.g., for parallel evaluation [CK86, K88, UV88] or for optimization <ref> [N89b] </ref>.
Reference: [NS91] <author> J.F. Naughton, Y. Sagiv, Naughton, J.F., Sagiv, Y.: </author> <title> A simple characterization of uniform boundedness for a class of recursions, </title> <journal> J. Logic Programming, </journal> <volume> 10 (1991), </volume> <pages> 233-254. </pages>
Reference-contexts: Boundedness is also a semantic property (i.e., it is preserved by pro-gram equivalence): a Datalog program is bounded iff it is equivalent to a positive existential first-order formula <ref> [NS91] </ref> iff it is equivalent, over finite structures, to a first-order formula [AG89]. Let us describe the problem, its status (see also [KA89]), and our contributions. 1.1 Basic Definitions Datalog Syntax: A (Datalog) program P is a finite set of rules. <p> Other decidable cases appear: in [S85] for uniform boundedness of "typed template dependency" rules, in <ref> [NS91] </ref> which generalizes [I86, N89a], and in [HKMV91], which presents a decidability result for certain single-rule programs. 1.3 Our Contributions In this paper we concentrate on program arity and number of rules.
Reference: [S85] <author> Y. Sagiv, </author> <title> On Computing Restricted Projections of Representative Instances, </title> <journal> SIAM J. of Computing, </journal> <volume> 17 (1988), </volume> <pages> 1-22 </pages>
Reference-contexts: Decision procedures are possible in some other special cases: e.g., [V88] shows the NP-completeness of the boundedness problem for arity 2 programs with one linear rule; also for chain rules and some of their generalizations we have decidability through context-free language finiteness tests [G90]. Other decidable cases appear: in <ref> [S85] </ref> for uniform boundedness of "typed template dependency" rules, in [NS91] which generalizes [I86, N89a], and in [HKMV91], which presents a decidability result for certain single-rule programs. 1.3 Our Contributions In this paper we concentrate on program arity and number of rules.
Reference: [S88] <author> Y. Sagiv, </author> <title> Optimizing Datalog Programs, Foundations of Deductive Databases and Logic Programming, </title> <editor> J. Minker ed., </editor> <publisher> Morgan-Kaufmann 1988, </publisher> <pages> 659-698. </pages>
Reference-contexts: While predicate boundedness could in principle be harder than uniform boundedness, we do not know of any class of Datalog programs for which predicate boundedness is undecidable while uniform boundedness is decidable. In contrast, uniform equivalence of Datalog programs is decidable <ref> [S88] </ref> (first shown in [CK86] for one IDB predicate), while predicate equivalence is undecidable [Sh87].
Reference: [Sh87] <author> O. Shmueli, </author> <title> Decidability and Expressiveness Aspects of Logic Queries, </title> <booktitle> Proc. 6th ACM Symp. on Principles of Database Systems (1987), </booktitle> <pages> 237-249. </pages>
Reference-contexts: In contrast, uniform equivalence of Datalog programs is decidable [S88] (first shown in [CK86] for one IDB predicate), while predicate equivalence is undecidable <ref> [Sh87] </ref>.
Reference: [U89] <author> J.D. Ullman, </author> <title> Principles of Database and Knowledge Base Systems: Volumes I,II, </title> <publisher> Computer Science Press 1989. </publisher>
Reference-contexts: 1 Introduction It has been realized for some time that first-order database query languages are lacking in expressive power. This has led to the study of Datalog programs <ref> [K90, U89] </ref>, which combine positive existential first-order formulas with recursion|see [CH85]. Analyzing the depth of recursion of these database logic programs has emerged as a fundamental problem, e.g., for parallel evaluation [CK86, K88, UV88] or for optimization [N89b]. <p> Because of the use of the halting rule, I 2 P h+2 (D). 2 We remark that the embedding described in the above proof is in fact a containment mapping (see <ref> [U89] </ref>) between conjunctive queries: any (h + 2)-fold unwinding of P into a conjunctive query can be mapped into any t-fold unwinding, for t h + 2.
Reference: [UV88] <author> J.D. Ullman, A. Van Gelder, </author> <title> Parallel Complexity of Logical Query Programs, </title> <journal> Algorithmica, </journal> <volume> 3 (1988), </volume> <pages> 5-42. </pages>
Reference-contexts: This has led to the study of Datalog programs [K90, U89], which combine positive existential first-order formulas with recursion|see [CH85]. Analyzing the depth of recursion of these database logic programs has emerged as a fundamental problem, e.g., for parallel evaluation <ref> [CK86, K88, UV88] </ref> or for optimization [N89b].
Reference: [V88] <author> M.Y. Vardi, </author> <title> Decidability and Undecidability Results for Boundedness of Linear Recursive Queries, </title> <booktitle> Proc. 7th ACM Symp. on Principles of Database Systems (1988), </booktitle> <pages> 341-351. </pages>
Reference-contexts: Datalog boundedness (i.e., whether the depth of recursion of a given program is a con stant independent of the input database) is interesting because it is the simplest case of fl The results presented here appeared in preliminary form in <ref> [V88] </ref> (Section 2 of this paper) and [HKMV91] (Sections 3-6 and the appendix of this paper). y Dept. of Computer Science, Brown University, Providence, RI 02912. Supported by ONR grant N00014 83-K-0146 ARPA Order No. 6320-1. z Dept. of Computer Science, Brown University, Providence, RI 02912. <p> Predicate boundedness (and thus program and uniform boundedness as well) is shown to be decidable for monadic programs in [CGKV88], which also contains a partial analysis of the complexity of this decision problem (see also [M90]). Decision procedures are possible in some other special cases: e.g., <ref> [V88] </ref> shows the NP-completeness of the boundedness problem for arity 2 programs with one linear rule; also for chain rules and some of their generalizations we have decidability through context-free language finiteness tests [G90]. <p> the number of rules classification: (1) Is uniform boundedness decidable for linear single rule programs? Note that, linear, arity 4 is NP-hard [K88]; non-linear is also open. (2) Is program boundedness decidable for one linear rule, any initialization rules and any arity predicates? Note that, linear, arity 2 is NP-complete <ref> [V88] </ref>; some sufficient conditions for decidability appear in [HKMV91]; without linearity the problem is undecidable [A89]. Appendix: Ternary Datalog via the Halting Problem In this appendix, we give a proof of the undecidability of uniform boundedness for ternary Datalog programs along the lines of [GMSV87].
References-found: 25

