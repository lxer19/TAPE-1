URL: ftp://ftp.cs.columbia.edu/reports/reports-1991/cucs-022-91.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1991.html
Root-URL: http://www.cs.columbia.edu
Title: Rule Chaining in Marvel: Dynamic Binding of Parameters  
Author: George T. Heineman Gail E. Kaiser Naser S. Barghouti Israel Z. Ben-Shaul 
Keyword: Programming-in-the-large, reasoning techniques, lifecycle support, experience report. c fl1991, Heineman, Kaiser, Barghouti, Ben-Shaul  
Note: Barghouti and Heineman are supported in part by the Center for Telecommunications Research. Kaiser is supported by National Science Foundation grants CCR-9000930, CDA-8920080 and CCR-8858029, by grants from AT&T, BNR, DEC, IBM, SRA and Xerox, by the New York State Center for Advanced Technology on Computer and Information Systems and by the NSF Engineering Research Center for Telecommunications Research. Ben-Shaul is supported in part by the Center for Advanced Technology.  
Date: May 6, 1991  
Pubnum: CUCS-022-91  
Abstract: Marvel is a rule-based development environment (RBDE) that assists in the development of software projects. Marvel encapsulates each software development activity in a rule that specifies the condition for invoking the activity and its effects on the components of the project under development. These components are abstracted as objects and stored in a persistent object database. Each rule applies to a specific class of objects, which is specified as the parameter of the rule. Firing a rule entails binding its formal parameter to a specific object. If the rule changes the object in such a way that the conditions of other rules become satisfied, these other rules are automatically fired. A problem arises in this forward chaining model when the classes of the objects manipulated by the rules are different. Marvel has to determine which object to bind to the parameter of each rule in the chain, based on the object manipulated by the original rule that initiated the chain. We describe a heuristic approach for solving this problem in the current Marvel implementation and introduce an algorithmic approach that does better. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> V. Ambriola, P. Ciancarini, and Montanegro C. </author> <title> Software Process Enactment in Oikos. </title> <booktitle> In Fourth ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 183-192, </pages> <address> Irvine CA, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: If Marvel allowed effects to be asserted on derived parameters, then backward chaining would also be affected by the chaining problem. As it stands, however, Marvel's backward chaining cycle, like Prolog unification, is straightforward. Oikos <ref> [1] </ref> extends a Darwin-like system to more complicated control structures among rules, but uses a blackboard scheme that passes all necessary information from one blackboard to another directly, thus bypassing the chaining problem.
Reference: [2] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Modeling Concurrency in Rule-Based Development Environments. </title> <journal> IEEE Expert, </journal> <volume> 5(6) </volume> <pages> 15-27, </pages> <month> December </month> <year> 1990. </year>
Reference-contexts: Marvel provides automated assistance by applying forward and backward chaining among the rules in order to automatically invoke activities that are parts of the development process. One distinguishing feature of Marvel is its integration of object-oriented data modeling and rule-based process modeling <ref> [2] </ref>. Each development activity on the components of the project under development is modeled as a rule that specifies the condition for invoking the activity and the effect of the activity on the components. The project's components are modeled as objects and stored in a persistent object database.
Reference: [3] <author> G. M. Clemm. </author> <title> The Workshop System A Practical Knowledge-Based Software Environment. </title> <booktitle> In ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 55-64, </pages> <address> Boston, </address> <month> November </month> <year> 1988. </year> <journal> ACM Press. Special issue of SIGPLAN Notices, </journal> <volume> 24(2), </volume> <month> February </month> <year> 1989. </year>
Reference-contexts: Odin <ref> [3] </ref>, AP5 [4] and OPS5 systems have rules that are triggers activated when the state of the object database changes. The chaining problem does not appear under this data-driven 9 approach, since there is no specified flow of control. Rule-based database systems like post--gres [16] work in a similar fashion.
Reference: [4] <author> D. Cohen. </author> <title> Compiling complex database transition triggers. </title> <booktitle> In 1989 ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 225-234, </pages> <address> Portland OR, </address> <month> June </month> <year> 1989. </year> <journal> Special issue of SIGMOD Record, </journal> <volume> 18(2), </volume> <month> June </month> <year> 1989. </year>
Reference-contexts: The reader should observe that if there were no derived parameters, this problem would not exist, for the conditions and effects of a rule would be based solely on the formal parameter. Marvel, like AP5 <ref> [4] </ref> and other systems, allows for rules to have derived parameters by using existential and universal operators to bind quantified parameters to certain objects based on arbitrary logical expressions. Figure 2 shows some rules in the Msl language. <p> Odin [3], AP5 <ref> [4] </ref> and OPS5 systems have rules that are triggers activated when the state of the object database changes. The chaining problem does not appear under this data-driven 9 approach, since there is no specified flow of control. Rule-based database systems like post--gres [16] work in a similar fashion.
Reference: [5] <editor> Umeshwar Dayal et al. </editor> <title> Simplifying complex objects: The probe approach to modeling and querying them. </title> <editor> In Stanley B. Zdonik and David Maier, editors, </editor> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <pages> pages 390-399, </pages> <publisher> Morgan Kaufmann, Inc., </publisher> <year> 1990. </year> <month> 10 </month>
Reference-contexts: Rule-based database systems like post--gres [16] work in a similar fashion. The composite-object hierarchy allows Marvel to make efficient navigational queries to the object database; in addition, the algorithmic approach outlined in section 6 is dependent on this structure, since this makes an efficient inversion process. The probe DBMS <ref> [5] </ref> provides for queries on object databases, and outlines some methods for optimization.
Reference: [6] <author> Deborah Frincke, Myla Archer, and Karl Levitt. </author> <title> A Planning System for the Intelligent Testing of Secure Software. </title> <booktitle> In Knowledge-Based Software Assistant KBSA-5, </booktitle> <pages> pages 346-360, </pages> <address> Liverpool NY, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: We are currently investigating the implementation of the logic-based inversion method. 7 Related Work There are many other systems that support intelligent assistance; we focus on those systems that execute some form of chaining to perform this assistance. EPOS [14] and TPLAN <ref> [6] </ref> attempt to achieve subgoals (backward chaining) when the condition for an invoked rule is not satisfied. Darwin [15] carries out inferencing to determine whether or not an activity is allowed. These kind of systems perform strictly backward chaining, and are usually Prolog-based.
Reference: [7] <author> Mark Gisi and Gail E. Kaiser. </author> <title> Extending A Tool Integration Language (Experience Report). </title> <type> Technical Report CUCS-014-91, </type> <institution> Columbia University Department of Computer Science, </institution> <month> April </month> <year> 1991. </year> <note> Submitted for publication. </note>
Reference-contexts: Marvel binds the failed object to r i 's formal parameter since effects are restricted to be based on the formal parameter. Once r's condition is satisfied, Marvel executes r's activity with the necessary information (see <ref> [7] </ref> for a full description of this process) and selects the proper effect to assert as determined by the result of this execution. For every predicate p in this effect, Marvel asserts it on the object database and collects those rules from the rule network that may now be satisfied.
Reference: [8] <editor> C. Godart, F. Charoy, and J.C. Derniame. </editor> <booktitle> Computer Assisted Software Engineering: Char-acterisation and Modeling. </booktitle> <address> ICCI 89 Toronto, </address> <year> 1989. </year>
Reference-contexts: The merlin [9] system has both backward and forward chaining capabilities, but it avoids the chaining problem; backward chaining is resolved through Prolog-style unification, while forward chaining explicitly lists the parameters (much like a blackboard scheme) that are passed from one rule to the next. alf <ref> [8] </ref> has forward chaining capabilities, but the paper does not state how it determines parameters. grapple [10] is exceptional, in that it explicitly addresses the parameter issue that arises in chaining between rules.
Reference: [9] <author> H. Hunnekens and G. Junkermann and B. Peuschel and W. Schafer, J. Vagts. </author> <title> A Step Towards Knowledge-based Software Process Modeling. </title> <booktitle> In 1st Conference on System Development Environments and Factories (SDE&F 1). </booktitle> <publisher> Pitman Publishing, </publisher> <address> London, </address> <year> 1990. </year>
Reference-contexts: As it stands, however, Marvel's backward chaining cycle, like Prolog unification, is straightforward. Oikos [1] extends a Darwin-like system to more complicated control structures among rules, but uses a blackboard scheme that passes all necessary information from one blackboard to another directly, thus bypassing the chaining problem. The merlin <ref> [9] </ref> system has both backward and forward chaining capabilities, but it avoids the chaining problem; backward chaining is resolved through Prolog-style unification, while forward chaining explicitly lists the parameters (much like a blackboard scheme) that are passed from one rule to the next. alf [8] has forward chaining capabilities, but the
Reference: [10] <author> K. E. Huff and V. R. Lesser. </author> <title> A Plan-based Intelligent Assistant that Supports the Software Development Process. </title> <booktitle> In ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 97-106, </pages> <address> Boston, MA, </address> <month> November </month> <year> 1988. </year> <journal> Special issue of SIGPLAN Notices, </journal> <volume> 24(2), </volume> <month> February </month> <year> 1989. </year>
Reference-contexts: If the system assumes that rule chaining occurs in a localized area in the object database, then the search space can be kept small. As an alternative to searching, the system could also use a set of axioms (as put forth in grapple <ref> [10] </ref>) to determine legal choices for the parameter. In Marvel we have implemented a set of heuristics to search "near" an object to determine the proper objects to use during chaining. <p> it avoids the chaining problem; backward chaining is resolved through Prolog-style unification, while forward chaining explicitly lists the parameters (much like a blackboard scheme) that are passed from one rule to the next. alf [8] has forward chaining capabilities, but the paper does not state how it determines parameters. grapple <ref> [10] </ref> is exceptional, in that it explicitly addresses the parameter issue that arises in chaining between rules. Odin [3], AP5 [4] and OPS5 systems have rules that are triggers activated when the state of the object database changes.
Reference: [11] <author> Gail E. Kaiser, Naser S. Barghouti, Peter H. Feiler, and Robert W. Schwanke. </author> <title> Database Support for Knowledge-Based Engineering Environments. </title> <journal> IEEE Expert, </journal> <volume> 3(2) </volume> <pages> 18-32, </pages> <month> Summer </month> <year> 1988. </year>
Reference-contexts: In this paper, we describe the chaining problem and explain how it is solved in the current implementation of Marvel. We describe Marvel, detailing only those aspects necessary to understand the chaining problem and our solutions; for a more complete description of Marvel, see <ref> [12, 13, 11] </ref>. We next explain the chaining problem in detail with a motivating example. We describe a heuristic approach to solving this problem and discuss its implementation in the current Marvel system.
Reference: [12] <author> Gail E. Kaiser, Naser S. Barghouti, and Michael H. Sokolsky. </author> <title> Experience with Process Modeling in the Marvel Software Development Environment Kernel. </title> <editor> In Bruce Shriver, editor, </editor> <booktitle> 23rd Annual Hawaii International Conference on System Sciences, </booktitle> <volume> volume II, </volume> <pages> pages 131-140, </pages> <address> Kona HI, </address> <month> January </month> <year> 1990. </year>
Reference-contexts: In this paper, we describe the chaining problem and explain how it is solved in the current implementation of Marvel. We describe Marvel, detailing only those aspects necessary to understand the chaining problem and our solutions; for a more complete description of Marvel, see <ref> [12, 13, 11] </ref>. We next explain the chaining problem in detail with a motivating example. We describe a heuristic approach to solving this problem and discuss its implementation in the current Marvel system.
Reference: [13] <author> Gail E. Kaiser, Peter H. Feiler, and Steven S. Popovich. </author> <title> Intelligent Assistance for Software Development and Maintenance. </title> <journal> IEEE Software, </journal> <volume> 5(3) </volume> <pages> 40-49, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: In this paper, we describe the chaining problem and explain how it is solved in the current implementation of Marvel. We describe Marvel, detailing only those aspects necessary to understand the chaining problem and our solutions; for a more complete description of Marvel, see <ref> [12, 13, 11] </ref>. We next explain the chaining problem in detail with a motivating example. We describe a heuristic approach to solving this problem and discuss its implementation in the current Marvel system.
Reference: [14] <author> Chunnian Liu. </author> <title> Software Process Planning and Execution: Coupling vs. Integration. </title> <type> Technical report, </type> <institution> Norwegian Institute of Technology (NTH), </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: We are currently investigating the implementation of the logic-based inversion method. 7 Related Work There are many other systems that support intelligent assistance; we focus on those systems that execute some form of chaining to perform this assistance. EPOS <ref> [14] </ref> and TPLAN [6] attempt to achieve subgoals (backward chaining) when the condition for an invoked rule is not satisfied. Darwin [15] carries out inferencing to determine whether or not an activity is allowed. These kind of systems perform strictly backward chaining, and are usually Prolog-based.
Reference: [15] <author> N. H. Minsky and D. Rozenshtein. </author> <title> A Software Development Environment for Law-Governed Systems. </title> <booktitle> In ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 65-75, </pages> <address> Boston MA, </address> <month> November </month> <year> 1988. </year>
Reference-contexts: EPOS [14] and TPLAN [6] attempt to achieve subgoals (backward chaining) when the condition for an invoked rule is not satisfied. Darwin <ref> [15] </ref> carries out inferencing to determine whether or not an activity is allowed. These kind of systems perform strictly backward chaining, and are usually Prolog-based. The unification scheme in Prolog successfully determines parameters to match because the body of Prolog clauses have no quantified expressions like those in Msl.
Reference: [16] <author> Michael Stonebraker and Lawrence A. Rowe. </author> <title> The Design of postgres. </title> <editor> In Carlo Zaniolo, editor, </editor> <booktitle> 1989 ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 340-355, </pages> <address> Washington DC, </address> <month> May </month> <year> 1986. </year> <journal> Special issue of SIGMOD Record, </journal> <volume> 18(2), </volume> <month> June </month> <year> 1989. </year> <month> 11 </month>
Reference-contexts: Odin [3], AP5 [4] and OPS5 systems have rules that are triggers activated when the state of the object database changes. The chaining problem does not appear under this data-driven 9 approach, since there is no specified flow of control. Rule-based database systems like post--gres <ref> [16] </ref> work in a similar fashion. The composite-object hierarchy allows Marvel to make efficient navigational queries to the object database; in addition, the algorithmic approach outlined in section 6 is dependent on this structure, since this makes an efficient inversion process.
References-found: 16

