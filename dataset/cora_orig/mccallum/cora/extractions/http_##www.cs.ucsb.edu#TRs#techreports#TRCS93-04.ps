URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS93-04.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Efficient Implementation of Synchronous Communication Over Asynchronous Networks  
Author: Manhoi Choy and Ambuj K. Singh 
Keyword: Concurrency, Distributed Algorithms, Fairness, Synchronization.  
Address: Santa Barbara, California 93106  
Affiliation: Department of Computer Science University of California at Santa Barbara  
Abstract: The implementation of synchronous communication primitives over asynchronous message-passing networks is investigated. Efficient algorithms are presented for the committee coordination problem and its more dynamic version called the first-order interaction problem. A new notion of strong fairness called 1-sf and algorithms achieving it are described. It is further shown that any stronger notion of fairness cannot be implemented. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. R. Apt, N. Francez, and S. Katz. </author> <title> Appraising fairness in languages for distributed programming. </title> <journal> Distributed Computing, </journal> <volume> 2 </volume> <pages> 226-241, </pages> <year> 1988. </year>
Reference-contexts: We explore, 1-sf , the only remaining condition, in the remainder of this section. First, we prove that 1-sf is an adequate notion of fairness <ref> [1] </ref>. Next, we present algorithms achieving 1-sf for both binary and general interactions. 3.2 Adequacy of 1-sf Apt, Francez, and Katz [1] have suggested a number of criteria appraising fairness notions under different models of computations. These criteria include feasibility, equivalence robustness, and liveness enhancing. <p> We explore, 1-sf , the only remaining condition, in the remainder of this section. First, we prove that 1-sf is an adequate notion of fairness <ref> [1] </ref>. Next, we present algorithms achieving 1-sf for both binary and general interactions. 3.2 Adequacy of 1-sf Apt, Francez, and Katz [1] have suggested a number of criteria appraising fairness notions under different models of computations. These criteria include feasibility, equivalence robustness, and liveness enhancing. <p> Fairness notion F is liveness enhancing if there is a program P such that some progress properties (such as program termination) can not be proved without F in the model of computation under consideration. A fairness notion is called adequate <ref> [1] </ref> if it satisfies all these three criteria. It can be shown that 1-sf is adequate for the multi-party interaction problem under the asynchronous message passing system model. We only sketch the proofs of these properties. The ideas behind these proofs are essentially from [1]. <p> A fairness notion is called adequate <ref> [1] </ref> if it satisfies all these three criteria. It can be shown that 1-sf is adequate for the multi-party interaction problem under the asynchronous message passing system model. We only sketch the proofs of these properties. The ideas behind these proofs are essentially from [1]. To show that 1-sf satisfies feasibility, we construct an explicit scheduler that satisfies the following two requirements. 1. For any program P , any legal computation of P can be generated by the scheduler. 2. <p> Then, we considered 1-sf . We showed that for the case of binary interactions, 1-sf is equivalent to SPF , the only kind of fairness shown to be implementable. Then, we showed that 1-sf is feasible, equivalence robust, and liveness enhancing and consequently, an adequate notion of fairness <ref> [1] </ref>. Finally, we presented algorithms that implement 1-sf for both binary and general interactions. Both the algorithms were constructed by combining an underlying solution to the dining philosophers problem with a queuing mechanism at each process. The former ensured WIF and the latter ensured 1-sf .
Reference: [2] <author> P. C. Attie, N. Francez, and O. Grumberg. </author> <title> Fairness and hyperfairness in multi-party interactions. </title> <booktitle> In Proceedings of the 8th Annual ACM Symposium Principles of Programming Languages, </booktitle> <pages> pages 292-305, </pages> <year> 1990. </year>
Reference-contexts: The progress requirement in both the zeroth-order and the first-order interaction problem is one of weak fairness: any continuously ready interaction should be committed. Stronger notions of fairness have been investigated for these problems <ref> [2, 11, 24] </ref>. Existing classification of fairness notions for interactions is along two orthogonal directions: the subject of fairness and the level of fairness [2, 11]. A subject may be a process, a group of processes, or an interaction. The level of fairness may be weak, strong, and unconditional. <p> Stronger notions of fairness have been investigated for these problems [2, 11, 24]. Existing classification of fairness notions for interactions is along two orthogonal directions: the subject of fairness and the level of fairness <ref> [2, 11] </ref>. A subject may be a process, a group of processes, or an interaction. The level of fairness may be weak, strong, and unconditional. This gives us a combination of nine types of fairness notions: weak process fairness, weak group fairness, weak interaction fairness, strong process fairness, etc. <p> This proves the following theorem. Theorem 3 SGF and SIF are not implementable for the binary (and hence general) interaction problem. From this impossibility result, one can also show that SPF <ref> [2] </ref> is not implementable for general interactions. For this proof, we add one extra process r 0 to interaction K. Process r 0 is continuously ready.
Reference: [3] <author> R. J. R. Back and R. Kurki-Suonio. </author> <title> Distributed cooperation with action systems. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(4) </volume> <pages> 513-554, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction Design and implementation of efficient inter-process communication primitives is an important goal for parallel and distributed systems. This paper investigates the case of synchronous communication primitives. These primitives occur in languages such as Ada [17] and CSP [5], and programming paradigms such as Shared Actions [20], Joint Actions <ref> [3] </ref>, Raddle [10], IP [12], and Script [13]. The basic form of synchronous communication, supported by Ada and CSP, allows process synchronization only between two processes. This kind of primitive has been later generalized to allow communication and synchronization between an arbitrary number of processes [3, 10, 20]. <p> The basic form of synchronous communication, supported by Ada and CSP, allows process synchronization only between two processes. This kind of primitive has been later generalized to allow communication and synchronization between an arbitrary number of processes <ref> [3, 10, 20] </ref>.
Reference: [4] <author> R. L. Bagrodia and Y. Tsay. </author> <title> An efficient algorithm for fair interprocess synchronization. </title> <type> Unpublished Manuscript. </type> <year> 1989. </year>
Reference-contexts: Fault-tolerance of our algorithm can be improved by choosing a suitable fault-tolerant dining philosophers algorithm [7]. Restrictions Authors/Algorithms Response time Message Complexity Buckley and Silberschatz [5] O (N -) O (k) m = 2 Sistla [21] O (k 3 (t c + -)) O (k) Bagrodia and Tsay <ref> [4] </ref> O (k 2 -) O (k) Tsay and Bagrodia [23] O (k 2 -) O (k) Our algorithm O (k 2 -) O (k) Kumar [15] O (N -) O (km) Arbitrary Park and Kim [18] O (N -) O (km) m Ramesh [19] O (N -) O (km) Our <p> The message complexity of all the three algorithms is O (k). It should be noted that the response time bound of Algorithm 2 is of the same order of magnitude as the best known algorithms <ref> [4, 23] </ref> satisfying the weaker requirement of WIF . 3.5 1-sf for General Interactions The algorithm for the case of general interactions is once more composed of two phases: a first phase in which processes attempt commitment directly with each other and a second phase in which processes attempt commitment with
Reference: [5] <author> G. N. Buckley and A. Silberschatz. </author> <title> An effective implementation for the generalized input-output construct of CSP. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(2) </volume> <pages> 223-235, </pages> <year> 1982. </year>
Reference-contexts: 1 Introduction Design and implementation of efficient inter-process communication primitives is an important goal for parallel and distributed systems. This paper investigates the case of synchronous communication primitives. These primitives occur in languages such as Ada [17] and CSP <ref> [5] </ref>, and programming paradigms such as Shared Actions [20], Joint Actions [3], Raddle [10], IP [12], and Script [13]. The basic form of synchronous communication, supported by Ada and CSP, allows process synchronization only between two processes. <p> This improves the fault-tolerance of their algorithm. Fault-tolerance of our algorithm can be improved by choosing a suitable fault-tolerant dining philosophers algorithm [7]. Restrictions Authors/Algorithms Response time Message Complexity Buckley and Silberschatz <ref> [5] </ref> O (N -) O (k) m = 2 Sistla [21] O (k 3 (t c + -)) O (k) Bagrodia and Tsay [4] O (k 2 -) O (k) Tsay and Bagrodia [23] O (k 2 -) O (k) Our algorithm O (k 2 -) O (k) Kumar [15] O
Reference: [6] <author> K. M. Chandy and J. Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley Pub. Co., </publisher> <address> Reading, Mass., </address> <year> 1988. </year>
Reference-contexts: This kind of primitive has been later generalized to allow communication and synchronization between an arbitrary number of processes [3, 10, 20]. This general setting has been abstracted by Chandy and Misra <ref> [6] </ref> as the Committee Coordination problem: each professor in a university serves on one or more committees, each committee has a fixed set of members who may be waiting to convene a committee from time to time, and a committee cannot convene until all its members are present. <p> interaction fairness requires that if a set of processes that can fulfill all the roles of an interaction is continuously ready then an instance of the interaction consisting of some processes in the set will be committed eventually. 2.2 An Algorithm We use a technique due to Chandy and Misra <ref> [6] </ref> and solve the first-order interaction problem by transforming the problem to the dining philosophers problem [16]. The zeroth-order interaction problem is also solved as a result since it is a restriction of the first-order interaction problem. To begin, we give a brief account of the dining philosophers problem.
Reference: [7] <author> M. Choy and A. K. Singh. </author> <title> Efficient fault tolerant algorithms for resource allocation in distributed systems. </title> <booktitle> In Proceedings of the 21th Annual ACM Symposium on Theory of Computing, </booktitle> <year> 1992. </year> <month> 22 </month>
Reference-contexts: of an eating session of a philosopher, for any set of processes Q Readyset 6 that fulfills all the roles of the corresponding interaction, some process in Q becomes non--ready.) 2 In order to compare our algorithms to existing solutions, we choose a dining philosophers algorithms presented by us in <ref> [7] </ref>. For this algorithm, f (ffi) = g (ffi) = O (ffi 2 ) and M (ffi) = O (ffi). From the transformation used in Algorithm 1, ffi km, where k = max p jI (p)j and m is as defined earlier. <p> This improves the fault-tolerance of their algorithm. Fault-tolerance of our algorithm can be improved by choosing a suitable fault-tolerant dining philosophers algorithm <ref> [7] </ref>. <p> The proof of the message complexity bound follows as at most 4 messages are sent in the first phase and at most 10 messages are sent in the second phase per eating period. 2 If we use the algorithm presented by us in <ref> [7] </ref> as the underlying dining philosophers algorithm (f (ffi) = g (ffi) = O (ffi 2 ) and M (ffi) = O (ffi)) then the response time of the composite algorithm is O (k 2 -) and the message complexity of the composite algorithm is O (k). <p> Therefore, a philosopher f p I has at most (m 1) fl km edges. Consequently, the degree of the conflict graph is at most m fl (km 1). If we use the algorithm presented by us in <ref> [7] </ref> as the underlying dining philosophers algorithm (f (ffi) = g (ffi) = O (ffi 2 ) and M (ffi) = O (ffi)) then the response time of the composite algorithm is O (m 4 k 2 -) and the message complexity of the composite algorithm is O (m 3 k).
Reference: [8] <author> M. Choy and A. K. Singh. </author> <title> Tight lower bounds on failure locality of distributed syn-chronization. </title> <booktitle> In Proceedings of the Thirtieth Annual Allerton Conference on Communication, Control, and Computing, </booktitle> <year> 1992. </year>
Reference: [9] <author> M. J. Fischer, N. A. Lynch, and M. S. Paterson. </author> <title> Impossibility of distributed consensus with one faulty process. </title> <journal> J. ACM, </journal> <volume> 32(2) </volume> <pages> 374-382, </pages> <year> 1985. </year>
Reference: [10] <author> I. R. </author> <title> Forman. </title> <booktitle> On the design of large distributed systems. In Proceedings of the First International Conference on Computer Languages, </booktitle> <pages> pages 84-95, </pages> <address> Miami, Florida, </address> <year> 1986. </year>
Reference-contexts: This paper investigates the case of synchronous communication primitives. These primitives occur in languages such as Ada [17] and CSP [5], and programming paradigms such as Shared Actions [20], Joint Actions [3], Raddle <ref> [10] </ref>, IP [12], and Script [13]. The basic form of synchronous communication, supported by Ada and CSP, allows process synchronization only between two processes. This kind of primitive has been later generalized to allow communication and synchronization between an arbitrary number of processes [3, 10, 20]. <p> The basic form of synchronous communication, supported by Ada and CSP, allows process synchronization only between two processes. This kind of primitive has been later generalized to allow communication and synchronization between an arbitrary number of processes <ref> [3, 10, 20] </ref>.
Reference: [11] <author> N. Francez. </author> <title> Fairness. </title> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: The progress requirement in both the zeroth-order and the first-order interaction problem is one of weak fairness: any continuously ready interaction should be committed. Stronger notions of fairness have been investigated for these problems <ref> [2, 11, 24] </ref>. Existing classification of fairness notions for interactions is along two orthogonal directions: the subject of fairness and the level of fairness [2, 11]. A subject may be a process, a group of processes, or an interaction. The level of fairness may be weak, strong, and unconditional. <p> Stronger notions of fairness have been investigated for these problems [2, 11, 24]. Existing classification of fairness notions for interactions is along two orthogonal directions: the subject of fairness and the level of fairness <ref> [2, 11] </ref>. A subject may be a process, a group of processes, or an interaction. The level of fairness may be weak, strong, and unconditional. This gives us a combination of nine types of fairness notions: weak process fairness, weak group fairness, weak interaction fairness, strong process fairness, etc.
Reference: [12] <author> N. Francez and I. R. Forman. </author> <title> Interacting Processes: A Multiparty Approach to Coordinated Distributed Programming. </title> <publisher> Forthcoming book, </publisher> <year> 1990. </year>
Reference-contexts: This paper investigates the case of synchronous communication primitives. These primitives occur in languages such as Ada [17] and CSP [5], and programming paradigms such as Shared Actions [20], Joint Actions [3], Raddle [10], IP <ref> [12] </ref>, and Script [13]. The basic form of synchronous communication, supported by Ada and CSP, allows process synchronization only between two processes. This kind of primitive has been later generalized to allow communication and synchronization between an arbitrary number of processes [3, 10, 20].
Reference: [13] <author> N. Francez, B. Hailpern, and G. G. Taubenfeld. </author> <title> Script: A communication abstraction mechanism. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 6(1) </volume> <pages> 35-88, </pages> <year> 1986. </year>
Reference-contexts: This paper investigates the case of synchronous communication primitives. These primitives occur in languages such as Ada [17] and CSP [5], and programming paradigms such as Shared Actions [20], Joint Actions [3], Raddle [10], IP [12], and Script <ref> [13] </ref>. The basic form of synchronous communication, supported by Ada and CSP, allows process synchronization only between two processes. This kind of primitive has been later generalized to allow communication and synchronization between an arbitrary number of processes [3, 10, 20].
Reference: [14] <author> Y. J. Joung and S.A. Smolka. </author> <title> Coordinating first-order multiparty interactions. </title> <booktitle> In Proceedings of the 8th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 209-220, </pages> <year> 1991. </year>
Reference-contexts: A solution to the problem should ensure that committees with common members are not scheduled at the same time and that a committee that is continuously ready is eventually scheduled. The first-order interaction problem <ref> [14] </ref> is a variation of the committee coordination problem that provides some degree of dynamism. In contrast to committees (henceforth called zeroth-order interactions) where the participants are fixed in advance, first-order interactions support dynamically varying sets of participants. <p> Consequently, the resulting solution to the first-order interaction problem has a response time of O (k 2 m 2 -) and a message complexity of O (km). The algorithm by Joung and Smolka <ref> [14] </ref> has a response time of O (N -), where N is the total number of interactions in the system, and the number of messages sent is 6m per process per interaction. <p> The message complexities are incomparable as more than one instance of an interaction can be committed by a single coordinator in our algorithm. As opposed to our algorithm where the coordinators are fixed in advance, the algorithm by Joung and Smolka <ref> [14] </ref> chooses coordinators dynamically from the set of ready processes. This improves the fault-tolerance of their algorithm. Fault-tolerance of our algorithm can be improved by choosing a suitable fault-tolerant dining philosophers algorithm [7].
Reference: [15] <author> D. Kumar. </author> <title> An algorithm for N-party synchronization using tokens. </title> <booktitle> In Proceedings of the 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 320-327, </pages> <year> 1990. </year>
Reference-contexts: Silberschatz [5] O (N -) O (k) m = 2 Sistla [21] O (k 3 (t c + -)) O (k) Bagrodia and Tsay [4] O (k 2 -) O (k) Tsay and Bagrodia [23] O (k 2 -) O (k) Our algorithm O (k 2 -) O (k) Kumar <ref> [15] </ref> O (N -) O (km) Arbitrary Park and Kim [18] O (N -) O (km) m Ramesh [19] O (N -) O (km) Our algorithm O (k 2 m 2 -) O (km) Here, m is the number of processes required to execute an interaction, k is the number of
Reference: [16] <author> N. Lynch. </author> <title> Fast allocation of nearby resources in a distributed system. </title> <booktitle> In Proceedings of the 12th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 70-81, </pages> <year> 1980. </year>
Reference-contexts: an interaction is continuously ready then an instance of the interaction consisting of some processes in the set will be committed eventually. 2.2 An Algorithm We use a technique due to Chandy and Misra [6] and solve the first-order interaction problem by transforming the problem to the dining philosophers problem <ref> [16] </ref>. The zeroth-order interaction problem is also solved as a result since it is a restriction of the first-order interaction problem. To begin, we give a brief account of the dining philosophers problem.
Reference: [17] <author> United States Department of Defense. </author> <title> Reference manual for the Ada programming language. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: 1 Introduction Design and implementation of efficient inter-process communication primitives is an important goal for parallel and distributed systems. This paper investigates the case of synchronous communication primitives. These primitives occur in languages such as Ada <ref> [17] </ref> and CSP [5], and programming paradigms such as Shared Actions [20], Joint Actions [3], Raddle [10], IP [12], and Script [13]. The basic form of synchronous communication, supported by Ada and CSP, allows process synchronization only between two processes.
Reference: [18] <author> M. H. Park and M. Kim. </author> <title> A distributed synchronization scheme for fair multi-process handshakes. </title> <journal> Information Processing Letters, </journal> (24):131-138, 1990. 
Reference-contexts: Sistla [21] O (k 3 (t c + -)) O (k) Bagrodia and Tsay [4] O (k 2 -) O (k) Tsay and Bagrodia [23] O (k 2 -) O (k) Our algorithm O (k 2 -) O (k) Kumar [15] O (N -) O (km) Arbitrary Park and Kim <ref> [18] </ref> O (N -) O (km) m Ramesh [19] O (N -) O (km) Our algorithm O (k 2 m 2 -) O (km) Here, m is the number of processes required to execute an interaction, k is the number of interactions in which a process may participate, N is the
Reference: [19] <author> S. Ramesh. </author> <title> A new and efficient implementation of multiprocess synchronization. </title> <booktitle> In PARLE: Parallel Architectures and Languages Europe. Lecture Notes in Computer Sciences 259, </booktitle> <pages> pages 387-401, </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year>
Reference-contexts: -)) O (k) Bagrodia and Tsay [4] O (k 2 -) O (k) Tsay and Bagrodia [23] O (k 2 -) O (k) Our algorithm O (k 2 -) O (k) Kumar [15] O (N -) O (km) Arbitrary Park and Kim [18] O (N -) O (km) m Ramesh <ref> [19] </ref> O (N -) O (km) Our algorithm O (k 2 m 2 -) O (km) Here, m is the number of processes required to execute an interaction, k is the number of interactions in which a process may participate, N is the total number of interactions in the system, and
Reference: [20] <author> S. Ramesh and S. L. Mehndiratta. </author> <title> A methodology for developing distributed programs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(8) </volume> <pages> 967-976, </pages> <year> 1987. </year>
Reference-contexts: 1 Introduction Design and implementation of efficient inter-process communication primitives is an important goal for parallel and distributed systems. This paper investigates the case of synchronous communication primitives. These primitives occur in languages such as Ada [17] and CSP [5], and programming paradigms such as Shared Actions <ref> [20] </ref>, Joint Actions [3], Raddle [10], IP [12], and Script [13]. The basic form of synchronous communication, supported by Ada and CSP, allows process synchronization only between two processes. <p> The basic form of synchronous communication, supported by Ada and CSP, allows process synchronization only between two processes. This kind of primitive has been later generalized to allow communication and synchronization between an arbitrary number of processes <ref> [3, 10, 20] </ref>.
Reference: [21] <author> A. P. Sistla. </author> <title> Distributed algorithms for ensuring fair interprocess communications. </title> <booktitle> In Proceedings of the 3rd Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 266-277, </pages> <year> 1984. </year> <month> 23 </month>
Reference-contexts: This improves the fault-tolerance of their algorithm. Fault-tolerance of our algorithm can be improved by choosing a suitable fault-tolerant dining philosophers algorithm [7]. Restrictions Authors/Algorithms Response time Message Complexity Buckley and Silberschatz [5] O (N -) O (k) m = 2 Sistla <ref> [21] </ref> O (k 3 (t c + -)) O (k) Bagrodia and Tsay [4] O (k 2 -) O (k) Tsay and Bagrodia [23] O (k 2 -) O (k) Our algorithm O (k 2 -) O (k) Kumar [15] O (N -) O (km) Arbitrary Park and Kim [18] O <p> Strong fairness is difficult to implement. In fact the only kind of strong fairness that has been shown to be implementable is SPF for the case of binary interactions <ref> [21, 23] </ref>. Tsay and Bagrodia [24] have shown that SIF is not achievable even for binary interactions. <p> In comparison, the response time of the algorithms by Sistla <ref> [21] </ref> and Tsay and Bagrodia [23] is O (k 3 -). The message complexity of all the three algorithms is O (k).
Reference: [22] <author> E. Styer and G. Peterson. </author> <title> Improved algorithms for distributed resource allocation. </title> <booktitle> In Proceedings of the 7th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 105-116, </pages> <year> 1988. </year>
Reference: [23] <author> Y. Tsay and R. L. Bagrodia. </author> <title> A real-time algorithm for fair interprocess synchronization. </title> <booktitle> In Proceedings of the 12th International Conference on Distributed Computing Systems, </booktitle> <year> 1992. </year>
Reference-contexts: Restrictions Authors/Algorithms Response time Message Complexity Buckley and Silberschatz [5] O (N -) O (k) m = 2 Sistla [21] O (k 3 (t c + -)) O (k) Bagrodia and Tsay [4] O (k 2 -) O (k) Tsay and Bagrodia <ref> [23] </ref> O (k 2 -) O (k) Our algorithm O (k 2 -) O (k) Kumar [15] O (N -) O (km) Arbitrary Park and Kim [18] O (N -) O (km) m Ramesh [19] O (N -) O (km) Our algorithm O (k 2 m 2 -) O (km) Here, <p> Strong fairness is difficult to implement. In fact the only kind of strong fairness that has been shown to be implementable is SPF for the case of binary interactions <ref> [21, 23] </ref>. Tsay and Bagrodia [24] have shown that SIF is not achievable even for binary interactions. <p> In comparison, the response time of the algorithms by Sistla [21] and Tsay and Bagrodia <ref> [23] </ref> is O (k 3 -). The message complexity of all the three algorithms is O (k). <p> The message complexity of all the three algorithms is O (k). It should be noted that the response time bound of Algorithm 2 is of the same order of magnitude as the best known algorithms <ref> [4, 23] </ref> satisfying the weaker requirement of WIF . 3.5 1-sf for General Interactions The algorithm for the case of general interactions is once more composed of two phases: a first phase in which processes attempt commitment directly with each other and a second phase in which processes attempt commitment with
Reference: [24] <author> Y. Tsay and R. L. Bagrodia. </author> <title> Some impossibility results in interprocess synchronization. </title> <type> Technical Report CSD-890059, </type> <institution> Computer Science Department, UCLA, </institution> <year> 1989. </year> <month> 24 </month>
Reference-contexts: The progress requirement in both the zeroth-order and the first-order interaction problem is one of weak fairness: any continuously ready interaction should be committed. Stronger notions of fairness have been investigated for these problems <ref> [2, 11, 24] </ref>. Existing classification of fairness notions for interactions is along two orthogonal directions: the subject of fairness and the level of fairness [2, 11]. A subject may be a process, a group of processes, or an interaction. The level of fairness may be weak, strong, and unconditional. <p> This gives us a combination of nine types of fairness notions: weak process fairness, weak group fairness, weak interaction fairness, strong process fairness, etc. Though a number of algorithms achieving weak fairness conditions have been proposed, only a few algorithms exist for strong fairness. Furthermore, there exist impossibility results <ref> [24] </ref> showing that some kinds of strong fairness are not implementable. <p> Strong fairness is difficult to implement. In fact the only kind of strong fairness that has been shown to be implementable is SPF for the case of binary interactions [21, 23]. Tsay and Bagrodia <ref> [24] </ref> have shown that SIF is not achievable even for binary interactions. The impossibility result is proved by constructing an infinite history of three processes p; q; r that participate in three mutually conflicting binary interactions I= fp; qg, J = fq; rg, and K= fr; pg.
References-found: 24

