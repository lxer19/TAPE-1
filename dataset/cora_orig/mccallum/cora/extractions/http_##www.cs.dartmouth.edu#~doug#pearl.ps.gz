URL: http://www.cs.dartmouth.edu/~doug/pearl.ps.gz
Refering-URL: http://www.cs.dartmouth.edu/~doug/
Root-URL: http://www.cs.dartmouth.edu
Email: doug@cs.dartmouth.edu  
Title: Power Series, Power Serious  opened the serious here and beat them easy. Ring Lardner, You know  
Author: M. Douglas McIlroy 
Address: College, Hanover, New Hampshire 03755fl  
Affiliation: Dartmouth  
Note: J. Functional Programming 1 (1): 1-000, January 1998. Printed in the United Kingdom c 1998 Cambridge University Press  I  me Al  
Abstract: Power series and stream processing were made for each other. Stream algorithms for power series are short, sweet, and compositional. Their neatness shines through in Haskell, thanks to pattern-matching, lazy lists, and operator overloading. In a short compass one can build working code from ground zero (scalar operations) up to exact calculation of generating functions and solutions of differential equations. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Abelson, H. and Sussman, G. J. </author> <year> 1976. </year> <title> The Structure and Interpretation of Computer Programs. </title> <publisher> MIT Press. </publisher>
Reference: <author> Burge, W. H. </author> <year> 1975. </year> <title> Recursive Programming Techniques. </title> <publisher> Addison-Wesley Hehner, </publisher> <editor> E. C. R. </editor> <year> 1993. </year> <title> A Practical Theory of Programming. </title> <publisher> Springer-Verlag. </publisher>
Reference-contexts: of 30 zeros. take 30 (sinx - sqrt (1-cosx^2)) take 30 (sinx/cosx - revert (integral (1/(1+x^2)))) 6 Generating functions A generating function S for a sequence of numbers, s n , is S = n When the s n have suitable recursive definitions, the generating function satisfies related recursive equations <ref> (Burge, 1975) </ref>. Running these equations as stream algorithms, we can directly enumerate the values of s n . This lends concreteness to the term `generating function': when run as a program, a generating function literally generates its sequence. We illustrate with two familiar examples, binary trees and ordered trees.
Reference: <author> Kahn, G. and MacQueen, D. B. </author> <year> 1977. </year> <title> Coroutines and networks of parallel processes, </title> <editor> in Gilchrist, B. (Ed.), </editor> <booktitle> Information Processing 77, </booktitle> <pages> 993-998. </pages> <publisher> North Holland. </publisher>
Reference-contexts: Pedagogically, it well illustrates the intellectual clarity that streams can bring to software design. Above all, the method is powerful in its own right; it deserves to be taken serious. 8 Sources Kahn used a stream-processing system <ref> (Kahn and MacQueen 1977) </ref> for power-series algorithms like those given here; the work was not published. Abelson and Suss-man (1985) gave examples in Scheme. McIlroy (1990) covered most of the ground in a less perspicuous stream-processing language. Hehner (1993) demonstrated the technique in a formal setting.
Reference: <author> Knuth, D. E. </author> <year> 1968. </year> <booktitle> The Art of Computer Programming, </booktitle> <volume> Volume 1, </volume> <publisher> 2.3.4.4. Addison-Wesley. </publisher>
Reference-contexts: Hence T = 1 + xT 2 The Haskell equivalent is ts = 1 : ts^2 (The appealing code ts = 1 + x*ts^2 won't work. Why not? How does it differ from expx = 1 + (integral expx)?) Evaluating ts yields the Catalan numbers, as it should <ref> (Knuth 1968) </ref>: [1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, ... ] 10 M. Douglas McIlroy Ordered trees Consider next the generating function for nonempty ordered trees on n nodes. An n + 1-node tree, for n &gt;= 0, is made of a root and an n-node forest. <p> = 1 : list yields this value for tree: [0, 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, ... ] Catalan numbers again! The apparent identity between the number of binary trees on n nodes and the number of nonempty ordered trees on n +1 nodes is real <ref> (Knuth 1968) </ref>: a little algebra confirms that tree = xT . 7 Final remarks Stream processing can be beaten asymptotically if the goal is to find a given number of coefficients of a given series (Knuth 1969). In particular, multiplication involves convolution, which can be done faster by FFT.
Reference: <author> Knuth, D. E. </author> <year> 1969. </year> <booktitle> The Art of Computer Programming, </booktitle> <volume> Volume 2. </volume> <publisher> Addison-Wesley. </publisher>
Reference-contexts: n nodes and the number of nonempty ordered trees on n +1 nodes is real (Knuth 1968): a little algebra confirms that tree = xT . 7 Final remarks Stream processing can be beaten asymptotically if the goal is to find a given number of coefficients of a given series <ref> (Knuth 1969) </ref>. In particular, multiplication involves convolution, which can be done faster by FFT. Nevertheless, stream processing affords the cleanest way to manipulate power series. It has the advantage of incrementality-one can decide on the fly when to stop. And it is compositional.
Reference: <author> McIlroy, M. D. </author> <year> 1990. </year> <title> Squinting at power series. </title> <journal> Software-Practice and Experience, </journal> <volume> 20: </volume> <pages> 661-683. </pages>
Reference: <author> Pontryagin, L. S. </author> <year> 1962. </year> <title> Ordinary Differential equations. </title> <publisher> Addison-Wesley. </publisher>
References-found: 7

