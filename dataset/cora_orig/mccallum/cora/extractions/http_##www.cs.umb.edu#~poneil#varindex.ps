URL: http://www.cs.umb.edu/~poneil/varindex.ps
Refering-URL: http://www.cs.toronto.edu/~mendel/dwbib.html
Root-URL: 
Email: poneil@cs.umb.edu quass@cs.stanford.edu  
Title: Improved Query Performance with Variant Indexes  
Author: Patrick ONeil Dallan Quass 
Address: Boston, MA 02125-3393 Stanford, CA 94305  
Affiliation: Tucson, Arizona, USA  Department of Mathematics and Computer Science Department of Computer Science University of Massachusetts at Boston Stanford University  
Note: SIGMOD '97 5/97,  
Abstract: 1 - Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the ACM copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Association of Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. Abstract: The read-mostly environment of data warehousing makes it possible to use more complex indexes to speed up queries than in situations where concurrent updates are present. The current paper presents a short review of current indexing technology, including rowset representation by Bitmaps, and then introduces two approaches we call BitSliced indexing and Projection indexing. A Projection index materializes all values of a column in RID order, and a BitSliced index essentially takes an orthogonal bit-by-bit view of the same data. While some of these concepts started with the MODEL 204 product, and both BitSliced and Projection indexing are now fully realized in Sybase IQ, this is the first rigorous examination of such indexing capabilities in the literature. We compare algorithms that become feasible with these variant index types against algorithms using more conventional indexes. The analysis demonstrates important performance advantages for variant indexes in some types of SQL aggregation, predicate evaluation, and grouping. The paper concludes by introducing a new method whereby multidimensional group-by queries, reminiscent of OLAP/Datacube queries but with more flexibility, can be very efficiently performed. 
Abstract-found: 1
Intro-found: 1
Reference: [COMER79] <author> Comer, D. </author> <title> The Ubiquitous B-tree. </title> <journal> Comput. Surv. </journal> <volume> 11 (1979), </volume> <pages> pp. 121-137. </pages>
Reference-contexts: We then introduce Projection and BitSliced indexes. 2.1 Traditional Value-List Indexes Database indexes provided today by most database systems use B + tree 1 indexes to retrieve rows of a table with specified values involving one or more columns (see <ref> [COMER79] </ref>). The leaf level of the B-tree index consists of a sequence of entries for index keyvalues. Each keyvalue reflects the value of the indexed column or columns in one or more rows in the table, and each keyvalue entry references the set of rows with that value.
Reference: [EDEL95] <author> Herb Edelstein. </author> <title> Faster Data Warehouses. </title> <booktitle> Information Week, </booktitle> <month> Dec. 4, </month> <year> 1995, </year> <pages> pp. 77-88. </pages> <note> Give title and author on http://www.techweb.com/search/advsearch.html. </note>
Reference-contexts: The Sybase IQ product currently provides both variant index types <ref> [EDEL95, FREN95] </ref>, and recommends multiple indexes per column in some cases. Late in the paper, we introduce a new indexing approach to support OLAP-type queries, commonly used in Data Warehouses. Such queries are called D at a cu b e queries in [GBLP96]. <p> Thus reading the values from a Projection index requires only 1/20 the number of disk page access as reading the values from the rows. The Sybase IQ product is the first one to have utilized the Projection index heavily, under the name of "Fast Projection Index" <ref> [EDEL95, FREN95] </ref>. The definition of a Projection index is reminiscent of vertically partitioning the columns of a table. <p> Range Evaluation Performance by Index Type 4.2 Range Predicate with a NonBinary Bit-Sliced Index Sybase IQ was the first product to demonstrate in practice that the same BitSliced index, called the "High NonGroup Index" <ref> [EDEL95] </ref>, could be used both for evaluating range predicates (Algorithm 4.2) and performing Aggregates (Algorithm 3.2, et al). For many years, MODEL 204 has used a form of indexing to evaluate range predicates, known as "Numeric Range" [M204].
Reference: [FREN95] <author> Clark D. </author> <title> French. "One Size Fits All" Database Architectures Do Not Work for DSS. </title> <booktitle> Proceedings of the 1995 ACM SIGMOD Conference, </booktitle> <pages> pp. 449-450. </pages>
Reference-contexts: The Sybase IQ product currently provides both variant index types <ref> [EDEL95, FREN95] </ref>, and recommends multiple indexes per column in some cases. Late in the paper, we introduce a new indexing approach to support OLAP-type queries, commonly used in Data Warehouses. Such queries are called D at a cu b e queries in [GBLP96]. <p> Thus reading the values from a Projection index requires only 1/20 the number of disk page access as reading the values from the rows. The Sybase IQ product is the first one to have utilized the Projection index heavily, under the name of "Fast Projection Index" <ref> [EDEL95, FREN95] </ref>. The definition of a Projection index is reminiscent of vertically partitioning the columns of a table.
Reference: [GBLP96] <author> Jim Gray, Adam Bosworth, Andrew Layman, and Hamid Pirahesh. </author> <title> Data Cube: A Relational Operator Generalizing Group-By, </title> <booktitle> Cross-Tab, and SubTotals. Proc. 12th Int. Conf. on Data Eng., </booktitle> <pages> pp. 152-159, </pages> <year> 1996. </year>
Reference-contexts: Late in the paper, we introduce a new indexing approach to support OLAP-type queries, commonly used in Data Warehouses. Such queries are called D at a cu b e queries in <ref> [GBLP96] </ref>. OLAP query performance depends on creating a set of summary tables to efficiently evaluate an expected set of queries. The summary tables pre-materialize needed aggregates, an approach that is possible only when the expected set of queries is known in advance. <p> Most OLAP products do not express their queries in SQL, but much of the work of typical OLAP queries could be represented in SQL <ref> [GBLP96] </ref> (although more than one query might be needed). [5.1] SELECT P.brand, T.week, C.city, SUM (S.dollar_sales) FROM SALES S, PRODUCT P, CUSTOMER C, TIME T WHERE S.day = T.day and S.cid = C.cid and S.pid = P.pid and P.brand = :brandvar and T.week &gt;= :datevar and C.state in ('Maine', 'New Hampshire',
Reference: [GP87] <author> Jim Gray and Franco Putzolu. </author> <title> The Five Minute Rule for Trading Memory for Disk Accesses and The 10 Byte Rule for Trading Memory for CPU Time. </title> <booktitle> Proc. 1987 ACM SIGMOD, </booktitle> <pages> pp. 395-398. </pages>
Reference-contexts: I/O and CPU factors for the four plans We can compare the four query plans in terms of dollar cost by converting I/O and CPU costs to dollar amounts, as in <ref> [GP87] </ref>. In 1997, a 2 GB hard disk with a 10 ms access time costs roughly $600. With the I/O rate we have been assuming, this is approximately $6.00 per I/O per second.
Reference: [HRU96] <author> Venky Harinarayan, Anand Rajaraman, and Jeffrey D. Ullman. </author> <title> Implementing Data Cubes Efficiently. </title> <booktitle> Proc. 1996 ACM SIGMOD, </booktitle> <pages> pp. 205-216. </pages>
Reference-contexts: The higher the dimensional levels, the fewer elements in the summary table, but there are a lot of possible combinations of hierarchies. Luckily, we don't need to create all possible summary tables in order to speed up the queries a great deal. For more details, see <ref> [STG95, HRU96] </ref>. By doing the aggregation work beforehand, summary tables provide quick response to queries, so long as all selection conditions are restrictions on dimensions that have been foreseen in advance.
Reference: [KIMB96] <author> Ralph Kimball. </author> <title> The Data Warehouse Toolkit. </title> <publisher> John Wiley & Sons, </publisher> <year> 1996. </year>
Reference-contexts: Assume that we are given a star-join schema, consisting of a central fact table Sales, containing sales data, and dimension tables known as Stores (where the sales are made), Time (when the sales are made), Product (involved in the sales), and Promotion (method of promotion being used). (See <ref> [KIMB96] </ref>, Chapter 2, for a detailed explanation of this schema.
Reference: [M204] <institution> MODEL 204 File Manager's Guide, </institution> <note> Version 2, Release 1.0, </note> <month> April </month> <year> 1989, </year> <institution> Computer Corporation of America. </institution>
Reference-contexts: Corresponding to these Fragments, the rows of a table are partitioned into Segments, with an equal number of row slots for each segment. In MODEL 204 (see <ref> [M204, O'NEI87] </ref>), a Bitmap Fragment fits on a 6 KByte page, and contains about 48K bits, so the table is broken into segments of about 48K rows each. This segmentation has two important implications. The first implication involves RID-lists. <p> For many years, MODEL 204 has used a form of indexing to evaluate range predicates, known as "Numeric Range" <ref> [M204] </ref>. Numeric Range evaluation is similar to BitSliced Algorithm 4.2, except that numeric quantities are expressed in a larger base (base 10). It turns out that the effort of performing a range retrieval can be reduced if we are willing to store a larger number of Bitmaps.
Reference: [O'NEI87] <author> Patrick O'Neil. </author> <title> Model 204 Architecture and Performance. </title> <booktitle> Springer-Verlag Lecture Notes in Computer Science 359, 2nd Int. Workshop on High Performance Transactions Systems (HPTS), Asilomar, </booktitle> <address> CA, </address> <year> 1987, </year> <pages> pp. 40-59. </pages>
Reference-contexts: Thus the length in bytes of the leaf level of a B-tree index with a small number of keyvalues is about 4 times the number of table rows. 2.1.1 Bitmap Indexes Bitmap indexes were first developed for database use in the Model 204 product from Computer Corporation of America (see <ref> [O'NEI87] </ref>). A Bitmap is an alternate form for representing RID-lists in a Value-List index. Bitmaps are more space-efficient than RID-lists when the number of keyvalues for the index is low. Furthermore, we will show that Bitmaps are usually more CPU-efficient as well, because of the simplicity of their representation. <p> Corresponding to these Fragments, the rows of a table are partitioned into Segments, with an equal number of row slots for each segment. In MODEL 204 (see <ref> [M204, O'NEI87] </ref>), a Bitmap Fragment fits on a 6 KByte page, and contains about 48K bits, so the table is broken into segments of about 48K rows each. This segmentation has two important implications. The first implication involves RID-lists. <p> Such an eventuality is unlikely in business applications, however. A user-defined method to bitslice aggregate quantities was used by some MODEL 204 customers and is defined on page 48 of <ref> [O'NEI87] </ref>. Sybase IQ currently provides a fully realized Bit-Sliced index, which is known to the query optimizer and transparent to SQL users. <p> As pointed out earlier, if a Segment s 1 of the Foundset (or Groupset) is completely empty (i.e., all bits are 0), then ANDing s 1 with any other Segment s 2 will also result in an empty Segment. As explained in <ref> [O'NEI87] </ref>, the entry in the B-tree leaf level for a column C that references an all-zeros Bitmap Segment is simply missing, and a reasonable algorithm to AND Bitmaps will test this before accessing any Segment Bitmap pages.
Reference: [O'NEI91] <author> Patrick O'Neil. </author> <title> The Set Query Benchmark. The Benchmark Handbook for Database and Transaction Processing Systems, </title> <editor> Jim Gray (Ed.), </editor> <publisher> Morgan Kaufmann, </publisher> <editor> 2nd Ed. </editor> <year> 1993, </year> <pages> pp. 359-395. </pages>
Reference-contexts: Example 2.1. In the Set Query benchmark of <ref> [O'NEI91] </ref>, the results from one of the SQL statements in Query Suite Q5 gives a good illustration of Bitmap performance.
Reference: [O'NEI96] <author> Patrick O'Neil. </author> <title> Database: Principles, Programming, and Performance. </title> <publisher> Morgan Kaufmann, 3rd printing, </publisher> <year> 1996. </year>
Reference-contexts: For example, MVS DB2 provides this kind of compression, (see <ref> [O'NEI96] </ref>, Figure 7.19). Keyvalues with RID-lists that cross leaf pages require multiple Fragments. We assume in what follows that RID-lists (and Bitmaps, which follow) are read from disk in multiples of Fragments. <p> By comparison, MVS DB2 Version 2.3, running on an IBM 9221/170 used an algorithm that extracted and wrote out all pairs of (K10, K25) values from the rows, sorted by value pair, and counted the result in groups, taking 248 seconds of elapsed time and 223 seconds of CPU. (See <ref> [O'NEI96] </ref> for more details.) u 2.1.3 Segmentation To optimize Bitmap index access, Bitmaps can be broken into Fragments of equal sizes to fit on single fixed-size disk pages. <p> Since 2,000,000 rows in the Foundset B f represent only 1/50 of all rows in the SALES table, the number of disk pages that the Foundset occupies can be estimated (see <ref> [O'NEI96] </ref>, Formula [7.6.4]) as: 5 ,000,000 (1 - e -2,000,000/5,000,000 ) = 1,648,400 disk pages The time to perform such a sequence of I/Os, assuming one disk arm retrieves 100 disk pages per second in relatively close sequence on disk, is 16,484 seconds, or more than 4 hours of disk arm
Reference: [O'NGG95] <author> Patrick O'Neil and Goetz Graefe. </author> <title> Multi-Table Joins Through Bitmapped Join Indices. </title> <booktitle> SIGMOD Record, </booktitle> <month> September, </month> <year> 1995, </year> <pages> pp. 8-11, </pages>
Reference-contexts: Thus, there will be a "combinatorial explosion" of Join Indexes in terms of the number of independent columns. The Bitmap join index, defined in <ref> [O'NGG95] </ref>, addresses this problem. In its simplest form, this is an index on a table T based on a single column of a table S, where S commonly joins with T in a specified way.
Reference: [O'NQUA] <author> Patrick O'Neil and Dallan Quass. </author> <title> Improved Query Performance with Variant Indexes. </title> <note> Extended paper, available on http:/www.cs.umb.edu/~poneil/varindexx.ps </note>
Reference-contexts: To find MAX and MIN using a Projection index, one must loop through all values stored. The algorithm to evaluate MAX or MIN using a BitSliced index is given in our extended paper, <ref> [O'NQUA] </ref>, together with other algorithms not detailed in this Section. 2 Best only if there is a clustering of rows in B in a local region, a fraction f of the pages, f 0.755. <p> Surprisingly, a BitSliced index can also be used to determine the MEDIAN, in about the same amount of time as it takes to determine SUM (see <ref> [O'NQUA] </ref>). <p> Numeric Range evaluation is similar to BitSliced Algorithm 4.2, except that numeric quantities are expressed in a larger base (base 10). It turns out that the effort of performing a range retrieval can be reduced if we are willing to store a larger number of Bitmaps. In <ref> [O'NQUA] </ref> we show how BitSliced Algorithm 4.2 can be generalized to base 8, where the BitSlices represent sets of rows with octal digit O i c, c a nonzero octal digit. This is a generalization of Binary BitSlices, which represent sets of rows with binary digit B i 1. 5.
Reference: [PH96] <author> D. A. Patterson and J. L. Hennessy. </author> <title> Computer Architecture, A Quantitative Approach. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: Each disk page I/O is generally assumed to require several thousand instructions to perform (see, for example, <ref> [PH96] </ref>, Section 6.7, where 10,000 instructions are assumed). Query Plan 2: Calculating SUM with a Projection index.
Reference: [STG95] <institution> Stanford Technology Group, Inc., </institution> <note> An INFORMIX Co.. Designing the Data Warehouse on Relational Databases. Informix White Paper, 1995, http://www.informix.com. </note>
Reference-contexts: The higher the dimensional levels, the fewer elements in the summary table, but there are a lot of possible combinations of hierarchies. Luckily, we don't need to create all possible summary tables in order to speed up the queries a great deal. For more details, see <ref> [STG95, HRU96] </ref>. By doing the aggregation work beforehand, summary tables provide quick response to queries, so long as all selection conditions are restrictions on dimensions that have been foreseen in advance.
Reference: [TPC] <author> TPC Home Page. </author> <title> Descriptions and results of TPC benchmarks, including the TPC-C and TPC-D benchmarks. </title> <address> http://www.tpc.org. </address>
References-found: 16

