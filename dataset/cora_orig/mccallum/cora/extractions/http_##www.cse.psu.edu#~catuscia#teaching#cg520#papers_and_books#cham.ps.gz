URL: http://www.cse.psu.edu/~catuscia/teaching/cg520/papers_and_books/cham.ps.gz
Refering-URL: http://www.cse.psu.edu/~catuscia/teaching/cg520/98Fall/references.html
Root-URL: http://www.cse.psu.edu
Title: The Chemical Abstract Machine  
Author: Grard Berry Grard Boudol 
Date: October 26, 1998  
Address: 06560 Valbonne, France  06560 Valbonne, France  
Affiliation: Ecole Nationale Suprieure des Mines de Paris Centre de Mathmatiques Appliques Sophia-Antipolis,  INRIA Sophia-Antipolis,  
Abstract: We introduce a new kind of abstract machine based on the chemical metaphor used in the language of Bantre and Le Mtayer. States of a machine are chemical solutions where AEoating molecules can interact according to reaction rules. Solutions can be stratioed by encapsulating subsolutions within membranes that force reactions to occur locally. We illustrate the use of this model by describing the operational semantics of the TCCS and CCS process calculi and of the fragment of Milner, Parrow, and Walker's Calculus of Mobile Processes used by Milner to encode the lambda-calculus. We also give ideas on how to extract a higher-order concurrent -calculus out of the basic concepts of the chemical abstract machine. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martin Abadi, Luca Cardelli, Pierre-Louis Curien, and Jean-Jacques Lvy. </author> <title> Explicit substitutions. </title> <booktitle> In Proc. 17th ACM Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 3146, </pages> <year> 1990. </year>
Reference-contexts: Then our set of rules 32 does not really specify a machine: an abstract machine should not involve such a complex mechanism. We can remedy this deociency using explicit substitutions, like in <ref> [1, 19] </ref>. The idea is to bind a formal substitution oe to a term M , building a new term denoted M [oe] in [1]. <p> We can remedy this deociency using explicit substitutions, like in [1, 19]. The idea is to bind a formal substitution oe to a term M , building a new term denoted M [oe] in <ref> [1] </ref>.
Reference: [2] <author> Samson Abramsky. </author> <title> The lazy -calculus. </title> <editor> In D. Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, </booktitle> <pages> pages 65116. </pages> <publisher> Addison Wes-ley, </publisher> <year> 1989. </year>
Reference-contexts: Some familiarity with the -calculus will be assumed. We just recall the syntax: M ::= x j (x:M ) j (M M ) where x stands for any variable. We are interested here in the lazy evaluation of -terms (following <ref> [2] </ref>), that is the reAEexive and transitive closure of the 26 relation M . M 0 inductively given by (x:M )N . <p> This is the kind of semantical equality we propose for our fl-calculus. However, we shall not follow [13] and [15] for what concerns the result of experiments. To report the success of a test we shall use, as in <ref> [2] </ref>, the simplest operational information, namely convergence, that is existence of a normal form: the agent M passes the test C [] if C [M ] converges. <p> an agent M is said to converge, in notation M +, if and only if there exists an inert solution S such that fj M jg ! S Then the deonition of the testing preorder (on closed terms) is exactly the one of Morris' preorder (cf. [6], exercise 16.5.5, and <ref> [2] </ref>), that is: M v N , def 8C: C [M ]+ ) C [N ]+ As usual the associated equivalence ' is given by M ' N , def M v N & N v M Let us see an example, showing that testing allows to distinguish divergent terms in <p> Mobile processes can be very simply implemented. The concurrent -calculus fully exploits the ability of going back and forth between terms and solutions. It can be viewed as a direct extension of the lazy -calculus of <ref> [2] </ref>. Of course, this is still a preliminary work. Other concurrent computation applications should be modelled; we think in particular of process handling in operating systems. The theory of machine execution and observation should also be fully developed.
Reference: [3] <author> Andr Arnold. </author> <note> Smantique des processus communicants. RAIRO In-formatique Thorique, 15(2):103139, </note> <year> 1981. </year>
Reference-contexts: The situation is much less clear in the oeld of concurrent programming. Models such as Petri Nets [30], Communicating Automata <ref> [3] </ref>, or Data Flow Networks [22] can be considered as abstract machines, but certainly they lack expressive power. More expressive models such as Algebraic Process Calculi [26, 8] are intended to be speciocation formalisms for distributed systems rather than abstract machines.
Reference: [4] <author> Jean-Pierre Bantre, Anne Coutant, and Daniel Le Mtayer. </author> <title> A parallel machine for multiset transformation and its programming style. </title> <booktitle> In Future Generation Computer Systems 4, </booktitle> <pages> pages 133144. </pages> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Such concepts convey a rigid geometrical vision of concurrency. Our chemical abstract machine model is based on a radically dioeerent paradigm, which originated in the language of Bantre and Le Mtayer <ref> [4, 5] </ref>. These authors pointed out that parallel programming with control threads is more diOEcult to manage than sequential programming, a fact that contrasts with the common expectation that parallelism should ease program design. They argued that a high-level parallel programming methodology should be liberated from control management. <p> In chemistry, this is the result of Brownian motion, but we don't insist on any particular mechanism, this being an implementation matter not studied here, see <ref> [4, 11] </ref>. The solution transformation process is obviously inherently parallel: any number of reactions can be performed in parallel, 2 provided that they involve disjoint sets of molecules. Let us give a simple but striking example from [4, 5]. <p> The solution transformation process is obviously inherently parallel: any number of reactions can be performed in parallel, 2 provided that they involve disjoint sets of molecules. Let us give a simple but striking example from <ref> [4, 5] </ref>. Assume the solution is originally made of all integers from 2 to n, along with the rule that any integer destroys its multiples. Then the solution will end up containing the prime numbers between 2 and n. See [4, 5] for more examples and for implementation techniques. <p> Let us give a simple but striking example from <ref> [4, 5] </ref>. Assume the solution is originally made of all integers from 2 to n, along with the rule that any integer destroys its multiples. Then the solution will end up containing the prime numbers between 2 and n. See [4, 5] for more examples and for implementation techniques. Technically, a program is deoned by the structure of the molecules it handles and by a set of reaction rules. <p> In this paper, we only study the descriptive power of chams; it does not depend on using parallel evaluation, since a non-conAEicting parallel application of rules is equivalent, up to permutations, to any sequence of the individual rules. See <ref> [4] </ref> for a practical use of parallel reductions. 3.2 A Classiocation of Rules We usually distinguish between three kinds of rules: heating rules *, cooling rules +, and reaction rules !. The distinction is not enforced by the formalism.
Reference: [5] <author> Jean-Pierre Bantre and Daniel Le Mtayer. </author> <title> The gamma model and its discipline of programming. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 15:55 77, </volume> <year> 1990. </year>
Reference-contexts: Such concepts convey a rigid geometrical vision of concurrency. Our chemical abstract machine model is based on a radically dioeerent paradigm, which originated in the language of Bantre and Le Mtayer <ref> [4, 5] </ref>. These authors pointed out that parallel programming with control threads is more diOEcult to manage than sequential programming, a fact that contrasts with the common expectation that parallelism should ease program design. They argued that a high-level parallel programming methodology should be liberated from control management. <p> The solution transformation process is obviously inherently parallel: any number of reactions can be performed in parallel, 2 provided that they involve disjoint sets of molecules. Let us give a simple but striking example from <ref> [4, 5] </ref>. Assume the solution is originally made of all integers from 2 to n, along with the rule that any integer destroys its multiples. Then the solution will end up containing the prime numbers between 2 and n. See [4, 5] for more examples and for implementation techniques. <p> Let us give a simple but striking example from <ref> [4, 5] </ref>. Assume the solution is originally made of all integers from 2 to n, along with the rule that any integer destroys its multiples. Then the solution will end up containing the prime numbers between 2 and n. See [4, 5] for more examples and for implementation techniques. Technically, a program is deoned by the structure of the molecules it handles and by a set of reaction rules.
Reference: [6] <author> Henk Barendregt. </author> <title> The Type-Free Lambda-Calculus. </title> <booktitle> Studies in Logic Volume 103. </booktitle> <publisher> North-Holland, </publisher> <year> 1981. </year>
Reference-contexts: The multiset union of S and S 0 is written S ] S 0 . As in the -calculus <ref> [6] </ref>, we use the context notation C [ ] to denote a molecule with a hole [ ] in which to place another molecule. <p> On the other hand, the -calculus is intrinsically sequential <ref> [6, 7] </ref> and cannot handle even the weakest form of concurrency. Building new calculi that combine both abilities is a goal of primary importance [9, 31]. In [9], we introduced such a tentative concurrent lambda-calculus called the fl-calculus. <p> Parallel Or We can also deone a iparallel orj, which is a parallel variant of the usual ileft-sequential orj (cf. [9]). Let us see this point in some detail. It is known (see <ref> [6] </ref>) that K = x y x and F = x y y can be regarded as the truth values, respectively true and false. Then one can deone a combinator for disjunction, namely V = x y (xK)y. <p> For instance if denotes the non-terminating term (where = x (xx) is the duplicator) then the evaluation of VK does not terminate. This is why V is ileft-sequentialj. Moreover from Berry's sequentiality theorem <ref> [7, 6] </ref>, one can show that there is no -deonable combinator representing parallel disjunction, that is no combinator O such that both OKX and OXK reduce to K without evaluating X and OFF reduces to F. <p> Convergence Testing Formally, an agent M is said to converge, in notation M +, if and only if there exists an inert solution S such that fj M jg ! S Then the deonition of the testing preorder (on closed terms) is exactly the one of Morris' preorder (cf. <ref> [6] </ref>, exercise 16.5.5, and [2]), that is: M v N , def 8C: C [M ]+ ) C [N ]+ As usual the associated equivalence ' is given by M ' N , def M v N & N v M Let us see an example, showing that testing allows to
Reference: [7] <editor> Grard Berry. Squentialit de l'evaluation formelle des -expressions. In B. Robinet, editor, </editor> <booktitle> Program Transformations 3rd International Colloquium on Programming, </booktitle> <pages> pages 6780. </pages> <address> DUNOD, Paris, </address> <year> 1978. </year>
Reference-contexts: On the other hand, the -calculus is intrinsically sequential <ref> [6, 7] </ref> and cannot handle even the weakest form of concurrency. Building new calculi that combine both abilities is a goal of primary importance [9, 31]. In [9], we introduced such a tentative concurrent lambda-calculus called the fl-calculus. <p> For instance if denotes the non-terminating term (where = x (xx) is the duplicator) then the evaluation of VK does not terminate. This is why V is ileft-sequentialj. Moreover from Berry's sequentiality theorem <ref> [7, 6] </ref>, one can show that there is no -deonable combinator representing parallel disjunction, that is no combinator O such that both OKX and OXK reduce to K without evaluating X and OFF reduces to F.
Reference: [8] <author> Grard Boudol. </author> <title> Notes on algebraic calculi of processes. </title> <editor> In K. Apt, editor, </editor> <booktitle> Logic and Models of Concurrent Systems. NATO ASI Series F13, </booktitle> <year> 1985. </year>
Reference-contexts: 1 Introduction We present the notion of a Chemical Abstract Machine or cham, suited to model concurrent computations. We show that chemical abstract machines can implement known models of concurrent computation such as algebraic process calculi <ref> [26, 8] </ref>, Milner's Mobile Processes calculus [28, 27], and a concurrent -calculus similar to the one presented in [9]. 1 Abstract Machines Abstract machines are widely used in the classical theory of sequential computations. <p> The situation is much less clear in the oeld of concurrent programming. Models such as Petri Nets [30], Communicating Automata [3], or Data Flow Networks [22] can be considered as abstract machines, but certainly they lack expressive power. More expressive models such as Algebraic Process Calculi <ref> [26, 8] </ref> are intended to be speciocation formalisms for distributed systems rather than abstract machines. Implementation models of Concurrent Programming Languages such as CSP [21] are conceptually based on standard sequential machine models augmented with scheduling facilities, not on specioc abstract machines. <p> This is actually quite well-known to CCS simulator implementors. Handling other process calculi raises no particular problem. For example, one can deone a cham for Meije <ref> [8] </ref>, which is universal among the labelled process calculi [17]. <p> Inference rules are replaced by standard rewrite rules. The dioeerence between internal and external transitions is made obvious and so are the well-known diOEculties with sums considered as programming primitives. More powerful iuniversalj process calculi such as MEIJE <ref> [8] </ref> can be handled as well. Mobile processes can be very simply implemented. The concurrent -calculus fully exploits the ability of going back and forth between terms and solutions. It can be viewed as a direct extension of the lazy -calculus of [2].
Reference: [9] <author> Grard Boudol. </author> <title> Towards a lambda-calculus for concurrent and communicating systems. </title> <booktitle> In TAPSOFT 1989, Lecture Notes in Computer Science 351, </booktitle> <pages> pages 149161. </pages> <address> SpringerVerlag, </address> <year> 1989. </year>
Reference-contexts: We show that chemical abstract machines can implement known models of concurrent computation such as algebraic process calculi [26, 8], Milner's Mobile Processes calculus [28, 27], and a concurrent -calculus similar to the one presented in <ref> [9] </ref>. 1 Abstract Machines Abstract machines are widely used in the classical theory of sequential computations. Turing Machines or Random Access Machines are primary tools within the theories of recursive functions and computational complexity. <p> In Section 4, we treat the full TCCS [16] calculus and indicate how to handle other process calculi. Section 5 presents a cham for a subset of Milner's Calculus of Mobile Processes [28]. Section 6 is devoted to a concurrent lambda-calculus similar to that of <ref> [9] </ref>. <p> On the other hand, the -calculus is intrinsically sequential [6, 7] and cannot handle even the weakest form of concurrency. Building new calculi that combine both abilities is a goal of primary importance <ref> [9, 31] </ref>. In [9], we introduced such a tentative concurrent lambda-calculus called the fl-calculus. We could describe the (lazy) evaluation in this calculus by means of a cham. However, our formalism itself suggests a simpler and perhaps better calculus of the same kind. <p> On the other hand, the -calculus is intrinsically sequential [6, 7] and cannot handle even the weakest form of concurrency. Building new calculi that combine both abilities is a goal of primary importance [9, 31]. In <ref> [9] </ref>, we introduced such a tentative concurrent lambda-calculus called the fl-calculus. We could describe the (lazy) evaluation in this calculus by means of a cham. However, our formalism itself suggests a simpler and perhaps better calculus of the same kind. <p> However in his higher order calculus, fi-reduction is performed in two steps, involving an intermediary state which does not represent a -term. Then the -calculus is not exactly a sub-calculus of Thomsen's CHOCS calculus. Restricting Communication A First Attempt Another solution was presented in <ref> [9] </ref> using two concurrency operators: an interleaving operator `j' and a binary communication operator `fi'. <p> As usual we shall omit (or add) some parentheses in writing the terms, which will be called processes or sometimes agents. In what follows we shall call this concurrent calculus the fl-calculus, superseding the one proposed in <ref> [9] </ref>. To formalise the execution mechanism, we need a syntactic notion of stable state, generalising that of weak head normal form. Basically, a stable term is made out of ions of the same valence (either positive or negative), and will therefore represent an inert solution. <p> This should not be confused with CCS restriction: if a membrane encloses a stable state (i.e. emitter or receptor), then it may vanish. The hatching rule conveniently replaces the termination equations concerning the cooperation operator of <ref> [9] </ref> (in our calculus, a icooperationj operator would be hM j N i). <p> Therefore one easily sees that M N fl fl ! N . Clearly such a combinator is not -deonable since it does not preserve the Church Rosser property. Concurrent Abstractions As in <ref> [9] </ref>, we extend our syntax by deoning concurrent abstractions, that is sets of negative valences. More precisely, we deone receptors of the form [x 1 j j x n ] M where x 1 ; : : : ; x n are distinct variables. <p> For instance, the choice operator can be redeoned by = [x j y] x, which is a parallel variant of the usual cancellator K. Parallel Or We can also deone a iparallel orj, which is a parallel variant of the usual ileft-sequential orj (cf. <ref> [9] </ref>). Let us see this point in some detail. It is known (see [6]) that K = x y x and F = x y y can be regarded as the truth values, respectively true and false. <p> This is a semantic statement, so we would have orst to deone an equivalence relation ' on fl-terms such that: OK ' K ' OK O ' In <ref> [9] </ref> it was proposed to adapt the notion of observational bisimulation of CCS [26, 31] to serve as the semantic equivalence.
Reference: [10] <author> Nicholas Carriero and David Gelerntner. </author> <title> Linda in context. </title> <journal> Communications of the ACM, </journal> <volume> 32(4):444458, </volume> <year> 1989. </year>
Reference-contexts: The reaction rules are multiset rewritings. Other authors have proposed models in which the AEow of control is made completely implicit: see for example the set of assignments used in UNITY [11] or the tuple space of Linda <ref> [10] </ref>. These models are based on similar concepts and bear the same degree of potential parallelism. Another instance of multiset rewriting is the token game in Petri Nets: markings are multisets of places which play the role of molecules, and transitions are rules to transform markings.
Reference: [11] <author> Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design, a Foundation. </title> <publisher> Addison-Wesley, </publisher> <year> 1988. </year> <month> 37 </month>
Reference-contexts: In chemistry, this is the result of Brownian motion, but we don't insist on any particular mechanism, this being an implementation matter not studied here, see <ref> [4, 11] </ref>. The solution transformation process is obviously inherently parallel: any number of reactions can be performed in parallel, 2 provided that they involve disjoint sets of molecules. Let us give a simple but striking example from [4, 5]. <p> The reaction rules are multiset rewritings. Other authors have proposed models in which the AEow of control is made completely implicit: see for example the set of assignments used in UNITY <ref> [11] </ref> or the tuple space of Linda [10]. These models are based on similar concepts and bear the same degree of potential parallelism.
Reference: [12] <author> Pierre-Louis Curien. </author> <title> Categorical Combinators, Sequential Algorithms, </title> <booktitle> and Functional Programming. Research Notes in Theoretical Computer Science. </booktitle> <publisher> Pitman, London, John Wiley & Sons, </publisher> <address> New York, Toronto, </address> <year> 1986. </year>
Reference-contexts: Turing Machines or Random Access Machines are primary tools within the theories of recursive functions and computational complexity. The SECD machine [23] and the Categorical Abstract Machine <ref> [12] </ref> are used to study and implement the -calculus, while the SMC machine [25] may be used to describe the semantics of usual imperative constructs. The situation is much less clear in the oeld of concurrent programming. <p> This combinator does exist in the fl-calculus and is represented by: O = [x j y] (xK)y It is a parallel variant of the left-sequential disjunction, or equivalently a choice between left-sequential disjunction V and right-sequential disjunction y x (xK)y, see <ref> [12] </ref>. Explicit Substitutions The reader may have noted that we use ordinary substitution in our presen tation of the fl-calculus, namely in the reaction rule. Then our set of rules 32 does not really specify a machine: an abstract machine should not involve such a complex mechanism. <p> It is not diOEcult to see that C [P ] diverges, whereas C [Q] fl ! I, therefore P 6' Q. We shall not investigate here the properties of the testing preorder. A orst step would be to prove a generalisation of the well-known icontext lemmaj (cf. <ref> [12] </ref>), showing that observers of the form h h [] j R 1 i j R k i are enough to test the agents, that is M v N , 8k 8R 1 ; : : : ; R k : Such a result would allow us to give a simple
Reference: [13] <author> Philippe Darondeau. </author> <title> About fair asynchrony. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 37:305336, </address> <year> 1985. </year>
Reference-contexts: As a matter of fact, observational bisimulation has often been criticized for being too discriminating, and weaker iextensionalj equivalences have been proposed (for a survey, see [14] and [20]). For instance Darondeau in <ref> [13] </ref> argued that ia semantics which stems from more sophisticated observers [than programs] is not really extensionalj. In other words, the semantics of processes should be derived from their observation by means of program contexts C []. <p> This is the kind of semantical equality we propose for our fl-calculus. However, we shall not follow <ref> [13] </ref> and [15] for what concerns the result of experiments. To report the success of a test we shall use, as in [2], the simplest operational information, namely convergence, that is existence of a normal form: the agent M passes the test C [] if C [M ] converges.
Reference: [14] <author> Rocco De Nicola. </author> <title> Extensional equivalences for transition systems. </title> <journal> Acta Informatica, </journal> <volume> 24:211237, </volume> <year> 1987. </year>
Reference-contexts: As a matter of fact, observational bisimulation has often been criticized for being too discriminating, and weaker iextensionalj equivalences have been proposed (for a survey, see <ref> [14] </ref> and [20]). For instance Darondeau in [13] argued that ia semantics which stems from more sophisticated observers [than programs] is not really extensionalj. In other words, the semantics of processes should be derived from their observation by means of program contexts C [].
Reference: [15] <author> Rocco De Nicola and Matthew Hennessy. </author> <title> Testing equivalences for processes. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 34:83133, </address> <year> 1984. </year>
Reference-contexts: In other words, the semantics of processes should be derived from their observation by means of program contexts C []. These program contexts may be regarded as tests over processes, and there is a natural way to deone an associated testing equivalence (cf. <ref> [15] </ref>): two process are equivalent if they pass the same tests. This is the kind of semantical equality we propose for our fl-calculus. However, we shall not follow [13] and [15] for what concerns the result of experiments. <p> may be regarded as tests over processes, and there is a natural way to deone an associated testing equivalence (cf. <ref> [15] </ref>): two process are equivalent if they pass the same tests. This is the kind of semantical equality we propose for our fl-calculus. However, we shall not follow [13] and [15] for what concerns the result of experiments. To report the success of a test we shall use, as in [2], the simplest operational information, namely convergence, that is existence of a normal form: the agent M passes the test C [] if C [M ] converges.
Reference: [16] <author> Rocco De Nicola and Matthew Hennessy. </author> <title> CCS without o 's. </title> <booktitle> In TAP-SOFT 87, Lecture Notes in Computer Science 249, </booktitle> <pages> pages 138152. </pages> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: To make the reader familiar with our concepts, the next section presents a simple machine for a subset of CCS. Section 3 gives some formal deonitions. In Section 4, we treat the full TCCS <ref> [16] </ref> calculus and indicate how to handle other process calculi. Section 5 presents a cham for a subset of Milner's Calculus of Mobile Processes [28]. Section 6 is devoted to a concurrent lambda-calculus similar to that of [9]. <p> Milner's original rules involve a special o label representing internal communication. This happens to be quite unnatural with respect to abstract machine executions, where internal transitions should not be visible to the user. We prefer to use the De Nicola Hennessy TCCS rules <ref> [16] </ref> that deone two kinds of transitions between agents: the internal transitions p ! p 0 and the labelled transitions p ff ! p 0 . <p> Technically, we enrich our molecule syntax by considering any solution contained within a membrane as a single molecule to which operators such as `n' or ` []' (external choice, see <ref> [16] </ref>) can be applied. We can then construct complex molecules containing subsolutions, such as fj O; a:b:O jgna. <p> 4 Process Calculi Chams In this section, we onish the treatment of the TCCS process calculus, we relate the cham semantics with the original structural operational semantics, and we brieAEy indicate how to handle other process calculi. 4.1 The Full TCCS Calculus We onish the description of the TCCS calculus <ref> [16] </ref> and of its SOS semantics. We have already seen the inaction `O', parallel ` j ', preoxing `:', and restriction `n' operators. <p> There are several possible sums, see <ref> [16] </ref> for an extensive discussion. The simplest sum is the internal sum , which non-deterministically chooses a component: p q ! p In an external sum p []q, the agents p and q can freely perform internal actions and can also propose communications to the environment.
Reference: [17] <author> Robert De Simone. </author> <title> Higher-level synchronising devices in meije-sccs. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 37:245267, </address> <year> 1985. </year>
Reference-contexts: This is actually quite well-known to CCS simulator implementors. Handling other process calculi raises no particular problem. For example, one can deone a cham for Meije [8], which is universal among the labelled process calculi <ref> [17] </ref>.
Reference: [18] <author> Pierpaolo Degano, Rocco De Nicola, and Ugo Montanari. </author> <title> A distributed operational semantics for CCS based on condition/events systems. </title> <journal> Acta Informatica, </journal> <volume> 26:5991, </volume> <year> 1988. </year>
Reference-contexts: The comma `;' appearing in the right-hand side expresses that the heating and cooling rule respectively yield and take a pair of molecules. This is very similar to the decomposition of processes into sequential components used in the translation from CCS to Petri Nets presented in <ref> [18] </ref>. The reaction rule deals with ions, i.e. molecules of the form ff:p. Since ff is the ion's communication capability, we call it its valence. Whenever two complementary ions AEoat in the solution, they can react with each other and release their bodies in the solution. The valences simply vanish. <p> Notice that the notion of a syntactic position disappears even for the standard parallel construct ` j ': it is impossible to know whether fj p; q jg was obtained by heating fj p j q jg or fj q j p jg (unlike in <ref> [18] </ref>). Chemical concurrency is naturally associative and commutative, since multisets are intrinsically unordered.
Reference: [19] <author> T. Hardin and J.-J. Lvy. </author> <title> A conAEuent calculus of substitutions. </title> <booktitle> In France-Japan Artiocial Intelligence and Computer Science Symposium,. </booktitle> <address> Izu, </address> <year> 1989. </year>
Reference-contexts: Then our set of rules 32 does not really specify a machine: an abstract machine should not involve such a complex mechanism. We can remedy this deociency using explicit substitutions, like in <ref> [1, 19] </ref>. The idea is to bind a formal substitution oe to a term M , building a new term denoted M [oe] in [1].
Reference: [20] <author> Matthew Hennessy. </author> <title> Observing processes. In Linear Time, Branching Time and Partial Orders in Logics and Models for Concurrency, </title> <booktitle> Lecture Notes in Computer Science 354, </booktitle> <pages> pages 173200. </pages> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: As a matter of fact, observational bisimulation has often been criticized for being too discriminating, and weaker iextensionalj equivalences have been proposed (for a survey, see [14] and <ref> [20] </ref>). For instance Darondeau in [13] argued that ia semantics which stems from more sophisticated observers [than programs] is not really extensionalj. In other words, the semantics of processes should be derived from their observation by means of program contexts C [].
Reference: [21] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: More expressive models such as Algebraic Process Calculi [26, 8] are intended to be speciocation formalisms for distributed systems rather than abstract machines. Implementation models of Concurrent Programming Languages such as CSP <ref> [21] </ref> are conceptually based on standard sequential machine models augmented with scheduling facilities, not on specioc abstract machines. The Language Most available concurrency models are based on architectural concepts, e.g. networks of processes communicating by means of ports or channels. Such concepts convey a rigid geometrical vision of concurrency.
Reference: [22] <author> Gilles Kahn. </author> <title> The semantics of a simple language for parallel processing. </title> <booktitle> In IFIP Congress 1974, </booktitle> <year> 1974. </year>
Reference-contexts: The situation is much less clear in the oeld of concurrent programming. Models such as Petri Nets [30], Communicating Automata [3], or Data Flow Networks <ref> [22] </ref> can be considered as abstract machines, but certainly they lack expressive power. More expressive models such as Algebraic Process Calculi [26, 8] are intended to be speciocation formalisms for distributed systems rather than abstract machines.
Reference: [23] <author> Peter Landin. </author> <title> The mechanical evaluation of expressions. </title> <journal> Computer Journal, </journal> <volume> 6:308320, </volume> <year> 1964. </year>
Reference-contexts: Turing Machines or Random Access Machines are primary tools within the theories of recursive functions and computational complexity. The SECD machine <ref> [23] </ref> and the Categorical Abstract Machine [12] are used to study and implement the -calculus, while the SMC machine [25] may be used to describe the semantics of usual imperative constructs. The situation is much less clear in the oeld of concurrent programming.
Reference: [24] <author> Jos Meseguer. </author> <title> Rewriting as a unioed model for concurrency. </title> <type> Technical report, SRI International Technical Report, </type> <year> 1990. </year> <month> 38 </month>
Reference-contexts: m i 's and the m j 's by a common substitution, then fj M 1 ; M 2 ; : : : ; M k jg ! fj M 0 2 ; : : : ; M 0 1 Very precise algebraic deonitions of these notions are given in <ref> [24] </ref>. 12 * The Chemical Law. Reactions can be performed freely within any solution: S ! S 0 * The Membrane Law.
Reference: [25] <author> Robin Milner. </author> <title> Program Semantics and Mechanized Proofs, </title> <type> pages 344. </type> <institution> Mathematical Center Tracts 82, </institution> <address> Amsterdam, </address> <year> 1976. </year>
Reference-contexts: Turing Machines or Random Access Machines are primary tools within the theories of recursive functions and computational complexity. The SECD machine [23] and the Categorical Abstract Machine [12] are used to study and implement the -calculus, while the SMC machine <ref> [25] </ref> may be used to describe the semantics of usual imperative constructs. The situation is much less clear in the oeld of concurrent programming. Models such as Petri Nets [30], Communicating Automata [3], or Data Flow Networks [22] can be considered as abstract machines, but certainly they lack expressive power.
Reference: [26] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction We present the notion of a Chemical Abstract Machine or cham, suited to model concurrent computations. We show that chemical abstract machines can implement known models of concurrent computation such as algebraic process calculi <ref> [26, 8] </ref>, Milner's Mobile Processes calculus [28, 27], and a concurrent -calculus similar to the one presented in [9]. 1 Abstract Machines Abstract machines are widely used in the classical theory of sequential computations. <p> The situation is much less clear in the oeld of concurrent programming. Models such as Petri Nets [30], Communicating Automata [3], or Data Flow Networks [22] can be considered as abstract machines, but certainly they lack expressive power. More expressive models such as Algebraic Process Calculi <ref> [26, 8] </ref> are intended to be speciocation formalisms for distributed systems rather than abstract machines. Implementation models of Concurrent Programming Languages such as CSP [21] are conceptually based on standard sequential machine models augmented with scheduling facilities, not on specioc abstract machines. <p> Section 6 is devoted to a concurrent lambda-calculus similar to that of [9]. We conclude in Section 7. 2 Handling a Subset of CCS Our orst illustrative example is a fragment CCS of Milner's process calculus CCS <ref> [26] </ref>, containing the most basic operators O (inaction), `:' (preoxing), and ` j ' (parallel), as well as the restriction operator `n' to make the example non-trivial. <p> This is a semantic statement, so we would have orst to deone an equivalence relation ' on fl-terms such that: OK ' K ' OK O ' In [9] it was proposed to adapt the notion of observational bisimulation of CCS <ref> [26, 31] </ref> to serve as the semantic equivalence. We could deone this notion here, with the idea that x is an input guard and M + an output action, but this does not seem to be a good choice.
Reference: [27] <author> Robin Milner. </author> <title> Functions as processes. </title> <booktitle> In ICALP 90, Lecture Notes in Computer Science 443, </booktitle> <pages> pages 167180. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction We present the notion of a Chemical Abstract Machine or cham, suited to model concurrent computations. We show that chemical abstract machines can implement known models of concurrent computation such as algebraic process calculi [26, 8], Milner's Mobile Processes calculus <ref> [28, 27] </ref>, and a concurrent -calculus similar to the one presented in [9]. 1 Abstract Machines Abstract machines are widely used in the classical theory of sequential computations. Turing Machines or Random Access Machines are primary tools within the theories of recursive functions and computational complexity. <p> Intuitively, channel names can be passed between processes through named channels. We only consider the restricted calculus studied in <ref> [27] </ref>, which is powerful enough to simulate the lambda-calculus. The full -calculus has other operators such as sums; they can be handled by chams just like the corresponding CCS operators. Like CCS, the -calculus deals with a set N of names and a set L of labels. <p> The agent xy:p sends the name y on channel x. Parallelism 22 is interleaving, and replication conveniently replaces recursion: !p generates p j !p. 5.1 The Original Semantics In <ref> [27] </ref>, Milner presents a semantics in a mixture of SOS and cham styles. Terms are considered modulo structural equalities, which include in particular associativity and commutativity of the parallel operator. This amounts to handle cham multisets in a purely algebraic framework.
Reference: [28] <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A calculus of mobile processes. </title> <type> Technical Report ECS-LFCS-89-85, </type> <institution> LFCS, Edinburgh University, </institution> <year> 1989. </year>
Reference-contexts: 1 Introduction We present the notion of a Chemical Abstract Machine or cham, suited to model concurrent computations. We show that chemical abstract machines can implement known models of concurrent computation such as algebraic process calculi [26, 8], Milner's Mobile Processes calculus <ref> [28, 27] </ref>, and a concurrent -calculus similar to the one presented in [9]. 1 Abstract Machines Abstract machines are widely used in the classical theory of sequential computations. Turing Machines or Random Access Machines are primary tools within the theories of recursive functions and computational complexity. <p> Section 3 gives some formal deonitions. In Section 4, we treat the full TCCS [16] calculus and indicate how to handle other process calculi. Section 5 presents a cham for a subset of Milner's Calculus of Mobile Processes <ref> [28] </ref>. Section 6 is devoted to a concurrent lambda-calculus similar to that of [9].
Reference: [29] <author> Gordon Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report report DAIMI FN-19, </type> <institution> University of Aarhus, </institution> <year> 1981. </year>
Reference-contexts: A specioc machine is deoned by giving the molecule algebra and the rules. The rules have no premisses and are purely local, unlike the inference rules classically used in structural operational semantics <ref> [29] </ref>. In a given cham, we (informally) classify molecules and rules. Not all 3 molecules directly exhibit interaction capabilities. Those which do are called ions. The interaction capability of an ion is generally determined only by a part of it that we call its valence. <p> The CCS agents p, q, etc., are given by the syntax: p ::= O j ff:p j (p j p) j pna 2.1 Inference Rules Semantics Process calculi semantics are usually deoned by inference rules in Plotkin's structural operational semantics style <ref> [29] </ref>, called SOS for short. Milner's original rules involve a special o label representing internal communication. This happens to be quite unnatural with respect to abstract machine executions, where internal transitions should not be visible to the user. <p> This is in the line of the standard notion of an operational semantics, where one uses unlabelled transitions for reduction, evaluation, rewriting, or machine runs, see <ref> [29] </ref>. However, classical process calculi semantics nicely deone observation, and we must also do it if we want to make any use of chams and to deone appropriate equivalence notions. A solution should be able to perform an externally observable ff action whenever it contains an ion ff:p.
Reference: [30] <author> Wolfgang Reisig. </author> <title> Petri Nets: an Introduction. </title> <booktitle> EATCS Monographs on Theoretical Computer Science. </booktitle> <address> SpringerVerlag, </address> <year> 1985. </year>
Reference-contexts: The situation is much less clear in the oeld of concurrent programming. Models such as Petri Nets <ref> [30] </ref>, Communicating Automata [3], or Data Flow Networks [22] can be considered as abstract machines, but certainly they lack expressive power. More expressive models such as Algebraic Process Calculi [26, 8] are intended to be speciocation formalisms for distributed systems rather than abstract machines.
Reference: [31] <author> Bent Thomsen. </author> <title> A calculus of higher-order communicating systems. </title> <booktitle> In Proc. 16th ACM Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 143154, </pages> <year> 1989. </year> <month> 39 </month>
Reference-contexts: On the other hand, the -calculus is intrinsically sequential [6, 7] and cannot handle even the weakest form of concurrency. Building new calculi that combine both abilities is a goal of primary importance <ref> [9, 31] </ref>. In [9], we introduced such a tentative concurrent lambda-calculus called the fl-calculus. We could describe the (lazy) evaluation in this calculus by means of a cham. However, our formalism itself suggests a simpler and perhaps better calculus of the same kind. <p> Consider, for instance, the -term ((x:y:M )N )P . The translation would be x:y:M j (N ) j (P ). The associative/commutative character of concur-rency would make the arguments N and P interchangeable, which is clearly wrong. Thomsen solved this problem in <ref> [31] </ref> using the CCS operators of restriction and renaming. However in his higher order calculus, fi-reduction is performed in two steps, involving an intermediary state which does not represent a -term. Then the -calculus is not exactly a sub-calculus of Thomsen's CHOCS calculus. <p> This is a semantic statement, so we would have orst to deone an equivalence relation ' on fl-terms such that: OK ' K ' OK O ' In [9] it was proposed to adapt the notion of observational bisimulation of CCS <ref> [26, 31] </ref> to serve as the semantic equivalence. We could deone this notion here, with the idea that x is an input guard and M + an output action, but this does not seem to be a good choice.
References-found: 31

