URL: http://www.cs.umn.edu/Research/Agassiz/Paper/lim.lcpc96.ps.Z
Refering-URL: http://www.cs.umn.edu/Research/Agassiz/agassiz_pubs.html
Root-URL: http://www.cs.umn.edu
Phone: 2  3  
Title: Compiler Support for Maintaining Cache Coherence Using Data Prefetching (Extended Abstract)  
Author: Hock-Beng Lim Lynn Choi and Pen-Chung Yew 
Address: Urbana, IL 61801  Santa Clara, CA 95095  Minneapolis, MN 55455  
Affiliation: 1 Center for Supercomputing R D, Univ. of Illinois,  Microprocessor Group, Intel Corporation,  Dept. of Computer Science, Univ. of Minnesota,  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> L. Choi. </author> <title> Hardware and Compiler Support for Cache Coherence in Large-Scale Multiprocessors. </title> <type> PhD thesis, </type> <institution> Center for Supercomputing R & D, UIUC, </institution> <month> March </month> <year> 1996. </year>
Reference-contexts: Three main program analysis techniques are used in stale reference analysis : stale reference detection, array data-flow analysis, and interprocedural analysis <ref> [1] </ref>. 3.2 Prefetch Target Analysis Since prefetch operations introduce instruction execution and network traffic overheads, it is important to minimize the number of unnecessary prefetches. The prefetch target analysis algorithm determines which potentially stale references should be prefetched.
Reference: 2. <author> L. Choi, H.-B. Lim, and P.-C. Yew. </author> <title> Multiprocessor cache coherence : A compiler-directed approach. </title> <note> To appear in IEEE Parallel & Distributed Tech., </note> <month> Winter </month> <year> 1996. </year>
Reference-contexts: Private caches for processors have been used to reduce the number of main memory accesses. However, the use of private caches leads to the classic cache coherence problem. Compiler-directed cache coherence schemes <ref> [2] </ref> offer a viable solution to this problem for large-scale shared-memory multiprocessors. Although compiler-directed cache coherence schemes can improve multiprocessor cache performance, they cannot totally eliminate main memory accesses. Thus, data prefetching schemes have been developed to hide the memory latency.
Reference: 3. <author> E. Gornish. </author> <title> Compile time analysis for data prefetching. </title> <type> Master's thesis, </type> <institution> Center for Supercomputing R & D, UIUC, </institution> <month> December </month> <year> 1989. </year>
Reference-contexts: Our prefetch scheduling algorithm considers each inner loop and serial code section of the program, and attempts to make a good engineering decision to use one of the following prefetch scheduling techniques : Vector prefetch generation Gornish developed an algorithm that can be used to pull out <ref> [3] </ref> array references from loops for prefetching. We adapted his approach for the CCDP scheme by imposing a restriction on the number of loop levels from which ar-ray references should be pulled, in order to maximize the effectiveness of the vector prefetches. <p> This is done in the same manner as Gornish's algorithm to pull back <ref> [3] </ref> references. To ensure correctness and to maximize the effectiveness of the prefetches, our algorithm uses a parameter to decide whether to move back a prefetch operation.
Reference: 4. <author> T. Mowry. </author> <title> Tolerating Latency Through Software-Controlled Data Prefetching. </title> <type> PhD thesis, </type> <institution> Dept. of Elect. Eng., Stanford University, </institution> <month> March </month> <year> 1994. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: We also check if the amount of data to be prefetched will exceed the available prefetch queue size or the cache size. A vector prefetch will be issued only if these hardware constraints are satisfied. Software pipelining Mowry <ref> [4] </ref> used software pipelining to schedule single cache-line prefetch operations. We adapted the software pipelining algorithm to suit the CCDP scheme. First, we impose a restriction that software pipelining will be used only for inner loops that do not contain branches or recursive procedure calls.
References-found: 4

