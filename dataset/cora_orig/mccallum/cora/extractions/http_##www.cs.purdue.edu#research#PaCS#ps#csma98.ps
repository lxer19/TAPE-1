URL: http://www.cs.purdue.edu/research/PaCS/ps/csma98.ps
Refering-URL: http://www.cs.purdue.edu/research/PaCS/parasol.html
Root-URL: http://www.cs.purdue.edu
Title: A LAZY CALENDAR FOR OPTIMISTIC PARALLEL SIMULATION optimistic parallel simulator's calendar implements rollback and fossil-collect
Author: Reuben Pasquini and Vernon Rego 
Note: An  
Address: West Lafayette, IN 47907-1398  
Affiliation: Department of Computer Sciences Purdue University  
Abstract: A discrete event simulation system uses a calendar to quickly schedule events for execution. A sequential simulator's calendar supports two operations: schedule-event and get-next-event. The schedule-event operation stores an event e in the calendar for execution at some future virtual time t e . The get-next-event operation selects the next event for the simulation to execute. The data structures in most sequential calendars do not support parallel simulation well. We introduce a new lazy hybrid calendar which combines the data structures used in different sequential calendars to efficiently implement the methods needed in optimistic parallel simulation. The lazy calendar also takes advantage of lookahead present in a simulation to avoid scheduling events which are later unscheduled by a rollback. 
Abstract-found: 1
Intro-found: 1
Reference: <author> R. Brown. </author> <year> 1988. </year> <title> "Calendar Queues: A Fast O(1) Priority Queue Implementation for the Simulation Event Set Problem." </title> <journal> Communications of the ACM 31, </journal> <volume> no. 10 (Oct.): </volume> <pages> 1220-1227. </pages>
Reference-contexts: Each event simulated involves one schedule-event and one get-next-event calendar operation. Various efficient calendar implementations have been employed in sequential simulation languages. Most calendar data structures implement some kind of heap based priority queue (a notable exception is the calendar queue <ref> (Brown 1988) </ref>). A heap based priority queue supports the get-next-event and schedule-event operations in O (log n) steps (where n is the size of the calendar) (Chung, Sang, and Rego 1993).
Reference: <author> Corman, T.; Leiserson, C.; and R. Rivest. </author> <year> 1990. </year> <title> Introduction to Algorithms. </title> <institution> Massachusetts Institute of Technology. </institution>
Reference: <author> Chandy, K.M. and J. Misra. </author> <year> 1981. </year> <title> "Asynchronous Distributed Simulation Via a Sequence of Parallel Computations." </title> <journal> Communications of the ACM 24, </journal> <volume> no. 11 (Apr.): </volume> <pages> 198-206. </pages>
Reference-contexts: A PDES must employ an algorithm which ensures that events execute in a causally consistent way. A simulation is causally consistent if events access simulation objects in nondecreasing time-stamp order. In seminal works on achieving causal consistency, <ref> (Chandy and Misra 1981) </ref> and (Jefferson 1985) propose different solutions. The Chandy-Misra algorithm avoids causality errors by ensuring that each processor executes events in time-stamp order. <p> Because of this, the Chandy-Misra algorithm is called a conservative parallel simulation algorithm <ref> (Chandy and Misra 1981) </ref>. The time warp algorithm is an optimistic algorithm for PDES. It is optimistic in the sense that each processor executes every available event in time-stamp order with the optimistic assumption that causality is not being violated.
Reference: <author> Chung, K.; Sang, J.; and V. Rego. </author> <year> 1993. </year> <title> "A Performance Comparison of Event Calendar Algorithms: An Empirical Approach." </title> <journal> Software-Practice and Experience 23, </journal> <volume> no. 10 (Oct.): </volume> <pages> 1107-1138. </pages>
Reference-contexts: Most calendar data structures implement some kind of heap based priority queue (a notable exception is the calendar queue (Brown 1988)). A heap based priority queue supports the get-next-event and schedule-event operations in O (log n) steps (where n is the size of the calendar) <ref> (Chung, Sang, and Rego 1993) </ref>. A doubly linked list (dll) based calendar implements the schedule-event operation in O (n) steps and the get-next-event operation in O (1) steps. Therefore, each simulated event requires O (n) steps in a dll calendar and O (log n) steps in a heap based calendar.
Reference: <author> R. Fujimoto. </author> <year> 1989. </year> <title> "Time Warp on a Shared Memory Multiprocessor." </title> <journal> Transactions of the Society for Computer Simulation 6, </journal> <volume> no. </volume> <month> 3 (July): </month> <pages> 211-239. </pages>
Reference-contexts: Finally, a dll calendar performs the fossil-collect method in O (n) steps by searching for the last calendar entry e executed with time stamp t e jt e &lt; t gvt and discarding the calendar entries before e inclusive. The GTW <ref> (Fujimoto 1989) </ref> PDES system bases its calendar on a heap. A heap supports schedule-event and get-next-event in O (log n) steps.
Reference: <author> D.R. Jefferson. </author> <year> 1985. </year> <title> "Virtual Time." </title> <journal> ACM Transactions on Programming Languages and Systems 7, </journal> <volume> no. </volume> <month> 3 (July): </month> <pages> 404-425. </pages>
Reference-contexts: A PDES must employ an algorithm which ensures that events execute in a causally consistent way. A simulation is causally consistent if events access simulation objects in nondecreasing time-stamp order. In seminal works on achieving causal consistency, (Chandy and Misra 1981) and <ref> (Jefferson 1985) </ref> propose different solutions. The Chandy-Misra algorithm avoids causality errors by ensuring that each processor executes events in time-stamp order. <p> The calendar unexecutes an event e by removing from the calendar every event scheduled during e's execution and sending anti-messages to cancel every event which e scheduled on remote processors <ref> (Jefferson 1985) </ref>. Since the calendar must unexecute each rolled back event, we know that O (m) is a lower bound on the performance of the rollback operation.
Reference: <author> Lin, Y.B. and E.D. Laxowska. </author> <year> 1989. </year> <title> "Exploiting Lookahead in Parallel Simulation." </title> <type> Technical Report 89-10-06. </type> <institution> Department of Computer Science, University of Washington, </institution> <year> 1989. </year>
Reference: <author> Mascarenhas, E.; Knop, F.; and V. Rego. </author> <year> 1995. </year> <title> "ParaSol: A Multi-threaded System for Parallel Simulation Based on Mobile Threads." </title> <booktitle> In Proceedings of the 1995 Winter Simulation Conference. IEEE, </booktitle> <pages> 690-697. </pages>
Reference-contexts: First, in section 2 we introduce ParaSol, the PDES tool we use to evaluate the lazy calendar. Next, in section 3 we introduce our new lazy hybrid calendar and compare its performance with other calendar implementations. Finally, we conclude in section 4. 2 PARASOL We use the ParaSol <ref> (Mascarenhas, Knop, and Rego 1995) </ref> PDES system in our experiments. ParaSol is a set of libraries which extend C++ to support PDES using the process-interaction world view. ParaSol provides a simulation developer with C++ classes with which he can instantiate simulation processes and objects.
Reference: <author> Martin, D.E. and T.J. Mcbrayer. </author> <year> 1997. </year> <pages> "Warped </pages>
Reference-contexts: The SPEEDES calendar is designed for use with a semi-conservative breathing-time-buckets based simulation. Other parallel simulation systems modify sequential calendar data structures for parallel simulation. The WARPED <ref> (Martin and McBrayer 1997) </ref> PDES system uses a doubly linked list (dll) based calendar. A dll calendar implements an m event rollback in O (m) operations. Each event e in the calendar maintains a list of the events scheduled in the calendar as a result of e's execution.
References-found: 9

