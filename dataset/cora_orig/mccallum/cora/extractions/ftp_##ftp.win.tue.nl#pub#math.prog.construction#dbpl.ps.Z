URL: ftp://ftp.win.tue.nl/pub/math.prog.construction/dbpl.ps.Z
Refering-URL: http://www.win.tue.nl/cs/wp/papers/papers.html
Root-URL: http://www.win.tue.nl
Title: A database calculus based on strong monads and partial functions  
Author: Eerke Boiten and Paul Hoogendijk 
Note: Draft March '95; ext.abs. submitted to 5th DBPL  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> R.C. Backhouse, H. Doornbos, and P. Hoogendijk. </author> <title> A class of commuting relators. </title> <booktitle> In Lecture Notes of the STOP 1992 Summer School on Constructive Algorithmics, Ame-land. STOP, </booktitle> <year> 1992. </year> <note> Available via anonymous ftp from ftp.win.tue.nl in directory pub/math.prog.construction. </note>
Reference-contexts: P = id: For lists nest L is an injective function, but unnest L is not its left inverse: unnest L :nest L :[(a ; 5) ; (b ; 1) ; (a ; 7)] = f definition nest L g unnest L :[(a ; [5 ; 7]:) ; (b ; <ref> [1] </ref>) ; (a ; [5 ; 7])] = f definition unnest L g [(a ; 5) ; (a ; 7) ; (b ; 1) ; (a ; 5) ; (a ; 7)] One could argue that either the nest operation on lists should discard the duplicates (making it no longer injective <p> A different class of useful operations for interfacing several datatypes is formed by operations that commute functors, i.e. that convert FG-structures into GF-structures. Our group has studied such operations <ref> [1] </ref>, and called them "zips", after the well known operator that turns a pair of lists of equal length into a list of pairs. The special case where G is the powerset functor P has been studied by de Moor [3] under the name of "cross operators". <p> Altogether, it seems that more research is needed into zips and other data type transformations before a more conclusive form of a query language with multiple collection types can be established. We expect that research done in this group on zips <ref> [1] </ref> and on the so-called Boom hierarchy [7] of datatypes will provide a solid basis for this further research. 7 Summary and conclusions Monads with strength and a monoid structure imposed on them are a nice way to structure a basic query language.
Reference: [2] <author> Val Breazu-Tannen, Peter Buneman, and Limsoon Wong. </author> <title> Naturally embedded query languages. </title> <booktitle> In Proceedings of International Conference on Database Theory, volume 646 of Lecture Notes in Computer Science, </booktitle> <pages> pages 140-154, </pages> <address> Berlin, 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The choice for exactly this set of axioms is motivated by category theory (the axioms are such that they characterize the categorical constructs that are mentioned in the boldface labels) and other presentations of this calculus <ref> [13, 2] </ref>. Of course these axioms hold for the interpretation we have given. In order to save on typing constraints in the axioms, it is assumed that all arrows are typed in a way that makes the compositions and other constructs well-defined. <p> The expressive power of this calculus is that of the nested relational algebra [10] with equality test, as is shown in the presentation of this calculus in <ref> [2] </ref>. <p> Indeed we already wrote Functor (P), Monad (P), etcetera, to suggest that these constructs and laws could be viewed as being parameterized by an arbitrary functor F. Following Wadler [13] we could call this structure a strong ringad. Trinder [12] and Tannen et al <ref> [2] </ref> have argued that this collection of operations forms the essence of so-called bulk- or collection types.
Reference: [3] <author> O. de Moor. </author> <title> Categories, Relations and Dynamic Programming. </title> <type> PhD thesis, </type> <institution> Oxford University Laboratory, Programming Research Group, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: Our group has studied such operations [1], and called them "zips", after the well known operator that turns a pair of lists of equal length into a list of pairs. The special case where G is the powerset functor P has been studied by de Moor <ref> [3] </ref> under the name of "cross operators".
Reference: [4] <author> Peter Freyd, Paul Hoogendijk, and Oege de Moor. </author> <title> Membership of datatypes. </title> <type> Unpublished manuscript, </type> <year> 1993. </year>
Reference-contexts: In category theory, this function is called the strength of the powerset functor. Defined as a comprehension, it is In general the strength of a functor F is a natural transformation from FA fi B to F (A fi B), which has interesting links with the concept of membership <ref> [4] </ref>. <p> For example, to define a deterministic conversion from bags to lists one needs an order on the element type, which need not exist. As can be checked by type analysis 8 The paper <ref> [4] </ref> gives a definition of setify F in terms of the membership relation of F , which is strongly related to the strength of F.
Reference: [5] <author> P.J. Freyd and A. Scedrov. </author> <title> Categories, </title> <publisher> Allegories. North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: The powerset operator [6] is not available as a computational construct in our setting. 3 We have moved away from real abstract category theory here by mentioning the "subsets" of an object. A categorically sound definition of the powerset functor exists, see <ref> [5] </ref> or some other textbook. <p> They might also be interested to know that TotjF can for any F easily be expressed without applications and case distinctions if the base category is a boolean division allegory <ref> [5] </ref>. 5 Note that here follows another Kleisli composition. 6 Even though we allowed equality test for all types, it must be taken into account that it is an expensive operation on sets. 5 4 Sets as first class ob jects: the nested relational calculus In the previous sections we built
Reference: [6] <author> Marc Gyssens and Dirk Van Gught. </author> <title> A comparison between algebraic query languages for flat and nested databases. </title> <journal> Theoretical Computer Science, </journal> <volume> 87 </volume> <pages> 263-286, </pages> <year> 1991. </year>
Reference-contexts: The powerset operator <ref> [6] </ref> is not available as a computational construct in our setting. 3 We have moved away from real abstract category theory here by mentioning the "subsets" of an object. A categorically sound definition of the powerset functor exists, see [5] or some other textbook.
Reference: [7] <author> P.F. Hoogendijk and R.C. Backhouse. </author> <title> Relational programming laws in the tree, list, bag, set hierarchy. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 22 </volume> <pages> 67-105, </pages> <year> 1994. </year>
Reference-contexts: had that unnest P ffi nest P = id: For lists nest L is an injective function, but unnest L is not its left inverse: unnest L :nest L :[(a ; 5) ; (b ; 1) ; (a ; 7)] = f definition nest L g unnest L :[(a ; <ref> [5 ; 7] </ref>:) ; (b ; [1]) ; (a ; [5 ; 7])] = f definition unnest L g [(a ; 5) ; (a ; 7) ; (b ; 1) ; (a ; 5) ; (a ; 7)] One could argue that either the nest operation on lists should discard the <p> lists nest L is an injective function, but unnest L is not its left inverse: unnest L :nest L :[(a ; 5) ; (b ; 1) ; (a ; 7)] = f definition nest L g unnest L :[(a ; <ref> [5 ; 7] </ref>:) ; (b ; [1]) ; (a ; [5 ; 7])] = f definition unnest L g [(a ; 5) ; (a ; 7) ; (b ; 1) ; (a ; 5) ; (a ; 7)] One could argue that either the nest operation on lists should discard the duplicates (making it no longer injective since order information is <p> Altogether, it seems that more research is needed into zips and other data type transformations before a more conclusive form of a query language with multiple collection types can be established. We expect that research done in this group on zips [1] and on the so-called Boom hierarchy <ref> [7] </ref> of datatypes will provide a solid basis for this further research. 7 Summary and conclusions Monads with strength and a monoid structure imposed on them are a nice way to structure a basic query language. This is by no means a new observation.
Reference: [8] <author> L. Libkin. </author> <title> Normalizing incomplete databases. </title> <booktitle> In PODS-95, </booktitle> <year> 1995. </year>
Reference-contexts: ; L turns a list of m lists of length n into a list of n lists of length m in the obvious way. 10 A final example of the use of zips is in the approach to query languages for databases with partial information advocated by Libkin and Wong <ref> [9, 8] </ref>. They combine a collection type (sets or bags) with a version of sets that has a non-standard interpretation (but is otherwise identical), the so-called or-sets. An or-set conceptually represents one of the values in it.
Reference: [9] <author> L. Libkin and L. Wong. </author> <title> Semantic representations and query languages for or-sets. </title> <booktitle> In PODS-93, </booktitle> <pages> pages 155-166, </pages> <year> 1993. </year>
Reference-contexts: ; L turns a list of m lists of length n into a list of n lists of length m in the obvious way. 10 A final example of the use of zips is in the approach to query languages for databases with partial information advocated by Libkin and Wong <ref> [9, 8] </ref>. They combine a collection type (sets or bags) with a version of sets that has a non-standard interpretation (but is otherwise identical), the so-called or-sets. An or-set conceptually represents one of the values in it.
Reference: [10] <author> H.-J. Schek and M.H. Scholl. </author> <title> The relational model with relation-valued attributes. </title> <journal> Information systems, </journal> <volume> 11(2) </volume> <pages> 137-147, </pages> <year> 1986. </year>
Reference-contexts: The expressive power of this calculus is that of the nested relational algebra <ref> [10] </ref> with equality test, as is shown in the presentation of this calculus in [2].
Reference: [11] <author> Val Tannen. </author> <title> Tutorial: Languages for collection types. </title> <booktitle> Slides for the 13th ACM Conference on Principles of Database Systems. Available via World Wide Web on file://ftp.cis.upenn.edu/pub/papers/db_research/pods94t_slide.ps.Z, </booktitle> <year> 1994. </year>
Reference-contexts: T 6= ;g unnest :T = f (x ; y) j 9 (S : (x ; S) 2 T : y 2 S)g In our calculus they are the beauty: unnest P ; A ; B = ext P :stl P ; A ; B and the beast (translated from <ref> [11] </ref>): nest P;A;B = map P :( o A;P (AfiB) 4 f ) ffi str P;A;P (AfiB) ffi ( A;B 4 id P (AfiB) ) where f = 0 A fi A ; B ffi lift P :(equal A fi id B ) ffi stl P;A;AfiB Note that this nested algebra
Reference: [12] <author> P.W. Trinder. </author> <title> Comprehensions a query notation for DBPLs. </title> <booktitle> In Proceedings of the 1990 Glasgow Database Workshop, </booktitle> <pages> pages 95-102, </pages> <address> Glasgow, Scotland, </address> <month> March </month> <year> 1990. </year>
Reference-contexts: Indeed we already wrote Functor (P), Monad (P), etcetera, to suggest that these constructs and laws could be viewed as being parameterized by an arbitrary functor F. Following Wadler [13] we could call this structure a strong ringad. Trinder <ref> [12] </ref> and Tannen et al [2] have argued that this collection of operations forms the essence of so-called bulk- or collection types.
Reference: [13] <author> Philip Wadler. </author> <note> Notes on monads and ringads. Unpublished note, </note> <year> 1990. </year>
Reference-contexts: The choice for exactly this set of axioms is motivated by category theory (the axioms are such that they characterize the categorical constructs that are mentioned in the boldface labels) and other presentations of this calculus <ref> [13, 2] </ref>. Of course these axioms hold for the interpretation we have given. In order to save on typing constraints in the axioms, it is assumed that all arrows are typed in a way that makes the compositions and other constructs well-defined. <p> Indeed we already wrote Functor (P), Monad (P), etcetera, to suggest that these constructs and laws could be viewed as being parameterized by an arbitrary functor F. Following Wadler <ref> [13] </ref> we could call this structure a strong ringad. Trinder [12] and Tannen et al [2] have argued that this collection of operations forms the essence of so-called bulk- or collection types.
Reference: [14] <author> R.F.C. Walters. </author> <title> The free category with products on a multigraph. </title> <journal> J. Pure & Applied Algebra, </journal> <volume> 62 </volume> <pages> 199-203, </pages> <year> 1989. </year>
Reference-contexts: Disallowing products of the type A fi A seems awkward, so we introduce the "semi-commutativity" axiom below, which states that values of different type may be exchanged in products. 1 That this is sound practice is proved in <ref> [14] </ref>: for any category with products an equivalent category with associative products exists. 2 Axiom 5 (Semi-commutativity) Let swap A ; B = AE A;B 4 o A;B , the isomorphism between A fi B and B fi A: If A and B are relatively prime, then swap A ; B
References-found: 14

