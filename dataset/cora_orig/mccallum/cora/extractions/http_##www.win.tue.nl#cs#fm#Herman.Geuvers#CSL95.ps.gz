URL: http://www.win.tue.nl/cs/fm/Herman.Geuvers/CSL95.ps.gz
Refering-URL: http://www.win.tue.nl/cs/fm/Herman.Geuvers/
Root-URL: http://www.win.tue.nl
Email: gilles@cwi.nl  herman@win.tue.nl  
Phone: 2  3  
Title: Congruence types  
Author: Gilles Barthe ; and Herman Geuvers ; 
Address: Amsterdam, The Netherlands,  Eindhoven, The Netherlands,  Netherlands  
Affiliation: 1 Centrum voor Wiskunde en Informatica (CWI),  Faculty of Mathematics and Informatics, Technical University of  Faculty of Mathematics and Informatics, University of Nijmegen, The  
Abstract: We introduce a type-theoretical framework in which canonical term rewriting systems can be represented faithfully both from the logical and the computational points of view. The framework is based on congruence types, a new syntax which combines inductive, algebraic and quotient types. Congruence types improve on existing work to combine type theories with algebraic rewriting by making explicit the fact that the term-rewriting systems under consideration are initial models of an equational theory. As a result, the interaction gustavo:thesisween the type theory and the algebraic types (rewriting systems) is much more powerful than in previous work. Congruence types can be used (i) to introduce initial models of canonical term-rewriting systems (ii) to obtain a suitable computational behavior of a definable operation (iii) to provide an elegant solution to the problem of equational reasoning in type theory. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <editor> S. Abramsky, D. Gabbay, and T. Maibaum, editors. </editor> <booktitle> Handbook of Logic in Computer Science. </booktitle> <publisher> Oxford Science Publications, </publisher> <year> 1992. </year>
Reference: 2. <author> R. Backhouse, P. Chisholm, and G. Malcolm. </author> <title> Do-it-yourself type theory (part I). </title> <journal> BEATCS: Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 68-110, </pages> <year> 1988. </year>
Reference: 3. <author> R. Backhouse, P. Chisholm, and G. Malcolm. </author> <title> Do-it-yourself type theory (part II). </title> <journal> BEATCS: Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> 35 </volume> <pages> 205-244, </pages> <year> 1988. </year>
Reference: 4. <author> F. Barbanera, M. Fernandez, and H. </author> <title> Geuvers. Modularity of strong normalisation and confluence in the algebraic -cube. </title> <booktitle> In Proceedings of LICS'94, </booktitle> <pages> pages 406-415. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction The combination of type systems with algebraic rewriting systems has given rise to algebraic-functional languages, a class of very powerful programming languages (see for example <ref> [4, 9, 12, 22] </ref>). Yet these frameworks only allow for a limited interaction between the algebraic rewriting systems and the type theory. For example, if Zis defined as an algebraic type, one cannot define the absolute value or prove that every integer is either positive or negative. <p> In presence of ae-reduction, one cannot rely on subject reduction or confluence of the combined reduction relation on the set of pseudo-terms to prove soundness. The solution is to replace the conversion rule by the reduction-expansion rule (see <ref> [4] </ref>). The construction of these terms is rather intricate and involves the definition of a normal form map nf : Z ! Z with suitable properties. The construction will be reported elsewhere. The term F behaves as a kind of `primitive recursor for the integers'. <p> Because fiOae-reduction is not Church-Rosser on the pseudo-terms, this involves some extra technicalities that were developped in <ref> [4] </ref> for the addition of algebraic rewriting to CC. Proposition 2 (Subject Reduction) If ` a : A and a ! fiOae a 0 , then ` a 0 : A.
Reference: 5. <author> H.P. Barendregt. </author> <title> Lambda calculi with types. </title> <editor> In Abramsky et al. </editor> <volume> [1], </volume> <pages> pages 117-309. Volume 2. </pages>
Reference: 6. <author> G. Barthe. </author> <title> Extensions of pure type systems. </title> <booktitle> In Dezani-Ciancaglini and Plotkin [16], </booktitle> <pages> pages 16-31. </pages>
Reference-contexts: The congruence type defined from this set of rewrite rules gives rise to an inductive type N with constructors 0, s and + and an algebraic type with the reduction rules R. In this framework, + has a suitable computational 4 The reader is refered to <ref> [6, 13, 20, 21] </ref> for a type-theoretic account of quotients. behavior and N gives indeed a suitable representation of N. Note that in this case we are again interested in the quotient type N . Use the quotient structure to prove properties of the algebra of terms (the inductive type).
Reference: 7. <author> G. Barthe. </author> <title> Formalising algebra in type theory: fundamentals and applications to group theory. </title> <type> Manuscript. </type> <note> An earlier version appeared as technical report CSI-R9508, </note> <institution> University of Nijmegen, </institution> <note> under the title `Formalising mathematics in type theory: </note> <institution> fundamentals and case studies', </institution> <year> 1995. </year>
Reference-contexts: The gain here is that if [s] and [t] have a common reduct, then the conclusion is immediate. This use of congruence types is very important in proof-checking and is the basis of lean proof-checking, a two-level approach to formal mathematics for efficient equational reasoning introduced in <ref> [7] </ref> and further developed in [10]. In this paper we want to emphasize especially the usefulness of congruence types and therefore we discuss three examples in quite some detail. Furthermore, we give a definition of the general syntax and an overview of the meta-theory of the system.
Reference: 8. <author> G. Barthe and H. Elbers. </author> <title> Towards lean proof checking. </title> <type> Manuscript, </type> <year> 1996. </year>
Reference-contexts: In <ref> [10, 8] </ref>, Barthe et al. have proposed oracle types as a theoretical framework to study the combination of proof-checkers and computer algebra systems. <p> Another important direction for research is the application of congruence and oracle types in proof-checking. Extending the framework of oracle types to cover many forms of rewriting would enable the two-level approach of <ref> [8, 10] </ref> to be extended to a significant class of problems, including for example a decision procedure to detect logical equivalence of formulae of propositional logic.
Reference: 9. <author> G. Barthe and H. </author> <title> Geuvers. Modular properties of algebraic pure type systems. </title> <editor> In G. Dowek, J. Heering, K. Meinke, and B. Moller, editors, </editor> <booktitle> Proceedings of HOA'95, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: 1 Introduction The combination of type systems with algebraic rewriting systems has given rise to algebraic-functional languages, a class of very powerful programming languages (see for example <ref> [4, 9, 12, 22] </ref>). Yet these frameworks only allow for a limited interaction between the algebraic rewriting systems and the type theory. For example, if Zis defined as an algebraic type, one cannot define the absolute value or prove that every integer is either positive or negative.
Reference: 10. <author> G. Barthe, M. Ruys, and H. Barendregt. </author> <title> A two-level approach towards lean proof-checking. </title> <editor> In S. Berardi and M. Coppo, editors, </editor> <booktitle> Proceedings of TYPES'95, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1996. </year> <note> To appear. </note>
Reference-contexts: This use of congruence types is very important in proof-checking and is the basis of lean proof-checking, a two-level approach to formal mathematics for efficient equational reasoning introduced in [7] and further developed in <ref> [10] </ref>. In this paper we want to emphasize especially the usefulness of congruence types and therefore we discuss three examples in quite some detail. Furthermore, we give a definition of the general syntax and an overview of the meta-theory of the system. The paper is organised as follows. <p> See section 2. Applications of congruence types to proof-checking Congruence types provide a suitable framework to ease the problem of equational reasoning in proof-checking. As argued in <ref> [10] </ref>, they also lay the foundations for a theoretical study of the interaction between computer algebra systems and proof-checkers. See section 4.2. Prerequisites and terminology The paper assumes some familiarity with pure type systems ([5, 17]), inductive types (see for example [26]) and first-order term-rewriting ([15, 23]). <p> In <ref> [10, 8] </ref>, Barthe et al. have proposed oracle types as a theoretical framework to study the combination of proof-checkers and computer algebra systems. <p> Another important direction for research is the application of congruence and oracle types in proof-checking. Extending the framework of oracle types to cover many forms of rewriting would enable the two-level approach of <ref> [8, 10] </ref> to be extended to a significant class of problems, including for example a decision procedure to detect logical equivalence of formulae of propositional logic.
Reference: 11. <author> G. Betarte. </author> <title> A machine-assisted proof that the integers form an integral domain. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, Chalmers University, </institution> <year> 1993. </year>
Reference: 12. <author> V. Breazu-Tannen. </author> <title> Combining algebra and higher-order types. </title> <booktitle> In Proceedings of LICS'88, </booktitle> <pages> pages 82-90. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1988. </year>
Reference-contexts: 1 Introduction The combination of type systems with algebraic rewriting systems has given rise to algebraic-functional languages, a class of very powerful programming languages (see for example <ref> [4, 9, 12, 22] </ref>). Yet these frameworks only allow for a limited interaction between the algebraic rewriting systems and the type theory. For example, if Zis defined as an algebraic type, one cannot define the absolute value or prove that every integer is either positive or negative. <p> Church-Rosser and strongly normalizing) term-rewriting systems. It turns out that all the standard results for the Calculus of Constructions hold for its extension with congruence types. Note however that proofs are complicated by the fact that fiOae-reduction is not confluent on pseudo-terms (see <ref> [12] </ref> for a counterexample). A relatively easy fact, but nevertheless a key observation is the following.
Reference: 13. <author> R.L. Constable, S.F. Allen, H.M. Bromley, W.R. Cleaveland, J.F. Cremer, R.W. Harper, D.J. Howe, T.B. Knoblock, N.P. Mendler, P. Panangaden, J.T. Sasaki, and S.F. Smith. </author> <title> Implementing Mathematics with the NuPrl Development System. </title> <publisher> Prentice-Hall, inc., </publisher> <address> Englewood Cliffs, New Jersey, first edition, </address> <year> 1986. </year>
Reference-contexts: The congruence type defined from this set of rewrite rules gives rise to an inductive type N with constructors 0, s and + and an algebraic type with the reduction rules R. In this framework, + has a suitable computational 4 The reader is refered to <ref> [6, 13, 20, 21] </ref> for a type-theoretic account of quotients. behavior and N gives indeed a suitable representation of N. Note that in this case we are again interested in the quotient type N . Use the quotient structure to prove properties of the algebra of terms (the inductive type).
Reference: 14. <author> T. Coquand. </author> <title> Pattern matching in type theory. </title> <editor> In B. Nordstrom, ed-itor, </editor> <booktitle> Informal proceedings of LF'92, </booktitle> <pages> pages 66-79, </pages> <year> 1992. </year> <note> Available from http://www.dcs.ed.ac.uk/lfcsinfo/research/types-bra/proc/index.html. </note>
Reference-contexts: Congruence types and pattern-matching It is possible to use congruence types to give a computationally faithful representation of definable operators on inductive types. In effect, congruence types share some of the power of pattern-matching as introduced by Coquand in <ref> [14] </ref>. See section 4.1. Congruence types and algebraic rewriting Congruence types are also more expressive than algebraic rewriting because of the presence of elimination principles. They are closely related to Jouannaud and Okada's algebraic functional paradigm ([4, 22]). <p> Hence + has not the expected computational behavior. This fact was already pointed out in <ref> [14] </ref> as a motivating example to introduce pattern-matching in type theory. Congruence types offer an alternative approach to define a type of natural numbers with well-behaved arithmetical operations. <p> Note that, as N is inductively definable, every closed algebraic term reduces to a fundamental algebraic term, i.e. one built from the fundamental constructors. Congruence types and pattern-matching It is particularly interesting to compare our syntax with pattern-matching as introduced in <ref> [14] </ref>. Both offer a means to give a computationally adequate representation of definable operations on inductive types. Technically, this is achieved by different means. <p> The structure of rewrite rules allowed is more liberal in the syntax of congruence types than in the syntax of pattern-matching. For example, the rule + (+ x y) z ! + x (+ y z) does not satisfy the criterion given in <ref> [14] </ref>. 4.2 The free group over a set of atoms Oracle types is another syntax for introducing term-rewriting systems in type theory, obtained from congruence types by forgetting the rep constructor and its associated reduction rules.
Reference: 15. <author> N. Dershowitz and J-P. Jouannaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <title> Formal models and semantics. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> volume B, </volume> <pages> pages 243-320. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference: 16. <editor> M. Dezani-Ciancaglini and G. Plotkin, editors. </editor> <booktitle> Proceedings of TLCA'95, volume 902 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference: 17. <author> H. </author> <title> Geuvers. Logics and type systems. </title> <type> PhD thesis, </type> <institution> University of Nijmegen, </institution> <year> 1993. </year>
Reference: 18. <author> H. </author> <title> Geuvers. A short and flexible proof of strong normalisation for the calculus of constructions. </title> <editor> In P. Dybjer, B. Nordstrom, and J. Smith, editors, </editor> <booktitle> Proceedings of TYPES'94, volume 996 of Lecture Notes in Computer Science, </booktitle> <pages> pages 14-38. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Then CC extended with the congruence types associated to S 1 , : : : , S n is strongly normalising. The proof is an adaptation of the semantical proof of strong normalisation for CC with (first-order) inductive types given in <ref> [18] </ref>. Corollary 4 1.
Reference: 19. <author> H. Geuvers and B. Werner. </author> <title> On the Church-Rosser property for expressive type systems and its consequence for their metatheoretic study. </title> <booktitle> In Proceedings of LICS'94, </booktitle> <pages> pages 320-329. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: : Z:(neg x) ! P ! P a term F (f 0 ; f s ; f p ) of type Z ! P . is that for every two convertible legal types A and B, there exists a conversion path through legal types; this property is called soundness in <ref> [19] </ref>. Soundness is a very desirable property of the system because it ensures that non-typable terms do not play any role in derivations. In presence of ae-reduction, one cannot rely on subject reduction or confluence of the combined reduction relation on the set of pseudo-terms to prove soundness.
Reference: 20. <author> M. Hofmann. </author> <title> A simple model for quotient types. </title> <booktitle> In Dezani-Ciancaglini and Plotkin [16], </booktitle> <pages> pages 216-234. </pages>
Reference-contexts: The congruence type defined from this set of rewrite rules gives rise to an inductive type N with constructors 0, s and + and an algebraic type with the reduction rules R. In this framework, + has a suitable computational 4 The reader is refered to <ref> [6, 13, 20, 21] </ref> for a type-theoretic account of quotients. behavior and N gives indeed a suitable representation of N. Note that in this case we are again interested in the quotient type N . Use the quotient structure to prove properties of the algebra of terms (the inductive type).
Reference: 21. <author> B. Jacobs. </author> <title> Categorical logic and type theory. </title> <journal> 199-. </journal> <note> Book. In preparation. </note>
Reference-contexts: The congruence type defined from this set of rewrite rules gives rise to an inductive type N with constructors 0, s and + and an algebraic type with the reduction rules R. In this framework, + has a suitable computational 4 The reader is refered to <ref> [6, 13, 20, 21] </ref> for a type-theoretic account of quotients. behavior and N gives indeed a suitable representation of N. Note that in this case we are again interested in the quotient type N . Use the quotient structure to prove properties of the algebra of terms (the inductive type).
Reference: 22. <author> J-P. Jouannaud and M. Okada. </author> <title> Executable higher-order algebraic specification languages. </title> <booktitle> In Proceedings of LICS'91, </booktitle> <pages> pages 350-361. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction The combination of type systems with algebraic rewriting systems has given rise to algebraic-functional languages, a class of very powerful programming languages (see for example <ref> [4, 9, 12, 22] </ref>). Yet these frameworks only allow for a limited interaction between the algebraic rewriting systems and the type theory. For example, if Zis defined as an algebraic type, one cannot define the absolute value or prove that every integer is either positive or negative.
Reference: 23. <editor> J-W. Klop. Term-rewriting systems. In Abramsky et al. </editor> <volume> [1], </volume> <pages> pages 1-116. Volume 2. </pages>
Reference: 24. <author> Z. Luo. </author> <title> Computation and Reasoning: A Type Theory for Computer Science. </title> <booktitle> Number 11 in International Series of Monographs on Computer Science. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1994. </year>
Reference: 25. <author> B. Nordstrom, K. Petersson, and J. Smith. </author> <title> Programming in Martin-Lof's Type Theory. An Introduction. </title> <booktitle> Number 7 in International Series of Monographs on Computer Science. </booktitle> <publisher> Oxford University Press, </publisher> <year> 1990. </year>
Reference: 26. <author> C. Paulin-Mohring. </author> <title> Inductive definitions in the system Coq. Rules and properties. </title> <editor> In M. Bezem and J-F. Groote, editors, </editor> <booktitle> Proceedings of TLCA'93, volume 664 of Lecture Notes in Computer Science, </booktitle> <pages> pages 328-345. </pages> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: As argued in [10], they also lay the foundations for a theoretical study of the interaction between computer algebra systems and proof-checkers. See section 4.2. Prerequisites and terminology The paper assumes some familiarity with pure type systems ([5, 17]), inductive types (see for example <ref> [26] </ref>) and first-order term-rewriting ([15, 23]). A signature is a pair = (F ; Ar) where F is a set (the set of function symbols) and Ar : F ! N is the arity map. Term-rewriting systems are defined as usual.

References-found: 26

