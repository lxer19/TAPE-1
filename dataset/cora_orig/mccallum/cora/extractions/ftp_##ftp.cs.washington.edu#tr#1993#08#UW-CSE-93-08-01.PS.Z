URL: ftp://ftp.cs.washington.edu/tr/1993/08/UW-CSE-93-08-01.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Title: A (More) Formal Definition of Communicating Real-Time State Machines  
Author: Alan C. Shaw 
Pubnum: Technical Report No. 93-08-01  
Abstract: The language of communicating real-time state machines is defined precisely in three parts. First, the syntax of a single machine and of a set of connected machines are described. Then, the static semantics is described as the set of execution paths obtained through a static analysis. Finally, the dynamic semantics is defined by specifying a simulation algorithm that produces execution traces or histories. The most difficult and interesting aspect is that dealing with time.
Abstract-found: 1
Intro-found: 1
Reference: [Hoare 85] <author> C. Hoare, </author> <title> Communicating Sequential Processes, </title> <booktitle> Prentice-Hall International, </booktitle> <address> Englewood Cliffs, NJ, </address> <year> 1985. </year>
Reference-contexts: 1 Introduction Communicating Real-Time State Machines (CRSMs), a requirements and design specification language for real-time systems, were introduced and defined informally in [Shaw 92]. They are uni versal state machines, with guarded commands as transitions, synchronous IO communication over unidirectional channels much like Hoare's CSP <ref> [Hoare 85] </ref>, and mechanisms for specifying execution times of transitions and for accessing real-time, using a continuous time model.
Reference: [Raju 93] <author> S. Raju, </author> <title> "An Automatic Verification Technique for Communicating Real-Time State Machines," </title> <type> TR #93-04-08, </type> <institution> Dept. of Computer Science & Engineering, University of Washington, </institution> <address> Seattle, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: A discrete time version of CRSMs has been implemented [Raju & Shaw 92]. Further, a verifier for the discrete time version based on timed reachability graphs has been developed and built <ref> [Raju 93] </ref>. In the verifier paper, Raju presents a "tuple" definition for the form or syntax of discrete time CRSMs. Our purpose here is to provide a more precise definition of the semantics of CRSMs. We do this in three parts.
Reference: [Raju & Shaw 92] <author> S. Raju and A. Shaw, </author> <title> "A Prototyping Environment for Specifying, Executing and Checking Communicating Real-Time State Machines," </title> <type> TR #92-10-03, </type> <institution> Dept. of Computer Science & Engineering, University of Washington, </institution> <address> Seattle, </address> <month> October </month> <year> 1992. </year> <note> A revised version is in publication in the journal Software-Practice & Experience. </note>
Reference-contexts: The original paper described the CRSM notation, presented many applications examples, outlined an algorithm for simulating the execution of a system of CRSMs, and discussed some methods for reasoning about system behaviors in terms of CRSM event traces. A discrete time version of CRSMs has been implemented <ref> [Raju & Shaw 92] </ref>. Further, a verifier for the discrete time version based on timed reachability graphs has been developed and built [Raju 93]. In the verifier paper, Raju presents a "tuple" definition for the form or syntax of discrete time CRSMs.
Reference: [Shaw 92] <author> A. Shaw, </author> <title> "Communicating Real-Time State Machines," </title> <journal> IEEE Trans. on Software Eng., </journal> <volume> Vol. 18, No. 9, </volume> <month> September </month> <year> 1992, </year> <pages> pp. 805-816. 14 </pages>
Reference-contexts: 1 Introduction Communicating Real-Time State Machines (CRSMs), a requirements and design specification language for real-time systems, were introduced and defined informally in <ref> [Shaw 92] </ref>. They are uni versal state machines, with guarded commands as transitions, synchronous IO communication over unidirectional channels much like Hoare's CSP [Hoare 85], and mechanisms for specifying execution times of transitions and for accessing real-time, using a continuous time model. <p> When the context is obvious, we will omit the "M:" notation. The algorithm for each step in the simulation is essentially the three-phase one presented in <ref> [Shaw 92] </ref>. Errors in the time bound expressions, the "semantic" errors mentioned in Sec. 4.1, are not checked for, but this check could be added easily. 9 Phase 1: Construct a set of possible next events NEL (M ) for each machine M .
References-found: 4

