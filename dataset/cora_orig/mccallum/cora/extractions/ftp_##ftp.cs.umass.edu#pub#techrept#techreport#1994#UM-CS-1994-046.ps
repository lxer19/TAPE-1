URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1994/UM-CS-1994-046.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/94-046.html
Root-URL: 
Email: email: dwyer@cs.umass.edu  
Title: A Compact Petri Net Representation for Concurrent Programs 1 (Research Paper)  
Author: Matthew B. Dwyer Lori A. Clarke Kari A. Niesy 
Address: Amherst, MA 01003  Irvine  
Affiliation: ?Department of Computer Science University of Massachusetts, Amherst  yDept. of Information Computer Science University of California,  
Abstract: This paper presents a compact Petri net representation that is efficient to construct for concurrent programs that use explicit tasking and rendezvous style communication. These Petri nets are based on task interaction graphs and are called TIG-based Petri nets (TPN)s. They form a compact representation by abstracting large regions of program execution with associated summary information that is necessary for performing program analysis. We present a flexible framework for checking a variety of properties of concurrent programs using the reachability graph generated from a TPN. We present experimental results that demonstrate the benefit of TPNs over alternate Petri net representations and discuss the applicability of Petri net reduction techniques to TPNs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G.R. Andrews. </author> <title> Paradigms for process interaction in distributed programs. </title> <journal> ACM Computing Surveys, </journal> <volume> 23(1) </volume> <pages> 49-90, </pages> <month> mar </month> <year> 1991. </year>
Reference-contexts: Such results are useful as an initial indication of the feasibility of an analysis technique. Given that the structure of real concurrent programs <ref> [1] </ref> and the behavior of analysis technique may vary greatly from program to program, however, we need to evaluate 1 analysis techniques over a range of real concurrent programs. To date, there has been little empirical work in this area.
Reference: [2] <author> G.S. Avrunin, U.A. Buy, J.C. Corbett, L.K. Dillon, and J.C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> November </month> <year> 1991. </year>
Reference-contexts: Integer linear programming techniques avoid consideration of the state space entirely. They formulate a set of necessary conditions related to the property of interest and analyze the satisfiability of those conditions by the program <ref> [2] </ref>. For this approach to be successful the necessary conditions must be strong so that the number of spurious analysis results is small. Unfortunately, in the worst case, the algorithm for analyzing these conditions requires exponential time. <p> BDS is a simulation of a border defense system [13]. It contains 15 tasks and has entry calls and accept statements nested within complicated control flow structures. Gas-1 are versions of the one pump gas-station example without deadlock and with the operator task unrolled to accept separate customer entries <ref> [2] </ref>. Phils are versions of the basic dining philosophers example with deadlock [2]. RW are versions of the readers/writers example presented in [2]. The number of tasks next to the example name indicates the scale of the problem. <p> Gas-1 are versions of the one pump gas-station example without deadlock and with the operator task unrolled to accept separate customer entries <ref> [2] </ref>. Phils are versions of the basic dining philosophers example with deadlock [2]. RW are versions of the readers/writers example presented in [2]. The number of tasks next to the example name indicates the scale of the problem. <p> Gas-1 are versions of the one pump gas-station example without deadlock and with the operator task unrolled to accept separate customer entries <ref> [2] </ref>. Phils are versions of the basic dining philosophers example with deadlock [2]. RW are versions of the readers/writers example presented in [2]. The number of tasks next to the example name indicates the scale of the problem.
Reference: [3] <author> J.R. Burch, E.M. Clarke, K.L. McMillan, D.L. Dill, and L.J. Hwang. </author> <title> Symbolic model checking : 10 20 states and beyond. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 428-439, </pages> <year> 1990. </year>
Reference-contexts: For some programs, state space reduction is able to decrease the cost considerably but, in general, the cost of these techniques grows exponentially. Symbolic model-checking techniques use a fix-point computation over an encoding of the state transition relation to determine reachability of a given state <ref> [3] </ref>. For some systems this encoding is very compact, allowing time-efficient analysis. Finding a compact encoding can be difficult, however, and for some systems no compact encoding exists, resulting in a worst case state transition relation that is exponential in size.
Reference: [4] <author> S.C. Cheung and J. Kramer. </author> <title> Tractable flow analysis for anomaly detection in distributed programs. </title> <booktitle> In Proceedings of the European Software Engineering Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Unfortunately, in the worst case, the algorithm for analyzing these conditions requires exponential time. Data flow analysis techniques are one of the few concurrency analysis approaches that do not have exponential cost <ref> [4, 6, 8, 14] </ref>. These techniques formulate a set of conditions related to the property to be analyzed as a set of data flow problems whose solution provides information about the validity or satisfiability of those conditions by the program.
Reference: [5] <author> J.C. Corbett. </author> <title> An empirical evaluation of three methods for deadlock analysis of Ada tasking programs. </title> <booktitle> 1994. Proceedings of the International Symposium on Software, Testing and Analysis. </booktitle> <pages> 15 </pages>
Reference-contexts: A recent study <ref> [5] </ref> has compared the cost-effectiveness of state space enumeration, reduction, model-checking and integer programming analysis techniques.
Reference: [6] <author> E. Duesterwald and M.L. Soffa. </author> <title> Concurrency analysis in the presence of procedures using a data flow framework. </title> <booktitle> In Proceedings of the ACM SIGSOFT Symposium on Testing, Analysis and Verification (TAV4), </booktitle> <month> October </month> <year> 1991. </year>
Reference-contexts: Unfortunately, in the worst case, the algorithm for analyzing these conditions requires exponential time. Data flow analysis techniques are one of the few concurrency analysis approaches that do not have exponential cost <ref> [4, 6, 8, 14] </ref>. These techniques formulate a set of conditions related to the property to be analyzed as a set of data flow problems whose solution provides information about the validity or satisfiability of those conditions by the program.
Reference: [7] <author> S. Duri, U. Buy, R. Devarapalli, </author> <title> and S.M. Shatz. Using state space methods for deadlock analysis in Ada tasking. </title> <journal> Software Engineering Notes, </journal> <volume> 18(3) </volume> <pages> 51-60, </pages> <month> July </month> <year> 1993. </year> <booktitle> Proceedings of the International Symposium on Software Testing and Analysis (ISSTA93). </booktitle>
Reference-contexts: suggest that despite the rapid growth of the state space, enumeration methods that consider the entire concurrent program can be practical for small to medium size programs of moderate complexity [25] and that state space reduction techniques can increase the size of the programs that can be considered still further <ref> [7, 22] </ref>. A recent study [5] has compared the cost-effectiveness of state space enumeration, reduction, model-checking and integer programming analysis techniques. <p> Experiments using the TOTAL system were conducted for BDS, versions of Gas-1, Phils and the RW examples <ref> [7, 22, 20] </ref>. The size of Ada-nets, in terms of places and transitions, and the size of the corresponding reachability graphs in terms of states and arcs, are given in figure 7, next to the comparable TPN results. <p> Although the maximum capacity of the TOTAL toolset is not stated, programs whose reachability graphs are as large as 200000 states and 750000 arcs have been analyzed <ref> [7] </ref>. If we assume that reachability graphs are at least that large for the examples where reachability graphs for Ada-nets could not be generated, then our results for the Gas-1 5, Phils 5, and Phils 7 examples also show a compaction on the order of two orders of magnitude. <p> Comparing TPNs and Ada-nets is fair because they represent equivalent amounts of program information. While early work on TOTAL relied on straightforward reachability of Ada-nets [19, 21], more recent work <ref> [7, 22] </ref> has demonstrated that if we are only interested in analyzing programs for deadlock freedom, Petri net reduction techniques are capable of significantly extending the size of problems for which reacha-bility analysis can be performed 3 . 4.2 Checking Properties Checking whether a program exhibits a desired property involves defining <p> Recent experimental data has demonstrated that net reduction techniques are an effective approach to extending the size of programs for which deadlock checking is practical <ref> [7, 22] </ref>. Unfortunately, program deadlocks are not conservatively represented by the set of reachable TPN markings without successors, so we cannot directly apply existing deadlock preserving Petri net reductions. Net reductions can be developed, however, that are applicable to TPNs.
Reference: [8] <author> M.B. Dwyer and L.A. Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <booktitle> 1994. Proceedings of the ACM SIGSOFT Symposium on the Foundations of Software Engineering (to appear). </booktitle>
Reference-contexts: Unfortunately, in the worst case, the algorithm for analyzing these conditions requires exponential time. Data flow analysis techniques are one of the few concurrency analysis approaches that do not have exponential cost <ref> [4, 6, 8, 14] </ref>. These techniques formulate a set of conditions related to the property to be analyzed as a set of data flow problems whose solution provides information about the validity or satisfiability of those conditions by the program.
Reference: [9] <author> K. Forester. </author> <title> TIG-based Petri nets for modeling Ada tasking. </title> <type> Master's thesis, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: The example CFGPN in section 2 has 16 places and 13 transitions. An Ada-net [21] is a CFGPN designed to model Ada programs. An Ada-net for this example has 21 places and 16 transitions <ref> [9] </ref>.
Reference: [10] <author> P. Godefroid and P. Wolper. </author> <title> Using partial orders for the efficient verification of deadlock freedom and safety properties. </title> <booktitle> In Proceedings of the Third Workshop on Computer Aided Verification, </booktitle> <pages> pages 417-428, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: The state space considered by these methods can be reduced by maintaining only the parts of the state space that are relevant to the analysis of a particular property, such as deadlock freedom <ref> [10, 22] </ref>. For some programs, state space reduction is able to decrease the cost considerably but, in general, the cost of these techniques grows exponentially. Symbolic model-checking techniques use a fix-point computation over an encoding of the state transition relation to determine reachability of a given state [3].
Reference: [11] <author> D.L. Long and L.A. Clarke. </author> <title> Task interaction graphs for concurrency analysis. </title> <booktitle> In Proceedings of the 11th International Conference on Software Engineering, </booktitle> <pages> pages 44-52, </pages> <address> Pittsburgh, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: We have developed a framework for experimenting with a variety of state space enumeration analyses that is based on task interaction graphs (TIG)s <ref> [11] </ref> and Petri nets [17]. Petri nets are a well-studied representation for concurrent systems [16]. This paper presents a Petri net representation, called TIG-based Petri nets (TPN)s, that is efficient to construct for concurrent programs that use explicit tasking and rendezvous style communication. <p> The reachability graph of this type of Petri net has been used to perform analysis of Ada tasking programs [15, 19]. Task Interaction Graphs TIGs have been proposed by Long and Clarke <ref> [11] </ref> as a compact representation for a rich class of tasking programs. TIGs divide tasks into maximal sequential regions, where such task regions define all of the possible behaviors between two consecutive task interactions. <p> The TIG abstraction hides task control flow information and thus results in a smaller graph than a traditional control flow graph. An overview of the TIG representation for a subset of Ada is given below; a more 3 complete description is found in <ref> [11] </ref>.
Reference: [12] <author> D. Mandrioli, R. Zicari, C. Ghezzi, and F. Tisato. </author> <title> Modeling the Ada task system by Petri nets. </title> <journal> Computer Languages, </journal> <volume> 10(1) </volume> <pages> 43-61, </pages> <year> 1985. </year>
Reference-contexts: A transition that is never enabled is called dead. the paper. Petri net models of concurrent programs have existed for some time; they are usually constructed from the set of control flow graphs for the tasks of the program <ref> [12, 15, 18, 19] </ref>. We call Petri nets that explicitly represent the possible control flow paths in each program task control flow graph Petri nets (CFGPN)s. Figure 2 illustrates a typical CFGPN for the example, where rendezvous start and end are represented by separate transitions.
Reference: [13] <author> S.P. Masticola. </author> <title> Static Detection of Deadlocks in Polynomial Time. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <month> May </month> <year> 1993. </year>
Reference-contexts: In this table, we use the symbol to indicate that the tools were unable to build the reachability graph for the example and the symbol * to indicate that no experimental data are available. BDS is a simulation of a border defense system <ref> [13] </ref>. It contains 15 tasks and has entry calls and accept statements nested within complicated control flow structures. Gas-1 are versions of the one pump gas-station example without deadlock and with the operator task unrolled to accept separate customer entries [2].
Reference: [14] <author> S.P. Masticola and B.G. Ryder. </author> <title> A model of Ada programs for static deadlock detection in polynomial time. </title> <booktitle> In Proceedings of Workshop on Parallel and Distributed Debugging. ACM, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: Unfortunately, in the worst case, the algorithm for analyzing these conditions requires exponential time. Data flow analysis techniques are one of the few concurrency analysis approaches that do not have exponential cost <ref> [4, 6, 8, 14] </ref>. These techniques formulate a set of conditions related to the property to be analyzed as a set of data flow problems whose solution provides information about the validity or satisfiability of those conditions by the program.
Reference: [15] <author> E.T. Morgan and R.R. Razouk. </author> <title> Interactive state-space analysis of concurrent systems. </title> <journal> IEEE Transactions of Software Engineering, </journal> <volume> 13(10) </volume> <pages> 1080-1091, </pages> <year> 1987. </year>
Reference-contexts: State space enumeration methods consider each reachable program state to determine whether a program satisfies a given property <ref> [15, 21, 23, 25] </ref>. Unfortunately, in general, as programs increase in size and complexity, the state space grows exponentially and the space/time requirements of these analysis methods becomes impractical. <p> A transition that is never enabled is called dead. the paper. Petri net models of concurrent programs have existed for some time; they are usually constructed from the set of control flow graphs for the tasks of the program <ref> [12, 15, 18, 19] </ref>. We call Petri nets that explicitly represent the possible control flow paths in each program task control flow graph Petri nets (CFGPN)s. Figure 2 illustrates a typical CFGPN for the example, where rendezvous start and end are represented by separate transitions. <p> Because the net represents control flow choices explicitly, the set of reachable markings that have no successor marking is a conservative approximation of the set of program deadlock states. The reachability graph of this type of Petri net has been used to perform analysis of Ada tasking programs <ref> [15, 19] </ref>. Task Interaction Graphs TIGs have been proposed by Long and Clarke [11] as a compact representation for a rich class of tasking programs. TIGs divide tasks into maximal sequential regions, where such task regions define all of the possible behaviors between two consecutive task interactions. <p> Thus, to judge the effectiveness of a representation for reachability analysis we need to consider both the size of the generated reachability graph and the cost of checking properties on that graph. 4.1 Reachability The TPN reachability graph is generated using standard Petri net techniques <ref> [15] </ref>. The structure of TPNs is such that the number of marked places in any TPN marking is equal to the number of tasks in the program.
Reference: [16] <author> T. Murata. </author> <title> Petri nets: Properties, analysis and applications. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 77(44) </volume> <pages> 541-580, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: We have developed a framework for experimenting with a variety of state space enumeration analyses that is based on task interaction graphs (TIG)s [11] and Petri nets [17]. Petri nets are a well-studied representation for concurrent systems <ref> [16] </ref>. This paper presents a Petri net representation, called TIG-based Petri nets (TPN)s, that is efficient to construct for concurrent programs that use explicit tasking and rendezvous style communication. This representation summarizes large regions of program execution and makes the relevant information available for analysis. <p> In this section we consider techniques for reducing a TPN prior to reachability analysis. The theory of Petri net reductions <ref> [16] </ref> allows a given net to be replaced by a reduced net that maintains certain properties of the original net and has a smaller reachability graph. Most Petri net representations of concurrent programs, including TPNs, explicitly represent all potential inter-task communications.
Reference: [17] <author> J.L. Peterson. </author> <title> Petri Net Theory and the Modeling of Systems. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: We have developed a framework for experimenting with a variety of state space enumeration analyses that is based on task interaction graphs (TIG)s [11] and Petri nets <ref> [17] </ref>. Petri nets are a well-studied representation for concurrent systems [16]. This paper presents a Petri net representation, called TIG-based Petri nets (TPN)s, that is efficient to construct for concurrent programs that use explicit tasking and rendezvous style communication.
Reference: [18] <author> M. Pezze, R.N. Taylor, and M. Young. </author> <title> Graph models for reachability analysis of concurrent programs. </title> <type> Technical Report TR-92-27, </type> <institution> Department of Information and Computer Science, University of California, Irvine, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: A transition that is never enabled is called dead. the paper. Petri net models of concurrent programs have existed for some time; they are usually constructed from the set of control flow graphs for the tasks of the program <ref> [12, 15, 18, 19] </ref>. We call Petri nets that explicitly represent the possible control flow paths in each program task control flow graph Petri nets (CFGPN)s. Figure 2 illustrates a typical CFGPN for the example, where rendezvous start and end are represented by separate transitions.
Reference: [19] <author> S. M. Shatz and W. K. Cheng. </author> <title> A Petri net framework for automated static analysis. </title> <journal> The Journal of Systems and Software, </journal> <volume> 8 </volume> <pages> 343-359, </pages> <year> 1988. </year>
Reference-contexts: A transition that is never enabled is called dead. the paper. Petri net models of concurrent programs have existed for some time; they are usually constructed from the set of control flow graphs for the tasks of the program <ref> [12, 15, 18, 19] </ref>. We call Petri nets that explicitly represent the possible control flow paths in each program task control flow graph Petri nets (CFGPN)s. Figure 2 illustrates a typical CFGPN for the example, where rendezvous start and end are represented by separate transitions. <p> Because the net represents control flow choices explicitly, the set of reachable markings that have no successor marking is a conservative approximation of the set of program deadlock states. The reachability graph of this type of Petri net has been used to perform analysis of Ada tasking programs <ref> [15, 19] </ref>. Task Interaction Graphs TIGs have been proposed by Long and Clarke [11] as a compact representation for a rich class of tasking programs. TIGs divide tasks into maximal sequential regions, where such task regions define all of the possible behaviors between two consecutive task interactions. <p> For the gas station this is the number of customers, for dining philosophers the number of philosophers and forks, and for readers/writers the number of reader and writer tasks. 8 We compare TPNs to the Ada-nets generated using the TOTAL system <ref> [19] </ref> because Ada-nets are an example of the class of CFGPNs described in section 2 and TOTAL is one of the few Petri net based systems for analyzing Ada tasking programs for which a mature implementation and experimental data are available. <p> Comparing TPNs and Ada-nets is fair because they represent equivalent amounts of program information. While early work on TOTAL relied on straightforward reachability of Ada-nets <ref> [19, 21] </ref>, more recent work [7, 22] has demonstrated that if we are only interested in analyzing programs for deadlock freedom, Petri net reduction techniques are capable of significantly extending the size of problems for which reacha-bility analysis can be performed 3 . 4.2 Checking Properties Checking whether a program exhibits
Reference: [20] <author> S.M. </author> <title> Shatz. </title> <type> Personal Communication, </type> <month> February </month> <year> 1993. </year> <month> 16 </month>
Reference-contexts: Experiments using the TOTAL system were conducted for BDS, versions of Gas-1, Phils and the RW examples <ref> [7, 22, 20] </ref>. The size of Ada-nets, in terms of places and transitions, and the size of the corresponding reachability graphs in terms of states and arcs, are given in figure 7, next to the comparable TPN results.
Reference: [21] <author> S.M. Shatz, K. Mai, C. Black, and S. Tu. </author> <title> Design and implementation of a Petri net based toolkit for Ada tasking analysis. </title> <journal> IEEE Transactions on Parallel and Distributed System, </journal> <volume> 1(4) </volume> <pages> 424-441, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: State space enumeration methods consider each reachable program state to determine whether a program satisfies a given property <ref> [15, 21, 23, 25] </ref>. Unfortunately, in general, as programs increase in size and complexity, the state space grows exponentially and the space/time requirements of these analysis methods becomes impractical. <p> For comparison, the TPN for the example in figure 1 has 6 places and 9 transitions. The example CFGPN in section 2 has 16 places and 13 transitions. An Ada-net <ref> [21] </ref> is a CFGPN designed to model Ada programs. An Ada-net for this example has 21 places and 16 transitions [9]. <p> Comparing TPNs and Ada-nets is fair because they represent equivalent amounts of program information. While early work on TOTAL relied on straightforward reachability of Ada-nets <ref> [19, 21] </ref>, more recent work [7, 22] has demonstrated that if we are only interested in analyzing programs for deadlock freedom, Petri net reduction techniques are capable of significantly extending the size of problems for which reacha-bility analysis can be performed 3 . 4.2 Checking Properties Checking whether a program exhibits
Reference: [22] <author> S.M. Shatz, S. Tu, , T.Murata, and S. Duri. </author> <title> Theory and application of Petri net reduction for Ada tasking deadlock analysis. </title> <type> Technical report, </type> <institution> Software Systems Laboratory, Department of Electrical Engineering and Computer Science, University of Illinois, Chicago, IL, </institution> <year> 1994. </year>
Reference-contexts: The state space considered by these methods can be reduced by maintaining only the parts of the state space that are relevant to the analysis of a particular property, such as deadlock freedom <ref> [10, 22] </ref>. For some programs, state space reduction is able to decrease the cost considerably but, in general, the cost of these techniques grows exponentially. Symbolic model-checking techniques use a fix-point computation over an encoding of the state transition relation to determine reachability of a given state [3]. <p> suggest that despite the rapid growth of the state space, enumeration methods that consider the entire concurrent program can be practical for small to medium size programs of moderate complexity [25] and that state space reduction techniques can increase the size of the programs that can be considered still further <ref> [7, 22] </ref>. A recent study [5] has compared the cost-effectiveness of state space enumeration, reduction, model-checking and integer programming analysis techniques. <p> Experiments using the TOTAL system were conducted for BDS, versions of Gas-1, Phils and the RW examples <ref> [7, 22, 20] </ref>. The size of Ada-nets, in terms of places and transitions, and the size of the corresponding reachability graphs in terms of states and arcs, are given in figure 7, next to the comparable TPN results. <p> Comparing TPNs and Ada-nets is fair because they represent equivalent amounts of program information. While early work on TOTAL relied on straightforward reachability of Ada-nets [19, 21], more recent work <ref> [7, 22] </ref> has demonstrated that if we are only interested in analyzing programs for deadlock freedom, Petri net reduction techniques are capable of significantly extending the size of problems for which reacha-bility analysis can be performed 3 . 4.2 Checking Properties Checking whether a program exhibits a desired property involves defining <p> Recent experimental data has demonstrated that net reduction techniques are an effective approach to extending the size of programs for which deadlock checking is practical <ref> [7, 22] </ref>. Unfortunately, program deadlocks are not conservatively represented by the set of reachable TPN markings without successors, so we cannot directly apply existing deadlock preserving Petri net reductions. Net reductions can be developed, however, that are applicable to TPNs.
Reference: [23] <author> R.N. Taylor. </author> <title> A general-purpose algorithm for analyzing concurrent programs. </title> <journal> Communications of the ACM, </journal> <volume> 26(5) </volume> <pages> 362-376, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: State space enumeration methods consider each reachable program state to determine whether a program satisfies a given property <ref> [15, 21, 23, 25] </ref>. Unfortunately, in general, as programs increase in size and complexity, the state space grows exponentially and the space/time requirements of these analysis methods becomes impractical.
Reference: [24] <author> W.J. Yeh and M. Young. </author> <title> Compositional reachability analysis using process algebra. </title> <booktitle> In Proceedings of the ACM SIGSOFT Symposium on Testing, Analysis and Verification (TAV4), </booktitle> <pages> pages 49-59, </pages> <address> Victoria, Canada, </address> <month> October </month> <year> 1991. </year> <note> ACM Press. </note>
Reference-contexts: Finding conditions that are strong enough for the analysis problem at hand, yet amenable to a polynomial-time data flow formulation can be difficult. Compositional approaches decompose the original analysis problem into smaller problems on which the above techniques can be applied <ref> [24] </ref>. This approach relies on finding a decomposition of the original problem that significantly reduces the cost of analysis for the subproblems. For many programs, such a suitable decomposition may be difficult to find, if one exists at all.
Reference: [25] <author> M. Young, R.N. Taylor, D.L. Levine, K. Forester, and D. Brodbeck. </author> <title> A concurrency analysis tool suite: Rationale, design, and preliminary experience. </title> <type> Technical Report TR-128-P, </type> <institution> Software Engineering Research Center, 1398 Computer Sciences, Purdue University, West Lafayette, </institution> <note> IN 47907-1398, </note> <month> October </month> <year> 1992. </year> <month> 17 </month>
Reference-contexts: State space enumeration methods consider each reachable program state to determine whether a program satisfies a given property <ref> [15, 21, 23, 25] </ref>. Unfortunately, in general, as programs increase in size and complexity, the state space grows exponentially and the space/time requirements of these analysis methods becomes impractical. <p> To date, there has been little empirical work in this area. Experimental results suggest that despite the rapid growth of the state space, enumeration methods that consider the entire concurrent program can be practical for small to medium size programs of moderate complexity <ref> [25] </ref> and that state space reduction techniques can increase the size of the programs that can be considered still further [7, 22]. A recent study [5] has compared the cost-effectiveness of state space enumeration, reduction, model-checking and integer programming analysis techniques. <p> Young et. al. <ref> [25] </ref> discuss separating the construction of the reachability graph from the process of checking a particular property. If we can construct the reachability graph, it is often practical to check the property of interest on each of the states in the graph. <p> This algorithm is strongly dependent on the number of choice combinations for a TPN marking. The number of choice combinations is, in the worst case, exponential in the number of tasks in the program. Young et. al. <ref> [25] </ref> have shown that this problem is NP-hard, but they have found through experimentation that for a number of programs checking this condition is practical.
References-found: 25

