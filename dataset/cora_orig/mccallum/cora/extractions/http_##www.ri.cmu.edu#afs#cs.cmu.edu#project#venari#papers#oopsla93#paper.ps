URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/venari/papers/oopsla93/paper.ps
Refering-URL: http://www.ri.cmu.edu/afs/cs.cmu.edu/project/venari/www/oopsla93.html
Root-URL: 
Note: Abstract  
Abstract: Specifications are useful because they allow reasoning about objects without concern for their implementations. Type hierarchies are useful because they allow types that share common properties to be designed as a family. This paper is concerned with the interaction between specifications and type Specifications and Their Use in Defining Subtypes hierarchies. We present a way of specifying types, and show how some extra information, in addition to specifications of the objects' methods, is needed to support reasoning. We also provide a new way of showing that one type is a subtype of another. Our technique makes use of information in the types' specifications and works even in a very general computational environment in which possibly concurrent Barbara Liskov Jeannette M. Wing users share mutable objects. Massachusetts Institute of Technology School of Computer Science Laboratory for Computer Science Carnegie Mellon University 1. Introduction 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> America, P. </author> <title> LNCS. Volume 489: Designing an Object-Oriented Programming Language with Behavioural Subtyping. </title> <booktitle> In Foundations of Object-Oriented Languages, </booktitle> <address> REX School/Workshop, Noordwijkerhout, The Netherlands, </address> <month> May/June </month> <year> 1990, </year> <editor> J. W. de Bakker and W. P. de Roever and G. Rozenberg, Ed., </editor> <publisher> Springer-Verlag, </publisher> <address> NY, </address> <year> 1991, </year> <pages> pp. 60-90. </pages>
Reference-contexts: Though many of these researchers separate the specification of an object's creators from its other methods, no one has identified the problem posed by the missing creators, and thus no one has provided an explicit solution to this problem. Others such as America <ref> [1] </ref>, Cusack [6], and Dhara and Leavens [9] have proposed rules for determining whether one type is a subtype of another. Many of these approaches are not constructive, i.e., they tell you what to look for, but not how to prove that you got it. <p> In particular, oldest ensures that the returned element is the one that was first inserted longest ago. The additional remove method removes the oldest element from the set. 8 4.2. Subtype Relation Defined in Terms of Specifications Various authors have defined subtyping by relating two type specifications <ref> [1, 15, 6, 3, 22] </ref>. The commonality among these subtype definitions is that they all capture the following two properties, stated informally: Values of the subtype relate to values of the supertype. Behaviors of the subtype methods relate to behaviors of corresponding supertype methods. <p> Behaviors of the subtype methods relate to behaviors of corresponding supertype methods. As introduced in the previous section, we use abstraction functions to relate value spaces. These are similar to America's transfer functions <ref> [1] </ref>, Leavens's simulation relations [15], and Bruce and Wegner's coercion functions [3]. <p> This semantic requirement on the methods' pre and post-conditions is analogous to the syntactic requirement on the methods' signatures [2, 24, 4] (see our contra/covariance rules below). Except for minor differences, our way of relating methods is similar to America's <ref> [1] </ref>, Leavens's [15], and Cusack's [6]. <p> Subtype constraints ensure supertype constraints. Constraint Rule. For all x: s . C (x) fi C [A (x )/x , A (x )/x ] s t pre r post y 4.4. Discussion Our first subtype definition (given in Section 4.2) is similar to others <ref> [1, 6, 15] </ref>, but it does not go far enough. It fails to rule out subtype relations that would permit surprising behavior in the presence of shared mutable objects. Besides us, only Dhara and Leavens [9, 8] address this case.
Reference: 2. <author> Black, A. P., Hutchinson, N., Jul, E., Levy, H. M., and Carter, L. </author> <title> "Distribution and Abstract Types in Emerald". </title> <journal> IEEE TSE SE-13 (Jan. </journal> <year> 1987), </year> <pages> 65-76. 15 </pages>
Reference-contexts: This semantic requirement on the methods' pre and post-conditions is analogous to the syntactic requirement on the methods' signatures <ref> [2, 24, 4] </ref> (see our contra/covariance rules below). Except for minor differences, our way of relating methods is similar to America's [1], Leavens's [15], and Cusack's [6].
Reference: 3. <author> Bruce, K. B., and Wegner, P. </author> <title> An Algebraic Model of Subtypes in Object-Oriented Languages (Draft). </title> <journal> ACM SIGPLAN Notices, </journal> <month> Oct., </month> <year> 1986. </year> <booktitle> Object-Oriented Programming Workshop. </booktitle>
Reference-contexts: In particular, oldest ensures that the returned element is the one that was first inserted longest ago. The additional remove method removes the oldest element from the set. 8 4.2. Subtype Relation Defined in Terms of Specifications Various authors have defined subtyping by relating two type specifications <ref> [1, 15, 6, 3, 22] </ref>. The commonality among these subtype definitions is that they all capture the following two properties, stated informally: Values of the subtype relate to values of the supertype. Behaviors of the subtype methods relate to behaviors of corresponding supertype methods. <p> Behaviors of the subtype methods relate to behaviors of corresponding supertype methods. As introduced in the previous section, we use abstraction functions to relate value spaces. These are similar to America's transfer functions [1], Leavens's simulation relations [15], and Bruce and Wegner's coercion functions <ref> [3] </ref>.
Reference: 4. <author> Cardelli, L. </author> <title> "A semantics of multiple inheritance". </title> <booktitle> Information and Computation 76 (1988), </booktitle> <pages> 138-164. </pages>
Reference-contexts: This semantic requirement on the methods' pre and post-conditions is analogous to the syntactic requirement on the methods' signatures <ref> [2, 24, 4] </ref> (see our contra/covariance rules below). Except for minor differences, our way of relating methods is similar to America's [1], Leavens's [15], and Cusack's [6].
Reference: 5. <author> Carrington,, D., Duke, D., Duke, R., King, P., Rose, G., and Smith, P. Object-Z: </author> <title> An Object Oriented Extension to Z. </title> <booktitle> FORTE89, International Conference on Formal Description Techniques, </booktitle> <month> Dec., </month> <year> 1989. </year>
Reference-contexts: Our technique is also constructive: One can prove whether a subtype relation holds by proving a small number of simple lemmas. Others have worked on both of the problems attacked in this paper. For example, many have proposed Z as the basis of specifications of object types <ref> [7, 10, 5] </ref>; Goguen and Meseguer use FOOPS [13]; Leavens and his colleagues use Larch [16, 18, 9].
Reference: 6. <author> Cusack, E. </author> <title> Inheritance in object oriented Z. </title> <booktitle> Proceedings of ECOOP '91, </booktitle> <year> 1991. </year>
Reference-contexts: Though many of these researchers separate the specification of an object's creators from its other methods, no one has identified the problem posed by the missing creators, and thus no one has provided an explicit solution to this problem. Others such as America [1], Cusack <ref> [6] </ref>, and Dhara and Leavens [9] have proposed rules for determining whether one type is a subtype of another. Many of these approaches are not constructive, i.e., they tell you what to look for, but not how to prove that you got it. <p> In particular, oldest ensures that the returned element is the one that was first inserted longest ago. The additional remove method removes the oldest element from the set. 8 4.2. Subtype Relation Defined in Terms of Specifications Various authors have defined subtyping by relating two type specifications <ref> [1, 15, 6, 3, 22] </ref>. The commonality among these subtype definitions is that they all capture the following two properties, stated informally: Values of the subtype relate to values of the supertype. Behaviors of the subtype methods relate to behaviors of corresponding supertype methods. <p> This semantic requirement on the methods' pre and post-conditions is analogous to the syntactic requirement on the methods' signatures [2, 24, 4] (see our contra/covariance rules below). Except for minor differences, our way of relating methods is similar to America's [1], Leavens's [15], and Cusack's <ref> [6] </ref>. <p> Subtype constraints ensure supertype constraints. Constraint Rule. For all x: s . C (x) fi C [A (x )/x , A (x )/x ] s t pre r post y 4.4. Discussion Our first subtype definition (given in Section 4.2) is similar to others <ref> [1, 6, 15] </ref>, but it does not go far enough. It fails to rule out subtype relations that would permit surprising behavior in the presence of shared mutable objects. Besides us, only Dhara and Leavens [9, 8] address this case.
Reference: 7. <author> Cusack, E., and Lai, M. </author> <title> Object-Oriented Specification in LOTOS and Z, or My Cat Really is Object-Oriented! Foundations of Object Oriented Languages, </title> <month> June, </month> <year> 1991, </year> <pages> pp. 179-202. </pages> <note> LNCS 489. </note>
Reference-contexts: Our technique is also constructive: One can prove whether a subtype relation holds by proving a small number of simple lemmas. Others have worked on both of the problems attacked in this paper. For example, many have proposed Z as the basis of specifications of object types <ref> [7, 10, 5] </ref>; Goguen and Meseguer use FOOPS [13]; Leavens and his colleagues use Larch [16, 18, 9].
Reference: 8. <author> Krishna Kishore Dhara. </author> <title> Subtyping among mutable types in object-oriented programming languages. </title> <institution> Master Th., Iowa State University, Ames, Iowa,1992. </institution>
Reference-contexts: Discussion Our first subtype definition (given in Section 4.2) is similar to others [1, 6, 15], but it does not go far enough. It fails to rule out subtype relations that would permit surprising behavior in the presence of shared mutable objects. Besides us, only Dhara and Leavens <ref> [9, 8] </ref> address this case. Rather than add 13 explicit constraints in specifications, they place restrictions on the kinds of aliasing allowed in their programs. Their solution is limited to the special case of single-user, single-program environments.
Reference: 9. <author> Krishna Kishore Dhara and Leavens, G. T. </author> <title> Subtyping for mutable types in object-oriented programming languages. </title> <type> Tech. Rept. TR #92-36, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> Nov., </month> <year> 1992. </year>
Reference-contexts: Others have worked on both of the problems attacked in this paper. For example, many have proposed Z as the basis of specifications of object types [7, 10, 5]; Goguen and Meseguer use FOOPS [13]; Leavens and his colleagues use Larch <ref> [16, 18, 9] </ref>. Though many of these researchers separate the specification of an object's creators from its other methods, no one has identified the problem posed by the missing creators, and thus no one has provided an explicit solution to this problem. <p> Others such as America [1], Cusack [6], and Dhara and Leavens <ref> [9] </ref> have proposed rules for determining whether one type is a subtype of another. Many of these approaches are not constructive, i.e., they tell you what to look for, but not how to prove that you got it. <p> Discussion Our first subtype definition (given in Section 4.2) is similar to others [1, 6, 15], but it does not go far enough. It fails to rule out subtype relations that would permit surprising behavior in the presence of shared mutable objects. Besides us, only Dhara and Leavens <ref> [9, 8] </ref> address this case. Rather than add 13 explicit constraints in specifications, they place restrictions on the kinds of aliasing allowed in their programs. Their solution is limited to the special case of single-user, single-program environments.
Reference: 10. <author> Duke, D., and Duke, R. </author> <title> A History Model for Classes in Object-Z. Proceedings of VDM '90: VDM and Z, </title> <year> 1990. </year>
Reference-contexts: Our technique is also constructive: One can prove whether a subtype relation holds by proving a small number of simple lemmas. Others have worked on both of the problems attacked in this paper. For example, many have proposed Z as the basis of specifications of object types <ref> [7, 10, 5] </ref>; Goguen and Meseguer use FOOPS [13]; Leavens and his colleagues use Larch [16, 18, 9].
Reference: 11. <author> Ehrig, H., and Mahr, B. </author> <title> Fundamentals of Algebraic Specification 1. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: In our examples, we stick to standard notation for functions on sets, sequences, and tuples with their usual mathematical properties; in this paper we omit the Larch traits that would be used to specify such details. Many other specification languages like Z [26], OBJ3 [12], ACT-ONE <ref> [11] </ref> could just as easily be adopted to describe a type's value space. In the second tier, Larch interfaces are used to describe the behaviors of an object's methods. For example, Figure 3-1 gives a specification for a set type whose objects have methods insert, delete, select, elements, and equal.
Reference: 12. <author> Goguen, J. A., Kirchner, C., Kirchner, H., Megrelis, A., Meseguer, J., and Winkler, T. </author> <title> An Introduction to OBJ3. </title> <booktitle> Proceedings, Conference on Conditional Term Rewriting, </booktitle> <year> 1988, </year> <pages> pp. 258-263. </pages> <note> LNCS 308. </note>
Reference-contexts: In our examples, we stick to standard notation for functions on sets, sequences, and tuples with their usual mathematical properties; in this paper we omit the Larch traits that would be used to specify such details. Many other specification languages like Z [26], OBJ3 <ref> [12] </ref>, ACT-ONE [11] could just as easily be adopted to describe a type's value space. In the second tier, Larch interfaces are used to describe the behaviors of an object's methods.
Reference: 13. <author> Goguen, J. A., and Meseguer, J. </author> <title> Unifying Functional, Object-Oriented and Relational Programming with Logical Semantics. </title> <booktitle> Research Directions in Object Oriented Programming, </booktitle> <year> 1987. </year>
Reference-contexts: Others have worked on both of the problems attacked in this paper. For example, many have proposed Z as the basis of specifications of object types [7, 10, 5]; Goguen and Meseguer use FOOPS <ref> [13] </ref>; Leavens and his colleagues use Larch [16, 18, 9]. Though many of these researchers separate the specification of an object's creators from its other methods, no one has identified the problem posed by the missing creators, and thus no one has provided an explicit solution to this problem.
Reference: 14. <author> Guttag, J. V., Horning, J. J., and Wing, J. M. </author> <title> "The Larch Family of Specification Languages". </title> <booktitle> IEEE Software 2, </booktitle> <month> 5 (sept </month> <year> 1985), </year> <pages> 24-36. </pages>
Reference-contexts: In our work we use formal specifications in the two-tiered style of Larch <ref> [14] </ref>. In the first tier, Larch traits, written in the style of algebraic specifications, are used to define a vocabulary of sort and function symbols. These symbols define a term language, where each term denotes a value (of a particular sort).
Reference: 15. <author> Leavens, G. </author> <title> Verifying Object-Oriented Programs That Use Subtypes. </title> <type> Tech. </type> <institution> Rept. 439, MIT Lab. for Computer Science, </institution> <month> Feb., </month> <year> 1989. </year> <type> Ph.D. thesis. </type>
Reference-contexts: In particular, oldest ensures that the returned element is the one that was first inserted longest ago. The additional remove method removes the oldest element from the set. 8 4.2. Subtype Relation Defined in Terms of Specifications Various authors have defined subtyping by relating two type specifications <ref> [1, 15, 6, 3, 22] </ref>. The commonality among these subtype definitions is that they all capture the following two properties, stated informally: Values of the subtype relate to values of the supertype. Behaviors of the subtype methods relate to behaviors of corresponding supertype methods. <p> Behaviors of the subtype methods relate to behaviors of corresponding supertype methods. As introduced in the previous section, we use abstraction functions to relate value spaces. These are similar to America's transfer functions [1], Leavens's simulation relations <ref> [15] </ref>, and Bruce and Wegner's coercion functions [3]. <p> This semantic requirement on the methods' pre and post-conditions is analogous to the syntactic requirement on the methods' signatures [2, 24, 4] (see our contra/covariance rules below). Except for minor differences, our way of relating methods is similar to America's [1], Leavens's <ref> [15] </ref>, and Cusack's [6]. <p> Subtype constraints ensure supertype constraints. Constraint Rule. For all x: s . C (x) fi C [A (x )/x , A (x )/x ] s t pre r post y 4.4. Discussion Our first subtype definition (given in Section 4.2) is similar to others <ref> [1, 6, 15] </ref>, but it does not go far enough. It fails to rule out subtype relations that would permit surprising behavior in the presence of shared mutable objects. Besides us, only Dhara and Leavens [9, 8] address this case.
Reference: 16. <author> Leavens, G. T. </author> <title> "Modular specification and verification of object-oriented programs". </title> <booktitle> IEEE Software 8, </booktitle> <month> 4 (July </month> <year> 1991), </year> <pages> 72-80. </pages>
Reference-contexts: Others have worked on both of the problems attacked in this paper. For example, many have proposed Z as the basis of specifications of object types [7, 10, 5]; Goguen and Meseguer use FOOPS [13]; Leavens and his colleagues use Larch <ref> [16, 18, 9] </ref>. Though many of these researchers separate the specification of an object's creators from its other methods, no one has identified the problem posed by the missing creators, and thus no one has provided an explicit solution to this problem.
Reference: 17. <author> Leavens, G. T., and Krishna Kishore Dhara. </author> <title> A Foundation for the Model Theory of Abstract Data Types with Mutation and Aliasing (preliminary version). </title> <type> Tech. Rept. TR #92-35, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> Nov., </month> <year> 1992. </year>
Reference-contexts: Many of these approaches are not constructive, i.e., they tell you what to look for, but not how to prove that you got it. Other work <ref> [27, 17] </ref> is couched in formalisms that we believe are not very easy for programmers to deal with. In contrast, our subtype 2 definition is constructive and takes the form of a simple checklist of rules, which programmers can use in a formal or informal way.
Reference: 18. <author> Leavens, G. T., and Weihl, W. E. </author> <title> Reasoning about Object-Oriented Programs that use Subtypes. </title> <booktitle> ECOOP/OOPSLA '90 Proceedings, </booktitle> <year> 1990. </year>
Reference-contexts: Others have worked on both of the problems attacked in this paper. For example, many have proposed Z as the basis of specifications of object types [7, 10, 5]; Goguen and Meseguer use FOOPS [13]; Leavens and his colleagues use Larch <ref> [16, 18, 9] </ref>. Though many of these researchers separate the specification of an object's creators from its other methods, no one has identified the problem posed by the missing creators, and thus no one has provided an explicit solution to this problem.
Reference: 19. <author> Liskov, B. et al. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: The pre-condition is the predicate of the requires clause; if this clause is missing, the pre-condition is trivially ``true.'' For example, select's pre-condition checks to see if the set has any elements. The post-condition is the 1 This model is based on CLU semantics <ref> [19] </ref>. 4 conjunction of the modifies and ensures clauses. Insert's post-condition says that the set's value may 2 change because of the addition of its integer argument.
Reference: 20. <author> Liskov, B., and Guttag, J. </author> <title> Abstraction and Specification in Program Design. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: We have used specifications like this with considerable success in our own work, and they are described in Liskov and Guttag <ref> [20] </ref>. 3.2. Specifying Creators Objects are created and initialized through creators.
Reference: 21. <author> Liskov, B. </author> <title> Preliminary Design of the Thor Object-Oriented Database System. </title> <booktitle> Proc. of the Software Technology Conference, </booktitle> <month> April, </month> <year> 1992. </year> <note> Also Programming Methodology Group Memo 74, </note> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: To reason about the use of variable x using the specification of its type T, we need to impose additional constraints on the subtype relation. Now consider the case of an environment of shared mutable objects, such as is provided by object-oriented databases (e.g., Thor <ref> [21] </ref> and Gemstone [23]). (In fact, it was our interest in Thor that motivated us to study the meaning of the subtype relation in the first place.) In such systems, there is a universe containing shared, mutable objects and a way of naming those objects.
Reference: 22. <author> Liskov, B., and Wing, J. M. </author> <title> A New Definition of the Subtype Relation. </title> <booktitle> Proceedings of ECOOP '93, </booktitle> <address> Kaiserslautern, Germany, </address> <year> 1993. </year> <note> to appear. 16 </note>
Reference-contexts: Furthermore, only we have a technique that works in a general environment in which objects can be shared among possibly concurrent users. The rule for proving the subtype relation given in this paper is simpler than the one given in our own earlier work <ref> [22] </ref>, but it requires more information in specifications, which may be a disadvantage. The remainder of the paper is organized as follows. In Section 2 we describe our model of computation. <p> In particular, oldest ensures that the returned element is the one that was first inserted longest ago. The additional remove method removes the oldest element from the set. 8 4.2. Subtype Relation Defined in Terms of Specifications Various authors have defined subtyping by relating two type specifications <ref> [1, 15, 6, 3, 22] </ref>. The commonality among these subtype definitions is that they all capture the following two properties, stated informally: Values of the subtype relate to values of the supertype. Behaviors of the subtype methods relate to behaviors of corresponding supertype methods. <p> Rather than add 13 explicit constraints in specifications, they place restrictions on the kinds of aliasing allowed in their programs. Their solution is limited to the special case of single-user, single-program environments. We have also worked out another general approach that requires an extension map instead of explicit constraints <ref> [22] </ref>. This extension map is defined for all extra mutators introduced by the subtype and requires ``explaining'' the behavior of each extra mutator as a program expressed in terms of non-extra methods.
Reference: 23. <author> Maier, D., and Stein, J. </author> <title> Development and Implementation of an Object-Oriented DBMS. </title> <booktitle> Readings in Object-Oriented Database Systems, </booktitle> <year> 1990, </year> <pages> pp. 167-185. </pages>
Reference-contexts: To reason about the use of variable x using the specification of its type T, we need to impose additional constraints on the subtype relation. Now consider the case of an environment of shared mutable objects, such as is provided by object-oriented databases (e.g., Thor [21] and Gemstone <ref> [23] </ref>). (In fact, it was our interest in Thor that motivated us to study the meaning of the subtype relation in the first place.) In such systems, there is a universe containing shared, mutable objects and a way of naming those objects.
Reference: 24. <author> Schaffert, C., Cooper, T., and Wilpolt, C. </author> <title> Trellis: Object-Based Environment Language Reference Manual. </title> <type> Tech. </type> <institution> Rept. 372, Digital Equipment Corp./Easter Research Lab., </institution> <year> 1985. </year>
Reference-contexts: This semantic requirement on the methods' pre and post-conditions is analogous to the syntactic requirement on the methods' signatures <ref> [2, 24, 4] </ref> (see our contra/covariance rules below). Except for minor differences, our way of relating methods is similar to America's [1], Leavens's [15], and Cusack's [6].
Reference: 25. <author> Scheid, J., and Holtsberg, S. </author> <title> Ina Jo Specification Language Reference Manual. </title> <type> Tech. </type> <institution> Rept. TM-6021/001/06, Paramax Systems Corporation, A Unisys Company, </institution> <month> June, </month> <year> 1992. </year>
Reference-contexts: We assume each type t specification preserves invariants and satisfies constraints. 4 The use of the term ``constraint'' is borrowed from the Ina Jo specification language <ref> [25] </ref>, which also includes constraints in specifications. 12 Returning to our set and fat_set example, we see that the constraint rule is not satisfied since set has the trivial constraint ``true,'' which does not imply fat_set's constraint.
Reference: 26. <author> Spivey, J. M. </author> <title> The Z Notation: A Reference Manual. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: In our examples, we stick to standard notation for functions on sets, sequences, and tuples with their usual mathematical properties; in this paper we omit the Larch traits that would be used to specify such details. Many other specification languages like Z <ref> [26] </ref>, OBJ3 [12], ACT-ONE [11] could just as easily be adopted to describe a type's value space. In the second tier, Larch interfaces are used to describe the behaviors of an object's methods.
Reference: 27. <author> Utting, M. </author> <title> An Object-Oriented Refinement Calculus with Modular Reasoning. </title> <type> Ph.D. </type> <institution> Th., University of New South Wales, Australia, </institution> <year> 1992. </year>
Reference-contexts: Many of these approaches are not constructive, i.e., they tell you what to look for, but not how to prove that you got it. Other work <ref> [27, 17] </ref> is couched in formalisms that we believe are not very easy for programmers to deal with. In contrast, our subtype 2 definition is constructive and takes the form of a simple checklist of rules, which programmers can use in a formal or informal way.
References-found: 27

