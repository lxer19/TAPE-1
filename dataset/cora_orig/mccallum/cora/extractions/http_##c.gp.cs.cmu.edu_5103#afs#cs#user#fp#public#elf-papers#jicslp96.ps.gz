URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/elf-papers/jicslp96.ps.gz
Refering-URL: http://c.gp.cs.cmu.edu:5103/afs/cs/user/fp/public/elf-papers/INDEX.html
Root-URL: http://www.cs.cmu.edu
Email: Gilles.Dowek@inria.fr  Therese.Hardin@litp.ibp.fr  Claude.Kirchner@loria.fr  fp@cs.cmu.edu  
Title: Unification via Explicit Substitutions: The Case of Higher-Order Patterns  
Author: Gilles Dowek Therese Hardin Claude Kirchner Frank Pfenning 
Address: B.P. 105 78153 Le Chesnay Cedex, France  Universite Paris 6, 4 Place Jussieu 75252 Paris Cedex 05, France  B.P. 101 54602 Villers-les-Nancy Cedex, France  Pittsburgh, PA 15213, U.S.A.  
Affiliation: INRIA Rocquencourt  LITP and INRIA-Rocquencourt  INRIA Lorraine CRIN  Department of Computer Science Carnegie Mellon University  
Abstract: Following the general method and related completeness results on using explicit substitutions to perform higher-order unification proposed in [5], we investigate in this paper the case of higher-order patterns as introduced by Miller. We show that our general algorithm specializes in a very convenient way to patterns. We also sketch an efficient implementation of the abstract algorithm and its generalization to constraint simplification. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Martin Abadi, Lucas Cardelli, Pierre-Louis Curien, and Jean-Jacques Levy. </author> <title> Explicit substitutions. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(4) </volume> <pages> 375-416, </pages> <year> 1991. </year>
Reference-contexts: They can be found in [6]. 2 Explicit substitutions The -calculus is a first-order rewriting system, introduced to provide an explicit treatment of substitutions initiated by fi-reductions. Here, we shall use the - calculus described in <ref> [1] </ref>, in its typed version [1, 4], but similar free calculi with explicit substitutions can be used in the same way provided they are confluent and weakly terminating on the free algebra generated by term variables (here also called meta-variables). <p> They can be found in [6]. 2 Explicit substitutions The -calculus is a first-order rewriting system, introduced to provide an explicit treatment of substitutions initiated by fi-reductions. Here, we shall use the - calculus described in [1], in its typed version <ref> [1, 4] </ref>, but similar free calculi with explicit substitutions can be used in the same way provided they are confluent and weakly terminating on the free algebra generated by term variables (here also called meta-variables).
Reference: [2] <author> P. Borovansky. </author> <title> Implementation of higher-order unification based on calculus of explicit substitutions. </title> <editor> In Moroslav Bartosek, Jan Staudek, and Jir i Wiedermann, editors, </editor> <booktitle> Proceedings of the SOFSEM'95: Theory and Practice of Informatics, volume 1012 of Lecture Notes in Computer Science, </booktitle> <pages> pages 363-368. </pages> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Instead, we transform the term only into weak head-normal form (see also <ref> [2] </ref>).
Reference: [3] <author> P. Brisset. </author> <title> Compilation de LambdaProlog. </title> <type> PhD thesis, </type> <institution> Rennes I, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Another solution has been adopted in Prolog/Mali <ref> [3] </ref>. As far as we know, nobody has considered this question for patterns or constraints. Qian [23] gives a linear algorithm for higher-order pattern unification, but to our knowledge it has never been implemented and its practicality remains open. He also does not consider more general constraints.
Reference: [4] <author> Pierre-Louis Curien and Alejandro Rios. </author> <title> Un resultat de completude pour les substitutions explicites. </title> <institution> Compte-rendus de l'Academie des Sciences de Paris, 312(I):471-476, </institution> <year> 1991. </year>
Reference-contexts: They can be found in [6]. 2 Explicit substitutions The -calculus is a first-order rewriting system, introduced to provide an explicit treatment of substitutions initiated by fi-reductions. Here, we shall use the - calculus described in [1], in its typed version <ref> [1, 4] </ref>, but similar free calculi with explicit substitutions can be used in the same way provided they are confluent and weakly terminating on the free algebra generated by term variables (here also called meta-variables).
Reference: [5] <author> Gilles Dowek, Therese Hardin, and Claude Kirchner. </author> <title> Higher-order unification via explicit substitutions, extended abstract. </title> <editor> In Dexter Kozen, editor, </editor> <booktitle> Proceedings of LICS'95, </booktitle> <pages> pages 366-374, </pages> <address> San Diego, </address> <month> June </month> <year> 1995. </year>
Reference-contexts: They permit the expensive operation of substitution to be postponed until necessary and, furthermore, they allow multiple successive substitutions to be combined. As shown in <ref> [5] </ref>, Huet's unification algorithm for simply typed lambda terms is a specific instance of first-order equational unification in a calculus of explicit substitutions. In practice, modified versions of Huet's algorithm have performed well, despite the general undecidability of the problem. <p> Then in Section 5, we describe an efficient way to implement these transformations in a logical framework context. We finally conclude with related and future work. For the basic concepts and definitions on lambda calculus, calculus of substitution, unification and term rewriting, we refer to <ref> [5] </ref>. For lack of space, almost all proofs and several developments are missing from this version of the paper. They can be found in [6]. 2 Explicit substitutions The -calculus is a first-order rewriting system, introduced to provide an explicit treatment of substitutions initiated by fi-reductions. <p> Equations in the simply-typed -calculus are translated to equations in the - calculus <ref> [5] </ref>. Crucial in the translation is the proper treatment of free variables, since higher-order variables and capture-avoiding substitution are replaced by meta-variables and grafting, i.e., first-order replacement. This gap is bridged through the so-called pre-cooking of a term which raises the free variables to their proper context. <p> This pre-cooking of a -term a, written a F , is defined as a F = F (a; 0) where: 1. F (( A a); n) = A (F (a; n + 1)), 3. F (k; n) = 1 [" k1 ] As shown in <ref> [5] </ref>, pre-cooking is an homomorphism from -calculus to -calculus. <p> ~ Z: X 1 = ? a n such that 81 i n; X i 2 X , a i is a pattern, and: (i) 81 i &lt; j n X i 6= X j ; (iii) 81 i n X i =2 ~ Z; Note that flex-flex equations (see <ref> [5] </ref>) do not occur in -pattern solved forms. A solved form therefore trivially determines a unique grafting which is its unifier. In order to state the transformation rules, we need the following definitions and properties. <p> Given a -pattern unification problem, the transformation rules described in Figures 4 and 5 allow normalizing it into a solved form when it has solutions, or into F otherwise. The main differences between pattern unification and -unification lie in the Exp-app rule of <ref> [5] </ref>. This rule, that implements for -unification the imitation and projection steps of Huet's algorithm, is mainly replaced by the rules Pruning1, Pruning2 and Invert. <p> Thus: Theorem 17 Unification of -patterns is decidable and unitary. If the problem we start with is the pre-cooking of some problem in -calculus in a context , then we may want to translate back the solved problem in -calculus. This can be done with the rules Anti-* of <ref> [5] </ref>. As shown in the full paper, starting from a pattern unification problem in the simply typed -calculus, pre-cooking followed by the application of the PatternUnif rules under the strategy we have described and ended by the Anti-* rules, provides a correct and complete way of solving pattern unification. <p> In comparison with the standard presentation of pattern unification, our presentation does not need mixed prefixes to simplify abstractions. Here we just reap the benefit of the encoding of scopes constraints in the calculus itself <ref> [5] </ref>. Similarly, the raising step is merely our Anti-Exp- rule.
Reference: [6] <author> Gilles Dowek, Therese Hardin, Claude Kirchner, and Frank Pfenning. </author> <title> Unification via explicit substitutions: The case of higher-order patterns. Rapport technique, </title> <institution> INRIA, Rocquencourt, France, </institution> <year> 1996. </year> <month> Forthcoming. </month>
Reference-contexts: For the basic concepts and definitions on lambda calculus, calculus of substitution, unification and term rewriting, we refer to [5]. For lack of space, almost all proofs and several developments are missing from this version of the paper. They can be found in <ref> [6] </ref>. 2 Explicit substitutions The -calculus is a first-order rewriting system, introduced to provide an explicit treatment of substitutions initiated by fi-reductions. <p> The algorithm is also obviously still sound and complete for unification problems consisting entirely of patterns. A more detailed description can be found in <ref> [6] </ref>. In practice it has proved superior to Huet's algorithm in many cases, primarily because the latter makes non-deterministic choices which may have to be undone and backtracked later.
Reference: [7] <author> Dominic Duggan. </author> <title> Logical closures. </title> <editor> In Frank Pfenning, editor, </editor> <booktitle> Proceedings of the 5th International Conference on Logic Programming and Automated Reasoning, </booktitle> <pages> pages 114-129, </pages> <address> Kiev, Ukraine, July 1994. </address> <publisher> Springer-Verlag LNAI 822. </publisher>
Reference-contexts: One interesting question we plan to consider in future work is if an explicit substitution calculus might be exposed at the level of the programming language, rather than remain confined to the implementation. This raises a number of tantalizing possibilities as pointed out by Duggan <ref> [7] </ref>. Besides MLF [8], the ALF system [11] also employs an explicit substitution calculus with dependent types and makes it available to the user, but its operational properties (such as unification) have not yet been fully investigated. Acknowledgements.
Reference: [8] <author> Robert Harper and Frank Pfenning. </author> <title> A module system for a programming language based on the LF logical framework. </title> <journal> Journal of Logic and Computation, </journal> <note> 1996. To appear. </note>
Reference-contexts: This algorithm (augmented, at present without proof, to the case of dependent types) has been implemented in SML as the core of MLF, a version of the logical framework LF with a module layer <ref> [8] </ref>. It has shown good computational properties, although we have not undertaken a systematic empirical comparison. The remainder of the paper is organized as follows. The next section describes , the explicit calculus of substitution that we are using, together with its fundamental properties. <p> In this section we present an algorithm which is close to the actual efficient implementation of pattern unification in the MLF (modular LF) language <ref> [8] </ref>. <p> One interesting question we plan to consider in future work is if an explicit substitution calculus might be exposed at the level of the programming language, rather than remain confined to the implementation. This raises a number of tantalizing possibilities as pointed out by Duggan [7]. Besides MLF <ref> [8] </ref>, the ALF system [11] also employs an explicit substitution calculus with dependent types and makes it available to the user, but its operational properties (such as unification) have not yet been fully investigated. Acknowledgements.
Reference: [9] <author> J.-P. Jouannaud and Claude Kirchner. </author> <title> Solving equations in abstract algebras: a rule-based survey of unification. </title> <editor> In Jean-Louis Lassez and G. Plotkin, editors, </editor> <booktitle> Computational Logic. Essays in honor of Alan Robinson, chapter 8, </booktitle> <pages> pages 257-321. </pages> <publisher> The MIT press, </publisher> <address> Cambridge (MA, USA), </address> <year> 1991. </year>
Reference-contexts: For instance, the term (2 3) is in the image of " because 1 does not occur in it, but (1 3) is not in the image of " because 1 occurs in it. 4 Pattern unification 4.1 Transformation rules Definition 9 The language of (unification) constraints is defined by <ref> [9] </ref>: C ::= ( ` a = ? Here T represents the constraint that is always satisfied, F the unsatisfiable constraint, a and b are any -terms of the same type in context , and X 2 X .
Reference: [10] <author> Claude Kirchner, Helene Kirchner, and M. Rusinowitch. </author> <title> Deduction with symbolic constraints. </title> <journal> Revue d'Intelligence Artificielle, </journal> <volume> 4(3) </volume> <pages> 9-52, </pages> <year> 1990. </year> <note> Special issue on Automatic Deduction. </note>
Reference-contexts: However, almost all dynamically arising equations fall within the pattern fragment. This led to the development of a constraint simplification algorithm [20] which solves all equations between patterns and postpones other constraints. This constraint handling can then be used in a deduction-with-constraints process <ref> [10] </ref>. We show in this paper that the unification algorithm for patterns can be generalized to a constraint simplification algorithm for the unrestricted case. <p> Others (including certain flex-rigid and flex-flex equations) should be postponed as constraints in the hope that they will be instantiated further by solutions to other constraints. Such a general scheme of deduction with constraints has been studied in first order logic with equality <ref> [10] </ref> and has shown a fundamental improvement in the theorem proving techniques. In our situation, this technique avoids all branching during constraint simplification (as opposed to Huet's algorithm, for example). The resulting pattern simplification algorithm is described in [20] in the framework of the Elf programming language.
Reference: [11] <author> Lena Magnusson. </author> <title> The Implementation of ALF|A Proof Editor Based on Martin-Lof 's Monomorphic Type Theory with Explicit Substitution. </title> <type> PhD thesis, </type> <institution> Chalmers University of Technology and Goteborg University, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: This raises a number of tantalizing possibilities as pointed out by Duggan [7]. Besides MLF [8], the ALF system <ref> [11] </ref> also employs an explicit substitution calculus with dependent types and makes it available to the user, but its operational properties (such as unification) have not yet been fully investigated. Acknowledgements.
Reference: [12] <author> Spiro Michaylov and Frank Pfenning. </author> <title> An empirical study of the runtime behavior of higher-order logic programs. </title> <editor> In D. Miller, editor, </editor> <booktitle> Proceedings of the Workshop on the Prolog Programming Language, </booktitle> <pages> pages 257-271, </pages> <address> Philadelphia, Pennsylvania, </address> <month> July </month> <year> 1992. </year> <institution> University of Pennsylvania. </institution> <note> Available as Technical Report MS-CIS-92-86. </note>
Reference-contexts: This behaviour can be explained in algebraic terms as the fact that applying a pattern substitution to a term is injective and thus has an inverse. An empirical analysis of existing higher-order logic programs <ref> [12, 13] </ref> suggested that a static restriction of higher-order logic programming to patterns is too severe from the programmer's point of view. However, almost all dynamically arising equations fall within the pattern fragment. <p> An empirical study confirming this observation can be found in <ref> [12] </ref>. These experiments suggest an operational model, whereby equations which lie entirely within the pattern fragment of the typed -calculus should be solved immediately with the pattern unification algorithm.
Reference: [13] <author> Spiro Michaylov and Frank Pfenning. </author> <title> Higher-order logic programming as constraint logic programming. </title> <booktitle> In Position Papers for the First Workshop on Principles and Practice of Constraint Programming, </booktitle> <pages> pages 221-229, </pages> <address> Newport, Rhode Island, </address> <month> April </month> <year> 1993. </year> <institution> Brown University. </institution>
Reference-contexts: This behaviour can be explained in algebraic terms as the fact that applying a pattern substitution to a term is injective and thus has an inverse. An empirical analysis of existing higher-order logic programs <ref> [12, 13] </ref> suggested that a static restriction of higher-order logic programming to patterns is too severe from the programmer's point of view. However, almost all dynamically arising equations fall within the pattern fragment.
Reference: [14] <author> Dale Miller. </author> <title> A logic programming language with lambda-abstraction, function variables, and simple unification. </title> <journal> Journal of Logic and Computation, </journal> <volume> 1(4) </volume> <pages> 497-536, </pages> <year> 1991. </year>
Reference-contexts: In practice, modified versions of Huet's algorithm have performed well, despite the general undecidability of the problem. Miller observed that many problems fell within a decidable fragment <ref> [14] </ref>, usually now referred to as higher-order patterns. Unification on this fragment is decidable and unitary, even for very rich type theories such as the Calculus of Constructions [21].
Reference: [15] <author> Gopalan Nadathur. </author> <title> A notation for lambda terms II: Refinements and applications. </title> <type> Technical Report CS-1994-01, </type> <institution> Department of Computer Science, Duke University, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Furthermore, we have the guarantee that any produced solution without remaining constraints is indeed a most general solution, which is important, for example, in type reconstruction. 6 Related and future work Perhaps most closely related is work by Nadathur <ref> [17, 18, 15] </ref> who independently developed a calculus quite similar to explicit substitutions and sketched an implementation of Huet's algorithm for higher-order unification in it. Another solution has been adopted in Prolog/Mali [3]. As far as we know, nobody has considered this question for patterns or constraints.
Reference: [16] <author> Gopalan Nadathur and Dale Miller. </author> <title> An overview of Prolog. </title> <editor> In Kenneth A. Bowen and Robert A. Kowalski, editors, </editor> <booktitle> Fifth International Logic Programming Conference, </booktitle> <pages> pages 810-827, </pages> <address> Seattle, Washington, August 1988. </address> <publisher> MIT Press. </publisher>
Reference-contexts: 1 Introduction Typed -calculi of various sorts are used pervasively in logical frameworks and their implementations (e.g., Prolog <ref> [16] </ref>, Isabelle [19], or Elf [22]) and in general reasoning systems such as Coq or Nuprl. Unlike functional programming languages, these implementations require access to the body of -terms for such operations as substitution, normalization, matching, or unification.
Reference: [17] <author> Gopalan Nadathur and Debra Sue Wilson. </author> <title> A representation of lambda terms suitable for operations on their intensions. </title> <editor> In M. Wand, editor, </editor> <booktitle> Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 341-348, </pages> <year> 1990. </year>
Reference-contexts: Furthermore, we have the guarantee that any produced solution without remaining constraints is indeed a most general solution, which is important, for example, in type reconstruction. 6 Related and future work Perhaps most closely related is work by Nadathur <ref> [17, 18, 15] </ref> who independently developed a calculus quite similar to explicit substitutions and sketched an implementation of Huet's algorithm for higher-order unification in it. Another solution has been adopted in Prolog/Mali [3]. As far as we know, nobody has considered this question for patterns or constraints.
Reference: [18] <author> Gopalan Nadathur and Debra Sue Wilson. </author> <title> A notation for lambda terms I: A generalization of environments (revised). </title> <type> Technical Report CS-1994-03, </type> <institution> Department of Computer Science, Duke University, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Furthermore, we have the guarantee that any produced solution without remaining constraints is indeed a most general solution, which is important, for example, in type reconstruction. 6 Related and future work Perhaps most closely related is work by Nadathur <ref> [17, 18, 15] </ref> who independently developed a calculus quite similar to explicit substitutions and sketched an implementation of Huet's algorithm for higher-order unification in it. Another solution has been adopted in Prolog/Mali [3]. As far as we know, nobody has considered this question for patterns or constraints.
Reference: [19] <editor> Tobias Nipkow and Lawrence C. Paulson. Isabelle-91. In D. Kapur, editor, </editor> <booktitle> Proceedings of the 11th International Conference on Automated Deduction, </booktitle> <pages> pages 673-676, </pages> <address> Saratoga Springs, NY, </address> <year> 1992. </year> <note> Springer-Verlag LNAI 607. System abstract. </note>
Reference-contexts: 1 Introduction Typed -calculi of various sorts are used pervasively in logical frameworks and their implementations (e.g., Prolog [16], Isabelle <ref> [19] </ref>, or Elf [22]) and in general reasoning systems such as Coq or Nuprl. Unlike functional programming languages, these implementations require access to the body of -terms for such operations as substitution, normalization, matching, or unification.
Reference: [20] <author> Frank Pfenning. </author> <title> Logic programming in the LF logical framework. </title> <editor> In Gerard Huet and Gordon Plotkin, editors, </editor> <booktitle> Logical Frameworks, </booktitle> <pages> pages 149-181. </pages> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: However, almost all dynamically arising equations fall within the pattern fragment. This led to the development of a constraint simplification algorithm <ref> [20] </ref> which solves all equations between patterns and postpones other constraints. This constraint handling can then be used in a deduction-with-constraints process [10]. We show in this paper that the unification algorithm for patterns can be generalized to a constraint simplification algorithm for the unrestricted case. <p> In our situation, this technique avoids all branching during constraint simplification (as opposed to Huet's algorithm, for example). The resulting pattern simplification algorithm is described in <ref> [20] </ref> in the framework of the Elf programming language. The implementation [22] is practical, but not nearly as efficient as unification would be for a language such as Prolog. Some of these inefficiencies can be addressed using a calculus of explicit substitutions.
Reference: [21] <author> Frank Pfenning. </author> <title> Unification and anti-unification in the Calculus of Constructions. </title> <booktitle> In Sixth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 74-85, </pages> <address> Amster-dam, The Netherlands, </address> <month> July </month> <year> 1991. </year>
Reference-contexts: Miller observed that many problems fell within a decidable fragment [14], usually now referred to as higher-order patterns. Unification on this fragment is decidable and unitary, even for very rich type theories such as the Calculus of Constructions <ref> [21] </ref>.
Reference: [22] <author> Frank Pfenning. </author> <title> Elf: A meta-language for deductive systems. </title> <editor> In A. Bundy, editor, </editor> <booktitle> Proceedings of the 12th International Conference on Automated Deduction, </booktitle> <pages> pages 811-815, </pages> <address> Nancy, France, </address> <month> June </month> <year> 1994. </year> <note> Springer-Verlag LNAI 814. System abstract. </note>
Reference-contexts: 1 Introduction Typed -calculi of various sorts are used pervasively in logical frameworks and their implementations (e.g., Prolog [16], Isabelle [19], or Elf <ref> [22] </ref>) and in general reasoning systems such as Coq or Nuprl. Unlike functional programming languages, these implementations require access to the body of -terms for such operations as substitution, normalization, matching, or unification. Their efficient implementation is therefore a central problem in theorem proving and higher-order logic programming. <p> In our situation, this technique avoids all branching during constraint simplification (as opposed to Huet's algorithm, for example). The resulting pattern simplification algorithm is described in [20] in the framework of the Elf programming language. The implementation <ref> [22] </ref> is practical, but not nearly as efficient as unification would be for a language such as Prolog. Some of these inefficiencies can be addressed using a calculus of explicit substitutions.
Reference: [23] <author> Zhenyu Qian. </author> <title> Linear unification of higher-order patterns. </title> <editor> In M.-C. Gaudel and J.-P. Jouannaud, editors, </editor> <booktitle> Proceedings of the Colloquium on Trees in Algebra and Programming, </booktitle> <pages> pages 391-405, </pages> <address> Orsay, France, April 1993. </address> <publisher> Springer-Verlag LNCS 668. </publisher>
Reference-contexts: Another solution has been adopted in Prolog/Mali [3]. As far as we know, nobody has considered this question for patterns or constraints. Qian <ref> [23] </ref> gives a linear algorithm for higher-order pattern unification, but to our knowledge it has never been implemented and its practicality remains open. He also does not consider more general constraints.
Reference: [24] <author> A. Ros. </author> <title> Contributions a l'etude des -calculs avec des substitutions explicites. </title> <institution> These de Doctorat d'Universite, U. Paris VII, </institution> <year> 1993. </year>
Reference-contexts: For the sake of brevity we often omit type labels in -abstractions and substitutions. The reduction rules defining the semantics of this typed calculus are given in is called . It is shown in <ref> [24] </ref> that the typed -calculus is confluent and weakly terminating. For later use, let us also mention the notion of long normal form of a -term which is the -long form of its fi-normal form.
References-found: 24

