URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1998/1998-07.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fkoenh,frankb,wiebe,jjg@cs.ruu.nl  
Title: A Formal Embedding of AgentSpeak(L) in 3APL  
Author: Koen Hindriks, Frank S. de Boer, Wiebe van der Hoek and John-Jules Ch. Meyer 
Address: P.O. Box 80.089, 3508 TB Utrecht, The Netherlands  
Affiliation: University Utrecht, Department of Computer Science  
Abstract: Agent-based computing in Artificial Intelligence has given rise to a number of diverse and competing proposals for agent programming languages. Agents, in the sense we are using it, are complex mental entities consisting of beliefs, goals, and intentions. For several reasons it has been difficult to evaluate and compare the different proposals for agent languages. One of the main reasons, in our opinion, is the lack of a general semantic framework which provides a suitable basis for language comparison. Our aim is to make as much use as possible of formal methods from the area of programming semantics. In this paper, we give a formal embedding of the agent language AgentSpeak(L) in our own agent language 3APL. To this end we define a notion of simulation based on the formal operational semantics of the languages. The main result of the paper is a proof that 3APL can simulate AgentSpeak(L). As a consequence, 3APL has at least the same expressive power as AgentSpeak(L). The comparison yields some new insights into the features of the agent languages. One of the results is that AgentSpeak(L) can be substantially simplified. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mark d'Inverno, David Kinny, Michael Luck, and Michael Wooldridge. </author> <title> A Formal Specification of dMARS. </title> <editor> In Munindar P. Singh, Anand Rao, and Michael J. Wooldridge, editors, </editor> <booktitle> Intelligent Agents IV (LNAI 1365), </booktitle> <pages> pages 155-176, </pages> <year> 1998. </year>
Reference-contexts: The rule CleanStackEntry to be defined below was omitted in [8], as also noted in <ref> [1] </ref>. The rule implements the notion of an intention being executed in definition 16 in [8]. It is used for the removal of a plan that has been completely executed. <p> The rule CleanIntSet is used for this purpose. It was not given in [8], as was also noted in <ref> [1] </ref>. However, from a formal point of view the rule may be considered redundant because it does not change the observable behaviour of an agent.
Reference: [2] <author> Matthias Felleisen. </author> <title> On the expressive power of programming languages. </title> <editor> In G. Goos and J. Hartmanis, editors, </editor> <booktitle> 3rd European Symposium on Programming (LNCS 432), </booktitle> <pages> pages 134-151. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: The reason is that any reasonable programming language is Turing-complete, and for this reason any programming language can simulate another programming language. Therefore, we will impose one more constraint on the translation function t : A translation function should also preserve the global structure of an agent (cf. <ref> [2] </ref>). Such a constraint seems both intuitive and reasonable.
Reference: [3] <author> Koen V. Hindriks, Frank S. de Boer, Wiebe van der Hoek, and John-Jules Ch. Meyer. </author> <title> Control Structures of Rule-Based Agent Languages. </title> <note> Accepted for ATAL98, </note> <year> 1998. </year>
Reference-contexts: Other types of rules are conceivable, and are also included in 3APL. These second type of rules are used for other purposes than planning what to do, for example, for goal revision (cf. <ref> [4, 3] </ref>). An agent of the programming language AgentSpeak (L) consists of beliefs, goals, plan rules, intentions, and events which make up its mental state. An agent also has an associated set of actions for changing its environment. <p> This concludes our short summary of AgentSpeak (L) and 3APL. For the details, the reader is referred to [8] for AgentSpeak (L) and to <ref> [4, 3] </ref> for 3APL, and the discussion in the rest of this paper. <p> The selection functions can be looked upon as defining part of the control structure for an interpreter for AgentSpeak (L) (cf. <ref> [3] </ref>). 4.2 Semantics of AgentSpeak (L) The operational semantics of AgentSpeak (L) is given by a proof system. The proof system allows the derivation of computation steps of agents. The proof system consists of a set of proof rules which define a derivability relation `. <p> The main difference between AgentSpeak (2) and 3APL resides in the set of (plan) rules, since 3APL allows rules with more general heads. These rules make a more general type of goal revision possible (cf. <ref> [4, 3] </ref>). 6 Conclusion The conclusion which can be drawn from the results concerning the expressive power is that every agent which can be programmed in AgentSpeak (L) can also be programmed in 3APL. <p> For example, in every cycle of the interpreter first an event is processed and then an intention is processed (achieve goal, execute action or test). We 23 have looked in more detail at specifying the semantic structure imposed on AgentSpeak (L), and also for 3APL, by an interpreter in <ref> [3] </ref>, using the results obtained in the present paper that events and intentions can be transformed into goals.
Reference: [4] <author> Koen V. Hindriks, Frank S. de Boer, Wiebe van der Hoek, and John-Jules Ch. Meyer. </author> <title> Formal Semantics for an Abstract Agent Programming Language. </title> <editor> In Munindar P. Singh, Anand Rao, and Michael J. Wooldridge, editors, </editor> <booktitle> Intelligent Agents IV (LNAI 1365), </booktitle> <pages> pages 215-229, </pages> <year> 1998. </year>
Reference-contexts: One of the reasons for this, we think, is the lack of a general semantic framework which provides a suitable basis for language comparison. Our aim is to make as much use as possible of formal methods from more traditional computing science to deal with these issues. In <ref> [4] </ref> we introduced the agent programming language 3APL (triple-a-p-l) and formally defined its semantics. In that paper, we informally compared our programming language with several other programming languages for agents proposed in the literature. The most important characteristic of our language is that it is rule-based. <p> Other types of rules are conceivable, and are also included in 3APL. These second type of rules are used for other purposes than planning what to do, for example, for goal revision (cf. <ref> [4, 3] </ref>). An agent of the programming language AgentSpeak (L) consists of beliefs, goals, plan rules, intentions, and events which make up its mental state. An agent also has an associated set of actions for changing its environment. <p> This concludes our short summary of AgentSpeak (L) and 3APL. For the details, the reader is referred to [8] for AgentSpeak (L) and to <ref> [4, 3] </ref> for 3APL, and the discussion in the rest of this paper. <p> Such a renaming is necessary to avoid interference between variables which occur in the plan rule with variables that occur in the intention. This issue is discussed in more detail in <ref> [4] </ref>. Furthermore, the values retrieved by substitutions should be applied to the whole intention and not just to a part of it, as is done in [8]. Otherwise, value-passing would be of limited use. The generation of an internal event is defined in the next rule. <p> Theorem 5.11 proves that t 2 is a translation bisimulation, which corresponds to 22 condition E2 in definition 3.6. Taken together, this concludes the proof that AgentSpeak (2) has at least the same expressive power as AgentSpeak (1). Since AgentSpeak (2) is a proper subset of 3APL (cf. <ref> [4] </ref>), this also shows by transitivity of the expressiveness relation that 3APL has at least the same expressive power as AgentSpeak (2). The main difference between AgentSpeak (2) and 3APL resides in the set of (plan) rules, since 3APL allows rules with more general heads. <p> The main difference between AgentSpeak (2) and 3APL resides in the set of (plan) rules, since 3APL allows rules with more general heads. These rules make a more general type of goal revision possible (cf. <ref> [4, 3] </ref>). 6 Conclusion The conclusion which can be drawn from the results concerning the expressive power is that every agent which can be programmed in AgentSpeak (L) can also be programmed in 3APL. <p> On the other hand, a number of features of 3APL which are discussed in <ref> [4] </ref> were not needed to simulate AgentSpeak (L). These features include more (imperative) programming constructs like parallel composition and non-deterministic choice, and a more general goal revision mechanism.
Reference: [5] <author> Robin Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: The basic idea is that each computation step of one of the agents is matched or simulated by a computation step of the other agent, and vice versa. The comparison based on this idea is called (strong) bisimulation in the literature (cf. <ref> [6, 5] </ref>). A bisimulation is a binary relation between agents, based on a transition relation which defines the legal computation steps of agents. To be able to compare computation steps of agents we need to make explicit when computation steps match with each other. <p> In action-based semantics, transitions are labelled by actions, and it is easy to state such a condition: two computation steps match if they have the same action labels (cf. <ref> [5] </ref>). In case a state-based, unlabelled transition semantics is used, as is the case for the agent programming languages in this paper, the matching needs to be based on a state-based concept. We use the state-based concept of an observable.
Reference: [6] <author> David M. R. Park. </author> <title> Concurrency and Automata on Infinite Sequences (LNCS 104). </title> <publisher> Springer-Verlag, </publisher> <year> 1980. </year>
Reference-contexts: The basic idea is that each computation step of one of the agents is matched or simulated by a computation step of the other agent, and vice versa. The comparison based on this idea is called (strong) bisimulation in the literature (cf. <ref> [6, 5] </ref>). A bisimulation is a binary relation between agents, based on a transition relation which defines the legal computation steps of agents. To be able to compare computation steps of agents we need to make explicit when computation steps match with each other.
Reference: [7] <author> G. Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical report, </type> <institution> Aarhus University, Computer Science Department, </institution> <year> 1981. </year>
Reference: [8] <author> Anand S. Rao. AgentSpeak(L): </author> <title> BDI Agents Speak Out in a Logical Computable Language. </title> <editor> In W. van der Velde and J.W. Perram, editors, </editor> <booktitle> Agents Breaking Away, </booktitle> <pages> pages 42-55. </pages> <publisher> Springer, </publisher> <year> 1996. </year>
Reference-contexts: This concludes our short summary of AgentSpeak (L) and 3APL. For the details, the reader is referred to <ref> [8] </ref> for AgentSpeak (L) and to [4, 3] for 3APL, and the discussion in the rest of this paper. <p> We have tried to stay as close as possible to the original definition of the semantics of AgentSpeak (L) as given in <ref> [8] </ref>. The semantics of AgentSpeak (L) is defined by a slightly different and somewhat weaker formalism. It is quite easy, however, to transform the semantics of AgentSpeak (L) into a transition system, as we will show. <p> First, the syntax and semantics of the two languages AgentSpeak (L) and AgentSpeak (1) are defined. The definition of the syntax and semantics of AgentSpeak (L) is based on the description of AgentSpeak (L) in <ref> [8] </ref>. The semantic rules have been changed at a number of places, however, to correct for some omissions in [8]. <p> The definition of the syntax and semantics of AgentSpeak (L) is based on the description of AgentSpeak (L) in <ref> [8] </ref>. The semantic rules have been changed at a number of places, however, to correct for some omissions in [8]. The semantics of AgentSpeak (1) is given by means of a Plotkin-style transition system. 4.1 The Syntax of AgentSpeak (L) The beliefs of AgentSpeak (L) agents are given by a fragment of first-order logic, namely the set of literals. <p> A test goal is a test on the belief base to check if something is or is not believed to be the case. Definition 4.6 (triggering events) The set of triggering events E t is defined by: [Syn-9] If ! 2 G, then +! 2 E t . In <ref> [8] </ref>, four types of triggering events are defined. Besides the triggering event +! in definition 4.6, three other types of triggering events, !; +?, and ?, are defined. Triggering events are triggered when an addition (+) or deletion (-) to the set of goals or beliefs occurs. <p> Besides the triggering event +! in definition 4.6, three other types of triggering events, !; +?, and ?, are defined. Triggering events are triggered when an addition (+) or deletion (-) to the set of goals or beliefs occurs. The formal semantics in <ref> [8] </ref>, however, does not make any reference to the last three triggering events. Therefore, we do not consider the latter type of triggering events in this paper. The triggering event +! is generated in case a plan for an achievement goal ! has to be found. <p> Condition (i) expresses that no events have been generated when execution begins. Condition (ii) expresses that an agent may only have adopted a number of simple achievement goals when execution begins. The definition of AgentSpeak (L) agents we have given differs in some respects from that in <ref> [8] </ref>. One of the more important differences is that we do not put (basic) actions in a set to keep record of which actions have to be executed. Instead, we formally define the semantics of actions as updates on the belief base. <p> If the agent needs to keep track of actions which are executed or need to be executed, it can store this information in the belief base. Another difference is that we have not included the three selection functions from <ref> [8] </ref> for selecting intentions and plans. We think this is an aspect which should not be included in the definition of the operational semantics, but is better viewed as a feature of an interpreter implementing the agent language. <p> The composition of the two substitutions fl is used to instantiate variables in this new intention (and thus variables in the plan). The rule IntendMeans deals with internal events. We do not give a rule for external events. Such a rule is given in <ref> [8] </ref>, but since an agent will only generate internal events the rule is redundant. There is one important difference between the rule IntendMeans as given here and the one given in [8] which concerns the renaming of variables. <p> We do not give a rule for external events. Such a rule is given in <ref> [8] </ref>, but since an agent will only generate internal events the rule is redundant. There is one important difference between the rule IntendMeans as given here and the one given in [8] which concerns the renaming of variables. We use p 2 0 P to denote that p is a variant of a rule in P, i.e. a plan rule in which variables may have been renamed uniformly. <p> This issue is discussed in more detail in [4]. Furthermore, the values retrieved by substitutions should be applied to the whole intention and not just to a part of it, as is done in <ref> [8] </ref>. Otherwise, value-passing would be of limited use. The generation of an internal event is defined in the next rule. It is the only rule in the system that creates events (cf. remark above). <p> The rule CleanStackEntry to be defined below was omitted in <ref> [8] </ref>, as also noted in [1]. The rule implements the notion of an intention being executed in definition 16 in [8]. It is used for the removal of a plan that has been completely executed. <p> The rule CleanStackEntry to be defined below was omitted in <ref> [8] </ref>, as also noted in [1]. The rule implements the notion of an intention being executed in definition 16 in [8]. It is used for the removal of a plan that has been completely executed. The entry occupied by this plan is popped from the intention so that execution may continue with the remainder of the intention (which triggered the completed plan). <p> In case that a plan has been executed completely but there is no remaining part of the intention consisting of plans still to be executed, the intention itself may be removed from the intention set. The rule CleanIntSet is used for this purpose. It was not given in <ref> [8] </ref>, as was also noted in [1]. However, from a formal point of view the rule may be considered redundant because it does not change the observable behaviour of an agent. <p> Although we have based our description of the proof rules of AgentSpeak (L) on <ref> [8] </ref>, we have made a number of changes to the rules as they are presented in [8]. The rules we give do not modify the language in any essential way ([9]). <p> Although we have based our description of the proof rules of AgentSpeak (L) on <ref> [8] </ref>, we have made a number of changes to the rules as they are presented in [8]. The rules we give do not modify the language in any essential way ([9]). Apart from minor differences, the more important issue of renaming variables has already been discussed. 4.2.1 Computations and Observables The proof system for AgentSpeak (L) defines a derivation relation ` on BDI configurations. <p> Furthermore, it is not (yet) clear when and how to use this kind of `backtracking'. Research into integrating these kinds of possibilities into a formal semantics is still to be done, as far as we know. Besides the operational semantics for AgentSpeak (L), in <ref> [8] </ref> also an algorithm for an interpreter for AgentSpeak (L), or a control structure as we would like to call it, is defined. This control structure specifies to some extent in which order the proof rules should be used to execute AgentSpeak (L) agents.
Reference: [9] <author> Anand S. Rao. </author> <title> Private communication, </title> <month> March </month> <year> 1997. </year>
Reference: [10] <author> Krister Segerberg. </author> <title> Modal logics with linear alternative relations. </title> <journal> Theoria, </journal> <volume> 36 </volume> <pages> 301-322, </pages> <year> 1970. </year>
Reference-contexts: Such a method is called a translation function. If a translation function t defines a (weak) bisimulation R, i.e. t = R, we obtain a special case of (weak) bisimulation also called a p-morphism in the literature (cf. <ref> [10] </ref>). A p-morphism is a bisimulation such that the bisimulation relation is a function. This specialised notion of bisimulation yields a concept suitable to compare the expressive power of agent programming languages. In general, however, the sets of observables of two different languages are different.
Reference: [11] <author> Yoav Shoham. </author> <title> Agent-oriented programming. </title> <journal> Artificial Intelligence, </journal> <volume> 60 </volume> <pages> 51-92, </pages> <year> 1993. </year> <month> 24 </month>
Reference-contexts: Since the semantics of AGENT-0 is only given informally in <ref> [11] </ref>, we cannot construct an embedding for AGENT-0 agents. However, the language 3APL, which has a formal semantics, might be used to define the formal semantics of AGENT-0 or an abstraction of AGENT-0. The structure of this paper is as follows.
References-found: 11

