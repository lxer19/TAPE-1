URL: http://www.cs.gatech.edu/computing/Database/students/vibby/papers/mm-vldb92.ps.Z
Refering-URL: http://www.cs.gatech.edu/computing/Database/students/vibby/vibby.html
Root-URL: 
Title: Locking and Latching in a Memory-Resident Database System  
Author: Vibby Gottemukkala Tobin J. Lehman 
Date: 1992  
Address: Canada  
Note: Proceedings of the 18th VLDB Conference  
Affiliation: Georgia Institute of Technology IBM Almaden Research Center  Vancouver, British Columbia,  
Abstract: As part of the Starburst extensible database project developed at the IBM Almaden Research Center, we designed and implemented a memory-resident storage component that co-exists with Starburst's disk-oriented storage component. The two storage components share the same common services, such as query optimization, transaction management, etc. However, the memory-resident storage component is faster than the disk-oriented storage component and hence needs faster run-time services. This paper examines two run-time services, the lock manager and the latch mechanism, and investigates possible cost-cutting measures. We propose the use of of a single latch for protecting a table, all of its indexes, and all of its related lock information, in order to reduce storage component latch costs. We then show that although a table-level latch is a large granule latch, it does not significantly restrict concurrency. We also examine traditional lock manager design and suggest a different design that is appropriate for memory-resident storage components. The new design exploits direct addressing of lock data and dynamic, multi-granularity locks. Performance measurements of the new lock manager show that it outperforms the regular Starburst lock manager, which is of a traditional lock manager design, by as much as 60%. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the VLDB copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. keywords: Memory-resident database, lock manager, latch, Starburst.
Abstract-found: 1
Intro-found: 1
Reference: [Agrawal 85] <author> R. Agrawal, M. Carey, and M. Livny, </author> <title> "Models for Studying Concurrency Control Performance: Alternatives and Implications," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <month> May </month> <year> 1985. </year>
Reference-contexts: Compared to the large body of work in the locking family of concurrency control methods (for example, <ref> [Agrawal 85, Bernstein 81, Carey 83, Carey 84, Eswaran 76] </ref>), there is little or no published work in the area of changing the locking mechanism itself. The System R lock manager described in [Gray 78] appears to be the basic design choice of most database systems, including Starburst.
Reference: [Bernstein 81] <author> P. Bernstein and N. Goodman, </author> <title> "Concurrency Control in Distributed Database Systems," </title> <journal> ACM Computing Surveys 13, </journal> <month> 2 , June </month> <year> 1981. </year>
Reference-contexts: Compared to the large body of work in the locking family of concurrency control methods (for example, <ref> [Agrawal 85, Bernstein 81, Carey 83, Carey 84, Eswaran 76] </ref>), there is little or no published work in the area of changing the locking mechanism itself. The System R lock manager described in [Gray 78] appears to be the basic design choice of most database systems, including Starburst.
Reference: [Bitton 83] <author> D. Bitton, D. DeWitt, and C. Tur-byfill, </author> <title> "Benchmarking Simple Database Operations," </title> <booktitle> Proc. 9th VLDB Conf., </booktitle> <month> November </month> <year> 1983. </year>
Reference-contexts: Our example database is made up of 100 tables, each 10,000 tuples in size. Each tuple contains 16 fields and is 208 bytes long, as described by the Wisconsin Benchmark Database <ref> [Bitton 83] </ref>. To mimic a realistic distri bution of database references, we use the 80-20/80-20 rule. That is, 80% of the references go to 20% of the tables (warm tables). Furthermore, 80% of the references to warm tables go to 20% of the tables (hot tables).
Reference: [Blasgen 79] <author> M. Blasgen, J. Gray, M. Mitoma, and T. Price, </author> <title> "The Convoy Phenomenon," </title> <booktitle> Operating Systems Review 13, </booktitle> <month> 2 April </month> <year> 1979. </year>
Reference-contexts: 30 41% MMM Index Scan: Fetch 2 tuples (table latches) 0.329 ms 0.022 ms 3 6% MMM table and Index Insert: (node/index/lock latches) 0.552 ms 0.182 ms 25 33% MMM table and Index Insert: (table latches) 0.377 ms 0.0073 ms 1 2% Table 1: Latch costs in MMM and VRM. <ref> [Blasgen 79] </ref>. One way to avoid this problem would be to suspend process pre-emption for the duration of the table latch. 4 Thus, in a uni-processor system, any table-latch contention problems could be avoided.
Reference: [Carey 83] <author> M. Carey, </author> <title> "An Abstract Model of Database Concurrency Control Algorithms," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <month> May </month> <year> 1983. </year>
Reference-contexts: Compared to the large body of work in the locking family of concurrency control methods (for example, <ref> [Agrawal 85, Bernstein 81, Carey 83, Carey 84, Eswaran 76] </ref>), there is little or no published work in the area of changing the locking mechanism itself. The System R lock manager described in [Gray 78] appears to be the basic design choice of most database systems, including Starburst.
Reference: [Carey 84] <author> M. Carey and M. Stonebraker, </author> <title> "The Performance of Concurrency Control Algorithms for Database Management Systems," </title> <booktitle> Proc. 10th VLDB Conf., </booktitle> <month> August </month> <year> 1984. </year>
Reference-contexts: Compared to the large body of work in the locking family of concurrency control methods (for example, <ref> [Agrawal 85, Bernstein 81, Carey 83, Carey 84, Eswaran 76] </ref>), there is little or no published work in the area of changing the locking mechanism itself. The System R lock manager described in [Gray 78] appears to be the basic design choice of most database systems, including Starburst.
Reference: [DeWitt 90] <author> D. DeWitt et al., </author> <title> "The Gamma Database Machine Project," </title> <journal> IEEE TKDE 2, </journal> <volume> 1, </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: for the SB LM lock/unlock call at 370 RISC instructions, and compare that with the 150 IBM 370 (CISC) instructions that were used by a lock/unlock call in R* [Gray 89], and the 235 DEC VAX (CISC) instructions that were used by a lock/unlock call in the GAMMA database machine <ref> [DeWitt 90, Ghandeharizadeh 89] </ref>. It is difficult to compare RISC and CISC instructions at this level and draw any conclusions, but we can make some observations.
Reference: [DeWitt 84] <author> D.J. DeWitt et al, </author> <title> "Implementation Techniques for Main Memory Database Systems," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <month> June </month> <year> 1984. </year>
Reference: [Eich 87] <author> M. Eich, </author> <title> "A Classification and Comparison of Main Memory Database Recovery Techniques," </title> <booktitle> Proc. of the 3rd Int. Conf. on Data Engineering, </booktitle> <month> February </month> <year> 1987, </year> <pages> pp 332-339. </pages>
Reference: [Eswaran 76] <author> K. Eswaran, J. Gray, R. Lorie, and I. Traiger, </author> <title> "The Notions of Consistency and Predicate Locks in a Database System," </title> <journal> CACM Vol 19, </journal> <volume> No 11 , November 1976. </volume>
Reference-contexts: Compared to the large body of work in the locking family of concurrency control methods (for example, <ref> [Agrawal 85, Bernstein 81, Carey 83, Carey 84, Eswaran 76] </ref>), there is little or no published work in the area of changing the locking mechanism itself. The System R lock manager described in [Gray 78] appears to be the basic design choice of most database systems, including Starburst.
Reference: [Ghandeharizadeh 89] <author> S. Ghandeharizadeh, </author> <title> implementor of the GAMMA database machine lock manager, </title> <type> Personal communication, </type> <month> February </month> <year> 1989. </year>
Reference-contexts: for the SB LM lock/unlock call at 370 RISC instructions, and compare that with the 150 IBM 370 (CISC) instructions that were used by a lock/unlock call in R* [Gray 89], and the 235 DEC VAX (CISC) instructions that were used by a lock/unlock call in the GAMMA database machine <ref> [DeWitt 90, Ghandeharizadeh 89] </ref>. It is difficult to compare RISC and CISC instructions at this level and draw any conclusions, but we can make some observations.
Reference: [Gottemukkala 92] <author> V. Gottemukkala, T. Lehman, </author> <title> "The Design and Performance Evaluation of a Lock Manager for a Memory-Resident Database System," </title> <note> submitted for publication, </note> <month> Feb </month> <year> 1992. </year>
Reference: [Gray 78] <author> J. Gray, </author> <booktitle> "Notes on Database Operating Systems," Operating Systems, An Advanced Course, </booktitle> <volume> vol. 60, </volume> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: A latch, or short-term lock, is a low level primitive that provides a cheap serialization mechanism with shared and exclusive lock modes, but no deadlock detection <ref> [Gray 78] </ref>. In Starburst, latches are used to, among other things, gain exclusive or shared access to buffer pool pages. <p> The System R lock manager described in <ref> [Gray 78] </ref> appears to be the basic design choice of most database systems, including Starburst. Even though the regular Starburst lock manager keeps all of its data in memory, there are features in MMM that a lock manager could exploit to improve performance.
Reference: [Gray 89] <author> J. Gray, </author> <title> Implementor of the R* lock manager, </title> <type> Personal communication, </type> <month> February </month> <year> 1989. </year>
Reference-contexts: In fact, in R* [Williams 82], a distributed relational database system prototype developed at IBM research, a latch and unlatch operation used about 20 CISC (IBM 370) instructions, 1 which was roughly an order of magnitude less than a lock and unlock operation <ref> [Yost 92, Gray 89, Lehman 89] </ref>. Thus, given a latch's relatively short pathlength, one might dismiss the concern of latches imposing a significant overhead in the overall storage component pathlength. 2.1 Design Alternatives One could imagine different MMM designs depending on latch cost. <p> We estimate the 37 microseconds for the SB LM lock/unlock call at 370 RISC instructions, and compare that with the 150 IBM 370 (CISC) instructions that were used by a lock/unlock call in R* <ref> [Gray 89] </ref>, and the 235 DEC VAX (CISC) instructions that were used by a lock/unlock call in the GAMMA database machine [DeWitt 90, Ghandeharizadeh 89]. It is difficult to compare RISC and CISC instructions at this level and draw any conclusions, but we can make some observations.
Reference: [Haas 89] <author> L. Haas et al., </author> <title> "Extensible Query Processing in Starburst," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: At the IBM Almaden Research Center, we are building such a system. As the base relational database system, we are using Starburst, an extensible database system prototype <ref> [Haas 89, Haas 90] </ref>. One of the goals of Starburst is to support experimentation with storage components through the use of its extensible Data Management Extension Architecture (DMEA) [Lindsay 87]. DMEA provides database implementors with a simple interface for creating new storage methods and attachments.
Reference: [Haas 90] <author> L. Haas et al., </author> <title> "Starburst Mid-Flight: As the Dust Clears," </title> <journal> IEEE TKDE 2, </journal> <volume> 1, </volume> <month> March </month> <year> 1990. </year>
Reference-contexts: At the IBM Almaden Research Center, we are building such a system. As the base relational database system, we are using Starburst, an extensible database system prototype <ref> [Haas 89, Haas 90] </ref>. One of the goals of Starburst is to support experimentation with storage components through the use of its extensible Data Management Extension Architecture (DMEA) [Lindsay 87]. DMEA provides database implementors with a simple interface for creating new storage methods and attachments.
Reference: [Hagmann 86] <author> R. Hagmann, </author> <title> "A Crash Recovery Scheme for a Memory-Resident Database System," </title> <journal> IEEE Trans. on Computers C-35, </journal> <month> 9 , September </month> <year> 1986. </year>
Reference: [Horwitz 85] <author> S. Horwitz and T. Teitelbaum, </author> <title> "Relations and Attributes: A Symbiotic Basis for Editing Environments," </title> <booktitle> Proc. ACM SIGPLAN Conf. on Lang. Issues in Prog. </booktitle> <address> Env., </address> <month> June </month> <year> 1985. </year>
Reference-contexts: 1 Introduction The performance of relational database management system (DBMS) implementations has often been a problem for non-traditional database applications wishing to use the attractive features of the relational model. Applications such as language-based editors <ref> [Horwitz 85] </ref>, program development environments [Lin-ton 84], and performance monitoring tools [Snodgrass 84] could benefit from using the relational model, yet they require better performance than that typically associated with disk-oriented database systems.
Reference: [Kleinrock 75] <author> L. Kleinrock, </author> <title> Queuing Systems Vol I: Theory, </title> <publisher> Wiley, </publisher> <year> 1975. </year>
Reference-contexts: In this analysis, it is assumed that all limiting effects (such as multiprogramming level limitations or contention for other resources) have been removed. Then, given i , Little's Law <ref> [Kleinrock 75] </ref> N = i gives us the number of transactions that can be run in parallel, which equates to the processors that can be kept busy simultaneously. We refer to this quantity as the amount of processor overlap.
Reference: [Kumar 91] <author> V. Kumar and A. Berger, </author> <title> "Performance Measurement of Some Main Memory Database Recovery Algorithms," </title> <booktitle> Proc. of the 7th Int. Conf. on Data Engineering, </booktitle> <month> April </month> <year> 1991. </year>
Reference: [Lamb 91 ] <author> C. Lamb, G. Landis, J. Orenstein, Dan Weinreb, </author> <title> "The ObjectStore Database System," </title> <journal> CACM Vol 34, </journal> <note> No 10 , October 1991. </note>
Reference-contexts: Thus, application designers are often frustrated in choosing between database systems that offer either function or performance, but never both. The advent of object-oriented database systems, such as Object Store <ref> [Lamb 91] </ref>, has further clouded the issue of which type of database system to use. Object Store uses a memory-based storage component and, as a result, is able to perform database operations at memory speeds. <p> Object Store uses a memory-based storage component and, as a result, is able to perform database operations at memory speeds. Furthermore, the virtues of object-oriented programming have already contributed to many success stories <ref> [Michaels 91, Lamb 91] </ref>. However, those applications that need support for relational operations, as well as high-performance, have not yet had their needs met.
Reference: [Lehman 86] <author> T. Lehman and M. Carey, </author> <title> "A Study of Index Structures for Main Memory Database Management Systems," </title> <booktitle> Proc. 12th Conf. Very Large Data Bases, </booktitle> <month> August </month> <year> 1986. </year>
Reference-contexts: If latch cost were indeed insignificant, as some numbers indicate, one might consider a design of the MMM storage component that mimicked the VRM design, i.e. where individual latches control a table's memory pages (referred to in MMM as partitions 2 ), the nodes in a (T Tree <ref> [Lehman 86] </ref>) index, and the lock manager data structures. The many fine-grained latches would ensure that sharing was not limited. If, on the other hand, latch cost turned out to be more substantial, one might consider an alternative MMM design where all latches were removed, except one: the table latch. <p> The disparity between the two latching paradigms is more apparent when we examine the index case. MMM indexes contain only pointers to table data <ref> [Lehman 86, Lehman 92] </ref>, so table data must be latched whenever an index is used. <p> Starburst memory constraints prevented us from creating a lock hash table larger than 1,000 slots, so lock numbers greater than 500 caused SB LM's performance to decrease. 6 The best perfor 6 By using a dynamic hashing algorithm, such as linear hashing [Litwin 80] or modified linear hashing <ref> [Lehman 86] </ref>, we could mance was obtained from SB LM when setting and releasing 100 locks, 25 microseconds and 12 microseconds, respectively.
Reference: [Lehman 87] <author> T. Lehman and M. Carey, </author> <title> "A Recovery Algorithm for a High-Performance Memory-Resident Database System," </title> <booktitle> Proc. ACM SIG-MOD Conf., </booktitle> <month> May </month> <year> 1987. </year>
Reference: [Lehman 89] <author> T. Lehman and M. Carey, </author> <title> "A Con-currency Control Algorithm for Memory-Resident Database System," </title> <booktitle> Foundations of Data Organization and Algorithms, </booktitle> <month> FODO </month> <year> 1989. </year>
Reference-contexts: In fact, in R* [Williams 82], a distributed relational database system prototype developed at IBM research, a latch and unlatch operation used about 20 CISC (IBM 370) instructions, 1 which was roughly an order of magnitude less than a lock and unlock operation <ref> [Yost 92, Gray 89, Lehman 89] </ref>. Thus, given a latch's relatively short pathlength, one might dismiss the concern of latches imposing a significant overhead in the overall storage component pathlength. 2.1 Design Alternatives One could imagine different MMM designs depending on latch cost.
Reference: [Lehman 92] <author> T. Lehman, E. Shekita, </author> <title> and L.F. Cabr-era, An Evaluation of the Starburst Memory-Resident Storage Component , Submitted for publication, </title> <month> Feb </month> <year> 1992. </year>
Reference-contexts: The two Starburst storage components of interest in this paper are the traditional disk-oriented storage component, known as the Vanilla Relation Manager (VRM), and the high-performance memory-resident storage component, known as the Main Memory Manager (MMM) <ref> [Lehman 92] </ref>. MMM is intended to be the storage component one would use when storing data for which fast response-time is crucial, while for less critical data, or for data that does not fit in memory, VRM would be used. <p> The disparity between the two latching paradigms is more apparent when we examine the index case. MMM indexes contain only pointers to table data <ref> [Lehman 86, Lehman 92] </ref>, so table data must be latched whenever an index is used. <p> Hence, setting a tuple lock results in two lock calls to set the table-level intention lock and the actual tuple lock. 3.2 The MMM Lock Manager MMM and the MMM lock manager. MMM manages tables in variable-length segments, which are collec tions of fixed-length partitions that contain records <ref> [Lehman 92] </ref>. Each segment has a segment control block, which contains control information, and lock information. As we mentioned in Section 2, a single table latch protects the table and all of its related structures, such as index and lock information.
Reference: [Lindsay 89] <author> B. Lindsay, R* implementor, </author> <type> personal communication, </type> <month> Feb 89. </month>
Reference: [Lindsay 87] <author> B. Lindsay, J. McPherson, and H. Pira-hesh, </author> <title> "A Data Management Extension Architecture," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <month> June </month> <year> 1987. </year>
Reference-contexts: As the base relational database system, we are using Starburst, an extensible database system prototype [Haas 89, Haas 90]. One of the goals of Starburst is to support experimentation with storage components through the use of its extensible Data Management Extension Architecture (DMEA) <ref> [Lindsay 87] </ref>. DMEA provides database implementors with a simple interface for creating new storage methods and attachments. In Starburst terms, storage methods manage tables and their associated records, while attachments manage data structures related to tables, such as indexes.
Reference: [Linton 84] <author> M. Linton, </author> <title> "Implementing Relational Views of Programs," </title> <booktitle> Proc. ACM SIGSOFT-SIGPLAN Symp. on Practical Software Development Environments, </booktitle> <month> April </month> <year> 1984. </year>
Reference: [Litwin 80] <author> W. Litwin, </author> <title> "Linear Hashing: A New Tool for File and Table Addressing," </title> <booktitle> Proc. 6th Conf. Very Large Data Bases, </booktitle> <month> October </month> <year> 1980. </year>
Reference-contexts: Starburst memory constraints prevented us from creating a lock hash table larger than 1,000 slots, so lock numbers greater than 500 caused SB LM's performance to decrease. 6 The best perfor 6 By using a dynamic hashing algorithm, such as linear hashing <ref> [Litwin 80] </ref> or modified linear hashing [Lehman 86], we could mance was obtained from SB LM when setting and releasing 100 locks, 25 microseconds and 12 microseconds, respectively.
Reference: [Michaels 91] <author> J. Michaels, </author> <title> "Managing Money with Objects," </title> <journal> Wall Street Computer Review, </journal> <volume> Vol 9, No. 3, </volume> <month> December </month> <year> 1991. </year>
Reference-contexts: Object Store uses a memory-based storage component and, as a result, is able to perform database operations at memory speeds. Furthermore, the virtues of object-oriented programming have already contributed to many success stories <ref> [Michaels 91, Lamb 91] </ref>. However, those applications that need support for relational operations, as well as high-performance, have not yet had their needs met.
Reference: [Salem 90] <author> K. Salem and H. Garcia-Molina, </author> <title> "System M: A Transaction Processing Testbed for Memory-Resident Data," </title> <journal> IEEE TKDE 2, </journal> <volume> 1, </volume> <month> March </month> <year> 1990. </year>
Reference: [Salem 86] <author> K. Salem and H. Garcia-Molina, </author> <title> Crash Recovery Mechanisms for Main Storage Database Systems, </title> <type> Tech. Rep. </type> <institution> No. CS-TR-0340-86, CS Dept., Princeton Univ., </institution> <month> April </month> <year> 1986. </year>
Reference: [Snodgrass 84] <author> R. Snodgrass, </author> <title> "Monitoring in a Software Development Environment: A Relational Approach," </title> <booktitle> Proc. ACM SIGSOFT-SIGPLAN Symp. on Practical Soft. </booktitle> <institution> Dev. Env., </institution> <month> April </month> <year> 1984. </year>
Reference-contexts: 1 Introduction The performance of relational database management system (DBMS) implementations has often been a problem for non-traditional database applications wishing to use the attractive features of the relational model. Applications such as language-based editors [Horwitz 85], program development environments [Lin-ton 84], and performance monitoring tools <ref> [Snodgrass 84] </ref> could benefit from using the relational model, yet they require better performance than that typically associated with disk-oriented database systems. Thus, application designers are often frustrated in choosing between database systems that offer either function or performance, but never both.
Reference: [Williams 82 ] <author> R. Williams et al, </author> <title> "R*: An Overview of the Architecture," </title> <booktitle> Proc. of the Int. Conf. on Database Systems, </booktitle> <address> Jerusalem, Israel, </address> <month> June </month> <year> 1982. </year> <title> Published in Improving Database Usability and Responsiveness, </title> <editor> P. Scheuermann, ed. </editor> <publisher> Academic Press, </publisher> <address> N.Y. </address>
Reference-contexts: A latch operation typically involves far fewer instructions than a lock operation, as a latch's data structures are statically allocated and directly addressable. In fact, in R* <ref> [Williams 82] </ref>, a distributed relational database system prototype developed at IBM research, a latch and unlatch operation used about 20 CISC (IBM 370) instructions, 1 which was roughly an order of magnitude less than a lock and unlock operation [Yost 92, Gray 89, Lehman 89].
Reference: [Yost 92 ] <author> R. Yost, </author> <title> Implementor of the R* latch mechanism, </title> <type> personal communication, </type> <month> February </month> <year> 1992. </year>
Reference-contexts: In fact, in R* [Williams 82], a distributed relational database system prototype developed at IBM research, a latch and unlatch operation used about 20 CISC (IBM 370) instructions, 1 which was roughly an order of magnitude less than a lock and unlock operation <ref> [Yost 92, Gray 89, Lehman 89] </ref>. Thus, given a latch's relatively short pathlength, one might dismiss the concern of latches imposing a significant overhead in the overall storage component pathlength. 2.1 Design Alternatives One could imagine different MMM designs depending on latch cost.
References-found: 35

