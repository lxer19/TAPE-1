URL: http://pine.cs.yale.edu:4201/home/stoc97-proceedings.ps
Refering-URL: http://pine.cs.yale.edu:4201/home/coin-abstract.html
Root-URL: http://www.cs.yale.edu
Title: Lower Bounds for Distributed Coin-Flipping and Randomized Consensus  
Author: James Aspnes 
Abstract: We examine a class of collective coin-flipping games that arises from randomized distributed algorithms with halting failures. In these games, a sequence of local coin flips is generated, which must be combined to form a single global coin flip. An adversary monitors the game and may attempt to bias its outcome by hiding the result of up to t local coin flips. We show that to guarantee at most constant bias, (t 2 ) local coins are needed, even if (a) the local coins can have arbitrary distributions and ranges, (b) the adversary is required to decide immediately whether to hide or reveal each local coin, and (c) the game can detect which local coins have been hidden. If the adversary is permitted to control the outcome of the coin except for cases whose probability is polynomial in t, (t 2 = log 2 t) local coins are needed. Combining this fact with an extended version of the well-known Fischer-Lynch-Paterson impossibility proof of deterministic consensus, we show that given an adaptive adversary, any t-resilient asynchronous consensus protocol requires (t 2 = log 2 t) local coin flips in any model that can be simulated deterministically using atomic registers. This gives the first non-trivial lower bound on the total work required by wait-free consensus and is tight to within logarithmic factors. 
Abstract-found: 1
Intro-found: 1
Reference: [AAT94] <author> Rajeev Alur, Hagit Attiya, and Gadi Taubenfeld. </author> <title> Time-adaptive algorithms for synchronization. </title> <booktitle> In Proceedings of the Twenty-Sixth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 800-809, </pages> <address> Montreal, Quebec, Canada, </address> <month> may </month> <year> 1994. </year>
Reference-contexts: Restrictions on the amount of asynchrony can also have a large effect <ref> [AAT94, SSW91] </ref>. 5 Acknowledgments The author is indebted to Russell Impagliazzo for many fruitful discussions of coin-flipping problems, Steven Rudich for a suggestion that eventually became the truncation argument used to prove Theorem 5, Mike Saks for encouragement and pointers to related work, and Faith Fich, Wai-Kau Lo, Eric Ruppert, and
Reference: [AB96] <author> Yonatan Aumann and Michael Bender. </author> <title> Efficient asynchronous consensus with a value-oblivious adversary scheduler. </title> <booktitle> In Proceedings of the 23rd International Conference on Automata, Languages, and Programming, </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: Various versions of this can be found in the the consensus work of Chor, Israeli, and Li [CIL87] and Abrahamson [Abr88], and in the O (n log n) total work protocol of Aumann and Bender <ref> [AB96] </ref> and the O (log n) work-per-process protocol of Chandra [Cha96].
Reference: [Abr88] <author> K. Abrahamson. </author> <title> On achieving consensus using a shared memory. </title> <booktitle> In Proceedings of the Seventh ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1988. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson <ref> [Abr88] </ref>; since its appearance, numerous polynomial-time algorithms have appeared [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96]. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting. <p> One plausible approach is to limit the knowledge the adversary has of register contents, to prevent it from discriminating against coin-flips it dislikes. Various versions of this can be found in the the consensus work of Chor, Israeli, and Li [CIL87] and Abrahamson <ref> [Abr88] </ref>, and in the O (n log n) total work protocol of Aumann and Bender [AB96] and the O (log n) work-per-process protocol of Chandra [Cha96].
Reference: [ADS89] <author> Hagit Attiya, Danny Dolev, and Nir Shavit. </author> <title> Bounded polynomial randomized consensus. </title> <booktitle> In Proceedings of the Eighth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 281-294, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting.
Reference: [AH90] <author> James Aspnes and Maurice Herlihy. </author> <title> Fast randomized consensus using shared memory. </title> <journal> Journal of Algorithms, </journal> <volume> 11(3) </volume> <pages> 441-461, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting. <p> 2 ) local coin-flips, and at least (n 2 ) work in order to communicate these coin-flips. 1 1 Some of the algorithms deviate slightly from the simple Improvements in other aspects of consensus algo-rithms have steadily brought their costs down, from the O (n 4 ) total work of <ref> [AH90] </ref> to the O (n 2 log n) total work of [BR91]. But while these algorithms have steadily approached the (n 2 ) barrier, none have broken it.
Reference: [AN90] <author> Noga Alon and Moni Naor. </author> <title> Coin-flipping games immune against linear-sized coalitions. </title> <booktitle> In Proceedings of the 31st Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 46-54. </pages> <publisher> IEEE, </publisher> <year> 1990. </year>
Reference-contexts: Many such games assume that the locations of faulty coins are fixed in advance; under these assumptions very efficient games exist <ref> [AN90, CL93, BOL85, Sak89] </ref>.
Reference: [Asp93] <author> James Aspnes. </author> <title> Time- and space-efficient randomized consensus. </title> <journal> Journal of Algorithms, </journal> <volume> 14(3) </volume> <pages> 414-431, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting. <p> However, no proof was known that consensus could not be solved in less than (n 2 ) time; the barrier was solely a result of the apparent absence of alternatives to using shared coins based on majority voting. Indeed, it was asked in <ref> [Asp93] </ref> if it was necessarily the case that (a) every consensus protocol contained an embedded shared coin protocol; and (b) no shared coin protocol could achieve better performance than majority voting. 1.1 Our Results In this paper we answer both of these questions, though the answers are not as simple as <p> Furthermore, it is tight in the sense that it shows that no constant-bias shared coin can use less than (t 2 ) local coins, a bound achieved (ignoring constants) by majority voting. majority-voting approach described here. In the algorithm of Aspnes <ref> [Asp93] </ref>, some votes are generated deterministically. In the algorithm of Saks, Shavit, and Woll [SSW91], several coin-flipping protocols optimized for different execution patterns are run in parallel.
Reference: [AW96] <author> James Aspnes and Orli Waarts. </author> <title> Randomized consensus in O(n log 2 n) operations per processor. </title> <journal> SIAM Journal on Computing, </journal> <volume> 25(5) </volume> <pages> 1024-1044, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting. <p> In the algorithm of Aspnes [Asp93], some votes are generated deterministically. In the algorithm of Saks, Shavit, and Woll [SSW91], several coin-flipping protocols optimized for different execution patterns are run in parallel. In the algorithm of Aspnes and Waarts <ref> [AW96] </ref>, processes that have already cast many votes generate votes with increasing weights in order to finish the protocol quickly.
Reference: [BOL85] <author> Michael Ben-Or and Nathan Linial. </author> <title> Collective coin flipping, robust voting schemes and minimization of banzhaf values. </title> <booktitle> In Proceedings of the 26th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 408-416. </pages> <publisher> IEEE, </publisher> <year> 1985. </year>
Reference-contexts: However, none of these protocols costs less than simple majority voting in terms of the expected total number of local coin flips performed in the worst case. 1.2 Related Work Many varieties of collective coin-flipping games have been studied, starting with the work of Ben-Or and Linial <ref> [BOL85] </ref>. Many such games assume that the locations of faulty coins are fixed in advance; under these assumptions very efficient games exist [AN90, CL93, BOL85, Sak89]. <p> Many such games assume that the locations of faulty coins are fixed in advance; under these assumptions very efficient games exist <ref> [AN90, CL93, BOL85, Sak89] </ref>. <p> They show that any such consensus protocol must use ( p n) distinct registers to guarantee agreement. Unfortunately, their techniques do not appear to generalize to showing lower bounds on work. 2 Coin-Flipping Games A collective coin-flipping game <ref> [BOL85] </ref> is an algorithm for combining many local coins into a single global coin, whose bias should be small even though some of the local coins may be obscured by a malicious adversary.
Reference: [BOLS87] <author> M. Ben-Or, N. Linial, and M. Saks. </author> <title> Collective coin flipping and other models of imperfect randomness. In Combinatorics, </title> <journal> volume 52 of Colloquia Mathematic Societatis Janos Bolyai, </journal> <pages> pages 75-112, </pages> <address> Eger (Hun-gary), </address> <year> 1987. </year>
Reference-contexts: If none of these limiting assumptions are made, the adversary gains considerably more power. An excellent survey of results for a wide variety of models involving fair or nearly fair two-valued local coins can be found in <ref> [BOLS87] </ref>. Our work differs from these in that we allow arbitrary distributions on the local coins.
Reference: [BR90] <author> Gabi Bracha and Ophir Rachman. </author> <title> Approximated counters and randomized consensus. </title> <type> Technical Report 662, </type> <institution> Technion, </institution> <year> 1990. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting.
Reference: [BR91] <author> Gabi Bracha and Ophir Rachman. </author> <title> Randomized consensus in expected O(n 2 log n) operations. </title> <booktitle> In Proceedings of the Fifth Workshop on Distributed Algorithms, </booktitle> <year> 1991. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting. <p> in order to communicate these coin-flips. 1 1 Some of the algorithms deviate slightly from the simple Improvements in other aspects of consensus algo-rithms have steadily brought their costs down, from the O (n 4 ) total work of [AH90] to the O (n 2 log n) total work of <ref> [BR91] </ref>. But while these algorithms have steadily approached the (n 2 ) barrier, none have broken it.
Reference: [CFG + 85] <author> Benny Chor, Joel Friedman, Oded Goldre--ich, Johan H-astad, Steven Rudich, and Roman Smolensky. </author> <title> The bit extraction problem or t-resilient functions. </title> <booktitle> In Proceedings of the 2th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 396-407. </pages> <publisher> IEEE, </publisher> <year> 1985. </year>
Reference-contexts: Another assumption that greatly limits the power of the adversary is to require that both the locations and values of faulty coins are fixed in advance; this is the bit extraction problem <ref> [CFG + 85, Fri92, Vaz85] </ref>, in which it is possible to derive completely unbiased random bits. If none of these limiting assumptions are made, the adversary gains considerably more power.
Reference: [Cha96] <author> Tushar Deepak Chandra. </author> <title> Polylog randomized wait-free consensus. </title> <booktitle> In Proceedings of the Fifteenth Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 166-175, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: This is not the case for consensus; for example, Chandra's consensus algorithm <ref> [Cha96] </ref> for a weak adversary switches over to an algorithm that is robust against an adaptive adversary if it does not finish in its usual time. <p> Various versions of this can be found in the the consensus work of Chor, Israeli, and Li [CIL87] and Abrahamson [Abr88], and in the O (n log n) total work protocol of Aumann and Bender [AB96] and the O (log n) work-per-process protocol of Chandra <ref> [Cha96] </ref>.
Reference: [CI93] <author> Richard Cleve and Russell Impagliazzo. </author> <title> Martingales with Boolean final value must make jumps of O(1=n 1=2 ) with constant probability. </title> <type> Unpublished manuscript, </type> <year> 1993. </year>
Reference-contexts: Without such a restriction, the best previously known bound is a bound of (1= n) on the influence of an adversary that can hide one coin; this is an easy corollary of a theorem about gaps in martingale sequences due to Cleve and Impagliazzo <ref> [CI93] </ref>. A very nice lower bound on the space used by wait-free shared-memory consensus is due to Fich, Herlihy, and Shavit [FHS93]. They show that any such consensus protocol must use ( p n) distinct registers to guarantee agreement.
Reference: [CIL87] <author> B. Chor, A. Israeli, and M. Li. </author> <title> On processor coordination using asynchronous hardware. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1987. </year>
Reference-contexts: In an asynchronous setting, it has long been known that if an adversary can halt a single process, then no deterministic consensus algorithm is possible without the use of powerful synchronization primitives <ref> [CIL87, DDS87, FLP85, Her91, LAA87] </ref>. In contrast, randomized algorithms can solve consensus in a shared-memory system for n processes even if the adversary can halt up to n 1 processes. <p> One plausible approach is to limit the knowledge the adversary has of register contents, to prevent it from discriminating against coin-flips it dislikes. Various versions of this can be found in the the consensus work of Chor, Israeli, and Li <ref> [CIL87] </ref> and Abrahamson [Abr88], and in the O (n log n) total work protocol of Aumann and Bender [AB96] and the O (log n) work-per-process protocol of Chandra [Cha96].
Reference: [CL93] <author> Jason Cooper and Nathan Linial. </author> <title> Fast perfect-information leader-election protocol with linear immunity. </title> <booktitle> In Proceedings of the Twenty-Fifth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 662-671. </pages> <publisher> ACM, </publisher> <year> 1993. </year>
Reference-contexts: Many such games assume that the locations of faulty coins are fixed in advance; under these assumptions very efficient games exist <ref> [AN90, CL93, BOL85, Sak89] </ref>.
Reference: [DDS87] <author> D. Dolev, C. Dwork, and L. Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> 34(1) </volume> <pages> 77-97, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: In an asynchronous setting, it has long been known that if an adversary can halt a single process, then no deterministic consensus algorithm is possible without the use of powerful synchronization primitives <ref> [CIL87, DDS87, FLP85, Her91, LAA87] </ref>. In contrast, randomized algorithms can solve consensus in a shared-memory system for n processes even if the adversary can halt up to n 1 processes.
Reference: [DHPW92] <author> Cynthia Dwork, Maurice Herlihy, Serge Plotkin, and Orli Waarts. </author> <title> Time-lapse snapshots. </title> <booktitle> In Proceedings of Israel Symposium on the Theory of Computing and Systems, </booktitle> <year> 1992. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting.
Reference: [FHS93] <author> Faith Fich, Maurice Herlihy, and Nir Shavit. </author> <title> On the complexity of randomized synchronization. </title> <booktitle> In Proceedings of the 12th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1993. </year>
Reference-contexts: A very nice lower bound on the space used by wait-free shared-memory consensus is due to Fich, Herlihy, and Shavit <ref> [FHS93] </ref>. They show that any such consensus protocol must use ( p n) distinct registers to guarantee agreement.
Reference: [FLP85] <author> M. Fischer, N.A. Lynch, </author> <title> and M.S. Pater-son. Impossibility of distributed commit with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2), </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: In an asynchronous setting, it has long been known that if an adversary can halt a single process, then no deterministic consensus algorithm is possible without the use of powerful synchronization primitives <ref> [CIL87, DDS87, FLP85, Her91, LAA87] </ref>. In contrast, randomized algorithms can solve consensus in a shared-memory system for n processes even if the adversary can halt up to n 1 processes. <p> These ranges are used to define a probabilistic version of the bivalence and univalence conditions used in the well-known Fischer-Lynch-Paterson (FLP) impossibility proof for deterministic consensus <ref> [FLP85] </ref>. We will define an execution as bivalent if the adversary can force either outcome with high probability. A v-valent execution will be one after which only the outcome v can be forced with high probability.
Reference: [Fri92] <author> Joel Friedman. </author> <title> On the bit extraction problem. </title> <booktitle> In Proceedings of the 33rd Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 314-319. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: Another assumption that greatly limits the power of the adversary is to require that both the locations and values of faulty coins are fixed in advance; this is the bit extraction problem <ref> [CFG + 85, Fri92, Vaz85] </ref>, in which it is possible to derive completely unbiased random bits. If none of these limiting assumptions are made, the adversary gains considerably more power.
Reference: [Har66] <author> L. H. Harper. </author> <title> Optimal numberings and isoperimetric problems on graphs. </title> <journal> Journal of Combinatorial Theory, </journal> <volume> 1 </volume> <pages> 385-394, </pages> <year> 1966. </year>
Reference-contexts: Our work differs from these in that we allow arbitrary distributions on the local coins. With a restriction to fair coins, Harper's isoperimetric inequality for the hypercube <ref> [Har66] </ref> implies that the majority function gives the least power to an off-line adversary that can see all coins before deciding which to change; and Lichtenstein, Linial, and Saks [LLS89] have shown that majority is also optimal against an on-line adversary similar to the one we consider here.
Reference: [Her91] <author> Maurice Herlihy. </author> <title> Wait-free synchronization. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(1) </volume> <pages> 124-149, </pages> <month> Jan-uary </month> <year> 1991. </year>
Reference-contexts: In an asynchronous setting, it has long been known that if an adversary can halt a single process, then no deterministic consensus algorithm is possible without the use of powerful synchronization primitives <ref> [CIL87, DDS87, FLP85, Her91, LAA87] </ref>. In contrast, randomized algorithms can solve consensus in a shared-memory system for n processes even if the adversary can halt up to n 1 processes. <p> In contrast, randomized algorithms can solve consensus in a shared-memory system for n processes even if the adversary can halt up to n 1 processes. Such algorithms are called wait-free <ref> [Her91] </ref> because any process can finish the algorithm without waiting for slower (or possibly dead) processes.
Reference: [LAA87] <author> Michael C. Loui and Hosame H. Abu-Amara. </author> <title> Memory requirements for agreement among unreliable asynchronous processes. </title> <editor> In Franco P. Preparata, editor, </editor> <booktitle> Advances in Computing Research, </booktitle> <volume> volume 4. </volume> <publisher> JAI Press, </publisher> <year> 1987. </year>
Reference-contexts: In an asynchronous setting, it has long been known that if an adversary can halt a single process, then no deterministic consensus algorithm is possible without the use of powerful synchronization primitives <ref> [CIL87, DDS87, FLP85, Her91, LAA87] </ref>. In contrast, randomized algorithms can solve consensus in a shared-memory system for n processes even if the adversary can halt up to n 1 processes.
Reference: [LLS89] <author> D. Lichtenstein, N. Linial, and M. Saks. </author> <title> Some extremal problems arising from discrete control processes. </title> <journal> Combinatorica, </journal> <volume> 9, </volume> <year> 1989. </year>
Reference-contexts: With a restriction to fair coins, Harper's isoperimetric inequality for the hypercube [Har66] implies that the majority function gives the least power to an off-line adversary that can see all coins before deciding which to change; and Lichtenstein, Linial, and Saks <ref> [LLS89] </ref> have shown that majority is also optimal against an on-line adversary similar to the one we consider here.
Reference: [Sak89] <author> Michael Saks. </author> <title> A robust non-cryptographic protocol for collective coin flipping. </title> <journal> SIAM Journal on Discrete Mathematics, </journal> <volume> 2(2) </volume> <pages> 240-244, </pages> <year> 1989. </year>
Reference-contexts: Many such games assume that the locations of faulty coins are fixed in advance; under these assumptions very efficient games exist <ref> [AN90, CL93, BOL85, Sak89] </ref>.
Reference: [SSW91] <author> Michael Saks, Nir Shavit, and Heather Woll. </author> <title> Optimal time randomized consensus | making resilient algorithms fast in practice. </title> <booktitle> In Proceedings of the Second Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 351-362, </pages> <year> 1991. </year>
Reference-contexts: The first known algorithm that solves shared-memory consensus against an adaptive adversary is the exponential-time algorithm of Abrahamson [Abr88]; since its appearance, numerous polynomial-time algorithms have appeared <ref> [AH90, ADS89, SSW91, Asp93, DHPW92, BR90, BR91, AW96] </ref>. Most of these algorithms are built around shared coin protocols in which the processes individually generate many random 1 local coin flips, which are combined by majority voting. <p> In the algorithm of Aspnes [Asp93], some votes are generated deterministically. In the algorithm of Saks, Shavit, and Woll <ref> [SSW91] </ref>, several coin-flipping protocols optimized for different execution patterns are run in parallel. In the algorithm of Aspnes and Waarts [AW96], processes that have already cast many votes generate votes with increasing weights in order to finish the protocol quickly. <p> Restrictions on the amount of asynchrony can also have a large effect <ref> [AAT94, SSW91] </ref>. 5 Acknowledgments The author is indebted to Russell Impagliazzo for many fruitful discussions of coin-flipping problems, Steven Rudich for a suggestion that eventually became the truncation argument used to prove Theorem 5, Mike Saks for encouragement and pointers to related work, and Faith Fich, Wai-Kau Lo, Eric Ruppert, and
Reference: [Vaz85] <author> Umesh Vazirani. </author> <title> Towards a strong communication complexity theory, or generating quasi-random sequences from two communicating slightly-random sources. </title> <booktitle> In Proceedings of the Twenty-Ninth Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 366-378. </pages> <publisher> ACM, </publisher> <year> 1985. </year>
Reference-contexts: Another assumption that greatly limits the power of the adversary is to require that both the locations and values of faulty coins are fixed in advance; this is the bit extraction problem <ref> [CFG + 85, Fri92, Vaz85] </ref>, in which it is possible to derive completely unbiased random bits. If none of these limiting assumptions are made, the adversary gains considerably more power.
References-found: 29

