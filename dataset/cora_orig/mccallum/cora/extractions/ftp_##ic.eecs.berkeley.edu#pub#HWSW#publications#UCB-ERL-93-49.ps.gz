URL: ftp://ic.eecs.berkeley.edu/pub/HWSW/publications/UCB-ERL-93-49.ps.gz
Refering-URL: http://www-cad.eecs.berkeley.edu/research/hsc/publications.html
Root-URL: 
Title: Synthesis of Mixed Software-Hardware Implementations from CFSM Specifications  
Author: Massimiliano Chiodo, Paolo Giusto, Harry Hsieh, Attila Jurecska, Luciano Lavagno, Alberto Sangiovanni-Vincentelli 
Date: June 1, 1993  
Abstract: Embedded controllers for reactive real-time applications are implemented as mixed software-hardware systems. In [CLJ + 93], a formal specification model called Co-design Finite State Machine (CFSM) is introduced. In this paper we present a methodology for partitioning and automatic synthesis of software-hardware systems specified with CFSMs. CFSM networks are partitioned into software and hardware domains. Interfaces between hardware and/or software partitions are defined. An implementation of the entire system is automatically generated and optimization techniques are applied to both software and hardware. To reduce the complexity of the design and the representation, library modules can be predefined and reused. An example from the automotive industry is used to demonstrate the method. 
Abstract-found: 1
Intro-found: 1
Reference: [ACD90] <author> R. Alur, C. Courcoubetis, and D. Dill. </author> <title> Model-Checking for Real-Time Systems. </title> <booktitle> In Proceedings of the Fifth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 414-425, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: The FSM specified by M 0 can be used as an input to a formal verification algorithm. The composition with timing descriptors is not different from what Alur et al. proposed <ref> [ACD90] </ref>. A non-trivial problem is how to derive the timing descriptor of a transformation. The information needed must be provided by the synthesis process. This is trivial for hardware, in which there is always a 1-clock delay.
Reference: [ACH + 92] <author> R. Alur, C. Courcoubetis, N. Halbwachs, D. Dill, and H. Wong-Toi. </author> <title> Minimization of timed transition systems. </title> <booktitle> Proceedings of CONCUR, </booktitle> <year> 1992. </year>
Reference-contexts: For our seat belt example, we want to figure out if, according to our description, the seat belt will never start buzzing from 15 seconds after the key has been turned on. In TCTL <ref> [ACH + 92] </ref> notation, this becomes: AG (KEY ON ! AF (&gt;15)s (AG :ALARM ON )) where AF (&gt;15)s f means for every path, there exists a state on the path at which f holds after 15 seconds.
Reference: [Bak93] <author> W. Baker. </author> <title> Application of the synchronous/reactive model to the VHDL language. </title> <type> Technical report, </type> <institution> U.C. Berkeley, </institution> <year> 1993. </year>
Reference: [BAPM83] <author> M. Ben-Ari, A. Pneuli, and Z. Manna. </author> <title> The temporal logic of branching time. </title> <journal> Acta Inf., </journal> (20):207-226, 1983. 
Reference-contexts: These are two essential properties of every sound concurrent software system as explained in <ref> [BAPM83] </ref>. We consider each CFSM as a software concurrent process or task . A task is acyclic, without iteration. Each time it is activated it performs at most one (possibly none if no triggering event is present) transition of the CFSM.
Reference: [BCG91] <author> G. Berry, P. Corunne, and G. Gonthier. </author> <title> The synchronous approach to reactive and real-time systems. </title> <journal> IEEE Proceedings, </journal> <volume> 79, </volume> <month> September </month> <year> 1991. </year>
Reference: [BCH + 91] <author> R.K. Brayton, M. Chiodo, R. Hojati, T. Kam, K. Kodandapani, R.P. Kurshan, S. Ma-lik, A.L. Sangiovanni-Vincentelli, E.M. Sentovich, T. Shiple, and H.Y. Wang. </author> <title> BLIF-MV:an interchange format for design verification and synthesis. </title> <type> Technical Report UCB/ERL M91/97, </type> <institution> U.C. Berkeley, </institution> <month> November </month> <year> 1991. </year>
Reference: [BCMD90] <author> J. Burch, E. Clarke, K. McMillan, and D. Dill. </author> <title> Sequential circuit verification using symbolic model checking. </title> <booktitle> Proceedings of the Design Automation Conference, </booktitle> <pages> pages 46-51, </pages> <year> 1990. </year>
Reference-contexts: An example of verification is to verify that a given sequence of transitions , an undesirable behavior, is not consistent with M . If 6 M , then 6 I, since I M . We can use CTL formula <ref> [BCMD90] </ref> to express properties. To cast this model checking problem into a language containment problem, we will only need to convert the CTL formula into a task automata.
Reference: [Bor88] <author> G. Borriello. </author> <title> A New Interface Specification Methodology and its Application to Transducer Synthesis. </title> <type> PhD thesis, </type> <institution> U.C. Berkeley, </institution> <month> May </month> <year> 1988. </year> <note> (technical report UCB/CSD 88/430). </note>
Reference-contexts: Because of the different nature of implementation domains, conceptually we can think of an interface mechanism as a three-layer block (see figure 7.) This idea is expressed more formally by Borriello in <ref> [Bor88] </ref>. Within the sender's domain, block A translates the event into the representation of the channel's domain. Block B within the channel domain actually gets the event across. Block C transforms the event into the sender's representation. In practice, interfaces can come in the form of cooperating mixed hardware-software solutions.
Reference: [BSV92] <author> F. Balarin and A. Sangiovanni-Vincentelli. </author> <title> A verification strategy for timing-constrained systems. </title> <booktitle> Proceedings of the Fourth Workshop on Computer-Aided Verification, </booktitle> <pages> pages 148-163, </pages> <year> 1992. </year>
Reference-contexts: Reduction techniques are being proposed to cope with this problem. Automatic techniques have been proposed to reduce the complexity of CTL model checking <ref> [CSSVB92, BSV92] </ref>. Non-automatic techniques that make use of abstraction, like the one proposed by Kurshan [Kur90] to verify !-regular properties and the one proposed by Grumberg et al [DLG92] to perform model checking using the restricted temporal logic CTL*, seem powerful. However, their effectiveness depends heavily on the designer's ingenuity. <p> Immediately we see a state-explosion problem. As an experiment, we formulate this seat belt design into a network of N F as in [CLJ + 93]. We then use iterative method for quantitative real-time verification as proposed in <ref> [BSV92] </ref> to verify the property "Alarm will not be on forever" as described earlier. The verification is allowed to run overnight on a DEC Alpha machine and only intermediate result is obtained. The size of the representation simply grows too large for the verification algorithm to reach its conclusion.
Reference: [Bur92] <author> J. R. Burch. </author> <title> Automatic Symbolic Verification of Real-Time Concurrent Systems. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: We use a discrete model of time, where each CFSM takes a non-zero unbounded time to perform its task (at least before an implementation is chosen). This model is quite realistic for synchronous systems and lends itself to efficient formal verification techniques (e.g. [Kur90], <ref> [Bur92] </ref>). Events directly implement a synchronous protocol ([CKN86]) between communicating partners. The receiver waits for the sender to emit the event (which is essential to avoid reading the wrong information), but the sender can proceed after emitting the event without the need to wait.
Reference: [CBG + 92] <author> E. Clarke, J. Burch, O. Grumberg, D. Long, and K. McMillan. </author> <title> Automatic verification of sequentila circuit designs. </title> <journal> Phil. Transaction, Royal Society of London., </journal> <volume> A(339):105-120, </volume> <year> 1992. </year>
Reference-contexts: Path is defined as a sequence of states and is used to represent possible behavior or computations of the transition system <ref> [CBG + 92] </ref>. This CTL formula literally describes the behavior, "It is always true that ALARM ON is true implies that for all path there exists a state where ALARM OFF is true." Note that the property is expressed in terms of paths and states of an FSM.
Reference: [CDHWT92] <author> C. Courcoubetis, D. Dill, N. Halbwachs, and H. Wong-Toi. </author> <title> An implementation of three algorithms for timing verification based on automata emptiness. </title> <booktitle> IEEE Real-Time Systems Symposium, </booktitle> <year> 1992. </year>
Reference-contexts: The size of the representation simply grows too large for the verification algorithm to reach its conclusion. Before the algorithm is terminated, BDD node count have grown in excess of 180,000. Other reduction techniques are being investigated to reduce the complexity of real-time model checking, as discussed in <ref> [Kur90, CDHWT92, HNSY92] </ref>. 8.2 Simulation Simulation should be used whenever the complexity of the system makes formal verification infeasible. Since the system is inherently discrete, the number of distinct traces of the system with bounded delay given by timing descriptors will be finite.
Reference: [CKN86] <author> D. Del Corso, H. Kirkman, and J. D. Nicoud. </author> <title> Microcomputer buses and links. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1986. </year>
Reference: [CLJ + 93] <author> M. Chiodo, L. Lavagno, A. Jurecska, P. Giusto, H. Hsieh, and A. Sangiovanni-Vincentelli. </author> <title> A formal model and methodology for hardware/software co-design. </title> <type> Technical report, </type> <institution> U.C. Berkeley, </institution> <year> 1993. </year> <month> 63 </month>
Reference-contexts: Designers today seem more concerned with "getting something done" as soon as possible regardless of whether this something is what they really want. To address the points listed above, we propose to use a non-committed behavioral internal representation based on Co-Design Finite State Machines, or CFSMs <ref> [CLJ + 93] </ref>. By a synthesis point of view, the most desirable characteristic of CFSMs is that they can model a significant class of both hardware circuits and software programs. <p> The paper is organized as follows: Section 2 recall the CFSM theory thoroughly introduced in <ref> [CLJ + 93] </ref>, Section 3 describes the technique used to partition a system design, Section 4 describes the algorithms used to synthesize the hardware and software implementations, Section 5 describes how we handle system complexity, Section 6 describes how heterogeneous implementation domains are interfaced, Section 7 discusses the issue of software <p> interfaced, Section 7 discusses the issue of software optimization, Section 8 discusses the issue of system validation, Section 9 shows an example of automated synthesis of a system from the automotive industry, and finally Section 10 draws some conclusions and outlines future developments of the project. 6 2 Background In <ref> [CLJ + 93] </ref>, we thoroughly introduced the theoretical foundation of our approach to Hardware-software Co-Design. Here, we briefly recall the main points. The basic observable entities that define the behavior of the system that we want to model are events. <p> We only force all the output events for a transition to be emitted if one of them is emitted. However, fairness is imposed to the type of software implementation we propose through the use of a fair software scheduler. As explained in <ref> [CLJ + 93] </ref>, we need to map CFSMs into FSMs for synthesis and validation. <p> For each output signal there a FSM somewhat similar to those used for input signals that governs the transmission of the output signal pairs of F to the external world. Notice that, the output FSM being a Moore machine, the whole network N F is a Moore machine. In <ref> [CLJ + 93] </ref>, we have shown formally the behavioral equivalence between a CFSM network and an FSM network. This interpretation of a CFSM network N C as an FSM network N F is extremely useful for synthesis. <p> A complete specification of the SHIFT language has been given in <ref> [CLJ + 93] </ref>. Figure 3 shows how the simple seat belt example described in Figure 2 and Example 2 can be specified using SHIFT. The example shows how the SHIFT specification of a system is organized into a three-layer hierarchy. <p> As explained in <ref> [CLJ + 93] </ref>, this is necessary to transform the reactive syntax of CFSMs into the purely synchronous syntax of BLIF-MV. In the case of hardware synthesis the modeling of delay is very simple. Events are sensed immediately and reacted within the minimum delay. <p> In order to make sure that we synthesize correct implementation we require .names tables to be deterministic. Non-determinism which is allowed in our methodology at the specification level <ref> [CLJ + 93] </ref> must be resolved by the designer before the synthesis step. A .names table is non-deterministic if given two rows with the same input part, there exists at least a variable (either trigger event or data value) such that the correspondent values are different. <p> The former, sometime called implementation verification, is accomplished by construction in <ref> [CLJ + 93] </ref> for implementations of CFSM specifications. The latter can be divided into specification verification and design verification. Specification verification is done when the property to be validated is implementation-independent. Design verification is done when implementation-dependent parameters are used. These tasks are performed mostly by prototyping and simulation. <p> If the properties are expressed as statements in a logic language, such as Computation Tree Logic (CTL)[EC82], then the verification problem is called model checking. The first step in formal verification is to define a time model of the system. In <ref> [CLJ + 93] </ref>, the behavior in time of a SHIFT specification is formally defined. A CFSM C is represented by the corresponding FSM network N F which is composed of a "main" completely specified FSM F , input FSMs, and output FSMs. <p> Immediately we see a state-explosion problem. As an experiment, we formulate this seat belt design into a network of N F as in <ref> [CLJ + 93] </ref>. We then use iterative method for quantitative real-time verification as proposed in [BSV92] to verify the property "Alarm will not be on forever" as described earlier. The verification is allowed to run overnight on a DEC Alpha machine and only intermediate result is obtained. <p> This methodology satisfies the fundamental requirements outlined in Section 1: 1. Natural specification. Our methodology utilizes a formal specification model called CFSM, that is well suited to model control-dominated systems <ref> [CLJ + 93] </ref>. 2. Easy partitioning. Since both hardware and software have the same CFSM representation at the specification level, we do not have to commit ourselves to a particular mix of software-hardware implementation. In Section 3, we defined the interfaces that are necessary for communication between partitions. <p> We also outlined a method for software synthesis of CFSMs using simple if-then-else construct. A simple "fair" scheduler is also discussed. 4. Optimization. We have shown a software optimization technique for reducing the code size. 5. Validation. The FSM model derived from CFSM <ref> [CLJ + 93] </ref> is compatible with input format of many formal verification algorithms. We have shown how a simple hardware-software system can be modeled and how a simple property may be verified with a particular verification algorithm.
Reference: [CLM91] <author> E. M. Clarke, D. E. Long, and K. L. McMillan. </author> <title> A language for compositional specifi-cation and verification of finite state hardware controllers. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9), </volume> <month> September </month> <year> 1991. </year>
Reference: [CSSVB92] <author> M. Chiodo, T. Shiple, A. Sangiovanni-Vincentelli, and R. Brayton. </author> <title> Automatic reduction in CTL compositional model checking. </title> <booktitle> Proceedings of the Fourth Workshop on Computer-Aided Verification, </booktitle> <pages> pages 225-238, </pages> <year> 1992. </year>
Reference-contexts: Reduction techniques are being proposed to cope with this problem. Automatic techniques have been proposed to reduce the complexity of CTL model checking <ref> [CSSVB92, BSV92] </ref>. Non-automatic techniques that make use of abstraction, like the one proposed by Kurshan [Kur90] to verify !-regular properties and the one proposed by Grumberg et al [DLG92] to perform model checking using the restricted temporal logic CTL*, seem powerful. However, their effectiveness depends heavily on the designer's ingenuity.
Reference: [CSV92] <author> M. Chiodo and A. Sangiovanni-Vincentelli. </author> <title> Design methods for reactive real-time system co-design. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> September </month> <year> 1992. </year>
Reference-contexts: Since timing requirements may not be met by the software, part of the design has to be implemented in hardware. As pointed out in <ref> [CSV92] </ref>, mixed Hardware-Software systems design is still in its infancy as a recognized discipline, although it has been common practice in industrial systems design for decades. <p> Therefore, they can be used as a representation 2 of a system's behavior rather than of a circuit's or a program's. The main points of our approach, which has been introduced in <ref> [CSV92] </ref>, are: 1. An array of formal languages, each of which is mapped into a neutral FSM based Intermediate Format (IF), is used to specify different parts of a system. 2. The IF represents a network of CFSMs and is organized in a way that makes partitioning easy. 3. <p> However, their effectiveness depends heavily on the designer's ingenuity. For a complete example of qualitative real-time formal verification within our methodology, see <ref> [CSV92] </ref>. Implementation-dependent design verification is very important if all or parts of the system have been through the entire design process. It should be clear that the behavior of M is an abstraction of the real time behavior of a system.
Reference: [DH89] <author> D. Druzinski and D. Hare. </author> <title> Using statecharts for hardware description and synthesis. </title> <journal> IEEE Transacions on Computer-Aided Design, </journal> <volume> 8(7), </volume> <month> July </month> <year> 1989. </year>
Reference: [DLG92] <author> H. De-Leon and Orna Grumberg. </author> <title> Modular abstractions for verifying real-time distributed systems. </title> <booktitle> Proceedings of the Fourth Workshop on Computer-Aided Verification, </booktitle> <pages> pages 3-17, </pages> <year> 1992. </year>
Reference-contexts: Automatic techniques have been proposed to reduce the complexity of CTL model checking [CSSVB92, BSV92]. Non-automatic techniques that make use of abstraction, like the one proposed by Kurshan [Kur90] to verify !-regular properties and the one proposed by Grumberg et al <ref> [DLG92] </ref> to perform model checking using the restricted temporal logic CTL*, seem powerful. However, their effectiveness depends heavily on the designer's ingenuity. For a complete example of qualitative real-time formal verification within our methodology, see [CSV92].
Reference: [DMNSV88] <author> S. Devadas, H-K. T. Ma, A. R. Newton, and A. Sangiovanni-Vincentelli. MUSTANG: </author> <title> State Assignment of Finite State Machines Targeting Multi-Level Logic Implementations. </title> <booktitle> In IEEE Transactions on Computer-Aided Design, </booktitle> <pages> pages 1290-1300, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: Currently, we have developed a BLIF-MV to BLIF translator that accepts only deterministic BLIF-MV descriptions and applies the "natural" encoding implied by interpreting each value in a .mv &lt;name&gt; &lt;val 1&gt; ... &lt;val n&gt; statement as an integer. Programs such as NOVA [Vil86], MUSTANG <ref> [DMNSV88] </ref> or JEDI [LN89] can be used (via sis) to do the encoding so that the logic implementing the FSM is minimized. As a further optimization, we can also use multiplexer and bus allocation techniques from high-level synthesis to minimize the consumption of expensive inter-partition communication resources (i.e. <p> In principle, a multi-valued mapping associating each symbolic value with its successor could have been defined, thus implying the use of a symbol encoding program (such as, e.g., NOVA [Vil86], MUSTANG <ref> [DMNSV88] </ref> or JEDI [LN89]). Using encoding/decoding and a binary adder correspond to an optimized hand implementation of the very same behavior. In "life-size" design, it is unpractical to list explicitly encodings in a BLIF-MV file.
Reference: [EC82] <author> E. A. Emerson and E. M. Clarke. </author> <title> Using branching-time temporal logic to syntehsisze synchronization skeletons. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 2(3) </volume> <pages> 241-266, </pages> <year> 1982. </year>
Reference: [EH92] <author> R. Ernst and J. Henkel. </author> <title> Hardware-software codesign of embedded controllers based on hardware extraction. </title> <booktitle> In Proceedings of the International Workshop on Hardware-Software Codesign, </booktitle> <month> September </month> <year> 1992. </year>
Reference: [FGet al.86] <author> A. Fuggetta, C. Ghezzi, and et al.. </author> <title> Formal data flow diagrams. </title> <journal> IEEE Transaction of Software Engineering, </journal> <year> 1986. </year>
Reference: [GJM92] <author> R. K. Gupta, C. N. Coelho Jr., and G. De Micheli. </author> <title> System-level synthesis using re-programmable components. </title> <booktitle> In Proceedings of the European Design Automation Conference (EDAC), </booktitle> <pages> pages 2-7, </pages> <month> March </month> <year> 1992. </year>
Reference: [HK87] <author> Z. Har'El and R. Kurshan. </author> <title> Cospan user's guide. </title> <journal> AT&T, </journal> <month> October </month> <year> 1987. </year>
Reference-contexts: This is due to two main causes: 1) Result is related to the way in which properties are expressed and system described. 2) Computational complexity. In fact, the possibility of an explosion in the size of the internal representation in a formal verification tool such as COSPAN <ref> [HK87] </ref> is a major obstacle to the extensive application of formal verification techniques to real industrial designs. Reduction techniques are being proposed to cope with this problem. Automatic techniques have been proposed to reduce the complexity of CTL model checking [CSSVB92, BSV92].
Reference: [HNSY92] <author> T. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> Symbolic model checking for real-time systems. </title> <type> Technical Report, </type> <institution> Cornell University, </institution> <year> 1992. </year>
Reference-contexts: The size of the representation simply grows too large for the verification algorithm to reach its conclusion. Before the algorithm is terminated, BDD node count have grown in excess of 180,000. Other reduction techniques are being investigated to reduce the complexity of real-time model checking, as discussed in <ref> [Kur90, CDHWT92, HNSY92] </ref>. 8.2 Simulation Simulation should be used whenever the complexity of the system makes formal verification infeasible. Since the system is inherently discrete, the number of distinct traces of the system with bounded delay given by timing descriptors will be finite.
Reference: [Kur90] <author> R. P. Kurshan. </author> <title> Analysis of discrete event coordination. </title> <booktitle> In Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We use a discrete model of time, where each CFSM takes a non-zero unbounded time to perform its task (at least before an implementation is chosen). This model is quite realistic for synchronous systems and lends itself to efficient formal verification techniques (e.g. <ref> [Kur90] </ref>, [Bur92]). Events directly implement a synchronous protocol ([CKN86]) between communicating partners. The receiver waits for the sender to emit the event (which is essential to avoid reading the wrong information), but the sender can proceed after emitting the event without the need to wait. <p> A CFSM C is represented by the corresponding FSM network N F which is composed of a "main" completely specified FSM F , input FSMs, and output FSMs. The behavior specified by N F is an abstracted specification of the system's real behavior in the sense of Kurshan <ref> [Kur90] </ref>. The non-determinism in the input and output FSMs reflects unbounded delay. For the network of CFSMs N C , there is a corresponding model M of network of N F Any implementation I of N C is contained in M , or I M . <p> Reduction techniques are being proposed to cope with this problem. Automatic techniques have been proposed to reduce the complexity of CTL model checking [CSSVB92, BSV92]. Non-automatic techniques that make use of abstraction, like the one proposed by Kurshan <ref> [Kur90] </ref> to verify !-regular properties and the one proposed by Grumberg et al [DLG92] to perform model checking using the restricted temporal logic CTL*, seem powerful. However, their effectiveness depends heavily on the designer's ingenuity. For a complete example of qualitative real-time formal verification within our methodology, see [CSV92]. <p> That is, using transition relations, we can build a M 0 = M T where T restricts the non-determinism of M <ref> [Kur90] </ref>. The FSM specified by M 0 can be used as an input to a formal verification algorithm. The composition with timing descriptors is not different from what Alur et al. proposed [ACD90]. A non-trivial problem is how to derive the timing descriptor of a transformation. <p> The size of the representation simply grows too large for the verification algorithm to reach its conclusion. Before the algorithm is terminated, BDD node count have grown in excess of 180,000. Other reduction techniques are being investigated to reduce the complexity of real-time model checking, as discussed in <ref> [Kur90, CDHWT92, HNSY92] </ref>. 8.2 Simulation Simulation should be used whenever the complexity of the system makes formal verification infeasible. Since the system is inherently discrete, the number of distinct traces of the system with bounded delay given by timing descriptors will be finite.
Reference: [LN89] <author> B. Lin and A. R. </author> <title> Newton. Synthesis of multiple level logic from symbolic high-level description languages. </title> <booktitle> In Proceedings of the International Conference on Very Large Scale Integration, </booktitle> <year> 1989. </year>
Reference-contexts: Currently, we have developed a BLIF-MV to BLIF translator that accepts only deterministic BLIF-MV descriptions and applies the "natural" encoding implied by interpreting each value in a .mv &lt;name&gt; &lt;val 1&gt; ... &lt;val n&gt; statement as an integer. Programs such as NOVA [Vil86], MUSTANG [DMNSV88] or JEDI <ref> [LN89] </ref> can be used (via sis) to do the encoding so that the logic implementing the FSM is minimized. As a further optimization, we can also use multiplexer and bus allocation techniques from high-level synthesis to minimize the consumption of expensive inter-partition communication resources (i.e. <p> In principle, a multi-valued mapping associating each symbolic value with its successor could have been defined, thus implying the use of a symbol encoding program (such as, e.g., NOVA [Vil86], MUSTANG [DMNSV88] or JEDI <ref> [LN89] </ref>). Using encoding/decoding and a binary adder correspond to an optimized hand implementation of the very same behavior. In "life-size" design, it is unpractical to list explicitly encodings in a BLIF-MV file.
Reference: [PM85] <author> P.T.Ward and Mellor. </author> <title> Structured development for Real-Time Systems. </title> <publisher> Yourdon Press, </publisher> <year> 1985. </year>
Reference: [RSV87] <author> R. Rudell and A. Sangiovanni-Vincentelli. </author> <title> Multiple-valued minimization for PLA optimization. </title> <journal> IEEE Transactions on Computer-Aided Design, </journal> <month> September </month> <year> 1987. </year>
Reference: [SSL + 92] <author> E. M. Sentovich, K. J. Singh, L. Lavagno, C. Moon, R. Murgai, A. Saldanha, H. Savoj, P. R. Stephan, R. K. Brayton, and A. Sangiovanni-Vincentelli. </author> <title> SIS: A system for sequential circuit synthesis. </title> <type> Technical Report UCB/ERL M92/41, </type> <institution> U.C. Berkeley, </institution> <month> May </month> <year> 1992. </year>
Reference: [SSM + 92] <author> E.M. Sentovich, K.J. Singh, C. Moon, H. Savoj, R.K. Brayton, and A.L. Sangiovanni-Vincentelli. </author> <title> Sequential circuit design using synthesis and optimization. </title> <booktitle> In Proceedings of the International Conference on Computer Design, </booktitle> <month> October </month> <year> 1992. </year>
Reference: [Vil86] <author> T. Villa. </author> <title> Constrained encoding in hypercubes: Applications to state assignment. </title> <editor> In U. C. </editor> <address> Berkeley, </address> <note> ERL Memo 86/44, </note> <month> May </month> <year> 1986. </year> <month> 65 </month>
Reference-contexts: Currently, we have developed a BLIF-MV to BLIF translator that accepts only deterministic BLIF-MV descriptions and applies the "natural" encoding implied by interpreting each value in a .mv &lt;name&gt; &lt;val 1&gt; ... &lt;val n&gt; statement as an integer. Programs such as NOVA <ref> [Vil86] </ref>, MUSTANG [DMNSV88] or JEDI [LN89] can be used (via sis) to do the encoding so that the logic implementing the FSM is minimized. As a further optimization, we can also use multiplexer and bus allocation techniques from high-level synthesis to minimize the consumption of expensive inter-partition communication resources (i.e. <p> In principle, a multi-valued mapping associating each symbolic value with its successor could have been defined, thus implying the use of a symbol encoding program (such as, e.g., NOVA <ref> [Vil86] </ref>, MUSTANG [DMNSV88] or JEDI [LN89]). Using encoding/decoding and a binary adder correspond to an optimized hand implementation of the very same behavior. In "life-size" design, it is unpractical to list explicitly encodings in a BLIF-MV file.
References-found: 33

