URL: file://ftp.irisa.fr/local/lande/vgdlm-ISySe97.ps.gz
Refering-URL: http://www.irisa.fr/lande/LeMetayer.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: gouranton@irisa.fr, lemetayer@irisa.fr  
Title: Formal development of static program analysers  
Author: Valerie Gouranton and Daniel Le Metayer IRISA/INRIA 
Address: 35042 Rennes Cedex, France  
Affiliation: Campus de Beaulieu,  
Abstract: We propose an approach for the formal development of static analysers which is based on transformations of inference systems. The specification of an analyser is made of two components: an operational semantics of the programming language and the definition of a property by recurrence on the proof trees of the operational semantics. The derivation is a succession of specialisations of inference systems with respect to properties on their proof trees. In this paper, we illustrate the methodology with the derivation of analysers for a non strict functional language. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Cleaveland, E. Madelaine, and S. Sims. </author> <title> A front-end generator for verification tools. In Tools and Algorithms for the Construction ans Analysis of Systems, </title> <booktitle> TACAS'95, number 1019 in Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Most program analyses in the past were based on either low-level operational semantics [2] or denotational semantics [9], but the use of SOS as a basis for the design of anal-ysers has been advocated by several researchers recently <ref> [1, 8, 12, 13] </ref>. Generic frameworks for program analysis have been proposed in the context of logic programming languages [7] and data flow analysis [16, 17].
Reference: [2] <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Fourth annual ACM Symposium on Principles of Programming Languages, POPL'77, </booktitle> <pages> pages 238252, </pages> <address> Los Angeles, California, </address> <month> Jan. </month> <year> 1977. </year>
Reference-contexts: The theory of abstract interpretation <ref> [2] </ref> provides a strong formal basis for static program analysis. It has been extensively studied and applied to various styles of language semantics. The work described here does not provide an alternative formal underpinning for program analysis. <p> The correctness of the resulting analysis, which is guaranteed by construction here, could alternatively be rephrased in the abstract interpretation framework [13]. Most program analyses in the past were based on either low-level operational semantics <ref> [2] </ref> or denotational semantics [9], but the use of SOS as a basis for the design of anal-ysers has been advocated by several researchers recently [1, 8, 12, 13].
Reference: [3] <author> P. Cousot and R. Cousot. </author> <title> Inductive definitions semantics and abstract interpretation. </title> <booktitle> In Nineteenth annual ACM Symposium on Principles of Programming Languages, POPL'92, </booktitle> <pages> pages 8394, </pages> <address> Albuquerque, New Mexico, </address> <month> Jan. </month> <year> 1992. </year>
Reference-contexts: Extension of SOS (based on positive and negative inductive definitions) have been proposed <ref> [3] </ref> which make it possible to reason in a uni form way on finite and infinite behaviours. * The approach should be supported by a semiautomatic tool for the design of program analysers.
Reference: [4] <author> V. Gouranton. </author> <title> Derivation of static analysers by folding/unfolding of operational specifications. </title> <type> PhD thesis, </type> <institution> Rennes, France, </institution> <note> to appear. </note>
Reference-contexts: For the sake of conciseness, we have focussed on analyses of functional programs here, but we have experimented the approach on various other properties and programming languages (groundness for logic programming, live variable analysis for imperative languages, single-threading for functional languages, . . . ) <ref> [4] </ref>. There are three main directions in which the work described here is currently being be extended: * The SOS considered so far are big-steps (or natural) semantics [10]. Small-step SOS are more precise and they are required for a proper treatment of non-determinism, non-termination and parallelism. <p> To this aim, we are currently working on the application of the well known fold/unfold technique (traditionally studied in the context of pure functional programs) to inference systems defined as relations <ref> [4] </ref>.
Reference: [5] <author> V. Gouranton and D. Le Metayer. </author> <title> Derivation of static anal-ysers of functional programs from path properties of a natural semantics. </title> <type> Technical Report 2607, </type> <institution> INRIA, Domaine de Voluceau, Rocquencourt, </institution> <address> BP 105, 78153 Le chesnay Cedex FRANCE, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: The interested reader can find them in <ref> [5] </ref>. We should stress the fact that the variable names used in the definition of functions are entirely irrelevant because variables are systematically renamed by ff-conversion in the semantics of the language.
Reference: [6] <author> C. Hankin and D. Le Metayer. </author> <title> Deriving algorithms from types inference systems: Application to strictness analysis. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <address> POPL'94, pages 202212, Portland, Oregon, USA, </address> <month> Jan. </month> <year> 1994. </year>
Reference-contexts: Inference algorithms In order to derive inference algorithms from the inference systems presented in the previous sections, we can rely on lazy type inference technique. Lazy type inference was first introduced in <ref> [6] </ref> and it has proved to be an appropriate basis for the design of efficient analysers. A lazy type inference algorithm works in a bottom-up (or backwards) mode, starting with an initial query of the form [; e; ] (when trying to prove ` p e : ). <p> We do not dwell on the lazy type inference algorithm in this paper because it is a direct application of previous results. The interested reader can find a more detailed presentation of lazy types in <ref> [6] </ref>. 7. Conclusion The distinctive feature of the work presented here is the inference system derivation approach for the formal development of static analysers.
Reference: [7] <author> B. Le Charlier, K. Musumbu, and P. Van Hentenryck. </author> <title> A generic interpretation algorithm and its complexity analysis. </title> <editor> In koichi Furukawa, editor, </editor> <booktitle> Proceedings of the eight International Conference on Logic Programming, </booktitle> <pages> pages 6478, </pages> <year> 1991. </year>
Reference-contexts: Generic frameworks for program analysis have been proposed in the context of logic programming languages <ref> [7] </ref> and data flow analysis [16, 17]. They rely on abstract interpretations of denotational semantics ([7, 16]) or interpreters ([17]) and genericity is achieved by parameterising the abstract domains and choosing appropriate abstract functions. The implementation details of the analysis algorithm can be factorised.
Reference: [8] <author> D. Le Metayer and D. Schmidt. </author> <title> Structural operational semantics as a basis for static program analysis. </title> <journal> In ACM Computing Surveys, </journal> <volume> volume 28, </volume> <pages> pages 340343, </pages> <year> 1996. </year>
Reference-contexts: introduction to programming language semantics in [10, 14] and a more detailed argument in favour of the use of SOS for static analysis in <ref> [8] </ref>. As far as the property of interest is concerned, we suggest a two level specification : 1. First, an abstraction function A is defined, which extracts from the proof trees of the SOS the pieces of information I r that are relevant for the analysis under consideration. <p> Most program analyses in the past were based on either low-level operational semantics [2] or denotational semantics [9], but the use of SOS as a basis for the design of anal-ysers has been advocated by several researchers recently <ref> [1, 8, 12, 13] </ref>. Generic frameworks for program analysis have been proposed in the context of logic programming languages [7] and data flow analysis [16, 17].
Reference: [9] <author> F. Nielson. </author> <title> A denotational framework for data flow analysis. </title> <journal> Acta Informatica, </journal> <volume> 18:265287, </volume> <year> 1982. </year>
Reference-contexts: The correctness of the resulting analysis, which is guaranteed by construction here, could alternatively be rephrased in the abstract interpretation framework [13]. Most program analyses in the past were based on either low-level operational semantics [2] or denotational semantics <ref> [9] </ref>, but the use of SOS as a basis for the design of anal-ysers has been advocated by several researchers recently [1, 8, 12, 13]. Generic frameworks for program analysis have been proposed in the context of logic programming languages [7] and data flow analysis [16, 17].
Reference: [10] <author> H. Nielson and F. Nielson, </author> <title> editors. Semantics With Applications. </title> <publisher> John Wiley & Sons, </publisher> <year> 1992. </year>
Reference-contexts: introduction to programming language semantics in <ref> [10, 14] </ref> and a more detailed argument in favour of the use of SOS for static analysis in [8]. As far as the property of interest is concerned, we suggest a two level specification : 1. <p> The interested reader can find a discussion on these two op tions in <ref> [10] </ref>. The methodology used to derive the analysers from their semantics is based on transformations of inference systems. The two main derivation stages are the following: * Stage 1: the inputs are the SOS of the language and the abstraction function A. <p> There are three main directions in which the work described here is currently being be extended: * The SOS considered so far are big-steps (or natural) semantics <ref> [10] </ref>. Small-step SOS are more precise and they are required for a proper treatment of non-determinism, non-termination and parallelism.
Reference: [11] <author> G. Plotkin. </author> <title> A structural approach of operational semantics. </title> <type> Technical Report FN-19, DAIMI, </type> <institution> Aarhus University, Den-mark, </institution> <year> 1981. </year>
Reference: [12] <author> S. Purushothaman and J. Seaman. </author> <title> From operational definitions to abstract semantics. </title> <booktitle> In Conference on Functional programming Languages and Computer Architecture, FPCA'93, </booktitle> <pages> pages 276285, </pages> <address> Copenhagen, Denmark, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Most program analyses in the past were based on either low-level operational semantics [2] or denotational semantics [9], but the use of SOS as a basis for the design of anal-ysers has been advocated by several researchers recently <ref> [1, 8, 12, 13] </ref>. Generic frameworks for program analysis have been proposed in the context of logic programming languages [7] and data flow analysis [16, 17].
Reference: [13] <author> D. Schmidt. </author> <title> Natural-semantics-based abstract interpretation. </title> <booktitle> In Second international Static Analysis Symposium, SAS'95, number 983 in Lecture Notes in Computer Science, </booktitle> <address> Glasgow, UK, Sept. 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Its goal is rather to put forward software engineering techniques to support the design of new analyses. The correctness of the resulting analysis, which is guaranteed by construction here, could alternatively be rephrased in the abstract interpretation framework <ref> [13] </ref>. Most program analyses in the past were based on either low-level operational semantics [2] or denotational semantics [9], but the use of SOS as a basis for the design of anal-ysers has been advocated by several researchers recently [1, 8, 12, 13]. <p> Most program analyses in the past were based on either low-level operational semantics [2] or denotational semantics [9], but the use of SOS as a basis for the design of anal-ysers has been advocated by several researchers recently <ref> [1, 8, 12, 13] </ref>. Generic frameworks for program analysis have been proposed in the context of logic programming languages [7] and data flow analysis [16, 17].
Reference: [14] <author> D. Schmidt. </author> <title> Programming language semantics. In CRC Handbook of Computer Science, </title> <editor> Allen Tucker, </editor> <publisher> ed CRC Press, </publisher> <address> Boca Raton, FL, </address> <note> in press. Abridged version, ACM Computing Surveys, </note> <year> 1996. </year>
Reference-contexts: introduction to programming language semantics in <ref> [10, 14] </ref> and a more detailed argument in favour of the use of SOS for static analysis in [8]. As far as the property of interest is concerned, we suggest a two level specification : 1.
Reference: [15] <author> B. Steffen. </author> <title> Generating data flow analysis algorithms from modal specifications. </title> <institution> Science of Computer Science, 21(2):115139, </institution> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Despite this difference of point of view, all these works are obviously inspired by the same goals. The framework introduced in <ref> [15] </ref> is closer to the spirit of the work presented in this paper but the technique itself is quite different. Programs are represented as models in a modal logic and a data flow analysis can be specified as a property in the logic.
Reference: [16] <author> G. Venkatesh. </author> <title> A framework for construction and evaluation of high-level specifications for program analysis techniques. </title> <booktitle> In SIGPLAN Conference on Programming Language Design and Implementation, PLDI'89, </booktitle> <volume> volume 24, </volume> <pages> pages 112, </pages> <address> Portland, Oregon, </address> <month> July </month> <year> 1989. </year>
Reference-contexts: Generic frameworks for program analysis have been proposed in the context of logic programming languages [7] and data flow analysis <ref> [16, 17] </ref>. They rely on abstract interpretations of denotational semantics ([7, 16]) or interpreters ([17]) and genericity is achieved by parameterising the abstract domains and choosing appropriate abstract functions. The implementation details of the analysis algorithm can be factorised.
Reference: [17] <author> K. Yi and W. Harrison III. </author> <title> Automatic generation and management of interprocedural program analyses. </title> <booktitle> In Twentieth Annual SIGPLAN-SIGACT Symposium on Principles of Programming Languages, POPL'93, </booktitle> <pages> pages 246259, </pages> <address> Charleston, South Carolina, </address> <month> Jan. </month> <year> 1993. </year>
Reference-contexts: Generic frameworks for program analysis have been proposed in the context of logic programming languages [7] and data flow analysis <ref> [16, 17] </ref>. They rely on abstract interpretations of denotational semantics ([7, 16]) or interpreters ([17]) and genericity is achieved by parameterising the abstract domains and choosing appropriate abstract functions. The implementation details of the analysis algorithm can be factorised.
References-found: 17

