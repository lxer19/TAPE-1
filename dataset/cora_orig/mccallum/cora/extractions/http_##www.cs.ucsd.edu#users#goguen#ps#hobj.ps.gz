URL: http://www.cs.ucsd.edu/users/goguen/ps/hobj.ps.gz
Refering-URL: http://www.cs.ucsd.edu/users/goguen/new.html
Root-URL: http://www.cs.ucsd.edu
Title: More Higher Order Programming in OBJ  
Author: Joseph A. Goguen and Grant Malcolm 
Affiliation: Dept. Computer Science Engineering, University of California at San Diego Programming Research Group, Oxford University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Su Feng, Toshiki Sakabe, and Yasuyoshi Inagaki. </author> <title> Mechanizing explicit inductive equational reasoning by DTRC. </title> <editor> In Kokichi Futatsugi, editor, </editor> <booktitle> Proceedings, Workshop on Tenth Anniversary of OBJ2, Itoh, </booktitle> <address> Japan, </address> <month> 21-22 October </month> <year> 1995. </year> <pages> Unisys, </pages> <year> 1995. </year>
Reference-contexts: It is interesting to notice that nesting parameterized modules in this way corresponds to a kind of dependent type [5]. 2 3 Recursive Definition over the Natural Numbers The example below was inspired by work of Feng, Sakabe and Inagaki <ref> [1] </ref> on their dynamic term rewriting calculus. We do not follow their code, but instead seek to accomplish the same objective in a way that is natural to OBJ3. <p> The "self-referential" use of NAT2 in the last module seems not to be mentioned in [8]. 3 4 Inductive Proof over the Natural Numbers The example in this section was also inspired by <ref> [1] </ref>. The objective in this case is to mechanize induction by encapsulating the structure of standard inductive proofs over the natural numbers into a reusable specification. The code below proves associativity of addition for natural numbers.
Reference: [2] <author> Kokichi Futatsugi and Toshimi Sawada. </author> <title> Design considerations for Cafe specification environment. </title> <editor> In Kokichi Futatsugi, editor, </editor> <booktitle> Proceedings, Workshop on Tenth Anniversary of OBJ2, Itoh, </booktitle> <address> Japan, </address> <month> 21-22 October </month> <year> 1995. </year> <pages> Unisys, </pages> <year> 1995. </year> <month> 8 </month>
Reference-contexts: The example below follows one suggested by Yatsu and Futatsugi [9] in connection with their design work on the CafeOBJ system <ref> [2] </ref>. The parameterized LIST object defines lists, with a comma syntax for concatenation. The theory FUN defines an interface requesting a (unary) function f between two possibly different sorts. Then MAP extends f to a function between lists of those sorts, parameterized by the sorts and the function.
Reference: [3] <author> Joseph Goguen. </author> <title> Principles of parameterized programming. </title> <editor> In Ted Biggerstaff and Alan Perlis, editors, </editor> <booktitle> Software Reusability, Volume I: Concepts and Models, </booktitle> <pages> pages 159-225. </pages> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction This paper discusses the use of OBJ3's parameterized modules for higher order programming, giving examples beyond those in <ref> [8, 3, 4] </ref> and showing some capabilities that may seem surprising. We also discuss parameterized views, which are not yet implemented, but which we hope soon will be.
Reference: [4] <author> Joseph Goguen. </author> <title> Higher-order functions considered unnecessary for higher-order programming. </title> <editor> In David Turner, editor, </editor> <booktitle> Research Topics in Functional Programming, </booktitle> <pages> pages 309-352. </pages> <publisher> Addison Wesley, </publisher> <year> 1990. </year> <note> University of Texas at Austin Year of Programming Series; preliminary version in SRI Technical Report SRI-CSL-88-1, </note> <month> January </month> <year> 1988. </year>
Reference-contexts: 1 Introduction This paper discusses the use of OBJ3's parameterized modules for higher order programming, giving examples beyond those in <ref> [8, 3, 4] </ref> and showing some capabilities that may seem surprising. We also discuss parameterized views, which are not yet implemented, but which we hope soon will be.
Reference: [5] <author> Joseph Goguen. </author> <title> Types as theories. </title> <editor> In George Michael Reed, Andrew William Roscoe, and Ralph F. Wachter, editors, </editor> <booktitle> Topology and Category Theory in Computer Science, </booktitle> <pages> pages 357-390. </pages> <address> Oxford, </address> <year> 1991. </year> <booktitle> Proceedings of a Conference held at Oxford, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: It would have been even more natural to have the two sorts in the body of FUN instead of as parameters. It is interesting to notice that nesting parameterized modules in this way corresponds to a kind of dependent type <ref> [5] </ref>. 2 3 Recursive Definition over the Natural Numbers The example below was inspired by work of Feng, Sakabe and Inagaki [1] on their dynamic term rewriting calculus. We do not follow their code, but instead seek to accomplish the same objective in a way that is natural to OBJ3. <p> However, we have written an executable version of the above code by replacing ASSOCV with three views corresponding to its three instantiations in IND. The semantics of parameterized views is discussed in <ref> [5] </ref>, using the notion of pushout from category theory. It would not be difficult to give a semantics using the more concrete approach introduced in [7]. <p> This would give a fully general inductive proof structure that could be reused for any equational property by suitably instantiating the parameterized view. The semantics of theories parameterized by parameterized views seems a natural extension of the semantics of parameterized views in <ref> [5] </ref>, and we hope to investigate this subject soon. 7 Some Undocumented Features of Parameterization Anyone who wants to do further experiments with higher order programming in OBJ3 may find the following remarks useful: 1. Proper terms cannot be used as parameters of modules.
Reference: [6] <author> Joseph Goguen and Razvan Diaconescu. </author> <title> Towards an algebraic semantics for the object paradigm. </title> <editor> In Hartmut Ehrig and Fernando Orejas, editors, </editor> <booktitle> Proceedings, Tenth Workshop on Abstract Data Types, </booktitle> <pages> pages 1-29. </pages> <publisher> Springer, </publisher> <year> 1994. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 785. </volume>
Reference-contexts: Another feature that would be interesting to implement and experiment with is the synchronized concurrent connection introduced in <ref> [6] </ref> for specification of concurrent object oriented systems. We feel it should be very exciting to explore this new area of parameterized programming, and hope to do so in the not too distant future. Acknowledgement We thank Prof.
Reference: [7] <author> Joseph Goguen and Will Tracz. </author> <title> An implementation-oriented semantics for module composition, </title> <note> 1996. In preparation. </note>
Reference-contexts: The semantics of parameterized views is discussed in [5], using the notion of pushout from category theory. It would not be difficult to give a semantics using the more concrete approach introduced in <ref> [7] </ref>. The technique of the proof above could also be used to prove other properties of numbers, just by replacing ASSOCV with a view picking out the two new terms to be proved equal.
Reference: [8] <author> Joseph Goguen, Timothy Winkler, Jose Meseguer, Kokichi Futatsugi, and Jean-Pierre Jouan-naud. Introducing OBJ. In Joseph Goguen and Grant Malcolm, </author> <title> editors, Algebraic Specification with OBJ: An Introduction with Case Studies. </title> <note> to appear. Also Technical Report, SRI International. </note>
Reference-contexts: 1 Introduction This paper discusses the use of OBJ3's parameterized modules for higher order programming, giving examples beyond those in <ref> [8, 3, 4] </ref> and showing some capabilities that may seem surprising. We also discuss parameterized views, which are not yet implemented, but which we hope soon will be. <p> We also discuss parameterized views, which are not yet implemented, but which we hope soon will be. We assume familiarity with <ref> [8] </ref>, which appears as the first paper in this book. 2 Parameterized Modules as Parameters A feature of OBJ3 not discussed in [8] allows the use of parameterized modules as parameter theories of other modules. <p> We also discuss parameterized views, which are not yet implemented, but which we hope soon will be. We assume familiarity with <ref> [8] </ref>, which appears as the first paper in this book. 2 Parameterized Modules as Parameters A feature of OBJ3 not discussed in [8] allows the use of parameterized modules as parameter theories of other modules. The example below follows one suggested by Yatsu and Futatsugi [9] in connection with their design work on the CafeOBJ system [2]. The parameterized LIST object defines lists, with a comma syntax for concatenation. <p> The "self-referential" use of NAT2 in the last module seems not to be mentioned in <ref> [8] </ref>. 3 4 Inductive Proof over the Natural Numbers The example in this section was also inspired by [1]. The objective in this case is to mechanize induction by encapsulating the structure of standard inductive proofs over the natural numbers into a reusable specification. <p> HYP [(t).TERM] + HYP [(u).TERM] + (GOAL * (op goal to step))[view to TERM is op a to t ++ u . endv] endm red base and step . ***&gt; should be: true 5 6 Parameterized Views Parameterized views are not implemented in OBJ3, but Sections 4.7 and C.8 of <ref> [8] </ref>, on higher order programming and on category theory, respectively, present parameterized views asserting certain properties of parameterized modules. The code below is again for proving associativity of addition, but now using a parameterized view. Because of this, the code does not run in the current OBJ3 implementation.
Reference: [9] <author> Hirokazu Yatsu and Kokichi Futatsugi. </author> <title> Modular specification in CafeOBJ. </title> <editor> In Kokichi Futatsugi, editor, </editor> <booktitle> Proceedings, Workshop on Tenth Anniversary of OBJ2, Itoh, </booktitle> <address> Japan, </address> <month> 21-22 October </month> <year> 1995. </year> <pages> Unisys, </pages> <year> 1995. </year> <month> 9 </month>
Reference-contexts: We assume familiarity with [8], which appears as the first paper in this book. 2 Parameterized Modules as Parameters A feature of OBJ3 not discussed in [8] allows the use of parameterized modules as parameter theories of other modules. The example below follows one suggested by Yatsu and Futatsugi <ref> [9] </ref> in connection with their design work on the CafeOBJ system [2]. The parameterized LIST object defines lists, with a comma syntax for concatenation. The theory FUN defines an interface requesting a (unary) function f between two possibly different sorts. <p> Elt.X . var L : List1 . eq map nil = nil . endo make MAP-double is MAP [NAT,NAT, view to DOUBLE is op f_ to double_ . endv] endm We could also have added L1 :: LIST [X], L2 :: LIST [Y] to the parameters of MAP, as in <ref> [9] </ref>, but the above is more natural to OBJ3. It would have been even more natural to have the two sorts in the body of FUN instead of as parameters.
References-found: 9

