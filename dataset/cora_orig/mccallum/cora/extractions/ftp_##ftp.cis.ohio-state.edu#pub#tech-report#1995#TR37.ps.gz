URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/1995/TR37.ps.gz
Refering-URL: http://www.cis.ohio-state.edu/rsrg/bib-engineer.html
Root-URL: 
Email: weide,edwards,heym,long,ogden-@cis.ohio-state.edu  
Title: Characterizing Observability and Controllability of Software Components  
Author: Bruce W. Weide Stephen H. Edwards Wayne D. Heym Timothy J. Long William F. Ogden 
Note: Copyright 1995 by the authors. All rights reserved. Also with  
Address: 2015 Neil Avenue Columbus, OH 43210  Otterbein College, Westerville, OH 43081.  
Affiliation: Department of Computer and Information Science The Ohio State University  Department of Mathematical Sciences,  
Abstract: Technical Report OSU-CISRC-9/95-TR37 September 1995 
Abstract-found: 1
Intro-found: 1
Reference: [Bucci 94] <author> Bucci, P., Hollingsworth, J.E., Krone, J., and Weide, B.W., </author> <title> Implementing Components in RESOLVE, </title> <booktitle> Software Engineering Notes 19, </booktitle> <volume> 4, </volume> <month> October </month> <year> 1994, </year> <pages> 40-52. </pages>
Reference-contexts: To illustrate these difficulties we use the example in Figure 2 of a possible specification for a Set ADT. Here the appropriate mathematical model seems clear. The question is what operations need to be provided in order to achieve observability and controllability. The specification language is RESOLVE <ref> [Bucci 94, Edwards 94, Ogden 94] </ref>, but the issues involved arise in any model-based specification language [Wing 90]. <p> Each realization (implementation) of a concept may require additional parameters beyond those of the concept, and these appear in the realization header <ref> [Bucci 94] </ref>. This mechanism lets us require that the implementation of an operation Were_Equal for type Set may only count on the always-present initialization, finalization, and swapping for Items, and on a similarly-defined Items_Were_Equal operation.
Reference: [Edwards 94] <author> Edwards, S.H., Heym, W.D., Long, T.J., Sitaraman, M., and Weide, B.W., </author> <title> Specifying Components in RESOLVE, </title> <booktitle> Software Engineering Notes 19, </booktitle> <volume> 4, </volume> <month> October </month> <year> 1994, </year> <pages> 29-39. </pages>
Reference-contexts: Observability One of the most important design decisions facing a reusable component specifier is the selection of an appropriate mathematical model (also called conceptual model or abstract model or mental model [Norman 90]) for the state space of values for variables (or objects) of a new abstract data type (ADT) <ref> [Edwards 94, Guttag 93, Spivey 89, Weide 91, Wing 90] </ref>. <p> Background and Working Example The principles of observability and controllability, as defined here, are meaningful only in the context of model-based specifications where mathematical theory and program specification are separate, as in Larch [Guttag 93] and RESOLVE <ref> [Edwards 94] </ref>. The question addressed by observability and controllability is essentially whether the mathematical model of an ADT is in some sense minimal in size and structure for specifying a programming concept. <p> To illustrate these difficulties we use the example in Figure 2 of a possible specification for a Set ADT. Here the appropriate mathematical model seems clear. The question is what operations need to be provided in order to achieve observability and controllability. The specification language is RESOLVE <ref> [Bucci 94, Edwards 94, Ogden 94] </ref>, but the issues involved arise in any model-based specification language [Wing 90].
Reference: [Edwards 95] <author> Edwards, S.H., </author> <title> A Formal Model of Software Subsystems, </title> <type> Ph.D. dissertation, </type> <institution> Dept. of Computer and Information Science, The Ohio State Univ., Columbus, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: This model is used to explain the abstract behavior of a components operations, so the choice of model directly influences the understandability of the concept and the ease of reasoning about its implementations and clients that are 2 layered on top of it <ref> [Sitaraman 93, Edwards 95] </ref>. Typically, the specification designer must consider a variety of candidate mathematical models before identifying the best one (s).
Reference: [Ernst 94] <author> Ernst, G.W., Hookway, R.J., and Ogden, W.F., </author> <title> Modular Verification of Data Abstractions with Shared Realizations, </title> <journal> IEEE Transactions on Software Engineering 20, </journal> <volume> 4, </volume> <month> April </month> <year> 1994, </year> <pages> 288-307. </pages>
Reference-contexts: x) then if Is_Member (s2, x) then Remove (s1, x) Remove (s2, x) return Were_Equal (s1, s2) else return false end if else if Is_Member (s2, x) then return false else return Were_Equal (s1, s2) end if end if end Were_Equal This illustrates the power of a modular proof system <ref> [Ernst 94] </ref>. There might be Items for which it is impossible to implement the enumerator interface, but this does not influence the total correctness of Were_Equal. At the mathematical level, if the state space math [Item] is effectively enumerable then in principle there exists an implementation of the enumerator interface.
Reference: [Goguen 78] <author> Goguen, J.A., Thatcher, J.W., and Wagner, E.G., </author> <title> An Initial Algebra Approach to the Specification, Correctness, and Implementation of Abstract Data Types, </title> <booktitle> in Current Trends in Programing Methodology 4, </booktitle> <editor> R. T. Yeh, ed., </editor> <publisher> Prentice-Hall, </publisher> <year> 1978, </year> <pages> 80-149. </pages>
Reference-contexts: A related issue that received much attention in the late 1970s in the algebraic specification community is when two mathematical values should be considered equal. Some authors <ref> [Liskov 75, Goguen 78] </ref> considered two values to be different unless demonstrably equal based on the axioms. Others [Guttag 78] considered two values to be equal unless provably different.
Reference: [Guttag 78] <author> Guttag, J.V., Horowitz, E., and Musser, </author> <title> D.R., Abstract Data Types and Software Validation, </title> <journal> Communications of the ACM 21, </journal> <volume> 12, </volume> <month> December </month> <year> 1978, </year> <pages> 1048-1064. </pages>
Reference-contexts: A related issue that received much attention in the late 1970s in the algebraic specification community is when two mathematical values should be considered equal. Some authors [Liskov 75, Goguen 78] considered two values to be different unless demonstrably equal based on the axioms. Others <ref> [Guttag 78] </ref> considered two values to be equal unless provably different. While the first group took a traditional view and insisted that the smallest congruence relation defined by the axioms be used, the latter group allowed any congruence relations (including the smallest) consistent with the axioms.
Reference: [Guttag 93] <author> Guttag, J.V., and Horning J.J., </author> <title> Larch: Languages and Tools for Formal Specification, </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Observability One of the most important design decisions facing a reusable component specifier is the selection of an appropriate mathematical model (also called conceptual model or abstract model or mental model [Norman 90]) for the state space of values for variables (or objects) of a new abstract data type (ADT) <ref> [Edwards 94, Guttag 93, Spivey 89, Weide 91, Wing 90] </ref>. <p> Background and Working Example The principles of observability and controllability, as defined here, are meaningful only in the context of model-based specifications where mathematical theory and program specification are separate, as in Larch <ref> [Guttag 93] </ref> and RESOLVE [Edwards 94]. The question addressed by observability and controllability is essentially whether the mathematical model of an ADT is in some sense minimal in size and structure for specifying a programming concept. <p> This is not a well-formed question for true algebraic specifications, in which a mathematical theory and a programming component being specified are treated as inseparable. The closely related taxonomy of mathematical functions of a theory into observers and constructors (e.g., <ref> [Liskov 86, Guttag 93] </ref>) is clearly related in spirit, but these notions are one level removed as they pertain to the design of mathematical theories and not to the design of model-based specifications that use those theories. <p> In general, for well-defined theories that are typically used as models (e.g., the Larch set trait <ref> [Guttag 93] </ref>) the two notions converge.
Reference: [Jones 90] <author> Jones, C.B., </author> <title> Systematic Software Development Using VDM, 2 nd ed., </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: 1. Introduction Specifying the behavior of a software component especially one that is meant to be reused is a challenging task. Some important quality objectives of design in this area include avoiding implementation bias <ref> [Jones 90] </ref> and achieving understandability for potential component clients [Sitaraman 93]. <p> There is the notion of an unbiased or sufficiently abstract or fully abstract model <ref> [Jones 90] </ref>, which is similar to observability in the sense that it is defined almost exactly like O 0 . But this informal definition leaves open the possibility of various interpretations, along the lines suggested in Sections 3 and 4, which is precisely the confusion we wish to clear up.
Reference: [Liskov 75] <author> Liskov, B.H., and Zilles, </author> <title> S.N., Specification Techniques for Data Abstractions, </title> <journal> IEEE Transactions on Software Engineering SE-1, </journal> <volume> 1, </volume> <month> March </month> <year> 1975, </year> <pages> 7-19. </pages>
Reference-contexts: A related issue that received much attention in the late 1970s in the algebraic specification community is when two mathematical values should be considered equal. Some authors <ref> [Liskov 75, Goguen 78] </ref> considered two values to be different unless demonstrably equal based on the axioms. Others [Guttag 78] considered two values to be equal unless provably different.
Reference: [Liskov 86] <author> Liskov, B., and Guttag, J., </author> <title> Abstraction and Specification in Program Development, </title> <publisher> McGraw-Hill, </publisher> <year> 1986. </year>
Reference-contexts: This is not a well-formed question for true algebraic specifications, in which a mathematical theory and a programming component being specified are treated as inseparable. The closely related taxonomy of mathematical functions of a theory into observers and constructors (e.g., <ref> [Liskov 86, Guttag 93] </ref>) is clearly related in spirit, but these notions are one level removed as they pertain to the design of mathematical theories and not to the design of model-based specifications that use those theories.
Reference: [Norman 90] <author> Norman, D.A., </author> <title> The Design of Everyday Things, </title> <address> Doubleday/Currency, </address> <year> 1990. </year> <month> 20 </month>
Reference-contexts: The Principle of Observability One of the most important design decisions facing a reusable component specifier is the selection of an appropriate mathematical model (also called conceptual model or abstract model or mental model <ref> [Norman 90] </ref>) for the state space of values for variables (or objects) of a new abstract data type (ADT) [Edwards 94, Guttag 93, Spivey 89, Weide 91, Wing 90]. <p> specifier is trying to give the client fails to convey the true situation, and the client is likely to look for another model of the components behavior and to translate mentally between the official specification and this alternate view a situation virtually certain to result in miscommunication between the parties <ref> [Norman 90] </ref>. 1.2. The Principle of Controllability A complementary objective to understandability is utility: a reusable component should be useful to a variety of clients whose particular needs for variants of a basic functionality are perforce unknown at component design time.
Reference: [Ogden 94] <author> Ogden, W.F., Sitaraman, M., Weide, B.W., and Zweben, S.H., </author> <title> The RESOLVE Framework and Discipline A Research Synopsis, </title> <booktitle> Software Engineering Notes 19, </booktitle> <volume> 4, </volume> <month> October </month> <year> 1994, </year> <pages> 23-28. </pages>
Reference-contexts: To illustrate these difficulties we use the example in Figure 2 of a possible specification for a Set ADT. Here the appropriate mathematical model seems clear. The question is what operations need to be provided in order to achieve observability and controllability. The specification language is RESOLVE <ref> [Bucci 94, Edwards 94, Ogden 94] </ref>, but the issues involved arise in any model-based specification language [Wing 90].
Reference: [Sitaraman 93] <author> Sitaraman, M., Harms, D.E., and Welch, L.W., </author> <title> On Specification of Reusable Software Components, </title> <journal> International Journal of Software Engineering and Knowledge Engineering 3, </journal> <volume> 2, </volume> <month> June </month> <year> 1993, </year> <pages> 207-229. </pages>
Reference-contexts: 1. Introduction Specifying the behavior of a software component especially one that is meant to be reused is a challenging task. Some important quality objectives of design in this area include avoiding implementation bias [Jones 90] and achieving understandability for potential component clients <ref> [Sitaraman 93] </ref>. <p> This model is used to explain the abstract behavior of a components operations, so the choice of model directly influences the understandability of the concept and the ease of reasoning about its implementations and clients that are 2 layered on top of it <ref> [Sitaraman 93, Edwards 95] </ref>. Typically, the specification designer must consider a variety of candidate mathematical models before identifying the best one (s).
Reference: [Spivey 89] <author> Spivey, J.M., </author> <title> The Z Notation: A Reference Manual, </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: Observability One of the most important design decisions facing a reusable component specifier is the selection of an appropriate mathematical model (also called conceptual model or abstract model or mental model [Norman 90]) for the state space of values for variables (or objects) of a new abstract data type (ADT) <ref> [Edwards 94, Guttag 93, Spivey 89, Weide 91, Wing 90] </ref>.
Reference: [Weide 91] <author> Weide, B.W., Ogden, W.F., and Zweben, S.H., </author> <title> Reusable Software Components, </title> <booktitle> in Advances in Computers, </booktitle> <volume> vol. 33, </volume> <editor> M.C. Yovits, ed., </editor> <publisher> Academic Press, </publisher> <year> 1991, </year> <pages> 1-65. </pages>
Reference-contexts: In prior work we surveyed several specification principles that were intuitively described in the literature and proposed practical tests for compliance <ref> [Weide 91] </ref>. In this paper we report on some interesting problems associated with two of these principles, observability and controllability, which deal with the relationship between the expressiveness of the mathematics used in a specification and the computational power of the specified component. <p> At each fork in the road (marked in the text with y) this paper takes a particular branch in concert with folklore about specification design, leading toward and beyond fairly specific principles proposed in the literature <ref> [Weide 91] </ref>. This gives a depth-first view of the landscape of Figure 1. A more comprehensive paper in preparation will discuss the paths we do not follow here. 1.1. <p> Observability One of the most important design decisions facing a reusable component specifier is the selection of an appropriate mathematical model (also called conceptual model or abstract model or mental model [Norman 90]) for the state space of values for variables (or objects) of a new abstract data type (ADT) <ref> [Edwards 94, Guttag 93, Spivey 89, Weide 91, Wing 90] </ref>. <p> An implementation of specified behavior is totally correct if it is partially correct (i.e., correct if terminating) and terminating, for any totally correct implementations of the components it uses. We select this path because it leads to the specific principles identified in earlier work <ref> [Weide 91] </ref>, and thereby come to the following possible formalization of observability: O 1 A specification S defining the program type ADT is observable iff there is a totally correct layered implementation of: operation Are_Equal ( preserves x1: ADT preserves x2: ADT ): Boolean 8 ensures Are_Equal iff (x1 = x2) <p> y 2 Should observability and controllability be defined in terms of relationships between two program variables, or in terms of a program variable and a universally quantified mathematical variable, or perhaps in some other way? Here we choose the first path, which we took in deriving the principles published earlier <ref> [Weide 91] </ref> and which a priori seems as reasonable as any other. The revision needed for controllability, however, makes it clear that the definition is contingent, or relative, in the following sense. <p> Are_Equal iff (x1 = x2) C 2 A specification S defining the program type ADT is relatively controllable iff there is a totally correct layered implementation of: operation Get_Replica 9 preserves x1: ADT produces x2: ADT ) ensures x2 = x1 These definitions match practical compliance tests of prior work <ref> [Weide 91] </ref>. But they still have some technical problems. 3.3. <p> This is one reason we previously suggested the guideline of testing the stronger criteria O 2 and C 2 <ref> [Weide 91] </ref>. For components in other languages, however, C 3 is a nontrivial criterion. For example, consider an Ada package defining a Stack ADT as a limited private type (no assignment operator), along with operations Push, Pop, and Is_Empty having the usual meanings.
Reference: [Weide 94] <author> Weide, B.W., Ogden, W.F., and Sitaraman, M., </author> <title> Recasting Algorithms to Encourage Reuse, </title> <journal> IEEE Software 11, </journal> <volume> 5, </volume> <month> September </month> <year> 1994, </year> <pages> 80-88. </pages>
Reference-contexts: Although every operation in Figure 1 has functional behavior the results of each operation are uniquely determined by its inputs there are many situations where it is appropriate to define an operation so its post-condition can be satisfied in more than one possible way <ref> [Weide 94] </ref>. A correct implementation might exhibit functional behavior, but a client of the specification cannot count on any particular function being computed only on the results of each operation satisfying the relation specified in the post-condition.
Reference: [Wing 90] <author> Wing, J.M., </author> <title> A Specifiers Introduction to Formal Methods, </title> <journal> Computer 23, </journal> <volume> 9, </volume> <month> September </month> <year> 1990, </year> <pages> 8-24. </pages>
Reference-contexts: Observability One of the most important design decisions facing a reusable component specifier is the selection of an appropriate mathematical model (also called conceptual model or abstract model or mental model [Norman 90]) for the state space of values for variables (or objects) of a new abstract data type (ADT) <ref> [Edwards 94, Guttag 93, Spivey 89, Weide 91, Wing 90] </ref>. <p> Here the appropriate mathematical model seems clear. The question is what operations need to be provided in order to achieve observability and controllability. The specification language is RESOLVE [Bucci 94, Edwards 94, Ogden 94], but the issues involved arise in any model-based specification language <ref> [Wing 90] </ref>. In RESOLVE, the mathematical model of an ADT is defined explicitly, as with finite set; or by reference to a program type, as with math [Item], which denotes the mathematical model type of the program type Item.
References-found: 17

