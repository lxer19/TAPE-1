URL: ftp://ftp.eecs.umich.edu/groups/gasm/gemmex.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Email: anlauff@acm.org  kutter@tik.ee.ethz.ch  alfonso@univaq.it  
Title: Formal Aspects of and Development Environments for Montages  
Author: Matthias Anlauff Philipp W. Kutter Alfonso Pierantonio 
Date: August 31, 1997  
Address: Berkeley, CA 94704, USA  CH-8092 Zurich, Switzerland  I-67100 L'Aquila, Italy  
Affiliation: International Computer Science Institute  Eidgenossische Technische Hochschule  Universita di L'Aquila  
Abstract: The specification of all aspects of a programming language requires adequate formal models and tool support. Montages specifications combine graphical and textual elements to yield language descriptions similar in structure, length, and complexity to those in common language manuals, but with a formal semantics. A broad range of people involved in programming language design and use may find convenient to use Montages in combination with the tool Gem-Mex. It allows the automatic generation of high quality documents, type-checkers, interpreters and symbolic debuggers.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abramsky. </author> <title> Semantics of Interaction. In Trees in Algebra and Programming - CAAP'96, </title> <booktitle> 21st Int. Coll., volume 1059 of LNCS, </booktitle> <pages> page 1. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: To cite Abramsky " : : : once languages with features beyond the purely functional are considered, the appropriateness of modeling programs by functions is increasingly open to question. Neither concurrency nor `advanced' imperative features have been captured denotationally in a fully convincing fashion." <ref> [1] </ref> Other research has been carried out because of the above considerations about pragmatics. In particular, it is worth mentioning Action semantics [21], which is an initial-algebra semantics [11], based on Mosses' unified algebras.
Reference: [2] <author> M. Anlauff. </author> <title> The semantics of the object-oriented programming language sather. </title> <type> Technical report, </type> <institution> International Computer Science Institute, Berkeley, </institution> <year> 1997. </year> <note> In preparation. </note>
Reference-contexts: The specification method scales-up to realistic languages, e.g. in [20] is the complete specification of the whole language Oberon can be found. Complex features as encapsulation, modularity, inheritance and pointers are covered in a surprisingly short and comprehensive manner. Montages have been used also in <ref> [2] </ref> and [10] for formalizing the object-oriented language Sather and the SQL direct (ISO9075), respectively. The collection of Montages defining a language may be used used for generating automatically a number of tools, such as type-checkers, interpreters and symbolic debuggers.
Reference: [3] <author> M. Anlauff, P.W. Kutter, A. Pierantonio, D. Rosenzweit, L. Thiele, and W. Zimmermann. </author> <title> Compiler construction with montages. </title> <note> submitted for publication, </note> <year> 1997. </year>
Reference-contexts: Imperative versus declarative style In [18] we defined tree traversal in an imperative style. Here we use alternatively a definition in a declarative style. The declarative style presented here can be used for parallel traversal as well, which is needed for the derivation of parallel compilers <ref> [3] </ref>. The imperative version of [18] is a sequential refinement of the declarative version given here. The advantage of the imperative version is that it is easier to read for non-academic programmers.
Reference: [4] <author> E. Borger. </author> <title> Why Use Evolving Algebras for Hardware and Software Engineering. </title> <booktitle> In SOFTSEM'95 22nd Seminar on Current Trends in Theory and Practice of Informatics, volume 1012 of LNCS, </booktitle> <pages> pages 236 - 271. </pages> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Although all used aspects of ASMs are explained during the sections, we have to be rather short. For a more complete treatment and motivations we refer to <ref> [12, 4] </ref>. 2.1 Initial State and Tree Representation Given a context free grammar of a language, the generation of a string S of that language can be described by means of a derivation tree. The root of the tree is labeled with the start symbol. <p> As pointed out in <ref> [4] </ref> ASMs are deliberately not imposing any particular calculus. The ease of abstraction makes ASMs very suitable for different application domains and for each of them it makes sense to have a different verification system with its own assumptions. <p> The ease of abstraction makes ASMs very suitable for different application domains and for each of them it makes sense to have a different verification system with its own assumptions. Moreover, one is able to do complex mathematical proofs directly in the ASM framework, as shown in <ref> [4, 5, 8] </ref>. The translation of an ASM model in other formalisms is interesting if tools are available with powerful verification capabilities. Montages are formal descriptions of programming languages with an higher intelligibility than usual semantics descriptions.
Reference: [5] <author> E. Borger and I. Durdanovic. </author> <title> Correctness of Compiling Occam to Transputer Code. </title> <journal> Computer Journal, </journal> <volume> 39(1):52 - 92, </volume> <year> 1996. </year>
Reference-contexts: The state transitions are given by rules that update functions pointwise and extend universes with new elements. ASMs have already been used to model the dynamic semantics of programming languages such as Pro-log [7], Occam <ref> [5] </ref>, C [13], C++ [26], Oberon [17], and VHDL [6]. At the risk of oversimplifying somewhat, we can describe some of these models [13, 26, 17] as follows. Program execution is modeled by the evolution of two functions CT and S. <p> The classical use of ASMs abstracts from the static semantics and assumes the result of a static analysis in order to define the dynamic semantics. The main criticisms against such an approach is that the static analysis is not formalized. An exception is the work on Occam <ref> [5] </ref>. Unfortunately the solution presented there allows not for the definition of the static semantics. Montages solves the problem using control and data flow graphs and at the same time allows one to give a very compact definition of static semantics as full first-order predicates. <p> The ease of abstraction makes ASMs very suitable for different application domains and for each of them it makes sense to have a different verification system with its own assumptions. Moreover, one is able to do complex mathematical proofs directly in the ASM framework, as shown in <ref> [4, 5, 8] </ref>. The translation of an ASM model in other formalisms is interesting if tools are available with powerful verification capabilities. Montages are formal descriptions of programming languages with an higher intelligibility than usual semantics descriptions.
Reference: [6] <author> E. Borger, U. Glaser, and W. Mueller. </author> <title> Formal Definition of an Abstract VHDL'93 Simulator by EA-machines. In Semantics of VHDL, </title> <booktitle> volume 307 of The Kluwer International Series in Engineering and Computer Science. </booktitle> <publisher> Kluwer, </publisher> <year> 1995. </year>
Reference-contexts: The state transitions are given by rules that update functions pointwise and extend universes with new elements. ASMs have already been used to model the dynamic semantics of programming languages such as Pro-log [7], Occam [5], C [13], C++ [26], Oberon [17], and VHDL <ref> [6] </ref>. At the risk of oversimplifying somewhat, we can describe some of these models [13, 26, 17] as follows. Program execution is modeled by the evolution of two functions CT and S.
Reference: [7] <author> E. Borger and D. Rosenzweig. </author> <title> A Mathematical Definition of Full Prolog. </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1994. </year>
Reference-contexts: The state transitions are given by rules that update functions pointwise and extend universes with new elements. ASMs have already been used to model the dynamic semantics of programming languages such as Pro-log <ref> [7] </ref>, Occam [5], C [13], C++ [26], Oberon [17], and VHDL [6]. At the risk of oversimplifying somewhat, we can describe some of these models [13, 26, 17] as follows. Program execution is modeled by the evolution of two functions CT and S.
Reference: [8] <author> E. Borger and D. Rosenzweig. </author> <title> The WAM Definition and Compiler Correctness, </title> <booktitle> chapter 2, pages 20 - 90. Series in Computer Science and Artificial Intelligence. </booktitle> <publisher> Elsevier Science B.V.North Holland, </publisher> <year> 1995. </year>
Reference-contexts: The ease of abstraction makes ASMs very suitable for different application domains and for each of them it makes sense to have a different verification system with its own assumptions. Moreover, one is able to do complex mathematical proofs directly in the ASM framework, as shown in <ref> [4, 5, 8] </ref>. The translation of an ASM model in other formalisms is interesting if tools are available with powerful verification capabilities. Montages are formal descriptions of programming languages with an higher intelligibility than usual semantics descriptions.
Reference: [9] <author> P. Borra, D. Clement, T. Despeyroux, J. Incerpi, G. Kahn, B. Lang, and V. Pascual. </author> <title> CENTAUR: The System. </title> <type> Technical Report 777, </type> <institution> INRIA, Sophia Antipolis, </institution> <year> 1987. </year>
Reference-contexts: For somebody knowing mathematical logic, Natural Semantics are pretty intuitive and we used it for the dynamic semantics of Oberon [16]. Although we succeeded due to the excellent tool support by Centaur <ref> [9] </ref>, the result was much longer and more complex then the Montages counterpart given in [20], since one has to carry around all the state information in the case of Natural Semantics.
Reference: [10] <author> B. DiFranco. Semantica Statica e Dinamica di SQL mediante i Montaggi. </author> <type> Master's thesis, </type> <institution> Universita di L'Aquila, </institution> <year> 1997. </year> <note> in italian. </note>
Reference-contexts: The specification method scales-up to realistic languages, e.g. in [20] is the complete specification of the whole language Oberon can be found. Complex features as encapsulation, modularity, inheritance and pointers are covered in a surprisingly short and comprehensive manner. Montages have been used also in [2] and <ref> [10] </ref> for formalizing the object-oriented language Sather and the SQL direct (ISO9075), respectively. The collection of Montages defining a language may be used used for generating automatically a number of tools, such as type-checkers, interpreters and symbolic debuggers. <p> At the same time Montages retain the advantages of ASMs. Experience in scaling up both basic ASMs and Montages for large case studies such as the specification of SQL <ref> [10] </ref> and Oberon [17, 20] showed some important advantages of Montages with respect to basic ASMs: * the readability and comprehension of specifications improved drastically since the specification is ar ranged in capsules of behavior according to the rules of the context-free grammar, * the maintenance of the whole specification is
Reference: [11] <author> J.A. Goguen, J.W. Thatcher, E.G. Wagner, and J.B. Wright. </author> <title> Initial algebras semantics and continuous algebras. </title> <journal> J.ACM, </journal> <volume> (24):68 - 95, </volume> <year> 1977. </year> <month> 15 </month>
Reference-contexts: Neither concurrency nor `advanced' imperative features have been captured denotationally in a fully convincing fashion." [1] Other research has been carried out because of the above considerations about pragmatics. In particular, it is worth mentioning Action semantics [21], which is an initial-algebra semantics <ref> [11] </ref>, based on Mosses' unified algebras. Action semantics retained some denotational semantics features, i.e. context-free grammars for defining abstract-syntax trees, and the use of Horn clauses to give inductive definition of compositional 13 semantic functions. The main semantic entities are actions, which are specified by means of the action notation.
Reference: [12] <author> Y. Gurevich. </author> <title> Evolving Algebras 1993: Lipari Guide. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Thus, Montages are a formal instrument which can be equally well understood by language designers, compiler constructors, and programmers. Based on Abstract State Machines (formally called Evolving Algebras) <ref> [12] </ref> Montages provide a theoretical basis for a number of activities from initial language design to prototyping. <p> ASMs have been proposed by Y.Gurevich as a dynamic generalization of multi-sorted algebras, intended to provide a more versatile notion of Turing machine, "able to simulate arbitrary algorithms in a direct and essentially coding-free way" <ref> [12] </ref>. In short, ASMs are a state-based formalism in which a state is updated in discrete time steps. Unlike most state based systems, the state is given by an algebra, that is, a collection of functions and universes. <p> Although all used aspects of ASMs are explained during the sections, we have to be rather short. For a more complete treatment and motivations we refer to <ref> [12, 4] </ref>. 2.1 Initial State and Tree Representation Given a context free grammar of a language, the generation of a string S of that language can be described by means of a derivation tree. The root of the tree is labeled with the start symbol.
Reference: [13] <author> Y. Gurevich and J.K. Huggins. </author> <title> The Semantics of the C Programming Language, </title> <booktitle> volume 702 of LNCS, </booktitle> <pages> pages 274 - 308. </pages> <publisher> Springer Verlag, </publisher> <year> 1993. </year>
Reference-contexts: The state transitions are given by rules that update functions pointwise and extend universes with new elements. ASMs have already been used to model the dynamic semantics of programming languages such as Pro-log [7], Occam [5], C <ref> [13] </ref>, C++ [26], Oberon [17], and VHDL [6]. At the risk of oversimplifying somewhat, we can describe some of these models [13, 26, 17] as follows. Program execution is modeled by the evolution of two functions CT and S. <p> ASMs have already been used to model the dynamic semantics of programming languages such as Pro-log [7], Occam [5], C [13], C++ [26], Oberon [17], and VHDL [6]. At the risk of oversimplifying somewhat, we can describe some of these models <ref> [13, 26, 17] </ref> as follows. Program execution is modeled by the evolution of two functions CT and S. The current task CT represents the part of the program text currently in execution and may be seen as an abstract program counter. S represents the current value of the store. <p> S represents the current value of the store. Formally one define the initial state of the functions and specifies how they evolve by means of transition rules. In the described models <ref> [13, 26, 17] </ref>, the initial state is assumed to include the results of a static analysis, which is only described informally. This analysis provides a representation of the program's control and data flow in the form of functions between parts of the program text.
Reference: [14] <author> G. Kahn. </author> <title> Natural Semantics. </title> <booktitle> In Proceedings of the Symp. on Theoretical Aspects of Computer Science, </booktitle> <address> Passau, Germany, </address> <year> 1987. </year>
Reference-contexts: In this respect, Montages are much more expressive since they make use of the full first-order logic for the static semantics predicates. An approach with the same ambitious goal are Kahn's Natural Semantics <ref> [14] </ref> which are directly based on Natural Deduction. For somebody knowing mathematical logic, Natural Semantics are pretty intuitive and we used it for the dynamic semantics of Oberon [16].
Reference: [15] <author> D.E. Knuth. </author> <title> Semantics of Context-Free Languages. </title> <journal> Math. Systems Theory, </journal> <volume> 2(2):127 - 146, </volume> <year> 1968. </year>
Reference-contexts: Although we succeeded due to the excellent tool support by Centaur [9], the result was much longer and more complex then the Montages counterpart given in [20], since one has to carry around all the state information in the case of Natural Semantics. Although attribute grammars <ref> [15] </ref> are not designed to specify all aspects of languages, it's worth noting that the the solution for the static aspects of our approach has some similarities with attribute grammars.
Reference: [16] <author> P.W. Kutter. </author> <title> Executable Specification of Oberon Using Natural Semantics. Term Work, ETH Zurich, </title> <booktitle> implementation on the Centaur System [9], </booktitle> <year> 1996. </year>
Reference-contexts: An approach with the same ambitious goal are Kahn's Natural Semantics [14] which are directly based on Natural Deduction. For somebody knowing mathematical logic, Natural Semantics are pretty intuitive and we used it for the dynamic semantics of Oberon <ref> [16] </ref>. Although we succeeded due to the excellent tool support by Centaur [9], the result was much longer and more complex then the Montages counterpart given in [20], since one has to carry around all the state information in the case of Natural Semantics.
Reference: [17] <author> P.W. Kutter. </author> <title> Dynamic Semantics of the Programming Language Oberon. </title> <type> TIK-Report 27, </type> <institution> ETH Zurich, </institution> <year> 1997. </year>
Reference-contexts: The state transitions are given by rules that update functions pointwise and extend universes with new elements. ASMs have already been used to model the dynamic semantics of programming languages such as Pro-log [7], Occam [5], C [13], C++ [26], Oberon <ref> [17] </ref>, and VHDL [6]. At the risk of oversimplifying somewhat, we can describe some of these models [13, 26, 17] as follows. Program execution is modeled by the evolution of two functions CT and S. <p> ASMs have already been used to model the dynamic semantics of programming languages such as Pro-log [7], Occam [5], C [13], C++ [26], Oberon [17], and VHDL [6]. At the risk of oversimplifying somewhat, we can describe some of these models <ref> [13, 26, 17] </ref> as follows. Program execution is modeled by the evolution of two functions CT and S. The current task CT represents the part of the program text currently in execution and may be seen as an abstract program counter. S represents the current value of the store. <p> S represents the current value of the store. Formally one define the initial state of the functions and specifies how they evolve by means of transition rules. In the described models <ref> [13, 26, 17] </ref>, the initial state is assumed to include the results of a static analysis, which is only described informally. This analysis provides a representation of the program's control and data flow in the form of functions between parts of the program text. <p> At the same time Montages retain the advantages of ASMs. Experience in scaling up both basic ASMs and Montages for large case studies such as the specification of SQL [10] and Oberon <ref> [17, 20] </ref> showed some important advantages of Montages with respect to basic ASMs: * the readability and comprehension of specifications improved drastically since the specification is ar ranged in capsules of behavior according to the rules of the context-free grammar, * the maintenance of the whole specification is much easier since
Reference: [18] <author> P.W. Kutter and A. Pierantonio. </author> <title> Montages: Unified static and dynamic semantics of programming languages. </title> <type> Technical Report 118, </type> <institution> Dip. Matematica Pura ed Applicata, Universita di L'Aquila, </institution> <month> July </month> <year> 1996. </year>
Reference-contexts: In instance of the pattern traverses a compact derivation tree of a given grammar, and executes at each node an action, which depends on the characterization. In addition a general technique is introduced allowing to sequentialize the tree traversal in an arbitrary way. Imperative versus declarative style In <ref> [18] </ref> we defined tree traversal in an imperative style. Here we use alternatively a definition in a declarative style. The declarative style presented here can be used for parallel traversal as well, which is needed for the derivation of parallel compilers [3]. The imperative version of [18] is a sequential refinement <p> versus declarative style In <ref> [18] </ref> we defined tree traversal in an imperative style. Here we use alternatively a definition in a declarative style. The declarative style presented here can be used for parallel traversal as well, which is needed for the derivation of parallel compilers [3]. The imperative version of [18] is a sequential refinement of the declarative version given here. The advantage of the imperative version is that it is easier to read for non-academic programmers.
Reference: [19] <author> P.W. Kutter and A. Pierantonio. </author> <title> Montages Specifications of Realistic Programming Languages. </title> <journal> Springer Journal of Universal Computer Science, </journal> <volume> 3(5) </volume> <pages> 416-442, </pages> <year> 1997. </year>
Reference-contexts: 1 Introduction Montages <ref> [19] </ref> are a specification formalism for describing all aspects of programming languages. Syntax, static analysis and semantics, and dynamic semantics are given in a unified and coherent way by means of semi-visual descriptions. <p> The resulting ASM semantics is exactly as compact as the visual Montages, i.e. each element in a Montages corresponds to an update in the ASM-semantics. In <ref> [19] </ref> we defined several notational shortcuts, which are not used in this text. 3.1 Basic Definitions Formally speaking, the semantics of a Montages specification is an ASM M that for a given program checks the static semantics, initializes the control and data flow functions, and in a second phase executes the
Reference: [20] <author> P.W. Kutter and A. Pierantonio. </author> <title> The Formal Specification of Oberon. </title> <journal> Springer Journal of Universal Computer Science, </journal> <volume> 3(5) </volume> <pages> 443-503, </pages> <year> 1997. </year>
Reference-contexts: This mapping is provided by means of graphs which confer to the specification a certain intelligibility. In this paper, we show some toy examples. The specification method scales-up to realistic languages, e.g. in <ref> [20] </ref> is the complete specification of the whole language Oberon can be found. Complex features as encapsulation, modularity, inheritance and pointers are covered in a surprisingly short and comprehensive manner. <p> For somebody knowing mathematical logic, Natural Semantics are pretty intuitive and we used it for the dynamic semantics of Oberon [16]. Although we succeeded due to the excellent tool support by Centaur [9], the result was much longer and more complex then the Montages counterpart given in <ref> [20] </ref>, since one has to carry around all the state information in the case of Natural Semantics. Although attribute grammars [15] are not designed to specify all aspects of languages, it's worth noting that the the solution for the static aspects of our approach has some similarities with attribute grammars. <p> At the same time Montages retain the advantages of ASMs. Experience in scaling up both basic ASMs and Montages for large case studies such as the specification of SQL [10] and Oberon <ref> [17, 20] </ref> showed some important advantages of Montages with respect to basic ASMs: * the readability and comprehension of specifications improved drastically since the specification is ar ranged in capsules of behavior according to the rules of the context-free grammar, * the maintenance of the whole specification is much easier since
Reference: [21] <author> P. Mosses. </author> <title> Theory and Practice of Action Semantics. </title> <booktitle> In MFCS'96, 21st International Symposium, volume 1113 of LNCS, </booktitle> <pages> pages 37 - 61. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: Moreover domain definitions often need to be changed when extending the language with unforeseen constructs, for instance a change from the direct style to the continuation style when adding gotos <ref> [21] </ref>. To cite Abramsky " : : : once languages with features beyond the purely functional are considered, the appropriateness of modeling programs by functions is increasingly open to question. <p> Neither concurrency nor `advanced' imperative features have been captured denotationally in a fully convincing fashion." [1] Other research has been carried out because of the above considerations about pragmatics. In particular, it is worth mentioning Action semantics <ref> [21] </ref>, which is an initial-algebra semantics [11], based on Mosses' unified algebras. Action semantics retained some denotational semantics features, i.e. context-free grammars for defining abstract-syntax trees, and the use of Horn clauses to give inductive definition of compositional 13 semantic functions. <p> To mention Mosses " : : : the current structural operational semantics of action notation is not easy to modify; alternative forms of operational semantics, such as evolving-algebra semantics, might be preferable in that respect." <ref> [21] </ref> Another universal meta-language for all aspects of programming languages is ASF+SDF [25]. It is an initial-algebra approach and specifies the static and dynamic semantics by means of positive conditional equations.
Reference: [22] <author> M. Odersky. </author> <title> A New Approach to Formal Language Definition and its Application to Oberon. </title> <type> PhD thesis, </type> <institution> ETH Zurich, </institution> <year> 1989. </year>
Reference-contexts: The new nodes are labeled with the corresponding symbols s 1 to s m . Such trees can be made more compact by putting multiple labels in the case of synonym productions <ref> [22] </ref>. Synonym productions are rules of the form n ::= s 1 js 2 j : : : js m , which give place to nodes with only one child. <p> Although in certain cases they may be executed very efficiently, we preferred not to use them for the following reasons: using ASMs we have the same formalism for all parts of the specification; and as shown in <ref> [22] </ref> attribute grammars tend to be very long if applied to real programming languages. Using ASMs for dynamic semantics, the work in [23] defines a framework comparable to ours. Although it has different aims, namely efficient execution.
Reference: [23] <author> A. Poetzsch-Heffter. </author> <title> Developing Efficient Interpreters Based on Formal Language Specifications. </title> <booktitle> In Compiler Construction, volume 786 of Lecture Notes in Computer Science, </booktitle> <pages> pages 233 - 247. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: Using ASMs for dynamic semantics, the work in <ref> [23] </ref> defines a framework comparable to ours. Although it has different aims, namely efficient execution. For the static part, it proposes occurrence algebras which integrate term algebras and context free grammars by providing terms for all nodes of all possible derivation trees.
Reference: [24] <author> D.A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn & Bacon, </publisher> <year> 1986. </year>
Reference-contexts: But its problems with the pragmatical side of language design have been discovered already in case studies of the scale of Pascal and C (see for instance <ref> [24] </ref>). Information hiding, object orientedness and complex name analysis are not covered because of the global visibility of the definition of semantic domains throughout a denotation description.
Reference: [25] <author> A. van Deursen, J. Heering, and P. Klint, </author> <title> editors. Language Prototyping AnAlgebraic Approach, </title> <booktitle> volume 5 of AMAST Series in Computing. World Scientific, </booktitle> <year> 1996. </year>
Reference-contexts: To mention Mosses " : : : the current structural operational semantics of action notation is not easy to modify; alternative forms of operational semantics, such as evolving-algebra semantics, might be preferable in that respect." [21] Another universal meta-language for all aspects of programming languages is ASF+SDF <ref> [25] </ref>. It is an initial-algebra approach and specifies the static and dynamic semantics by means of positive conditional equations.
Reference: [26] <author> C. Wallace. </author> <title> The Semantics of the C++ Programming Language. </title> <editor> In E. Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 131 - 164. </pages> <publisher> Oxford University Press, </publisher> <year> 1994. </year> <month> 16 </month>
Reference-contexts: The state transitions are given by rules that update functions pointwise and extend universes with new elements. ASMs have already been used to model the dynamic semantics of programming languages such as Pro-log [7], Occam [5], C [13], C++ <ref> [26] </ref>, Oberon [17], and VHDL [6]. At the risk of oversimplifying somewhat, we can describe some of these models [13, 26, 17] as follows. Program execution is modeled by the evolution of two functions CT and S. <p> ASMs have already been used to model the dynamic semantics of programming languages such as Pro-log [7], Occam [5], C [13], C++ [26], Oberon [17], and VHDL [6]. At the risk of oversimplifying somewhat, we can describe some of these models <ref> [13, 26, 17] </ref> as follows. Program execution is modeled by the evolution of two functions CT and S. The current task CT represents the part of the program text currently in execution and may be seen as an abstract program counter. S represents the current value of the store. <p> S represents the current value of the store. Formally one define the initial state of the functions and specifies how they evolve by means of transition rules. In the described models <ref> [13, 26, 17] </ref>, the initial state is assumed to include the results of a static analysis, which is only described informally. This analysis provides a representation of the program's control and data flow in the form of functions between parts of the program text.
References-found: 26

