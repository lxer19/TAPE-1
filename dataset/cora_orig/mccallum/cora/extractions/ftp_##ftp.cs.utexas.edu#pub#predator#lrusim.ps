URL: ftp://ftp.cs.utexas.edu/pub/predator/lrusim.ps
Refering-URL: http://www.cs.utexas.edu/users/schwartz/pub.htm
Root-URL: 
Email: (gjimenez,batory)@cs.utexas.edu  
Title: Memory Simulators and Software Generators  
Author: Guillermo Jimenez-Perez and Don Batory 
Address: Austin, Texas 78712  
Affiliation: Department of Computer Sciences The University of Texas at Austin  
Abstract: We present results on re-engineering a highly-tuned, hand-coded memory simulator using the P2 container data structure generator. This application was chosen because synthesizing the simulator's data structures would not exploit P2's primary advantage of automatically applying sophisticated code optimization techniques. Thus, we initially believed that using P2 would be an overkill and that P2-generated code would provide no performance advantages over hand-coding. On the contrary, we found that P2 produced more efficient code and that it offered significant advantages to software development that we had had not previously realized. 
Abstract-found: 1
Intro-found: 1
Reference: [Bat92] <author> Don Batory and Sean O'Malley. </author> <title> The design and implementation of hierarchical software systems with reusable components. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> October </month> <year> 1992. </year>
Reference-contexts: Domain modeling for transformational generators (e.g. DRACO [Nei91] and KIDS [Smi90]) can be quite different than that used for compositional generators (e.g. frameworks [Joh88]). However, the GenVoca design paradigm <ref> [Bat92] </ref> unifies important aspects of both compositional and transformational approaches by treating them as alternative ways of implementing GenVoca domain models. This is possible because GenVoca components represent stereotypical refinements that occur in a domain.
Reference: [Big87] <author> T. Biggerstaff and C. Richter. </author> <title> Reusability framework, assessment and directions. </title> <journal> IEEE Software, </journal> <pages> pages 41-49, </pages> <month> March </month> <year> 1987. </year>
Reference-contexts: Guillermo Jimenez was supported by the Instituto Tecnologico y de Estudios Superiores de Monterrey, Mexico. 1 Biggerstaff and Richter <ref> [Big87] </ref> observed that there are two rather different kinds of generator technologies: compositional and transformational. Both compose components in similar ways, but the nature of their components are quite different. Compositional components encapsulate the code that applications execute at run-time.
Reference: [Bat93a] <author> Don Batory, Vivek Singhal, Marty Sirkin, and Jeff Thomas. </author> <title> Scalable software libraries. </title> <address> Proc.ACM SIGSOFT'93, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: This paper presents results of reengineering a hand-coded application using the GenVoca data structures generator P2 <ref> [Bat93a, Bat94, Tho95] </ref>, and explores the advantages and disadvantages of using generators over hand-coding. But more importantly, our experiments shed light on the tradeoffs of choosing a compositional implementation over a transformational implementation of a domain model. Our target application is a C++ memory management simulator. <p> factors (e.g., dynamic compositions) may be much more important. 1 We have implemented the GenVoca domain model of container data structures both transformationally (e.g., the P2 generator) and compositionally (the P++ library [Sin96]). 2 2 The P2 Container Data Structures Generator P2 is a GenVoca generator of container data structures <ref> [Bat93a, Bat94, Tho95] </ref>. A container is a collection of elements that are instances of a single data type. Cursors reference and update elements of a container. Common data structures | arrays, binary trees, ordered lists, etc. | are implementations of containers. <p> Minor changes to a type expression can generate substantially different code. Usually, a P2 program includes only a few type equations and each equation is at most a few lines long. Thus, tuning and maintaining a P2 program is often a matter of changing a few lines and regenerating <ref> [Bat93a, Bat94] </ref>. 3 Locality of Reference Studies The Object-Oriented Programming Systems (OOPS) Research Group at The University of Texas at Austin is studying different aspects of memory management in operating systems [Wil95]. One project is to analyze the locality of references in memory hierarchies. <p> Key fields are expressed as annotations to a container declaration. These annotations are not shown in our declaration of page cont above, but are discussed in <ref> [Bat93a] </ref>. 5 has n pages, the level below it has k pages, etc., we can see how hits and misses behave in the memory hierarchy by seeing how page hits or misses concentrate between pages 1 and n, pages n + 1 to n + k, etc. <p> Thus, it is always possible that hand-coded applications can perform better than generated code. However, the issue is "how much effort is needed to do better than generated code?". The experiments in this paper (which in hindsight is also supported by our previous experiences <ref> [Bat93a, Bat94] </ref>) suggest that level of effort to optimize code manually to achieve the performance of generated code is far greater than any programmer would be willing to invest.
Reference: [Bat93b] <author> D. Batory and D. Vasavada. </author> <title> Software components for object-oriented database systems. </title> <journal> International Journal of Software Engineering and Knowledge Engineering, </journal> <volume> 3(2) </volume> <pages> 165-192, </pages> <year> 1993. </year>
Reference: [Bat94] <author> Don Batory, Jeff Thomas, and Marty Sirkin. </author> <title> Reengineering a complex application using a scalable data structure compiler. </title> <booktitle> Proc. ACM SIGSOFT, </booktitle> <year> 1994. </year>
Reference-contexts: This paper presents results of reengineering a hand-coded application using the GenVoca data structures generator P2 <ref> [Bat93a, Bat94, Tho95] </ref>, and explores the advantages and disadvantages of using generators over hand-coding. But more importantly, our experiments shed light on the tradeoffs of choosing a compositional implementation over a transformational implementation of a domain model. Our target application is a C++ memory management simulator. <p> factors (e.g., dynamic compositions) may be much more important. 1 We have implemented the GenVoca domain model of container data structures both transformationally (e.g., the P2 generator) and compositionally (the P++ library [Sin96]). 2 2 The P2 Container Data Structures Generator P2 is a GenVoca generator of container data structures <ref> [Bat93a, Bat94, Tho95] </ref>. A container is a collection of elements that are instances of a single data type. Cursors reference and update elements of a container. Common data structures | arrays, binary trees, ordered lists, etc. | are implementations of containers. <p> Minor changes to a type expression can generate substantially different code. Usually, a P2 program includes only a few type equations and each equation is at most a few lines long. Thus, tuning and maintaining a P2 program is often a matter of changing a few lines and regenerating <ref> [Bat93a, Bat94] </ref>. 3 Locality of Reference Studies The Object-Oriented Programming Systems (OOPS) Research Group at The University of Texas at Austin is studying different aspects of memory management in operating systems [Wil95]. One project is to analyze the locality of references in memory hierarchies. <p> Thus, it is always possible that hand-coded applications can perform better than generated code. However, the issue is "how much effort is needed to do better than generated code?". The experiments in this paper (which in hindsight is also supported by our previous experiences <ref> [Bat93a, Bat94] </ref>) suggest that level of effort to optimize code manually to achieve the performance of generated code is far greater than any programmer would be willing to invest. <p> From our best estimates, the C++ implementation is approximately 6650 lines of source code, whereas the P2 version is only 2550 lines, a 60 percent reduction in code volume. A factor of 2-3 improvement in productivity appears to be consistent with other uses of P2 <ref> [Bat94] </ref>. That generators also produce efficient code (for the reasons we cited earlier) makes their use that much more attractive. Software Maintainability. Generators can substantially improve software understandability, quality, and maintainability.
Reference: [Cme93] <author> Robert F. Cmelik and David Keppel. Shade: </author> <title> A fast instruction-set simulator for execution profiling. </title> <type> Technical Report UWCSE 93-06-06, </type> <institution> University of Washington, </institution> <year> 1993. </year>
Reference-contexts: This allows the OOPS group to obtain a better understanding of locality for different OS memory management design parameters and page eviction policies. Trace files of programs are generated using special tools, such as Shade <ref> [Cme93] </ref>, an instruction-set simulator and custom trace generator.
Reference: [Hen90] <author> John L. Hennessy and David A Patterson. </author> <title> Computer Architecture A Quantitative Approach. </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1990. </year>
Reference-contexts: To evaluate the performance of P2 generated code, we were given trace files by the OOPS group that they used previously in their performance studies. Our first benchmarks were the trace files, tex, cc1, and spice, that are commonly used to analyze different aspects related to memory usage <ref> [Hen90] </ref>. These files are relatively small compared to more "industrial strength" trace files p2c, expresso, and ghostscript, which are two orders of magnitude larger [Wil95, Wil96]. Running times for both the original C++ and P2 versions of LRUsim are shown in Table 1.
Reference: [Joh88] <author> R. E. Johnson and B. Foote. </author> <title> Designing reusable classes. </title> <journal> Journal of Object-Oriented Programming, </journal> <month> June/July </month> <year> 1988. </year>
Reference-contexts: Domain modeling for transformational generators (e.g. DRACO [Nei91] and KIDS [Smi90]) can be quite different than that used for compositional generators (e.g. frameworks <ref> [Joh88] </ref>). However, the GenVoca design paradigm [Bat92] unifies important aspects of both compositional and transformational approaches by treating them as alternative ways of implementing GenVoca domain models. This is possible because GenVoca components represent stereotypical refinements that occur in a domain.
Reference: [Nei91] <author> J. Neighbros. </author> <title> Draco: A method for engineering reusable software systems. </title> <editor> In R. Prieto-Diaz and G . Arango, editors, </editor> <title> Domain Analysis and Software Systems Modelling. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1991. </year>
Reference-contexts: Compositional technologies may be preferred over transformational technologies in domains where domain-specific optimizations play a minimal role in application performance or in domains where components must be composable at application run-time and cannot be limited to static compile-time compositions. Domain modeling for transformational generators (e.g. DRACO <ref> [Nei91] </ref> and KIDS [Smi90]) can be quite different than that used for compositional generators (e.g. frameworks [Joh88]). However, the GenVoca design paradigm [Bat92] unifies important aspects of both compositional and transformational approaches by treating them as alternative ways of implementing GenVoca domain models.
Reference: [Sim95] <author> C. Simonyi. </author> <title> The death of computer languages, the birth of intentional programming. Microsoft Research. Also, </title> <booktitle> NATO Science Committee Conference, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: Thus, as long as there are no ambiguities in the linguistic extensions that are being made, generators for different domains can be plugged and unplugged from the compiler. This advanced vision of 13 software componentry is being realized by the IP project at Microsoft Research <ref> [Sim95, Sma96] </ref> and the Jakarta project at the University of Texas at Austin. 6 Conclusions The power, capability, and potential of software generators continues to surprise us.
Reference: [Sin96] <author> Vivek Singhal. </author> <title> P++: A Language for Large-Scale Reusable Software. </title> <type> PhD thesis, </type> <institution> Dept. of Computer Sciences, The University of Texas at Austin, </institution> <year> 1996. </year>
Reference-contexts: suggests that performance may not be a critical factor in choosing between compositional and transformational implementation approaches; other factors (e.g., dynamic compositions) may be much more important. 1 We have implemented the GenVoca domain model of container data structures both transformationally (e.g., the P2 generator) and compositionally (the P++ library <ref> [Sin96] </ref>). 2 2 The P2 Container Data Structures Generator P2 is a GenVoca generator of container data structures [Bat93a, Bat94, Tho95]. A container is a collection of elements that are instances of a single data type. Cursors reference and update elements of a container.
Reference: [Sit96] <author> S. Sreerama, D. Fleming, and M. Sitaraman. </author> <title> Graceful object-based performace evolution. </title> <type> Technical report, </type> <institution> West Virginia University, </institution> <year> 1996. </year>
Reference-contexts: references all elements of the container, while a second cursor (selected page) references only elements that satisfy the predicate (touches &gt; 20). 3 cursor &lt;page_cont&gt; all_pages; // P2 declaration of a cursor that // ranges over all elements of page_cont 2 A similar approach using C++ templates is presented in <ref> [Sit96] </ref>. There component compositions are made through parameterization; plugging and unplugging is done by parameter substitution. 3 Note that predicates in P2 are expressed by strings: attribute A of the element referenced by a cursor is denoted $.A. <p> Software Maintainability. Generators can substantially improve software understandability, quality, and maintainability. An algorithm is easier to understand and maintain if it has a compact 10 A similar approach for component substitution was advocated in <ref> [Sit96] </ref>, with emphasis on performance evolution. 12 specification as a short function instead of a collection of collaborating functions. The P2 functions that define the LRU mechanism are very small. The largest has only 52 lines of code.
Reference: [Sma96] <author> Y. Smaragdakis and D. Batory. Distil: </author> <title> A transformation library for data structures. </title> <type> Technical Report in progress, </type> <institution> Department of Computer Sciences, The University of Texas at Austin, </institution> <year> 1996. </year>
Reference-contexts: Thus, as long as there are no ambiguities in the linguistic extensions that are being made, generators for different domains can be plugged and unplugged from the compiler. This advanced vision of 13 software componentry is being realized by the IP project at Microsoft Research <ref> [Sim95, Sma96] </ref> and the Jakarta project at the University of Texas at Austin. 6 Conclusions The power, capability, and potential of software generators continues to surprise us. <p> This approach essentially makes them non-interoperable with other generators (that extend a possibly different language). A key problem for GenVoca generators is building extensible programming languages that can modularly support the addition of multiple generator technologies in a seamless fashion. This too is a subject of our future work <ref> [Sma96] </ref>. Acknowledgements. We are grateful for the help, advice, and time that Paul Wilson, Doug van Wieren, Mark Johnstone, and other members of the OOPS group have contributed to our work. 14
Reference: [Smi90] <author> D. R. Smith. Kids: </author> <title> A semiautomatic program development system. </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> September </month> <year> 1990. </year>
Reference-contexts: Compositional technologies may be preferred over transformational technologies in domains where domain-specific optimizations play a minimal role in application performance or in domains where components must be composable at application run-time and cannot be limited to static compile-time compositions. Domain modeling for transformational generators (e.g. DRACO [Nei91] and KIDS <ref> [Smi90] </ref>) can be quite different than that used for compositional generators (e.g. frameworks [Joh88]). However, the GenVoca design paradigm [Bat92] unifies important aspects of both compositional and transformational approaches by treating them as alternative ways of implementing GenVoca domain models.
Reference: [Str91] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language, second edition. </title> <publisher> Addison-Wesley, </publisher> <year> 1991. </year>
Reference-contexts: This would enable experimentation with different structures | a limited version of that offered by P2 | simply by swapping one data structure template for another. Templates have the advantage that they don't compromise run-time efficiency, while permitting genericity <ref> [Str91] </ref>. In the following paragraphs, we explain the LRUsim data structures and their interrelationships. The core of LRUsim is the module that implements the LRU mechanism, called LRU mech. LRU mech maintains the LRU ordering of memory page references (touches).
Reference: [Tho95] <author> Jeff Thomas and Don Batory. P2: </author> <title> An extensible lightweight dbms. </title> <type> Technical Report TR-95-04, </type> <institution> Department of Computer Sciences, The University of Texas at Au stin, </institution> <month> February </month> <year> 1995. </year> <month> 15 </month>
Reference-contexts: This paper presents results of reengineering a hand-coded application using the GenVoca data structures generator P2 <ref> [Bat93a, Bat94, Tho95] </ref>, and explores the advantages and disadvantages of using generators over hand-coding. But more importantly, our experiments shed light on the tradeoffs of choosing a compositional implementation over a transformational implementation of a domain model. Our target application is a C++ memory management simulator. <p> factors (e.g., dynamic compositions) may be much more important. 1 We have implemented the GenVoca domain model of container data structures both transformationally (e.g., the P2 generator) and compositionally (the P++ library [Sin96]). 2 2 The P2 Container Data Structures Generator P2 is a GenVoca generator of container data structures <ref> [Bat93a, Bat94, Tho95] </ref>. A container is a collection of elements that are instances of a single data type. Cursors reference and update elements of a container. Common data structures | arrays, binary trees, ordered lists, etc. | are implementations of containers.
Reference: [Wil95] <author> Paul Wilson, Mark Johnstone, Michael Neely, and David Boles. </author> <title> Dynamic storage allo-cation: A survey and critical review. </title> <booktitle> International Workshop on Memory Management, </booktitle> <month> September </month> <year> 1995. </year>
Reference-contexts: Thus, tuning and maintaining a P2 program is often a matter of changing a few lines and regenerating [Bat93a, Bat94]. 3 Locality of Reference Studies The Object-Oriented Programming Systems (OOPS) Research Group at The University of Texas at Austin is studying different aspects of memory management in operating systems <ref> [Wil95] </ref>. One project is to analyze the locality of references in memory hierarchies. The goal is to show that locality of references is a consequence of regularities in both the structure of programs and in how memory allocators map program objects onto virtual address spaces [Wil96]. <p> Our first benchmarks were the trace files, tex, cc1, and spice, that are commonly used to analyze different aspects related to memory usage [Hen90]. These files are relatively small compared to more "industrial strength" trace files p2c, expresso, and ghostscript, which are two orders of magnitude larger <ref> [Wil95, Wil96] </ref>. Running times for both the original C++ and P2 versions of LRUsim are shown in Table 1. Although the original LRUsim C++ code had undergone several revisions and significant manual tunings, our first version using P2 ran a surprising 30 percent faster on all benchmarks.
Reference: [Wil96] <author> Paul Wilson. </author> <title> Locality of reference, patterns in program behavior, memory management, and memory hierarchies. </title> <type> Technical report, </type> <institution> The University of Texas at Austin, </institution> <year> 1996. </year> <month> 16 </month>
Reference-contexts: One project is to analyze the locality of references in memory hierarchies. The goal is to show that locality of references is a consequence of regularities in both the structure of programs and in how memory allocators map program objects onto virtual address spaces <ref> [Wil96] </ref>. OOPS research is experimentally driven: references of actual program executions are studied, rather than using randomly generated memory references. (The belief is that randomly generated memory references do not reflect the true usage of memory in real programs). <p> Our first benchmarks were the trace files, tex, cc1, and spice, that are commonly used to analyze different aspects related to memory usage [Hen90]. These files are relatively small compared to more "industrial strength" trace files p2c, expresso, and ghostscript, which are two orders of magnitude larger <ref> [Wil95, Wil96] </ref>. Running times for both the original C++ and P2 versions of LRUsim are shown in Table 1. Although the original LRUsim C++ code had undergone several revisions and significant manual tunings, our first version using P2 ran a surprising 30 percent faster on all benchmarks.
References-found: 18

