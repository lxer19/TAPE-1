URL: http://www.cs.utexas.edu/users/mcguire/research/postscript/thesis.ps.gz
Refering-URL: http://www.cs.utexas.edu/users/mcguire/research/thesis/
Root-URL: http://www.cs.utexas.edu
Title: Implementing Abstract Protocols in C example protocols and their implementations will be presented, including an
Author: Tommy Marcus McGuire, M.A. Supervisor: Mohamed G. Gouda 
Note: Several  Also, a reference has been provided for the functions in the suite.  
Address: Austin, 1994  
Affiliation: The University of Texas at  
Abstract: The goal of this work is the creation of a system to aid the implementation of a network communication protocol specified in the Abstract Protocol notation. The requirements of this system are primarily faithfulness to the formal notation and at least a semblance of efficiency. To this end, a suite of functions has been written to allow the creation of the processes involved in the protocol, originally specified in the Abstract Protocol notation, in the programming language C. The basic idea of the suite is the registration of functions whose execution affects the protocol state and which are enabled or disabled by the protocol state. The core of the suite is the function engine(), which invokes the functions in response to state changes. 1 This thesis was presented to the faculty of the Graduate School of The University of Texas at Austin in December, 1994. This edition has also been published as Technical Report TR96-31 from the Department of Computer Sciences at The University of Texas at Austin. 
Abstract-found: 1
Intro-found: 1
Reference: [Barnes 82] <author> Barnes, J.G.P. </author> <booktitle> Programming in ADA. </booktitle> <address> Wokingham, England: </address> <publisher> Addison-Wesley, </publisher> <year> 1982. </year>
Reference-contexts: However, the gap between the specification and the implementation remains. For the most part, this is due to the relatively low-level nature of the communication primitives supplied by many operating systems and programming languages. The most advanced of these languages, such as Ada <ref> [Barnes 82] </ref> and Distributed C [Pleier 93], provide primitives for sending and receiving messages as well as structures such as select for building a networking protocol from those primitives.
Reference: [Brown 91] <author> Brown, Geoffrey M., Mohamed G. Gouda, and Raymond E. Miller. </author> <title> "Block Acknowledgment: Redesigning the Window Protocol." </title> <journal> IEEE Transactions on Communications, </journal> <volume> Vol. 39, No. </volume> <month> 4 (April </month> <year> 1991). </year>
Reference-contexts: Its syntax is very simple. Combined with protocol properties stated in its notation, it offers a set of proof obligations that make ensuring that a protocol satisfies a certain property relatively easy. For more information, see <ref> [Brown 91] </ref>, [Burns 93], [Gouda 91], and [Gouda 93]. However, the gap between the specification and the implementation remains. For the most part, this is due to the relatively low-level nature of the communication primitives supplied by many operating systems and programming languages.
Reference: [Burns 93] <author> Burns, James E., Mohamed G. Gouda, and Raymond E. Miller. </author> <title> "Stabilization and pseudo-stabilization." </title> <booktitle> Distributed Computing, </booktitle> <month> 7 </month> <year> (1993). </year>
Reference-contexts: Its syntax is very simple. Combined with protocol properties stated in its notation, it offers a set of proof obligations that make ensuring that a protocol satisfies a certain property relatively easy. For more information, see [Brown 91], <ref> [Burns 93] </ref>, [Gouda 91], and [Gouda 93]. However, the gap between the specification and the implementation remains. For the most part, this is due to the relatively low-level nature of the communication primitives supplied by many operating systems and programming languages.
Reference: [Gouda 91] <author> Gouda, Mohamed G., and Nicholas J. Multari. </author> <title> "Stabilizing Communication Protocols." </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. </volume> <pages> 40, </pages> <note> No 4 (April 1991). </note>
Reference-contexts: Its syntax is very simple. Combined with protocol properties stated in its notation, it offers a set of proof obligations that make ensuring that a protocol satisfies a certain property relatively easy. For more information, see [Brown 91], [Burns 93], <ref> [Gouda 91] </ref>, and [Gouda 93]. However, the gap between the specification and the implementation remains. For the most part, this is due to the relatively low-level nature of the communication primitives supplied by many operating systems and programming languages.
Reference: [Gouda 93] <author> Gouda, Mohamed G. </author> <title> "Protocol verification made simple: a tutorial." </title> <booktitle> Computer Networks and ISDN Systems, </booktitle> <month> 25 </month> <year> (1993). </year>
Reference-contexts: Its syntax is very simple. Combined with protocol properties stated in its notation, it offers a set of proof obligations that make ensuring that a protocol satisfies a certain property relatively easy. For more information, see [Brown 91], [Burns 93], [Gouda 91], and <ref> [Gouda 93] </ref>. However, the gap between the specification and the implementation remains. For the most part, this is due to the relatively low-level nature of the communication primitives supplied by many operating systems and programming languages.
Reference: [Knuth 86] <author> Knuth, Donald E. </author> <title> T E X: The Program. </title> <address> Reading, Massachusetts: </address> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: These groups are marked off from the sur- rounding text by thin horizontal lines. For more information on structured documentation, see [Knuth 92], [Sewell 89], <ref> [Knuth 86] </ref>, and [Knuth 93]. 5 6 Chapter 2 Language Issues 2.1 Abstract Protocols This section will present a brief look at those aspects of AP which are used by the example protocols described later|most of these aspects are either unique to AP or raise significant implementation issues.
Reference: [Knuth 92] <author> Knuth, Donald E. </author> <title> hh Literate Programmingii. </title> <booktitle> Center for the Study of Language and Information Lecture Notes Number 27 (1992). </booktitle>
Reference-contexts: These groups are marked off from the sur- rounding text by thin horizontal lines. For more information on structured documentation, see <ref> [Knuth 92] </ref>, [Sewell 89], [Knuth 86], and [Knuth 93]. 5 6 Chapter 2 Language Issues 2.1 Abstract Protocols This section will present a brief look at those aspects of AP which are used by the example protocols described later|most of these aspects are either unique to AP or raise significant implementation
Reference: [Knuth 93] <author> Knuth, Donald E. </author> <title> The Stanford GraphBase. </title> <address> New York: </address> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: These groups are marked off from the sur- rounding text by thin horizontal lines. For more information on structured documentation, see [Knuth 92], [Sewell 89], [Knuth 86], and <ref> [Knuth 93] </ref>. 5 6 Chapter 2 Language Issues 2.1 Abstract Protocols This section will present a brief look at those aspects of AP which are used by the example protocols described later|most of these aspects are either unique to AP or raise significant implementation issues.
Reference: [Pleier 93] <author> Pleier, Christoph. </author> <title> "The Distributed C Development Environment." </title> <institution> In-stitut fur Informatik, Technische Universitat Munchen, </institution> <year> 1993. </year>
Reference-contexts: However, the gap between the specification and the implementation remains. For the most part, this is due to the relatively low-level nature of the communication primitives supplied by many operating systems and programming languages. The most advanced of these languages, such as Ada [Barnes 82] and Distributed C <ref> [Pleier 93] </ref>, provide primitives for sending and receiving messages as well as structures such as select for building a networking protocol from those primitives. However, they are based on the idea of communicating sequential processes rather than on reactive systems which respond to state changes with action.
Reference: [Sewell 89] <author> Sewell, Wayne. </author> <title> Weaving a Program: Literate Programming in WEB. </title> <address> New York: </address> <publisher> Van Nostrand Reinhold, </publisher> <year> 1989. </year>
Reference-contexts: These groups are marked off from the sur- rounding text by thin horizontal lines. For more information on structured documentation, see [Knuth 92], <ref> [Sewell 89] </ref>, [Knuth 86], and [Knuth 93]. 5 6 Chapter 2 Language Issues 2.1 Abstract Protocols This section will present a brief look at those aspects of AP which are used by the example protocols described later|most of these aspects are either unique to AP or raise significant implementation issues.
Reference: [Stevens 90] <author> Stevens, W. Richard. </author> <title> UNIX Network Programming. </title> <address> Englewood Cliffs, New Jersey: </address> <publisher> PTR Prentice Hall, </publisher> <year> 1990. </year> <month> 75 </month>
Reference-contexts: It is not obvious that translation between AP and the structures such as select would be easy. More widely available systems, such as the Unix socket interface <ref> [Stevens 90] </ref>, do not even provide the framework available in Ada; the focus in these systems is only on the sending and receiving primitives. The large gap between an AP specification and its implementation in C using TCP/IP sockets lies primarily in bookkeeping, syntax, and structure.
References-found: 11

