URL: ftp://ftp.cs.man.ac.uk/pub/fac/FACj_7E_pp67-110.ps.Z
Refering-URL: http://www.cs.man.ac.uk/fmethods/facj/e-papers/index.html
Root-URL: http://www.cs.man.ac.uk
Email: email: flone,btg@ecrc.de  
Title: of Computing Some Facile Chemistry  
Author: Lone Leth and Bent Thomsen 
Keyword: Chemical abstract machines; Structural operational semantics; Functional concurrent programming; CML; Facile; Poly/ML; Distribution; Channel management.  
Address: Munich, Germany  
Affiliation: European Computer-Industry Research Centre,  
Note: Formal Aspects of Computing (1995) 7(E): 67-110 c 1995 BCS Formal Aspects  
Abstract: In this paper we use the chemical abstract machine (CHAM) framework [BeB90, BeB92, Bou94] for discussing various semantics for the Facile programming language [GMP89, GMP90, FAR93] and for formalising (parts of) its implementations. We use these formal descriptions to argue (informally) about implementability and cost of implementation in terms of low level machinery needed to implement the given semantics. We take the Facile language as source for discussion, but the results also apply to several other new languages such as CML [Rep91, BMT92] and Poly/ML [Mat91]. Characteristic for all these languages is that they combine ideas from the -calculus and process algebra, such as CCS [Mil80, Mil89], to support high level constructs for programming concurrent, parallel and/or distributed systems. This paper may also be seen as a case study in comparing semantic descriptions using structural operational semantics [Plo81] and the chemical abstract machine framework [BeB90, BeB92, Bou94]. 
Abstract-found: 1
Intro-found: 1
Reference: [ALP93] <author> Andreoli, J.-M., Leth, L., Pareschi, R., Thomsen, B.: </author> <title> True Concurrency Semantics for a Linear Logic Programming Language with Broadcast Communication, </title> <journal> pp. </journal> <pages> 182-198, </pages> <booktitle> Proceedings of TAPSOFT'93, </booktitle> <publisher> LNCS 668, Springer-Verlag, </publisher> <year> 1993. </year>
Reference-contexts: Each particular machine is defined by adding a set of simple rules that specify how to generate new molecules from old ones. The framework has been used to specify CHAMs for CCS and the fl-calculus in [BeB90], for LCCS in [Let91], for the -calculus in [BeB92], for LO in <ref> [ALP93] </ref> and for the weak -calculus with sharing in [Bou94]. In this paper we cast the Facile semantics in the CHAM framework 1 . We use the CHAM framework for experimenting with the Facile language by introducing various semantic interpretations for the choice operator. <p> Consistency can be achieved by group communication protocols such as ISIS [BJS87, Bir93]. The ISIS protocols heavily rely on broadcast communication. Modelling this in the CHAM framework is beyond the scope of this paper (see <ref> [ALP93] </ref> for an example of how to use the CHAM framework to model broadcasting).
Reference: [App89] <author> Appel, A.W.: </author> <title> Continuation-Passing, Closure-Passing Style, </title> <booktitle> in Proceedings of POPL'89, </booktitle> <year> 1989. </year>
Reference-contexts: In the current state of the project three versions of the language supporting polymorphic types have been implemented by extending the ML language [MTH90] with the concurrency constructs of Facile [KrC91, Kuo92, FAR93]. These implementations use continuations, as found in the Standard ML of New Jersey (SML/NJ) implementation <ref> [App89] </ref>, for introducing concurrency. Con-currency is simulated using continuations in [Kuo92], and in [KrC91, FAR93] concurrency is obtained by scheduling between user level continuations. Furthermore, the latter two implementations support true distributed computing on networks of homogeneous hardware (currently Sun4 or SPARC machines).
Reference: [BeB90] <author> Berry, G., Boudol, G.: </author> <title> The Chemical Abstract Machine, </title> <booktitle> in Proceedings of POPL'90, </booktitle> <year> 1990. </year>
Reference-contexts: Furthermore, the latter two implementations support true distributed computing on networks of homogeneous hardware (currently Sun4 or SPARC machines). Recently a new framework for the description of concurrent systems, called chemical abstract machines (CHAMs), has been proposed <ref> [BeB90, BeB92, Bou94] </ref>. The basic idea of the CHAM is that the state of a system is like a chemical solution where molecules float around. These molecules can interact with each other according to reaction rules. <p> CHAMs all obey a simple set of structural laws. Each particular machine is defined by adding a set of simple rules that specify how to generate new molecules from old ones. The framework has been used to specify CHAMs for CCS and the fl-calculus in <ref> [BeB90] </ref>, for LCCS in [Let91], for the -calculus in [BeB92], for LO in [ALP93] and for the weak -calculus with sharing in [Bou94]. In this paper we cast the Facile semantics in the CHAM framework 1 . <p> This paper may also be seen as a case study in comparing semantic descriptions using SOS and the CHAM framework. The paper is not structured around such a study and the study is not conclusive, but we have found (or further substantiated the observations in <ref> [BeB90] </ref>) that traditional structural operational semantics [Plo81] equipped with a notion of observable behaviour is in general useful for expressing external behaviour of systems. On the other hand, the CHAM seems to be advantageous when describing internal system architecture and behaviour. <p> The CHAM framework has also allowed us to work in an incremental way when moving from one semantics to another. It seems to be difficult to use this approach when designing SOS. In <ref> [BeB90] </ref> it is shown that the SOS and the CHAM frameworks are equally expressive when instantiated to particular cases e.g. CCS or the fl-calculus. Where relevant in this paper we show how the SOS and the CHAM semantics for Facile are related. <p> Furthermore we discuss aspects of physical distribution, in particular channel management in distributed implementations of Facile, still within the CHAM framework. Finally we give some concluding remarks in Section 7. 70 L. Leth and B. Thomsen 2. Brief Introduction to the CHAM Framework The basic idea of the CHAM <ref> [BeB90] </ref> is that the state of a system is like a chemical solution where molecules float around. These molecules can interact with each other according to some reaction rules. Possible contact between molecules is provided for by some means of a stirring mechanism. <p> A solution consisting of an instance of a left hand side of a reaction rule can be substituted by a solution consisting of the corresponding instance of the right hand side of the rule. In addition to the reaction laws there are three general laws <ref> [BeB90] </ref> 2 : 1. The chemical law S ! S 0 describes how parts of a multiset can be rewritten. 2. The membrane law S ! S 0 states that a solution can be rewritten inside any subsolution. <p> Reaction represents communication on matching input and output channels, and fi-reduction results in applying a function to a value and thus binding the variable. Note that the fi-reduction rule uses context rewrite, not the CHAM mechanism as in the CHAM semantics for the fl-calculus given in <ref> [BeB90] </ref>. Applying the Spawn rule results in a new process executing in parallel with the spawning process, the Channel rule creates a new channel not introduced previously and the Code rule implies activating a process script. To execute a Facile behaviour be we start from the initial solution 82 L. <p> However, this rule must only be applied when further communications are impossible. This requires "global knowledge" of the system, which is contrary to the philosophy of the CHAM framework <ref> [BeB90] </ref>. In a real implementation this would amount to doing distributed garbage collection on stuck processes. This is feasible, but in general undesirable. Actually it is possible to code internal choice in Facile in such a way that garbage collection of stuck processes is not needed. <p> A CHAM for Facile with External Choice (Facile ) In the following we discuss Facile with the TCCS notion of external () choice. In the development of the CHAM we use the ideas about pairing and projection found in <ref> [BeB90] </ref>. <p> This semantics for the choice operator might limit the parallelism in the system due to the necessity of freezing communications and computations as mentioned above. In a distributed environment this is unfeasible because of the need for freezing the global state. Readers familiar with <ref> [BeB90] </ref> will notice that the o molecule replaces the notion of external observer discussed in [BeB90]. This allows us to stay within the CHAM framework. <p> In a distributed environment this is unfeasible because of the need for freezing the global state. Readers familiar with <ref> [BeB90] </ref> will notice that the o molecule replaces the notion of external observer discussed in [BeB90]. This allows us to stay within the CHAM framework. The o molecule plays a similar role as the K molecule discussed for channel name management, and in a real implementation this may become a bottleneck. <p> On the other hand, the CHAM seems to be advantageous when describing internal system architecture and behaviour. It is possible to extend the CHAM framework with a notion of external observation using air-locks to extract ions following ideas Some Facile Chemistry 109 from <ref> [BeB90] </ref>. Thus it is possible to relate all aspects of an SOS with a CHAM. However, it seems to be rather cumbersome and so far it has only been done on a case by case basis.
Reference: [BeB92] <author> Berry, G., Boudol, G.: </author> <title> The chemical abstract machine, </title> <journal> TCS 96, </journal> <pages> pp. 217-248, </pages> <year> 1992. </year>
Reference-contexts: Furthermore, the latter two implementations support true distributed computing on networks of homogeneous hardware (currently Sun4 or SPARC machines). Recently a new framework for the description of concurrent systems, called chemical abstract machines (CHAMs), has been proposed <ref> [BeB90, BeB92, Bou94] </ref>. The basic idea of the CHAM is that the state of a system is like a chemical solution where molecules float around. These molecules can interact with each other according to reaction rules. <p> Each particular machine is defined by adding a set of simple rules that specify how to generate new molecules from old ones. The framework has been used to specify CHAMs for CCS and the fl-calculus in [BeB90], for LCCS in [Let91], for the -calculus in <ref> [BeB92] </ref>, for LO in [ALP93] and for the weak -calculus with sharing in [Bou94]. In this paper we cast the Facile semantics in the CHAM framework 1 . We use the CHAM framework for experimenting with the Facile language by introducing various semantic interpretations for the choice operator. <p> C [ ] denotes a molecule with a hole [ ] in which to place another molecule. 3. The (reversible) airlock law, presented in some CHAMs, fj m jg ] S ! fj m / S jg 2 In <ref> [BeB92] </ref> four general laws are mentioned since a general reaction law which instantiates the specific rewrite rules for each CHAM is defined. Some Facile Chemistry 71 converts any arbitrary solution into a singleton solution, isolating the molecule m. <p> This is a very good example of how the CHAM framework makes the semantic presentation easier compared to the SOS, where the K component has to be present in all the inference rules. A similar treatment of restriction in the -calculus is discussed in <ref> [BeB92] </ref>. To execute a Facile behaviour be we have to start with the initial solution S 0 = fj be; ; jg. If we assume that each molecule in a CHAM represents a process or a resource then channel creation will demand some synchronisation with the channel name manager. <p> the following rules: act C [chan]; (K; S) ! act C [k]; (K [ fkg; S n fkg) act C [chan]; (K; ;) ! act C [error]; (K; ;) An alternative and perhaps more abstract solution to channel name management has been proposed in [Mil90] and was also considered in <ref> [BeB92] </ref>. In this approach molecules of the form k:m are introduced. These molecules are viewed as having k restricted in such a way that ions with k in their valence (i.e. being ready to communicate over the k channel) are prohibited from reactions.
Reference: [BMT92] <author> Berry, D., Milner, R., Turner, D.N.: </author> <title> A semantics for ML concurrency primitives, </title> <booktitle> in Proceedings of POPL'92, </booktitle> <pages> pp. 119-129, </pages> <year> 1992. </year>
Reference-contexts: CCS or the fl-calculus. Where relevant in this paper we show how the SOS and the CHAM semantics for Facile are related. We have taken the Facile language as source for discussion, but the results also apply to several other new languages such as CML <ref> [Rep91, BMT92] </ref> and Poly/ML [Mat91]. Characteristic for all these languages is that they combine ideas from the -calculus and process algebra, such as CCS [Mil80, Mil89], to support high level constructs for programming concurrent, parallel and/or distributed systems. The outline of the paper is as follows.
Reference: [BJS87] <author> Birman, K., P., Joseph, T. & Schmuck, F.: </author> <title> ISIS A Distributed Programming Environment, Version 2.1 - User's Guide and Reference Manual, </title> <month> July, </month> <year> 1987. </year>
Reference-contexts: One way to improve this situation is to replicate the channel manager on each node and keep the replicae consistent. Consistency can be achieved by group communication protocols such as ISIS <ref> [BJS87, Bir93] </ref>. The ISIS protocols heavily rely on broadcast communication. Modelling this in the CHAM framework is beyond the scope of this paper (see [ALP93] for an example of how to use the CHAM framework to model broadcasting).
Reference: [Bir93] <author> Birman, K.: </author> <title> The Process group Approach to Reliable Distributed Computing, </title> <journal> Communication of the ACM, </journal> <month> December, </month> <year> 1993. </year>
Reference-contexts: One way to improve this situation is to replicate the channel manager on each node and keep the replicae consistent. Consistency can be achieved by group communication protocols such as ISIS <ref> [BJS87, Bir93] </ref>. The ISIS protocols heavily rely on broadcast communication. Modelling this in the CHAM framework is beyond the scope of this paper (see [ALP93] for an example of how to use the CHAM framework to model broadcasting).
Reference: [Bou85] <author> Boudol, G.: </author> <booktitle> Notes on algebraic calculi of processes, Logics and Models of Concurrent Systems, NATO ASI Series F13,K. </booktitle> <editor> Apt, Ed. </editor> <year> (1985). </year>
Reference-contexts: obtained by the following program, where e; be is shorthand for act (x:code (be))e, provided x does not occur free in be: act (x:code (x?; be jj x?; be 0 jj x!triv; term))chan Coding of internal choice in terms of communication, parallel composition and restriction was first studied in MEIJE <ref> [Bou85] </ref> where choice is not treated as a primitive operator. This only simulates the effect of since it leaves one of the threads x?; be or x?; be 0 ready to receive, but no further communications will be possible.
Reference: [Bou89] <author> Boudol, G.: </author> <title> Towards a Lambda-Calculus for Concurrent and Communicating Systems, </title> <booktitle> in Proceedings of TAPSOFT 89, Lecture Notes in Computer Science 351, </booktitle> <pages> pp. 149-161, </pages> <year> 1989. </year>
Reference: [Bou92] <author> Boudol, G.: </author> <title> Asynchrony and the -calculus, Note, </title> <institution> INRIA Sophia-Antipolis, </institution> <year> 1992. </year>
Reference-contexts: Leth and B. Thomsen Thus asynchronous messages become molecules in their own right and float around in the solution until they react with molecules ready to receive. This semantics bears some resemblance with the work in [HoT91] as well as the work in <ref> [Bou92] </ref>. It is easy to derive a description for an implementation of asynchronous communication from the CHAMs for formalising parts of the Facile implementation.
Reference: [Bou94] <author> Boudol, G.: </author> <title> Some Chemical Abstract Machines, Note, </title> <institution> INRIA Sophia-Antipolis, </institution> <year> 1994. </year>
Reference-contexts: Furthermore, the latter two implementations support true distributed computing on networks of homogeneous hardware (currently Sun4 or SPARC machines). Recently a new framework for the description of concurrent systems, called chemical abstract machines (CHAMs), has been proposed <ref> [BeB90, BeB92, Bou94] </ref>. The basic idea of the CHAM is that the state of a system is like a chemical solution where molecules float around. These molecules can interact with each other according to reaction rules. <p> The framework has been used to specify CHAMs for CCS and the fl-calculus in [BeB90], for LCCS in [Let91], for the -calculus in [BeB92], for LO in [ALP93] and for the weak -calculus with sharing in <ref> [Bou94] </ref>. In this paper we cast the Facile semantics in the CHAM framework 1 . We use the CHAM framework for experimenting with the Facile language by introducing various semantic interpretations for the choice operator.
Reference: [FeF89] <author> Felleisen, M., Friedman, </author> <title> D.P.: A syntactic theory of sequential state, </title> <journal> TCS 69(3), </journal> <pages> pp. 243-287, </pages> <year> 1989. </year>
Reference-contexts: The theorem is constructive in the sense that we may algorithmically calculate the unique context C and thus find the next redex r for each transition. The 6 The correspondence between evaluation contexts and continuations has recently been studied by several authors (see e.g. <ref> [FeF89] </ref>) 80 L. Leth and B. Thomsen following algorithm constructs C and r from a given e. This is done by working structurally through e.
Reference: [Gla92] <author> Glauert, J.: </author> <title> Asynchronous Mobile Processes and Graph Rewriting, </title> <booktitle> Proceedings of the PARLE'92 Conference, </booktitle> <publisher> LNCS 605, Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: OQ [ fvg) ! act C [v]; k:(;; OQ) act C [k!v]; k:(IQ [ fC 0 g; ;) ! act C [triv]; act C 0 [v]; k:(IQ; ;) act C [k?]; k:(IQ; ;) ! k:(IQ [ fCg; ;) This implementation technique has been used to implement the -calculus in Dactl <ref> [Gla92] </ref>. It should be noted that none of the two CHAMs above necessarily keep the original order of messages. However, this can be encoded by providing a FIFO discipline on the queues.
Reference: [GMP89] <author> Giacalone, A., Mishra, P., Prasad, S.: </author> <title> Facile: a symmetric integration of concurrent and functional programming, </title> <journal> International Journal of Parallel Programming, </journal> <volume> Vol 18, No. 2, </volume> <pages> pp. 121-160, </pages> <year> 1989. </year>
Reference-contexts: 1. Introduction The work presented in this paper has been carried out in the context of the Facile project at ECRC. This project has as its main objective to provide powerful support for developing applications that require both distributed computation and complex information processing. The Facile language <ref> [GMP89, GMP90, FAR93] </ref> is an experimental programming language resulting from a concrete attempt to integrate the typed call-by-value -calculus with a process language similar to Correspondence and offprint requests to: Lone Leth and Bent Thomsen, European Computer Industry Research Centre, Arabellastrasse 17, D-81925, Munich, Germany 68 L. Leth and B. <p> When the initial design of Facile took place the interpretation of the %- operator was intentionally left somewhat open <ref> [GMP89] </ref>. <p> The former transitions should not trigger the choice, whereas the latter must do so to simulate the SOS correctly. This problem was first noticed in the CFAM description of Facile <ref> [GMP89] </ref>. It should be mentioned that no existing Facile implementation follows this semantics either. From the above discussion we conclude that the CCS choice operator might not be a good primitive to implement.
Reference: [GMP90] <author> Giacalone, A., Mishra, P., Prasad, S., </author> <title> Operational and Algebraic Semantics for Facile: A Symmetric Integration of Concurrent and Functional Programming, </title> <booktitle> in Proceedings of ICALP 90, Lecture Notes in Computer Science 443, </booktitle> <pages> pp. 765-780, </pages> <year> 1990. </year>
Reference-contexts: 1. Introduction The work presented in this paper has been carried out in the context of the Facile project at ECRC. This project has as its main objective to provide powerful support for developing applications that require both distributed computation and complex information processing. The Facile language <ref> [GMP89, GMP90, FAR93] </ref> is an experimental programming language resulting from a concrete attempt to integrate the typed call-by-value -calculus with a process language similar to Correspondence and offprint requests to: Lone Leth and Bent Thomsen, European Computer Industry Research Centre, Arabellastrasse 17, D-81925, Munich, Germany 68 L. Leth and B. <p> The language also has static typing. A monomorphic type system was defined in <ref> [GMP90] </ref>. A formal definition of a polymorphic type system for Facile has recently been investigated in [Tho93]. <p> At the theoretical level, a structural operational semantics (SOS) [Plo81] has been developed in terms of labelled transition systems, and a notion of observability of programs is defined by extending the notion of bisimulation <ref> [GMP90] </ref>. An SOS covering aspects of physical distribution, time dependent behaviour and exceptions has been developed in [TLG92]. Conceptually a distributed Facile system consists of a collection of nodes, each supporting the (simulated) concurrent execution of Facile processes. <p> This has allowed us to justify design issues and implementation decisions before carrying out a full scale implementation effort. We use the formal CHAM semantics to give 1 The abstract syntax and SOS is based on <ref> [GMP90] </ref> and [TLG92]. See [FAR93] for the concrete programming syntax. <p> This means that solutions can be evaluated in parallel. However, parallel evaluation is not a requirement since a non-conflicting parallel application of rules is equivalent to applying the individual rules in any sequence. 3. Syntax and Semantics of Facile The Facile language, as defined in <ref> [GMP90] </ref>, consists of two parts; an expression part (the functions) and a behaviour expression part (the processes). Facile expressions are statically typed. The type system defined in [GMP90] gives type judgements of the form A ` e : t where A is a type environment and t is a type. <p> Syntax and Semantics of Facile The Facile language, as defined in <ref> [GMP90] </ref>, consists of two parts; an expression part (the functions) and a behaviour expression part (the processes). Facile expressions are statically typed. The type system defined in [GMP90] gives type judgements of the form A ` e : t where A is a type environment and t is a type. The judgements are to be read as: "in the type environment A the expression e has type t". <p> Substituting an expression for a variable with the usual avoidance of accidental binding is denoted by efe 0 =xg. For a formal definition of these concepts see <ref> [GMP90] </ref>. Normally we only need to substitute values for variables. <p> When the initial design of Facile took place the interpretation of the %- operator was intentionally left somewhat open [GMP89]. In <ref> [GMP90, Pra91a] </ref> the operator was given an interpretation corresponding to the CCS choice operator + (where the choice between two processes is triggered by the first action, internal or external, of any of the two processes) since this operator is the most general from a mathematical point of view. <p> CCS choice operator is denoted Facile + , Facile with the TCCS internal choice operator is denoted Facile , Facile with the TCCS external choice operator is denoted Facile and Facile with the choice resolved at communication time is denoted Facile 2 . 3 activate is the syntax introduced in <ref> [GMP90] </ref>. Here we use act instead to save space. Similarly we use chan for channel and term for terminate. Some Facile Chemistry 73 The operational semantics for Facile is given in terms of a labelled transition system (LTS). <p> The core of the semantics is expressed by the last four rules given below. The first two of these rules define the transitions (potentially) generated by the guard values sGuard and rGuard once their arguments have been reduced to 4 alternative is the syntax introduced in <ref> [GMP90] </ref>. Here we use alt instead to save space. Similarly we use rGuard for receiveGuard and sGuard for sendGuard. 74 L. Leth and B. Thomsen Table 1. Operational semantics for Facile . <p> A distributed Facile system executes in a collection of nodes, each supporting the (simulated) concurrent execution of Facile processes. Nodes can be dynamically created, processes can be activated at specific nodes, and communication over channels may occur between different nodes. The Facile language, as defined in <ref> [GMP90] </ref>, is extended by introducing a newnode operator for creating nodes and by modifying the spawn operator to allow for spawning processes at specific nodes. <p> Conclusion In this paper we have shown how the CHAM framework can be used for experimenting with various semantics for the choice operator (the %-operator) in Facile. We have seen that even though an interpretation of the %-operator corresponding to the CCS choice operator, as suggested in <ref> [GMP90, Pra91a] </ref>, is the most general from a mathematical point of view, it may be difficult to implement and it will be expensive in terms of low level machinery.
Reference: [Gri90] <author> Griffin, T. G.: </author> <title> A Formulae-as-Types Notion of Control, </title> <booktitle> in Proceedings of POPL'90, </booktitle> <year> 1990. </year>
Reference-contexts: In this section we shall extend a result about ISWIM to Facile. The extension of this result to Facile expressions will allow us to focus on behaviour expressions, and at the same time preserve the call-by-value semantics for expressions. Some Facile Chemistry 79 For ISWIM the following holds <ref> [Gri90] </ref>: e ! e 0 iff 9!C; r: e = C [r]; e 0 = C [e 00 ]; r ! e 00 : where C is an evaluation context of the form C ::= [ ] Ce vC and r is a redex of the form (x:e)v.
Reference: [HdN87] <author> Hennessy, M., de Nicola, R.: </author> <title> CCS without o 's, </title> <booktitle> Lecture Notes in Computer Science 249, </booktitle> <pages> pp. 138-152, </pages> <year> 1987. </year> <title> 110 L. </title> <editor> Leth and B. </editor> <publisher> Thomsen </publisher>
Reference-contexts: In [Pra91b] it was proposed to adopt an interpretation corresponding either to the TCCS <ref> [HdN87] </ref> internal choice operator (where the choice between two processes is decided non-deterministically by the system) or the TCCS external choice operator (where the choice between two processes is decided by communication with an external process) or in fact having both operators in the language. <p> Recall that the SOS for this choice operator specifies that the choice may be triggered by an external communication as well as an internal transition in either branch. From a mathematical point of view this choice operator is possibly the simplest and most general <ref> [Mil89, HdN87] </ref>. 88 L. Leth and B.
Reference: [HoT91] <author> Honda, K., Tokoro, M.: </author> <title> An object calculus for asynchronous communication, </title> <booktitle> in Proceedings of ECOOP'91, </booktitle> <year> 1991. </year>
Reference-contexts: Leth and B. Thomsen Thus asynchronous messages become molecules in their own right and float around in the solution until they react with molecules ready to receive. This semantics bears some resemblance with the work in <ref> [HoT91] </ref> as well as the work in [Bou92]. It is easy to derive a description for an implementation of asynchronous communication from the CHAMs for formalising parts of the Facile implementation.
Reference: [Kna93] <author> Knabe, F.: </author> <title> "A Distributed Protocol for Channel-Based Communication with Choice," </title> <journal> Computers and Artificial Intelligence, </journal> <volume> Volume 12, Number 5, </volume> <year> 1993, </year> <pages> pp. 475-490. </pages>
Reference-contexts: It is quite a tricky issue and boils down to encoding one of several protocols for implementing distributed choice. A good overview of the problem and a particular solution to the problem of distributed choice in Facile may be found in <ref> [Kna93] </ref>. The distributed channel management scheme obviously changes the semantics of communication slightly when communication involves more than one node since there now is a potential for failures. However, the failure model is quite clear and does not put a great burden on the implementation when failures are acceptable.
Reference: [KrC91] <author> Kramer, A., Cosquer, F.: </author> <title> Distributing Facile, MAGIC Note 12, </title> <address> ECRC, </address> <year> 1991 </year> <month> 8 </month> . 
Reference-contexts: In the current state of the project three versions of the language supporting polymorphic types have been implemented by extending the ML language [MTH90] with the concurrency constructs of Facile <ref> [KrC91, Kuo92, FAR93] </ref>. These implementations use continuations, as found in the Standard ML of New Jersey (SML/NJ) implementation [App89], for introducing concurrency. Con-currency is simulated using continuations in [Kuo92], and in [KrC91, FAR93] concurrency is obtained by scheduling between user level continuations. <p> These implementations use continuations, as found in the Standard ML of New Jersey (SML/NJ) implementation [App89], for introducing concurrency. Con-currency is simulated using continuations in [Kuo92], and in <ref> [KrC91, FAR93] </ref> concurrency is obtained by scheduling between user level continuations. Furthermore, the latter two implementations support true distributed computing on networks of homogeneous hardware (currently Sun4 or SPARC machines). <p> Note that external transitions produced during the evaluation of a guard will not trigger a choice. Only when each guard and all arguments to these guards have been evaluated to values, an external transition which may trigger the choice will be produced. The implementations of Facile described in <ref> [KrC91, FAR93] </ref> make programming in a physically distributed environment possible. In the following we discuss the extensions to the language which have to do with the locations where processes execute. A distributed Facile system executes in a collection of nodes, each supporting the (simulated) concurrent execution of Facile processes. <p> This behaviour is placed at the node to run concurrently with whatever is computing there. 5 In the implementations <ref> [KrC91, FAR93] </ref> the newnode function takes a string argument specifying the host name of the new node. 76 L. Leth and B. Thomsen Table 3. Operational semantics for the alt-construct. <p> A Facile system may comprise of several nodes, denoted by dbe jjj dbe. We have chosen to keep the location space flat and thus avoid introducing a notion of sublocation. This fits the distributed Facile implementations <ref> [KrC91, FAR93] </ref>, and our approach seems easy to adapt in case we decide to introduce a notion of sublocation. <p> Straightforward by induction on the inferences used to establish K; e l K 0 ; e 0 and analysis of the structure of e. This notion of evaluation context maps almost directly to the notion of continuation found in the implementations of Facile <ref> [KrC91, Kuo92, FAR93] </ref> and we shall use the terms as synonyms. The theorem is constructive in the sense that we may algorithmically calculate the unique context C and thus find the next redex r for each transition. <p> Leth and B. Thomsen The former case, where one of the branches diverges, corresponds quite closely to the semantics adopted by the Facile implementations <ref> [KrC91, Kuo92, FAR93] </ref> as well as the implementation of CML [Rep91]. 5.6. A CHAM for Facile with Expression Level Choice (Facile alt ) So far we have only discussed choice operators which reside at the behaviour expression level of Facile. However, in the implementations of Facile [KrC91, Kuo92, FAR93] the choice <p> by the Facile implementations <ref> [KrC91, Kuo92, FAR93] </ref> as well as the implementation of CML [Rep91]. 5.6. A CHAM for Facile with Expression Level Choice (Facile alt ) So far we have only discussed choice operators which reside at the behaviour expression level of Facile. However, in the implementations of Facile [KrC91, Kuo92, FAR93] the choice operator resides at the expression level. This is also the case for the CML [Rep91] and Poly/ML [Mat91] languages, which extend the ML language with concurrency constructs similar to those found in Facile. <p> A CHAM for Distributed Facile with Decentralised Channel Management As an alternative to replicating channel managers we focus on a different approach which is used in the distributed implementations of Facile <ref> [KrC91, FAR93] </ref>. Instead of letting the implementation take care of replicating the channel manager as suggested above we give the programmer control over where channels are created. This is easily facilitated in a decentralised channel management scheme or in a per channel management scheme. <p> Most of the discussion of choice operators has focused on choice operators which reside at the behaviour expression level of Facile. This discussion has mainly been used to evaluate the possible variants. However, in the implementations of Facile <ref> [KrC91, Kuo92, FAR93] </ref> the choice operator resides at the expression level. This is also the case for the CML [Rep91] and Poly/ML [Mat91] languages, which extend the ML language with concurrency constructs similar to those found in Facile. <p> We have also applied the CHAM framework for formalising how the concept of channel management is introduced in a real implementation. This work has helped us in describing the implementations <ref> [KrC91, Kuo92, FAR93] </ref>, and it has also provided guidelines for new improved implementations. We have studied two schemes. The first scheme corresponds to channels being implemented using centralised channel management, and the second scheme corresponds to channel management being implemented using decentralised channel management. <p> The first scheme corresponds closely to a formalisation of (parts of) the experimental implementation of Facile described in [Kuo92]. This description also corresponds to the implementation of channels in CML. The second scheme corresponds closely to a formalisation of (parts of) the implementations of Facile described in <ref> [KrC91, FAR93] </ref>. We have also used the CHAM framework for discussing channel management in physically distributed environments. The notion of node/location has been discussed, looking at how a Facile node is modelled and how it is created.
Reference: [Kuo92] <author> Kuo, T.-M.: </author> <title> Magic Facile version 0.3, MAGIC Note 22, </title> <address> ECRC, </address> <year> 1992. </year>
Reference-contexts: In the current state of the project three versions of the language supporting polymorphic types have been implemented by extending the ML language [MTH90] with the concurrency constructs of Facile <ref> [KrC91, Kuo92, FAR93] </ref>. These implementations use continuations, as found in the Standard ML of New Jersey (SML/NJ) implementation [App89], for introducing concurrency. Con-currency is simulated using continuations in [Kuo92], and in [KrC91, FAR93] concurrency is obtained by scheduling between user level continuations. <p> These implementations use continuations, as found in the Standard ML of New Jersey (SML/NJ) implementation [App89], for introducing concurrency. Con-currency is simulated using continuations in <ref> [Kuo92] </ref>, and in [KrC91, FAR93] concurrency is obtained by scheduling between user level continuations. Furthermore, the latter two implementations support true distributed computing on networks of homogeneous hardware (currently Sun4 or SPARC machines). <p> Straightforward by induction on the inferences used to establish K; e l K 0 ; e 0 and analysis of the structure of e. This notion of evaluation context maps almost directly to the notion of continuation found in the implementations of Facile <ref> [KrC91, Kuo92, FAR93] </ref> and we shall use the terms as synonyms. The theorem is constructive in the sense that we may algorithmically calculate the unique context C and thus find the next redex r for each transition. <p> Leth and B. Thomsen The former case, where one of the branches diverges, corresponds quite closely to the semantics adopted by the Facile implementations <ref> [KrC91, Kuo92, FAR93] </ref> as well as the implementation of CML [Rep91]. 5.6. A CHAM for Facile with Expression Level Choice (Facile alt ) So far we have only discussed choice operators which reside at the behaviour expression level of Facile. However, in the implementations of Facile [KrC91, Kuo92, FAR93] the choice <p> by the Facile implementations <ref> [KrC91, Kuo92, FAR93] </ref> as well as the implementation of CML [Rep91]. 5.6. A CHAM for Facile with Expression Level Choice (Facile alt ) So far we have only discussed choice operators which reside at the behaviour expression level of Facile. However, in the implementations of Facile [KrC91, Kuo92, FAR93] the choice operator resides at the expression level. This is also the case for the CML [Rep91] and Poly/ML [Mat91] languages, which extend the ML language with concurrency constructs similar to those found in Facile. <p> This is done by activating the suspended input continuation on the value v and activating the suspended output continuation on the trivial value triv. This models quite faithfully how communication is implemented in the uniprocessor implementation of Facile <ref> [Kuo92] </ref> as well as CML [Rep91]. Note that all other rules stay unchanged. The CHAM simulates the Facile computations if the initial state satisfies the condition that the queues involved are initially empty. <p> CHAMs for Centralised Channel Management with Process Suspension The CHAMs discussed in the previous sections quite faithfully model the implementation of communication in CML [Rep91] as well as the uniprocessor implementation of Facile <ref> [Kuo92] </ref>. However, for distributed implementations it is rather inefficient to store the continuation of a suspended process at the channel manager. In the following we work towards CHAMs exhibiting better properties for distributed implementations. <p> Most of the discussion of choice operators has focused on choice operators which reside at the behaviour expression level of Facile. This discussion has mainly been used to evaluate the possible variants. However, in the implementations of Facile <ref> [KrC91, Kuo92, FAR93] </ref> the choice operator resides at the expression level. This is also the case for the CML [Rep91] and Poly/ML [Mat91] languages, which extend the ML language with concurrency constructs similar to those found in Facile. <p> We have also applied the CHAM framework for formalising how the concept of channel management is introduced in a real implementation. This work has helped us in describing the implementations <ref> [KrC91, Kuo92, FAR93] </ref>, and it has also provided guidelines for new improved implementations. We have studied two schemes. The first scheme corresponds to channels being implemented using centralised channel management, and the second scheme corresponds to channel management being implemented using decentralised channel management. <p> We have studied two schemes. The first scheme corresponds to channels being implemented using centralised channel management, and the second scheme corresponds to channel management being implemented using decentralised channel management. The first scheme corresponds closely to a formalisation of (parts of) the experimental implementation of Facile described in <ref> [Kuo92] </ref>. This description also corresponds to the implementation of channels in CML. The second scheme corresponds closely to a formalisation of (parts of) the implementations of Facile described in [KrC91, FAR93]. We have also used the CHAM framework for discussing channel management in physically distributed environments.
Reference: [Lan64] <author> Landin P.: </author> <title> The mechanical evaluation of expressions, </title> <journal> Computer Journal, </journal> <volume> 6(4), </volume> <year> 1964. </year>
Reference-contexts: Evaluation Contexts From the SOS we can observe that the expression part of Facile contains the call-by-value -calculus with a deterministic evaluation strategy derived from Landin's ISWIM <ref> [Lan64, Lan66] </ref>. In this section we shall extend a result about ISWIM to Facile. The extension of this result to Facile expressions will allow us to focus on behaviour expressions, and at the same time preserve the call-by-value semantics for expressions.
Reference: [Lan66] <author> Landin P.: </author> <title> The next 700 programming languages, </title> <journal> Comm. ACM, </journal> <volume> 9(3), </volume> <pages> pp. 157-166, </pages> <year> 1966. </year>
Reference-contexts: Evaluation Contexts From the SOS we can observe that the expression part of Facile contains the call-by-value -calculus with a deterministic evaluation strategy derived from Landin's ISWIM <ref> [Lan64, Lan66] </ref>. In this section we shall extend a result about ISWIM to Facile. The extension of this result to Facile expressions will allow us to focus on behaviour expressions, and at the same time preserve the call-by-value semantics for expressions.
Reference: [Let91] <author> Leth, L.: </author> <title> Functional Programs as Reconfigurable Networks of Communicating Processes, </title> <type> Ph. D. thesis, </type> <institution> Imperial College, </institution> <year> 1991. </year>
Reference-contexts: Functions, processes and communication channels are first class values. Thus the language exhibits mobility of links in the sense of the -calculus [MPW89] and LCCS <ref> [Let91] </ref> as well as mobility of processes in the sense of CHOCS [Tho89] or Plain CHOCS [Tho90] since the Facile language has static scoping. The language also has static typing. A monomorphic type system was defined in [GMP90]. <p> CHAMs all obey a simple set of structural laws. Each particular machine is defined by adding a set of simple rules that specify how to generate new molecules from old ones. The framework has been used to specify CHAMs for CCS and the fl-calculus in [BeB90], for LCCS in <ref> [Let91] </ref>, for the -calculus in [BeB92], for LO in [ALP93] and for the weak -calculus with sharing in [Bou94]. In this paper we cast the Facile semantics in the CHAM framework 1 .
Reference: [Mat91] <author> Matthews, D.: </author> <title> A Distributed Concurrent Implementation of Standard ML, </title> <booktitle> to appear in Proceedings of EurOpen Autumn 1991 Conference, </booktitle> <year> 1991. </year>
Reference-contexts: CCS or the fl-calculus. Where relevant in this paper we show how the SOS and the CHAM semantics for Facile are related. We have taken the Facile language as source for discussion, but the results also apply to several other new languages such as CML [Rep91, BMT92] and Poly/ML <ref> [Mat91] </ref>. Characteristic for all these languages is that they combine ideas from the -calculus and process algebra, such as CCS [Mil80, Mil89], to support high level constructs for programming concurrent, parallel and/or distributed systems. The outline of the paper is as follows. <p> However, in the implementations of Facile [KrC91, Kuo92, FAR93] the choice operator resides at the expression level. This is also the case for the CML [Rep91] and Poly/ML <ref> [Mat91] </ref> languages, which extend the ML language with concurrency constructs similar to those found in Facile. It turns out that the study carried out so far can be used to shed light on the choice operators of these languages. <p> This discussion has mainly been used to evaluate the possible variants. However, in the implementations of Facile [KrC91, Kuo92, FAR93] the choice operator resides at the expression level. This is also the case for the CML [Rep91] and Poly/ML <ref> [Mat91] </ref> languages, which extend the ML language with concurrency constructs similar to those found in Facile. It turns out that the study carried out so far also can be used to shed light on the choice operators of these languages.
Reference: [Mil80] <author> Milner, R.: </author> <title> A Calculus of Communicating Systems, </title> <booktitle> Lecture Notes in Computer Science 92, </booktitle> <year> 1980. </year>
Reference-contexts: Leth and B. Thomsen CCS <ref> [Mil80, Mil89] </ref>. Call-by-value -calculus and CCS have merged symmetrically to obtain a language that supports both functional and process abstractions: functions may be defined and used to specify internal computations of concurrent processes; dynamic process creation and synchronised communication over typed channels may occur during any expression evaluation. <p> We have taken the Facile language as source for discussion, but the results also apply to several other new languages such as CML [Rep91, BMT92] and Poly/ML [Mat91]. Characteristic for all these languages is that they combine ideas from the -calculus and process algebra, such as CCS <ref> [Mil80, Mil89] </ref>, to support high level constructs for programming concurrent, parallel and/or distributed systems. The outline of the paper is as follows. In Section 2 we introduce the notion of CHAM. The Facile syntax and operational semantics based on labelled transition systems is presented in Section 3. <p> As we shall see below some rewrite rules are considered heating or cooling rules. Such rules are akin to structural rules in classical inference rule presentations. Example 2.1. When dealing with a simple subset of CCS <ref> [Mil80] </ref> the CHAM contains the following rules for inaction, parallel and reaction for the agents a:P and a:Q: inaction: 0 * (* means heating) parallel: P j Q P; Q ( means reversible heating/cooling) reaction: a:P; a:Q ! P; Q (! means reaction) These rules are to be interpreted as follows.
Reference: [Mil89] <author> Milner, R.: </author> <title> Communication and Concurrency, </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Leth and B. Thomsen CCS <ref> [Mil80, Mil89] </ref>. Call-by-value -calculus and CCS have merged symmetrically to obtain a language that supports both functional and process abstractions: functions may be defined and used to specify internal computations of concurrent processes; dynamic process creation and synchronised communication over typed channels may occur during any expression evaluation. <p> We have taken the Facile language as source for discussion, but the results also apply to several other new languages such as CML [Rep91, BMT92] and Poly/ML [Mat91]. Characteristic for all these languages is that they combine ideas from the -calculus and process algebra, such as CCS <ref> [Mil80, Mil89] </ref>, to support high level constructs for programming concurrent, parallel and/or distributed systems. The outline of the paper is as follows. In Section 2 we introduce the notion of CHAM. The Facile syntax and operational semantics based on labelled transition systems is presented in Section 3. <p> Recall that the SOS for this choice operator specifies that the choice may be triggered by an external communication as well as an internal transition in either branch. From a mathematical point of view this choice operator is possibly the simplest and most general <ref> [Mil89, HdN87] </ref>. 88 L. Leth and B. <p> One of the important components of an implementation of Facile is the notion of channel. A channel can be viewed as either a conceptual component or a physical component. Conceptually a channel is an interaction point in the sense of CCS <ref> [Mil89] </ref>. This is well illustrated in the previous CHAMs where molecules react with each other when they have reached an ion form with complementary valences. i i i j Q Q Q Fig. 1. Conceptual channels.
Reference: [Mil90] <author> Milner, R.: </author> <title> Functions as processes, </title> <booktitle> in Proceedings of ICALP 1990, Lecture Notes in Computer Science 443, </booktitle> <pages> pp. 167-180, </pages> <year> 1990. </year>
Reference-contexts: modelled in the CHAM framework by the following rules: act C [chan]; (K; S) ! act C [k]; (K [ fkg; S n fkg) act C [chan]; (K; ;) ! act C [error]; (K; ;) An alternative and perhaps more abstract solution to channel name management has been proposed in <ref> [Mil90] </ref> and was also considered in [BeB92]. In this approach molecules of the form k:m are introduced. These molecules are viewed as having k restricted in such a way that ions with k in their valence (i.e. being ready to communicate over the k channel) are prohibited from reactions.
Reference: [MPW89] <author> Milner, R., Parrow, J. and Walker, D.: </author> <title> A calculus of mobile processes, </title> <institution> Reports ECS-LFCS-89-85 and -86, Laboratory for Foundations of Computer Science, Computer Science Department, Edinburgh University, </institution> <year> 1989. </year> <note> (To appear in Journal of Information and Computation.) </note>
Reference-contexts: Functions, processes and communication channels are first class values. Thus the language exhibits mobility of links in the sense of the -calculus <ref> [MPW89] </ref> and LCCS [Let91] as well as mobility of processes in the sense of CHOCS [Tho89] or Plain CHOCS [Tho90] since the Facile language has static scoping. The language also has static typing. A monomorphic type system was defined in [GMP90].
Reference: [MTH90] <author> Milner, R., Tofte, M., Harper, R.: </author> <title> Definition of Standard ML, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Nodes can be dynamically created, processes can be activated at specific nodes, and communication over channels may occur between different nodes. In the current state of the project three versions of the language supporting polymorphic types have been implemented by extending the ML language <ref> [MTH90] </ref> with the concurrency constructs of Facile [KrC91, Kuo92, FAR93]. These implementations use continuations, as found in the Standard ML of New Jersey (SML/NJ) implementation [App89], for introducing concurrency. Con-currency is simulated using continuations in [Kuo92], and in [KrC91, FAR93] concurrency is obtained by scheduling between user level continuations.
Reference: [Plo81] <author> Plotkin, G.: </author> <title> A Structural Approach to Operational Semantics, </title> <type> Technical report DAIMI FN-19, </type> <institution> Computer Science Department, Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: The language also has static typing. A monomorphic type system was defined in [GMP90]. A formal definition of a polymorphic type system for Facile has recently been investigated in [Tho93]. At the theoretical level, a structural operational semantics (SOS) <ref> [Plo81] </ref> has been developed in terms of labelled transition systems, and a notion of observability of programs is defined by extending the notion of bisimulation [GMP90]. An SOS covering aspects of physical distribution, time dependent behaviour and exceptions has been developed in [TLG92]. <p> The paper is not structured around such a study and the study is not conclusive, but we have found (or further substantiated the observations in [BeB90]) that traditional structural operational semantics <ref> [Plo81] </ref> equipped with a notion of observable behaviour is in general useful for expressing external behaviour of systems. On the other hand, the CHAM seems to be advantageous when describing internal system architecture and behaviour.
Reference: [Pra91a] <author> Prasad, S.: </author> <title> Towards A Symmetric Integration of Concurrent and Functional Programming, </title> <type> Ph. D. thesis, </type> <institution> State University of New York at Stony Brook, </institution> <year> 1991. </year>
Reference-contexts: When the initial design of Facile took place the interpretation of the %- operator was intentionally left somewhat open [GMP89]. In <ref> [GMP90, Pra91a] </ref> the operator was given an interpretation corresponding to the CCS choice operator + (where the choice between two processes is triggered by the first action, internal or external, of any of the two processes) since this operator is the most general from a mathematical point of view. <p> Conclusion In this paper we have shown how the CHAM framework can be used for experimenting with various semantics for the choice operator (the %-operator) in Facile. We have seen that even though an interpretation of the %-operator corresponding to the CCS choice operator, as suggested in <ref> [GMP90, Pra91a] </ref>, is the most general from a mathematical point of view, it may be difficult to implement and it will be expensive in terms of low level machinery.
Reference: [Pra91b] <author> Prasad, S.: </author> <title> About choice, </title> <type> unpublished manuscript, </type> <year> 1991. </year>
Reference-contexts: In <ref> [Pra91b] </ref> it was proposed to adopt an interpretation corresponding either to the TCCS [HdN87] internal choice operator (where the choice between two processes is decided non-deterministically by the system) or the TCCS external choice operator (where the choice between two processes is decided by communication with an external process) or in
Reference: [Rep91] <author> Reppy, J.H.: </author> <title> CML: a higher order concurrent language, </title> <booktitle> in Proceedings of SIG-PLAN'91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 293-305, </pages> <year> 1991. </year>
Reference-contexts: CCS or the fl-calculus. Where relevant in this paper we show how the SOS and the CHAM semantics for Facile are related. We have taken the Facile language as source for discussion, but the results also apply to several other new languages such as CML <ref> [Rep91, BMT92] </ref> and Poly/ML [Mat91]. Characteristic for all these languages is that they combine ideas from the -calculus and process algebra, such as CCS [Mil80, Mil89], to support high level constructs for programming concurrent, parallel and/or distributed systems. The outline of the paper is as follows. <p> Leth and B. Thomsen The former case, where one of the branches diverges, corresponds quite closely to the semantics adopted by the Facile implementations [KrC91, Kuo92, FAR93] as well as the implementation of CML <ref> [Rep91] </ref>. 5.6. A CHAM for Facile with Expression Level Choice (Facile alt ) So far we have only discussed choice operators which reside at the behaviour expression level of Facile. However, in the implementations of Facile [KrC91, Kuo92, FAR93] the choice operator resides at the expression level. <p> However, in the implementations of Facile [KrC91, Kuo92, FAR93] the choice operator resides at the expression level. This is also the case for the CML <ref> [Rep91] </ref> and Poly/ML [Mat91] languages, which extend the ML language with concurrency constructs similar to those found in Facile. It turns out that the study carried out so far can be used to shed light on the choice operators of these languages. <p> This is done by activating the suspended input continuation on the value v and activating the suspended output continuation on the trivial value triv. This models quite faithfully how communication is implemented in the uniprocessor implementation of Facile [Kuo92] as well as CML <ref> [Rep91] </ref>. Note that all other rules stay unchanged. The CHAM simulates the Facile computations if the initial state satisfies the condition that the queues involved are initially empty. <p> CHAMs for Centralised Channel Management with Process Suspension The CHAMs discussed in the previous sections quite faithfully model the implementation of communication in CML <ref> [Rep91] </ref> as well as the uniprocessor implementation of Facile [Kuo92]. However, for distributed implementations it is rather inefficient to store the continuation of a suspended process at the channel manager. In the following we work towards CHAMs exhibiting better properties for distributed implementations. <p> This discussion has mainly been used to evaluate the possible variants. However, in the implementations of Facile [KrC91, Kuo92, FAR93] the choice operator resides at the expression level. This is also the case for the CML <ref> [Rep91] </ref> and Poly/ML [Mat91] languages, which extend the ML language with concurrency constructs similar to those found in Facile. It turns out that the study carried out so far also can be used to shed light on the choice operators of these languages.
Reference: [Tal94] <author> Talpin, J.-P.: </author> <title> The Calumet Experiment Part I: An Implementation of Group-Communication Protocols in Facile, </title> <type> Technical report ECRC-94-4, </type> <year> 1994. </year>
Reference-contexts: The communication mechanism with this semantics may be used to program libraries of communication mechanisms that provide a certain level of fault tolerance. One example of such libraries for group communication may be found in <ref> [Tal94] </ref>. 7. Conclusion In this paper we have shown how the CHAM framework can be used for experimenting with various semantics for the choice operator (the %-operator) in Facile.
Reference: [Tho89] <author> Thomsen, B.: </author> <title> A calculus of higher-order communicating systems, </title> <booktitle> Proceedings of POPL'89, </booktitle> <year> 1989. </year>
Reference-contexts: Functions, processes and communication channels are first class values. Thus the language exhibits mobility of links in the sense of the -calculus [MPW89] and LCCS [Let91] as well as mobility of processes in the sense of CHOCS <ref> [Tho89] </ref> or Plain CHOCS [Tho90] since the Facile language has static scoping. The language also has static typing. A monomorphic type system was defined in [GMP90]. A formal definition of a polymorphic type system for Facile has recently been investigated in [Tho93].
Reference: [Tho90] <author> Thomsen, B.: </author> <title> Calculi for Higher Order Communicating Systems. </title> <type> PhD thesis, </type> <institution> Imperial College, </institution> <year> 1990. </year>
Reference-contexts: Functions, processes and communication channels are first class values. Thus the language exhibits mobility of links in the sense of the -calculus [MPW89] and LCCS [Let91] as well as mobility of processes in the sense of CHOCS [Tho89] or Plain CHOCS <ref> [Tho90] </ref> since the Facile language has static scoping. The language also has static typing. A monomorphic type system was defined in [GMP90]. A formal definition of a polymorphic type system for Facile has recently been investigated in [Tho93].
Reference: [Tho93] <author> Thomsen, B.: </author> <title> Polymorphic Sorts and Types for Concurrent Functional Programs, </title> <type> Technical report ECRC-93-10, </type> <year> 1993. </year>
Reference-contexts: The language also has static typing. A monomorphic type system was defined in [GMP90]. A formal definition of a polymorphic type system for Facile has recently been investigated in <ref> [Tho93] </ref>. At the theoretical level, a structural operational semantics (SOS) [Plo81] has been developed in terms of labelled transition systems, and a notion of observability of programs is defined by extending the notion of bisimulation [GMP90].
Reference: [TLG92] <author> Thomsen, B., Leth, L., Giacalone, A.: </author> <title> Some Issues in the Semantics of Facile Distributed Programming, </title> <booktitle> Proceedings of the 1992 REX Workshop on Semantics: Foundations and Applications, </booktitle> <publisher> LNCS 666, Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: An SOS covering aspects of physical distribution, time dependent behaviour and exceptions has been developed in <ref> [TLG92] </ref>. Conceptually a distributed Facile system consists of a collection of nodes, each supporting the (simulated) concurrent execution of Facile processes. Nodes can be dynamically created, processes can be activated at specific nodes, and communication over channels may occur between different nodes. <p> This has allowed us to justify design issues and implementation decisions before carrying out a full scale implementation effort. We use the formal CHAM semantics to give 1 The abstract syntax and SOS is based on [GMP90] and <ref> [TLG92] </ref>. See [FAR93] for the concrete programming syntax. <p> It is relatively easy to construct an SOS from the CHAM presented in Section 5.5. In <ref> [TLG92] </ref> a choice operator alt (alternative) was introduced. This operator resides on the expression level of Facile. The reason for having a choice operator at the expression level is that this guarantees no nesting of choice and parallel composition. <p> The last three rules are for observing distributed behaviour expressions. We allow interleaving between two locations and communication similar to the notion of concurrency and communication at the behaviour expression level (see <ref> [TLG92] </ref> for further discussion on the possible variations on these rules). 4. Evaluation Contexts From the SOS we can observe that the expression part of Facile contains the call-by-value -calculus with a deterministic evaluation strategy derived from Landin's ISWIM [Lan64, Lan66]. <p> This seems unavoidable, and only a time out mechanism for unblocking communications can solve this problem (or rather provide means by which the programmer may program around the problem of blocked communications). A discussion of time out constructs is beyond the scope of this paper (see <ref> [TLG92] </ref> for more information about the handling of time in Facile). In this paper we have elided from describing how to implement choice in the decentralised channel management scheme. It is quite a tricky issue and boils down to encoding one of several protocols for implementing distributed choice.
Reference: [FAR93] <author> Thomsen, B., Leth, L., Prasad, S., Kuo, T.-S., Kramer, A., Knabe, F., Giacalone, A.: </author> <title> Facile Antigua Release Programming Guide, </title> <type> Technical report ECRC-93-20, </type> <year> 1993. </year> <note> Received June 1992 Accepted in revised form November 1994 by C. </note> <author> B. </author> <title> Jones 8 MAGIC Notes are internal working documents from the MAGIC group at ECRC. </title>
Reference-contexts: 1. Introduction The work presented in this paper has been carried out in the context of the Facile project at ECRC. This project has as its main objective to provide powerful support for developing applications that require both distributed computation and complex information processing. The Facile language <ref> [GMP89, GMP90, FAR93] </ref> is an experimental programming language resulting from a concrete attempt to integrate the typed call-by-value -calculus with a process language similar to Correspondence and offprint requests to: Lone Leth and Bent Thomsen, European Computer Industry Research Centre, Arabellastrasse 17, D-81925, Munich, Germany 68 L. Leth and B. <p> In the current state of the project three versions of the language supporting polymorphic types have been implemented by extending the ML language [MTH90] with the concurrency constructs of Facile <ref> [KrC91, Kuo92, FAR93] </ref>. These implementations use continuations, as found in the Standard ML of New Jersey (SML/NJ) implementation [App89], for introducing concurrency. Con-currency is simulated using continuations in [Kuo92], and in [KrC91, FAR93] concurrency is obtained by scheduling between user level continuations. <p> These implementations use continuations, as found in the Standard ML of New Jersey (SML/NJ) implementation [App89], for introducing concurrency. Con-currency is simulated using continuations in [Kuo92], and in <ref> [KrC91, FAR93] </ref> concurrency is obtained by scheduling between user level continuations. Furthermore, the latter two implementations support true distributed computing on networks of homogeneous hardware (currently Sun4 or SPARC machines). <p> This has allowed us to justify design issues and implementation decisions before carrying out a full scale implementation effort. We use the formal CHAM semantics to give 1 The abstract syntax and SOS is based on [GMP90] and [TLG92]. See <ref> [FAR93] </ref> for the concrete programming syntax. <p> Note that external transitions produced during the evaluation of a guard will not trigger a choice. Only when each guard and all arguments to these guards have been evaluated to values, an external transition which may trigger the choice will be produced. The implementations of Facile described in <ref> [KrC91, FAR93] </ref> make programming in a physically distributed environment possible. In the following we discuss the extensions to the language which have to do with the locations where processes execute. A distributed Facile system executes in a collection of nodes, each supporting the (simulated) concurrent execution of Facile processes. <p> This behaviour is placed at the node to run concurrently with whatever is computing there. 5 In the implementations <ref> [KrC91, FAR93] </ref> the newnode function takes a string argument specifying the host name of the new node. 76 L. Leth and B. Thomsen Table 3. Operational semantics for the alt-construct. <p> A Facile system may comprise of several nodes, denoted by dbe jjj dbe. We have chosen to keep the location space flat and thus avoid introducing a notion of sublocation. This fits the distributed Facile implementations <ref> [KrC91, FAR93] </ref>, and our approach seems easy to adapt in case we decide to introduce a notion of sublocation. <p> Straightforward by induction on the inferences used to establish K; e l K 0 ; e 0 and analysis of the structure of e. This notion of evaluation context maps almost directly to the notion of continuation found in the implementations of Facile <ref> [KrC91, Kuo92, FAR93] </ref> and we shall use the terms as synonyms. The theorem is constructive in the sense that we may algorithmically calculate the unique context C and thus find the next redex r for each transition. <p> Leth and B. Thomsen The former case, where one of the branches diverges, corresponds quite closely to the semantics adopted by the Facile implementations <ref> [KrC91, Kuo92, FAR93] </ref> as well as the implementation of CML [Rep91]. 5.6. A CHAM for Facile with Expression Level Choice (Facile alt ) So far we have only discussed choice operators which reside at the behaviour expression level of Facile. However, in the implementations of Facile [KrC91, Kuo92, FAR93] the choice <p> by the Facile implementations <ref> [KrC91, Kuo92, FAR93] </ref> as well as the implementation of CML [Rep91]. 5.6. A CHAM for Facile with Expression Level Choice (Facile alt ) So far we have only discussed choice operators which reside at the behaviour expression level of Facile. However, in the implementations of Facile [KrC91, Kuo92, FAR93] the choice operator resides at the expression level. This is also the case for the CML [Rep91] and Poly/ML [Mat91] languages, which extend the ML language with concurrency constructs similar to those found in Facile. <p> First a message goes to the suspended sender. This message contains information about the suspended receiver. When the suspended sender receives the reactivation signal a message including the value is sent to the suspended receiver. This is very close in spirit to modelling the implementation described in <ref> [FAR93] </ref>. However, in the real implementation each asynchronous message above is accompanied by an acknowledgement message. In fact a mixture between the approach described in the above CHAM and the previous CHAM is used. <p> A CHAM for Distributed Facile with Decentralised Channel Management As an alternative to replicating channel managers we focus on a different approach which is used in the distributed implementations of Facile <ref> [KrC91, FAR93] </ref>. Instead of letting the implementation take care of replicating the channel manager as suggested above we give the programmer control over where channels are created. This is easily facilitated in a decentralised channel management scheme or in a per channel management scheme. <p> Then the value is thrown at the continuation and the behaviour continues execution. This models quite faithfully how chan 106 L. Leth and B. Thomsen nel management is implemented in the Facile Antigua Release <ref> [FAR93] </ref>. In the face of node failure it is obvious that channel managers may disappear when a node fails, just as in the case of centralised channel management. <p> Most of the discussion of choice operators has focused on choice operators which reside at the behaviour expression level of Facile. This discussion has mainly been used to evaluate the possible variants. However, in the implementations of Facile <ref> [KrC91, Kuo92, FAR93] </ref> the choice operator resides at the expression level. This is also the case for the CML [Rep91] and Poly/ML [Mat91] languages, which extend the ML language with concurrency constructs similar to those found in Facile. <p> We have also applied the CHAM framework for formalising how the concept of channel management is introduced in a real implementation. This work has helped us in describing the implementations <ref> [KrC91, Kuo92, FAR93] </ref>, and it has also provided guidelines for new improved implementations. We have studied two schemes. The first scheme corresponds to channels being implemented using centralised channel management, and the second scheme corresponds to channel management being implemented using decentralised channel management. <p> The first scheme corresponds closely to a formalisation of (parts of) the experimental implementation of Facile described in [Kuo92]. This description also corresponds to the implementation of channels in CML. The second scheme corresponds closely to a formalisation of (parts of) the implementations of Facile described in <ref> [KrC91, FAR93] </ref>. We have also used the CHAM framework for discussing channel management in physically distributed environments. The notion of node/location has been discussed, looking at how a Facile node is modelled and how it is created.
References-found: 40

