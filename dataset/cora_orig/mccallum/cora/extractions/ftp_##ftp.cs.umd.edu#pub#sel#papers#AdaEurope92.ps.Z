URL: ftp://ftp.cs.umd.edu/pub/sel/papers/AdaEurope92.ps.Z
Refering-URL: http://www.cs.umd.edu/users/bthomas/abs/ae92.html
Root-URL: 
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: <editor> Proceedings of the Fifteenth Annual Software Engineering Workshop Ada: </editor> <booktitle> The Choice for '92 (Proceedings of the Ada-Europe International Conference) Proceedings of the Eighth National Conference on Ada Technology IEEE Computer Software Engineering Notes Proceedings of the 6th Symposium on Empirical Foundations of Information and Software Sciences Software Engineering Journal IEEE Transactions on Software Engineering IEEE Transactions on Software Engineering </booktitle>
Reference: [1] <author> W. W. Agresti, W. M. Evanco, and M. C. Smith. </author> <title> Early Experiences Building a Software Quality Prediction Model. </title> <booktitle> In , NASA/GSFC, </booktitle> <address> Greenbelt, Maryland, </address> <month> November </month> <year> 1990. </year>
Reference-contexts: The complexity of the component interface is also an important factor. Limiting program dependencies is suggested as a means for improving reusability, and techniques for transforming existing software to limit dependencies is discussed in [3]. Agresti et al. <ref> [1] </ref> have developed multivariate models of software qualities using characteristics of the software architecture. Increasing dependencies in the system is shown to reduce the reliability of the system. There is a trade-off between these two complexities.
Reference: [2] <author> N. Badaro and Th. Moineau. ROSE-Ada: </author> <title> A Method and a Tool to Help Reuse of Ada Codes. </title> <booktitle> In , Athens, </booktitle> <address> Greece, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Repository based techniques strive for reuse by collecting reusable entities and providing efficient means to locate the appropriate object for a particular task. Techniques for storing objects to allow for effective automated retrieval are outlined in <ref> [2, 22] </ref>. Lanergan and Grasso [18] were able to provide for their organization a classification of functional modules in the context of the COBOL language and obtain a leverage of 60% of the regularly used code.
Reference: [3] <author> J. Bailey and V. Basili. </author> <title> Software Reclamation: Improving Post-Development Reusability. </title> <booktitle> In , 1990. </booktitle>
Reference-contexts: The complexity of the component interface is also an important factor. Limiting program dependencies is suggested as a means for improving reusability, and techniques for transforming existing software to limit dependencies is discussed in <ref> [3] </ref>. Agresti et al. [1] have developed multivariate models of software qualities using characteristics of the software architecture. Increasing dependencies in the system is shown to reduce the reliability of the system. There is a trade-off between these two complexities. <p> While there was a significant difference (at .0001 level) between the visibility in the reused verbatim class and each of the other classes, no such distinction was found when comparing the classes of new, slightly modified and extensively modified components. This supports the view presented in <ref> [3] </ref> that reducing dependencies may make a module more reusable. One possible explanation for the lower complexity observed in the reused code is that the reused components comprise only simple, straightforward functions (e.g. general utilities), and as 6 8.0 4.0 0.0 Ext. Mod.
Reference: [4] <author> R. Balzer, T. Cheatham, and C. Green. </author> <title> Software Technology in the 1990's: Using a New Paradigm. </title> , <type> 16(11), </type> <month> November </month> <year> 1983. </year>
Reference-contexts: To realize such benefits, techniques to achieve effective reuse have been the focus of extensive research effort over the past twenty years [24]. Generational approaches such as those described in <ref> [4, 5] </ref> attempt to achieve reuse through the generation of source code from other forms. Boyle and Muralidaharan [12] view the automatic translation as a successful mechanism to transfer programs into new programming environment.
Reference: [5] <author> D. Barstow. </author> <title> Rapid Prototyping, Automatic Programming, </title> <journal> and Experimental Sciences. </journal> , <volume> 7(5), </volume> <month> December </month> <year> 1982. </year>
Reference-contexts: To realize such benefits, techniques to achieve effective reuse have been the focus of extensive research effort over the past twenty years [24]. Generational approaches such as those described in <ref> [4, 5] </ref> attempt to achieve reuse through the generation of source code from other forms. Boyle and Muralidaharan [12] view the automatic translation as a successful mechanism to transfer programs into new programming environment.
Reference: [6] <author> V. Basili, D. Rombach, J. Bailey, and A. Delis. </author> <title> Ada Reusability Analysis and Measurement. </title> <booktitle> In , Atlanta, </booktitle> <address> Georgia, </address> <month> October </month> <year> 1988. </year>
Reference-contexts: Some other attempts geared predominantly towards source code reuse are found in [19, 20]. The common element in 1 2 A Measurement Guided Reuse Process these efforts is that they all strive for the reuse of products or by-products of the software life cycle. Basili et al. <ref> [6, 7] </ref> indicate that the reuse of processes in addition to software products may result in even greater benefits. Caldiera and Basili [13] identify four fundamental steps in a reuse process cycle and introduce the idea of metric use for the identification and extraction of reusable code.
Reference: [7] <author> V. R. Basili and H. D. Rombach. </author> <title> Support for Comprehensive Reuse. </title> , <type> 6(5), </type> <month> September </month> <year> 1991. </year>
Reference-contexts: Some other attempts geared predominantly towards source code reuse are found in [19, 20]. The common element in 1 2 A Measurement Guided Reuse Process these efforts is that they all strive for the reuse of products or by-products of the software life cycle. Basili et al. <ref> [6, 7] </ref> indicate that the reuse of processes in addition to software products may result in even greater benefits. Caldiera and Basili [13] identify four fundamental steps in a reuse process cycle and introduce the idea of metric use for the identification and extraction of reusable code. <p> Section 5 summarizes and identifies major conclusions. Basili and Rombach <ref> [7] </ref> outline a framework for the support of a reuse oriented development environment. <p> Throughout the transition the effectiveness of reuse can be monitored. Measurement can help us to better understand, evaluate and improve the quality of the reuse processes. A general architecture supporting the integration of measurement with software development processes is outlined in <ref> [7] </ref>. The reuse-oriented organization can only be effective if it shows an overall improvement over a traditional organization. By monitoring the resulting effect on the cost and quality of the final product, we can better understand the reuse process and evaluate its effectiveness.
Reference: [8] <author> B. W. Boehm. </author> <booktitle> Software Engineering Economics. </booktitle> , <address> SE-10(1), </address> <month> January </month> <year> 1984. </year>
Reference-contexts: As development effort is often considered to be an exponential function of software size, a reduction in the amount of software to be created can provide a dramatic savings in development cost <ref> [8] </ref>. Reduced development cost is not the only benefit of reuse. Reused software has a track record|it has been well tested and exercised and thus may be more reliable and defect-free than newly developed software.

Reference: [10] <author> G. Booch. . Benjamin-Cummings, </author> <note> second edition, </note> <year> 1987. </year>
Reference-contexts: While this data is not sufficient to build an accurate model relating reuse and cost, it does provide an indication that the effect of reuse is widespread|in addition to the savings in the implementation phase we see an indication of savings in integration and test phase. Booch <ref> [10] </ref> identifies the primary use of generic units as reusable software components.
Reference: [11] <author> E. W. Booth and M.E. Stark. </author> <title> Designing Configurable Software: COMPASS Implementation Concepts. </title> <note> In , October 1991. </note>
Reference-contexts: Our final purpose was to examine the effect of reuse over time using a metric-based approach. The change to a more generic architecture is evident from the percentage of the generic portion of the system. This change provided significant benefits|a reduction in development cost, duration, and error density <ref> [11] </ref>. Looking across all projects, we see few differences among the classes in terms of the complexity metrics. However, when we look at each project individually, we see a changing pattern of reuse. Figures 8 and 9 show the changing profile of reuse over time.
Reference: [12] <author> J. Boyle and M. Muralidaran. </author> <title> Program Reusability through Program Transformation. </title> , <address> SE-10(5), </address> <month> September </month> <year> 1984. </year>
Reference-contexts: To realize such benefits, techniques to achieve effective reuse have been the focus of extensive research effort over the past twenty years [24]. Generational approaches such as those described in [4, 5] attempt to achieve reuse through the generation of source code from other forms. Boyle and Muralidaharan <ref> [12] </ref> view the automatic translation as a successful mechanism to transfer programs into new programming environment. Repository based techniques strive for reuse by collecting reusable entities and providing efficient means to locate the appropriate object for a particular task.
Reference: [13] <author> G. Caldiera and V. R. Basili. </author> <title> Identifying and Qualifying Reusable Software Components. </title> , <type> 24(2), </type> <month> February </month> <year> 1991. </year>
Reference-contexts: Basili et al. [6, 7] indicate that the reuse of processes in addition to software products may result in even greater benefits. Caldiera and Basili <ref> [13] </ref> identify four fundamental steps in a reuse process cycle and introduce the idea of metric use for the identification and extraction of reusable code. A validation study was performed focusing on the identification of reusable components in a C/Unix environment. <p> In this paper we discuss the use of measurement to better understand and evaluate an Ada reuse process. Using various metrics, we analyzed the effect of reuse in Ada developments in a single organization over a 3 year period. This paper extends the work presented in <ref> [13] </ref> in the Ada environment and generalizes the approach of using software metrics to determine the effectiveness of reuse. We argue that metrics, in addition to facilitating the extraction of software components, can aid in the evaluation of reused code and reuse processes. <p> A project organization can be tailored toward reuse by separating project concerns from software component development concerns. Such an organization is described in detail in <ref> [13] </ref>. The distinction with traditional development is that in this reuse oriented organization, the project organization provides specifications to the factory organization, which retrieves the appropriate components, and provides them to the project organization for integration. <p> This side is focused on the component rather than the system into which the component must be integrated. It is not expected that the factory side is driven solely by project requests; rather domain analyses will sustain continuing development in the factory. The work of Caldiera and Basili <ref> [13] </ref> deals with the factory side of the organization. <p> Highly complex components may be more error-prone and difficult to understand. In the context of reuse, excess complexity is seen as an inhibitor of effective reuse, as it can make the integration and rework costs outweigh the cost of developing a component from scratch <ref> [13] </ref>. The complexity of the component interface is also an important factor. Limiting program dependencies is suggested as a means for improving reusability, and techniques for transforming existing software to limit dependencies is discussed in [3]. <p> The increased complexity of the reused objects suggests that reuse is occurring at higher levels of abstraction. This supports the notion that a model of reusability must be evolved over time to keep pace with a changing environment <ref> [13] </ref>. While the lower cyclomatic complexity and visibility associated with the reused components indicates that such measures may work well in the initial assessment of reuse candidates. Clearly, however, reuse with Ada is not limited to these types of candidates.
Reference: [14] <author> D. </author> <title> Doubleday. ASAP: Ada Static Analyzer Program. </title> <type> Technical report CS-TR-1897, </type> <institution> University of Maryland, </institution> <month> May </month> <year> 1987. </year>
Reference-contexts: As with custom versus reused code, we believed we would see differences between the two classes. We analyzed the systems with a source code static analysis tool, ASAP <ref> [14] </ref>, which provided us with a static profile of each compilation unit, including, for example, basic complexity measures such as McCabe's Cyclomatic Complexity and Halstead's Software Science, as well as counts of various types of declarations.
Reference: [15] <editor> C. Jones. </editor> . <publisher> McGraw-Hill, </publisher> <year> 1986. </year>
Reference-contexts: The following sections describe what we have seen relative to reuse across four recent projects in three areas: error density, product complexity, and productivity. Rework has been identified as a major cost factor in software development. Jones <ref> [15] </ref> indicates that it typically accounts for over 50% of the effort for large projects. Reuse of previously developed, tested, and qualified components can reduce the number of errors in development, thus reducing rework effort. analyzed. The bar labeled "New" indicates error density in newly created components. "Ext. Mod.", "Slt.
Reference: [16] <author> T.C. Jones. </author> <title> Reusability in Programming: A Survey of the State of the Art. </title> , <address> SE-10(5), </address> <month> September </month> <year> 1984. </year>
Reference-contexts: The Ada generic features are observed as an enabler of reuse at higher levels of abstraction. Finally, using several metrics, we identify trends indicating an improving reuse process. Reuse has long been cited as essential for obtaining significant improvement in software development productivity. Jones <ref> [16] </ref> indicates that only 15 percent of the developed software is unique to the applications for which it was developed.
Reference: [17] <author> R. Kester. </author> <title> SEL Ada Reuse Analysis and Representations. </title> <booktitle> In . NASA/GSFC, </booktitle> <month> November </month> <year> 1990. </year>
Reference-contexts: The percentage of reused code on these projects ranged from 9 to 87 percent (verbatim), and 29 to 94 percent (verbatim and with modification) <ref> [17] </ref>. The purpose of this experiment was to quantify reuse with objective metrics, assess the impact of reuse on complexity, and to investigate the viability of a metrics based approach to reuse in an Ada development environment.
Reference: [18] <author> R. Lanergan and C. Grasso. </author> <title> Software Engineering with Reusable Designs and Code. </title> , <address> SE-10(5), </address> <month> September </month> <year> 1984. </year>
Reference-contexts: The effect of the improved quality will not stop at the completion of development-rather the most significant benefit of reuse may be its effect on maintenance <ref> [18, 23] </ref>. To realize such benefits, techniques to achieve effective reuse have been the focus of extensive research effort over the past twenty years [24]. Generational approaches such as those described in [4, 5] attempt to achieve reuse through the generation of source code from other forms. <p> Repository based techniques strive for reuse by collecting reusable entities and providing efficient means to locate the appropriate object for a particular task. Techniques for storing objects to allow for effective automated retrieval are outlined in [2, 22]. Lanergan and Grasso <ref> [18] </ref> were able to provide for their organization a classification of functional modules in the context of the COBOL language and obtain a leverage of 60% of the regularly used code.
Reference: [19] <author> S. Litvintchouk and A. Matsumoto. </author> <title> Design of Ada Systems Yielding Reusable Components: An Approach Using Structured Algebraic Specification. </title> , <address> SE-10(5), </address> <month> September </month> <year> 1984. </year>
Reference-contexts: Cheatham [25] outlines a methodology of abstract programs that can be to a family of concrete programs using very high level languages. Some other attempts geared predominantly towards source code reuse are found in <ref> [19, 20] </ref>. The common element in 1 2 A Measurement Guided Reuse Process these efforts is that they all strive for the reuse of products or by-products of the software life cycle.
Reference: [20] <author> Y. Matsumoto. </author> <title> Some Experiences in Promoting Reusable Software: Presentation in Higher Abstract Levels. </title> , <address> SE-10(5), </address> <month> September </month> <year> 1984. </year>
Reference-contexts: Cheatham [25] outlines a methodology of abstract programs that can be to a family of concrete programs using very high level languages. Some other attempts geared predominantly towards source code reuse are found in <ref> [19, 20] </ref>. The common element in 1 2 A Measurement Guided Reuse Process these efforts is that they all strive for the reuse of products or by-products of the software life cycle.
Reference: [21] <author> T. McCabe. </author> <title> A Complexity Measure. </title> , <address> SE-2(4), </address> <month> December </month> <year> 1976. </year>
Reference-contexts: Cyclomatic Complexity Ave. Visibility AAA Cyclomatic complexity <ref> [21] </ref> is a graph-theoretic measure of the control organization of a component. Highly complex components may be more error-prone and difficult to understand.
Reference: [22] <author> R. Prieto-Diaz and P. Freeman. </author> <title> Classyfying Software for Reusability. </title> , <type> 4(1), </type> <month> January </month> <year> 1987. </year>
Reference-contexts: Repository based techniques strive for reuse by collecting reusable entities and providing efficient means to locate the appropriate object for a particular task. Techniques for storing objects to allow for effective automated retrieval are outlined in <ref> [2, 22] </ref>. Lanergan and Grasso [18] were able to provide for their organization a classification of functional modules in the context of the COBOL language and obtain a leverage of 60% of the regularly used code.
Reference: [23] <author> H. D. Rombach. </author> <title> Software Reuse: A Key to the Maintenance Problem. </title> , <type> 33(1), </type> <month> January/February </month> <year> 1991. </year>
Reference-contexts: The effect of the improved quality will not stop at the completion of development-rather the most significant benefit of reuse may be its effect on maintenance <ref> [18, 23] </ref>. To realize such benefits, techniques to achieve effective reuse have been the focus of extensive research effort over the past twenty years [24]. Generational approaches such as those described in [4, 5] attempt to achieve reuse through the generation of source code from other forms.
Reference: [24] <author> T. Standish. </author> <title> An Essay on Software Reuse. </title> , <type> 10(5), </type> <month> Septem-ber </month> <year> 1984. </year>
Reference-contexts: To realize such benefits, techniques to achieve effective reuse have been the focus of extensive research effort over the past twenty years <ref> [24] </ref>. Generational approaches such as those described in [4, 5] attempt to achieve reuse through the generation of source code from other forms. Boyle and Muralidaharan [12] view the automatic translation as a successful mechanism to transfer programs into new programming environment.
Reference: [25] <author> Jr. T. Cheatham. </author> <title> Reusability Through Program Transformations. </title> , <address> SE-10(5), </address> <month> September </month> <year> 1984. </year>
Reference-contexts: Lanergan and Grasso [18] were able to provide for their organization a classification of functional modules in the context of the COBOL language and obtain a leverage of 60% of the regularly used code. Cheatham <ref> [25] </ref> outlines a methodology of abstract programs that can be to a family of concrete programs using very high level languages. Some other attempts geared predominantly towards source code reuse are found in [19, 20].
References-found: 25

