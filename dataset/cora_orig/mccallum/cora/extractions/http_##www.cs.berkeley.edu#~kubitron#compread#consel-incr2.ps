URL: http://www.cs.berkeley.edu/~kubitron/compread/consel-incr2.ps
Refering-URL: http://www.cs.berkeley.edu/~kubitron/compread/index.html
Root-URL: 
Email: (synthetix-request@cse.ogi.edu)  
Title: Optimistic Incremental Specialization: Streamlining a Commercial Operating System  
Author: Calton Pu, Tito Autrey, Andrew Black, Charles Consel Crispin Cowan, Jon Inouye, Lakshmi Kethana, Jonathan Walpole, and Ke Zhang 
Affiliation: Department of Computer Science and Engineering Oregon Graduate Institute of Science Technology  
Abstract: Conventional operating system code is written to deal with all possible system states, and performs considerable interpretation to determine the current system state before taking action. A consequence of this approach is that kernel calls which perform little actual work take a long time to execute. To address this problem, we use specialized operating system code that reduces interpretation for common cases, but still behaves correctly in the fully general case. We describe how specialized operating system code can be generated and bound incrementally as the information on which it depends becomes available. We extend our specialization techniques to include the notion of optimistic incremental specialization: a technique for generating specialized kernel code optimistically for system states that are likely to occur, but not certain. The ideas outlined in this paper allow the conventional kernel design tenet of "optimizing for the common case" to be extended to the domain of adaptive operating systems. We also show that aggressive use of specialization can produce in-kernel implementations of operating system functionality with performance comparable to user-level implementations. We demonstrate that these ideas are applicable in real-world operating systems by describing a re-implementation of the HP-UX file system. Our specialized read system call reduces the cost of a single byte read by a factor of 3, and an 8 KB read by 26%, while preserving the semantics of the HP-UX read call. By relaxing the semantics of HP-UX read we were able to cut the cost of a single byte read system call by more than an order of magnitude. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Thomas B. Alexander, Kenneth G. Robertson, Dean T. Lindsey, Donald L. Rogers, John R. Obermeyer, John R. Keller, Keith Y. Oka, and Marlin M. Jones II. </author> <title> Corporate Business Servers: An Alternative to Mainframes for Business Computing. </title> <journal> Hewlett-Packard Journal, </journal> <volume> 45(3) </volume> <pages> 8-30, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: In this case, the file descriptor is marked as unspecialized and the memory is read occupies is marked for garbage collection at file close time. 4 Performance Results The experimental environment for the benchmarks was a Hewlett-Packard 9000 series 800 G70 (9000/887) dual-processor server <ref> [1] </ref> running in single-user mode. This server is configured with 128 MB of RAM. The two PA7100 [16] processors run at 96 MHz and each contains one MB of instruction cache and one MB of data cache.
Reference: [2] <author> Thomas E. Anderson, Brian N. Bershad, Edward D. Lazowska, and Henry M. Levy. </author> <title> Scheduler Activations: Effective Kernel Support for the User-Level Management of Parallelism. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(1) </volume> <pages> 53-79, </pages> <month> February </month> <year> 1992. </year>
Reference-contexts: This result is encouraging because it shows the feasibility of implementing operating system functionality at kernel level with performance similar to user-level libraries. Aggressive specialization may render unnecessary the popular trend of duplicating operating system functionality at user level <ref> [2, 19] </ref> for performance reasons. Another commonly cited reason for moving operating system functionality to user level is to give applications more control over policy decisions and operating system implementations. We believe that these benefits can also be gained without duplicating operating system functionality at user level.
Reference: [3] <author> Arindam Banerji and David L. Cohn. </author> <title> An Infrastructure for Application-Specific Customization. </title> <booktitle> In Proceedings of the ACM European SIGOPS Workshop, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: Choices [7] provides generalized components, called frameworks, which can be replaced with specialized versions using inheritance and dynamic linking. The Spring kernel uses an extensible RPC framework [18] to redirect object invocations to appropriate handlers based on the type of object. The Substrate Object Model <ref> [3] </ref> supports extensibility in the AIX kernel by providing additional interfaces for passing usage hints and customizing in-kernel implementations. Similarly, the Apertos operating system [31] supports dynamic reconfiguration by modifying an object's behavior through operations on its meta-interface.
Reference: [4] <author> Brian N. Bershad, Stefan Savage, Przemys law Pardyak, Emin Gun Sirer, Marc Fiuczynski, David Becker, Su-san Eggers, and Craig Chambers. </author> <title> Extensibility, Safety and Performance in the SPIN Operating System. </title> <booktitle> In Symposium on Operating Systems Principles (SOSP), </booktitle> <address> Copper Mountain, Colorado, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Similarly, Flex [8] allows dynamic loading of operating system modules into the Mach kernel, and uses a migrating threads model to reduce IPC overhead. One problem with allowing applications to load modules into the kernel is loss of protection. The SPIN kernel <ref> [4] </ref> allows applications to load executable modules, called spindles, dynamically into the kernel. These spindles are written in a type-safe programming language to ensure that they do not adversely affect kernel operations. Object-oriented operating systems allow customization through the use of inheritance, invocation redirection, and meta-interfaces.
Reference: [5] <author> D.L. Black, D.B. Golub, D.P. Julin, R.F. Rashid, R.P. Draves, R.W. Dean, A. Forin, J. Barrera, H. Tokuda, G. Malan, and D. Bohman. </author> <title> Microkernel operating system architecture and Mach. </title> <booktitle> In Proceedings of the Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 11-30, </pages> <address> Seattle, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Micro-kernel operating systems <ref> [5, 6, 11, 9, 21, 27, 29] </ref> were an early example of this trend, and improve adaptiveness by allowing operating system functionality to be implemented in user-level servers that can be customized and configured to produce special-purpose operating systems.
Reference: [6] <author> F. J. Burkowski, C. L. A. Clarke, Crispin Cowan, and G. J. Vreugdenhil. </author> <title> Architectural Support for Lightweight Tasking in the Sylvan Multiprocessor System. </title> <booktitle> In Symposium on Experience with Distributed and Multiprocessor Systems (SEDMS II), </booktitle> <pages> pages 165-184, </pages> <address> Atlanta, Georgia, </address> <month> March </month> <year> 1991. </year>
Reference-contexts: Micro-kernel operating systems <ref> [5, 6, 11, 9, 21, 27, 29] </ref> were an early example of this trend, and improve adaptiveness by allowing operating system functionality to be implemented in user-level servers that can be customized and configured to produce special-purpose operating systems.
Reference: [7] <author> Roy H. Campbell, Nayeem Islam, and Peter Madany. </author> <title> Choices: Frameworks and Refinement. </title> <journal> Computing Systems, </journal> <volume> 5(3) </volume> <pages> 217-257, </pages> <year> 1992. </year>
Reference-contexts: These spindles are written in a type-safe programming language to ensure that they do not adversely affect kernel operations. Object-oriented operating systems allow customization through the use of inheritance, invocation redirection, and meta-interfaces. Choices <ref> [7] </ref> provides generalized components, called frameworks, which can be replaced with specialized versions using inheritance and dynamic linking. The Spring kernel uses an extensible RPC framework [18] to redirect object invocations to appropriate handlers based on the type of object.
Reference: [8] <author> John B. Carter, Bryan Ford, Mike Hibler, Ravindra Kuramkote, Jeffrey Law, Lay Lepreau, Douglas B. Orr, Leigh Stoller, and Mark Swanson. </author> <title> FLEX: A Tool for Building Efficient and Flexible Systems. </title> <booktitle> In Proceedings of the Fourth Workshop on Workstation Operating Systems, </booktitle> <pages> pages 198-202, </pages> <address> Napa, CA, </address> <month> October </month> <year> 1993. </year>
Reference-contexts: To address this performance problem Chorus [29] allows modules, known as supervisor actors, to be loaded into the kernel address space. A specialized IPC mechanism is used for communication between actors within the kernel address space. Similarly, Flex <ref> [8] </ref> allows dynamic loading of operating system modules into the Mach kernel, and uses a migrating threads model to reduce IPC overhead. One problem with allowing applications to load modules into the kernel is loss of protection.
Reference: [9] <author> David R. Cheriton. </author> <title> The V Distributed System. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 314-333, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Micro-kernel operating systems <ref> [5, 6, 11, 9, 21, 27, 29] </ref> were an early example of this trend, and improve adaptiveness by allowing operating system functionality to be implemented in user-level servers that can be customized and configured to produce special-purpose operating systems.
Reference: [10] <author> David R. Cheriton and Kenneth J. Duda. </author> <title> A Caching Model of Operating System Kernel Functionality. </title> <booktitle> In Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 179-193, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: The Substrate Object Model [3] supports extensibility in the AIX kernel by providing additional interfaces for passing usage hints and customizing in-kernel implementations. Similarly, the Apertos operating system [31] supports dynamic reconfiguration by modifying an object's behavior through operations on its meta-interface. Other systems, such as the Cache kernel <ref> [10] </ref> and the Exo-kernel [17] address the performance problem by moving even more functionality out of the operating system kernel and placing it closer to the application. In this "minimal-kernel" approach extensibility is the norm rather than the exception.
Reference: [11] <author> David R. Cheriton, M. A. Malcolm, L. S. Melen, and G. R. Sager. Thoth, </author> <title> A Portable Real-Time Operating System. </title> <journal> Communications of the ACM, </journal> <volume> 22(2) </volume> <pages> 105-115, </pages> <month> February </month> <year> 1979. </year>
Reference-contexts: Micro-kernel operating systems <ref> [5, 6, 11, 9, 21, 27, 29] </ref> were an early example of this trend, and improve adaptiveness by allowing operating system functionality to be implemented in user-level servers that can be customized and configured to produce special-purpose operating systems.
Reference: [12] <author> Frederick W. Clegg, Gary Shiu-Fan Ho, Steven R. Kus-mer, and John R. Sontag. </author> <title> The HP-UX Operating System on HP Precision Architecture Computers. </title> <journal> Hewlett-Packard Journal, </journal> <volume> 37(12) </volume> <pages> 4-22, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: This paper illustrates our approach applying specialization in the context of a commercial Unix operating system and the C programming language. Specifically, it focuses on the specialization of the read system call, in HP-UX <ref> [12] </ref> while retaining standard HP-UX semantics. Since read is representative of many other Unix system calls and since HP-UX is representative of many other Unix systems, we expect the results of our study to generalize well beyond this specific implementation. The remainder of the paper is organized as follows.
Reference: [13] <author> C. Consel and O. Danvy. </author> <title> Tutorial notes on partial evaluation. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 493-501, </pages> <year> 1993. </year>
Reference-contexts: Related work is discussed in section 6. Section 7 concludes the paper. 2 What is Specialization? Program specialization, also called partial evaluation (PE), is a program transformation process aimed at customizing a program based on parts of its input <ref> [13, 30] </ref>. In essence, this process consists of performing constant propagation and folding, generalized to arbitrary computations. In principle, program specialization can be applied to any program that exhibits interpretation. That is, any program whose control flow is determined by the analysis of some data.
Reference: [14] <author> C. Consel and F. Noel. </author> <title> A general approach to run-time specialization and its application to C. </title> <type> Report 946, </type> <institution> Inria/Irisa, Rennes, France, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: The cost of runtime code generation can be avoided by generating code templates statically and optimistically at compile time. At kernel call invocation time, the templates are simply filled in and bound appropriately <ref> [14] </ref>. 3 Specializing HP-UX read To explore the real-world applicability of the techniques outlined above, we applied incremental and optimistic specialization to the HP-UX 9.04 read system call. read was chosen as a test case because it is representative of many other Unix system calls because it is a variation of
Reference: [15] <author> C. Consel, C. Pu, and J. Walpole. </author> <title> Incremental specialization: The key to high performance, modularity and portability in operating systems. </title> <booktitle> In Proceedings of ACM Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <address> Copenhagen, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: We call this repeated application of a partial evaluator incremental specialization <ref> [15] </ref>. The discussion so far has considered generating specialized code only on the basis of known invariants, i.e., bindings that are known to be constant. In an operating system, there are many things that are likely to be constant for long periods of time, but may occasionally vary.
Reference: [16] <author> Eric DeLano, Will Walker, and Mark Forsyth. </author> <title> A High Speed Superscalar PA-RISC Processor. </title> <booktitle> In COMPCON 92, </booktitle> <pages> pages 116-121, </pages> <address> San Francisco, CA, </address> <month> February 24-28 </month> <year> 1992. </year>
Reference-contexts: This server is configured with 128 MB of RAM. The two PA7100 <ref> [16] </ref> processors run at 96 MHz and each contains one MB of instruction cache and one MB of data cache. Section 4.1 presents an experiment to show how incremental specialization can reduce the overhead of the read system call. Sections 4.2 through 4.4 describe the overhead costs of specialization.
Reference: [17] <author> Dawson R. Engler, M. Frans Kaashoek, and James O'Toole Jr. Exokernel: </author> <title> An Operating System Architecture for Application-level Resource Management. </title> <booktitle> In Symposium on Operating Systems Principles (SOSP), </booktitle> <address> Copper Mountain, Colorado, </address> <month> December </month> <year> 1995. </year>
Reference-contexts: Similarly, the Apertos operating system [31] supports dynamic reconfiguration by modifying an object's behavior through operations on its meta-interface. Other systems, such as the Cache kernel [10] and the Exo-kernel <ref> [17] </ref> address the performance problem by moving even more functionality out of the operating system kernel and placing it closer to the application. In this "minimal-kernel" approach extensibility is the norm rather than the exception. Synthetix differs from the other extensible operating systems described above in a number of ways.
Reference: [18] <author> Graham Hamilton, Michael L. Powell, and James G. Mitchell. Subcontract: </author> <title> A flexible base of distributed programming. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 69-79, </pages> <address> Asheville, NC, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Object-oriented operating systems allow customization through the use of inheritance, invocation redirection, and meta-interfaces. Choices [7] provides generalized components, called frameworks, which can be replaced with specialized versions using inheritance and dynamic linking. The Spring kernel uses an extensible RPC framework <ref> [18] </ref> to redirect object invocations to appropriate handlers based on the type of object. The Substrate Object Model [3] supports extensibility in the AIX kernel by providing additional interfaces for passing usage hints and customizing in-kernel implementations.
Reference: [19] <author> Kieran Harty and David R. Cheriton. </author> <title> Application-controlled physical memory using external page-cache management. </title> <booktitle> In Proceedings of the Fifth International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS-V), </booktitle> <pages> pages 187-197, </pages> <address> Boston, MA, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: This result is encouraging because it shows the feasibility of implementing operating system functionality at kernel level with performance similar to user-level libraries. Aggressive specialization may render unnecessary the popular trend of duplicating operating system functionality at user level <ref> [2, 19] </ref> for performance reasons. Another commonly cited reason for moving operating system functionality to user level is to give applications more control over policy decisions and operating system implementations. We believe that these benefits can also be gained without duplicating operating system functionality at user level.
Reference: [20] <author> Hewlett-Packard. </author> <title> PA-RISC 1.1 Architecture and Instruction Set Reference Manual, </title> <note> second edition, </note> <month> September </month> <year> 1992. </year>
Reference-contexts: Timestamps are obtained by reading the PA-RISC's interval timer, a processor control register that is incremented every processor cycle <ref> [20] </ref>. Table 3 numerically compares the performance of HP-UX read with is read for reads of one byte, 8 KB, and 64 KB, and Figures 3 through 5 graphically represents the same data.
Reference: [21] <author> Dan Hildebrand. </author> <title> An Architectural Overview of QNX. </title> <booktitle> In Proceedings of the USENIX Workshop on Micro-kernels and Other Kernel Architectures, </booktitle> <pages> pages 113-123, </pages> <address> Seattle, WA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Micro-kernel operating systems <ref> [5, 6, 11, 9, 21, 27, 29] </ref> were an early example of this trend, and improve adaptiveness by allowing operating system functionality to be implemented in user-level servers that can be customized and configured to produce special-purpose operating systems.
Reference: [22] <author> Gregor Kiczales. </author> <title> Towards a new model of abstraction in software engineering. </title> <booktitle> In Proc. of the IMSA'92 Workshop on Reflection and Meta-level Architectures, </booktitle> <year> 1992. </year> <note> See http://www.xerox.com/PARC/spl/eca/oi.html for updates. </note>
Reference-contexts: Another commonly cited reason for moving operating system functionality to user level is to give applications more control over policy decisions and operating system implementations. We believe that these benefits can also be gained without duplicating operating system functionality at user level. Following an open-implementation (OI) philosophy <ref> [22] </ref>, operating system functionality can remain in the kernel, with customization of the implementation supported in a controlled manner via meta-interface calls [23]. A strong lesson from our work and from other work in the OI community [22] is that abstractly specified interfaces, i.e., those that do not constrain implementation choices <p> Following an open-implementation (OI) philosophy <ref> [22] </ref>, operating system functionality can remain in the kernel, with customization of the implementation supported in a controlled manner via meta-interface calls [23]. A strong lesson from our work and from other work in the OI community [22] is that abstractly specified interfaces, i.e., those that do not constrain implementation choices unnecessarily, are the key to gaining the most benefit from techniques such as specialization. 6 Related Work Our work on optimistic incremental specialization can be viewed as part of a widespread research trend towards adaptive operating systems.
Reference: [23] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bo-brow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: We believe that these benefits can also be gained without duplicating operating system functionality at user level. Following an open-implementation (OI) philosophy [22], operating system functionality can remain in the kernel, with customization of the implementation supported in a controlled manner via meta-interface calls <ref> [23] </ref>.
Reference: [24] <author> Samuel J. Le*er, Marshall Kirk McKusick, Michael J. Karels, and John S. Quarterman. </author> <title> 4.3BSD UNIX Operating System. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: To explore the real-world applicability of the techniques outlined above, we applied incremental and optimistic specialization to the HP-UX 9.04 read system call. read was chosen as a test case because it is representative of many other Unix system calls because it is a variation of the BSD file system <ref> [24] </ref>. The HP-UX implementation of read is also representative of many other Unix implementations. Therefore, we expect our results to be applicable to other Unix-like systems.
Reference: [25] <author> H. Massalin and C. Pu. </author> <title> Threads and input/output in the Synthesis kernel. </title> <booktitle> In Proceedings of the Twelfth Symposium on Operating Systems Principles, </booktitle> <pages> pages 191-201, </pages> <address> Arizona, </address> <month> December </month> <year> 1989. </year>
Reference-contexts: One of the lessons of the Synthesis operating system <ref> [25] </ref> is that significant gains in efficiency can be made by replacing this generic code with specialized code. The specialized code performs correctly only in a restricted environment, but it is chosen so that this restricted environment is the common case. <p> Extensive use of this kind of specialization in Synthesis achieved improvement in kernel call performance ranging from a factor of 3 to a factor of 56 <ref> [25] </ref> for a subset of the Unix system call interface. <p> We have shown how this model supports the concepts of incremental and optimistic specialization. These concepts refine previous work on kernel optimization using dynamic code generation in Synthesis <ref> [28, 25] </ref>. We have demonstrated the feasibility and usefulness of incremental, optimistic specialization by applying it to file system code in a commercial operating system (HP-UX).
Reference: [26] <author> David Mosberger, Larry L. Peterson, and Sean O'Malley. </author> <title> Protocol Latency: MIPS and Reality. </title> <type> Report TR 95-02, </type> <institution> Dept of Computer Science, University of Arizona, Tuscon, Arizona, </institution> <month> April </month> <year> 1995. </year>
Reference-contexts: Third, the explicit use of invariants and guards in Syn-thetix also supports the composability of specializations: guards determine whether two specializations are compos-able. Other extensible operating systems do not provide support to determine whether separate extensions are com-posable. Like Synthetix, Scout <ref> [26] </ref> has focused on the specialization of existing systems code. Scout has concentrated on networking code and has focused on specializations that minimize code and data caching effects. In contrast, we have focused on parametric specialization to reduce the length of various fast paths in the kernel.
Reference: [27] <author> S. J. Mullender, G. van Rossum, A. S. Tanenbaum, R. van Renesse, and H. van Staveren. </author> <title> Amoeba | A distributed Operating System for the 1990's. </title> <journal> IEEE Computer, </journal> <volume> 23(5), </volume> <month> May </month> <year> 1990. </year>
Reference-contexts: Micro-kernel operating systems <ref> [5, 6, 11, 9, 21, 27, 29] </ref> were an early example of this trend, and improve adaptiveness by allowing operating system functionality to be implemented in user-level servers that can be customized and configured to produce special-purpose operating systems.
Reference: [28] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <month> Winter </month> <year> 1988. </year>
Reference-contexts: Given a list of invariants, which may be available either statically or dynamically, a combination of compile-time and run-time PE should be capable of generating the required specialized code. For example, the Synthesis kernel <ref> [28] </ref> performed the (conceptual) PE step just once, at runtime during open. <p> We have shown how this model supports the concepts of incremental and optimistic specialization. These concepts refine previous work on kernel optimization using dynamic code generation in Synthesis <ref> [28, 25] </ref>. We have demonstrated the feasibility and usefulness of incremental, optimistic specialization by applying it to file system code in a commercial operating system (HP-UX).
Reference: [29] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrman, C. Kaiser, S. Langlois, P. Leonard, and W. Neuhauser. </author> <title> Overview of the Chorus distributed operating system. </title> <booktitle> In Proceedings of the Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pages 39-69, </pages> <address> Seattle, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: Micro-kernel operating systems <ref> [5, 6, 11, 9, 21, 27, 29] </ref> were an early example of this trend, and improve adaptiveness by allowing operating system functionality to be implemented in user-level servers that can be customized and configured to produce special-purpose operating systems. <p> While micro-kernel-based architectures improve adaptiveness over monolithic kernels, support for user-level servers incurs a high performance penalty. To address this performance problem Chorus <ref> [29] </ref> allows modules, known as supervisor actors, to be loaded into the kernel address space. A specialized IPC mechanism is used for communication between actors within the kernel address space.
Reference: [30] <author> P. Sestoft and A. V. Zamulin. </author> <title> Annotated bibliography on partial evaluation and mixed computation. </title> <editor> In D. Bjtrner, A. P. Ershov, and N. D. Jones, editors, </editor> <title> Partial Evaluation and Mixed Computation. </title> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference-contexts: Related work is discussed in section 6. Section 7 concludes the paper. 2 What is Specialization? Program specialization, also called partial evaluation (PE), is a program transformation process aimed at customizing a program based on parts of its input <ref> [13, 30] </ref>. In essence, this process consists of performing constant propagation and folding, generalized to arbitrary computations. In principle, program specialization can be applied to any program that exhibits interpretation. That is, any program whose control flow is determined by the analysis of some data.
Reference: [31] <author> Yasuhiko Yokote. </author> <title> The Apertos Reflective Operating System: The Concept and Its Implementation. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (OOP-SLA), </booktitle> <pages> pages 414-434, </pages> <address> Vancouver, BC, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: The Substrate Object Model [3] supports extensibility in the AIX kernel by providing additional interfaces for passing usage hints and customizing in-kernel implementations. Similarly, the Apertos operating system <ref> [31] </ref> supports dynamic reconfiguration by modifying an object's behavior through operations on its meta-interface. Other systems, such as the Cache kernel [10] and the Exo-kernel [17] address the performance problem by moving even more functionality out of the operating system kernel and placing it closer to the application.
References-found: 31

