URL: ftp://ftp.cs.brown.edu/pub/techreports/94/cs94-28.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-94-28.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> S. Abiteboul and C. Beeri. </author> <title> On the Power of Languages for the Manipulation of Complex Objects. </title> <note> INRIA Research Report 846, </note> <year> 1988. </year>
Reference-contexts: For the problem of type inference we refer to [29]. It is possible to "naturally embed" in the typed lambda calculus with equality many database query languages including the relational calculus/algebra [20], Datalog (with or without negation) [18, 31, 6], and the complex object calculus/algebra (with or without powerset) <ref> [1, 3] </ref>. <p> It is possible to extend the scheme above to an encoding of fixpoints and even Abiteboul's and Beeri's Complex Object Algebra <ref> [1] </ref>. This takes us from 26 Gerd Hillebrand, Paris Kanellakis, and Sridhar Ramaswamy manipulating "flat" relations to more complicated data structures, namely arbitrary finite trees built from tuple and set constructors. <p> They are "pure," without added constructs or added polymorphism. For example, the typed - calculus with equality is the simplest syntax to date, that can be used to describe the complex object algebra of <ref> [1] </ref>. In our embeddings we use lists of tuples and Functional Programming Formalisms for OODB Methods 27 simulate sets by eliminating duplicates. In [1, 15, 13] sets are used as basic constructs, and set iteration replaces list iteration in [15, 13]. <p> For example, the typed - calculus with equality is the simplest syntax to date, that can be used to describe the complex object algebra of [1]. In our embeddings we use lists of tuples and Functional Programming Formalisms for OODB Methods 27 simulate sets by eliminating duplicates. In <ref> [1, 15, 13] </ref> sets are used as basic constructs, and set iteration replaces list iteration in [15, 13]. One open question is: how can the -calculus syntax and semantics be augmented with set iteration? Not all database query languages can be embedded in the typed -calculus. <p> Such a formalism would have all the object-oriented features of MS and the expressibility and data abstraction capabilities of TLC = . Given the organization of data into collections one would like the evaluation mechanism to emphasize sets, as in <ref> [1, 15, 13] </ref>. Object-oriented dialects of Lisp [7] illustrate such linguistic syntheses (without sets and with a less clear type system). The challenge is to come up with a simply typed (and elegant) formal synthesis, that also facilitates the manipulation of collections of objects.
Reference: 2. <author> S. Abiteboul and P. Kanellakis. </author> <title> Object Identity as a Query Language Primitive. </title> <booktitle> In Proceedings ACM SIGMOD, </booktitle> <pages> pp. 159-173, </pages> <year> 1989. </year> <note> (Also INRIA Tech. Rep. 1022, </note> <year> 1989.) </year>
Reference-contexts: Object assignments: We assume the existence of a countably infinite set of objects (o 1 ; o 2 ; : : :) disjoint from classes and methods. We use object assignments <ref> [2] </ref> to provide semantics for classes with inheritance. The semantics of base methods is defined using partial functions satisfying certain signature con straints. Definition 2. <p> Any computation that is not elementary is not captured by our framework. What should be added to the typed -calculus to capture exactly the more powerful database query languages such as the computable queries of <ref> [16, 2] </ref>? The use of reduction strategies in these embeddings provides a link between complexity theory, finite model theory, and the typed -calculus, that should be further investigated.
Reference: 3. <author> S. Abiteboul and P. Kanellakis. </author> <title> Database Theory Column: Query Languages for Complex Object Databases. </title> <journal> SIGACT News, </journal> <volume> 21 (1990), </volume> <pages> pp. 9-18. </pages>
Reference-contexts: For the problem of type inference we refer to [29]. It is possible to "naturally embed" in the typed lambda calculus with equality many database query languages including the relational calculus/algebra [20], Datalog (with or without negation) [18, 31, 6], and the complex object calculus/algebra (with or without powerset) <ref> [1, 3] </ref>.
Reference: 4. <author> S. Abiteboul, P. Kanellakis, S. Ramaswamy, and E. Waller. </author> <title> Method Schemas. </title> <institution> Brown University Tech. </institution> <type> Rep. </type> <institution> CS-92-33, </institution> <year> 1992. </year> <note> (An earlier version appeared in Proceedings 9th ACM PODS, </note> <year> 1990.) </year>
Reference-contexts: We relate these two programming formalisms to OODBs and in particular to the description of OODB methods. In order to accomplish this: (1) We modify applicative program schemas into an OODB formalism called method schemas (MS) in <ref> [4] </ref>. We show that method schemas (over ordered databases) express exactly the PTIME queries. (2) We present the typed lambda calculus as a formalism for expressing a wide range of relational and complex-object database queries [25]. <p> So, in terms of expressive power, the typed lambda calculus is the more general (even if not the more convenient) framework. By our overview of the approaches in <ref> [4, 25] </ref> and our new characterization of the expressive power of method schemas we demonstrate how many notions from relational and object-oriented databases can be formulated, with no loss of generality, in pure functional form. More specifically, we proceed as follows. <p> A more precise term for this problem would be signature inference. The incremental version of consistency checking for method schemas is an algorithmic formalization of the database schema evolution problem <ref> [4, 10, 26, 39, 43, 45] </ref>. In Section 2.2, we survey the state-of-the-art on consistency checking. We use various algorithmic techniques and techniques from the theory of program schemas, e.g., [8, 33]. <p> A solution that is adopted practically (e.g., [9]) is to maintain a dependency graph of the methods and recompile only methods that may have been affected by the update. Of course, understanding what may be affected is the crucial part. We briefly summarize some results from <ref> [4] </ref> (on what may be affected) and some open questions. Let n be the size of method definitions in the input method schema and c the size of the class hierarchy. In the general case of polyadic recursive schemas, consistency is undecidable.
Reference: 5. <author> S. Abiteboul, G. Lausen, H. Uphoff, and E. Waller. </author> <title> Methods and Rules. </title> <booktitle> In Proceedings ACM SIGMOD, </booktitle> <pages> pp. 32-41, </pages> <year> 1993. </year>
Reference-contexts: For finite ordered interpretations this is a functional characterization of PTIME (analogous to the logical characterizations of [27, 42]). A different functional characterization in terms of equations is presented in [24]. Note also that, Datalog with negation has been used in <ref> [5] </ref> to provide semantics to a number of variations of method schemas. In Section 3.1 we outline the input-output conventions, in Section 3.2 we argue that every PTIME query is expressible, and in Section 3.3 that only PTIME queries are expressible.
Reference: 6. <author> S. Abiteboul and V. Vianu. </author> <title> Datalog Extensions for Database Queries and Updates. </title> <journal> JCSS, </journal> <volume> 43 (1991), </volume> <pages> pp. 62-124. </pages>
Reference-contexts: We use various algorithmic techniques and techniques from the theory of program schemas, e.g., [8, 33]. In Section 3, we examine the expressive power of MS by relating it to the more Functional Programming Formalisms for OODB Methods 3 conventional formalisms of relational calculus [20] and Datalog with negation <ref> [18, 31, 6] </ref>. For finite ordered interpretations this is a functional characterization of PTIME (analogous to the logical characterizations of [27, 42]). A different functional characterization in terms of equations is presented in [24]. <p> We refer to [25] for how to remove equality from this calculus. For the problem of type inference we refer to [29]. It is possible to "naturally embed" in the typed lambda calculus with equality many database query languages including the relational calculus/algebra [20], Datalog (with or without negation) <ref> [18, 31, 6] </ref>, and the complex object calculus/algebra (with or without powerset) [1, 3].
Reference: 7. <author> N. Adams and J. Rees. </author> <title> Object-Oriented Programming in Scheme. </title> <booktitle> In Proceedings ACM Lisp and Functional Programming, </booktitle> <pages> pp. 277-288, </pages> <year> 1988. </year> <note> 28 Gerd Hillebrand, Paris Kanellakis, and Sridhar Ramaswamy </note>
Reference-contexts: Such a formalism would have all the object-oriented features of MS and the expressibility and data abstraction capabilities of TLC = . Given the organization of data into collections one would like the evaluation mechanism to emphasize sets, as in [1, 15, 13]. Object-oriented dialects of Lisp <ref> [7] </ref> illustrate such linguistic syntheses (without sets and with a less clear type system). The challenge is to come up with a simply typed (and elegant) formal synthesis, that also facilitates the manipulation of collections of objects.
Reference: 8. <author> E. Ashcroft, Z. Manna, and A. Pnueli. </author> <title> Decidable Properties of Monadic Functional Schemas. </title> <journal> JACM, </journal> <volume> 20 (1973), </volume> <pages> pp. 489-499. </pages>
Reference-contexts: The incremental version of consistency checking for method schemas is an algorithmic formalization of the database schema evolution problem [4, 10, 26, 39, 43, 45]. In Section 2.2, we survey the state-of-the-art on consistency checking. We use various algorithmic techniques and techniques from the theory of program schemas, e.g., <ref> [8, 33] </ref>. In Section 3, we examine the expressive power of MS by relating it to the more Functional Programming Formalisms for OODB Methods 3 conventional formalisms of relational calculus [20] and Datalog with negation [18, 31, 6]. <p> In the case of monadic schemas, the set of possible computations can be described using a context-free language. An inconsistency may be reached if this language has a non-empty intersection with a particular regular language. To handle overloading, one can use a modification of a technique of <ref> [8] </ref>. The decision procedure runs in O (nc 3 ) time. In the case of monadic and recursion-free schemas, checking a whole schema for consistency is logspace-complete in PTIME. This indicates that very efficient incremental solutions for even the simplest syntactic cases may be hard to obtain.
Reference: 9. <editor> F. Bancilhon, C. Delobel, and P. Kanellakis, editors. </editor> <title> Building an Object-Oriented Database System: The Story of O 2 . Morgan-Kaufmann, </title> <year> 1992. </year>
Reference-contexts: 1 Introduction Object-oriented databases (OODBs) represent a new generation of database technology, which has developed through a combination of advanced programming language features and successful relational/network database techniques, see <ref> [9, 30, 44] </ref>. Both programming language theory and database theory have fl Research supported by ONR Contract N00014-91-J-4052, ARPA Order 8225. 2 Gerd Hillebrand, Paris Kanellakis, and Sridhar Ramaswamy been proposed as starting points for OODB formal foundations. <p> Because of the function-centric character of OODBs we believe that this is one of the most promising approaches to the problem of their formalization. Note that some of the actual query languages in OODB prototypes are functional <ref> [9] </ref> and that recent research on complex-objects and types has emphasized functional models [13, 14]. Two well-studied functional formalisms in the theory of programming languages are (1) applicative program schemas [21, 23] and (2) typed lambda calculi [19, 11, 12]. <p> In an object-oriented context, it is not reasonable to recompile all methods each time the schema is updated. The problem is to obtain an incremental consistency checking algorithm that would avoid redoing the same verifications/computations. A solution that is adopted practically (e.g., <ref> [9] </ref>) is to maintain a dependency graph of the methods and recompile only methods that may have been affected by the update. Of course, understanding what may be affected is the crucial part. We briefly summarize some results from [4] (on what may be affected) and some open questions.
Reference: 10. <author> J. Banerjee, W. Kim, H-J. Kim, and H. Korth. </author> <title> Semantics and Implementation of Schema Evolution in Object-Oriented Databases. </title> <booktitle> In Proceedings ACM SIGMOD, </booktitle> <pages> pp. 311-322, </pages> <year> 1987. </year>
Reference-contexts: A more precise term for this problem would be signature inference. The incremental version of consistency checking for method schemas is an algorithmic formalization of the database schema evolution problem <ref> [4, 10, 26, 39, 43, 45] </ref>. In Section 2.2, we survey the state-of-the-art on consistency checking. We use various algorithmic techniques and techniques from the theory of program schemas, e.g., [8, 33].
Reference: 11. <author> H. Barendregt. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> North Holland, </publisher> <year> 1984. </year>
Reference-contexts: Two well-studied functional formalisms in the theory of programming languages are (1) applicative program schemas [21, 23] and (2) typed lambda calculi <ref> [19, 11, 12] </ref>. We relate these two programming formalisms to OODBs and in particular to the description of OODB methods. In order to accomplish this: (1) We modify applicative program schemas into an OODB formalism called method schemas (MS) in [4]. <p> Theorem 13 (Strong normalization property). For each e, there exists an integer n such that if e &gt; e 0 , then the derivation involves no more than n fi-reductions. For more details, see for example <ref> [19, 11] </ref>. In particular, [11, Section 15.3] discusses the Church-Rosser property for the untyped -calculus enriched with equality. We refer to [25] for how to remove equality from the language. <p> Theorem 13 (Strong normalization property). For each e, there exists an integer n such that if e &gt; e 0 , then the derivation involves no more than n fi-reductions. For more details, see for example [19, 11]. In particular, <ref> [11, Section 15.3] </ref> discusses the Church-Rosser property for the untyped -calculus enriched with equality. We refer to [25] for how to remove equality from the language.
Reference: 12. <author> H. Barendregt. </author> <title> Functional Programming and Lambda Calculus. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. B, </volume> <pages> pp. 321-363. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: Two well-studied functional formalisms in the theory of programming languages are (1) applicative program schemas [21, 23] and (2) typed lambda calculi <ref> [19, 11, 12] </ref>. We relate these two programming formalisms to OODBs and in particular to the description of OODB methods. In order to accomplish this: (1) We modify applicative program schemas into an OODB formalism called method schemas (MS) in [4]. <p> The fact that the subterm and its replacement have the same type is referred to as the subject reduction theorem <ref> [12, Theorem 4.2.8] </ref>. We write &gt; for the reflexive, transitive closure of &gt; ff and &gt; fi .
Reference: 13. <author> V. Breazu-Tannen, P. Buneman, and S. Naqvi. </author> <title> Structural Recursion as a Query Language. </title> <booktitle> In Proceedings DBPL3, </booktitle> <pages> pp. 9-19. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: Note that some of the actual query languages in OODB prototypes are functional [9] and that recent research on complex-objects and types has emphasized functional models <ref> [13, 14] </ref>. Two well-studied functional formalisms in the theory of programming languages are (1) applicative program schemas [21, 23] and (2) typed lambda calculi [19, 11, 12]. We relate these two programming formalisms to OODBs and in particular to the description of OODB methods. <p> For example, the typed - calculus with equality is the simplest syntax to date, that can be used to describe the complex object algebra of [1]. In our embeddings we use lists of tuples and Functional Programming Formalisms for OODB Methods 27 simulate sets by eliminating duplicates. In <ref> [1, 15, 13] </ref> sets are used as basic constructs, and set iteration replaces list iteration in [15, 13]. One open question is: how can the -calculus syntax and semantics be augmented with set iteration? Not all database query languages can be embedded in the typed -calculus. <p> In our embeddings we use lists of tuples and Functional Programming Formalisms for OODB Methods 27 simulate sets by eliminating duplicates. In [1, 15, 13] sets are used as basic constructs, and set iteration replaces list iteration in <ref> [15, 13] </ref>. One open question is: how can the -calculus syntax and semantics be augmented with set iteration? Not all database query languages can be embedded in the typed -calculus. Any computation that is not elementary is not captured by our framework. <p> Such a formalism would have all the object-oriented features of MS and the expressibility and data abstraction capabilities of TLC = . Given the organization of data into collections one would like the evaluation mechanism to emphasize sets, as in <ref> [1, 15, 13] </ref>. Object-oriented dialects of Lisp [7] illustrate such linguistic syntheses (without sets and with a less clear type system). The challenge is to come up with a simply typed (and elegant) formal synthesis, that also facilitates the manipulation of collections of objects.
Reference: 14. <author> V. Breazu-Tannen, P. Buneman, and L. Wong. </author> <title> Naturally Embedded Query Languages. </title> <booktitle> In Proceedings 4th ICDT. </booktitle> <publisher> LNCS, Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Note that some of the actual query languages in OODB prototypes are functional [9] and that recent research on complex-objects and types has emphasized functional models <ref> [13, 14] </ref>. Two well-studied functional formalisms in the theory of programming languages are (1) applicative program schemas [21, 23] and (2) typed lambda calculi [19, 11, 12]. We relate these two programming formalisms to OODBs and in particular to the description of OODB methods.
Reference: 15. <author> P. Buneman, R. Frankel, and R. Nikhil. </author> <title> An Implementation Technique for Database Query Languages. </title> <journal> ACM TODS, </journal> <volume> 7 (1982), </volume> <pages> pp. 164-186. </pages>
Reference-contexts: This is a function-centric (or method-centric) view of data as opposed to the structure-centric view of data in relational databases (e.g., in [28, 41]). Interesting functional approaches to database query languages have been advocated in the past, e.g., <ref> [15, 38] </ref>, but much remains to be done in this area. Because of the function-centric character of OODBs we believe that this is one of the most promising approaches to the problem of their formalization. <p> For example, the typed - calculus with equality is the simplest syntax to date, that can be used to describe the complex object algebra of [1]. In our embeddings we use lists of tuples and Functional Programming Formalisms for OODB Methods 27 simulate sets by eliminating duplicates. In <ref> [1, 15, 13] </ref> sets are used as basic constructs, and set iteration replaces list iteration in [15, 13]. One open question is: how can the -calculus syntax and semantics be augmented with set iteration? Not all database query languages can be embedded in the typed -calculus. <p> In our embeddings we use lists of tuples and Functional Programming Formalisms for OODB Methods 27 simulate sets by eliminating duplicates. In [1, 15, 13] sets are used as basic constructs, and set iteration replaces list iteration in <ref> [15, 13] </ref>. One open question is: how can the -calculus syntax and semantics be augmented with set iteration? Not all database query languages can be embedded in the typed -calculus. Any computation that is not elementary is not captured by our framework. <p> Such a formalism would have all the object-oriented features of MS and the expressibility and data abstraction capabilities of TLC = . Given the organization of data into collections one would like the evaluation mechanism to emphasize sets, as in <ref> [1, 15, 13] </ref>. Object-oriented dialects of Lisp [7] illustrate such linguistic syntheses (without sets and with a less clear type system). The challenge is to come up with a simply typed (and elegant) formal synthesis, that also facilitates the manipulation of collections of objects.
Reference: 16. <author> A. Chandra and D. Harel. </author> <title> Computable Queries for Relational Databases. </title> <journal> JCSS, </journal> <volume> 21 (1980), </volume> <pages> pp. 156-178. </pages>
Reference-contexts: This takes us from 26 Gerd Hillebrand, Paris Kanellakis, and Sridhar Ramaswamy manipulating "flat" relations to more complicated data structures, namely arbitrary finite trees built from tuple and set constructors. The algebra under consideration is extremely powerful|in fact it expresses any "generic" (see <ref> [16] </ref>) elementary time computation on finite structures. Theorem 15. Let (R 1 ; : : :; R l ) be a complex object algebra expression over the relational schema S = (R 1 ; : : : ; R l ). <p> Any computation that is not elementary is not captured by our framework. What should be added to the typed -calculus to capture exactly the more powerful database query languages such as the computable queries of <ref> [16, 2] </ref>? The use of reduction strategies in these embeddings provides a link between complexity theory, finite model theory, and the typed -calculus, that should be further investigated.
Reference: 17. <author> A. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <journal> JCSS, </journal> <volume> 25 (1982), </volume> <pages> pp. 99-128. </pages>
Reference-contexts: We refer to [25] for the more advanced fixpoint and powerset features. Note that these features allow the embedding of higher-order queries, e.g., the second-order queries of <ref> [22, 17] </ref>. Note that we only use the very core of programming language type systems, i.e., only simple types without any polymorphism.
Reference: 18. <author> A. Chandra and D. Harel. </author> <title> Horn Clause Queries and Generalizations. </title> <journal> JLP, </journal> <volume> 2 (1985), </volume> <pages> pp. 1-15. </pages>
Reference-contexts: We use various algorithmic techniques and techniques from the theory of program schemas, e.g., [8, 33]. In Section 3, we examine the expressive power of MS by relating it to the more Functional Programming Formalisms for OODB Methods 3 conventional formalisms of relational calculus [20] and Datalog with negation <ref> [18, 31, 6] </ref>. For finite ordered interpretations this is a functional characterization of PTIME (analogous to the logical characterizations of [27, 42]). A different functional characterization in terms of equations is presented in [24]. <p> We refer to [25] for how to remove equality from this calculus. For the problem of type inference we refer to [29]. It is possible to "naturally embed" in the typed lambda calculus with equality many database query languages including the relational calculus/algebra [20], Datalog (with or without negation) <ref> [18, 31, 6] </ref>, and the complex object calculus/algebra (with or without powerset) [1, 3].
Reference: 19. <author> A. Church. </author> <title> The Calculi of Lambda-Conversion. </title> <publisher> Princeton University Press, </publisher> <year> 1941. </year>
Reference-contexts: Two well-studied functional formalisms in the theory of programming languages are (1) applicative program schemas [21, 23] and (2) typed lambda calculi <ref> [19, 11, 12] </ref>. We relate these two programming formalisms to OODBs and in particular to the description of OODB methods. In order to accomplish this: (1) We modify applicative program schemas into an OODB formalism called method schemas (MS) in [4]. <p> Theorem 13 (Strong normalization property). For each e, there exists an integer n such that if e &gt; e 0 , then the derivation involves no more than n fi-reductions. For more details, see for example <ref> [19, 11] </ref>. In particular, [11, Section 15.3] discusses the Church-Rosser property for the untyped -calculus enriched with equality. We refer to [25] for how to remove equality from the language.
Reference: 20. <author> E. Codd. </author> <title> Relational Completeness of Database Sublanguages. </title> <editor> In R. Rustin, editor, </editor> <booktitle> Database Systems, </booktitle> <pages> pp. 65-98. </pages> <publisher> Prentice Hall, </publisher> <year> 1972. </year>
Reference-contexts: We use various algorithmic techniques and techniques from the theory of program schemas, e.g., [8, 33]. In Section 3, we examine the expressive power of MS by relating it to the more Functional Programming Formalisms for OODB Methods 3 conventional formalisms of relational calculus <ref> [20] </ref> and Datalog with negation [18, 31, 6]. For finite ordered interpretations this is a functional characterization of PTIME (analogous to the logical characterizations of [27, 42]). A different functional characterization in terms of equations is presented in [24]. <p> We refer to [25] for how to remove equality from this calculus. For the problem of type inference we refer to [29]. It is possible to "naturally embed" in the typed lambda calculus with equality many database query languages including the relational calculus/algebra <ref> [20] </ref>, Datalog (with or without negation) [18, 31, 6], and the complex object calculus/algebra (with or without powerset) [1, 3]. <p> The (more simple) encoding given below uses types of order 4. Functional Programming Formalisms for OODB Methods 21 5.2 Expressing Relational Queries In this section, we show how to express the relational algebra operators of <ref> [20] </ref> in the simply typed lambda calculus with equality. Every operator is coded as a -term that takes one or two relations in the list-of-tuples format described in Section 5.1 as input and produces another relation in the same format as output.
Reference: 21. <author> B. Courcelle. </author> <title> Recursive Applicative Program Schemes. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. B, </volume> <pages> pp. 459-492. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: Note that some of the actual query languages in OODB prototypes are functional [9] and that recent research on complex-objects and types has emphasized functional models [13, 14]. Two well-studied functional formalisms in the theory of programming languages are (1) applicative program schemas <ref> [21, 23] </ref> and (2) typed lambda calculi [19, 11, 12]. We relate these two programming formalisms to OODBs and in particular to the description of OODB methods. In order to accomplish this: (1) We modify applicative program schemas into an OODB formalism called method schemas (MS) in [4].
Reference: 22. <author> R. Fagin. </author> <title> Generalized First-Order Spectra and Polynomial-Time Recognizable Sets. </title> <booktitle> SIAM-AMS Proceedings, 7 (1974), </booktitle> <pages> pp. 43-73. </pages>
Reference-contexts: We refer to [25] for the more advanced fixpoint and powerset features. Note that these features allow the embedding of higher-order queries, e.g., the second-order queries of <ref> [22, 17] </ref>. Note that we only use the very core of programming language type systems, i.e., only simple types without any polymorphism.
Reference: 23. <author> S. Greibach. </author> <title> Theory of Program Structures: Schemes, Semantics, </title> <booktitle> Verification. </booktitle> <volume> LNCS Vol. 36, </volume> <publisher> Springer, </publisher> <year> 1975. </year>
Reference-contexts: Note that some of the actual query languages in OODB prototypes are functional [9] and that recent research on complex-objects and types has emphasized functional models [13, 14]. Two well-studied functional formalisms in the theory of programming languages are (1) applicative program schemas <ref> [21, 23] </ref> and (2) typed lambda calculi [19, 11, 12]. We relate these two programming formalisms to OODBs and in particular to the description of OODB methods. In order to accomplish this: (1) We modify applicative program schemas into an OODB formalism called method schemas (MS) in [4].
Reference: 24. <author> Y. Gurevich. </author> <title> Algebras of Feasible Functions. </title> <booktitle> In Proceedings 24th IEEE FOCS, </booktitle> <pages> pp. 210-214, </pages> <year> 1983. </year>
Reference-contexts: For finite ordered interpretations this is a functional characterization of PTIME (analogous to the logical characterizations of [27, 42]). A different functional characterization in terms of equations is presented in <ref> [24] </ref>. Note also that, Datalog with negation has been used in [5] to provide semantics to a number of variations of method schemas. <p> Given the emphasis of database theory on efficiency, we can restrict ourselves to PTIME queries. For PTIME queries we present here a method schema framework (Section 3) and the basis for a lambda calculus framework (Section 5 and [25]). For other functional characterizations of PTIME we refer to <ref> [24, 32] </ref>.
Reference: 25. <author> G. Hillebrand, P. Kanellakis, and H. Mairson. </author> <title> Database Query Languages Embedded in the Typed Lambda Calculus. </title> <booktitle> In Proceedings 8th IEEE LICS, </booktitle> <year> 1993. </year>
Reference-contexts: We show that method schemas (over ordered databases) express exactly the PTIME queries. (2) We present the typed lambda calculus as a formalism for expressing a wide range of relational and complex-object database queries <ref> [25] </ref>. In this case, the elementary time queries (which properly contain the PTIME queries) are expressible, because of a limited ability to create and manipulate list structures. So, in terms of expressive power, the typed lambda calculus is the more general (even if not the more convenient) framework. <p> So, in terms of expressive power, the typed lambda calculus is the more general (even if not the more convenient) framework. By our overview of the approaches in <ref> [4, 25] </ref> and our new characterization of the expressive power of method schemas we demonstrate how many notions from relational and object-oriented databases can be formulated, with no loss of generality, in pure functional form. More specifically, we proceed as follows. <p> The notion of types here is structural and quite different from the notion of classes. In Section 4, we present some basic background on the syntax, the operational semantics, and the types of the simply typed lambda calculus with equality (TLC = ). We refer to <ref> [25] </ref> for how to remove equality from this calculus. For the problem of type inference we refer to [29]. <p> In Section 5.2 we present, as an extended example, the embedding of the relational algebra. Our analysis of the expressive power of the simply typed lambda calculus is based on the analysis of reduction sequences of [40, 34]. We refer to <ref> [25] </ref> for the more advanced fixpoint and powerset features. Note that these features allow the embedding of higher-order queries, e.g., the second-order queries of [22, 17]. Note that we only use the very core of programming language type systems, i.e., only simple types without any polymorphism. <p> Note that we only use the very core of programming language type systems, i.e., only simple types without any polymorphism. It is interesting that the (otherwise very convenient) use of method names in method schemas and their recursive definition can all be simulated using the fixpoints of <ref> [25] </ref> in the typed lambda calculus. The embeddings we present form the first step in understanding the connec 4 Gerd Hillebrand, Paris Kanellakis, and Sridhar Ramaswamy tions between functional programming and databases. Given the emphasis of database theory on efficiency, we can restrict ourselves to PTIME queries. <p> Given the emphasis of database theory on efficiency, we can restrict ourselves to PTIME queries. For PTIME queries we present here a method schema framework (Section 3) and the basis for a lambda calculus framework (Section 5 and <ref> [25] </ref>). For other functional characterizations of PTIME we refer to [24, 32]. <p> For more details, see for example [19, 11]. In particular, [11, Section 15.3] discusses the Church-Rosser property for the untyped -calculus enriched with equality. We refer to <ref> [25] </ref> for how to remove equality from the language. For results concerning the type inference problem for TLC and its extensions, i. e. the problem of deciding whether a given (untyped) term can be typed, see for 18 Gerd Hillebrand, Paris Kanellakis, and Sridhar Ramaswamy example [29].
Reference: 26. <author> R. Hull, K. Tanaka, and M. Yoshikawa. </author> <title> Behavior Analysis of Object-Oriented Databases: Method Structure, Execution Trees and Reachability. </title> <booktitle> In Proceedings 3rd International Conference on Foundations of Data Organization and Algorithms, </booktitle> <address> Paris 1989. </address>
Reference-contexts: A more precise term for this problem would be signature inference. The incremental version of consistency checking for method schemas is an algorithmic formalization of the database schema evolution problem <ref> [4, 10, 26, 39, 43, 45] </ref>. In Section 2.2, we survey the state-of-the-art on consistency checking. We use various algorithmic techniques and techniques from the theory of program schemas, e.g., [8, 33]. <p> A variety of questions are important in this setting, e.g.: (1) Is a schema consistent? (2) Are there possible/certain diverging computations? (3) Is method m (at c) possibly/certainly "reachable" from m 0 (at c 0 ) <ref> [26] </ref>? We concentrate here on (1) although most of the techniques that we develop can be used for studying other problems such as (2) or (3). Two properties simplify consistency checking: monadic arity and absence of recursion.
Reference: 27. <author> N. Immerman. </author> <title> Relational Queries Computable in Polynomial Time. </title> <journal> Info. and Comp., </journal> <volume> 68 (1986), </volume> <pages> pp. 86-104. </pages>
Reference-contexts: For finite ordered interpretations this is a functional characterization of PTIME (analogous to the logical characterizations of <ref> [27, 42] </ref>). A different functional characterization in terms of equations is presented in [24]. Note also that, Datalog with negation has been used in [5] to provide semantics to a number of variations of method schemas. <p> The results of Immerman <ref> [27] </ref> and Vardi [42] then imply that method schemas can compute all PTIME queries over finite ordered databases. To begin with, let us illustrate how to code simple Boolean and arithmetical functions. We represent the truth values True and False by the classes Number and Zero.
Reference: 28. <author> P. Kanellakis. </author> <title> Elements of Relational Database Theory. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. B, </volume> <pages> pp. 1073-1156. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: We view the organization of data into objects with methods as the core new feature of OODBs. This is a function-centric (or method-centric) view of data as opposed to the structure-centric view of data in relational databases (e.g., in <ref> [28, 41] </ref>). Interesting functional approaches to database query languages have been advocated in the past, e.g., [15, 38], but much remains to be done in this area. <p> In this section, we describe a very simple way of encoding relations as interpreted base methods, and we show that under this interpretation, method schemas express exactly the PTIME queries. We assume some familiarity with Datalog terminology and notation from <ref> [28, 41] </ref>, e.g., rules, EDBs, IDBs etc. 3.1 I/O Conventions We consider queries over finite ordered relational databases. <p> of the output; if q (~x) reduces to an object of class Zero, then the tuple represented by ~x is not considered part of the output. 3.2 Expressing PTIME Queries We show that under the input/output conventions given above, method schemas can compute inflationary fixpoints of Datalog : programs (see <ref> [28] </ref> for a survey of these concepts). The results of Immerman [27] and Vardi [42] then imply that method schemas can compute all PTIME queries over finite ordered databases. To begin with, let us illustrate how to code simple Boolean and arithmetical functions.
Reference: 29. <author> P. Kanellakis, J. Mitchell, and H. Mairson. </author> <title> Unification and ML-type reconstruction. </title> <editor> In J-L. Lassez and G. Plotkin, editors, </editor> <booktitle> Computational Logic: Essays in Honor of Alan Robinson, </booktitle> <pages> pp. 444-479. </pages> <publisher> MIT Press, </publisher> <year> 1991. </year> <booktitle> (Also in Proceedings 16th ACM POPL, 1989 and Proceedings 17th ACM POPL, </booktitle> <year> 1990.) </year> <title> Functional Programming Formalisms for OODB Methods 29 </title>
Reference-contexts: In Section 4, we present some basic background on the syntax, the operational semantics, and the types of the simply typed lambda calculus with equality (TLC = ). We refer to [25] for how to remove equality from this calculus. For the problem of type inference we refer to <ref> [29] </ref>. It is possible to "naturally embed" in the typed lambda calculus with equality many database query languages including the relational calculus/algebra [20], Datalog (with or without negation) [18, 31, 6], and the complex object calculus/algebra (with or without powerset) [1, 3]. <p> We refer to [25] for how to remove equality from the language. For results concerning the type inference problem for TLC and its extensions, i. e. the problem of deciding whether a given (untyped) term can be typed, see for 18 Gerd Hillebrand, Paris Kanellakis, and Sridhar Ramaswamy example <ref> [29] </ref>. The type inference problem for TLC = is equivalent to first-order unification. Note that, the language presented above is the "simplest" typed lambda calculus.
Reference: 30. <author> W. Kim, F. </author> <title> Lochovsky. Object-Oriented Concepts, Applications, and Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: 1 Introduction Object-oriented databases (OODBs) represent a new generation of database technology, which has developed through a combination of advanced programming language features and successful relational/network database techniques, see <ref> [9, 30, 44] </ref>. Both programming language theory and database theory have fl Research supported by ONR Contract N00014-91-J-4052, ARPA Order 8225. 2 Gerd Hillebrand, Paris Kanellakis, and Sridhar Ramaswamy been proposed as starting points for OODB formal foundations.
Reference: 31. <author> P. Kolaitis and C. Papadimitriou. </author> <booktitle> Why Not Negation By Fixpoint? In Proceedings 7th ACM PODS, </booktitle> <pages> pp. 231-239, </pages> <year> 1988. </year>
Reference-contexts: We use various algorithmic techniques and techniques from the theory of program schemas, e.g., [8, 33]. In Section 3, we examine the expressive power of MS by relating it to the more Functional Programming Formalisms for OODB Methods 3 conventional formalisms of relational calculus [20] and Datalog with negation <ref> [18, 31, 6] </ref>. For finite ordered interpretations this is a functional characterization of PTIME (analogous to the logical characterizations of [27, 42]). A different functional characterization in terms of equations is presented in [24]. <p> We refer to [25] for how to remove equality from this calculus. For the problem of type inference we refer to [29]. It is possible to "naturally embed" in the typed lambda calculus with equality many database query languages including the relational calculus/algebra [20], Datalog (with or without negation) <ref> [18, 31, 6] </ref>, and the complex object calculus/algebra (with or without powerset) [1, 3].
Reference: 32. <author> D. Leivant and J.-Y. Marion. </author> <title> Lambda Calculus Characterizations of Poly-Time. </title> <booktitle> In Proceedings of the International Conference on Typed Lambda Calculi and Applications, </booktitle> <address> Utrecht 1993. </address> <note> (To appear in Fundamenta Informaticae.) </note>
Reference-contexts: Given the emphasis of database theory on efficiency, we can restrict ourselves to PTIME queries. For PTIME queries we present here a method schema framework (Section 3) and the basis for a lambda calculus framework (Section 5 and [25]). For other functional characterizations of PTIME we refer to <ref> [24, 32] </ref>.
Reference: 33. <author> D. Luckham, D. Park, and M. Paterson. </author> <title> On Formalized Computer Programs. </title> <journal> JCSS, </journal> <volume> 4 (1970), </volume> <pages> pp. 220-249. </pages>
Reference-contexts: The incremental version of consistency checking for method schemas is an algorithmic formalization of the database schema evolution problem [4, 10, 26, 39, 43, 45]. In Section 2.2, we survey the state-of-the-art on consistency checking. We use various algorithmic techniques and techniques from the theory of program schemas, e.g., <ref> [8, 33] </ref>. In Section 3, we examine the expressive power of MS by relating it to the more Functional Programming Formalisms for OODB Methods 3 conventional formalisms of relational calculus [20] and Datalog with negation [18, 31, 6]. <p> In the general case of polyadic recursive schemas, consistency is undecidable. Both polyadic methods and recursion are necessary for this result. The proof is by reduction from results in <ref> [33] </ref>. This undecidability result holds for schemas with methods of arity less than or equal to 3. The decidability of method schema consistency with methods of arity 2 is open. In the case of monadic schemas, the set of possible computations can be described using a context-free language.
Reference: 34. <author> H. Mairson. </author> <title> A Simple Proof of a Theorem of Statman. </title> <journal> TCS, </journal> <volume> 103 (1992), </volume> <pages> pp. 387-394. </pages>
Reference-contexts: In Section 5.2 we present, as an extended example, the embedding of the relational algebra. Our analysis of the expressive power of the simply typed lambda calculus is based on the analysis of reduction sequences of <ref> [40, 34] </ref>. We refer to [25] for the more advanced fixpoint and powerset features. Note that these features allow the embedding of higher-order queries, e.g., the second-order queries of [22, 17].
Reference: 35. <author> R. Milner. </author> <title> A Theory of Type Polymorphism in Programming. </title> <journal> JCSS, </journal> <volume> 17 (1978), </volume> <pages> pp. 348-375. </pages>
Reference-contexts: The type inference problem for TLC = is equivalent to first-order unification. Note that, the language presented above is the "simplest" typed lambda calculus. It has no type polymorphism and is a subset of the core-ML language of <ref> [35] </ref> without let and without any explicit fixpoint construct. 5 The Expressive Power of TLC = The principal technical tool for this section is list iteration. Let us briefly review how it works and its limitations. <p> In our exposition we have explored the relationship with program schemas and simply typed calculi. This is a first step towards more complex database programming language models. For example, let- or ML-polymorphism <ref> [35] </ref> is a very useful feature to include in a functional data model. The language ML has been the basis for many programming language investigations on structure and method inheritance.
Reference: 36. <author> J.C. Mitchell. </author> <title> Toward a Typed Foundation for Method Specialization and Inheritance. </title> <booktitle> In Proceedings 17th ACM POPL, </booktitle> <pages> pp. 109-124, </pages> <year> 1990. </year>
Reference-contexts: The language ML has been the basis for many programming language investigations on structure and method inheritance. The literature is too extensive to even attempt a survey, but for pointers to the recent literature and for a programming language view of some of the issues raised here we recommend <ref> [36, 37] </ref>.
Reference: 37. <author> J.C. Mitchell, F. Honsell, K. Fisher. </author> <title> A Lambda Calculus of Objects and Method Specialization. </title> <booktitle> In Proceedings 8th IEEE LICS, </booktitle> <pages> pp. 26-38, </pages> <year> 1993. </year>
Reference-contexts: The language ML has been the basis for many programming language investigations on structure and method inheritance. The literature is too extensive to even attempt a survey, but for pointers to the recent literature and for a programming language view of some of the issues raised here we recommend <ref> [36, 37] </ref>.
Reference: 38. <author> D. Shipman. </author> <title> The Functional Data Model and the Data Language DAPLEX. </title> <journal> ACM TODS, </journal> <volume> 6 (1981), </volume> <pages> pp. 140-173. </pages>
Reference-contexts: This is a function-centric (or method-centric) view of data as opposed to the structure-centric view of data in relational databases (e.g., in [28, 41]). Interesting functional approaches to database query languages have been advocated in the past, e.g., <ref> [15, 38] </ref>, but much remains to be done in this area. Because of the function-centric character of OODBs we believe that this is one of the most promising approaches to the problem of their formalization.
Reference: 39. <author> A. Skarra and S. Zdonik. </author> <title> Type Evolution in an Object-Oriented Database. </title> <editor> In B. Shriver and P. Wegner, editors, </editor> <booktitle> Research Directions in Object-Oriented Programming, </booktitle> <pages> pp. 393-416. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: A more precise term for this problem would be signature inference. The incremental version of consistency checking for method schemas is an algorithmic formalization of the database schema evolution problem <ref> [4, 10, 26, 39, 43, 45] </ref>. In Section 2.2, we survey the state-of-the-art on consistency checking. We use various algorithmic techniques and techniques from the theory of program schemas, e.g., [8, 33].
Reference: 40. <author> R. Statman. </author> <title> The Typed -Calculus Is Not Elementary Recursive. </title> <journal> TCS, </journal> <volume> 9 (1979), </volume> <pages> pp. 73-81. </pages>
Reference-contexts: In Section 5.2 we present, as an extended example, the embedding of the relational algebra. Our analysis of the expressive power of the simply typed lambda calculus is based on the analysis of reduction sequences of <ref> [40, 34] </ref>. We refer to [25] for the more advanced fixpoint and powerset features. Note that these features allow the embedding of higher-order queries, e.g., the second-order queries of [22, 17].
Reference: 41. <author> J. Ullman. </author> <title> Principles of Database Systems, 2nd ed. </title> <publisher> Computer Science Press, </publisher> <year> 1982. </year>
Reference-contexts: We view the organization of data into objects with methods as the core new feature of OODBs. This is a function-centric (or method-centric) view of data as opposed to the structure-centric view of data in relational databases (e.g., in <ref> [28, 41] </ref>). Interesting functional approaches to database query languages have been advocated in the past, e.g., [15, 38], but much remains to be done in this area. <p> In this section, we describe a very simple way of encoding relations as interpreted base methods, and we show that under this interpretation, method schemas express exactly the PTIME queries. We assume some familiarity with Datalog terminology and notation from <ref> [28, 41] </ref>, e.g., rules, EDBs, IDBs etc. 3.1 I/O Conventions We consider queries over finite ordered relational databases.
Reference: 42. <author> M. Vardi. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> In Proceedings of the 14th ACM STOC, </booktitle> <pages> pp. 137-146, </pages> <year> 1982. </year>
Reference-contexts: For finite ordered interpretations this is a functional characterization of PTIME (analogous to the logical characterizations of <ref> [27, 42] </ref>). A different functional characterization in terms of equations is presented in [24]. Note also that, Datalog with negation has been used in [5] to provide semantics to a number of variations of method schemas. <p> The results of Immerman [27] and Vardi <ref> [42] </ref> then imply that method schemas can compute all PTIME queries over finite ordered databases. To begin with, let us illustrate how to code simple Boolean and arithmetical functions. We represent the truth values True and False by the classes Number and Zero.
Reference: 43. <author> E. Waller. </author> <title> Schema Updates and Consistency. </title> <booktitle> In Proceedings 2nd International Conference on Deductive and Object-oriented Databases, </booktitle> <address> Munich 1991. </address>
Reference-contexts: A more precise term for this problem would be signature inference. The incremental version of consistency checking for method schemas is an algorithmic formalization of the database schema evolution problem <ref> [4, 10, 26, 39, 43, 45] </ref>. In Section 2.2, we survey the state-of-the-art on consistency checking. We use various algorithmic techniques and techniques from the theory of program schemas, e.g., [8, 33].
Reference: 44. <author> S. Zdonik, D. Maier. </author> <title> Readings in Object-Oriented Database Systems. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: 1 Introduction Object-oriented databases (OODBs) represent a new generation of database technology, which has developed through a combination of advanced programming language features and successful relational/network database techniques, see <ref> [9, 30, 44] </ref>. Both programming language theory and database theory have fl Research supported by ONR Contract N00014-91-J-4052, ARPA Order 8225. 2 Gerd Hillebrand, Paris Kanellakis, and Sridhar Ramaswamy been proposed as starting points for OODB formal foundations.
Reference: 45. <author> R. Zicari. </author> <title> A Framework for Schema Updates in an Object-Oriented Database System. </title> <editor> In F. Bancilhon, C. Delobel, and P. Kanellakis, editors, </editor> <title> Building an Object-Oriented Database System: </title> <booktitle> The Story of O 2 , pp. </booktitle> <pages> 146-182. </pages> <publisher> Morgan-Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: A more precise term for this problem would be signature inference. The incremental version of consistency checking for method schemas is an algorithmic formalization of the database schema evolution problem <ref> [4, 10, 26, 39, 43, 45] </ref>. In Section 2.2, we survey the state-of-the-art on consistency checking. We use various algorithmic techniques and techniques from the theory of program schemas, e.g., [8, 33].
References-found: 45

