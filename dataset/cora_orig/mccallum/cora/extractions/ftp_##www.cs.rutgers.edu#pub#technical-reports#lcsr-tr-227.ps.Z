URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-227.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: minsky@cs.rutgers.edu  partha@cs.rutgers.edu  
Title: Establishing Regularities in Object-Oriented (Eiffel) Systems  
Author: Naftaly H. Minsky Partha pratim Pal 
Keyword: regularities, object-oriented systems, law-governed archi tecture, kernel, intensive-care unit.  
Note: Work supported in part by NSF grants No. CCR-9308773, and in part by ARPA Contract Number DABT63-93-C-0064 Work supported by NSF grants No. CCR-9308773  
Date: July 1, 1994  
Address: New Brunswick, NJ 08903 USA  
Affiliation: Department of Computer Science Rutgers University  
Abstract: to the comprehensibility, manageability and reliability of large software systems, and should, therefore, be considered an important element of their architecture. But the inherent globality of regularities makes them very hard to implement in traditional methods. We have argued elsewhere that this difficulty can be alleviated by means of law-governed architecture (LGA), under which a system designers can establish a desired regularity (of a certain kind) simply by declaring it formally and explicitly as the law of the system. Once such a law-governed regularity is declared, it is enforced by the environment in which the system is developed. This paper, which is based on a recently developed environment called Darwin-E, describes the application of LGA to object oriented systems written in the Eiffel language. We introduce here the formalism for specifying laws under Darwin-E, and give a sample of regularities that can be efficiently established by such laws. In particular, we demonstrate how one can establish a kernelized architecture suitable for the construction of critical embedded software, such as the software embedded in an intensive care unit. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Birtwistle G., O. Dahl, B. Myhrtag, and K. Mygaard. </author> <title> Simula Begin. </title> <publisher> Auer-bach Press, </publisher> <year> 1973. </year>
Reference-contexts: This useful notion is supported by both Simula 67 <ref> [1] </ref> and C++ [2], but unfortunately not by Eiffel, in which features of a class are automatically visible in all the descendant of this class. This limitation of Eiffel can be easily rectified under Darwin-E.
Reference: [2] <author> Stanley B. Lippman. </author> <title> C++ Primer. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: This useful notion is supported by both Simula 67 [1] and C++ <ref> [2] </ref>, but unfortunately not by Eiffel, in which features of a class are automatically visible in all the descendant of this class. This limitation of Eiffel can be easily rectified under Darwin-E.
Reference: [3] <author> B. Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: Section 3 provides an overview of Darwin-E | a specialization of the LGA based Darwin/2 environment [4] for systems written in the object-oriented language Eiffel <ref> [3] </ref>. Section 4 introduces some of the aspects of an Eiffel system that can be regulated under Darwin-E, and discusses the nature and use of such regulations. <p> The Eiffel language provides no means for establishing such constraints 1 but LGA does, as we shall see in Section 5.4. 1 Interestingly, Eiffel does provide syntactic means for grouping of classes into clusters, but it does not associate any semantics with such grouping <ref> [3] </ref>. 4 structure of software embedded in an intensive care unit Operating System Kernel Rest of the System Kernel Classes 5 3 An Overview of Law-Governed Architecture The main novelty of Law Governed Architecture (LGA) is that it associates with every software development project P an explicit set of rules L <p> For example, there are good reason to keep the encryption key of a class encryption completely hidden. Second, a decrease in the visibility of f1 would make compile-time type checking impossible, giving rise to a phenomenon called in Eiffel system-level validity failure <ref> [3] </ref>. To provide some control over this capability of Eiffel we introduce the following interaction: Definition 5 (changeExp interaction) Let c1 be a class, f1 be one of the features defined in c1, and c2 be a descended of c1. <p> This, however, is a rarely used operation whose use can be tightly regulated separately by means of cannot call rule. 20 4.7 Reverse Assignment Reverse assignment is a type-safe means provided by Eiffel <ref> [3] </ref> to "resurrect" a pointer stored in variable of more general type then the object being pointed to, making this object usable for what it really is.
Reference: [4] <author> N.H. Minsky. </author> <title> Law-governed systems. </title> <journal> The IEE Software Engineering Journal, </journal> <month> September </month> <year> 1991. </year> <note> (This is a revision of a similarly entitled 1987 technical report). </note>
Reference-contexts: means for specifying global constraints over the interactions between the modules of the system, beyond the constraints built into the language itself. 2 It is quite clear that the imposition of regularities requires a software archi- tecture that provide a global view of systems; such is our Law-Governed Architecture (LGA) <ref> [4, 5] </ref>. Under this architecture a desired regularity (if it is in our range) can be established in a given system simply by declaring it formally and explicitly as the law of the system, to be enforced by the environment in which the system is developed. <p> The rest of this paper is organized as follows: Section 2 provides a motivating example by introducing a useful regularity, called kernelized design, which is difficult to implement in traditional methods. Section 3 provides an overview of Darwin-E | a specialization of the LGA based Darwin/2 environment <ref> [4] </ref> for systems written in the object-oriented language Eiffel [3]. Section 4 introduces some of the aspects of an Eiffel system that can be regulated under Darwin-E, and discusses the nature and use of such regulations. <p> Interactions between the component-parts of the system being developed. The rules that regulate the former kind of interactions, thus governing the process of evolution of P, are enforced dynamically, when the regulated operations are invoked. The structure of these rules has been described in <ref> [4] </ref>, and its knowledge will not be required for the rest of this paper.
Reference: [5] <author> N.H. Minsky. </author> <title> Law-governed regularities in software systems. </title> <type> Technical Report LCSR-TR-220, </type> <institution> Rutgers University, LCSR, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: In spite of the great importance of regularities <ref> [5] </ref>, particularly for large systems, current programming technology provides very little support for them. This is unfortunate because regularities are inherently hard to implement reliably without such a support. The problem with the implementation of regularities stems from their intrinsic globality. <p> One can, of course, establish a desired regularity by painstakingly building all components of the system in accordance with it. But, as has been argued in <ref> [5] </ref>, such a "manual" implementation of regularities is laborious, unreliable and difficult to verify . Moreover, manually implemented regularities are difficult to maintain as invariants of evolution, because they can be compromised by a change anywhere in the system. <p> means for specifying global constraints over the interactions between the modules of the system, beyond the constraints built into the language itself. 2 It is quite clear that the imposition of regularities requires a software archi- tecture that provide a global view of systems; such is our Law-Governed Architecture (LGA) <ref> [4, 5] </ref>. Under this architecture a desired regularity (if it is in our range) can be established in a given system simply by declaring it formally and explicitly as the law of the system, to be enforced by the environment in which the system is developed. <p> This is so because ``@'' is a built in operator defined in such a way that a term of the form p@x succeeds if object x has the property p in the object-base B. Thus, rule 3.2 makes it illegal for kernel classes to inherit from non-kernel classes. (See <ref> [5] </ref> for more detailed discussion of the interpretation of rules.) The law L may contain several such cannot inherit rules, which impose various prohibitions over the inherit interaction. <p> Such rules will also be discussed in a forthcoming paper. Finally, although darwin-E, deals with systems written in Eiffel, the general idea of law-governed regularities discussed in this paper should apply to object-oriented system written in other languages, and, in fact, to large software systems in general <ref> [5] </ref>. Work is underway to build an environment similar to darwin-E for systems written in C++.
Reference: [6] <author> N.H. Minsky. </author> <title> A problem with long-term computing processes, and what can be done about it. </title> <type> Technical Report LCSR-TR-226, </type> <institution> Rutgers University, LCSR, </institution> <month> June </month> <year> 1994. </year> <month> 27 </month>
Reference-contexts: These audit-classes should be allowed to observe the status of the rest of the system, but not to effect its status in any way. In other words, an audit class should be allowed to call only SEF-routines defined in the rest of the system. (see <ref> [6] </ref> for a detailed discussion of such a system). But how do we know which routines are SEF? Of course, one can program any given routine carefully to be SEF and then allow it to be used by the audit-classes. <p> A more sophisticated kinds of rules, that allows one to automatically induce certain kinds of changes throughout a system being developed, are also possible under darwin-E. Such rules would, in particular, allow one to establish the kind of monitoring regime required for on-line auditing, as discussed in <ref> [6] </ref>. Such rules will also be discussed in a forthcoming paper. Finally, although darwin-E, deals with systems written in Eiffel, the general idea of law-governed regularities discussed in this paper should apply to object-oriented system written in other languages, and, in fact, to large software systems in general [5].
Reference: [7] <author> A. Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <booktitle> In Proceedings of the OOPSLA'86 Conference, </booktitle> <pages> pages 38-45, </pages> <month> September-October </month> <year> 1986. </year> <month> 28 </month>
Reference-contexts: The potentially negative implications of these aspects of inheritance to encapsulation have been pointed out by Snyder <ref> [7] </ref>. The conflict between inheritance and selective export in Eiffel is due to the fact that anything exported to a class is automatically accessible to all its descendants. To explain why this may be undesirable, consider a class account with features deposit and withdraw. <p> While this may simplify the code in the heir class, it compromises the encapsulation provided by the parent classes, in the general manner discussed in <ref> [7] </ref>. We can fortify encapsulation in Eiffel, without giving up much of the ease of access provided by it, by allowing a heir only read access to the attributes it inherits.
References-found: 7

