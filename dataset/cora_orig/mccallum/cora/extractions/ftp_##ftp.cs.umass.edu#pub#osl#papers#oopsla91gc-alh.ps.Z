URL: ftp://ftp.cs.umass.edu/pub/osl/papers/oopsla91gc-alh.ps.Z
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Title: Main Memory Management for Persistence  
Author: Antony L. Hosking 
Address: Amherst, MA 01003  
Affiliation: Object Oriented Systems Laboratory Department of Computer and Information Science University of Massachusetts  
Abstract: Reachability-based persistence imposes new requirements for main memory management in general, and garbage collection in particular. After a brief introduction to the characteristics and requirements of reachability-based persistence, we present the design of a run-time storage manager for Persistent Smalltalk and Persistent Modula-3, which allows the reclamation of storage from both temporary objects and buffered persistent objects. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. P. Atkinson, P. J. Bailey, K. J. Chisholm, P. W. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> The Computer Journal, </journal> <volume> 26(4) </volume> <pages> 360-365, </pages> <month> Nov. </month> <year> 1983. </year>
Reference-contexts: A particular goal of language designers has been the provision of orthogonal persistence, allowing programs to be expressed independently of the longevity of the data they manipulate, and conversely, so that the longevity of an object is independent of the way it is manipulated <ref> [1, 2] </ref>. A common approach to supporting orthogonal persistence in a programming language is to provide the illusion of a persistent heap. As far as the programmer is concerned, all objects are allocated and manipulated in the persistent heap just as if they were in an ordinary main memory heap.
Reference: [2] <author> M. P. Atkinson and R. Morrison. </author> <title> Procedures as persistent data objects. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 7(4) </volume> <pages> 539-559, </pages> <month> Oct. </month> <year> 1985. </year>
Reference-contexts: A particular goal of language designers has been the provision of orthogonal persistence, allowing programs to be expressed independently of the longevity of the data they manipulate, and conversely, so that the longevity of an object is independent of the way it is manipulated <ref> [1, 2] </ref>. A common approach to supporting orthogonal persistence in a programming language is to provide the illusion of a persistent heap. As far as the programmer is concerned, all objects are allocated and manipulated in the persistent heap just as if they were in an ordinary main memory heap.
Reference: [3] <author> J. F. Bartlett. </author> <title> Compacting garbage collection with ambiguous roots. </title> <type> Research Report 88/2, </type> <institution> Western Research Laboratory, Digital Equipment Corporation, </institution> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: This limits the style of garbage collection we can apply by excluding collection schemes that do not accurately find all pointers to objects, such as ambiguous roots collectors <ref> [3, 4] </ref>. 3 Design and rationale As we have mentioned, the volatile heap is partitioned into two areas: a transient area, and a persistent area (see Figure 3).
Reference: [4] <author> H.-J. Boehm and M. Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software: Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: This limits the style of garbage collection we can apply by excluding collection schemes that do not accurately find all pointers to objects, such as ambiguous roots collectors <ref> [3, 4] </ref>. 3 Design and rationale As we have mentioned, the volatile heap is partitioned into two areas: a transient area, and a persistent area (see Figure 3).
Reference: [5] <author> L. Cardelli, J. Donahue, L. Glassman, M. Jordan, B. Kalsow, and G. Nelson. </author> <note> Modula-3 report (revised). Technical Report DEC SRC 52, </note> <institution> DEC Systems Research Center/Olivetti Research Center, </institution> <address> Palo Alto/Menlo Park, CA, </address> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: We call that part of the persistent heap that is in main memory volatile since only objects in memory can be manipulated and updated. Our version of object faulting [7, 8, 9] is being used to implement persistence for Smalltalk and Modula-3 <ref> [5] </ref>. Here, we concern ourselves with management of the volatile heap, and the requirements imposed by persistence on the techniques used.
Reference: [6] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: These new objects must also eventually be made to persist if they are in some way reachable from the persistent roots. Implementing the abstraction of a persistent heap can be achieved in many ways. The simplest approach is that used in programming environments such as Smalltalk <ref> [6] </ref>. The heap is stored in some file on disk and then loaded into memory in its entirety when the environment begins executing. New objects are created and old objects updated in main memory.
Reference: [7] <author> A. L. Hosking and J. E. B. Moss. </author> <title> Towards compile-time optimisations for persistence. </title> <editor> In A. Dearle, G. M. Shaw, and S. B. Zdonik, editors, </editor> <booktitle> Proceedings of the Fourth International Workshop on Persistent Object Systems, </booktitle> <pages> pages 17-27, </pages> <address> Martha's Vineyard, Massachusetts, </address> <month> Sept. </month> <year> 1990. </year> <title> Published as Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year> <note> Also available as COINS Technical Report 90-74, </note> <institution> University of Massachusetts. </institution>
Reference-contexts: We call that part of the persistent heap that is in main memory volatile since only objects in memory can be manipulated and updated. Our version of object faulting <ref> [7, 8, 9] </ref> is being used to implement persistence for Smalltalk and Modula-3 [5]. Here, we concern ourselves with management of the volatile heap, and the requirements imposed by persistence on the techniques used. <p> Further, we can go ahead and retrieve the target object if it is known that it will eventually be needed. This can be established through compile-time analysis of programs <ref> [7, 8] </ref>. Page 2 1. The secondary storage manager retrieves the segment containing the target object (T) if the segment is not already resident in its buffers. 2.
Reference: [8] <author> A. L. Hosking and J. E. B. Moss. </author> <title> Compiler support for persistent programming. </title> <type> COINS Technical Report 91-25, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> Mar. </month> <year> 1991. </year> <pages> Page 5 </pages>
Reference-contexts: We call that part of the persistent heap that is in main memory volatile since only objects in memory can be manipulated and updated. Our version of object faulting <ref> [7, 8, 9] </ref> is being used to implement persistence for Smalltalk and Modula-3 [5]. Here, we concern ourselves with management of the volatile heap, and the requirements imposed by persistence on the techniques used. <p> Further, we can go ahead and retrieve the target object if it is known that it will eventually be needed. This can be established through compile-time analysis of programs <ref> [7, 8] </ref>. Page 2 1. The secondary storage manager retrieves the segment containing the target object (T) if the segment is not already resident in its buffers. 2.
Reference: [9] <author> A. L. Hosking, J. E. B. Moss, and C. Bliss. </author> <title> Design of an object faulting persistent Smalltalk. </title> <type> COINS Technical Report 90-45, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> May </month> <year> 1990. </year>
Reference-contexts: We call that part of the persistent heap that is in main memory volatile since only objects in memory can be manipulated and updated. Our version of object faulting <ref> [7, 8, 9] </ref> is being used to implement persistence for Smalltalk and Modula-3 [5]. Here, we concern ourselves with management of the volatile heap, and the requirements imposed by persistence on the techniques used.
Reference: [10] <author> R. L. Hudson, J. E. B. Moss, A. Diwan, and C. F. </author> <title> Weight. A language-independent garbage collector toolkit. </title> <type> COINS Technical Report 91-47, </type> <institution> University of Massachusetts, Amherst, </institution> <month> Sept. </month> <year> 1991. </year> <note> Submitted for publication. </note>
Reference: [11] <author> T. Kaehler and G. Krasner. </author> <title> LOOMlarge object-oriented memory for Smalltalk-80 systems. </title> <editor> In G. Krasner, editor, </editor> <title> Smalltalk-80: Bits of History, Words of Advice, </title> <booktitle> chapter 14, </booktitle> <pages> pages 251-270. </pages> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: We implement these checks in a manner similar to LOOM <ref> [11] </ref>, by having resident pseudo-objects called fault blocks stand in for non-resident objects. Every memory reference to a non-resident object is actually a pointer to a fault block.
Reference: [12] <author> J. E. B. Moss. </author> <title> Design of the Mneme persistent object store. </title> <journal> ACM Trans. Inf. Syst., </journal> <volume> 8(2) </volume> <pages> 103-139, </pages> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: The fault block actually contains the identifier for the persistent object it represents. At fault time this identifier is passed to the storage manager to retrieve the object. We use the Mneme persistent object store as the underlying storage manager <ref> [12] </ref>. Retrieving just one object at every object fault has been shown to be extremely inefficientthis was the chief downfall of LOOM.
Reference: [13] <author> J. E. B. Moss. </author> <title> Working with persistent objects: To swizzle or not to swizzle. </title> <type> COINS Technical Report 90-38, </type> <institution> University of Massachusetts, </institution> <address> Amherst, MA 01003, </address> <month> May </month> <year> 1990. </year> <note> Submitted for publication. </note>
Reference-contexts: Note that the newly resident object may contain references to other persistent objects. These will typically be represented as object identifiers in permanent storage, but will be converted to in-memory pointers when the object is made resident, in a process known as swizzling <ref> [13] </ref>. In Figure 1 (b) such a reference has been swizzled to point to a fault block. Note also that there remains a level of indirection via the indirect block. To eliminate some of this overhead we arrange for the garbage collector to bypass any indirect block it comes across.
Reference: [14] <author> D. Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 157-167, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> Apr. </month> <year> 1984. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 19, </volume> <month> 5 (May </month> <year> 1984). </year> <pages> Page 6 </pages>
Reference-contexts: The transient area is managed by a multi-generational scavenging garbage collector (for details of this collector see [10])such collectors focus their efforts on scavenging younger generations, based on the observation that young objects tend to die young <ref> [14] </ref>. New objects are allocated in the youngest generation of the transient area.
References-found: 14

