URL: http://www.csd.uu.se/~hamfelt/pub/GULP.ps
Refering-URL: http://www.csd.uu.se/~hamfelt/
Root-URL: 
Title: Constructing Logic Programs with Higher-Order Predicates 1 recursion operators, denoting higher-order relations rather than functions,
Author: Jtrgen Fischer Nilsson Andreas Hamfelt Perche nessuna cosa si puo amare ne odiare, se prima 
Note: The  no si a cognitio  
Address: Denmark  Uppsala University  Leonardo da Vinci, Notebooks  
Affiliation: Department of Computer Science Technical University of  Computing Science Department  di quella.  
Abstract: This paper proposes a logic programming approach based on the application of a system of higher-order predicates put at disposal within ordinary logic programming languages such as prolog. These higher-order predicates parallel the higher-order functionals or combinators which form an established part of contemporary functional programming methodology. The suggested toolbox of higher-order predicates for composing logic programs is derived from one universal higher-order predicate. They take the form of recursion operators (in particular for expressing recursion along lists) intended to cover all commonly occurring recursion schemes in logic programming practice. Their theoretical sufficiency is proved and their practical adequacy is argued through examples. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> T.S. Gegg-Harrison: </author> <title> Basic Prolog Schemata, </title> <institution> CS-1989-20, Dept. of Computer Science, Duke University, </institution> <year> 1989. </year>
Reference: [2] <author> A. Hamfelt & J. Fischer Nilsson: </author> <title> Inductive Metalogic Programming, Procs. </title> <booktitle> of Workshop on Inductive Logic Programing, </booktitle> <editor> S. Wrobel (ed.), </editor> <booktitle> Bad/Honnef/Bonn 1994, GMD-Studien Nr. </booktitle> <volume> 237, </volume> <pages> ISSN 0170-8120, </pages> <year> 1994. </year>
Reference: [3] <author> M. Kirschenbaum & L. S. Sterling: </author> <title> Refinement Strategies for Inductive Learning of Simple Prolog Programs, Procs. </title> <booktitle> of the 12th Int. Conf. on Artificial Intelligence, IJCAI-91, </booktitle> <address> Sydney, </address> <year> 1991. </year> <pages> pp. 757-761. </pages>
Reference: [4] <author> E. Marakakis & J. P. Gallagher: </author> <title> Schema-Based Top-Down Design of Logic Programs Using Abstract Data Types, Logic program Synthesis and Transformation Meta-Programming in Logic, </title> <editor> LOPSTR'94 and Meta'94, L. Fribourg & F. Turini (eds.), </editor> <publisher> LNCS 883, Springer, </publisher> <year> 1994. </year>
Reference: [5] <author> D.A. Miller & G. Nadathur: </author> <title> Higher-order Logic Programming, Procs. </title> <booktitle> of the 3rd International Logic Programming Conference, </booktitle> <publisher> LNCS 225, Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: Email: jfn@id.dtu.dk. Andreas Hamfelt: Computing Science Department, Uppsala University, Box 311, S-751 05 Uppsala, Sweden. Fax: +46 18 52 12 70. Phone: +46 18 18 10 37. Email: hamfelt@csd.uu.se. disposal directly within ordinary first-order logic programming in prolog. Contrast with dedicated logic programming languages such as prolog <ref> [5] </ref> and others. Functional programming as a matter of routine applies higher-order functions for expressing recurring recursions, e.g., list recursions.
Reference: [6] <author> L. Sterling & E. Shapiro: </author> <title> The Art of Prolog, </title> <publisher> MIT Press, </publisher> <year> 1986, 1991. </year>
Reference-contexts: ) Base (X; Y ): divconc ((Base; Decomp; Comp); X; Z) Decomp (X; X1; X2); divconc ((Base; Decomp; Comp); X1; Y 1); divconc ((Base; Decomp; Comp); X2; Y 2); Comp (X; Y 1; Y 2; Z): The quicksort algorithm in the simple ordinary prolog formulation (without differ-ence lists), cf. e.g. <ref> [6] </ref>, lends itself to formulation by means of the divide-and-conquer operator: qsort (L; Ls) divconc ((emptycase; decomp; comp); L; Ls): 8 &gt; &gt; &gt; &gt; &gt; &gt; &lt; emptycase (nil ; nil ): decomp (X:T; L1; L2) partition (leq (X); gr (X); L; L1; L2): ( a (leq (X); Y ) <p> the program having its recursions embraced in the operators. 3 Adequacy of Proposed Recursion Operators In order to bring to bear the higher-order operator technique as a general logic programming methodology we have to argue that the above recursion operators suffice e.g. for the collection of (pure) logic programs in <ref> [6] </ref>. Most of the programs therein can be managed using solely fold and linrec, more intricate pure programs calls for divconq or even the most general univ as in the case of meta-interpreters. This investigation will be reported in a forthcoming paper in preparation. <p> This is common logic programming practice for instance on the output list of quick-sort, cf. e.g. <ref> [6] </ref>. We want to devise a generalised and principled approach which avoids elaborate program alterations.
Reference: [7] <author> D. H. D. Warren: </author> <title> Higher-order extensions to PROLOG: are they needed ?, D. </title> <editor> Michie (ed.): </editor> <booktitle> Machine Intelligence 10, </booktitle> <publisher> Ellis Horwood and Edinburgh University Press, </publisher> <year> 1982. </year> <pages> pp. 441-454. </pages>
Reference-contexts: A): foldl (P; A; B:X; W ) P (B; A; V ) ^ foldl (P; V; X; W ): and foldr (P; A; nil; A): foldr (P; A; B:X; W ) foldr (P; A; X; V ) ^ P (B; V; W ): 1.1 Higher-Order Relations and Logic Programming In <ref> [7] </ref> David Warren gave a recipe for emulating higher-order predicates (and functions) as "first class objects" in prolog: In essence the higher-order atomic formula P (t 1 ; : : : ; t n ) is handled as the first-order atomic formula apply (P; t 1 ; : : : ;
References-found: 7

