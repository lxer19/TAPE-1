URL: ftp://ftp.cs.arizona.edu/reports/1996/TR96-18.ps
Refering-URL: http://www.cs.arizona.edu/research/reports.html
Root-URL: http://www.cs.arizona.edu
Email: fmuth, debrayg@cs.arizona.edu  
Title: On The Complexity of Function Pointer May-Alias Analysis  
Author: Robert Muth Saumya Debray 
Date: October 25, 1996  
Address: Tucson, AZ 85721, USA  
Affiliation: Department of Computer Science University of Arizona  
Abstract: This paper considers the complexity of interprocedural function pointer may-alias analysis, i.e., determining the set of functions that a function pointer (in a language such as C) can point to at a point in a program. This information is necessary, for example, in order to construct the control flow graphs of programs that use function pointers, which in turn is fundamental for most dataflow analyses and optimizations. We show that the general problem is complete for deterministic exponential time. We then consider two natural simplifications to the basic (precise) analysis and examine their complexity. The approach described can be used to readily obtain similar complexity results for related analyses such as reachability and recursiveness.
Abstract-found: 1
Intro-found: 1
Reference: [ASU86] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers. principles, techniques, and tools. </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: Section 6 briefly considers the related problem of function pointer must-alias analysis. Finally, Section 7 concludes. 2 Preliminaries For code analysis and optimization purposes, compilers typically construct a control flow graph for each function in a program <ref> [ASU86] </ref>. This is a directed graph where each node represents a segment of executable code that has a single 1 The determination of whether some (nontrivial) property will actually hold at a particular program point at runtime is, of course, undecidable.
Reference: [CCHK90] <author> D. Callahan, A. Carle, M. Hall, and K. Kennedy. </author> <title> Constructing the procedure call multigraph. </title> <journal> IEEE Trans. on Softw. Eng., </journal> <volume> 16(4):483, </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: The problem of determining interprocedural control flow in the presence of procedure-valued arguments was first investigated in the context of call (multi)graph construction for Fortran programs, which do not allow functions to return procedure values <ref> [Ryd79, CCHK90] </ref>. More recently, Shivers uses abstract fl This work was supported in part by the National Science Foundation under grant number CCR-9502826. interpretation to examine the problem in the context of higher-order languages such as Scheme [Shi88, Shi91]: His major concerns are with semantic aspects of the problem.
Reference: [CBC93] <author> J.-D. Choi, M. Burke, and P. Carini, </author> <title> "Efficient Flow-Sensitive Interproce-dural Computation of Pointer-Induced Aliases and Side Effects", </title> <booktitle> Proc. 20th. ACM Symposium on Principles of Programming Languages, </booktitle> <month> Jan. </month> <year> 1993, </year> <pages> pp. 232-245. </pages>
Reference-contexts: 1 Introduction Recent years have seen a great deal of interest in interprocedural compile-time analyses and optimizations (see, for example, <ref> [CBC93, LR92, LRZ93, Mye81, SP81, WL95] </ref>). Fundamental to any such effort is the determination of interpro-cedural control flow.
Reference: [Hei94] <author> Nevin Heintze. </author> <title> Control flow analysis and type systems. </title> <type> Technical Report CMU-CS-94-227, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: In effect, the analysis of a function invocation does not maintain any information about the context from which it arose: for this reason, this has also been referred to as "zeroth-order control flow analysis" (0-CFA) <ref> [Hei94, Shi88, Shi91] </ref>. We can capture the effects of this approximation by changing the equations for return and entry nodes.
Reference: [HY86] <author> Paul Hudak and Jonathan Young. </author> <title> Higher-order strictness analysis in un-typed lambda calculus. </title> <booktitle> In Proc. 13th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 97-109, </pages> <address> St. Petersburg Beach, Florida, </address> <month> Jan-uary </month> <year> 1986. </year>
Reference-contexts: Theorem 3.2 (Hudak and Young <ref> [HY86] </ref>) The RMBF problem is EXPTIME-complete in the length of the pair (eq; ~z).
Reference: [JM81] <author> Neil D. Jones and Steven S. Muchnick. </author> <title> Complexity of flow analysis, inductive assertion synthesis, and a language due to Dijkstra. </title> <editor> In Steven S Muchnick and Neil D Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 12, </volume> <pages> pages 380-393. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: This paper examines in detail the computational complexity of a number of variations on interprocedural function pointer may-alias analysis. We first show that the computation of precise solutions requires the use of the relational attributes method <ref> [JM81] </ref>, which, in turn, implies NP-hardness even in the absence of function calls, and show that the problem is complete for deterministic exponential time. We then examine two natural ways to simplify the analysis at the cost of precision. The first is to use an independent attributes analysis [JM81], i.e., ignore <p> attributes method <ref> [JM81] </ref>, which, in turn, implies NP-hardness even in the absence of function calls, and show that the problem is complete for deterministic exponential time. We then examine two natural ways to simplify the analysis at the cost of precision. The first is to use an independent attributes analysis [JM81], i.e., ignore dependences between the aliases of different variables. Somewhat surprisingly, the problem remains EXPTIME-complete in this case: the simplification produces no improvement in the theoretical worst-case complexity. <p> Jones and Muchnick refer to the former kind of analysis as the relational attributes method, and the latter kind as the independent attributes method <ref> [JM81] </ref>. In practice, program analyses typically use the independent attributes method because it tends to be simpler and more efficient to implement. In the context of function pointer may-alias analysis, a precise analysis algorithm cannot use the independent attributes method in general. <p> of different variables is lost during an independent attributes analysis. 3.2 A Framework for Function Pointer May-Alias Analysis As Example 3.1 illustrates, a precise analysis requires what Jones and Muchnick have referred to as a relational attributes analysis, i.e., where connections between the possible aliases of different variables are maintained <ref> [JM81] </ref>. We will keep track of such connections using environments, which map local variables to the functions they are aliased to (point to).
Reference: [JM86] <author> Neil D. Jones and A. Mycroft. </author> <title> Data flow analysis of applicative programs using minimal function graphs: abridged version. </title> <booktitle> In Proc. 13th ACM 16 Symp. on Principles of Programming Languages, </booktitle> <pages> pages 296-306, </pages> <address> St. Pe--tersburg, FL, </address> <month> January </month> <year> 1986. </year>
Reference-contexts: This essentially resembles the minimal function graphs approach of <ref> [JM86] </ref>. We use AEnv fl to denote the least fixpoint of the system of equations given above for AEnv . Since the sets Var and Fun are finite, so is the set Env = Var ! Fun.
Reference: [Lak93] <author> Arun Lakhotia. </author> <title> Constructing call multigraphs using dependence graphs. </title> <booktitle> In Proc. 20th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 273-284, </pages> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference-contexts: Lakhotia studies the general problem for a language where procedures may be assigned to variables, invoked through variables, and returned as results <ref> [Lak93] </ref>. Lakhotia gives a polynomial time algorithm whose efficiency gains come at the cost of considerable imprecision in the analysis. Zhang and Ryder [ZR94] examine the complexity of interprocedural function pointer may-alias analysis for the programming language C. <p> Hence the problem has been simplified considerably. In fact, it is equivalent to a problem discussed by Lakhotia <ref> [Lak93] </ref> who also shows how to solve it polynomial time. 5 6 Interprocedural Function Pointer Must Alias Analysis The discussion thus far has focused on interprocedural function pointer may-alias analysis, which is concerned with determining whether there exists a computation path through the program along which certain aliases can occur.
Reference: [LR92] <author> William Landi and Barbara G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(7) </volume> <pages> 235-248, </pages> <month> July </month> <year> 1992. </year> <booktitle> Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: 1 Introduction Recent years have seen a great deal of interest in interprocedural compile-time analyses and optimizations (see, for example, <ref> [CBC93, LR92, LRZ93, Mye81, SP81, WL95] </ref>). Fundamental to any such effort is the determination of interpro-cedural control flow.
Reference: [LRZ93] <author> William Landi, Barbara G. Ryder, and Sean Zhang. </author> <title> Interprocedural side effect analysis with pointer aliasing. </title> <journal> SIGPLAN Notices, </journal> <volume> 28(6) </volume> <pages> 56-67, </pages> <month> June </month> <year> 1993. </year> <booktitle> Proceedings of the ACM SIGPLAN '93 Conference on Programming Language Design and Implementation. </booktitle>
Reference-contexts: 1 Introduction Recent years have seen a great deal of interest in interprocedural compile-time analyses and optimizations (see, for example, <ref> [CBC93, LR92, LRZ93, Mye81, SP81, WL95] </ref>). Fundamental to any such effort is the determination of interpro-cedural control flow.
Reference: [Mye81] <author> Eugene W. Myers. </author> <title> A precise interprocedural data flow algorithm. </title> <booktitle> In Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <address> Williamsburg, Virginia, </address> <month> January </month> <year> 1981. </year>
Reference-contexts: 1 Introduction Recent years have seen a great deal of interest in interprocedural compile-time analyses and optimizations (see, for example, <ref> [CBC93, LR92, LRZ93, Mye81, SP81, WL95] </ref>). Fundamental to any such effort is the determination of interpro-cedural control flow.
Reference: [Ryd79] <author> Barbara G. Ryder. </author> <title> Constructing the call graph of a program. </title> <journal> IEEE Transaction of Software Engineering, </journal> <volume> SE-5(3):216-226, </volume> <year> 1979. </year>
Reference-contexts: The problem of determining interprocedural control flow in the presence of procedure-valued arguments was first investigated in the context of call (multi)graph construction for Fortran programs, which do not allow functions to return procedure values <ref> [Ryd79, CCHK90] </ref>. More recently, Shivers uses abstract fl This work was supported in part by the National Science Foundation under grant number CCR-9502826. interpretation to examine the problem in the context of higher-order languages such as Scheme [Shi88, Shi91]: His major concerns are with semantic aspects of the problem.
Reference: [Shi88] <author> Olin G. Shivers. </author> <title> Control flow analysis in scheme. </title> <booktitle> In Proceedings of the ACM SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 164-174, </pages> <address> Atlanta, Georgia, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: More recently, Shivers uses abstract fl This work was supported in part by the National Science Foundation under grant number CCR-9502826. interpretation to examine the problem in the context of higher-order languages such as Scheme <ref> [Shi88, Shi91] </ref>: His major concerns are with semantic aspects of the problem. Lakhotia studies the general problem for a language where procedures may be assigned to variables, invoked through variables, and returned as results [Lak93]. <p> In effect, the analysis of a function invocation does not maintain any information about the context from which it arose: for this reason, this has also been referred to as "zeroth-order control flow analysis" (0-CFA) <ref> [Hei94, Shi88, Shi91] </ref>. We can capture the effects of this approximation by changing the equations for return and entry nodes.
Reference: [Shi91] <author> Olin G. Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages or Taming Lambda. </title> <type> PhD thesis, </type> <institution> Carnige-Mellon Univeristy, </institution> <month> May </month> <year> 1991. </year> <note> Also available as CMU-CS-91-145. </note>
Reference-contexts: More recently, Shivers uses abstract fl This work was supported in part by the National Science Foundation under grant number CCR-9502826. interpretation to examine the problem in the context of higher-order languages such as Scheme <ref> [Shi88, Shi91] </ref>: His major concerns are with semantic aspects of the problem. Lakhotia studies the general problem for a language where procedures may be assigned to variables, invoked through variables, and returned as results [Lak93]. <p> In effect, the analysis of a function invocation does not maintain any information about the context from which it arose: for this reason, this has also been referred to as "zeroth-order control flow analysis" (0-CFA) <ref> [Hei94, Shi88, Shi91] </ref>. We can capture the effects of this approximation by changing the equations for return and entry nodes.
Reference: [SP81] <author> Micha Sharir and Amir Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <editor> In Steven S Muchnick and Neil D Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 7, </volume> <pages> pages 189-233. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: 1 Introduction Recent years have seen a great deal of interest in interprocedural compile-time analyses and optimizations (see, for example, <ref> [CBC93, LR92, LRZ93, Mye81, SP81, WL95] </ref>). Fundamental to any such effort is the determination of interpro-cedural control flow.
Reference: [Tar55] <author> Alfred Tarski. </author> <title> A lattice-theoretic fixpoint theorem and its applications. </title> <journal> Pacific J. Math, </journal> <volume> 5 </volume> <pages> 285-309, </pages> <year> 1955. </year>
Reference-contexts: join operations u and t respectively, let t (f) : S ! S be the functional corresponding to the right hand side of this equation: if t is monotone and continuous (note that a monotone function over a finite (-height) lattice is necessarily continuous), then from the Knaster-Tarski fixpoint theorem <ref> [Tar55] </ref>, it has a least fixpoint given by F where ? is the least element of S and t i denotes the i-times iterated unfolding of t . We use lfp (f ) and sometimes f fl to denote this least fixpoint.
Reference: [WL95] <author> R. P. Wilson and M. S. Lam, </author> <title> "Efficient Context-Sensitive Pointer Analysis for C Programs", </title> <booktitle> Proc. SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1995, </year> <pages> pp. 1-12. </pages>
Reference-contexts: 1 Introduction Recent years have seen a great deal of interest in interprocedural compile-time analyses and optimizations (see, for example, <ref> [CBC93, LR92, LRZ93, Mye81, SP81, WL95] </ref>). Fundamental to any such effort is the determination of interpro-cedural control flow.
Reference: [ZR94] <author> Sean Zhang and Barbara G. Ryder. </author> <title> Complexity of single level function pointer aliasing analysis. </title> <type> Technical Report LCSR-TR-233, </type> <institution> Laboratory of Computer Science Research, Rutgers University, </institution> <month> October </month> <year> 1994. </year> <month> 17 </month>
Reference-contexts: Lakhotia studies the general problem for a language where procedures may be assigned to variables, invoked through variables, and returned as results [Lak93]. Lakhotia gives a polynomial time algorithm whose efficiency gains come at the cost of considerable imprecision in the analysis. Zhang and Ryder <ref> [ZR94] </ref> examine the complexity of interprocedural function pointer may-alias analysis for the programming language C. <p> holds at a program point, an analysis must consider statically executable paths from the entry point of the program upto that point: roughly speaking, these are paths that can actually be taken during execution, modulo the assumption (standard in dataflow analysis) that both branches of a conditional can be taken <ref> [ZR94] </ref>. More formally, these paths can be defined as follows: Definition 2.1 [Statically executable path] A path starting at the root 2 of the interprocedural control flow graph is statically executable if it satisfies the following two conditions: 1. The path has a proper subpath containing all the return nodes. <p> The Main Theorem is an easy corollary of this result: 12 Corollary 3.1 FP-MayAlias is EXPTIME-complete. It is interesting, at this point, to revisit the NP-hardness result for function pointer may-alias analysis due to Zhang and Ryder <ref> [ZR94] </ref>. As shown in Section 3.1, a relational attributes analysis is necessary for precise function pointer may alias analysis. <p> In this paper, we consider complexity issues for a variety of approaches to this problem. We show that a relational attribute analysis is necessary if precise results are to be obtained; extend earlier results by Zhang and Ryder <ref> [ZR94] </ref> to show that the problem is complete for deterministic exponential time; and show that for precise analyses, Zhang and Ryder's NP-hardness result holds even for intra-procedural analyses: that is, aliasing effects alone give rise to NP-hardness even when inter-procedural effects are absent.
References-found: 18

