URL: http://www.cs.wisc.edu/~patil/docs/techrep.ps
Refering-URL: http://www.cs.wisc.edu/~patil/patil.html
Root-URL: 
Email: -patil, fischer-@cs.wisc.edu  
Title: Shadow Guarding Run-time Checking You Can Afford  
Author: Harish Patil and Charles Fischer 
Date: November 9, 1994  
Address: 1210 W. Dayton Street Madison, WI 53706  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Abstract: Shared memory multiprocessors are becoming increasingly common. We present a technique that uses shared memory multiprocessors to efficiently implement run-time checking. The user program pays a very small premium on each run. In return there is an assurance of reliability. A second shadow process looks for errors in the background. For the error-free runs, the user process hardly notices the shadow process; for erroneous runs, the shadow process provides useful error information automatically.
Abstract-found: 1
Intro-found: 1
Reference: [ABS94] <author> Todd Austin, Scott Breach, and Gurindar Sohi. </author> <title> Efficient detection of all pointer and array access errors. </title> <booktitle> In Proceedings of the ACM SIGPLAN94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 290301, </pages> <year> 1994. </year>
Reference-contexts: Sometimes shadow can even run ahead of the main process catching errors before they actually occur. 3. Handling of real programs: Shadow guarding has been implemented to handle real C programs. It provides complete <ref> [ABS94] </ref> error coverage for array and pointer access errors. It has been used to detect previously unreported errors in a number of SPEC benchmarks and Unix utilities. 4. <p> Suns multi-threading library [PKB+91] was used to create main and shadow threads. The test programs included integer benchmarks from the SPEC92 test suite, one program, yacr, from the SafeC <ref> [ABS94] </ref> test suite and many commonly used utilities from SunOs 4.1.3. A utility called fuzz [MLS90] was used to generate random input for the SunOs utilities. <p> If a pointers intended referent is freed and the memory is reallocated, dereferencing the pointer should lead to a temporal access error; however Purify is also unable to detect that error. Austin et al <ref> [ABS94] </ref> have proposed translation of C programs to SafeC programs to handle array and pointer access errors. Their technique provides complete error detection under certain conditions. They have reported execution time overhead in the range of 130% to 540% for 6 (optimized) test programs. <p> An input C program, annotated with macros, results in a C++ program which combined with some run-time support performs pointer access checking. Shadow guarding shares the completeness of error detection with SafeC. Unlike the system described in <ref> [ABS94] </ref>, shadow guarding is completely automated and has been used to detect errors in real programs. Temporal access errors in SafeC are caught using a capability attribute which is an essentially unique value per object, much like the Lock in shadow guards.
Reference: [AG88] <author> Ziya Aral and Ilya Gertner. </author> <title> High-level debugging in Parasight. </title> <booktitle> In ACM Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pages 151162, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: In contrast shadow processing is a run-time technique that removes expensive tracing from the critical execution path of a program and shifts the cost to another processor. Parasight <ref> [AG88] </ref> is a parallel programming environment for shared-memory multiprocessors. The system allows creation of observer programs (parasites) that run concurrently with a target program and monitor its behavior.
Reference: [And93] <author> Lars Ole Andersen. </author> <title> Binding-time analysis and the taming of C pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN93 Symposium on Partial Evaluation and Semantics-Based Program Manipulation, </booktitle> <pages> pages 4758, </pages> <year> 1993. </year>
Reference-contexts: Both the sequential approach and shadow guarding approach can equally benefit from these optimizations. We are currently exploring an optimization to reduce the overhead of temporal checks. We want to statically determine the life-time of the referent of pointers. The approach based on [EGH94] and <ref> [And93] </ref> classifies pointers into the following categories: i. Points_to_NULL: These are uninitialized pointers whose dereference is reported at compile time. ii. Points_to_global iii. Points_to_local_of_current_function iv. Points_to_local_of_exited_function: Dereferencing these pointers is illegal and can be reported at compile time. v. Points_to_heap.
Reference: [BH93] <author> Thomas Ball and Susan Horwitz. </author> <title> Slicing programs with arbitrary control-flow. </title> <booktitle> In Proceedings of the 1st International Workshop on Automated and Algorithmic Debugging, volume 749. Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1993. </year>
Reference-contexts: We modified the shadow program for alvinn to delete statements not necessary for guarding and the resulting shadow process ran 21% faster than the sequential checking process. We are currently interfacing our translator with the slicing backend from the Wisconsin Program-Integration System. The slicing backend, based on <ref> [BH93] </ref>, can slice programs with arbitrary control ow. It should allow us to generate much faster shadow programs. 4 Related work ANNA (Annotated ADA) is an Ada language extension that allows user defined executable asser tions (checking code) about program behavior.
Reference: [EGH94] <author> Marayam Emami, Rakesh Ghiya, and Laurie Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the ACM SIGPLAN94 Conference on Programming Language Design and 14 Implementation, </booktitle> <pages> pages 242256, </pages> <year> 1994. </year>
Reference-contexts: Both the sequential approach and shadow guarding approach can equally benefit from these optimizations. We are currently exploring an optimization to reduce the overhead of temporal checks. We want to statically determine the life-time of the referent of pointers. The approach based on <ref> [EGH94] </ref> and [And93] classifies pointers into the following categories: i. Points_to_NULL: These are uninitialized pointers whose dereference is reported at compile time. ii. Points_to_global iii. Points_to_local_of_current_function iv. Points_to_local_of_exited_function: Dereferencing these pointers is illegal and can be reported at compile time. v. Points_to_heap.
Reference: [Feu73] <author> E. A. Feustal. </author> <title> On the advantages of tagged architectures. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-22(7):12411258, </volume> <month> July </month> <year> 1973. </year>
Reference-contexts: Hence * 1994 by Harish Patil and Charles Fischer. This work was supported by NSF grant CCR-9122267 2 run-time checking can be overlapped with normal computation. One approach to concurrent run-time checking is to use specialized hardware. Tagged hardware <ref> [Feu73] </ref> can be used for type-checking at run-time. Watchdog processors [MJ88] are used to provide control ow checking. Unfortunately specialized architectures are not widely available and they may not be able to support the full range of desirable checks (e.g., pointer validity checking).
Reference: [GGPY89] <author> Patrick Gelsinger, Paolo Gargini, Gerhard Parker, and Albert Y. C. Yu. </author> <title> Microprocessors circa 2000. </title> <journal> IEEE Spectrum, </journal> <pages> pages 4347, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Vendors such as Sun and SGI offer multiprocessor workstations. Dual processor PCs have started appearing in the market. With rapid advances in microprocessor technology, high-performance microprocessors should soon be able to incorporate as many as four general-purpose central processing units on a single chip <ref> [GGPY89] </ref>. We believe it is quite likely that current applications will not be able to routinely use this extra processing power. As a result, processors will often be underutilized. We plan to use spare processors to execute run-time checks using a technique called shadow processing.
Reference: [Gup93] <author> Rajiv Gupta. </author> <title> Optimizing array bound checks using flow analysis. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 2:135150, </volume> <month> March-December </month> <year> 1993. </year>
Reference-contexts: Execution time: shadow guarding vs. sequential checking normalized execution time 10 3.3 Speeding up shadowing The execution time of the shadow process depends on two factors: Number of pointer operations in the input program. To reduce this slowdown, a variety of range checking optimizations such as <ref> [Gup93] </ref> can be applied to reduce the number of checks done at run-time. Both the sequential approach and shadow guarding approach can equally benefit from these optimizations. We are currently exploring an optimization to reduce the overhead of temporal checks.
Reference: [HJ92] <author> Reed Hastings and Bob Joyce. Purify: </author> <title> Fast detection of memory leaks and access errors. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 125136, </pages> <year> 1992. </year>
Reference-contexts: Extensive run-time checking provided by diagnostic compilers incurs significant run-time costs. In [Ste92], run-time checks were added to a C compiler. The code generated ran 10 times slower than the original code. Similar slowdowns are reported for commercially available run-time error checking systems such as Purify <ref> [HJ92] </ref>. The high cost of run-time checks restricts their use to the program development phase. When programs are fully developed and tested, they are assumed to be correct and run-time checks are disabled. This is dangerous because errors in heavily-used programs can be extremely destructive. <p> It detects approximately 70 run-time violations involving illegal array and pointer accesses, improper function arguments, type mismatches etc. Interpretation of the intermediate code for supporting these checks is very expensive though; the evaluator executes C code approximately 200 times slower than the compiled object code. Purify <ref> [HJ92] </ref> is a commercially available system that modifies object files to, in essence, implement a byte-level tagged architecture in software. It maintains a bit table at run-time to hold a two-bit state code for each byte in the memory.
Reference: [HS91] <author> Samual P. Harbison and Guy L. Steele Jr. </author> <title> C - A Reference Manual. </title> <publisher> Prentice Hall, 3rd edition, </publisher> <year> 1991. </year>
Reference-contexts: We will use the term pointer to denote array references as well because when an array identifier appears in an expression, the type of the identifier is converted from array of T to pointer to T <ref> [HS91] </ref>. Operations on pointers in the main process lead to operations on guards in the shadow. Structures and unions containing pointers have shadow objects containing guards. Each level of a multilevel pointer type in the main program leads to a typedef of corresponding guard type. <p> In Figure 3, the intended referent of p is another pointer q, G_p.shptr points to the guard of q viz. G_q. Thus the 2-level dereference **p leads to checking of two guards G_p and *(G_p.shptr) (which is G_q). In C, invalid pointers <ref> [HS91] </ref> can be created by casting arbitrary integer values to pointer types, by deallocating the storage for the referent of the pointer, or by using pointer arithmetic to produce a pointer pointing outside its intended referent. <p> If p is a multi-level pointer, var must be a pointer with its own guard G_var. In this case the statement G_p.shptr = &G_var is needed. Otherwise a NULL value is assigned to G_p.shptr. setjmp and longjmp functions in C implement a primitive form of nonlocal jumps <ref> [HS91] </ref>. setjmp (env) records its callers environment in the jump buffer env, an implementation-defined array. The function longjmp takes as its argument a jump buffer previously filled by a calling setjmp and restores the environment stored in that buffer.
Reference: [HS92] <author> Laurie J. Hendren and Bhama Sridharan. </author> <title> The SIMPLE AST - McCAT compiler. ACAPS design note 36, </title> <institution> School of Computer Science, McGill University, Montreal, Canada, </institution> <year> 1992. </year>
Reference-contexts: Further, they can occur as loop conditions, array indices, actual parameters etc. A simplification phase was introduced to restrict the case analysis required for shadow guarding. Our simplifier is a C-to-C translator whose output is a subset of C similar to the intermediate representation called SIMPLE from McGill university <ref> [HS92] </ref>. Simplification greatly reduces the number of cases to be analyzed by the translator phase - there are only 15 types of basic statements in any simplified program.
Reference: [KLP88] <author> Stephan Kaufer, Russel Lopez, and Sesha Pratap. </author> <title> Saber-C an interpreter-based programming environment for the C language. </title> <booktitle> In Proceedings of the Summer USENIX Conference, </booktitle> <pages> pages 161171, </pages> <year> 1988. </year>
Reference-contexts: Like shadow processing, the ANNA to ADA transformer uses the idea of executing checking code concurrently with the underlying program. However, it generates numerous tasks per annotation, which may lead to excessive overhead. Executing user defined assertions seems like a good application for shadow processing. CodeCenter <ref> [KLP88] </ref> is a programming environment that supports an interpreter-based development scheme for the C language. The evaluator in CodeCenter provides a wide range of run-time checks. It detects approximately 70 run-time violations involving illegal array and pointer accesses, improper function arguments, type mismatches etc.
Reference: [Lar90] <author> James Larus. </author> <title> Abstract execution: A technique for efficiently tracing programs. </title> <journal> Software - Practice and Experience, </journal> <volume> 20(12):12411258, </volume> <month> December </month> <year> 1990. </year>
Reference-contexts: Hence a separate storage class attribute, as in safe pointers, to catch freeing of global objects is not necessary. Shadow processing was motivated, in part, by a tool called AE that supports abstract execution <ref> [Lar90] </ref>. AE is used for efficient generation of detailed program traces. A source program, in C, is instrumented to record a small set of key events during execution.
Reference: [MJ88] <author> A. Mahmood and McCluskey E. J. </author> <title> Concurrent error detection using watchdog processor - a survey. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-37(2):160174, </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: Hence * 1994 by Harish Patil and Charles Fischer. This work was supported by NSF grant CCR-9122267 2 run-time checking can be overlapped with normal computation. One approach to concurrent run-time checking is to use specialized hardware. Tagged hardware [Feu73] can be used for type-checking at run-time. Watchdog processors <ref> [MJ88] </ref> are used to provide control ow checking. Unfortunately specialized architectures are not widely available and they may not be able to support the full range of desirable checks (e.g., pointer validity checking). We propose to use general purpose multi-processors for concurrent run-time checking.
Reference: [MLS90] <author> Barton P. Miller, Fredriksen Lars, and Brian So. </author> <title> An empirical study of the reliability of Unix utilities. </title> <journal> Communications of the ACM, </journal> <volume> 33(12):3244, </volume> <month> December </month> <year> 1990. </year> <note> [PKB + 91] M. </note> <author> L. Powell, S. R. Kleiman, S. Barton, D. Shah, D. Stein, and M. Weeks. </author> <title> SunOS multi-thread architecture. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 114, </pages> <year> 1991. </year>
Reference-contexts: Even if an erroneous program crashes, it may be difficult to repeat the error inside a debugger. Further, debugging long running programs can be very time consuming. Undiscovered errors in heavily-used programs may not be rare; a study <ref> [MLS90] </ref> has shown that as many as a quarter of the most commonly used Unix utilities crash or hang when presented with unexpected inputs. Thus there is a strong case for running programs with checks routinely enabled. Naturally, these checks should be as inexpensive as possible. <p> Suns multi-threading library [PKB+91] was used to create main and shadow threads. The test programs included integer benchmarks from the SPEC92 test suite, one program, yacr, from the SafeC [ABS94] test suite and many commonly used utilities from SunOs 4.1.3. A utility called fuzz <ref> [MLS90] </ref> was used to generate random input for the SunOs utilities. SPEC benchmarks were tested with their reference inputs. 3.1 Errors uncovered Run-time errors which do not crash programs can go unnoticed for a long time. Shadow guarding reports such errors as they occur. <p> Four SunOs utilities col, deroff, uniq, and units crashed with random inputs. These were already reported to be buggy <ref> [MLS90] </ref> in earlier versions of SunOs. However, we found new errors in these utilities as well. In all, we uncovered 15 errors in nine programs. A complete report on the errors in the programs tested so far is presented in the Appendix.
Reference: [SM93] <author> Sriram Sankar and Manas Mandal. </author> <title> Concurrent runtime monitoring of formally specified programs. </title> <booktitle> Computer, </booktitle> <address> 26(3):3241, </address> <month> March </month> <year> 1993. </year>
Reference-contexts: An ANNA to ADA transformer that allows either sequential or concurrent execution of the checking code is described in <ref> [SM93] </ref>. Concurrent run time monitoring is achieved by defining an ADA task containing a checking function for each annotation. Calls to the checking function are automatically inserted at places where inconsistency 11 with respect to the annotation can arise.
Reference: [Ste92] <author> Joseph L. Steffen. </author> <title> Adding run-time checking to the portable C compiler. </title> <journal> Software - Practice and Experience, </journal> <volume> 22(4):825834, </volume> <month> April </month> <year> 1992. </year> <month> 15 </month>
Reference-contexts: 1 Introduction Run-time checks can detect errors that cannot be detected at compile-time, including array bound violations, invalid pointer accesses, and use of uninitialized variables. Extensive run-time checking provided by diagnostic compilers incurs significant run-time costs. In <ref> [Ste92] </ref>, run-time checks were added to a C compiler. The code generated ran 10 times slower than the original code. Similar slowdowns are reported for commercially available run-time error checking systems such as Purify [HJ92]. The high cost of run-time checks restricts their use to the program development phase.
References-found: 17

