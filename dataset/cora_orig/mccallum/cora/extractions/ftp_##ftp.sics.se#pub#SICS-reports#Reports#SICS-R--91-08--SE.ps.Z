URL: ftp://ftp.sics.se/pub/SICS-reports/Reports/SICS-R--91-08--SE.ps.Z
Refering-URL: http://www.sics.se/libindex.html
Root-URL: 
Title: SICS/R91:08 Programming Paradigms of the Andorra Kernel Language  
Author: Sverker Janson Seif Haridi 
Date: April 10, 1991  
Abstract: SICS Research Report R91:08 Swedish Institute of Computer Science Box 1263, S-164 28 KISTA, Sweden 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Reem Bahgat and Steve Gregory. Pandora: </author> <title> Non-deterministic parallel logic programming. </title> <booktitle> In Proceedings of the Sixth International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: The potential of the Andorra model as a basis for combining Pro-log and committed-choice languages was first realised by Haridi [7, 6]. 1 Independently, Bahgat and Gregory extended the basic Andorra model by allowing full Parlog execution during the deterministic phase in the language Pandora <ref> [1] </ref>. As a joint effort between us and Warren, an Extended Andorra Model (EAM) was developed. It is a set of rewrite rules on AND/OR-trees that potentially unifies the abilities of Prolog and GHC. In some sense, the EAM is for AKL what definite clause resolution is for Prolog. <p> An often used example is the n-queens problem <ref> [13, 9, 1] </ref>. <p> The previous goal is now restated. ?- m (X,[1,2,3]), m (X,[2,3,4]). The execution proceeds as follows. The initial goal is an and-box containing the two atomic goals. All rewrites will be performed on both goals "in parallel". and (m (X; <ref> [1; 2; 3] </ref>); m (X; [2; 3; 4])) First of all, local forking is applied to the m goals. The member goals now appear in the guard of a wait guarded goal. and (choice (and (member (X; [1; 2; 3])) : true); choice (and (member (X; [2; 3; 4])) : true)) <p> All rewrites will be performed on both goals "in parallel". and (m (X; <ref> [1; 2; 3] </ref>); m (X; [2; 3; 4])) First of all, local forking is applied to the m goals. The member goals now appear in the guard of a wait guarded goal. and (choice (and (member (X; [1; 2; 3])) : true); choice (and (member (X; [2; 3; 4])) : true)) The first step of the local execution is local forking of the member goals with the two clauses in the definition, producing choice-boxes with two guarded goals each with trivially solved guards. 16 choice (and (choice (true
Reference: [2] <author> Francisco Bueno and Manuel Hermenegildo. </author> <title> Towards a translation algorithm from Prolog to the Andorra Kernel Language. </title> <type> PEPMA Internal Report, </type> <month> January </month> <year> 1991. </year>
Reference-contexts: Finally, it is shown how to make way for independent and-parallel execution. Using data-flow analysis, it is possible to make translation from Pro-log to AKL completely automatic along the lines outlined below <ref> [2] </ref>. 4.2.1 Trivial Translation of Pure Definitions The first translation considered completely ignores the possibility of putting goals in the guard. <p> By putting the goals in guards and extracting the output argument, unless the goals attempt to restrict X, all computation steps are always admissible. This style of translation can make use of the tools developed for restricted and-parallelism, such as compile-time analysis of independence, making it completely automatic <ref> [2] </ref>. 4.3 Meta-Interpretation Some logic programming languages allow compact meta-interpreters to be written. Meta-interpreters come to many different uses. <p> The previous goal is now restated. ?- m (X,[1,2,3]), m (X,[2,3,4]). The execution proceeds as follows. The initial goal is an and-box containing the two atomic goals. All rewrites will be performed on both goals "in parallel". and (m (X; <ref> [1; 2; 3] </ref>); m (X; [2; 3; 4])) First of all, local forking is applied to the m goals. The member goals now appear in the guard of a wait guarded goal. and (choice (and (member (X; [1; 2; 3])) : true); choice (and (member (X; [2; 3; 4])) : true)) <p> The previous goal is now restated. ?- m (X,[1,2,3]), m (X,[2,3,4]). The execution proceeds as follows. The initial goal is an and-box containing the two atomic goals. All rewrites will be performed on both goals "in parallel". and (m (X; [1; 2; 3]); m (X; <ref> [2; 3; 4] </ref>)) First of all, local forking is applied to the m goals. The member goals now appear in the guard of a wait guarded goal. and (choice (and (member (X; [1; 2; 3])) : true); choice (and (member (X; [2; 3; 4])) : true)) The first step of the <p> All rewrites will be performed on both goals "in parallel". and (m (X; <ref> [1; 2; 3] </ref>); m (X; [2; 3; 4])) First of all, local forking is applied to the m goals. The member goals now appear in the guard of a wait guarded goal. and (choice (and (member (X; [1; 2; 3])) : true); choice (and (member (X; [2; 3; 4])) : true)) The first step of the local execution is local forking of the member goals with the two clauses in the definition, producing choice-boxes with two guarded goals each with trivially solved guards. 16 choice (and (choice (true <p> parallel". and (m (X; [1; 2; 3]); m (X; <ref> [2; 3; 4] </ref>)) First of all, local forking is applied to the m goals. The member goals now appear in the guard of a wait guarded goal. and (choice (and (member (X; [1; 2; 3])) : true); choice (and (member (X; [2; 3; 4])) : true)) The first step of the local execution is local forking of the member goals with the two clauses in the definition, producing choice-boxes with two guarded goals each with trivially solved guards. 16 choice (and (choice (true : X = 1; true : member (X; [2; <p> [2; 3; 4])) : true)) The first step of the local execution is local forking of the member goals with the two clauses in the definition, producing choice-boxes with two guarded goals each with trivially solved guards. 16 choice (and (choice (true : X = 1; true : member (X; <ref> [2; 3] </ref>))) : true; and (choice (true : X = 2; true : member (X; [3; 4]))) : true) As this state is stable, nondeterminate promotion may be applied on either of the branches, followed by determinate promotion of the other. (There is room for some indeterministic choice between rules here, <p> The most lucid execution is shown.) and (choice (and (X = 1) : true; and (member (X; <ref> [2; 3] </ref>)) : true); choice (and (X = 2) : true; and (member (X; [3; 4])) : true)) Now note that the member goals that have been promoted are similar in appearance to the previous member goals.
Reference: [3] <author> Vitor Santos Costa, David H. D. Warren, and Rong Yang. </author> <title> The Andorra-I engine: A parallel implementation of the Basic Andorra model. </title> <type> Technical note, </type> <institution> University of Bristol, Department of Computer Science, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: This idea owes much to the notion of determinacy in P-Prolog [16]. The Andorra model has been implemented providing stream-and parallelism in combination with or-parallelism <ref> [3] </ref>. The potential of the Andorra model as a basis for combining Pro-log and committed-choice languages was first realised by Haridi [7, 6]. 1 Independently, Bahgat and Gregory extended the basic Andorra model by allowing full Parlog execution during the deterministic phase in the language Pandora [1]. <p> One appealing property is that all determinate goals may be executed in parallel, thereby extracting implicit dependent and-parallelism from pure programs. For example, the Andorra-I implementation provides both dependent and- and or-parallel execution on the Sequent Symmetry <ref> [3] </ref>. In AKL, this principle has been generalised to a language with deep guards, and is embodied in the stability condition. However, the basic principle itself is available as a special case. Its implications are further discussed in section 5.1. <p> The previous goal is now restated. ?- m (X,[1,2,3]), m (X,[2,3,4]). The execution proceeds as follows. The initial goal is an and-box containing the two atomic goals. All rewrites will be performed on both goals "in parallel". and (m (X; <ref> [1; 2; 3] </ref>); m (X; [2; 3; 4])) First of all, local forking is applied to the m goals. The member goals now appear in the guard of a wait guarded goal. and (choice (and (member (X; [1; 2; 3])) : true); choice (and (member (X; [2; 3; 4])) : true)) <p> The previous goal is now restated. ?- m (X,[1,2,3]), m (X,[2,3,4]). The execution proceeds as follows. The initial goal is an and-box containing the two atomic goals. All rewrites will be performed on both goals "in parallel". and (m (X; [1; 2; 3]); m (X; <ref> [2; 3; 4] </ref>)) First of all, local forking is applied to the m goals. The member goals now appear in the guard of a wait guarded goal. and (choice (and (member (X; [1; 2; 3])) : true); choice (and (member (X; [2; 3; 4])) : true)) The first step of the <p> All rewrites will be performed on both goals "in parallel". and (m (X; <ref> [1; 2; 3] </ref>); m (X; [2; 3; 4])) First of all, local forking is applied to the m goals. The member goals now appear in the guard of a wait guarded goal. and (choice (and (member (X; [1; 2; 3])) : true); choice (and (member (X; [2; 3; 4])) : true)) The first step of the local execution is local forking of the member goals with the two clauses in the definition, producing choice-boxes with two guarded goals each with trivially solved guards. 16 choice (and (choice (true <p> parallel". and (m (X; [1; 2; 3]); m (X; <ref> [2; 3; 4] </ref>)) First of all, local forking is applied to the m goals. The member goals now appear in the guard of a wait guarded goal. and (choice (and (member (X; [1; 2; 3])) : true); choice (and (member (X; [2; 3; 4])) : true)) The first step of the local execution is local forking of the member goals with the two clauses in the definition, producing choice-boxes with two guarded goals each with trivially solved guards. 16 choice (and (choice (true : X = 1; true : member (X; [2; <p> [2; 3; 4])) : true)) The first step of the local execution is local forking of the member goals with the two clauses in the definition, producing choice-boxes with two guarded goals each with trivially solved guards. 16 choice (and (choice (true : X = 1; true : member (X; <ref> [2; 3] </ref>))) : true; and (choice (true : X = 2; true : member (X; [3; 4]))) : true) As this state is stable, nondeterminate promotion may be applied on either of the branches, followed by determinate promotion of the other. (There is room for some indeterministic choice between rules here, <p> of the member goals with the two clauses in the definition, producing choice-boxes with two guarded goals each with trivially solved guards. 16 choice (and (choice (true : X = 1; true : member (X; [2; 3]))) : true; and (choice (true : X = 2; true : member (X; <ref> [3; 4] </ref>))) : true) As this state is stable, nondeterminate promotion may be applied on either of the branches, followed by determinate promotion of the other. (There is room for some indeterministic choice between rules here, but with equivalent result. <p> The most lucid execution is shown.) and (choice (and (X = 1) : true; and (member (X; <ref> [2; 3] </ref>)) : true); choice (and (X = 2) : true; and (member (X; [3; 4])) : true)) Now note that the member goals that have been promoted are similar in appearance to the previous member goals. <p> The most lucid execution is shown.) and (choice (and (X = 1) : true; and (member (X; [2; 3])) : true); choice (and (X = 2) : true; and (member (X; <ref> [3; 4] </ref>)) : true)) Now note that the member goals that have been promoted are similar in appearance to the previous member goals. It is easily seen that the last two steps can be repeated two more times for each of the remaining elements in the lists.
Reference: [4] <author> Torken Franzen. </author> <title> Logical aspects of the Andorra Kernel Language. </title> <note> (Revised version of SICS Research Report R90008, submitted to ILPS'91). </note>
Reference-contexts: For a thorough treatment of the AKL rules and their logical properties see <ref> [5, 4] </ref>. The computation model generalises definite clause resolution where program clauses are resolved against a goal clause. <p> The precise logical reading of these expressions is given by the declarative semantics of AKL <ref> [5, 4] </ref>. <p> The previous goal is now restated. ?- m (X,[1,2,3]), m (X,[2,3,4]). The execution proceeds as follows. The initial goal is an and-box containing the two atomic goals. All rewrites will be performed on both goals "in parallel". and (m (X; [1; 2; 3]); m (X; <ref> [2; 3; 4] </ref>)) First of all, local forking is applied to the m goals. The member goals now appear in the guard of a wait guarded goal. and (choice (and (member (X; [1; 2; 3])) : true); choice (and (member (X; [2; 3; 4])) : true)) The first step of the <p> parallel". and (m (X; [1; 2; 3]); m (X; <ref> [2; 3; 4] </ref>)) First of all, local forking is applied to the m goals. The member goals now appear in the guard of a wait guarded goal. and (choice (and (member (X; [1; 2; 3])) : true); choice (and (member (X; [2; 3; 4])) : true)) The first step of the local execution is local forking of the member goals with the two clauses in the definition, producing choice-boxes with two guarded goals each with trivially solved guards. 16 choice (and (choice (true : X = 1; true : member (X; [2; <p> of the member goals with the two clauses in the definition, producing choice-boxes with two guarded goals each with trivially solved guards. 16 choice (and (choice (true : X = 1; true : member (X; [2; 3]))) : true; and (choice (true : X = 2; true : member (X; <ref> [3; 4] </ref>))) : true) As this state is stable, nondeterminate promotion may be applied on either of the branches, followed by determinate promotion of the other. (There is room for some indeterministic choice between rules here, but with equivalent result. <p> The most lucid execution is shown.) and (choice (and (X = 1) : true; and (member (X; [2; 3])) : true); choice (and (X = 2) : true; and (member (X; <ref> [3; 4] </ref>)) : true)) Now note that the member goals that have been promoted are similar in appearance to the previous member goals. It is easily seen that the last two steps can be repeated two more times for each of the remaining elements in the lists.
Reference: [5] <author> Torken Franzen. </author> <title> Formal aspects of the Andorra Kernel Language: </title> <type> I. </type> <institution> Research Report R90008, SICS, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: For a thorough treatment of the AKL rules and their logical properties see <ref> [5, 4] </ref>. The computation model generalises definite clause resolution where program clauses are resolved against a goal clause. <p> The precise logical reading of these expressions is given by the declarative semantics of AKL <ref> [5, 4] </ref>. <p> AKL: H (in,Y) :- G ! Y=out, B. The quietness restriction is essential for parallel execution by making cut insensitive to the order of execution of goals. Also, with the quietness restriction, cut in AKL can be given an intuitive logical interpretation as "if-then-else"; see <ref> [5] </ref> for a discussion and proof. An important corollary is the soundness of negation-as-failure in its most general way (without being constructive) in AKL. Unfortunately, the quietness restriction also makes some pragmatically justifiable programming tricks impossible that are possible in Pro-log.
Reference: [6] <author> Seif Haridi. </author> <title> A logic programming language based on the Andorra model. </title> <journal> New Generation Computing, </journal> (7):109-125, 1990. <volume> 21 </volume>
Reference-contexts: This idea owes much to the notion of determinacy in P-Prolog [16]. The Andorra model has been implemented providing stream-and parallelism in combination with or-parallelism [3]. The potential of the Andorra model as a basis for combining Pro-log and committed-choice languages was first realised by Haridi <ref> [7, 6] </ref>. 1 Independently, Bahgat and Gregory extended the basic Andorra model by allowing full Parlog execution during the deterministic phase in the language Pandora [1]. As a joint effort between us and Warren, an Extended Andorra Model (EAM) was developed.
Reference: [7] <author> Seif Haridi and Per Brand. </author> <title> Andorra Prolog, an integration of Prolog and committed choice languages. </title> <booktitle> In Proceedings of the FGCS, </booktitle> <year> 1988. </year>
Reference-contexts: This idea owes much to the notion of determinacy in P-Prolog [16]. The Andorra model has been implemented providing stream-and parallelism in combination with or-parallelism [3]. The potential of the Andorra model as a basis for combining Pro-log and committed-choice languages was first realised by Haridi <ref> [7, 6] </ref>. 1 Independently, Bahgat and Gregory extended the basic Andorra model by allowing full Parlog execution during the deterministic phase in the language Pandora [1]. As a joint effort between us and Warren, an Extended Andorra Model (EAM) was developed.
Reference: [8] <author> Seif Haridi and Sverker Janson. </author> <title> Kernel Andorra Prolog and its computation model. </title> <booktitle> In Proceedings of the Seventh International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1990. </year> <note> (Revised version of SICS Research Report R90002). </note>
Reference-contexts: 1 Introduction The Andorra Kernel Language (AKL) is a general concurrent logic programming language that is based on an instance of the Kernel Andorra Prolog (KAP) control framework for the Extended Andorra Model <ref> [8] </ref>. This paper presents a language design. The purpose is to, by means of more or less familiar examples, illustrate the possibilities provided by AKL. This is not to say that implementation has been set aside. We have a prototype implementation of the language, which is showing good results. <p> Warren has proposed an implicit control regime for the EAM with the goal to provide good behaviour for programs without extra annotations apart from cut and commit [15]. We have earlier developed a formal computation model based on the EAM for the language framework Kernel Andorra Prolog (KAP) <ref> [8] </ref>. There we added the wait guard operator to delimit local execution, and the model was based on the notion of constraints and constraint operations. For the latter notions, the work of Vijay Saraswat was very influential [9]. <p> A more definitive solution, allowing fully automatic translation, is to add noisy cut as a new guard operator in the language <ref> [8, 10] </ref>. This is an option in the Kernel Andorra Prolog framework, and it has been included in the prototype implementation of AKL.
Reference: [9] <author> Vijay A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, </institution> <month> January </month> <year> 1990. </year>
Reference-contexts: There we added the wait guard operator to delimit local execution, and the model was based on the notion of constraints and constraint operations. For the latter notions, the work of Vijay Saraswat was very influential <ref> [9] </ref>. A language that is an instance of the KAP framework uses a subset of the guard-operators and the constraint operations, and it may also further restrict the basic control principles provided. <p> An often used example is the n-queens problem <ref> [13, 9, 1] </ref>.
Reference: [10] <author> Vijay A. Saraswat and Seif Haridi. </author> <title> Some notes on Andorra Prolog. unpublished note, </title> <month> May </month> <year> 1989. </year>
Reference-contexts: A more definitive solution, allowing fully automatic translation, is to add noisy cut as a new guard operator in the language <ref> [8, 10] </ref>. This is an option in the Kernel Andorra Prolog framework, and it has been included in the prototype implementation of AKL.
Reference: [11] <author> Ehud Shapiro. </author> <title> Concurrent Prolog: A progress report. </title> <journal> IEEE Computer, </journal> <volume> 8(19) </volume> <pages> 44-58, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: Pure Horn-clause programs can also be executed by the following meta-interpreter, which is derived from the Or-parallel Prolog interpreter in Concurrent Prolog by Ken Kahn <ref> [11] </ref>. (The predicate clauses/2 returns a list of clauses for a goal, and append/3 is the directional append from two input lists to one output list.) The major difference is that the following is a full-fledged all-solutions interpreter as opposed to the single-solution interpreter in Concurrent Prolog.
Reference: [12] <author> Kazunori Ueda. </author> <title> A new implementation technique for flat GHC. </title> <booktitle> In Proceedings of the Seventh International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In the AKL, the tree can be represented by a tree of processes, as in GHC. It can be argued that this is less efficient than the Prolog solution, but new results on compilation techniques for FGHC-like programs suggest that this inefficiency is not necessarily an inherent problem (see <ref> [12] </ref>). A more definitive solution, allowing fully automatic translation, is to add noisy cut as a new guard operator in the language [8, 10]. This is an option in the Kernel Andorra Prolog framework, and it has been included in the prototype implementation of AKL.
Reference: [13] <author> Pascal Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: An often used example is the n-queens problem <ref> [13, 9, 1] </ref>. <p> An often used example is the n-queens problem [13, 9, 1]. The following program is adapted from <ref> [13] </ref> using a finite domain constraints package written entirely in AKL. queens (N, []). queens (N, [XjY]) :- fd (domain (N, X)), noattack (X, Y), queens (N, Y). noattack (X ,Xs) :- noattack (X, Xs, 1). noattack (X, [], Nb). noattack (X, [YjYs], Nb) :- fd ((X 6= Y, X 6=
Reference: [14] <author> David H. D. Warren. </author> <title> The Andorra principle. </title> <booktitle> Presented at the Gigalips workshop, </booktitle> <address> Stockholm, </address> <year> 1987. </year>
Reference-contexts: The Andorra model was proposed by Warren <ref> [14] </ref> as a basic tool for combining or-parallelism with general and-parallelism in the execution of pure definite clauses (see section 4.2.3). This idea owes much to the notion of determinacy in P-Prolog [16]. The Andorra model has been implemented providing stream-and parallelism in combination with or-parallelism [3]. <p> It states that atomic goals that have at most one candidate clause (determinate goals) should be selected first. Only when there are no such goals may another goal be selected (a nondeterminate goal) <ref> [14] </ref>. One appealing property is that all determinate goals may be executed in parallel, thereby extracting implicit dependent and-parallelism from pure programs. For example, the Andorra-I implementation provides both dependent and- and or-parallel execution on the Sequent Symmetry [3].
Reference: [15] <author> David H. D. Warren. </author> <title> The Extended Andorra Model with implicit control. </title> <booktitle> presented at a Parallel Logic Programming workshop in Eilat, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: Warren has proposed an implicit control regime for the EAM with the goal to provide good behaviour for programs without extra annotations apart from cut and commit <ref> [15] </ref>. We have earlier developed a formal computation model based on the EAM for the language framework Kernel Andorra Prolog (KAP) [8]. There we added the wait guard operator to delimit local execution, and the model was based on the notion of constraints and constraint operations. <p> Also, the more that is done locally, the more may be available for parallel execution on a multi-processor. The following example shows how a useful tradeoff can be achieved (adapted from <ref> [15] </ref>). It is a program that finds common sublists of two lists. In its first formulation, there is only trivial local execution. sublist ([], []). sublist ([XjL], [XjL1]) :- sublist (L, L1). sublist (L, [XjL1]) :- sublist (L, L1). ?- sublist (L, [c,a,t,s]), sublist (L, [l,a,s,t]).
Reference: [16] <author> Rong Yang and Hideo Aiso. P-Prolog: </author> <title> A parallel logic langauge based on exclusive relation. </title> <booktitle> In Proceedings of the Third International Conference on Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1986. </year> <title> A workshop record for the Parallel Logic Programming workshop in Eilat, with copies of slides and position papers, </title> <note> is available from SICS. 22 </note>
Reference-contexts: The Andorra model was proposed by Warren [14] as a basic tool for combining or-parallelism with general and-parallelism in the execution of pure definite clauses (see section 4.2.3). This idea owes much to the notion of determinacy in P-Prolog <ref> [16] </ref>. The Andorra model has been implemented providing stream-and parallelism in combination with or-parallelism [3].
References-found: 16

