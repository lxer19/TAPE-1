URL: ftp://ftp.cs.utah.edu/pub/jacobs-thesis.ps.Z
Refering-URL: http://www.cs.utah.edu/~gary/MSO-publications.html
Root-URL: 
Title: UCL+P A PERSISTENT COMMON LISP  
Author: by James H. Jacobs 
Degree: A dissertation submitted to the faculty of The University of Utah in partial fulfillment of the requirements for the degree of Doctor of Philosophy  
Date: August 1994  
Affiliation: Department of Computer Science The University of Utah  
Abstract-found: 0
Intro-found: 0
Reference: [1] <author> R. Agrawal. </author> <title> Concurrency control performance modelling: Alternatives and implications. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(4), </volume> <month> December </month> <year> 1987. </year>
Reference-contexts: When less than 10 transactions are simultaneously accessing the store the throughput is about the same for both optimistic and pessimistic approaches <ref> [1] </ref>; however as the number of concurrent transactions increases above 10, the pessimistic protocol typically gives a higher throughput.
Reference: [2] <author> R. Agrawal and Gehani N. H. </author> <title> ODE (Object Database and Environment): The language and data model. </title> <booktitle> In Proc. Int'l. Conf. on Management of Data, </booktitle> <pages> pages 36-45, </pages> <address> Portland, Oregon, May-June 1989. ACM-SIGMOD. </address>
Reference-contexts: The extended languages can be grouped into three classes: C++ derived, Lisp derived and others. Many different persistent programming systems have been derived from C++. This is not surprising since C++ is currently the most popular object-oriented programming language. Notable examples in this category include E [25], O++/ODE <ref> [2] </ref>, and ObjectStore [17]; ObjectStore will be described further below. Although some aspects of these languages are relevant to UCL+P, they fail to address many of the problems that UCL+P must solve.
Reference: [3] <author> Malcom P. Atkinson and O. Peter Buneman. </author> <title> Types and persistence in database programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 19(2) </volume> <pages> 105-190, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: Future extensions and enhancements to the system are discussed in Chapter 9. Finally, Chapter 10 summarizes this work and assesses both its successes and deficiencies. CHAPTER 2 RELATED WORK In the last 10 years there has been considerable interest in developing languages to support concurrent and persistent programming <ref> [3] </ref> [4] [7]. This interest has led to modifications of existing languages and the development of new languages.
Reference: [4] <author> Henri E. Bal, Jennifer G. Steiner, and Tanenbaum Andrew S. </author> <title> Programming languages for distributed computing systems. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3) </volume> <pages> 261-322, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Future extensions and enhancements to the system are discussed in Chapter 9. Finally, Chapter 10 summarizes this work and assesses both its successes and deficiencies. CHAPTER 2 RELATED WORK In the last 10 years there has been considerable interest in developing languages to support concurrent and persistent programming [3] <ref> [4] </ref> [7]. This interest has led to modifications of existing languages and the development of new languages.
Reference: [5] <author> Gilles Barbedette. </author> <title> LispO 2 : A persistent object-oriented Lisp. </title> <editor> In F. Bancilhon, C. Delobel, and P. Kanellakkis, editors, </editor> <title> Building an Object-Oriented Database System: </title> <booktitle> The Story of O 2 , chapter 10, </booktitle> <pages> pages 215-233. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1992. </year> <note> Also in Proceedings of the 2nd EDBT. </note>
Reference-contexts: The Lisp language family has also been the departing point for many persistent programming systems. However, most of these systems provide only object level persistence. The Lisp derivatives, PCLOS, MetaStore, and PISA will be discussed 7 below. LispO 2 <ref> [5] </ref> purports to be a persistent Lisp, but the published information is insufficient to validate this claim. Persistent programming systems have been built around several other existing languages, and some new languages have been created that incorporate persistence.
Reference: [6] <author> P. Butterworth, A. Otis, and J. Stein. </author> <title> The GemStone object database management system. </title> <journal> CACM, </journal> <volume> 34(10) </volume> <pages> 64-77, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: One of the earliest fully persistent languages was PS-Algol; it is discussed further below. ML is closer to a functional language than Lisp and its persistent variant provides an instructive contrast. Several different combinations of persistence and Smalltalk have been developed: Alltalk [30], GemStone <ref> [6] </ref>, and Persistent Smalltalk [15]. However, there are two aspects of Smalltalk that make it largely irrelevant to this project.
Reference: [7] <author> S. M. Clamen. </author> <title> Data persistence in programming languages: A survey. </title> <type> Technical report, </type> <institution> Carnegie Mellon University, </institution> <year> 1991. </year> <month> CMU-CS-91-155. </month>
Reference-contexts: Finally, Chapter 10 summarizes this work and assesses both its successes and deficiencies. CHAPTER 2 RELATED WORK In the last 10 years there has been considerable interest in developing languages to support concurrent and persistent programming [3] [4] <ref> [7] </ref>. This interest has led to modifications of existing languages and the development of new languages.
Reference: [8] <author> W. P. Cockshott. </author> <title> PS-ALGOL Implementations: Applications in Persistent Object-oriented Programming. </title> <publisher> Ellis Horwood, </publisher> <year> 1990. </year>
Reference-contexts: Second, Smalltalk programs are compiled into a byte code which is then interpreted; efficiently adding persistence support to an interpreter is much easier than providing that support in a system using compiled programs. 2.1 PS-Algol PS-Algol was probably the earliest persistent programming language <ref> [8] </ref>. PS-Algol provided persistence orthogonal to data types. Persistent values are stored in a file that is explicitly opened. Each file contains a symbol table construct that maps strings to PS-Algol values. The symbol table serves as the root of the file. <p> File level granularity can be very cost effective, and is fairly easy to implement, but the amount of concurrent access it permits to the store is very limited. Despite its restrictiveness, file level has been adopted by several systems 48 (e.g., MetaStore [18], PS-Algol <ref> [8] </ref>). Package level granularity would be similar to file level granularity. 5.2.2.2 Value Level Granularity On the other end of the spectrum is value level granularity. For persistent programming systems, value is defined by the language.
Reference: [9] <author> Korth H. F. and A. Silberschatz. </author> <title> Database System Concepts, Second Edition. </title> <publisher> McGraw-Hill, </publisher> <year> 1991. </year>
Reference-contexts: First, they provide atomicity for groups of related changes, ensuring the consistency of stored values. A transaction groups a sequence of operations on persistent values together and either makes the results of 19 all the operations persistent or discards them all <ref> [9] </ref>. If the changes are made then the transaction is said to have committed, and otherwise the transaction is said to have aborted. Ensuring atomic transaction semantics requires that all mutations to persistent values occur only within the dynamic scope of a transaction construct.
Reference: [10] <author> S. Ford, J. Joseph, Langworthy D., D. Lively, G. Pathak, E. Perez, R. Peterson, D. Sparacin, S. Thatte, Wells D., and S. Agarwala. Zeitgeist: </author> <title> Database support for object-oriented programming. </title> <editor> In K. R. Dittrich, editor, </editor> <booktitle> Advances in Object-Oriented Database Systems. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: If an optimistic policy is in force, then the accesses must be recorded so that the read and write sets are available for transaction validation at commit time. Users of value level granularity are Thor [19], ObServer [14], Zeitgeist <ref> [10] </ref>, and ESM [12]. Thor proposes to use an optimistic approach to concurrency whereas ESM and ObServer use locking. <p> Page level granularity is a commonly used approach. Among the persistent stores using them are ObjectStore [17], and Texas [28]. ObServer [14] and Zeitgeist <ref> [10] </ref> provide both page and value level granularity. 5.2.2.4 Concurrency and Granularity in UCL+P The language semantics we developed for UCL+P include conferring persistence by reachability from persistent roots at commit time.
Reference: [11] <author> R. P. Gabriel. </author> <title> Perfomance and Evaluation of Lisp Systems. </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Access recording turns (potentially) every heap reference into a write, which has serious implications for cache behavior. As expected, adding support for transparent persistence slows down program execution. To measure the change in code performance we utilized the Gabriel bench mark set <ref> [11] </ref> which is tailored for Lisp programs; the results are shown in Table 6.1. When the tests were run, the runtime system used an IV that was 100% of the half heap size (since the average value size in the benchmark set is closer to 8 bytes).
Reference: [12] <author> ESM Group. </author> <title> Using the EXODUS Storage Manager V2.0.2. </title> <institution> Dept. of Computer Science, University of Wisconsin, </institution> <month> January </month> <year> 1992. </year>
Reference-contexts: If an optimistic policy is in force, then the accesses must be recorded so that the read and write sets are available for transaction validation at commit time. Users of value level granularity are Thor [19], ObServer [14], Zeitgeist [10], and ESM <ref> [12] </ref>. Thor proposes to use an optimistic approach to concurrency whereas ESM and ObServer use locking.
Reference: [13] <author> Maurice Herlihy. </author> <title> Optimistic concurrency control for abstract data types. </title> <editor> In 113 Zdonik and Maier, editors, </editor> <booktitle> Readings in Ojbect-Oriented Database Systems. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: The read and write sets, along with the new values for new and mutated values are sent over to the store manager. 85 7.4 Validation 6 UCL+P uses a conflict-based backwards validation approach <ref> [13] </ref>. Under this approach when a transaction completes its read and write sets are compared with those generated by transactions which were active at the same time and committed prior to the new transaction.
Reference: [14] <author> Mark F. Hornick and Stanley B. Zdonik. </author> <title> A shared, segmented memory system for an object-oriented database. </title> <journal> ACM TOOIS, </journal> <volume> 5(1), </volume> <month> January </month> <year> 1987. </year> <note> Also in [34]. </note>
Reference-contexts: If an optimistic policy is in force, then the accesses must be recorded so that the read and write sets are available for transaction validation at commit time. Users of value level granularity are Thor [19], ObServer <ref> [14] </ref>, Zeitgeist [10], and ESM [12]. Thor proposes to use an optimistic approach to concurrency whereas ESM and ObServer use locking. <p> Page level granularity is a commonly used approach. Among the persistent stores using them are ObjectStore [17], and Texas [28]. ObServer <ref> [14] </ref> and Zeitgeist [10] provide both page and value level granularity. 5.2.2.4 Concurrency and Granularity in UCL+P The language semantics we developed for UCL+P include conferring persistence by reachability from persistent roots at commit time.
Reference: [15] <author> A. L. Hosking, J. E. B. Moss, and C. Bliss. </author> <title> Design of an object faulting persistent SmallTalk. </title> <type> Technical report, </type> <institution> Univerity of Massachusetts, </institution> <year> 1990. UM-CS-1990-045. </year>
Reference-contexts: One of the earliest fully persistent languages was PS-Algol; it is discussed further below. ML is closer to a functional language than Lisp and its persistent variant provides an instructive contrast. Several different combinations of persistence and Smalltalk have been developed: Alltalk [30], GemStone [6], and Persistent Smalltalk <ref> [15] </ref>. However, there are two aspects of Smalltalk that make it largely irrelevant to this project.
Reference: [16] <author> G. Kiczales, J. des Rivieres, and D. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: class metaobject will have a volatile classwide slot; if this slot were to be used as a class-extent (list of all class instances) it is not clear how this slot would be initialized when a package containing persistent instances of the class was opened. 9.1.2 MOP Structures The Meta-object protocol <ref> [16] </ref> defines several different metaobjects: classes, methods, and generic functions. Classes define the layout of instance objects, contain classwide slots, and are members of an inheritance hierarchy.
Reference: [17] <author> Charles Lamb, Gordon Landis, Jack Orenstein, and Dan Weinreb. </author> <title> The ObjectStore database system. </title> <journal> Communications of the ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Many different persistent programming systems have been derived from C++. This is not surprising since C++ is currently the most popular object-oriented programming language. Notable examples in this category include E [25], O++/ODE [2], and ObjectStore <ref> [17] </ref>; ObjectStore will be described further below. Although some aspects of these languages are relevant to UCL+P, they fail to address many of the problems that UCL+P must solve. Lisp features automatic storage management, dynamic binding, and first class functions, none of which have a counterpart in the C++ world. <p> For example, if a formatting function relying on the global variable radix became persistent, subsequent uses of the formating function would forever use the value of radix that was in force when the function became persistent. 2.2 ObjectStore ObjectStore <ref> [17] </ref> is an object-oriented database system based on C++. User programs are written in a C++ extension which is precompiled into C++. Ob-jectStore provides persistence to all first-class C++ data types (which excludes functions). Persistence is conferred on a value at creation time. <p> To provide high level support for a locking approch, the runtime system has to detect read and write accesses to granules and then obtain the appropriate locks from the transaction manager before proceeding. As an optimization, ObjectStore implicitly read locks all granules held by the runtime system <ref> [17] </ref>. If another transaction requires a write lock on one of these granules, the Store Manager would call back to the runtime system to see if the granule was really read locked. <p> A benefit of the larger granularity is that the cost of obtaining locks is amortized over the entire page, since only the first value access on a page requires requesting a lock. Page level granularity is a commonly used approach. Among the persistent stores using them are ObjectStore <ref> [17] </ref>, and Texas [28]. ObServer [14] and Zeitgeist [10] provide both page and value level granularity. 5.2.2.4 Concurrency and Granularity in UCL+P The language semantics we developed for UCL+P include conferring persistence by reachability from persistent roots at commit time. <p> The portions of the original package that are not shadowed in the versioned package would be shared, thus not requiring redundant storage. This sort of versioning is fairly common to object-oriented databases (e.g., Ob-jectStore <ref> [17] </ref>). However, the nature of Lisp data types would make implementing it subtly harder. <p> If the list was complete when the first cons cell was committed, the store should be able to keep the list together. For a more complex data structure, especially one where the constituents are shared, the problem is not as straightforward. Systems such as ObjectStore <ref> [17] </ref> allow the programmer to define page clusters within the store and assign a persistent value to a specified cluster when it is created. Since the programmer often has a good idea of the interrelationship between values, this provides a useful way to improve store performance.
Reference: [18] <author> Arthur H. Lee. </author> <title> The Persistent Object System MetaStore: Persistence via Metaprogramming. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> August </month> <year> 1992. </year>
Reference-contexts: The introduction of the virtual database between the language and a variety of DBMSes provides for a very flexible approach, but the extra level increases the problems associated with integrating the data representations of a general purpose language and a DBMS. 2.4 MetaStore MetaStore <ref> [18] </ref>, like PCLOS, is a Lisp-based persistent object system. MetaStore makes use of the CLOS meta-object protocol to create and manage persistable objects. One of the goals of MetaStore was to produce a portable system, so no modifications of the Lisp compiler and run time system were possible. <p> File level granularity can be very cost effective, and is fairly easy to implement, but the amount of concurrent access it permits to the store is very limited. Despite its restrictiveness, file level has been adopted by several systems 48 (e.g., MetaStore <ref> [18] </ref>, PS-Algol [8]). Package level granularity would be similar to file level granularity. 5.2.2.2 Value Level Granularity On the other end of the spectrum is value level granularity. For persistent programming systems, value is defined by the language.
Reference: [19] <author> Barbara Liskov. </author> <title> Preliminary design of the Thor object-oriented database system. </title> <type> Unpublished, </type> <year> 1992. </year>
Reference-contexts: If an optimistic policy is in force, then the accesses must be recorded so that the read and write sets are available for transaction validation at commit time. Users of value level granularity are Thor <ref> [19] </ref>, ObServer [14], Zeitgeist [10], and ESM [12]. Thor proposes to use an optimistic approach to concurrency whereas ESM and ObServer use locking.
Reference: [20] <author> J. Eliot B. Moss. </author> <title> Nested transactions: An introduction. </title> <editor> In Bharat K. Bhargava, editor, </editor> <title> Concurrency Control and Reliability in Distributed Systems, </title> <booktitle> chapter 14, </booktitle> <pages> pages 395-425. </pages> <publisher> Van Nostrand Reinhold, </publisher> <year> 1987. </year>
Reference-contexts: Global symbols follow dynamic scoping rules. 21 The variable lisp::*abort-reason* is defined to contain an implementation dependent reason for the transaction abort (e.g. 'deadlock, 'validation-failed, etc.). It can also be set via the abort-transaction function (see below). Support for nested transactions <ref> [20] </ref> is permitted. An implementation dependent parameter, *max-transaction-depth*, specifies the maximum level of nesting. <p> The indirect costs are incurred in communicating with the store manager. We need to consider both of these costs in selecting an appropriate policy. A decision had to be made about whether to support nested transactions <ref> [20] </ref>. Nested transactions can increase the flexibility of the system, particularly when transactions are of long duration.
Reference: [21] <author> S. M. Nettles and Wing J. M. </author> <title> Persistence + undoability = transactions. </title> <booktitle> In Proceedings of the Hawaii International Conference on Systems Science 25, </booktitle> <year> 1992. </year> <note> See also tech-report CMU-CS-91-173. </note>
Reference-contexts: the persistent store. 2 1 PISA is also the name used for persistent immutable shared values. 2 If the object file changes between the load of the function and the time it is placed into the 13 2.6 Persistent ML A persistent version of ML has been built at CMU <ref> [21] </ref>. Orthogonal persistence is introduced by augmenting the ML program's environment with a persistent environment. A function is provided that explicitly opens the file containing the persistent environment; it appears that only one persistent environment can be open at a time. One part of the environment is a symbol table.
Reference: [22] <institution> Object Design Incoporated. </institution> <note> ObjectStore User's Guide for Release 2.0, </note> <year> 1993. </year>
Reference-contexts: Type evolution was not possible in the early versions of ObjectStore, but bowing to the necessity of production systems to alter database schema, the current release does support the evolution of types <ref> [22] </ref>. ObjectStore does a good job of providing orthogonal persistence to C++. The use of virtual memory to transparently support value loading, write back and locking permits the programmer to write code using a style that is fairly natural to a C++ programmer.
Reference: [23] <author> A. Paepcke. PCLOS: </author> <title> A flexible implementation of CLOS persistence. </title> <editor> In S. Gjessing and K. Nygaard, editors, </editor> <booktitle> Proceedings of the European Conference on Object-Oriented Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: Because C++ functions are second class data types, ObjectStore does not concern itself with persistent functions. No persistent association is made between objects and their methods. 2.3 PCLOS PCLOS <ref> [23, 24] </ref> is a persistent object system based on the Common Lisp Object System. PCLOS provides first class persistence only to persistable objects. An object is persistable if its class inherits from the PCLOS provided class pclos-class.
Reference: [24] <author> A. Paepcke. PCLOS: </author> <title> A critical review. </title> <booktitle> In OOPSLA '89. ACM, </booktitle> <year> 1989. </year>
Reference-contexts: Because C++ functions are second class data types, ObjectStore does not concern itself with persistent functions. No persistent association is made between objects and their methods. 2.3 PCLOS PCLOS <ref> [23, 24] </ref> is a persistent object system based on the Common Lisp Object System. PCLOS provides first class persistence only to persistable objects. An object is persistable if its class inherits from the PCLOS provided class pclos-class.
Reference: [25] <author> Joel E. Richardson, Michael J. Carey, and Daniel T. Schuh. </author> <title> The design of the E programming language. </title> <type> Technical report, </type> <institution> University of Wisconsin, </institution> <year> 1989. </year> <type> Tech Report 824. </type>
Reference-contexts: The extended languages can be grouped into three classes: C++ derived, Lisp derived and others. Many different persistent programming systems have been derived from C++. This is not surprising since C++ is currently the most popular object-oriented programming language. Notable examples in this category include E <ref> [25] </ref>, O++/ODE [2], and ObjectStore [17]; ObjectStore will be described further below. Although some aspects of these languages are relevant to UCL+P, they fail to address many of the problems that UCL+P must solve.
Reference: [26] <author> M. Shapiro, D. Plainfosse, and O. Gruber. </author> <title> A garbage dectection protocol for a realistic distributed object-support system. </title> <type> Technical report, </type> <institution> INRIA, 1990. Rapport de Recherche INRIA 1320. </institution>
Reference-contexts: If a package were self-contained, then garbage collection would be trivial; however, UCL+P allows interpackage references. This leads to adopting a conservative garbage collection algorithm patterned after <ref> [26] </ref>. In this approach we use the named references (symbols) as the roots of the garbage collection. <p> By modularizing the store, persistent packages also facilitate the task of garbage collecting persistent values. When a package is not being accessed by Lisp processes, the store can perform off-line garbage collection using algorithms similar to those developed by Shapiro <ref> [26] </ref>. Using this approach, garbage collection can be performed on a package by package basis without taking the entire persistent store off-line. 10.1.5 Application The Persistent Lisp language was demonstrated using a simple application, a toy geographical database.
Reference: [27] <author> Robert A. Shaw. </author> <title> Empirical Analysis of A Lisp System. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <month> February </month> <year> 1988. </year> <month> 114 </month>
Reference-contexts: Since some Lisp programs can spend a considerable amount of time, perhaps as much as one third <ref> [27] </ref>, performing garbage collection, changes to the garbage collector can greatly impact program performance. UCL uses a two-space, copying 63 garbage collector; the collector copies live values from the current half-heap to the spare half-heap. In UCL+P, the collector also reclaims dead IV entries.
Reference: [28] <author> V. Singhal, Kakkad S., and P. Wilson. </author> <title> Texas: An efficient, portable persistent store. </title> <booktitle> In Proceedings of the Fifth International Workshop of Persistent Object Systems. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Page level granularity is a commonly used approach. Among the persistent stores using them are ObjectStore [17], and Texas <ref> [28] </ref>. ObServer [14] and Zeitgeist [10] provide both page and value level granularity. 5.2.2.4 Concurrency and Granularity in UCL+P The language semantics we developed for UCL+P include conferring persistence by reachability from persistent roots at commit time. <p> Despite this, some translation scheme is required when values are moved from the program's memory into the store. In UCL+P, these transformations are limited to the intervalue references. A translation approach similar to Texas <ref> [28] </ref> was adopted. Each persistent package on the store is composed of four address spaces: data, name, symbol, and proxy.
Reference: [29] <author> Guy L. Steele, Jr. </author> <title> Common Lisp: The Language, Second Edition. </title> <publisher> Digital Press, </publisher> <year> 1991. </year>
Reference-contexts: For some of the data types (e.g., numbers) the semantics of persistence is quite straightforward and for others (e.g., functions) it is fairly complex. 4.4.1 Numbers, Characters Common Lisp permits the implementation to make copies of characters and numbers whenever desired <ref> [29] </ref>; therefore, no Lisp program can safely rely on two numbers being eq to each other. <p> This is analogous to performing a sequence of defstruct, make-struct, defstruct. 43 Common Lisp states that the results of redefining a structure are undefined <ref> [29] </ref> (in the transient world); Persistent Lisp adopts this approach. 4.4.7 Persistence Semantics of Classes, Methods, and Generic Functions These data types were introduced into Common Lisp along with CLOS. CLOS provides a very powerful object system, including multiple inheritance, the meta-object protocol, and a simple form of type evolution.
Reference: [30] <author> A. Straw, F. Mellender, and S. Riegel. </author> <title> Object management in a persistent smalltalksystem. </title> <journal> Software Practice and Experience, </journal> <volume> 19(8) </volume> <pages> 719-737, </pages> <month> August </month> <year> 1989. </year>
Reference-contexts: One of the earliest fully persistent languages was PS-Algol; it is discussed further below. ML is closer to a functional language than Lisp and its persistent variant provides an instructive contrast. Several different combinations of persistence and Smalltalk have been developed: Alltalk <ref> [30] </ref>, GemStone [6], and Persistent Smalltalk [15]. However, there are two aspects of Smalltalk that make it largely irrelevant to this project.
Reference: [31] <author> Mark R. Swanson. </author> <title> Concurrent Scheme reference. </title> <journal> Lisp and Symbolic Computation, </journal> 5(1/2):95-104, May 1992. 
Reference-contexts: Portability and efficiency concerns caused the system to rely on the programmer to explicitly mark modified objects as dirty. A nestable transaction mechanism is provided for implementing atomic operations. 2.5 PISA Persistent Immutable Shared Abstractions (PISA) [33] is an extension to Concurrent Utah Scheme (CUS) <ref> [31] </ref>. One of the goals of the extension was to allow CUS programs to manipulate large amounts of data without relying on distributed shared virtual memory. PISA provides persistence to all Scheme data types except continuations.
Reference: [32] <author> Paul R. Wison. </author> <title> Pointer swizzling at page fault time: Efficiently supporting huge address spaces on standard hardware. </title> <journal> Computer Architecture News, </journal> <volume> 19(4) </volume> <pages> 6-13, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: EID that is not known to the system, an IV entry will be allocated for that EID and space on the pheap will be reserved for the page containing the value associated with the EID (if it has not already been allocated). 9 This process is called swizzling by Wilson <ref> [32] </ref> 10 For most values the EID can be determined from the virtual address and the persistent heap page table. 70 6.5.1.1 Proxy Values Proxies are special values that stand in for values located in other packages which are referenced from within the package containing the proxy.
Reference: [33] <author> Benny Yih, Mark R. Swanson, and Robert R. Kessler. </author> <title> Persistent immutable shared abstractions. </title> <editor> In Jr. Robert H. Halstead and Takayasu Ito (Eds.), editors, </editor> <booktitle> Parallel Symbolic Computing: Languages, Systems, and Applications, number 748 in Lecture Notes in Computer Science, </booktitle> <address> Berlin, </address> <month> November </month> <year> 1993. </year> <title> Springer-Verlag. </title> <booktitle> Proceedings of the 1992 Workshop on Parallel Symbolic Computing, </booktitle> <address> Cambridge, Mass. </address>
Reference-contexts: Portability and efficiency concerns caused the system to rely on the programmer to explicitly mark modified objects as dirty. A nestable transaction mechanism is provided for implementing atomic operations. 2.5 PISA Persistent Immutable Shared Abstractions (PISA) <ref> [33] </ref> is an extension to Concurrent Utah Scheme (CUS) [31]. One of the goals of the extension was to allow CUS programs to manipulate large amounts of data without relying on distributed shared virtual memory. PISA provides persistence to all Scheme data types except continuations.
Reference: [34] <editor> Stanley B. Zdonik and David Maier, editors. </editor> <booktitle> Readings in Object-Oriented Database Systems. </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
References-found: 34

