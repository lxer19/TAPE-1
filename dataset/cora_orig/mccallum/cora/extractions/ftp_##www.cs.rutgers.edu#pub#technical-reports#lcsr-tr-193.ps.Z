URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-193.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: pande@cadillac.siemens.com  landi@cadillac.siemens.com  ryder@cs.rutgers.edu  
Title: Interprocedural Reaching Definitions in the Presence of Single Level Pointers  
Author: Hemant D. Pande William Landi Barbara G. Ryder 
Date: October 13, 1992  
Address: 755 College Rd. East Princeton, NJ 08540  755 College Rd. East Princeton, NJ 08540  
Affiliation: Siemens Corporate Research Inc  Siemens Corporate Research Inc  Department of Computer Science Rutgers University  
Abstract: This paper describes the first algorithm that calculates Interprocedural Def-Use Associations in C software systems. Our algorithm accounts for program-point-specific pointer-induced aliases, although it is currently limited to programs using a single level of indirection. We prove the NP-hardness of the Interprocedural Reaching Definitions Problem and point out the approx imation made by our polynomial-time algorithm. Initial empirical results are also presented. fl The research reported here was supported by Siemens Corporate Research and NSF grants CCR-8920078 and CCR-9023628 1/5. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> H. Agrawal and J.R. Horgan. </author> <title> Dynamic program slicing. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 246-256, </pages> <month> June </month> <year> 1990. </year> <journal> also available as SIGPLAN Notices, </journal> <volume> vol 25, no 6, </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: If we obtain a safe approximation to Def-Use Associations solution, then only the latter situation can occur. Debuggers based on static and dynamic slicing methods <ref> [1, 19, 21, 34, 41, 43] </ref> offer the promise of efficient on-line analyses of programs.
Reference: [2] <author> J. M. Barth. </author> <title> A practical interprocedural data flow analysis algorithm. </title> <journal> Communications of the ACM, </journal> <volume> 21(9) </volume> <pages> 724-736, </pages> <year> 1978. </year>
Reference-contexts: In other words assuming all paths through the program are executable <ref> [2] </ref>. 5 3 Theoretical Complexity of the Problem Myers [30] showed that precise Interprocedural Reaching Definitions is NP-complete in the presence of aliasing. Landi and Ryder [23] proved the NP-hardness of the Intraprocedural Alias Problem in the presence of multiple level pointers. <p> We are empirically testing the viability and precision of our algorithm, and have reported preliminary results. Our research marks an important milestone 15 under the common assumptions of static analysis <ref> [2] </ref>. 18 in the practical static analysis of C programs, producing information useful for debugging, testing and maintenance tools. In the future, we plan to extend our algorithm to handle multiple level pointers and recursive structures, as well as to increase the efficiency of the algorithm.
Reference: [3] <author> D. Callahan. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 47-56, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: Many spurious side effects are generated because of this imprecision [23]. 1.2 Related Work Recent emphasis in the static analysis community has been on expanding compile-time analyses to include interprocedural information <ref> [3, 7, 8, 14, 15, 18, 28, 29, 30] </ref>. The Fortran model of interprocedural communication has been successfully analyzed [3, 7, 8, 15, 29], although some analyses have yet to demonstrate their practicality. <p> The Fortran model of interprocedural communication has been successfully analyzed <ref> [3, 7, 8, 15, 29] </ref>, although some analyses have yet to demonstrate their practicality. Callahan [3] and Harrold-Soffa [15] suggested factoring the aliases into the problem solution after the side effect analysis, as in previous work by Lomet [29]. <p> The Fortran model of interprocedural communication has been successfully analyzed [3, 7, 8, 15, 29], although some analyses have yet to demonstrate their practicality. Callahan <ref> [3] </ref> and Harrold-Soffa [15] suggested factoring the aliases into the problem solution after the side effect analysis, as in previous work by Lomet [29].
Reference: [4] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 25, No 6. </volume>
Reference-contexts: The context of this work has been the development of parallelizing compilers; it has concentrated on conflict/dependence analysis, which asks "When can two names point in a dynamic structure to the same cell?" <ref> [4, 13, 16, 17, 20, 27] </ref>.
Reference: [5] <author> A. Chow and A. Rudmik. </author> <title> The design of a data flow analyzer. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 106-113, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: Both (i) and (ii) can occur in C programs. Most previous work in analyzing pointer-induced aliasing has been incomplete, impractical, or imprecise by design <ref> [5, 6, 9, 10, 12, 31, 42] </ref>. This would render corresponding Def-Use analysis imprecise as well. Thus, our work on Interprocedural Reaching Definitions in the presence of pointers, which builds on our work in pointer-induced aliasing, is qualitatively different from previous work.
Reference: [6] <author> B. G. Cooper. </author> <title> Ambitious data flow analysis of procedural programs. </title> <type> Master's thesis, </type> <institution> University of Minnesota, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: Both (i) and (ii) can occur in C programs. Most previous work in analyzing pointer-induced aliasing has been incomplete, impractical, or imprecise by design <ref> [5, 6, 9, 10, 12, 31, 42] </ref>. This would render corresponding Def-Use analysis imprecise as well. Thus, our work on Interprocedural Reaching Definitions in the presence of pointers, which builds on our work in pointer-induced aliasing, is qualitatively different from previous work.
Reference: [7] <author> K. Cooper and K. Kennedy. </author> <title> Efficient computation of flow insensitive interprocedural summary information. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 247-258, </pages> <month> June </month> <year> 1984. </year> <journal> SIGPLAN Notices, </journal> <volume> Vol 19, No 6. </volume>
Reference-contexts: Many spurious side effects are generated because of this imprecision [23]. 1.2 Related Work Recent emphasis in the static analysis community has been on expanding compile-time analyses to include interprocedural information <ref> [3, 7, 8, 14, 15, 18, 28, 29, 30] </ref>. The Fortran model of interprocedural communication has been successfully analyzed [3, 7, 8, 15, 29], although some analyses have yet to demonstrate their practicality. <p> The Fortran model of interprocedural communication has been successfully analyzed <ref> [3, 7, 8, 15, 29] </ref>, although some analyses have yet to demonstrate their practicality. Callahan [3] and Harrold-Soffa [15] suggested factoring the aliases into the problem solution after the side effect analysis, as in previous work by Lomet [29].
Reference: [8] <author> K. Cooper and K. Kennedy. </author> <title> Fast interprocedural alias analysis. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-59, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Many spurious side effects are generated because of this imprecision [23]. 1.2 Related Work Recent emphasis in the static analysis community has been on expanding compile-time analyses to include interprocedural information <ref> [3, 7, 8, 14, 15, 18, 28, 29, 30] </ref>. The Fortran model of interprocedural communication has been successfully analyzed [3, 7, 8, 15, 29], although some analyses have yet to demonstrate their practicality. <p> The Fortran model of interprocedural communication has been successfully analyzed <ref> [3, 7, 8, 15, 29] </ref>, although some analyses have yet to demonstrate their practicality. Callahan [3] and Harrold-Soffa [15] suggested factoring the aliases into the problem solution after the side effect analysis, as in previous work by Lomet [29]. <p> These aliases are defined at a program point, not just at procedure entry as in the Fortran analysis of <ref> [8] </ref>; thus, they are program-point-specific aliases. must be aliased: a must be aliased to b at n iff for all realizable paths n 1 n 2 : : :n i1 n, &lt;a; b&gt; holds.
Reference: [9] <author> D. S. Coutant. </author> <title> Retargetable high-level alias analysis. </title> <booktitle> In Conference Record of the Thirteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 110-118, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: Both (i) and (ii) can occur in C programs. Most previous work in analyzing pointer-induced aliasing has been incomplete, impractical, or imprecise by design <ref> [5, 6, 9, 10, 12, 31, 42] </ref>. This would render corresponding Def-Use analysis imprecise as well. Thus, our work on Interprocedural Reaching Definitions in the presence of pointers, which builds on our work in pointer-induced aliasing, is qualitatively different from previous work.
Reference: [10] <author> A. Deutsch. </author> <title> On determining lifetime and aliasing of dynamically allocated data in higher-order functional specifications. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 157-168, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: Both (i) and (ii) can occur in C programs. Most previous work in analyzing pointer-induced aliasing has been incomplete, impractical, or imprecise by design <ref> [5, 6, 9, 10, 12, 31, 42] </ref>. This would render corresponding Def-Use analysis imprecise as well. Thus, our work on Interprocedural Reaching Definitions in the presence of pointers, which builds on our work in pointer-induced aliasing, is qualitatively different from previous work.
Reference: [11] <author> P.G. Frankl and E.J. Weyuker. </author> <title> A data flow testing tool. </title> <booktitle> In Proceedings of Softfair II. IEEE, </booktitle> <month> December </month> <year> 1985. </year>
Reference-contexts: Data flow information is crucial to data flow based testing systems <ref> [11, 14, 33, 32, 37] </ref>. The accuracy of the static Def-Use information determines the efficiency of the test case coverage.
Reference: [12] <author> C. A. Guarna. </author> <title> A technique for analyzing pointer and structure references in parallel restructuring compilers. </title> <booktitle> In Proceedings of the International Conference on Parallel Processing, </booktitle> <pages> pages 212-220, </pages> <year> 1988. </year>
Reference-contexts: Both (i) and (ii) can occur in C programs. Most previous work in analyzing pointer-induced aliasing has been incomplete, impractical, or imprecise by design <ref> [5, 6, 9, 10, 12, 31, 42] </ref>. This would render corresponding Def-Use analysis imprecise as well. Thus, our work on Interprocedural Reaching Definitions in the presence of pointers, which builds on our work in pointer-induced aliasing, is qualitatively different from previous work.
Reference: [13] <author> W. L. Harrison III and Z. Ammarguellat. </author> <title> Parcel and Miprac: parallelizers for symbolic and numeric programs. </title> <booktitle> In Proceedings of International Workshop on Compilers for Parallel Computers, </booktitle> <pages> pages 329-346. </pages> <institution> Ecole des Mines de Paris - CAI, UPMC Laboratoire MASI, </institution> <month> December </month> <year> 1990. </year> <institution> Paris, France. </institution>
Reference-contexts: The context of this work has been the development of parallelizing compilers; it has concentrated on conflict/dependence analysis, which asks "When can two names point in a dynamic structure to the same cell?" <ref> [4, 13, 16, 17, 20, 27] </ref>.
Reference: [14] <author> M. J. Harrold and M. L. Soffa. </author> <title> Interprocedural data flow testing. </title> <booktitle> In Proceedings of the Third Testing, Analysis, and Verification Symposium, </booktitle> <pages> pages 158-167, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Data flow information is crucial to data flow based testing systems <ref> [11, 14, 33, 32, 37] </ref>. The accuracy of the static Def-Use information determines the efficiency of the test case coverage. <p> Many spurious side effects are generated because of this imprecision [23]. 1.2 Related Work Recent emphasis in the static analysis community has been on expanding compile-time analyses to include interprocedural information <ref> [3, 7, 8, 14, 15, 18, 28, 29, 30] </ref>. The Fortran model of interprocedural communication has been successfully analyzed [3, 7, 8, 15, 29], although some analyses have yet to demonstrate their practicality.
Reference: [15] <author> M. J. Harrold and M. L. Soffa. </author> <title> Computation of interprocedural definition and use dependencies. </title> <booktitle> In Proceedings of the 1990 International Conference on Computer Languages, </booktitle> <pages> pages 297-306, </pages> <year> 1990. </year>
Reference-contexts: Many spurious side effects are generated because of this imprecision [23]. 1.2 Related Work Recent emphasis in the static analysis community has been on expanding compile-time analyses to include interprocedural information <ref> [3, 7, 8, 14, 15, 18, 28, 29, 30] </ref>. The Fortran model of interprocedural communication has been successfully analyzed [3, 7, 8, 15, 29], although some analyses have yet to demonstrate their practicality. <p> The Fortran model of interprocedural communication has been successfully analyzed <ref> [3, 7, 8, 15, 29] </ref>, although some analyses have yet to demonstrate their practicality. Callahan [3] and Harrold-Soffa [15] suggested factoring the aliases into the problem solution after the side effect analysis, as in previous work by Lomet [29]. <p> The Fortran model of interprocedural communication has been successfully analyzed [3, 7, 8, 15, 29], although some analyses have yet to demonstrate their practicality. Callahan [3] and Harrold-Soffa <ref> [15] </ref> suggested factoring the aliases into the problem solution after the side effect analysis, as in previous work by Lomet [29]. Lomet's approach suggested that an approximation of side effects could be obtained by analyzing the procedure under different aliasing conditions and then combining them at some loss of precision. <p> If a is a pointer variable we consider a definition of a to also be an implicit definition of fla (i.e., the object name obtained by a single level indirection from a). 2 This representation of a program is similar to those of <ref> [15, 30] </ref>, although we use it differently during analysis. 4 l : f = q h : q = f call m,B entry B call k,B entry A exit B return k,B return m,B exit A A ( ) - k : B ( ); else l : f = q;
Reference: [16] <author> L. J. Hendren and A. Nicolau. </author> <title> Parallelizing programs with recursive data structures. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 35-47, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The context of this work has been the development of parallelizing compilers; it has concentrated on conflict/dependence analysis, which asks "When can two names point in a dynamic structure to the same cell?" <ref> [4, 13, 16, 17, 20, 27] </ref>.
Reference: [17] <author> S. Horwitz, P. Pfeiffer, and T. Reps. </author> <title> Dependence analysis for pointer variables. </title> <booktitle> In Proceedings of the ACM SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 28-40, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: The context of this work has been the development of parallelizing compilers; it has concentrated on conflict/dependence analysis, which asks "When can two names point in a dynamic structure to the same cell?" <ref> [4, 13, 16, 17, 20, 27] </ref>.
Reference: [18] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(1) </volume> <pages> 26-60, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The aim of slicing is to concentrate the programmer's attention on those parts of the program significant to the computation under current investigation; the more imprecise the static information, the less effectively the slicing method can prune away unrelated computations. Experimental techniques for merging independently altered versions of programs <ref> [18, 44] </ref> are of great interest to the programming-in-the-large community. In this domain also, the precision of the data flow information greatly impacts the comparison of the program semantics before and after changes; imprecise information may lead to incorrect conclusions of semantic differences. <p> Many spurious side effects are generated because of this imprecision [23]. 1.2 Related Work Recent emphasis in the static analysis community has been on expanding compile-time analyses to include interprocedural information <ref> [3, 7, 8, 14, 15, 18, 28, 29, 30] </ref>. The Fortran model of interprocedural communication has been successfully analyzed [3, 7, 8, 15, 29], although some analyses have yet to demonstrate their practicality.
Reference: [19] <author> Susan Horwitz, Thomas Reps, and David Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 35-46, </pages> <month> June </month> <year> 1988. </year>
Reference-contexts: If we obtain a safe approximation to Def-Use Associations solution, then only the latter situation can occur. Debuggers based on static and dynamic slicing methods <ref> [1, 19, 21, 34, 41, 43] </ref> offer the promise of efficient on-line analyses of programs.
Reference: [20] <author> N. Jones and S. Muchnick. </author> <title> Flow analysis and optimization of lisp-like structures. </title> <editor> In S. Muchnick and N. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 102-131. </pages> <publisher> Prentice Hall, </publisher> <year> 1979. </year> <month> 20 </month>
Reference-contexts: The context of this work has been the development of parallelizing compilers; it has concentrated on conflict/dependence analysis, which asks "When can two names point in a dynamic structure to the same cell?" <ref> [4, 13, 16, 17, 20, 27] </ref>.
Reference: [21] <author> Bogdan Korel and Janusz Laski. </author> <title> Dynamic slicing of computer programs. </title> <journal> Journal of Systems Software, </journal> <volume> 13:187--195, </volume> <year> 1990. </year>
Reference-contexts: If we obtain a safe approximation to Def-Use Associations solution, then only the latter situation can occur. Debuggers based on static and dynamic slicing methods <ref> [1, 19, 21, 34, 41, 43] </ref> offer the promise of efficient on-line analyses of programs.
Reference: [22] <author> W. Landi. </author> <title> Interprocedural Aliasing in the Presence of Pointers. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <month> January </month> <year> 1992. </year> <month> LCSR-TR-174. </month>
Reference-contexts: At this time, we are using conditional techniques to obtain an approximate analysis of aliasing in C programs with multiple levels of indirection <ref> [25, 22] </ref>. We are also investigating the extension of our Interprocedural Reaching Definitions algorithm to an approximate algorithm for analyzing programs with multiple levels of indirection. <p> For single level pointers, at most one alias pair is required to hold at the entry node to insure that alias-pair exists at the end of a particular realizable path from entry node to n <ref> [22] </ref>. Therefore, assumed-alias is either ; or a single alias pair. Note however, that for a particular alias-pair , different paths may require different assumptions at the entry.
Reference: [23] <author> W. Landi and B. G. Ryder. </author> <title> Aliasing with and without pointers: A problem taxonomy. </title> <institution> Center for Computer Aids for Industrial Productivity Technical Report CAIP-TR-125, Rutgers University, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: This paper describes the Def-Use analysis algorithm which is based on a polynomial-time Interprocedural Reaching Definitions calculation. We also report preliminary implementation results. Previous research in alias analysis of C programs has proven the theoretical difficulty of precisely solving the aliasing problem for programs with multiple levels of indirection <ref> [23, 24] </ref>. This research initiated the idea of performing conditional alias analysis in the presence of pointers. It allows us to analyze the code in a procedure under certain input assumptions. We then combine the results of these conditional analyses for those assumptions that actually may occur during program execution. <p> Our previous work in providing efficient incremental semantic change impact analysis of C programs using interprocedural data flow analysis, has been hampered by the lack of precision in the alias analyses. Many spurious side effects are generated because of this imprecision <ref> [23] </ref>. 1.2 Related Work Recent emphasis in the static analysis community has been on expanding compile-time analyses to include interprocedural information [3, 7, 8, 14, 15, 18, 28, 29, 30]. <p> In other words assuming all paths through the program are executable [2]. 5 3 Theoretical Complexity of the Problem Myers [30] showed that precise Interprocedural Reaching Definitions is NP-complete in the presence of aliasing. Landi and Ryder <ref> [23] </ref> proved the NP-hardness of the Intraprocedural Alias Problem in the presence of multiple level pointers. We show that precise solution of Intraprocedural Reaching Definitions in the presence of single level pointers is NP-hard. <p> We show that precise solution of Intraprocedural Reaching Definitions in the presence of single level pointers is NP-hard. Our proof is by reduction of the 3-SAT problem and is a variation of similar proofs in <ref> [23, 26, 30] </ref>. Theorem 1 In the presence of single level pointers, the problem of calculating precise Intraproce-dural Reaching Definitions is NP-hard. <p> The conditional must-alias set for a node n of the ICFG and an alias-pair is the unique minimal set of pairs that must be aliased at the entry node of the procedure containing n which insures that alias-pair must 5 This predicate appears as holds in <ref> [23, 24] </ref>. 6 entry (n) denotes the entry node of the procedure containing n, and entry A denotes the entry node of procedure A. 8 hold at n. If no such set exists, we say must-hold (n; alias-pair) is ?.
Reference: [24] <author> W. Landi and B. G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: This paper describes the Def-Use analysis algorithm which is based on a polynomial-time Interprocedural Reaching Definitions calculation. We also report preliminary implementation results. Previous research in alias analysis of C programs has proven the theoretical difficulty of precisely solving the aliasing problem for programs with multiple levels of indirection <ref> [23, 24] </ref>. This research initiated the idea of performing conditional alias analysis in the presence of pointers. It allows us to analyze the code in a procedure under certain input assumptions. We then combine the results of these conditional analyses for those assumptions that actually may occur during program execution. <p> The conditional must-alias set for a node n of the ICFG and an alias-pair is the unique minimal set of pairs that must be aliased at the entry node of the procedure containing n which insures that alias-pair must 5 This predicate appears as holds in <ref> [23, 24] </ref>. 6 entry (n) denotes the entry node of the procedure containing n, and entry A denotes the entry node of procedure A. 8 hold at n. If no such set exists, we say must-hold (n; alias-pair) is ?.
Reference: [25] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1992. </year>
Reference-contexts: At this time, we are using conditional techniques to obtain an approximate analysis of aliasing in C programs with multiple levels of indirection <ref> [25, 22] </ref>. We are also investigating the extension of our Interprocedural Reaching Definitions algorithm to an approximate algorithm for analyzing programs with multiple levels of indirection. <p> A similar situation exists 16 in efficiently finding aliases; we have applied our aliasing algorithm implementation techniques <ref> [25] </ref> to the reaches calculation. Basically, in our implementation we propagate information forward from each ICFG node to its successors. At an assignment node, we initialize the appropriate reaches predicates to true depending on the may-hold predicates at the node. We then propagate the reaches values along the realizable paths. <p> With this approach, our implementation never processes any unrealizable assumptions. As a result the implementation takes time proportional to the size of reaches solution. To obtain a lower bound on the empirical precision of our Reaching Definitions solution we use methods similar to those in <ref> [25] </ref>. We can show that there is only one source of approximation in our algorithm [35] which is illustrated by the following scenario.
Reference: [26] <author> J. R. Larus. </author> <title> Restructuring Symbolic Programs for Concurrent Execution on Multiprocessors. </title> <type> PhD thesis, </type> <institution> University of California Berkeley, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: We show that precise solution of Intraprocedural Reaching Definitions in the presence of single level pointers is NP-hard. Our proof is by reduction of the 3-SAT problem and is a variation of similar proofs in <ref> [23, 26, 30] </ref>. Theorem 1 In the presence of single level pointers, the problem of calculating precise Intraproce-dural Reaching Definitions is NP-hard.
Reference: [27] <author> J. R. Larus and P. N. Hilfinger. </author> <title> Detecting conflicts between structure accesses. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 21-34, </pages> <month> July </month> <year> 1988. </year> <journal> SIGPLAN NOTICES, </journal> <volume> Vol. 23, No. </volume> <pages> 7. </pages>
Reference-contexts: The context of this work has been the development of parallelizing compilers; it has concentrated on conflict/dependence analysis, which asks "When can two names point in a dynamic structure to the same cell?" <ref> [4, 13, 16, 17, 20, 27] </ref>.
Reference: [28] <author> Sying-Syang Liu and Abu-Bakr Taha. </author> <title> Interprocedural definition-use dependency analysis for recursive procedures. </title> <type> Technical Report SERC-TR-42-F, </type> <institution> Software Engineering Research Center, University of Florida, Gainesville, Florida, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: Many spurious side effects are generated because of this imprecision [23]. 1.2 Related Work Recent emphasis in the static analysis community has been on expanding compile-time analyses to include interprocedural information <ref> [3, 7, 8, 14, 15, 18, 28, 29, 30] </ref>. The Fortran model of interprocedural communication has been successfully analyzed [3, 7, 8, 15, 29], although some analyses have yet to demonstrate their practicality.
Reference: [29] <author> D. Lomet. </author> <title> Data flow analysis in the presence of procedure calls. </title> <journal> Journal of Research and Development, </journal> <volume> 21(6) </volume> <pages> 559-571, </pages> <month> November </month> <year> 1977. </year>
Reference-contexts: Many spurious side effects are generated because of this imprecision [23]. 1.2 Related Work Recent emphasis in the static analysis community has been on expanding compile-time analyses to include interprocedural information <ref> [3, 7, 8, 14, 15, 18, 28, 29, 30] </ref>. The Fortran model of interprocedural communication has been successfully analyzed [3, 7, 8, 15, 29], although some analyses have yet to demonstrate their practicality. <p> The Fortran model of interprocedural communication has been successfully analyzed <ref> [3, 7, 8, 15, 29] </ref>, although some analyses have yet to demonstrate their practicality. Callahan [3] and Harrold-Soffa [15] suggested factoring the aliases into the problem solution after the side effect analysis, as in previous work by Lomet [29]. <p> The Fortran model of interprocedural communication has been successfully analyzed [3, 7, 8, 15, 29], although some analyses have yet to demonstrate their practicality. Callahan [3] and Harrold-Soffa [15] suggested factoring the aliases into the problem solution after the side effect analysis, as in previous work by Lomet <ref> [29] </ref>. Lomet's approach suggested that an approximation of side effects could be obtained by analyzing the procedure under different aliasing conditions and then combining them at some loss of precision. This is similar to our approach, except we are dealing with pointer-induced aliasing.
Reference: [30] <author> E. M. Myers. </author> <title> A precise interprocedural data flow algorithm. </title> <booktitle> In Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: Many spurious side effects are generated because of this imprecision [23]. 1.2 Related Work Recent emphasis in the static analysis community has been on expanding compile-time analyses to include interprocedural information <ref> [3, 7, 8, 14, 15, 18, 28, 29, 30] </ref>. The Fortran model of interprocedural communication has been successfully analyzed [3, 7, 8, 15, 29], although some analyses have yet to demonstrate their practicality. <p> If a is a pointer variable we consider a definition of a to also be an implicit definition of fla (i.e., the object name obtained by a single level indirection from a). 2 This representation of a program is similar to those of <ref> [15, 30] </ref>, although we use it differently during analysis. 4 l : f = q h : q = f call m,B entry B call k,B entry A exit B return k,B return m,B exit A A ( ) - k : B ( ); else l : f = q; <p> In other words assuming all paths through the program are executable [2]. 5 3 Theoretical Complexity of the Problem Myers <ref> [30] </ref> showed that precise Interprocedural Reaching Definitions is NP-complete in the presence of aliasing. Landi and Ryder [23] proved the NP-hardness of the Intraprocedural Alias Problem in the presence of multiple level pointers. <p> We show that precise solution of Intraprocedural Reaching Definitions in the presence of single level pointers is NP-hard. Our proof is by reduction of the 3-SAT problem and is a variation of similar proofs in <ref> [23, 26, 30] </ref>. Theorem 1 In the presence of single level pointers, the problem of calculating precise Intraproce-dural Reaching Definitions is NP-hard.
Reference: [31] <author> A. Neirynck, P. Panangaden, and A. Demers. </author> <title> Computation of aliases and support sets. </title> <booktitle> In Conference Record of the Fourteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 274-283, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Both (i) and (ii) can occur in C programs. Most previous work in analyzing pointer-induced aliasing has been incomplete, impractical, or imprecise by design <ref> [5, 6, 9, 10, 12, 31, 42] </ref>. This would render corresponding Def-Use analysis imprecise as well. Thus, our work on Interprocedural Reaching Definitions in the presence of pointers, which builds on our work in pointer-induced aliasing, is qualitatively different from previous work.
Reference: [32] <author> T. J. Ostrand and E. Weyuker. </author> <title> Data flow based test adequecy analysis for languages with pointers. </title> <booktitle> In Proceedings of the 1991 Symposium on Software Testing, Analysis and Verification (TAV4), </booktitle> <month> October </month> <year> 1991. </year> <institution> Victoria, B.C., Canada. </institution>
Reference-contexts: Data flow information is crucial to data flow based testing systems <ref> [11, 14, 33, 32, 37] </ref>. The accuracy of the static Def-Use information determines the efficiency of the test case coverage.
Reference: [33] <author> Thomas J. </author> <title> Ostrand. Data-flow testing with pointers and function calls. </title> <booktitle> In Proceedings of the Pacific Northwest Software Quality Conference, </booktitle> <month> October </month> <year> 1990. </year>
Reference-contexts: Data flow information is crucial to data flow based testing systems <ref> [11, 14, 33, 32, 37] </ref>. The accuracy of the static Def-Use information determines the efficiency of the test case coverage. <p> We present our preliminary implementation results in Table 1. The programs in the first group were written as programming assignments for graduate courses at Rutgers University. The second group is chosen from the source code for C library functions. The third group is from the test suite for TACTIC <ref> [33] </ref>, which is currently using the Def-Use Associations information to perform data-flow based test coverage of C programs. The timings for Alias and Reaching Definitions calculation on these programs are promising. Additional experiments are needed to confirm that our techniques remain practical for larger programs.
Reference: [34] <author> K. J. Ottenstein and L. M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <month> May </month> <year> 1984. </year>
Reference-contexts: If we obtain a safe approximation to Def-Use Associations solution, then only the latter situation can occur. Debuggers based on static and dynamic slicing methods <ref> [1, 19, 21, 34, 41, 43] </ref> offer the promise of efficient on-line analyses of programs.
Reference: [35] <author> H. D. Pande. </author> <title> Static Analysis in the Presence of Pointers. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <year> 1993. </year> <note> in preparation. </note>
Reference-contexts: Since C has only pass-by-value, we present only that, but we can handle pass-by-reference by a transformation <ref> [35] </ref>. The introduction of pointers results in aliases at various program points. Our analysis must account for the generation and killing of reaching definitions due to aliasing effects. We also need to model the aliasing effects of pointer parameter bindings for each call site. <p> To obtain a lower bound on the empirical precision of our Reaching Definitions solution we use methods similar to those in [25]. We can show that there is only one source of approximation in our algorithm <ref> [35] </ref> which is illustrated by the following scenario.
Reference: [36] <author> Michael Platoff, Michael Wagner, and Joseph Camaratta. </author> <title> An integrated program representation and toolkit for the maintenanc e of C programs. </title> <booktitle> In Proceedings of the Conference on Software Maintenance. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> October </month> <year> 1991. </year>
Reference-contexts: We have constructed a prototype implementation of our algorithm to observe its performance on C programs. We do not use must-hold information as there are still theoretical difficulties that must be surmounted before must-hold can be practically implemented. We are using the PTT system from Siemens <ref> [36] </ref> for our C parser. We have aimed to eliminate the effect of purely hypothetical assumptions, such as &lt;m : a&gt; at entry R in Figure 5, and to calculate the reaches solution in time proportional to the number of true reaches predicates.
Reference: [37] <author> S. Rapps and E. Weyuker. </author> <title> Selecting software test data using data flow information. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(4):367-375, </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: Data flow information is crucial to data flow based testing systems <ref> [11, 14, 33, 32, 37] </ref>. The accuracy of the static Def-Use information determines the efficiency of the test case coverage.
Reference: [38] <author> B. G. Ryder. </author> <title> Ismm: Incremental software maintenance manager. </title> <booktitle> In Proceedings of the IEEE Computer Society Conference on Software Maintenance, </booktitle> <pages> pages 142-164, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: In this domain also, the precision of the data flow information greatly impacts the comparison of the program semantics before and after changes; imprecise information may lead to incorrect conclusions of semantic differences. Software maintenance aids that compute and report the semantic change impact of evolving software systems <ref> [38, 39, 40] </ref>, similarly rely on the accuracy of their static analyses to provide reasonably precise side effect information. Our previous work in providing efficient incremental semantic change impact analysis of C programs using interprocedural data flow analysis, has been hampered by the lack of precision in the alias analyses.
Reference: [39] <author> B. G. Ryder and M. D. Carroll. </author> <title> An incremental algorithm for software analysis. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 171-179, </pages> <month> December </month> <year> 1986. </year>
Reference-contexts: In this domain also, the precision of the data flow information greatly impacts the comparison of the program semantics before and after changes; imprecise information may lead to incorrect conclusions of semantic differences. Software maintenance aids that compute and report the semantic change impact of evolving software systems <ref> [38, 39, 40] </ref>, similarly rely on the accuracy of their static analyses to provide reasonably precise side effect information. Our previous work in providing efficient incremental semantic change impact analysis of C programs using interprocedural data flow analysis, has been hampered by the lack of precision in the alias analyses.
Reference: [40] <author> B. G. Ryder, W. Landi, and H. Pande. </author> <title> Profiling an incremental data flow analysis algorithm. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(2) </volume> <pages> 129-140, </pages> <month> February </month> <year> 1990. </year>
Reference-contexts: In this domain also, the precision of the data flow information greatly impacts the comparison of the program semantics before and after changes; imprecise information may lead to incorrect conclusions of semantic differences. Software maintenance aids that compute and report the semantic change impact of evolving software systems <ref> [38, 39, 40] </ref>, similarly rely on the accuracy of their static analyses to provide reasonably precise side effect information. Our previous work in providing efficient incremental semantic change impact analysis of C programs using interprocedural data flow analysis, has been hampered by the lack of precision in the alias analyses.
Reference: [41] <author> G. A. Venkatesh. </author> <title> The semantic approach to program slicing. </title> <booktitle> In Proceedings of the SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 107-119, </pages> <month> June </month> <year> 1991. </year> <month> 21 </month>
Reference-contexts: If we obtain a safe approximation to Def-Use Associations solution, then only the latter situation can occur. Debuggers based on static and dynamic slicing methods <ref> [1, 19, 21, 34, 41, 43] </ref> offer the promise of efficient on-line analyses of programs.
Reference: [42] <author> W. E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label vari-ables. </title> <booktitle> In Conference Record of the Seventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: Both (i) and (ii) can occur in C programs. Most previous work in analyzing pointer-induced aliasing has been incomplete, impractical, or imprecise by design <ref> [5, 6, 9, 10, 12, 31, 42] </ref>. This would render corresponding Def-Use analysis imprecise as well. Thus, our work on Interprocedural Reaching Definitions in the presence of pointers, which builds on our work in pointer-induced aliasing, is qualitatively different from previous work.
Reference: [43] <author> Mark Weiser. </author> <title> Program slicing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-10(4):352-357, </volume> <month> July </month> <year> 1984. </year>
Reference-contexts: If we obtain a safe approximation to Def-Use Associations solution, then only the latter situation can occur. Debuggers based on static and dynamic slicing methods <ref> [1, 19, 21, 34, 41, 43] </ref> offer the promise of efficient on-line analyses of programs.
Reference: [44] <author> W. Yang, S. Horwitz, and T. Reps. </author> <title> A program integration algorithm that accomodates semantics preserving transformations. </title> <booktitle> In Proceedings of the Fourth ACM SIGSOFT Symposium on Software Development Environments, </booktitle> <pages> pages 133-143, </pages> <month> December </month> <year> 1990. </year> <note> also available as SIGSOFT Notes, vol 15, no 6, </note> <month> December </month> <year> 1990. </year> <month> 22 </month>
Reference-contexts: The aim of slicing is to concentrate the programmer's attention on those parts of the program significant to the computation under current investigation; the more imprecise the static information, the less effectively the slicing method can prune away unrelated computations. Experimental techniques for merging independently altered versions of programs <ref> [18, 44] </ref> are of great interest to the programming-in-the-large community. In this domain also, the precision of the data flow information greatly impacts the comparison of the program semantics before and after changes; imprecise information may lead to incorrect conclusions of semantic differences.
References-found: 44

