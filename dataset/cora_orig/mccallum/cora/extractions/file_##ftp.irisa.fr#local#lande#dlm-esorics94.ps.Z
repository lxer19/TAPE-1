URL: file://ftp.irisa.fr/local/lande/dlm-esorics94.ps.Z
Refering-URL: http://www.irisa.fr/lande/LeMetayer.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: e-mail: jpbanatre/bryce/lemetayer@irisa.fr  
Title: Compile-time detection of information flow in sequential programs  
Author: Jean-Pierre Ban^atre Ciaran Bryce Daniel Le Metayer 
Keyword: formal verification, program analysis, verification tools, computer security, information flow.  
Address: 35042 Rennes Cedex, France  
Affiliation: IRISA Campus de Beaulieu  
Abstract: We give a formal definition of the notion of information flow for a simple guarded command language. We propose an axiomatisation of security properties based on this notion of information flow and we prove its soundness with respect to the operational semantics of the language. We then identify the sources of non determinism in proofs and we derive in successive steps an inference algorithm which is both sound and complete with respect to the inference system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abramsky (S.) and Hankin (C. L.), </author> <title> "Abstract interpretation of declarative languages", </title> <publisher> Ellis Horwood, </publisher> <year> 1987. </year>
Reference-contexts: g F fP g fl [C 1 ! S 1 2C 2 ! S 2 2::::::2C n ! S n ]f i Q i g with: R y = z6=y f (x 62 z) j R ) (x 62 z)g i f (y i 62 y) j 8 j 2 <ref> [1; . . .; n] </ref>: R ) (y i 62 x j ) and F V The intuition behind the new rule for the assignment command is that T y (R) represents the conjunction of all the properties x 62 z derivable from the input property R. <p> We compute this property using an iterative technique akin to the method used for finding least fixed points in abstract interpretation <ref> [1] </ref>. Figure 6 presents SS 4 which is a refinement of SS 3 with an effective rule for the repetitive statement. The following properties show that SS 4 is the expression, in the form of an inference system, of a terminating, correct and complete algorithm. <p> i Q n1 T 5 (P 0 ; fl [C 1 ! S 1 2C 2 ! S 2 2::::::2C n ! S n ]) = P n with: R y = f (z; x) 2 R j z 6= yg f (y; y i ) j 8 j 2 <ref> [1; . . .; n] </ref>: (x j ; y i ) 2 R and 8 v 2 IF p : (v; y i ) 2 Rg 9 5 Inference as transformations on graphs A conjunctive property P can alternatively be represented as a set of pairs of variables: f (y; x)
Reference: [2] <author> Aho (A. V.), Sethi (R.) and Ullman (J. D.), </author> <booktitle> "Compilers: Principles, Techniques and Tools", </booktitle> <publisher> Addison Wesley, </publisher> <address> Reading, Mass, </address> <year> 1986. </year>
Reference-contexts: The proof checking method is akin to the program analysis techniques used in modern optimising compilers <ref> [2] </ref>. Such a tool must satisfy two crucial properties in order to be useful for checking security properties: * Its correctness must be established. * It must be reasonably efficient. These goals are achieved in several stages.
Reference: [3] <author> Andrews (G.R.), Reitman (R.P.), </author> <title> "An Axiomatic Approach to Information Flow in Programs", </title> <journal> in ACM Transactions on Programming Languages and Systems, </journal> <volume> volume 2 (1), </volume> <month> January </month> <year> 1980, </year> <pages> pages 504-513. </pages>
Reference-contexts: As a consequence the graph can still be built incrementally avoiding the need for an iterative process. 7 Related work Language based information flow control mechanisms have traditionally used security levels <ref> [8, 3] </ref>. Each variable is assigned a level denoting the sensitivity of the information it contains. After an operation, the level of the variable which received the information flow must be no less than the level of the flow source variables. <p> To our knowledge there have been surprisingly few attempts to achieve these goals so far. Most of the approaches described in the literature either lead to manual verification techniques <ref> [3] </ref> or rely on informal correctness proofs [9]. The closest work in the spirit of the contribution presented here is [19]. They derive a flow control algorithm as an abstract interpretation of the denotational semantics of the programming language.
Reference: [4] <author> Ban^atre (J.-P.) and C. Bryce, (C.), </author> <title> "A security proof system for networks of communicating processes", </title> <journal> Irisa research report, </journal> <volume> no 744, </volume> <month> June </month> <year> 1993. </year>
Reference-contexts: In contrast with this approach, we do not require security classes to be associated with variables but we check that the value of one particular variable cannot flow into another variable. We have shown in <ref> [4] </ref> that this approach provides more flexibility in the choice of a particular security policy. Our algorithm could in fact be applied to synthesise the weakest constraints on the security classes of the variables of an unannotated program.
Reference: [5] <author> Ban^atre (J.-P.) and C. Bryce, (C.), and Le Metayer (D.), </author> <title> "Mechanical proof of security properties", </title> <journal> Irisa research report, </journal> <volume> no 825, </volume> <month> May </month> <year> 1994. </year> <month> 16 </month>
Reference-contexts: Section 6 provides insights on the extension to more realistic language features including parallelism and pointer manipulation and section 7 reviews related work. Space considerations prevent us from providing details about the proofs here. The interested reader can find a complete treatment in <ref> [5] </ref>. 2 An inference system for security properties We consider a simple guarded command language whose syntax is defined as follows: Program ::= Decl ; Decl ; Stmt program Decl ::= var v declarations Stmt ::= (p, Comm) statements Comm ::= v := E j t [i] := E j skip <p> The correctness of SS 1 can be proven by induction on the structure of terms as a consequence of a more general property <ref> [5] </ref>. Let us now consider, as an example, a library decryption program. The program has three inputs and two outputs. The input consists of a string of encrypted text, or cipher, a key for decryption and a unit rate which the user is charged for each character decrypted. <p> ` 2 fP g S fQg Proposition 3.3 (completeness of SS 3 ) 8S; P; Q: if ` 2 fP g S fQg then 9Q 0 : ` 3 fP g S fQ 0 g Q 0 ) Q Both properties are proved by induction on the structure of commands <ref> [5] </ref>. 4 Mechanical analysis of the repetitive command In order to be able to treat the repetitive statement mechanically we must be able to compute a property P 0 such that P ) P 0 8i = 1::nfP 0 gS i fQ i g and i Furthermore it must be the <p> 3 fP g S fQg Proposition 4.3 (completeness of SS 4 ) 8S; P; Q: if ` 3 fP g S fQg then 9Q 0 : ` 4 fP g S fQ 0 g Q 0 ) Q The three properties are proven by induction on the structure of commands <ref> [5] </ref>. 8 fRg y := exp (x 1 ; x 2 ; :::::; x n ) fT y (R)g fP gskipfP g fP gS1fQg; fQgS2fRg fP gS1; S2fRg fP g [C 1 ! S 1 2C 2 ! S 2 2::::::2C n ! S n ]f i Q i g i <p> v q )g + f (v q ; v p )g 11 Proposition 5.2 (Correctness of T 6 ) 8S; P; Q; G; p; q: H (p; G) = P and T 5 (P; S) = Q ) This property can be proved by induction on the structure of expressions <ref> [5] </ref>. It should be clear that some straightforward optimisations can be applied to this algorithm. First it is not necessary to keep one occurrence of variable per program point in the graph.
Reference: [6] <author> Cohen (E.), </author> <title> "Information Transmission in Computational Systems", </title> <booktitle> in Proceedings ACM Symposium on Operating System Principles, </booktitle> <year> 1977, </year> <pages> pages 133-139. </pages>
Reference-contexts: This is because the information in each of the right hand side operands can influence value of the left hand side variable <ref> [6] </ref>.
Reference: [7] <author> Cytron (R.), Ferrante (J.), Rosen (B. K.) and Wegman (M. N.), </author> <title> "Efficiently computing Static Single Assignment form and the control dependence graph", </title> <journal> in ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No 4, </volume> <month> October </month> <year> 1991, </year> <pages> pages 451-490. </pages>
Reference-contexts: It may however make the analyser more expensive (the same situation occurs in traditional data flow analysis). For instance we can deal with explicit goto commands by adding new assignments at the join nodes of the control flow graph (very much like the -functions in SSA forms <ref> [7] </ref>). Such assignments are already implicit in the rules for the alternative and repetitive commands (see Figure 8 for instance). 14 The need for ensuring security properties becomes especially crucial in the context of dis-tributed systems.
Reference: [8] <author> Denning (D.E.), </author> <title> Secure Information Flow in Computer Systems, </title> <type> Phd Thesis, </type> <institution> Purdue University, </institution> <month> May </month> <year> 1975. </year>
Reference-contexts: ! S 2 2::::::2C n ! S n ]; &gt; ! abort 8i: &lt; C i ; &gt; ! f alse &lt; fl [C 1 ! S 1 2C 2 ! S 2 2::::::2C n ! S n ]; &gt; ! 3 Conditional commands introduce a new class of flows <ref> [8] </ref>. The fact that a command is conditionally executed signals information to an observer concerning the value of the command guard. <p> This is an example of an implicit flow <ref> [8] </ref> or what we more generally refer to as an indirect flow. We note IF p the set of indirect information flow variables at a particular program point p. IF p can be defined syntactically as the set of variables occurring in embedding guards. <p> As a consequence the graph can still be built incrementally avoiding the need for an iterative process. 7 Related work Language based information flow control mechanisms have traditionally used security levels <ref> [8, 3] </ref>. Each variable is assigned a level denoting the sensitivity of the information it contains. After an operation, the level of the variable which received the information flow must be no less than the level of the flow source variables.
Reference: [9] <author> Denning (D.E.), Denning (P.J.), </author> <title> "Certification of Programs for Secure Information Flow", </title> <journal> in Communications of the ACM, </journal> <volume> volume 20 (7), </volume> <month> July </month> <year> 1977, </year> <pages> pages 504-513. </pages>
Reference-contexts: To our knowledge there have been surprisingly few attempts to achieve these goals so far. Most of the approaches described in the literature either lead to manual verification techniques [3] or rely on informal correctness proofs <ref> [9] </ref>. The closest work in the spirit of the contribution presented here is [19]. They derive a flow control algorithm as an abstract interpretation of the denotational semantics of the programming language. The programmer associates each variable with a security class (such as unclassified, classified, secret, . . . ).
Reference: [10] <author> Hankin (C. L.) and Le Metayer (D.), </author> <title> "Deriving Algorithms from Type Inference Systems: Application to Strictness Analysis", </title> <booktitle> in Proceedings ACM POPL, </booktitle> <year> 1994, </year> <pages> pages 202-212. </pages>
Reference-contexts: The techniques used to transform the original proof system into an algorithmic version are akin to methods used to get a syntax-directed version of type inference systems including weakening rules <ref> [10] </ref>. 1 The rest of the paper is organised in the following way. Section 2 introduces our guarded command language with its operational semantics and our definition of information flow.
Reference: [11] <author> Hoare (C.A.R.), </author> <title> Communicating Sequential Processes, </title> <publisher> Prentice-Hall London, </publisher> <year> 1985. </year>
Reference-contexts: We are currently studying the generalisation of our work for a full version of CSP <ref> [11] </ref>. In CSP, communication commands may occur in guards and in statements. The notion of indirect flow has to be extended to take such communications into account.
Reference: [12] <author> Jones (A.), Lipton (R.), </author> <title> "The Enforcement of Security Policies for Computations", </title> <booktitle> in Proceedings of the 5 th Symposium on Operating System Principles, </booktitle> <month> November </month> <year> 1975, </year> <pages> pages 197-206. </pages>
Reference-contexts: However, the security level approach severely 15 restricts the range of policies that one might like to support. A flow mechanism should log the variables that have flown to each variable rather than the level of the data. Jones and Lipton's surveillance set mechanism <ref> [12] </ref> is in this spirit and has some similarities with the mechanism proposed here. In [18], McLean describes a unified framework for showing that a software module specification is non-interfering and that the module code satisfies this specification.
Reference: [13] <author> Kennedy K. W., </author> <title> "A Survey of Data Flow Analysis Techniques", in Program Flow Analysis, </title> <editor> S. S. Muchnik and N. D. Jones, Eds, </editor> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference: [14] <author> Lampson (B.), </author> <title> "A note on the Confinement Problem", </title> <journal> in Communications of the ACM, </journal> <volume> volume 16 (10), </volume> <month> October </month> <year> 1973, </year> <pages> pages 613-615. </pages>
Reference-contexts: To be usable, the user must trust the program not to secretly leak the clear text or the key to the library owner via the charges output. Such a leakage is termed a covert channel in <ref> [14] </ref>. The proof system described in Figure 1 allows us to prove the following property: ` 1 fInitg Library f (clear 62 charge) and (key 62 charge)g that is, the charge output may not receive a flow of information from the clear variable or from the key input.
Reference: [15] <author> Landi (W.) and Ryder (B. G.), </author> <title> "Pointer-induced aliasing: a problem classification", </title> <booktitle> in Proceedings ACM POPL, </booktitle> <year> 1991, </year> <pages> pages 93-103. </pages>
Reference-contexts: We consider them in turn. The addition of general pointers in a language complicates most program analyses because it introduces the well-known problem of aliasing. Aliasing occurs during program execution when two or more names exist for the same location <ref> [15] </ref>. Let us take a small example in the context of information flow to illustrate the problem. int i; j; k; flp i := j; The variable p is assigned the location of i. As a consequence, an information flow from i to p must be accounted for. <p> As far as the proof checking algorithm is concerned, the first solution is to complement the method presented in this paper with a pointer aliasing analysis. Various techniques have been proposed in the literature to tackle this problem <ref> [15, 16] </ref>. These techniques are more or less accurate (and expensive) depending on the level of indirection which is considered.
Reference: [16] <author> Landi (W.) and Ryder (B. G.), </author> <title> "A safe approximate algorithm for interprocedural pointer aliasing", </title> <booktitle> in Proceedings ACM Programming Language Design and Implementation, </booktitle> <year> 1992, </year> <pages> pages 235-248. </pages>
Reference-contexts: As far as the proof checking algorithm is concerned, the first solution is to complement the method presented in this paper with a pointer aliasing analysis. Various techniques have been proposed in the literature to tackle this problem <ref> [15, 16] </ref>. These techniques are more or less accurate (and expensive) depending on the level of indirection which is considered. <p> A more ambitious research direction would be to integrate both analysers into a single, more efficient, algorithm. A possible solution is to consider object names rather than simple variables in the information flow analysis. Following <ref> [16] </ref>, object names can be defined as follows: object name = variable j fl:object name j object name:field of structure The introduction of less structured sequential control flow does not introduce deep technical problems into our analysis.
Reference: [17] <author> McLean (J.), </author> <title> "A Formal Method for the Abstract Specification of Software", </title> <journal> in Journal of the ACM, </journal> <volume> 31, </volume> <month> July </month> <year> 1984, </year> <pages> pages 600-627. </pages>
Reference-contexts: Non-interference is a security property which states that a user's output cannot be affected by the input of any user with a higher security level. McLean's approach is based on the trace method for software module specification <ref> [17] </ref>. This method defines a module's semantics as the set of legal module traces (sequences of module procedure calls), the values returned by the traces terminating in a function call and a trace equivalence. Non-interference can be proved from the module's trace semantics.
Reference: [18] <author> McLean (J.), </author> <title> "Proving Non-interference and Functional Correctness Using Traces", </title> <journal> in Journal of Computer Security, </journal> <volume> 1(1), </volume> <month> Spring </month> <year> 1992, </year> <pages> pages 37-57. </pages>
Reference-contexts: A flow mechanism should log the variables that have flown to each variable rather than the level of the data. Jones and Lipton's surveillance set mechanism [12] is in this spirit and has some similarities with the mechanism proposed here. In <ref> [18] </ref>, McLean describes a unified framework for showing that a software module specification is non-interfering and that the module code satisfies this specification. Non-interference is a security property which states that a user's output cannot be affected by the input of any user with a higher security level.
Reference: [19] <author> Mizuno (M.), Schmidt (D.), </author> <title> "A Security Control Flow Control Algorithm and Its Deno-tational Semantics Correctness Proof", </title> <journal> Journal on the Formal Aspects of Computing, </journal> <volume> 4 (6A), </volume> <month> november </month> <year> 1992, </year> <pages> pages 722-754. 17 </pages>
Reference-contexts: To our knowledge there have been surprisingly few attempts to achieve these goals so far. Most of the approaches described in the literature either lead to manual verification techniques [3] or rely on informal correctness proofs [9]. The closest work in the spirit of the contribution presented here is <ref> [19] </ref>. They derive a flow control algorithm as an abstract interpretation of the denotational semantics of the programming language. The programmer associates each variable with a security class (such as unclassified, classified, secret, . . . ).
References-found: 19

