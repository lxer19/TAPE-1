URL: ftp://ftp.cs.utah.edu/pub/banavar/mod_scheme.ps.Z
Refering-URL: http://www.cs.utah.edu/~gary/MSO-publications.html
Root-URL: 
Title: Object-Oriented Programming in Scheme with First-Class Modules and Operator-Based Inheritance  
Author: Guruduth Banavar Gary Lindstrom 
Keyword: Paper Category: Research. Topic Area: Language design and implementation.  
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah,  
Abstract: We characterize object-oriented programming as structuring and manipulating a uniform space of first-class values representing modules, a distillation of the notion of classes. Operators over modules individually achieve effects such as encapsulation, sharing, and static binding. A variety of idioms of O-O programming find convenient expression within this model, including several forms of single and multiple inheritance, abstract classes, class variables, inheritance hierarchy combination, and reflection. We show that this programming style simplifies O-O programming via enhanced uniformity, and supports a flexible model of object-orientation that provides an attractive alternative to meta-programming. Finally, we show that these notions of O-O programming are language independent, by implementing a Modular Scheme prototype as a completion of a generic O-O framework for modularity. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Reference manual for the Ada programming language. ANSI/MIL-STD-1815 A, </institution> <year> 1983. </year>
Reference-contexts: Modular programming has traditionally dealt with issues of structuring, encapsulation, and independent development of software. Known by various names such as packages, structures, etc., modules have long played the role of static design artifacts <ref> [22, 1] </ref>. However, it has not yet been widely recognized that O-O programming is but a sophisticated form of modular programming. The power of first-class modules as given here is even less recognized. In the context of Scheme, several module systems have been developed [12, 28].
Reference: [2] <author> Guruduth Banavar, Gary Lindstrom, and Douglas Orr. Etyma: </author> <title> A framework for modular systems. </title> <type> CS Dept. TR UUCS-94-035, </type> <institution> University of Utah, </institution> <month> December </month> <year> 1994. </year> <title> Short version persented at the workshop on O-O Compilation at OOPSLA '94, </title> <address> Portland, OR. </address>
Reference-contexts: The language described here has been realized as one completion of Etyma. Among the other completions of Etyma are a linker and a compiler for an interface definition language, described in <ref> [2] </ref>. This section describes the O-O design and implementation of the modular extension to a basic Scheme interpreter. The overall architecture of the implementation is shown in Figure 13. The interpreter for Modular Scheme is implemented as an extension of the Scheme interpreter provided in the STk [14] package.
Reference: [3] <author> Gilad Bracha. </author> <title> The Programming Language Jigsaw: Mixins, Modularity and Multiple Inheritance. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> March </month> <year> 1992. </year> <note> Technical report UUCS-92-007; 143 pp. </note>
Reference-contexts: Such abstractions have been characterized as functions from classes to classes [4]. However, the approach of operator-based inheritance given here uniformly treats all aspects of inheritance as operations over modules, as was first developed in <ref> [3] </ref>.
Reference: [4] <author> Gilad Bracha and William Cook. </author> <title> Mixin-based inheritance. </title> <booktitle> In Proc. OOPSLA Conference, </booktitle> <address> Ottawa, </address> <month> October </month> <year> 1990. </year> <note> ACM. </note>
Reference-contexts: Abstract modules such as these are sometimes called "mixins" | reusable abstractions that require other abstractions in order to be usefully applied. Such abstractions have been characterized as functions from classes to classes <ref> [4] </ref>. However, the approach of operator-based inheritance given here uniformly treats all aspects of inheritance as operations over modules, as was first developed in [3].
Reference: [5] <author> Gilad Bracha and Gary Lindstrom. </author> <title> Modularity meets inheritance. </title> <booktitle> In Proc. International Conference on Computer Languages, </booktitle> <pages> pages 282-290, </pages> <address> San Francisco, CA, </address> <month> April 20-23, </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal> <note> Also available as Technical Report UUCS-91-017. </note>
Reference-contexts: Classes were modeled as record generators by Cook [11], who also first introduced some of the operators used here. Based on this, Bracha and Lindstrom in <ref> [5] </ref> developed a comprehensive suite of operators to support sharing, encapsulation, and static binding.
Reference: [6] <author> P. Canning, W. Cook, W. Hill, and W. Olthoff. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> Proceedings of the ACM Conference on Object-Oriented Programming, Systems, Languages, and Applications, </booktitle> <pages> pages 457-467, </pages> <year> 1989. </year>
Reference-contexts: The module from which an instance was created can be obtained with the primitive module-of. Thus, (module-of (self)) is similar to self class in Smalltalk, like current in Eiffel [24], and myclass 8 in <ref> [6] </ref>. The names of the publicly accessible attributes of a module are accessible via the attrs--of primitives. For example, the mutable attributes of a module can be encapsulated with the expression in box (b) of Figure 4.
Reference: [7] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <type> Modula-3 report. Technical Report 31, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> August </month> <year> 1988. </year>
Reference-contexts: Many single inheritance systems such as Smalltalk-80 and Modula-3 (object types, modulo static typing) <ref> [7] </ref> share the notion of a class consisting of methods and encapsulated instance variables. In these systems, it is possible to specify a class declaration similar to that shown in box (a) of Figure 3. The define-class construct will be explained below.
Reference: [8] <author> Luca Cardelli and John C. Mitchell. </author> <title> Operations on records. </title> <type> Technical Report 48, </type> <institution> Digital Equipment Corporation Systems Research Center, </institution> <month> August </month> <year> 1989. </year>
Reference-contexts: The percentages for class and method reuse give an indication of design reuse, whereas those for lines of code give a measure of code reuse. 7 Related Work The design of Modular Scheme is based upon a semantic notion of modules that goes back to record calculi <ref> [16, 8] </ref>. Classes were modeled as record generators by Cook [11], who also first introduced some of the operators used here. Based on this, Bracha and Lindstrom in [5] developed a comprehensive suite of operators to support sharing, encapsulation, and static binding.
Reference: [9] <author> Shigeru Chiba and Takashi Masuda. </author> <title> Designing an extensible distributed language with a meta-level architecture. </title> <booktitle> In Proceedings of the 7th European Conference on Object-Oriented Programming. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1993. </year> <note> LNCS 707. </note>
Reference-contexts: CLOS also supports a protocol to interact with its meta-architecture. Dexterity of multiple inheritance as given in Section 4.1 was a primary practical motivation for the CLOS MOP. 21 Systems such as the CLOS meta-object protocol (MOP) [19] and Open C++ <ref> [9] </ref> expose the implementation objects of the language processor to the programmer via a controlled protocol. Many aspects of the language's implementation, such as object data layout, are controllable via such a meta-protocol.
Reference: [10] <author> William Clinger and Jonathan Rees. </author> <title> Revised 4 report on the algorithmic language scheme. </title> <journal> ACM Lisp Pointers, </journal> <volume> 4(3), </volume> <year> 1991. </year>
Reference-contexts: Encapsulation, sharing, and static binding are achieved via individual operators over classes. This point of view gives rise to an expressive programming style that models most existing idioms of O-O programming while providing the flexibility to express many others. We illustrate this programming style with the programming language Scheme <ref> [10] </ref>, extended with an abstraction mechanism called modules. Hence, we call our language Modular Scheme. We believe that the present day notion of object-orientation is really the most advanced stage of an evolution towards modularity in programming languages. <p> while keeping with its original design philosophy that "... a very small number of rules for forming expressions, with no restrictions on how they are composed, suffice to form a practical and efficient programming language that is flexible enough to support most of the major programming paradigms in use today." <ref> [10] </ref> The above language is expressive and flexible enough to model most previously existing techniques of O-O programming, without recourse to meta-programming.
Reference: [11] <author> William Cook and Jen Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <booktitle> In Proc. ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications, </booktitle> <pages> pages 433-444, </pages> <year> 1989. </year>
Reference-contexts: Module interconnection is established by actually combining modules, with interconnection validation at combination time. Individual instances of modules represent concrete environments such as those in traditional systems. Specifically, modules abstract over the notion of what "self" means until they are instantiated <ref> [11] </ref>. This enables a remarkable degree of flexibility in their manipulation. In Modular Scheme, a module consists of a list of attributes with no order significance. Attributes are of two kinds. Mutable attributes are similar to Scheme variables, and can store any Scheme value. <p> Classes were modeled as record generators by Cook <ref> [11] </ref>, who also first introduced some of the operators used here. Based on this, Bracha and Lindstrom in [5] developed a comprehensive suite of operators to support sharing, encapsulation, and static binding.
Reference: [12] <author> Pavel Curtis and James Rauen. </author> <title> A module system for scheme. </title> <booktitle> In Conference Record of the ACM Lisp and Functional Programming. ACM, </booktitle> <year> 1990. </year>
Reference-contexts: We then relate our work with other research, and present conclusions. 2 Modules and Instances We introduce our model of modules by relating it to module systems for Scheme such as those given in <ref> [12, 28] </ref>. In these systems, a module is essentially an environment for binding names to values. A module is a name scope that explicitly provides (exports) names and requires (imports) other names. <p> However, it has not yet been widely recognized that O-O programming is but a sophisticated form of modular programming. The power of first-class modules as given here is even less recognized. In the context of Scheme, several module systems have been developed <ref> [12, 28] </ref>. These systems essentially provide the functionality described in Section 2, although [12] supports explicit interfaces. Lisp packages [27] and Scheme first-class environments are much restricted forms of modularity compared to the system presented here. Beta provides a uniform model of programming via patterns. <p> The power of first-class modules as given here is even less recognized. In the context of Scheme, several module systems have been developed [12, 28]. These systems essentially provide the functionality described in Section 2, although <ref> [12] </ref> supports explicit interfaces. Lisp packages [27] and Scheme first-class environments are much restricted forms of modularity compared to the system presented here. Beta provides a uniform model of programming via patterns. However, it does not support first-class modules or operator-based inheritance.
Reference: [13] <author> R. Ducournau, M. Habib, M. Huchard, and M. L. Mugnier. </author> <title> Proposal for a monotonic multiple inheritance linearization. </title> <booktitle> In Proceedings of OOPSLA, </booktitle> <pages> pages pages 164 - 175, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: It has been argued that currently used linearizations do not ensure that "the inheritance mechanism behaves "naturally" relative to the incremental design of the inheritance hierarchy" <ref> [13] </ref>. Perhaps it is better to let the programmer select the precedence order of superclasses as dictated by individual applications. In the case of CLOS, a programmer with considerable expertise can use the meta-object protocol of the language and adapt the default rule.
Reference: [14] <author> Erick Gallesio. </author> <note> STk reference manual. Version 2.1, 1993/94. 23 </note>
Reference-contexts: This section describes the O-O design and implementation of the modular extension to a basic Scheme interpreter. The overall architecture of the implementation is shown in Figure 13. The interpreter for Modular Scheme is implemented as an extension of the Scheme interpreter provided in the STk <ref> [14] </ref> package. The basic Scheme interpreter is implemented in C. The code for the extension is designed as a set of C++ classes that inherit from classes in Etyma.
Reference: [15] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison--Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Classes, on the other hand, are usually not first-class values, and inheritance is often considered an operational and static structuring activity. Some dynamic languages like CLOS [18] and Smalltalk <ref> [15] </ref> permit access to classes at run-time, usually as objects of other (meta-)classes. However, even in dynamic O-O languages, there is often a disparity between the manner in which classes and other values are manipulated.
Reference: [16] <author> Robert Harper and Benjamin Pierce. </author> <title> A record calculus based on symmetric concatenation. </title> <booktitle> In Proc. of the ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 131-142, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: The percentages for class and method reuse give an indication of design reuse, whereas those for lines of code give a measure of code reuse. 7 Related Work The design of Modular Scheme is based upon a semantic notion of modules that goes back to record calculi <ref> [16, 8] </ref>. Classes were modeled as record generators by Cook [11], who also first introduced some of the operators used here. Based on this, Bracha and Lindstrom in [5] developed a comprehensive suite of operators to support sharing, encapsulation, and static binding.
Reference: [17] <author> Ralph E. Johnson and Vincent F. Russo. </author> <title> Reusing object-oriented designs. </title> <type> Technical Report UIUCDCS 91-1696, </type> <institution> University of Illinois at Urbana-Champagne, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: In fact, an object-oriented framework <ref> [17] </ref> called Etyma incorporating these generic notions has been designed and implemented in C++. The language described here has been realized as one completion of Etyma. Among the other completions of Etyma are a linker and a compiler for an interface definition language, described in [2].
Reference: [18] <author> Sonya E. Keene. </author> <title> Object-Oriented Programming in Common Lisp. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: Instances are typically "first-class" values in the language, i.e. they can be created, stored, accessed, and passed into and out of functions. Classes, on the other hand, are usually not first-class values, and inheritance is often considered an operational and static structuring activity. Some dynamic languages like CLOS <ref> [18] </ref> and Smalltalk [15] permit access to classes at run-time, usually as objects of other (meta-)classes. However, even in dynamic O-O languages, there is often a disparity between the manner in which classes and other values are manipulated. <p> There is also some similarity between manager modules and the concept of "object managers" given in the language Paragon [26], a language for programming with abstract data types. A popular language family for O-O programming with Lisp is the CLOS family of languages <ref> [18, 20] </ref>. CLOS supports a quite different model of O-O programming than the one described here, with multiple-dispatch, generic functions, and weak encapsulation. Modular Scheme, on the other hand, supports only single dispatch. CLOS also supports a protocol to interact with its meta-architecture.
Reference: [19] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> The MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: Modular Scheme, on the other hand, supports only single dispatch. CLOS also supports a protocol to interact with its meta-architecture. Dexterity of multiple inheritance as given in Section 4.1 was a primary practical motivation for the CLOS MOP. 21 Systems such as the CLOS meta-object protocol (MOP) <ref> [19] </ref> and Open C++ [9] expose the implementation objects of the language processor to the programmer via a controlled protocol. Many aspects of the language's implementation, such as object data layout, are controllable via such a meta-protocol.
Reference: [20] <author> Gregor Kiczales and Luis Rodriguez. </author> <title> Efficient method dispatch in PCL. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 99-105. </pages> <publisher> ACM, </publisher> <year> 1990. </year>
Reference-contexts: There is also some similarity between manager modules and the concept of "object managers" given in the language Paragon [26], a language for programming with abstract data types. A popular language family for O-O programming with Lisp is the CLOS family of languages <ref> [18, 20] </ref>. CLOS supports a quite different model of O-O programming than the one described here, with multiple-dispatch, generic functions, and weak encapsulation. Modular Scheme, on the other hand, supports only single dispatch. CLOS also supports a protocol to interact with its meta-architecture.
Reference: [21] <author> Bent Bruun Kristensen, Ole Lehrmann Madsen, Birger Moller-Pedersen, and Kristen Nygaard. </author> <title> The BETA programming language. </title> <booktitle> In Research Directions in Object-Oriented Programming, </booktitle> <pages> pages pages 7 - 48. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference-contexts: Destructive module primitives are to be used with caution, and used only for optimizing stable programs. 3.4 Prefixing The programming language Beta <ref> [21] </ref> supports a form of single inheritance called prefixing which is quite different from the single inheritance presented in Section 3. In prefixing, a superclass method that expects to be re-bound by a subclass definition uses a construct called inner somewhere in its body.
Reference: [22] <author> David MacQueen. </author> <title> Modules for Standard ML. </title> <type> LFCS report, </type> <institution> Dept. of Computer Science, Univ. of Edinburgh, </institution> <address> Scotland, </address> <year> 1986. </year> <title> Part III of Standard ML, by Robert Harper, David MacQueen and Robin Milner. </title>
Reference-contexts: Modular programming has traditionally dealt with issues of structuring, encapsulation, and independent development of software. Known by various names such as packages, structures, etc., modules have long played the role of static design artifacts <ref> [22, 1] </ref>. However, it has not yet been widely recognized that O-O programming is but a sophisticated form of modular programming. The power of first-class modules as given here is even less recognized. In the context of Scheme, several module systems have been developed [12, 28].
Reference: [23] <author> Ole Lehrmann Madsen. </author> <title> Block structure and object-oriented languages. </title> <booktitle> In Research Directions in Object-Oriented Programming, </booktitle> <pages> pages pages 113 - 128. </pages> <publisher> MIT Press, </publisher> <year> 1987. </year>
Reference: [24] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: The module from which an instance was created can be obtained with the primitive module-of. Thus, (module-of (self)) is similar to self class in Smalltalk, like current in Eiffel <ref> [24] </ref>, and myclass 8 in [6]. The names of the publicly accessible attributes of a module are accessible via the attrs--of primitives. For example, the mutable attributes of a module can be encapsulated with the expression in box (b) of Figure 4.
Reference: [25] <author> Harold Ossher and William Harrison. </author> <title> Combination of inheritance hierarchies. </title> <booktitle> In OOPSLA Proceedings, </booktitle> <pages> pages 25-40, </pages> <month> October </month> <year> 1992. </year>
Reference-contexts: This can be achieved with the expression shown in box (b) of Figure 12. Several applications of this style of hierarchy combination are given in <ref> [25] </ref>. Manager modules. Reflection is a means by which programs can access and manipulate themselves. Modular Scheme supports a form of reflective programming on modules with the introspective primitives given in Section 3.2 in conjunction with what are called manager modules.
Reference: [26] <author> Mark Steven Sherman. </author> <title> Paragon: A Language Using Type Hierarchies for the Specification, Implementation and Selection of Abstract Data Types. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1985. </year>
Reference-contexts: Beta's style of prefixing is described and simulated in Section 3.4. Beta supports arbitrary nesting of modules with which meta-classes can be simulated, as with manager modules (Section 5.2). There is also some similarity between manager modules and the concept of "object managers" given in the language Paragon <ref> [26] </ref>, a language for programming with abstract data types. A popular language family for O-O programming with Lisp is the CLOS family of languages [18, 20]. CLOS supports a quite different model of O-O programming than the one described here, with multiple-dispatch, generic functions, and weak encapsulation.
Reference: [27] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Bedford, MA, </address> <year> 1984. </year>
Reference-contexts: The power of first-class modules as given here is even less recognized. In the context of Scheme, several module systems have been developed [12, 28]. These systems essentially provide the functionality described in Section 2, although [12] supports explicit interfaces. Lisp packages <ref> [27] </ref> and Scheme first-class environments are much restricted forms of modularity compared to the system presented here. Beta provides a uniform model of programming via patterns. However, it does not support first-class modules or operator-based inheritance. Beta's style of prefixing is described and simulated in Section 3.4.
Reference: [28] <author> Sho-Huan Simon Tung. </author> <title> Interactive modular programming in scheme. </title> <booktitle> In Proceedings of the ACM Lisp and Functional Programming Conference, </booktitle> <pages> pages pages 86 - 95. </pages> <publisher> ACM, </publisher> <year> 1992. </year> <title> Last modified: </title> <month> February 28, </month> <year> 1995 </year> <month> 24 </month>
Reference-contexts: We then relate our work with other research, and present conclusions. 2 Modules and Instances We introduce our model of modules by relating it to module systems for Scheme such as those given in <ref> [12, 28] </ref>. In these systems, a module is essentially an environment for binding names to values. A module is a name scope that explicitly provides (exports) names and requires (imports) other names. <p> However, it has not yet been widely recognized that O-O programming is but a sophisticated form of modular programming. The power of first-class modules as given here is even less recognized. In the context of Scheme, several module systems have been developed <ref> [12, 28] </ref>. These systems essentially provide the functionality described in Section 2, although [12] supports explicit interfaces. Lisp packages [27] and Scheme first-class environments are much restricted forms of modularity compared to the system presented here. Beta provides a uniform model of programming via patterns.
References-found: 28

