URL: ftp://ftp.research.microsoft.com/users/lomet/pub/ap-readopt.ps
Refering-URL: http://www.research.microsoft.com/db/
Root-URL: http://www.research.microsoft.com
Title: Persistent Applications Using Generalized Redo Recovery  
Author: David B. Lomet 
Address: Redmond, WA 98052  
Affiliation: Microsoft Corporation  
Abstract: We describe how to recover applications after system crashes using database recovery. Earlier efforts, based on frequent application checkpoints and/or logging values read, are very expensive. We treat application state as a cached object and log application execution as operations in the recovery framework of [15]. Logging application execution does not require logging the application state. Further, logged application reads are mostly logical operations in which only the data source identity is logged. We describe a cache manager that handles the flush order dependencies introduced by these log operations and a recovery process that restores application state by replaying the application. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Bartlett, J. </author> <title> A NonStop* Kernel. </title> <booktitle> Proc. ACM Symp. on Oper ating System Principles(1981) 22-29. </booktitle>
Reference-contexts: When all application state is in recoverable storage, each update to application state, however small, is logged to keep the state recov erable. * Write persistent application checkpoints (which capture the entire process image of the application) at every RM interaction <ref> [1] </ref>. (Paging techniques can be used to capture the changes at, perhaps, page level granularity.) All these techniques have limitations. Some require a special language. Some do not recover applications written without interactions with system state external to the application. explicit concern for recovery.
Reference: [2] <author> Bernstein, P., Hadzilacos, V., and Goodman, N. </author> <title> Concurrency Control and Recovery in Database Systems Addison Wesley (1987) Reading, </title> <address> MA </address>
Reference-contexts: Consider OP1 and OP2 of Figure 3. Inverting the installation order of these operations makes the persistent store non-recoverable. Complex log operations like these require careful write order to remain recoverable. Operations can be replayed if we install their effects in serialization (conflict) graph order <ref> [2] </ref>. However, this is overkill as we can ignore: write-read edges: The read of object x by a later operation O 2 does not interfere with the replay of an earlier operation O 1 that writes x.
Reference: [3] <author> Bernstein, P., Hsu, M., and Mann, B. </author> <title> Implementing Re coverable Requests Using Queues. </title> <booktitle> Proc. ACM SIGMOD Conf.(May, </booktitle> <address> 1990) Atlantic City, NJ 112-122 </address>
Reference-contexts: Between transactions, the application state is deterministically derivable from its initial state. A failure results in incomplete transactions being aborted and the application is re-instantiated in its inital, stably stored, state. * Keep application state small and write it entirely to a recoverable RM, e.g. database or recoverable queue <ref> [3] </ref>, as required. This is facilitated by the use of an application scripting language [4, 18]. The script language interpreter stores the entire application state at well chosen times so that application execution can continue from the saved state after a crash.
Reference: [4] <author> Bernstein, P., Gyllstrom, P. and Wimberg, T. </author> <title> STDL A Portable Language for Transaction Processing. </title> <booktitle> Proc. Very Large Databases Conf.(Sept. </booktitle> <address> 1993) Dublin 218-229. </address>
Reference-contexts: This is facilitated by the use of an application scripting language <ref> [4, 18] </ref>. The script language interpreter stores the entire application state at well chosen times so that application execution can continue from the saved state after a crash.
Reference: [5] <author> Borg, A., Baumbach, J. and Glazer, S. </author> <title> A Message System Supporting Fault Tolerance. </title> <booktitle> Proc. ACM Symp. on Operating System Principles(Oct. </booktitle> <address> 1983) Bretton Woods, NH 90-99. </address>
Reference-contexts: This reduces normal execution cost while increasing the overhead of the recovery process itself since now parts of the applications need to be re-executed during recovery. This is a good trade-off because crashes are rare. Recovery cost is controllable by log checkpoint frequency, exactly as with database recovery. Unlike <ref> [19, 5, 6] </ref>, we exploit database style recovery. We focus on applications that interact with each other mostly by reading and writing persistently stored data, e.g. data in a database or file system. We log not only application reads and writes, but also application execution sequences between these interactions.
Reference: [6] <author> Borg, A., Blau, W., Graetsch, W. </author> <title> Fault Tolerance Under UNIX ACM Trans. </title> <journal> on Computer Systems 7,1 (Feb. </journal> <volume> 1989) 1 24. </volume>
Reference-contexts: This reduces normal execution cost while increasing the overhead of the recovery process itself since now parts of the applications need to be re-executed during recovery. This is a good trade-off because crashes are rare. Recovery cost is controllable by log checkpoint frequency, exactly as with database recovery. Unlike <ref> [19, 5, 6] </ref>, we exploit database style recovery. We focus on applications that interact with each other mostly by reading and writing persistently stored data, e.g. data in a database or file system. We log not only application reads and writes, but also application execution sequences between these interactions.
Reference: [7] <author> Borr, A. </author> <title> Transaction Monitoring in Encompass *: Reliable and Distributed Transaction Processing. </title> <booktitle> Proc. Very Large Databases Conf.(Sept. </booktitle> <address> 1981) Cannes, France 155-165. </address>
Reference: [8] <author> Chang, A., and Mergen, M. </author> <title> 801 Storage: Architecture and Programming. </title> <journal> ACM Trans. on Computer Systems 6,1 (Feb. </journal> <year> 1988) </year> <month> 28-50. </month>
Reference-contexts: The script language interpreter stores the entire application state at well chosen times so that application execution can continue from the saved state after a crash. Persistent workflows are usually dealt with in this way. * Use a persistent programming language that logs updates to persistent (recoverable) storage <ref> [11, 8] </ref>.
Reference: [9] <author> Eppinger, J., Mummert, L., and Spector, A. Camelot and Avalon: </author> <title> A Distributed Transaction Facility Morgan Kauf mann (1991) San Mateo, </title> <address> CA </address>
Reference: [10] <author> Gray, J. and Reuter, A. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann (1993) San Mateo, </publisher> <address> CA </address>
Reference-contexts: The application may also interact with the user, and perhaps with other RMs. Application interaction with a designated database system permits us to exploit its mechanisms to recover the application as well as the database. This functionality is similar to persistent save points <ref> [10] </ref>. It might, as a first step, permit database stored procedures (which can cross multiple transaction boundaries) to become a unit of consistency and recovery in addition to database transactions. <p> be recorded on the log; (3) describing the extensions to database recovery mechanisms needed to cope with the more complex operations that efficient application recovery entails. 1.2 Existing Techniques Existing ways to deal with application executions interrupted by system crashes have difficulties that restrict their usefulness. * Make applications stateless <ref> [10] </ref>. Between transactions, the application state is deterministically derivable from its initial state. <p> Most database systems log only page-oriented operations <ref> [10, 17] </ref>. This permits flushing pages in arbitrary order as the installation graph edges connect only operations of a single page. Flushing the page installs all operations with earlier updates to that page.
Reference: [11] <author> Haskin, R., Malachi, Y., Sawdon, W. and Chan, G. </author> <title> Recov ery Management in QuickSilver. </title> <journal> ACM Trans. on Computer Systems 6,1 (Feb. </journal> <year> 1988) </year> <month> 82-108. </month>
Reference-contexts: The script language interpreter stores the entire application state at well chosen times so that application execution can continue from the saved state after a crash. Persistent workflows are usually dealt with in this way. * Use a persistent programming language that logs updates to persistent (recoverable) storage <ref> [11, 8] </ref>.
Reference: [12] <author> Hsu, M. </author> <title> (ed) Workflow and Extended Transaction Systems. </title> <journal> Data Engineering Bulletin 16,2 (June 1993) </journal>
Reference: [13] <author> Hsu, M. </author> <title> (ed) Workflow Systems. </title> <journal> Data Engineering Bulletin 18,1 (March 1995) </journal>
Reference: [14] <author> Lomet, D. </author> <title> Application Recovery with Logical Write Oper ations. </title> <note> (Technical Report in preparation) 1996 </note>
Reference-contexts: Here we only discuss physical and physiological writes to avoid dealing with the flush dependencies of logical writes, but handle logical writes in <ref> [14] </ref>. Initiate and Completion Operations In addition to the above, the RM needs application initiation and termination operations. We launch an application via an initiate operation (Init (A)) which instantiates the application's invocation state by writing application state A 1 . <p> This is frequently inconvenient because it can interfere with the execution of ongoing requests while the installation is in progress. It is usually expensive, writing both to the log and to the stable system state. In <ref> [14] </ref>, we show how to avoid multi-object atomic flushes, permitting us to use logical writes. This leads to a further substantial reduction in the recovery overhead during normal operation. 5.3 Further Research Both this paper and [14] attack the cost of application recovery by greatly reducing (i) the data written to <p> In <ref> [14] </ref>, we show how to avoid multi-object atomic flushes, permitting us to use logical writes. This leads to a further substantial reduction in the recovery overhead during normal operation. 5.3 Further Research Both this paper and [14] attack the cost of application recovery by greatly reducing (i) the data written to the log and (ii) the frequency of application installation. The complication of diffuse application state remains.
Reference: [15] <author> Lomet, D. and Tuttle, M. </author> <title> Redo Recovery after System Crashes. </title> <booktitle> Proc. Very Large Databases Conf.(Sept. </booktitle> <address> 1995) Zurich, Switzerland 457-468. </address>
Reference-contexts: To ensure recovery using these more complex application operations, we base our RM on the theory developed in <ref> [15] </ref>. The cache manager of our new RM flushes objects in a careful order to avoid overwriting stable earlier versions of objects that are needed for replay. <p> In section 2, we treat application state as a persistent object and decompose application execution into a series of log operations. Section 3 provides a short summary of the redo recovery framework of <ref> [15] </ref>. We identify here what is required for RM recovery with complex application operations. Section 4 then describes an RM that provides application recovery. Extensions consistent with the recovery framework are made to cache management, logging, and the recovery process. <p> Installation then atomically swings a pointer in the stable state from the old version of the object to the new using a single page write. Thus, application state (and other large values) needs a pointer indirection to permit atomic installation. Testable State Recovery uses a REDO test <ref> [15] </ref> to determine whether an operation is installed or not. If uninstalled, the operation is replayed Otherwise, it can be bypassed. We make application state testable for this purpose. An operation consistent application state is associated with a state identifier (SI), both in cache and in stable system state. <p> Hence, we identify the updates and operations of <ref> [15] </ref>, and we use operation in the sequel to identify them. The cache manager carefully flushes cached data to the stable system state to preserve recoverability, i.e. that we can replay operations successfully. <p> For application recovery, operations are page-oriented, where we generalize page to variable or object, except for R (A; O). Because of reads, our CM enforces a more careful order, i.e., to provide the required installation ordering. Figure 3 is an example of this. In <ref> [15] </ref>, a write graph W is defined as an acyclic graph, derived from the installation graph, which orders the flushing of objects. <p> Useful notation for describing our technique is presented in Table 2. Translating from installation to write graph is described abstractly in <ref> [15] </ref>. Section 4 describes concretely how to do this in an RM that can handle application recovery. <p> The write graph needed for application recovery is not that simple. Our CM incrementally maintains the active part of a non-trivial write graph as new operations are executed, unlike creating the entire write graph de novo from the installation graph as described in <ref> [15] </ref>. 4.1.1 Flush Dependencies We use the term flush dependency to refer to the relationship between O and A whenever there is an uninstalled read R (A; O) of O by A. This is the only form of flush dependency. Initially, the read is a potential flush dependency. <p> Because we exclude logical writes, no object need ever be flushed before an application is flushed. Hence, no flush dependency cycles ever exist among the variables of the write graph. This avoids the merging of write graph nodes from the collapse step described in <ref> [15] </ref>. Because all our operations write to exactly one variable, all nodes n of the write graph have exactly one variable in vars (n). Hence, we identify a write graph node n with vars (n) = O with its variable O and denote it by N O . <p> This required that we: 1. create log operations for application interactions and for execution sequences between interactions, carefully characterizing the nature of all log operations within the recovery framework of <ref> [15] </ref>.
Reference: [16] <author> Lomet, D. and Tuttle, M. </author> <title> A Formal Treatment of Redo Recovery with Pragmatic Implications. </title> <institution> Cambridge Research Lab, Cambridge, </institution> <note> MA.(in preparation) </note>
Reference: [17] <author> Mohan, C., Haderle, D., Lindsay, B., Pirahesh, H., Schwarz, P. </author> <title> ARIES: A transaction recovery method supporting fine granularity locking and partial rollbacks using write-ahead logging. </title> <journal> ACM Trans. on Database Systems 17,1 (Mar. </journal> <year> 1992) </year> <month> 94-162. </month>
Reference-contexts: Most database systems log only page-oriented operations <ref> [10, 17] </ref>. This permits flushing pages in arbitrary order as the installation graph edges connect only operations of a single page. Flushing the page installs all operations with earlier updates to that page. <p> Hence we focus on rebuilding the cache. We ignore transactional issues and undo recovery. We consider analysis and redo passes. Analysis Phase We first perform an analysis pass on the log <ref> [17] </ref> to optimize repeating history (i.e. redo recovery) by isolating redo recovery to only those objects that have uninstalled operations. The analysis pass rebuilds the object table, which is analogous to the ARIES dirty pages table.
Reference: [18] <author> Salzberg, B. and Tombroff, D. DSDT: </author> <title> Durable scripts con taining database transactions. </title> <booktitle> Proc. Int'l Conf. on Data En gineering(Feb. </booktitle> <address> 1996) New Orleans, LA 624-633. </address>
Reference-contexts: This is facilitated by the use of an application scripting language <ref> [4, 18] </ref>. The script language interpreter stores the entire application state at well chosen times so that application execution can continue from the saved state after a crash.
Reference: [19] <author> Strom, R. and Yemini, S. </author> <title> Optimistic Recovery in Dis tributed Systems ACM Trans. </title> <booktitle> on Computer Systems 3,3 (Aug. </booktitle> <year> 1985) </year> <month> 204-226. </month>
Reference-contexts: Recovery overhead during normal operation compromises performance. Of particular concern here is how much information needs to be logged, and how frequently the (potentially large) application state needs to be flushed. None of the techniques directly leverage database recovery. 1.3 Application Replay Our approach, like <ref> [19] </ref>, replays applications during recovery. This reduces normal execution cost while increasing the overhead of the recovery process itself since now parts of the applications need to be re-executed during recovery. This is a good trade-off because crashes are rare. <p> This reduces normal execution cost while increasing the overhead of the recovery process itself since now parts of the applications need to be re-executed during recovery. This is a good trade-off because crashes are rare. Recovery cost is controllable by log checkpoint frequency, exactly as with database recovery. Unlike <ref> [19, 5, 6] </ref>, we exploit database style recovery. We focus on applications that interact with each other mostly by reading and writing persistently stored data, e.g. data in a database or file system. We log not only application reads and writes, but also application execution sequences between these interactions. <p> The recovered state must include the application state as of its last external write. 1 This requires a log force of the write operation. 1 Otherwise one may need to roll back the state as a result of failures elsewhere, as required in <ref> [19] </ref>. Transaction commit is a special case of forcing the log prior to exposing state. A common optimization is group commit, and we can generalize it for application recovery. The log does needn't be forced when a transaction commits, only when the commit is made known to a user.
References-found: 19

