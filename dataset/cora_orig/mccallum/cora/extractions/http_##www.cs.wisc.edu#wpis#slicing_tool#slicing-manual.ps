URL: http://www.cs.wisc.edu/wpis/slicing_tool/slicing-manual.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Wisconsin Program-Slicing Tool 1.1 Reference Manual  
Address: Madison, WI  
Affiliation: University of Wisconsin  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> L.-. Andersen. </author> <title> Program analysis and specialization for the c programming language. </title> <type> Technical report, </type> <institution> Datalogisk Institut, Univ. of Copenhagen, Copenhagen, Denmark, </institution> <month> May </month> <year> 1994. </year> <note> Report TOPPS D-203 and Ph.D. diss. </note>
Reference-contexts: At installation time, the Slicing Tool can be configured to use one of two supported approaches to pointer analysis. The more precise (and recommended) option, which is the default, uses an implementation of the flow-insensitive points-to analysis algorithm developed by L.-. Andersen <ref> [1, 14] </ref>. <p> The system dependence graph of a given program can be written to a file for later use. 2.7 Differences from Release 1.0 Release 1.1 of the Slicing Tool incorporates the points-to analysis algorithm due to L.-. Andersen <ref> [1, 14] </ref> to resolve dereferences of pointer variable and indirect calls. The C front end in Release 1.1 contains a new utility, named wpst-pa, to perform this points-to analysis.
Reference: [2] <author> D. Binkley. </author> <title> Precise executable interprocedural slices. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 2(1-4):31-45, </volume> <month> December </month> <year> 1993. </year>
Reference-contexts: System dependence graphs represent patented technology [6], the rights to which are held by the Wisconsin Alumni Foundation. This document describes the basic command set of the Slicing Tool. An overview of the system's theoretical underpinnings can be found in <ref> [5, 7, 10, 2] </ref>. The user interface for the Slicing Tool incorporates a language-specific editor created using the Synthesizer Generator, a meta-system for creating interactive, language-based program-development systems [12, 13]. <p> Change the display to indicate the components of the executable backward slice of the program with respect to the slice set. An executable slice includes all program components needed for the actual parameters at all call sites to match the formal parameters at the called procedure <ref> [7, 2] </ref>. To view elements of the slice that reside in other program files, use the slice-browser command. executable-slice-augment Augment the slice set with the collection of program components contained within the current textual selection. <p> Change the display to indicate the components of the executable backward slice of the program with respect to the augmented slice set. An executable slice includes all program components needed for the actual parameters at all call sites to match the formal parameters at the called procedure <ref> [7, 2] </ref>. <p> An executable slice includes all program components needed for the actual parameters at all call sites to match the formal parameters at the called procedure <ref> [7, 2] </ref>. To view elements of the slice that reside in other program files, use the slice-browser command.
Reference: [3] <author> J. Ferrante, K. Ottenstein, and J. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> In ACM Trans. Program. Lang. Syst., </journal> <pages> pages 319-349, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: Introduction The Wisconsin Program-Slicing Tool is a prototype system that supports backward and forward slicing|operations that help the user gain an understanding of what a program does and how it works. At the heart of the system is a package for manipulating program dependence graphs (PDGs) <ref> [3, 4, 8] </ref> and an extension of program dependence graphs, called system dependence graphs (SDGs) [7, 10]. System dependence graphs represent patented technology [6], the rights to which are held by the Wisconsin Alumni Foundation. This document describes the basic command set of the Slicing Tool.
Reference: [4] <author> S. Horwitz, J. Prins, and T. Reps. </author> <title> Integrating non-interfering versions of programs. </title> <journal> ACM Trans. Program. Lang. Syst., </journal> <volume> 11(3) </volume> <pages> 345-387, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: Introduction The Wisconsin Program-Slicing Tool is a prototype system that supports backward and forward slicing|operations that help the user gain an understanding of what a program does and how it works. At the heart of the system is a package for manipulating program dependence graphs (PDGs) <ref> [3, 4, 8] </ref> and an extension of program dependence graphs, called system dependence graphs (SDGs) [7, 10]. System dependence graphs represent patented technology [6], the rights to which are held by the Wisconsin Alumni Foundation. This document describes the basic command set of the Slicing Tool.
Reference: [5] <author> S. Horwitz and T. Reps. </author> <title> The use of program dependence graphs in software engineering. </title> <booktitle> In Proceedings of the Fourteenth International Conference on Software Engineering, </booktitle> <pages> pages 392-411, </pages> <address> Melbourne, Aus-tralia, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: System dependence graphs represent patented technology [6], the rights to which are held by the Wisconsin Alumni Foundation. This document describes the basic command set of the Slicing Tool. An overview of the system's theoretical underpinnings can be found in <ref> [5, 7, 10, 2] </ref>. The user interface for the Slicing Tool incorporates a language-specific editor created using the Synthesizer Generator, a meta-system for creating interactive, language-based program-development systems [12, 13].
Reference: [6] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing of computer programs using dependence graphs. </title> <type> U.S. Patent Number 5,161,216, issued November 3, </type> <year> 1992. </year>
Reference-contexts: At the heart of the system is a package for manipulating program dependence graphs (PDGs) [3, 4, 8] and an extension of program dependence graphs, called system dependence graphs (SDGs) [7, 10]. System dependence graphs represent patented technology <ref> [6] </ref>, the rights to which are held by the Wisconsin Alumni Foundation. This document describes the basic command set of the Slicing Tool. An overview of the system's theoretical underpinnings can be found in [5, 7, 10, 2].
Reference: [7] <author> S. Horwitz, T. Reps, and D. Binkley. </author> <title> Interprocedural slicing using dependence graphs. </title> <journal> ACM Trans. Program. Lang. Syst., </journal> <volume> 12(1), </volume> <month> January </month> <year> 1990. </year>
Reference-contexts: At the heart of the system is a package for manipulating program dependence graphs (PDGs) [3, 4, 8] and an extension of program dependence graphs, called system dependence graphs (SDGs) <ref> [7, 10] </ref>. System dependence graphs represent patented technology [6], the rights to which are held by the Wisconsin Alumni Foundation. This document describes the basic command set of the Slicing Tool. An overview of the system's theoretical underpinnings can be found in [5, 7, 10, 2]. <p> System dependence graphs represent patented technology [6], the rights to which are held by the Wisconsin Alumni Foundation. This document describes the basic command set of the Slicing Tool. An overview of the system's theoretical underpinnings can be found in <ref> [5, 7, 10, 2] </ref>. The user interface for the Slicing Tool incorporates a language-specific editor created using the Synthesizer Generator, a meta-system for creating interactive, language-based program-development systems [12, 13]. <p> the optimistic (non-conservative) assumption that they do not use or modify global variables and do not dereference pointer variables; we then make the conservative assumption that at all calls to such functions all possible dependences exist, and thus insert all possible summary edges (i.e., edges between parameter-in and parameter-out vertices <ref> [7, 10] </ref>) into the SDG. At installation time, the Slicing Tool can be configured to use one of two supported approaches to pointer analysis. The more precise (and recommended) option, which is the default, uses an implementation of the flow-insensitive points-to analysis algorithm developed by L.-. Andersen [1, 14]. <p> The program's procedure dependence graphs are constructed from their corresponding control flow graphs. The system dependence graph proper is then constructed by linking together all of the program's procedure dependence graphs with call-graph information and introducing some additional information that summarizes transitive dependences due to procedure calls <ref> [7, 10] </ref>. The system dependence graph of a given program can be written to a file for later use. 2.7 Differences from Release 1.0 Release 1.1 of the Slicing Tool incorporates the points-to analysis algorithm due to L.-. Andersen [1, 14] to resolve dereferences of pointer variable and indirect calls. <p> to be used by the C preprocessor. cpp-clean After a cpp-display command has been executed in the current buffer, remove highlighting from the display of the current buffer and the buffer containing the preprocessed file. 3.2 Program Slicing The Slicing Tool includes commands to display the components of program slices <ref> [15, 9, 7, 10] </ref>. A special display style HIGHLIGHT (with a distinctive color and/or type-face) is used to distinguish the components of a slice from other components of the program. <p> Change the display to indicate the components of the executable backward slice of the program with respect to the slice set. An executable slice includes all program components needed for the actual parameters at all call sites to match the formal parameters at the called procedure <ref> [7, 2] </ref>. To view elements of the slice that reside in other program files, use the slice-browser command. executable-slice-augment Augment the slice set with the collection of program components contained within the current textual selection. <p> Change the display to indicate the components of the executable backward slice of the program with respect to the augmented slice set. An executable slice includes all program components needed for the actual parameters at all call sites to match the formal parameters at the called procedure <ref> [7, 2] </ref>. <p> An executable slice includes all program components needed for the actual parameters at all call sites to match the formal parameters at the called procedure <ref> [7, 2] </ref>. To view elements of the slice that reside in other program files, use the slice-browser command.
Reference: [8] <author> D.J. Kuck, R.H. Kuhn, B. Leasure, D.A. Padua, and M. Wolfe. </author> <title> Dependence graphs and compiler optimizations. </title> <booktitle> In Conference Record of the Eighth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-218, </pages> <year> 1981. </year>
Reference-contexts: Introduction The Wisconsin Program-Slicing Tool is a prototype system that supports backward and forward slicing|operations that help the user gain an understanding of what a program does and how it works. At the heart of the system is a package for manipulating program dependence graphs (PDGs) <ref> [3, 4, 8] </ref> and an extension of program dependence graphs, called system dependence graphs (SDGs) [7, 10]. System dependence graphs represent patented technology [6], the rights to which are held by the Wisconsin Alumni Foundation. This document describes the basic command set of the Slicing Tool.
Reference: [9] <author> K.J. Ottenstein and L.M. Ottenstein. </author> <title> The program dependence graph in a software development environment. </title> <booktitle> Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 177-184, </pages> <month> May </month> <year> 1984. </year> <note> 23 24 BIBLIOGRAPHY </note>
Reference-contexts: to be used by the C preprocessor. cpp-clean After a cpp-display command has been executed in the current buffer, remove highlighting from the display of the current buffer and the buffer containing the preprocessed file. 3.2 Program Slicing The Slicing Tool includes commands to display the components of program slices <ref> [15, 9, 7, 10] </ref>. A special display style HIGHLIGHT (with a distinctive color and/or type-face) is used to distinguish the components of a slice from other components of the program.
Reference: [10] <author> T. Reps, S. Horwitz, M. Sagiv, and G. Rosay. </author> <title> Speeding up slicing. </title> <booktitle> In Proceedings of the Second ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 11-20, </pages> <address> New Orleans, LA, </address> <month> De-cember </month> <year> 1994. </year>
Reference-contexts: At the heart of the system is a package for manipulating program dependence graphs (PDGs) [3, 4, 8] and an extension of program dependence graphs, called system dependence graphs (SDGs) <ref> [7, 10] </ref>. System dependence graphs represent patented technology [6], the rights to which are held by the Wisconsin Alumni Foundation. This document describes the basic command set of the Slicing Tool. An overview of the system's theoretical underpinnings can be found in [5, 7, 10, 2]. <p> System dependence graphs represent patented technology [6], the rights to which are held by the Wisconsin Alumni Foundation. This document describes the basic command set of the Slicing Tool. An overview of the system's theoretical underpinnings can be found in <ref> [5, 7, 10, 2] </ref>. The user interface for the Slicing Tool incorporates a language-specific editor created using the Synthesizer Generator, a meta-system for creating interactive, language-based program-development systems [12, 13]. <p> the optimistic (non-conservative) assumption that they do not use or modify global variables and do not dereference pointer variables; we then make the conservative assumption that at all calls to such functions all possible dependences exist, and thus insert all possible summary edges (i.e., edges between parameter-in and parameter-out vertices <ref> [7, 10] </ref>) into the SDG. At installation time, the Slicing Tool can be configured to use one of two supported approaches to pointer analysis. The more precise (and recommended) option, which is the default, uses an implementation of the flow-insensitive points-to analysis algorithm developed by L.-. Andersen [1, 14]. <p> The program's procedure dependence graphs are constructed from their corresponding control flow graphs. The system dependence graph proper is then constructed by linking together all of the program's procedure dependence graphs with call-graph information and introducing some additional information that summarizes transitive dependences due to procedure calls <ref> [7, 10] </ref>. The system dependence graph of a given program can be written to a file for later use. 2.7 Differences from Release 1.0 Release 1.1 of the Slicing Tool incorporates the points-to analysis algorithm due to L.-. Andersen [1, 14] to resolve dereferences of pointer variable and indirect calls. <p> to be used by the C preprocessor. cpp-clean After a cpp-display command has been executed in the current buffer, remove highlighting from the display of the current buffer and the buffer containing the preprocessed file. 3.2 Program Slicing The Slicing Tool includes commands to display the components of program slices <ref> [15, 9, 7, 10] </ref>. A special display style HIGHLIGHT (with a distinctive color and/or type-face) is used to distinguish the components of a slice from other components of the program.
Reference: [11] <author> T. Reps and G. Rosay. </author> <title> Precise interprocedural chopping. </title> <booktitle> In Proceedings of the Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 41-52, </pages> <address> Washington, DC, </address> <month> October </month> <year> 1995. </year>
Reference-contexts: of the slice that reside in that file. (Warning: This collection of elements is not guaranteed to be a well-formed program.) This command is valid only after one of the backward slice operations has been performed. 3.3 Program Chopping The Slicing Tool provides commands for chopping operations, as described in <ref> [11] </ref>. These commands are currently not available in the io configuration. A chop is a multi-source/multi-target reachability operation (i.e., it consists of the set of elements along paths from a source component to a target component). <p> The target set will be the set of targets for later invocation of chop or truncated-chop. clear-target Clear the target set, the set of targets for later invocation of chop or truncated-chop. chop Display program components in the chop of the program (see <ref> [11] </ref>) with respect to source set, the components selected by the mark-source commands, and target set, the components selected by the mark-target commands. <p> To view elements of the chop that reside in other program files, use the chop-browser command. truncated-chop Display program components in the truncated chop of the program (see <ref> [11] </ref>) with respect to source set, the components selected by the mark-source commands, and target set, the components selected by the mark-target commands.
Reference: [12] <author> T. Reps and T. Teitelbaum. </author> <title> The Synthesizer Generator: A System for Constructing Language-Based Editors. </title> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: An overview of the system's theoretical underpinnings can be found in [5, 7, 10, 2]. The user interface for the Slicing Tool incorporates a language-specific editor created using the Synthesizer Generator, a meta-system for creating interactive, language-based program-development systems <ref> [12, 13] </ref>. As with all editors created with the Synthesizer Generator, the Slicing Tool's editor exhibits characteristics that are specific to the Slicing Tool, while at the same time sharing the generic user interface described in Chapter 5 of The Synthesizer Generator Reference Manual [13].
Reference: [13] <author> T. Reps and T. Teitelbaum. </author> <title> The Synthesizer Generator Reference Manual: </title> <booktitle> Third Edition. </booktitle> <address> New York, NY, </address> <year> 1988. </year>
Reference-contexts: An overview of the system's theoretical underpinnings can be found in [5, 7, 10, 2]. The user interface for the Slicing Tool incorporates a language-specific editor created using the Synthesizer Generator, a meta-system for creating interactive, language-based program-development systems <ref> [12, 13] </ref>. As with all editors created with the Synthesizer Generator, the Slicing Tool's editor exhibits characteristics that are specific to the Slicing Tool, while at the same time sharing the generic user interface described in Chapter 5 of The Synthesizer Generator Reference Manual [13]. <p> As with all editors created with the Synthesizer Generator, the Slicing Tool's editor exhibits characteristics that are specific to the Slicing Tool, while at the same time sharing the generic user interface described in Chapter 5 of The Synthesizer Generator Reference Manual <ref> [13] </ref>. This document primarily describes the commands that are specific to the Slicing Tool|for example, for invoking slicing operations|as opposed to commands that are part of the standard user interface of editors created with the Synthesizer Generator. 1 2 CHAPTER 1. <p> This section contains an outline of a session with the Slicing Tool. For the general use of editors created with the Synthesizer Generator, see Chapter 5 of The Synthesizer Generator Reference Manual <ref> [13] </ref>. Commands specific to the Slicing Tool are described in this document in Chapter 3, Slicing Tool Commands. The Slicing Tool has an online user manual, organized as an HTML document consisting of a collection of "hypertext pages" connected by "hot links". <p> See Section 9.6 of The Synthesizer Generator Reference Manual for information about defining display styles for editors created with the Synthesizer Generator <ref> [13] </ref>.) All commands in this section operate on a program for which a system dependence graph (SDG) has been successfully built, and, except for unslice and slice-browser, when the current buffer displays one of the program files of the SDG being sliced.
Reference: [14] <author> M. Shapiro and S. Horwitz. </author> <title> Fast and accurate flow-insensitive points-to analysis. </title> <booktitle> In Conference Record of the Twenty-Fourth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 133-145, </pages> <address> New York, NY, </address> <month> January </month> <year> 1997. </year> <booktitle> ACM. POPL Paris, </booktitle> <address> France, </address> <month> Jan. </month> <pages> 15-17. </pages>
Reference-contexts: At installation time, the Slicing Tool can be configured to use one of two supported approaches to pointer analysis. The more precise (and recommended) option, which is the default, uses an implementation of the flow-insensitive points-to analysis algorithm developed by L.-. Andersen <ref> [1, 14] </ref>. <p> The system dependence graph of a given program can be written to a file for later use. 2.7 Differences from Release 1.0 Release 1.1 of the Slicing Tool incorporates the points-to analysis algorithm due to L.-. Andersen <ref> [1, 14] </ref> to resolve dereferences of pointer variable and indirect calls. The C front end in Release 1.1 contains a new utility, named wpst-pa, to perform this points-to analysis.

References-found: 14

