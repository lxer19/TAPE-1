URL: ftp://ftp.cs.toronto.edu/pub/bonner/papers/transaction.logic/dbpl97-long.ps
Refering-URL: http://www.cs.toronto.edu/DB/people/bonner/papers.html
Root-URL: 
Email: bonner@db.toronto.edu  
Title: Transaction Datalog: a Compositional Language for Transaction Programming  
Author: Anthony J. Bonner 
Web: http://www.cs.toronto.edu/~bonner/transaction-logic.html  
Note: This and related papers are available at the Transaction Logic web-page:  
Address: Toronto, ON, Canada M5S 1A4  
Affiliation: University of Toronto, Department of Computer Science  
Abstract: In the classical model of database transactions, large transactions cannot be built out of smaller ones. Instead, transactions are modelled as atomic and isolated units of work. This model has been widely successful in traditional database applications, in which transactions perform only a few simple operations on small amounts of simply-structured data. Unfortunately, this model is inappropriate for more complex applications in which transactions must be combined and coordinated to achieve a larger goal. Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. These applications require new transaction models, new methods of transaction management, and new transaction languages. This paper focuses on the latter issue: languages for specifying non-classical transactions, and combining them into complex processes. In particular, we develop Transaction Datalog, a deductive language that integrates queries, updates, and transaction composition in a simple logical framework. This integration extends the deductive-database paradigm with several new capabilities. For instance, Transaction Datalog supports all the properties of classical transactions, such as persistence, atomicity, isolation, abort and rollback. It also supports properties found in many new transaction models, such as subtransaction hierarchies, concurrency within individual transactions, cooperation between concurrent activities, a separation of atomicity and isolation, and fine-grained control over abort and rollback. These capabilities are all provided within a purely logical framework, including a natural model theory and a sound-and-complete proof theory. This paper outlines the problems of developing a compositional transaction language, illustrates our solution (Transaction Datalog) through a series of examples, and develops its formal semantics in terms of a logical inference system. A short version of this paper appears in Proceedings of the Sixth International Workshop on Database Programming Languages (DBPL), Estes Park, Colorado, August 18-20 1997, pages 303-322. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Abiteboul. </author> <title> Updates, a new frontier. </title> <booktitle> In Intl. Conference on Database Theory, </booktitle> <pages> pages 1-18, </pages> <year> 1988. </year>
Reference-contexts: Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored. These issues have been studied extensively in the context of classical 4 transactions and database queries (e:g:, <ref> [23, 24, 70, 2, 3, 1] </ref>). The challenge is to extend this theory to non-classical transactions. This paper takes a first step. 1.2 Transaction Datalog In this paper, we propose a logic-based approach to the problems of specifying non-classical transactions. <p> In this system, all execution traces are safe. That is, programs do not expand the data domain during execution, and in particular, they do not create new domain values and insert them into the database (so-called value invention <ref> [1] </ref>). Safety is guaranteed by defining inference with respect to a finite data domain. 3 Definition 3.3 (Inference System) Let dom be a finite set of constant symbols, called the data domain. <p> Formally, these issues are abstracted away, and only the effects of transactions are considered. These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu <ref> [3, 2, 1] </ref>, the procedural language QL of Chandra and Harel [23, 24], 4 Dynamic Prolog [50, 73], LDL [57, 58], and numerous other languages (e:g:, [20, 25, 62, 22, 30]). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions.
Reference: [2] <author> S. Abiteboul and V. Vianu. </author> <title> Procedural languages for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 41 </volume> <pages> 181-229, </pages> <year> 1990. </year>
Reference-contexts: Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored. These issues have been studied extensively in the context of classical 4 transactions and database queries (e:g:, <ref> [23, 24, 70, 2, 3, 1] </ref>). The challenge is to extend this theory to non-classical transactions. This paper takes a first step. 1.2 Transaction Datalog In this paper, we propose a logic-based approach to the problems of specifying non-classical transactions. <p> Formally, these issues are abstracted away, and only the effects of transactions are considered. These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu <ref> [3, 2, 1] </ref>, the procedural language QL of Chandra and Harel [23, 24], 4 Dynamic Prolog [50, 73], LDL [57, 58], and numerous other languages (e:g:, [20, 25, 62, 22, 30]). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions.
Reference: [3] <author> S. Abiteboul and V. Vianu. </author> <title> Datalog extensions for database queries and updates. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 43 </volume> <pages> 62-124, </pages> <year> 1991. </year>
Reference-contexts: Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored. These issues have been studied extensively in the context of classical 4 transactions and database queries (e:g:, <ref> [23, 24, 70, 2, 3, 1] </ref>). The challenge is to extend this theory to non-classical transactions. This paper takes a first step. 1.2 Transaction Datalog In this paper, we propose a logic-based approach to the problems of specifying non-classical transactions. <p> Formally, these issues are abstracted away, and only the effects of transactions are considered. These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu <ref> [3, 2, 1] </ref>, the procedural language QL of Chandra and Harel [23, 24], 4 Dynamic Prolog [50, 73], LDL [57, 58], and numerous other languages (e:g:, [20, 25, 62, 22, 30]). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions.
Reference: [4] <author> D. Agrawal and A. El Abbadi. </author> <title> Transaction management in database systems. </title> <booktitle> In [32], chapter 1, </booktitle> <pages> pages 1-31. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1992. </year>
Reference-contexts: Moreover, "there is a strong relationship between the concept of modularization in software engineering and the nested transaction mechanism" [40]. These properties make nested transactions ideal for distributed 5 applications, object-oriented databases, and layered software systems <ref> [75, 4, 5, 55] </ref>. Numer--ous examples in this paper deal with nested transactions. In addition to transactional features, Transaction Datalog provides all the functionality of a declarative query language and a procedural programming language, seamlessly integrated.
Reference: [5] <author> G. Alonso, S. Blott, A. Fessler, and H.-J. Schek. </author> <title> Correctness and parallelism in composite systems. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 197-208, </pages> <address> Tuscon, AZ, </address> <month> May 12-14 </month> <year> 1997. </year>
Reference-contexts: Moreover, "there is a strong relationship between the concept of modularization in software engineering and the nested transaction mechanism" [40]. These properties make nested transactions ideal for distributed 5 applications, object-oriented databases, and layered software systems <ref> [75, 4, 5, 55] </ref>. Numer--ous examples in this paper deal with nested transactions. In addition to transactional features, Transaction Datalog provides all the functionality of a declarative query language and a procedural programming language, seamlessly integrated.
Reference: [6] <author> P. Attie, M. Singh, A. Sheth, and M. Rusinkiewicz. </author> <title> Specifying and enforcing intertask dependencies. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Unfortunately, although some programming languages have been implemented and others have been proposed, their theoretical foundations are incomplete. In general, the theory of non-classical transactions has focussed on transaction management (e:g:, <ref> [8, 49, 74, 26, 6] </ref>), not on transaction languages. For instance, there has been no attempt to integrate relational algebra and relational updates into a language for transaction composition. Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored. <p> Developments in this area include ACTA [26, 27], proposals for Third Generation TP Monitors [29], approaches based on temporal logic <ref> [6] </ref> and event algebras [66, 65], and numerous other works (e:g:, [46, 36]). In this paper, we addressed both issues, and integrated them into a single language.
Reference: [7] <author> F. Bancilhon. </author> <title> Object-oriented database systems. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 152-162, </pages> <address> New York, 1988. </address> <publisher> ACM. </publisher>
Reference-contexts: The result is that Transaction Datalog avoids many of the problems of embedded SQL, such as the infamous "impedance mismatch" problem <ref> [28, 7, 62] </ref>. Of course, Transaction Datalog can also compose transactions and define nested transactions, which goes well beyond the capabilities of embedded SQL. 2 Overview of Transaction Datalog This section introduces Transaction Datalog informally through a series of simple examples.
Reference: [8] <author> C. Beeri, P.A. Bernstein, N. Goodman, M.Y. Lai, and D.E. Shasha. </author> <title> A concurrency control theory for nested transactions. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 45-62, </pages> <year> 1983. </year> <month> 25 </month>
Reference-contexts: Unfortunately, although some programming languages have been implemented and others have been proposed, their theoretical foundations are incomplete. In general, the theory of non-classical transactions has focussed on transaction management (e:g:, <ref> [8, 49, 74, 26, 6] </ref>), not on transaction languages. For instance, there has been no attempt to integrate relational algebra and relational updates into a language for transaction composition. Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored.
Reference: [9] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Concurrency Control and Recovery in Databases. </title> <publisher> Addison Wesley, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction Database transactions were originally modeled as atomic and isolated units of work, with no internal structure and no external connections <ref> [9] </ref>. This "classical" transaction model has been widely successful for applications like banking, airline reservations, and inventory control, where transactions perform only a few simple operations on small amounts of simply-structured data. <p> Because communication can be two-way, executions of such programs need not be serializable <ref> [9] </ref>, so TD programs need not be isolated transactions. To specify isolation, TD includes a logical modality called the modality of isolation, denoted fi. Intuitively, the formula fi means that program executes in isolation from all other concurrent programs. <p> When the transaction base is implicit, we sometimes refer to the goal as a program. A transaction program is a program whose main procedure executes in isolation, i:e:, has the form fi. In the literature <ref> [9, 40] </ref>, a transaction is a particular execution of a transaction program. This paper uses the same definition, but when there is no confusion, we sometimes use "transaction" as an abbreviation for "transaction program." 3.2 Execution Traces Concurrency in Transaction Datalog has an interleaving semantics. <p> As a special case, a concurrent execution of transactions must have the same effect as a serial execution; i:e:, transactions must be serializable, which is the normal understanding in database concurrency control <ref> [9] </ref>. Our semantics therefore specifies the effects of a TD program, but not its actual execution inside a DBMS. In fact, inside a DBMS, concurrent programs may be executed in parallel, rather than in an interleaved fashion. For instance, suppose that predicates p and q are stored on different disks.
Reference: [10] <author> A. Bonner, A. Shrufi, and S. Rozen. LabFlow-1: </author> <title> a database benchmark for high-throughput workflow management. </title> <booktitle> In Intl. Conference on Extending Database Technology, number 1057 in Lecture Notes in Computer Science, </booktitle> <pages> pages 463-478, </pages> <address> Avignon, France, March 25-29 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes <ref> [32, 40, 39, 10, 42, 34, 21, 43, 45] </ref>. These applications require new transaction models, new methods of transaction management, and new transaction languages [32, 40, 39, 29]. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. <p> The workflow model in the example is based on workflows at the Whitehead Institute/MIT Center for Genome Research, in which workflows are used to carry out the tens of millions of biological experiments needed to map and sequence the human genome <ref> [10, 67] </ref>. Example 4.2 (Workflow) Consider a workflow consisting of a sequence of three activities. The workflow processes a stream of work items. Each item is processed first by Activity 1, then by Activity 2, and finally by Activity 3.
Reference: [11] <author> A.J. Bonner. </author> <title> Hypothetical Datalog: Complexity and expressibility. </title> <journal> Theoretical Computer Science, </journal> <volume> 76 </volume> <pages> 3-51, </pages> <year> 1990. </year>
Reference-contexts: There are two versions of CDL. The version developed in [61] is very different from TD. It is modeled on the kind of concurrency found in alternating Turing machines, which does not allow for communication between concurrent processes. A deductive-database analogue of this version of CDL is Hypothetical Datalog <ref> [11] </ref>, in which hypothetical databases represent the states of the various (non-communicating) concurrent processes in an alternating computation. The version of CDL developed in [60] does allow for communication, but only after adding considerable complexity to the semantics.
Reference: [12] <author> A.J. Bonner. </author> <title> The power of cooperating transactions. </title> <type> Manuscript, </type> <year> 1997. </year>
Reference-contexts: In the case of database programming languages (like TD), these operations are elementary database transactions. The precise set of elementary operations is somewhat arbitrary, and in this paper, four are provided. These operations are simple, they can be efficiently implemented, and they lead to expressive completeness <ref> [12] </ref>. They are also minimal, since removing any one of them causes a loss of expressive completeness [12]. To represent these four operations, we use four types of expression: q, empty.r, ins.q, del.q. The first two expressions are yes/no queries. <p> The precise set of elementary operations is somewhat arbitrary, and in this paper, four are provided. These operations are simple, they can be efficiently implemented, and they lead to expressive completeness <ref> [12] </ref>. They are also minimal, since removing any one of them causes a loss of expressive completeness [12]. To represent these four operations, we use four types of expression: q, empty.r, ins.q, del.q. The first two expressions are yes/no queries. Intuitively, q means "Is atom q in the database," and empty.r means "Is relation r empty." The other two expressions are updates. <p> Transaction Datalog is a fragment of Transaction Logic. We have focussed on this fragment because it captures many essential properties of the general logic in a simpler setting. In addition, it has interesting complexity properties <ref> [12] </ref>, and it greatly extends the capabilities of deductive database systems. Although not the subject of this paper, several results on the complexity and expressibility of TD are worth mentioning [12]. For instance, the data complexity of TD is complete for RE. <p> In addition, it has interesting complexity properties <ref> [12] </ref>, and it greatly extends the capabilities of deductive database systems. Although not the subject of this paper, several results on the complexity and expressibility of TD are worth mentioning [12]. For instance, the data complexity of TD is complete for RE. In addition, TD is expressively complete; i:e:, it expresses all computable generic transactions.
Reference: [13] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming. </title> <booktitle> In Intl. Conference on Logic Programming, </booktitle> <pages> pages 257-282, </pages> <address> Budapest, Hungary, June 1993. </address> <publisher> MIT Press. </publisher>
Reference-contexts: In addition, it provides a smooth integration of procedural and declarative programming, and in the absence of updates, it reduces to classical Datalog. Transaction Datalog is derived from a general logic of state change called Transaction Logic <ref> [14, 16, 13, 19, 15] </ref>. Transaction Logic allows users to express properties of transaction programs, and to reason about them [18]. For instance, one can reason about when a program will commit or abort, and about whether a program preserves integrity constraints. <p> Transaction Datalog is derived from this Horn fragment by restricting it to relational databases and to rules without function symbols (i:e:, just as classical Datalog is derived from classical Horn logic). Transaction Datalog thus inherits the semantics of the full logic, which has been published elsewhere <ref> [14, 16, 13, 19] </ref>. However, because Transaction Datalog is a specialized system, it has a specialized semantics, which is simpler than the more-general semantics of the full logic. This paper develops the simplified semantics in terms of a logical inference system. <p> Like classical Datalog, TD has both a declarative semantics and an equivalent operational semantics. The declarative semantics includes a logical model theory and sound-and-complete inference system. The operational semantics includes an SLD-style proof procedure in the logic-programming tradition <ref> [14, 16, 13, 19, 15] </ref>. This procedure executes transactions and updates the database as it proves theorems. Transaction Datalog is a minimal language based on a few simple operations. However, these operations lead directly to a wide range of transactional and programming capabilities. <p> The second rule halts the recursion after all the tuples have been deleted from relation r, i:e:, after n 1 recursive calls 2 3 Syntax and Semantics Recall that Transaction Datalog is a fragment of Transaction Logic, which is a general logic of state change <ref> [14, 16, 13, 19, 15] </ref>. Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof procedures, which have been published elsewhere [14, 16, 13, 19]. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. <p> Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof procedures, which have been published elsewhere <ref> [14, 16, 13, 19] </ref>. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. The simplification comes from restricting Transaction Logic to relational databases and Horn-like rules without function symbols (in much the same way that classical Datalog is a restriction of classical logic). <p> The simplified semantics is based on a logical inference system that describes the legal execution traces of a TD program. It should also be mentioned that Transaction Logic (and thus Transaction Datalog) has an operational semantics based on a proof procedure with unification <ref> [16, 15, 13] </ref>. This procedure executes transactions, updates the database, and generates query answers, all as a result of proving theorems. Transactional features such as abort, rollback, and save-points are also handled by the proof procedure. <p> : D 1 ` 1 P : D 2 ` 2 if D 3 is the concatenation of D 1 and D 2 . 3 In contrast to Transaction Datalog, the semantics of Transaction Logic is defined with respect to an infinite data domain, including both constant and function symbols <ref> [14, 16, 13, 15] </ref>. In this more-general setting, value invention is possible, and safety is guaranteed by syntactic restrictions. 16 5. Concurrent Composition: P : D 1 ` 1 P : D 2 ` 2 if D 3 is an interleaving of D 1 and D 2 . 6. <p> For instance, to simulate some non-classical transaction models, we must augment TD with negation-as-failure, as mentioned earlier. In addition, a complete treatment must deal with several other issues, including non-relational databases and legacy systems. Many of these issues are dealt with in the more general framework of Transaction Logic <ref> [14, 16, 13, 19, 15] </ref>. Transaction Datalog is a fragment of Transaction Logic. We have focussed on this fragment because it captures many essential properties of the general logic in a simpler setting. <p> In TD, states are relational databases that can be queried and updated. In contrast, CDL focuses on the internal states of executing programs, while the notion of a database state is entirely missing. Acknowledgements: Transaction Logic was developed in collaboration with Michael Kifer <ref> [14, 16, 13, 19, 15] </ref>. Thanks go to David Toman and Michael Kifer for their comments on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: [14] <author> A.J. Bonner and M. Kifer. </author> <title> An overview of transaction logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 133 </volume> <pages> 205-265, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: In addition, it provides a smooth integration of procedural and declarative programming, and in the absence of updates, it reduces to classical Datalog. Transaction Datalog is derived from a general logic of state change called Transaction Logic <ref> [14, 16, 13, 19, 15] </ref>. Transaction Logic allows users to express properties of transaction programs, and to reason about them [18]. For instance, one can reason about when a program will commit or abort, and about whether a program preserves integrity constraints. <p> Transaction Datalog is derived from this Horn fragment by restricting it to relational databases and to rules without function symbols (i:e:, just as classical Datalog is derived from classical Horn logic). Transaction Datalog thus inherits the semantics of the full logic, which has been published elsewhere <ref> [14, 16, 13, 19] </ref>. However, because Transaction Datalog is a specialized system, it has a specialized semantics, which is simpler than the more-general semantics of the full logic. This paper develops the simplified semantics in terms of a logical inference system. <p> Like classical Datalog, TD has both a declarative semantics and an equivalent operational semantics. The declarative semantics includes a logical model theory and sound-and-complete inference system. The operational semantics includes an SLD-style proof procedure in the logic-programming tradition <ref> [14, 16, 13, 19, 15] </ref>. This procedure executes transactions and updates the database as it proves theorems. Transaction Datalog is a minimal language based on a few simple operations. However, these operations lead directly to a wide range of transactional and programming capabilities. <p> The second rule halts the recursion after all the tuples have been deleted from relation r, i:e:, after n 1 recursive calls 2 3 Syntax and Semantics Recall that Transaction Datalog is a fragment of Transaction Logic, which is a general logic of state change <ref> [14, 16, 13, 19, 15] </ref>. Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof procedures, which have been published elsewhere [14, 16, 13, 19]. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. <p> Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof procedures, which have been published elsewhere <ref> [14, 16, 13, 19] </ref>. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. The simplification comes from restricting Transaction Logic to relational databases and Horn-like rules without function symbols (in much the same way that classical Datalog is a restriction of classical logic). <p> : D 1 ` 1 P : D 2 ` 2 if D 3 is the concatenation of D 1 and D 2 . 3 In contrast to Transaction Datalog, the semantics of Transaction Logic is defined with respect to an infinite data domain, including both constant and function symbols <ref> [14, 16, 13, 15] </ref>. In this more-general setting, value invention is possible, and safety is guaranteed by syntactic restrictions. 16 5. Concurrent Composition: P : D 1 ` 1 P : D 2 ` 2 if D 3 is an interleaving of D 1 and D 2 . 6. <p> In addition, many have no notion of database state or declarative query, many are propositional, and many are simply inappropriate for database applications. An extensive comparison of these formalisms with the sequential version of Transaction Logic can be found in <ref> [15, 14] </ref>. Transaction Languages: Broadly speaking, the theoretical literature has explored two kinds of transaction language, in order to address two different problems. In the first approach, the user specifies the effects of individual transactions; and in the second approach, he coordinates the execution of a set of transactions. <p> Detailed discussion of these works can be found in <ref> [17, 14, 15] </ref>. The coordination approach focuses on non-classical transactions. The problem is to develop a high-level language for combining a set of tasks into a larger application or software system. The focus is on relationships between tasks. <p> For instance, to simulate some non-classical transaction models, we must augment TD with negation-as-failure, as mentioned earlier. In addition, a complete treatment must deal with several other issues, including non-relational databases and legacy systems. Many of these issues are dealt with in the more general framework of Transaction Logic <ref> [14, 16, 13, 19, 15] </ref>. Transaction Datalog is a fragment of Transaction Logic. We have focussed on this fragment because it captures many essential properties of the general logic in a simpler setting. <p> In TD, states are relational databases that can be queried and updated. In contrast, CDL focuses on the internal states of executing programs, while the notion of a database state is entirely missing. Acknowledgements: Transaction Logic was developed in collaboration with Michael Kifer <ref> [14, 16, 13, 19, 15] </ref>. Thanks go to David Toman and Michael Kifer for their comments on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: [15] <author> A.J. Bonner and M. Kifer. </author> <title> Transaction logic programming (or a logic of declarative and procedural knowledge). </title> <type> Technical Report CSRI-323, </type> <institution> University of Toronto, </institution> <month> November </month> <year> 1995. </year> <note> http://www.cs.toronto.edu/~bonner/transaction-logic.html. </note>
Reference-contexts: In addition, it provides a smooth integration of procedural and declarative programming, and in the absence of updates, it reduces to classical Datalog. Transaction Datalog is derived from a general logic of state change called Transaction Logic <ref> [14, 16, 13, 19, 15] </ref>. Transaction Logic allows users to express properties of transaction programs, and to reason about them [18]. For instance, one can reason about when a program will commit or abort, and about whether a program preserves integrity constraints. <p> Like classical Datalog, TD has both a declarative semantics and an equivalent operational semantics. The declarative semantics includes a logical model theory and sound-and-complete inference system. The operational semantics includes an SLD-style proof procedure in the logic-programming tradition <ref> [14, 16, 13, 19, 15] </ref>. This procedure executes transactions and updates the database as it proves theorems. Transaction Datalog is a minimal language based on a few simple operations. However, these operations lead directly to a wide range of transactional and programming capabilities. <p> The second rule halts the recursion after all the tuples have been deleted from relation r, i:e:, after n 1 recursive calls 2 3 Syntax and Semantics Recall that Transaction Datalog is a fragment of Transaction Logic, which is a general logic of state change <ref> [14, 16, 13, 19, 15] </ref>. Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof procedures, which have been published elsewhere [14, 16, 13, 19]. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. <p> The simplified semantics is based on a logical inference system that describes the legal execution traces of a TD program. It should also be mentioned that Transaction Logic (and thus Transaction Datalog) has an operational semantics based on a proof procedure with unification <ref> [16, 15, 13] </ref>. This procedure executes transactions, updates the database, and generates query answers, all as a result of proving theorems. Transactional features such as abort, rollback, and save-points are also handled by the proof procedure. <p> : D 1 ` 1 P : D 2 ` 2 if D 3 is the concatenation of D 1 and D 2 . 3 In contrast to Transaction Datalog, the semantics of Transaction Logic is defined with respect to an infinite data domain, including both constant and function symbols <ref> [14, 16, 13, 15] </ref>. In this more-general setting, value invention is possible, and safety is guaranteed by syntactic restrictions. 16 5. Concurrent Composition: P : D 1 ` 1 P : D 2 ` 2 if D 3 is an interleaving of D 1 and D 2 . 6. <p> In addition, many have no notion of database state or declarative query, many are propositional, and many are simply inappropriate for database applications. An extensive comparison of these formalisms with the sequential version of Transaction Logic can be found in <ref> [15, 14] </ref>. Transaction Languages: Broadly speaking, the theoretical literature has explored two kinds of transaction language, in order to address two different problems. In the first approach, the user specifies the effects of individual transactions; and in the second approach, he coordinates the execution of a set of transactions. <p> Detailed discussion of these works can be found in <ref> [17, 14, 15] </ref>. The coordination approach focuses on non-classical transactions. The problem is to develop a high-level language for combining a set of tasks into a larger application or software system. The focus is on relationships between tasks. <p> For instance, to simulate some non-classical transaction models, we must augment TD with negation-as-failure, as mentioned earlier. In addition, a complete treatment must deal with several other issues, including non-relational databases and legacy systems. Many of these issues are dealt with in the more general framework of Transaction Logic <ref> [14, 16, 13, 19, 15] </ref>. Transaction Datalog is a fragment of Transaction Logic. We have focussed on this fragment because it captures many essential properties of the general logic in a simpler setting. <p> In TD, states are relational databases that can be queried and updated. In contrast, CDL focuses on the internal states of executing programs, while the notion of a database state is entirely missing. Acknowledgements: Transaction Logic was developed in collaboration with Michael Kifer <ref> [14, 16, 13, 19, 15] </ref>. Thanks go to David Toman and Michael Kifer for their comments on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: [16] <author> A.J. Bonner and M. Kifer. </author> <title> Concurrency and communication in transaction logic. </title> <booktitle> In Joint Intl. Conference and Symposium on Logic Programming, </booktitle> <pages> pages 142-156, </pages> <address> Bonn, Germany, September 1996. </address> <publisher> MIT Press. </publisher>
Reference-contexts: In addition, it provides a smooth integration of procedural and declarative programming, and in the absence of updates, it reduces to classical Datalog. Transaction Datalog is derived from a general logic of state change called Transaction Logic <ref> [14, 16, 13, 19, 15] </ref>. Transaction Logic allows users to express properties of transaction programs, and to reason about them [18]. For instance, one can reason about when a program will commit or abort, and about whether a program preserves integrity constraints. <p> Transaction Datalog is derived from this Horn fragment by restricting it to relational databases and to rules without function symbols (i:e:, just as classical Datalog is derived from classical Horn logic). Transaction Datalog thus inherits the semantics of the full logic, which has been published elsewhere <ref> [14, 16, 13, 19] </ref>. However, because Transaction Datalog is a specialized system, it has a specialized semantics, which is simpler than the more-general semantics of the full logic. This paper develops the simplified semantics in terms of a logical inference system. <p> Like classical Datalog, TD has both a declarative semantics and an equivalent operational semantics. The declarative semantics includes a logical model theory and sound-and-complete inference system. The operational semantics includes an SLD-style proof procedure in the logic-programming tradition <ref> [14, 16, 13, 19, 15] </ref>. This procedure executes transactions and updates the database as it proves theorems. Transaction Datalog is a minimal language based on a few simple operations. However, these operations lead directly to a wide range of transactional and programming capabilities. <p> In particular, the database can contain structures and access methods designed for efficient communication. For instance, some relations in the database could be a view of a set of message queues or communication channels, as described in <ref> [16] </ref>. 10 The first rule defines the top-level process, which immediately splits into two subprocesses, called processA and processB. The two subprocesses execute concurrently, but not independently. <p> The second rule halts the recursion after all the tuples have been deleted from relation r, i:e:, after n 1 recursive calls 2 3 Syntax and Semantics Recall that Transaction Datalog is a fragment of Transaction Logic, which is a general logic of state change <ref> [14, 16, 13, 19, 15] </ref>. Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof procedures, which have been published elsewhere [14, 16, 13, 19]. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. <p> Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof procedures, which have been published elsewhere <ref> [14, 16, 13, 19] </ref>. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. The simplification comes from restricting Transaction Logic to relational databases and Horn-like rules without function symbols (in much the same way that classical Datalog is a restriction of classical logic). <p> The simplified semantics is based on a logical inference system that describes the legal execution traces of a TD program. It should also be mentioned that Transaction Logic (and thus Transaction Datalog) has an operational semantics based on a proof procedure with unification <ref> [16, 15, 13] </ref>. This procedure executes transactions, updates the database, and generates query answers, all as a result of proving theorems. Transactional features such as abort, rollback, and save-points are also handled by the proof procedure. <p> The development is based on a logical inference system that specifies the legal execution traces of a TD program. In <ref> [16] </ref>, an equivalent, model-theoretic semantics is developed, along with a practical proof procedure based on unification. The inference system below manipulates expressions of the form P : D ` , called sequents. <p> : D 1 ` 1 P : D 2 ` 2 if D 3 is the concatenation of D 1 and D 2 . 3 In contrast to Transaction Datalog, the semantics of Transaction Logic is defined with respect to an infinite data domain, including both constant and function symbols <ref> [14, 16, 13, 15] </ref>. In this more-general setting, value invention is possible, and safety is guaranteed by syntactic restrictions. 16 5. Concurrent Composition: P : D 1 ` 1 P : D 2 ` 2 if D 3 is an interleaving of D 1 and D 2 . 6. <p> For instance, to simulate some non-classical transaction models, we must augment TD with negation-as-failure, as mentioned earlier. In addition, a complete treatment must deal with several other issues, including non-relational databases and legacy systems. Many of these issues are dealt with in the more general framework of Transaction Logic <ref> [14, 16, 13, 19, 15] </ref>. Transaction Datalog is a fragment of Transaction Logic. We have focussed on this fragment because it captures many essential properties of the general logic in a simpler setting. <p> First, they extend the logic programming paradigm with a host of transactional notions, including atomicity, isolation, rollback, and subtransaction hierarchies. Second, they integrate concurrency, communication and updates into a purely logical framework, including a natural model theory and a sound-and-complete proof theory <ref> [16] </ref>. This integration presents interesting possibilities for concurrent logic programming (CLP). For instance, concurrent processes can now communicate via the database, since one process can read what another process writes. This form of communication leads to a programming style that is very different from that of existing CLP languages [64]. <p> Examples 2.1, 2.7 and 4.1 are towards the data-oriented end of the spectrum, while Examples 2.4, 2.5 and 4.2 are towards the process-oriented end, and Example 2.2 is in the middle. A comparison of Transaction Logic and the recently developed pi calculus [53, 54] can be found in <ref> [16] </ref>. Concurrent Dynamic Logic: In [61, 60], Peleg develops Concurrent Dynamic Logic (CDL). There are two versions of CDL. The version developed in [61] is very different from TD. <p> In TD, states are relational databases that can be queried and updated. In contrast, CDL focuses on the internal states of executing programs, while the notion of a database state is entirely missing. Acknowledgements: Transaction Logic was developed in collaboration with Michael Kifer <ref> [14, 16, 13, 19, 15] </ref>. Thanks go to David Toman and Michael Kifer for their comments on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: [17] <author> A.J. Bonner and M. Kifer. </author> <title> A logic for programming database transactions. </title> <editor> In J. Chomicki and G. Saake, editors, </editor> <booktitle> Logics for Databases and Information Systems, chapter 5, </booktitle> <pages> pages 117-166. </pages> <publisher> Kluwer Academic Publishers, </publisher> <month> March </month> <year> 1998. </year>
Reference-contexts: Detailed discussion of these works can be found in <ref> [17, 14, 15] </ref>. The coordination approach focuses on non-classical transactions. The problem is to develop a high-level language for combining a set of tasks into a larger application or software system. The focus is on relationships between tasks.
Reference: [18] <author> A.J. Bonner and M. Kifer. </author> <title> Results on reasoning about action in transaction logic. </title> <note> Submitted for Publication, </note> <year> 1998. </year>
Reference-contexts: Transaction Datalog is derived from a general logic of state change called Transaction Logic [14, 16, 13, 19, 15]. Transaction Logic allows users to express properties of transaction programs, and to reason about them <ref> [18] </ref>. For instance, one can reason about when a program will commit or abort, and about whether a program preserves integrity constraints. In addition, like classical logic, Transaction Logic has a "Horn" fragment with both a procedural and declarative semantics.
Reference: [19] <author> A.J. Bonner, M. Kifer, and M. Consens. </author> <title> Database programming in transaction logic. </title> <editor> In A. Ohori C. Beeri and D.E. Shasha, editors, </editor> <booktitle> Proceedings of the International Workshop on Database Programming Languages, Workshops in Computing, </booktitle> <pages> pages 309-337. </pages> <publisher> Springer-Verlag, </publisher> <month> February </month> <year> 1994. </year> <booktitle> Workshop held on Aug 30-Sept 1, 1993, </booktitle> <address> New York City, NY. </address>
Reference-contexts: In addition, it provides a smooth integration of procedural and declarative programming, and in the absence of updates, it reduces to classical Datalog. Transaction Datalog is derived from a general logic of state change called Transaction Logic <ref> [14, 16, 13, 19, 15] </ref>. Transaction Logic allows users to express properties of transaction programs, and to reason about them [18]. For instance, one can reason about when a program will commit or abort, and about whether a program preserves integrity constraints. <p> Transaction Datalog is derived from this Horn fragment by restricting it to relational databases and to rules without function symbols (i:e:, just as classical Datalog is derived from classical Horn logic). Transaction Datalog thus inherits the semantics of the full logic, which has been published elsewhere <ref> [14, 16, 13, 19] </ref>. However, because Transaction Datalog is a specialized system, it has a specialized semantics, which is simpler than the more-general semantics of the full logic. This paper develops the simplified semantics in terms of a logical inference system. <p> Like classical Datalog, TD has both a declarative semantics and an equivalent operational semantics. The declarative semantics includes a logical model theory and sound-and-complete inference system. The operational semantics includes an SLD-style proof procedure in the logic-programming tradition <ref> [14, 16, 13, 19, 15] </ref>. This procedure executes transactions and updates the database as it proves theorems. Transaction Datalog is a minimal language based on a few simple operations. However, these operations lead directly to a wide range of transactional and programming capabilities. <p> The second rule halts the recursion after all the tuples have been deleted from relation r, i:e:, after n 1 recursive calls 2 3 Syntax and Semantics Recall that Transaction Datalog is a fragment of Transaction Logic, which is a general logic of state change <ref> [14, 16, 13, 19, 15] </ref>. Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof procedures, which have been published elsewhere [14, 16, 13, 19]. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. <p> Transaction Datalog therefore inherits the semantics of Transaction Logic, including its model theory and proof procedures, which have been published elsewhere <ref> [14, 16, 13, 19] </ref>. For convenience, this section develops a simplified version of that semantics, specialized for Transaction Datalog. The simplification comes from restricting Transaction Logic to relational databases and Horn-like rules without function symbols (in much the same way that classical Datalog is a restriction of classical logic). <p> For instance, to simulate some non-classical transaction models, we must augment TD with negation-as-failure, as mentioned earlier. In addition, a complete treatment must deal with several other issues, including non-relational databases and legacy systems. Many of these issues are dealt with in the more general framework of Transaction Logic <ref> [14, 16, 13, 19, 15] </ref>. Transaction Datalog is a fragment of Transaction Logic. We have focussed on this fragment because it captures many essential properties of the general logic in a simpler setting. <p> In TD, states are relational databases that can be queried and updated. In contrast, CDL focuses on the internal states of executing programs, while the notion of a database state is entirely missing. Acknowledgements: Transaction Logic was developed in collaboration with Michael Kifer <ref> [14, 16, 13, 19, 15] </ref>. Thanks go to David Toman and Michael Kifer for their comments on this paper. This work was supported in part by a Research Grant from the Natural Sciences and Engineering Research Council of Canada (NSERC).
Reference: [20] <author> F. Bry. </author> <title> Intensional updates: Abduction via deduction. </title> <booktitle> In Intl. Conference on Logic Programming, </booktitle> <address> Jerusalem, Israel, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [3, 2, 1], the procedural language QL of Chandra and Harel [23, 24], 4 Dynamic Prolog [50, 73], LDL [57, 58], and numerous other languages (e:g:, <ref> [20, 25, 62, 22, 30] </ref>). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions. The problem is to develop a high-level language for combining a set of tasks into a larger application or software system.
Reference: [21] <author> O. Bukhres and E. Kueshn, Eds. </author> <title> Special issue on software support for work flow management. </title> <journal> Distributed and Parallel Databases|An International Journal, </journal> <volume> 3(2), </volume> <month> April </month> <year> 1995. </year>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes <ref> [32, 40, 39, 10, 42, 34, 21, 43, 45] </ref>. These applications require new transaction models, new methods of transaction management, and new transaction languages [32, 40, 39, 29]. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes.
Reference: [22] <author> M.A. Casanova. </author> <title> The Concurrency Control Problem for Database Systems, </title> <booktitle> volume 116 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, Heidelberg, New York, </address> <year> 1981. </year>
Reference-contexts: Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [3, 2, 1], the procedural language QL of Chandra and Harel [23, 24], 4 Dynamic Prolog [50, 73], LDL [57, 58], and numerous other languages (e:g:, <ref> [20, 25, 62, 22, 30] </ref>). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions. The problem is to develop a high-level language for combining a set of tasks into a larger application or software system.
Reference: [23] <author> A.K. Chandra and D. Harel. </author> <title> Computable queries for relational databases. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21(2) </volume> <pages> 156-178, </pages> <year> 1980. </year>
Reference-contexts: Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored. These issues have been studied extensively in the context of classical 4 transactions and database queries (e:g:, <ref> [23, 24, 70, 2, 3, 1] </ref>). The challenge is to extend this theory to non-classical transactions. This paper takes a first step. 1.2 Transaction Datalog In this paper, we propose a logic-based approach to the problems of specifying non-classical transactions. <p> These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [3, 2, 1], the procedural language QL of Chandra and Harel <ref> [23, 24] </ref>, 4 Dynamic Prolog [50, 73], LDL [57, 58], and numerous other languages (e:g:, [20, 25, 62, 22, 30]). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions.
Reference: [24] <author> A.K. Chandra and D. Harel. </author> <title> Structure and complexity of relational queries. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 25(1) </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored. These issues have been studied extensively in the context of classical 4 transactions and database queries (e:g:, <ref> [23, 24, 70, 2, 3, 1] </ref>). The challenge is to extend this theory to non-classical transactions. This paper takes a first step. 1.2 Transaction Datalog In this paper, we propose a logic-based approach to the problems of specifying non-classical transactions. <p> These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [3, 2, 1], the procedural language QL of Chandra and Harel <ref> [23, 24] </ref>, 4 Dynamic Prolog [50, 73], LDL [57, 58], and numerous other languages (e:g:, [20, 25, 62, 22, 30]). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions.
Reference: [25] <author> W. Chen. </author> <title> Declarative updates of relational databases. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 20(1) </volume> <pages> 42-70, </pages> <month> March </month> <year> 1995. </year>
Reference-contexts: Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [3, 2, 1], the procedural language QL of Chandra and Harel [23, 24], 4 Dynamic Prolog [50, 73], LDL [57, 58], and numerous other languages (e:g:, <ref> [20, 25, 62, 22, 30] </ref>). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions. The problem is to develop a high-level language for combining a set of tasks into a larger application or software system.
Reference: [26] <author> P.K. Chrysanthis and K. Ramamritham. </author> <title> Synthesis of extended transaction models using ACTA. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 19(3) </volume> <pages> 450-491, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Unfortunately, although some programming languages have been implemented and others have been proposed, their theoretical foundations are incomplete. In general, the theory of non-classical transactions has focussed on transaction management (e:g:, <ref> [8, 49, 74, 26, 6] </ref>), not on transaction languages. For instance, there has been no attempt to integrate relational algebra and relational updates into a language for transaction composition. Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored. <p> Typically, these languages model a classical transaction as a finite automaton with a small number of states such as "start," "commit" and "abort." Temporal constraints between the states of different automata are then specified in a propositional logic. Developments in this area include ACTA <ref> [26, 27] </ref>, proposals for Third Generation TP Monitors [29], approaches based on temporal logic [6] and event algebras [66, 65], and numerous other works (e:g:, [46, 36]). In this paper, we addressed both issues, and integrated them into a single language.
Reference: [27] <author> P.K. Chrysanthis and K. Ramamrithm. </author> <title> ACTA: The SAGA continues. </title> <booktitle> In [32], chapter 10, </booktitle> <pages> pages 349-397. </pages> <year> 1992. </year>
Reference-contexts: Typically, these languages model a classical transaction as a finite automaton with a small number of states such as "start," "commit" and "abort." Temporal constraints between the states of different automata are then specified in a propositional logic. Developments in this area include ACTA <ref> [26, 27] </ref>, proposals for Third Generation TP Monitors [29], approaches based on temporal logic [6] and event algebras [66, 65], and numerous other works (e:g:, [46, 36]). In this paper, we addressed both issues, and integrated them into a single language.
Reference: [28] <author> G. Copeland and D. Maier. </author> <title> Making smalltalk a database system. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 316-325, </pages> <address> Boston, MA, </address> <month> June </month> <year> 1984. </year>
Reference-contexts: The result is that Transaction Datalog avoids many of the problems of embedded SQL, such as the infamous "impedance mismatch" problem <ref> [28, 7, 62] </ref>. Of course, Transaction Datalog can also compose transactions and define nested transactions, which goes well beyond the capabilities of embedded SQL. 2 Overview of Transaction Datalog This section introduces Transaction Datalog informally through a series of simple examples.
Reference: [29] <author> U. Dayal, H. Garcia-Molina, M. Hsu, B. Kao, and M.-C. Shan. </author> <title> Third generation TP monitors: A database challenge. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 393-397, </pages> <address> Washington, DD, </address> <month> May </month> <year> 1993. </year>
Reference-contexts: Such applications combine database transactions, application programs, and other activities into larger information systems and business processes [32, 40, 39, 10, 42, 34, 21, 43, 45]. These applications require new transaction models, new methods of transaction management, and new transaction languages <ref> [32, 40, 39, 29] </ref>. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. In particular, we argue that logic provides a natural basis for such languages. The main contribution is a new deductive language called Transaction Datalog (abbreviated TD). <p> The focus has therefore been on systems issues such as concurrency control and recovery, locking protocols, distributed commit and abort, fault tolerance, scheduling, implementation and performance. In addition to new methods of transaction management, new transaction languages are also needed <ref> [29] </ref>. These languages must deal both with conventional programming issues and with transactional issues. For instance, they must allow transaction programs to be combined sequentially, concurrently, and hierarchically. In addition, they must deal with persistent data and with transaction abort, rollback, atomicity, and isolation. <p> We shall refer to these two approaches as specification and coordination, respectively. In software-engineering terms, these two approaches correspond to "programming in the small" and "programming in the large," respectively <ref> [31, 29] </ref>. The specification approach implicitly focuses on classical transactions. The problem is to develop a high-level language for specifying database queries and updates, and to establish its theoretical properties, such as formal semantics, data complexity, and expressive power. Numerous languages with logical, algebraic and procedural semantics have been developed. <p> Developments in this area include ACTA [26, 27], proposals for Third Generation TP Monitors <ref> [29] </ref>, approaches based on temporal logic [6] and event algebras [66, 65], and numerous other works (e:g:, [46, 36]). In this paper, we addressed both issues, and integrated them into a single language.
Reference: [30] <author> C. de Maindreville and E. Simon. </author> <title> Non-deterministic queries and updates in deductive databases. </title> <booktitle> In Intl. Conference on Very Large Data Bases. </booktitle> <publisher> Morgan Kaufmann, </publisher> <address> San Francisco, CA, </address> <year> 1988. </year>
Reference-contexts: Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [3, 2, 1], the procedural language QL of Chandra and Harel [23, 24], 4 Dynamic Prolog [50, 73], LDL [57, 58], and numerous other languages (e:g:, <ref> [20, 25, 62, 22, 30] </ref>). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions. The problem is to develop a high-level language for combining a set of tasks into a larger application or software system.
Reference: [31] <author> F. DeRemer and H.H. Kron. </author> <title> Programming-in-the-large versus programming-in-the-small. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-2(2):80-86, </volume> <month> June </month> <year> 1976. </year>
Reference-contexts: We shall refer to these two approaches as specification and coordination, respectively. In software-engineering terms, these two approaches correspond to "programming in the small" and "programming in the large," respectively <ref> [31, 29] </ref>. The specification approach implicitly focuses on classical transactions. The problem is to develop a high-level language for specifying database queries and updates, and to establish its theoretical properties, such as formal semantics, data complexity, and expressive power. Numerous languages with logical, algebraic and procedural semantics have been developed.
Reference: [32] <editor> A.K. Elmagarmid, editor. </editor> <title> Database Transaction Models for Advanced Applications. </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes <ref> [32, 40, 39, 10, 42, 34, 21, 43, 45] </ref>. These applications require new transaction models, new methods of transaction management, and new transaction languages [32, 40, 39, 29]. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. <p> Such applications combine database transactions, application programs, and other activities into larger information systems and business processes [32, 40, 39, 10, 42, 34, 21, 43, 45]. These applications require new transaction models, new methods of transaction management, and new transaction languages <ref> [32, 40, 39, 29] </ref>. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. In particular, we argue that logic provides a natural basis for such languages. The main contribution is a new deductive language called Transaction Datalog (abbreviated TD). <p> Related papers on Transaction Logic, a prototype implementation, and the results of benchmark tests are available at the Transaction Logic web-page: http:// www.cs.toronto.edu/~bonner/transaction-logic.html 2 1.1 Background The limitations of the classical transaction model are well-documented in the literature (e:g:, <ref> [39, 55, 40, 32] </ref>). One important limitation is that this model does not support the composition of transaction programs. For instance, database transactions are usually defined by embedding SQL commands within a host programming language. <p> Such dependencies are typical of many new database applications, in which transactions participate in a complex web of relations. These new applications require the 3 development of new transaction models. This need has been eloquently expressed by Jim Gray <ref> [32, page xvii] </ref>: The transaction concept has emerged as the key structuring technique for distributed data and distributed computations. Originally developed and applied to database applications, the transaction model is now being used in new application areas ranging from process control to cooperative work. <p> Many new transaction models have been proposed in the literature. Nested Transactions were the first [55, 40]. More recent models include Sagas [37], ConTracts [72], Flex Transactions [33], Cooperative Transactions [59], Multi-Level Transactions and Open Nested Transactions [75], among others <ref> [32] </ref>. Much of the research on these models emphasizes transaction management. The focus has therefore been on systems issues such as concurrency control and recovery, locking protocols, distributed commit and abort, fault tolerance, scheduling, implementation and performance.
Reference: [33] <author> A.K. Elmagarmid, Y. Leu, W. Litwin, and M. Rusinkiewcz. </author> <title> A multidatabase transaction model for interbase. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 507-518, </pages> <address> Brisbane, Australia, </address> <month> August 13-16 </month> <year> 1990. </year>
Reference-contexts: Many new transaction models have been proposed in the literature. Nested Transactions were the first [55, 40]. More recent models include Sagas [37], ConTracts [72], Flex Transactions <ref> [33] </ref>, Cooperative Transactions [59], Multi-Level Transactions and Open Nested Transactions [75], among others [32]. Much of the research on these models emphasizes transaction management. The focus has therefore been on systems issues such as concurrency control and recovery, locking protocols, distributed commit and abort, fault tolerance, scheduling, implementation and performance.
Reference: [34] <editor> A. Elmagarmid, Ed. </editor> <title> Special issue on unconventional transaction management. </title> <journal> Bulletin of the Technical Committee on Data Engineering (IEEE Computer Society), </journal> <volume> 14(1), </volume> <month> June </month> <year> 1991. </year>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes <ref> [32, 40, 39, 10, 42, 34, 21, 43, 45] </ref>. These applications require new transaction models, new methods of transaction management, and new transaction languages [32, 40, 39, 29]. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes.
Reference: [35] <author> J.L. Eppinger, L.B. Mummert, and A.Z. Spector. Camelot and Avalon: </author> <title> A Distributed Transaction Facility. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1991. </year>
Reference-contexts: In addition, Transactional-C is a commercial programming language for the Encina TP monitor, which provides full support for nested transactions [68]. Likewise, a number of research projects have developed programming languages for nested transactions <ref> [48, 35] </ref> and other non-classical transaction models [72, 56, 71]. Unfortunately, although some programming languages have been implemented and others have been proposed, their theoretical foundations are incomplete. In general, the theory of non-classical transactions has focussed on transaction management (e:g:, [8, 49, 74, 26, 6]), not on transaction languages.
Reference: [36] <author> H. Garcia-Molina, D. Gawlick, J. Klein, K. Kleissner, and K. Salem. </author> <title> Coordinating multi-transaction activities. </title> <type> Technical Report TR-247-90, </type> <institution> Princeton University, </institution> <year> 1990. </year>
Reference-contexts: Developments in this area include ACTA [26, 27], proposals for Third Generation TP Monitors [29], approaches based on temporal logic [6] and event algebras [66, 65], and numerous other works (e:g:, <ref> [46, 36] </ref>). In this paper, we addressed both issues, and integrated them into a single language.
Reference: [37] <author> H. Garcia-Molina and K. Salem. Sagas. </author> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 249-259, </pages> <month> May </month> <year> 1987. </year> <month> 27 </month>
Reference-contexts: Many new transaction models have been proposed in the literature. Nested Transactions were the first [55, 40]. More recent models include Sagas <ref> [37] </ref>, ConTracts [72], Flex Transactions [33], Cooperative Transactions [59], Multi-Level Transactions and Open Nested Transactions [75], among others [32]. Much of the research on these models emphasizes transaction management.
Reference: [38] <author> D. Georgakopoulos, M. Hornick, and A. Sheth. </author> <title> An overview of workflow management: From process modeling to infrastructure for automation. </title> <journal> Journal on Distributed and Parallel Database Systems, </journal> <volume> 3(2) </volume> <pages> 119-153, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Intuitively, a workflow is a network of concurrent activities whose execution must be coordinated <ref> [38] </ref>. Ensuring their proper coordination and timely execution is known as workflow management. In so-called production workflows, activities are organized into factory-like production lines [45]. Many production workflows are organized around work items of some kind, which the workflow activities operate on.
Reference: [39] <author> J. Gray. </author> <title> The transaction concept: Virtues and limitations. </title> <booktitle> In Intl. Conference on Very Large Data Bases, </booktitle> <pages> pages 144-154, </pages> <address> Cannes, France, </address> <month> September </month> <year> 1981. </year>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes <ref> [32, 40, 39, 10, 42, 34, 21, 43, 45] </ref>. These applications require new transaction models, new methods of transaction management, and new transaction languages [32, 40, 39, 29]. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. <p> Such applications combine database transactions, application programs, and other activities into larger information systems and business processes [32, 40, 39, 10, 42, 34, 21, 43, 45]. These applications require new transaction models, new methods of transaction management, and new transaction languages <ref> [32, 40, 39, 29] </ref>. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. In particular, we argue that logic provides a natural basis for such languages. The main contribution is a new deductive language called Transaction Datalog (abbreviated TD). <p> Related papers on Transaction Logic, a prototype implementation, and the results of benchmark tests are available at the Transaction Logic web-page: http:// www.cs.toronto.edu/~bonner/transaction-logic.html 2 1.1 Background The limitations of the classical transaction model are well-documented in the literature (e:g:, <ref> [39, 55, 40, 32] </ref>). One important limitation is that this model does not support the composition of transaction programs. For instance, database transactions are usually defined by embedding SQL commands within a host programming language.
Reference: [40] <author> J. Gray and A. Reuter. </author> <title> Transaction Processing: Concepts and Techniques. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes <ref> [32, 40, 39, 10, 42, 34, 21, 43, 45] </ref>. These applications require new transaction models, new methods of transaction management, and new transaction languages [32, 40, 39, 29]. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. <p> Such applications combine database transactions, application programs, and other activities into larger information systems and business processes [32, 40, 39, 10, 42, 34, 21, 43, 45]. These applications require new transaction models, new methods of transaction management, and new transaction languages <ref> [32, 40, 39, 29] </ref>. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. In particular, we argue that logic provides a natural basis for such languages. The main contribution is a new deductive language called Transaction Datalog (abbreviated TD). <p> Related papers on Transaction Logic, a prototype implementation, and the results of benchmark tests are available at the Transaction Logic web-page: http:// www.cs.toronto.edu/~bonner/transaction-logic.html 2 1.1 Background The limitations of the classical transaction model are well-documented in the literature (e:g:, <ref> [39, 55, 40, 32] </ref>). One important limitation is that this model does not support the composition of transaction programs. For instance, database transactions are usually defined by embedding SQL commands within a host programming language. <p> The first attempt to address this problem lead to the nested transaction model, in which a transaction can be composed of subtransactions <ref> [55, 40] </ref>. As a simple example, suppose we have a transaction program for withdrawing money from a bank account, and another for depositing money. <p> The concept must be made recursive, it must deal with concurrency within a transaction, it must relax the strict isolation among transactions, and it must deal more gracefully with failures. Many new transaction models have been proposed in the literature. Nested Transactions were the first <ref> [55, 40] </ref>. More recent models include Sagas [37], ConTracts [72], Flex Transactions [33], Cooperative Transactions [59], Multi-Level Transactions and Open Nested Transactions [75], among others [32]. Much of the research on these models emphasizes transaction management. <p> Like classical Datalog, Transaction Datalog can be embellished with negation-as-failure. When this is done, TD can simulate a number of different transaction models. For simplicity, though, this paper focuses on the negation-free version of the language, which is well-suited to specifying nested transactions <ref> [55, 40] </ref>. In this model, a transaction may be decomposed into subtransactions. <p> These subtransactions may execute serially or concurrently, and their effects are undone if the parent transaction aborts, even if the subtransactions have already committed. "Nested transactions provide a powerful mechanism for fine-tuning the scope of rollback in applications with a complex structure" <ref> [40] </ref>. Moreover, "there is a strong relationship between the concept of modularization in software engineering and the nested transaction mechanism" [40]. These properties make nested transactions ideal for distributed 5 applications, object-oriented databases, and layered software systems [75, 4, 5, 55]. Numer--ous examples in this paper deal with nested transactions. <p> if the parent transaction aborts, even if the subtransactions have already committed. "Nested transactions provide a powerful mechanism for fine-tuning the scope of rollback in applications with a complex structure" <ref> [40] </ref>. Moreover, "there is a strong relationship between the concept of modularization in software engineering and the nested transaction mechanism" [40]. These properties make nested transactions ideal for distributed 5 applications, object-oriented databases, and layered software systems [75, 4, 5, 55]. Numer--ous examples in this paper deal with nested transactions. <p> When the transaction base is implicit, we sometimes refer to the goal as a program. A transaction program is a program whose main procedure executes in isolation, i:e:, has the form fi. In the literature <ref> [9, 40] </ref>, a transaction is a particular execution of a transaction program. This paper uses the same definition, but when there is no confusion, we sometimes use "transaction" as an abbreviation for "transaction program." 3.2 Execution Traces Concurrency in Transaction Datalog has an interleaving semantics.
Reference: [41] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1985. </year>
Reference-contexts: Process Algebras: These are a family of algebraic systems for modeling concurrent communicating processes. They include Milner's Calculus of Communicating Systems (CCS) [51], and Hoare's Communicating Sequential Processes (CSP) <ref> [41] </ref>, among others. Transaction Datalog and process algebras use very different formal frameworks. This difference is most easily seen in terms of COSY [47], an early algebraic approach to modeling concurrent processes. COSY is an extension of regular expressions, while Transaction Dat-alog is an extension of deductive databases.
Reference: [42] <author> M. Hsu, Ed. </author> <title> Special issue on workflow and extended transaction systems. </title> <journal> Bulletin of the Technical Committee on Data Engineering (IEEE Computer Society), </journal> <volume> 16(2), </volume> <month> June </month> <year> 1993. </year>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes <ref> [32, 40, 39, 10, 42, 34, 21, 43, 45] </ref>. These applications require new transaction models, new methods of transaction management, and new transaction languages [32, 40, 39, 29]. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes.
Reference: [43] <author> M. Hsu, </author> <title> Ed. </title> <journal> Special issue on workflow systems. Bulletin of the Technical Committee on Data Engineering (IEEE Computer Society), </journal> <volume> 18(1), </volume> <month> March </month> <year> 1995. </year>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes <ref> [32, 40, 39, 10, 42, 34, 21, 43, 45] </ref>. These applications require new transaction models, new methods of transaction management, and new transaction languages [32, 40, 39, 29]. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes.
Reference: [44] <author> Samuel Y.K. Hung. </author> <title> Implementation and Performance of Transaction Logic in Prolog. </title> <type> Master's thesis, </type> <institution> Department of Computer Science, University of Toronto, </institution> <year> 1996. </year> <note> http:// www.cs.toronto.edu/~bonner/transaction-logic.html. </note>
Reference-contexts: This procedure executes transactions, updates the database, and generates query answers, all as a result of proving theorems. Transactional features such as abort, rollback, and save-points are also handled by the proof procedure. This procedure is the foundation of our implementation <ref> [44] </ref>. 3.1 Syntax The language of Transaction Datalog includes three infinite enumerable sets of symbols: constant symbols (a; b; c; :::), variables (X; Y; Z; :::), and predicate symbols (p; q; r; :::).
Reference: [45] <author> Setrag Khoshafian and Marek Buckiewicz. </author> <title> Introduction to Groupware, Workflow, and Workgroup Computing. </title> <publisher> John Wiley & Sons, Inc., </publisher> <year> 1995. </year>
Reference-contexts: Examples include CAD, office automation, collaborative work, manufacturing control, and workflow management. Such applications combine database transactions, application programs, and other activities into larger information systems and business processes <ref> [32, 40, 39, 10, 42, 34, 21, 43, 45] </ref>. These applications require new transaction models, new methods of transaction management, and new transaction languages [32, 40, 39, 29]. This paper focuses on the latter issue: languages for specifying non-classical transactions, and for combining them into complex processes. <p> Intuitively, a workflow is a network of concurrent activities whose execution must be coordinated [38]. Ensuring their proper coordination and timely execution is known as workflow management. In so-called production workflows, activities are organized into factory-like production lines <ref> [45] </ref>. Many production workflows are organized around work items of some kind, which the workflow activities operate on. Examples of work items include insurance claims, loan applications, and laboratory samples.
Reference: [46] <author> J. Klein. </author> <title> Advanced rule-driven transaction management. </title> <booktitle> In IEEE COMPCON. IEEE, </booktitle> <year> 1991. </year>
Reference-contexts: Developments in this area include ACTA [26, 27], proposals for Third Generation TP Monitors [29], approaches based on temporal logic [6] and event algebras [66, 65], and numerous other works (e:g:, <ref> [46, 36] </ref>). In this paper, we addressed both issues, and integrated them into a single language.
Reference: [47] <author> P.E. Lauer and R.H. Campbell. </author> <title> Formal semantics of a class of high-level primitives for co-ordinating concurrent processes. </title> <journal> Acta Informatica, </journal> <volume> 5 </volume> <pages> 297-332, </pages> <year> 1975. </year>
Reference-contexts: They include Milner's Calculus of Communicating Systems (CCS) [51], and Hoare's Communicating Sequential Processes (CSP) [41], among others. Transaction Datalog and process algebras use very different formal frameworks. This difference is most easily seen in terms of COSY <ref> [47] </ref>, an early algebraic approach to modeling concurrent processes. COSY is an extension of regular expressions, while Transaction Dat-alog is an extension of deductive databases. Process algebras have since developed into equational theories, but the formal differences with TD remain the same.
Reference: [48] <author> B. Liskov. </author> <title> Distributed programming in Argus. </title> <journal> Communications of ACM, </journal> <volume> 31(3) </volume> <pages> 300-312, </pages> <year> 1988. </year>
Reference-contexts: In addition, Transactional-C is a commercial programming language for the Encina TP monitor, which provides full support for nested transactions [68]. Likewise, a number of research projects have developed programming languages for nested transactions <ref> [48, 35] </ref> and other non-classical transaction models [72, 56, 71]. Unfortunately, although some programming languages have been implemented and others have been proposed, their theoretical foundations are incomplete. In general, the theory of non-classical transactions has focussed on transaction management (e:g:, [8, 49, 74, 26, 6]), not on transaction languages.
Reference: [49] <author> N.A. Lynch. </author> <title> Multilevel atomicity: A new correctness criterion for database concurrency control. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 8(4) </volume> <pages> 484-502, </pages> <year> 1983. </year>
Reference-contexts: Unfortunately, although some programming languages have been implemented and others have been proposed, their theoretical foundations are incomplete. In general, the theory of non-classical transactions has focussed on transaction management (e:g:, <ref> [8, 49, 74, 26, 6] </ref>), not on transaction languages. For instance, there has been no attempt to integrate relational algebra and relational updates into a language for transaction composition. Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored.
Reference: [50] <author> S. Manchanda and D.S. Warren. </author> <title> A logic-based language for database updates. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 363-394. </pages> <publisher> Morgan-Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [3, 2, 1], the procedural language QL of Chandra and Harel [23, 24], 4 Dynamic Prolog <ref> [50, 73] </ref>, LDL [57, 58], and numerous other languages (e:g:, [20, 25, 62, 22, 30]). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions.
Reference: [51] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice Hall, </publisher> <year> 1989. </year>
Reference-contexts: Indeed, one of the novelties of TD is that it provides a logical foundation for exactly this 23 kind of interaction. Process Algebras: These are a family of algebraic systems for modeling concurrent communicating processes. They include Milner's Calculus of Communicating Systems (CCS) <ref> [51] </ref>, and Hoare's Communicating Sequential Processes (CSP) [41], among others. Transaction Datalog and process algebras use very different formal frameworks. This difference is most easily seen in terms of COSY [47], an early algebraic approach to modeling concurrent processes.
Reference: [52] <author> R. Milner. </author> <title> Operational and algebraic semantics of concurrent processes. </title> <booktitle> In [69], chapter 19, </booktitle> <pages> pages 1201-1242. </pages> <year> 1990. </year>
Reference-contexts: For instance, process algebras explicitly reject the notion of processes interacting via shared memory (such as a database) <ref> [52] </ref>. Instead, each process has its own local memory, and it interacts with other processes via synchronized communication. In contrast, Transaction Datalog is explicitly intended for database transactions, i:e:, processes that interact with a shared database.
Reference: [53] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, I. </title> <journal> Information and Computation, </journal> <volume> 100(1) </volume> <pages> 1-40, </pages> <month> September </month> <year> 1992. </year> <month> 28 </month>
Reference-contexts: Examples 2.1, 2.7 and 4.1 are towards the data-oriented end of the spectrum, while Examples 2.4, 2.5 and 4.2 are towards the process-oriented end, and Example 2.2 is in the middle. A comparison of Transaction Logic and the recently developed pi calculus <ref> [53, 54] </ref> can be found in [16]. Concurrent Dynamic Logic: In [61, 60], Peleg develops Concurrent Dynamic Logic (CDL). There are two versions of CDL. The version developed in [61] is very different from TD.
Reference: [54] <author> R. Milner, J. Parrow, and D. Walker. </author> <title> A calculus of mobile processes, II. </title> <journal> Information and Computation, </journal> <volume> 100(1) </volume> <pages> 41-77, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Examples 2.1, 2.7 and 4.1 are towards the data-oriented end of the spectrum, while Examples 2.4, 2.5 and 4.2 are towards the process-oriented end, and Example 2.2 is in the middle. A comparison of Transaction Logic and the recently developed pi calculus <ref> [53, 54] </ref> can be found in [16]. Concurrent Dynamic Logic: In [61, 60], Peleg develops Concurrent Dynamic Logic (CDL). There are two versions of CDL. The version developed in [61] is very different from TD.
Reference: [55] <author> J. E. B. Moss. </author> <title> Nested Transactions: An Approach to Reliable Distributed Computing. </title> <booktitle> Series in Information Systems. </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1985. </year>
Reference-contexts: Related papers on Transaction Logic, a prototype implementation, and the results of benchmark tests are available at the Transaction Logic web-page: http:// www.cs.toronto.edu/~bonner/transaction-logic.html 2 1.1 Background The limitations of the classical transaction model are well-documented in the literature (e:g:, <ref> [39, 55, 40, 32] </ref>). One important limitation is that this model does not support the composition of transaction programs. For instance, database transactions are usually defined by embedding SQL commands within a host programming language. <p> The first attempt to address this problem lead to the nested transaction model, in which a transaction can be composed of subtransactions <ref> [55, 40] </ref>. As a simple example, suppose we have a transaction program for withdrawing money from a bank account, and another for depositing money. <p> The concept must be made recursive, it must deal with concurrency within a transaction, it must relax the strict isolation among transactions, and it must deal more gracefully with failures. Many new transaction models have been proposed in the literature. Nested Transactions were the first <ref> [55, 40] </ref>. More recent models include Sagas [37], ConTracts [72], Flex Transactions [33], Cooperative Transactions [59], Multi-Level Transactions and Open Nested Transactions [75], among others [32]. Much of the research on these models emphasizes transaction management. <p> Like classical Datalog, Transaction Datalog can be embellished with negation-as-failure. When this is done, TD can simulate a number of different transaction models. For simplicity, though, this paper focuses on the negation-free version of the language, which is well-suited to specifying nested transactions <ref> [55, 40] </ref>. In this model, a transaction may be decomposed into subtransactions. <p> Moreover, "there is a strong relationship between the concept of modularization in software engineering and the nested transaction mechanism" [40]. These properties make nested transactions ideal for distributed 5 applications, object-oriented databases, and layered software systems <ref> [75, 4, 5, 55] </ref>. Numer--ous examples in this paper deal with nested transactions. In addition to transactional features, Transaction Datalog provides all the functionality of a declarative query language and a procedural programming language, seamlessly integrated.
Reference: [56] <author> J.G. Mullen and A.K. Elmagarmid. InterSQL: </author> <title> A multidatabase transaction programming language. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <pages> pages 399-416, </pages> <address> New York City, </address> <month> 30 Aug-1 Sept </month> <year> 1993. </year>
Reference-contexts: In addition, Transactional-C is a commercial programming language for the Encina TP monitor, which provides full support for nested transactions [68]. Likewise, a number of research projects have developed programming languages for nested transactions [48, 35] and other non-classical transaction models <ref> [72, 56, 71] </ref>. Unfortunately, although some programming languages have been implemented and others have been proposed, their theoretical foundations are incomplete. In general, the theory of non-classical transactions has focussed on transaction management (e:g:, [8, 49, 74, 26, 6]), not on transaction languages.
Reference: [57] <author> S. Naqvi and R. Krishnamurthy. </author> <title> Database updates in logic programming. </title> <booktitle> In ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 251-262, </pages> <address> New York, </address> <month> March </month> <year> 1988. </year> <note> ACM. </note>
Reference-contexts: These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [3, 2, 1], the procedural language QL of Chandra and Harel [23, 24], 4 Dynamic Prolog [50, 73], LDL <ref> [57, 58] </ref>, and numerous other languages (e:g:, [20, 25, 62, 22, 30]). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions.
Reference: [58] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Language for Data and Knowledge Bases. </title> <publisher> Computer Science Press, </publisher> <address> Rockville, MD, </address> <year> 1989. </year>
Reference-contexts: These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [3, 2, 1], the procedural language QL of Chandra and Harel [23, 24], 4 Dynamic Prolog [50, 73], LDL <ref> [57, 58] </ref>, and numerous other languages (e:g:, [20, 25, 62, 22, 30]). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions.
Reference: [59] <author> M. H. Nodine, S. Ramaswamy, and S. B. Zdonik. </author> <title> A cooperative transaction model for design databases. </title> <booktitle> In [32], chapter 3, </booktitle> <pages> pages 53-85. </pages> <year> 1992. </year>
Reference-contexts: Many new transaction models have been proposed in the literature. Nested Transactions were the first [55, 40]. More recent models include Sagas [37], ConTracts [72], Flex Transactions [33], Cooperative Transactions <ref> [59] </ref>, Multi-Level Transactions and Open Nested Transactions [75], among others [32]. Much of the research on these models emphasizes transaction management. The focus has therefore been on systems issues such as concurrency control and recovery, locking protocols, distributed commit and abort, fault tolerance, scheduling, implementation and performance.
Reference: [60] <author> D. Peleg. </author> <title> Communication in concurrent dynamic logic. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 35(1) </volume> <pages> 23-58, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: A comparison of Transaction Logic and the recently developed pi calculus [53, 54] can be found in [16]. Concurrent Dynamic Logic: In <ref> [61, 60] </ref>, Peleg develops Concurrent Dynamic Logic (CDL). There are two versions of CDL. The version developed in [61] is very different from TD. It is modeled on the kind of concurrency found in alternating Turing machines, which does not allow for communication between concurrent processes. <p> A deductive-database analogue of this version of CDL is Hypothetical Datalog [11], in which hypothetical databases represent the states of the various (non-communicating) concurrent processes in an alternating computation. The version of CDL developed in <ref> [60] </ref> does allow for communication, but only after adding considerable complexity to the semantics. In both versions of CDL, the meaning and intent of dynamic formulas is fundamentally 24 different from that of transaction formulas in TD.
Reference: [61] <author> D. </author> <title> Peleg. </title> <journal> Concurrent-dynamic logic. Journal of ACM, </journal> <volume> 34(2):450 - 479, </volume> <month> March </month> <year> 1987. </year>
Reference-contexts: A comparison of Transaction Logic and the recently developed pi calculus [53, 54] can be found in [16]. Concurrent Dynamic Logic: In <ref> [61, 60] </ref>, Peleg develops Concurrent Dynamic Logic (CDL). There are two versions of CDL. The version developed in [61] is very different from TD. It is modeled on the kind of concurrency found in alternating Turing machines, which does not allow for communication between concurrent processes. <p> A comparison of Transaction Logic and the recently developed pi calculus [53, 54] can be found in [16]. Concurrent Dynamic Logic: In [61, 60], Peleg develops Concurrent Dynamic Logic (CDL). There are two versions of CDL. The version developed in <ref> [61] </ref> is very different from TD. It is modeled on the kind of concurrency found in alternating Turing machines, which does not allow for communication between concurrent processes.
Reference: [62] <author> G. Phipps, M.A. Derr, and K.A. Ross. </author> <title> Glue-Nail: A deductive database system. </title> <booktitle> In ACM SIGMOD Conference on Management of Data, </booktitle> <pages> pages 308-317, </pages> <address> New York, 1991. </address> <publisher> ACM. </publisher>
Reference-contexts: The result is that Transaction Datalog avoids many of the problems of embedded SQL, such as the infamous "impedance mismatch" problem <ref> [28, 7, 62] </ref>. Of course, Transaction Datalog can also compose transactions and define nested transactions, which goes well beyond the capabilities of embedded SQL. 2 Overview of Transaction Datalog This section introduces Transaction Datalog informally through a series of simple examples. <p> Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [3, 2, 1], the procedural language QL of Chandra and Harel [23, 24], 4 Dynamic Prolog [50, 73], LDL [57, 58], and numerous other languages (e:g:, <ref> [20, 25, 62, 22, 30] </ref>). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions. The problem is to develop a high-level language for combining a set of tasks into a larger application or software system.
Reference: [63] <author> M. Rusinkiewicz and A. Sheth. </author> <title> Specification and execution of transactional workflows. </title> <editor> In W. Kim, editor, </editor> <title> Modern Database Systems: The Object Model, Interoperability, and Beyond. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: A typical control dependency is, "Task T2 cannot start until task T1 has committed;" and a typical data dependency is, "Task T2 can start if task T1 returns a value greater than 25" <ref> [63] </ref>. Specifying database updates and queries is not an issue here. Formally, the effects of tasks are abstracted away, and only the relationships between tasks are considered.
Reference: [64] <author> E. Shapiro. </author> <title> A family of concurrent logic programming languages. </title> <journal> ACM Computing Surveys, </journal> <volume> 21(3), </volume> <year> 1989. </year>
Reference-contexts: This integration presents interesting possibilities for concurrent logic programming (CLP). For instance, concurrent processes can now communicate via the database, since one process can read what another process writes. This form of communication leads to a programming style that is very different from that of existing CLP languages <ref> [64] </ref>. In such languages, concurrent processes communicate via shared variables and unification. This kind of communication is orthogonal to communication via the database. Both are possible in TD. Implementations of TD may therefore adopt many of the techniques of shared-variable communication developed for CLP.
Reference: [65] <author> M.P. Singh. </author> <title> Semantical considerations on workflows: An algebra for intertask dependencies. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <address> Gubbio, Umbria, Italy, </address> <month> September 6-8 </month> <year> 1995. </year>
Reference-contexts: Developments in this area include ACTA [26, 27], proposals for Third Generation TP Monitors [29], approaches based on temporal logic [6] and event algebras <ref> [66, 65] </ref>, and numerous other works (e:g:, [46, 36]). In this paper, we addressed both issues, and integrated them into a single language.
Reference: [66] <author> M.P. Singh. </author> <title> Synthesizing distributed constrained events from transactional workflow specifications. </title> <booktitle> In Proceedings of 12-th IEEE Intl. Conference on Data Engineering, </booktitle> <pages> pages 616-623, </pages> <address> New Orleans, LA, </address> <month> February </month> <year> 1996. </year>
Reference-contexts: Developments in this area include ACTA [26, 27], proposals for Third Generation TP Monitors [29], approaches based on temporal logic [6] and event algebras <ref> [66, 65] </ref>, and numerous other works (e:g:, [46, 36]). In this paper, we addressed both issues, and integrated them into a single language.
Reference: [67] <author> L. Stein, S. Rozen, and N. Goodman. </author> <title> Managing laboratory workflow with LabBase. </title> <booktitle> In Proceedings of the 1994 Conference on Computers in Medicine (CompMed94). </booktitle> <publisher> World Scientific Publishing Company, </publisher> <year> 1995. </year> <note> ftp://genome.wi.mit.edu/pub/papers/Y1995/ workflow.ps.Z. 29 </note>
Reference-contexts: The workflow model in the example is based on workflows at the Whitehead Institute/MIT Center for Genome Research, in which workflows are used to carry out the tens of millions of biological experiments needed to map and sequence the human genome <ref> [10, 67] </ref>. Example 4.2 (Workflow) Consider a workflow consisting of a sequence of three activities. The workflow processes a stream of work items. Each item is processed first by Activity 1, then by Activity 2, and finally by Activity 3.
Reference: [68] <author> Transarc-Encina. </author> <title> Encina Transactional Processing System: Transactional-C Program--mers Guide and Reference, </title> <institution> TP-00-D347. Transarc Corp., Pittsburg, </institution> <address> PA, </address> <year> 1991. </year>
Reference-contexts: For instance, some transaction programming languages offer save points, which support a limited form of nested transactions and partial rollback. In addition, Transactional-C is a commercial programming language for the Encina TP monitor, which provides full support for nested transactions <ref> [68] </ref>. Likewise, a number of research projects have developed programming languages for nested transactions [48, 35] and other non-classical transaction models [72, 56, 71]. Unfortunately, although some programming languages have been implemented and others have been proposed, their theoretical foundations are incomplete.
Reference: [69] <editor> J. van Leeuwen, editor. </editor> <booktitle> Handbook of Theoretical Computer Science, Volume B, Formal Methods and Semantics. </booktitle> <publisher> Elsevier, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference: [70] <author> M.Y. Vardi. </author> <title> The complexity of relational query languages. </title> <booktitle> In Proc. of 14th ACM Symposium on Theory of Computation, </booktitle> <pages> pages 137-146, </pages> <month> May </month> <year> 1982. </year>
Reference-contexts: Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored. These issues have been studied extensively in the context of classical 4 transactions and database queries (e:g:, <ref> [23, 24, 70, 2, 3, 1] </ref>). The challenge is to extend this theory to non-classical transactions. This paper takes a first step. 1.2 Transaction Datalog In this paper, we propose a logic-based approach to the problems of specifying non-classical transactions.
Reference: [71] <author> J. Veijalainen, F. Eliassen, and B. Holtkamp. </author> <title> The s-transaction model. </title> <note> In [32], chapter 12. </note> <year> 1992. </year>
Reference-contexts: In addition, Transactional-C is a commercial programming language for the Encina TP monitor, which provides full support for nested transactions [68]. Likewise, a number of research projects have developed programming languages for nested transactions [48, 35] and other non-classical transaction models <ref> [72, 56, 71] </ref>. Unfortunately, although some programming languages have been implemented and others have been proposed, their theoretical foundations are incomplete. In general, the theory of non-classical transactions has focussed on transaction management (e:g:, [8, 49, 74, 26, 6]), not on transaction languages.
Reference: [72] <author> H. Wachter and A. Reuter. </author> <title> The ConTract model. </title> <booktitle> In [32], chapter 7, </booktitle> <pages> pages 220-263. </pages> <year> 1992. </year>
Reference-contexts: In particular, they cannot be met by having application programmers specify transactions in a conventional programming language on top of a conventional DBMS (e:g:, by using SQL embedded in C, or even in concurrent C). As another example, consider the following abstract process, taken from <ref> [72] </ref>: Run Transaction T1. Then execute transactions T2, T3, and T4 in parallel. Immediately after their successful completion, start T5. But, if one of T2, T3, or T4 fails, then abort the other two. In this case, the effects of T1 have to be cancelled as well. <p> Many new transaction models have been proposed in the literature. Nested Transactions were the first [55, 40]. More recent models include Sagas [37], ConTracts <ref> [72] </ref>, Flex Transactions [33], Cooperative Transactions [59], Multi-Level Transactions and Open Nested Transactions [75], among others [32]. Much of the research on these models emphasizes transaction management. <p> In addition, Transactional-C is a commercial programming language for the Encina TP monitor, which provides full support for nested transactions [68]. Likewise, a number of research projects have developed programming languages for nested transactions [48, 35] and other non-classical transaction models <ref> [72, 56, 71] </ref>. Unfortunately, although some programming languages have been implemented and others have been proposed, their theoretical foundations are incomplete. In general, the theory of non-classical transactions has focussed on transaction management (e:g:, [8, 49, 74, 26, 6]), not on transaction languages.
Reference: [73] <author> D.S. Warren. </author> <title> Database Updates in Pure Prolog. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems, </booktitle> <pages> pages 244-253, </pages> <year> 1984. </year>
Reference-contexts: These languages therefore model a transaction as a mapping from databases to databases. Developments in this area include the procedural and declarative transaction languages of Abiteboul and Vianu [3, 2, 1], the procedural language QL of Chandra and Harel [23, 24], 4 Dynamic Prolog <ref> [50, 73] </ref>, LDL [57, 58], and numerous other languages (e:g:, [20, 25, 62, 22, 30]). Detailed discussion of these works can be found in [17, 14, 15]. The coordination approach focuses on non-classical transactions.
Reference: [74] <author> G. Weikum. </author> <title> Principles and realization strategies of multi-level transaction management. </title> <type> Technical Report DVSI-1987-T1, </type> <institution> Technical University of Darmstadt, Germany, </institution> <year> 1987. </year>
Reference-contexts: Unfortunately, although some programming languages have been implemented and others have been proposed, their theoretical foundations are incomplete. In general, the theory of non-classical transactions has focussed on transaction management (e:g:, <ref> [8, 49, 74, 26, 6] </ref>), not on transaction languages. For instance, there has been no attempt to integrate relational algebra and relational updates into a language for transaction composition. Likewise, issues such as declarative semantics, data complexity, and transaction expressibility have been completely ignored.
Reference: [75] <author> G. Weikum and H.-J. Schek. </author> <title> Concepts and applications of multilevel transactions and open nested transactions. </title> <booktitle> In [32], chapter 13, </booktitle> <pages> pages 515-553. </pages> <year> 1992. </year> <month> 30 </month>
Reference-contexts: Many new transaction models have been proposed in the literature. Nested Transactions were the first [55, 40]. More recent models include Sagas [37], ConTracts [72], Flex Transactions [33], Cooperative Transactions [59], Multi-Level Transactions and Open Nested Transactions <ref> [75] </ref>, among others [32]. Much of the research on these models emphasizes transaction management. The focus has therefore been on systems issues such as concurrency control and recovery, locking protocols, distributed commit and abort, fault tolerance, scheduling, implementation and performance. <p> Moreover, "there is a strong relationship between the concept of modularization in software engineering and the nested transaction mechanism" [40]. These properties make nested transactions ideal for distributed 5 applications, object-oriented databases, and layered software systems <ref> [75, 4, 5, 55] </ref>. Numer--ous examples in this paper deal with nested transactions. In addition to transactional features, Transaction Datalog provides all the functionality of a declarative query language and a procedural programming language, seamlessly integrated.
References-found: 75

