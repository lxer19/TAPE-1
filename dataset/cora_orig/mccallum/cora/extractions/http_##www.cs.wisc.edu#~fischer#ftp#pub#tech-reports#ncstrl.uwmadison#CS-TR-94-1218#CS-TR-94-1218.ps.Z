URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-94-1218/CS-TR-94-1218.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-94-1218/
Root-URL: http://www.cs.wisc.edu
Email: fwiener,naughtong@cs.wisc.edu  
Title: Bulk Loading into an OODB: A Performance Study  
Author: Janet L. Wiener Jeffrey F. Naughton 
Address: 1210 W. Dayton St., Madison, WI 53706  
Affiliation: Department of Computer Sciences University of Wisconsin-Madison  
Abstract: As object-oriented databases (OODB) attract an increasingly large community of users, these users bring with them large quantities of legacy data (hundreds and thousands of megabytes, and sometimes hundreds of gigabytes). In addition, scientific OODB users continually generate new data, often tens and hundreds of megabytes at a time. All this data must be loaded into the OODB. Every relational database system has a load utility, but nearly all OODBs do not. The process of loading data into an OODB is complicated by inter-object references, or relationships, in the data. These relationships are expressed in the OODB as object identifiers, which are not known at the time the load data is generated; they may contain cycles; and there may be implicit system-maintained inverse relationships that must also be stored. We introduce six algorithms for loading data into an OODB and present a performance study of them. The algorithms examine different techniques for dealing with circular and inverse relationships. Our performance study is based on both an analytic model and an implementation of all six algorithms on top of the Shore persistent object repository. We use the analytic model to explore a wide range of possible data and system configurations, and show that the implementation results strongly validate our analytic model. Our study demonstrates that it is important to choose a load algorithm carefully; in some cases the best algorithm achieved an improvement of one to two orders of magnitude over the naive algorithm.
Abstract-found: 1
Intro-found: 1
Reference: [Cat93] <author> R. G. G. Cattell, </author> <title> editor. The Object Database Standard: ODMG-93. </title> <publisher> Morgan-Kaufman, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1993. </year>
Reference-contexts: We describe several alternative resolution mechanisms in section 2. * Many OODB support system-maintained inverse relationships, sometimes called bidirectional relationships [Obj92, Ont92, Ver93, OHMS92, WI93]. In addition, inverse relationships are part of the ODMG standard <ref> [Cat93] </ref>. Inverse relationships are relationships that are maintained in both directions, so that an update to one direction of the relationship causes an update to the other. For example, suppose that object A has an inverse relationship with object B. <p> In this schema, each Experiment object has a relationship to an Input and an Output object. Figure 1 defines the schema in the Object Definition Language proposed by ODMG <ref> [Cat93] </ref>. 4 Input (temperature, humidity) f 102: 14.8, 87; g Experiment (scientist, input, output) f 1: "Lisa", 101, 201; 2: "Alex", 103, 202; 3: "Alex", 101, 203; g Output (plant growth) f 202: 1.75; g 2.2 Data file description The data file is an ascii text file describing the objects to
Reference: [CDF + 94] <author> M. Carey, D. DeWitt, M. Franklin, N. Hall, M. McAuliffe, J. Naughton, D. Schuh, M. Solomon, C. Tan, O. Tsatalos, S. White, and M. Zwilling. </author> <title> Shoring Up Persistent Applications. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <year> 1994. </year> <note> To appear. </note>
Reference-contexts: First, we built a simple analytic model to predict the performance of each algorithm. We used the analytic model to explore a wide range of load file and system configurations. We then implemented the algorithms on top of the Shore persistent object repository <ref> [CDF + 94] </ref>. The implementation not only validates our analytic model, the performance of the algorithms also highlights several key advantages and disadvantages of using logical object identifiers. Furthermore, our performance results show that one algorithm almost always outperforms all the others. <p> However, we were only able to use about 12 Mb for any test run, due to operating system and daemon memory requirements. The database was stored under the Shore storage manager <ref> [CDF + 94] </ref> on a raw Maxtor LXT-213SY disk controlled exclusively by Shore. The data file resided on a separate disk on the local file system, and thus did not interfere with the database I/O. For these tests, we turned logging off.
Reference: [CMR92] <author> J. B. Cushing, D. Maier, and M. Rao. </author> <title> Computational Proxies: Modeling Scientific Applications in Object Databases. </title> <type> Technical Report 92-020, </type> <institution> Oregon Graduate Institute, </institution> <month> December </month> <year> 1992. </year> <note> Revised May, </note> <year> 1993. </year>
Reference-contexts: Users are currently spending too much time and effort just loading the data they want to examine. For example, Cushing reports that loading the experimental data was the most time-consuming part of analyzing a set of computational chemistry experiments <ref> [CMR92] </ref>. In addition, we know of another commercial OODB customer who currently spends 36 hours loading a single set of new data every month. A load utility takes a description of all the data to be created, usually in text format, and loads the corresponding objects into the database.
Reference: [DLP + 93] <author> R. Drach, S. Louis, G. Potter, G. Richmond, D. Rotem, H. Samet, A. Segev, and A. Shoshani. </author> <title> Optimizing Mass Storage Organization and Access for Multi-Dimensional Scientific Data. </title> <booktitle> In Proceedings of the IEEE Symposium on Mass Storage Systems, </booktitle> <address> Monterey, CA, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: As an example, the climate modeling project at Lawrence Livermore National Laboratory has a very complex schema and generates single data points in the range of 20 to 150 Megabytes; a single data set typically contains 1 to 20 Gigabytes of data <ref> [DLP + 93] </ref>. Relational database systems provide a load utility to bypass the individual language statements; OODB need a similar facility. Users are currently spending too much time and effort just loading the data they want to examine.
Reference: [Mai] <author> David Maier. </author> <title> Private conversation, </title> <month> January 27, </month> <year> 1994. </year>
Reference-contexts: This is only possible with logical OIDs. We believe that any OODB that provides logical OIDs can also provide pre-assignment of OIDs; we know it is possible at the buffer manager level in GemStone <ref> [Mai] </ref> and in Ontos, as well as in Shore. 2.5 Creating inverse relationships Whenever we find a relationship from object A to object B that has an inverse, we know we need to store the inverse relationship, i.e., store the OID for A in object B.
Reference: [Moh93a] <author> C. Mohan. </author> <title> A Survey of DBMS Research Issues in Supporting Very Large Tables. </title> <booktitle> In Proceedings of the International Conference on Foundations of Data Organization and Algorithms, </booktitle> <address> Evanston, Il., </address> <year> 1993. </year>
Reference-contexts: A load utility takes a description of all the data to be created, usually in text format, and loads the corresponding objects into the database. Additionally, a load utility can group certain operations, such as integrity checks, to dramatically reduce their cost for the load <ref> [Moh93a] </ref>. Although a load utility is common in relational databases, we are aware of only one OODB load utility, in Objectivity/DB [Obj92], and it is limited in that it cannot load external data that does not already contain system-specific OIDs. <p> Since immediate inverse updates had unacceptable performance, we did not implement an unsorted inverse todo list. 8 integrity checking, it is known to be faster to load relations when integrity checking is deferred <ref> [Moh93a] </ref>. Duplicate integrity checks can be eliminated when processing the deferred checks, and the other integrity checks can be reordered to get better sequential I/O. DB2 has an option to defer integrity checking until the end of a load, and employs such optimizations [Moh93a]. <p> load relations when integrity checking is deferred <ref> [Moh93a] </ref>. Duplicate integrity checks can be eliminated when processing the deferred checks, and the other integrity checks can be reordered to get better sequential I/O. DB2 has an option to defer integrity checking until the end of a load, and employs such optimizations [Moh93a]. <p> The data file resided on a separate disk on the local file system, and thus did not interfere with the database I/O. For these tests, we turned logging off. It is important to be able to turn off logging when loading a lot of new data <ref> [Moh93a] </ref>; we found that when we used full logging, the log outgrew the database. It is unlikely that many users have enough extra disk space to accomodate such a log. We used Shore as the underlying persistent object manager even though Shore is still under development.
Reference: [Moh93b] <author> C. Mohan. </author> <title> IBM's Relational DBMS Products: Features and Technologies. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 445-448, </pages> <year> 1993. </year>
Reference-contexts: In both cases, when one tuple or object is loaded, another must be checked or updated. We discuss the similarity further in Section 2.5 when we describe techniqes for handling inverse relationships. Here we note that there are published techniques for smart handling of integrity checking <ref> [Moh93b] </ref>. The remainder of the paper is organized as follows. We present the loading algorithms in section 2. In Section 3 we describe the analytic cost model. <p> This was especially important for the algorithms that try to clear the todo list and inverse todo list. The implementors of DB2 similarly experienced significantly better performance when the load utility interacted directly with the buffer manager, instead of as a client <ref> [Moh93b] </ref>. However, there is nothing in the algorithms that prevents them from being implemented at the client level. Second, Shore provides logical OIDs, which we needed to test the assign-early algorithms. Exodus provides physical OIDs.
Reference: [Nel91] <author> G. Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: There are several published methods for mapping complex data structures to an ascii or binary file, and then reading it back in again. We based the data file format on that used by one such method called the Interface Description Language [Sno89]. Other methods include Pkl <ref> [Nel91] </ref> for Modula3 data, and Vegdahl's method for Smalltalk images [Veg86].
Reference: [Obj92] <institution> Objectivity, Inc. Objectivity/DB Documentation, </institution> <address> 2.0 edition, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: Additionally, a load utility can group certain operations, such as integrity checks, to dramatically reduce their cost for the load [Moh93a]. Although a load utility is common in relational databases, we are aware of only one OODB load utility, in Objectivity/DB <ref> [Obj92] </ref>, and it is limited in that it cannot load external data that does not already contain system-specific OIDs. <p> Therefore, the load utility must be able to resolve surrogate identifiers to objects that have not yet been created when the surrogate is first seen. We describe several alternative resolution mechanisms in section 2. * Many OODB support system-maintained inverse relationships, sometimes called bidirectional relationships <ref> [Obj92, Ont92, Ver93, OHMS92, WI93] </ref>. In addition, inverse relationships are part of the ODMG standard [Cat93]. Inverse relationships are relationships that are maintained in both directions, so that an update to one direction of the relationship causes an update to the other.
Reference: [OHMS92] <author> J. Orenstein, S. Haradhvala, B. Margulies, and D. Sakahara. </author> <title> Query Processing in the ObjectStore Database System. </title> <editor> In M. Stonebreaker, editor, </editor> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 403-412, </pages> <year> 1992. </year>
Reference-contexts: Therefore, the load utility must be able to resolve surrogate identifiers to objects that have not yet been created when the surrogate is first seen. We describe several alternative resolution mechanisms in section 2. * Many OODB support system-maintained inverse relationships, sometimes called bidirectional relationships <ref> [Obj92, Ont92, Ver93, OHMS92, WI93] </ref>. In addition, inverse relationships are part of the ODMG standard [Cat93]. Inverse relationships are relationships that are maintained in both directions, so that an update to one direction of the relationship causes an update to the other.
Reference: [Ont92] <author> Ontos, Inc. </author> <note> Ontos DB Reference Manual, release 2.2 edition, </note> <month> February </month> <year> 1992. </year>
Reference-contexts: Therefore, the load utility must be able to resolve surrogate identifiers to objects that have not yet been created when the surrogate is first seen. We describe several alternative resolution mechanisms in section 2. * Many OODB support system-maintained inverse relationships, sometimes called bidirectional relationships <ref> [Obj92, Ont92, Ver93, OHMS92, WI93] </ref>. In addition, inverse relationships are part of the ODMG standard [Cat93]. Inverse relationships are relationships that are maintained in both directions, so that an update to one direction of the relationship causes an update to the other.
Reference: [PG88] <author> N. W. Paton and P. M. D. Gray. </author> <title> Identification of Database Objects by Key. </title> <editor> In K. R. Dittrich, editor, </editor> <booktitle> Advances in Object-Oriented Database Systems: 2nd International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 280-285, </pages> <address> Berlin, Germany, </address> <month> September </month> <year> 1988. </year> <note> Springer-Verlag. </note>
Reference-contexts: In this example, all the surrogates are integers, and they are unique in the data file. However, in general, the surrogates may be strings or real numbers; if the class has a key they may even be part of the object's data <ref> [PG88] </ref>. The values for a set or list relationship are listed inside curly brackets. Strings are surrounded by 1 Loading from binary data files would be similar.
Reference: [Sho93] <author> A. Shoshani. </author> <title> A Layered Apporach to Scientific Data Management at Lawrence Berkeley Laboratory. </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 16(1) </volume> <pages> 4-8, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: Scientific applications generate a large volume of data with many complex associations in the information structure <ref> [Sho93] </ref>. It is not uncommon for a single experiment to have input and output parameters that number in the hundreds and thousands, and must be loaded into the OODB for each experiment.
Reference: [Sno89] <author> R. Snodgrass. </author> <title> The Interface Description Language: Definition and Use. </title> <publisher> Computer Science Press, </publisher> <year> 1989. </year>
Reference-contexts: There are several published methods for mapping complex data structures to an ascii or binary file, and then reading it back in again. We based the data file format on that used by one such method called the Interface Description Language <ref> [Sno89] </ref>. Other methods include Pkl [Nel91] for Modula3 data, and Vegdahl's method for Smalltalk images [Veg86].
Reference: [Veg86] <author> S. R. Vegdahl. </author> <title> Moving Structures between Smalltalk Images. </title> <booktitle> In Proceedings the International Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 466-471, </pages> <year> 1986. </year>
Reference-contexts: We based the data file format on that used by one such method called the Interface Description Language [Sno89]. Other methods include Pkl [Nel91] for Modula3 data, and Vegdahl's method for Smalltalk images <ref> [Veg86] </ref>.
Reference: [Ver93] <author> Versant Object Technology. </author> <title> Versant Object Database Management System C++Versant Manual, </title> <note> release 2 edition, </note> <month> July </month> <year> 1993. </year> <month> 25 </month>
Reference-contexts: Therefore, the load utility must be able to resolve surrogate identifiers to objects that have not yet been created when the surrogate is first seen. We describe several alternative resolution mechanisms in section 2. * Many OODB support system-maintained inverse relationships, sometimes called bidirectional relationships <ref> [Obj92, Ont92, Ver93, OHMS92, WI93] </ref>. In addition, inverse relationships are part of the ODMG standard [Cat93]. Inverse relationships are relationships that are maintained in both directions, so that an update to one direction of the relationship causes an update to the other.
Reference: [WI93] <author> J. L. Wiener and Y. Ioannidis. </author> <title> A Moose and a Fox Can Aid Scientists with Data Management Problems. </title> <booktitle> In Proceedings of the International Workshop on Database Programming Languages, </booktitle> <pages> pages 376-398, </pages> <address> New York, NY, 1993. </address> <publisher> Springer-Verlag. </publisher> <pages> 26 </pages>
Reference-contexts: Therefore, the load utility must be able to resolve surrogate identifiers to objects that have not yet been created when the surrogate is first seen. We describe several alternative resolution mechanisms in section 2. * Many OODB support system-maintained inverse relationships, sometimes called bidirectional relationships <ref> [Obj92, Ont92, Ver93, OHMS92, WI93] </ref>. In addition, inverse relationships are part of the ODMG standard [Cat93]. Inverse relationships are relationships that are maintained in both directions, so that an update to one direction of the relationship causes an update to the other. <p> We originally developed this data file format for the Moose object-oriented data model <ref> [WI93] </ref>, but it is generic enough to use for any object-oriented data model, and can easily be adapted to fit the output of a particular data generating program. Furthermore, any existing data file can easily be converted by a simple script to the data file format.
References-found: 17

