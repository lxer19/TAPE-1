URL: http://www.cs.utexas.edu/users/lavender/papers/oosi.ps
Refering-URL: http://www.cs.utexas.edu/users/lavender/papers/index.html
Root-URL: 
Email: g.lavender@isode.com  
Title: Using Polymorphic Types to Structure Flexible Protocol Stacks  
Author: R. Greg Lavender ISODE Consortium 
Note: To be submitted to ACM/IEEE Transactions on Networking  
Address: Park Drive Austin, Texas 78759  
Affiliation: 8920 Business  
Abstract: A new approach to structuring layered protocols using polymorphic service access points and type inheritance between protocol machines is presented. Polymorphic service access points facilitate the flexible instantiation of protocol machines containing the minimal functionality required by an application. The type inheritance structure is induced by a vertical partitioning of the upper layers of the ISO Reference Model, resulting in a non-monolithic protocol stack that supports concurrent object-oriented applications, such as Actor systems. The results presented represent a modest contribution to the research and practice of advanced protocol development. The type structures introduced demonstrate to software engineers, particularly those developing layered systems software, that object-oriented programming techniques facilitate and enhance the implementation of layered architectures. In addition, the results presented provide justification for object-oriented language designers that polymorphic and extensible type structures are useful for efficiently implementing layered communication protocol architectures.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Mark B. Abbott and Larry L. Peterson. </author> <title> A language-based approach to protocol implementation. </title> <booktitle> In SIGCOMM'92 Conference Proceedings, </booktitle> <pages> pages 27-38, </pages> <year> 1992. </year>
Reference-contexts: The Morpheus protocol development framework <ref> [1] </ref> and the OTSO protocol development framework [38, 39, 65] are both object-oriented approaches to structuring layered protocols.
Reference: [2] <author> Gul Agha and Christian J. Callsen. Actorspace: </author> <title> An open distributed programming paradigm. </title> <booktitle> In Principles and Practice of Parallel Programming Conference Proceedings, </booktitle> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: Merging both viewpoints leads to the following definition. An open system is a potentially open-ended, incremental, and evolutionary system relying on standard interconnection protocols for intercommunication among distributed, possibly heterogeneous, computational objects. Agha <ref> [2] </ref> recently proposed the concept of an ActorSpace as a paradigm for distributed groups of actors. Conceptually, the ActorSpace has a purpose similar to the Linda Tuple Space model [20] for cooperative work in parallel and distributed computing environments.
Reference: [3] <author> M. Stella Atkins. </author> <title> Experiments in SR with different upcall program structures. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(4) </volume> <pages> 365-392, </pages> <month> November </month> <year> 1988. </year>
Reference-contexts: The idea for structuring upward control flow in protocol implementations using upcalls originated with Clark [11]. From a programming methodology perspective, the upcall is perhaps the most important contribution to network programming to date. The utility of structuring protocol implementations using upcalls has already been demonstrated <ref> [3, 7] </ref>. Ideally, an asynchronous network event is scheduled as an independent thread of control that is used by the upcall to initiate an ordered sequence of operations upward through a protocol stack instance, starting at the virtual transport layer.
Reference: [4] <author> Brian N. Bershad. </author> <title> The increasing irrelevance of IPC performance for microkernel-based operating systems. </title> <booktitle> In Proceedings of the 1992 USENIX Workshop on Microkernels, </booktitle> <year> 1992. </year>
Reference-contexts: For this reason, the multiple process protocol stack approach is not a particularly good implementation technique for the monolithic protocol stack if high performance is required. One can argue, as Bershad does <ref> [4] </ref>, that inter-process communication performance is becoming less of an issue in new micro-kernel operating systems that support high-performance IPC/RPC. For example, Mach IPC is efficiently implemented using ports, memory objects, and continuations [18].
Reference: [5] <author> Kenneth P. Birman and Thomas A. Joseph. </author> <title> Exploiting virtual synchrony in distributed systems. </title> <booktitle> In Eleventh ACM Symposium on Operating System Principles, </booktitle> <pages> pages 123-86. </pages> <publisher> ACM, </publisher> <month> November </month> <year> 1987. </year>
Reference-contexts: The primary focus of this paper is on the type structure of a communications infrastructure that provides the basic peer-to-peer communications required by a variety of interaction models. The intent is not to introduce a group communication model such as the virtual synchrony model described by Birman <ref> [5] </ref> or the distributed process group model described by Cheriton [9]; but rather, to illustrate the application of type polymorphism and type inheritance to the structuring problems associated with layered peer-to-peer communication.
Reference: [6] <author> Frederick P. Brooks, Jr. </author> <title> No silver bullet: Essence and accidents of software engineering. </title> <booktitle> Computer, </booktitle> <pages> pages 10-19, </pages> <month> April </month> <year> 1987. </year>
Reference-contexts: The relevant issue is that data translation services must be provided in the upper layers so that arbitrary user-defined types may be constructed and exchanged as part of an association between heterogeneous peers. 7 Brooks <ref> [6] </ref> outlines the essence of general software construction, which suggests a structuralists approach. 9 * efficient synchronization of bidirectional, asynchronous, inter-layer control flow. * minimization of inter/intra-layer data manipulation. * flexible composition of functional subsets. The following subsections elaborate on each requirement.
Reference: [7] <author> David R. Cheriton. </author> <title> Exploiting recursion to simplify RPC communication architectures. </title> <booktitle> In SIG-COMM'88 Conference Proceedings, </booktitle> <pages> pages 76-87, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: The idea for structuring upward control flow in protocol implementations using upcalls originated with Clark [11]. From a programming methodology perspective, the upcall is perhaps the most important contribution to network programming to date. The utility of structuring protocol implementations using upcalls has already been demonstrated <ref> [3, 7] </ref>. Ideally, an asynchronous network event is scheduled as an independent thread of control that is used by the upcall to initiate an ordered sequence of operations upward through a protocol stack instance, starting at the virtual transport layer.
Reference: [8] <author> David R. Cheriton. </author> <title> The V distributed system. </title> <journal> Communications of the ACM, </journal> <volume> 31(3) </volume> <pages> 314-333, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: One can argue, as Bershad does [4], that inter-process communication performance is becoming less of an issue in new micro-kernel operating systems that support high-performance IPC/RPC. For example, Mach IPC is efficiently implemented using ports, memory objects, and continuations [18]. Other distributed operating systems, such as the V kernel <ref> [8] </ref>, the x-kernel [27], and Amoeba [46, 69] also provide high-performance IPC/RPC. The only significant advantage of a process-per-layer structuring approach is the degree of real concurrency that can be realized on a multi-processor architecture.
Reference: [9] <author> David R. Cheriton and Wally Zwaenepoel. </author> <title> Distributed process groups in the V kernel. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(2) </volume> <pages> 77-107, </pages> <month> May </month> <year> 1985. </year>
Reference-contexts: The intent is not to introduce a group communication model such as the virtual synchrony model described by Birman [5] or the distributed process group model described by Cheriton <ref> [9] </ref>; but rather, to illustrate the application of type polymorphism and type inheritance to the structuring problems associated with layered peer-to-peer communication.
Reference: [10] <author> David D. Clark. </author> <title> Modularity and efficiency in protocol implementation. Request For Comments RFC 817, Network Information Center, </title> <booktitle> SRI International, </booktitle> <month> July </month> <year> 1982. </year>
Reference-contexts: Clark makes the following comment regarding the conflict between structure and efficiency in protocol implementations <ref> [10, p. 1] </ref>: Modularity is one of the chief villains in attempting to obtain good performance, so that the designer is faced with a delicate and inevitable tradeoff between good structure and good performance.
Reference: [11] <author> David D. Clark. </author> <title> The structuring of systems using upcalls. </title> <booktitle> In Tenth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 171-180, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: The idea for structuring upward control flow in protocol implementations using upcalls originated with Clark <ref> [11] </ref>. From a programming methodology perspective, the upcall is perhaps the most important contribution to network programming to date. The utility of structuring protocol implementations using upcalls has already been demonstrated [3, 7].
Reference: [12] <author> David D. Clark, Van Jacobson, John Romkey, and Howard Salwen. </author> <title> An analysis of TCP processing overhead. </title> <journal> IEEE Communications Magazine, </journal> <pages> pages 23-29, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Research on the implementation and performance tuning of the Internet protocols has been done at the transport layer and below with regard to the tradeoff between structure and efficiency <ref> [12, 15, 70] </ref>. The experiences gained with the transport/network layer implementations in the Internet translate well to both the OSI lower layers and upper layers. In particular, protocol engineers know that excessive copying of data severely affects performance, as does intra-layer multiplexing [66]. <p> particular, over-generalization of the concept of a "layer" without regard to the specific functions performed by that layer may lead to an ill-conceived implementation that performs excessive copying of data and requires multiplexing of SAPs, both of which are known to have a highly negative impact on protocol machine performance <ref> [12] </ref>. The principal purpose of the SAP abstraction is to provide a point of entry for a specific application entity requesting a specific function offered by a service layer. <p> the case that arguments to an upcall procedure can be checked for type consistency since the invocation is accomplished through run-time dereferencing of a untyped or weakly-typed (e.g., void*) pointer. 3.3 Data Manipulation Excessive manipulation of data is perhaps the most significant contributor to poor performance in protocol machine implementations <ref> [12] </ref>. A upper layer protocol stack must be implemented in a manner 11 For example, the vtable in C ++ [19]. 12 that eliminates redundant manipulation of SDUs, PDUs, and the state information maintained by SAPs and PMs.
Reference: [13] <author> David D. Clark and David L. Tennenhouse. </author> <title> Architectural considerations for a new generation of protocols. </title> <booktitle> In SIGCOMM'90 Conference Proceedings, </booktitle> <pages> pages 200-208. </pages> <publisher> ACM, </publisher> <year> 1990. </year> <month> 39 </month>
Reference-contexts: Clark and Tennenhouse outline a set of requirements for this "new generation" of protocols with an emphasis on upper layer issues so that better overall protocol performance can be engineered <ref> [13] </ref>. As previously mentioned, the upper layers allow an application process to add structure to an otherwise unstructured communication channel. <p> The ultimate goal is to implement an upper layer protocol structure that "preserves the benefits of [layer] isolation, while increasing the range of implementation options available to end system designers" <ref> [13, p. 206] </ref>. Several perspectives exist on the problem of how to implement layered protocols in order to simultaneously gain modularity, efficiency, and compositional flexibility. At one extreme, the formalists might argue that correct and efficient protocol implementations should be automatically or semi-automatically generated from structured specifications.
Reference: [14] <author> Russel J. Clark, Mostafa H. Ammar, and Kenneth L. Calvert. </author> <title> Multi-protocol architectures as a paradigm for achieving inter-operability. </title> <type> Technical Report GIT-CC-92/36, </type> <institution> Georgia Institute of Technology, College of Computing, </institution> <year> 1992. </year>
Reference-contexts: about structuring layered protocol implementations so that good performance is obtained without casting aside good structuring principles and mechanisms, such as information hiding and ADTs? The structure-efficiency problem is further complicated by today's multi-protocol platforms that require flexible composition of protocols in order to meet the diverse needs of applications <ref> [14, 68] </ref>. The new thinking in protocol engineering is to be less myopic about the structure and performance of the lower layers in isolation and refocus on the structure and performance of the upper layers, with specific concern for the end-to-end needs of applications.
Reference: [15] <author> Douglas E. Comer. </author> <title> Internetworking with TCP/IP: Principles, Protocols, and Architecture. </title> <publisher> Prentice-Hall, </publisher> <year> 1988. </year>
Reference-contexts: Research on the implementation and performance tuning of the Internet protocols has been done at the transport layer and below with regard to the tradeoff between structure and efficiency <ref> [12, 15, 70] </ref>. The experiences gained with the transport/network layer implementations in the Internet translate well to both the OSI lower layers and upper layers. In particular, protocol engineers know that excessive copying of data severely affects performance, as does intra-layer multiplexing [66].
Reference: [16] <author> Douglas E. Comer and David L. Stevens. </author> <title> Internetworking with TCP/IP: Design, Implementation, and Internals. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: A practical obstacle is that the separation between the transport and network layers is not what one would think. Most TCP/IP implementations are closely integrated <ref> [16] </ref>; however, the streams-based approach to protocol implementation in Unix System V provides a model of separation that could support a vertically partitioned transport protocol structure.
Reference: [17] <author> Edsger W. Dijkstra. </author> <title> The structure of the `THE' multiprogramming system. </title> <journal> Communications of the ACM, </journal> <volume> 11(5) </volume> <pages> 341-346, </pages> <month> May </month> <year> 1968. </year>
Reference-contexts: Dijkstra is widely credited with an early application of hierarchical structuring to computer systems <ref> [17] </ref>. A layered partitioning of services provides a functional separation of concerns by defining a service at a layer n in terms of the services available at layer n 1.
Reference: [18] <author> Richard P. Draves, Brian N. Bershad, Richard F. Rashid, and Randall W. Dean. </author> <title> Using continuations to implement thread management and communication in operating systems. </title> <booktitle> In Thirteenth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 122-136, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: One can argue, as Bershad does [4], that inter-process communication performance is becoming less of an issue in new micro-kernel operating systems that support high-performance IPC/RPC. For example, Mach IPC is efficiently implemented using ports, memory objects, and continuations <ref> [18] </ref>. Other distributed operating systems, such as the V kernel [8], the x-kernel [27], and Amoeba [46, 69] also provide high-performance IPC/RPC. The only significant advantage of a process-per-layer structuring approach is the degree of real concurrency that can be realized on a multi-processor architecture.
Reference: [19] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: A upper layer protocol stack must be implemented in a manner 11 For example, the vtable in C ++ <ref> [19] </ref>. 12 that eliminates redundant manipulation of SDUs, PDUs, and the state information maintained by SAPs and PMs. Excessive data copying often arises in an implementation that over-generalizes the abstractions representing the protocol layers. <p> Stated another way, the functional units of the presentation service are type-based extensions of the functional units of the session service. It is natural then to treat the presentation service 23 A complete description of the syntax and semantics of virtual inheritance is found in <ref> [19] </ref>. 30 Table 2: Session Functional Subsets.
Reference: [20] <author> David Gelernter. </author> <title> Generative communication in linda. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 7(1) </volume> <pages> 80-113, </pages> <month> January </month> <year> 1985. </year>
Reference-contexts: Agha [2] recently proposed the concept of an ActorSpace as a paradigm for distributed groups of actors. Conceptually, the ActorSpace has a purpose similar to the Linda Tuple Space model <ref> [20] </ref> for cooperative work in parallel and distributed computing environments. Tomlinson [67] implemented a TreeSpace model in the Rosette language that is semantically a combination of the ActorSpace and Tuple Space models.
Reference: [21] <author> Carl Hewitt. </author> <title> Towards open information systems semantics. </title> <booktitle> Presented at the ECOOP-OOPSLA'90 Workshop on Object-Based Concurrency, </booktitle> <year> 1990. </year>
Reference-contexts: In semantic modeling and artificial intelligence, an open system denotes any collection of subsystems that are open-ended, incremental, and evolutionary [22]. A primary feature of this type of open system is the ability of its subsystems to communicate and interoperate using standard protocols. As defined by Hewitt <ref> [21] </ref>, an open information system is a particular kind of evolutionary open system based on the Actor model, that depends on standardized communication protocols. Merging both viewpoints leads to the following definition.
Reference: [22] <author> Carl Hewitt and Peter de Jong. </author> <title> Open systems. </title> <editor> In Michael L. Brodie, editor, </editor> <booktitle> On Conceptual Modeling, </booktitle> <pages> pages 147-164. </pages> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: Perhaps the term interoperable system is more descriptive since the primary objective is to achieve reliable interoperability among heterogeneous components. In semantic modeling and artificial intelligence, an open system denotes any collection of subsystems that are open-ended, incremental, and evolutionary <ref> [22] </ref>. A primary feature of this type of open system is the ability of its subsystems to communicate and interoperate using standard protocols.
Reference: [23] <author> Stephen P. Hufnagel. </author> <title> Vertically Partitioned Object-Oriented Software Design for Dependability and Good Performance. </title> <type> Ph.D. dissertation, </type> <institution> University of Texas, Austin, </institution> <month> January </month> <year> 1987. </year>
Reference-contexts: The new approach is based on a non-monolithic view of the protocol stack that is derived from a vertical partitioning of protocol machines, as depicted in Figure 6. Vertical partitioning has been shown to have a positive influence on performance <ref> [23, 24] </ref> and complements the principle of Integrated Layer Processing. A primary advantage of a vertically partitioned protocol stack is that it encourages a local synchronization policy, making it well suited to concurrent applications.
Reference: [24] <author> Stephen P. Hufnagel and James C. Browne. </author> <title> Performance properties of vertically partitioned object-oriented systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-15(8):935-946, </volume> <month> August </month> <year> 1989. </year>
Reference-contexts: In the case of a SAP, language scope rules associated with the ADT mechanism guarantee the necessary level of protection and are often efficiently realized. An important consideration is that if an abstraction representing an interface such as a SAP is subjected to over-generalization, then performance suffers <ref> [24] </ref>. Over-generalization occurs when algorithms or structures are generalized to the point at which the control logic for distinguishing specific cases obviates the benefit of the generalization. <p> The new approach is based on a non-monolithic view of the protocol stack that is derived from a vertical partitioning of protocol machines, as depicted in Figure 6. Vertical partitioning has been shown to have a positive influence on performance <ref> [23, 24] </ref> and complements the principle of Integrated Layer Processing. A primary advantage of a vertically partitioned protocol stack is that it encourages a local synchronization policy, making it well suited to concurrent applications.
Reference: [25] <author> Christian Huitema and Assem Doghri. </author> <title> Defining faster transfer syntaxes for the OSI presentation protocol. </title> <journal> ACM Computer Communication Review, </journal> <volume> 19(5) </volume> <pages> 44-55, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: An obvious assault on this problem is to define a more efficient encoding scheme, as was done by Huitema and Doghri <ref> [25, 26] </ref>. A more fundamental approach is proposed by Clark and Tennenhouse as part of the "new generation" thinking.
Reference: [26] <author> Christian Huitema and Assem Doghri. </author> <title> A high speed approach for the OSI presentation protocol. </title> <editor> In H. Rudin and R. Williamson, editors, </editor> <booktitle> Protocols for High-Speed Networks, </booktitle> <pages> pages 277-287. </pages> <address> Elsevier/North-Holland, </address> <year> 1989. </year>
Reference-contexts: An obvious assault on this problem is to define a more efficient encoding scheme, as was done by Huitema and Doghri <ref> [25, 26] </ref>. A more fundamental approach is proposed by Clark and Tennenhouse as part of the "new generation" thinking. <p> issue is the choice of the encoding rules and the flexibility with which different encodings rules can be employed by the presentation layer to encode/decode user data using the rules requested by the presentation user at connection establishment time; for example, the lightweight encoding rules proposed by Huitema and Doghri <ref> [26] </ref>. The independent protocol stack instances permitted by OOSI are ideally suited to supporting flexible bindings of different encoding rules.
Reference: [27] <author> Norman C. Hutchinson, Larry L. Peterson, Mark B. Abbott, and Sean O'Malley. </author> <title> RPC in the x-kernel: Evaluating new design techniques. </title> <booktitle> In Twelfth ACM Symposium on Operating System Principles, </booktitle> <pages> pages 91-101, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: For example, Mach IPC is efficiently implemented using ports, memory objects, and continuations [18]. Other distributed operating systems, such as the V kernel [8], the x-kernel <ref> [27] </ref>, and Amoeba [46, 69] also provide high-performance IPC/RPC. The only significant advantage of a process-per-layer structuring approach is the degree of real concurrency that can be realized on a multi-processor architecture. <p> Error (...); g ... 15 class TokenMgmt : public virtual Kernel, private virtual SPM::TokenMgmt f public: PsapAbort* PGiveTokenRequest (...); ... 20 class SyncMgmt : public virtual TokenMgmt, private virtual SPM::SyncMgmt f public: ... 25 g; The Morpheus framework is being done in conjunction with the x-kernel, a network-based operating system <ref> [27, 50] </ref>. Morpheus is an extension of previous x-kernel research on dynamic protocol machine configuration [47, 48]. Dynamic protocol machine configuration is one approach to providing a flexible protocol stack.
Reference: [28] <institution> IEEE Technical Committee on Operating Systems. Threads Extension for Portable Operating Systems, </institution> <month> February </month> <year> 1992. </year> <note> POSIX P1003.4a/D6. </note>
Reference-contexts: possibly blocking fl= 8 Assuming Berkeley Unix signal semantics [42], sigblock/sigsetmask to disable/enable interrupts. 9 It is important to distinguish between a real multi-threaded process model, as in Mach's task model and Solaris' lightweight process model, and a simulated one using a suitable user-level threads package such as POSIX threads <ref> [28] </ref>. 10 In at least one POSIX threads implementation [45], a thread will block but the I/O system call is made in non-blocking mode so that the entire process is not blocked.
Reference: [29] <author> International Organization for Standardization. </author> <title> Information Processing | Open Systems Interconnection | Transport Service Definition, </title> <note> 1986. ISO 8072 (CCITT X.214). </note>
Reference-contexts: Depending on the desired transport characteristics and the underlying subnetwork technology, the following combinations are prevalent: * Transmission Control Protocol [53] over the Internet Protocol [52] (TCP/IP). * User Datagram Protocol [51] over the Internet Protocol (UDP/IP). * Transport Protocol Class 4 <ref> [29, 30] </ref> over the Connectionless Network Protocol [31, 32] (TP4/CLNP). * Transport Protocol Class 0 [29, 30] over the X.25 connection-oriented network protocol [33, 34] (TP0/X.25). * TP0 over TCP via RFC 1006 [58]. 14 The virtual transport layer introduced previously in Figure 1 is specifically defined to deal with the <p> the underlying subnetwork technology, the following combinations are prevalent: * Transmission Control Protocol [53] over the Internet Protocol [52] (TCP/IP). * User Datagram Protocol [51] over the Internet Protocol (UDP/IP). * Transport Protocol Class 4 <ref> [29, 30] </ref> over the Connectionless Network Protocol [31, 32] (TP4/CLNP). * Transport Protocol Class 0 [29, 30] over the X.25 connection-oriented network protocol [33, 34] (TP0/X.25). * TP0 over TCP via RFC 1006 [58]. 14 The virtual transport layer introduced previously in Figure 1 is specifically defined to deal with the flexible instantiation of multiple transport/network protocol combinations while simultaneously using one or both of the
Reference: [30] <author> International Organization for Standardization. </author> <title> Information Processing | Open Systems Interconnection | Connection-oriented Transport Protocol Specification, </title> <note> 1986. ISO 8073 (CCITT X.224). </note>
Reference-contexts: Depending on the desired transport characteristics and the underlying subnetwork technology, the following combinations are prevalent: * Transmission Control Protocol [53] over the Internet Protocol [52] (TCP/IP). * User Datagram Protocol [51] over the Internet Protocol (UDP/IP). * Transport Protocol Class 4 <ref> [29, 30] </ref> over the Connectionless Network Protocol [31, 32] (TP4/CLNP). * Transport Protocol Class 0 [29, 30] over the X.25 connection-oriented network protocol [33, 34] (TP0/X.25). * TP0 over TCP via RFC 1006 [58]. 14 The virtual transport layer introduced previously in Figure 1 is specifically defined to deal with the <p> the underlying subnetwork technology, the following combinations are prevalent: * Transmission Control Protocol [53] over the Internet Protocol [52] (TCP/IP). * User Datagram Protocol [51] over the Internet Protocol (UDP/IP). * Transport Protocol Class 4 <ref> [29, 30] </ref> over the Connectionless Network Protocol [31, 32] (TP4/CLNP). * Transport Protocol Class 0 [29, 30] over the X.25 connection-oriented network protocol [33, 34] (TP0/X.25). * TP0 over TCP via RFC 1006 [58]. 14 The virtual transport layer introduced previously in Figure 1 is specifically defined to deal with the flexible instantiation of multiple transport/network protocol combinations while simultaneously using one or both of the
Reference: [31] <author> International Organization for Standardization. </author> <title> Information Processing | Data Communications | Addendum to the Network Service Definition Covering Connectionless-mode Transmission, 1987. ISO 8348/AD1. </title> <type> 40 </type>
Reference-contexts: Depending on the desired transport characteristics and the underlying subnetwork technology, the following combinations are prevalent: * Transmission Control Protocol [53] over the Internet Protocol [52] (TCP/IP). * User Datagram Protocol [51] over the Internet Protocol (UDP/IP). * Transport Protocol Class 4 [29, 30] over the Connectionless Network Protocol <ref> [31, 32] </ref> (TP4/CLNP). * Transport Protocol Class 0 [29, 30] over the X.25 connection-oriented network protocol [33, 34] (TP0/X.25). * TP0 over TCP via RFC 1006 [58]. 14 The virtual transport layer introduced previously in Figure 1 is specifically defined to deal with the flexible instantiation of multiple transport/network protocol combinations
Reference: [32] <author> International Organization for Standardization. </author> <title> Information Processing | Data Communications | Protocol for Providing The Connectionless-mode Network Service, 1987. </title> <type> ISO 8473. </type>
Reference-contexts: Depending on the desired transport characteristics and the underlying subnetwork technology, the following combinations are prevalent: * Transmission Control Protocol [53] over the Internet Protocol [52] (TCP/IP). * User Datagram Protocol [51] over the Internet Protocol (UDP/IP). * Transport Protocol Class 4 [29, 30] over the Connectionless Network Protocol <ref> [31, 32] </ref> (TP4/CLNP). * Transport Protocol Class 0 [29, 30] over the X.25 connection-oriented network protocol [33, 34] (TP0/X.25). * TP0 over TCP via RFC 1006 [58]. 14 The virtual transport layer introduced previously in Figure 1 is specifically defined to deal with the flexible instantiation of multiple transport/network protocol combinations
Reference: [33] <author> International Organization for Standardization. </author> <title> Information Processing | Data Communications | Network Service Definition, </title> <note> 1987. ISO 8348 (CCITT X.213). </note>
Reference-contexts: prevalent: * Transmission Control Protocol [53] over the Internet Protocol [52] (TCP/IP). * User Datagram Protocol [51] over the Internet Protocol (UDP/IP). * Transport Protocol Class 4 [29, 30] over the Connectionless Network Protocol [31, 32] (TP4/CLNP). * Transport Protocol Class 0 [29, 30] over the X.25 connection-oriented network protocol <ref> [33, 34] </ref> (TP0/X.25). * TP0 over TCP via RFC 1006 [58]. 14 The virtual transport layer introduced previously in Figure 1 is specifically defined to deal with the flexible instantiation of multiple transport/network protocol combinations while simultaneously using one or both of the common transport interface libraries.
Reference: [34] <author> International Organization for Standardization. </author> <title> Information Processing | Data Communications | Use of X.25 to Provide The Connection-mode Network Service, </title> <note> 1987. ISO 8878 (CCITT X.223). </note>
Reference-contexts: prevalent: * Transmission Control Protocol [53] over the Internet Protocol [52] (TCP/IP). * User Datagram Protocol [51] over the Internet Protocol (UDP/IP). * Transport Protocol Class 4 [29, 30] over the Connectionless Network Protocol [31, 32] (TP4/CLNP). * Transport Protocol Class 0 [29, 30] over the X.25 connection-oriented network protocol <ref> [33, 34] </ref> (TP0/X.25). * TP0 over TCP via RFC 1006 [58]. 14 The virtual transport layer introduced previously in Figure 1 is specifically defined to deal with the flexible instantiation of multiple transport/network protocol combinations while simultaneously using one or both of the common transport interface libraries.
Reference: [35] <author> International Organization for Standardization. </author> <title> Information Processing | Open Systems Interconnection | Basic Reference Model, 1987. </title> <type> ISO 7498. </type>
Reference-contexts: That is, each layer defines a communication service in terms of the services available at the next lower layer, down to the physical layer. In particular, the well-known ISO Reference Model for Open Systems Interconnection (OSI) defines a set of services and protocols for the interconnection of computer systems <ref> [35] </ref>. As depicted in Figure 1, the layered communication model is divided into the upper layers and the lower layers. The upper layers consist of all layers above the transport layer.
Reference: [36] <author> International Organization for Standardization. </author> <title> Information Processing | Open Systems Interconnection | Specification of Abstract Syntax Notation One (ASN.1), </title> <note> 1987. ISO 8824 (CCITT X.208). </note>
Reference-contexts: The structure is principally provided by presentation services that are used to represent and exchange application data using abstract types defined by a suitable representation language, such as Abstract Syntax Notation One (ASN.1) <ref> [36] </ref>. Other representation languages 8 are common; for example, the Interface Definition Language (IDL) [41] and the External Data Repre--sentation language (XDR) [43]. 6 An application will typically encode the data sent over a particular association into an appropriate transfer syntax.
Reference: [37] <author> International Organization for Standardization. </author> <title> Information Processing | Open Systems Interconnection | Specification of Basic Encoding Rules for Abstract Syntax Notation One, </title> <note> 1987. ISO 8825 (CCITT X.209). </note>
Reference-contexts: In general, the encoding and decoding of application data as part of normal data transfer is a memory intensive operation, which is exacerbated by bit stuffing and variable length encoding schemes, such as the Basic Encoding Rules (BER) <ref> [37] </ref>. An obvious assault on this problem is to define a more efficient encoding scheme, as was done by Huitema and Doghri [25, 26]. A more fundamental approach is proposed by Clark and Tennenhouse as part of the "new generation" thinking.
Reference: [38] <author> Juha Koivisto and Juhani Malka. </author> <title> OTSO|an object-oriented approach to distributed computation. </title> <booktitle> In USENIX C ++ Conference Proceedings, </booktitle> <pages> pages 163-177, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: The Morpheus protocol development framework [1] and the OTSO protocol development framework <ref> [38, 39, 65] </ref> are both object-oriented approaches to structuring layered protocols.
Reference: [39] <author> Juha Koivisto and James Reilly. </author> <title> Generating object-oriented telecommunications software using ASN.1 descriptions. </title> <booktitle> In Proceedings of the IFIP TC6/WG6.5 International Conference on Upper Layer Protocols, Architectures, and Applications, </booktitle> <month> May </month> <year> 1992. </year>
Reference-contexts: The Morpheus protocol development framework [1] and the OTSO protocol development framework <ref> [38, 39, 65] </ref> are both object-oriented approaches to structuring layered protocols.
Reference: [40] <author> Simon S. Lam. </author> <title> Protocol conversion. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(3) </volume> <pages> 353-362, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: is used as a connection-oriented network layer service to provide end-to-end reliability for the otherwise unreliable service offered by TP0, thereby enabling the use of the OSI upper layers over IP-based networks, such as the Internet [54]. 15 Lam provides a formal methodology for describing a general protocol conversion process <ref> [40] </ref>. 15 16 switching and data copying required for inter-process communication. An IPC is performed per layer for each request, indication, response, and confirmation event. Each IPC requires a context switch and copying of request arguments and a possible result from one address space to another.
Reference: [41] <author> David Alex Lamb. </author> <title> Idl: Sharing intermediate representations. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 9(3) </volume> <pages> 297-318, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: The structure is principally provided by presentation services that are used to represent and exchange application data using abstract types defined by a suitable representation language, such as Abstract Syntax Notation One (ASN.1) [36]. Other representation languages 8 are common; for example, the Interface Definition Language (IDL) <ref> [41] </ref> and the External Data Repre--sentation language (XDR) [43]. 6 An application will typically encode the data sent over a particular association into an appropriate transfer syntax. A transfer syntax commonly preserves type information and represents the data in a machine independent form.
Reference: [42] <author> Samuel J. Le*er, Marshall Kirk McKusick, Michael J. Karels, and John S. Quarterman. </author> <title> The Design and Implementation of the 4.3BSD UNIX Operating System. </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: A user thread may continue execution by binding the future result to a future object as follows: Psap psap; Future&lt;PSapIndication&gt; future = psap.PConnectRequest (...); . . . PSapIndication result = future; =fl obtain result, possibly blocking fl= 8 Assuming Berkeley Unix signal semantics <ref> [42] </ref>, sigblock/sigsetmask to disable/enable interrupts. 9 It is important to distinguish between a real multi-threaded process model, as in Mach's task model and Solaris' lightweight process model, and a simulated one using a suitable user-level threads package such as POSIX threads [28]. 10 In at least one POSIX threads implementation [45], <p> flexible upper layer protocol implementation is that the interface to the kernel based transport layer is via a programming library that generalizes the transport service interface. 13 The service interface generalization is required in order to gain some independence with respect to 13 For example in Unix, either Berkeley sockets <ref> [42] </ref> or the System V streams-based transport interface (TLI/XTI) [63, 64]. 14 multiple transport/network protocol combinations that may reside in the kernel.
Reference: [43] <author> Sun Microsystems. XDR: </author> <title> External data representation standard. Internet Protocol Specification RFC 1014, Network Information Center, </title> <booktitle> SRI International, </booktitle> <month> June </month> <year> 1987. </year>
Reference-contexts: Other representation languages 8 are common; for example, the Interface Definition Language (IDL) [41] and the External Data Repre--sentation language (XDR) <ref> [43] </ref>. 6 An application will typically encode the data sent over a particular association into an appropriate transfer syntax. A transfer syntax commonly preserves type information and represents the data in a machine independent form.
Reference: [44] <author> Jeffrey C. Mogul, Richard F. Rashid, and Michael J. Accetta. </author> <title> The packet filter: An efficient mechanism for user-level network code. </title> <booktitle> In Eleventh ACM Symposium on Operating System Principles, </booktitle> <pages> pages 39-51, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: local functions of an application entity are concerned with requesting remote operations from a peer application entity residing on another node, or implementing local operations that are made available for execution by a requesting peer. 1 Note that transport and network protocols can reside in user space as in Mach <ref> [44] </ref>. However, the Mach NetIPC implementation has better performance when kernel resident [49]. 2 The transport switching and conversion service is technically a session layer service, but it is useful to think of the switching and conversion functions as belonging to a separate "virtual" transport layer.
Reference: [45] <author> Frank Mueller. </author> <title> A library implementation of POSIX threads under Unix. </title> <booktitle> In Proceedings of the 1993 USENIX Winter Conference, </booktitle> <pages> pages 29-41, </pages> <month> January </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: [42], sigblock/sigsetmask to disable/enable interrupts. 9 It is important to distinguish between a real multi-threaded process model, as in Mach's task model and Solaris' lightweight process model, and a simulated one using a suitable user-level threads package such as POSIX threads [28]. 10 In at least one POSIX threads implementation <ref> [45] </ref>, a thread will block but the I/O system call is made in non-blocking mode so that the entire process is not blocked.
Reference: [46] <author> Sape J. Mullender, Guido van Rossum, Andrew S. Tanenbaum, and Robbert van Renesse. </author> <title> Amoeba: a distributed operating system for the 1990s. </title> <booktitle> Computer, </booktitle> <pages> pages 44-53, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: For example, Mach IPC is efficiently implemented using ports, memory objects, and continuations [18]. Other distributed operating systems, such as the V kernel [8], the x-kernel [27], and Amoeba <ref> [46, 69] </ref> also provide high-performance IPC/RPC. The only significant advantage of a process-per-layer structuring approach is the degree of real concurrency that can be realized on a multi-processor architecture.
Reference: [47] <author> Sean W. O'Malley and Larry L. Peterson. </author> <title> A new methodology for designing network software. </title> <type> Technical Report TR 90-29, </type> <institution> University of Arizona, Department of Computer Science, </institution> <month> September </month> <year> 1990. </year>
Reference-contexts: Morpheus is an extension of previous x-kernel research on dynamic protocol machine configuration <ref> [47, 48] </ref>. Dynamic protocol machine configuration is one approach to providing a flexible protocol stack. The primary advantage of a flexible protocol stack is that extraneous control machinery that is not needed for the service required by the connection is omitted at run-time, thereby minimizing wasted CPU cycles.
Reference: [48] <author> Sean W. O'Malley and Larry L. Peterson. </author> <title> A dynamic network architecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(10) </volume> <pages> 110-143, </pages> <month> May </month> <year> 1992. </year> <month> 41 </month>
Reference-contexts: Morpheus is an extension of previous x-kernel research on dynamic protocol machine configuration <ref> [47, 48] </ref>. Dynamic protocol machine configuration is one approach to providing a flexible protocol stack. The primary advantage of a flexible protocol stack is that extraneous control machinery that is not needed for the service required by the connection is omitted at run-time, thereby minimizing wasted CPU cycles.
Reference: [49] <author> H. Orman, E. Menze III, S. O'Malley, and L. Peterson. </author> <title> A fast and general implementation of Mach IPC in a network. </title> <booktitle> In Proceedings of the 1993 USENIX Mach Conference, </booktitle> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: However, the Mach NetIPC implementation has better performance when kernel resident <ref> [49] </ref>. 2 The transport switching and conversion service is technically a session layer service, but it is useful to think of the switching and conversion functions as belonging to a separate "virtual" transport layer.
Reference: [50] <author> Larry Peterson, Norman Hutchinson, Sean O'Malley, and Herman Rao. </author> <title> The x-kernel: A platform for accessing internet resources. </title> <booktitle> Computer, </booktitle> <pages> pages 23-33, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Error (...); g ... 15 class TokenMgmt : public virtual Kernel, private virtual SPM::TokenMgmt f public: PsapAbort* PGiveTokenRequest (...); ... 20 class SyncMgmt : public virtual TokenMgmt, private virtual SPM::SyncMgmt f public: ... 25 g; The Morpheus framework is being done in conjunction with the x-kernel, a network-based operating system <ref> [27, 50] </ref>. Morpheus is an extension of previous x-kernel research on dynamic protocol machine configuration [47, 48]. Dynamic protocol machine configuration is one approach to providing a flexible protocol stack.
Reference: [51] <author> John Postel. </author> <title> User datagram protocol. Internet Protocol Specification RFC 768, Network Information Center, </title> <booktitle> SRI International, </booktitle> <month> August </month> <year> 1980. </year>
Reference-contexts: Depending on the desired transport characteristics and the underlying subnetwork technology, the following combinations are prevalent: * Transmission Control Protocol [53] over the Internet Protocol [52] (TCP/IP). * User Datagram Protocol <ref> [51] </ref> over the Internet Protocol (UDP/IP). * Transport Protocol Class 4 [29, 30] over the Connectionless Network Protocol [31, 32] (TP4/CLNP). * Transport Protocol Class 0 [29, 30] over the X.25 connection-oriented network protocol [33, 34] (TP0/X.25). * TP0 over TCP via RFC 1006 [58]. 14 The virtual transport layer introduced
Reference: [52] <author> John Postel. </author> <title> Internet protocol. Internet Protocol Specification RFC 791, Network Information Center, </title> <booktitle> SRI International, </booktitle> <month> September </month> <year> 1981. </year>
Reference-contexts: Depending on the desired transport characteristics and the underlying subnetwork technology, the following combinations are prevalent: * Transmission Control Protocol [53] over the Internet Protocol <ref> [52] </ref> (TCP/IP). * User Datagram Protocol [51] over the Internet Protocol (UDP/IP). * Transport Protocol Class 4 [29, 30] over the Connectionless Network Protocol [31, 32] (TP4/CLNP). * Transport Protocol Class 0 [29, 30] over the X.25 connection-oriented network protocol [33, 34] (TP0/X.25). * TP0 over TCP via RFC 1006 [58].
Reference: [53] <author> John Postel. </author> <title> Transmission control protocol. Internet Protocol Specification RFC 793, Network Information Center, </title> <booktitle> SRI International, </booktitle> <month> September </month> <year> 1981. </year>
Reference-contexts: Depending on the desired transport characteristics and the underlying subnetwork technology, the following combinations are prevalent: * Transmission Control Protocol <ref> [53] </ref> over the Internet Protocol [52] (TCP/IP). * User Datagram Protocol [51] over the Internet Protocol (UDP/IP). * Transport Protocol Class 4 [29, 30] over the Connectionless Network Protocol [31, 32] (TP4/CLNP). * Transport Protocol Class 0 [29, 30] over the X.25 connection-oriented network protocol [33, 34] (TP0/X.25). * TP0 over
Reference: [54] <author> Marshall T. Rose. </author> <title> OSI transport services on top of the TCP. </title> <journal> Computer Networks and ISDN Systems, </journal> <volume> 12(3), </volume> <year> 1986. </year>
Reference-contexts: a significant performance penalty is incurred due to the cost of context 14 TCP/IP is used as a connection-oriented network layer service to provide end-to-end reliability for the otherwise unreliable service offered by TP0, thereby enabling the use of the OSI upper layers over IP-based networks, such as the Internet <ref> [54] </ref>. 15 Lam provides a formal methodology for describing a general protocol conversion process [40]. 15 16 switching and data copying required for inter-process communication. An IPC is performed per layer for each request, indication, response, and confirmation event. <p> Performance data is presented that shows the results of a performance analysis of the OOSI virtual transport layer operating over RFC 1006 <ref> [54] </ref>. The data reflects the comparison of OOSI with the ISODE RFC 1006 component and with raw TCP. The raw TCP data is provided to illustrate the best that can be done without the effects of the processing overhead introduced in both OOSI and ISODE in implementing RFC 1006.
Reference: [55] <author> Marshall T. Rose. </author> <title> ISO presentation services on top of TCP/IP-based internets. Internet Protocol Specification RFC 1085, Network Information Center, </title> <booktitle> SRI International, </booktitle> <month> December </month> <year> 1988. </year>
Reference-contexts: For example, the following fragment illustrates the instantiation of a generic Sap object that in turn instantiates a protocol machine that contains only a kernel functional unit: 22 For example, the lightweight presentation service, defined in RFC 1085 <ref> [55] </ref>, which bypasses the session service completely by mapping the presentation service directly onto a transport service. 23 template&lt;class T&gt; class Downcall f private: Semaphore* sem; =* system dependent semaphore type *= 5 public: =* construction = P (sem), destruction = V (sem) *= inline Downcall (T* pm) f sem =
Reference: [56] <author> Marshall T. Rose. </author> <title> The Open Book: A Practical Perspective on OSI. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: The general problems facing an implementor of an OSI protocol stack, such as multiplexing, PDU processing, etc., are outlined by Svobodova [62]. Rose gives a detailed treatment of the pragmatics of OSI using the ISO Development Environment (ISODE) as a reference implementation <ref> [56] </ref>. Research on the implementation and performance tuning of the Internet protocols has been done at the transport layer and below with regard to the tradeoff between structure and efficiency [12, 15, 70]. <p> Technically, the virtual transport layer is implemented by a hybrid protocol machine, often called a transport switch <ref> [56] </ref>, that allows the session service to bind a particular transport/network service combination at connection establishment time based on the quality of service and interoperability requirements of an application. <p> Each functional unit can be viewed as a micro-protocol that incrementally extends a basic kernel 27 protocol. The protocol definition is seemingly irrational, resulting in unnecessary technical complexity <ref> [56] </ref>. This complexity is primarily due to an attempt to keep the session protocol definition consistent with a pre-existing protocol definition rather than approaching the session layer problem from first principles. In this section, a rational approach to structuring the session protocol machine using inheritance is introduced.
Reference: [57] <author> Marshall T. Rose. </author> <title> The ISO Development Environment User's Manual, Volumes 1-5. </title> <booktitle> Performance Systems International, </booktitle> <month> July </month> <year> 1991. </year> <note> Version 7.0. </note>
Reference-contexts: It is generally more sensible to implement the entire upper layer structure in a single process and restrict IPC communication to only the user-kernel boundary at the virtual transport layer. The ISODE is a widely-used research implementation of the upper layer protocols <ref> [57] </ref>. Architecturally, ISODE is a single process, single threaded, monolithic protocol stack. In an ISODE application, only one application layer SAP is active at a time, so guaranteeing mutual exclusion simply requires prohibiting any upcalls from starting as the result of asynchronous network activity.
Reference: [58] <author> Marshall T. Rose and Dwight E. Cass. </author> <title> ISO transport services on top of the TCP. Internet Protocol Specification RFC 1006, Network Information Center, </title> <booktitle> SRI International, </booktitle> <month> May </month> <year> 1987. </year> <note> Version 3. </note>
Reference-contexts: [52] (TCP/IP). * User Datagram Protocol [51] over the Internet Protocol (UDP/IP). * Transport Protocol Class 4 [29, 30] over the Connectionless Network Protocol [31, 32] (TP4/CLNP). * Transport Protocol Class 0 [29, 30] over the X.25 connection-oriented network protocol [33, 34] (TP0/X.25). * TP0 over TCP via RFC 1006 <ref> [58] </ref>. 14 The virtual transport layer introduced previously in Figure 1 is specifically defined to deal with the flexible instantiation of multiple transport/network protocol combinations while simultaneously using one or both of the common transport interface libraries. <p> objects are created at run-time as part of a protocol stack instance: * a polymorphic mutex-enforcing SAP object. * a flexibly instantiated presentation/session protocol machine (PPM/SPM) object. * a flexibly instantiated virtual transport protocol machine (VTPM) object. 20 The unused reserved field in the RFC 1006 header could be used <ref> [58] </ref>. 21 OOSI is an acronym for objectified OSI. 22 template&lt;class T&gt; class Sap f private: T* pm; =* protocol machine subtype *= 5 public: inline Sap () f pm = new T (this); g inline ~Sap () f delete pm; g 10 inline Future&lt;SapIndication&gt; ConnectRequest (...) f Downcall&lt;T&gt; mutex (pm);
Reference: [59] <author> J. H. Saltzer, D. P. Reed, and D. D. Clark. </author> <title> End-to-end arguments in system design. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(4) </volume> <pages> 277-288, </pages> <month> November </month> <year> 1986. </year>
Reference-contexts: From the perspective of the application layer, communication issues such as flow control, bit error detection, and physical data transfer mechanisms are not typically of concern. As noted by Salzer, Reed, and Clark, end-to-end reliability issues permeate all layers <ref> [59] </ref>; however, modern transport protocols provide sufficient end-to-end reliability mechanisms for basic data transfer.
Reference: [60] <author> William L. Scherlis. </author> <title> Abstract data types, specialization, and program reuse. </title> <booktitle> In International Workshop on Advanced Programming Environments. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: A similar conclusion is echoed independently by Scherlis <ref> [60] </ref> with respect to structuring software for reuse using abstract data types.
Reference: [61] <author> Claude E. Shannon and Warren E. Weaver. </author> <title> The Mathematical Theory of Communication. </title> <publisher> University of Illinois Press, </publisher> <year> 1949. </year>
Reference-contexts: If a service request is for a confirmed service, the responder invokes a service response operation that is eventually received asynchronously by the initiator as a service confirm event. Confirm events effect layer state changes in the same manner as indication events. 5 Shannon <ref> [61] </ref> defined the basic theory, which is beyond the narrative scope of this work. 7 The layered model presents a desirable set of abstractions; however, the implementation of the protocol layers presents a challenge since protocols must be efficiently realized.
Reference: [62] <author> Liba Svobodova. </author> <title> Implementing OSI systems. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 7(7) </volume> <pages> 1115-1130, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: Alternatively, one might call this layer the transport convergence layer. 3 Adapted in part from Svobodova <ref> [62] </ref>. 5 There are three phases to an application association. In the connection establishment phase, an initiator performs a bind operation to establish an association with a responder. <p> Formal implementation agreements, or profiles, augment the basic specifications by providing implementation guidelines for those areas that are vague or left to interpretation. The general problems facing an implementor of an OSI protocol stack, such as multiplexing, PDU processing, etc., are outlined by Svobodova <ref> [62] </ref>. Rose gives a detailed treatment of the pragmatics of OSI using the ISO Development Environment (ISODE) as a reference implementation [56].
Reference: [63] <author> Unix Systems Laboratories Inc. </author> <title> Unix System V Release 4 Programmer's Guide: Networking Interfaces. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: to the kernel based transport layer is via a programming library that generalizes the transport service interface. 13 The service interface generalization is required in order to gain some independence with respect to 13 For example in Unix, either Berkeley sockets [42] or the System V streams-based transport interface (TLI/XTI) <ref> [63, 64] </ref>. 14 multiple transport/network protocol combinations that may reside in the kernel.
Reference: [64] <author> Unix Systems Laboratories Inc. </author> <title> Unix System V Release 4 Programmer's Guide: STREAMS. </title> <publisher> Prentice-Hall, </publisher> <year> 1990. </year>
Reference-contexts: to the kernel based transport layer is via a programming library that generalizes the transport service interface. 13 The service interface generalization is required in order to gain some independence with respect to 13 For example in Unix, either Berkeley sockets [42] or the System V streams-based transport interface (TLI/XTI) <ref> [63, 64] </ref>. 14 multiple transport/network protocol combinations that may reside in the kernel.
Reference: [65] <institution> Technical Research Center of Finland. </institution> <note> OTSO User's Guide, 1992. Version 1.1.5. </note>
Reference-contexts: The Morpheus protocol development framework [1] and the OTSO protocol development framework <ref> [38, 39, 65] </ref> are both object-oriented approaches to structuring layered protocols.
Reference: [66] <author> David L. Tennenhouse. </author> <title> Layered multiplexing considered harmful. </title> <editor> In H. Rudin and R. Williamson, editors, </editor> <booktitle> Protocols for High-Speed Networks, </booktitle> <pages> pages 143-158. </pages> <address> Elsevier/North-Holland, </address> <year> 1989. </year>
Reference-contexts: The experiences gained with the transport/network layer implementations in the Internet translate well to both the OSI lower layers and upper layers. In particular, protocol engineers know that excessive copying of data severely affects performance, as does intra-layer multiplexing <ref> [66] </ref>. In general, there has been little attention paid to the tradeoff between structure and efficiency in upper layer protocol implementations.
Reference: [67] <author> Chris Tomlinson, Greg Lavender, Greg Meredith, Darrell Woelk, and Phil Cannata. </author> <title> The Carnot extensible services switch (ESS) support for service execution. In Enterprise Integration Modeling: </title> <booktitle> Proceedings of the First International Conference. </booktitle> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: Agha [2] recently proposed the concept of an ActorSpace as a paradigm for distributed groups of actors. Conceptually, the ActorSpace has a purpose similar to the Linda Tuple Space model [20] for cooperative work in parallel and distributed computing environments. Tomlinson <ref> [67] </ref> implemented a TreeSpace model in the Rosette language that is semantically a combination of the ActorSpace and Tuple Space models.
Reference: [68] <author> Christian Tschudin. </author> <title> Flexible protocol stacks. </title> <booktitle> In SIGCOMM'91 Conference Proceedings, </booktitle> <pages> pages 197-205, </pages> <month> September </month> <year> 1991. </year> <month> 42 </month>
Reference-contexts: about structuring layered protocol implementations so that good performance is obtained without casting aside good structuring principles and mechanisms, such as information hiding and ADTs? The structure-efficiency problem is further complicated by today's multi-protocol platforms that require flexible composition of protocols in order to meet the diverse needs of applications <ref> [14, 68] </ref>. The new thinking in protocol engineering is to be less myopic about the structure and performance of the lower layers in isolation and refocus on the structure and performance of the upper layers, with specific concern for the end-to-end needs of applications.
Reference: [69] <author> Robert van Renesse, Hans van Staveren, and Andrew S. Tanenbaum. </author> <title> The performance of the Amoeba distributed operating system. </title> <journal> Software|Practice and Experience, </journal> <volume> 19 </volume> <pages> 223-234, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: For example, Mach IPC is efficiently implemented using ports, memory objects, and continuations [18]. Other distributed operating systems, such as the V kernel [8], the x-kernel [27], and Amoeba <ref> [46, 69] </ref> also provide high-performance IPC/RPC. The only significant advantage of a process-per-layer structuring approach is the degree of real concurrency that can be realized on a multi-processor architecture.
Reference: [70] <author> Richard W. Watson and Sandy A. Mamrak. </author> <title> Gaining efficiency in transport services by appropriate design and implementation choices. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(2) </volume> <pages> 97-120, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: Research on the implementation and performance tuning of the Internet protocols has been done at the transport layer and below with regard to the tradeoff between structure and efficiency <ref> [12, 15, 70] </ref>. The experiences gained with the transport/network layer implementations in the Internet translate well to both the OSI lower layers and upper layers. In particular, protocol engineers know that excessive copying of data severely affects performance, as does intra-layer multiplexing [66].
References-found: 70

