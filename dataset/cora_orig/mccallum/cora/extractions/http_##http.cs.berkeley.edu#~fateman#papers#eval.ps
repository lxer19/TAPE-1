URL: http://http.cs.berkeley.edu/~fateman/papers/eval.ps
Refering-URL: http://http.cs.berkeley.edu/~fateman/algebra.html
Root-URL: 
Title: Symbolic Mathematics System Evaluators  
Author: Richard J. Fateman 
Address: USA  
Affiliation: Computer Sciences Division Electrical Engineering and Computer Sciences Department University of California, Berkeley  
Abstract: Evaluation" of expressions and programs in a computer algebra system is central to every system, but inevitably fails to provide complete satisfaction. Here we explain the conflicting requirements, describe some solutions from current systems, and propose alternatives that might be preferable sometimes. We give examples primarily from Axiom, Mac-syma, Maple, Mathematica, with passing mention of a few other systems. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abdali, S. K., Cherry, G. W., and Soiffer, N. </author> <title> Spreadsheet computations in computer algebra. </title> <journal> ACM SIGSAM Bulletin 26, </journal> <month> 2 (Apr. </month> <year> 1992), </year> <pages> 10-18. </pages>
Reference-contexts: Then b [1,1]:0 changes the value of a as well as b. Another somewhat related question is how one would deal with evaluation in a matrix that is really a spreadsheet of formulas and values <ref> [1] </ref>. Traditional numerical programming languages do not have to deal with the gradations of levels of representation in a computer algebra system. In fact, the common programming term "function" for "subroutine returning a value" indicates the depth of mismatch between the mind-sets common in traditional programming and mathematics respectively. <p> But what if the computer system allows for such objects as 1 where 1 1 is arguably different from 0? What if a were an interval such as <ref> [0; 1] </ref> in which case a a is arguably the non-zero interval [1; 1]. <p> But what if the computer system allows for such objects as 1 where 1 1 is arguably different from 0? What if a were an interval such as [0; 1] in which case a a is arguably the non-zero interval <ref> [1; 1] </ref>. <p> In Macsyma, a similar notation for quoting operations is available so one can write a differential equation as 'diff (y,t)+f (t) = 0. For the quartic equation problem one could let s=solve (...) and then deal with `s <ref> [1] </ref> etc. without looking at the form of the solution. A hazard here is that one does not want to see|displayed| the quote-marks, suggesting the need for a slightly different but more visually similar "noun" operator for diff. <p> For example f (x) = x x and g (x) = 0 are a plausible pair: g has no occurrence of x and hence might be considered simpler. This equivalence is however false if the domain of valuation is that of interval arithmetic: if v = <ref> [1; 1] </ref> then v v is the interval [2; 2], not 0. A very appealing and generally achievable attribute of a good simplification program is idempotence. That is, simp (x)=simp (simp (x)) for all symbolic expressions x. <p> The assignment operation in most languages implicitly uses "evaluate to a name" on the left-hand side of the assignment. Consider the sequence i:=1, t [i]:=3, t [i]:=4. The left-hand side of the expression t [i]:=4 should be "evaluated" to the location for t <ref> [1] </ref>, not 3, and not t [i]. Maple's penchant for the use of side-effects for assigning values to extra variables makes an explicit version of this operation handy. Thus, divide (a,x+1,`q`) might test to see if x+1, divides exactly into the polynomial denoted by a.
Reference: [2] <author> Brownston, L., Farrell, R., Kant, E., and Martin, N. </author> <title> Programming Expert Systems in OPS5: An Introduction to Rule-Based Programming. </title> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: It is rarely convenient to use a completely declarative approach to specify a large computation. Early evidence from the expert-system building community suggests that constructing large systems by programming rules <ref> [2] </ref> may be even more difficult than construction via traditional imperative programming. 3. The unit of specification | rule application, is really a two part process. It requires pattern matching (usually a kind of graph-matching) in conjunction with checking of predicates on pattern-match variables. <p> This equivalence is however false if the domain of valuation is that of interval arithmetic: if v = [1; 1] then v v is the interval <ref> [2; 2] </ref>, not 0. A very appealing and generally achievable attribute of a good simplification program is idempotence. That is, simp (x)=simp (simp (x)) for all symbolic expressions x. It is intuitively appealing because if something is "already simplified" then it cannot "hurt" to try simplifying it again.
Reference: [3] <editor> Buchberger, B., Collins, G., Loos, R., and Al-brecht, R., Eds. </editor> <booktitle> Computer Algebra: Symbolic and Algebraic Computation. </booktitle> <publisher> Springer Verlag, </publisher> <year> 1983. </year>
Reference-contexts: It may be important to develop heuristics which avoiding the attempt to match at all. Such attempts to "optimize" rule sets, where information about partial matches are propagated can be critical to speed. There is a literature on computing reductions related to rules (e.g. Gro bner, Knuth-Bendix <ref> [3] </ref>), which can be helpful in the domain of polynomial computer algebra evaluation problems have to do with computing in polynomial ideals| reduction of systems modulo polynomial side-relations in several variables. Unfortunately, success in a larger domain does not follow from this same theory. 4.
Reference: [4] <author> Davis, M. </author> <title> Computability and Unsolvability. </title> <publisher> McGraw-Hill, </publisher> <year> 1958. </year>
Reference-contexts: These rules might direct transformations like 8x; y log (x y) ! log (x) + log (y) x; y &gt; 0 jxj ! x; if x 0; jxj; otherwise. Since even highly constrained and very simplistic rule transformation systems (e.g. Post systems <ref> [4] </ref>) are equivalent to Turing machines in formal computational power, they could be used, in principle, as the sole computational description for any formal algorithm, not just evaluation. Their advantage over the more traditional procedural definitions seems to be primarily in their declarative nature. <p> Though that would be desirable (a Church-Rosser <ref> [4] </ref> simplifier), for some classes of expressions, it just happens to be undecidable.) Note that we could consider building a valid simplifier by defining a sub-simplification procedure which is applied repeatedly until no more changes are observed, and then this n-iterative process is the simp with the idempotence property.
Reference: [5] <author> Fateman, R. J. </author> <title> Macsyma's general simplifier: Philosophy and operation. </title> <booktitle> Proc. 1979 Macsyma Users Conference, </booktitle> <address> Washington, D.C. </address> <year> (1979), </year> <month> 336|343. </month>
Reference: [6] <author> Fateman, R. J. </author> <title> A review of Mathematica. </title> <journal> J. Symbolic Comp. </journal> <volume> 13, </volume> <month> 5 (May </month> <year> 1992), </year> <month> 545|579. </month>
Reference-contexts: These are intended to automatically keep track of numerical errors in computation, although their failure to do so is one problem noted by Fateman <ref> [6] </ref>. Some expressions that are supposed to be purely floating-point (real) are "compiled" for rapid evaluation. This is useful for plotting, numerical quadrature, computing sound waves, and solving differential equations. The evaluation of compiled functions provides another set of semantics different from the usual arithmetic.
Reference: [7] <author> Foderaro, J. K. </author> <title> The Design of a Language for Algebraic Computation Systems. </title> <type> PhD thesis, </type> <institution> Univ. of Calif. at Berkeley, </institution> <year> 1983. </year>
Reference-contexts: What makes a language suitable? We insist that it be carefully defined. Common Lisp satisfies this criterion; the (much simpler) Scheme dialect of Lisp might do as well 8 ; even a computer algebra systems language could work if it 7 Newspeak <ref> [7] </ref>, Andante, were experimental languages developed at the University of California at Berkeley for writing computer algebra systems based on an algebraic mathematical abstraction that embodied most of what people have been trying to do. <p> Work by R. Zippel [13] takes this view. The demands of computer algebra seem, however, to strain the capabilities of less sophisticated systems. In fact, Newspeak's multiple-generic functions <ref> [7] </ref> (where the types of all the arguments, not just the first) determine the method to be used, were adopted by CLOS, and are particularly handy 9 .
Reference: [8] <author> Gradshteyn, I. S., and M.Ryzhik, I. </author> <title> Table of Integrals, Series, and Products, 4th ed. </title> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: Consider cos (n + 1)x sin nx, as appears in a well-known table of integrals (formula 1.351 <ref> [8] </ref>). Try that in your favorite CAS parser! Because the process of evaluation must make explicit the binding between notation and semantics, the design of the evaluation program must consider these issues centrally. Furthermore, evaluation typically is intertwined with "simplification" of results.
Reference: [9] <author> Soft Warehouse Inc. </author> <title> DERIVE User Manual version 2. Soft Warehouse, </title> <publisher> Inc, </publisher> <address> Honolulu, Hawaii, </address> <year> 1992. </year>
Reference-contexts: Mathematica's package notion may have been inspired by this development. A minor variation to Lisp's evaluation to avoid reporting certain error when a symbol is used unquoted, is used in MuLisp, a dialect of Lisp that supports the CAS Derive <ref> [9] </ref>. Consider a version of Lisp that has a modified eval that is exactly like eval in almost all respects except that errors caused by unbound variables or undefined functions result in "quoted" structure.
Reference: [10] <author> Jenks, R. D., and Sutor, R. S. </author> <title> AXIOM: the Scientific Computation System. </title> <publisher> NAG and Springer Verlag, </publisher> <address> NY, </address> <year> 1992. </year>
Reference-contexts: I suspect that experienced programmers fall prey to this source of bugs as well, especially since they may be more inclined to try to take advantage of the vast speedup potential. 6 A Collection of Systems 6.1 AXIOM Computing the "value of an expression e" in AXIOM <ref> [10] </ref> resembles the notion of evaluation in Lisp, which is to say, it is evaluation with respect to an environment. It also has an additional component, which requires evaluation to a type. Let us give several simple examples.
Reference: [11] <author> MacCallum, M. A. H., and Wright, F. </author> <title> Algebraic Computing with REDUCE. </title> <publisher> Oxford University Press, </publisher> <year> 1991. </year>
Reference-contexts: This must be handled rather gingerly. Consider that O [x]^6-O [x]^6, a series expression, is not zero but is "equal" to O [x]^6 and Interval [--1,1-]-Interval [--1,1-] is not zero either, but Interval [--2, 2-]. 6.5 REDUCE The REDUCE system <ref> [11] </ref> uses a model of evaluation similar to that in Lisp, a language in which it has historically been implemented, although a C-based version now exists.
Reference: [12] <author> Wolfram, S. </author> <title> Mathematica: A System for Doing Mathematics by Computer, 2nd ed. </title> <publisher> Addison Wesley, </publisher> <year> 1991. </year>
Reference-contexts: In the versions of Mathematica prior to 2.2, the same error occurred; eventually the vagaries of the Interval structure were incorporated into the equivalent of the Mathemat-ica kernel. 6.4 Mathematica The underlying scheme for evaluation in Mathematica <ref> [12] </ref> is based on the notion that when the user types in an expression the system should keep on applying rules to it (and function evaluation means rule application in Mathematica), until it stops changing. <p> For more advanced problems, Mathematica's evaluation tactics, intertwined with pattern matching and its notion of Packages is more elaborate than most. It is clear that the evaluation strategy is incompletely described in the reference <ref> [12] </ref>; furthermore it appears it is never fully described in the Mathematica literature. Experimentation may be a guide. It appears that the usual block structure expected of an Algol-like language is only partly simulated in Mathematica.
Reference: [13] <author> Zippel, R. </author> <title> The Weyl computer algebra substrate. </title> <type> Tech. Rep. 90-1077, </type> <institution> Dep't of Computer Science Cor-nell Univ., </institution> <year> 1990. </year>
Reference-contexts: Indeed, writing certain computer algebra programs in Common Lisp's object system (CLOS) is somewhat more convenient than otherwise. The hierarchy of classes, coercions and definitions of methods that are needed for writing computer algebra can to a large extent be mirrored by CLOS. Work by R. Zippel <ref> [13] </ref> takes this view. The demands of computer algebra seem, however, to strain the capabilities of less sophisticated systems.
References-found: 13

