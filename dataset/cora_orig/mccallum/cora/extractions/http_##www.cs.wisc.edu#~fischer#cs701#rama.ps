URL: http://www.cs.wisc.edu/~fischer/cs701/rama.ps
Refering-URL: http://www.cs.wisc.edu/~fischer/cs701/readings.html
Root-URL: 
Email: rama@watson.ibm.com  
Title: Data Flow Frequency Analysis  
Author: G. Ramalingam 
Address: P.O. Box 704, Yorktown Heights, NY, 10598, USA  
Affiliation: IBM T.J. Watson Research Center  
Abstract: Conventional dataflow analysis computes information about what facts may or will not hold during the execution of a program. Sometimes it is useful, for program optimization, to know how often or with what probability a fact holds true during program execution. In this paper, we provide a precise formulation of this problem for a large class of dataflow problems the class of finite bi-distributive subset problems. We show how it can be reduced to a generalization of the standard dataflow analysis problem, one that requires a sum-over-all-paths quantity instead of the usual meet-overall-paths quantity. We show that Kildall's result expressing the meet-over-all-paths value as a maximal-fixed-point carries over to the generalized setting. We then outline ways to adapt the standard dataflow analysis algorithms to solve this generalized problem, both in the intraprocedural and the interprocedural case. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F.E. Allen and J. Cocke. </author> <title> A program data flow analysis procedure. </title> <journal> Commun. of the ACM, </journal> <volume> 19(3) </volume> <pages> 137-147, </pages> <month> March </month> <year> 1976. </year>
Reference-contexts: For our purposes, it would be more efficient to adapt the various elimination-based dataflow analysis algorithms to solve this problem. (See [18] for a survey of elimination algorithms.) These algorithms are often linear or almost-linear in the size of the graph. (The Allen-Cocke interval analysis algorithm <ref> [1] </ref>, for example, is linear for reducible flow graphs whose loop nesting depth is bounded by a constant. Tarjan's algorithm [22] is almost-linear for all reducible flow graphs.
Reference: [2] <author> D. F. Bacon, M. Wegman, and K. Zadeck. </author> <title> Rapid type analysis for C++. </title> <type> Technical Report RC number pending, </type> <institution> IBM T.J. Watson Research Center, </institution> <year> 1996. </year>
Reference-contexts: It presents a theoretical foundation, as well as algorithms, for computing the frequency of dataflow facts. More work, however, remains to be done. Consider the type analysis problem that arises in the above-mentioned cloning optimization. There do exist simple, but effective, type analysis algorithms (for C++; see <ref> [2] </ref>) that fall into the FBS framework. Other, more powerful, type analysis algorithms [12, 13, 4], however, are not even distributive. The results in this paper do not apply to such algorithms.
Reference: [3] <author> T. Ball and J.R. Larus. </author> <title> Optimally profiling and tracing programs. </title> <booktitle> In Conference Record of the Nineteenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 59-70, </pages> <year> 1992. </year>
Reference-contexts: The probability that a certain branch in the program will be taken at run time can be estimated either statically or using profiling information <ref> [14, 23, 3] </ref>. In this paper, we show how the frequency or probability of dataflow facts can be computed for a large class of dataflow problems, a class we call finite bi-distributive subset (FBS) problems, once every edge in the control-flow graph is annotated with a probability. <p> This paper explores the possibility of computing such information statically once every branch out of a conditional node is labelled with a value that indicates the probability that that branch is taken. The probability labelling itself may be computed using simple heuristics, profiling tools, or static analysis. <ref> [23, 24, 14, 3] </ref>. Even when the labelling is computed using profiling tools, it is certainly more convenient to have to gather only this simple data at run-time, rather than having to gather, at run-time, specialized information that varies from one analysis problem to another.
Reference: [4] <author> Paul R. Carini, Michael Hind, and Harini Srinivasan. </author> <title> Flow-sensitive type analysis for C++. </title> <type> Technical Report RC 20267, </type> <institution> IBM T.J. Watson Research Center, </institution> <year> 1995. </year>
Reference-contexts: More work, however, remains to be done. Consider the type analysis problem that arises in the above-mentioned cloning optimization. There do exist simple, but effective, type analysis algorithms (for C++; see [2]) that fall into the FBS framework. Other, more powerful, type analysis algorithms <ref> [12, 13, 4] </ref>, however, are not even distributive. The results in this paper do not apply to such algorithms.
Reference: [5] <author> T.H. Cormen, C.E. Leiserson, and R.L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: In fact, they reveal that just as dataflow analysis reduces to reachability in the exploded graph, the problem we are interested in reduces to a simple algebraic path problem (see <ref> [7, 5] </ref>) over the exploded graph namely the algebraic path problem over the closed semiring (&lt; + ; +; :; fl ; 0; 1) whose closure operator fl is defined by: ff (= i=0 i 1 if ff 1 (This algebraic path problem is known as the Markov chain problem 5
Reference: [6] <author> J. Dean, C. Chambers, and D. Grove. </author> <title> Selective specialization for object-oriented languages. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 93-102, </pages> <year> 1995. </year>
Reference-contexts: u in a procedure p can be obtained by applying M (SLVP (r p ; u)) to the solution for r p . 7 Conclusion This work was originally motivated by procedure cloning an optimization that generates specializations of procedures for specific subtypes of the types of their formal parameters <ref> [6] </ref>. More efficient code can be generated for the specialized versions than for the unspecialized version because the types of the arguments are more precisely known. However, it is necessary to be selective about which specializations are generated to avoid code explosion.
Reference: [7] <author> M. Gondran and M. Minoux. </author> <title> Graphs and Algorithms. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: In fact, they reveal that just as dataflow analysis reduces to reachability in the exploded graph, the problem we are interested in reduces to a simple algebraic path problem (see <ref> [7, 5] </ref>) over the exploded graph namely the algebraic path problem over the closed semiring (&lt; + ; +; :; fl ; 0; 1) whose closure operator fl is defined by: ff (= i=0 i 1 if ff 1 (This algebraic path problem is known as the Markov chain problem 5
Reference: [8] <author> J.B. Kam and J.D. Ullman. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> J. ACM, </journal> <volume> 23 </volume> <pages> 158-171, </pages> <year> 1976. </year>
Reference-contexts: every edge e, then the sum-over-all-paths values G form a fixed point of the set of equations Q. (That is, the assignment &lt; x u := G (u) &gt; satisfies the collection of equations Q.) Proof See Appendix. 2 We now establish a result similar to Kam and Ullman's result <ref> [8, 9] </ref> relating MOP and MFP. In the following theorem, the ordering on &lt; D fl + is the ordering induced by the usual arithmetic ordering on &lt; + .
Reference: [9] <author> J.B. Kam and J.D. Ullman. </author> <title> Monotone data flow analysis frameworks. </title> <journal> Acta Informatica, </journal> <volume> 7 </volume> <pages> 305-317, </pages> <year> 1977. </year>
Reference-contexts: every edge e, then the sum-over-all-paths values G form a fixed point of the set of equations Q. (That is, the assignment &lt; x u := G (u) &gt; satisfies the collection of equations Q.) Proof See Appendix. 2 We now establish a result similar to Kam and Ullman's result <ref> [8, 9] </ref> relating MOP and MFP. In the following theorem, the ordering on &lt; D fl + is the ordering induced by the usual arithmetic ordering on &lt; + .
Reference: [10] <author> G. Kildall. </author> <title> A unified approach to global program optimization. </title> <booktitle> In Conference Record of the First ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 194-206, </pages> <address> New York, NY, 1973. </address> <publisher> ACM. </publisher>
Reference-contexts: In Section 6 we show how to extend the results to handle procedures. Section 7 presents our conclusion. 2 Preliminary Material We first review the lattice-theoretic framework for dataflow analysis developed by Kildall <ref> [10] </ref>.
Reference: [11] <author> J. Knoop and B. Steffen. </author> <title> The interprocedural coincidence theorem. </title> <editor> In U. Kastens and P. Pfahler, editors, </editor> <booktitle> Proceedings of the Fourth International Conference on Compiler Construction, Lecture Notes in Computer Science Vol. </booktitle> <volume> 641, </volume> <pages> pages 125-140. </pages> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A precise interprocedural dataflow analysis algorithm computes the meet-over-all-valid-paths solution, as opposed to the meet-over-all-paths solution <ref> [21, 11] </ref>.
Reference: [12] <author> Hemant D. Pande and Barbara G. Ryder. </author> <title> Static type determination for C++. </title> <booktitle> In Proceedings of the Sixth Usenix C++ Technical Conference, </booktitle> <pages> pages 85-97, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: More work, however, remains to be done. Consider the type analysis problem that arises in the above-mentioned cloning optimization. There do exist simple, but effective, type analysis algorithms (for C++; see [2]) that fall into the FBS framework. Other, more powerful, type analysis algorithms <ref> [12, 13, 4] </ref>, however, are not even distributive. The results in this paper do not apply to such algorithms.
Reference: [13] <author> Hemant D. Pande and Barbara G. Ryder. </author> <title> Static type determination and aliasing for C++. </title> <type> Technical Report LCSR-TR-250, </type> <institution> Department of Computer Science, Rut-gers University, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: More work, however, remains to be done. Consider the type analysis problem that arises in the above-mentioned cloning optimization. There do exist simple, but effective, type analysis algorithms (for C++; see [2]) that fall into the FBS framework. Other, more powerful, type analysis algorithms <ref> [12, 13, 4] </ref>, however, are not even distributive. The results in this paper do not apply to such algorithms.
Reference: [14] <author> J.R.C. Patterson. </author> <title> Accurate static branch prediction by value range propagation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 67-78, </pages> <year> 1995. </year>
Reference-contexts: The probability that a certain branch in the program will be taken at run time can be estimated either statically or using profiling information <ref> [14, 23, 3] </ref>. In this paper, we show how the frequency or probability of dataflow facts can be computed for a large class of dataflow problems, a class we call finite bi-distributive subset (FBS) problems, once every edge in the control-flow graph is annotated with a probability. <p> This paper explores the possibility of computing such information statically once every branch out of a conditional node is labelled with a value that indicates the probability that that branch is taken. The probability labelling itself may be computed using simple heuristics, profiling tools, or static analysis. <ref> [23, 24, 14, 3] </ref>. Even when the labelling is computed using profiling tools, it is certainly more convenient to have to gather only this simple data at run-time, rather than having to gather, at run-time, specialized information that varies from one analysis problem to another. <p> A couple of recent papers have utilized estimates of the probability of specific facts for program optimization. Proebsting and Fischer [15] outline a register allocation algorithm that utilizes estimates of the probability of a register-allocated variable remaining in the register at a subsequent use of the variable. Patterson <ref> [14] </ref> computes the probability of various variables having various values and utilizes this information for branch prediction, which has applications to several optimizations such as instruction scheduling. These papers, however, present no results relating the quantities computed to any formally defined quantity (such as a sum-over-all-path quantity).
Reference: [15] <author> T. Proebsting and C. Fischer. </author> <title> Probabilistic register allocation. </title> <booktitle> In Proceedings of the ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 300-310, </pages> <year> 1992. </year>
Reference-contexts: A couple of recent papers have utilized estimates of the probability of specific facts for program optimization. Proebsting and Fischer <ref> [15] </ref> outline a register allocation algorithm that utilizes estimates of the probability of a register-allocated variable remaining in the register at a subsequent use of the variable.
Reference: [16] <author> C.V. Ramamoorthy. </author> <title> Discrete markov analysis of computer programs. </title> <booktitle> In Proceedings of the ACM 20th National Conference, </booktitle> <pages> pages 386-391, </pages> <year> 1965. </year>
Reference-contexts: The problem of computing the expected frequency of execution of the various statements in a program, given a control-flow graph whose edges are labelled with a probability, has been studied previously <ref> [16, 23] </ref>. We are not aware of any previous work in generalizing these techniques to general dataflow analysis problems. We provide a theoretical foundation for dataflow frequency analysis and outline algorithms for the problem. The paper is organized as follows. <p> It remains to be seen how much this approximation can affect the solution. The problem of computing the expected frequency of execution of the various statements in a program, given a control-flow graph whose edges are labelled with a probability, has been studied previously <ref> [16, 23, 24] </ref>. A couple of recent papers have utilized estimates of the probability of specific facts for program optimization. Proebsting and Fischer [15] outline a register allocation algorithm that utilizes estimates of the probability of a register-allocated variable remaining in the register at a subsequent use of the variable.
Reference: [17] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interpro-cedural dataflow analysis via graph reachability. </title> <booktitle> In Conference Record of the Twenty-Second ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <year> 1995. </year>
Reference-contexts: This class of dataflow analysis problems is more general than the class of separable problems (also known as gen/kill or bit-vector problems) but less general than the class of finite distributive subset problems introduced by Reps et al <ref> [17] </ref>. The problem of computing the expected frequency of execution of the various statements in a program, given a control-flow graph whose edges are labelled with a probability, has been studied previously [16, 23]. <p> the powerset 2 D of a finite set D, F 2 D ! d 2 D , the set of distributive functions from 2 D to 2 D , and the meet operation is set union. (This is essentially the intraprocedural version of the framework introduced by Reps et al. <ref> [17] </ref>. Analysis problems over 2 D whose meet operation is set intersection can be transformed into a set union problem by considering its dual, as noted in [17].) Essentially, D is a (finite) set of facts that may or may not hold true at various program points and the problem is <p> D , and the meet operation is set union. (This is essentially the intraprocedural version of the framework introduced by Reps et al. <ref> [17] </ref>. Analysis problems over 2 D whose meet operation is set intersection can be transformed into a set union problem by considering its dual, as noted in [17].) Essentially, D is a (finite) set of facts that may or may not hold true at various program points and the problem is to determine which facts hold true at each program point. <p> The function t fl is essentially the representation relation of t defined by Reps et al. (See <ref> [17] </ref>.) The representation relation of t , denoted by R t , is a binary relation on D fl . <p> The structure of the resulting set of equations is better understood by considering the exploded control-flow graph introduced by Reps et al. <ref> [17] </ref>. <p> These papers, however, present no results relating the quantities computed to any formally defined quantity (such as a sum-over-all-path quantity). Nor do they explore the problem in the generalized setting that we do. The exploded control-flow graph introduced by Reps et al. <ref> [17] </ref> provides a natural and easy way to understand our problem reduction and algorithm. There are, in fact, several structural similarities between our work and an extension of the Reps et al. work outlined by Sagiv et al. [20, 19].
Reference: [18] <author> B. Ryder and M. Paull. </author> <title> Elimination algorithms for data flow analysis. </title> <journal> ACM Computing Surveys, </journal> <volume> 18(3), </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: For our purposes, it would be more efficient to adapt the various elimination-based dataflow analysis algorithms to solve this problem. (See <ref> [18] </ref> for a survey of elimination algorithms.) These algorithms are often linear or almost-linear in the size of the graph. (The Allen-Cocke interval analysis algorithm [1], for example, is linear for reducible flow graphs whose loop nesting depth is bounded by a constant.
Reference: [19] <author> M. Sagiv, T. Reps, and S. Horwitz. </author> <title> Precise interpro-cedural dataflow analysis with applications to constant propagation. </title> <note> To appear in Theoretical Computer Science. (Also Technical Report CS-TR-95-1284, </note> <institution> Computer Sciences Department, University of Wisconsin-Madison, </institution> <year> 1995). </year>
Reference-contexts: The exploded control-flow graph introduced by Reps et al. [17] provides a natural and easy way to understand our problem reduction and algorithm. There are, in fact, several structural similarities between our work and an extension of the Reps et al. work outlined by Sagiv et al. <ref> [20, 19] </ref>. Sagiv et al. study a class of dataflow problems they call the Inter-procedural Distributive Environment (IDE) problems.
Reference: [20] <author> M. Sagiv, T. Reps, and S. Horwitz. </author> <title> Precise interpro-cedural dataflow analysis with applications to constant propagation. </title> <booktitle> In Proceedings of FASE '95: Colloquium on Formal Approaches in Software Engineering, </booktitle> <pages> pages 651-665, </pages> <year> 1995. </year>
Reference-contexts: The definition follows automatically from this reasoning. Also see Lemma 4 and its proof for some more intuition behind the definition. available expressions, and live variables, have bi-distributive transfer functions. Copy constant propagation (eg., see <ref> [20] </ref>) is an example that is not a bit vector problem but is a bi-distributive problem. <p> The exploded control-flow graph introduced by Reps et al. [17] provides a natural and easy way to understand our problem reduction and algorithm. There are, in fact, several structural similarities between our work and an extension of the Reps et al. work outlined by Sagiv et al. <ref> [20, 19] </ref>. Sagiv et al. study a class of dataflow problems they call the Inter-procedural Distributive Environment (IDE) problems.
Reference: [21] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interpro-cedural data flow analysis. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 189-233. </pages> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: A precise interprocedural dataflow analysis algorithm computes the meet-over-all-valid-paths solution, as opposed to the meet-over-all-paths solution <ref> [21, 11] </ref>.
Reference: [22] <author> R.E. Tarjan. </author> <title> Fast algorithms for solving path problems. </title> <journal> J. ACM, </journal> <volume> 28 </volume> <pages> 594-614, </pages> <year> 1981. </year>
Reference-contexts: Tarjan's algorithm <ref> [22] </ref> is almost-linear for all reducible flow graphs. These algorithms for work for arbitrary graphs as well, but their complexity can be higher for irreducible graphs.) We can apply the elimination algorithms to either the original graph or the exploded graph. <p> The analysis of each control-flow graph, however, cannot be done as before (in the intraprocedural case), since the edges of the representation relation of the summary edges are labelled with symbolic variables instead of real values. Instead, we perform the analysis using an adaptation of Tarjan's generalized path algorithm <ref> [22] </ref>. This algorithm performs the elimination symbolically and computes a (symbolic) regular expression (i.e., an expression containing the operators +, :, and fl ) for each vertex u in the procedure p.
Reference: [23] <author> T.A. Wagner, V. Maverick, S.L. Graham, and M.A. Harrison. </author> <title> Accurate static estimators for program optimization. </title> <booktitle> In Proceedings of the ACM SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 85-96, </pages> <year> 1994. </year>
Reference-contexts: The probability that a certain branch in the program will be taken at run time can be estimated either statically or using profiling information <ref> [14, 23, 3] </ref>. In this paper, we show how the frequency or probability of dataflow facts can be computed for a large class of dataflow problems, a class we call finite bi-distributive subset (FBS) problems, once every edge in the control-flow graph is annotated with a probability. <p> The problem of computing the expected frequency of execution of the various statements in a program, given a control-flow graph whose edges are labelled with a probability, has been studied previously <ref> [16, 23] </ref>. We are not aware of any previous work in generalizing these techniques to general dataflow analysis problems. We provide a theoretical foundation for dataflow frequency analysis and outline algorithms for the problem. The paper is organized as follows. <p> One possible way of tackling this problem is to first compute just the expected execution frequency of each procedure, which can be done using just elimination techniques <ref> [23, 24] </ref>. If none of these values are 1 we may proceed with the iterative techniques to compute the frequency of dataflow facts. If any of these values is 1, we can heuristically alter the probability labelling, as in [23], so that these values are finite. <p> If none of these values are 1 we may proceed with the iterative techniques to compute the frequency of dataflow facts. If any of these values is 1, we can heuristically alter the probability labelling, as in <ref> [23] </ref>, so that these values are finite. Once the summary values have been computed, every M (SLVP (r p ; u)) (where u is a vertex in procedure p) can now be computed by evaluating the corresponding symbolic expression. <p> This paper explores the possibility of computing such information statically once every branch out of a conditional node is labelled with a value that indicates the probability that that branch is taken. The probability labelling itself may be computed using simple heuristics, profiling tools, or static analysis. <ref> [23, 24, 14, 3] </ref>. Even when the labelling is computed using profiling tools, it is certainly more convenient to have to gather only this simple data at run-time, rather than having to gather, at run-time, specialized information that varies from one analysis problem to another. <p> It remains to be seen how much this approximation can affect the solution. The problem of computing the expected frequency of execution of the various statements in a program, given a control-flow graph whose edges are labelled with a probability, has been studied previously <ref> [16, 23, 24] </ref>. A couple of recent papers have utilized estimates of the probability of specific facts for program optimization. Proebsting and Fischer [15] outline a register allocation algorithm that utilizes estimates of the probability of a register-allocated variable remaining in the register at a subsequent use of the variable.
Reference: [24] <author> Y. Wu and J.R. Larus. </author> <title> Static branch frequency and program profile analysis. </title> <booktitle> In Proceedings of the 27th International Symposium on Microarchitecture, </booktitle> <pages> pages 1-11, </pages> <year> 1994. </year>
Reference-contexts: One possible way of tackling this problem is to first compute just the expected execution frequency of each procedure, which can be done using just elimination techniques <ref> [23, 24] </ref>. If none of these values are 1 we may proceed with the iterative techniques to compute the frequency of dataflow facts. If any of these values is 1, we can heuristically alter the probability labelling, as in [23], so that these values are finite. <p> This paper explores the possibility of computing such information statically once every branch out of a conditional node is labelled with a value that indicates the probability that that branch is taken. The probability labelling itself may be computed using simple heuristics, profiling tools, or static analysis. <ref> [23, 24, 14, 3] </ref>. Even when the labelling is computed using profiling tools, it is certainly more convenient to have to gather only this simple data at run-time, rather than having to gather, at run-time, specialized information that varies from one analysis problem to another. <p> It remains to be seen how much this approximation can affect the solution. The problem of computing the expected frequency of execution of the various statements in a program, given a control-flow graph whose edges are labelled with a probability, has been studied previously <ref> [16, 23, 24] </ref>. A couple of recent papers have utilized estimates of the probability of specific facts for program optimization. Proebsting and Fischer [15] outline a register allocation algorithm that utilizes estimates of the probability of a register-allocated variable remaining in the register at a subsequent use of the variable.
References-found: 24

