URL: ftp://ftp.lcs.mit.edu/student-workshop/1996/abstracts/Myers_Bank.ps
Refering-URL: http://www.cag.lcs.mit.edu/student96/
Root-URL: 
Email: fandru, jbankg@lcs.mit.edu  
Title: Parameterized Types in Java  
Author: Andrew C. Myers Joseph A. Bank 
Affiliation: MIT Laboratory for Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Joseph Bank, Barbara Liskov, and Andrew C. My-ers. </author> <title> Parameterized types and Java. </title> <institution> At ftp://- ftp.pmg.lcs.mit.edu/pub/thor/javapt.ps.gz, </institution> <year> 1996. </year>
Reference-contexts: Finally, performance results from an extended Java interpreter that we have written suggest that these extensions support high-performance implementations. Further details on our extensions are available <ref> [1] </ref>. 2 Java Limitations Java's support for generic code (e.g. generic collections) is limited to subtype polymorphism. For example, the hash table class is declared to map from Object ! Object, where Object is the root of the class hierarchy.
Reference: [2] <author> Peter Canning, William Cook, Walter Hill, John Mitch-ell, and Walter Olthoff. </author> <title> F-bounded polymorphism for object-oriented programming. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 273-280, </pages> <year> 1989. </year>
Reference-contexts: Where clauses are a more powerful constraint mechanism than subtypes [3] because they can safely express the requirement for binary methods such as equal. They are also more powerful than the usual formulations of F-bounded polymorphism <ref> [2] </ref>. Our extended bytecode specification is probably the only example of a statically typed instruction set that supports parametric polymorphism. Unlike many generic-code implementations (e.g., for C++ templates), one sequence of instructions suffices for all instantiations of the generic code.
Reference: [3] <author> M. Day, R. Gruber, B. Liskov, and A. C. Myers. </author> <title> Sub-types vs. where clauses: Constraining parametric poly-morphism. </title> <booktitle> In Proceedings of OOPSLA '95, </booktitle> <address> Austin TX, </address> <month> October </month> <year> 1995. </year> <note> At ftp://ftp.pmg.lcs.mit.edu/pub/- thor/where-clauses.ps.gz. </note>
Reference-contexts: Because generic code is constrained, uses of generic abstractions can be type checked without examining the implementations of their abstractions. Many languages have macro-like generics (e.g., C++ and Modula-3 [6]) that do not provide this kind of separate compilation. Where clauses are a more powerful constraint mechanism than subtypes <ref> [3] </ref> because they can safely express the requirement for binary methods such as equal. They are also more powerful than the usual formulations of F-bounded polymorphism [2]. Our extended bytecode specification is probably the only example of a statically typed instruction set that supports parametric polymorphism. <p> Our goal was to provide good performance without duplicating executed code. The interpreter extensions slowed execution of non-parameterized code by only 4%; a careful implementation would have no slowdown <ref> [3] </ref>. We also tested the performance of a collection class implemented with parameterization and with other techniques. The results are shown in Figure 2: the 17% speedup offered by parameterized classes would likely be larger if Java were compiled, since run-time type casting of Object would be relatively more expensive.
Reference: [4] <author> B. Liskov et al. </author> <title> CLU reference manual. </title> <editor> In Goos and Hartmanis, editors, </editor> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> volume 114. </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: Joseph Bank is supported by a grant from Sun Microsystems. Web: www.pmg.lcs.mit.edu its ancestry in CLU <ref> [4] </ref>. However, Java has the additional constraint that it must be compilable into easily verifiable bytecodes. We have also designed a parameterized bytecode specification that preserves efficient verifiability. The extensions to Java for parametric polymorphism are based on constraining generic code with where clauses.
Reference: [5] <author> Barbara Liskov, Dorothy Curtis, Mark Day, Sanjay Ghe-mawat, Robert Gruber, Paul Johnson, and Andrew C. Myers. </author> <title> Theta Reference Manual. Programming Methodology Group Memo 88, </title> <institution> MIT Laboratory for Computer Science, </institution> <address> Cambridge, MA, </address> <month> February </month> <year> 1994. </year> <note> Available at http://www.pmg.lcs.mit.edu/papers/thetaref/. </note>
Reference-contexts: As we will see, parametric polymorphism permits the declaration of a hash table that maps between specific types, eliminating run-time checks. 3 Design Overview The design sketched here for parametric polymorphism in Java is derived from that in Theta <ref> [5] </ref> and has Andrew Myers is advised by Barbara Liskov and is supported in part by ARPA contract N00014-91-J-4136. Joseph Bank is supported by a grant from Sun Microsystems. Web: www.pmg.lcs.mit.edu its ancestry in CLU [4].
Reference: [6] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: The extensions to Java for parametric polymorphism are based on constraining generic code with where clauses. Because generic code is constrained, uses of generic abstractions can be type checked without examining the implementations of their abstractions. Many languages have macro-like generics (e.g., C++ and Modula-3 <ref> [6] </ref>) that do not provide this kind of separate compilation. Where clauses are a more powerful constraint mechanism than subtypes [3] because they can safely express the requirement for binary methods such as equal. They are also more powerful than the usual formulations of F-bounded polymorphism [2].
Reference: [7] <author> B. Stoustrup. </author> <title> The C++ Programming Language. </title> <address> Addi-son-Wesley, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction Java [8] promises to be an important language for WWW applications and software development in general. This popularity arises from several factors: simple object-oriented design; syntactic similarity to C++ <ref> [7] </ref>; strongly-typed code that is statically verifiable both as source code and as intermediate code. This note describes how to make Java more expressive by adding parametric polymorphism, which increases the power of compile-time type analysis and ultimately makes Java programs faster.
Reference: [8] <author> Sun Microsystems. </author> <title> Java Language Specification, </title> <note> version 1.0 beta edition, October 1995. Available at http://ftp.javasoft.com/docs/javaspec.ps.zip. 2 </note>
Reference-contexts: 1 Introduction Java <ref> [8] </ref> promises to be an important language for WWW applications and software development in general. This popularity arises from several factors: simple object-oriented design; syntactic similarity to C++ [7]; strongly-typed code that is statically verifiable both as source code and as intermediate code.
References-found: 8

