URL: ftp://ftp.db.toronto.edu/pub/papers/sicomp95.ps.Z
Refering-URL: http://www.cs.toronto.edu/~mendel/papers.html
Root-URL: 
Title: FINDING REGULAR SIMPLE PATHS IN GRAPH DATABASES  
Author: ALBERTO O. MENDELZONy AND PETER T. WOODz 
Keyword: Key words. Labelled directed graphs, NP-completeness, polynomial-time algorithms, regular expressions, simple paths  
Note: AMS(MOS) subject classifications. 68P, 68Q, 68R  
Abstract: We consider the following problem: given a labelled directed graph G and a regular expression R, find all pairs of nodes connected by a simple path such that the concatenation of the labels along the path satisfies R. The problem is motivated by the observation that many recursive queries in relational databases can be expressed in this form, and by the implementation of a query language, G + , based on this observation. We show that the problem is in general intractable, but present an algorithm than runs in polynomial time in the size of the graph when the regular expression and the graph are free of conflicts. We also present a class of languages whose expressions can always be evaluated in time polynomial in the size of both the graph and the expression, and characterize syntactically the expressions for such languages. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. AGRAWAL, </author> <title> Alpha: An extension of relational algebra to express a class of recursive queries, </title> <booktitle> in Proceedings of the 3rd International Conference on Data Engineering, </booktitle> <address> New York, 1987, </address> <publisher> IEEE, </publisher> <pages> pp. 580-590. </pages>
Reference-contexts: This particular limitation is overcome in the languages G + and Datalog through their ability to express recursive queries. The design of G + is based on the observation that many of the recursive queries that arise in practiceand in the literatureamount to graph traversals (for example, <ref> [1, 12, 19] </ref>). In G + , we view the database as a directed, labelled graph, and pose queries which are graph patterns; the answer to a query is the set of subgraphs of the database that match the given pattern.
Reference: [2] <author> A. AHO, J. HOPCROFT, AND J. ULLMAN, </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: REGULAR SIMPLE PATH is in NP, we observe that, for an arbitrary regular expression R, given a simple path from x to y in G with path label w, we can check in polynomial time in the lengths of R and w whether or not w is in L (R) <ref> [2] </ref>. It is interesting to note that if G is undirected, then both EVEN PATH and DISJOINT PATHS can be solved in polynomial time. EVEN PATH can be solved in polynomial time by using matching techniques [17], while a polynomial time algorithm for DISJOINT PATHS is given in [20]. <p> Clearly, [s 0 ] = L (M ). Similar definitions apply for a DFA. Given a regular expression R over S, an *-free NDFA M = (S; S; ffi; s 0 ; F ) which accepts L (R) can be constructed in polynomial time <ref> [2] </ref>. From now on, we will assume that all NDFAs are *-free. Example 3. Figure 3 shows the transition graph T of a DFA M . <p> M exhibits the Containment Property. 1 Unix is a trademark of AT&T. 9 Proof. In our proof, we will use the NDFA M R = (T; S; ; t 0 ; E) constructed from regular expression R (such that L (M R ) = L (R)) as detailed in <ref> [2] </ref>, and in which *-transitions are usually present. There is a one-to-one correspondence between non*-transitions in M R and occurrences of symbols in R, so that it makes sense to refer to the transition in M R corresponding to an occurrence of symbol a in R, and vice versa. <p> If (s; t) is marked by Algorithm S, then [s] 6 [t]. If M has n states, then Algorithm S runs in O (n 2 ) time (assuming a constant alphabet) [13]. (An alternative, almost linear-time algorithm is given in <ref> [2] </ref>.) Since the construction 11 of a DFA M accepting L (R) may take exponential time (in the size of R), using Algorithm S to test whether a regular expression is restricted is not efficient. <p> These latter edges correspond to forward, back and cross edges in a conventional DFST <ref> [2] </ref>. Assume that Algorithm C starts traversal from node (A; a), that is, SEARCH (A; A; a)) is called at Line 5 (a), and that the order of traversal is according to the DFST in Figure 15 (a).
Reference: [3] <author> A. AHO AND J. ULLMAN, </author> <title> Universality of data retrieval languages, </title> <booktitle> in Proceedings of the 6th ACM Symposium on Principles of Programming Languages, </booktitle> <address> New York, 1979, </address> <publisher> ACM, </publisher> <pages> pp. 110-120. </pages>
Reference-contexts: However, this notion of completeness has been questioned since it was shown that certain reasonable queries, such as finding the transitive closure of a binary relation, cannot be expressed in the calculus <ref> [3, 4] </ref>. This particular limitation is overcome in the languages G + and Datalog through their ability to express recursive queries.
Reference: [4] <author> F. BANCILHON, </author> <title> On the completeness of query languages for relational databases, </title> <booktitle> in Proceedings of the 7th Symposium on Mathematical Foundations of Computer Science, vol. 64 of Lecture Notes in Computer Science, </booktitle> <address> New York, 1978, </address> <publisher> Springer-Verlag, </publisher> <pages> pp. 112-123. </pages>
Reference-contexts: However, this notion of completeness has been questioned since it was shown that certain reasonable queries, such as finding the transitive closure of a binary relation, cannot be expressed in the calculus <ref> [3, 4] </ref>. This particular limitation is overcome in the languages G + and Datalog through their ability to express recursive queries.
Reference: [5] <author> A. BUCHSBAUM, P. KANELLAKIS, AND J. VITTER, </author> <title> A data structure for arc insertion and regular path finding, </title> <booktitle> in Proceedings of the 1st ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <year> 1990, </year> <pages> pp. 22-31. </pages>
Reference-contexts: One such language that captures exactly the queries computable in nondeterministic logarithmic space is presented in [8]. On-line algorithms for regular path finding are given in <ref> [5] </ref>, while a survey 23 of many results can be found in [24].
Reference: [6] <author> B. CARR E, </author> <title> Graphs and Networks, </title> <publisher> Oxford University Press, Oxford, </publisher> <address> England, </address> <year> 1979. </year>
Reference-contexts: There is a non-simple path from u to v in G which satisfies R but no simple path from u to v satisfying R. DEFINITION 9. An abbreviation of a string w is any string which can be obtained from w by removing one or more symbols of w <ref> [6] </ref>. So we are looking for a class of regular expressions which denote languages that are closed under abbreviation. Now consider the following definition for the class of restricted regular expressions. DEFINITION 10.
Reference: [7] <author> E. CODD, </author> <title> Relational completeness of data base sublanguages, in Data Base Systems, </title> <editor> R. Rustin, ed., </editor> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1972, </year> <pages> pp. 65-98. </pages>
Reference-contexts: The original proposal for the relational model included two query languages of equivalent expressive power: the relational calculus and the relational algebra <ref> [7] </ref>. These languages have been used as the yardstick by which other query languages are classified; a query language is said to be relationally complete if it has (at least) the expressive power of the relational calculus.
Reference: [8] <author> M. CONSENS AND A. MENDELZON, </author> <title> Graphlog: a visual formalism for real life recursion, </title> <booktitle> in Proceedings of the 9th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> Nashville, Tenn., </address> <month> Apr. </month> <pages> 2-4, </pages> <address> 1990, </address> <publisher> ACM, </publisher> <address> New York, </address> <pages> pp. 404-416. </pages>
Reference-contexts: Finally, we note that research has been done on the expressive power of graph-based query languages in which the restriction of simple path semantics is dropped. One such language that captures exactly the queries computable in nondeterministic logarithmic space is presented in <ref> [8] </ref>. On-line algorithms for regular path finding are given in [5], while a survey 23 of many results can be found in [24].
Reference: [9] <author> I. CRUZ, A. MENDELZON, AND P. WOOD, </author> <title> A graphical query language supporting recursion, </title> <booktitle> in Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <address> San Francisco, Calif., </address> <month> May 27-29, </month> <year> 1987, </year> <booktitle> ACM, </booktitle> <address> New York, </address> <pages> pp. </pages> <month> 323-330. </month> <title> [10] , G + : recursive queries without recursion, </title> <booktitle> in Proceedings of the 2nd International Conference on Expert Database Systems, </booktitle> <address> Tysons Corner, Virginia, </address> <month> Apr. </month> <pages> 25-27, </pages> <address> 1988, Benjamin/Cummings, Redwood City, </address> <pages> pp. 355-368. </pages>
Reference-contexts: However, the fact that queries which are especially useful in new application domains are not expressible in traditional query languages has led to proposals for more powerful query languages, such as the logic-based language Datalog [23] and our query language G + <ref> [9, 10] </ref>. The original proposal for the relational model included two query languages of equivalent expressive power: the relational calculus and the relational algebra [7].
Reference: [11] <author> S. FORTUNE, J. HOPCROFT, AND J. WYLLIE, </author> <title> The directed subgraph homeomorphism problem, </title> <journal> Theoretical Comput. Sci., </journal> <volume> 10 (1980), </volume> <pages> pp. 111-121. </pages>
Reference-contexts: When trying to find an efficient solution for this problem to incorporate in our implementation of G + , we were somewhat surprised to discover that the queries of Examples 1 and 2 are in fact both NP-complete. Using results in <ref> [11, 17] </ref>, we show in x2 that for certain fixed regular expressions (such as R in Example 2), the problem of deciding whether a pair of nodes is in the answer of a query is NP-complete, making the general problem NP-hard. <p> It is easy to see that FIXED REGULAR PATH (R) is in NP; we conclude that FIXED REGULAR PATH (R), where R = (00) fl , is NP-complete. (2) The fact that DISJOINT PATHS is NP-complete follows immediately from results in <ref> [11] </ref>. We reduce DISJOINT PATHS to FIXED REGULAR PATH (R), where R = 0 fl 10 fl . Given an instance G; w; x; y; z of DISJOINT PATHS, construct a db-graph H isomorphic to G, except that every edge of H is labelled with 0.
Reference: [12] <author> G. GRAHNE, S. SIPPU, AND E. SOISALON-SOININEN, </author> <title> Efficient evaluation for a subset of recursive queries, </title> <booktitle> in Proceedings of the 6th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> San Diego, Calif., </address> <month> Mar. </month> <pages> 23-25, </pages> <address> 1987, </address> <publisher> ACM, </publisher> <address> New York, </address> <pages> pp. 284-293. </pages>
Reference-contexts: This particular limitation is overcome in the languages G + and Datalog through their ability to express recursive queries. The design of G + is based on the observation that many of the recursive queries that arise in practiceand in the literatureamount to graph traversals (for example, <ref> [1, 12, 19] </ref>). In G + , we view the database as a directed, labelled graph, and pose queries which are graph patterns; the answer to a query is the set of subgraphs of the database that match the given pattern.
Reference: [13] <author> J. HOPCROFT AND J. ULLMAN, </author> <title> Introduction to Automata Theory, Languages, and Computation, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1979. </year>
Reference-contexts: Given a query Q R , we would like to test whether R is restricted in order to know that it is safe to use a polynomial time evaluation algorithm. By adapting an algorithm to minimize the number of states of a DFA <ref> [13] </ref>, we can compute the suffix language containment relation for all pairs of states in a DFA M . The suffix language containment relation will be used in subsequent sections; it also provides an obvious method for testing whether or not a regular expression R is restricted (using Theorem 4). <p> The algorithm for computing the suffix language containment relation, Algorithm S, is shown in Figure 5. Lines 3 to 7 of Algorithm S are taken directly from the algorithm in <ref> [13] </ref>. That algorithm marks pairs of inequivalent states, so it considers unordered pairs of states. Lines 1 and 2 of our algorithm are altered appropriately in order to consider ordered pairs of states. If (s; t) is marked by Algorithm S, then [s] 6 [t]. <p> Lines 1 and 2 of our algorithm are altered appropriately in order to consider ordered pairs of states. If (s; t) is marked by Algorithm S, then [s] 6 [t]. If M has n states, then Algorithm S runs in O (n 2 ) time (assuming a constant alphabet) <ref> [13] </ref>. (An alternative, almost linear-time algorithm is given in [2].) Since the construction 11 of a DFA M accepting L (R) may take exponential time (in the size of R), using Algorithm S to test whether a regular expression is restricted is not efficient. <p> that Theorem 8 is true independent of the particular DFA chosen is a consequence of the Myhill-Nerode theorem, which states that a language is accepted by a DFA if and only if it is the union of some of the equivalence classes of a right-invariant equivalence relation of finite index <ref> [13] </ref>. This leads us to the following definition. DEFINITION 14. Let R be a regular expression and T be the transition graph for a DFA accepting L (R).
Reference: [14] <author> H. HUNT, D. ROSENKRANTZ, AND T. SZYMANSKI, </author> <title> On the equivalence, containment, and covering problems for the regular and context-free languages, </title> <journal> J. Comput. System Sci., </journal> <volume> 12 (1976), </volume> <pages> pp. 222-268. </pages>
Reference-contexts: There is a path from x to y satisfying R if and only if there is a path in I from (x; s 0 ) to (y; s f ), for some s f 2 F . All this can be done in polynomial time <ref> [14] </ref>. In [22], Tarjan provides a polynomial-time algorithm for constructing a regular expression which represents the set of all paths between two nodes of a given graph.
Reference: [15] <author> Y. IOANNIDIS AND R. RAMAKRISHNAN, </author> <title> Efficient transitive closure algorithms, </title> <booktitle> in Proceedings of the 14th International Conference on Very Large Data Bases, </booktitle> <address> Los Angeles, Calif., Aug. 29-Sept. 1, 1988, </address> <publisher> Morgan Kaufmann, Palo Alto, </publisher> <pages> pp. 382-394. </pages>
Reference-contexts: Relaxing this assumption provides an interesting area for further study. Other researchers, investigating similar algorithms for transitive closure, have claimed that they are amenable to efficient secondary storage implementation <ref> [15] </ref>. Finally, we note that research has been done on the expressive power of graph-based query languages in which the restriction of simple path semantics is dropped. One such language that captures exactly the queries computable in nondeterministic logarithmic space is presented in [8].
Reference: [16] <author> B. JOUMARD AND M. MINOUX, </author> <title> An efficient algorithm for the transitive closure and a linear worst-case complexity result for a class of sparse graphs, </title> <journal> Inf. Process. Lett., </journal> <volume> 22 (1986), </volume> <pages> pp. 163-169. </pages>
Reference-contexts: We believe this is a topic for future research. For example, it would be interesting to see whether techniques used on sparse graphs, such as those in <ref> [16] </ref>, could be employed in our algorithm in order to improve its efficiency on sparse graphs. We should point out that the analysis in this paper, and the implementation itself, assume the graph can be entirely stored in main memory.
Reference: [17] <author> A. LAPAUGH AND C. PAPADIMITRIOU, </author> <title> The even-path problem for graphs and digraphs, Networks, </title> <booktitle> 14 (1984), </booktitle> <pages> pp. 507-513. </pages>
Reference-contexts: When trying to find an efficient solution for this problem to incorporate in our implementation of G + , we were somewhat surprised to discover that the queries of Examples 1 and 2 are in fact both NP-complete. Using results in <ref> [11, 17] </ref>, we show in x2 that for certain fixed regular expressions (such as R in Example 2), the problem of deciding whether a pair of nodes is in the answer of a query is NP-complete, making the general problem NP-hard. <p> THEOREM 1. Let 0 and 1 be distinct symbols in S. FIXED REGULAR PATH (R), in which R is either (1) (00) fl , or (2) 0 fl 10 fl , is NP-complete. Proof. (1) In <ref> [17] </ref>, EVEN PATH is shown to be NP-complete. We can reduce EVEN PATH to FIXED REGULAR PATH (R), where R = (00) fl , as follows. <p> It is interesting to note that if G is undirected, then both EVEN PATH and DISJOINT PATHS can be solved in polynomial time. EVEN PATH can be solved in polynomial time by using matching techniques <ref> [17] </ref>, while a polynomial time algorithm for DISJOINT PATHS is given in [20]. Each of the two NP-completeness results of Theorem 1 can be generalized. <p> Each of the two NP-completeness results of Theorem 1 can be generalized. We first generalize from the regular expression (00) fl to expressions of the form w fl , for any w 2 S fl such that jwj 2. For this we use the following NP-complete problem from <ref> [17] </ref>, which was used there to show the NP-completeness of EVEN PATH. PATH VIA A NODE Instance: Directed graph G = (N; E), and nodes x; y; m 2 N . Question: Is there a directed simple path from x to y via m? THEOREM 2. <p> Proof. Once again, membership in NP is easy to demonstrate. We reduce PATH VIA A NODE to FIXED REGULAR PATH (R) using a variation of the construction from <ref> [17] </ref>.
Reference: [18] <author> A. MENDELZON AND P. WOOD, </author> <title> Finding regular simple paths in graph databases, </title> <booktitle> in Proceedings of the 15th International Conference on Very Large Data Bases, </booktitle> <address> Amsterdam, The Netherlands, </address> <month> Aug. </month> <pages> 22-25, </pages> <address> 1989, </address> <publisher> Morgan Kaufmann, Palo Alto, </publisher> <pages> pp. 185-193. </pages>
Reference-contexts: However, there is a conflict in I. This is because there is an initial path in I from (A; a) via (B; a) to (B; c), but [a] 6 [c]. 3 This is a strictly weaker definition of conflict-freedom than that given in <ref> [18] </ref>. 17 I : ~ 1 (E,b) - ~ 0 (C,c) ~ (C,b) -0 ~ @ @ 0 1 1 0 FIG. 12. The intersection graph I of db-graph G and DFA M of Figure 10. Algorithm C: Evaluation of a query on a db-graph.
Reference: [19] <author> A. ROSENTHAL, S. HEILER, U. DAYAL, AND F. MANOLA, </author> <title> Traversal recursion: a practical approach to supporting recursive applications, </title> <booktitle> in Proceedings of the ACM SIGMOD Conference on Management of Data, </booktitle> <address> Washington, DC, </address> <month> May 28-30, </month> <year> 1986, </year> <booktitle> ACM, </booktitle> <address> New York, </address> <pages> pp. 166-176. </pages>
Reference-contexts: This particular limitation is overcome in the languages G + and Datalog through their ability to express recursive queries. The design of G + is based on the observation that many of the recursive queries that arise in practiceand in the literatureamount to graph traversals (for example, <ref> [1, 12, 19] </ref>). In G + , we view the database as a directed, labelled graph, and pose queries which are graph patterns; the answer to a query is the set of subgraphs of the database that match the given pattern.
Reference: [20] <author> Y. SHILOACH, </author> <title> A polynomial solution to the undirected two paths problem, </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 27 (1980), </volume> <pages> pp. 445-456. </pages>
Reference-contexts: It is interesting to note that if G is undirected, then both EVEN PATH and DISJOINT PATHS can be solved in polynomial time. EVEN PATH can be solved in polynomial time by using matching techniques [17], while a polynomial time algorithm for DISJOINT PATHS is given in <ref> [20] </ref>. Each of the two NP-completeness results of Theorem 1 can be generalized. We first generalize from the regular expression (00) fl to expressions of the form w fl , for any w 2 S fl such that jwj 2.
Reference: [21] <author> L. STOCKMEYER AND A. MEYER, </author> <title> Word problems requiring exponential time, </title> <booktitle> in Proceedings of the 5th Annual ACM Symposium on Theory of Computing, </booktitle> <address> Austin, Texas, </address> <month> Apr. </month> <title> 30-May 2, </title> <booktitle> 1973, ACM, </booktitle> <address> New York, </address> <pages> pp. 1-9. </pages>
Reference-contexts: The latter step can be done deterministically in time polynomial in the length of R <ref> [21] </ref>. We reduce the problem of Proposition 2 to the present problem by showing that R is not restricted if and only if R does not denote 0 fl . We have already shown that if R is not restricted, then L (R) 6= 0 fl .
Reference: [22] <author> R. TARJAN, </author> <title> Fast algorithms for solving path problems, </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 28 (1981), </volume> <pages> pp. 594-614. </pages>
Reference-contexts: There is a path from x to y satisfying R if and only if there is a path in I from (x; s 0 ) to (y; s f ), for some s f 2 F . All this can be done in polynomial time [14]. In <ref> [22] </ref>, Tarjan provides a polynomial-time algorithm for constructing a regular expression which represents the set of all paths between two nodes of a given graph.
Reference: [23] <author> J. ULLMAN, </author> <title> Implementation of logical query languages for databases, </title> <journal> ACM Trans. Database Syst., </journal> <volume> 10 (1985), </volume> <pages> pp. 289-321. </pages>
Reference-contexts: However, the fact that queries which are especially useful in new application domains are not expressible in traditional query languages has led to proposals for more powerful query languages, such as the logic-based language Datalog <ref> [23] </ref> and our query language G + [9, 10]. The original proposal for the relational model included two query languages of equivalent expressive power: the relational calculus and the relational algebra [7].
Reference: [24] <author> M. YANNAKAKIS, </author> <title> Graph-theoretic methods in database theory, </title> <booktitle> in Proceedings of the 9th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> Nashville, Tenn., </address> <month> Apr. </month> <pages> 2-4, </pages> <address> 1990, </address> <publisher> ACM, </publisher> <address> New York, </address> <pages> pp. 230-242. 24 </pages>
Reference-contexts: One such language that captures exactly the queries computable in nondeterministic logarithmic space is presented in [8]. On-line algorithms for regular path finding are given in [5], while a survey 23 of many results can be found in <ref> [24] </ref>.
References-found: 23

