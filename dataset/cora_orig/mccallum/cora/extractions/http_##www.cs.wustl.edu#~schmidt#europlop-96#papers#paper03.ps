URL: http://www.cs.wustl.edu/~schmidt/europlop-96/papers/paper03.ps
Refering-URL: http://www.cs.wustl.edu/~schmidt/europlop-96/ww1-papers.html
Root-URL: 
Email: e-mail: rueping@fzi.de  
Title: Framework Patterns  
Author: Andreas Rping 
Address: Haid-und-Neu-Strae 10-14 D-76131 Karlsruhe, Germany  
Affiliation: Forschungszentrum Informatik (FZI) Bereich Programmstrukturen  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides. </author> <title> Design Patterns - Elements of Reusable Object-Oriented Software. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: This makes the implementation more efficient. Solution Introduce subclasses for the special variants and hard-wire the corresponding subclasses when you know for sure that you will always use them together. Techniques for hard-wiring classes include factory methods and generic parameters: A1 A2 B1 B2 Andreas Rping 3 Factory methods <ref> [1] </ref> let subclasses decide which other subclasses they instantiate. If you choose one particular subclass representing one particular variant, the factory methods make sure you will also instan tiate the corresponding subclasses. Generic parameters can describe with which subclasses of other abstract classes a particular subclass can collaborate. <p> B1 B2 A1 A2 Andreas Rping 7 The factory object determines which variant of subclass objects it actually creates. For instance, this can depend on the factory objects state. Another option is to introduce an abstract factory <ref> [1] </ref>. Several concrete factories (F1 and F2) create different variants of subclass objects. One concrete factory is chosen and instantiated when the system starts. Example Use a factory object to consistently create the special windows, menus, and scrollbars, and youll have a consistent look and feel in your entire application. <p> When breaking down components into subcomponents, make sure that the subcomponents are orthogonal. Form subsystems in such a way that the same variation applies to all classes included in the subsystem. Example Build a subsystem consisting of Graph, Node, and Edge. Graph plays the role of a facade <ref> [1] </ref> because it provides the interface of the entire subsystem. Concrete subclasses of Graph create instances of subclasses of Node and Edge. When your application needs one particular graph, youll only have to state which subsystem you need rather then which classes you need. <p> The solution raises the issue of compatibility between subsystems. You can deal with compatibility between entire subsystems if you have a facade class (like C or D) <ref> [1] </ref> provide the subsystems interface. In this case you only have to consider the facade and its subclasses as far as compatibility is concerned [4]. A1 C1 D1 D2 D3 A2 C2 A C D DE 10 Framework Patterns Conclusions We have presented a pattern language for framework construction. <p> A1 C1 D1 D2 D3 A2 C2 A C D DE 10 Framework Patterns Conclusions We have presented a pattern language for framework construction. Patterns have turned out to be useful in the realm of frameworks before, for design <ref> [1] </ref> as well as for documentation purposes [3]. The main focus of our pattern language is on allowing as much exibility as possible while ensuring consistency at the same time. All our patterns contribute to a solution for this conict, each from a different context or point of view. <p> All our patterns contribute to a solution for this conict, each from a different context or point of view. Since our patterns are high-level design patterns, they can often be implemented by more concrete design patterns. As we have seen, some creational patterns from <ref> [1] </ref> such as Abstract Factory and Factory Method play an important role here. This comes to no surprise since framework instantiation has a lot to do with class instantiation or object creation. We dont claim completeness for the pattern language presented.
Reference: [2] <author> Ralph Johnson, Brian Foote. </author> <title> Designing Reusable Classes, in Journal of Object-Oriented Programming, Vol.1, No.2, May 1988. </title> <publisher> SIGS Publications, </publisher> <year> 1988. </year>
Reference-contexts: When we instantiate the framework, we customize its abstract architecture to obtain a concrete application. This way, we can use our framework to derive a number of application programs. These application programs reuse the frameworks architecture and represent solutions to a set of related problems <ref> [2] </ref>. A framework often comes with a library that offers numerous implementations for the abstract classes. The fact that there are many concrete components to choose from is what makes a framework so exible. Typically, only a subset of the concrete components are used in an application program.
Reference: [3] <author> Ralph Johnson. </author> <title> Documenting Frameworks using Patterns, </title> <editor> in Andreas Paepcke (Ed.), </editor> <booktitle> OOPSLA 92 - Object-Oriented Programming Systems, Languages, and Applications. Sigplan Notices Vol. </booktitle> <volume> 27, No. 10. </volume> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: A1 C1 D1 D2 D3 A2 C2 A C D DE 10 Framework Patterns Conclusions We have presented a pattern language for framework construction. Patterns have turned out to be useful in the realm of frameworks before, for design [1] as well as for documentation purposes <ref> [3] </ref>. The main focus of our pattern language is on allowing as much exibility as possible while ensuring consistency at the same time. All our patterns contribute to a solution for this conict, each from a different context or point of view.
Reference: [4] <author> Andreas Rping. </author> <title> Modules in Object-Oriented Systems, </title> <editor> in Raimund Ege, Madhu Singh, Bertrand Meyer (Eds.), </editor> <booktitle> TOOLS 14 - Technology of Object-Oriented Languages and Systems. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1994. </year>
Reference-contexts: You can deal with compatibility between entire subsystems if you have a facade class (like C or D) [1] provide the subsystems interface. In this case you only have to consider the facade and its subclasses as far as compatibility is concerned <ref> [4] </ref>. A1 C1 D1 D2 D3 A2 C2 A C D DE 10 Framework Patterns Conclusions We have presented a pattern language for framework construction. Patterns have turned out to be useful in the realm of frameworks before, for design [1] as well as for documentation purposes [3].
References-found: 4

