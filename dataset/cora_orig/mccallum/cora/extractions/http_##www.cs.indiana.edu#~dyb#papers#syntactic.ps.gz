URL: http://www.cs.indiana.edu/~dyb/papers/syntactic.ps.gz
Refering-URL: http://www.cs.indiana.edu/~dyb/pubs.html
Root-URL: http://www.cs.indiana.edu
Title: Syntactic Abstraction in Scheme  
Author: R. KENT DYBVIG ROBERT HIEB CARL BRUGGEMAN 
Keyword: Syntactic Abstraction, Macros, Program Transformation, Hygienic Macros  
Address: Bloomington, IN 47405  
Affiliation: Indiana University Computer Science Department  
Note: LISP AND SYMBOLIC COMPUTATION: An International Journal, 1993 c 1993 Kluwer Academic Publishers Manufactured in The Netherlands  (Revised: March, 1993)  
Email: (dyb@cs.indiana.edu)  (bruggema@cs.indiana.edu)  
Date: (Received: August, 1992)  
Abstract: Naive program transformations can have surprising effects due to the interaction between introduced identifier references and previously existing identifier bindings, or between introduced bindings and previously existing references. These interactions can result in inadvertent binding, or capturing, of identifiers. A further complication is that transformed programs may have little resemblance to original programs, making correlation of source and object code difficult. This article describes an efficient macro system that prevents inadvertent capturing while maintaining the correlation between source and object code. The macro system allows the programmer to define program transformations using an unrestricted, general-purpose language. Previous approaches to the capturing problem have been inadequate, overly restrictive, or inefficient, and the problem of source-object correlation has been largely unaddressed. The macro system is based on a new algorithm for implementing syntactic transformations and a new representation for syntactic expressions. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Steele Jr., Guy L. </author> <title> Common Lisp, the Language. </title> <note> Digital Press, second edition (1990). </note>
Reference-contexts: Its definition is shown later.) 16 DYBVIG, HIEB, AND BRUGGEMAN This same mechanism may be used to create aggregate identifier names typically required when defining structure-definition constructs such as Common Lisp's defstruct <ref> [1] </ref> as macros.
Reference: 2. <author> Barendregt, H. P. </author> <title> The Lambda Calculus: Its Syntax and Semantics. </title> <publisher> Elsevier Science Publishers, </publisher> <address> revised edition (1984). </address>
Reference-contexts: Alpha equivalence is the basis of Barendregt's variable convention, which assumes that the bound variables in terms used in definitions and proofs are always chosen to be different from the free variables <ref> [2, page 26] </ref>.
Reference: 3. <author> Bawden, Alan and Rees, Jonathan. </author> <title> Syntactic closures. </title> <booktitle> In Proceedings of the 1988 ACM Conference on Lisp and Functional Programming (July 1988) 86-95. </booktitle>
Reference-contexts: Since some macros cannot be expressed using this language, SYNTACTIC ABSTRACTION IN SCHEME 5 they have developed a low-level interface that requires new identifiers to be marked explicitly [4]. Bawden and Rees <ref> [3] </ref> approach the capturing problem from a different angle. Rather than providing automatic hygiene, their system forces the programmer to make explicit decisions about the resolution of free identifier references and the scope of identifier bindings. <p> Since constants can also be annotated, however, they too must be "exposed" before they can be examined. Source annotations can be implemented by adding another field to the wrapped expression structure of Section 4.4. 5. Conclusions The macro system described in this article, syntactic closures as augmented by Hanson <ref> [3, 13] </ref>, and the Clinger and Rees "explicit renaming" system [4, 5] are all compatible with the "high-level" facility (syntax-rules) described in the Revised 4 Report on Scheme [6]. Thus, the three systems differ primarily in the treatment of "low-level" macros.
Reference: 4. <author> Clinger, William. </author> <title> Hygienic macros through explicit renaming. LISP Pointers, </title> <type> 4, </type> <month> 4 </month> <year> (1991). </year>
Reference-contexts: Since some macros cannot be expressed using this language, SYNTACTIC ABSTRACTION IN SCHEME 5 they have developed a low-level interface that requires new identifiers to be marked explicitly <ref> [4] </ref>. Bawden and Rees [3] approach the capturing problem from a different angle. Rather than providing automatic hygiene, their system forces the programmer to make explicit decisions about the resolution of free identifier references and the scope of identifier bindings. <p> Source annotations can be implemented by adding another field to the wrapped expression structure of Section 4.4. 5. Conclusions The macro system described in this article, syntactic closures as augmented by Hanson [3, 13], and the Clinger and Rees "explicit renaming" system <ref> [4, 5] </ref> are all compatible with the "high-level" facility (syntax-rules) described in the Revised 4 Report on Scheme [6]. Thus, the three systems differ primarily in the treatment of "low-level" macros.
Reference: 5. <author> Clinger, William and Rees, Jonathan. </author> <title> Macros that work. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM Symposium on Principles of Programming Languages (January 1991) 155-162. </booktitle>
Reference-contexts: Local macros are referentially transparent in the sense that free identifiers appearing in the output of a local macro are scoped where the macro definition appears <ref> [5] </ref>. No keywords are reserved; keywords for core forms such as lambda as well as macro keywords defined by the program can be rebound, either as new macro keywords or as variables. <p> This is a serious problem for large programs that make heavy use of macros, i.e., nearly all large Scheme programs. Clinger and Rees <ref> [5] </ref> present an algorithm for hygienic macro transformations that does not have the quadratic time complexity of the KFFD algorithm. Their algorithm marks only the new identifiers introduced at each iteration of the macro transformation process, rather than all of the identifiers as in the KFFD algorithm. <p> The Revised 4 Report on Scheme [6] includes an appendix that contains a proposed macro system for Scheme. The high-level system (syntax-rules) described therein is a version of Kohlbecker's extend-syntax [8, 15, 16] with the same restrictions imposed by Clinger and Rees <ref> [5] </ref>. The revised-report appendix also describes a low-level system that, although it automatically preserves hygiene and referential transparency, requires manual destructuring of the input and restructuring of the output. <p> Source annotations can be implemented by adding another field to the wrapped expression structure of Section 4.4. 5. Conclusions The macro system described in this article, syntactic closures as augmented by Hanson [3, 13], and the Clinger and Rees "explicit renaming" system <ref> [4, 5] </ref> are all compatible with the "high-level" facility (syntax-rules) described in the Revised 4 Report on Scheme [6]. Thus, the three systems differ primarily in the treatment of "low-level" macros.
Reference: 6. <editor> Clinger, William, Rees, Jonathan, et al. </editor> <title> The revised 4 report on the algorithmic language Scheme. LISP Pointers, </title> <type> 4, </type> <month> 3 </month> <year> (1991). </year>
Reference-contexts: The macro system supports macros written in a general purpose programming language (Scheme) as well as macros written in high-level pattern languages such as extend-syntax [8, 15, 16] and syntax-rules <ref> [6] </ref>. Local macros are referentially transparent in the sense that free identifiers appearing in the output of a local macro are scoped where the macro definition appears [5]. <p> Their mechanism, however, does not enforce hygiene and handles only structured expressions; 6 DYBVIG, HIEB, AND BRUGGEMAN in particular, it does not handle variable references. The Revised 4 Report on Scheme <ref> [6] </ref> includes an appendix that contains a proposed macro system for Scheme. The high-level system (syntax-rules) described therein is a version of Kohlbecker's extend-syntax [8, 15, 16] with the same restrictions imposed by Clinger and Rees [5]. <p> Conclusions The macro system described in this article, syntactic closures as augmented by Hanson [3, 13], and the Clinger and Rees "explicit renaming" system [4, 5] are all compatible with the "high-level" facility (syntax-rules) described in the Revised 4 Report on Scheme <ref> [6] </ref>. Thus, the three systems differ primarily in the treatment of "low-level" macros. Our system extends automatic hygiene and referential transparency to the low level, whereas the other systems require explicit renaming of identifiers or construction of syntactic closures, which is tedious and error-prone.
Reference: 7. <author> Coutant, D., Meloy, S., and Ruscetta, M. </author> <title> DOC: A practical approach to source-level debugging of globally optimized code. </title> <booktitle> In Proceedings of the SIGPLAN '88 Conference on Programming Language Design and Implementation (July 1988) 125-134. </booktitle>
Reference-contexts: Reliable correlation of source code and macro-expanded code is necessary if the compiler, run-time system, and debugger are to communicate with the programmer in terms of the original source program. The effort invested in compilers to correlate source and optimized object code <ref> [7, 14, 19] </ref> is wasted if the macro expander loses the correlation of source and expanded code before compilation begins. The correlation techniques applied to optimizing compilers do not extend to macro processors because these techniques require that the entire set of possible code transformations be known a priori.
Reference: 8. <author> Dybvig, R. Kent. </author> <title> The Scheme Programming Language. </title> <publisher> Prentice-Hall (1987). </publisher>
Reference-contexts: This article presents a macro system for Scheme that enforces hygiene automatically while maintaining the correlation between source and object code. The macro system supports macros written in a general purpose programming language (Scheme) as well as macros written in high-level pattern languages such as extend-syntax <ref> [8, 15, 16] </ref> and syntax-rules [6]. Local macros are referentially transparent in the sense that free identifiers appearing in the output of a local macro are scoped where the macro definition appears [5]. <p> The Revised 4 Report on Scheme [6] includes an appendix that contains a proposed macro system for Scheme. The high-level system (syntax-rules) described therein is a version of Kohlbecker's extend-syntax <ref> [8, 15, 16] </ref> with the same restrictions imposed by Clinger and Rees [5]. The revised-report appendix also describes a low-level system that, although it automatically preserves hygiene and referential transparency, requires manual destructuring of the input and restructuring of the output. <p> in a subpattern followed by an ellipsis in the input. (Otherwise, the expander could not determine how many times the 5 A pattern datum is any nonlist, nonsymbol datum. 10 DYBVIG, HIEB, AND BRUGGEMAN subform should be repeated in the output.) This generalizes in a natural way to nested ellipses <ref> [8] </ref>. There is one exception to this rule: the special template ( ... ... ) expands into . . ..
Reference: 9. <author> Dybvig, R. Kent. </author> <title> Writing Hygienic Macros in Scheme with Syntax-Case. </title> <type> Technical Report 356, </type> <note> Indiana Computer Science Department (June 1992). 32 DYBVIG, HIEB, AND BRUGGEMAN </note>
Reference-contexts: Additional syntax-case examples appear in <ref> [9] </ref>. 4. The algorithm 4.1. Traditional macro systems Traditional Lisp macro systems rely on programs and data having the same representation, both textually and as internal structures.
Reference: 10. <author> Dybvig, R. Kent, Friedman, Daniel P., and Haynes, Christopher T. </author> <title> Expansion-passing style: Beyond conventional macros. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Lisp and Functional Programming (1986) 143-150. </booktitle>
Reference-contexts: He supports high-level definitions of derived notations in such a way that the definitions have certain formal properties that make them easy to reason about. As a result, however, his system is very restrictive with respect to the sort of macros that can be defined. Dybvig, Friedman, and Haynes <ref> [10, 11] </ref> address the source-object correlation problem, demonstrating that their proposed macro expansion protocol, expansion-passing style, is capable of maintaining source-object correlation even in the presence of arbitrary user-defined macros.
Reference: 11. <author> Dybvig, R. Kent, Friedman, Daniel P., and Haynes, Christopher T. </author> <title> Expansion-passing style: A general macro mechanism. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 1, </volume> <month> 1 </month> <year> (1988) </year> <month> 53-75. </month>
Reference-contexts: He supports high-level definitions of derived notations in such a way that the definitions have certain formal properties that make them easy to reason about. As a result, however, his system is very restrictive with respect to the sort of macros that can be defined. Dybvig, Friedman, and Haynes <ref> [10, 11] </ref> address the source-object correlation problem, demonstrating that their proposed macro expansion protocol, expansion-passing style, is capable of maintaining source-object correlation even in the presence of arbitrary user-defined macros.
Reference: 12. <author> Griffin, Timothy G. </author> <title> Definition and Top-Down Refinement for Interactive Proof Development Systems. </title> <type> PhD thesis, </type> <institution> Cornell University (August 1988). </institution>
Reference-contexts: This extends hygiene to local macros, which were not supported by the KFFD algorithm. Like automatic hygiene, this transparency is not present in either the syntactic closures or the Clinger/Rees low-level interfaces. Griffin <ref> [12] </ref> describes a theory of syntactic definitions in the context of interactive proof development systems. He supports high-level definitions of derived notations in such a way that the definitions have certain formal properties that make them easy to reason about.
Reference: 13. <author> Hanson, Chris. </author> <title> A syntactic closures macro facility. LISP Pointers, </title> <type> 4, </type> <month> 4 </month> <year> (1991). </year>
Reference-contexts: The result is a system that allows the programmer to avoid unwanted capturing. Unlike traditional closures, however, syntactic closures and their environments must be constructed explicitly. As a result, the mechanism is difficult to use and definitions created using it are hard to understand and verify. Hanson <ref> [13] </ref> alleviates this problem somewhat by demonstrating that the restricted high-level specification language supported by Clinger and Rees can be built on top of an extended version of syntactic closures. <p> Since constants can also be annotated, however, they too must be "exposed" before they can be examined. Source annotations can be implemented by adding another field to the wrapped expression structure of Section 4.4. 5. Conclusions The macro system described in this article, syntactic closures as augmented by Hanson <ref> [3, 13] </ref>, and the Clinger and Rees "explicit renaming" system [4, 5] are all compatible with the "high-level" facility (syntax-rules) described in the Revised 4 Report on Scheme [6]. Thus, the three systems differ primarily in the treatment of "low-level" macros.
Reference: 14. <author> Hennessy, J. </author> <title> Symbolic debugging of optimized code. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4, </volume> <month> 3 (July </month> <year> 1982) </year> <month> 323-344. </month>
Reference-contexts: Reliable correlation of source code and macro-expanded code is necessary if the compiler, run-time system, and debugger are to communicate with the programmer in terms of the original source program. The effort invested in compilers to correlate source and optimized object code <ref> [7, 14, 19] </ref> is wasted if the macro expander loses the correlation of source and expanded code before compilation begins. The correlation techniques applied to optimizing compilers do not extend to macro processors because these techniques require that the entire set of possible code transformations be known a priori.
Reference: 15. <author> Kohlbecker, Eugene. </author> <title> Syntactic Extensions in the Programming Language Lisp. </title> <type> PhD thesis, </type> <institution> Indiana University, </institution> <note> Bloomington (August 1986). </note>
Reference-contexts: This article presents a macro system for Scheme that enforces hygiene automatically while maintaining the correlation between source and object code. The macro system supports macros written in a general purpose programming language (Scheme) as well as macros written in high-level pattern languages such as extend-syntax <ref> [8, 15, 16] </ref> and syntax-rules [6]. Local macros are referentially transparent in the sense that free identifiers appearing in the output of a local macro are scoped where the macro definition appears [5]. <p> The Revised 4 Report on Scheme [6] includes an appendix that contains a proposed macro system for Scheme. The high-level system (syntax-rules) described therein is a version of Kohlbecker's extend-syntax <ref> [8, 15, 16] </ref> with the same restrictions imposed by Clinger and Rees [5]. The revised-report appendix also describes a low-level system that, although it automatically preserves hygiene and referential transparency, requires manual destructuring of the input and restructuring of the output.
Reference: 16. <author> Kohlbecker, Eugene and Wand, Mitchell. Macro-by-example: </author> <title> Deriving syntactic transformations from their specifications. </title> <booktitle> In Conference Record of the Fourteenth Annual ACM Symposium on Principles of Programming Languages (1987) 77-84. </booktitle>
Reference-contexts: This article presents a macro system for Scheme that enforces hygiene automatically while maintaining the correlation between source and object code. The macro system supports macros written in a general purpose programming language (Scheme) as well as macros written in high-level pattern languages such as extend-syntax <ref> [8, 15, 16] </ref> and syntax-rules [6]. Local macros are referentially transparent in the sense that free identifiers appearing in the output of a local macro are scoped where the macro definition appears [5]. <p> The Revised 4 Report on Scheme [6] includes an appendix that contains a proposed macro system for Scheme. The high-level system (syntax-rules) described therein is a version of Kohlbecker's extend-syntax <ref> [8, 15, 16] </ref> with the same restrictions imposed by Clinger and Rees [5]. The revised-report appendix also describes a low-level system that, although it automatically preserves hygiene and referential transparency, requires manual destructuring of the input and restructuring of the output.
Reference: 17. <author> Kohlbecker, Eugene, Friedman, Daniel P., Felleisen, Matthias, and Duba, Bruce. </author> <title> Hygienic macro expansion. </title> <booktitle> In Proceedings of the 1986 ACM Conference on Lisp and Functional Programming (1986) 151-161. </booktitle>
Reference-contexts: When one expression is substituted for another, apparent bindings can be shadowed, resulting in unintended capture of identifier references. The capturing problem, which is the source of many serious and difficult to find bugs, was first addressed by Kohlbecker, Friedman, Felleisen, and Duba <ref> [17] </ref>. <p> This insidious problem was first addressed by Kohlbecker, Friedman, Felleisen, and Duba <ref> [17] </ref>, who present an algorithm in which the macro system automatically renames bound variables to prevent inadvertent capturing. The fundamental notion underlying the KFFD algorithm is alpha equivalence, which equates terms that differ only in the names of bound variables. <p> Previous hygienic systems have provided mechanisms for explicit capturing, typically by allowing a macro to insert a symbol into an expansion as if it were part of the original source program <ref> [17] </ref>. Unfortunately, this means that macros cannot reliably expand into macros that use explicit capturing. Our system provides a more consistent way to accommodate such macros. A macro may construct implicit identifiers that behave as if they were present in the macro call.
Reference: 18. <author> Stoy, Joseph E. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press (1977). </publisher>
Reference-contexts: Furthermore, the pattern matching, destructuring, and restructuring facilities provided by the specification language must be completely abandoned for the same class of macros. Both low-level interfaces are completely different in style and usage from the high-level specification language. Macros defined in the high-level specification language are referentially transparent <ref> [18] </ref> in the sense that a macro-introduced identifier refers to the binding lexically visible where the macro definition appears rather than to the top-level binding or to the binding visible where the macro call appears. This extends hygiene to local macros, which were not supported by the KFFD algorithm.
Reference: 19. <author> Zellweger, P. </author> <title> An interactive high-level debugger for control-flow optimized programs. </title> <booktitle> In Proceedings of the ACM Software Engineering Symposium on High-Level Debugging (August 1983) 159-171. </booktitle>
Reference-contexts: Reliable correlation of source code and macro-expanded code is necessary if the compiler, run-time system, and debugger are to communicate with the programmer in terms of the original source program. The effort invested in compilers to correlate source and optimized object code <ref> [7, 14, 19] </ref> is wasted if the macro expander loses the correlation of source and expanded code before compilation begins. The correlation techniques applied to optimizing compilers do not extend to macro processors because these techniques require that the entire set of possible code transformations be known a priori.
References-found: 19

