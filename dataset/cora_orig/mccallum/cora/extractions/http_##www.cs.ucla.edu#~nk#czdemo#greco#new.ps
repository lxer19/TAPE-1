URL: http://www.cs.ucla.edu/~nk/czdemo/greco/new.ps
Refering-URL: http://www.cs.ucla.edu/~nk/czdemo/greco/
Root-URL: http://www.cs.ucla.edu
Email: greco@si:deis:unical:it zaniolo@cs:ucla:edu  
Title: Greedy Fixpoint Algorithms for Logic Programs with Negation and Extrema  
Author: Sergio Greco Carlo Zaniolo 
Date: October 22, 1997  
Address: Los Angeles 87030 Rende; Italy LosAngeles; CA 90024  
Affiliation: Dip: Elettr: Informatica Sist: Computer Science Dept: Universita della Calabria Univ: of California at  
Abstract: In the design of algorithms, the greedy paradigm provides a powerful tool for solving efficiently classical computational problems, within the framework of procedural languages. However, expressing these algorithms within the declarative framework of logic-based languages has proved to be a difficult research challenge. In this paper, we extend the framework of Datalog-like languages to obtain simple declarative formulations for such problems, and propose effective implementation techniques to ensure computational complexities comparable to those of procedural formulations. These advances are achieved through the use of the choice construct, that has semantics reducible to that of programs with negation under stable model semantics. Then we extend the fixpoint-based semantics of choice programs with preference annotations to guide search strategies and simple logic-based formulations of classical greedy algorithms. Finally, we show that with suitable storage structures, such as hash tables and priority queues, the computational complexity bounds on the execution of our declarative programs are the same as those of procedural algorithms for classical search and optimization problems. fl Work partially supported by ECUS033 and NSF Grant IRI-9314905
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Abiteboul S., E. Simon, V. Vianu. </author> <title> Non-Deterministic Language to Express Deterministic Transformation. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 215-229, </pages> <year> 1990. </year>
Reference: [2] <author> Abiteboul S., R. Hull, V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley. </publisher> <year> 1994. </year>
Reference-contexts: Because of the ability of choice programs to order the elements of a set, Datalog with choice is P-time complete and can, for instance, express the parity query|i.e., if a relation has an even number of elements <ref> [2] </ref>. This query can be expressed in standard Datalog only by assuming that the underdlying universe is totally ordered| an assumption that violates the data independence principle of genericity [5, 2]. <p> This query can be expressed in standard Datalog only by assuming that the underdlying universe is totally ordered| an assumption that violates the data independence principle of genericity <ref> [5, 2] </ref>.
Reference: [3] <author> Abiteboul S. and V. Vianu. </author> <title> Datalog Extensions for Databases Queries and Updates. </title> <journal> In Journal of Computer and System Science, </journal> <volume> 43, </volume> <pages> pages 62-124, </pages> <year> 1991. </year> <month> 41 </month>
Reference-contexts: The expressive power of the choice construct has been studied in [14, 11], where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator <ref> [3] </ref>, and the original version of choice proposed in [17], which is called static-choice, to distinguish from the dynamic choice used here [13]). <p> For instance, it has been shown in [13], that the task performed in Example 3 cannot be performed by positive programs with static choice or the witness operator <ref> [3] </ref>. In the rest of the paper, we will concentrate on nondeterminstic queries. In particular, our previous advisor example, can be modified using more sophisticated criteria to match students with candidate advisors.
Reference: [4] <author> Aho A.V., J.E. Hopcropt J.E., and J.D. </author> <title> Ullmann. The Design and analysis of Computer Algorithms. </title> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference: [5] <author> Chandra A., and D. Harel, </author> <title> Structure and Complexity of Relational Queries, </title> <journal> Journal of Computer and System Sciences 25, </journal> <volume> 1, </volume> <year> 1982, </year> <pages> pp. 99-128. </pages>
Reference-contexts: This query can be expressed in standard Datalog only by assuming that the underdlying universe is totally ordered| an assumption that violates the data independence principle of genericity <ref> [5, 2] </ref>.
Reference: [6] <author> Chomicki J., </author> <title> Temporal deductive databases, in Temporal Databases: Theory, Design and Implementation, </title> <editor> A. Tansel et al. eds., Benjamin/Cummings, </editor> <year> 1993. </year>
Reference-contexts: Furthermore, as we shall see later, these programs can be extended with choice without compromising their virtues. These approaches basically build on the Datalog 1S model <ref> [6] </ref> where predicates have a special (discrete-time) temporal argument that models a succession of events or states.
Reference: [7] <author> Ganguly S., S. Greco, and C. Zaniolo. </author> <title> Minimum and maximum predicates in logic programming. </title> <booktitle> In Proceedings of the Tenth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 154-163, </pages> <year> 1991. </year>
Reference: [8] <author> Ganguly S., S. Greco, and C. Zaniolo. </author> <title> Extrema Predicates in Deductive Databases. </title> <journal> Journal of Computer and System Science, </journal> <year> 1995. </year>
Reference: [9] <author> Greco S., C. Zaniolo, and S. Ganguly. </author> <title> Greedy by Choice. </title> <booktitle> In Proceedings of the 11th ACM Symposium on Principles of Database Systems, </booktitle> <year> 1992. </year>
Reference-contexts: In this paper, we introduce a new kind of specialization called greedy choice; this is motivated by the observation that it is frequently desirable to select a value that is the least (or the most) among the possible values and still satisfy the FDs defined by the choice atoms <ref> [9] </ref>. Therefore, with X denoting one or more variables of r and C denoting one single variable ranging over an ordered domain, a goal choice-least ((X),(C)) in a rule r can be used to denote that the FD choice ((X),(C)) is to be satisfied using least values of C.
Reference: [10] <author> Greco S., D. Sacca, and C. Zaniolo, </author> <booktitle> Dynamic Programming ... In Proc. of the International Logic programming Symposium Vancouver, </booktitle> <year> 1993. </year>
Reference: [11] <author> Greco S., D. Sacca, and C. Zaniolo, </author> <title> DATALOG Queries with Stratified Negation and Choice: from P to D P In Proc. </title> <booktitle> of the Fifth Int. Conf. on Database Theory, </booktitle> <year> 1995, </year> <pages> pp. 82-96. </pages>
Reference-contexts: This query can be expressed in standard Datalog only by assuming that the underdlying universe is totally ordered| an assumption that violates the data independence principle of genericity [5, 2]. The expressive power of the choice construct has been studied in <ref> [14, 11] </ref>, where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [3], and the original version of choice proposed in [17], which is called static-choice, to distinguish from the dynamic choice used here [13]).
Reference: [12] <author> Gelfond M. and V. Lifschitz. </author> <title> The stable model semantics of logic programming. </title> <booktitle> In Proceedings of the Fifth Intern. Conference on Logic Programming, </booktitle> <pages> pages 1070-1080, </pages> <year> 1988. </year>
Reference-contexts: introduction of the well-founded model semantics and stable-model semantics allows us to assign a formal meaning to most, if not all, programs of practical interest. Unfortunately, the computational problems remain largely unsolved; while various approaches have been proposed to more effective computations of well-founded models and stable models <ref> [25, 12] </ref>, these fall well short of matching the efficiency of classical procedural solutions, such as, say, algorithms that find shortest paths in graphs. In general, it is known that determining whether a program has a stable model is NP-complete [18]. <p> Since ground M (P ) is a positive program, it has a unique minimal model. A model M of P is said to be stable when M is also the minimum model of ground M (P ) <ref> [12] </ref>. A 4 given program can have one or more stable (total) model, or possibly none. Positive programs, locally stratified programs [21] and weakly stratified programs [22] are among those that have exactly one stable model. Let I be an interpretation for a program P .
Reference: [13] <author> Giannotti F., D. Pedreschi, D. Sacca, and C. Zaniolo. </author> <title> Nondeterminism in deductive databases. </title> <booktitle> In Proc. 2nd Int. Conf. on Deductive and Object-Oriented Databases, </booktitle> <year> 1991. </year>
Reference-contexts: (P; Majr); chosen (S; P): chosen (S; P) student (S; Majr; Yr); professor (P; Majr); :diffChoice (S; P): diffChoice (S; P) chosen (S; P 0 ); P 6= P 0 : 2 In general, the program f oe (P ) generated by the transformation discussed above has the following properties <ref> [13] </ref>: * f oe (P ) has one or more total stable models. * The chosen atoms in each stable model of f oe (P ) obey the FDs defined by the choice goals. The stable models of f oe (P ) are called choice models for P . <p> power of the choice construct has been studied in [14, 11], where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [3], and the original version of choice proposed in [17], which is called static-choice, to distinguish from the dynamic choice used here <ref> [13] </ref>). For instance, it has been shown in [13], that the task performed in Example 3 cannot be performed by positive programs with static choice or the witness operator [3]. In the rest of the paper, we will concentrate on nondeterminstic queries. <p> in [14, 11], where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [3], and the original version of choice proposed in [17], which is called static-choice, to distinguish from the dynamic choice used here <ref> [13] </ref>). For instance, it has been shown in [13], that the task performed in Example 3 cannot be performed by positive programs with static choice or the witness operator [3]. In the rest of the paper, we will concentrate on nondeterminstic queries. <p> For logic programs with infinite Herbrand universe, an additional assumption of fairness is needed to ensure completeness. As customary for database queries, computational complexity is evaluated with respect to the size of the database. Theorem 2. <ref> [13] </ref> Let P be a choice Datalog program. <p> It is therefore of interest to explore specializations of this concept that trade nondeterministic completeness (which is only of abstract interest to a programmer) in return for very concrete benefits, such as expressive power and performance. For instance, in the specialization called Eager Choice <ref> [13] </ref>, a maximal I is used in Equation 2. This results in a significant increase in expressive power , as demonstrated by the fact that negation can be emulated by eager choice [13, 14]. <p> For instance, in the specialization called Eager Choice [13], a maximal I is used in Equation 2. This results in a significant increase in expressive power , as demonstrated by the fact that negation can be emulated by eager choice <ref> [13, 14] </ref>.
Reference: [14] <author> Giannotti F., D. Pedreschi, C. Zaniolo, </author> <title> Semantics and Expressive Power of Non-Deterministic Constructs in Deductive, </title> <type> Technical Report C96-04, </type> <institution> Istituto CNUCE, Pisa,1996, </institution> <note> submitted for publication. </note>
Reference-contexts: This query can be expressed in standard Datalog only by assuming that the underdlying universe is totally ordered| an assumption that violates the data independence principle of genericity [5, 2]. The expressive power of the choice construct has been studied in <ref> [14, 11] </ref>, where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [3], and the original version of choice proposed in [17], which is called static-choice, to distinguish from the dynamic choice used here [13]). <p> Therefore, we have that, for any interpretation I of f oe (P ): T foe (P ) (I) = T P D (I) [ T P C (I): Following <ref> [14] </ref> we can now introduce a general operator for computing nondeterministic fixpoints of choice programs. Definition 2. <p> For instance, in the specialization called Eager Choice [13], a maximal I is used in Equation 2. This results in a significant increase in expressive power , as demonstrated by the fact that negation can be emulated by eager choice <ref> [13, 14] </ref>.
Reference: [15] <author> P. Helmann, B.M.E. Moret, and H.D. Shapiro. </author> <title> An Exact Characterization of Greedy Structures. </title> <journal> Siam J. Discrete Math., Vo. </journal> <volume> 6, No. 2, </volume> <pages> pages 274-283, </pages> <year> 1993. </year>
Reference-contexts: This entails simple declarative formulations and nearly optimal executions for large classes of problems, including those solvable using greedy algorithms. Greedy algorithms <ref> [16, 15] </ref> are those that solve a class of optimization problems, using a control structure of a single loop, where, at each iteration step some element judged the `best' at that stage is chosen and it is added to the solution. <p> Another interesting problem of deriving simple sufficient conditions for the propagation of least into stage stratified programs based on Matroid Theory [27] (or its generalizations such as greedoid [16] and Matroid embedding <ref> [15] </ref>).
Reference: [16] <author> Korte B. and L. Lovasz. </author> <title> Greedoids a structural framework for the greedy algorithm. </title> <editor> In W. R. Pulleyblank, editor, </editor> <booktitle> Progress in Combinatorial Optimization, </booktitle> <pages> pages 221-243. </pages> <publisher> Academic Press, </publisher> <year> 1984. </year> <month> 42 </month>
Reference-contexts: This entails simple declarative formulations and nearly optimal executions for large classes of problems, including those solvable using greedy algorithms. Greedy algorithms <ref> [16, 15] </ref> are those that solve a class of optimization problems, using a control structure of a single loop, where, at each iteration step some element judged the `best' at that stage is chosen and it is added to the solution. <p> Another interesting problem of deriving simple sufficient conditions for the propagation of least into stage stratified programs based on Matroid Theory [27] (or its generalizations such as greedoid <ref> [16] </ref> and Matroid embedding [15]).
Reference: [17] <author> Krishnamurthy R. and S. Naqvi. </author> <title> Non-deterministic choice in Datalog. </title> <booktitle> In Pro--ceedings of the 3rd International Conference on Data and Knowledge Bases, </booktitle> <year> 1988. </year>
Reference-contexts: The expressive power of the choice construct has been studied in [14, 11], where it is shown that it is more powerful than other nondeterministic constructs, including the witness operator [3], and the original version of choice proposed in <ref> [17] </ref>, which is called static-choice, to distinguish from the dynamic choice used here [13]). For instance, it has been shown in [13], that the task performed in Example 3 cannot be performed by positive programs with static choice or the witness operator [3].
Reference: [18] <author> Marek W., M. Truszczynski. </author> <title> Autoepistemic Logic. </title> <journal> Journal of ACM, </journal> <volume> 38(3) </volume> <pages> 588-619, </pages> <year> 1991. </year>
Reference-contexts: In general, it is known that determining whether a program has a stable model is NP-complete <ref> [18] </ref>. Therefore, in this paper we propose a different approach: while, at the semantic level, we strictly adhere to the formal declarative semantics of logic programs with negation, we also allow the use of extended non-monotonic constructs with first order semantics to facilitate the task of programmers and compilers alike. <p> the data complexity of computing a stable model for P is polynomial time. 2 Therefore, while finding a stable model for a Datalog program with negated goals is, assuming P 6= N P , in general exponential (checking if a Datalog program with negation admits a stable model is NP-complete <ref> [18] </ref>), for a choice Datalog program, P , the computation of one of the stable models for f oe (P ) can be performed in polynomial time using the Choice Fixpoint Computation.
Reference: [19] <author> Marek W., and M. Truszczynski, </author> <title> Nonmonotonic Logic|context dependent reasoning Springer-Verlag, </title> <year> 1993. </year>
Reference-contexts: While the unrestricted use of negation in recursive predicates leads to well-known semantics and implementation problems <ref> [19] </ref>, recently there have been introduced classes of programs, such as XY-stratification [29, 30], and the closely related notion of explicitly stratifiable programs [?], and Statelog [?], which yield locally stratified programs that are easy to recognize and implement.
Reference: [20] <author> Papadimitriou C., K. Steiglitz, </author> <title> Combinatorial Optimization: Algorithms and Complexity. </title> <address> Englewood Cliff, N.J., </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: of a relation in decreasing order. succ (root; root): succ (X; Y) succ ( ; X); d (Y); choice-most ((X); (Y)); choice ((Y); (X)): 2 Greedy algorithms often provide efficient approximate solutions to NP-complete problems; the following algorithm yields heuristically effective approximations of optimal solutions for the traveling salesperson problem <ref> [20] </ref>. Example 12. Greedy TSP. Given a complete undirected graph, the greedy approximate solution for the Traveling Salesman Problem (TSP) can be easily derived from the Hamiltonian path problem of Example 7 since on complete graph every simple path is hamiltonian.
Reference: [21] <author> Przymusinski T., </author> <title> On the declarative and procedural semantics of stratified deductive databases. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 193-216. </pages> <address> Morgan-Kaufman, Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: A model M of P is said to be stable when M is also the minimum model of ground M (P ) [12]. A 4 given program can have one or more stable (total) model, or possibly none. Positive programs, locally stratified programs <ref> [21] </ref> and weakly stratified programs [22] are among those that have exactly one stable model. Let I be an interpretation for a program P . <p> Let Q denote a program that is stratified or locally stratified; then, let ground j (Q) (ground j fl (Q)) denote the clauses in ground (Q) with head in the j-th stratum (stratums j). Then the well-founded model for Q which is also its unique stable model <ref> [21] </ref>, can be computed as follows: Procedure 1. Iterated Fixpoint for (locally) stratified programs. Input: Locally stratified program Q. Output: Set of atoms M ! .
Reference: [22] <author> Przymusinska A. and T. Przymusinski. </author> <title> Weakly Perfect Model Semantics for Logic Programs. </title> <booktitle> In Proceedings of the Fifth Intern. Conference on Logic Programming, </booktitle> <pages> pages 1106-1122, </pages> <year> 1988. </year>
Reference-contexts: A model M of P is said to be stable when M is also the minimum model of ground M (P ) [12]. A 4 given program can have one or more stable (total) model, or possibly none. Positive programs, locally stratified programs [21] and weakly stratified programs <ref> [22] </ref> are among those that have exactly one stable model. Let I be an interpretation for a program P .
Reference: [23] <author> Sacca D. and C. Zaniolo. </author> <title> Stable models and non-determinism in logic programs with negation. </title> <booktitle> Proceedings of the Ninth ACM Symposium on Principles of Database Systems, </booktitle> <pages> pages 205-217, </pages> <year> 1990. </year>
Reference: [24] <author> Ullmann J. F., </author> <booktitle> Principles of Data and Knowledge-Base Systems. </booktitle> <volume> Vol 1 & 2, </volume> <publisher> Computer Science Press, </publisher> <address> New York, </address> <year> 1989. </year>
Reference: [25] <author> Van Gelder A., K.A. Ross, and J.S. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> Journal of ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: introduction of the well-founded model semantics and stable-model semantics allows us to assign a formal meaning to most, if not all, programs of practical interest. Unfortunately, the computational problems remain largely unsolved; while various approaches have been proposed to more effective computations of well-founded models and stable models <ref> [25, 12] </ref>, these fall well short of matching the efficiency of classical procedural solutions, such as, say, algorithms that find shortest paths in graphs. In general, it is known that determining whether a program has a stable model is NP-complete [18].
Reference: [26] <author> Van Gelder A., </author> <booktitle> Foundations of Aggregations in Deductive Databases In Proc. of the Int. Conf. On Deductive and Object-Oriented databases, </booktitle> <year> 1993. </year>
Reference: [27] <author> Welsh D.J.A., </author> <title> editor. Matroid Theory. </title> <publisher> Academic Press, </publisher> <year> 1976. </year>
Reference-contexts: A intriguing problem is the detection and rewriting of naive programs where optimization predicates are used as postconditions, that are implementable by greedy algorithms. Another interesting problem of deriving simple sufficient conditions for the propagation of least into stage stratified programs based on Matroid Theory <ref> [27] </ref> (or its generalizations such as greedoid [16] and Matroid embedding [15]).
Reference: [28] <author> Zaniolo C., </author> <title> Intelligent Databases: Old Challenges and New Opportunities, </title> <journal> Journal of Intelligent Information Systems, </journal> <volume> 1, </volume> <pages> 271-292, </pages> <publisher> Kluwer Academic, </publisher> <year> 1992. </year>
Reference: [29] <author> Zaniolo, C., N. Arni, K. Ong, </author> <title> Negation and Aggregates in Recursive Rules: the LDL++ Approach, </title> <booktitle> Proc. 3rd Int. Conf. on Deductive and O-O DBs, </booktitle> <address> DOOD-93, Phoenix, AZ, </address> <month> Dec 6-8, </month> <year> 1993. </year>
Reference-contexts: While the unrestricted use of negation in recursive predicates leads to well-known semantics and implementation problems [19], recently there have been introduced classes of programs, such as XY-stratification <ref> [29, 30] </ref>, and the closely related notion of explicitly stratifiable programs [?], and Statelog [?], which yield locally stratified programs that are easy to recognize and implement. Furthermore, as we shall see later, these programs can be extended with choice without compromising their virtues. <p> issues: (i) are these programs well-formed from a semantic viewpoint, and (ii) (if they are semantically well-formed, e.g., have a stable model semantics) are they amenable to efficient implementation? Both these questions receive a positive answer, due to the particular syntactic structure of these programs that is known as XY-stratification <ref> [29] </ref>. XY-stratification is a special form of local stratification induced by particular structure of the temporal argument in the recursive predicates. This property can be checked on the basis of the syntax of the rules, thus it is independent of the extensional database [29] and ensures very efficient implementations. <p> these programs that is known as XY-stratification <ref> [29] </ref>. XY-stratification is a special form of local stratification induced by particular structure of the temporal argument in the recursive predicates. This property can be checked on the basis of the syntax of the rules, thus it is independent of the extensional database [29] and ensures very efficient implementations. The well founded model of a stratified program or a locally stratified program can be computed using the iterated fixpoint procedure discussed next. <p> Therefore unrestricted locally stratified programs cannot be allowed as such in practical computations. Thus, we will restrict our attention to a particular form of local stratification, called of XY-stratification, which can be recognized at compile time, and also yields very efficient executions <ref> [29] </ref>. We will now introduce the notion of XY-stratification and in the next section extend it in the presence of choice goals.
Reference: [30] <author> Zaniolo C., S. Ceri, C. Faloutsos, V.S. Subrahmanian and R. Zicari, </author> <title> Advanced Database Systems, </title> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1997. </year> <month> 43 </month>
Reference-contexts: While the unrestricted use of negation in recursive predicates leads to well-known semantics and implementation problems [19], recently there have been introduced classes of programs, such as XY-stratification <ref> [29, 30] </ref>, and the closely related notion of explicitly stratifiable programs [?], and Statelog [?], which yield locally stratified programs that are easy to recognize and implement. Furthermore, as we shall see later, these programs can be extended with choice without compromising their virtues. <p> The iterated fixpoint computation provides a general approach to the computation of the well-founded model for a locally stratified program. For an XY-stratified program P , this computation specializes into the following <ref> [30] </ref>: 3 However, if we have exit rules where the temporal argument is a constant greater than zero, or it is not a constant, then the exit rules might produce results at later steps, too. 22 Procedure 2. Stable model for XY-stratified programs. Input: XY-stratified program P . <p> In general the computation consists of two phases: (i) compilation and (ii) execution. All compilation algorithms discussed here execute with time complexity that is polynomial in the size of the programs. Moreover, we will assume, as it is customarly done <ref> [30] </ref>, that the size of the database dominates that of the program. Thus, execution costs dominate the compilation costs, which will then be disregarded in the derivation of the worst case complexities. We will employ the following two compilation techniques that are of common usage in deductive database systems [30]: * <p> done <ref> [30] </ref>, that the size of the database dominates that of the program. Thus, execution costs dominate the compilation costs, which will then be disregarded in the derivation of the worst case complexities. We will employ the following two compilation techniques that are of common usage in deductive database systems [30]: * Differential fixpoint computation for recursive programs without negation, and * Copy rule optimization for XY-stratified programs To expedite execution, we will take advantage of the following well-known storage structures: * Hash tables to support search on keys, and * Priority queues to support choice-least and choice-most goals.
References-found: 30

