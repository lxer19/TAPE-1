URL: http://theory.lcs.mit.edu/tds/papers/DePrisco/DVS.ps
Refering-URL: http://theory.lcs.mit.edu/tds/papers/DePrisco/dvs.html
Root-URL: 
Title: A Dynamic View-Oriented Group Communication Service  
Author: Roberto De Prisco Alan Fekete Nancy Lynch Alex Shvartsman Alex Shvartsman, 
Keyword: Paper format: Regular paper  
Address: 191 Auditorium Road,  CT 06269.  545 Technology Square, NE43-365, Cambridge, MA 02139, USA.  Madsen Building F09, University of Sydney, NSW 2006, Australia.  545 Technology Square, NE43-371, Cambridge, MA 02139, USA and  191 Auditorium Rd., U-155, University of Connecticut, Storrs, CT 06269.  
Affiliation: Dept. of Computer Science and Eng.,  University of Connecticut, Storrs,  MIT Laboratory for Computer Science,  Basser Department of Computer Science,  MIT Laboratory for Computer Science,  Dept. of Computer Science and Eng.,  
Note: Contact author:  
Pubnum: U-155,  
Email: E-mail: alex@theory.lcs.mit.edu.  
Date: January 9, 1998  
Abstract: View-oriented group communication services are widely used for fault-tolerant distributed computing. For applications involving coherent data, it is important to know when a process has a view of the current group membership that is primary, usually defined as a view containing a majority out of a static universe of processes. For high availability in a system where processes can join and leave routinely, some researchers have suggested defining primary views in a dynamic way, depending on having enough members in common with recent views. We present a new formal specification, dvs, for the safety guarantees made by a practical group communication service providing a dynamic notion of primary view. The specification is a simple automaton, with only seven kinds of actions. We demonstrate the value of the dvs specification by showing both how it can be implemented and how it can be used in an application. Both pieces are shown formally, with assertional proofs. First, we consider an implementation that is a variant of the group membership algorithm of Lotem, Keidar, and Dolev [29]. Our variant integrates communication with the membership service, uses information from the application processes saying when a view has been adequately prepared for computation by the application, and uses a static view-oriented service internally. We prove that this algorithm implements dvs, in the sense of trace inclusion. Second, we consider an application algorithm that is a variant of an algorithm in [2, 20, 26], modified to use dvs instead of a static view-oriented service. We show that it implements a (non-group-oriented) totally-ordered-broadcast service. Because of its simplicity, we believe that dvs will be easy to use for other applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <editor> Communications of the ACM, </editor> <booktitle> special section on group communications, </booktitle> <volume> vol. 39, no. 4, </volume> <year> 1996. </year>
Reference: [2] <author> Y. Amir, D. Dolev, P. Melliar-Smith and L. Moser, </author> <title> "Robust and Efficient Replication Using Group Communication" Technical Report 94-20, </title> <institution> Department of Computer Science, Hebrew University., </institution> <year> 1994. </year>
Reference-contexts: This specification consists of a simple state machine expressing safety requirements, plus a timed trace property expressing conditional performance/fault-tolerance requirements. This specification is easy to read and easy to use; we used it to prove the correctness of a complex totally-ordered-broadcast algorithm based on <ref> [26, 2] </ref>. <p> expressing a strong condition about nonempty intersections of views; the proof of this depends on relating a local check of majority intersection with known views to a global check of nonempty intersection with existing views. 2 Second, we consider an application algorithm that is a variant of an algorithm in <ref> [26, 2, 20] </ref>, modified to use dvs instead of a static view-oriented service. The modified algorithm uses the registration capability to tell the DVS service that information has been successfully exchanged at the beginning of a new view. We show that it implements a (non-group-oriented) totally-ordered-broadcast service.
Reference: [3] <author> Y. Amir, L. Moser, P. Melliar-Smith, D. Agrawal and P. Ciarfella, </author> <title> "Fast Message Ordering and Membership Using a Logical Token-Passing Ring", </title> <booktitle> in Proc. of IEEE International Conference on Distributed Computing Systems, </booktitle> <year> 1993, </year> <pages> pp 551-560. </pages>
Reference: [4] <author> O. Babaoglu, R. Davoli, L. Giachini and M. Baker, "Relacs: </author> <title> A Communication Infrastructure for Constructing Reliable Applications in Large-Scale Distributed Systems", </title> <booktitle> in Proc. of Hawaii International Conference on Computer and System Science, 1995, </booktitle> <volume> volume II, </volume> <pages> pp 612-621. </pages>
Reference-contexts: Within each view, the service offers guarantees about the order and reliability of message delivery. Examples of view-oriented group communication services are found in Isis [7], Transis [15], Totem [33], Newtop [18], Relacs <ref> [4] </ref>, and Horus [36]. In order to be useful to application programmers, system building blocks should come equipped with simple and precise specifications of their guaranteed behavior.
Reference: [5] <author> O. Babaoglu, R. Davoli and A. Montresor, </author> <title> "Failure Detectors, Group Membership and View-Synchronous Communication in Partitionable Asynchronous Systems", </title> <type> Technical Report UBLCS-95-18, </type> <institution> Department of Computer Science, University of Bologna, Italy. </institution>
Reference: [6] <author> O. Babaoglu, R. Davoli, L. Giachini and P. Sabattini, </author> <title> "The Inherent Cost of Strong-Partial View Synchronous Communication", </title> <booktitle> in Proc of Workshop on Distributed Algorithms, </booktitle> <pages> pp 72-86, </pages> <year> 1995. </year>
Reference: [7] <author> K.P. Birman and R. van Renesse, </author> <title> Reliable Distributed Computing with the Isis Toolkit, </title> <publisher> IEEE Computer Society Press, Los Alamitos, </publisher> <address> CA, </address> <year> 1994. </year>
Reference-contexts: Within each view, the service offers guarantees about the order and reliability of message delivery. Examples of view-oriented group communication services are found in Isis <ref> [7] </ref>, Transis [15], Totem [33], Newtop [18], Relacs [4], and Horus [36]. In order to be useful to application programmers, system building blocks should come equipped with simple and precise specifications of their guaranteed behavior.
Reference: [8] <author> T.D. Chandra, V. Hadzilacos, S. Toueg and B. Charron-Bost, </author> <title> "On the Impossibility of Group Membership", </title> <booktitle> in Proc. of 15 th Annual ACM Symp. on Principles of Distributed Comp., </booktitle> <pages> pp. 322-330, </pages> <year> 1996. </year>
Reference: [9] <author> G.V. Chockler, </author> <title> "An Adaptive Totally Ordered Multicast Protocol that Tolerates Partitions", </title> <type> manuscript, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, </institution> <month> August, </month> <year> 1997. </year>
Reference-contexts: This specification is easy to read and easy to use; we used it to prove the correctness of a complex totally-ordered-broadcast algorithm based on [26, 2]. Since then, Chockler has used a slightly simplified version of vs to model and verify an adaptive totally-ordered-broadcast algorithm <ref> [9] </ref>, Lesley and Fekete [28] have proved that a version of an algorithm of Cristian and Schmuck [12] implements vs, and Khazan has been using vs to model and verify a load-balancing database application [27]. The vs service produces arbitrary views, with arbitrary membership sets.
Reference: [10] <author> F. Cristian, </author> <title> "Synchronous and Asynchronous Group Communication", </title> <journal> Comm. of the ACM, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 88-97, </pages> <year> 1996. </year>
Reference: [11] <author> F. Cristian, </author> <title> "Group, Majority and Strict Agreement in Timed Asynchronous Distributed Systems", </title> <booktitle> in Proc. of 26 th Conference on Fault-Tolerant Computer Systems, </booktitle> <year> 1996, </year> <pages> pp. 178-187. </pages>
Reference: [12] <author> F. Cristian and F. Schmuck, </author> <title> "Agreeing on Processor Group Membership in Asynchronous Distributed Systems", </title> <type> Technical Report CSE95-428, </type> <institution> Dept. of Computer Science, University of California San Diego. </institution>
Reference-contexts: Since then, Chockler has used a slightly simplified version of vs to model and verify an adaptive totally-ordered-broadcast algorithm [9], Lesley and Fekete [28] have proved that a version of an algorithm of Cristian and Schmuck <ref> [12] </ref> implements vs, and Khazan has been using vs to model and verify a load-balancing database application [27]. The vs service produces arbitrary views, with arbitrary membership sets.
Reference: [13] <author> D. Davcev and W. Buckhard, </author> <title> "Consistency and recovery control for replicated files", </title> <booktitle> in ACM Symp. on Operating Systems Principles, n.10, </booktitle> <pages> pp. 87-96, </pages> <year> 1985. </year>
Reference-contexts: As a minimum, each primary must contain at least a majority of the processes in the previous primary. Several dynamic voting schemes have been developed to define primaries adaptively <ref> [13, 17, 25, 29, 35] </ref>. In particular, Lotem, Keidar, and Dolev [29] have described an implementation of a group 1 membership service that yields only primary views, according to a dynamic notion of primary.
Reference: [14] <author> S.E. Deering and D.R. Cheriton, </author> <title> "Multicast Routing in Datagram Internetworks and Extended LANs", </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> vol. 8, no. 2, </volume> <year> 1990. </year>
Reference: [15] <author> D. Dolev and D. Malki, </author> <title> "The Transis Approach to High Availability Cluster Communications", </title> <journal> Comm. of the ACM, </journal> <volume> vol. 39, no. 4, </volume> <pages> pp. 64-70, </pages> <year> 1996. </year>
Reference-contexts: Within each view, the service offers guarantees about the order and reliability of message delivery. Examples of view-oriented group communication services are found in Isis [7], Transis <ref> [15] </ref>, Totem [33], Newtop [18], Relacs [4], and Horus [36]. In order to be useful to application programmers, system building blocks should come equipped with simple and precise specifications of their guaranteed behavior.
Reference: [16] <author> D. Dolev, D. Malki and R. </author> <title> Strong "A framework for Partitionable Membership Service", </title> <type> Technical Report TR94-6, </type> <institution> Department of Computer Science, Hebrew University. </institution>
Reference: [17] <author> A. El Abbadi and S. Dani, </author> <title> "A dynamic accessibility protocol for replicated databases", </title> <journal> Data and knowledge engineering, </journal> <volume> n.6, </volume> <pages> pp. 319-332, </pages> <year> 1991. </year>
Reference-contexts: As a minimum, each primary must contain at least a majority of the processes in the previous primary. Several dynamic voting schemes have been developed to define primaries adaptively <ref> [13, 17, 25, 29, 35] </ref>. In particular, Lotem, Keidar, and Dolev [29] have described an implementation of a group 1 membership service that yields only primary views, according to a dynamic notion of primary.
Reference: [18] <author> P. Ezhilchelvan, R. Macedo and S. Shrivastava "Newtop: </author> <title> A Fault-Tolerant Group Communication Protocol" in Proc. </title> <booktitle> of IEEE Int-l Conference on Distributed Computing Systems, </booktitle> <year> 1995, </year> <pages> pp 296-306. </pages>
Reference-contexts: Within each view, the service offers guarantees about the order and reliability of message delivery. Examples of view-oriented group communication services are found in Isis [7], Transis [15], Totem [33], Newtop <ref> [18] </ref>, Relacs [4], and Horus [36]. In order to be useful to application programmers, system building blocks should come equipped with simple and precise specifications of their guaranteed behavior.
Reference: [19] <author> A. Fekete, F. Kaashoek and N. </author> <title> Lynch "Providing Sequentially-Consistent Shared Objects Using Group and Point-to-point Communication" in Proc. </title> <booktitle> of IEEE International Conference on Distributed Computer Systems, </booktitle> <year> 1995, </year> <pages> pp 439-449. </pages>
Reference: [20] <author> A. Fekete, N. Lynch and A. </author> <title> Shvartsman "Specifying and using a partitionable group communication service", </title> <booktitle> in Proc. of the 16 th annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Santa Barbara, CA, </address> <month> August </month> <year> 1997, </year> <pages> pp. 53-62. </pages>
Reference-contexts: Some examples of specifications for group membership services and view-oriented group communication services appear in [5, 6, 8, 11, 16, 20, 22, 23, 24, 32, 34, 37, 38]. In <ref> [20] </ref>, we presented a new specification, which we called vs, for a view-oriented group communication service. This specification consists of a simple state machine expressing safety requirements, plus a timed trace property expressing conditional performance/fault-tolerance requirements. <p> expressing a strong condition about nonempty intersections of views; the proof of this depends on relating a local check of majority intersection with known views to a global check of nonempty intersection with existing views. 2 Second, we consider an application algorithm that is a variant of an algorithm in <ref> [26, 2, 20] </ref>, modified to use dvs instead of a static view-oriented service. The modified algorithm uses the registration capability to tell the DVS service that information has been successfully exchanged at the beginning of a new view. We show that it implements a (non-group-oriented) totally-ordered-broadcast service. <p> Specifically, we use the I/O automaton model of Lynch and Tuttle [31] (without fairness). The model and associated methodology is described in Chapter 8 of [30]. 3 The vs specification In this work we use a modified version of the group communication service defined in <ref> [20] </ref>. The original service, called vs, assumes that every processor in the universe P of processors is a member of the initial view. In our setting the initial view is defined arbitrarily, and we modify the specification of vs to reflect this fact. <p> In our setting the initial view is defined arbitrarily, and we modify the specification of vs to reflect this fact. The modified specification is given in Figure 1. The specific modifications to the service specification in <ref> [20] </ref> are: * Initialization of the state variable created is changed from fv 0 g = fhg 0 ; Pig to fv 0 g = fhg 0 ; P 0 ig. * The type of state variables current-viewid [p] is changed from G to G ? ; the initialization of current-viewid <p> These modifications are extremely minor, and the modified service preserves the basic safety properties of the service in <ref> [20] </ref>: Monotone views: New views are reported in increasing order of view identifier. View synchrony: Messages sent in a view are delivered only within that view. <p> Having shown that F is an abstraction function, we infer Theorem 5.1. 6 Using the specification In this section we show how to use dvs to implement a totally ordered broadcast service. We use the same formal specification provided in <ref> [20] </ref>, called to. The specification is shown in Figure 7. We provide an implementation of the to service using dvs as a building block. This implementation is similar to the to implementation provided in [20] but exploits the extra information provided by the dvs service. The to implementation of [20] is <p> We use the same formal specification provided in <ref> [20] </ref>, called to. The specification is shown in Figure 7. We provide an implementation of the to service using dvs as a building block. This implementation is similar to the to implementation provided in [20] but exploits the extra information provided by the dvs service. The to implementation of [20] is built on top of the vs service which does not provide information about primary views. The to implementation [20] relies on primary views to establish the total order, thus it needs to determine whether <p> in <ref> [20] </ref>, called to. The specification is shown in Figure 7. We provide an implementation of the to service using dvs as a building block. This implementation is similar to the to implementation provided in [20] but exploits the extra information provided by the dvs service. The to implementation of [20] is built on top of the vs service which does not provide information about primary views. The to implementation [20] relies on primary views to establish the total order, thus it needs to determine whether or not the current view is primary, which is accomplished by a simple local test. <p> This implementation is similar to the to implementation provided in <ref> [20] </ref> but exploits the extra information provided by the dvs service. The to implementation of [20] is built on top of the vs service which does not provide information about primary views. The to implementation [20] relies on primary views to establish the total order, thus it needs to determine whether or not the current view is primary, which is accomplished by a simple local test. <p> Except for these differences, the to implementation is as in <ref> [20] </ref>. The overall implementation, called to-impl, is obtained by composing an automaton to-code p for each p 2 P with the dvs specification. The complete code for automaton to-code p is given in Figure 8 in the Appendix.
Reference: [21] <author> A. Fekete, N. Lynch and A. </author> <title> Shvartsman "Specifying and using a partitionable group communication service", </title> <note> extended version of [20], available at http://theory.lcs.mit.edu/tds </note>
Reference-contexts: The proof that F T O is an abstraction function from to-impl to to follows the outline of the one in <ref> [21] </ref>. However, the main invariant requires a different proof. That invariant is as follows. <p> Then for every x 2 allstate with x:high &gt; v:id , x:ord . This invariant has a more subtle proof then the one given in Lemma 6.17 of <ref> [21] </ref>. That proof uses the strong intersection property among primary view membership (in the implementation of [21] each primary view intersects each other primary view). The proof in [21] does not work in the setting of dvs because dvs guarantees a weaker intersection property (each primary view intersects only the primary <p> Then for every x 2 allstate with x:high &gt; v:id , x:ord . This invariant has a more subtle proof then the one given in Lemma 6.17 of <ref> [21] </ref>. That proof uses the strong intersection property among primary view membership (in the implementation of [21] each primary view intersects each other primary view). The proof in [21] does not work in the setting of dvs because dvs guarantees a weaker intersection property (each primary view intersects only the primary views in between the preceding and the following totally registered primary views). <p> This invariant has a more subtle proof then the one given in Lemma 6.17 of <ref> [21] </ref>. That proof uses the strong intersection property among primary view membership (in the implementation of [21] each primary view intersects each other primary view). The proof in [21] does not work in the setting of dvs because dvs guarantees a weaker intersection property (each primary view intersects only the primary views in between the preceding and the following totally registered primary views).
Reference: [22] <author> R. Friedman and R. van Renesse, </author> <title> "Strong and Weak Virtual Synchrony in Horus", </title> <type> Technical Report TR95-1537, </type> <institution> Department of Computer Science, Cornell University. </institution> <month> 11 </month>
Reference: [23] <author> M. Hiltunen and R. </author> <title> Schlichting "Properties of Membership Services", </title> <booktitle> in Proc. of 2 nd International Symposium on Autonomous Decentralized Systems, </booktitle> <pages> pp 200-207, </pages> <year> 1995. </year>
Reference: [24] <author> F. Jahanian, S. Fakhouri and R. Rajkumar, </author> <title> "Processor Group Membership Protocols: Specification, </title> <booktitle> Design and Implementation", in Proc. of 12 th IEEE Symp. on Reliable Distrib. </booktitle> <pages> Systems pp 2-11, </pages> <year> 1993. </year>
Reference: [25] <author> S. Jajodia and D. Mutchler, </author> <title> "Dynamic voting algorithms for maintaining the consistency of a replicated database", </title> <journal> ACM Trans. Database Systems, </journal> <volume> n.15(2), </volume> <pages> pp. 230-280, </pages> <year> 1990. </year>
Reference-contexts: As a minimum, each primary must contain at least a majority of the processes in the previous primary. Several dynamic voting schemes have been developed to define primaries adaptively <ref> [13, 17, 25, 29, 35] </ref>. In particular, Lotem, Keidar, and Dolev [29] have described an implementation of a group 1 membership service that yields only primary views, according to a dynamic notion of primary.
Reference: [26] <author> I. Keidar and D. Dolev, </author> <title> "Efficient Message Ordering in Dynamic Networks", </title> <booktitle> in Proc. of 15 th Annual ACM Symp. on Principles of Distributed Computing, </booktitle> <pages> pp. 68-76, </pages> <year> 1996. </year>
Reference-contexts: This specification consists of a simple state machine expressing safety requirements, plus a timed trace property expressing conditional performance/fault-tolerance requirements. This specification is easy to read and easy to use; we used it to prove the correctness of a complex totally-ordered-broadcast algorithm based on <ref> [26, 2] </ref>. <p> expressing a strong condition about nonempty intersections of views; the proof of this depends on relating a local check of majority intersection with known views to a global check of nonempty intersection with existing views. 2 Second, we consider an application algorithm that is a variant of an algorithm in <ref> [26, 2, 20] </ref>, modified to use dvs instead of a static view-oriented service. The modified algorithm uses the registration capability to tell the DVS service that information has been successfully exchanged at the beginning of a new view. We show that it implements a (non-group-oriented) totally-ordered-broadcast service.
Reference: [27] <author> R. Khazan, </author> <title> "Group Communication as a base for a Load-Balancing, Replicated Data Service", M.S. </title> <type> thesis, </type> <note> to appear, </note> <institution> Dept. of Elec. Eng. and Computer Science, Massachusetts Institute of Technology. </institution>
Reference-contexts: has used a slightly simplified version of vs to model and verify an adaptive totally-ordered-broadcast algorithm [9], Lesley and Fekete [28] have proved that a version of an algorithm of Cristian and Schmuck [12] implements vs, and Khazan has been using vs to model and verify a load-balancing database application <ref> [27] </ref>. The vs service produces arbitrary views, with arbitrary membership sets. However, in many applications of vs, especially those with strong data coherence requirements, the application processes perform significant computations only when they have a special type of view called a primary view .
Reference: [28] <author> N. Lesley and A. Fekete, </author> <title> "Providing virtual synchrony for group communication services", </title> <note> Preprint 1997. </note>
Reference-contexts: This specification is easy to read and easy to use; we used it to prove the correctness of a complex totally-ordered-broadcast algorithm based on [26, 2]. Since then, Chockler has used a slightly simplified version of vs to model and verify an adaptive totally-ordered-broadcast algorithm [9], Lesley and Fekete <ref> [28] </ref> have proved that a version of an algorithm of Cristian and Schmuck [12] implements vs, and Khazan has been using vs to model and verify a load-balancing database application [27]. The vs service produces arbitrary views, with arbitrary membership sets.
Reference: [29] <author> E. Lotem, I Keidar and D. Dolev, </author> <title> "Dynamic voting for consistent primary components", </title> <booktitle> in Proc. of the 16 th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Santa Barbara, CA, </address> <month> August </month> <year> 1997, </year> <pages> pp. 63-71. </pages>
Reference-contexts: As a minimum, each primary must contain at least a majority of the processes in the previous primary. Several dynamic voting schemes have been developed to define primaries adaptively <ref> [13, 17, 25, 29, 35] </ref>. In particular, Lotem, Keidar, and Dolev [29] have described an implementation of a group 1 membership service that yields only primary views, according to a dynamic notion of primary. <p> As a minimum, each primary must contain at least a majority of the processes in the previous primary. Several dynamic voting schemes have been developed to define primaries adaptively [13, 17, 25, 29, 35]. In particular, Lotem, Keidar, and Dolev <ref> [29] </ref> have described an implementation of a group 1 membership service that yields only primary views, according to a dynamic notion of primary. <p> These difficulties have led to errors in some of the past work on dynamic voting. The algorithm of <ref> [29] </ref> copes with these subtleties by maintaining information about a collection of primary views that "might be" the previous primary view. The service deals with group membership only, and not with communication. <p> This registration information appears to be important for the correctness of coherent-data applications run over a dynamic view-oriented group communication service. Another important feature of our specification, compared to that in <ref> [29] </ref>, is that our specification is given as an automaton, which maintains state information about the views and the messages sent in each view. <p> We build the algorithm on top of the vs service and we use ideas from <ref> [29] </ref>. The overall system is shown in Figure 4. It consists of client client p and automaton dvs-code p at each processor p, and the underlying vs service. The automaton dvs-code p is given in Figure 5. The composition of all dvs-code p automata and vs gives the implementation dvs-impl. <p> head of msgs-from-vs [client-cur.id] Eff: remove head of msgs-from-vs [client-cur.id] input vs-safe (m) q;p , where m 2 M c Eff: append hm; qi to safe-from-vs [cur.id] output dvs-safe (m) p Pre: hm; qi is head of safe-from-vs [client-cur.id] Eff: remove head of safe-from-vs [client-cur.id] mation, as pointed out in <ref> [29] </ref>, is crucial to preserving consistency. Thus each processor p has an "active" view, act p which is the latest view it knows is totally registered. Information about views previous to act p is deleted. Views after act p are kept in amb p .
Reference: [30] <author> N.A. Lynch, </author> <title> Distributed Algorithms, </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1996. </year>
Reference-contexts: The services and algorithms are described using state machine models. Specifically, we use the I/O automaton model of Lynch and Tuttle [31] (without fairness). The model and associated methodology is described in Chapter 8 of <ref> [30] </ref>. 3 The vs specification In this work we use a modified version of the group communication service defined in [20]. The original service, called vs, assumes that every processor in the universe P of processors is a member of the initial view.
Reference: [31] <author> N.A. Lynch and M.R. Tuttle, </author> <title> "An Introduction to Input/Output Automata", </title> <journal> CWI Quarterly, vol.2, </journal> <volume> no. 3, </volume> <pages> pp. 219-246, </pages> <year> 1989. </year>
Reference-contexts: The services and algorithms are described using state machine models. Specifically, we use the I/O automaton model of Lynch and Tuttle <ref> [31] </ref> (without fairness). The model and associated methodology is described in Chapter 8 of [30]. 3 The vs specification In this work we use a modified version of the group communication service defined in [20].
Reference: [32] <author> L. Moser, Y. Amir, P. Melliar-Smith and D. Agrawal, </author> <title> "Extended Virtual Synchrony" in Proc. </title> <booktitle> of IEEE International Conference on Distributed Computing Systems, </booktitle> <year> 1994, </year> <pages> pp 56-65. </pages>
Reference: [33] <author> L.E. Moser, P.M. Melliar-Smith, D.A. Agarawal, R.K. Budhia and C.A. Lingley-Papadopolous, </author> <month> "Totem: </month>
Reference-contexts: Within each view, the service offers guarantees about the order and reliability of message delivery. Examples of view-oriented group communication services are found in Isis [7], Transis [15], Totem <ref> [33] </ref>, Newtop [18], Relacs [4], and Horus [36]. In order to be useful to application programmers, system building blocks should come equipped with simple and precise specifications of their guaranteed behavior.
References-found: 33

