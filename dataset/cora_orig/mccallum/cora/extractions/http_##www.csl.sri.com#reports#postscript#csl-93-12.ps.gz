URL: http://www.csl.sri.com/reports/postscript/csl-93-12.ps.gz
Refering-URL: http://www.csl.sri.com/fm-papers.html
Root-URL: 
Title: Microprocessor Verification in PVS A Methodology and Simple Example  
Author: David Cyrluk 
Date: February 10, 1994  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martn Abadi and Leslie Lamport. </author> <title> The existence of refinement mappings. </title> <booktitle> In Third Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 165-175. </pages> <publisher> IEEE, Computer Society Press, </publisher> <month> July </month> <year> 1988. </year>
Reference-contexts: The current trend is to specify such systems as state transition systems. This is the approach taken in both Unity [3] and TLA [6]. This approach has also been used in protocol verification [5], and microprocessor verification [9]. Abadi and Lamport <ref> [1] </ref> discuss this approach and under what conditions it can be used. Over the past year we have used a general methodology based on state transition systems to verify the correctness of several hardware circuits. <p> We then explore one variation of the simple methodology in detail: how to handle timing differences between the specification and implementation machines. We present two alternatives for dealing with this problem. The first alternative 1 Abadi and Lamport <ref> [1] </ref> call this a refinement mapping. 5 is to "slow down" the specification machine. The second alternative is to "speed up" the implementation machine. We illustrate these two alternatives by applying them to the verification of a pipelined microprocessor [8].
Reference: [2] <author> Alexandre Bronstein. </author> <title> MLP: String-Functional Semantics and Boyer-Moore Mechanization for the Formal Verification of Synchronous Circuits. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1989. </year>
Reference-contexts: We compare the two approaches based on naturalness of specification and ease of proof. 5.3.1 Specification The approaches discussed in this paper allow a very straightforward encoding of the original circuits. It should be possible to automatically translate circuit descriptions into the logical specifications used in these approaches. (Bronstein <ref> [2] </ref> describes such a translation into the 43 Boyer-Moore logic.) The approaches are all flexible enough to allow the user to encode the circuits in different ways that may facilitate an easier proof of correctness.
Reference: [3] <author> K. Mani Chandy and Jayadev Misra. </author> <title> Parallel Program Design: A Foundation. </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: Such systems include reactive software systems such as operating systems, concurrent processes, many hardware circuits such as microprocessors, and many protocols such as cache coherence. The current trend is to specify such systems as state transition systems. This is the approach taken in both Unity <ref> [3] </ref> and TLA [6]. This approach has also been used in protocol verification [5], and microprocessor verification [9]. Abadi and Lamport [1] discuss this approach and under what conditions it can be used. <p> We would need to show that neither system violates those conditions when put together. One way of doing such things is by showing that each system does not violate some invariant of the other system. Unity <ref> [3] </ref> explores some of these issues. In regard to stating these invariants, the explicit timing approach might be more natural. However more work needs to go into this. 47 Chapter 6 Conclusions Many verification problems can be stated as equivalences of state machines.
Reference: [4] <author> John Hopcroft and Jeffrey Ullman. </author> <title> Introduction to Automata Theory, Languages, and Computation. </title> <publisher> Addison Wesley, </publisher> <year> 1979. </year>
Reference-contexts: This function takes a machine state and returns the corresponding output for that state. This corresponds to a Moore machine. In the case of a Mealy machine, the output will also be a function of the input. (For definitions and properties of these machines the reader is referred to <ref> [4] </ref>.) A boilerplate PVS specification of a state machine is presented in Figure 2.1. state_machine : THEORY BEGIN machine_state: TYPE = &lt;state type&gt; input: TYPE = &lt;input type&gt; output: TYPE = &lt;output type&gt; next_state: [machine_state, input -&gt; machine_state] % Specification of behavior of the next state function output: [machine_state -&gt; output]
Reference: [5] <author> Simon S. Lam and Udaya Shankar. </author> <title> A relational notation for state transition systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(7) </volume> <pages> 755-775, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: The current trend is to specify such systems as state transition systems. This is the approach taken in both Unity [3] and TLA [6]. This approach has also been used in protocol verification <ref> [5] </ref>, and microprocessor verification [9]. Abadi and Lamport [1] discuss this approach and under what conditions it can be used. Over the past year we have used a general methodology based on state transition systems to verify the correctness of several hardware circuits.
Reference: [6] <author> Leslie Lamport. </author> <title> The temporal logic of actions. </title> <type> Technical Report 79, </type> <institution> Digital Systems Research Center, </institution> <address> 130 Lytton Avenue; Palo Alto, California 94301, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: Such systems include reactive software systems such as operating systems, concurrent processes, many hardware circuits such as microprocessors, and many protocols such as cache coherence. The current trend is to specify such systems as state transition systems. This is the approach taken in both Unity [3] and TLA <ref> [6] </ref>. This approach has also been used in protocol verification [5], and microprocessor verification [9]. Abadi and Lamport [1] discuss this approach and under what conditions it can be used.
Reference: [7] <author> Sam Owre, John M. Rushby, and Natarajan Shankar. PVS: </author> <title> A prototype verification system. </title> <editor> In Deepak Kapur, editor, </editor> <booktitle> Automated Deduction - CADE-11, 11th International Conference on Automated Deduction, Lecture Notes in Artifical Intelligence, </booktitle> <pages> pages 748-752. </pages> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: Over the past year we have used a general methodology based on state transition systems to verify the correctness of several hardware circuits. In this paper we show how one can follow this methodology to verify state machine systems in the PVS verification system <ref> [7] </ref>. We illustrate this methodology on two examples|a simple example, part of a trip meter, and a more complex example, a pipelined microprocessor. The methodology consists of specifying both the specification and implementation of the system using state machines.
Reference: [8] <author> James B. Saxe, Stephen J. Garland, John V. Guttag, and James J. Horning. </author> <title> Using transformations and verification in circuit design. </title> <type> Technical Report 78, </type> <institution> Digital Systems Research Center, </institution> <address> 130 Lytton Avenue; Palo Alto, California 94301, </address> <month> September </month> <year> 1991. </year>
Reference-contexts: The first alternative 1 Abadi and Lamport [1] call this a refinement mapping. 5 is to "slow down" the specification machine. The second alternative is to "speed up" the implementation machine. We illustrate these two alternatives by applying them to the verification of a pipelined microprocessor <ref> [8] </ref>. It turns out that the choice of alternative does make a difference as to naturalness of specification and ease of proof. At the end of the paper we discuss other possible variations of this methodology, paying particular attention to their appropriateness for hardware verification. <p> Time was implicit in there being a sequence of states, but no explicit variable representing time was needed. However, there is a style of specification in which an explicit time variable can be used. Saxe, et al <ref> [8] </ref> use the explicit time style, for example. We will need to make use of the explicit time style when we slow down the specification machine. In the explicit time style execution traces are explicitly represented as functions from time to machine states. <p> The high level statement of correctness can then be stated differently than in the previous section, but ultimately, the proof of correctness still comes down to showing the commuta-tivity of diagram 2.4 (b). For further details see <ref> [8] </ref> or the discussion later in this paper. 12 trace_equiv [Astate, Istate, input, output: TYPE, A: [Astate, input -&gt; Astate], I: [Istate, input -&gt; Istate], Abst: (surjective?[Istate, Astate]), Aoutput: [Astate -&gt; output], Ioutput: [Istate -&gt; output]]: THEORY BEGIN ASSUMING Commutes: ASSUMPTION FORALL (s: Istate), (inp: input): Abst (I (s, inp)) = <p> Note that this mapping might be different for different stuttering states. In addition, because we no longer have explicit next-state functions, our definition of correctness needs to be changed. For details on this approach see <ref> [8] </ref>, as well as the discussion and example found later in this paper. 24 Chapter 5 A Pipelined Microprocessor We now illustrate how the two different approaches can be applied to a somewhat complicated example. This example is a pipelined microprocessor initially verified by Saxe, et al [8]. <p> this approach see <ref> [8] </ref>, as well as the discussion and example found later in this paper. 24 Chapter 5 A Pipelined Microprocessor We now illustrate how the two different approaches can be applied to a somewhat complicated example. This example is a pipelined microprocessor initially verified by Saxe, et al [8]. Figure 5.1 shows the non-pipelined version of the microprocessor which will be used as the specification. Figure 5.2 shows the pipelined version which will be used as the implementation. The reader is referred to [8] for an informal description of these circuits. <p> This example is a pipelined microprocessor initially verified by Saxe, et al <ref> [8] </ref>. Figure 5.1 shows the non-pipelined version of the microprocessor which will be used as the specification. Figure 5.2 shows the pipelined version which will be used as the implementation. The reader is referred to [8] for an informal description of these circuits. In this stripped-down microprocessor two types of instructions are distinguished|normal instructions and branch instructions. <p> If an instruction needs the value of a register that a previous instruction has written, but which hasn't been written in the register file yet (due to the pipeline delay), then this logic forwards the value of that register directly back to the ALU. (See <ref> [8] </ref> or the specification below for more details.) When the pipeline is being flushed due to a branch instruction, one of the IBC registers will be set to T. When this is the case, we say that the pipeline is stalled. In addition to this implementation [8] gives a third implementation <p> to the ALU. (See <ref> [8] </ref> or the specification below for more details.) When the pipeline is being flushed due to a branch instruction, one of the IBC registers will be set to T. When this is the case, we say that the pipeline is stalled. In addition to this implementation [8] gives a third implementation which is a more efficient version of this one obtained by retiming. 26 5.1 Speeding Up the Implementation Machine We now describe the verification of the microprocessor using the visible-state approach. 5.1.1 Overview We first give an overview of the verification. <p> to split these two cases each in two: one case for a branch instruction, one for a non-branch instruction. 5.1.2 The PVS Specification We now present in more detail the PVS specifications of the specification machine, implementation machine and the abstraction mapping between the two machines. from the presentation in <ref> [8] </ref>. 28 mux [data: TYPE]: THEORY BEGIN mux ((flg: bool), (a:data), (b: data)): data = (IF flg THEN b ELSE a ENDIF) END mux register_file [addr: TYPE, data: TYPE] : THEORY BEGIN null: addr register_file: TYPE = function [addr -&gt; data] select ((a: addr), (r: register_file)): data = r (a) assign <p> Rather than give all the details we just highlight the differences between the verification using the stuttering approach and the verification using the visible-state approach. The reader is referred to section 5.2.2 and <ref> [8] </ref> for more details. 36 5.2.1.1 Relating the Two Machines To relate the two machines we need to define when the specification machine stutters, and the abstraction mapping from the implementation machine to the specification machine. The specification machine stutters exactly when the implementation machine goes through non-visible states. <p> the visible-state approach the proof was broken down into cases of whether the instruction was a branch instruction or not, in the stuttering approach the proof was broken down into separate cases for each different stuttering transition. 5.2.2 The PVS Specification obtained in a straightforward manner from the presentation in <ref> [8] </ref>. Time is represented by the natural numbers. The wires in the circuit are represented as functions from time to the types that the wires carry. Hardware elements are represented as functions from the types on their input lines to the types on their output lines. <p> This set of equations, taken as a whole, specifies for each specification wire, an equivalent term involving only implementation wires. A requirement on this mapping is that the set of equations must be a conservative extension of the implementation. See <ref> [8] </ref> for details. The key equations that relate the implementation state to the specification state are SRF abs and SPCtr abs. Together they state that the effects of the instruction at the program counter at time t won't be reflected in the register file until time t + 3. <p> We saw this in the proofs of correctness of the microprocessor. The user had to separately deal with the cases of internal forwarding. Once this was done the remainder of the proof was essentially mechanical. 5.3.3 Verification of Saxe et al. The verification done in <ref> [8] </ref> uses the explicit-time style and stuttering approach to relating the two machines. Our comments concerning the stuttering approach apply equally well to the verification reported in [8]. The main difference between that verification and ours is in the theorem prover. Saxe et al. use the Larch Prover (LP). <p> Once this was done the remainder of the proof was essentially mechanical. 5.3.3 Verification of Saxe et al. The verification done in <ref> [8] </ref> uses the explicit-time style and stuttering approach to relating the two machines. Our comments concerning the stuttering approach apply equally well to the verification reported in [8]. The main difference between that verification and ours is in the theorem prover. Saxe et al. use the Larch Prover (LP). <p> In spite of these differences the proofs of correctness in the two systems are pretty much the same. If anything, perhaps there is more user guidance in the proof in <ref> [8] </ref>.
Reference: [9] <author> Mandayam Srivas and Mark Bickford. </author> <title> Formal verification of a pipelined microprocessor. </title> <journal> IEEE Software, </journal> <volume> 7(5) </volume> <pages> 52-64, </pages> <month> September </month> <year> 1990. </year> <month> 49 </month>
Reference-contexts: The current trend is to specify such systems as state transition systems. This is the approach taken in both Unity [3] and TLA [6]. This approach has also been used in protocol verification [5], and microprocessor verification <ref> [9] </ref>. Abadi and Lamport [1] discuss this approach and under what conditions it can be used. Over the past year we have used a general methodology based on state transition systems to verify the correctness of several hardware circuits. <p> Proving these lemmas correspond to verifying the pipeline invariants in <ref> [9] </ref>. We now need to specify the abstraction function that maps an implementation state to its corresponding specification state. The specification machine state is defined by the values of the program counter, SPCtr, and the register file, SRF. <p> One way is to have the specification machine consume the "correct" number of inputs in each cycle|one input for each stalled cycle. (This is the approach taken in <ref> [9] </ref>.) As mentioned earlier this potentially runs into the same problems as in the stuttering approach. The approach we took is to have the implementation machine only consume one input for each visible-state transition. Unfortunately, this may not always be reasonable. <p> The approach we took is to have the implementation machine only consume one input for each visible-state transition. Unfortunately, this may not always be reasonable. For example, in the verification of microprocessors with interrupts (such as <ref> [9] </ref>), the number of non-visible states depends on the input interrupt signal. This interrupt can occur during non-visible transitions as well as during visible transitions.
References-found: 9

