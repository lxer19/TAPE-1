URL: http://haskell.systemsz.cs.yale.edu/haskell/report/haskell-report.ps.gz
Refering-URL: http://haskell.systemsz.cs.yale.edu/haskell/report/
Root-URL: http://www.cs.yale.edu
Author: John Peterson [editor] Kevin Hammond [editor] Lennart Augustsson Brian Boutel Warren Burton Joseph Fasel Andrew D. Gordon John Hughes Paul Hudak Thomas Johnsson Mark Jones Simon Peyton Jones Alastair Reid Philip Wadler 
Keyword: Programming Language Haskell A Non-strict, Purely Functional Language  
Date: May 1, 1996  
Note: Version 1.3  
Abstract: Report on the Authors' affiliations: (1) Yale University, (2) University of St. Andrews, (3) Chalmers University of Technology, (4) Victoria University of Welling-ton, (5) Simon Fraser University, (6) Los Alamos National Laboratory, (7) University of Cambridge, (8) University of Glasgow, (9) University of Nottingham 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Backus. </author> <title> Can programming be liberated from the von Neumann style? A functional style and its algebra of programs. </title> <journal> CACM, </journal> <volume> 21(8) </volume> <pages> 613-641, </pages> <month> August </month> <year> 1978. </year>
Reference: [2] <author> H.B. Curry and R. Feys. </author> <title> Combinatory Logic. </title> <publisher> North-Holland Pub. Co., </publisher> <address> Amsterdam, </address> <year> 1958. </year>
Reference: [3] <author> L. Damas and R. Milner. </author> <title> Principal type schemes for functional programs. </title> <booktitle> In Proceedings of the 9th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 207-212, </pages> <address> Albuquerque, N.M., </address> <month> January </month> <year> 1982. </year>
Reference-contexts: These "built-in" datatypes are described in detail in Section 6.1. 4.1 Overview of Types and Classes Haskell uses a traditional Hindley-Milner polymorphic type system to provide a static type semantics <ref> [3, 4] </ref>, but the type system has been extended with type and constructor classes (or just classes) that provide a structured way to introduce overloaded functions. 32 4. <p> With one exception, the type variables in a Haskell type expression are all assumed to be universally quantified; there is no explicit syntax for universal quantification <ref> [3] </ref>. For example, the type expression a -&gt; a denotes the type 8 a: a ! a . For clarity, however, we often write quantification explicitly when discussing the types of Haskell programs.
Reference: [4] <author> R. Hindley. </author> <title> The principal type scheme of an object in combinatory logic. </title> <journal> Transactions of the American Mathematical Society, </journal> <volume> 146 </volume> <pages> 29-60, </pages> <month> December </month> <year> 1969. </year>
Reference-contexts: These "built-in" datatypes are described in detail in Section 6.1. 4.1 Overview of Types and Classes Haskell uses a traditional Hindley-Milner polymorphic type system to provide a static type semantics <ref> [3, 4] </ref>, but the type system has been extended with type and constructor classes (or just classes) that provide a structured way to introduce overloaded functions. 32 4.
Reference: [5] <author> P. Hudak, J. Fasel, and J. Peterson. </author> <title> A gentle introduction to Haskell. </title> <type> Technical Report YALEU/DCS/RR-901, </type> <institution> Yale University, </institution> <month> May </month> <year> 1996. </year>
Reference: [6] <author> ISO. </author> <title> A Character Set for Western European Languages. ISO Standard 8859-1, </title> <year> 1989. </year>
Reference-contexts: Haskell uses the Latin-ISO-8859-1 <ref> [6] </ref> character set. <p> The name otherwise is defined as True to make guarded expressions more readable. 6.1.2 Characters and Strings The character type Char is an enumeration and consists of 256 values, conforming to the ISO 8859-1 standard <ref> [6] </ref>. The lexical syntax for characters is defined in Section 2.5; character literals are nullary constructors in the datatype Char. Type Char is an instance of the classes Read, Show, Eq, Ord, Enum, and Bounded.
Reference: [7] <author> Mark P. Jones. </author> <title> A system of constructor classes: overloading and implicit higher-order polymorphism. </title> <journal> Journal of Functional Programming, </journal> <volume> 5(1), </volume> <month> January </month> <year> 1995. </year>
Reference-contexts: The first declaration above may be read "Int is an instance of the class Num as witnessed by these definitions (i.e. class methods) for (+) and negate." More examples of type and constructor classes can be found in the papers by Jones <ref> [7] </ref> or Wadler and Blott [11]. The term `type class' was used to describe the original Haskell 1.0 type system; `constructor class' was used to describe an extension to the original type classes. <p> For convenience, we write c =&gt; t even if the context c is empty, although in this case the concrete syntax contains no =&gt;. 4.1.3 Semantics of Types and Classes In this subsection, we provide informal details of the type system. (Wadler and Blott [11] and Jones <ref> [7] </ref> discuss type and constructor classes, respectively, in more detail.) The Haskell type system attributes a type to each expression in the program. <p> group: data C a =&gt; D a = Foo (S a) type S a = [D a] class C a where bar :: a -&gt; D a -&gt; Bool The kinds of variables, constructors, and classes within each group are determined using standard techniques of type inference and kind-preserving unification <ref> [7] </ref>. For example, in the definitions above, the parameter a appears as an argument of the function constructor (-&gt;) in the type of bar and hence must have kind fl.
Reference: [8] <author> P. Penfield, Jr. </author> <title> Principal values and branch cuts in complex APL. </title> <booktitle> In APL '81 Conference Proceedings, </booktitle> <pages> pages 248-256, </pages> <address> San Francisco, </address> <month> September </month> <year> 1981. </year>
Reference-contexts: The precise definition of the above functions is as in Common Lisp, which in turn follows Penfield's proposal for APL <ref> [8] </ref>.
Reference: [9] <author> J. Peterson (editor). </author> <title> The Haskell Library Report. </title> <type> Technical Report YALEU/DCS/RR-1105, </type> <institution> Yale University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: There is one distinguished module, Prelude, which is imported into all programs by default (see Section 5.3), plus a set of standard library modules which may be imported as required (see the Haskell Library Report <ref> [9] </ref>). 5.1 Module Structure A module defines a mutually recursive scope containing declarations for value bindings, data types, type synonyms, classes, etc. (see Section 4). module ! module modid [exports] where body j body body ! - [impdecls ;] [[fixdecls ;] topdecls [;]] - j impdecls [;] - modid ! conid <p> There are also many predefined library modules which provide less frequently used functions and types. For example, arrays, tables, and most of the input/output are all part of the standard libraries. These are defined in the Haskell Library Report <ref> [9] </ref>, a separate document. Separating libraries from the Prelude has the advantage of reducing the size and complexity of the Prelude, allowing it to be more easily assimilated, and increasing the space of useful names available to the programmer.
Reference: [10] <editor> S.L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. Prentice-Hall International, </booktitle> <address> Englewood Cliffs, New Jersey, </address> <year> 1987. </year>
Reference-contexts: q p The types of the definitions of g1 and g2 are both a ! a ! String, and the accumulated constraints are Ord a (arising from the use of &gt;), and Show a (arising from the use of show). 2 A similar transformation is described in Peyton Jones' book <ref> [10] </ref>. 4.5 Static Semantics of Function and Pattern Bindings 49 The type variables appearing in this collection of constraints are called the constrained type variables.


References-found: 10

