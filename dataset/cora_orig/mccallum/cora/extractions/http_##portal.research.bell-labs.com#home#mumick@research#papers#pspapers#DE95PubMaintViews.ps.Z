URL: http://portal.research.bell-labs.com/home/mumick@research/papers/pspapers/DE95PubMaintViews.ps.Z
Refering-URL: http://karna.cs.umd.edu:3264/people/godfrey/cites.html
Root-URL: 
Email: ashish@almaden.ibm.com  mumick@research.att.com  
Title: Maintenance of Materialized Views: Problems, Techniques, and Applications  
Author: Ashish Gupta Inderpal Singh Mumick 
Address: 650 Harry Road San Jose, CA-95120  600 Mountain Avenue Murray Hill, NJ 07974  
Affiliation: IBM Almaden Research Center  AT&T Bell Laboratories  
Abstract: In this paper we motivate and describe materialized views, their applications, and the problems and techniques for their maintenance. We present a taxonomy of view maintenance problems based upon the class of views considered, upon the resources used to maintain the view, upon the types of modifications to the base data that are considered during maintenance, and whether the technique works for all instances of databases and modifications. We describe some of the view maintenance techniques proposed in the literature in terms of our taxonomy. Finally, we consider new and promising application domains that are likely to drive work in materialized views and view maintenance.
Abstract-found: 1
Intro-found: 1
Reference: [BB82] <author> P. A. Bernstein and B. T. Blaustein. </author> <title> Fast Methods for Testing Quantified Relational Calculus Assertions. </title> <booktitle> In SIGMOD 1982, </booktitle> <pages> pages 39-50. </pages>
Reference-contexts: Thus, view maintenance techniques can be used to incrementally check integrity constraints when a database is modified. The expression to check integrity constraints typically can be simplified when the constraint holds before the modification, i.e., the corresponding views initially are empty <ref> [BC79, Nic82, BB82, BMM92, LST87, CW90] </ref>. Query Optimization: If a database system maintains several materialized views, the query optimizer can use these materialized views when optimizing arbitrary queries, even when the queries do not mention the views.
Reference: [BBC80] <author> P. A. Bernstein, B. T. Blaustein, and E. M. Clarke. </author> <title> Fast Maintenance of Semantic Integrity Assertions Using Redundant Aggregate Data. </title> <booktitle> In 6th VLDB, </booktitle> <year> 1980, </year> <pages> pages 126-136. </pages>
Reference: [BC79] <author> Peter O. Buneman and Eric K. Clemons. </author> <title> Efficiently Monitoring Relational Databases. </title> <journal> In ACM Transactions on Database Systems, </journal> <volume> Vol 4, No. 3, </volume> <year> 1979, </year> <pages> 368-382. </pages>
Reference-contexts: Thus, view maintenance techniques can be used to incrementally check integrity constraints when a database is modified. The expression to check integrity constraints typically can be simplified when the constraint holds before the modification, i.e., the corresponding views initially are empty <ref> [BC79, Nic82, BB82, BMM92, LST87, CW90] </ref>. Query Optimization: If a database system maintains several materialized views, the query optimizer can use these materialized views when optimizing arbitrary queries, even when the queries do not mention the views.
Reference: [BCL89] <author> J. A. Blakeley, N. Coburn, and P. Larson. </author> <title> Updating Derived Relations: Detecting Irrelevant and Autonomously Computable Updates. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 14(3) </volume> <pages> 369-400, </pages> <year> 1989. </year>
Reference-contexts: Instead, they are modelled as a deletion followed by an insertion. This model loses information thereby requiring more work and more information for maintaining a view than if updates were treated independently within a view maintenance algorithm <ref> [BCL89, UO92, GJM94] </ref>. The following example illustrates the other two dimensions used to characterize view maintenance. Example 2: (Language and Instance Dimensions) Example 1 considered a view definition language consisting of selection and projection operations. <p> that treating updates as a distinct type of modification lets us derive view maintenance algorithms for updates where no algorithms exist for deletions+insertions. 4.1 Using no Information: Query Independent of Update There is a lot of work on optimizing view maintenance by determining when a modification leaves a view unchanged <ref> [BLT86, BCL89, Elk90, LS93] </ref>. This is known as the "query independent of update", or the "irrelevant update" problem. All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. <p> All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. However, if the test fails, then some other algorithm has to be used for maintenance. <ref> [BLT86, BCL89] </ref> determine irrelevant updates for SPJ views while [Elk90] considers irrelevant updates for Datalog. <p> The idea of self-maintenance is not new | Autonomously computable views were defined by <ref> [BCL89] </ref> as the views that can be maintained using only the materialized view for all database instances, but for a given modification instance . They characterize a subset of SPJ views that are autonomously computable for insertions, deletions, and updates, where the deletions and updates are specified using conditions. <p> They do not consider views with self-joins or outer-joins, do not use key information, and they do not consider self-maintenance with respect to all instances of modifications. The characterization of autonomously computable views in <ref> [BCL89] </ref> for updates is inaccurate | For instance, [BCL89] determines, incorrectly, that the view "select X from r (X)" is not autonomously computable for the modification "Update (R (3) to R (4))". <p> They do not consider views with self-joins or outer-joins, do not use key information, and they do not consider self-maintenance with respect to all instances of modifications. The characterization of autonomously computable views in <ref> [BCL89] </ref> for updates is inaccurate | For instance, [BCL89] determines, incorrectly, that the view "select X from r (X)" is not autonomously computable for the modification "Update (R (3) to R (4))". Instance Specific Self-Maintenance For insertions and deletions only, a database instance specific self-maintenance algorithm for SPJ views was discussed first in [BT88].
Reference: [BLT86] <author> J. A. Blakeley, P. Larson, and F. Tompa. </author> <title> Efficiently Updating Materialized Views. </title> <booktitle> In SIGMOD 1986. </booktitle>
Reference-contexts: Other Counting Algorithms: [SI84] maintain select, project, and equijoin views using counts of the number of derivations of a tuple. They build data structures with pointers from a tuple t to other tuples derived using the tuple t . <ref> [BLT86] </ref> use counts just like the counting algorithm, but only to maintain SPJ views. <p> that treating updates as a distinct type of modification lets us derive view maintenance algorithms for updates where no algorithms exist for deletions+insertions. 4.1 Using no Information: Query Independent of Update There is a lot of work on optimizing view maintenance by determining when a modification leaves a view unchanged <ref> [BLT86, BCL89, Elk90, LS93] </ref>. This is known as the "query independent of update", or the "irrelevant update" problem. All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. <p> All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. However, if the test fails, then some other algorithm has to be used for maintenance. <ref> [BLT86, BCL89] </ref> determine irrelevant updates for SPJ views while [Elk90] considers irrelevant updates for Datalog.
Reference: [BMM92] <author> F. Bry, R. Manthey, and B. Martens. </author> <title> Integrity Verification in Knowledge Bases. </title> <booktitle> In Logic Programming, LNAI 592, </booktitle> <pages> pages 114-139, </pages> <year> 1992. </year>
Reference-contexts: Thus, view maintenance techniques can be used to incrementally check integrity constraints when a database is modified. The expression to check integrity constraints typically can be simplified when the constraint holds before the modification, i.e., the corresponding views initially are empty <ref> [BC79, Nic82, BB82, BMM92, LST87, CW90] </ref>. Query Optimization: If a database system maintains several materialized views, the query optimizer can use these materialized views when optimizing arbitrary queries, even when the queries do not mention the views.
Reference: [BST + 93] <author> R. J. Brachman, et al.. </author> <title> Integrated support for data archaeology. </title> <journal> In International Journal of Intelligent and Cooperative Information Systems, </journal> <volume> 2 </volume> <pages> 159-185, </pages> <year> 1993. </year>
Reference-contexts: Data Visualization: Visualization applications display views over the data in a database. As the user changes the view definition, the display has to be updated accordingly. An interface for such queries in a real estate system is reported in [WS93], where they are called dynamic queries. Data 12 archaeology <ref> [BST + 93] </ref> is a similar application where an archaeologist discovers rules about data by formulating queries, examining the results, and then changing the query iteratively as his/her understanding improves.
Reference: [BT88] <author> J. A. Blakeley and F. W. Tompa. </author> <title> Maintaining Materialized Views without Accessing Base Data. </title> <booktitle> In Information Systems, </booktitle> <volume> 13(4) </volume> <pages> 393-406, </pages> <year> 1988. </year> <month> 14 </month>
Reference-contexts: Instance Specific Self-Maintenance For insertions and deletions only, a database instance specific self-maintenance algorithm for SPJ views was discussed first in <ref> [BT88] </ref>. Subsequently this algorithm has been corrected and extended in [GB95]. 4.3 Using Materialized View and Some Base Relations: Partial-reference The partial-reference maintenance problem is to maintain a view given only a subset of the base relations and the materialized view.
Reference: [CKPS95] <author> S. Chaudhuri, R. Krishnamurthy, S. Potamianos, K. Shim. </author> <title> Query Optimization in the presence of Materialized Views. </title> <booktitle> In 11th IEEE Intl. Conference on Data Engineering, </booktitle> <year> 1995. </year>
Reference-contexts: Optimization of aggregation queries using materialized views is discussed in <ref> [CKPS95, DJLS95, GHQ95] </ref>. The view adaptation results of [GMR95] can be used to optimize a query using only one materialized view. 6 Open Problems This section describes some open problems in view maintenance, in the context of Figure 1.
Reference: [CW90] <author> S. Ceri and J. Widom. </author> <title> Deriving Production Rules for Constraint Maintenance. </title> <booktitle> In VLDB 1990. </booktitle>
Reference-contexts: Thus, view maintenance techniques can be used to incrementally check integrity constraints when a database is modified. The expression to check integrity constraints typically can be simplified when the constraint holds before the modification, i.e., the corresponding views initially are empty <ref> [BC79, Nic82, BB82, BMM92, LST87, CW90] </ref>. Query Optimization: If a database system maintains several materialized views, the query optimizer can use these materialized views when optimizing arbitrary queries, even when the queries do not mention the views.
Reference: [CW91] <author> S. Ceri and J. Widom. </author> <title> Deriving Production Rules for Incremental View Maintenance. </title> <booktitle> In VLDB 1991. </booktitle>
Reference-contexts: They derive two expressions for each view; one to compute the insertions into the view, and another to compute the deletions into the view. 6 The Ceri-Widom algorithm <ref> [CW91] </ref>: derives production rules to maintain selected SQL views - those without duplicates, aggregation, and negation, and those where the view attributes functionally determine the key of the base relation that is updated. <p> or after all the updates? Should active rules (or some other mechanism) be used to initiate view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in <ref> [NY83, CW91, GHJ94, RC + 95] </ref>. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC <p> active rules (or some other mechanism) be used to initiate view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in [NY83, CW91, GHJ94, RC + 95]. <ref> [CW91] </ref> considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC + 95] describes the ADMS system
Reference: [DJLS95] <author> S. Dar, H.V. Jagadish, A. Y. Levy, and D. Srivastava. </author> <title> Answering SQL queries with aggregation using views. </title> <type> Technical report, </type> <institution> AT&T, </institution> <year> 1995. </year>
Reference-contexts: Optimization of aggregation queries using materialized views is discussed in <ref> [CKPS95, DJLS95, GHQ95] </ref>. The view adaptation results of [GMR95] can be used to optimize a query using only one materialized view. 6 Open Problems This section describes some open problems in view maintenance, in the context of Figure 1.
Reference: [DLW95] <author> G. Dong, L. Libkin and L. Wong. </author> <title> On Impossibility of Decremental Recomputation of Recursive Queries in Relational Calculus and SQL. </title> <booktitle> In Proc. of the Intl. Wksp. on DB Prog. </booktitle> <address> Lang, </address> <year> 1995. </year>
Reference-contexts: The algorithm does not apply to all graphs or to general recursive programs. In fact, there does not exist a nonrecursive program to maintain the transitive closure of an arbitrary graph in response to deletions from the graph <ref> [DLW95] </ref>. Nontraditional Views [LMSS95a] extends the DRed algorithm to views that can have nonground tuples. [WDSY91] give a maintenance algorithm for a rule language with negation in the head and body of rules, using auxiliary information about the number of certain derivations of each tuple.
Reference: [DS93] <author> G. Dong and J. Su. </author> <title> Incremental and Decremental Evaluation of Transitive Closure by First-Order Queries. </title> <booktitle> In Proceedings of the 16th Australian Computer Science Conference, </booktitle> <year> 1993. </year>
Reference-contexts: Their algorithm gives finite even counts to all tuples, even those in a recursive view, and can be used even if tuples have infinitely many derivations. Transitive Closures [DT92] derive nonrecursive programs to update right-linear recursive views in response to insertions into the base relation. <ref> [DS93] </ref> give nonrecursive programs to update the transitive closure of specific kinds of graphs in response to insertions and deletions. The algorithm does not apply to all graphs or to general recursive programs.
Reference: [DT92] <author> G. Dong and R. Topor. </author> <title> Incremental Evaluation of Datalog Queries. </title> <booktitle> In ICDT, </booktitle> <year> 1992. </year>
Reference-contexts: The BDGEN system [NY83] uses counts to reflect not all derivations but only certain types of derivations. Their algorithm gives finite even counts to all tuples, even those in a recursive view, and can be used even if tuples have infinitely many derivations. Transitive Closures <ref> [DT92] </ref> derive nonrecursive programs to update right-linear recursive views in response to insertions into the base relation. [DS93] give nonrecursive programs to update the transitive closure of specific kinds of graphs in response to insertions and deletions. The algorithm does not apply to all graphs or to general recursive programs.
Reference: [Elk90] <author> C. Elkan. </author> <title> Independence of Logic Database Queries and Updates. </title> <booktitle> In 9th PODS, </booktitle> <pages> pages 154-160, </pages> <year> 1990. </year>
Reference-contexts: that treating updates as a distinct type of modification lets us derive view maintenance algorithms for updates where no algorithms exist for deletions+insertions. 4.1 Using no Information: Query Independent of Update There is a lot of work on optimizing view maintenance by determining when a modification leaves a view unchanged <ref> [BLT86, BCL89, Elk90, LS93] </ref>. This is known as the "query independent of update", or the "irrelevant update" problem. All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. <p> If the test succeeds, then the view stays unaffected by the modification. However, if the test fails, then some other algorithm has to be used for maintenance. [BLT86, BCL89] determine irrelevant updates for SPJ views while <ref> [Elk90] </ref> considers irrelevant updates for Datalog. Further, [LS93] can determine irrelevant updates for Datalog with negated base relations and arithmetic inequalities. 4.2 Using the Materialized View: Self-Maintenance Views that can be maintained using only the materialized view and key constraints are called self-maintainable views in [GJM94].
Reference: [GHJ94] <author> S. Ghandeharizadeh, R. Hull, and D Jacobs. Heraclitus[Alg,C]: </author> <title> Elevating Deltas to be First-Class Citizens in a Database Programming Language. </title> <type> Tech. Rep. </type> # <institution> USC-CS-94-581, USC, </institution> <year> 1994. </year>
Reference-contexts: or after all the updates? Should active rules (or some other mechanism) be used to initiate view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in <ref> [NY83, CW91, GHJ94, RC + 95] </ref>. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC <p> alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in [NY83, CW91, GHJ94, RC + 95]. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. <ref> [GHJ94] </ref> does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC + 95] describes the ADMS system that implements and maintains simple materialized views, "ViewCaches," in a multi-database environment.
Reference: [GB95] <author> A. Gupta and J. A. Blakeley. </author> <title> Maintaining Views using Materialized Views . Unpublished document. </title>
Reference-contexts: Instance Specific Self-Maintenance For insertions and deletions only, a database instance specific self-maintenance algorithm for SPJ views was discussed first in [BT88]. Subsequently this algorithm has been corrected and extended in <ref> [GB95] </ref>. 4.3 Using Materialized View and Some Base Relations: Partial-reference The partial-reference maintenance problem is to maintain a view given only a subset of the base relations and the materialized view. <p> Thus, the view is change-reference-maintainable. A similar claim holds for deletions from part but not for insertions into either relation. Instance Specific Partial-reference Maintenance <ref> [GB95, Gup94] </ref> give algorithms that successfully maintain a view for some instances of the database and modification, but not for others.
Reference: [GHQ95] <author> A. Gupta, V. Harinarayan and D. Quass. </author> <title> Generalized Projections: A Powerful Approach to Aggregation. </title> <booktitle> In VLDB, </booktitle> <year> 1995. </year>
Reference-contexts: Optimization of aggregation queries using materialized views is discussed in <ref> [CKPS95, DJLS95, GHQ95] </ref>. The view adaptation results of [GMR95] can be used to optimize a query using only one materialized view. 6 Open Problems This section describes some open problems in view maintenance, in the context of Figure 1.
Reference: [GJM94] <author> A. Gupta, H. V. Jagadish, and I. S. Mumick. </author> <title> Data integration using self-maintainable views. </title> <type> Technical Memorandum 113880-941101-32, </type> <institution> AT&T Bell Laboratories, </institution> <month> November </month> <year> 1994. </year>
Reference-contexts: Instead, they are modelled as a deletion followed by an insertion. This model loses information thereby requiring more work and more information for maintaining a view than if updates were treated independently within a view maintenance algorithm <ref> [BCL89, UO92, GJM94] </ref>. The following example illustrates the other two dimensions used to characterize view maintenance. Example 2: (Language and Instance Dimensions) Example 1 considered a view definition language consisting of selection and projection operations. <p> There is no relative ordering between the points on each dimension; they are listed in arbitrary order. Along the language dimension, chronicle algebra [JMS95] refers to languages that operate over ordered sequences that may not be stored in the database (see Section 4.3). Along the modification dimension, group updates <ref> [GJM94] </ref> refers to insertion of several tuples using information derived from a single deleted tuple. We study maintenance techniques for different points in the shown problem space. <p> View maintenance on outer-join views using the materialized view and all base relations has been discussed in <ref> [GJM94] </ref>. In this section we outline the algorithm of [GJM94] to maintain incrementally full outer-join views. <p> View maintenance on outer-join views using the materialized view and all base relations has been discussed in <ref> [GJM94] </ref>. In this section we outline the algorithm of [GJM94] to maintain incrementally full outer-join views. <p> Query (b) handles the modifications to table S similar to the manner in which query (a) handles the modifications to table R, with similar possible side-effects. The algorithm of <ref> [GJM94] </ref> handles these side effects. 3.3 Recursive Views Recursive queries or views often are expressed using rules in Datalog [Ull89], and all the work on maintaining recursive views has been done in the context of Datalog. <p> Further, [LS93] can determine irrelevant updates for Datalog with negated base relations and arithmetic inequalities. 4.2 Using the Materialized View: Self-Maintenance Views that can be maintained using only the materialized view and key constraints are called self-maintainable views in <ref> [GJM94] </ref>. Several results on self-maintainability of SPJ and outer-join views in response to insertions, deletions, and updates are also presented in [GJM94]. Following [GJM94], we define: 1 An algorithm to check finiteness appears in [MS93, MS94]. 9 Definition 1: (Self Maintainability With Respect to a Modification Type) A view V is <p> base relations and arithmetic inequalities. 4.2 Using the Materialized View: Self-Maintenance Views that can be maintained using only the materialized view and key constraints are called self-maintainable views in <ref> [GJM94] </ref>. Several results on self-maintainability of SPJ and outer-join views in response to insertions, deletions, and updates are also presented in [GJM94]. Following [GJM94], we define: 1 An algorithm to check finiteness appears in [MS93, MS94]. 9 Definition 1: (Self Maintainability With Respect to a Modification Type) A view V is said to be self-maintainable with respect to a modification type (insertion, deletion, or update) to a base relation R if for <p> and arithmetic inequalities. 4.2 Using the Materialized View: Self-Maintenance Views that can be maintained using only the materialized view and key constraints are called self-maintainable views in <ref> [GJM94] </ref>. Several results on self-maintainability of SPJ and outer-join views in response to insertions, deletions, and updates are also presented in [GJM94]. Following [GJM94], we define: 1 An algorithm to check finiteness appears in [MS93, MS94]. 9 Definition 1: (Self Maintainability With Respect to a Modification Type) A view V is said to be self-maintainable with respect to a modification type (insertion, deletion, or update) to a base relation R if for all database <p> Thus, the view is not self-maintainable with respect to deletions from supp. In fact, the view is not self-maintainable for insertions into either supp or part. Some results from <ref> [GJM94] </ref> are stated after the following definitions. Definition 2: (Distinguished Attribute) An attribute A of a relation R is said to be distinguished in a view V if attribute A appears in the select clause defining view V . <p> Definition 3: (Exposed Attribute) An attribute A of a relation R is said to be exposed in a view V if A is used in a predicate. An attribute that is not exposed is referred to as being non-exposed. Self-Maintainability With Respect to Insertions and Deletions <ref> [GJM94] </ref> shows that most SPJ views are not self-maintainable with respect to insertions, but they are often self-maintainable with respect to deletions and updates. <p> The ability to self-maintain a view depends upon the attributes being updated. In particular, updates to non-exposed attributes are self-maintainable when the key attributes are distinguished. The complete algorithm for self-maintenance of a view in response to updates to non-exposed attributes is described in <ref> [GJM94] </ref> and relies on (a) identifying the tuples in the current view that are potentially affected by the update, and (b) computing the effect of the update on these tuples. <p> Incremental view maintenance techniques can be used to maintain the materialized views in response to these modifications. While the materialized views are available for view maintenance, access to the remote databases may be restricted or expensive. Self-Maintainable views are thus useful to maintain a data warehouse <ref> [GJM94] </ref>. For cases where the view is not self-maintainable and one has to go to the remote databases, besides the cost of remote accesses, transaction management is also needed [ZG + 95]. Materialized views are used for data integration in [ZHKF95, GJM94]. <p> For cases where the view is not self-maintainable and one has to go to the remote databases, besides the cost of remote accesses, transaction management is also needed [ZG + 95]. Materialized views are used for data integration in <ref> [ZHKF95, GJM94] </ref>. Objects that reside in multiple databases are integrated to give a larger object if the child objects "match." Matching for relational tuples using outer-joins and a match operator is done in [GJM94], while more general matching conditions are discussed in [ZHKF95]. <p> Materialized views are used for data integration in [ZHKF95, GJM94]. Objects that reside in multiple databases are integrated to give a larger object if the child objects "match." Matching for relational tuples using outer-joins and a match operator is done in <ref> [GJM94] </ref>, while more general matching conditions are discussed in [ZHKF95]. The matching conditions of [ZHKF95] may be expensive to compute. By materializing the composed objects, in part or fully, the objects can be used inexpensivelym. [LMSS95b] presents another model of data integration.
Reference: [GKM92] <author> A. Gupta, D. Katiyar, and I. S. Mumick. </author> <title> Counting Solutions to the View Maintenance Problem. </title> <booktitle> In Workshop on Deductive Databases, JICSLP, </booktitle> <year> 1992. </year>
Reference-contexts: Updates are modeled directly; however since keys need to be derived for such a modeling, the update model is useful mainly for nonrecursive views. 8 Counting based algorithms can sometimes be used for recursive views. The counting algorithm of <ref> [GKM92] </ref> can be used effectively only if every tuple is guaranteed to have a finite number of derivations 1 , and even then the computation of counts can significantly increase the cost of computation.
Reference: [GL95] <author> T. Griffin and L. Libkin. </author> <title> Incremental maintenance of views with duplicates. </title> <booktitle> In SIGMOD 1995. </booktitle>
Reference-contexts: Algebraic Differencing: introduced in [Pai84] and used subsequently in [QW91] for view maintenance differentiates algebraic expressions to derive the relational expression that computes the change to an SPJ view without doing redundant computation. [GLT95] provide a correction to the minimality result of [QW91], and <ref> [GL95] </ref> extend the algebraic differencing approach to multiset algebra with aggregations and multiset difference.
Reference: [GLT95] <author> T. Griffin and L. Libkin and H. Trickey. </author> <title> A correction to "Incremental recomputation of active relational expressions" by Qian and Wiederhold. </title> <note> To appear in IEEE TKDE. </note>
Reference-contexts: Algebraic Differencing: introduced in [Pai84] and used subsequently in [QW91] for view maintenance differentiates algebraic expressions to derive the relational expression that computes the change to an SPJ view without doing redundant computation. <ref> [GLT95] </ref> provide a correction to the minimality result of [QW91], and [GL95] extend the algebraic differencing approach to multiset algebra with aggregations and multiset difference.
Reference: [GM93] <author> A. Gupta and I. S. Mumick. </author> <title> Improvements to the PF Algorithm. </title> <type> TR STAN-CS-93-1473, </type> <institution> Stanford. </institution>
Reference-contexts: However, the alternation of the steps after each semi-naive iteration also causes some tuples to be rederived several times. In addition, the PF algorithm ends up fragmenting computation and rederiving changed and deleted tuples again and again. <ref> [GM93] </ref> presents improvements to the PF algorithm that reduce rederivation of facts by using memoing and by exploiting the stratification in the program.
Reference: [GMR95] <author> A. Gupta, I. Singh Mumick, and K. A. Ross. </author> <title> Adapting materialized views after redefinitions. </title> <institution> In Columbia University TR CUCS-010-95, </institution> <month> March </month> <year> 1995. </year> <booktitle> Also in SIGMOD 1995, </booktitle> <pages> pages 211-222. </pages>
Reference-contexts: By materializing a view and incrementally recomputing it as its definition changes, the system keeps such applications interactive. <ref> [GMR95] </ref> studies the "view adaptation problem," i.e., how to incrementally recompute a materialized view in response to changes to the view definition. Mobile Systems: A common query in a personal digital assistant (PDA) is of the form "Which freeway exits are within a 5 mile radius". <p> Optimization of aggregation queries using materialized views is discussed in [CKPS95, DJLS95, GHQ95]. The view adaptation results of <ref> [GMR95] </ref> can be used to optimize a query using only one materialized view. 6 Open Problems This section describes some open problems in view maintenance, in the context of Figure 1. Many points on each of the three dimensions remain unconsidered, or even unrepresented.
Reference: [GMS93] <author> A. Gupta, I. S. Mumick, and V. S. Subrahmanian. </author> <title> Maintaining Views Incrementally. </title> <booktitle> In SIGMOD 1993, </booktitle> <pages> pages 157-167. </pages> <note> (Full version in AT&T technical report # 9921214-19-TM.) </note>
Reference-contexts: If tuples are inserted into and deleted from relation link, then (hop) is often computed by separately computing the set of deletions (hop) and the set of insertions + (hop) [QW91, HD92]. Alternatively, by differently tagging insertions and deletions they can be handled in one pass as in <ref> [GMS93] </ref>. 3 Using Full Information Most work on view maintenance has assumed that all the base relations and the materialized view are available during the maintenance process, and the focus has been on efficient techniques to maintain views expressed in different languages starting from select-project-join views and moving to relational algebra, <p> the language dimension into those applicable to nonrecursive views, those applicable to outer-join views, and those applicable to recursive views. 3.1 Nonrecursive Views We describe the counting algorithm for view maintenance, and then discuss several other view maintenance techniques that have been proposed in the literature. 5 The counting Algorithm <ref> [GMS93] </ref>: applies to SQL views that may or may not have duplicates, and that may be defined using UNION, negation, and aggregation. The basic idea in the counting algorithm is to keep a count of the number of derivations for each view tuple as extra information in the view. <p> We describe the DRed (Deletion and Rederivation) algorithm for view maintenance, and then discuss several other recursive view maintenance techniques that have been proposed in the literature. 7 The DRed Algorithm <ref> [GMS93] </ref>: applies to Datalog or SQL views, including views defined using recursion, UNION, and stratified negation and aggregation. However, SQL views with duplicate semantics cannot be maintained by this algorithm. The DRed algorithm computes changes to the view relations in three steps. <p> For nonrecursive views, the DRed algorithm always works better than the PF algorithm. The Kuchenhoff algorithm [Kuc91]: derives rules to compute the difference between consecutive database states for a stratified recursive program. The rules generated are similar in spirit to those of <ref> [GMS93] </ref>. However, some of the generated rules (for the depends predicates) are not safe, and the delete/prune/insert three step technique of [GMS93, HD92] is not used. <p> The rules generated are similar in spirit to those of [GMS93]. However, some of the generated rules (for the depends predicates) are not safe, and the delete/prune/insert three step technique of <ref> [GMS93, HD92] </ref> is not used. Further, when dealing with positive rules, the Kuchenhoff algorithm does not discard duplicate derivations that are guaranteed not to generate any change in the view as early as the DRed algorithm discards the duplicate derivations.
Reference: [GSUW94] <author> A. Gupta, S. Sagiv, J. D. Ullman, and J. Widom. </author> <title> Constraint Checking with Partial Information. </title> <booktitle> In 13th PODS, </booktitle> <year> 1994, </year> <pages> pages 45-55. </pages>
Reference: [Gup94] <author> A. Gupta. </author> <title> Partial Information Based Integrity Constraint Checking. </title> <type> Ph.D. Thesis, </type> <institution> Stanford (CS-TR-95-1534). </institution>
Reference-contexts: Thus, the view is change-reference-maintainable. A similar claim holds for deletions from part but not for insertions into either relation. Instance Specific Partial-reference Maintenance <ref> [GB95, Gup94] </ref> give algorithms that successfully maintain a view for some instances of the database and modification, but not for others.
Reference: [HD92] <author> J. V. Harrison and S. Dietrich. </author> <title> Maintenance of Materialized Views in a Deductive Database: An Update Propagation Approach. </title> <booktitle> In Workshop on Deductive Databases, JICSLP, </booktitle> <year> 1992. </year>
Reference-contexts: If tuples are inserted into and deleted from relation link, then (hop) is often computed by separately computing the set of deletions (hop) and the set of insertions + (hop) <ref> [QW91, HD92] </ref>. <p> None of the other algorithms discussed in this section handle the same class of views as the DRed algorithm; the most notable differentiating feature being aggregations. However, some algorithms derive more efficient solutions for special subclasses. The PF (Propagation/Filtration) algorithm <ref> [HD92] </ref>: is very similar to the DRed algorithm, except that it propagates the changes made to the base relations on a relation by relation basis. <p> The rules generated are similar in spirit to those of [GMS93]. However, some of the generated rules (for the depends predicates) are not safe, and the delete/prune/insert three step technique of <ref> [GMS93, HD92] </ref> is not used. Further, when dealing with positive rules, the Kuchenhoff algorithm does not discard duplicate derivations that are guaranteed not to generate any change in the view as early as the DRed algorithm discards the duplicate derivations.
Reference: [JMS95] <author> H. V. Jagadish, I. S. Mumick, and A. Silberschatz. </author> <title> View maintenance issues in the chronicle data model. </title> <booktitle> In 14th PODS, </booktitle> <pages> pages 113-124, </pages> <year> 1995. </year>
Reference-contexts: Materialized views are useful in new applications such as data warehousing, replication servers, chronicle or data recording systems <ref> [JMS95] </ref>, data visualization, and mobile systems. Integrity constraint checking and query optimization can also benefit from materialized views. What is view maintenance? Just as a cache gets dirty when the data from which it is copied is updated, a materialized view gets dirty whenever the underlying base relations are modified. <p> The instance dimension is not shown here so as to keep the figure manageable. There is no relative ordering between the points on each dimension; they are listed in arbitrary order. Along the language dimension, chronicle algebra <ref> [JMS95] </ref> refers to languages that operate over ordered sequences that may not be stored in the database (see Section 4.3). Along the modification dimension, group updates [GJM94] refers to insertion of several tuples using information derived from a single deleted tuple. <p> Two interesting subproblems here are when the view and all the relations except the modified relation are available, and when the view and modified relation are available. Modified Relation is not Available (Chronicle Views) A chronicle is an ordered sequence of tuples with insertion being the only permissible modification <ref> [JMS95] </ref>. A view over a chronicle, treating the chronicle as a relation, is called a chronicle view. <p> Techniques to specify and maintain such views efficiently are presented in <ref> [JMS95] </ref>. Only Modified Relation is Available (Change-reference Maintainable) Sometimes a view may be maintainable using only the modified base relation and the view, but without accessing other base relations. Different modifications need to be treated differently. <p> The model needs access to the remote databases during queries and thus differs from a typical warehousing model. Chronicle Systems: Banking, retailing, and billing systems deal with a continuous stream of transactional data. This ordered sequence of transactional tuples has been called a chronicle <ref> [JMS95] </ref>. One characteristic of a chronicle is that it can get very large, and it can be beyond the capacity of any database system to even store, far less access, for answering queries. Materialized views provide a way to answer queries over the chronicle without accessing the chronicle. <p> View maintenance techniques are needed to maintain these summaries as new transactions are added to the chronicle, but without accessing the old entries in the chronicle <ref> [JMS95] </ref>. Data Visualization: Visualization applications display views over the data in a database. As the user changes the view definition, the display has to be updated accordingly. An interface for such queries in a real estate system is reported in [WS93], where they are called dynamic queries. <p> The ADMS system uses materialized views in query optimization and addresses questions of caching, buffering, access paths, etc.. The complexity of view maintenance also needs to be explored. The dynamic complexity classes of [PI94] and the incremental maintenance complexity of <ref> [JMS95] </ref> characterize the computational complexity of maintaining a materialized copy of the view. [PI94] show that several recursive views have a first order dynamic complexity, while [JMS95] define languages with constant, logarithmic, and polynomial incremental maintenance complexity. Acknowledgements We thank H. V. <p> The complexity of view maintenance also needs to be explored. The dynamic complexity classes of [PI94] and the incremental maintenance complexity of <ref> [JMS95] </ref> characterize the computational complexity of maintaining a materialized copy of the view. [PI94] show that several recursive views have a first order dynamic complexity, while [JMS95] define languages with constant, logarithmic, and polynomial incremental maintenance complexity. Acknowledgements We thank H. V. Jagadish, Leonid Libkin, Dallan Quass, and Jennifer Widom for their insightful comments on the technical and presentation aspects of this paper.
Reference: [KSS87] <author> R. Kowalski, F. Sadri, and P. Soper. </author> <title> Integrity Checking in Deductive Databases. </title> <booktitle> In VLDB, </booktitle> <year> 1987. </year>
Reference: [Kuc91] <author> V. Kuchenhoff. </author> <title> On the Efficient Computation of the Difference Between Consecutive Database States. </title> <booktitle> In DOOD, LNCS 566, </booktitle> <year> 1991. </year> <month> 15 </month>
Reference-contexts: For nonrecursive views, the DRed algorithm always works better than the PF algorithm. The Kuchenhoff algorithm <ref> [Kuc91] </ref>: derives rules to compute the difference between consecutive database states for a stratified recursive program. The rules generated are similar in spirit to those of [GMS93].
Reference: [LMSS95a] <author> A. Y. Levy and A. O. Mendelzon and Y. Sagiv and D. Srivastava. </author> <title> Answering Queries Using Views. </title> <booktitle> In PODS 1995, </booktitle> <pages> pages 95-104. </pages>
Reference-contexts: The algorithm does not apply to all graphs or to general recursive programs. In fact, there does not exist a nonrecursive program to maintain the transitive closure of an arbitrary graph in response to deletions from the graph [DLW95]. Nontraditional Views <ref> [LMSS95a] </ref> extends the DRed algorithm to views that can have nonground tuples. [WDSY91] give a maintenance algorithm for a rule language with negation in the head and body of rules, using auxiliary information about the number of certain derivations of each tuple. <p> A query optimizer can optimize this query to access a materialized view that stores the number of items sold for each item and store, and avoid access to a much larger sales-transactions table. <ref> [RSU95, LMSS95a] </ref> discuss the problem of answering a conjunctive query (SPJ query) given a set of conjunctive view definitions. Optimization of aggregation queries using materialized views is discussed in [CKPS95, DJLS95, GHQ95].
Reference: [LMSS95b] <author> J. Lu, G. Moerkotte, J. Schu, and V. S. Subrahmanian. </author> <title> Efficient maintenance of materialized mediated views. </title> <booktitle> In SIGMOD 1995, </booktitle> <pages> pages 340-351. </pages>
Reference-contexts: The matching conditions of [ZHKF95] may be expensive to compute. By materializing the composed objects, in part or fully, the objects can be used inexpensivelym. <ref> [LMSS95b] </ref> presents another model of data integration. They consider views defined using some remote and some local relations. They materialize the view partially, without accessing the remote relation, by retaining a reference to the remote relation as a constraint in the view tuples.
Reference: [LS93] <author> A.Y. Levy and Y. Sagiv. </author> <title> Queries Independent of Updates. </title> <booktitle> In 19th VLDB, </booktitle> <pages> pages 171-181, </pages> <year> 1993. </year>
Reference-contexts: that treating updates as a distinct type of modification lets us derive view maintenance algorithms for updates where no algorithms exist for deletions+insertions. 4.1 Using no Information: Query Independent of Update There is a lot of work on optimizing view maintenance by determining when a modification leaves a view unchanged <ref> [BLT86, BCL89, Elk90, LS93] </ref>. This is known as the "query independent of update", or the "irrelevant update" problem. All these algorithms provide checks to determine whether a particular modification will be irrelevant. If the test succeeds, then the view stays unaffected by the modification. <p> If the test succeeds, then the view stays unaffected by the modification. However, if the test fails, then some other algorithm has to be used for maintenance. [BLT86, BCL89] determine irrelevant updates for SPJ views while [Elk90] considers irrelevant updates for Datalog. Further, <ref> [LS93] </ref> can determine irrelevant updates for Datalog with negated base relations and arithmetic inequalities. 4.2 Using the Materialized View: Self-Maintenance Views that can be maintained using only the materialized view and key constraints are called self-maintainable views in [GJM94].
Reference: [LST87] <author> J.W. Lloyd, E. A. Sonenberg, and R. W. Topor. </author> <title> Integrity Constraint Checking in Stratified Databases. </title> <journal> Journal of Logic Programming, </journal> <volume> 4(4) </volume> <pages> 331-343, </pages> <year> 1987. </year>
Reference-contexts: Thus, view maintenance techniques can be used to incrementally check integrity constraints when a database is modified. The expression to check integrity constraints typically can be simplified when the constraint holds before the modification, i.e., the corresponding views initially are empty <ref> [BC79, Nic82, BB82, BMM92, LST87, CW90] </ref>. Query Optimization: If a database system maintains several materialized views, the query optimizer can use these materialized views when optimizing arbitrary queries, even when the queries do not mention the views.
Reference: [MPP + 93] <author> B. Mitschang, H. Pirahesh, P. Pistor, B. Lindsay, and N. Sudkamp. </author> <title> SQL/XNF Processing Composite Objects as Abstractions over Relational Data. </title> <booktitle> In Proc. of 9 th IEEE ICDE, </booktitle> <year> 1993. </year>
Reference-contexts: Recursive Algorithms: The algorithms described in Section 3.3 for recursive views also apply to nonrecursive views. 3.2 Outer-Join Views Outer joins are important in domains like data integration and extended relational systems <ref> [MPP + 93] </ref>. View maintenance on outer-join views using the materialized view and all base relations has been discussed in [GJM94]. In this section we outline the algorithm of [GJM94] to maintain incrementally full outer-join views.
Reference: [MS93] <author> I. S. Mumick and O. Shmueli. </author> <title> Finiteness properties of database queries. </title> <booktitle> In Advances in Database Research: Proc. of the 4 th Australian Database Conference, </booktitle> <pages> pages 274-288, </pages> <year> 1993. </year>
Reference-contexts: The counting algorithm thus works by storing the number of alternative derivations, count (t), of each tuple t in the materialized view. This number is derived from the multiplicity of tuple t under duplicate semantics <ref> [Mum91, MS93] </ref>. Given a program T defining a set of views V 1 ; : : :; V k , the counting algorithm uses the differentiation technique of Section 2 to derive a program T . <p> Several results on self-maintainability of SPJ and outer-join views in response to insertions, deletions, and updates are also presented in [GJM94]. Following [GJM94], we define: 1 An algorithm to check finiteness appears in <ref> [MS93, MS94] </ref>. 9 Definition 1: (Self Maintainability With Respect to a Modification Type) A view V is said to be self-maintainable with respect to a modification type (insertion, deletion, or update) to a base relation R if for all database states, the view can be self-maintained in response to all instances
Reference: [MS94] <author> I. S. Mumick and O. Shmueli. </author> <title> Universal Finiteness and Satisfiability. </title> <booktitle> In PODS 1994, </booktitle> <pages> pages 190-200. </pages>
Reference-contexts: Several results on self-maintainability of SPJ and outer-join views in response to insertions, deletions, and updates are also presented in [GJM94]. Following [GJM94], we define: 1 An algorithm to check finiteness appears in <ref> [MS93, MS94] </ref>. 9 Definition 1: (Self Maintainability With Respect to a Modification Type) A view V is said to be self-maintainable with respect to a modification type (insertion, deletion, or update) to a base relation R if for all database states, the view can be self-maintained in response to all instances
Reference: [Mum91] <author> I. S. Mumick. </author> <title> Query Optimization in Deductive and Relational Databases. </title> <type> Ph.D. Thesis, </type> <institution> Stanford University, Stanford, </institution> <address> CA 94305, USA, </address> <year> 1991. </year>
Reference-contexts: The counting algorithm thus works by storing the number of alternative derivations, count (t), of each tuple t in the materialized view. This number is derived from the multiplicity of tuple t under duplicate semantics <ref> [Mum91, MS93] </ref>. Given a program T defining a set of views V 1 ; : : :; V k , the counting algorithm uses the differentiation technique of Section 2 to derive a program T .
Reference: [Nic82] <author> J. M. Nicolas. </author> <title> Logic for Improving Integrity Checking in Relational Data Bases. </title> <journal> Acta Informatica, </journal> <volume> 18(3) </volume> <pages> 227-253, </pages> <year> 1982. </year>
Reference-contexts: Thus, view maintenance techniques can be used to incrementally check integrity constraints when a database is modified. The expression to check integrity constraints typically can be simplified when the constraint holds before the modification, i.e., the corresponding views initially are empty <ref> [BC79, Nic82, BB82, BMM92, LST87, CW90] </ref>. Query Optimization: If a database system maintains several materialized views, the query optimizer can use these materialized views when optimizing arbitrary queries, even when the queries do not mention the views.
Reference: [NY83] <author> J. M. Nicolas and Yazdanian. </author> <title> An Outline of BDGEN: A Deductive DBMS. </title> <booktitle> In Information Processing, </booktitle> <pages> pages 705-717, </pages> <year> 1983. </year>
Reference-contexts: The counting algorithm of [GKM92] can be used effectively only if every tuple is guaranteed to have a finite number of derivations 1 , and even then the computation of counts can significantly increase the cost of computation. The BDGEN system <ref> [NY83] </ref> uses counts to reflect not all derivations but only certain types of derivations. Their algorithm gives finite even counts to all tuples, even those in a recursive view, and can be used even if tuples have infinitely many derivations. <p> or after all the updates? Should active rules (or some other mechanism) be used to initiate view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in <ref> [NY83, CW91, GHJ94, RC + 95] </ref>. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC <p> view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in [NY83, CW91, GHJ94, RC + 95]. [CW91] considers using production rules for doing view maintenance and <ref> [NY83] </ref> presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC + 95] describes the ADMS system that implements and maintains simple materialized views, "ViewCaches," in a
Reference: [Pai84] <author> R. Paige. </author> <title> Applications of finite differencing to database integrity control and query/transaction optimization. </title> <booktitle> In Advances in Database Theory, </booktitle> <pages> pages 170-209, </pages> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1984. </year>
Reference-contexts: Also, they compute insertions and deletions separately, without combining them into a single set with positive and negative counts. [Rou91] describes "ViewCaches," materialized views defined using selections and one join, that store only the TIDs of the tuples that join to produce view tuples. Algebraic Differencing: introduced in <ref> [Pai84] </ref> and used subsequently in [QW91] for view maintenance differentiates algebraic expressions to derive the relational expression that computes the change to an SPJ view without doing redundant computation. [GLT95] provide a correction to the minimality result of [QW91], and [GL95] extend the algebraic differencing approach to multiset algebra with aggregations
Reference: [PI94] <author> S. Patnaik and N. Immerman. </author> <title> Dyn-fo: A parallel, dynamic complexity class. </title> <booktitle> In PODS, </booktitle> <year> 1994. </year>
Reference-contexts: The ADMS system uses materialized views in query optimization and addresses questions of caching, buffering, access paths, etc.. The complexity of view maintenance also needs to be explored. The dynamic complexity classes of <ref> [PI94] </ref> and the incremental maintenance complexity of [JMS95] characterize the computational complexity of maintaining a materialized copy of the view. [PI94] show that several recursive views have a first order dynamic complexity, while [JMS95] define languages with constant, logarithmic, and polynomial incremental maintenance complexity. Acknowledgements We thank H. V. <p> The complexity of view maintenance also needs to be explored. The dynamic complexity classes of <ref> [PI94] </ref> and the incremental maintenance complexity of [JMS95] characterize the computational complexity of maintaining a materialized copy of the view. [PI94] show that several recursive views have a first order dynamic complexity, while [JMS95] define languages with constant, logarithmic, and polynomial incremental maintenance complexity. Acknowledgements We thank H. V. Jagadish, Leonid Libkin, Dallan Quass, and Jennifer Widom for their insightful comments on the technical and presentation aspects of this paper.
Reference: [QW91] <author> X. Qian and G. Wiederhold. </author> <title> Incremental Recomputation of Active Relational Expressions. </title> <journal> In IEEE TKDE, </journal> <volume> 3(1991), </volume> <pages> pages 337-341. </pages>
Reference-contexts: If tuples are inserted into and deleted from relation link, then (hop) is often computed by separately computing the set of deletions (hop) and the set of insertions + (hop) <ref> [QW91, HD92] </ref>. <p> Algebraic Differencing: introduced in [Pai84] and used subsequently in <ref> [QW91] </ref> for view maintenance differentiates algebraic expressions to derive the relational expression that computes the change to an SPJ view without doing redundant computation. [GLT95] provide a correction to the minimality result of [QW91], and [GL95] extend the algebraic differencing approach to multiset algebra with aggregations and multiset difference. <p> Algebraic Differencing: introduced in [Pai84] and used subsequently in <ref> [QW91] </ref> for view maintenance differentiates algebraic expressions to derive the relational expression that computes the change to an SPJ view without doing redundant computation. [GLT95] provide a correction to the minimality result of [QW91], and [GL95] extend the algebraic differencing approach to multiset algebra with aggregations and multiset difference.
Reference: [RSU95] <author> A. Rajaraman, Y. Sagiv, and J. D. Ullman. </author> <title> Answering queries using templates with binding patterns. </title> <booktitle> In PODS, </booktitle> <year> 1995, </year> <pages> pages 105-112. </pages>
Reference-contexts: A query optimizer can optimize this query to access a materialized view that stores the number of items sold for each item and store, and avoid access to a much larger sales-transactions table. <ref> [RSU95, LMSS95a] </ref> discuss the problem of answering a conjunctive query (SPJ query) given a set of conjunctive view definitions. Optimization of aggregation queries using materialized views is discussed in [CKPS95, DJLS95, GHQ95].
Reference: [RC + 95] <author> N. Roussopoulos, C. Chun, S. Kelley, A. Delis, and Y. Papakonstantinou. </author> <title> The ADMS Project: Views "R" Us. </title> <journal> In IEEE Data Engineering Bulletin, Special Issue on Materialized Views and Data Warehousing, </journal> <volume> 18(2), </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: or after all the updates? Should active rules (or some other mechanism) be used to initiate view maintenance automatically or should a user start the process? Should alternative algorithms be tried, based on a cost based model to choose between the options? Some existing work in this context is in <ref> [NY83, CW91, GHJ94, RC + 95] </ref>. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. [RC <p> [NY83, CW91, GHJ94, RC + 95]. [CW91] considers using production rules for doing view maintenance and [NY83] presents algorithms in the context of a deductive DB system. [GHJ94] does not discuss view maintenance but discusses efficient implementation of deltas in a system that can be used to implement materialized views. <ref> [RC + 95] </ref> describes the ADMS system that implements and maintains simple materialized views, "ViewCaches," in a multi-database environment. The ADMS system uses materialized views in query optimization and addresses questions of caching, buffering, access paths, etc.. The complexity of view maintenance also needs to be explored.
Reference: [Rou91] <author> N. Roussopoulos. </author> <title> The Incremental Access Method of View Cache: Concept, Algorithms, and Cost Analysis. </title> <booktitle> In ACM-TODS, </booktitle> <volume> 16(3) </volume> <pages> 535-563, </pages> <year> 1991. </year>
Reference-contexts: Also, they compute insertions and deletions separately, without combining them into a single set with positive and negative counts. <ref> [Rou91] </ref> describes "ViewCaches," materialized views defined using selections and one join, that store only the TIDs of the tuples that join to produce view tuples.
Reference: [SI84] <author> O. Shmueli and A. Itai. </author> <title> Maintenance of Views. </title> <booktitle> In SIGMOD 1984, </booktitle> <pages> pages 240-255. </pages>
Reference-contexts: For SQL views counts can be computed at little or no cost above the cost of evaluating the view for both set and duplicate semantics. The counting algorithm works for both set and duplicate semantics, and can be made to work for outer-join views (Section 3.2). Other Counting Algorithms: <ref> [SI84] </ref> maintain select, project, and equijoin views using counts of the number of derivations of a tuple. They build data structures with pointers from a tuple t to other tuples derived using the tuple t . [BLT86] use counts just like the counting algorithm, but only to maintain SPJ views.
Reference: [Ull89] <author> J. D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> Vol 2. </volume> <publisher> Computer Science Press. </publisher>
Reference-contexts: Query (b) handles the modifications to table S similar to the manner in which query (a) handles the modifications to table R, with similar possible side-effects. The algorithm of [GJM94] handles these side effects. 3.3 Recursive Views Recursive queries or views often are expressed using rules in Datalog <ref> [Ull89] </ref>, and all the work on maintaining recursive views has been done in the context of Datalog.
Reference: [UO92] <author> T. Urpi and A. Olive. </author> <title> A Method for Change Computation in Deductive Databases. </title> <booktitle> In VLDB 1992. </booktitle>
Reference-contexts: Instead, they are modelled as a deletion followed by an insertion. This model loses information thereby requiring more work and more information for maintaining a view than if updates were treated independently within a view maintenance algorithm <ref> [BCL89, UO92, GJM94] </ref>. The following example illustrates the other two dimensions used to characterize view maintenance. Example 2: (Language and Instance Dimensions) Example 1 considered a view definition language consisting of selection and projection operations. <p> Further, when dealing with positive rules, the Kuchenhoff algorithm does not discard duplicate derivations that are guaranteed not to generate any change in the view as early as the DRed algorithm discards the duplicate derivations. The Urpi-Olive algorithm <ref> [UO92] </ref>: for stratified Datalog views derives transition rules showing how each modification to a relation translates into a modification to each derived relation, using existentially quantified subexpressions in Datalog rules. The quantified subexpressions may go through negation, and can be eliminated under certain conditions.
Reference: [WDSY91] <author> O. Wolfson, H. M. Dewan, S. J. Stolfo, and Y. Yemini. </author> <title> Incremental Evaluation of Rules and its Relationship to Parallelism. </title> <booktitle> In SIGMOD 1991, </booktitle> <pages> pages 78-87. </pages>
Reference-contexts: In fact, there does not exist a nonrecursive program to maintain the transitive closure of an arbitrary graph in response to deletions from the graph [DLW95]. Nontraditional Views [LMSS95a] extends the DRed algorithm to views that can have nonground tuples. <ref> [WDSY91] </ref> give a maintenance algorithm for a rule language with negation in the head and body of rules, using auxiliary information about the number of certain derivations of each tuple.
Reference: [WS93] <author> C. Williamson and B. Shneiderman. </author> <title> The Dynamic HomeFinder: evaluating Dynamic Queries in a real- estate information exploration system. In Ben Shneiderman, editor, Sparks of Innovation in Human-Computer Interaction. </title> <publisher> Ablex Publishing Corp, </publisher> <year> 1993. </year>
Reference-contexts: Data Visualization: Visualization applications display views over the data in a database. As the user changes the view definition, the display has to be updated accordingly. An interface for such queries in a real estate system is reported in <ref> [WS93] </ref>, where they are called dynamic queries. Data 12 archaeology [BST + 93] is a similar application where an archaeologist discovers rules about data by formulating queries, examining the results, and then changing the query iteratively as his/her understanding improves.
Reference: [ZHKF95] <author> G. Zhou, R. Hull, R. King, J-C. Franchitti. </author> <title> Using Object Matching and Materialization to Integrate Heterogeneous Databases. </title> <booktitle> In Proc. of 3 rd Intl. Conf. on Cooperative Info. Sys., </booktitle> <year> 1995, </year> <pages> pp. 4-18. </pages>
Reference-contexts: For cases where the view is not self-maintainable and one has to go to the remote databases, besides the cost of remote accesses, transaction management is also needed [ZG + 95]. Materialized views are used for data integration in <ref> [ZHKF95, GJM94] </ref>. Objects that reside in multiple databases are integrated to give a larger object if the child objects "match." Matching for relational tuples using outer-joins and a match operator is done in [GJM94], while more general matching conditions are discussed in [ZHKF95]. <p> Objects that reside in multiple databases are integrated to give a larger object if the child objects "match." Matching for relational tuples using outer-joins and a match operator is done in [GJM94], while more general matching conditions are discussed in <ref> [ZHKF95] </ref>. The matching conditions of [ZHKF95] may be expensive to compute. By materializing the composed objects, in part or fully, the objects can be used inexpensivelym. [LMSS95b] presents another model of data integration. They consider views defined using some remote and some local relations. <p> Objects that reside in multiple databases are integrated to give a larger object if the child objects "match." Matching for relational tuples using outer-joins and a match operator is done in [GJM94], while more general matching conditions are discussed in <ref> [ZHKF95] </ref>. The matching conditions of [ZHKF95] may be expensive to compute. By materializing the composed objects, in part or fully, the objects can be used inexpensivelym. [LMSS95b] presents another model of data integration. They consider views defined using some remote and some local relations.
Reference: [ZG + 95] <author> Y. Zhuge, H. Garcia-Molina, J. Hammer, and J. Widom. </author> <title> View maintenance in a warehousing environment. </title> <booktitle> In SIGMOD 1995, </booktitle> <pages> pages 316-327. 16 </pages>
Reference-contexts: Self-Maintainable views are thus useful to maintain a data warehouse [GJM94]. For cases where the view is not self-maintainable and one has to go to the remote databases, besides the cost of remote accesses, transaction management is also needed <ref> [ZG + 95] </ref>. Materialized views are used for data integration in [ZHKF95, GJM94].
References-found: 55

