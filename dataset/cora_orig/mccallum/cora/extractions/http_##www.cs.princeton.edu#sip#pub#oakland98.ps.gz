URL: http://www.cs.princeton.edu/sip/pub/oakland98.ps.gz
Refering-URL: http://www.cs.princeton.edu/sip/pub/oakland98.html
Root-URL: http://www.cs.princeton.edu
Email: dwallach@cs.princeton.edu felten@cs.princeton.edu  
Title: Understanding Java Stack Inspection  
Author: Dan S. Wallach Edward W. Felten 
Keyword: Secure Internet Programming Laboratory  
Affiliation: Department of Computer Science Princeton University  
Abstract: This paper models the stack inspection algorithm in terms of a well-understood logic for access control and demonstrates how stack inspection is a useful tool for expressing and managing complex trust relationships. We show that an access control decision based on stack inspection corresponds to the construction of a proof in the logic, and we present an efficient decision procedure for generating these proofs. By examining the decision procedure, we demonstrate that many statements in the logic are equivalent and can thus be expressed in a simpler form. We show that there are a finite number of such statements, allowing us to represent the security state of the system as a pushdown automaton. We also show that this automaton may be embedded in Java by rewriting all Java classes to pass an additional argument when a procedure is invoked. We call this security-passing style and describe its benefits over previous stack inspection systems. Finally, we show how the logic allows us to describe a straightforward design for extending stack inspection across remote procedure calls. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> ABADI, M., BURROWS, M., LAMPSON, B., AND PLOTKIN, G. D. </author> <title> A calculus for access control in distributed systems. </title> <booktitle> ACM Transactions on Program 9 ming Languages and Systems 15, </booktitle> <address> 4 (Sept. </address> <year> 1993), </year> <month> 706734. </month>
Reference-contexts: To address these concerns, we will present a model of 1 stack inspection using a belief logic designed by Abadi, Burrows, Lampson, and Plotkin <ref> [1] </ref> (hereafter, ABLP logic) to reason about access control. Using this logic, we will derive an alternate technique for implementing stack inspection which is applicable to Java and other languages. Our procedure applies to remote procedure calls as well as local ones. This paper is organized as follows. <p> We note that each vendor takes different actions when the search reaches the end of the stack uneventfully: Netscape denies permission, while both Sun and Mi-crosoft allow it. 3 Access Control Logic We will model the behavior of Java stack inspection using ABLP logic <ref> [1, 9] </ref>. ABLP logic allows us to reason about what we believe to be true given the state of the system and a set of axioms. <p> We use a subset of the full ABLP logic, which we will describe here. Readers who want a full description and a more formal development of the logic should see <ref> [1] </ref> or [9]. The logic is based on a few simple concepts: principals, conjunctions of principals, targets, statements, quotation, and authority. * A principal is a person, organization or any other entity that may have the right to take actions or authorize actions. <p> Next, the decision procedure examines the Class 3 statements one at a time. When examining the statement F 1 j F 2 j j F k says Ok (U), the decision procedure terminates and returns true if both * for all i 2 <ref> [1; k] </ref>, there is a path from F i to T in the speaks-for graph, and * U = T. If the decision procedure examines all of the Class 3 statements without success, it terminates and returns false. Theorem 1 (Termination) The decision procedure always terminates. <p> When one side sends a message through the encrypted channel, we model this (following <ref> [1] </ref> and [22]) as a statement made by the sender's session key: we write K says s, where K is the sender's session key and s is the statement. <p> This paper has presented a formalization of Java's stack inspection using a logic developed by Abadi, Burrows, Lampson, and Plotkin <ref> [1] </ref>. Using this model, we have demonstrated how Java's access control decisions correspond to proving statements in ABLP logic. We have reduced the stack inspection model to a finite pushdown automaton, and described how to implement the automaton efficiently using security-passing style.
Reference: [2] <author> BIRRELL, A. D., NELSON, G., OWICKI, S., AND WOBBER, E. P. </author> <title> Network objects. </title> <journal> Software: Practice and Experience S4, </journal> <note> 25 (Dec. 1995), 87130. </note>
Reference: [3] <author> COHEN, G., CHASE, J., AND KAMINSKY, D. </author> <title> Automatic program transformation with JOIE. </title> <note> In Proc. 1998 Usenix Technical Symposium (June 1998). To appear. </note>
Reference-contexts: Security-passing style also lets us more easily transplant the stack inspection idea into other language and systems. We are currently implementing security-passing style by rewriting bytecode at load time using the JOIE <ref> [3] </ref> tool. The rewriter is a trusted module which we add to the JVM.
Reference: [4] <author> DEAN, D., FELTEN, E. W., AND WALLACH, D. S. </author> <title> Java security: From HotJava to Netscape and beyond. </title> <booktitle> In Proceedings of the 1996 IEEE Symposium on Security and Privacy (Oakland, </booktitle> <address> California, </address> <month> May </month> <year> 1996), </year> <pages> pp. </pages> <year> 190200. </year>
Reference-contexts: Java's promise, from its initial debut in the HotJava Web browser, has been to allow mutually untrusting code modules to co-exist in the same virtual machine in a secure and controllable manner. While there have been several security problems along the way <ref> [4, 13] </ref>, the security of Java implementations is improving and Java has continued to grow in popularity.
Reference: [5] <author> GONG, L. </author> <title> A secure identity-based capability system. </title> <booktitle> In Proceedings of the 1989 IEEE Symposium on Security and Privacy (Oakland, </booktitle> <address> California, </address> <month> May </month> <year> 1989), </year> <pages> pp. 5663. </pages>
Reference-contexts: Though a simple translation of security-passing style into the RPC case does not work, security-passing style with a few modifications works well for RPCs. RPC security has received a good deal of attention in the literature. The two prevailing styles of security are capabilities and access control lists <ref> [19, 5, 8, 16, 20] </ref>. Most of these systems support only simple principals. Even in systems that support more complex principals [22], the mechanisms to express those principals are relatively unwieldy. This section discusses how to extend the Java stack inspection model across RPCs.
Reference: [6] <author> GONG, L., AND SCHEMERS, R. </author> <title> Implementing protection domains in the Java Development Kit 1.2. </title> <booktitle> In The Internet Society Symposium on Network and Distributed System Security (San Diego, </booktitle> <address> California, </address> <month> Mar. </month> <year> 1998), </year> <institution> Internet Society. </institution>
Reference-contexts: While a number of other techniques may be used to achieve the same goals as stack inspection [21], stack inspection has proven to be quite attractive and has been adopted by all the major Java vendors <ref> [15, 6, 14] </ref> to meet their need to provide more flexible security policies than the rigid sandbox policy, which restricted all non-local code to the same set of privileges. <p> Variations on this approach are taken by Netscape's Communicator 4.0 [15], Microsoft's Internet Explorer 4.0 [14], and Sun's Java Development Kit 1.2 <ref> [6] </ref>. Stack inspection has a number of useful security properties [21] but very little prior art.
Reference: [7] <author> GOSLING, J., JOY, B., AND STEELE, G. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction The Java language <ref> [7] </ref> and virtual machine [11] are now being used in a wide variety of applications: Web fl Copyright 1998 IEEE. Published in the Proceedings of S&P'98, 3-6 May 1998 in Oakland, California. Personal use of this material is permitted.
Reference: [8] <author> HU, W. </author> <title> DCE Security Programming. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <address> Sebastopol, California, </address> <month> July </month> <year> 1995. </year>
Reference-contexts: Though a simple translation of security-passing style into the RPC case does not work, security-passing style with a few modifications works well for RPCs. RPC security has received a good deal of attention in the literature. The two prevailing styles of security are capabilities and access control lists <ref> [19, 5, 8, 16, 20] </ref>. Most of these systems support only simple principals. Even in systems that support more complex principals [22], the mechanisms to express those principals are relatively unwieldy. This section discusses how to extend the Java stack inspection model across RPCs.
Reference: [9] <author> LAMPSON, B., ABADI, M., BURROWS, M., AND WOBBER, E. </author> <title> Authentication in distributed systems: </title> <journal> Theory and practice. ACM Transactions on Computer Systems 10, </journal> <volume> 4 (Nov. </volume> <year> 1992), </year> <month> 265310. </month>
Reference-contexts: We note that each vendor takes different actions when the search reaches the end of the stack uneventfully: Netscape denies permission, while both Sun and Mi-crosoft allow it. 3 Access Control Logic We will model the behavior of Java stack inspection using ABLP logic <ref> [1, 9] </ref>. ABLP logic allows us to reason about what we believe to be true given the state of the system and a set of axioms. <p> We use a subset of the full ABLP logic, which we will describe here. Readers who want a full description and a more formal development of the logic should see [1] or <ref> [9] </ref>. The logic is based on a few simple concepts: principals, conjunctions of principals, targets, statements, quotation, and authority. * A principal is a person, organization or any other entity that may have the right to take actions or authorize actions.
Reference: [10] <author> LAMPSON, B. W. </author> <title> Protection. </title> <booktitle> In Proceedings of the Fifth Princeton Symposium on Information Sciences and Systems (Princeton University, </booktitle> <month> Mar. </month> <year> 1971), </year> <pages> pp. </pages> <note> 437443. Reprinted in Operating Systems Review, </note> <month> 8 1 (Jan. </month> <year> 1974), </year> <pages> pp. 1824. </pages>
Reference-contexts: Our model will support this intuition by requiring the JVM to prove in ABLP logic that each system call has been authorized by a suitable principal. 4.3 Setting Policy We use a standard access matrix <ref> [10] </ref> to keep track of which principals have permission to access which targets. If VM is a Java virtual machine, we define A VM to be a set of statements of the form P)T where P is a principal and T is a target.
Reference: [11] <author> LINDHOLM, T., AND YELLIN, F. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1996. </year>
Reference-contexts: 1 Introduction The Java language [7] and virtual machine <ref> [11] </ref> are now being used in a wide variety of applications: Web fl Copyright 1998 IEEE. Published in the Proceedings of S&P'98, 3-6 May 1998 in Oakland, California. Personal use of this material is permitted.
Reference: [12] <author> MCCARTHY, J., ABRAHAMS, P. W., EDWARDS, D. J., HART, T. P., AND LEVIN, M. I. </author> <title> LISP 1.5 Programmer's Manual, 2nd ed. </title> <institution> The Computation Center and Research Laboratory of Electronics, Massachusetts Institute of Technology, Cambridge, Massachusetts, </institution> <year> 1962. </year>
Reference-contexts: Stack inspection has a number of useful security properties [21] but very little prior art. In some ways, it resembles dynamic variables (where free variables are resolved from the caller's environment rather than from the environment in which the function is defined), as used in early versions of LISP <ref> [12] </ref>.
Reference: [13] <author> MCGRAW, G., AND FELTEN, E. W. </author> <title> Java Security: Hostile Applets, Holes, and Antidotes. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, New York, </address> <year> 1997. </year>
Reference-contexts: Java's promise, from its initial debut in the HotJava Web browser, has been to allow mutually untrusting code modules to co-exist in the same virtual machine in a secure and controllable manner. While there have been several security problems along the way <ref> [4, 13] </ref>, the security of Java implementations is improving and Java has continued to grow in popularity.
Reference: [14] <author> MICROSOFT CORPORATION. </author> <title> Trust-Based Security for Java. </title> <address> Redmond, Washington, </address> <month> Apr. </month> <year> 1997. </year> <note> http://www.microsoft.com/java/ security/jsecwp.htm. </note>
Reference-contexts: While a number of other techniques may be used to achieve the same goals as stack inspection [21], stack inspection has proven to be quite attractive and has been adopted by all the major Java vendors <ref> [15, 6, 14] </ref> to meet their need to provide more flexible security policies than the rigid sandbox policy, which restricted all non-local code to the same set of privileges. <p> The appendices list the axioms of ABLP logic used in this paper, and present proofs of our theorems. 2 Java Stack Inspection This section describes Java's current stack inspection mechanism 1 . Variations on this approach are taken by Netscape's Communicator 4.0 [15], Microsoft's Internet Explorer 4.0 <ref> [14] </ref>, and Sun's Java Development Kit 1.2 [6]. Stack inspection has a number of useful security properties [21] but very little prior art.
Reference: [15] <author> NETSCAPE COMMUNICATIONS CORPORATION. </author> <title> Introduction to the Capabilities Classes. </title> <address> Mountain View, California, </address> <month> Aug. </month> <year> 1997. </year> <note> http://developer.netscape.com/ library/documentation/signedobj/ capabilities/index.html. </note>
Reference-contexts: While a number of other techniques may be used to achieve the same goals as stack inspection [21], stack inspection has proven to be quite attractive and has been adopted by all the major Java vendors <ref> [15, 6, 14] </ref> to meet their need to provide more flexible security policies than the rigid sandbox policy, which restricted all non-local code to the same set of privileges. <p> The appendices list the axioms of ABLP logic used in this paper, and present proofs of our theorems. 2 Java Stack Inspection This section describes Java's current stack inspection mechanism 1 . Variations on this approach are taken by Netscape's Communicator 4.0 <ref> [15] </ref>, Microsoft's Internet Explorer 4.0 [14], and Sun's Java Development Kit 1.2 [6]. Stack inspection has a number of useful security properties [21] but very little prior art.
Reference: [16] <institution> OBJECT MANAGEMENT GROUP. Common Secure Interoperability, </institution> <month> July </month> <year> 1996. </year> <title> OMG Document Number: </title> <publisher> orbos/96-06-20. </publisher>
Reference-contexts: Though a simple translation of security-passing style into the RPC case does not work, security-passing style with a few modifications works well for RPCs. RPC security has received a good deal of attention in the literature. The two prevailing styles of security are capabilities and access control lists <ref> [19, 5, 8, 16, 20] </ref>. Most of these systems support only simple principals. Even in systems that support more complex principals [22], the mechanisms to express those principals are relatively unwieldy. This section discusses how to extend the Java stack inspection model across RPCs.
Reference: [17] <author> ROSKIND, J. </author> <title> Evolving the Security Model For Java From Navigator 2.x to Navigator 3.x. Netscape Communications Corporation, </title> <address> Mountain View, California, </address> <month> Aug. </month> <year> 1996. </year> <note> http: //developer.netscape.com/library/ technote/security/sectn1.html. </note>
Reference-contexts: In this model, the only principals are system and untrusted. Likewise, the only privilege available is full. This model resembles the stack inspection system used internally in Netscape Navigator 3.0 <ref> [17] </ref>.
Reference: [18] <author> STEELE, G. L. Rabbit: </author> <title> a compiler for Scheme. </title> <type> Tech. Rep. </type> <address> AI-TR-474, </address> <publisher> MIT, </publisher> <address> Cambridge, MA, </address> <year> 1978. </year>
Reference-contexts: The extra argument encodes the security state (the finite-state representation of the belief set) of the procedure's stack frame. This eliminates the need to have a separate pushdown stack for security states. We dub this approach security-passing style, by analogy to continuation-passing style <ref> [18] </ref>, a transformation technique used by some compilers that also replaces an explicit pushdown stack with implicitly-passed procedure arguments.
Reference: [19] <author> TANENBAUM, A. S., MULLENDER, S. J., AND VAN RENESSE, R. </author> <title> Using sparse capabilities in a distributed operating system. </title> <booktitle> In 6th International Conference on Distributed Computing Systems (Cam-bridge, </booktitle> <address> Massachusetts, </address> <month> May </month> <year> 1986), </year> <pages> pp. 558563. </pages>
Reference-contexts: Though a simple translation of security-passing style into the RPC case does not work, security-passing style with a few modifications works well for RPCs. RPC security has received a good deal of attention in the literature. The two prevailing styles of security are capabilities and access control lists <ref> [19, 5, 8, 16, 20] </ref>. Most of these systems support only simple principals. Even in systems that support more complex principals [22], the mechanisms to express those principals are relatively unwieldy. This section discusses how to extend the Java stack inspection model across RPCs.
Reference: [20] <author> VAN DOORN, L., ABADI, M., BURROWS, M., AND WOBBER, E. </author> <title> Secure network objects. </title> <booktitle> In Proceedings of the 1996 IEEE Symposium on Security and Privacy (Oakland, </booktitle> <address> California, </address> <month> May </month> <year> 1996). </year>
Reference-contexts: Though a simple translation of security-passing style into the RPC case does not work, security-passing style with a few modifications works well for RPCs. RPC security has received a good deal of attention in the literature. The two prevailing styles of security are capabilities and access control lists <ref> [19, 5, 8, 16, 20] </ref>. Most of these systems support only simple principals. Even in systems that support more complex principals [22], the mechanisms to express those principals are relatively unwieldy. This section discusses how to extend the Java stack inspection model across RPCs.
Reference: [21] <author> WALLACH, D. S., BALFANZ, D., DEAN, D., AND FELTEN, E. W. </author> <title> Extensible security architectures for Java. </title> <booktitle> In Proceedings of the Sixteenth ACM Symposium on Operating System Principles (Saint-Malo, </booktitle> <address> France, </address> <month> Oct. </month> <year> 1997), </year> <pages> pp. 116128. </pages>
Reference-contexts: While a number of other techniques may be used to achieve the same goals as stack inspection <ref> [21] </ref>, stack inspection has proven to be quite attractive and has been adopted by all the major Java vendors [15, 6, 14] to meet their need to provide more flexible security policies than the rigid sandbox policy, which restricted all non-local code to the same set of privileges. <p> Variations on this approach are taken by Netscape's Communicator 4.0 [15], Microsoft's Internet Explorer 4.0 [14], and Sun's Java Development Kit 1.2 [6]. Stack inspection has a number of useful security properties <ref> [21] </ref> but very little prior art. In some ways, it resembles dynamic variables (where free variables are resolved from the caller's environment rather than from the environment in which the function is defined), as used in early versions of LISP [12].
Reference: [22] <author> WOBBER, E., ABADI, M., BURROWS, M., AND LAMPSON, B. </author> <title> Authentication in the Taos operating system. </title> <journal> ACM Transactions on Computer Systems 12, </journal> <month> 1 (Feb. </month> <year> 1994), </year> <month> 332. </month>
Reference-contexts: ABLP logic allows us to reason about what we believe to be true given the state of the system and a set of axioms. It has been used to describe authentication and authorization in distributed systems such as Taos <ref> [22] </ref> and appears to be a good match for describing access control within Java. We use a subset of the full ABLP logic, which we will describe here. Readers who want a full description and a more formal development of the logic should see [1] or [9]. <p> RPC security has received a good deal of attention in the literature. The two prevailing styles of security are capabilities and access control lists [19, 5, 8, 16, 20]. Most of these systems support only simple principals. Even in systems that support more complex principals <ref> [22] </ref>, the mechanisms to express those principals are relatively unwieldy. This section discusses how to extend the Java stack inspection model across RPCs. <p> When one side sends a message through the encrypted channel, we model this (following [1] and <ref> [22] </ref>) as a statement made by the sender's session key: we write K says s, where K is the sender's session key and s is the statement.
References-found: 22

