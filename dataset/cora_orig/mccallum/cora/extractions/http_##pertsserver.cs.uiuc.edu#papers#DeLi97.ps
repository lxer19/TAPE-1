URL: http://pertsserver.cs.uiuc.edu/papers/DeLi97.ps
Refering-URL: http://pertsserver.cs.uiuc.edu/papers/
Root-URL: http://www.cs.uiuc.edu
Title: Scheduling Real-Time Applications in an Open Environment  
Author: Z. Deng J. W.-S. Liu 
Date: May 14, 1997  
Address: Urbana, IL 61801  
Affiliation: Department of Computer Science University of Illinois at Urbana-Champaign  
Abstract: This paper focuses on the problem of providing run-time support to real-time applications and non-real-time applications in an open system environment. It extends the two-level hierarchical scheduling scheme in [12] for scheduling independently developed applications. The extended scheme removes the following two restrictive requirements of the scheme in [12]: (1) real-time applications that are scheduled preemptively must consist solely of periodic tasks, and (2) applications must not share global resources (i.e., resources used by more than one applications). Consequently, the extended scheme allows us to deal with a much broader range of real-time applications. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C. L. Liu and J. W. Layland, </author> <title> "Scheduling Algorithms for Multiprogramming in a Hard Real Time Environment," </title> <journal> in J. Assoc. Comput. Mach., </journal> <volume> vol. 20(1), </volume> <pages> pp. 46-61, </pages> <year> 1973. </year>
Reference-contexts: 1 Introduction Recent advances in real-time systems technology have given us many good schemes for scheduling hard real-time applications. Examples are <ref> [1, 2, 5, 8] </ref>. A weakness shared by most existing schemes is that schedulability analysis must be done globally (i.e., by analyzing all applications in the system together) in order to validate the schedulability of each application in the system. <p> Theorem 1 in [12] is for the special case when no sporadic job has nonpreemptable sections; it follows directly from the lemma. Similarly, the well-known schedulability condition of independent, preemptable periodic tasks <ref> [1] </ref> also follows straightforwardly from this lemma. Again, we say that a constant utilization server or a total bandwidth server is schedulable if every time after the server budget and deadline are set, its budget is always exhausted at or before its deadline.
Reference: [2] <author> J. Lehoczky, L. Sha, and Y. Ding, </author> <title> "The Rate Monotonic Scheduling Algorithm Exact Characterization and Average Case Behavior," </title> <booktitle> in Proceedings of the IEEE Real-Time System Symposium, </booktitle> <pages> pp. 166-171, </pages> <year> 1989. </year> <month> 22 </month>
Reference-contexts: 1 Introduction Recent advances in real-time systems technology have given us many good schemes for scheduling hard real-time applications. Examples are <ref> [1, 2, 5, 8] </ref>. A weakness shared by most existing schemes is that schedulability analysis must be done globally (i.e., by analyzing all applications in the system together) in order to validate the schedulability of each application in the system.
Reference: [3] <author> J. P. Lehoczky, L. Sha, J. K. Strosnider, and H. Tokuda, </author> <title> "Fixed Priority Scheduling The--ory for Hard Real-Time Systems," in Foundations of Real-Time Computing, Scheduling and Resource Management (A. </title> <editor> M. Tilborg and G. M. Koob, eds.), ch. </editor> <volume> 1, </volume> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference: [4] <author> J. Y.-T. Leung and J. Whitehead, </author> <title> "On the Complexity of Fixed-Priority Scheduling of Periodic Real-Time Tasks," </title> <journal> Performance Evaluation, </journal> <volume> vol. 2, </volume> <pages> pp. 237-250, </pages> <year> 1982. </year>
Reference: [5] <author> B. Sprunt, L. Sha, and J. P. Lehoczky, </author> <title> "Aperiodic Task Scheduling for Hard Real-Time Systems," Real-Time Systems: </title> <journal> The International Journal of Time-Critical Computing Systems, </journal> <volume> vol. 1, </volume> <pages> pp. 27-60, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Recent advances in real-time systems technology have given us many good schemes for scheduling hard real-time applications. Examples are <ref> [1, 2, 5, 8] </ref>. A weakness shared by most existing schemes is that schedulability analysis must be done globally (i.e., by analyzing all applications in the system together) in order to validate the schedulability of each application in the system.
Reference: [6] <author> L. Sha, R. Rajkumar, and J. P. Lehoczky, </author> <title> "Priority Inheritance Protocols: An Approach to Real-Time Synchronization," </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(9) </volume> <pages> 1175-1185, </pages> <month> September </month> <year> 1990. </year>
Reference: [7] <author> T. P. Baker, </author> <title> "A Stack-Based Allocation Policy for Realtime Processes," </title> <booktitle> Proceedings of IEEE 11th Real-Time Systems Symposium, </booktitle> <pages> pp. 191-200, </pages> <month> December </month> <year> 1990. </year>
Reference: [8] <author> T. M. Ghazalie and T. P. Baker, </author> <title> "Aperiodic Servers in a Deadline Scheduling Environment," </title> <booktitle> Real-Time Systems, </booktitle> <volume> Vol. 9, No. 1, </volume> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Recent advances in real-time systems technology have given us many good schemes for scheduling hard real-time applications. Examples are <ref> [1, 2, 5, 8] </ref>. A weakness shared by most existing schemes is that schedulability analysis must be done globally (i.e., by analyzing all applications in the system together) in order to validate the schedulability of each application in the system.
Reference: [9] <author> M. Spuri and G. Buttazzo, </author> <title> "Scheduling Aperiodic Tasks in Dynamic Priority Systems," </title> <booktitle> Real-Time Systems, </booktitle> <volume> vol. 10, </volume> <pages> pp. 179-210, </pages> <year> 1996. </year>
Reference-contexts: We use a two-level scheduler, namely operating system scheduler and server schedulers, to schedule real-time applications, as we will describe in Section 3. The constant utilization server algorithm [12] used in our scheme is essentially the same as the total bandwidth server algorithm developed by Spuri and Buttazo <ref> [9] </ref>.
Reference: [10] <author> L. Zhang, "VirtualClock: </author> <title> A New Traffic Control Algorithm for Packet-Switched Networks," </title> <journal> ACM Transaction on Computer Systems, </journal> <volume> Vol. 9, No. 2, </volume> <pages> pp. 101-124, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The total bandwidth (and constant utilization) server algorithm is similar to the preemptive fair queueing and virtual clock algorithms proposed for scheduling network traffic through ATM switches <ref> [10, 11] </ref>.
Reference: [11] <author> A. Demers, S. Keshav, and S. Shenker, </author> <title> "Analysis and Simulation of a Fair Queueing Algorithm," </title> <booktitle> Proc. ACM SIGCOMM'89, </booktitle> <pages> pp. 3-12. </pages>
Reference-contexts: The total bandwidth (and constant utilization) server algorithm is similar to the preemptive fair queueing and virtual clock algorithms proposed for scheduling network traffic through ATM switches <ref> [10, 11] </ref>.
Reference: [12] <author> Z. Deng, J. W.-S. Liu, J. Sun, </author> <title> "Dynamic Scheduling of Hard Real-Time Applications in Open System Environment," </title> <type> Technical Report UIUCDCS-R-96-1981, </type> <institution> Department of Computer Science, University of Illinois at Urbana-Champaign. </institution>
Reference-contexts: Even when it is feasible, such an acceptance test can be costly when the applications are multi-threaded and complex. We proposed in <ref> [12] </ref> a two-level hierarchical scheme for scheduling an open system of multi-threaded, real-time applications together with non-real-time applications on a single processor. It allows different applications to be scheduled according to different scheduling algorithms. <p> Because it does not rely on fixed allocation of processor time or fine-grain time slicing, it is suited for applications with varying time demands and stringent timing requirements. The two-level scheme in <ref> [12] </ref> has serious limitations. While it can deal with all time-driven and nonpreemptive real-time applications, real-time applications that are scheduled preemptively must consist solely of periodic tasks. Moreover, applications must not share global resources (i.e., resources used by more than one applications). <p> The scheme in [13] uses a single-level scheduler that schedules the requests of processes according to their virtual deadlines. We use a two-level scheduler, namely operating system scheduler and server schedulers, to schedule real-time applications, as we will describe in Section 3. The constant utilization server algorithm <ref> [12] </ref> used in our scheme is essentially the same as the total bandwidth server algorithm developed by Spuri and Buttazo [9]. <p> It is simple to maintain its server S k , which is a constant utilization server of size k <ref> [12] </ref>. At each replenishment time t, the OS scheduler sets the server budget to the execution time e of the job J at the head of the S k 's ready queue and the server deadline to t + e= k . We have shown in [12] that for every job <p> server of size k <ref> [12] </ref>. At each replenishment time t, the OS scheduler sets the server budget to the execution time e of the job J at the head of the S k 's ready queue and the server deadline to t + e= k . We have shown in [12] that for every job J in A k , the replenishment time at which the server S k is given budget to execute J is same as the decision time when J would be scheduled if A k were to execute alone on a processor with speed k . <p> For convenience, we include the nonpreemptively scheduled application in the predictable type. Nonpredictable applications include those that have aperiodic and sporadic tasks and/or periodic tasks with release time jitters and are scheduled preemptively. In <ref> [12] </ref>, we proved the following sufficient condition under which a real-time application A k is schedulable in the open system if no application in the open system has nonpreemptable sections or uses global resources. 9 Theorem 1: A real-time application A k that is schedulable according to some scheduling algorithm k <p> For a predictable real-time application, it is possible to replenish the budget of its server in such a way that conditions 1 and 2 of Theorem 1 are always true, and the scheme for this type of applications that we described in <ref> [12] </ref> indeed works this way. Therefore, any predictable real-time application A k can be made schedulable in the open system if the server S k has server size k and is schedulable. (For example, the size of the server for the application in Figure 3 should be 0.25. <p> Theorem 1 in <ref> [12] </ref> is for the special case when no sporadic job has nonpreemptable sections; it follows directly from the lemma. Similarly, the well-known schedulability condition of independent, preemptable periodic tasks [1] also follows straightforwardly from this lemma. <p> Moreover, 11 it does not consume more processor time before each server deadline than the constant utilization server. Therefore, from the point of view of schedulability, it can be thought of as a constant utilization server. (More detailed argument on this point can be found in <ref> [12] </ref>.) 5 Schedulability Condition of Real-Time Applications in Open System When no application in the system has nonpreemptable sections or uses global resources, servers of different applications can preempt each other at any time. <p> If no application in the system has nonpreemptable sections or uses global resources, the inequality can be simplified to U t + U k 1 <ref> [12] </ref>. As described in Section 5, if some application in the system has nonpreemptable sections or uses global resources, the servers of all preemptive applications must be total bandwidth servers. <p> uses global resources, it changes the servers of all the existing preemptive applications in the system to total bandwidth servers, as stated in Figure 5. 6.2 Server Scheduler of Nonpredictable Application S k for a nonpredictable application A k . (Descriptions for servers of predictable applications can be found in <ref> [12] </ref>.) Since the precise release times of jobs in a nonpredictable application are unknown, the server scheduler of S k is unable to obtain an accurate occurrence time of the next event of A k . The algorithm described in Figure 8 gives an estimate. <p> or enters or leaves a nonpreemptable section, whichever occurs the earliest; t k minft 0 ; t + e 00 i =U k g; dictable Application A k 21 7 Summary The open system architecture and the two-level hierarchical scheduling scheme described in this paper extends the scheme proposed in <ref> [12] </ref>. The extended scheme can deal with the real-time applications that have nonpreemptable sections, use global resources, have release time jitters while the original scheme cannot.
Reference: [13] <author> I. Stoica, H. Abdel-Wahab, K. Jeffay, S. Baruah, J. Gehrke, and C. Plaxton, </author> <title> "A Proportional Share Resource Allocation Algorithm for Real-Time, Time-Shared Systems," </title> <booktitle> Proceedings of IEEE 17th Real-Time Systems Symposium, </booktitle> <pages> pp. 288-299, </pages> <month> December </month> <year> 1996. </year>
Reference-contexts: Section 7 is a summary and presents future work. 2 Related Work The algorithms used in our two-level scheduling scheme resemble the proportional share resource allocation scheme proposed by Ion Stoica, et al <ref> [13] </ref>. In essence, their scheme creates for each process a slower virtual processor whose speed is a fraction of the speed of the physical processor, as does our scheme for each application. <p> This difference in the design objectives of the two schemes leads to different structures of the scheduler. The scheme in <ref> [13] </ref> uses a single-level scheduler that schedules the requests of processes according to their virtual deadlines. We use a two-level scheduler, namely operating system scheduler and server schedulers, to schedule real-time applications, as we will describe in Section 3.
Reference: [14] <author> Al Mok, </author> <title> "Fundamental Design Problems of Distributed Systems for the Hard Real-Time Environment," </title> <type> Ph.D. Thesis, </type> <institution> MIT, Department of EE and CS, MIT/LCS/TR-297, </institution> <month> May </month> <year> 1983. </year>
Reference-contexts: It schedules all the ready servers according to the EDF algorithm. Whenever a server is scheduled, it executes the job at the head of its ready queue. Global resource contentions among applications are handled by the nonpreemptable critical section (NPS) protocol <ref> [14] </ref>. According to this protocol, whenever a job of an application A k requests for a global resource, the request is always granted.
References-found: 14

