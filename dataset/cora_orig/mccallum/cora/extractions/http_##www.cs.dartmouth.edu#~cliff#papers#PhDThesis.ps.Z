URL: http://www.cs.dartmouth.edu/~cliff/papers/PhDThesis.ps.Z
Refering-URL: http://www.cs.dartmouth.edu/~cliff/papers/
Root-URL: http://www.cs.dartmouth.edu
Title: Approximation Algorithms for Multicommodity Flow and Shop Scheduling Problems  
Author: by Clifford Stein David B. Shmoys Campbell L. Searle 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Doctor of Philosophy at the  Signature of Author  Certified by  Associate Professor  Thesis Supervisor Accepted by  Chairman, Departmental Committee on Graduate Students  
Note: c Massachusetts Institute of Technology  
Date: (1987)  (1989)  September 1992  1992  August 10, 1992  
Affiliation: B.S.E., Electrical Engineering and Computer Science Princeton University  S.M., Electrical Engineering and Computer Science Massachusetts Institute of Technology  MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  of Industrial Engineering and Operations Research, Cornell University  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> I. Adler, N. Karmarkar, M. Resende, and G. Veiga. </author> <title> An implementation of Karmarkar's algorithm for linear programming. </title> <journal> Mathematical Programming, </journal> <volume> 44 </volume> <pages> 297-335, </pages> <year> 1989. </year>
Reference-contexts: The lemma follows. We now give two ways to implement Randomized Strategy 2. The first is the straightforward one in which we pick an edge and then pick a commodity going through that edge. In each iteration, we first choose a random number x 2 <ref> [0; 1] </ref> and then find the smallest i for which a i = vw=1 F This procedure gives us an edge with the right probability. <p> Analogously, we can choose a commodity using this edge vw by choosing a random number y 2 <ref> [0; 1] </ref> and then finding the smallest i for which b i = j=1 f (vw) The b i ; i = 1; : : :; k can be computed in O (k) time. <p> Some algorithms that take advantage of the special structure of mul-ticommodity flow problems have been proposed. These algorithms fall into three main classes: price-directive decomposition, resource-directive decomposition, and partitioning approaches. More recent approaches include interior-point methods <ref> [1] </ref> and a combinatorial scaling algorithm [54]. All of the aforementioned algorithms solve multicommodity flow problems using one of two different objective functions. Some find a minimum-cost multicommodity flow, while others find a flow that maximizes the total amount of flow in the network. <p> The algorithm is mcnf85, a special purpose simplex code for multicommodity flow problems written by Kennington [32]. We chose it for two reasons. First, we had access to the code on our machine. Second, and more importantly, previous tests by Adler, Karmarkar, Resende and Veiga <ref> [1] </ref> demonstrate its efficiency. Adler et al. compared three different codes for multi-commodity flow: minos 5.0, which is an advanced implementation of the simplex method [47], mcnf85, and their own interior point method.
Reference: [2] <author> R. K. Ahuja, A. V. Goldberg, J. B. Orlin, and R. E. Tarjan. </author> <title> Finding Minimum-Cost Flows by Double Scaling. </title> <journal> Mathematical Programming, </journal> <volume> 53 </volume> <pages> 243-266, </pages> <year> 1992. </year>
Reference-contexts: In all cases, however, we find a flow that satisfies (2.19). Different situations require different choices. For general concurrent flow problems, the best choice seems to be either the algorithm of Goldberg and Tarjan [23] or that of Ahuja, Goldberg, Orlin and Tarjan <ref> [2] </ref>. For concurrent flow with uniform capacity, we use Gabow and Tarjan's [19] algorithm for the assignment problem. <p> The above bound can be improved if the capacities are small relative to n 2 =m. In this case we round the demands and solve this rounded problem using the double scaling algorithm of 2.4. ALGORITHMS FOR THE GENERAL CONCURRENT FLOW PROBLEM 59 Ahuja, Goldberg, Orlin, and Tarjan <ref> [2] </ref>. We then satisfy the remaining flow on arbitrary paths. This flow still satisfies (2.19) and the rounding allows us to use a faster algorithm. <p> If we divide both the demands and the capacities by , we get a problem where the maximum capacity of an edge is U= = 16U nk* 1 . We can then use the double scaling algorithm of Ahuja, Goldberg, Orlin and Tarjan <ref> [2] </ref> for solving the minimum-cost problem with rounded demands. This algorithm takes O (nm log (nC) log log (nU 0 )) time on a graph with maximum capacity U 0 . <p> Now Lemma 2.4.27 implies that (2.19) is satisfied. For all but very dense graphs, the double scaling algorithm of Ahuja, Goldberg, Orlin and Tarjan <ref> [2] </ref> gives a better bound. As we observed no edge carries more than d 0 i units of flow in the optimal flow of commodity i. Thus, we can also limit capacities to be no more than d 0 i .
Reference: [3] <author> R. K. Ahuja, T. L. Magnanti, and J. B. Orlin. </author> <title> Network flows. In G.L. </title> <editor> Nemhauser, A. H. G. Rinnooy Kan, and M. J. Todd, editors, </editor> <booktitle> Handbook in operations research and management science, Volume 1: Optimization, </booktitle> <pages> pages 211-360. </pages> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1990. </year>
Reference-contexts: This procedure is known as flow decomposition and it is well known how to compute a decomposition in O (nm) time (see, for example <ref> [3] </ref>) and in O (m log n) time using the dynamic tree data structure. [64] The sources and sinks play a symmetric role in the (undirected) problem, and hence k fl in the lemma could have been defined as the number of nodes in any subset that contains an endpoint of
Reference: [4] <author> D. Applegate and B. Cook. </author> <title> A computational study of the job-shop scheduling problem. </title> <journal> ORSA Journal of Computing, </journal> <volume> 3 </volume> <pages> 149-156, </pages> <year> 1991. </year>
Reference-contexts: Slightly larger instances, however, are still currently intractable; they report instances of size 10 fi 15, 15 fi 20, 15 fi 15 and 10 fi 20 that they were unable to solve <ref> [4] </ref>. 5.1. INTRODUCTION 131 Formal Definition and Previous Results We formally define the job shop problem as follows.
Reference: [5] <author> A. A. Assad. </author> <title> Multicommodity network flows a survey. </title> <journal> Networks, </journal> <volume> 8 </volume> <pages> 37-91, </pages> <year> 1978. </year>
Reference-contexts: A detailed description of these approaches requires a knowledge of linear programming that is beyond the scope of this thesis. We refer the reader to the surveys of Assad <ref> [5] </ref> and Kennington [31] and the thesis of Schneur [54] for more information on these approaches. We are aware of two implementations of algorithms for the unit-capacity unit-demand concurrent flow problem. Shahrokhi and Matula [59] report encouraging results for an implemen 4.3. AN IMPLEMENTATION 103 tation of their algorithm.
Reference: [6] <editor> I. Barany and T. Fiala. Tobbgepes utemezesi problemak kozel optimalis megoldasa. Szigma-Mat.-Kozgazdasagi Folyoirat, </editor> <volume> 15 </volume> <pages> 177-191, </pages> <year> 1982. </year>
Reference-contexts: Consider the algorithm that, whenever a machine is idle, assigns to it any job that has not yet been processed on that machine and is not currently being processed on another machine. Anna Racsmany <ref> [6] </ref> has observed that this greedy algorithm delivers a schedule of length at most max + (m 1)p max . We can adapt her proof to show that, in fact, the greedy algorithm delivers a schedule that is no longer than a factor of 2 times optimal.
Reference: [7] <author> I.S. Belov and Ya. N. Stolin. </author> <title> An algorithm in a single path operations scheduling problem. </title> <booktitle> In Mathematical Economics and Functional Analysis [In Russian], </booktitle> <pages> pages 248-257. </pages> <publisher> Nauka, </publisher> <address> Moscow, </address> <year> 1974. </year>
Reference-contexts: The most interesting approximation algorithms to date for job shop scheduling have appeared primarily in the Soviet literature and are based on a beautiful connection to geometric arguments. This approach was independently discovered by Belov and Stolin <ref> [7] </ref> and by Sevast'yanov [56] as 5.1. INTRODUCTION 133 well as by Fiala [15].
Reference: [8] <author> D. P. Bertsekas and P. Tseng. relaxt-III: </author> <title> A new and improved version of the relax code. </title> <type> Technical Report LIDS-P-1990, </type> <institution> MIT, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: For this purpose, we use the relaxt-iii minimum-cost flow code of Bert-sekas and Tseng <ref> [8] </ref>. One drawback of the routine we have chosen is that it requires integer capacities, costs, and demands, making preprocessing and postprocessing necessary each time it is called.
Reference: [9] <author> S. N. Bhatt and F. T. Leighton. </author> <title> A framework for solving VLSI graph layour problems. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 28, </volume> <year> 1984. </year> <note> 175 176 BIBLIOGRAPHY </note>
Reference-contexts: Leighton and Rao [43] showed how to use 3.3. SPARSE CUTS 89 these techniques to find approximately balanced separators. Combining the result of Leighton and Rao with the results of Bhatt and Leighton <ref> [9] </ref>, we obtain algorithms to approximate the minimum cut linear arrangement, minimum area layout and p 2-bifurcators of a graph. They also showed how to approximate the minimum feedback-arc set.
Reference: [10] <author> J. Cheriyan, </author> <month> October </month> <year> 1991. </year> <title> Private communication. </title>
Reference-contexts: In order to estimate a more realistic running time for this problem, we compute an upper bound on the what the running time would have if we were using the RNET code of Grigoriadis. Joseph Cheriyan <ref> [10] </ref> has reported that on a 4.4.
Reference: [11] <author> V. Chvatal. </author> <title> Linear Programming. </title> <editor> W. H. </editor> <publisher> Freeman and Company, </publisher> <year> 1983. </year>
Reference-contexts: While none of our algorithms actually rely on a procedure for linear programming, some of the proofs rely on well-known results about linear programming. We refer the reader who is unfamiliar with linear programming to a basic textbook such as that of Chvatal <ref> [11] </ref> or Schrijver [55]. We include an glossary of notation.
Reference: [12] <author> Thomas H. Cormen, Charles E. Leiserson, and Ronald L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press/McGraw-Hill, </publisher> <year> 1990. </year>
Reference-contexts: If the array gets too empty, copy its contents into a new array of half the size. The time required for copying can be amortized over the time required for the deletions that emptied the array. (See, for example, <ref> [12] </ref>, for a detailed description of this data structure.) Now, we consider the more general case in which the flow values of flow paths may vary. In this case, we use a three-level data structure. In the top level, the paths are organized according to their starting nodes.
Reference: [13] <author> R. Dial. </author> <title> Algorithm 360: Shortest path forest with topological ordering. </title> <journal> Communications of the ACM, </journal> <volume> 12 </volume> <pages> 632-633, </pages> <year> 1969. </year>
Reference-contexts: dist ~ ` (s; t) dist ` (s; t) + n *`(P ) = dist ` (s; t) + *`(P ) : Further, since each shortest path length is an integer multiple of *`(P ) 2n and no more than `(P ), we can use Dial's implementation of Dijkstra's algorithm <ref> [13] </ref> to compute dist ~ ` (s; t) in O (m+n* 1 ) time. 78 CHAPTER 2. MULTICOMMODITY FLOW ALGORITHMS Implementing FindPath with this approximate shortest path computation directly improves the time required by a deterministic implementation of Reduce.
Reference: [14] <author> P. Elias, A. Feinstein, and C. E. Shannon. </author> <title> Note on maximum flow through a network. </title> <journal> IRE Transactions on Information Theory IT-2, </journal> <pages> pages 117-199, </pages> <year> 1956. </year>
Reference-contexts: Consider first the case when commodity i has a single source and a single sink. The algorithm computes g i , a maximum flow for instance N = (G; u; s; t). Let jg i j be the value of this flow. Then by the maximum-flow minimum-cut theorem <ref> [17, 14] </ref>, there exists a cut with total capacity jg i j. It is easy to see that the smallest amount by which we can multiply the capacity of the cut and have a flow satisfying demands d i , is d i =jg i j.
Reference: [15] <author> T. </author> <title> Fiala. </title> <journal> Kozelt-o algorithmus a harom gep problemara. Alkalmazott Matematikai Lapok, </journal> <volume> 3 </volume> <pages> 389-398, </pages> <year> 1977. </year>
Reference-contexts: This approach was independently discovered by Belov and Stolin [7] and by Sevast'yanov [56] as 5.1. INTRODUCTION 133 well as by Fiala <ref> [15] </ref>. This approach typically produces schedules for which the length can be bounded by max + q (m; )p max , where q (; ) is a polynomial, and p max = max ij p ij is the maximum operation length.
Reference: [16] <author> T. Fiala. </author> <title> An algorithm for the open-shop problem. </title> <journal> Mathematics of Operations Research, </journal> <volume> 8(1) </volume> <pages> 100-109, </pages> <year> 1983. </year>
Reference-contexts: Fiala <ref> [16] </ref> has shown that if max (16m log m + 21m)p max , then C fl max is just max , and there is a polynomial-time algorithm to find an optimal schedule, but in general this problem is strongly N P-Complete.
Reference: [17] <author> L. R. Ford and D. R. Fulkerson. </author> <title> Maximal flow through a network. </title> <journal> Canad. J. Math., </journal> <volume> 8 </volume> <pages> 399-404, </pages> <year> 1956. </year>
Reference-contexts: Consider first the case when commodity i has a single source and a single sink. The algorithm computes g i , a maximum flow for instance N = (G; u; s; t). Let jg i j be the value of this flow. Then by the maximum-flow minimum-cut theorem <ref> [17, 14] </ref>, there exists a cut with total capacity jg i j. It is easy to see that the smallest amount by which we can multiply the capacity of the cut and have a flow satisfying demands d i , is d i =jg i j. <p> For concurrent flow with uniform capacity, we use Gabow and Tarjan's [19] algorithm for the assignment problem. When both the demands and capacities are uniform, we use the algorithm that iteratively computes shortest paths in the residual graph with nonnegative costs discovered independently by Ford and Fulkerson <ref> [17] </ref> and Yakovleva [71]. First, we consider the general concurrent flow problem. Lemma 2.4.29 For a commodity i, a minimum-cost flow with respect to ~ ` can be found in O (nm log (n 2 =m) log (nU )) time. <p> Plugging in the bound d 0 i m, we obtain the time bound claimed in the statement of the lemma. When both the capacities and demands are uniform and k is relatively large, we can obtain better performance by using the Ford and Fulkerson <ref> [17] </ref> minimum-cost flow algorithm, which iteratively computes shortest paths in the graph of residual edges with nonnegative costs. <p> The number of commodities is O (n). The capacities in the minimum-cost flow problem are integer multiples of . We shall use algorithm ScalingConcurrent with a suitable choice of minimum-cost flow routine. We shall use the minimum-cost flow algorithm due to Ford and Fulkerson <ref> [17] </ref> and Yakovleva [71], that repeatedly augments the flow along the shortest path in the residual graph, to solve these problems.
Reference: [18] <author> M.L. Fredman and R.E. Tarjan. </author> <title> Fibonacci heaps and their uses in improved network optimization algorithms. </title> <journal> Journal of the ACM, </journal> <volume> 34 </volume> <pages> 596-615, </pages> <year> 1987. </year>
Reference-contexts: Therefore, in this case, the number of shortest path computations required for finding a minimum-cost flow is at most O (m=k + 1). Each shortest path can be computed in O (m + n log n) time <ref> [18] </ref>. Thus we have shown: Lemma 2.5.2 For the simple concurrent flow problem with uniform capacities and demands, a flow for a commodity i satisfying (2.19) can be found in O m time. <p> All of these algorithms use the shortest-paths algorithm of Fredman and Tarjan <ref> [18] </ref> that runs in O (m + n log n) time.
Reference: [19] <author> H. N. Gabow and R. E. Tarjan. </author> <title> Faster scaling algorithms for network problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 18 </volume> <pages> 1013-1036, </pages> <year> 1989. </year>
Reference-contexts: Different situations require different choices. For general concurrent flow problems, the best choice seems to be either the algorithm of Goldberg and Tarjan [23] or that of Ahuja, Goldberg, Orlin and Tarjan [2]. For concurrent flow with uniform capacity, we use Gabow and Tarjan's <ref> [19] </ref> algorithm for the assignment problem. When both the demands and capacities are uniform, we use the algorithm that iteratively computes shortest paths in the residual graph with nonnegative costs discovered independently by Ford and Fulkerson [17] and Yakovleva [71]. First, we consider the general concurrent flow problem. <p> By arguments similar to those in Lemma 2.4.30, this procedure yields a flow that satisfies (2.19) . To solve the minimum-cost flow problem with capacities u 0 and demands d 0 i , we can use an algorithm of Gabow and Tarjan <ref> [19] </ref>. Gabow and Tarjan show how to modify their scaling 2.5.
Reference: [20] <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of N P -Completeness. W.H. </title> <publisher> Freeman and Company, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: It is strongly N P-hard, and moreover, except for the cases when there are two jobs or when there are two machines and each job has at most two operations, essentially all special cases of this problem are N P-hard, and typically strongly N P-hard <ref> [20, 39] </ref>. For example, it is N P-hard even if there are 3 machines, 3 jobs and each operation is of unit length; in this case we can think of the input length as the maximum number of operations in a job, .
Reference: [21] <author> A. V. Goldberg. </author> <title> A Natural Randomization Strategy for Multicommodity Flow and Related Algorithms. </title> <journal> Information Processing Letters, </journal> <volume> 42 </volume> <pages> 249-256, </pages> <year> 1992. </year>
Reference-contexts: The running times of the presented algorithms depend polynomially on * 1 . The deterministic algorithm runs in time proportional to * 2 and the randomized one runs in time proportional to * 3 . For the randomized algorithm, Goldberg <ref> [21] </ref> and Grigoriadis and Khachiyan [27] have shown how to improve the dependence on * of the randomized algorithm to * 2 . Our model of computation is the RAM. <p> Since in each subsequent call to Decongest, * decreases by a factor of 2, the the running times form a geometric series in * 1 . Hence the running time for the series is dominated by twice the time for the last iteration. Goldberg <ref> [21] </ref> and Grigoriadis and Khachiyan [27] have shown how to reduce the running time of our randomized algorithms by an * 1 factor. Goldberg gives a somewhat simplified 52 CHAPTER 2. <p> We reroute, in decreasing order, the k fl =2 groups with the greatest difference between cost and minimum-cost followed by k fl =2 randomly chosen commodity groups. To prevent domination by a limited number of groups, the random selection weights all commodity groups equally as proposed by Goldberg <ref> [21] </ref> and Grigoriadis and Khachiyan [27]. Note the savings over the theory here. We compute the costs once and then perform several reroutings. By the time that we actually reroute a commodity, it might be the case that that commodity is no longer *-bad.
Reference: [22] <author> A. V. Goldberg and R. E. Tarjan. </author> <title> Finding minimum-cost circulations by canceling negative cycles. </title> <journal> Journal of the ACM, </journal> <volume> 36 </volume> <pages> 873-886, 1898. BIBLIOGRAPHY 177 </pages>
Reference-contexts: Thus we can employ the bounds on Decongest from the second column for the table in Theorem 2.4.20 to obtain faster running times. The * scaling we use is similar to that used by Goldberg and Tarjan in their minimum-cost flow algorithm <ref> [22] </ref>. The details of our scaling algorithm, ScalingConcurrent, appear in Figure 2.11. Lemma 2.4.22 Let T C (*) = T C (*; I) be the running time of Concurrent, on input (*; I).
Reference: [23] <author> A. V. Goldberg and R. E. Tarjan. </author> <title> Solving minimum-cost flow problems by successive approximation. </title> <journal> Mathematics of Operations Research, </journal> <volume> 15(3) </volume> <pages> 430-466, </pages> <year> 1990. </year>
Reference-contexts: ALGORITHMS FOR THE GENERAL CONCURRENT FLOW PROBLEM 51 Proof : Combine Lemma 2.4.1, 2.4.2, Corollary 2.4.16, Corollary 2.4.18 and the fact that a maximum flow in an n-node m-edge graph can be computed in O (nm log (n 2 =m)) time <ref> [23] </ref>. Note that only in the non-simple case does the time for initialization appear in the final time bounds. A scaling algorithm The dependence on * given in Theorem 2.4.21 can be reduced somewhat, through a technique we call *-scaling. <p> 2 log nT MCF ) O (k fl nm log m log (nU ) Proof : Combine Theorem 2.4.21, Corollary 2.4.16, Corollary 2.4.18, Lemma 2.4.22, Theorem 2.4.20 and the fact that a maximum flow in an n-node m-edge graph can be computed in O (nm log (n 2 =m)) time <ref> [23] </ref>. Note that only in the non-simple case does the time for initialization appear in the final bound. Given an instance of a concurrent flow problem, the running time for Algorithm Scal-ingConcurrent is never greater than that of Algorithm Concurrent. <p> In all cases, however, we find a flow that satisfies (2.19). Different situations require different choices. For general concurrent flow problems, the best choice seems to be either the algorithm of Goldberg and Tarjan <ref> [23] </ref> or that of Ahuja, Goldberg, Orlin and Tarjan [2]. For concurrent flow with uniform capacity, we use Gabow and Tarjan's [19] algorithm for the assignment problem.
Reference: [24] <author> D. Goldfarb and M. Grigoriadis. </author> <title> A computational comparison of the Dinic and Network Simplex methods for maximum flow. </title> <journal> Annals of Operations Research, </journal> <volume> 13 </volume> <pages> 83-123, </pages> <year> 1988. </year>
Reference-contexts: We used two different random network generators, netgen [37] and rmfgen <ref> [24] </ref>. rmfgen generates graphs that have a set of square planes with connections between adjacent planes. When we refer to a graph generated by netgen, we will indicate the number of planes.
Reference: [25] <author> T. Gonzalez and S. Sahni. </author> <title> Open shop scheduling to minimize finish time. </title> <journal> Journal of the ACM, </journal> <volume> 23 </volume> <pages> 665-679, </pages> <year> 1976. </year>
Reference-contexts: When there are at least 3 machines both the open and flow shop problems are N P-hard [39]. When there are just two machines both these problems are known to be in P <ref> [29, 25] </ref>. In contrast, the two-machine job shop problem is only known to be polynomial-time solvable if each job has at most two operations, or if each operation has unit size [39]. Despite all the attention, however, surprisingly little has been known about approximation algorithms for shop scheduling problems.
Reference: [26] <author> T. Gonzalez and S. Sahni. </author> <title> Flowshop and jobshop schedules: complexity and approximation. </title> <journal> Operations Research, </journal> <volume> 26 </volume> <pages> 36-52, </pages> <year> 1978. </year>
Reference-contexts: Despite all the attention, however, surprisingly little has been known about approximation algorithms for shop scheduling problems. In fact, all that was known was the following observation by Gonzales and Sahni: Theorem 5.1.1 <ref> [26] </ref> An algorithm A for the job shop problem that produces a schedule in which at least one machine is running at any point in time is an m-approximation algorithm.
Reference: [27] <author> M. D. Grigoriadis and L. G. Khachiyan. </author> <title> Fast approximation schemes for convex programs with many blocks and coupling constraints. </title> <journal> SIAM Journal on Optimization, </journal> <volume> 4(1) </volume> <pages> 86-107, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: The running times of the presented algorithms depend polynomially on * 1 . The deterministic algorithm runs in time proportional to * 2 and the randomized one runs in time proportional to * 3 . For the randomized algorithm, Goldberg [21] and Grigoriadis and Khachiyan <ref> [27] </ref> have shown how to improve the dependence on * of the randomized algorithm to * 2 . Our model of computation is the RAM. We shall use the elementary arithmetic operations (addition, subtraction, comparison, multiplication, and integer division), and count each of these as a single step. <p> Since in each subsequent call to Decongest, * decreases by a factor of 2, the the running times form a geometric series in * 1 . Hence the running time for the series is dominated by twice the time for the last iteration. Goldberg [21] and Grigoriadis and Khachiyan <ref> [27] </ref> have shown how to reduce the running time of our randomized algorithms by an * 1 factor. Goldberg gives a somewhat simplified 52 CHAPTER 2. <p> To prevent domination by a limited number of groups, the random selection weights all commodity groups equally as proposed by Goldberg [21] and Grigoriadis and Khachiyan <ref> [27] </ref>. Note the savings over the theory here. We compute the costs once and then perform several reroutings. By the time that we actually reroute a commodity, it might be the case that that commodity is no longer *-bad.
Reference: [28] <author> M. D. Hansen. </author> <title> Approximation algorithms for geometric embeddings in the plane with applications to parallel processing problems. </title> <booktitle> In Proceedings of the 30th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 604-610. </pages> <publisher> IEEE, </publisher> <month> October </month> <year> 1989. </year>
Reference-contexts: Combining the result of Leighton and Rao with the results of Bhatt and Leighton [9], we obtain algorithms to approximate the minimum cut linear arrangement, minimum area layout and p 2-bifurcators of a graph. They also showed how to approximate the minimum feedback-arc set. Hansen <ref> [28] </ref> has shown how to extend these results to approximate some graph embedding problems, and Makedon and Tragoudas [46] have extended some of these results to hypergraphs. Consider the concurrent flow problem on G with one unit of demand between each pair of nodes.
Reference: [29] <author> S. M. Johnson. </author> <title> Optimal two- and three-stage production schedules with setup times included. </title> <journal> Naval Research Logistics Quarterly, </journal> <pages> pages 61-68, </pages> <year> 1954. </year>
Reference-contexts: When there are at least 3 machines both the open and flow shop problems are N P-hard [39]. When there are just two machines both these problems are known to be in P <ref> [29, 25] </ref>. In contrast, the two-machine job shop problem is only known to be polynomial-time solvable if each job has at most two operations, or if each operation has unit size [39]. Despite all the attention, however, surprisingly little has been known about approximation algorithms for shop scheduling problems.
Reference: [30] <author> S. Kapoor and P. M. Vaidya. </author> <title> Fast algorithms for convex quadratic programming and multicommodity flows. </title> <booktitle> In Proceedings of the 18th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 147-159, </pages> <year> 1986. </year>
Reference-contexts: The concurrent flow problem can be formulated as a linear program in O (mk) variables and O (nk + m) constraints. Any polynomial-time linear programming algorithm can be used to solve the problem optimally. Kapoor and Vaidya <ref> [30] </ref> gave a method to speed up the matrix inversions involved in Karmarkar-type algorithms for multicommodity flow problems; combining their technique with Vaidya's linear programming algorithm that uses fast matrix multiplication [67] yields a time bound of O (k 3:5 n 3 m :5 log (nDU )) for the concurrent flow <p> The concurrent flow problem can be formulated as a linear program in O (mk) variables and O (nk + m) constraints. Any polynomial time linear programming algorithm can be used to solve the problem optimally. Kapoor and Vaidya <ref> [30] </ref> gave a method to speed up the matrix inversions involved in Karmarkar-type algorithms for multicommodity flow problems.
Reference: [31] <author> J. Kennington. </author> <title> A survey of linear cost multicommodity network flows. </title> <journal> Operations Research, </journal> <volume> 26 </volume> <pages> 206-236, </pages> <year> 1978. </year>
Reference-contexts: A detailed description of these approaches requires a knowledge of linear programming that is beyond the scope of this thesis. We refer the reader to the surveys of Assad [5] and Kennington <ref> [31] </ref> and the thesis of Schneur [54] for more information on these approaches. We are aware of two implementations of algorithms for the unit-capacity unit-demand concurrent flow problem. Shahrokhi and Matula [59] report encouraging results for an implemen 4.3. AN IMPLEMENTATION 103 tation of their algorithm.
Reference: [32] <author> J. Kennington. </author> <title> A primal partitioning code for solving multicommodity flow problems (version 1). </title> <type> Technical Report Techincal Report 79009, </type> <institution> Deptartment of Industrial Engineering and Operations Research, Southern Methodist University, </institution> <year> 1979. </year>
Reference-contexts: The comparison reveals sufficiently consistent trends, however, that enable us to draw some general conclusions. We begin with a brief discussion of the algorithm to which we have compared our algorithm. The algorithm is mcnf85, a special purpose simplex code for multicommodity flow problems written by Kennington <ref> [32] </ref>. We chose it for two reasons. First, we had access to the code on our machine. Second, and more importantly, previous tests by Adler, Karmarkar, Resende and Veiga [1] demonstrate its efficiency.
Reference: [33] <author> P. Klein, A. Agrawal, R. Ravi, and S. Rao. </author> <title> Approximation through multicommodity flow. </title> <booktitle> In Proceedings of the 31st Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 726-737, </pages> <year> 1990. </year> <note> 178 BIBLIOGRAPHY </note>
Reference-contexts: APPLICATIONS OF MULTICOMMODITY FLOW main change to the Leighton and Rao algorithm is to select the node s for starting a tree with -(s) maximum.) Klein, Agrawal, Ravi, and Rao <ref> [33] </ref> extended the Leighton and Rao results to the case of simple concurrent flow problems with integral capacities and arbitrary integral demands. For a source-sink pair (s; t), let d (s; t) denote the corresponding demand. <p> The minimum ratio cut problem is to minimize the ratio u ((A))=d (A; A) over all cuts. By inequality (3.4), the minimum value of the ratio u ((A))=d (A; A) is an upper bound on 1= fl . Klein, Agrawal, Ravi, and Rao <ref> [33] </ref> proved that this upper bound is at most a factor of O (log nU log kD) more than 1= fl in general, and they gave an O (log nU log kD) approximation algorithm for the minimum cut problem, where U is the maximum capacity and D is the maximum demand. <p> to the sparsest cut in a graph can be found by a randomized algorithm in O (m 2 log 2 m) time. 3.3.3 Speeding up the General Case Finding Good Dual Solutions The algorithms for finding sparse cuts in node-weighted edge-weighted graphs were discovered by Klein, Agrawal, Ravi and Rao <ref> [33] </ref>. Similar to the algorithm of Leighton and Rao for the unit capacity case, they first approximately solved a concurrent flow problem and then used the edge lengths (dual variables) to guide the second phase of their algorithm. <p> Proof : The idea is to use the O (log n log kD) approximation result of Klein, Agrawal, Ravi, and Rao <ref> [33] </ref> as improved by Tragoudas [66]. Klein et al. show that the minimum value over all cuts u ((A))=d (A; A) is within an O (log n log kD) factor of the value of 1= fl . Consider the following auxiliary concurrent flow problem.
Reference: [34] <author> P. Klein, S. Kang, and J. Borger. </author> <title> Approximating concurrent flow with uniform demands and capacities: an implementation. </title> <booktitle> In DIMACS Series in Discrete Mathematics and Theoretical Computer Science: Volume 12, Network Flows and Matching, </booktitle> <month> October </month> <year> 1991. </year> <note> To appear. </note>
Reference-contexts: We are aware of two implementations of algorithms for the unit-capacity unit-demand concurrent flow problem. Shahrokhi and Matula [59] report encouraging results for an implemen 4.3. AN IMPLEMENTATION 103 tation of their algorithm. Klein, Kang and Borger <ref> [34] </ref> have implemented a variant of the algorithm of Klein, Stein and Tardos [36] which is essentially the algorithm ScalingUnit.
Reference: [35] <author> P. Klein, S. A. Plotkin, C. Stein, and E. Tardos. </author> <title> Faster approximation algorithms for the unit capacity concurrent flow problem with applications to routing and finding sparse cuts. </title> <journal> SIAM Journal on Computing, </journal> <volume> 23(3) </volume> <pages> 466-487, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Our algorithms are approximation algorithms that find *-optimal solutions, 1 This chapter contains joint work with Tom Leighton, Fillia Makedon, Serge Plotkin, Eva Tardos and Spyros Tragoudas [42] and joint work with Philip Klein, Serge Plotkin and Eva Tardos <ref> [35] </ref>. 9 10 CHAPTER 2. MULTICOMMODITY FLOW ALGORITHMS ones in which (1 + *) fl . In this chapter, we describe the first combinatorial approximation algorithms for the concurrent flow problem. Given any positive *, the algorithms find an *-optimal solution. <p> For some cases 1 This chapter contains joint work with Tom Leighton, Fillia Makedon, Serge Plotkin, Eva Tardos and Spyros Tragoudas [42] and joint work with Philip Klein, Serge Plotkin and Eva Tardos <ref> [35] </ref>. 83 84 CHAPTER 3. APPLICATIONS OF MULTICOMMODITY FLOW of interest, however, we can obtain rather strong results.
Reference: [36] <author> P. Klein, C. Stein, and E. Tardos. </author> <title> Leighton-Rao might be practical: faster approximation algorithms for concurrent flow with uniform capacities. </title> <booktitle> In Proceedings of the 22nd Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 310-321, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Shahrokhi and Matula [59] report encouraging results for an implemen 4.3. AN IMPLEMENTATION 103 tation of their algorithm. Klein, Kang and Borger [34] have implemented a variant of the algorithm of Klein, Stein and Tardos <ref> [36] </ref> which is essentially the algorithm ScalingUnit. Initial comparisons to the algorithm of Klein et al. show that, as expected, our algorithm performs fewer iterations, but take more time to perform each iteration. 4.3 An Implementation We now describe how we have adapted and implemented Algorithm ScalingConcurrent.
Reference: [37] <author> D. Klingman, A. Napier, and J. Stutz. NETGEN: </author> <title> A program for generating large scale capacitated assignment, transportation, and minimum cost flow network problems. </title> <journal> Management Science, </journal> <volume> 20 </volume> <pages> 814-821, </pages> <year> 1974. </year>
Reference-contexts: We used two different random network generators, netgen <ref> [37] </ref> and rmfgen [24]. rmfgen generates graphs that have a set of square planes with connections between adjacent planes. When we refer to a graph generated by netgen, we will indicate the number of planes.
Reference: [38] <author> E.L. Lawler. </author> <title> Combinatorial Optimization: Networks and Matroids. </title> <publisher> Holt, Rinehart and Winston, </publisher> <year> 1976. </year>
Reference-contexts: This computation can be carried out via a maximum flow computation in a graph with O (n) nodes and O (m) edges (see, for example, <ref> [38] </ref>). To find a good value of i , we perform binary search over the range of possible i . The maximum possible value of i is no more than the maximum edge flow divided by the minimum edge capacity.
Reference: [39] <author> E.L. Lawler, J.K. Lenstra, A.H.G. Rinooy Kan, </author> <title> and D.B. Shmoys. Sequencing and scheduling: Algorithms and complexity. In S.C. Graves, </title> <editor> A.H.G. Rinnooy Kan, and P.H. Zipkin, editors, </editor> <booktitle> Handbooks in Operations Research and Management Science, </booktitle> <volume> Vol 4., </volume> <booktitle> Logistics of Production and Inventory, </booktitle> <pages> pages 445-522. </pages> <publisher> North-Holland, </publisher> <year> 1993. </year>
Reference-contexts: It is strongly N P-hard, and moreover, except for the cases when there are two jobs or when there are two machines and each job has at most two operations, essentially all special cases of this problem are N P-hard, and typically strongly N P-hard <ref> [20, 39] </ref>. For example, it is N P-hard even if there are 3 machines, 3 jobs and each operation is of unit length; in this case we can think of the input length as the maximum number of operations in a job, . <p> A striking example of this difficulty is that a single instance of the problem involving only 10 jobs, 10 machines and 100 operations, which first appeared in a book by Muth and Thompson in 1963, remained unsolved for 23 years despite repeated attempts to find an optimal solution <ref> [39] </ref>. Today, due to better algorithms and faster machines, instances with 10 jobs and 10 machines seem to be tractable. <p> These lower bounds apply regardless of 132 CHAPTER 5. APPROXIMATION ALGORITHMS FOR SHOP SCHEDULING whether we have a job, flow, open or dag shop problem. There has been a tremendous amount of literature on shop scheduling problems over the last thirty years <ref> [39] </ref>. We mentioned earlier that all but the most restrictive versions of the job shop problem are N P-hard, as are the other versions of the problem. When there are at least 3 machines both the open and flow shop problems are N P-hard [39]. <p> problems over the last thirty years <ref> [39] </ref>. We mentioned earlier that all but the most restrictive versions of the job shop problem are N P-hard, as are the other versions of the problem. When there are at least 3 machines both the open and flow shop problems are N P-hard [39]. When there are just two machines both these problems are known to be in P [29, 25]. In contrast, the two-machine job shop problem is only known to be polynomial-time solvable if each job has at most two operations, or if each operation has unit size [39]. <p> are N P-hard <ref> [39] </ref>. When there are just two machines both these problems are known to be in P [29, 25]. In contrast, the two-machine job shop problem is only known to be polynomial-time solvable if each job has at most two operations, or if each operation has unit size [39]. Despite all the attention, however, surprisingly little has been known about approximation algorithms for shop scheduling problems. <p> They also added the restriction that each path does not traverse any edge more than once, or in scheduling terminology, each job has at most one operation on each machine. This restriction of the job shop problem remains (strongly) N P-hard <ref> [39] </ref>. The main result of Leighton, Maggs and Rao was to show that for their special case of the job shop problem, there always exists a schedule of length O ( max + P max ).
Reference: [40] <author> F. T. Leighton, </author> <month> November </month> <year> 1989. </year> <title> Private communication. </title>
Reference-contexts: A much more efficient approach is to use our unit-capacity approximation algorithm. The number of commodities required is O (n 2 ). Leighton <ref> [40] </ref> has discovered a technique to reduce the number of commodities required.
Reference: [41] <author> T. Leighton, B. Maggs, and S. Rao. </author> <title> Universal packet routing algorithms. </title> <booktitle> In Proceedings of the 29th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 256-269, </pages> <year> 1988. </year>
Reference-contexts: Another important result on shop scheduling comes, somewhat surprisingly, from the literature on packet routing. Leighton, Maggs and Rao <ref> [41] </ref> have proposed the following model for the routing of packets in a network: find paths for the packets, and then schedule the transmission 134 CHAPTER 5. APPROXIMATION ALGORITHMS FOR SHOP SCHEDULING of the packets along these paths so that no two packets traverse the same edge simultaneously. <p> We conclude with a discussion of the open shop problem in Section 5.5 and some open problems in Section 5.6. 5.2 The Basic Algorithm In this section we extend the technique due to Leighton, Maggs and Rao <ref> [41] </ref> of assigning random delays to jobs to the general case of non-preemptive job shop scheduling. A valid schedule assigns at most one job to a particular machine at any time, and schedules each job on at most one machine at any time.
Reference: [42] <author> T. Leighton, F. Makedon, S. Plotkin, C. Stein, E. Tardos, and S. Tragoudas. </author> <title> Fast approximation algorithms for multicommodity flow problems. </title> <booktitle> In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 101-111, </pages> <year> 1991. </year> <note> To appear in JCSS. BIBLIOGRAPHY 179 </note>
Reference-contexts: We denote the value of the maximum edge congestion by and the minimum possible maximum edge congestion by fl . Our algorithms are approximation algorithms that find *-optimal solutions, 1 This chapter contains joint work with Tom Leighton, Fillia Makedon, Serge Plotkin, Eva Tardos and Spyros Tragoudas <ref> [42] </ref> and joint work with Philip Klein, Serge Plotkin and Eva Tardos [35]. 9 10 CHAPTER 2. MULTICOMMODITY FLOW ALGORITHMS ones in which (1 + *) fl . In this chapter, we describe the first combinatorial approximation algorithms for the concurrent flow problem. <p> In general, we can not obtain results about integral solutions that are as strong as the results we have obtained about non-integral solutions. For some cases 1 This chapter contains joint work with Tom Leighton, Fillia Makedon, Serge Plotkin, Eva Tardos and Spyros Tragoudas <ref> [42] </ref> and joint work with Philip Klein, Serge Plotkin and Eva Tardos [35]. 83 84 CHAPTER 3. APPLICATIONS OF MULTICOMMODITY FLOW of interest, however, we can obtain rather strong results. <p> As discussed in Chapter 3, one of the motivations for this work comes from multicommodity flow problems that arise in approximating various NP-hard problems. (See [43],[33],[35], and <ref> [42] </ref> for details.) These problems have large numbers of commodities, i.e., at least as many commodities as the number of nodes.
Reference: [43] <author> T. Leighton and S. Rao. </author> <title> An approximate max-flow min-cut theorem for uniform multi-commodity flow problems with applications to approximation algorithms. </title> <booktitle> In Proceedings of the 29th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 422-431, </pages> <year> 1988. </year>
Reference-contexts: The metric we use is fi = u ((A))=(jAjj Aj): This value, fi, is small when the number of edges crossing the cut is small and when the two sides are balanced. Leighton and Rao <ref> [43] </ref> gave an O (log n)-approximation algorithm for the problem of minimizing the ratio fi = u ((A))=(jAjj Aj) over all cuts. Given the ability to find such cuts, many problems have been solved by using a divide-and-conquer approach in the manner described in the first paragraph of this subsection. <p> In particular, this approach has yielded the first polylog-times-optimal approximation algorithms for a wide variety of NP-complete graph problems. Leighton and Rao <ref> [43] </ref> showed how to use 3.3. SPARSE CUTS 89 these techniques to find approximately balanced separators. Combining the result of Leighton and Rao with the results of Bhatt and Leighton [9], we obtain algorithms to approximate the minimum cut linear arrangement, minimum area layout and p 2-bifurcators of a graph. <p> The Leighton and Rao <ref> [43] </ref> algorithm uses the solution of a concurrent flow problem in which the demand graph is the complete graph.
Reference: [44] <author> T. Leong, P. Shor, and C. Stein. </author> <title> DIMACS Series in Discrete Mathematics and Theoretical Computer Science: Volume 12, Network Flows and Matching, chapter Implementation of a combinatorial multicommodity flow algorithm. </title> <month> October </month> <year> 1991. </year>
Reference-contexts: An instance M of the concurrent flow problem can be expressed as the following linear program: 1 This chapter describes joint work with Tishya Leong and Peter Shor <ref> [44] </ref>. 101 102 CHAPTER 4.
Reference: [45] <author> G. F. Lev, N. Pippenger, and L. G. Valiant. </author> <title> A fast parallel algorithm for routing in permutation networks. </title> <journal> IEEE Transactions on Computers, </journal> <volume> C-30:93-100, </volume> <year> 1981. </year>
Reference-contexts: As long as there is at least one processor per operation, this coloring can be done in N C using the edge-coloring algorithm of Lev, Pippinger, and Valiant <ref> [45] </ref>.
Reference: [46] <author> F. Makedon and S. Tragoudas. </author> <title> Approximating the minimum net expansion: Near optimal solutions to circuit partitioning problems. </title> <booktitle> In Procedings of the 1990 Workshop on Graph Theoretic Concepts in Computer Science, </booktitle> <month> June </month> <year> 1990. </year>
Reference-contexts: They also showed how to approximate the minimum feedback-arc set. Hansen [28] has shown how to extend these results to approximate some graph embedding problems, and Makedon and Tragoudas <ref> [46] </ref> have extended some of these results to hypergraphs. Consider the concurrent flow problem on G with one unit of demand between each pair of nodes. <p> An analogous theorem can be obtained for finding approximately sparsest cuts in hypergraphs using the concurrent flow algorithm in conjunction with the approximation algorithm of Make don and Tragoudas <ref> [46] </ref>. 3.3.4 A Faster Algorithm for Low Degree Graphs In this section, we improve the running time given in Corollary 3.3.6 for low-degree graphs G. The new running time depends on , the maximum degree of any node in the graph G.
Reference: [47] <author> B.A. Murtaugh and M.A. Saunders. </author> <title> minos 5.0 user's guide. </title> <type> Technical Report Technical Report 83-20, </type> <institution> Systemns Optimizaiton Laboratory, Stanford University, </institution> <year> 1983. </year>
Reference-contexts: First, we had access to the code on our machine. Second, and more importantly, previous tests by Adler, Karmarkar, Resende and Veiga [1] demonstrate its efficiency. Adler et al. compared three different codes for multi-commodity flow: minos 5.0, which is an advanced implementation of the simplex method <ref> [47] </ref>, mcnf85, and their own interior point method. Their experiments show that the running time of minos grows much faster than that of the other two algorithms and that, for the problems they tested, mcnf85 and the interior point algorithm have comparable running times.
Reference: [48] <author> S. Plotkin, D. B. Shmoys, and E. Tardos. </author> <title> Fast approximation algorithms for fractional packing and covering problems. </title> <note> To appear in Math of Operations Research, </note> <year> 1995. </year>
Reference-contexts: While this approach yields a polynomial-time algorithm, the polynomial is rather large, since the bottleneck step is the solution of a large linear program. Recently, Plotkin, Shmoys and Tardos <ref> [48] </ref> have generalized the multicommodity flow approximation algorithms of Chapter 2 to show how to approximate a large class of packing linear programs. In this chapter we shall use their results to obtain an algorithm that is much more efficient than the randomized rounding approach. <p> The rest of this chapter focuses on solving Problem 6.1.1. 6.2 The Framework In this section, we describe the framework of Plotkin, Shmoys and Tardos <ref> [48] </ref> for approximately solving packing linear programs. We will be somewhat vague in our description, since it is only meant to convey the main ideas of their work. In the next section, we will be more formal and prove the results, citing from [48] as needed. 1 A recent result by <p> the framework of Plotkin, Shmoys and Tardos <ref> [48] </ref> for approximately solving packing linear programs. We will be somewhat vague in our description, since it is only meant to convey the main ideas of their work. In the next section, we will be more formal and prove the results, citing from [48] as needed. 1 A recent result by Srinivasan [65] describes how to achieve this bound using different techniques. 6.2. THE FRAMEWORK 153 Recall the concurrent flow problem that we solved in Chapter 2. <p> Informally, each iteration can be thought of as tightening constraint (6.4). Plotkin, Shmoys and Tardos <ref> [48] </ref> have shown that the techniques used for multicommodity flow problem in Chapter 2 apply to a much wider class of problems. They have given approximation algorithms for a large class of packing linear programs. <p> Such linear programs are called packing programs because constraints (6.7) define the problem of packing a convex combination of vectors subject to "capacity" constraints b. Let fl denote the minimum possible value of . The main result of <ref> [48] </ref> is that if a packing linear program satisfies certain technical conditions, then a solution with (1 + *) fl can be found in polynomial time. <p> Again, if we let y be the edge lengths ` in the multicommodity flow algorithm, the subroutine OPT is just a minimum-cost flow algorithm. We do not wish to spend much time on the general case. The reader is referred to <ref> [48] </ref> for a host of algorithms and applications. To understand how the algorithm works, we state the main routine, improve-packing which appears in Figure 6.1. Note the similarities with Decongest. <p> Observe that = P i i . Instead of a subroutine OPT, we have a series of k subroutines. The i th subroutine minimizes cx i subject to x i 2 P i for costs c = y t A i . In <ref> [48] </ref>, the main motivation for introducing this formulation is to allow the use of randomness. Where algorithm Concurrent randomly chooses a commodity i to reroute, Plotkin, Shmoys and Tardos randomly choose a polytope P i over which to optimize. <p> In addition, by analysis similar to that used in Theorem 3.2.1, we can obtain the following theorem: Theorem 6.2.1 (Plotkin, Shmoys, Tardos <ref> [48] </ref>) Let = max i i , and let = max f fl ; (=d) log M g, where M is the number of packing constraints and d is a parameter such that each component of each x i is comprised of integral multiples of d. <p> Further, throughout the execution, * = ( p For the remainder of this chapter, we focus specifically on the application to shop scheduling and quote results from <ref> [48] </ref> as needed. 6.3 The Solution We now turn to the solution of Problem 6.1.1. Since we introduce initial delays in the range [0; max = log (m)], the resulting schedule has length ` = P max + max =log (m). <p> Finally, the error * = ( p We now turn to the time needed to implement one iteration. We will show that an iteration can be implemented efficiently in the RAM model of computation. While it appears that the algorithms in <ref> [48] </ref> can be implemented in the RAM model using techniques similar to those used in Section 2.4.2 of this thesis, the computation is not explicitly done in [48]. Here we perform the necessary computations for the case of program ICONJ. <p> While it appears that the algorithms in <ref> [48] </ref> can be implemented in the RAM model using techniques similar to those used in Section 2.4.2 of this thesis, the computation is not explicitly done in [48]. Here we perform the necessary computations for the case of program ICONJ. The first step of Improve-Packing computes the costs y i = 1 b i e ffa i x=b i . As before, the difficulty here is that we have to compute exponential functions. <p> In order to have an efficient algorithm, we must bound the precision needed in our computation. We now show that we need only O (log (m)) bits of precision for each component of y. We use the following theorem of <ref> [48] </ref>, which is similar to Lemma 2.4.24. 6.3. THE SOLUTION 161 Theorem 6.3.2 [48] Let C p (y) be the value returned by OPT, the minimization subroutine. <p> We now show that we need only O (log (m)) bits of precision for each component of y. We use the following theorem of <ref> [48] </ref>, which is similar to Lemma 2.4.24. 6.3. THE SOLUTION 161 Theorem 6.3.2 [48] Let C p (y) be the value returned by OPT, the minimization subroutine.
Reference: [49] <author> P. Raghavan. </author> <title> Probabilistic construction of deterministic algorithms: approximating packing integer programs. </title> <booktitle> In Proceedings of the 27th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 10-18, </pages> <year> 1986. </year>
Reference-contexts: In fact, the constant implicit in this bound is quite small. Later Raghavan <ref> [49] </ref> showed how this conversion method can be made deterministic. Using Theorem 3.2.1, we can directly obtain an integral flow satisfying (3.3) and thus solve the channel routing problem. This method is much faster than the original method of Raghavan and Thompson.
Reference: [50] <author> P. Raghavan. </author> <title> Probabilistic construction of deterministic algorithms: approximating packing integer programs. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 37 </volume> <pages> 130-143, </pages> <year> 1988. </year>
Reference-contexts: In Chapter 6 we will show how to find integer solutions to a related problem. The unit-capacity unit-demand problem in which fl = (log n) is one of those studied by Raghavan <ref> [50] </ref> and Raghavan and Thompson [51, 52]. The problem is to find a solution to a unit-capacity unit-demand concurrent flow problem in which all flows must be integral. They introduced a technique for solving this type of problem known as randomized rounding. <p> The previous bounds involved using the linear programming algorithm of Vaidya [67], which takes O (n 10:5 7 log (m)) for this problem, combined with a deterministic version of the randomized rounding of Raghavan and Thompson [52] and Raghavan <ref> [50] </ref>. Glossary of Notation A glossary of nation, containing symbols that are used frequently, follows. It is divided into three sections. The first contains notation used in Chapters 2, 3 and 4 to describe multicommodity flows. The second contains notation used in Chapters 5 and 6 to describe shop scheduling.
Reference: [51] <author> P. Raghavan and C. D. Thompson. </author> <title> Provably good routing in graphs: regular arrays. </title> <booktitle> In Proceedings of the 17th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 79-87, </pages> <year> 1985. </year>
Reference-contexts: In Chapter 6 we will show how to find integer solutions to a related problem. The unit-capacity unit-demand problem in which fl = (log n) is one of those studied by Raghavan [50] and Raghavan and Thompson <ref> [51, 52] </ref>. The problem is to find a solution to a unit-capacity unit-demand concurrent flow problem in which all flows must be integral. They introduced a technique for solving this type of problem known as randomized rounding. <p> In other words, we do not need to 3.2. AN INTEGER THEOREM FOR MULTICOMMODITY FLOWS 85 solve the linear-program relaxation and perform the rounding. Our modification to algorithm ScalingUnit provides an alternative proof of Raghavan and Thompson's result <ref> [51] </ref>. It also yields a significantly faster algorithm, since the time-consuming step is now approximately solving a concurrent flow problem, rather than exactly solving a linear-program. <p> The 3.3. SPARSE CUTS 87 modules are connected up by wires that are routed through the channels. For purposes of regularity the channels have uniform width. It is desirable to minimize that width in order to minimize the total area of the VLSI circuit. Raghavan and Thompson <ref> [51] </ref> give an approximation algorithm for minimizing the channel width. They model the problem as a graph problem in which one must route wires between pairs of nodes in a graph G so as to minimize the maximum number of wires routed through an edge.
Reference: [52] <author> P. Raghavan and C. D. Thompson. </author> <title> Randomized rounding: a technique for provably good algorithms and algorithmic proofs. </title> <journal> Combinatorica, </journal> <volume> 7 </volume> <pages> 365-374, </pages> <year> 1987. </year> <note> 180 BIBLIOGRAPHY </note>
Reference-contexts: In Chapter 6 we will show how to find integer solutions to a related problem. The unit-capacity unit-demand problem in which fl = (log n) is one of those studied by Raghavan [50] and Raghavan and Thompson <ref> [51, 52] </ref>. The problem is to find a solution to a unit-capacity unit-demand concurrent flow problem in which all flows must be integral. They introduced a technique for solving this type of problem known as randomized rounding. <p> One approach, which appears in [60], is to use a derandomized version of the randomized rounding techniques of Raghavan and Thompson <ref> [52] </ref>, which are alluded to in Chapter 3. While this approach yields a polynomial-time algorithm, the polynomial is rather large, since the bottleneck step is the solution of a large linear program. <p> The previous bounds involved using the linear programming algorithm of Vaidya [67], which takes O (n 10:5 7 log (m)) for this problem, combined with a deterministic version of the randomized rounding of Raghavan and Thompson <ref> [52] </ref> and Raghavan [50]. Glossary of Notation A glossary of nation, containing symbols that are used frequently, follows. It is divided into three sections. The first contains notation used in Chapters 2, 3 and 4 to describe multicommodity flows.
Reference: [53] <author> R. Ravi, A. Agrawal, and P. Klein. </author> <title> Ordering problems approximated: single-processor scheduling and interval graph completion. </title> <booktitle> In Proceedings of the 1991 ICALP Conference, </booktitle> <pages> pages 751-762, </pages> <year> 1991. </year>
Reference-contexts: Using this result, Klein et al. give approximation algorithms for chordalization of a graph, register sufficiency, minimum deletion of clauses in a 2CN F formula, via minimization and the edge-deletion graph bipartization problems. Later Ravi, Agrawal and Klein <ref> [53] </ref> used these techniques to give approximation algorithms for interval graph completion and a single-processor scheduling algorithm.
Reference: [54] <author> R. Schneur. </author> <title> Scaling algorithms for multicommodity flow problems and network flow problems with side constraints. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <address> Cambridge, MA, </address> <month> February </month> <year> 1991. </year>
Reference-contexts: Some algorithms that take advantage of the special structure of mul-ticommodity flow problems have been proposed. These algorithms fall into three main classes: price-directive decomposition, resource-directive decomposition, and partitioning approaches. More recent approaches include interior-point methods [1] and a combinatorial scaling algorithm <ref> [54] </ref>. All of the aforementioned algorithms solve multicommodity flow problems using one of two different objective functions. Some find a minimum-cost multicommodity flow, while others find a flow that maximizes the total amount of flow in the network. <p> A detailed description of these approaches requires a knowledge of linear programming that is beyond the scope of this thesis. We refer the reader to the surveys of Assad [5] and Kennington [31] and the thesis of Schneur <ref> [54] </ref> for more information on these approaches. We are aware of two implementations of algorithms for the unit-capacity unit-demand concurrent flow problem. Shahrokhi and Matula [59] report encouraging results for an implemen 4.3. AN IMPLEMENTATION 103 tation of their algorithm. <p> We also note that the minimum-cost flow code that we used is written to handle multiple sources and sinks, so grouping does not create any added complexity. The advantages gained by grouping commodities have also been documented by Schneur <ref> [54] </ref>. 104 CHAPTER 4. IMPLEMENTING MULTICOMMODITY FLOW ALGORITHMS 4.3.2 Choosing a Commodity to Reroute Recall that algorithm ScalingConcurrent uses either a deterministic strategy or a randomized strategy for choosing a commodity group (or a commodity) to reroute. <p> The first, by Shahrokhi and Matula [59], works only for graphs in which every capacity and demand is 1, but it would still be interesting to see how our algorithm 4.5. CONCLUSIONS AND OPEN PROBLEMS 117 compares to theirs on this class of graphs. The second, by Schneur <ref> [54] </ref>, also works by gradually rerouting flow. She has shown that her algorithm runs well on many problems. We would like to compare the algorithms on the same machine and the same problems. We conclude by mentioning a valuable lesson learned about accuracy.
Reference: [55] <author> A. Schrijver. </author> <title> Theory of linear and integer programming. </title> <publisher> John Wiley and Sons, </publisher> <year> 1986. </year>
Reference-contexts: While none of our algorithms actually rely on a procedure for linear programming, some of the proofs rely on well-known results about linear programming. We refer the reader who is unfamiliar with linear programming to a basic textbook such as that of Chvatal [11] or Schrijver <ref> [55] </ref>. We include an glossary of notation.
Reference: [56] <author> S. V. Sevast'yanov. </author> <title> On an asymptotic approach to some problems in scheduling theory. </title> <booktitle> In Abstracts of papers at 3rd All-Union Conf. of Problems of Theoretical Cybernetics [in Russian], </booktitle> <pages> pages 67-69. </pages> <publisher> Inst. Mat. Sibirsk. Otdel. Akad. Nauk SSSR, </publisher> <address> Novosibirsk, </address> <year> 1974. </year>
Reference-contexts: The most interesting approximation algorithms to date for job shop scheduling have appeared primarily in the Soviet literature and are based on a beautiful connection to geometric arguments. This approach was independently discovered by Belov and Stolin [7] and by Sevast'yanov <ref> [56] </ref> as 5.1. INTRODUCTION 133 well as by Fiala [15]. This approach typically produces schedules for which the length can be bounded by max + q (m; )p max , where q (; ) is a polynomial, and p max = max ij p ij is the maximum operation length. <p> Finally, combining this theorem with the results of Chapter 5 we get the following theorem. The other bottleneck in the shop scheduling algorithm is the algorithm of Sevast'yanov <ref> [56] </ref> that takes O ((mn) 2 ) time. Theorem 6.3.8 There exists a deterministic algorithm for job shop scheduling that finds a schedule of length O (log 2 (m) C fl max ) in O (n 2 m 2 2 + n 3 2 log (m)( + log (m))) time.
Reference: [57] <author> S.V. Sevast'yanov. </author> <title> Efficient construction of schedules close to optimal for the cases of arbitrary and alternative routes of parts. </title> <journal> Soviet Math. Dokl., </journal> <volume> 29(3) </volume> <pages> 447-450, </pages> <year> 1984. </year>
Reference-contexts: This approach typically produces schedules for which the length can be bounded by max + q (m; )p max , where q (; ) is a polynomial, and p max = max ij p ij is the maximum operation length. For the job shop problem, Sevast'yanov <ref> [57, 58] </ref> gave a polynomial-time algorithm that delivers a schedule of length at most max + O (m 3 )p max . The bounds obtained in this way do not give good worst-case relative error bounds.
Reference: [58] <author> S.V. Sevast'yanov. </author> <title> Bounding algorithm for the routing problem with arbitrary paths and alternative servers. </title> <journal> Kibernetika, </journal> <volume> 22(6) </volume> <pages> 74-79, </pages> <year> 1986. </year> <booktitle> Translation in Cybernetics 22, </booktitle> <pages> pages 773-780. </pages>
Reference-contexts: This approach typically produces schedules for which the length can be bounded by max + q (m; )p max , where q (; ) is a polynomial, and p max = max ij p ij is the maximum operation length. For the job shop problem, Sevast'yanov <ref> [57, 58] </ref> gave a polynomial-time algorithm that delivers a schedule of length at most max + O (m 3 )p max . The bounds obtained in this way do not give good worst-case relative error bounds. <p> For the instance consisting of just the short jobs, let 0 max and p 0 max denote the maximum machine load and operation length, respectively. Using the algorithm of <ref> [58] </ref> described in the introduction, we can, in time polynomial in the input size, produce a schedule of length 0 max + 2m 3 p 0 this instance. <p> A schedule for the resulting job shop problem of length ( max + P max ) yields a solution for the more general problem of length O ( ( avg + P max )). Sevast'yanov <ref> [58] </ref> used a somewhat more complicated reduction to handle a slightly more general setting. For each operation O ij to be processed by a machine in S k , if p ij (S k )=jS k j, assign O ij to one machine in S k .
Reference: [59] <author> F. Shahrokhi and D. W. Matula. </author> <title> The maximum concurrent flow problem. </title> <journal> Journal of the ACM, </journal> <volume> 37:318 - 334, </volume> <year> 1990. </year>
Reference-contexts: The only previous combinatorial polynomial approximation algorithms for concurrent flow problems only handle the special case when all the capacities are 1. For this special case, Shahrokhi and Matula <ref> [59] </ref> gave an algorithm that ran in O (* 5 nm 7 ) time. Our algorithm is based on this work, so we describe the basic ideas here. The algorithm starts by finding a flow that satisfies the demands but not the capacity constraints. <p> jf i (vw)j, and say that a multicommodity flow f in G is feasible if f (vw) u (vw) for all edges vw. (Note that f (vw) is always non-negative.) We consider the optimization version of this problem, called the simple concurrent flow problem, first defined by Shahrokhi and Matula <ref> [59] </ref>. In this problem the objective is to compute the maximum possible value z such that there is a feasible multicommodity flow with demands z d i for 1 i k. We call z the throughput of the multicommodity flow. <p> We refer the reader to the surveys of Assad [5] and Kennington [31] and the thesis of Schneur [54] for more information on these approaches. We are aware of two implementations of algorithms for the unit-capacity unit-demand concurrent flow problem. Shahrokhi and Matula <ref> [59] </ref> report encouraging results for an implemen 4.3. AN IMPLEMENTATION 103 tation of their algorithm. Klein, Kang and Borger [34] have implemented a variant of the algorithm of Klein, Stein and Tardos [36] which is essentially the algorithm ScalingUnit. <p> Using the solution to the previous problem as a starting point for the new problem might improve the running time. We are aware of two other implementations of combinatorial algorithms to which we should compare our algorithm. The first, by Shahrokhi and Matula <ref> [59] </ref>, works only for graphs in which every capacity and demand is 1, but it would still be interesting to see how our algorithm 4.5. CONCLUSIONS AND OPEN PROBLEMS 117 compares to theirs on this class of graphs. The second, by Schneur [54], also works by gradually rerouting flow.
Reference: [60] <author> D. B. Shmoys, C. Stein, and J. Wein. </author> <title> Improved approximation algorithms for shop scheduling problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 23(3) </volume> <pages> 617-632, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: If the total order is the 1 This chapter describes joint work with David Shmoys and Joel Wein <ref> [60] </ref>. 129 130 CHAPTER 5. APPROXIMATION ALGORITHMS FOR SHOP SCHEDULING same total order for every job, and each job has at most one operation on each machine, we have a flow shop scheduling problem. <p> APPROXIMATION ALGORITHMS FOR SHOP SCHEDULING more efficient algorithms that have the same performance guarantees? Chapter 6 Derandomizing Shop Scheduling Via Flow Techniques In this chapter, we show how the shop scheduling algorithms of the previous chapter can be made deterministic. One approach, which appears in <ref> [60] </ref>, is to use a derandomized version of the randomized rounding techniques of Raghavan and Thompson [52], which are alluded to in Chapter 3. While this approach yields a polynomial-time algorithm, the polynomial is rather large, since the bottleneck step is the solution of a large linear program.
Reference: [61] <author> D. B. Shmoys, J. Wein, and D.P. Williamson. </author> <title> Scheduling parallel machines on-line. </title> <journal> SIAM Journal on Computing, </journal> <note> 1994. To appear. </note>
Reference-contexts: It is possible to extend this model by associating with each job J j a release date r j , on which J j becomes available for processing. A theorem of Shmoys, Wein and Williamson <ref> [61] </ref> shows that the length of the optimal schedule is no more than twice the length of the optimal schedule for the corresponding problem without release dates. All our results thus apply to this model, with the corresponding bounds multiplied by 2.
Reference: [62] <author> D.B. Shmoys. </author> <type> Personal communication, </type> <year> 1990. </year>
Reference-contexts: This simpler presentation of the proof is due to David Shmoys <ref> [62] </ref>. Theorem 5.1.3 There exists a polynomial time algorithm A for the flow shop problem that yields a schedule of length bounded above by C fl max + m (m 1)p max . Proof : The proof relies heavily on the following lemma.
Reference: [63] <author> D D. Sleator and R.E. Tarjan. </author> <title> A data structure for dynamic trees. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 26 </volume> <pages> 362-391, </pages> <year> 1983. </year>
Reference-contexts: We must first update the flow graph G i to reflect this change. Second, the update might introduce directed cycles in G i , so we must eliminate such cycles of flow. We use an algorithm due to Sleator and Tarjan <ref> [63] </ref> to implement this process. Sleator and Tarjan gave a simple O (nm) algorithm and a more sophisticated O (m log n) algorithm for the problem of converting an arbitrary flow into an acyclic flow. Eliminating cycles only decreases the flows on edges, so it cannot increase .
Reference: [64] <author> D.D. Sleator and R.E. Tarjan. </author> <title> Self-adjusting binary search trees. </title> <journal> Journal of the ACM, </journal> <volume> 32 </volume> <pages> 652-686, </pages> <year> 1985. </year> <note> BIBLIOGRAPHY 181 </note>
Reference-contexts: This procedure is known as flow decomposition and it is well known how to compute a decomposition in O (nm) time (see, for example [3]) and in O (m log n) time using the dynamic tree data structure. <ref> [64] </ref> The sources and sinks play a symmetric role in the (undirected) problem, and hence k fl in the lemma could have been defined as the number of nodes in any subset that contains an endpoint of each commodity.
Reference: [65] <author> A. Srinivasan. </author> <title> A generalization of Chernoff-Hoeffding bounds, with applications. </title> <type> Unpublished Manuscript, </type> <year> 1992. </year>
Reference-contexts: We will be somewhat vague in our description, since it is only meant to convey the main ideas of their work. In the next section, we will be more formal and prove the results, citing from [48] as needed. 1 A recent result by Srinivasan <ref> [65] </ref> describes how to achieve this bound using different techniques. 6.2. THE FRAMEWORK 153 Recall the concurrent flow problem that we solved in Chapter 2.
Reference: [66] <author> S. Tragoudas. </author> <title> VLSI partitioning approximation algorithms based on multicommodity flow and other techniques. </title> <type> PhD thesis, </type> <institution> University of Texax at Dallas, </institution> <year> 1991. </year>
Reference-contexts: Tragoudas <ref> [66] </ref> has observed that their algorithm can be modified to give an O (log n log kD) factor instead. <p> Proof : The idea is to use the O (log n log kD) approximation result of Klein, Agrawal, Ravi, and Rao [33] as improved by Tragoudas <ref> [66] </ref>. Klein et al. show that the minimum value over all cuts u ((A))=d (A; A) is within an O (log n log kD) factor of the value of 1= fl . Consider the following auxiliary concurrent flow problem. The graph is G with capacities u.
Reference: [67] <author> P. M. Vaidya. </author> <title> Speeding up linear programming using fast matrix multiplication. </title> <booktitle> In Proceedings of the 30th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 332-337, </pages> <year> 1989. </year>
Reference-contexts: Any polynomial-time linear programming algorithm can be used to solve the problem optimally. Kapoor and Vaidya [30] gave a method to speed up the matrix inversions involved in Karmarkar-type algorithms for multicommodity flow problems; combining their technique with Vaidya's linear programming algorithm that uses fast matrix multiplication <ref> [67] </ref> yields a time bound of O (k 3:5 n 3 m :5 log (nDU )) for the concurrent flow problem with integer demands and an O (k 2:5 n 2 m :5 log (n* 1 DU )) time bound to find an approximate solution. <p> Any polynomial time linear programming algorithm can be used to solve the problem optimally. Kapoor and Vaidya [30] gave a method to speed up the matrix inversions involved in Karmarkar-type algorithms for multicommodity flow problems. Combining their technique with Vaidya's linear programming algorithm that uses fast matrix multiplication <ref> [67] </ref> yields a time bound of O (k 3:5 n 3 m :5 log (nDU )) to obtain an optimal solution to the concurrent flow problem with integer demands and an O (k 2:5 n 2 m :5 log (n* 1 DU )) time bound to find an approximate solution. <p> The running time in Theorem 6.3.8 compares quite favorably with the previous best bound for this problem. The previous bounds involved using the linear programming algorithm of Vaidya <ref> [67] </ref>, which takes O (n 10:5 7 log (m)) for this problem, combined with a deterministic version of the randomized rounding of Raghavan and Thompson [52] and Raghavan [50]. Glossary of Notation A glossary of nation, containing symbols that are used frequently, follows. It is divided into three sections.
Reference: [68] <author> J. Wein. </author> <title> Algorithms for Scheduling and Network Problems. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <address> Cambridge, MA, </address> <month> August </month> <year> 1991. </year>
Reference-contexts: We can adapt her proof to show that, in fact, the greedy algorithm delivers a schedule that is no longer than a factor of 2 times optimal. In fact Wein <ref> [68] </ref>, has shown that even with release dates the greedy algorithm is a 2-approximation algorithm. He has also shown that this bound is fairly tight, since he can produce schedules of length (2 1 m ) times optimal. We include his proof here.
Reference: [69] <author> D. P. Williamson. </author> <title> The non-approximability of shop scheduling. </title> <type> Unpublished Manuscript, </type> <year> 1991. </year>
Reference-contexts: The theorem follows directly. Little was also known in the way of negative results, results that indicate it is difficult to approximate these problems. Recently, however, Williamson, Hall, Hoogeveen, Hurkens, Lenstra, and Shmoys [70], extending work by Williamson <ref> [69] </ref>, have shown that unless P = N P, none of these problems can be approximated arbitrarily closely.
Reference: [70] <author> D. P. Williamson, L. Hall, J. A. Hoogeven, C. A. J. Hurkens, J. K. Lenstra, and D. B. Shmoys. </author> <title> Short shop schedules. </title> <type> Unpublished Manuscript, </type> <year> 1993. </year>
Reference-contexts: The theorem follows directly. Little was also known in the way of negative results, results that indicate it is difficult to approximate these problems. Recently, however, Williamson, Hall, Hoogeveen, Hurkens, Lenstra, and Shmoys <ref> [70] </ref>, extending work by Williamson [69], have shown that unless P = N P, none of these problems can be approximated arbitrarily closely. Theorem 5.1.2 [70] Unless P = N P, there is no polynomial-time algorithm that approximates any of the job shop, flow shop or open shop problems within a <p> Recently, however, Williamson, Hall, Hoogeveen, Hurkens, Lenstra, and Shmoys <ref> [70] </ref>, extending work by Williamson [69], have shown that unless P = N P, none of these problems can be approximated arbitrarily closely. Theorem 5.1.2 [70] Unless P = N P, there is no polynomial-time algorithm that approximates any of the job shop, flow shop or open shop problems within a factor of less than 5 4 .
Reference: [71] <author> M.A. Yakovleva. </author> <title> A problem on minimum transportation cost. In V.S. </title> <editor> Nemchinov, editor, </editor> <booktitle> Applications of Mathematics in Economic Research, </booktitle> <pages> pages 390-399. </pages> <address> Izdat. Social'no-Ekon. Lit., Moscow, </address> <year> 1959. </year>
Reference-contexts: When both the demands and capacities are uniform, we use the algorithm that iteratively computes shortest paths in the residual graph with nonnegative costs discovered independently by Ford and Fulkerson [17] and Yakovleva <ref> [71] </ref>. First, we consider the general concurrent flow problem. Lemma 2.4.29 For a commodity i, a minimum-cost flow with respect to ~ ` can be found in O (nm log (n 2 =m) log (nU )) time. <p> The number of commodities is O (n). The capacities in the minimum-cost flow problem are integer multiples of . We shall use algorithm ScalingConcurrent with a suitable choice of minimum-cost flow routine. We shall use the minimum-cost flow algorithm due to Ford and Fulkerson [17] and Yakovleva <ref> [71] </ref>, that repeatedly augments the flow along the shortest path in the residual graph, to solve these problems.
References-found: 71

