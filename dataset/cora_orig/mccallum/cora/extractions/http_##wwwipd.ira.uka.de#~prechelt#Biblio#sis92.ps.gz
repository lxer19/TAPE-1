URL: http://wwwipd.ira.uka.de/~prechelt/Biblio/sis92.ps.gz
Refering-URL: 
Root-URL: 
Email: (prechelt@ira.uka.de)  
Title: The SIS Project: Software Reuse with a Natural Language Approach  
Author: Lutz Prechelt 
Date: June 16, 1992  
Address: Postfach 6980 D-7500 Karlsruhe, Germany  
Affiliation: Institut fur Programmstrukturen und Datenorganisation Universitat Karlsruhe  
Pubnum: Technical Report 2/92  
Abstract: The SIS (Software Information System) project investigated a new approach to one part of the software reuse problem. The problem is how to find and use a reusable component from a repository. The approach is (1) to provide a knowledge representation system that allows for modeling the components in the repository with user-defined semantic categories, (2) to provide deductive capabilities in this knowledge representation system, to perform powerful retrieval operations, and (3) to complement the formal query facility with a natural language user interface in order to achieve ease of use and freedom from terminology constraints imposed by the names used in the knowledge base. In the SIS project, both the knowledge representation system YAKS and the natural language processing component SARA have been designed and built. We have developed a general approach for building transportable natural language interfaces for databases using KL-ONE-like knowledge representation languages. A prototype system called YAKR was built for which this approach was used to integrate YAKS and SARA. This report describes the philosophy, design, and implemen tation of YAKR, the first experiences we have gathered with it, and the limitations we expect. 
Abstract-found: 1
Intro-found: 1
Reference: <institution> z|4Tn:DxTNFTH.VrLB(J22tnbZ`p0Z*Vr@"tlPFRPB&6b2bR|Z V(&&x^b:h&`L(J8XZ*:N" NdpX(&lt; vnNZD.,FFfN F80&&gt;XXNJj? (From: DATAMATION, </institution> <month> April </month> <year> 1973, </year> <pages> pp 72-73, </pages> <note> by Donald Kenney) For full enjoyment, now start again and read carefully. References </note>
Reference: [1] <author> Rolf Adams. </author> <title> KRS | a hybrid system for representing knowledge in knowledge-based help systems. </title> <booktitle> In [21], </booktitle> <pages> pages 129-133, </pages> <year> 1991. </year>
Reference-contexts: Several appendices provide additional details. 2 The YAKS Knowledge Representation System The YAKS knowledge representation language (in a former version named KRS <ref> [1, 17] </ref>) has well defined model-theoretic semantics and distinguishes between assertional and terminological knowledge. The terminological knowledge defines a "vocabulary" to be used to express facts. The assertional knowledge 7 comprises facts about individuals in the application domain. The terminological knowledge consists of concept definitions and role definitions.
Reference: [2] <author> Rolf Adams. </author> <title> Wissensreprasentation und -akquisition in einem naturlichsprachlichen Software-Informationssystem. </title> <type> PhD thesis, </type> <institution> Institut fur Programmstrukturen und Datenorganisation, Universitat Karlsruhe, </institution> <month> November </month> <year> 1992. </year> <note> to appear. </note>
Reference-contexts: In YAKS, all limitations of the query language stem from limitations of the modeling language. For a detailed description of YAKS see <ref> [2] </ref>. 3 YAKS Knowledge Acquisition In principle, the knowledge acquisition process for YAKS has two main stages: First, define the terminology that will be used to describe the domain that is to be modeled.
Reference: [3] <author> Emmon Bach and Robert T. Harms, </author> <title> editors. Universals in Linguistic Theory. </title> <publisher> Holt, Rineheart, and Winston, Inc, </publisher> <address> London, </address> <month> Reprint </month> <year> 1972. </year>
Reference: [4] <author> Bruce Ballard. </author> <title> A lexical, syntactic, and semantic framework for a user-customized natural language question-answering system. </title> <editor> In Martha Evens, editor, </editor> <booktitle> Lexical-Semantic Relational Models, </booktitle> <pages> pages 211-236. </pages> <publisher> Cambridge University Press, </publisher> <year> 1988. </year>
Reference-contexts: Another integration of a natural language interface with a KL-ONE-like knowledge base has been done for the LaSSIE system and is described rather briefly in [15]. The natural language component is realized by customizing the natural language processor TELI <ref> [4] </ref>. The knowledge structures of TELI are similar to those used in SARA, but there is no inheritance hierarchy for the case frames. The integration does not work with general models and is restricted to frames describing actions.
Reference: [5] <author> M. Bates and R. Bobrow. </author> <title> Natural Language Interfaces: What's Here, What's Coming, and Who Needs It, </title> <booktitle> chapter 10, </booktitle> <pages> pages 179-194. </pages> <publisher> Ablex Publishing Company, </publisher> <year> 1984. </year>
Reference-contexts: The usefulness of the current implementation, however, is reduced, because the syntactic and semantic coverage of our system is quite limited. As pointed out in <ref> [5] </ref>, a limited natural language interface may still be useful as long as there is at least one way of expressing the thing wanted and the user can easily find that term or phrase.
Reference: [6] <author> Ted Biggerstaff and Charles Richter. </author> <title> Reusability framework, assessment, and directions. </title> <journal> IEEE Software, </journal> <volume> 4(2) </volume> <pages> 41-49, </pages> <month> March </month> <year> 1987. </year> <note> also in [36] and in [7]. </note>
Reference-contexts: These or similar hypotheses are supported by observations of many scientists in the area of software engineering (see for example <ref> [6, 29, 35, 40, 18, 22] </ref>), although especially A4 is often not addressed at all in papers about concrete software reuse support systems. 1.2 Requirements From these assumptions we derive one-to-one the following requirements as guidelines for the design of YAKR: R1: The system must allow successful querying with partial and
Reference: [7] <author> Ted J. Biggerstaff and Alan J. Perlis, </author> <title> editors. Software Reusability | Concepts and Models, Volume I. </title> <publisher> ACM Press Frontier Series. Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1989. </year>
Reference: [8] <author> R.J. Brachman and J.G. Schmolze. </author> <title> An overview of the KL-ONE knowledge representation system. </title> <journal> Cognitive Science, </journal> <volume> 9 </volume> <pages> 171-216, </pages> <year> 1985. </year>
Reference-contexts: The design of our system is outlined in the following subsection. 1.3 Basic Design 5 1.3 Basic Design R1 is realized with a specially designed knowledge representation language, YAKS (Yet Another Knowledge representation System 1 ), which has similarities to KL-ONE <ref> [8] </ref>. The constructs of the language are directly targeted to the description of software components and allow to define suitable terminology for software from any domain.
Reference: [9] <author> Finn Dag But. </author> <title> A natural language interface for KRS. </title> <type> Master's thesis, </type> <institution> Institut fur Programmstrukturen und Datenorganisation, Universitat Karlsruhe, D-7500 Karlsruhe, Germany, </institution> <year> 1991. </year>
Reference-contexts: It should be noticed that this example was not made for a real application but to show how YAKR works. It does thus not show a stringent modeling style. A detailed (although not completely up-to-date) description of the annotations and their semantics can be found in <ref> [9] </ref>. PRIM-CONCEPT Objects = anything. NOUN (komponente objekt). ROLES (has-synonym : strings; NOUN (name bezeichner identifizierer) ). PRIM-CONCEPT actions = anything. NOUN (aktion ereignis vorgang). ROLES (has-agent : Functions; AT-DOMAIN (agent) ). PRIM-CONCEPT Call-Actions = actions. VERB (rufen (rufen auf)) NOUN (aufruf aufrufen ruf rufen) PREFIX (aufruf). <p> A detailed description of this translation can be found in <ref> [9] </ref>. Generally speaking, the head of a case frame instantiation, as well as all of its fillers are considered restrictions. These restrictions are computed and combined into a query expression | in many cases simply by applying the AND operator to them.
Reference: [10] <author> J. Carbonell. </author> <title> Requirements for robust natural language interfaces: The Language Craft and XCALIBUR experiences. </title> <booktitle> In International Conference on Computational Linguistics, </booktitle> <pages> pages 162-163. </pages> <institution> Association for Computational Linguistics, </institution> <year> 1986. </year>
Reference-contexts: Case frame parsing provides a good starting point for building robust parsers and for handling dialogue phenomena such as ellipsis <ref> [10, 13, 11] </ref>, since least-error fitting of case frames can be used. The main disadvantage of case frame parsing is that complex syntactical constructions cannot be handled adequately.
Reference: [11] <author> J. Carbonell and P. Hayes. </author> <title> Coping with extragrammaticality. </title> <booktitle> In International Conference on Computational Linguistics, </booktitle> <pages> pages 437-443, </pages> <year> 1984. </year>
Reference-contexts: Case frame parsing provides a good starting point for building robust parsers and for handling dialogue phenomena such as ellipsis <ref> [10, 13, 11] </ref>, since least-error fitting of case frames can be used. The main disadvantage of case frame parsing is that complex syntactical constructions cannot be handled adequately.
Reference: [12] <author> J. Carbonell and P. Hayes. </author> <title> Natural-language understanding. </title> <editor> In S. Shapiro, editor, </editor> <booktitle> Encyclopedia of Artificial Intelligence, </booktitle> <volume> volume 1, </volume> <pages> pages 660-677. </pages> <publisher> John Wiley & Sons, </publisher> <year> 1987. </year>
Reference-contexts: For detailed information about this tool, see [34] 4 The SARA Natural Language Processor The effort to implement a sophisticated natural language processor is high. Therefore, we chose to implement a case frame parser <ref> [38, 12] </ref>, which is based on the notion of semantic case [16] and requires only moderate implementation effort compared to other parsing techniques, as for example unification-based parsing [33].
Reference: [13] <author> Jaime G. Carbonell and Philip J. Hayes. </author> <title> Robust parsing using multiple construction-specific strategies. </title> <booktitle> In Proceedings of the Seventh IJCAI, </booktitle> <pages> pages 432-439, </pages> <month> August </month> <year> 1981. </year>
Reference-contexts: Case frame parsing provides a good starting point for building robust parsers and for handling dialogue phenomena such as ellipsis <ref> [10, 13, 11] </ref>, since least-error fitting of case frames can be used. The main disadvantage of case frame parsing is that complex syntactical constructions cannot be handled adequately.
Reference: [14] <author> P. Devanbu, R.J. Brachman, P.G. Selfridge, and B.W. Ballard. </author> <title> LaSSIE: A knowledge-based software information system. </title> <journal> Communications of the ACM, </journal> <volume> 34(5) </volume> <pages> 34-49, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: A natural language query is also quicker to produce than a sixtuple can be built. 22 8 RELATED WORK The software information system that is most similar to ours is LaSSIE/CODE-BASE <ref> [14, 32] </ref>. LaSSIE originally used a frame based knowledge representation language called KANDOR, which was later replaced by a language called Classic. In LaSSIE all information in the knowledge base had to be handcoded.
Reference: [15] <author> P. Devanbu, P. Selfridge, B. Ballard, and R. Brachman. </author> <title> A knowledge based software information system. </title> <booktitle> In International Joint Conference on Artificial Intelligence, </booktitle> <pages> pages 110-115. </pages> <publisher> Morgan Kaufmann Publishers, </publisher> <year> 1989. </year>
Reference-contexts: The syntactic component is, like ours, rather restricted and does not cover anaphorical references and most conjunctions. Another integration of a natural language interface with a KL-ONE-like knowledge base has been done for the LaSSIE system and is described rather briefly in <ref> [15] </ref>. The natural language component is realized by customizing the natural language processor TELI [4]. The knowledge structures of TELI are similar to those used in SARA, but there is no inheritance hierarchy for the case frames.
Reference: [16] <author> Charles J. Fillmore. </author> <title> The case for case. In [3]. </title> <publisher> Holt, Rineheart, and Winston, Inc, </publisher> <year> 1968. </year> <note> REFERENCES 37 </note>
Reference-contexts: For detailed information about this tool, see [34] 4 The SARA Natural Language Processor The effort to implement a sophisticated natural language processor is high. Therefore, we chose to implement a case frame parser [38, 12], which is based on the notion of semantic case <ref> [16] </ref> and requires only moderate implementation effort compared to other parsing techniques, as for example unification-based parsing [33]. Case frame parsing provides a good starting point for building robust parsers and for handling dialogue phenomena such as ellipsis [10, 13, 11], since least-error fitting of case frames can be used.
Reference: [17] <author> Martin Fischer. </author> <title> Realisierung eines Wissensreprasentationssystems fur die Reprasentationssprache KRS. </title> <type> Master's thesis, </type> <institution> Universitat Karlsruhe, D-7500 Karlsruhe, </institution> <year> 1991. </year>
Reference-contexts: Several appendices provide additional details. 2 The YAKS Knowledge Representation System The YAKS knowledge representation language (in a former version named KRS <ref> [1, 17] </ref>) has well defined model-theoretic semantics and distinguishes between assertional and terminological knowledge. The terminological knowledge defines a "vocabulary" to be used to express facts. The assertional knowledge 7 comprises facts about individuals in the application domain. The terminological knowledge consists of concept definitions and role definitions.
Reference: [18] <author> G.W. Furnas, T.K. Landauer, L.M. Gomez, and S.T. Dumas. </author> <title> The vocabulary problem in human-system communication. </title> <journal> Communications of the ACM, </journal> <volume> 30(11) </volume> <pages> 964-971, </pages> <month> November </month> <year> 1987. </year>
Reference-contexts: These or similar hypotheses are supported by observations of many scientists in the area of software engineering (see for example <ref> [6, 29, 35, 40, 18, 22] </ref>), although especially A4 is often not addressed at all in papers about concrete software reuse support systems. 1.2 Requirements From these assumptions we derive one-to-one the following requirements as guidelines for the design of YAKR: R1: The system must allow successful querying with partial and
Reference: [19] <author> Keith E. Gorlen, Sanford M. Orlow, and Perry S. Plexico. </author> <title> Data Abstraction and Object-Oriented Programming in C ++ . Wiley, </title> <address> Chichester, </address> <year> 1991. </year>
Reference-contexts: of what a YAKS modelling may look like will be given below in section 5. 3.1 Our Experimental Modeling To learn about how modeling actually works and how good our system behaves on a medium-sized example, we have modeled a part of the internal view of the NIH Class Library <ref> [19] </ref>, which is written in C ++ . The most complicated part of this task was to model the constructs of the C ++ programming language. The resulting terminology contains about 160 concepts and 130 roles in 40 Kilobytes of YAKS source code.
Reference: [20] <author> B. Grosz, D. Appelt, P. Martin, and F. Pereira. </author> <title> TEAM: An experiment in the design of transportable natural language interfaces. </title> <journal> Artificial Intelligence, </journal> <volume> 32(1987) </volume> <pages> 173-243, </pages> <year> 1987. </year>
Reference-contexts: This section compares related approaches to this problem. TEAM <ref> [20] </ref> is probably the most sophisticated and well known transportable natural language interface. TEAM makes use of four knowledge sources: the augmented phrase structure grammar, the lexicon, the conceptual schema, and the database schema.
Reference: [21] <editor> IEEE Computer Society. </editor> <booktitle> The Seventh Conference on Artificial Intelligence Applications, </booktitle> <address> Miami Beach, Florida, February 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [22] <author> Michael Loren Mauldin. </author> <title> Information Retrieval by Text Skimming. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <year> 1987. </year> <note> also as Techreport CMU-CS-89-193. </note>
Reference-contexts: These or similar hypotheses are supported by observations of many scientists in the area of software engineering (see for example <ref> [6, 29, 35, 40, 18, 22] </ref>), although especially A4 is often not addressed at all in papers about concrete software reuse support systems. 1.2 Requirements From these assumptions we derive one-to-one the following requirements as guidelines for the design of YAKR: R1: The system must allow successful querying with partial and
Reference: [23] <author> Andy Podgurski and Lynn Pierce. </author> <title> Behavior sampling: A technique for automated retrieval of reusable components. </title> <booktitle> In Proceedings of the 14th International Conference on Software Engineering, </booktitle> <pages> pages 349-360, </pages> <month> May </month> <year> 1992. </year>
Reference-contexts: Many of them are not general: All approaches that rely on formal specifications in any way, e.g. [30], are completely impractical for interactive components, e.g. X Window System widgets, and are difficult to use. Others, e.g. <ref> [23] </ref>, require the user to specify the component "by example", which seems useful as an additional technique (if the user knows the functionality needed, but has no vocabulary to describe it), but most often places far too much workload on the user and is also impractical for components that cannot easily
Reference: [24] <author> Lutz Prechelt. </author> <title> Ein Fallschablonenzerteiler fur Deutsch. </title> <type> Master's thesis, </type> <institution> Institut fur Programmstrukturen und Datenorganisation, Universitat Karlsruhe, D-7500 Karlsruhe, Germany, </institution> <year> 1989. </year>
Reference-contexts: The main disadvantage of case frame parsing is that complex syntactical constructions cannot be handled adequately. However, the syntactic coverage of our case frame parser SARA <ref> [24] </ref>, which targets German, is quite broad compared to other parsers using this technology; it handles the following syntactic phenomena: Noun phrases with determiners, adjectives, adverbs, restricted numbering, and simple quantifiers; simple conjunctions and disjunctions of noun phrases; all types of sentences (Yes/no-questions, Wh-questions, declaratives, imperatives, infinitives, to-be-sentences, to-have-sentences) in all
Reference: [25] <author> R. Prieto-Diaz and P. Freeman. </author> <title> Classifying software for reusability. </title> <journal> IEEE Software, </journal> <volume> 4(1) </volume> <pages> 6-16, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: This section surveys some of the most important of them and compares them to the approach taken in YAKR. The probably most well-known work in representing and finding reusable software components is that of Prieto-Diaz <ref> [26, 25, 27, 28] </ref>. He proposes a so-called "faceted classification" of software components: To classify a component, from any one of a small set of predefined facets (aspects), exactly one of a set of predefined terms must be chosen.
Reference: [26] <author> Ruben Prieto-Diaz. </author> <title> A Software Classification Scheme. </title> <type> PhD thesis, </type> <institution> Department of Information and Computer Science, University of California, </institution> <address> Irvine, CA, </address> <year> 1985. </year>
Reference-contexts: This section surveys some of the most important of them and compares them to the approach taken in YAKR. The probably most well-known work in representing and finding reusable software components is that of Prieto-Diaz <ref> [26, 25, 27, 28] </ref>. He proposes a so-called "faceted classification" of software components: To classify a component, from any one of a small set of predefined facets (aspects), exactly one of a set of predefined terms must be chosen.
Reference: [27] <author> Ruben Prieto-Diaz. </author> <title> Classficiation of reusable modules. </title> <booktitle> In in [7], </booktitle> <pages> pages 99-123. </pages> <publisher> ACM press, </publisher> <year> 1987. </year>
Reference-contexts: This section surveys some of the most important of them and compares them to the approach taken in YAKR. The probably most well-known work in representing and finding reusable software components is that of Prieto-Diaz <ref> [26, 25, 27, 28] </ref>. He proposes a so-called "faceted classification" of software components: To classify a component, from any one of a small set of predefined facets (aspects), exactly one of a set of predefined terms must be chosen.
Reference: [28] <author> Ruben Prieto-Diaz. </author> <title> Implementing faceted classification for software reuse. </title> <journal> Communications of the ACM, </journal> <volume> 34(5) </volume> <pages> 89-97, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: This section surveys some of the most important of them and compares them to the approach taken in YAKR. The probably most well-known work in representing and finding reusable software components is that of Prieto-Diaz <ref> [26, 25, 27, 28] </ref>. He proposes a so-called "faceted classification" of software components: To classify a component, from any one of a small set of predefined facets (aspects), exactly one of a set of predefined terms must be chosen.
Reference: [29] <author> M. Ratcliffe. </author> <title> Report on a workshop on software reuse held at Hereford, UK, on 1-2 may, </title> <booktitle> 1986. ACM SIGSOFT Software Engineering Notes, </booktitle> <volume> 12(1) </volume> <pages> 42-47, </pages> <month> January </month> <year> 1987. </year> <note> also in [36]. </note>
Reference-contexts: These or similar hypotheses are supported by observations of many scientists in the area of software engineering (see for example <ref> [6, 29, 35, 40, 18, 22] </ref>), although especially A4 is often not addressed at all in papers about concrete software reuse support systems. 1.2 Requirements From these assumptions we derive one-to-one the following requirements as guidelines for the design of YAKR: R1: The system must allow successful querying with partial and
Reference: [30] <author> Eugene J. Rollins and Jeannette M. Wing. </author> <title> Specifications as search keys for software libraries. </title> <booktitle> In Proceedings of the International Conference on Logic Programming, </booktitle> <address> Paris, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Most of them are more or less lacking the capability to handle requests of a user, who has only an incomplete and fuzzy specification of the needed component at hand. Many of them are not general: All approaches that rely on formal specifications in any way, e.g. <ref> [30] </ref>, are completely impractical for interactive components, e.g. X Window System widgets, and are difficult to use.
Reference: [31] <author> R.C. Schank. </author> <title> Conceptual Dependency: A theory of natural language understanding. </title> <journal> Cognitive Psychology, </journal> <pages> pages 552-631, </pages> <year> 1972. </year>
Reference-contexts: For a short discussion of the LaSSIE natural language interface, see the next section. A simpler variant of this approach is represented by the work of Wook and Sommerville [39]. They use conceptual dependency theory <ref> [31] </ref> (a canonicalized variant of case frames) to represent the components. After the user has given a keyword for the main action of the needed component, the system presents a template of the corresponding conceptual dependency frame, which is then interactively filled by the user and used for component retrieval.
Reference: [32] <author> Peter G. Selfridge. </author> <title> Knowledge representation support for a software information system. </title> <booktitle> In [21], </booktitle> <pages> pages 134-140, </pages> <year> 1991. </year>
Reference-contexts: A natural language query is also quicker to produce than a sixtuple can be built. 22 8 RELATED WORK The software information system that is most similar to ours is LaSSIE/CODE-BASE <ref> [14, 32] </ref>. LaSSIE originally used a frame based knowledge representation language called KANDOR, which was later replaced by a language called Classic. In LaSSIE all information in the knowledge base had to be handcoded.
Reference: [33] <author> S. Shieber, </author> <title> editor. An Introduction to Unification-Based Approaches to Grammar. </title> <booktitle> CSLI Lecture Notes 4. </booktitle> <publisher> Chicago University Press, </publisher> <year> 1986. </year>
Reference-contexts: Therefore, we chose to implement a case frame parser [38, 12], which is based on the notion of semantic case [16] and requires only moderate implementation effort compared to other parsing techniques, as for example unification-based parsing <ref> [33] </ref>. Case frame parsing provides a good starting point for building robust parsers and for handling dialogue phenomena such as ellipsis [10, 13, 11], since least-error fitting of case frames can be used. The main disadvantage of case frame parsing is that complex syntactical constructions cannot be handled adequately.
Reference: [34] <author> Tore Syvertsen. </author> <title> CPPREF | an information abstractor for C ++ . Master's thesis, </title> <institution> Institut fur Programm-strukturen und Datenorganisation, Universitat Karlsruhe, D-7500 Karlsruhe, Germany, </institution> <month> April </month> <year> 1992. </year>
Reference-contexts: These roles are only partially computed by CPPREF itself, most of them are deduced from others by YAKS. For detailed information about this tool, see <ref> [34] </ref> 4 The SARA Natural Language Processor The effort to implement a sophisticated natural language processor is high.
Reference: [35] <author> Will Tracz. </author> <title> Software reuse: </title> <booktitle> Motivators and inhibitors. In Proceedings of COMPCON S'87, </booktitle> <pages> pages 358-363. </pages> <publisher> IEEE, IEEE Computer Society Press, </publisher> <month> February </month> <year> 1987. </year> <note> also in [36]. </note>
Reference-contexts: These or similar hypotheses are supported by observations of many scientists in the area of software engineering (see for example <ref> [6, 29, 35, 40, 18, 22] </ref>), although especially A4 is often not addressed at all in papers about concrete software reuse support systems. 1.2 Requirements From these assumptions we derive one-to-one the following requirements as guidelines for the design of YAKR: R1: The system must allow successful querying with partial and
Reference: [36] <author> Will Tracz, </author> <title> editor. Software Reuse: Emerging Technology. Tutorial. </title> <publisher> IEEE Computer Society Press, </publisher> <address> Wa-shington, D.C., </address> <year> 1988. </year>
Reference: [37] <author> D. Warren and F. Pereira. </author> <title> An efficient easily adaptable system for interpreting natural language queries. </title> <journal> American Journal of Computational Linguistics, </journal> <volume> 8(3-4):110-122, </volume> <month> July-December </month> <year> 1982. </year>
Reference-contexts: We also do not handle the problems that these syntactic constructions entail in semantic processing, such as scope determination. Furthermore, our system does not support measurement units and does not have special mechanisms for handling relations or cases related to time or location. Chat-80 <ref> [37] </ref> is an efficient, transportable system for Prolog knowledge bases. The system is imple mented in Prolog itself. The lexicon and the case information are specified with Prolog clauses. This specification is tedious compared to our mechanism. As in TEAM, extra type information must be specified.
Reference: [38] <author> Patrick Henry Winston. </author> <booktitle> Artificial Intelligence. </booktitle> <publisher> Addison Wesley, </publisher> <year> 1981. </year>
Reference-contexts: For detailed information about this tool, see [34] 4 The SARA Natural Language Processor The effort to implement a sophisticated natural language processor is high. Therefore, we chose to implement a case frame parser <ref> [38, 12] </ref>, which is based on the notion of semantic case [16] and requires only moderate implementation effort compared to other parsing techniques, as for example unification-based parsing [33].
Reference: [39] <author> Murray Wood and Ian Sommerville. </author> <title> An information retrieval system for software components. </title> <journal> Software Engineering Journal, </journal> <pages> pages 198-212, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: For a short discussion of the LaSSIE natural language interface, see the next section. A simpler variant of this approach is represented by the work of Wook and Sommerville <ref> [39] </ref>. They use conceptual dependency theory [31] (a canonicalized variant of case frames) to represent the components.
Reference: [40] <author> Scott N. Woodfield, David W. Embley, and Del T. Scott. </author> <title> Can programmers reuse software. </title> <journal> IEEE Software, </journal> <volume> 4(4) </volume> <pages> 52-59, </pages> <month> July </month> <year> 1987. </year> <note> also in [36]. </note>
Reference-contexts: These or similar hypotheses are supported by observations of many scientists in the area of software engineering (see for example <ref> [6, 29, 35, 40, 18, 22] </ref>), although especially A4 is often not addressed at all in papers about concrete software reuse support systems. 1.2 Requirements From these assumptions we derive one-to-one the following requirements as guidelines for the design of YAKR: R1: The system must allow successful querying with partial and
References-found: 41

