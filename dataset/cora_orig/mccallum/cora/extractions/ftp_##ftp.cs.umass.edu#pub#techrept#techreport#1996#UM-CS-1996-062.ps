URL: ftp://ftp.cs.umass.edu/pub/techrept/techreport/1996/UM-CS-1996-062.ps
Refering-URL: http://laser.cs.umass.edu/abstracts/96-062.html
Root-URL: 
Title: Analyzing Partially-Implemented Real-Time Systems  
Author: George S. Avrunin James C. Corbett Laura K. Dillon 
Keyword: Real-time, concurrency, static analysis, Ada, temporal logic, hybrid systems, Graphical Interval Logic  
Address: Amherst, MA 01003  Honolulu, HI 96822  Santa Barbara, CA 93106  
Affiliation: Department of Computer Science University of Massachusetts  Department of Information and Computer Science University of Hawai`i  Computer Science Department University of California  
Abstract: Technical Report 96-62 August 9, 1996 Abstract We propose a method for analyzing partially-implemented real-time systems. Here we consider real-time concurrent systems for which some components are implemented in Ada and some are partially specified using regular expressions and Graphical Interval Logic (GIL), a real-time temporal logic. We show how to construct models of the partially-implemented systems that account for such properties as run-time overhead and scheduling of processes, yet support tractable analysis of nontrivial programs. The approach can be fully automated, and we illustrate it by analyzing a small example. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur, C. Courcoubetis, N. Halbwachs, T. Henzinger, P. Ho, X. Nicollin, A. Olivero, J. Sifakis, and S. Yovine. </author> <title> The algorithmic analysis of hybrid systems. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 138:334, </address> <year> 1995. </year>
Reference-contexts: We express this constraint with the GIL formula IntFreq in Figure 4. Hybrid Automata In order to perform analysis, we translate the various specifications of the program into a common abstract model: constant slope linear hybrid automata <ref> [1, 2] </ref>. Hybrid automata 5 IntFreq: combine a finite-state control with a set of real-valued variables. The values of these variables change continuously while the automaton remains at a control location, and may change discretely with an instantaneous transition from one control location to another. <p> To filter out these spurious locations, we convert the regular expression constraining the order of the stub task interactions which was given earlier into an automaton and intersect this automaton with the automaton in Figure 5. (Intersection is performed using the standard product operator for hybrid automata <ref> [1] </ref> in which transitions sharing the same event label must be taken together.) The resulting intersection eliminates the transitions on Ready from locations 1 and 3. <p> 2 ]) [60; 120] Process slow data ([L 3 ; U 3 ]) [1000; 1500] Process fast data (with cache) ([L 4 ; U 4 ]) [200; 400] Process fast data (without cache) ([L 5 ; U 5 ]) [400; 600] Table 1: Durations Used in Example (microseconds) tion; see <ref> [1] </ref> for details). The property automaton M P does not constrain the behavior of M S ; it simply observes the behavior (via synchronizing transitions) and accepts violations of P .
Reference: [2] <author> R. Alur, T. A. Henzinger, and P.-H. Ho. </author> <title> Automatic symbolic verification of embedded systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 22(3):181201, </volume> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: We express this constraint with the GIL formula IntFreq in Figure 4. Hybrid Automata In order to perform analysis, we translate the various specifications of the program into a common abstract model: constant slope linear hybrid automata <ref> [1, 2] </ref>. Hybrid automata 5 IntFreq: combine a finite-state control with a set of real-valued variables. The values of these variables change continuously while the automaton remains at a control location, and may change discretely with an instantaneous transition from one control location to another.
Reference: [3] <author> R. L. Bagrodia and C.-C. Shen. </author> <title> MIDAS: Integrated design and simulation of distributed systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(10):10421058, </volume> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: Perhaps the work closest in spirit to this paper is that of Bagrodia and Shen <ref> [3, 20] </ref>. They do stochastic performance evaluation of real-time systems in which some components are fully implemented and others are represented by discrete-event simulation models.
Reference: [4] <author> S. C. Cheung and J. Kramer. </author> <title> Enhancing compositional reachability analysis with context constraints. </title> <editor> In D. Notkin, editor, </editor> <booktitle> Proceedings of the First ACM SIG-SOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 115125, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Corbett [68] has developed models for concurrent Ada programs that represent these detailed timing properties. A number of authors (e.g., <ref> [4, 5, 22] </ref>) have proposed methods for doing compositional analysis by decomposing a concurrent system into subsystems with simple interfaces and replacing some of the subsystems by simpler processes that have the same interfaces to their environments.
Reference: [5] <author> E. Clarke, D. Long, and K. McMillan. </author> <title> Compositional model checking. </title> <booktitle> In Proceedings of the Fourth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 353362, </pages> <year> 1989. </year>
Reference-contexts: Corbett [68] has developed models for concurrent Ada programs that represent these detailed timing properties. A number of authors (e.g., <ref> [4, 5, 22] </ref>) have proposed methods for doing compositional analysis by decomposing a concurrent system into subsystems with simple interfaces and replacing some of the subsystems by simpler processes that have the same interfaces to their environments.
Reference: [6] <author> J. C. Corbett. </author> <title> Modeling and analysis of real-time Ada tasking programs. </title> <booktitle> In Proceedings Real-Time Systems Symposium, </booktitle> <pages> pages 132141, </pages> <address> San Juan, Puerto Rico, Dec. 1994. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference: [7] <author> J. C. Corbett. </author> <title> Constructing abstract models of concurrent real-time software. </title> <editor> In S. J. Zeil, editor, </editor> <booktitle> Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 250260, </pages> <address> San Diego, Jan. 1996. </address> <publisher> ACM Press. </publisher>
Reference: [8] <author> J. C. Corbett. </author> <title> Timing analysis of Ada tasking programs. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 22(7), </volume> <month> July </month> <year> 1996. </year>
Reference-contexts: We show how automata derived from the regular expressions and the GIL specifications [11] can be combined with hybrid automata constructed from the Ada code <ref> [8] </ref> to construct models of the partially-implemented systems that account for such properties as run-time overhead and scheduling, yet support tractable analysis of nontrivial programs. Our method can be fully automated. We illustrate the approach with analysis of a small example. <p> We use the real-valued variables of the hybrid automaton to enforce timing constraints on its transitions. We first construct a hybrid automaton representing the program using the method of <ref> [8] </ref>. Each control location in this automaton is an abstraction of the program's state, and each transition represents the execution of a code region transforming that state. <p> Note that the implementation of the rendezvous mechanism and the priority scheduling of the tasks on a single CPU produces a fairly complex behavior. In the analyses described above, we used the model building tool for Ada described in <ref> [8] </ref> to construct the hybrid automaton representing the program from an Ada-like specification 5 of the code in Figure 2. <p> DETAILS The approach presented here combines two separate bodies of work: Corbett's method for constructing timed models of 5 Our specification language contains (a subset of) Ada's constructs, but in a Lisp-like syntax to facilitate parsing. For example, we write (call T E) rather than T.E. Ada tasking programs <ref> [8] </ref> and Dillon et al.'s method for using Graphical Interval Logic to construct test oracles [10,11]. Although space limitations preclude presentation of the complete details of our approach, in this section we sketch the modifications and extensions that were necessary to combine the two methods. <p> A full presentation of our approach is in preparation and will be published separately. Ada to Hybrid Automata In order to construct models of partially implemented programs, we modified the translation of Ada to hybrid automata described in <ref> [8] </ref> to allow stub tasks. A stub task is given by the communication statements it contains.
Reference: [9] <author> L. K. Dillon, G. Kutty, L. E. Moser, P. M. Melliar-Smith, and Y. S. Ramakrishna. </author> <title> A graphical interval logic for specifying concurrent systems. </title> <journal> ACM Trans. Softw. Eng. Meth., </journal> <volume> 3(2):131165, </volume> <month> Apr. </month> <year> 1994. </year>
Reference-contexts: In this paper, we propose a method for analyzing partially-implemented real-time systems. We consider real-time concurrent systems for which some components are implemented in Ada and some are partially specified using regular expressions and Graphical Interval Logic (GIL) <ref> [9] </ref>, a real-time temporal logic with an intuitive graphical representation 1 similar to the time-lines typically used by system develop-ers.
Reference: [10] <author> L. K. Dillon and Y. S. Ramakrishna. </author> <title> Generating oracles from your favorite temporal logic specifications. </title> <booktitle> In Proceedings of the Fourth ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <month> Oct. </month> <year> 1996. </year> <note> To appear. 10 </note>
Reference-contexts: composition reachable from the initial state (the reachable states of a hybrid automaton are computed using a fixpoint calcula 7 Duration/Delay Range/Value ReadSensor [100; 200] ReadingExpire 1500 Update Display [75; 100] Code to queue/pend call in caller (before blocking) [60; 80] Code to complete call in caller (after being signaled) <ref> [10; 20] </ref> Code to begin rendezvous in acceptor (before body) [25; 50] Code to complete rendezvous in acceptor (after body) [25; 50] Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Cache life (K) 2500 Max Sensor Frequency (F ) 2000 <p> Such a project would certainly involve some significant challenges (though the work of Dillon and Ramakrishna <ref> [10] </ref> might simplify the generation of automata from temporal logic specifications), but there is nothing in our basic approach that limits its applicability to Ada and GIL. We have illustrated our method by analyzing a small, but nontrivial, example.
Reference: [11] <author> L. K. Dillon and Q. Yu. </author> <title> Oracles for checking temporal properties of concurrent systems. </title> <editor> In D. Wile, editor, </editor> <booktitle> Proceedings of the Second ACM SIGSOFT Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 140 153, </pages> <address> New Orleans, </address> <month> Dec. </month> <year> 1994. </year> <note> ACM Press (Proceedings appeared in Software Engineering Notes, 19(5)). </note>
Reference-contexts: We show how automata derived from the regular expressions and the GIL specifications <ref> [11] </ref> can be combined with hybrid automata constructed from the Ada code [8] to construct models of the partially-implemented systems that account for such properties as run-time overhead and scheduling, yet support tractable analysis of nontrivial programs. Our method can be fully automated. <p> These include timed Petri nets, communicating finite state machines, timed automata, timed process algebras, and real-time logics. In this paper, we rely on algorithms for converting GIL specifications into automata that were originally developed for producing oracles to monitor executions of concurrent systems <ref> [11] </ref>. We believe that GIL's graphical representation, discussed and illustrated below, makes it especially suitable as a high-level specification formalism for use by developers of real-time systems. For the most part, the work on formal models of real-time concurrent systems has been intended to represent specifications, not implementations. <p> The automata for the GIL formulas are constructed by hand using an extension of the algorithm in <ref> [11] </ref>. These automata are fed to HyTech, which takes their product and computes the set of reachable states. The performance of HyTech (version 1.02b) on the analyses described above is given in Table 2. <p> The durations associated with states indicate the amount of time that elapses between event occurrences. Hybrid automata are produced from GIL formulas by a tableau procedure like that described in <ref> [11] </ref>, but extended to handle duration predicates and bi-directional searches.
Reference: [12] <author> M. G. Harbour, M. H. Klein, and J. P. Lehoczky. </author> <title> Timing analysis for fixed-priority scheduling of hard real-time systems. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 20(1):1328, </volume> <year> 1994. </year>
Reference-contexts: These restrictions allow the use of special scheduling techniques and algorithms, such as rate monotonic scheduling [14], to guarantee that a system's timing requirements are satisfied <ref> [12, 19] </ref>. In fact, there are many situations in which developers would benefit from tools that could analyze partially-implemented systems, those for which some components are given only as high-level specifications while others are fully implemented in a programming language.
Reference: [13] <author> T. A. Henzinger, P.-H. Ho, and H. Wong-Toi. HyTech: </author> <title> the next generation. </title> <booktitle> In Proceedings of the Real-Time Systems Symposium, </booktitle> <pages> pages 5665. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1995. </year>
Reference-contexts: The system designer would specify the property P with a GIL formula, which is then negated and converted into a hybrid automaton. We use the HyTech verifier for hybrid systems <ref> [13] </ref> to analyze the hybrid automata we construct. We illustrate our technique by verifying several properties of our example. First, we verify that the Sensor task will never time out waiting to deliver the data to the Control task.
Reference: [14] <author> C. L. Liu and J. W. Layland. </author> <title> Scheduling algorithms for multiprogramming in a hard-real-time environment. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 20(1):4661, </volume> <year> 1973. </year>
Reference-contexts: In practice, developers of real-time systems typically restrict the architectures of their systems so that system components are highly structured and interact in very limited ways (e.g., periodic tasks with precedence constraints). These restrictions allow the use of special scheduling techniques and algorithms, such as rate monotonic scheduling <ref> [14] </ref>, to guarantee that a system's timing requirements are satisfied [12, 19]. In fact, there are many situations in which developers would benefit from tools that could analyze partially-implemented systems, those for which some components are given only as high-level specifications while others are fully implemented in a programming language.
Reference: [15] <author> Z. Manna and A. Pnueli. </author> <title> Temporal Verification of Reactive Systems: Safety. </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1995. </year>
Reference-contexts: A tableau procedure for a propositional temporal logic depends on semantic rules that reduce a formula to be verified into one or more alternatives, where each alternative pairs a propositional formula with a formula that must hold at the next state in the state sequence <ref> [15, 21] </ref>. To handle duration predicates, semantic rules must also describe clock activities. The semantic rules for full GIL therefore produce alternatives that contain various non-logical terms, which signify that a transition activates a new timer, checks an active timer, and/or deactivates a timer.
Reference: [16] <author> C. Y. Park and A. C. Shaw. </author> <title> Experiments with a program timing tool based on source-level timing schema. </title> <booktitle> IEEE Computer, </booktitle> <pages> pages 4857, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: The time bounds of the code regions are specified using special computation events embedded in this specification; in a real timing analysis tool, these durations would be derived from the sequential code comprising these regions using techniques like <ref> [16] </ref>. The automata for the GIL formulas are constructed by hand using an extension of the algorithm in [11]. These automata are fed to HyTech, which takes their product and computes the set of reachable states.
Reference: [17] <author> M. Pezze. </author> <title> A formal approach to the development of high integrity programmable electronic systems. High Integrity Systems, </title> <note> 1996. To appear. </note>
Reference-contexts: The work on Cabernet <ref> [17] </ref> involves the construction of an environment for the specification and analysis of real-time systems that uses a class of high-level Petri nets as the formal kernel but provides features for customization that could support specifications written in a variety of other formalisms.
Reference: [18] <author> M. Pezze and M. Young. </author> <title> Generation of multi-formalism state-space analysis tools. </title> <editor> In S. J. Zeil, editor, </editor> <booktitle> Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 172 179, </pages> <address> San Diego, Jan. 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: For example, Zave and Jackson [23] discuss the integration of different specification formalisms by translating each formalism into predicate logic. This work does not address the problem of analyzing the systems so specified. Pezze and Young <ref> [18] </ref> present an approach to building state-space analysis tools that accept system descriptions involving several formalisms, but that work is chiefly concerned with the generation of tools rather than analysis of systems described in specific notations and does not discuss the representation of real-time systems.
Reference: [19] <author> L. Sha and J. B. Goodenough. </author> <title> Real-time scheduling theory and Ada. </title> <journal> IEEE Computer, </journal> <volume> 23:5362, </volume> <month> April </month> <year> 1990. </year>
Reference-contexts: These restrictions allow the use of special scheduling techniques and algorithms, such as rate monotonic scheduling [14], to guarantee that a system's timing requirements are satisfied <ref> [12, 19] </ref>. In fact, there are many situations in which developers would benefit from tools that could analyze partially-implemented systems, those for which some components are given only as high-level specifications while others are fully implemented in a programming language.
Reference: [20] <author> C.-C. Shen and R. L. Bagrodia. </author> <title> Parallel hybrid models in system design. </title> <editor> In G. W. Evens, M. Mollaghasemi, E. C. Russell, and W. E. Biles, editors, </editor> <booktitle> Proceedings of the Winter Simulation ConferenceWSC '93, </booktitle> <pages> pages 589594, </pages> <month> Dec. </month> <year> 1993. </year>
Reference-contexts: Perhaps the work closest in spirit to this paper is that of Bagrodia and Shen <ref> [3, 20] </ref>. They do stochastic performance evaluation of real-time systems in which some components are fully implemented and others are represented by discrete-event simulation models. <p> composition reachable from the initial state (the reachable states of a hybrid automaton are computed using a fixpoint calcula 7 Duration/Delay Range/Value ReadSensor [100; 200] ReadingExpire 1500 Update Display [75; 100] Code to queue/pend call in caller (before blocking) [60; 80] Code to complete call in caller (after being signaled) <ref> [10; 20] </ref> Code to begin rendezvous in acceptor (before body) [25; 50] Code to complete rendezvous in acceptor (after body) [25; 50] Code to set timer request [25; 50] Code to process timer expiration [25; 50] Timer interrupt period () 100 Cache life (K) 2500 Max Sensor Frequency (F ) 2000
Reference: [21] <author> P. Wolper. </author> <title> The tableau method for temporal logic: An overview. </title> <journal> In Logique et Analyse, </journal> <volume> volume 110111, </volume> <pages> pages 119136, </pages> <month> JuneSeptember </month> <year> 1985. </year>
Reference-contexts: A tableau procedure for a propositional temporal logic depends on semantic rules that reduce a formula to be verified into one or more alternatives, where each alternative pairs a propositional formula with a formula that must hold at the next state in the state sequence <ref> [15, 21] </ref>. To handle duration predicates, semantic rules must also describe clock activities. The semantic rules for full GIL therefore produce alternatives that contain various non-logical terms, which signify that a transition activates a new timer, checks an active timer, and/or deactivates a timer.
Reference: [22] <author> W. J. Yeh and M. Young. </author> <title> Compositional reachabil-ity analysis using process algebra. </title> <booktitle> In Proceedings of the Symposium on Testing, Analysis, and Verification (TAV4), </booktitle> <pages> pages 178187, </pages> <address> New York, </address> <month> Oct. </month> <year> 1991. </year> <institution> ACM SIGSOFT, Association for Computing Machinery. </institution>
Reference-contexts: Corbett [68] has developed models for concurrent Ada programs that represent these detailed timing properties. A number of authors (e.g., <ref> [4, 5, 22] </ref>) have proposed methods for doing compositional analysis by decomposing a concurrent system into subsystems with simple interfaces and replacing some of the subsystems by simpler processes that have the same interfaces to their environments.
Reference: [23] <author> P. Zave and M. Jackson. </author> <title> Conjunction as composition. </title> <journal> ACM Trans. Softw. Eng. Meth., </journal> <volume> 2(4):379411, </volume> <year> 1993. </year> <month> 11 </month>
Reference-contexts: The approach we propose here composes systems whose components are described in two very different notations, a graphical interval logic and the Ada programming language. Several researchers have considered the problem of integrating different types of notations for representing the components of a system. For example, Zave and Jackson <ref> [23] </ref> discuss the integration of different specification formalisms by translating each formalism into predicate logic. This work does not address the problem of analyzing the systems so specified.
References-found: 23

