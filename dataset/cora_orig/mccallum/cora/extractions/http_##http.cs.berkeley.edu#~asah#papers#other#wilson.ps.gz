URL: http://http.cs.berkeley.edu/~asah/papers/other/wilson.ps.gz
Refering-URL: http://http.cs.berkeley.edu/~asah/papers/other/
Root-URL: http://www.cs.berkeley.edu
Email: wilson,johnston@cs.utexas.edu  
Title: Real-Time Non-Copying Garbage Collection Real-time garbage collection is not popular, despite its obvious attractiveness for
Author: Paul R. Wilson and Mark S. Johnstone 
Note: Position paper for the 1993 ACM OOPSLA Workshop  2 Real  Baker's incremental copying technique is the  though any  
Date: 1 Overview  
Address: Austin  
Affiliation: Department of Computer Sciences University of Texas at  
Abstract: We have developed a hard real-time garbage collector for C++ which uses a write barrier, only coordinating collection work with modifications of pointers in data structures, making coordination costs cheaper and more predictable. We combine this write barrier approach with implicit non-copying reclamation, which has most of the advantages of copying collection (notably the avoidance of the sweep phase required by mark-sweep collectors, and and the touching of garbage objects when reclaiming their space). Because a non-copying collector cannot compact live data, fragmentation is a potential problem in our system. We believe that the problem is not as severe as it appears at first glance, however, and that for most programs, usable worst-case space bounds can be ensured. For other programs, it may also be feasible to rely on an occasional compacting collection with some degradation of real-time guarantees. This implementation strategy is well suited to stock hardware and operating systems. Because the write barrier records the same information as the write barrier for a generational scheme, our collector can easily be made generational to provide excellent average-case efficiency while preserving hard real-time response. We also believe that our collector is easier to parallelize than copying collectors. Real-time garbage collection must be incremental; that is, it must be possible to perform small units of garbage collection work while an application is executing, rather than halting the application and performing large amounts of work without interruption. Strict bounds on individual garbage collection pauses are often used as the criterion for real-time garbage collection, but for practical applications, the requirements are often stricter still. The application must be able to make significant progress. That is, for a garbage collector to be usefully real-time not only must the pauses be short and bounded, they must not occur too often. The garbage collector must be able to guarantee not only that every garbage collection pause is bounded, but that for any given increment of computation, a minimum amount of the CPU is always available for the running application. 
Abstract-found: 1
Intro-found: 1
Reference: [AEL88] <author> Andrew W. Appel, John R. Ellis, and Kai Li. </author> <title> Real-time concurrent garbage collection on stock multiprocessors. </title> <booktitle> In Proceedings of the 1988 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 11-20, </pages> <address> Atlanta, Georgia, June 1988. </address> <publisher> ACM Press. </publisher>
Reference-contexts: This problem is even worse in recent collectors which use pagewise virtual memory protections to trigger larger increments of collector work <ref> [AEL88, Det90, Joh92] </ref>, but it is also significant on Lisp-machine style hardware. Even if the necessary checks are performed by dedicated parallel hardware, most of the available CPU time may be used up (in the worst case) by the actual trapping to copying routines and the copying itself.
Reference: [AP87] <author> S. Abraham and J. Patel. </author> <title> Parallel garbage collection on a virtual memory system. </title> <editor> In E. Chiricozzi and A. D'Amato, editors, </editor> <booktitle> International Conference on Parallel Processing and Applications, </booktitle> <pages> pages 243-246, </pages> <address> L'Aquila, Italy, September 1987. </address> <publisher> Elsevier North-Holland. </publisher>
Reference-contexts: Since the application can still reach the white object through the black object's pointer, this creates a dangling pointer. To prevent this, two basic strategies are possible [Wil92]. One strategy, snapshot-at-beginning, is to ensure that objects can never get lost, by preventing any pointers from being destroyed <ref> [AP87, Yua90] </ref>. Before overwriting a pointer, the old pointer value is saved away so that the collector can still find it. We call this a snapshot-at-beginning algorithm because the collector's view of reachable data structures is fixed when collection begins.
Reference: [Bak91] <author> Henry G. Baker, Jr. </author> <title> The Treadmill: Real-time garbage collection without motion sickness. Position paper for OOPSLA '91 Workshop on Garbage Collection in Object-Oriented Systems. </title> <note> Summary appears in [?], October 1991. Also appears as SIGPLAN Notices 27(3) 66-70, </note> <month> March </month> <year> 1992. </year>
Reference-contexts: garbage collection, which we will discuss later. 4 Nonmoving Implicit Recla mation We have combined an incremental update write barrier with a generalization of Baker's non-copying implicit reclamation strategy, so that unreached objects needn't be traversed to be reclaimed, as they are in the sweep phase of a mark-sweep collector <ref> [Bak91] </ref>. 3 A copying collector copies the live data out of a region of memory, 3 It appears that this same basic strategy was used in a non-incremental collector for C++ by Thomas Wang, and is described in a Masters Thesis from California Polytechnic at San Luis Obispo; we have not
Reference: [BDS91] <author> Hans-J. Boehm, Alan J. Demers, and Scott Shenker. </author> <title> Mostly parallel garbage collection. </title> <booktitle> In Proceedings of the 1991 SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 157-164, </pages> <address> Toronto, On-tario, </address> <month> June </month> <year> 1991. </year> <note> ACM Press. Published as SIGPLAN Notices 26(6), </note> <month> June </month> <year> 1992. </year>
Reference-contexts: When such a pointer is created, the collector is notified so that it can either trace the pointed-to object immediately, or re-examine the stored-into location again later, to find any "hidden" objects <ref> [Ste75, DLM + 78, BDS91] </ref>. That is, the collector's view of reachable data structures is incrementally updated in the face of changes to those data structures by the running program.
Reference: [Boe93] <author> Hans-Juergen Boehm. </author> <title> Space-efficient conservative garbage collection. </title> <booktitle> In SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <year> 1993. </year> <title> To appear. 9 Because it is a non-copying collector, however, it can operate fairly efficiently with a lesser degree of cooperation, by using conservative pointer finding within stack frames [BW88, </title> <journal> Boe93]. </journal> <volume> 7 </volume>
Reference: [BW88] <author> Hans-Juergen Boehm and Mark Weiser. </author> <title> Garbage collection in an uncooperative environment. </title> <journal> Software Practice and Experience, </journal> <volume> 18(9) </volume> <pages> 807-820, </pages> <month> September </month> <year> 1988. </year>
Reference: [DB76] <author> L. Peter Deutsch and Daniel G. Bo-brow. </author> <title> An efficient, incremental, automatic garbage collector. </title> <journal> Communications of the ACM, </journal> <volume> 19(9) </volume> <pages> 522-526, </pages> <month> September </month> <year> 1976. </year>
Reference-contexts: Unlike deferred reference counting <ref> [DB76] </ref>, our collection scheme can reclaim cyclic garbage. Unlike Baker's read-barrier algorithms (and also unlike coarse-grained algorithms relying on virtual memory cooperation), it provides reasonable hard real-time guarantees. A generational version of our hard real-time collector should be competitive with existing state-of-the-art generational collectors in terms of raw performance.
Reference: [Det90] <author> David L. Detlefs. </author> <title> Concurrent garbage collection for C++. </title> <type> Technical Report CMU-CS-90-119, </type> <institution> Carnegie-Mellon University, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: This problem is even worse in recent collectors which use pagewise virtual memory protections to trigger larger increments of collector work <ref> [AEL88, Det90, Joh92] </ref>, but it is also significant on Lisp-machine style hardware. Even if the necessary checks are performed by dedicated parallel hardware, most of the available CPU time may be used up (in the worst case) by the actual trapping to copying routines and the copying itself.
Reference: [Det92] <author> David L. Detlefs. </author> <title> Garbage collection and runtime typing as a C++ library. </title> <booktitle> In USENIX C++ Conference [USE92]. </booktitle>
Reference-contexts: relatively efficient, and most of the current cost (typically increasing run time by 10 to 90 percent) appears to be due to the lack of compiler cooperation rather than a flaw in the collector itself. 8 It already outperforms a deferred reference counting collector with a similar smart-pointer language interface <ref> [Det92] </ref>; we expect tuning to improve its performance considerably in the near future, and we will further improve it by making it generational and exploiting compiler cooperation. Unlike deferred reference counting [DB76], our collection scheme can reclaim cyclic garbage.
Reference: [DLM + 78] <author> Edsger W. Dijkstra, Leslie Lamport, A. J. Martin, C. S. Scholten, and E. F. M. Steffens. </author> <title> On-the-fly garbage collection: An exercise in cooperation. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 966-975, </pages> <month> November </month> <year> 1978. </year>
Reference-contexts: This problem is best understood via the abstraction of tricolor marking <ref> [DLM + 78] </ref>. At the begin 2 ning of a garbage collection cycle, we consider all objects to be white. When the traversal reaches an object, it is colored grey. When a grey object's pointer fields are scanned and their referents are greyed, it is colored black. <p> When such a pointer is created, the collector is notified so that it can either trace the pointed-to object immediately, or re-examine the stored-into location again later, to find any "hidden" objects <ref> [Ste75, DLM + 78, BDS91] </ref>. That is, the collector's view of reachable data structures is incrementally updated in the face of changes to those data structures by the running program.
Reference: [Ede92] <author> Daniel Ross Edelson. </author> <title> Smart pointers: They're smart, but they're not pointers. </title> <booktitle> In USENIX C++ Conference [USE92], </booktitle> <pages> pages 1-19. </pages> <note> Technical Report UCSC-CRL-92-27, </note> <institution> University of Cali-fornia at Santa Cruz, Baskin Center for Computer Engineering and Information Sciences, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: C++; garbage collected objects have an associated pointer type defined in a library as a parameterized class, and client code must use these pointers rather than raw C++ pointers. (Parameterization and operator overloading make this relatively easy, although smart pointers can not be used quite as flexibly as raw pointers <ref> [Ede92] </ref>.) The main difference between our parameterized pointers and normal pointers is that pointer assignments execute an additional few lines of code, which constitute the write barrier. In C++, pointers may point to an element of an array or a substructure of a record.
Reference: [EV] <author> Steven L. Engelstad and James E. Van-dendorpe. </author> <title> Automatic storage management for systems with real-time constraints. Position paper for 1991 OOP-SLA Workshop on Garbage Collection in Object-Oriented Systems. </title> <note> (Available via anonymous internet ftp from cs.utexas.edu as pub/garbage/GC91/engelstad.ps.). </note>
Reference-contexts: This read barrier cost is potentially high, and very unpredictable, because the cost of traversing an ordinary list is strongly dependent on whether the list has already been reached and copied by the collector <ref> [Nil88, EV, Wit92] </ref>. This problem is even worse in recent collectors which use pagewise virtual memory protections to trigger larger increments of collector work [AEL88, Det90, Joh92], but it is also significant on Lisp-machine style hardware. <p> To our knowledge, this is the first actual implementation of an incremental non-copying implicit reclamation collector, and the first hard real-time incremental update collector. Our overall philosophy for real-time collecition is similar to that of Engelstad and Vandendorpe <ref> [EV] </ref>, but our collector differs from theirs in several ways, most obviously in the use of implicit reclamation. 7 Our initial, untuned implementation is relatively efficient, and most of the current cost (typically increasing run time by 10 to 90 percent) appears to be due to the lack of compiler cooperation
Reference: [Joh92] <author> Ralph E. Johnson. </author> <title> Reducing the latency of a real-time garbage collector. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 1(1) </volume> <pages> 46-58, </pages> <month> March </month> <year> 1992. </year>
Reference-contexts: This problem is even worse in recent collectors which use pagewise virtual memory protections to trigger larger increments of collector work <ref> [AEL88, Det90, Joh92] </ref>, but it is also significant on Lisp-machine style hardware. Even if the necessary checks are performed by dedicated parallel hardware, most of the available CPU time may be used up (in the worst case) by the actual trapping to copying routines and the copying itself.
Reference: [Nil88] <author> Kelvin Nilsen. </author> <title> Garbage collection of strings and linked data structures in real time. </title> <journal> Software Practice and Experience, </journal> <volume> 18(7) </volume> <pages> 613-640, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: This read barrier cost is potentially high, and very unpredictable, because the cost of traversing an ordinary list is strongly dependent on whether the list has already been reached and copied by the collector <ref> [Nil88, EV, Wit92] </ref>. This problem is even worse in recent collectors which use pagewise virtual memory protections to trigger larger increments of collector work [AEL88, Det90, Joh92], but it is also significant on Lisp-machine style hardware.
Reference: [NS90] <author> Kelvin Nilsen and William J. Schmidt. </author> <title> A high-level overview of hardware assisted real-time garbage collection. </title> <type> Technical Report TR 90-18a, </type> <institution> Dept. of Computer Science, Iowa State University, Ames, Iowa, </institution> <year> 1990. </year>
Reference-contexts: Even if the necessary checks are performed by dedicated parallel hardware, most of the available CPU time may be used up (in the worst case) by the actual trapping to copying routines and the copying itself. Complex memory subsystem hardware could solve this problem <ref> [NS90] </ref>, but such hardware has not yet been built and is unlikely to be widely available (or economical) soon. Nilsen and Schmidt [NS90] argue that even if increments of garbage collection work are small, a real-time program may miss its deadlines if too many small increments add up to too much <p> Complex memory subsystem hardware could solve this problem <ref> [NS90] </ref>, but such hardware has not yet been built and is unlikely to be widely available (or economical) soon. Nilsen and Schmidt [NS90] argue that even if increments of garbage collection work are small, a real-time program may miss its deadlines if too many small increments add up to too much total overhead over some period of time relevant to a deadline. <p> Nilsen's solution to this problem is to require that the worst-case delays for any program operation be small relative to that operation's normal execution time <ref> [NS90] </ref>. So, for example, if the worst case for any operation is only twice the usual case, there is no possibility for any increment of computation taking more than twice as long as it would without garbage collection. We believe that this is unnecessarily restrictive.
Reference: [Ste75] <author> Guy L. Steele Jr. </author> <title> Multiprocessing com-pactifying garbage collection. </title> <journal> Communications of the ACM, </journal> <volume> 18(9) </volume> <pages> 495-508, </pages> <month> September </month> <year> 1975. </year>
Reference-contexts: When such a pointer is created, the collector is notified so that it can either trace the pointed-to object immediately, or re-examine the stored-into location again later, to find any "hidden" objects <ref> [Ste75, DLM + 78, BDS91] </ref>. That is, the collector's view of reachable data structures is incrementally updated in the face of changes to those data structures by the running program.
Reference: [USE92] <editor> USENIX Association. </editor> <booktitle> USENIX C++ Conference, </booktitle> <address> Portland, Oregon, </address> <month> August </month> <year> 1992. </year>
Reference: [WH91] <author> Paul R. Wilson and Barry Hayes. </author> <title> The 1991 OOPSLA Workshop on Garbage Collection in Object Oriented Systems (organizers' report). </title> <editor> In Jerry L. Archibald, editor, </editor> <booktitle> OOPSLA '91 Addendum to the Proceedings, </booktitle> <pages> pages 63-71, </pages> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year> <note> ACM Press. Published as OOPS Messenger 3(4), </note> <month> October </month> <year> 1992. </year>
Reference: [Wil92] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <editor> In Yves Bekkers and Jacques Cohen, editors, </editor> <booktitle> International Workshop on Memory Management, number 637 in Lecture Notes in Computer Science, </booktitle> <pages> pages 1-42, </pages> <address> St. Malo, France, </address> <month> September </month> <year> 1992. </year> <note> Springer-Verlag. </note>
Reference-contexts: Since the application can still reach the white object through the black object's pointer, this creates a dangling pointer. To prevent this, two basic strategies are possible <ref> [Wil92] </ref>. One strategy, snapshot-at-beginning, is to ensure that objects can never get lost, by preventing any pointers from being destroyed [AP87, Yua90]. Before overwriting a pointer, the old pointer value is saved away so that the collector can still find it. <p> Our collector uses an incremental update strategy for four major reasons: * Adaptability to generational collection: The write barrier used for incremental collection can serve double duty as a write barrier for tracking inter-generational pointers in a gen erational collector <ref> [Wil92] </ref>. 1 * Reduced conservatism: Snapshot-at-beginning algorithms retain all objects that are live at the moment incremental collection begins, and objects that become garbage during collection are retained until the end of the next garbage collection cycle.
Reference: [Wit92] <author> P. T. Withington. </author> <title> How real is "real time" garbage collection? Position paper, </title> <booktitle> OOPSLA '92 Workshop on Garbage Collection in Object-Oriented Systems, </booktitle> <year> 1992. </year>
Reference-contexts: This read barrier cost is potentially high, and very unpredictable, because the cost of traversing an ordinary list is strongly dependent on whether the list has already been reached and copied by the collector <ref> [Nil88, EV, Wit92] </ref>. This problem is even worse in recent collectors which use pagewise virtual memory protections to trigger larger increments of collector work [AEL88, Det90, Joh92], but it is also significant on Lisp-machine style hardware.
Reference: [Yua90] <author> Taichi Yuasa. </author> <title> Real-time garbage collection on general-purpose machines. </title> <journal> Journal of Systems and Software, </journal> <volume> 11 </volume> <pages> 181-198, </pages> <year> 1990. </year>
Reference-contexts: Since the application can still reach the white object through the black object's pointer, this creates a dangling pointer. To prevent this, two basic strategies are possible [Wil92]. One strategy, snapshot-at-beginning, is to ensure that objects can never get lost, by preventing any pointers from being destroyed <ref> [AP87, Yua90] </ref>. Before overwriting a pointer, the old pointer value is saved away so that the collector can still find it. We call this a snapshot-at-beginning algorithm because the collector's view of reachable data structures is fixed when collection begins.
References-found: 21

