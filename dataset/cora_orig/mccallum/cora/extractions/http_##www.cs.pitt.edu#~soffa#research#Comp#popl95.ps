URL: http://www.cs.pitt.edu/~soffa/research/Comp/popl95.ps
Refering-URL: http://www.cs.pitt.edu/~soffa/research/analysis.html
Root-URL: 
Email: fduester,gupta,soffag@cs.pitt.edu  
Title: Demand-driven Computation of Interprocedural Data Flow  
Author: Evelyn Duesterwald Rajiv Gupta Mary Lou Soffa 
Address: Pittsburgh Pittsburgh, PA 15260  
Affiliation: Department of Computer Science University of  
Abstract: This paper presents a general framework for deriving demand-driven algorithms for interprocedural data flow analysis of imperative programs. The goal of demand-driven analysis is to reduce the time and/or space overhead of conventional exhaustive analysis by avoiding the collection of information that is not needed. In our framework, a demand for data flow information is modeled as a set of data flow queries. The derived demand-driven algorithms find responses to these queries through a partial reversal of the respective data flow analysis. Depending on whether minimizing time or space is of primary concern, result caching may be incorporated in the derived algorithm. Our framework is applicable to inter-procedural data flow problems with a finite domain set. If the problem's flow functions are distributive, the derived demand algorithms provide as precise information as the corresponding exhaustive analysis. For problems with monotone but non-distributive flow functions the provided data flow solutions are only approximate. We demonstrate our approach using the example of interprocedural copy constant propagation. 
Abstract-found: 1
Intro-found: 1
Reference: [Bir84] <author> G. Birkhoff. </author> <title> Lattice theory, </title> <booktitle> volume 25. American Mathematical Society, Colloquium Publication, </booktitle> <address> Washington, DC, </address> <note> 3rd edition, `84. </note>
Reference-contexts: Note, that if no such element exists h r (y) = &gt; (undefined). If the function h is u-distributive then the following relationship holds between function h and its reverse h r [Cou81, HL92]: The above relationship uniquely determines the reverse function and defines a Galois connection <ref> [Bir84] </ref> between h and its reverse h r . Note, that the u-distributivity is necessary for establishing this relationship.
Reference: [BJ78] <author> W.A. Babich and M. Jazayeri. </author> <title> The method of attributes for data flow analysis: Part II . Demand analysis. </title> <journal> Acta Informatica, </journal> <volume> 10(3), </volume> <month> Oct. `78. </month>
Reference-contexts: The restriction to a finite lattice does not even apply if our approach is used for intraprocedural analysis. The utility of demand-driven analysis algorithm has also been demonstrated in a number of demand-driven algorithms developed for specific analysis problems, including the following problems. Babich et al. <ref> [BJ78] </ref> presented a demand algorithm for intraprocedural live variable analysis based on attribute grammars. Strom and Yellin [SY93] presented a demand based analysis for typestate checking.
Reference: [Bou93] <author> F. Bourdoncle. </author> <title> Abstract debugging of high-order imperative languages. </title> <booktitle> In SIGPLAN '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 36-45, </pages> <address> Albuquerque, NM, </address> <month> Jun. '93. </month>
Reference-contexts: The concepts of deriving data flow information by backward propagation of assertions was described using operational semantics by Cousot [Cou81] and later developed and implemented in a debugging system for higher-order functions <ref> [Bou93] </ref>. The analysis for discovering linked conditions in programs described in [SMHY93] is also based on backward propagation of assertions starting from test sites in conditionals.
Reference: [CC77] <author> P. Cousot and R. Cousot. </author> <title> Static determination of dynamic properties of recursive procedures. </title> <editor> In E.J. Neuhold, editor, </editor> <booktitle> IFIP Conf. on Formal Description of Programming Concepts, </booktitle> <pages> pages 237-277. </pages> <publisher> North-Hollan Pub. Co., </publisher> <pages> `77. 11 </pages>
Reference-contexts: The derivation of demand algorithms is based on a conventional exhaustive interprocedural analysis framework. Several formal frameworks for (exhaustive) interprocedural analysis have been described <ref> [CC77, Ros79, JM82, SP81, KS92] </ref>. We use the framework by Sharir and Pnueli [SP81] as the basis for our approach. We first follow the assumptions of the Sharir-Pnueli framework and consider programs with parameterless (recursive) procedures and with a single global address space. <p> The algorithm is essentially a reversed version of Sharir and Pnueli's tabulation algorithm [SP81] to compute the original (unreversed) summary functions. A similar lazy fixed point computation of only the relevant equations was also described in the chaotic iteration algorithms <ref> [CC77] </ref> and the minimal function graphs for applicative programs [JM73]. Reverse flow functions, which we apply in the query propagation rules, have previously been discussed in [HL92] to demonstrate that an abstract interpretation may be performed in either a forward or a backward direction.
Reference: [CCF90] <author> J.D. Choi, R.K. Cytron, and J. Ferrante. </author> <title> Automatic construction of sparse data flow evaluation graphs. </title> <booktitle> In 18th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 55-66, </pages> <address> Orlando, FL, </address> <month> Jan. `90. </month>
Reference-contexts: Several sparse analysis techniques have been presented to reduce the number of data flow equations by either manipulating the underlying graphical program representation, such as the analyses based on the global value graph [RT82], static single assignment form [RWZ88, WZ85], the sparse evaluation graph <ref> [CCF90] </ref>, the dependence graph [JP93] or by direct manipulation of the equation system through partitioning algorithms [DGS94]. Slotwise analysis [DRZ92] also falls into this class of sparse technique but is limited to bitvector data flow problems. <p> An interesting combination of the two approaches would be to use, for example, a reduced equation system according to [DGS94] or a sparse evaluation graph as in <ref> [CCF90] </ref>, as the basis for propagating data flow queries. Incremental data flow analysis [Ros81, Zad84, RP88, PS89] has also addressed the avoidance of exhaustive solution re computations.
Reference: [CCF92] <author> J.D. Choi, R. Cytron, and J. Ferrante. </author> <title> On the efficient engineering of ambitious program analysis. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 20(2) </volume> <pages> 105-114, </pages> <month> Feb. '92. </month>
Reference-contexts: A demand-driven analysis approach naturally provides the capabilities to service requests whose nature and extent may vary depending on the user and the program. The utility of demand-driven analysis has previously been demonstrated for a number of specific analysis problems <ref> [CCF92, CHK92, CG93, SY93, SMHY93, Mas94] </ref>. Unlike these applications, the objective of our approach is to address demand-based analysis in a general way. We present a lattice based framework for the derivation of demand-driven algorithms for interprocedural data flow analysis. <p> The actual optimization problem to be performed on the SSA form triggers the expansion of the SSA form to include only the necessary alias-information. Similar ideas have also been implemented in the demand-based expansion algorithm of factored def-def chains <ref> [CCF92] </ref>. Other related work addresses the goal of reducing the cost of data flow analysis by avoiding the computation of irrelevant intermediate results.
Reference: [CG93] <author> R. Cytron and R. Gershbein. </author> <title> Efficient accommodation of may-alias information in SSA form. </title> <booktitle> In SIG-PLAN '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 36-45, </pages> <address> Albuquerque, NM, </address> <month> Jun. '93. </month>
Reference-contexts: A demand-driven analysis approach naturally provides the capabilities to service requests whose nature and extent may vary depending on the user and the program. The utility of demand-driven analysis has previously been demonstrated for a number of specific analysis problems <ref> [CCF92, CHK92, CG93, SY93, SMHY93, Mas94] </ref>. Unlike these applications, the objective of our approach is to address demand-based analysis in a general way. We present a lattice based framework for the derivation of demand-driven algorithms for interprocedural data flow analysis. <p> In procedure cloning [CHK92], procedure clones are created during the analysis on demand whenever it is found that an additional clone will lead to more accurate information. Cytron and Gershbein <ref> [CG93] </ref> described an algorithm for the incremental incorporation of alias information into SSA form. The actual optimization problem to be performed on the SSA form triggers the expansion of the SSA form to include only the necessary alias-information.
Reference: [CHK92] <author> K. Cooper, M. Hall, and K. Kennedy. </author> <title> Procedure cloning. </title> <booktitle> In IEEE 1992 Int. Conf. on Computer Languages, </booktitle> <pages> pages 96-105, </pages> <address> San Francisco, CA, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: A demand-driven analysis approach naturally provides the capabilities to service requests whose nature and extent may vary depending on the user and the program. The utility of demand-driven analysis has previously been demonstrated for a number of specific analysis problems <ref> [CCF92, CHK92, CG93, SY93, SMHY93, Mas94] </ref>. Unlike these applications, the objective of our approach is to address demand-based analysis in a general way. We present a lattice based framework for the derivation of demand-driven algorithms for interprocedural data flow analysis. <p> This backward search, like our query algorithm, performs the analysis from the points of interest (i.e., the points where an expression is suspected to be redundant) and it also uses early termination to end the search. In procedure cloning <ref> [CHK92] </ref>, procedure clones are created during the analysis on demand whenever it is found that an additional clone will lead to more accurate information. Cytron and Gershbein [CG93] described an algorithm for the incremental incorporation of alias information into SSA form.
Reference: [CK88] <author> K. Cooper and K. Kennedy. </author> <title> Interprocedural side-effect analysis in linear time. </title> <booktitle> SIGPLAN '88 Symp. on Compiler Construction, published in SIGPLAN Notices, </booktitle> <volume> 23(7) </volume> <pages> 57-66, </pages> <month> Jun. `88. </month>
Reference-contexts: The class of distributive and finite data flow problems that can be handled precisely includes, among others, the interprocedural versions of the classical bitvector problems, such as live variables and available expressions, as well as common interprocedural problems, such as procedure side-effect analysis <ref> [CK88] </ref>. We have chosen the example of in terprocedural copy constant propagation for illustrating the demand-driven framework in this paper. Section 2 reviews Sharir and Pnueli's interprocedural framework. In Section 3 we derive a system of query propagation rules from which we establish a generic demand algorithm.
Reference: [Coo85] <author> K. Cooper. </author> <title> Analyzing aliases of reference formal parameters. </title> <booktitle> In 12th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 281-290, `85. </pages>
Reference-contexts: Reference parameters may introduce aliases through the binding mechanism between actual and formal parameters. The determination of precise alias information is NP-complete [Mye81]. Therefore, we assume that approximate alias information is provided for each procedure p in form of a summary relation alias (p) as described in <ref> [Coo85] </ref>. A pair (x; y) 2 alias (p) if x is aliased to y in some invocation of p (may-aliases). <p> The computation of the alias (p) sets can be expressed as a distributive data flow problem with a finite domain set over a program's call graph <ref> [Coo85] </ref>. Thus, we can employ the demand-driven analysis concepts from the previous section in order to compute only the relevant alias pairs in procedures that are actually analyzed.
Reference: [Cou81] <author> P. Cousot. </author> <title> Semantic foundations of program analysis. </title> <editor> In S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 303-342. </pages> <publisher> Prentice-Hall, </publisher> <pages> `81. </pages>
Reference-contexts: Note, that if no such element exists h r (y) = &gt; (undefined). If the function h is u-distributive then the following relationship holds between function h and its reverse h r <ref> [Cou81, HL92] </ref>: The above relationship uniquely determines the reverse function and defines a Galois connection [Bir84] between h and its reverse h r . Note, that the u-distributivity is necessary for establishing this relationship. <p> The concepts of deriving data flow information by backward propagation of assertions was described using operational semantics by Cousot <ref> [Cou81] </ref> and later developed and implemented in a debugging system for higher-order functions [Bou93]. The analysis for discovering linked conditions in programs described in [SMHY93] is also based on backward propagation of assertions starting from test sites in conditionals. <p> Reverse flow functions, which we apply in the query propagation rules, have previously been discussed in [HL92] to demonstrate that an abstract interpretation may be performed in either a forward or a backward direction. The relationship between forward and backward directions of an analysis was also discussed by Cousot <ref> [Cou81] </ref>. Recently, two approaches to demand-driven interproce-dural analysis were presented by Reps [Rep94] and Reps et al. [RSH94]. In the first approach [Rep94], a limited class of data flow problems, the locally separable problems, are encoded as logic programs.
Reference: [DGS94] <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa. Reducing the cost of data flow analysis by congruence partitioning. </title> <booktitle> In 5th Int. Conf. on Compiler Construction, </booktitle> <pages> pages 357-373, </pages> <address> Edinburgh, U.K., </address> <month> Apr. </month> <pages> `94. </pages> <publisher> Springer Verlag, LNCS 786. </publisher>
Reference-contexts: number of data flow equations by either manipulating the underlying graphical program representation, such as the analyses based on the global value graph [RT82], static single assignment form [RWZ88, WZ85], the sparse evaluation graph [CCF90], the dependence graph [JP93] or by direct manipulation of the equation system through partitioning algorithms <ref> [DGS94] </ref>. Slotwise analysis [DRZ92] also falls into this class of sparse technique but is limited to bitvector data flow problems. <p> An interesting combination of the two approaches would be to use, for example, a reduced equation system according to <ref> [DGS94] </ref> or a sparse evaluation graph as in [CCF90], as the basis for propagating data flow queries. Incremental data flow analysis [Ros81, Zad84, RP88, PS89] has also addressed the avoidance of exhaustive solution re computations.
Reference: [DRZ92] <author> D.M. Dhamdhere, B.K. Rosen, and F.K. Zadeck. </author> <title> How to analyze large programs efficiently and informatively. </title> <booktitle> In SIGPLAN '92 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 212-223, </pages> <address> San Francisco, CA, </address> <month> Jun. `92. </month>
Reference-contexts: Slotwise analysis <ref> [DRZ92] </ref> also falls into this class of sparse technique but is limited to bitvector data flow problems.
Reference: [GT93] <author> D. Grove and L. Torczon. </author> <title> Interprocedural constant propagation: a study of jump function implementations. </title> <booktitle> In SIGPLAN '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 90-99, </pages> <address> Al-buquerque, NM, </address> <month> Jun. `93. </month>
Reference-contexts: Since no expressions are evaluated, CCP is less expensive but may discover fewer constants than constant propagation with expression evaluation. Recent studies on interprocedural constant propagation <ref> [GT93] </ref> indicate that the discovery of constants based on copies may be as effective in practice for the interprocedural propagation as the more costly discovery of constants based on symbolic evaluation.
Reference: [HL92] <author> J. Hughes and J. Launchbury. </author> <title> Reversing abstract interpretations. </title> <booktitle> In 4th European Symp. on Programming, </booktitle> <pages> pages 269-286, </pages> <publisher> Rennes, </publisher> <address> France, Feb. `92. </address> <publisher> Springer Verlag, LNCS 582. </publisher>
Reference-contexts: To find the appropriate query element z for the new query q 0 we apply the reverse function h r <ref> [HL92] </ref>. <p> Note, that if no such element exists h r (y) = &gt; (undefined). If the function h is u-distributive then the following relationship holds between function h and its reverse h r <ref> [Cou81, HL92] </ref>: The above relationship uniquely determines the reverse function and defines a Galois connection [Bir84] between h and its reverse h r . Note, that the u-distributivity is necessary for establishing this relationship. <p> Lemma 1 states relevant properties with respect to the composition, the meet and the join of functions. Lemma 1 Let g and h be two u-distributive functions. (i) (g h) r = h r g r Proof: straightforward and omitted for brevity (see also <ref> [HL92] </ref>). Table 2 shows the definition of the reverse flow functions in CCP. For all flow functions f r n (&gt;) = &gt; and f r ?. <p> A similar lazy fixed point computation of only the relevant equations was also described in the chaotic iteration algorithms [CC77] and the minimal function graphs for applicative programs [JM73]. Reverse flow functions, which we apply in the query propagation rules, have previously been discussed in <ref> [HL92] </ref> to demonstrate that an abstract interpretation may be performed in either a forward or a backward direction. The relationship between forward and backward directions of an analysis was also discussed by Cousot [Cou81].
Reference: [JM73] <author> N.D. Jones and A. Mycroft. </author> <title> Data flow analysis of applicative programs using minimal function graphs. </title> <booktitle> In 13th Symp. on Principles of Programming Languages, </booktitle> <pages> pages 194-206, </pages> <address> Florida, </address> <year> 1973. </year>
Reference-contexts: The algorithm is essentially a reversed version of Sharir and Pnueli's tabulation algorithm [SP81] to compute the original (unreversed) summary functions. A similar lazy fixed point computation of only the relevant equations was also described in the chaotic iteration algorithms [CC77] and the minimal function graphs for applicative programs <ref> [JM73] </ref>. Reverse flow functions, which we apply in the query propagation rules, have previously been discussed in [HL92] to demonstrate that an abstract interpretation may be performed in either a forward or a backward direction.
Reference: [JM82] <author> N. Jones and S. Muchnick. </author> <title> A flexible approach to in-terprocedural data flow analysis and programs with recursive data structures. </title> <booktitle> In 9th Symp. on Principles of Programming Languages, </booktitle> <pages> pages 66-74, </pages> <address> Albu-querque, New Mexico, </address> <year> 1982. </year>
Reference-contexts: The derivation of demand algorithms is based on a conventional exhaustive interprocedural analysis framework. Several formal frameworks for (exhaustive) interprocedural analysis have been described <ref> [CC77, Ros79, JM82, SP81, KS92] </ref>. We use the framework by Sharir and Pnueli [SP81] as the basis for our approach. We first follow the assumptions of the Sharir-Pnueli framework and consider programs with parameterless (recursive) procedures and with a single global address space.
Reference: [JP93] <author> R. Johnson and K. Pingali. </author> <title> Dependence-based program analysis. </title> <booktitle> In SIGPLAN '93 Conf. on Programming Language Design and Implementation, </booktitle> <pages> pages 78-89, </pages> <address> Albuquerque, NM, </address> <month> Jun. `93. </month>
Reference-contexts: Several sparse analysis techniques have been presented to reduce the number of data flow equations by either manipulating the underlying graphical program representation, such as the analyses based on the global value graph [RT82], static single assignment form [RWZ88, WZ85], the sparse evaluation graph [CCF90], the dependence graph <ref> [JP93] </ref> or by direct manipulation of the equation system through partitioning algorithms [DGS94]. Slotwise analysis [DRZ92] also falls into this class of sparse technique but is limited to bitvector data flow problems.
Reference: [Kil73] <author> G. Kildall. </author> <title> A unified approach to global program optimization. </title> <booktitle> In 1st ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 194-206, </pages> <address> Boston, Mas-sachusetts, </address> <month> Jan. `73. </month>
Reference-contexts: CCP is a distributive version of the (non-distributive) constant propagation analysis with expression evaluation <ref> [Kil73] </ref>. A variable is a copy constant if it is either assigned a constant value or it is assigned a copy of another variable that is a copy constant. Since no expressions are evaluated, CCP is less expensive but may discover fewer constants than constant propagation with expression evaluation.
Reference: [KS92] <author> J. Knoop and B. Steffen. </author> <title> The interprocedural coincidence theorem. </title> <booktitle> In 4th Int. Conf. on Compiler Construction, </booktitle> <pages> pages 125-140, </pages> <address> Paderborn, Germany, Oct. '92. </address> <publisher> Springer Verlag, LNCS 641. </publisher>
Reference-contexts: The derivation of demand algorithms is based on a conventional exhaustive interprocedural analysis framework. Several formal frameworks for (exhaustive) interprocedural analysis have been described <ref> [CC77, Ros79, JM82, SP81, KS92] </ref>. We use the framework by Sharir and Pnueli [SP81] as the basis for our approach. We first follow the assumptions of the Sharir-Pnueli framework and consider programs with parameterless (recursive) procedures and with a single global address space.
Reference: [KU77] <author> J.B. Kam and J.D. Ullman. </author> <title> Monotone data flow analysis frameworks. </title> <journal> Acta Informatica, </journal> <volume> 7(3) </volume> <pages> 305-317, </pages> <month> Jul. `77. </month>
Reference-contexts: 1 Introduction Phrased in the traditional data flow framework <ref> [KU77] </ref>, the solution to a data flow problem is expressed as the fixed point of a system of equations. Each equation expresses the solution at one program point in terms of the solution at immediately preceding (or succeeding) points.
Reference: [Mas94] <author> V. Maslov. </author> <title> Lazy array data-flow dependence analysis. </title> <booktitle> In ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 1-15, </pages> <month> Jan. `94. </month>
Reference-contexts: A demand-driven analysis approach naturally provides the capabilities to service requests whose nature and extent may vary depending on the user and the program. The utility of demand-driven analysis has previously been demonstrated for a number of specific analysis problems <ref> [CCF92, CHK92, CG93, SY93, SMHY93, Mas94] </ref>. Unlike these applications, the objective of our approach is to address demand-based analysis in a general way. We present a lattice based framework for the derivation of demand-driven algorithms for interprocedural data flow analysis.
Reference: [Mye81] <author> E.W. Myers. </author> <title> A precise inter-procedural data flow algorithm. </title> <booktitle> In 8th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 219-230, </pages> <address> Williamsburg, Virginia, </address> <month> Jan. `81. </month>
Reference-contexts: Two variables x and y are aliases in a procedure p if x and y may refer to the same location during some invocation of p. Reference parameters may introduce aliases through the binding mechanism between actual and formal parameters. The determination of precise alias information is NP-complete <ref> [Mye81] </ref>. Therefore, we assume that approximate alias information is provided for each procedure p in form of a summary relation alias (p) as described in [Coo85]. A pair (x; y) 2 alias (p) if x is aliased to y in some invocation of p (may-aliases).
Reference: [PS89] <author> L. Pollock and M.L. Soffa. </author> <title> An incremental version of iterative data flow analysis. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 15(12) </volume> <pages> 1537-1549, </pages> <month> Dec. `89. </month>
Reference-contexts: An interesting combination of the two approaches would be to use, for example, a reduced equation system according to [DGS94] or a sparse evaluation graph as in [CCF90], as the basis for propagating data flow queries. Incremental data flow analysis <ref> [Ros81, Zad84, RP88, PS89] </ref> has also addressed the avoidance of exhaustive solution re computations.
Reference: [Rep94] <author> T. Reps. </author> <title> Solving demand versions of interprocedu-ral analysis problems. </title> <booktitle> In 5th Int. Conf. on Compiler Construction, </booktitle> <pages> pages 389-403, </pages> <address> Edinburgh, U.K., </address> <month> Apr. </month> <pages> `94. </pages> <publisher> Springer Verlag, LNCS 786. </publisher>
Reference-contexts: The relationship between forward and backward directions of an analysis was also discussed by Cousot [Cou81]. Recently, two approaches to demand-driven interproce-dural analysis were presented by Reps <ref> [Rep94] </ref> and Reps et al. [RSH94]. In the first approach [Rep94], a limited class of data flow problems, the locally separable problems, are encoded as logic programs. Demand algorithms are then obtained by utilizing fast logic program evaluation techniques developed in the logic-programming and deductive-database communities. <p> The relationship between forward and backward directions of an analysis was also discussed by Cousot [Cou81]. Recently, two approaches to demand-driven interproce-dural analysis were presented by Reps <ref> [Rep94] </ref> and Reps et al. [RSH94]. In the first approach [Rep94], a limited class of data flow problems, the locally separable problems, are encoded as logic programs. Demand algorithms are then obtained by utilizing fast logic program evaluation techniques developed in the logic-programming and deductive-database communities.
Reference: [Ros79] <author> B. Rosen. </author> <title> Data flow analysis for procedural languages. </title> <journal> Journal of the ACM, </journal> <volume> 26(2) </volume> <pages> 322-344, `79. </pages>
Reference-contexts: The derivation of demand algorithms is based on a conventional exhaustive interprocedural analysis framework. Several formal frameworks for (exhaustive) interprocedural analysis have been described <ref> [CC77, Ros79, JM82, SP81, KS92] </ref>. We use the framework by Sharir and Pnueli [SP81] as the basis for our approach. We first follow the assumptions of the Sharir-Pnueli framework and consider programs with parameterless (recursive) procedures and with a single global address space.
Reference: [Ros81] <author> B. Rosen. </author> <title> Linear cost is sometimes quadratic. </title> <booktitle> In 8th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 117-124, </pages> <month> Jun. `81. </month>
Reference-contexts: An interesting combination of the two approaches would be to use, for example, a reduced equation system according to [DGS94] or a sparse evaluation graph as in [CCF90], as the basis for propagating data flow queries. Incremental data flow analysis <ref> [Ros81, Zad84, RP88, PS89] </ref> has also addressed the avoidance of exhaustive solution re computations.
Reference: [RP88] <author> B.G. Ryder and M.C. Paull. </author> <title> Incremental data flow analysis algorithms. </title> <journal> ACM Trans. Programming Languages and Systems, </journal> <volume> 10(1) </volume> <pages> 1-50, `88. </pages>
Reference-contexts: An interesting combination of the two approaches would be to use, for example, a reduced equation system according to [DGS94] or a sparse evaluation graph as in [CCF90], as the basis for propagating data flow queries. Incremental data flow analysis <ref> [Ros81, Zad84, RP88, PS89] </ref> has also addressed the avoidance of exhaustive solution re computations.
Reference: [RSH94] <author> T. Reps, M. Sagiv, and S. Horwitz. </author> <title> Interprocedu-ral dataflow analysis via graph reachability. </title> <type> Technical Report 94-14, </type> <institution> Datalogisk Institut, University of Copenhagen, Copenhagen, Denmark, </institution> <month> `94. </month>
Reference-contexts: The relationship between forward and backward directions of an analysis was also discussed by Cousot [Cou81]. Recently, two approaches to demand-driven interproce-dural analysis were presented by Reps [Rep94] and Reps et al. <ref> [RSH94] </ref>. In the first approach [Rep94], a limited class of data flow problems, the locally separable problems, are encoded as logic programs. Demand algorithms are then obtained by utilizing fast logic program evaluation techniques developed in the logic-programming and deductive-database communities. In a more recent work by Reps et al. [RSH94] <p> <ref> [RSH94] </ref>. In the first approach [Rep94], a limited class of data flow problems, the locally separable problems, are encoded as logic programs. Demand algorithms are then obtained by utilizing fast logic program evaluation techniques developed in the logic-programming and deductive-database communities. In a more recent work by Reps et al. [RSH94] the first approach is generalized to a larger class of problems. In this second approach a data flow problem is transformed into a specialized graph-reachability problem.
Reference: [RT82] <author> J. Reif and R.E. Tarjan. </author> <title> Symbolic program analysis in almost linear time. </title> <journal> SIAM Journal of Computing, </journal> <volume> 11(1) </volume> <pages> 81-93, </pages> <month> Feb. `82. </month>
Reference-contexts: Several sparse analysis techniques have been presented to reduce the number of data flow equations by either manipulating the underlying graphical program representation, such as the analyses based on the global value graph <ref> [RT82] </ref>, static single assignment form [RWZ88, WZ85], the sparse evaluation graph [CCF90], the dependence graph [JP93] or by direct manipulation of the equation system through partitioning algorithms [DGS94]. Slotwise analysis [DRZ92] also falls into this class of sparse technique but is limited to bitvector data flow problems.
Reference: [RWZ88] <author> B. Rosen, M. Wegman, and F.K. Zadeck. </author> <title> Global value numbers and redundant computations. </title> <booktitle> In 15th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 12-27, </pages> <address> San Diego, CA, </address> <month> Jan. `88. </month>
Reference-contexts: The authors experimentally demonstrate that their goal-oriented (and demand-driven) backward analysis is more efficient than the original forward analysis for typestate checking that eagerly collects all available information that may or may not be of relevance. Question propagation, a phase in the algorithm for global value numbering <ref> [RWZ88] </ref> performs a demand-based backward search in order to locate redundant expressions. This backward search, like our query algorithm, performs the analysis from the points of interest (i.e., the points where an expression is suspected to be redundant) and it also uses early termination to end the search. <p> Several sparse analysis techniques have been presented to reduce the number of data flow equations by either manipulating the underlying graphical program representation, such as the analyses based on the global value graph [RT82], static single assignment form <ref> [RWZ88, WZ85] </ref>, the sparse evaluation graph [CCF90], the dependence graph [JP93] or by direct manipulation of the equation system through partitioning algorithms [DGS94]. Slotwise analysis [DRZ92] also falls into this class of sparse technique but is limited to bitvector data flow problems.
Reference: [SMHY93] <author> A.D. Stoyenko, T.J. Marlowe, W.A. Halang, and M. Younis. </author> <title> Enabling efficient schedulability analysis through conditional linking and program transformations. </title> <journal> Control Engineering Practice, </journal> <volume> 1(1) </volume> <pages> 85-105, '93. </pages>
Reference-contexts: A demand-driven analysis approach naturally provides the capabilities to service requests whose nature and extent may vary depending on the user and the program. The utility of demand-driven analysis has previously been demonstrated for a number of specific analysis problems <ref> [CCF92, CHK92, CG93, SY93, SMHY93, Mas94] </ref>. Unlike these applications, the objective of our approach is to address demand-based analysis in a general way. We present a lattice based framework for the derivation of demand-driven algorithms for interprocedural data flow analysis. <p> The concepts of deriving data flow information by backward propagation of assertions was described using operational semantics by Cousot [Cou81] and later developed and implemented in a debugging system for higher-order functions [Bou93]. The analysis for discovering linked conditions in programs described in <ref> [SMHY93] </ref> is also based on backward propagation of assertions starting from test sites in conditionals. An important component of our demand-driven approach is the tabulation algorithm Compute r that implements the lazy evaluation of only relevant (i.e., needed) equation val ues.
Reference: [SP81] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interpro-cedural data flow analysis. </title> <editor> In S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <booktitle> Theory and Applications, </booktitle> <pages> pages 189-234. </pages> <publisher> Prentice-Hall, </publisher> <pages> `81. </pages>
Reference-contexts: The derivation of demand algorithms is based on a conventional exhaustive interprocedural analysis framework. Several formal frameworks for (exhaustive) interprocedural analysis have been described <ref> [CC77, Ros79, JM82, SP81, KS92] </ref>. We use the framework by Sharir and Pnueli [SP81] as the basis for our approach. We first follow the assumptions of the Sharir-Pnueli framework and consider programs with parameterless (recursive) procedures and with a single global address space. <p> The derivation of demand algorithms is based on a conventional exhaustive interprocedural analysis framework. Several formal frameworks for (exhaustive) interprocedural analysis have been described [CC77, Ros79, JM82, SP81, KS92]. We use the framework by Sharir and Pnueli <ref> [SP81] </ref> as the basis for our approach. We first follow the assumptions of the Sharir-Pnueli framework and consider programs with parameterless (recursive) procedures and with a single global address space. We then consider extensions to our framework to allow non-procedure valued reference parameters and local variables. <p> the meet-over-all-valid-paths solution mop : N 7! L: p=n 1 :::n k 2IP (r main ;n) f n k1 : : : f n 1 (?) If the analysis is u-distributive then the mop solution can be computed as the greatest fixed point of a system of data flow equations <ref> [SP81] </ref>. Data flow equations are evaluated in a two-phase approach. During the first phase the data flow effect of each procedure is analyzed independent of its calling context. The results of this phase are procedure summary functions as defined in equation system 1. <p> An important component of our demand-driven approach is the tabulation algorithm Compute r that implements the lazy evaluation of only relevant (i.e., needed) equation val ues. The algorithm is essentially a reversed version of Sharir and Pnueli's tabulation algorithm <ref> [SP81] </ref> to compute the original (unreversed) summary functions. A similar lazy fixed point computation of only the relevant equations was also described in the chaotic iteration algorithms [CC77] and the minimal function graphs for applicative programs [JM73].
Reference: [SY93] <author> R.E. Strom and D.M. Yellin. </author> <title> Extending typestate checking using conditional liveness analysis. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> 19(5) </volume> <pages> 478-485, </pages> <month> May '93. </month>
Reference-contexts: A demand-driven analysis approach naturally provides the capabilities to service requests whose nature and extent may vary depending on the user and the program. The utility of demand-driven analysis has previously been demonstrated for a number of specific analysis problems <ref> [CCF92, CHK92, CG93, SY93, SMHY93, Mas94] </ref>. Unlike these applications, the objective of our approach is to address demand-based analysis in a general way. We present a lattice based framework for the derivation of demand-driven algorithms for interprocedural data flow analysis. <p> The utility of demand-driven analysis algorithm has also been demonstrated in a number of demand-driven algorithms developed for specific analysis problems, including the following problems. Babich et al. [BJ78] presented a demand algorithm for intraprocedural live variable analysis based on attribute grammars. Strom and Yellin <ref> [SY93] </ref> presented a demand based analysis for typestate checking. The authors experimentally demonstrate that their goal-oriented (and demand-driven) backward analysis is more efficient than the original forward analysis for typestate checking that eagerly collects all available information that may or may not be of relevance.
Reference: [WZ85] <author> M. Wegman and F.K. Zadeck. </author> <title> Constant propagation with conditional branches. </title> <booktitle> In 12th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 291-299, </pages> <address> New Orleans, </address> <month> Jan. `85. </month>
Reference-contexts: Several sparse analysis techniques have been presented to reduce the number of data flow equations by either manipulating the underlying graphical program representation, such as the analyses based on the global value graph [RT82], static single assignment form <ref> [RWZ88, WZ85] </ref>, the sparse evaluation graph [CCF90], the dependence graph [JP93] or by direct manipulation of the equation system through partitioning algorithms [DGS94]. Slotwise analysis [DRZ92] also falls into this class of sparse technique but is limited to bitvector data flow problems.
Reference: [Zad84] <author> F.K. Zadeck. </author> <title> Incremental data flow analysis in a structured program editor. </title> <booktitle> In SIGPLAN Symp. on Compiler Construction, </booktitle> <pages> pages 132-143, </pages> <month> Jun. </month> <pages> `84. 12 </pages>
Reference-contexts: Determining that a variable v is a copy constant requires the simultaneous analysis of all programs variables. CCP is not a partitionable <ref> [Zad84] </ref> analysis that would permit the separate analysis of each variable as, for example, is possible in live variable analysis. The CCP lattice for a program with k variables is the product L k , where the component lattice L is defined as shown in Figure 2. <p> An interesting combination of the two approaches would be to use, for example, a reduced equation system according to [DGS94] or a sparse evaluation graph as in [CCF90], as the basis for propagating data flow queries. Incremental data flow analysis <ref> [Ros81, Zad84, RP88, PS89] </ref> has also addressed the avoidance of exhaustive solution re computations.
References-found: 36

