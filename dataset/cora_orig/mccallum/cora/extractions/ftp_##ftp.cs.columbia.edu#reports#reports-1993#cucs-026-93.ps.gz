URL: ftp://ftp.cs.columbia.edu/reports/reports-1993/cucs-026-93.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1993.html
Root-URL: http://www.cs.columbia.edu
Title: Disconnected Operation in a Multi-User Software Development Environment  1993.  
Author: Peter D. Skopp Gail E. Kaiser c fl Peter D. Skopp and Gail E. 
Keyword: Disconnected Operation, software development pre-fetching, mobile computing.  
Note: To appear in the IEEE Workshop on Advances in Parallel and Distributed Systems, Princeton NJ,  Skopp is supported in part by the National Science Foundation. Kaiser is supported by grants from the National Science Foundation, Andersen Consulting, Bull HN Information Systems and IBM Canada Ltd, and by the New York State Center for Advanced Technology in Computers and Information Systems.  
Address: New York, NY 10027  
Affiliation: Columbia University Department of Computer Science  
Pubnum: CUCS-026-93  
Email: Kaiser  
Date: August 1993  October  
Abstract: Software Development Environments have traditionally relied upon a central project database and file repository, accessible to a programmer's workstation via a local area network connection. The introduction of powerful mobile computers has demonstrated the need for a new model, which allows for machines with transient network connectivity to assist programmers in product development. We propose a process-based checkout model by which process and product files that may be needed during a planned period of dis-connectivity are pre-fetched with minimal user effort. Rather than selecting each file by hand, which is tedious and error-prone, the user only informs the environment of the portion of the software development process intended to be executed while disconnected. The environment is then responsible for pre-fetching the necessary files. We hope that this approach will enable programmers to continue working on a project without network access. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> 2nd International Conference on the Software Process: Continuous Software Process Improvement, </institution> <address> Berlin, Germany, February 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: A subclass of SDEs, called process-centered environments (PCEs), in addition provide some formalism through which a process may be specified | basically a partial ordering among software engineering tasks, constraints and obligations of those tasks, and the files and tools used in the tasks <ref> [1] </ref>. The generic PCE kernel is parameterized by the desired process, and the same PCE can support a wide range of different processes. Software engineers are well-known for their long working hours, some of which can be conducted at home using dumb terminals and modems.
Reference: [2] <author> David Cornelius. XRemote: </author> <title> A Serial Line Protocol for X. </title> <booktitle> In 6th Annual X Technical Conference, </booktitle> <month> January </month> <year> 1992. </year>
Reference-contexts: Low bandwidth serial line protocols such as SLIP and PPP are inadequate for maintaining a sophisticated display or transferring large files for local tool manipulation. X11 based protocols such as XRemote <ref> [2] </ref> and LBX [3] will maintain higher throughput via a serial line, but may still be too slow for interactive usage.
Reference: [3] <author> Jim Fulton and Chris Kent Kantarjiev. </author> <title> An Update on Low Bandwidth X (LBX), A Standard for X and Serial Lines. </title> <type> Technical Report P93-00001, </type> <institution> Xerox Palo Alto Research Center, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Low bandwidth serial line protocols such as SLIP and PPP are inadequate for maintaining a sophisticated display or transferring large files for local tool manipulation. X11 based protocols such as XRemote [2] and LBX <ref> [3] </ref> will maintain higher throughput via a serial line, but may still be too slow for interactive usage.
Reference: [4] <author> Israel Z. Ben-Shaul. </author> <title> Oz: A Decentralized Process Centered Environment. </title> <type> Technical Report CUCS-011-93, </type> <institution> Columbia University, Department of Computer Science, </institution> <month> April </month> <year> 1993. </year> <type> PhD Thesis Proposal. </type>
Reference-contexts: the Laputa project, we are primarily investigating the problems of disconnected operation, when a software engineer removes a notebook computer from the network for a period in order to conduct work off-site. (In the related Oz project, we are studying geographically distributed operation over a high-speed network connecting multiple sites <ref> [4] </ref>.) We assume the user restores the connection eventually, to merge the (partially) completed work with the ongoing efforts of other personnel collaborating on the same large-scale project.
Reference: [5] <author> Gail E. Kaiser, Peter H. Feiler, and Steven S. Popovich. </author> <title> Intelligent Assistance for Software Development and Maintenance. </title> <journal> IEEE Software, </journal> <volume> 5(3) </volume> <pages> 40-49, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Laputa is being implemented by modifying the Marvel 3.1 environment, in which the process is defined by a set of condition/activity/effects rules <ref> [5] </ref>. An instance of Marvel represents its process internally by a rule network, whose links indicate possible forward and backward chains between rules related by a common predicate [6].
Reference: [6] <author> George T. Heineman, Gail E. Kaiser, Naser S. Barghouti, and Israel Z. Ben-Shaul. </author> <title> Rule chaining in marvel: Dynamic binding of parameters. </title> <journal> IEEE Expert, </journal> <volume> 7(6) </volume> <pages> 26-32, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: An instance of Marvel represents its process internally by a rule network, whose links indicate possible forward and backward chains between rules related by a common predicate <ref> [6] </ref>. When a user requests to execute a particular software engineering task, Marvel employs the network to enforce and automate the subprocess involving the rule corresponding to that task.
Reference: [7] <author> Israel Z. Ben-Shaul, Gail E. Kaiser, and George T. Heineman. </author> <title> An Architecture for Multi-User Software Development Environments. </title> <journal> Computing Systems, The Journal of the USENIX Association, </journal> <volume> 6(2) </volume> <pages> 65-103, </pages> <month> Spring </month> <year> 1993. </year>
Reference-contexts: Each participant in a process interfaces to the system through a separate client, which supplies the user interface and forks individual tools. The clients are coordinated by a server that incorporates the process engine and the shared file repository <ref> [7] </ref>. The standard client/server protocol is for the client to display the repository in graphical format, the user selects from the task menu and clicks on the desired arguments, and then the client transmits this information to the server for any needed backward chaining. <p> Fortunately, in addition to being parameterized by the desired process, Marvel includes a sophisticated approach to concur-rency control whereby new lock modes, compatibility among lock modes, and resolution of locking conflicts can also be defined on a project-specific basis <ref> [7, 15] </ref>. We exploit these facilities to support the Laputa disconnected client.
Reference: [8] <author> J. S. Heideman, T. T. Page, R. G. Guy, and G. J. Popek. </author> <title> Primarily Disconnected Operation: Experiences with Ficus. </title> <booktitle> In Second Workshop on Management of Replicated Data. IEEE, </booktitle> <month> Novem-ber </month> <year> 1992. </year>
Reference-contexts: Inconsistencies between local copies of files and those in the central repository must be trackable. Disconnected operation supported through file pre-fetching is not a new area of research, however previous systems <ref> [8, 9, 10] </ref> were unable to draw upon the detailed application semantics inherently available from PCEs such as Marvel. We see three possible approaches to the choice of files to pre-fetch, the last of which is a novel contribution of this research: 1.
Reference: [9] <author> Mahadev Satyanarayanan, James J. Kistler, Puneet Kumar, Maria E. Okasaki, Ellen H. Siegel, and David C. Steere. Coda: </author> <title> A Highly Available File System for a Distributed Workstation Environment. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 39(4) </volume> <pages> 447-459, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Inconsistencies between local copies of files and those in the central repository must be trackable. Disconnected operation supported through file pre-fetching is not a new area of research, however previous systems <ref> [8, 9, 10] </ref> were unable to draw upon the detailed application semantics inherently available from PCEs such as Marvel. We see three possible approaches to the choice of files to pre-fetch, the last of which is a novel contribution of this research: 1.
Reference: [10] <author> Carl D. Tait and Dan Duchamp. </author> <title> Detection and Exploitation of File Working Sets. </title> <booktitle> In 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 2-9. </pages> <publisher> IEEE, </publisher> <month> May </month> <year> 1991. </year>
Reference-contexts: Inconsistencies between local copies of files and those in the central repository must be trackable. Disconnected operation supported through file pre-fetching is not a new area of research, however previous systems <ref> [8, 9, 10] </ref> were unable to draw upon the detailed application semantics inherently available from PCEs such as Marvel. We see three possible approaches to the choice of files to pre-fetch, the last of which is a novel contribution of this research: 1.
Reference: [11] <author> Gail E. Kaiser, Steven S. Popovich, and Israel Z. Ben-Shaul. </author> <title> A Bi-Level Language for Software Process Modeling. </title> <booktitle> In 15th International Conference on Software Engineering, </booktitle> <pages> pages 132-143, </pages> <address> Baltimore MD, May 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Process-based selection addresses the problems encountered with manual and heuristic selection. However, the process-based approach is not as simple as it sounds. Practical industrial-scale processes are complex, with numerous opportunities for choice or iteration <ref> [11] </ref>. The transitive closure of consequences emanating from a process step can be immense, and instantiating each enclosed task with the appropriate files could mark most of the repository for pre-fetching.
Reference: [12] <author> M. J. Rochkind. </author> <title> The Source Code Control System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1:364-370, </volume> <year> 1975. </year>
Reference-contexts: most likely forward chaining path if the disk is too small and considering multiple paths if there is more free space. 4 Concurrency Control The obvious approach to concurrency control in this context would be the "checkout" model found in most version control tools and some modern database systems (e.g., <ref> [12, 13] </ref>). Each pre-fetched file would be locked in shared or exclusive mode, depending on whether it is only to be read or possibly may be updated during the disconnected process fragment. These locks would be maintained persistently until later reconnection and "checkin".
Reference: [13] <author> Won Kim, Nat Ballou, Jorge F. Garz, and Darrell Woelk. </author> <title> A Distributed Object-Oriented Database System Supporting Shared and Private Databases. </title> <journal> ACM Transactions on Information Systems, </journal> <volume> 9(1) </volume> <pages> 31-51, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: most likely forward chaining path if the disk is too small and considering multiple paths if there is more free space. 4 Concurrency Control The obvious approach to concurrency control in this context would be the "checkout" model found in most version control tools and some modern database systems (e.g., <ref> [12, 13] </ref>). Each pre-fetched file would be locked in shared or exclusive mode, depending on whether it is only to be read or possibly may be updated during the disconnected process fragment. These locks would be maintained persistently until later reconnection and "checkin".
Reference: [14] <author> Naser S. Barghouti and Gail E. Kaiser. </author> <title> Con-currency Control in Advanced Database Applications. </title> <journal> ACM Computing Surveys, </journal> <volume> 23(3) </volume> <pages> 269-317, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: These locks would be maintained persistently until later reconnection and "checkin". But a more flexible approach is desirable for some software engineering applications <ref> [14] </ref>. Fortunately, in addition to being parameterized by the desired process, Marvel includes a sophisticated approach to concur-rency control whereby new lock modes, compatibility among lock modes, and resolution of locking conflicts can also be defined on a project-specific basis [7, 15].
Reference: [15] <author> George T. Heineman. </author> <title> A Transaction Manager Component for Cooperative Transaction Models. </title> <type> Technical Report CUCS-017-93, </type> <institution> Columbia University Department of Computer Science, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: Fortunately, in addition to being parameterized by the desired process, Marvel includes a sophisticated approach to concur-rency control whereby new lock modes, compatibility among lock modes, and resolution of locking conflicts can also be defined on a project-specific basis <ref> [7, 15] </ref>. We exploit these facilities to support the Laputa disconnected client.
Reference: [16] <author> Walter F. Tichy. </author> <title> RCS | a system for version control. </title> <journal> Software | Practice & Experience, </journal> <volume> 15(7) </volume> <pages> 637-654, </pages> <month> July </month> <year> 1985. </year>
Reference-contexts: The reserve rule in figure 4 is used to reserve a file from a version control system such as RCS <ref> [16] </ref>. (Note that the use of such a tool is orthogonal to the con-currency control system and lock compatibility matrix supported by the Marvel kernel, and its use in checking files in and out of a Laputa client.
Reference: [17] <author> Evan W. Adams, Masahiro Honda, and Ter-rence C. Miller. </author> <title> Object Management in a CASE Environment. </title> <booktitle> In 11th International Conference on Software Engineering, </booktitle> <pages> pages 154-163, </pages> <address> Pitts-burgh PA, May 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: It was released in March 1993, and has been licensed to over fifteen institutions to date. 8 Contributions A related approach was taken in the Sun Network Software Environment <ref> [17] </ref>. A user would select a software component to check out, and all of its constituent files were "acquired". The user was then able to work independently on the files in the component. Other users were free to "acquire" the same software component, increasing parallelism.
References-found: 17

