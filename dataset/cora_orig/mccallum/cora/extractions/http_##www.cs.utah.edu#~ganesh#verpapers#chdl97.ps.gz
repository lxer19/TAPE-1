URL: http://www.cs.utah.edu/~ganesh/verpapers/chdl97.ps.gz
Refering-URL: http://www.cs.utah.edu/~mjones/papers/utah.notes.html
Root-URL: 
Email: fratan,ganeshg@cs.utah.edu  
Title: A New Partial Order Reduction Algorithm for Concurrent System Verification  
Author: Ratan Nalumasu, Ganesh Gopalakrishnan 
Keyword: Finite system verification, Explicit enumeration, Partial order reductions  
Address: Salt Lake City, UT 84112  
Affiliation: Department of Computer Science University of Utah,  
Abstract: This paper presents a new partial order reduction algorithm called Two phase that is implemented in a verification tool, PV (Protocol Verifier). Two phase significantly reduces space and time requirements on many practically important protocols on which the partial order reduction algorithms implemented in previous tools (Godefroid 1995, Holzmann et al. 1994, Peled 1996) yield very little savings. This is primarily attributable to their use of a run-time proviso deciding which processes to run in a given state. Two phase avoids this proviso and follows a much simpler execution strategy that dramatically reduces the number of executions examined on a significant number of examples. We describe the Two phase algorithm, prove its correctness, and provide evidence of its superior performance on a number of examples including the directory based protocols of a multiprocessor under development. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Avalanche. </author> <note> http://www.cs.utah.edu/projects/avalanche. </note>
Reference: <author> Clarke, E. M., Emerson, E. A., and Sistla, A. P. </author> <year> (1986). </year> <title> Automatic verification of finite-state concurrent systems. </title> <journal> ACM TOPLAS, </journal> <volume> 8(2) </volume> <pages> 244-263. </pages>
Reference-contexts: 1 INTRODUCTION With the increasing scale of hardware systems and the corresponding increase in the number of concurrent protocols involved in their design, formal verification of concurrent protocols is an important practical need. Explicit state enumeration methods <ref> (Clarke et al. 1986, Holzmann 1991, Dill 1996) </ref> have shown considerable promise in verification of real-world protocol verification problems and have been used with success on many industrial designs.
Reference: <author> Dill, D. </author> <year> (1996). </year> <title> The Stanford Murphi verifier. </title> <booktitle> In CAV, </booktitle> <address> New Brunswick, New Jersey. </address>
Reference-contexts: Using most explicit state enumeration tools, a concurrent system is modeled as a set of concurrent processes communicating via shared variables <ref> (Dill 1996) </ref> and/or communication channels (Holzmann 1991) executing under an interleaving model. An important run-time optimization called partial-order Supported in part by ARPA Order #B990 Under SPAWAR Contract #N0039-95-C-0018 (Avalanche), DARPA under contract #DABT6396C0094 (UV), and NSF MIP MIP-9321836. c flIFIP 1996.
Reference: <author> Godefroid, P. </author> <year> (1995). </year> <title> Partial-Order Methods for the Verification of Concurrent Systems: An approach to the State-Explosion Problem. </title> <type> PhD thesis, </type> <institution> Univerite De Liege. </institution>
Reference-contexts: In our research in system-level hardware design, specifically in the verification of cache coherence protocols used in the Utah Avalanche multiprocessor (Avalanche ), we observed that existing tools that support partial-order reductions <ref> (Godefroid 1995, Holzmann et al. 1994) </ref> failed to provide sufficient reductions. We traced this state explosion to their use of run-time provisos (explained later) deciding which processes to run in a given state. <p> In this paper, we prove that PV preserves all stutter-free safety properties. In (Nalumasu et al. 1996b), we also prove that Two phase preserves liveness properties in a limited setting. We also summarize experimental results on a number of examples. 2 BACKGROUND The tools SPIN (Holzmann 1991) and PO-PACKAGE <ref> (Godefroid 1995) </ref> as well as our PV verifier use Promela (Holzmann 1991) as input language. In Promela, a concurrent program consists of a set of sequential processes communicating via a set of global variables and channels. Channels may have a capacity of zero or more. <p> In some protocols, e.g., Figure 3 (a), all reachable states in the protocol are generated. Figure 3 (c) shows the state space generated on this protocol. Another algorithm that uses the (weak) proviso and sleepsets implemented in the tool PO-PACKAGE, <ref> (Godefroid 1995) </ref>, also exhibits similar state explosion. The Two phase algorithm is shown as Twophase () in Figure 2. <p> States generated in this phase are saved in the temporary variable list. These states are added to cache during the second phase. In the second phase, all executable transitions at s are examined. The Two phase algorithm outperforms the proviso algorithm and PO PACKAGE <ref> (Godefroid 1995) </ref> when the proviso is invoked often; confirmed by the examples in Section 5. In most reactive systems, a transaction typi cally involves a subset of processes. <p> Hence, the Two phase algorithm outperforms the other two algorithms. Run times of these protocols are summarized in Table 3. 6 CONCLUSIONS We have presented a new partial order reduction algorithm called Two phase. Unlike the proviso algorithm or PO-PACKAGE <ref> (Godefroid 1995) </ref>, Two phase does not use the proviso. Instead it alternates one step of partial order reduction step (using deterministic transitions) followed by one step of classical depth first search (using all transitions). The (strong) proviso algorithm is shown to preserve all LTL-X formulae (Peled 1996).
Reference: <author> Gopalakrishnan, G. </author> <year> (1994). </year> <title> Micropipeline wavefront arbiters. </title> <journal> IEEE Design & Test of Computers, </journal> <volume> 11(4) </volume> <pages> 55-64. </pages>
Reference-contexts: The proviso algorithm aborted search on invalidate after generating more than 963,000 states due to lack of memory. A cross-bar arbiter that operates by sweeping diagonally propagating "wave-fronts" within a circuit array <ref> (Gopalakrishnan 1994) </ref> was verified using PV. The results are presented as rows W6-W8 in table 3. Statistics for PO-PACKAGE algorithm is not reported on this example as the protocol contains a large number of processes that the implementation could not handle.
Reference: <author> Holzmann, G. </author> <year> (1991). </year> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall. </publisher>
Reference-contexts: Using most explicit state enumeration tools, a concurrent system is modeled as a set of concurrent processes communicating via shared variables (Dill 1996) and/or communication channels <ref> (Holzmann 1991) </ref> executing under an interleaving model. An important run-time optimization called partial-order Supported in part by ARPA Order #B990 Under SPAWAR Contract #N0039-95-C-0018 (Avalanche), DARPA under contract #DABT6396C0094 (UV), and NSF MIP MIP-9321836. c flIFIP 1996. <p> In this paper, we prove that PV preserves all stutter-free safety properties. In (Nalumasu et al. 1996b), we also prove that Two phase preserves liveness properties in a limited setting. We also summarize experimental results on a number of examples. 2 BACKGROUND The tools SPIN <ref> (Holzmann 1991) </ref> and PO-PACKAGE (Godefroid 1995) as well as our PV verifier use Promela (Holzmann 1991) as input language. In Promela, a concurrent program consists of a set of sequential processes communicating via a set of global variables and channels. Channels may have a capacity of zero or more. <p> In (Nalumasu et al. 1996b), we also prove that Two phase preserves liveness properties in a limited setting. We also summarize experimental results on a number of examples. 2 BACKGROUND The tools SPIN <ref> (Holzmann 1991) </ref> and PO-PACKAGE (Godefroid 1995) as well as our PV verifier use Promela (Holzmann 1991) as input language. In Promela, a concurrent program consists of a set of sequential processes communicating via a set of global variables and channels. Channels may have a capacity of zero or more. For zero capacity channels, the rendezvous communication discipline is employed.
Reference: <author> Holzmann, G. and Peled, D. </author> <year> (1994). </year> <title> An improvement in formal verification. </title> <booktitle> In FORTE, </booktitle> <address> Bern, Switzerland. </address>
Reference-contexts: Whenever a state S is explored by the algorithm, in the first phase all deterministic processes are executed one after the other, resulting in a state S 0 . In the second phase, the algorithm explores all transitions executable at S 0 . 3 ALGORITHMS The algorithm presented in <ref> (Holzmann et al. 1994) </ref> attempts to find a process in an internal state such that all transitions of that process from that internal state are safe and that none of the transitions of the process result in a state that is in the stack. This is also called strong proviso.
Reference: <author> Nalumasu, R. and Gopalakrishnan, G. </author> <year> (1996). </year> <title> Partial order reductions without the proviso. </title> <type> Technical Report UUCS-96-006, </type> <institution> University of Utah, </institution> <address> Salt Lake City, UT, USA. </address>
Reference-contexts: Hence adding s 0 to cache does not violate the lemma. Thus in both cases, list can be added to cache without violating the lemma. Lemma 2: Twophase () terminates after a finite number of calls. Proof: Omitted. See <ref> (Nalumasu et al. 1996) </ref> for details. Theorem: Twophase () preserves all stutter free safety properties. <p> Further, a transition need not be executed at a state if it is executed at a successor of that state obtained by executing a sequence of safe transitions (i.e. stuttering steps do not matter). From Lemma 1, and the definition of deterministic, Twophase () satisfies these two conditions. See <ref> (Nalumasu et al. 1996) </ref> for details. 5 CASE STUDIES Figures 3 and 4 show two extremal cases. Table 1 shows the results of running the algorithms on these two protocols.
Reference: <author> Nalumasu, R. and Gopalakrishnan, G. </author> <year> (1996b). </year> <title> Liveness proof of the two-phase algorithm. </title> <address> http://www.cs.utah.edu/~ratan/twolive.html. </address>
Reference-contexts: In this paper, we prove that PV preserves all stutter-free safety properties. In <ref> (Nalumasu et al. 1996b) </ref>, we also prove that Two phase preserves liveness properties in a limited setting. <p> The (strong) proviso algorithm is shown to preserve all LTL-X formulae (Peled 1996). In this paper, we proved that Two phase algorithm preserves only stutter free safety properties. It is not difficult to see that Two phase also preserves liveness properties. <ref> (Nalumasu et al. 1996b) </ref> presents a proof that Two phase preserves liveness properties in a limited setting where all transitions are either unconditionally safe or unsafe, i.e., conditionally safe transitions are not present.
Reference: <author> Peled, D. </author> <year> (1996). </year> <title> Combining partial order reductions with on-the-fly model-checking. </title> <journal> Journal of Formal Methods in Systems Design, </journal> <volume> 8 </volume> (1):39-64. 
Reference-contexts: Published by Chapman & Hall 2 Two phase Algorithm for Partial Order Reductions process P f int l; if :: c ! 7 -&gt; skip; :: d ? l -&gt; skip; fi; if :: l == 0 -&gt; skip :: l != 0 -&gt; skip fi g reductions <ref> (Peled 1996, Godefroid 1995, Valmari 1993) </ref> helps avoid having to examine all possible interleavings among processes, and is crucial to handling large models. <p> Instead it alternates one step of partial order reduction step (using deterministic transitions) followed by one step of classical depth first search (using all transitions). The (strong) proviso algorithm is shown to preserve all LTL-X formulae <ref> (Peled 1996) </ref>. In this paper, we proved that Two phase algorithm preserves only stutter free safety properties.
Reference: <author> Valmari, A. </author> <year> (1993). </year> <title> On-the-fly verification with stubborn sets. </title> <booktitle> In CAV, </booktitle> <pages> pages 397-408, </pages> <address> Elounda, Greece. </address>
References-found: 11

