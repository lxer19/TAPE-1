URL: http://www-cad.eecs.berkeley.edu/~orna/publications/concur96.ps.Z
Refering-URL: http://www-cad.eecs.berkeley.edu/~orna/pub.html
Root-URL: 
Email: Email: ftah,ornag@eecs.berkeley.edu  Email: vardi@cs.rice.edu  
Title: A Space-Efficient On-the- Algorithm for Real-Time Model Checking  
Author: Thomas A. Henzinger Orna Kupferman Moshe Y. Vardi 
Address: Berkeley, CA 94720-1770, U.S.A.  Houston, TX 77005-1892, U.S.A.  
Note: Address:  Address:  
Affiliation: UC Berkeley  Rice University  EECS Department,  Department of Computer Science,  
Abstract: In temporal-logic model checking, we verify the correctness of a program with respect to a desired behavior by checking whether a structure that models the program satisfies a temporal-logic formula that specifies the behavior. The main practical limitation of model checking is caused by the size of the state space of the program, which grows exponentially with the number of concurrent components. This problem, known as the state-explosion problem, becomes more difficult when we consider real-time model checking, where the program and the specification involve quantitative references to time. In particular, when use timed automata to describe real-time programs and we specify timed behaviors in the logic TCTL, a real-time extension of the temporal logic CTL with clock variables, then the state space under consideration grows exponentially not only with the number of concurrent components, but also with the number of clocks and the length of the clock constraints used in the program and the specification. Two powerful methods for coping with the state-explosion problem are on-the-fly and space-efficient model checking. In on-the-fly model checking, we explore only the portion of the state space of the program whose exploration is essential for determining the satisfaction of the specification. In space-efficient model checking, we store in memory the minimal information required, preferring to spend time on reconstructing information rather than spend space on storing it. In this work we develop an automata-theoretic approach to TCTL model checking that combines both methods. We suggest, for the first time, a PSPACE on-the-fly model-checking algorithm for TCTL. 
Abstract-found: 1
Intro-found: 1
Reference: [ACD93] <author> R. Alur, C. Courcoubetis, and D. Dill. </author> <title> Model-checking in dense real-time. </title> <journal> Information and Computation, </journal> <volume> 104(1) </volume> <pages> 2-34, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Nevertheless, model checking for TCTL is hard. Indeed, while the model-checking problem for CTL can be solved in linear time [CES86], it is PSPACE-complete for TCTL <ref> [ACD93] </ref>. This means that methods that cope with the computational limitations of CTL model checking become even more essential when we turn to consider TCTL model checking. The main computational limitation of CTL model checking is caused by the size of the program. <p> Given a TCTL formula and a real-time program U , we construct a 1-letter word HAA D ;U such that the language of D ;U is not empty iff U satisfies . Several model-checking algorithms for TCTL are studied in the literature <ref> [ACD93, HNSY94, LL95, SS95] </ref>. All these algorithms use the finite quotient of the state space suggested in [AD94]. They differ in how they explore the finite-state structure it induces. In [ACD93], a bottom-up labeling algorithm is used. This basic algorithm gains two optimizations in [HNSY94]. <p> Several model-checking algorithms for TCTL are studied in the literature [ACD93, HNSY94, LL95, SS95]. All these algorithms use the finite quotient of the state space suggested in [AD94]. They differ in how they explore the finite-state structure it induces. In <ref> [ACD93] </ref>, a bottom-up labeling algorithm is used. This basic algorithm gains two optimizations in [HNSY94]. There, the algorithm uses a symbolic presentation of the state space and it tries to reduce the state space by integrating regions together. <p> We consider here TCTL, the real-time extension of the branching temporal logic CTL <ref> [ACD93] </ref>. Formulas of TCTL are defined with respect to the sets AP and C U of the program's atomic propositions and clocks, respectively, and a set C of specification clocks. Atomic formulas of TCTL refer to the satisfaction of atomic propositions and put constraints on the values of the clocks. <p> Our algorithm is based on an automata-theoretic framework to TCTL model checking. One may wonder why our framework is purposeful for model checking and does not attempt to serve the satisfiability problem. The satisfiability problem for TCTL is undecidable <ref> [ACD93] </ref>. Hence, a comprehensive automata-theoretic framework for TCTL should involve tree automata for which the nonemptiness problem is undecidable.
Reference: [AD94] <author> R. Alur and D. Dill. </author> <title> A theory of timed automata. </title> <journal> Theoretical Computer Science, </journal> <volume> 126(2) </volume> <pages> 183-236, </pages> <year> 1994. </year>
Reference-contexts: So, for model checking of untimed temporal logics, the automata-theoretic approach combines on-the-fly methods and space efficiency. The automata-theoretic counterpart for describing languages of timed objects are timed automata <ref> [AD94] </ref>. Timed automata use finitely many real-valued clocks to keep track of timing constraints, and serve as the common way of modeling the behavior of real-time programs. The automata-theoretic approach to CTL cannot be easily extended to handle TCTL. <p> The automata-theoretic approach to CTL cannot be easily extended to handle TCTL. The reason is TCTL's dense time domain which requires models with infinitely many states. It was shown, however, in <ref> [AD94] </ref>, that each real-time program induces a finite quotient of the infinite state space. <p> Several model-checking algorithms for TCTL are studied in the literature [ACD93, HNSY94, LL95, SS95]. All these algorithms use the finite quotient of the state space suggested in <ref> [AD94] </ref>. They differ in how they explore the finite-state structure it induces. In [ACD93], a bottom-up labeling algorithm is used. This basic algorithm gains two optimizations in [HNSY94]. <p> a set C of clocks, a formula in guard (C) is one of the following: * true, false, or c ~ v, where c 2 C, v 2 N 1 , and ~ 2 f; &gt;; ; &lt;g, 1 As we can multiply all clock values by the same factor <ref> [AD94] </ref>, using N, rather then Q, does not reduce the expressive power of the automata. 4 * 1 _ 2 or 1 ^ 2 , where 1 and 2 are formulas in guard (C). <p> Define the set of clock regions induced by and U <ref> [AD94] </ref>. 2. Define the function reg succ : ! , that maps a clock region to its (unique) successor clock region [AD94]. 7 3. Construct a 1-letter alternating automaton D ;U on infinite words. <p> Define the set of clock regions induced by and U <ref> [AD94] </ref>. 2. Define the function reg succ : ! , that maps a clock region to its (unique) successor clock region [AD94]. 7 3. Construct a 1-letter alternating automaton D ;U on infinite words. Each state in this untimed automaton is associated with a subformula ' of , a location l of U , and a clock region from . <p> We can partition the infinitely many clock environments to finitely many equivalent classes such that all clock environments of the same class are indistinguishable by formulas in guard (C) that are clock constraints in either or U . It was proven in <ref> [AD94] </ref> that a sufficient condition for two environment clocks to be indistinguishable is agreement on the integral parts of all clocks values and agreement on the ordering of the fractional parts of all clock values. This leads to the following definition of regions. <p> A clock environment E then belongs to iff it satisfies all its clock constraints. By the definition of regions, the constraints that represent specify the integral part of all clocks, the order among the fractional parts, and whether they are equal to 0. Lemma 3.1 <ref> [AD94] </ref> The number of regions in is bounded by jCj! 2 jCj Q 8 For a region and a formula ' 2 guard (C), we say that satisfies ' (denoted j= ') iff rep () satisfies '.
Reference: [AFH96] <author> R. Alur, T. Feder, and T.A. Henzinger. </author> <title> The benefits of relaxing punctuality. </title> <journal> Journal of the ACM, </journal> <volume> 43(1) </volume> <pages> 116-146, </pages> <year> 1996. </year>
Reference-contexts: It turned out that model-checking methods for untimed temporal logics can be extended quite easily to handle discrete time [Eme92, AH93]. Present research on real-time temporal logics focuses on dense time, where time stamps are reals <ref> [Alu91, AFH96] </ref>. There, model checking becomes significantly more complex. For example, while the model-checking problem is PSPACE-complete for the linear temporal logic LTL [SC85], it is undecidable for its real-time extension TLTL [AH94]. We can still define real-time temporal logics with a dense-time domain for which model checking is decidable.
Reference: [AH92] <author> R. Alur and T.A. Henzinger. </author> <title> Logics and models of real time: a survey. </title> <editor> In J.W. de Bakker, K. Huizing, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Real Time: </title> <booktitle> Theory in Practice, Lecture Notes in Computer Science 600, </booktitle> <pages> pages 74-106. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: In branching temporal logics, formulas are interpreted over infinite trees and describe the behavior of the possible computations of a nondeterministic program. The development of concurrent programs that must meet rigid real-time constraints has brought with it a need for real-time temporal logics that enable quantitative reference to time <ref> [EMSS90, AH92] </ref>. Formulas of real-time temporal logics are interpreted over timed structures (infinite words or infinite trees in which a time stamp is associated with every position), and their syntax includes, in addition to qualitative temporal operators (such as "eventually"), also explicit time references (such as "within 4 time units").
Reference: [AH93] <author> R. Alur and T. Henzinger. </author> <title> Real-time logics: Complexity and expressiveness. </title> <journal> Information and Computation, </journal> <volume> 104(1) </volume> <pages> 35-77, </pages> <month> May </month> <year> 1993. </year> <month> 19 </month>
Reference-contexts: Early research on real-time temporal logics considered discrete time, where time stamps are integers. It turned out that model-checking methods for untimed temporal logics can be extended quite easily to handle discrete time <ref> [Eme92, AH93] </ref>. Present research on real-time temporal logics focuses on dense time, where time stamps are reals [Alu91, AFH96]. There, model checking becomes significantly more complex. For example, while the model-checking problem is PSPACE-complete for the linear temporal logic LTL [SC85], it is undecidable for its real-time extension TLTL [AH94].
Reference: [AH94] <author> R. Alur and T.A. Henzinger. </author> <title> A really temporal logic. </title> <journal> Journal of the ACM, </journal> <volume> 41(1) </volume> <pages> 181-204, </pages> <year> 1994. </year>
Reference-contexts: Present research on real-time temporal logics focuses on dense time, where time stamps are reals [Alu91, AFH96]. There, model checking becomes significantly more complex. For example, while the model-checking problem is PSPACE-complete for the linear temporal logic LTL [SC85], it is undecidable for its real-time extension TLTL <ref> [AH94] </ref>. We can still define real-time temporal logics with a dense-time domain for which model checking is decidable. Such a logic is TCTL, the real-time extension of the branching temporal logic CTL.
Reference: [Alu91] <author> R. Alur. </author> <title> Techniques for Automatic Verification of Real-time Systems. </title> <type> PhD thesis, </type> <institution> Stanford University, </institution> <year> 1991. </year>
Reference-contexts: It turned out that model-checking methods for untimed temporal logics can be extended quite easily to handle discrete time [Eme92, AH93]. Present research on real-time temporal logics focuses on dense time, where time stamps are reals <ref> [Alu91, AFH96] </ref>. There, model checking becomes significantly more complex. For example, while the model-checking problem is PSPACE-complete for the linear temporal logic LTL [SC85], it is undecidable for its real-time extension TLTL [AH94]. We can still define real-time temporal logics with a dense-time domain for which model checking is decidable.
Reference: [BVW94] <author> O. Bernholtz, M.Y. Vardi, and P. Wolper. </author> <title> An automata-theoretic approach to branching-time model checking. </title> <editor> In D. L. Dill, editor, </editor> <booktitle> Computer Aided Verification, Proc. 6th Int. Conference, volume 818 of Lecture Notes in Computer Science, </booktitle> <pages> pages 142-155, </pages> <address> Stanford, June 1994. </address> <publisher> Springer-Verlag, </publisher> <address> Berlin. </address>
Reference-contexts: Like temporal logics, they come in two varieties: automata on infinite words (word automata, for short) and automata on infinite trees (tree automata). The automata-theoretic approach to temporal logic uses the theory of automata as a unifying paradigm for program specification and verification <ref> [VW94, BVW94] </ref>. In this paradigm, both the program and the specification are translated to (or are given as) automata. Linear temporal logic formulas correspond to word automata and branching temporal logic formulas correspond to tree automata. Then, questions about programs and their specifications can be reduced to questions about automata. <p> Moreover, the special structure of HAA enables us to check their nonemptiness in efficient space and leads to an on-the-fly model-checking algorithm for CTL that needs space linear in the length of but only polylogarithmic in the size of P <ref> [BVW94] </ref>. So, for model checking of untimed temporal logics, the automata-theoretic approach combines on-the-fly methods and space efficiency. The automata-theoretic counterpart for describing languages of timed objects are timed automata [AD94]. <p> Note also that each infinite path in the run corresponds to a sequence in Q ! . The run is accepting if all its infinite paths satisfy the acceptance condition. An automaton is nonempty if it accepts some word. A hesitant alternating automaton (HAA) on words <ref> [BVW94] </ref> is an alternating automaton A = h; Q; ffi; q 0 ; ffi where ff = hG; Bi with G Q and B Q and ffi satisfies the following. <p> The number of sets in the partition of Q is defined as the depth of A. Theorem 3.3 <ref> [BVW94] </ref> (1) The 1-letter nonemptiness problem for HAA can be solved in linear time. (2) The 1-letter nonemptiness problem for HAA of size n and depth m can be solved in space O (m log 2 n). <p> The restricted structure of HAA suggests an automata-based model-checking algorithm that combines on-the-fly methods with space efficiency <ref> [BVW94] </ref>. Essentially, HAA enable on-the-fly model-checking since their transition function depends only on the current states and input. They enable space efficiency since their nonemptiness can be checked in efficient space. <p> Sets Q ' for ' of the form A' 1 U ' 2 or A' 1 ~ U ' 2 are universal. It is easy to see that the hesitation condition holds too. As in the automata for CTL <ref> [BVW94] </ref>, disjunctions and conjunctions in are handled by the existential and universal branching, respectively, of alternating automata. The until operator and its duality are handled by partitioning them to requirements on the present (current location) and requirements on the future (successor locations).
Reference: [CE81] <author> E.M. Clarke and E.A. Emerson. </author> <title> Design and synthesis of synchronization skeletons using branching time temporal logic. </title> <booktitle> In Proc. Workshop on Logic of Programs, volume 131 of Lecture Notes in Computer Science, </booktitle> <pages> pages 52-71. </pages> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: In temporal logic model checking , we verify that a program meets a desired behavior by checking that a mathematical model of the program satisfies a temporal logic formula that specifies the behavior <ref> [CE81, QS81] </ref>. Temporal logics come in two varieties: linear and branching [Lam80]. In linear temporal logics, formulas are interpreted over infinite words and describe the behavior of each of the infinite computations of a program.
Reference: [CES86] <author> E.M. Clarke, </author> <title> E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> January </month> <year> 1986. </year>
Reference-contexts: The branching nature and the limited syntax of TCTL circumvent the difficulties that make TLTL model checking undecidable and yet enables the specifications of many interesting real-time properties. Nevertheless, model checking for TCTL is hard. Indeed, while the model-checking problem for CTL can be solved in linear time <ref> [CES86] </ref>, it is PSPACE-complete for TCTL [ACD93]. This means that methods that cope with the computational limitations of CTL model checking become even more essential when we turn to consider TCTL model checking. The main computational limitation of CTL model checking is caused by the size of the program. <p> We can add to fi more sets (e.g. fh'; l; i : grant 2 P (l)g) and restrict path quantification further (in the above example, to paths that diverge and visit a state labeled with grant infinitely often). Thus, like fair-CTL of <ref> [CES86] </ref>, we can handle fair-TCTL, where the input linear timed automaton is augmented with fairness constraints.
Reference: [CVWY92] <author> C. Courcoubetis, M.Y. Vardi, P. Wolper, and M. Yannakakis. </author> <title> Memory efficient algorithms for the verification of temporal properties. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 1 </volume> <pages> 275-288, </pages> <year> 1992. </year>
Reference-contexts: More specifically, questions such as satisfiability of specifications and correctness of programs with respect to their specifications can be reduced to questions such as nonemptiness and containment of automata. These reductions yield clean and optimal algorithms and are helpful in implementing model-checking methods <ref> [CVWY92] </ref>. In the automata-theoretic approach to CTL model checking, we translate a formula to a tree hesitant alternating automaton (HAA) A of size linear in the length of . For checking whether a program P satisfies , we check the nonemptiness of the product of A and P .
Reference: [Eme92] <author> E.A. Emerson. </author> <title> Real time and the -calculus. </title> <editor> In J.W. de Bakker, K. Huizing, W.-P. de Roever, and G. Rozenberg, editors, </editor> <title> Real Time: </title> <booktitle> Theory in Practice, Lecture Notes in Computer Science 600, </booktitle> <pages> pages 176-194. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Early research on real-time temporal logics considered discrete time, where time stamps are integers. It turned out that model-checking methods for untimed temporal logics can be extended quite easily to handle discrete time <ref> [Eme92, AH93] </ref>. Present research on real-time temporal logics focuses on dense time, where time stamps are reals [Alu91, AFH96]. There, model checking becomes significantly more complex. For example, while the model-checking problem is PSPACE-complete for the linear temporal logic LTL [SC85], it is undecidable for its real-time extension TLTL [AH94].
Reference: [EMSS90] <author> E.A. Emerson, A.K. Mok, A.P. Sistla, and J. Srinivasan. </author> <title> Quantitative temporal reasoning. </title> <booktitle> In Proc. 2nd Conference on Computer Aided Verification, volume 531 of Lecture Notes in Computer Science, </booktitle> <pages> pages 136-145. </pages> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: In branching temporal logics, formulas are interpreted over infinite trees and describe the behavior of the possible computations of a nondeterministic program. The development of concurrent programs that must meet rigid real-time constraints has brought with it a need for real-time temporal logics that enable quantitative reference to time <ref> [EMSS90, AH92] </ref>. Formulas of real-time temporal logics are interpreted over timed structures (infinite words or infinite trees in which a time stamp is associated with every position), and their syntax includes, in addition to qualitative temporal operators (such as "eventually"), also explicit time references (such as "within 4 time units").
Reference: [FMJJ92] <author> J.-C. Fernandez, L. Mounier, C. Jard, and T. Jeron. </author> <title> On-the-fly verification of finite transition systems. </title> <booktitle> Formal Methods in System Design, </booktitle> <volume> 1 </volume> <pages> 251-273, </pages> <year> 1992. </year>
Reference-contexts: Two powerful methods for coping with the state explosion problem are on-the-fly model checking and space-efficient model checking. In on-the-fly model checking, we explore only a portion of the state space of the program; namely, the portion 1 whose exploration is essential for determining the satisfaction of the specification <ref> [FMJJ92] </ref>. On-the-fly model-checking is strongly related to local model-checking, where we check whether a specific state of the program satisfies a specification [SW89]. The motivation for space-efficient algorithms comes from the fact that space, rather than time, is the computational bottleneck of model checking.
Reference: [HNSY94] <author> T.A. Henzinger, X. Nicollin, J. Sifakis, and S. Yovine. </author> <title> Symbolic model checking for real-time systems. </title> <journal> Information and Computation, </journal> <volume> 111 </volume> <pages> 193-244, </pages> <year> 1994. </year>
Reference-contexts: Given a TCTL formula and a real-time program U , we construct a 1-letter word HAA D ;U such that the language of D ;U is not empty iff U satisfies . Several model-checking algorithms for TCTL are studied in the literature <ref> [ACD93, HNSY94, LL95, SS95] </ref>. All these algorithms use the finite quotient of the state space suggested in [AD94]. They differ in how they explore the finite-state structure it induces. In [ACD93], a bottom-up labeling algorithm is used. This basic algorithm gains two optimizations in [HNSY94]. <p> All these algorithms use the finite quotient of the state space suggested in [AD94]. They differ in how they explore the finite-state structure it induces. In [ACD93], a bottom-up labeling algorithm is used. This basic algorithm gains two optimizations in <ref> [HNSY94] </ref>. There, the algorithm uses a symbolic presentation of the state space and it tries to reduce the state space by integrating regions together. Typically, regions whose clock values are indistinguishable by the clock constraints in the program and the formula are integrated into a single zone. <p> The algorithm TMC works on-the-fly and explores only a portion of the program checked, but, unlike our algorithm, TMC maintains this portion all along its execution. Thus, the best bound to its complexity is exponential space. Maintenance of this portion and the bottom-up reasoning in <ref> [HNSY94, YL93, SS95] </ref> are essential, however, for obtaining zones that are as coarse as possible. The simple combinatorial structure that emerges from our automata-theoretic approach offers several advantages. First, automata separate the logical and the algorithmic components of the model-checking problem. <p> Note that path quantification in TCTL ranges over diverging paths only. Note also that the semantics of the until operator and its duality requires either ' 1 or ' 2 to be satisfied until the satisfaction of ' 2 . As explained in <ref> [HNSY94] </ref>, this meets our expectations of the dense-time domain. Thus, the formula z:A (z 4)U (z &gt; 4) is always valid and, similarly, the dual formula z:A (z &gt; 4) ~ U (z 4) is not satisfiable. <p> Our algorithm does not achieve such a coarse split of R. Instead, it refines the zone [0 x &lt; 2] into its four regions [x = 0] ; [0 &lt; x &lt; 1] ; [x = 1] ; [1 &lt; x &lt; 2]: In this sense, the algorithm in <ref> [HNSY94] </ref> and the algorithm TMC in [SS95] are more efficient than our algorithm. Why can not we integrate the four regions into a single zone as well? To answer this question, consider the linear timed automaton U 0 below. <p> Therefore, when we integrate regions together, we must get ready to every possible future, in particular to one that requires the split of the zone [0 x &lt; 2]. The optimal split performed by <ref> [HNSY94, SS95] </ref> must involve also some bottom-up reasoning, which increases worst-case space complexity. <p> The saving is more significant with respect to guards that are lower bounds (c &gt; v or c v); there, we can integrate all the time transitions up to the lower bound. 18 Finally, the saving is optimal (that is, achieves the same coarse split as in <ref> [HNSY94, SS95] </ref>) with respect to guards that are tight bounds (c = v). <p> We showed that there is a trade-off between worst-case space efficiency and optimization of the state space by integrating several regions into a zone. The measure for this trade-off is the amount of look-ahead on the input linear timed automaton allowed to the model-checking algorithm. The algorithm in <ref> [HNSY94] </ref> performs pure bottom-up reasoning (i.e., reasoning with complete look-ahead), and achieves maximal zones. Our algorithm performs pure top-down reasoning (i.e., reasoning without look ahead), and achieves space efficiency.
Reference: [KV95] <author> O. Kupferman and M.Y. Vardi. </author> <title> On the complexity of branching modular model checking. </title> <booktitle> In Proc. 6th Conferance on Concurrency Theory, </booktitle> <pages> pages 408-422, </pages> <address> Philadelphia, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: The translation to automata handles the logic, and the nonemptiness test handles the algorithmics. This separation makes both components simple and enables us to identify the exact complexity of the model checking problem. Second, using Libi alternating automata (LAA), which are HAA augmented with a fairness condition <ref> [KV95] </ref>, we can restrict path quantification in TCTL to range only over computations of the program that diverge (i.e., in which time always proceed), and we can extend our method to fair-TCTL. Both extensions do not exist in the algorithm TMC. <p> In order to perform fair model checking, HAA were extended in <ref> [KV95] </ref> to Libi Alternating Automata (LAA). A LAA is an HAA extended with a generalized Buchi fairness condition fi 2 Q ; i.e., fi is a set of subsets of the state-space of the LAA. <p> It is shown in <ref> [KV95] </ref> that the time and space complexities of the 1-letter nonemptiness problem for HAA apply also to LAA (the version presented in [KV95] uses a Rabin fairness condition, yet the extension to generalized Buchi is straightforward). <p> It is shown in <ref> [KV95] </ref> that the time and space complexities of the 1-letter nonemptiness problem for HAA apply also to LAA (the version presented in [KV95] uses a Rabin fairness condition, yet the extension to generalized Buchi is straightforward). We now use LAA in order to range path quantification only over computations that diverge.
Reference: [Lam80] <author> L. Lamport. </author> <title> Sometimes is sometimes "not never" on the temporal logic of programs. </title> <booktitle> In Proceedings of the 7th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-185, </pages> <month> January </month> <year> 1980. </year>
Reference-contexts: In temporal logic model checking , we verify that a program meets a desired behavior by checking that a mathematical model of the program satisfies a temporal logic formula that specifies the behavior [CE81, QS81]. Temporal logics come in two varieties: linear and branching <ref> [Lam80] </ref>. In linear temporal logics, formulas are interpreted over infinite words and describe the behavior of each of the infinite computations of a program. In branching temporal logics, formulas are interpreted over infinite trees and describe the behavior of the possible computations of a nondeterministic program.
Reference: [LL95] <author> F. Laroussinie and K. G. Larsen. </author> <title> Compositional model checking of real time systems. </title> <booktitle> In Proc. 6th Conferance on Concurrency Theory, </booktitle> <pages> pages 27-41, </pages> <address> Philadelphia, </address> <month> August </month> <year> 1995. </year> <note> Springer-Verlag. </note>
Reference-contexts: Given a TCTL formula and a real-time program U , we construct a 1-letter word HAA D ;U such that the language of D ;U is not empty iff U satisfies . Several model-checking algorithms for TCTL are studied in the literature <ref> [ACD93, HNSY94, LL95, SS95] </ref>. All these algorithms use the finite quotient of the state space suggested in [AD94]. They differ in how they explore the finite-state structure it induces. In [ACD93], a bottom-up labeling algorithm is used. This basic algorithm gains two optimizations in [HNSY94].
Reference: [MP92] <author> Z. Manna and A. Pnueli. </author> <title> The Temporal Logic of Reactive and Concurrent Systems: Specification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: The first step in program verification is to come up with a formal specification of the program. Temporal logics can describe a temporal ordering of events and have been adopted as a powerful tool for specifying and verifying concurrent programs <ref> [Pnu77, MP92] </ref>. In temporal logic model checking , we verify that a program meets a desired behavior by checking that a mathematical model of the program satisfies a temporal logic formula that specifies the behavior [CE81, QS81]. Temporal logics come in two varieties: linear and branching [Lam80].
Reference: [MS87] <author> D.E. Muller and P.E. Schupp. </author> <title> Alternating automata on infinite trees. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 54,:267-276, </address> <year> 1987. </year> <month> 20 </month>
Reference-contexts: Alternating automata on infinite words generalize nondeterministic automata and were first introduced in <ref> [MS87] </ref>. Consider a nondeterministic word automaton with a set Q of states and a transition function M . The function M maps an automaton state q 2 Q and an input letter 2 to a set of states. Each such state suggests a nondeterministic choice for the automaton's next state.
Reference: [MSS86] <author> D.E. Muller, A. Saoudi, and P.E. Schupp. </author> <title> Alternating automata, the weak monadic theory of the tree and its complexity. </title> <booktitle> In Proc. 13th Int. Colloquium on Automata, Languages and Programming. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1986. </year>
Reference-contexts: A hesitant alternating automaton (HAA) on words [BVW94] is an alternating automaton A = h; Q; ffi; q 0 ; ffi where ff = hG; Bi with G Q and B Q and ffi satisfies the following. First, as in weak alternating automata <ref> [MSS86] </ref>, there exists a partition of Q into disjoint sets Q i , and a partial order on the collection of the Q i 's such that for every q 2 Q i and q 0 2 Q j for which q 0 occurs in ffi (q; ) for some 2
Reference: [Pnu77] <author> A. Pnueli. </author> <title> The temporal logic of programs. </title> <booktitle> In Proc. 18th IEEE Symposium on Foundation of Computer Science, </booktitle> <pages> pages 46-57, </pages> <year> 1977. </year>
Reference-contexts: The first step in program verification is to come up with a formal specification of the program. Temporal logics can describe a temporal ordering of events and have been adopted as a powerful tool for specifying and verifying concurrent programs <ref> [Pnu77, MP92] </ref>. In temporal logic model checking , we verify that a program meets a desired behavior by checking that a mathematical model of the program satisfies a temporal logic formula that specifies the behavior [CE81, QS81]. Temporal logics come in two varieties: linear and branching [Lam80].
Reference: [QS81] <author> J.P. Queille and J. Sifakis. </author> <title> Specification and verification of concurrent systems in Cesar. </title> <booktitle> In Proc. 5th International Symp. on Programming, </booktitle> <volume> volume 137, </volume> <pages> pages 337-351. </pages> <note> Springer-Verlag, Lecture Notes in Computer Science, </note> <year> 1981. </year>
Reference-contexts: In temporal logic model checking , we verify that a program meets a desired behavior by checking that a mathematical model of the program satisfies a temporal logic formula that specifies the behavior <ref> [CE81, QS81] </ref>. Temporal logics come in two varieties: linear and branching [Lam80]. In linear temporal logics, formulas are interpreted over infinite words and describe the behavior of each of the infinite computations of a program.
Reference: [SC85] <author> A.P. Sistla and E.M. Clarke. </author> <title> The complexity of propositional linear temporal logic. </title> <journal> J. ACM, </journal> <volume> 32 </volume> <pages> 733-749, </pages> <year> 1985. </year>
Reference-contexts: Present research on real-time temporal logics focuses on dense time, where time stamps are reals [Alu91, AFH96]. There, model checking becomes significantly more complex. For example, while the model-checking problem is PSPACE-complete for the linear temporal logic LTL <ref> [SC85] </ref>, it is undecidable for its real-time extension TLTL [AH94]. We can still define real-time temporal logics with a dense-time domain for which model checking is decidable. Such a logic is TCTL, the real-time extension of the branching temporal logic CTL.
Reference: [SS95] <author> O.V. Sokolsky and S.A. Smolka. </author> <title> Local model checking for real-time systems. </title> <booktitle> In Computer Aided Verification, Proc. 7th Int. Conference, Lecture Notes in Computer Science 939, </booktitle> <pages> pages 211-224, Liege, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Given a TCTL formula and a real-time program U , we construct a 1-letter word HAA D ;U such that the language of D ;U is not empty iff U satisfies . Several model-checking algorithms for TCTL are studied in the literature <ref> [ACD93, HNSY94, LL95, SS95] </ref>. All these algorithms use the finite quotient of the state space suggested in [AD94]. They differ in how they explore the finite-state structure it induces. In [ACD93], a bottom-up labeling algorithm is used. This basic algorithm gains two optimizations in [HNSY94]. <p> Typically, regions whose clock values are indistinguishable by the clock constraints in the program and the formula are integrated into a single zone. More work on reducing the state space is done in <ref> [SS95] </ref>, adopting the minimization algorithm of [YL93]. The model-checking algorithm TMC, suggested in [SS95], combines top-down and bottom-up reasoning. The algorithm TMC works on-the-fly and explores only a portion of the program checked, but, unlike our algorithm, TMC maintains this portion all along its execution. <p> Typically, regions whose clock values are indistinguishable by the clock constraints in the program and the formula are integrated into a single zone. More work on reducing the state space is done in <ref> [SS95] </ref>, adopting the minimization algorithm of [YL93]. The model-checking algorithm TMC, suggested in [SS95], combines top-down and bottom-up reasoning. The algorithm TMC works on-the-fly and explores only a portion of the program checked, but, unlike our algorithm, TMC maintains this portion all along its execution. Thus, the best bound to its complexity is exponential space. <p> The algorithm TMC works on-the-fly and explores only a portion of the program checked, but, unlike our algorithm, TMC maintains this portion all along its execution. Thus, the best bound to its complexity is exponential space. Maintenance of this portion and the bottom-up reasoning in <ref> [HNSY94, YL93, SS95] </ref> are essential, however, for obtaining zones that are as coarse as possible. The simple combinatorial structure that emerges from our automata-theoretic approach offers several advantages. First, automata separate the logical and the algorithmic components of the model-checking problem. <p> Instead, it refines the zone [0 x &lt; 2] into its four regions [x = 0] ; [0 &lt; x &lt; 1] ; [x = 1] ; [1 &lt; x &lt; 2]: In this sense, the algorithm in [HNSY94] and the algorithm TMC in <ref> [SS95] </ref> are more efficient than our algorithm. Why can not we integrate the four regions into a single zone as well? To answer this question, consider the linear timed automaton U 0 below. <p> Therefore, when we integrate regions together, we must get ready to every possible future, in particular to one that requires the split of the zone [0 x &lt; 2]. The optimal split performed by <ref> [HNSY94, SS95] </ref> must involve also some bottom-up reasoning, which increases worst-case space complexity. <p> The saving is more significant with respect to guards that are lower bounds (c &gt; v or c v); there, we can integrate all the time transitions up to the lower bound. 18 Finally, the saving is optimal (that is, achieves the same coarse split as in <ref> [HNSY94, SS95] </ref>) with respect to guards that are tight bounds (c = v). <p> The algorithm in [HNSY94] performs pure bottom-up reasoning (i.e., reasoning with complete look-ahead), and achieves maximal zones. Our algorithm performs pure top-down reasoning (i.e., reasoning without look ahead), and achieves space efficiency. The algorithm TMC in <ref> [SS95] </ref> combines the two savings; it proceeds on-the-fly to save space, but restricts the look-ahead to only part of the input. Naturally, for each of the algorithms we can contract problems for which the algorithm performs better than the other algorithms.
Reference: [SW89] <author> C. Stirling and D. Walker. </author> <title> Local model checking in the modal mu-calculus. </title> <booktitle> In Proc. 15th Col. on Trees in Algebra and Programming. Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: On-the-fly model-checking is strongly related to local model-checking, where we check whether a specific state of the program satisfies a specification <ref> [SW89] </ref>. The motivation for space-efficient algorithms comes from the fact that space, rather than time, is the computational bottleneck of model checking. Accordingly, in space-efficient model checking, we store in memory the minimal information required, preferring to spend time on reconstructing information rather than spend space on storing it.
Reference: [Tho90] <author> W. Thomas. </author> <title> Automata on infinite objects. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 165-191, </pages> <year> 1990. </year>
Reference-contexts: [x = 0; 1 &lt; z &lt; 2] ; 6 : [0 &lt; x &lt; 1; 1 &lt; z &lt; 2; hxi &lt; hzi] ; 7 : [0 &lt; x &lt; 1; z = 9 3.2 Alternating Automata For an introduction to the theory of automata on infinite words see <ref> [Tho90] </ref>. Alternating automata on infinite words generalize nondeterministic automata and were first introduced in [MS87]. Consider a nondeterministic word automaton with a set Q of states and a transition function M .
Reference: [VW94] <author> M.Y. Vardi and P. Wolper. </author> <title> Reasoning about infinite computations. </title> <journal> Information and Computation, </journal> <volume> 115(1) </volume> <pages> 1-37, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Like temporal logics, they come in two varieties: automata on infinite words (word automata, for short) and automata on infinite trees (tree automata). The automata-theoretic approach to temporal logic uses the theory of automata as a unifying paradigm for program specification and verification <ref> [VW94, BVW94] </ref>. In this paradigm, both the program and the specification are translated to (or are given as) automata. Linear temporal logic formulas correspond to word automata and branching temporal logic formulas correspond to tree automata. Then, questions about programs and their specifications can be reduced to questions about automata.
Reference: [YL93] <author> M. Yannakakis and D. Lee. </author> <title> An efficient algorithm for minimizing real-time transition systems. </title> <editor> In C. Courcoubetis, editor, </editor> <booktitle> Computer Aided Verification, Proc. 5th Int. Conference, volume 697 of Lecture Notes in Computer Science 697, </booktitle> <pages> pages 210-224, </pages> <address> Elounda, Crete, </address> <month> June </month> <year> 1993. </year> <booktitle> Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag. </publisher> <pages> 21 </pages>
Reference-contexts: Typically, regions whose clock values are indistinguishable by the clock constraints in the program and the formula are integrated into a single zone. More work on reducing the state space is done in [SS95], adopting the minimization algorithm of <ref> [YL93] </ref>. The model-checking algorithm TMC, suggested in [SS95], combines top-down and bottom-up reasoning. The algorithm TMC works on-the-fly and explores only a portion of the program checked, but, unlike our algorithm, TMC maintains this portion all along its execution. Thus, the best bound to its complexity is exponential space. <p> The algorithm TMC works on-the-fly and explores only a portion of the program checked, but, unlike our algorithm, TMC maintains this portion all along its execution. Thus, the best bound to its complexity is exponential space. Maintenance of this portion and the bottom-up reasoning in <ref> [HNSY94, YL93, SS95] </ref> are essential, however, for obtaining zones that are as coarse as possible. The simple combinatorial structure that emerges from our automata-theoretic approach offers several advantages. First, automata separate the logical and the algorithmic components of the model-checking problem.
References-found: 29

