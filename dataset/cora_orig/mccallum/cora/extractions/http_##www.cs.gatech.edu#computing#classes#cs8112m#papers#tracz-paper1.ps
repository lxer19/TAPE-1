URL: http://www.cs.gatech.edu/computing/classes/cs8112m/papers/tracz-paper1.ps
Refering-URL: http://www.cs.gatech.edu/computing/classes/cs8112m/wi95/
Root-URL: 
Title: A Domain-Specific Software Architecture Engineering Process Outline  
Author: Will Tracz Lou Coglianese Patrick Young 
Keyword: Domain Analysis, Domain Specific Software Architecture, Domain Engineering  
Note: software to reuse." Tracz  
Address: MD 0210 Owego, NY 13827-1298  
Affiliation: IBM Corporation Federal Systems Company  
Email: tracz@vnet.ibm.com  
Date: [9]  
Abstract: One of the dilemmas that has prevented software developers from reusing software is the lack of software artifacts to use or the existence of artifacts that are difficult to integrate. Domain-Specific Software Architectures (DSSAs) have been proposed[4] in order to address these issues. A DSSA not only provides a framework for reusable software components to fit into, but captures the design rationale and provides for a degree of adaptability. This paper 1 presents an outline for a Domain-Specific Software Architecture engineering process. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Booch. </author> <title> Software Components with Ada. </title> <address> Ben-jamin/Cummings, </address> <year> 1987. </year>
Reference-contexts: They are best suited for identifying existing reusable components or components that can serve as a basis for creating reusable components. Another option is to import reusable components from some other domain. This is possible, especially in the case of low-level data structures <ref> [1] </ref>, utilities, and user interface software. Figure 6 shows the individual steps in this process stage. Stage 5 Inputs The interface specifications generated in Stage 4 and related artifacts from existing systems are the primary inputs to this stage. Stage 5 Outputs 1.
Reference: [2] <author> K.C. Kang, S.G. Cohen, J.A. Hess, </author> <title> W.E. Novak, and A.S. Peterson. Feature-Oriented Domain Analysis (FODA) Feasibility Study. </title> <type> Technical Report CMU/SEI-90-TR-21, </type> <institution> Software Engineering Institute, </institution> <month> November </month> <year> 1990. </year>
Reference-contexts: Defense Advanced Research Projects Agency in cooperation with the US on the Reuse Library Process Model that was developed as part of the STARS (Software Technology for Adaptable and Reliable Systems) program by Ruben Prieto-Diaz [6] and the Feature-Oriented Domain Analysis (FODA) work by Kyo Kang, Sholom Cohen, et al <ref> [2] </ref> at the Software Engineering Institute (SEI) cast into the methodology supported by Requirements Driven Design tool (RDD-100) 4 and the Issue Based Information Systems (IBIS) model for recording design decisions and design rationales.
Reference: [3] <author> K.J. Lee and et al. </author> <title> An ood paradigm for flight simulators, 2nd edition. </title> <type> Technical Report CMU/SEI-88-TR-30, </type> <institution> Software Engineering Institute, </institution> <year> 1988. </year>
Reference-contexts: Existing domain-analysis processes fail to distinctly separate "problem-domain analysis" from "solution-space analysis". In particular they tend to focus on the latter rather than the former 5 . Domain-modeling processes (e.g. OCU Model <ref> [3] </ref>), on the other hand, focus on problem-domain analysis. The domain-engineering process described in this document addresses the issues raised by both domain-modeling and domain-analysis processes in the definition of a Domain-Specific Software Architecture.
Reference: [4] <author> E.G. Mettala. </author> <title> Domain Specific Software Architectures, </title> <month> June </month> <year> 1990. </year> <title> Presentation at ISTO Software Technology Community Meeting. </title>
Reference: [5] <author> R. Prieto-Diaz. </author> <title> Domain Analysis for Reusability. </title> <booktitle> In Proceedings of COMPSAC'87, </booktitle> <pages> pages 23-29, </pages> <year> 1987. </year>
Reference-contexts: A Domain-Specific Software Architecture is, in effect, a multiple-point solution to a set of application-specific requirements (which define a problem domain). Another difference between this approach to domain engineering and other domain analysis approaches (e.g., Prieto-Diaz <ref> [5] </ref>) is that case-based reasoning and reverse engineering are not central mechanisms for identifying reusable resources, but rather existing applications are used as vehicles to validate the architectures that are derived, top-down, from generalized user requirements.
Reference: [6] <author> R. Prieto-Diaz. </author> <title> Reuse Library Process Model. </title> <type> Technical Report AD-B157091, </type> <institution> IBM CDRL 03041-002, STARS, </institution> <month> July </month> <year> 1991. </year>
Reference-contexts: verifying its correctness and merit. 3 This effort is sponsored by the US Department of Defense Advanced Research Projects Agency in cooperation with the US on the Reuse Library Process Model that was developed as part of the STARS (Software Technology for Adaptable and Reliable Systems) program by Ruben Prieto-Diaz <ref> [6] </ref> and the Feature-Oriented Domain Analysis (FODA) work by Kyo Kang, Sholom Cohen, et al [2] at the Software Engineering Institute (SEI) cast into the methodology supported by Requirements Driven Design tool (RDD-100) 4 and the Issue Based Information Systems (IBIS) model for recording design decisions and design rationales. <p> This distinction is partially motivated by an observation Ruben Prieto-Diaz made in describing the Establish Global Requirements stage (A5113 Stage 1.1.3) of the STARS Domain Analysis Activities <ref> [6] </ref> relating to two kinds of requirements in an application domain: 1. Stable | ones that do not change from application to application and 2. Variable | ones do/might change.
Reference: [7] <author> W. Tracz. </author> <title> A Conceptual Model for Megaprogram-ming. </title> <journal> ACM Software Engineering Notes, </journal> <volume> 16(3) </volume> <pages> 36-45, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: The unit of abstraction that is being manipulated at 8 Addressing design and implementation constraints relate to establishing Context in the 3-C model <ref> [7] </ref>. this stage in the domain-engineering process is a model or module.
Reference: [8] <author> W. Tracz and L. Coglianese. </author> <title> Domain Engineering Process Guidelines. </title> <type> Technical Report ADAGE-IBM-92-02, </type> <institution> IBM Federal Sector Division, </institution> <month> March </month> <year> 1992. </year>
Reference-contexts: Produce/Gather Reusable Workproducts (figure 6) * Implementation/collection of reusable arti facts (e.g., code, documentation, etc.). The remaining material in this paper consist of a breakdown of the stages listed above. A detailed description of each stage is found in <ref> [8] </ref>. Each stage consists of a series of questions to be answered and a list of inputs required, outputs to be generated, and verification criteria 6 . <p> In the domain engineering process we will differentiate between general assigned activities (labeled A) and verification activities (labeled V). 6 For reasons of brevity, the verification criteria are omitted from this paper, but are found in the full report <ref> [8] </ref>. Stage 1: Define the Scope of the Domain The first phase in the domain-engineering process focuses on determining what is in the domain of interest and to what ends is this process being applied.
Reference: [9] <author> W.J. Tracz. </author> <title> Software Reuse Maxims. </title> <journal> ACM Software Engineering Notes, </journal> <volume> 13(4) </volume> <pages> 28-31, </pages> <month> October </month> <year> 1988. </year>
Reference: [10] <author> P.S. Young and R.N. Taylor. Teamware: </author> <title> Process Programming Support for Managers and Teams, </title> <month> July </month> <year> 1992. </year>
Reference-contexts: The paper closes with a description of the time-line being used to to perform the initial domain analysis (Stages 1-4 and parts of Stage 5). Process Diagram Notation The notation used in the process diagrams that follow has been developed as part of the Teamware Process Programming Language <ref> [10] </ref>. Teamware has been designed to both support specification and enactment of software processes.
References-found: 10

