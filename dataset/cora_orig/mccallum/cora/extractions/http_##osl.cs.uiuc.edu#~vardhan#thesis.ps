URL: http://osl.cs.uiuc.edu/~vardhan/thesis.ps
Refering-URL: http://osl.cs.uiuc.edu/~vardhan/
Root-URL: http://www.cs.uiuc.edu
Note: c flCopyright by Abhay Vardhan, 1998  
Abstract-found: 0
Intro-found: 1
Reference: [1] <institution> The Actor Foundry. </institution> <note> http://www-osl.cs.uiuc.edu/foundry. </note>
Reference-contexts: n in P m by p endif end Algorithm 5.2: Collector part of Schelvis' algorithm 45 Chapter 6 Implementation This chapter describes the implementation of garbage collection of actors in a distributed environment. 6.1 Underlying architecture We have implemented a garbage collector for actors in the Actor Foundry (release 0.1.8) <ref> [1] </ref>, which is an Actor system written in Java TM . The run-time environment of the Actor Foundry consists of one or more Java Virtual Machines (JVMs) running on possibly different hosts. Actors can be created on local or remote hosts and messages can be sent between actors. <p> The Actor Foundry is organized so that its different parts are required to implement certain interfaces. This enables components to be replaced with behaviorally equivalent components. interest to us are presented below. The reader is referred to <ref> [1] </ref> for details about other features of the Foundry. 6.1.1 The Actor Manager This part of the Foundry is responsible for actual management of actors.
Reference: [2] <author> G. Agha. </author> <title> Actors: A Model of Concurrent Computation in Distributed System s. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1986. </year>
Reference-contexts: The model of computation in actor systems is explained and garbage collection in both non-actor and actor systems is discussed. 2.1 Actor systems In the Actor model <ref> [2] </ref>, the universe consists of autonomous computational agents called actors that encapsulate data as well as some primitive processing power to manipulate data. Each actor has a unique mail address which can be used to communicate with that actor. Communication between actors is asynchronous with unbounded delay but guaranteed delivery.
Reference: [3] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, USA, </address> <note> second edition, </note> <year> 1998. </year>
Reference-contexts: A Java class Packet encapsulates the functionality of the timestamp packets and a Java class Globalroot contains the functions for adding and deleting edges in the global root graph and for sending and receiving timestamp packets according to Schelvis' algorithm. 6.2.1 Support from Java's garbage collector The Java programming language <ref> [3] </ref> has support for garbage collection. We cannot use this support to automatically collect garbage actors because actors have an encapsulated thread of control which always makes them non-garbage according to the semantics of Java.
Reference: [4] <author> Lex Augusteijn. </author> <title> Garbage collection in a distributed environment. </title> <editor> In de Bakker et al. </editor> <volume> [10], </volume> <pages> pages 75-93. </pages>
Reference-contexts: All the hosts must come to an agreement that the mark phase has completed before the sweep can be begun. This makes this scheme difficult to scale. It is also not resilient to network partitions and host crashes as it relies on the cooperation of all the processors. Augusteijn <ref> [4] </ref> presents an algorithm based on an incremental three-color mark-sweep algorithm applied to a distributed object system. Juul [15] proposes another distributed version of 13 the incremental mark-sweep algorithm. The protocol to determine the termination of the mark phase is described as a two-phase commit protocol.
Reference: [5] <author> Ozalp Babaoglu and Keith Marzullo. </author> <title> Consistent global states of distributed systems: Fundamental concepts and mechanisms. </title> <editor> In S. Mullender, editor, </editor> <booktitle> Distributed Systems, </booktitle> <pages> pages 55-96. </pages> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Since there is no omniscient observer in a distributed system, a global snapshot is usually constructed by taking a consistent cut of the global state and accounting for any messages in transit in the network. The reader is referred to <ref> [5, 34] </ref> for details. However, such a "global-snapshot" approach requires synchronization among all the hosts in the system which raises questions about scalability. For this reason, most algorithms try to avoid taking a global-snapshot. 35 There are several other algorithms available in the literature as described in Chapter 3.
Reference: [6] <editor> Yves Bekkers and Jacques Cohen, editors. </editor> <booktitle> Proceedings of International Workshop on Memory Management, volume 637 of Lecture Notes in Computer Science, </booktitle> <address> St Malo, France, 16-18 September 1992. </address> <publisher> Springer-Verlag. </publisher>
Reference: [7] <author> David I. Bevan. </author> <title> Distributed garbage collection using reference counting. </title> <booktitle> In PARLE Parallel Architectures and Languages Europe, volume 259 of Lecture Notes in Computer Science, </booktitle> <pages> pages 176-187. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: Therefore naive versions of reference counting would have race conditions which might lead to incorrect garbage collection. To solve this, many algorithms have been presented. 3.2.1.1 Weighted Reference Counting Bevan <ref> [7] </ref> and Watson and Watson [39] independently proposed the use of Weighted Reference Counting (WRC). In this scheme, each reference to an object is associated with a weight instead of a simple count of 1 as in the case of reference counting.
Reference: [8] <author> Andrew Birrell, David Evers, Greg Nelson, Susan Owicki, and Edward Wobber. </author> <title> Distributed garbage collection for network objects. </title> <type> Technical Report 116, </type> <institution> DEC Systems Research Center, </institution> <address> 130 Lytton Avenue, Palo Alto, CA 94301, </address> <month> December </month> <year> 1993. </year> <month> 57 </month>
Reference-contexts: This improves resilience to message and space failures at the cost of some memory overhead. Shapiro et al [35] and Birrel <ref> [8] </ref> use this technique for distributed garbage collection. 12 3.2.2 Hybrid techniques Reference counting and reference listing are unable to collect cyclic garbage but they do not require synchronization among processors and are scalable.
Reference: [9] <author> Peter B. Bishop. </author> <title> Computer systems with a very large address space and garbage collection. </title> <institution> MIT Report LCS/TR-178, Laboratory for Computer Science, MIT, </institution> <address> Cambridge, MA., </address> <month> May </month> <year> 1977. </year>
Reference-contexts: Some techniques propose running a distributed tracing algorithm at a low frequency in addition to the reference counting techniques to reclaim cyclic garbage. Bishop <ref> [9] </ref> proposes an object migration technique where objects suspected of belonging to a garbage cycle are migrated to a single node where they can be collected by a cyclic local garbage collector. Rodriguez-Rivera [32] proposes an algorithm based on reference listing augmented with back tracing.
Reference: [10] <editor> Jacobus W. de Bakker, L. Nijman, and Philip C. Treleaven, editors. </editor> <booktitle> PARLE'87 Parallel Architectures and Languages Europe, volume 258/259 of Lecture Notes in Computer Science, </booktitle> <address> Eindhoven, The Netherlands, June 1987. </address> <publisher> Springer-Verlag. </publisher>
Reference: [11] <author> Peter Dickman. </author> <title> Optimising weighted reference counts for scalable fault-tolerant distributed object-support systems, </title> <year> 1992. </year>
Reference-contexts: T otalW eight = X P artialW eights The main problem with WRC (apart from the inherent shortcomings of reference counting) is that there is a possibility of underflow of the weights. Dickman <ref> [11] </ref> proposed an optimized version of WRC which makes it resilient to message loss and handles the problem of underflow. 3.2.1.2 Indirect reference counting Piquer [28] proposed Indirect Reference Counting as an alternative to naive reference counting.
Reference: [12] <author> Peter Dickman. </author> <title> Incremental, distributed orphan detection and actor garbage collection using graph partitioning and euler cycles. </title> <editor> In Ozalp Babaoglu and Keith Marzullo, editors, </editor> <booktitle> Tenth International Workshop on Distributed Algorithms WDAG'96, volume 1151 of Lecture Notes in Computer Science, </booktitle> <address> Bologna, </address> <month> October </month> <year> 1996. </year> <note> Springer-Verlag. </note>
Reference-contexts: Based on these timestamps the global collector can decide if a consistent vision of the global distributed graph has been formed, and proceeds to garbage collect only in the case that consistency has been achieved. In a recent paper, Dickman <ref> [12] </ref> presents an interesting algorithm called the Partition Merging algorithm (PMA). A key idea of the algorithm is that all actors reachable from an unblocked actor (including the unblocked actor itself) have the same garbage status.
Reference: [13] <author> R. John M. Hughes. </author> <title> A distributed garbage collection algorithm. </title> <editor> In Jean-Pierre Jouan-naud, editor, </editor> <booktitle> Record of the 1985 Conference on Functional Programming and Computer Architecture, volume 201 of Lecture Notes in Computer Science, </booktitle> <pages> pages 256-272, </pages> <address> Nancy, France, </address> <month> September </month> <year> 1985. </year> <note> Springer-Verlag. </note>
Reference-contexts: The local garbage collector periodically queries the global garbage collection service about the elements of its alleged roots that are no longer remotely reachable. Hughes <ref> [13] </ref> describes an appealing algorithm where mark bits are replaced by timestamps. The key idea is that a garbage object's timestamp remains constant whereas a non-garbage object timestamp increases monotonically. A global threshold is computed and any object whose timestamp is lower than the threshold is recognized as garbage.
Reference: [14] <author> Richard E. Jones. </author> <title> Garbage Collection: Algorithms for Automatic Dynamic Memory Management. </title> <publisher> Wiley, </publisher> <month> July </month> <year> 1996. </year> <title> With a chapter on Distributed Garbage Collection by R. </title> <type> Lins. </type>
Reference-contexts: An excellent survey of uniprocessor garbage collection techniques is given by Wilson [40]. Algorithms for garbage collection for both uniprocessors and distributed systems are described by Jones in <ref> [14] </ref>.
Reference: [15] <author> Neils-Christian Juul and Eric Jul. </author> <title> Comprehensive and robust garbage collection in a distributed system. </title> <note> In Bekkers and Cohen [6]. </note>
Reference-contexts: This makes this scheme difficult to scale. It is also not resilient to network partitions and host crashes as it relies on the cooperation of all the processors. Augusteijn [4] presents an algorithm based on an incremental three-color mark-sweep algorithm applied to a distributed object system. Juul <ref> [15] </ref> proposes another distributed version of 13 the incremental mark-sweep algorithm. The protocol to determine the termination of the mark phase is described as a two-phase commit protocol. Ladin and Liskov [19] propose an algorithm that relies on a logically centralized global garbage detection service.
Reference: [16] <author> Dennis Kafura, Manibrata Mukherji, and Doug Washabaugh. </author> <title> Concurrent and distributed garbage collection of active objects. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 6(4), </volume> <month> April </month> <year> 1995. </year>
Reference-contexts: Washabaugh [38] has described a real-time and distributed version of actor garbage collection based on the Push-Pull and Is-Black algorithms. In a more recent paper, Kafura et al <ref> [16] </ref> have described in detail a distributed version of the Push-Pull algorithm. Local garbage collection at different hosts is allowed to proceed independently. A distributed global collector is invoked for collecting garbage not recognizable by the local collectors.
Reference: [17] <author> Dennis Kafura, Doug Washabaugh, and Jeff Nelson. </author> <title> Garbage collection of actors. </title> <editor> In Norman Meyrowitz, editor, </editor> <booktitle> OOPSLA'90 ACM Conference on Object-Oriented Systems, Languages and Applications, volume 25(10) of ACM SIGPLAN Notices, </booktitle> <pages> pages 126-134, </pages> <address> Ottawa, Ontario, </address> <month> October </month> <year> 1990. </year> <note> ACM Press. 58 </note>
Reference-contexts: But before we describe that, we review the existing algorithms that have been formulated for actors. A formal definition of garbage actors was first given by Kafura <ref> [17] </ref>.
Reference: [18] <author> Tomio Kamada, Satoshi Matsuoka, and Akinori Yonezawa. </author> <title> Efficient parallel global garbage collection on massively parallel computers. </title> <editor> In Eliot Moss, Paul R. Wilson, and Benjamin Zorn, editors, </editor> <booktitle> OOPSLA/ECOOP '93 Workshop on Garbage Collection in Object-Oriented Systems, </booktitle> <month> October </month> <year> 1993. </year>
Reference-contexts: Instead of using the terms touched, suspended and untouched 17 for different possible states of actors, we use the terms black, gray and white respectively to remain consistent with Kafura's terminology. A garbage collector for active objects in an MPP environment has been described by Kamada <ref> [18] </ref>. In this work, all active objects are considered live. An interesting feature of their algorithm is the use of a centralized agent which handles many problems related to synchronization and detection of termination of various phases of the garbage collection.
Reference: [19] <author> Rivka Ladin and Barbara Liskov. </author> <title> Garbage collection of a distributed heap. </title> <booktitle> In International Conference on Distributed Computing Systems, </booktitle> <address> Yokohama, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Juul [15] proposes another distributed version of 13 the incremental mark-sweep algorithm. The protocol to determine the termination of the mark phase is described as a two-phase commit protocol. Ladin and Liskov <ref> [19] </ref> propose an algorithm that relies on a logically centralized global garbage detection service. The service may be physically replicated for higher availability. Each site maintains a list of objects that have been referenced from other sites. These are treated as roots for local garbage collection.
Reference: [20] <author> Bernard Lang, Christian Quenniac, and Jose Piquer. </author> <title> Garbage collecting the world. </title> <booktitle> In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, ACM SIGPLAN Notices, </booktitle> <pages> pages 39-50. </pages> <publisher> ACM Press, </publisher> <month> January </month> <year> 1992. </year>
Reference-contexts: They use a logical clock to timestamp events. A reference-listing-based algorithm is used to collect acyclic distributed garbage and the timestamp algorithm can be invoked to collect the cyclic part of the garbage. Lang, Queinnec and Piquer <ref> [20] </ref> suggests combining reference counting and mark-sweep in order to perform garbage collection within groups. A group is a dynamic collection of spaces which are built by group negotiation. Mark-sweep is carried out within the group and reference counting is used to collect objects whose references cross groups.
Reference: [21] <author> Fabrice Le Fessant, Ian Piumarta, and Marc Shapiro. </author> <title> An implementation for complete asynchronous distributed garbage collection. </title> <booktitle> In Proceedings of SIGPLAN'98 Conference on Programming Languages Design and Implementation, ACM SIGPLAN Notices, </booktitle> <address> Montreal, June 1998. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The key idea is that a garbage object's timestamp remains constant whereas a non-garbage object timestamp increases monotonically. A global threshold is computed and any object whose timestamp is lower than the threshold is recognized as garbage. Fessant et al <ref> [21] </ref> present an algorithm based on Hughes' algorithm in a simplified form that makes fewer assumptions about the distributed system. They use a logical clock to timestamp events.
Reference: [22] <author> Sylvain Louboutin and Vinny Cahill. </author> <title> A lazy log-keeping mechanism for comprehensive global garbage detection on Amadeus. </title> <booktitle> In OOIS (Object-Oriented Information Systems) '95, </booktitle> <pages> pages 118-132, </pages> <address> London, </address> <month> December </month> <year> 1995. </year> <note> Springer-Verlag. Technical report TCD-CS-95-11. </note>
Reference-contexts: The algorithm does not require any synchronization among different processors but is still able to collect all garbage. We have used this algorithm in our implementation of global garbage collection. The details are presented in Section 5.7. Louboutin <ref> [23, 24, 22] </ref> presents an interesting algorithm which is able to collect all distributed garbage by tracking causal dependencies of relevant mutator events. Each host performs its local garbage collection independently and builds a global root graph which is the entrance graph in Schelvis' terminology described in the previous paragraph.
Reference: [23] <author> Sylvain R.Y. Louboutin. </author> <title> A Reactive Approach to Comprehensive Global Garbage Detection. </title> <type> PhD thesis, </type> <institution> Trinity College, </institution> <address> Dublin, </address> <year> 1998. </year> <note> In preparation. </note>
Reference-contexts: The algorithm does not require any synchronization among different processors but is still able to collect all garbage. We have used this algorithm in our implementation of global garbage collection. The details are presented in Section 5.7. Louboutin <ref> [23, 24, 22] </ref> presents an interesting algorithm which is able to collect all distributed garbage by tracking causal dependencies of relevant mutator events. Each host performs its local garbage collection independently and builds a global root graph which is the entrance graph in Schelvis' terminology described in the previous paragraph. <p> It appears that Schelvis' algorithm has some unique features and advantages but it has not been used much in the garbage collection community. Recently, Louboutin <ref> [23] </ref> has proposed a reactive algorithm with similar features, but a few implementation issues are not resolved, as mentioned in Section 3.2.4. <p> The parameter a is dropped when it is clear from the context. Objects referenced from outside the host are called global roots following the terminology of Louboutin <ref> [23] </ref>. The set of global roots consists of the COs and the M Qs of any actors referenced from outside and the M Qs of actors which reference any actor outside (because the M Q of the remote actor would reference the M Q of the local actor). <p> A mark-sweep algorithm is used for local garbage collection. 5.3 Global root graph The concept of a global root graph has been borrowed from Louboutin <ref> [23] </ref>. The vertices of this graph consist of the global roots of all hosts and local roots of some hosts. The local roots that 37 are included in the set of vertices are only those from which a path exists to a remote object.
Reference: [24] <author> Sylvain R.Y. Louboutin and Vinny Cahill. </author> <title> Comprehensive distributed garbage collection by tracking causal dependencies of relevant mutator events. </title> <booktitle> In Proceedings of ICDCS'97 International Conference on Distributed Computing Systems. </booktitle> <publisher> IEEE Press, </publisher> <year> 1997. </year>
Reference-contexts: The algorithm does not require any synchronization among different processors but is still able to collect all garbage. We have used this algorithm in our implementation of global garbage collection. The details are presented in Section 5.7. Louboutin <ref> [23, 24, 22] </ref> presents an interesting algorithm which is able to collect all distributed garbage by tracking causal dependencies of relevant mutator events. Each host performs its local garbage collection independently and builds a global root graph which is the entrance graph in Schelvis' terminology described in the previous paragraph.
Reference: [25] <author> Umesh Maheshwari and Barbara Liskov. </author> <title> Collecting cyclic distributed garbage by back tracing. </title> <booktitle> In Proceedings of PODC'97 Principles of Distributed Computing, </booktitle> <year> 1997. </year>
Reference-contexts: For an object suspected to be garbage, the algorithm recursively traces back the references to find the transitive closure of objects that reach the suspect. If this closure does not contain any root, the objects in the closure are recognized as garbage. A similar approach is followed by Maheshwari <ref> [25] </ref>. Rodriguez [31] suggests an algorithm based on reference listing with partial tracing in order to collect cyclic garbage. Tracing is initiated at an object suspected to be a part of a garbage cycle.
Reference: [26] <author> Khayri A. Mohamed-Ali. </author> <title> Object Oriented Storage Management and Garbage Collection in Distributed Processing Systems. </title> <type> PhD thesis, </type> <institution> Royal Institute of Technology, Stockholm, </institution> <month> December </month> <year> 1984. </year> <month> 59 </month>
Reference-contexts: A group is a dynamic collection of spaces which are built by group negotiation. Mark-sweep is carried out within the group and reference counting is used to collect objects whose references cross groups. Scalability of the garbage collector is achieved through a hierarchy of nested groups. Ali <ref> [26] </ref> presents an algorithm that allows each processor to mark-sweep its own heap independently.
Reference: [27] <author> Jeffrey E. Nelson. </author> <title> Automatic, incremental, on-the-fly garbage collection of actors. </title> <type> Master's thesis, </type> <institution> Virginia Polytechnic Institute and State University, </institution> <year> 1989. </year>
Reference-contexts: Nelson <ref> [27] </ref> formulated certain coloring rules to identify actor garbage. These are given in Algorithm 3.1. 1. All actors are colored white, with the exception of root actors which are colored black. 2.
Reference: [28] <author> Jose M. Piquer. </author> <title> Indirect reference counting: A distributed garbage collection algorithm. </title> <editor> In Aarts et al., editors, </editor> <booktitle> PARLE'91 Parallel Architectures and Languages Europe, volume 505 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: Dickman [11] proposed an optimized version of WRC which makes it resilient to message loss and handles the problem of underflow. 3.2.1.2 Indirect reference counting Piquer <ref> [28] </ref> proposed Indirect Reference Counting as an alternative to naive reference counting. In this algorithm, each remote reference for a non resident object has two fields associated with it. One is a counter and the other is a pointer.
Reference: [29] <author> Isabelle Puaut. </author> <title> Distributed garbage collection of active objects with no global synchroni-sation. </title> <note> In Bekkers and Cohen [6]. </note>
Reference-contexts: In this work, all active objects are considered live. An interesting feature of their algorithm is the use of a centralized agent which handles many problems related to synchronization and detection of termination of various phases of the garbage collection. Puaut <ref> [29, 30] </ref> presents an algorithm comprising of independent local collectors loosely coupled to a global collector. The global collector is a logically centralized service that maintains a graph which is a merge of subgraphs sent by the local garbage collectors.
Reference: [30] <author> Isabelle Puaut. </author> <title> A distributed garbage collector for active objects. </title> <booktitle> In PARLE'94 Parallel Architectures and Languages Europe, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year> <note> Also INRIA UCIS-DIFUSION RR 2134. </note>
Reference-contexts: In this work, all active objects are considered live. An interesting feature of their algorithm is the use of a centralized agent which handles many problems related to synchronization and detection of termination of various phases of the garbage collection. Puaut <ref> [29, 30] </ref> presents an algorithm comprising of independent local collectors loosely coupled to a global collector. The global collector is a logically centralized service that maintains a graph which is a merge of subgraphs sent by the local garbage collectors.
Reference: [31] <author> Helena C. C. D. Rodrigues and Richard E. Jones. </author> <title> Cyclic distributed garbage collection with group merger. </title> <editor> In Erik Jul, editor, </editor> <booktitle> Proceedings of 12th European Conference on Object-Oriented Programming, ECOOP98, Lecture Notes in Computer Science, </booktitle> <pages> pages 249-273, </pages> <address> Brussels, </address> <month> July </month> <year> 1998. </year> <note> Springer-Verlag. Also UKC Technical report 17-97, </note> <month> December </month> <year> 1997. </year>
Reference-contexts: If this closure does not contain any root, the objects in the closure are recognized as garbage. A similar approach is followed by Maheshwari [25]. Rodriguez <ref> [31] </ref> suggests an algorithm based on reference listing with partial tracing in order to collect cyclic garbage. Tracing is initiated at an object suspected to be a part of a garbage cycle.
Reference: [32] <author> Gustavo Rodriguez-Riviera and Vince Russo. </author> <title> Cyclic distributed garbage collection without global synchronization in CORBA. </title> <editor> In Peter Dickman and Paul R. Wilson, editors, </editor> <booktitle> OOPSLA '97 Workshop on Garbage Collection and Memory Management, </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: Bishop [9] proposes an object migration technique where objects suspected of belonging to a garbage cycle are migrated to a single node where they can be collected by a cyclic local garbage collector. Rodriguez-Rivera <ref> [32] </ref> proposes an algorithm based on reference listing augmented with back tracing. For an object suspected to be garbage, the algorithm recursively traces back the references to find the transitive closure of objects that reach the suspect.
Reference: [33] <author> M. Schelvis. </author> <title> Incremental distribution of timestamp packets | a new approach to distributed garbage collection. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(10) </volume> <pages> 37-48, </pages> <year> 1989. </year>
Reference-contexts: At the end of a local garbage collection, the processor informs all other processors of the remote pointers that it retains, so that they may treat the corresponding objects as roots in their own local garbage collection. This algorithm is unable to collect global cycles. 3.2.4 Other algorithms Schelvis <ref> [33] </ref> proposed a comprehensive global garbage collection algorithm based on time-stamp packet distribution. In this algorithm, a table called an entrance table is kept of all the local 14 objects that are remotely referenced. These are included in the root set for local garbage collection. <p> For this reason, most algorithms try to avoid taking a global-snapshot. 35 There are several other algorithms available in the literature as described in Chapter 3. We have chosen to adapt Schelvis' <ref> [33] </ref> work for garbage collection of actors. <p> Similarly receive (m,p,n) refers to the computation done in response to receiving a timestamp packet p from global root m by global root n. For more details regarding Schelvis' algorithm and for a proof of its correctness, the reader is referred to Schelvis <ref> [33] </ref>. All nodes n have the empty packet * in P n . The packets are computed in a manner such that the following invariants are preserved. <p> There exist actor garbage collectors which do not maintain inverse acquaintances. However, as discussed in section 4.4, in certain cases maintaining inverse acquaintances can reduce the effort required for garbage collection drastically. Using the transformation technique described in Chapter 4, a previously described algorithm (Schelvis <ref> [33] </ref> for garbage collection in object oriented systems has been adapted for collecting garbage actors in a distributed environment. The algorithm has been implemented on an actor system based on Java.
Reference: [34] <author> Reinhard Schwarz and Friedemann Mattern. </author> <title> Detecting Causal Relationships in Distributed Computations: In Search of the Holy Grail. </title> <journal> Distributed Computing, </journal> <volume> 7(3) </volume> <pages> 149-174, </pages> <year> 1994. </year>
Reference-contexts: Since there is no omniscient observer in a distributed system, a global snapshot is usually constructed by taking a consistent cut of the global state and accounting for any messages in transit in the network. The reader is referred to <ref> [5, 34] </ref> for details. However, such a "global-snapshot" approach requires synchronization among all the hosts in the system which raises questions about scalability. For this reason, most algorithms try to avoid taking a global-snapshot. 35 There are several other algorithms available in the literature as described in Chapter 3.
Reference: [35] <author> Marc Shapiro, Peter Dickman, and David Plainfosse. </author> <title> SSP chains: Robust, distributed references supporting acyclic garbage collection. </title> <institution> Rapports de Recherche 1799, Institut National de la Recherche en Informatique et Automatique, </institution> <month> November </month> <year> 1992. </year> <note> Also available as Broadcast Technical Report 1. </note>
Reference-contexts: This improves resilience to message and space failures at the cost of some memory overhead. Shapiro et al <ref> [35] </ref> and Birrel [8] use this technique for distributed garbage collection. 12 3.2.2 Hybrid techniques Reference counting and reference listing are unable to collect cyclic garbage but they do not require synchronization among processors and are scalable.
Reference: [36] <author> Nalini Venkatasubramanian, Gul Agha, and Carolyn Talcott. </author> <title> Hierarchical garbage collection in scalable distributed systems. </title> <type> Technical Report UIUCDCS-R-92-1740, </type> <institution> Dept. of Computer Science, University of Illinois at Urbana-Champaign, </institution> <month> April </month> <year> 1992. </year> <month> 60 </month>
Reference-contexts: The garbage collector is able to collect cycles of active actors which cannot send any message to any live actor. A hierarchical distributed garbage collection algorithm is described by Venkatasubramanian et al <ref> [36, 37] </ref>. An approach similar to mark-sweep is followed with specialized marking rules which are formulated according to the definition of garbage in actors. A fixed network topology is assumed. A broadcast to all hosts initiates the process of garbage collection. <p> This gives us a simple algorithm for garbage collection of actors based on mark-sweep. A close look at this algorithm reveals that it is very similar to a known algorithm for garbage collection of actors as given by Venkata-subramanian <ref> [36] </ref>. This algorithm is described in Figure 3.2 on page 19. We can see that there is a correspondence between Venkatasubramanian's algorithm and our mark-sweep on the object-reference graph.
Reference: [37] <author> Nalini Venkatasubramanian, Gul Agha, and Carolyn Talcott. </author> <title> Scalable distributed garbage collection for systems of active objects. </title> <booktitle> In Bekkers and Cohen [6], </booktitle> <pages> pages 134-147. </pages>
Reference-contexts: The garbage collector is able to collect cycles of active actors which cannot send any message to any live actor. A hierarchical distributed garbage collection algorithm is described by Venkatasubramanian et al <ref> [36, 37] </ref>. An approach similar to mark-sweep is followed with specialized marking rules which are formulated according to the definition of garbage in actors. A fixed network topology is assumed. A broadcast to all hosts initiates the process of garbage collection.
Reference: [38] <author> Douglas Markham Washabaugh. </author> <title> Real-time garbage collection of actors in a distributed system. </title> <type> Master's thesis, </type> <institution> Virginia Polytechnic Institute and State University, </institution> <year> 1989. </year>
Reference-contexts: If a black actor is found, then the originating actor is colored black. Both these algorithms have a space complexity of Order (N ) and time complexity of Order (N 2 ) where N is the number of actors in the system. Washabaugh <ref> [38] </ref> has described a real-time and distributed version of actor garbage collection based on the Push-Pull and Is-Black algorithms. In a more recent paper, Kafura et al [16] have described in detail a distributed version of the Push-Pull algorithm. Local garbage collection at different hosts is allowed to proceed independently.
Reference: [39] <author> Paul Watson and Ian Watson. </author> <title> An efficient garbage collection scheme for parallel computer architectures. </title> <editor> In de Bakker et al. </editor> <volume> [10], </volume> <pages> pages 432-443. </pages>
Reference-contexts: Therefore naive versions of reference counting would have race conditions which might lead to incorrect garbage collection. To solve this, many algorithms have been presented. 3.2.1.1 Weighted Reference Counting Bevan [7] and Watson and Watson <ref> [39] </ref> independently proposed the use of Weighted Reference Counting (WRC). In this scheme, each reference to an object is associated with a weight instead of a simple count of 1 as in the case of reference counting.
Reference: [40] <author> Paul R. Wilson. </author> <title> Uniprocessor garbage collection techniques. </title> <type> Technical report, </type> <institution> University of Texas, </institution> <month> January </month> <year> 1994. </year> <note> Expanded version of the IWMM92 paper. 61 </note>
Reference-contexts: To introduce some concepts common for all garbage collection algorithms, we start by considering uniprocessor garbage collection. 3.1 Uniprocessor garbage collection The problem of garbage collection in uniprocessors has been well studied. An excellent survey of uniprocessor garbage collection techniques is given by Wilson <ref> [40] </ref>. Algorithms for garbage collection for both uniprocessors and distributed systems are described by Jones in [14].
References-found: 40

