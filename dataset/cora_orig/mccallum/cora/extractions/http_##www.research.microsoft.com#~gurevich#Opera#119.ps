URL: http://www.research.microsoft.com/~gurevich/Opera/119.ps
Refering-URL: http://www.research.microsoft.com/~gurevich/annotated.html
Root-URL: http://www.research.microsoft.com
Email: gurevich@umich.edu)  masp@informatik.rwth-aachen.de)  
Title: Recursive Abstract State Machines  
Author: Yuri Gurevich Marc Spielmann 
Address: USA  Aachen, Germany  
Affiliation: (University of Michigan,  (RWTH  
Abstract: According to the ASM thesis, any algorithm is essentially a Gurevich abstract state machine. The only objection to this thesis, at least in its sequential version, has been that ASMs do not capture recursion properly. To this end, we suggest recursive ASMs. Key Words: abstract state machines, recursion, distributed computations, concur-rency Category: F.1.1, F.1.2 
Abstract-found: 1
Intro-found: 1
Reference: [Borger 95] <author> E. Borger. </author> <title> Annotated bibliography on evolving algebras. </title> <editor> In E. Borger, editor, </editor> <booktitle> Specification and Validation Methods, </booktitle> <pages> pages 37-51. </pages> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: 1 Introduction The abstract state machine (formerly evolving algebra) thesis [Gurevich 91] asserts that abstract state machines (ASMs, for brevity) express algorithms on their natural level of abstraction in a direct and coding-free manner. The thesis is supported by a wide spectrum of applications <ref> [Borger 95] </ref>, [Castillo 96], [Huggins 96]. However, some people have objected that ASMs are iterative in their nature, whereas many algorithms (e.g., Divide and Conquer) are naturally recursive. In many cases recursion is concise, elegant, and inherent to the algorithm.
Reference: [Castillo 96] <author> G. D. Castillo. </author> <title> WWW page Evolving Algebras Europe, </title> <note> http://www.uni-paderborn.de/Informatik/eas.html, May 96. </note>
Reference-contexts: 1 Introduction The abstract state machine (formerly evolving algebra) thesis [Gurevich 91] asserts that abstract state machines (ASMs, for brevity) express algorithms on their natural level of abstraction in a direct and coding-free manner. The thesis is supported by a wide spectrum of applications [Borger 95], <ref> [Castillo 96] </ref>, [Huggins 96]. However, some people have objected that ASMs are iterative in their nature, whereas many algorithms (e.g., Divide and Conquer) are naturally recursive. In many cases recursion is concise, elegant, and inherent to the algorithm.
Reference: [Dexter, Doyle, Gurevich 97] <author> S. Dexter, P. Doyle, and Y. Gurevich. </author> <title> Gurevich abstract state machines and schonhage storage modification machines. </title> <type> Technical Report CSE-TR-326-97, </type> <institution> University of Michigan, </institution> <year> 1997. </year> <note> Also in this volume. </note>
Reference-contexts: endchoose endimport where every remaining import and choose in fl main (x; y) occurs in a vary rule, and the variables in x; y are disjoint and do not occur bounded in fl main (x; y). (This special form can be obtained, e.g., by the First Normal Form procedure of <ref> [Dexter, Doyle, Gurevich 97] </ref> extended by a second round to push out choose rules in the same way as import rules in the first round.
Reference: [Gurevich 91] <author> Y. Gurevich. </author> <title> Evolving Algebras: An attempt to discover semantics. </title> <journal> Bulletin of the EATCS, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <year> 1991. </year> <note> A slightly revised version in G. </note> <editor> Rozenberg and A. Salomaa, editors, </editor> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <pages> pages 266-292, </pages> <publisher> World Scientific, </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction The abstract state machine (formerly evolving algebra) thesis <ref> [Gurevich 91] </ref> asserts that abstract state machines (ASMs, for brevity) express algorithms on their natural level of abstraction in a direct and coding-free manner. The thesis is supported by a wide spectrum of applications [Borger 95], [Castillo 96], [Huggins 96].
Reference: [Gurevich 95] <author> Y. Gurevich. </author> <title> Evolving Algebras 1993: Lipari Guide. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: Building upon this idea, we suggest a definition of recursive ASMs. The implicit use of distributed computing has an important side benefit: it leads naturally to concurrent recursion. In addition, we reduce recursive ASMs to distributed ASMs as described in the Lipari guide <ref> [Gurevich 95] </ref>. If desired, one can view recursive notation as mere abbreviation. 1 Partially supported by NSF grant CCR 95-04375 and ONR grant N00014-94-1-1182. 2 Visiting scholar at the University of Michigan, partially supported by DAAD and The University of Michigan. The paper is organized as follows. <p> As a result, the model becomes non-deterministic. Finally, in [Section 4] we restrict the general model of [Section 3] so that global functions can be changed but determinism is ensured by sequential execution of recursive calls. Conventions The paper is based on the Lipari guide <ref> [Gurevich 95] </ref> and uses some additional conventions. The executor of a one-agent ASM starts in an initial state with Mode = Initial and halts when Mode = Final. <p> In the case of slave agents, the Mode function is actually a unary function Mode (Me). (The distinction between master and slave agents is mostly didactic.) As usual, the semantics of distributed ASMs is given by the class of possible runs <ref> [Gurevich 95] </ref>. Notice that in general this semantics is non-deterministic; different finite runs may lead to different final states. <p> Optionally, one may indicate the type of any Arg ij or the type of F i . A type is nothing but a universe <ref> [Gurevich 95] </ref>. All types in rec should be universes of main . Notice that type errors can be checked by additional guards. 2 The definition easily generalizes to the case where, instead of main , one has a collection of such one-agent programs.
Reference: [Huggins 96] <author> J. K. Huggins. </author> <title> WWW page Abstract State Machines (Evolving Algebras), </title> <note> http://www.eecs.umich.edu/ealgebras, September 1996. </note>
Reference-contexts: 1 Introduction The abstract state machine (formerly evolving algebra) thesis [Gurevich 91] asserts that abstract state machines (ASMs, for brevity) express algorithms on their natural level of abstraction in a direct and coding-free manner. The thesis is supported by a wide spectrum of applications [Borger 95], [Castillo 96], <ref> [Huggins 96] </ref>. However, some people have objected that ASMs are iterative in their nature, whereas many algorithms (e.g., Divide and Conquer) are naturally recursive. In many cases recursion is concise, elegant, and inherent to the algorithm.
Reference: [Lucas 96] <author> E. </author> <title> Lucas. </title> <journal> Recreations mathematiques, </journal> <volume> volume 3, </volume> <pages> pages 55-59. </pages> <note> Gauthier-Villars et fils, Paris, 1891-1896. Reprinted by A. Blanchard, Paris, </note> <year> 1960. </year>
Reference-contexts: In this case a deterministic, sequential evaluation is ensured. Only one agent works, whereas all other agents wait in a hierarchical dependency. Example 4.1 (The Towers of Hanoi). The well-known Towers of Hanoi problem <ref> [Lucas 96] </ref> is purely sequential: our task is to instruct the player how to move a pile of disks of decreasing size from one peg to another using at most 3 pegs in such a way that at no point a larger disk rests on a smaller one.
Reference: [Savitch 70] <author> W. J. Savitch. </author> <title> Relational between nondeterministic and deterministic tape complexity. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 4 </volume> <pages> 177-192, </pages> <year> 1970. </year> <title> Acknowledgements. Thanks to the anonymous referees. This article was processed using the L A T E X macro package with JUCS style </title>
Reference-contexts: To prove Pspace = NPspace, Wal-ter Savitch has suggested the following recursive algorithm for the REACHA-BILITY decision problem, which works in space log 2 (GraphSize). Some familiarity with Savitch's solution <ref> [Savitch 70] </ref> would be hepful for the reader. (We assume that the input is an ordered graph with constants FirstNode and LastNode, and a unary node-successor function Succ): if Mode = Initial then Output := Reach (StartNode; GoalNode; log (GraphSize)) Mode := Final endif rec Reach (From; To : node; l
References-found: 8

