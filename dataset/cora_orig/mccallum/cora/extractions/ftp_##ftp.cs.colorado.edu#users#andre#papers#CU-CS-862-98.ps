URL: ftp://ftp.cs.colorado.edu/users/andre/papers/CU-CS-862-98.ps
Refering-URL: http://www.cs.colorado.edu/~andre/papers.html
Root-URL: http://www.cs.colorado.edu
Email: fandre,dennis,alwg@cs.colorado.edu  
Title: Investigating the Applicability of Architecture Description in Configuration Management and Software Deployment  
Author: Andre van der Hoek, Dennis Heimbigner, and Alexander L. Wolf 
Address: Boulder, CO 80309 USA  
Affiliation: Software Engineering Research Laboratory Department of Computer Science University of Colorado  
Abstract: University of Colorado Department of Computer Science Technical Report CU-CS-862-98 September 1998 ABSTRACT The discipline of software architecture has traditionally been concerned with high-level design. In particular, a variety of architecture description languages have been developed that are used to precisely capture a design. Additionally, analysis tools have been constructed that are used to verify particular properties of a design. However, today's trend towards the development of component-based software seems to suggest a new use of software architecture. Because an architecture captures components and the connections among them, it could potentially be used as an organizing abstraction for many of the activities in the software life cycle. In this paper we present an initial investigation into the feasibility of such use. In particular, we closely examine the role system modeling plays in the fields of configuration management and software deployment, and relate this role to the system modeling capabilities of architecture description languages. The outcome of this investigation is twofold. First, we conclude that, for the specific cases of configuration management and software deployment, the use of software architecture brings opportunities to significantly extend the provided functionality. Second, we present requirements for a number of extensions to typical architecture description languages that are needed to make our approach viable. This work was supported in part by the Air Force Materiel Command, Rome Laboratory, and the Defense Advanced Research Projects Agency under Contract Numbers F30602-94-C-0253 and F30602-98-2-0163. The content of the information does not necessarily reflect the position or the policy of the Government and no official endorsement should be inferred. c fl 1998 Andre van der Hoek, Dennis Heimbigner, and Alexander L. Wolf
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Allen and D. Garlan. </author> <title> A Formal Basis for Architectural Connection. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 6(3) </volume> <pages> 213-249, </pages> <month> July </month> <year> 1997. </year>
Reference-contexts: A large variety of languages have been created, and each language has its particular strengths and weaknesses. Besides being able to model the components and interconnections of a system, some languages allow, for example, the modeling of the interaction behavior among components <ref> [1, 6] </ref>. Others permit the modeling of constraints [17]. Additional research in the discipline of software architecture has been concerned with the verification of particular properties of an architecture once it has been created. <p> Others permit the modeling of constraints [17]. Additional research in the discipline of software architecture has been concerned with the verification of particular properties of an architecture once it has been created. Methods exist that, for example, can verify whether an architecture is free of deadlock <ref> [1] </ref> or whether an architecture eventually reaches a certain desired state [4]. Other ADLs lend themselves to the detection of inconsistencies among components that have been put together in an architecture. Architectural mismatches, such as competing threads of control, have been uncovered this way [6]. <p> Consistency is enforced by most ADLs through their strong support for composition. Because components and connections are typed, type checking at system composition time ensures a certain level of consistency. A stronger, behavioral type of consistency is achieved by Wright <ref> [1] </ref> and CHAM [6]. Both ADLs formally define architectures. Inconsistencies in an architecture are uncovered by carrying out analyses on its formal definition. Architectural mismatches, such as competing threads of control, have been uncovered this way in, for example, CHAM.
Reference: [2] <author> D. Batory and B.J. Geraci. </author> <title> Composition Validation and Subjectivity in GenVoca Generators. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 23(2) </volume> <pages> 67-82, </pages> <month> February </month> <year> 1997. </year>
Reference-contexts: Float := 0.0; begin Start =&gt; Evaluate ($StartPoint);; (?x in Float) FuncValue (?x) =&gt; ... end Optimizer; architecture GlobalOptimization () return root is O : Optimizer; F : ComplexFunction; connect (?x in Float) O.Evaluate (?x) =&gt; F.Compute (?x); (?y in Float) F.Result (?y) =&gt; O.FuncValue (?y); end GlobalOptimization; 6 GenVoca <ref> [2] </ref>, is generative in nature: based on an architectural description, a system implementation is generated. Because this approach limits itself to domain-specific applications, it is very powerful.
Reference: [3] <author> R.H. Byrd, E. Eskow, A. van der Hoek, R.B. Schnabel, and K.P.B. Oldenkamp. </author> <title> A Parallel Global Optimization Method for Solving Molecular Cluster and Polymer Conformation Problems. </title> <booktitle> In Proceedings of the Seventh SIAM Conference on Parallel Processing for Scientific Computing, </booktitle> <pages> pages 72-77. </pages> <publisher> SIAM, </publisher> <year> 1995. </year>
Reference-contexts: In Section 7 we draw our conclusions from the comparison and present the answers to the above questions. We end in Section 8 with an outlook at the future work that remains to be done. 2 EXAMPLE research in the field of numerical analysis <ref> [3] </ref>. The purpose of the system is to globally optimize a mathematical function, i.e., to find the point in the domain of the function that yields the absolute lowest function value.
Reference: [4] <author> S.C. Cheung, D Giannakopoulou, and J. Kramer. </author> <title> Verification of Liveness Properties Using Compositional Reachability Analysis. </title> <booktitle> In Proceedings of the Sixth European Software Engineering Conference, number 1301 in Lecture Notes in Computer Science, </booktitle> <pages> pages 227-243, </pages> <address> New York, New York, </address> <month> September </month> <year> 1997. </year> <note> Springer-Verlag. </note>
Reference-contexts: Methods exist that, for example, can verify whether an architecture is free of deadlock [1] or whether an architecture eventually reaches a certain desired state <ref> [4] </ref>. Other ADLs lend themselves to the detection of inconsistencies among components that have been put together in an architecture. Architectural mismatches, such as competing threads of control, have been uncovered this way [6].
Reference: [5] <author> G.M. Clemm. </author> <title> The Odin Specification Language. </title> <booktitle> In Proceedings of the International Workshop on Software Versioning and Configuration Control, </booktitle> <pages> pages 144-158, </pages> <year> 1988. </year>
Reference-contexts: Some of these focus on the construction of a system out of a set of individual source files <ref> [5, 10] </ref>. Others are concerned with the management of versions and configurations of source files [15, 18]. Only recently, the two have been combined into unified system models that not only address versioning and construction, but also raise the level of abstraction from source files to system-level components [9, 29].
Reference: [6] <editor> D. Compare, P. Inverardi, and A.L. Wolf. </editor> <booktitle> Uncovering Architectural Mismatch in Dynamic Behavior. Science of Computer Programming, </booktitle> <year> 1999. </year> <note> To appear. </note>
Reference-contexts: A large variety of languages have been created, and each language has its particular strengths and weaknesses. Besides being able to model the components and interconnections of a system, some languages allow, for example, the modeling of the interaction behavior among components <ref> [1, 6] </ref>. Others permit the modeling of constraints [17]. Additional research in the discipline of software architecture has been concerned with the verification of particular properties of an architecture once it has been created. <p> Other ADLs lend themselves to the detection of inconsistencies among components that have been put together in an architecture. Architectural mismatches, such as competing threads of control, have been uncovered this way <ref> [6] </ref>. As we can see from this brief discussion, the focus of the discipline of software architecture has mainly been on the issues that arise during the design of component-based software systems. <p> Consistency is enforced by most ADLs through their strong support for composition. Because components and connections are typed, type checking at system composition time ensures a certain level of consistency. A stronger, behavioral type of consistency is achieved by Wright [1] and CHAM <ref> [6] </ref>. Both ADLs formally define architectures. Inconsistencies in an architecture are uncovered by carrying out analyses on its formal definition. Architectural mismatches, such as competing threads of control, have been uncovered this way in, for example, CHAM.
Reference: [7] <author> R. Conradi and B. Westfechtel. </author> <title> Version Models for Software Configuration Management. </title> <journal> ACM Computing Surveys, </journal> <note> 1998. To appear. </note>
Reference-contexts: The next three comparison dimensions, construction, versioning, and selection, are at the heart of configuration management. Advanced techniques and modeling capabilities have been developed over the years <ref> [7] </ref> of which the example has highlighted the essential contributions. However, two additional concepts deserve special mention. * Variants and revisions. Our example contains two versions of an optimization algorithm: the Optimizer component and the FastOptimizer component.
Reference: [8] <institution> Desktop Management Task Force Inc. Desktop Management Interface Specification, </institution> <month> March </month> <year> 1996. </year>
Reference-contexts: models that have been developed are all static in nature. 6 SOFTWARE DEPLOYMENT In contrast to the disciplines of software architecture and configuration management, systems models in the field of software deployment tend to be declarative in nature; a schema is used to describe deployment information about a software system <ref> [8, 13, 27] </ref>. Based on the information in the schema, activities such as release, install, configure, update, and deinstall are supported by a deployment tool. One of the more advanced system models that has been developed to support software deployment is incorporated in the Software Dock framework [12].
Reference: [9] <author> J. Estublier and R. Casallas. </author> <title> The Adele Configuration Manager. </title> <editor> In W. Tichy, editor, </editor> <booktitle> Configuration Management, number 2 in Trends in Software, </booktitle> <pages> pages 99-134. </pages> <publisher> Wiley, </publisher> <address> London, Great Britain, </address> <year> 1994. </year>
Reference-contexts: Others are concerned with the management of versions and configurations of source files [15, 18]. Only recently, the two have been combined into unified system models that not only address versioning and construction, but also raise the level of abstraction from source files to system-level components <ref> [9, 29] </ref>. To illustrate the strengths and weaknesses of a typical system model developed by the configuration management discipline, Figure 4 presents a revised version of our optimization example that is modeled in the PCL system modeling language [29]. <p> However, when arbitrary components are selected to be combined in a new configuration, potential inconsistencies are not revealed by the information that is modeled. The typing mechanism of Adele <ref> [9] </ref> and the interface specifications introduced by Perry [23] provide some improvement, but behavioral consistency cannot be achieved since both are static in nature. The next three comparison dimensions, construction, versioning, and selection, are at the heart of configuration management.
Reference: [10] <author> S.I. Feldman. </author> <title> MAKE | A Program for Maintaining Computer Programs. </title> <journal> Software|Practice and Experience, </journal> (9):252-265, April 1979. 
Reference-contexts: Some of these focus on the construction of a system out of a set of individual source files <ref> [5, 10] </ref>. Others are concerned with the management of versions and configurations of source files [15, 18]. Only recently, the two have been combined into unified system models that not only address versioning and construction, but also raise the level of abstraction from source files to system-level components [9, 29].
Reference: [11] <author> D. Garlan, R. Monroe, and D. Wile. ACME: </author> <title> An Architecture Description Interchange Language. </title> <booktitle> In Proceedings of CASCON '97. </booktitle> <institution> IBM Center for Advanced Studies, </institution> <month> November </month> <year> 1997. </year>
Reference-contexts: Further proof of the importance of composition in ADLs is presented by ACME <ref> [11] </ref>, an architecture description language that has been proposed to unify existing ADLs. ACME is centered around the notion of components, connectors, and configurations, which are all system modeling constructs that are used to model the composition of a system.
Reference: [12] <editor> R.S. Hall, D.M. Heimbigner, A. van der Hoek, and A.L. Wolf. </editor> <title> An Architecture for Post-Development Configuration Management in a Wide-Area Network. </title> <booktitle> In Proceedings of the 1997 International Conference on Distributed Computing Systems, </booktitle> <pages> pages 269-278. </pages> <publisher> IEEE Computer Society, </publisher> <month> May </month> <year> 1997. </year>
Reference-contexts: Based on the information in the schema, activities such as release, install, configure, update, and deinstall are supported by a deployment tool. One of the more advanced system models that has been developed to support software deployment is incorporated in the Software Dock framework <ref> [12] </ref>. Figure 5 illustrates a part of our global optimization example as it would be described in a Software Dock schema. Modeled are two components, the Optimizer component and the ComplexFunction component.
Reference: [13] <editor> R.S. Hall, D.M. Heimbigner, and A.L. Wolf. </editor> <title> Requirements for Software Deployment Languages and Schema. </title> <booktitle> In Proceedings of the Eighth International Symposium on System Configuration Management, Lecture Notes in Computer Science, </booktitle> <address> New York, New York, 1998. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: models that have been developed are all static in nature. 6 SOFTWARE DEPLOYMENT In contrast to the disciplines of software architecture and configuration management, systems models in the field of software deployment tend to be declarative in nature; a schema is used to describe deployment information about a software system <ref> [8, 13, 27] </ref>. Based on the information in the schema, activities such as release, install, configure, update, and deinstall are supported by a deployment tool. One of the more advanced system models that has been developed to support software deployment is incorporated in the Software Dock framework [12].
Reference: [14] <author> P. Inverardi and A.L. Wolf. </author> <title> Formal Specification and Analysis of Software Architectures using the Chemical Abstract Machine Model. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 373-386, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Internal dynamism, on the other hand, is the ability to create and destroy components from within the system model. Both external and internal dynamism are present in ADLs. Most notably, C2 supports external dynamism through its ArchShell [19] environment, whereas internal dynamism is supported by Rapide [17] and CHAM <ref> [14] </ref>. In either case, though, support is limited because the system model itself provides no constructs to support the architectural changes with guidelines and constraints. It is not possible, for example, to specify in the system model what particular topology needs to be maintained while an architecture is being modified.
Reference: [15] <author> D.B. Leblang, R.P. Chase, Jr., and H. Spilke. </author> <title> Increasing Productivity with a Parallel Configuration Manager. </title> <booktitle> In Proceedings of the International Workshop on Software Versioning and Configuration Control, </booktitle> <pages> pages 144-158, </pages> <year> 1988. </year>
Reference-contexts: Some of these focus on the construction of a system out of a set of individual source files [5, 10]. Others are concerned with the management of versions and configurations of source files <ref> [15, 18] </ref>. Only recently, the two have been combined into unified system models that not only address versioning and construction, but also raise the level of abstraction from source files to system-level components [9, 29].
Reference: [16] <author> D.C. Luckham, J.J. Kenney, L.M. Augustin, J. Vera, D. Bryan, and W. Mann. </author> <title> Specification and Analysis of System Architecture Using Rapide. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 336-355, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Combined with the architecture-level connections among components, the specification of the interaction behavior of all components results in a completely specified system on which important analyses can be carried out. For example, the Rapide tool set contains tools that simulate an architecture to uncover such architectural faults as deadlock <ref> [16] </ref>. We now turn our attention to the comparison dimensions that we described in Section 3 and the rankings given to software architecture in Table 1. From the discussion of the Rapide example, it should be clear that Rapide is focused on the composition dimension.
Reference: [17] <author> D.C. Luckham and J. Vera. </author> <title> An Event-Based Architecture Definition Language. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(9) </volume> <pages> 717-734, </pages> <month> September </month> <year> 1995. </year> <month> 15 </month>
Reference-contexts: Besides being able to model the components and interconnections of a system, some languages allow, for example, the modeling of the interaction behavior among components [1, 6]. Others permit the modeling of constraints <ref> [17] </ref>. Additional research in the discipline of software architecture has been concerned with the verification of particular properties of an architecture once it has been created. <p> In particular, ADLs partition a system into individual components, describe the behavior of each component, and model the interconnections among the components. Figure 3 illustrates this focus of ADLs with an example architecture that is modeled in the Rapide <ref> [17] </ref> architecture description language. Shown are two components of the example system discussed in Section 2, a component that evaluates the function at a particular point in its domain, ComplexFunction, and a component that performs an optimization algorithm, Optimizer. <p> Internal dynamism, on the other hand, is the ability to create and destroy components from within the system model. Both external and internal dynamism are present in ADLs. Most notably, C2 supports external dynamism through its ArchShell [19] environment, whereas internal dynamism is supported by Rapide <ref> [17] </ref> and CHAM [14]. In either case, though, support is limited because the system model itself provides no constructs to support the architectural changes with guidelines and constraints.
Reference: [18] <author> K. Marzullo and D. Wiebe. </author> <title> A Software System Modelling Facility. </title> <booktitle> In Proceedings of the ACM SIG--SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments. ACM SIGSOFT, </booktitle> <month> April </month> <year> 1984. </year>
Reference-contexts: Some of these focus on the construction of a system out of a set of individual source files [5, 10]. Others are concerned with the management of versions and configurations of source files <ref> [15, 18] </ref>. Only recently, the two have been combined into unified system models that not only address versioning and construction, but also raise the level of abstraction from source files to system-level components [9, 29].
Reference: [19] <author> N. Medvidovic. </author> <title> ADLs and Dynamic Architecture Changes. </title> <editor> In L. Vidal, A. Finkelstein, G. Spanoudakis, and A.L. Wolf, editors, </editor> <booktitle> Joint Proceedings of the SIGSOFT '96 Workshops, </booktitle> <pages> pages 24-27, </pages> <address> New York, New York, 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Internal dynamism, on the other hand, is the ability to create and destroy components from within the system model. Both external and internal dynamism are present in ADLs. Most notably, C2 supports external dynamism through its ArchShell <ref> [19] </ref> environment, whereas internal dynamism is supported by Rapide [17] and CHAM [14]. In either case, though, support is limited because the system model itself provides no constructs to support the architectural changes with guidelines and constraints.
Reference: [20] <author> N. Medvidovic and R.N. Taylor. </author> <title> A Framework for Classifying and Comparing Architecture Description Languages. </title> <booktitle> In Proceedings of the Sixth European Software Engineering Conference, number 1301 in Lecture Notes in Computer Science, </booktitle> <pages> pages 60-76, </pages> <address> New York, New York, </address> <month> September </month> <year> 1997. </year> <note> Springer-Verlag. </note>
Reference-contexts: From the discussion of the Rapide example, it should be clear that Rapide is focused on the composition dimension. This focus is shared by other ADLs, which is illustrated by a recent survey of existing ADLs <ref> [20] </ref>. The survey uses several key characteristics of components, connectors, 2 and configurations as its comparison dimensions.
Reference: [21] <author> D. Le Metayer. </author> <title> Software Architecture Styles as Graph Grammers. </title> <booktitle> In Proceedings of the Fourth ACM SIGSOFT Symposium on the Foundations of Software Engineering, SIGSOFT Software Engineering Notes, </booktitle> <pages> pages 15-23. </pages> <institution> Association for Computer Machinery, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: It is not possible, for example, to specify in the system model what particular topology needs to be maintained while an architecture is being modified. The graph grammar approach developed by Le Metayer <ref> [21] </ref> addresses this problem and provides a means for constraining the topology of a system. As an inherent part of a system architecture, a coordination component is modeled.
Reference: [22] <author> D. Nachbar. </author> <title> When Network File Systems Aren't Enough: Automatic Software Distribution Revisited. </title> <booktitle> In Proceedings of the USENIX 1986 Summer Technical Conference, </booktitle> <pages> pages 159-171, </pages> <address> Atlanta, GA, </address> <month> June </month> <year> 1986. </year> <institution> USENIX Association. </institution>
Reference-contexts: As compared to configuration management, the modeling capabilities are rather similar. The only difference is that software deployment does not have an explicit notion of a change set in its modeling capabilities. Although sophisticated delta mechanisms are available for efficient software updates <ref> [22] </ref>, these mechanisms lack the expressiveness of change sets. Support for the final dimension, dynamism, is not available in current software deployment systems.
Reference: [23] <author> D.E. Perry. </author> <title> System Compositions and Shared Dependencies. </title> <booktitle> In Proceedings of the Sixth International Workshop on Software Configuration Management, number 1167 in Lecture Notes in Computer Science, </booktitle> <pages> pages 139-153, </pages> <address> New York, New York, 1996. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: However, when arbitrary components are selected to be combined in a new configuration, potential inconsistencies are not revealed by the information that is modeled. The typing mechanism of Adele [9] and the interface specifications introduced by Perry <ref> [23] </ref> provide some improvement, but behavioral consistency cannot be achieved since both are static in nature. The next three comparison dimensions, construction, versioning, and selection, are at the heart of configuration management.
Reference: [24] <author> M. Shaw, R. DeLine, D.V. Klein, T.L. Ross, D.M. Young, and G. Zelesnik. </author> <title> Abstractions for Software Architecture and Tools to Support Them. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 21(4) </volume> <pages> 314-335, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: The support for the other comparison dimensions besides composition and consistency is rather limited in current ADLs. Version control and the selection of components that constitute a configuration mostly have to be carried out by hand without any guidance from an architectural system model. UniCon <ref> [24] </ref> is an exception. Although it does not allow for versions of the actual compositional constructs (such as, for example, components, interfaces, or types), its system model does support variant implementations of components. Construction has received some attention from the architecture community.
Reference: [25] <institution> Software Maintenance & Development Systems, Inc, Concord, Massachusetts. Aide de Camp Product Overview, </institution> <month> September </month> <year> 1994. </year>
Reference-contexts: Both the variant and revision relationship are explicitly modeled; typically, the variants and revisions of a component are organized in a version tree. * Change sets. A rather different approach to modeling system configurations is the change-set approach <ref> [25] </ref>. As opposed to managing versions of components, change sets model changes as first-class entities. Changes can be simple modifications to a single component, but can also be complex modifications having a system-wide impact.
Reference: [26] <author> J.A. Stafford, D.J. Richardson, and A.L. Wolf. </author> <title> Chaining: A Software Architecture Dependence Analysis Technique. </title> <type> Technical Report CU-CS-845-97, </type> <institution> Department of Computer Science, University of Colorado, Boulder, Colorado, </institution> <month> September </month> <year> 1997. </year>
Reference-contexts: We believe that this conclusion extends to other activities in the software life cycle, which is already demonstrated by initial work in architectural-based testing <ref> [26] </ref>. To realize this vision, much work remains to be done and difficult problems remain to be solved.
Reference: [27] <institution> Tivoli Systems, Inc. Applications Management Specification, </institution> <year> 1995. </year>
Reference-contexts: models that have been developed are all static in nature. 6 SOFTWARE DEPLOYMENT In contrast to the disciplines of software architecture and configuration management, systems models in the field of software deployment tend to be declarative in nature; a schema is used to describe deployment information about a software system <ref> [8, 13, 27] </ref>. Based on the information in the schema, activities such as release, install, configure, update, and deinstall are supported by a deployment tool. One of the more advanced system models that has been developed to support software deployment is incorporated in the Software Dock framework [12].
Reference: [28] <institution> Tivoli Systems, Inc. TME/10 Software Distribution, </institution> <year> 1997. </year>
Reference-contexts: Although the explicit modeling of connections and behavioral specifications is lacking, other compositional constructs are unique to the discipline of software deployment. In particular, it is possible to model a system out of multiple systems, possibly located at multiple geographical sites <ref> [28] </ref>. Another important feature is the the optionality of components.
Reference: [29] <author> E. Tryggeseth, B. Gulla, and R. Conradi. </author> <title> Modelling Systems with Variability using the PROTEUS Configuration Language. In Software Configuration Management: </title> <booktitle> ICSE SCM-4 and SCM-5 Workshops Selected Papers, number 1005 in Lecture Notes in Computer Science, </booktitle> <pages> pages 216-240, </pages> <address> New York, New York, 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Others are concerned with the management of versions and configurations of source files [15, 18]. Only recently, the two have been combined into unified system models that not only address versioning and construction, but also raise the level of abstraction from source files to system-level components <ref> [9, 29] </ref>. To illustrate the strengths and weaknesses of a typical system model developed by the configuration management discipline, Figure 4 presents a revised version of our optimization example that is modeled in the PCL system modeling language [29]. <p> To illustrate the strengths and weaknesses of a typical system model developed by the configuration management discipline, Figure 4 presents a revised version of our optimization example that is modeled in the PCL system modeling language <ref> [29] </ref>. Compared to the previous version in Figure 3, one additional component (or family in PCL terminology) has been introduced: the FastOptimizer component carries out an optimization in less time than the regular Optimizer component, but sacrifices precision to gain the time benefit.
Reference: [30] <editor> A. van der Hoek, R.S. Hall, A. Carzaniga, D.M. Heimbigner, and A.L. Wolf. </editor> <title> Software Deployment: Extending Configuration Management Support into the Field. </title> <journal> Journal of Defense Software Engineering, </journal> <volume> 11(2) </volume> <pages> 9-13, </pages> <year> 1998. </year>
Reference-contexts: Support for the final dimension, dynamism, is not available in current software deployment systems. Despite the fact that it has been recognized as a problem and is an integral part of the software deployment life cycle <ref> [30] </ref>, no solutions have been devised as of yet. 7 LESSONS TO BE LEARNED Based on the comparison carried out in the previous three sections, we now attempt to answer the questions posed in the introduction.
Reference: [31] <editor> A. van der Hoek, D.M. Heimbigner, and A.L. Wolf. </editor> <booktitle> Versioned Software Architecture. In Third International Software Architecture Workshop, </booktitle> <year> 1998. </year> <note> To appear. 16 </note>
Reference-contexts: Both the discipline of configuration management and the discipline of software deployment would benefit from the provided modeling capabilities for connections and interaction behaviors. Connections can be used to reduce architectural erosion, whereas interaction behaviors can be used to verify the consistency of selections of components <ref> [31] </ref>. Both of these are important capabilities that are currently not available. * The use of software architecture would reduce the context switch between configuration management and software deployment.
References-found: 31

