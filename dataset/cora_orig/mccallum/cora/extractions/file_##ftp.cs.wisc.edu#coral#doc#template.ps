URL: file://ftp.cs.wisc.edu/coral/doc/template.ps
Refering-URL: http://www.cs.wisc.edu/coral/coral.papers.html
Root-URL: 
Title: Magic Templates: A Spellbinding Approach to Logic Programs  
Author: Raghu Ramakrishnan 
Affiliation: University of Wisconsin-Madison  
Abstract: We consider a bottom-up query-evaluation scheme in which facts of relations are allowed to have nonground terms. The Magic Sets query-rewriting technique is generalized to allow arguments of predicates to be treated as bound even though the rules do not provide ground bindings for those arguments. In particular, we regard as ``bound'' any argument containing a function symbol or a variable that appears more than once in the argument list. Generalized ``magic'' predicates are thus defined to compute the set of all goals reached in a top-down exploration of the rules, starting from a given query goal; these goals are not facts of constants as in previous versions of the Magic Sets algorithm. The magic predicates are then used to restrict a bottom-up evaluation of the rules so that there are no redundant actions; that is, every step of the bottom-up computation must be performed by any algorithm that uses the same sideways information passing strategy (sips). The price paid, compared to previous versions of Magic Sets, is that we must store relations with nonground facts; and we must perform unifications, rather than equijoins, when evaluating the rules bottom-up. The method is applicable to general Horn clause logic programs. 
Abstract-found: 1
Intro-found: 1
Reference: [APPRSU86] <author> F. Afrati, C. Papadimitriou, G. Papageorgiou, A. Roussou, Y. Sagiv and J.D. Ull-man, </author> <title> ``Convergence of Sideways Query Evaluation,'' </title> <booktitle> Proc. ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: In this case, the computation mimics Prolog all too faithfully. [] We do not consider how to test whether bottom-up evaluation terminates on a given program. We refer the reader to <ref> [APPRSU86, KL87, KRS88] </ref> for some work on this problem. 7. Constraint Logic Programming We now describe how Constraint Logic Programming (CLP) can be implemented using the bottom-up approach we described in earlier sections. The ability to deal with rules that are not range-restricted is crucial.
Reference: [Ba85] <author> F. Bancilhon, </author> <title> ``A Note on the Performance of Rule Based Systems,'' </title> <type> MCC Technical Report DB-022-85, </type> <year> 1985. </year>
Reference-contexts: As we proceed, we have a collection of adorned predicates, and as hhhhhhhhhhhhhhhh Seminaive fixpoint computation is a refinement that avoids repeating inferences in different iterations. (See, e.g., <ref> [Ba85] </ref>. Note that non-linear rules are also treated.) - -- each one is processed, we will mark it, so that it will not be processed again. <p> Properties of Magic Programs In the previous section, we showed that the Magic Templates algorithm transformed the given program into an equivalent program with respect to the query. The fixpoint of the transformed program is computed using a bottom-up iteration, possibly with some refinements as in Sem-inaive evaluation (e.g. <ref> [Ba85] </ref>). In this section, we consider some properties of the fixpoint evaluation of the transformed program. 6.1. <p> Sip-optimality does not imply that facts and queries are not generated more than once. However, if the bottom-up computation is done using Seminaive evaluation (e.g., <ref> [Ba85] </ref>), no fact is inferred twice using the same derivation. (In general, it is not possible to avoid inferring the same fact by two distinct derivations without sacrificing completeness of the evaluation strategy.) Prolog does not have this property, and the importance of this distinction between Magic Templates and Prolog is
Reference: [BaR86] <author> F. Bancilhon and R. Ramakrishnan, </author> <title> ``An Amateur's Introduction to Recursive Query Processing Strategies,'' </title> <booktitle> Proc. SIGMOD, </booktitle> <year> 1986. </year>
Reference-contexts: 1. Introduction Several strategies have been proposed for evaluating recursive queries expressed using sets of Horn clauses [BeR87, BMSU86, DW87, GMN84, HN84, KL86a, KL86b, KL87, Na87, Na88, RL85, SZ86a, SZ86b, Ul85, VG86, Vi86, Vi88, etc.]. (See <ref> [BaR86, BaR88] </ref> for a survey and performance comparison.) It is our thesis that each of these strategies has two distinct components a binding passing or sideways information passing strategy (sip) for each rule and a control strategy. <p> using the same derivation. (In general, it is not possible to avoid inferring the same fact by two distinct derivations without sacrificing completeness of the evaluation strategy.) Prolog does not have this property, and the importance of this distinction between Magic Templates and Prolog is emphasized by the study in <ref> [BaR86, BaR88] </ref>. (In the examples considered there, Magic Templates is identical to Generalized Magic Sets, which is the method used in the comparison. Also, there are some examples in which that study assigns a lower cost to Prolog, in terms of the number of facts inferred.
Reference: [BaR88] <author> F. Bancilhon and R. Ramakrishnan, </author> <title> ``Performance Evaluation of Data Intensive Logic Programs,'' In Foundations of Deductive Databases and Logic Programming, </title> <editor> Ed. J. Minker, </editor> <publisher> Morgan Kaufman, </publisher> <year> 1988. </year>
Reference-contexts: 1. Introduction Several strategies have been proposed for evaluating recursive queries expressed using sets of Horn clauses [BeR87, BMSU86, DW87, GMN84, HN84, KL86a, KL86b, KL87, Na87, Na88, RL85, SZ86a, SZ86b, Ul85, VG86, Vi86, Vi88, etc.]. (See <ref> [BaR86, BaR88] </ref> for a survey and performance comparison.) It is our thesis that each of these strategies has two distinct components a binding passing or sideways information passing strategy (sip) for each rule and a control strategy. <p> using the same derivation. (In general, it is not possible to avoid inferring the same fact by two distinct derivations without sacrificing completeness of the evaluation strategy.) Prolog does not have this property, and the importance of this distinction between Magic Templates and Prolog is emphasized by the study in <ref> [BaR86, BaR88] </ref>. (In the examples considered there, Magic Templates is identical to Generalized Magic Sets, which is the method used in the comparison. Also, there are some examples in which that study assigns a lower cost to Prolog, in terms of the number of facts inferred.
Reference: [BeR87] <author> C. Beeri and R. Ramakrishnan, </author> <title> ``On the Power of Magic,'' </title> <booktitle> Proc. ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <year> 1987. </year>
Reference-contexts: In particular, we show that simple bottom-up evaluation may be used to implement any sip collection by first rewriting the given set of Horn clauses and then evaluating the rewritten set. Our result generalizes Generalized Magic Sets and other related strategies presented in <ref> [BeR87] </ref>. The importance of the generalization is that the bottom-up methods now apply to any Horn clause logic program. <p> In this paper, we show the power of the bottom-up approach, and, by a careful separation of binding propagation and the flow of control (following <ref> [BeR87] </ref>), we also clarify the relationship between top-down and bottom-up evaluation strategies. We also consider how these techniques can be used to implement Constraint Logic Programs ([JL87], [JM87], [HJLMSYY86]). For example, consider the following rule: p (X,Y) :- X &gt; Y. <p> Sideways Information Passing The notion of sideways information passing was studied in <ref> [BeR87] </ref>, and we refer the reader to it for a more detailed discussion. The discussion in this section follows the presentation there, but with some important differences. The only bindings considered there were of the form X = c, where X is some variable and c is some ground term. <p> We explain the meaning of such a graph by explaining how the computation of a rule uses an arc N fi S q, hhhhhhhhhhhhhhhh For simplicity, we assume that there is at most one arc entering a given node q. Multiple arcs can be dealt with as in <ref> [BeR87] </ref>. - -- then explaining the complete computation of a rule. This arc means that the variables in S are bound to terms by solving the literals in N ( a ``join'' in database terminology). <p> Example 1: Consider the following rules: sg (X,Y) :- flat (X,Y). sg (X,Y) :- up (X,Z1), sg.1 (Z1,Z2), flat (Z2,Z3), sg.2 (Z3,Z4), down (Z4,Y). Query: sg (john,X)? This is a non-linear version of the same-generation program <ref> [BeR87, BMSU86] </ref>. We have numbered the sg occurrences in the second rule for convenience. Given the query, the natural way to use the second rule seems to be to solve the predicates in the indicated order, using bindings from each predicate to solve the next predicate. <p> therefore ignore bindings that are passed to base predicates (and which can be used to retrieve a subset of the corresponding relations) for simplicity of exposition. [] - -- The previous example introduced the notion of sips, and the sips in it satisfy the earlier definition of a sip in <ref> [BeR87] </ref>. The next example illustrates some differences. <p> This is in fact what Prolog does, and the following sip describes this: same- fi X,Y q While this is a valid sip according to the definition presented in this paper, it is not a valid sip according to the definition in <ref> [BeR87] </ref> since X and Y are not bound to ground terms in the arc entering q. [] In the second condition defining a sip, if N fi p is a sip arc with label S, we require that the variables in S should appear in arguments of p. <p> This is simply a consequence of the fact that bindings for other variables are of no interest when evaluating that predicate occurrence. However, we depart from the definition of a sip in <ref> [BeR87] </ref> in an important way we no longer require that these variables also appear in arguments of predicates in N. <p> In later sections, we see how this sip can be implemented using a bottom-up fixpoint computation. However, this sip is clearly invalid according to the definition in <ref> [BeR87] </ref>, and further, it cannot be implemented using the algorithms presented there. (As we will show later, a bottom-up implementation of this sip requires us to introduce rules that are not range-restricted.) This example illustrates the more general notion of ``binding'' used in this paper, in contrast to the earlier work <p> The following example illustrates this. - -- Example 4: p (X) :- q1 (X,Y), q2 ([Y|Z]). q2 ([Y|U]) :- q1 (Y,U). This program illustrates a sideways information passing strategy that is disallowed in <ref> [BeR87] </ref> because it cannot be efficiently implemented using the rewriting methods presented there. (This reflects a decision that is followed in most of the deductive database literature, and was first discussed in [Ul85].) Consider a query p (X)? The following is a possible sip for the first rule: -q 1- fi <p> This is not a valid sip according to the definition in <ref> [BeR87] </ref> since Z is not bound in the (only) argument of q 2. [] 2.1. Full Sips Consider a rule r with a given set of arguments bound in the head literal p. <p> Since the head of a rule may appear with several adornments, it follows that we may attach several distinct sips to versions of the same rule, one to each version. The details are similar to the corresponding algorithm in <ref> [BeR87] </ref>, but with some important differences that we discuss after presenting the algorithm. The process starts from the given query. <p> Example 5: (From <ref> [BeR87] </ref>) The following is the adorned rule set corresponding to the non linear same generation example, for the sip of Example 1. 1. sg bf (X,Y) :- flat (X,Y). 2. sg bf (X,Y) :- up (X,Z1), sg bf (Z1,Z2), flat (Z2,Z3), sg bf (Z,Z4), down (Z4,Y). <p> The adorned program contains a rule that is not range-restricted (rule 2). This program is disal lowed in <ref> [BeR87] </ref>. [] Example 7: The adorned rule set corresponding to the program and sip in Example 3 is the following: q f (X) :- p bbf (X,X,Y). This adorned program would not be produced at all by the algorithm in [BeR87]. <p> This program is disal lowed in <ref> [BeR87] </ref>. [] Example 7: The adorned rule set corresponding to the program and sip in Example 3 is the following: q f (X) :- p bbf (X,X,Y). This adorned program would not be produced at all by the algorithm in [BeR87]. <p> The earliest version was called Magic Sets [BMSU86], and a generalization to arbitrary range-restricted rules is called Generalized Magic Sets <ref> [BeR87] </ref>. - -- The rewriting algorithm to be described in this section is from [BeR87]. <p> The earliest version was called Magic Sets [BMSU86], and a generalization to arbitrary range-restricted rules is called Generalized Magic Sets <ref> [BeR87] </ref>. - -- The rewriting algorithm to be described in this section is from [BeR87]. However, the evaluation of the rewritten programs, the notion of program equivalence, and the proofs of the theorems and lemmas characterizing the rewritten programs, all differ due to the different interpretations of sips and adornments presented in this paper, and must be reconsidered. <p> Thus, magic_q i a i is to be thought of as ``the magic predicate of q i a i '', rather than as a predicate magic_q i with adornment a i .) The restriction on programs in <ref> [BeR87] </ref> can be stated in terms of the rewritten programs produced by the rewriting algorithms: ``Every rule in the rewritten program should be range-restricted.'' The restrictions on sips (in particular, the restriction that in a sip arc N fi S p, every variable in S should appear in N) and adornments <p> rewriting algorithms: ``Every rule in the rewritten program should be range-restricted.'' The restrictions on sips (in particular, the restriction that in a sip arc N fi S p, every variable in S should appear in N) and adornments (the restriction that partially bound arguments should be considered free arguments) in <ref> [BeR87] </ref> are necessary to ensure this. We now illustrate the rewriting algorithm through several examples. <p> rule] magic_sg bf (Z1) :- magic_sg bf (X), up (X,Z1) [From rule 2, 2nd body literal] magic_sg bf (Z3) :- magic_sg bf (X), up (X,Z1), sg bf (Z1,Z2), flat (Z2,Z3) [From rule 2, 4th body literal] hhhhhhhhhhhhhhhh We do not consider the case of multiple arcs entering a predicate; see <ref> [BeR87] </ref>. - -- sg bf (X,Y) :- magic_sg bf (X), flat (X,Y) [Modified rule 1] sg bf (X,Y) :- magic_sg bf (X), up (X,Z1), sg bf (Z1,Z2), flat (Z2,Z3) sg bf (Z3,Z4), down (Z4,Y) [Modified rule 2] [] In the above example, we observe that some joins are repeated in the <p> There is a variant of Magic Sets, called Supplementary Magic Sets, presented in <ref> [BeR87] </ref>, that avoids this duplication of effort by storing the results of these joins, after projecting out unnecessary arguments. We remark that the Supplementary algorithm is easily generalized along the lines indicated in this paper. <p> The rewritten program contains a rule that is not range-restricted (rule 2). This program is disallowed by the restrictions in <ref> [BeR87] </ref>. The execution of this program proceeds as follows. The last rule can be applied to generate magic_q bb (U,U). The third rule can then be applied to generate q bb (5,5), and the first rule can then be applied to generate p ff (5,5). <p> Since such arcs always lead to rules that are not range-restricted in the rewritten program, such arcs were disallowed by the definition of sips in <ref> [BeR87] </ref>. [] Example 12: The rewritten program corresponding to the first adorned program in Example 9 is the following: p f (X) :- q1 (X,Y), q 2 b ([Y|Z]). q 2 b ([Y|U]) :- magic_q 2 b ([Y|U]), q1 (Y,U). magic_q 2 b ([Y|Z]) :- q1 (X,Y). <p> We first define the class of strategies for which this claim of optimality is made, following <ref> [BeR87] </ref>. Our definition generalizes that in [BeR87] by including strategies that generate nonground facts. <p> We first define the class of strategies for which this claim of optimality is made, following <ref> [BeR87] </ref>. Our definition generalizes that in [BeR87] by including strategies that generate nonground facts. <p> Examples of such methods include Counting <ref> [BeR87, BMSU86, SZ86a, SZ86b] </ref>, the methods proposed in [HN84, Na87, Na88]. Typically, such methods seek to exploit the structure of the rules in some way that goes beyond sideways information passing, and are less generally applicable. However, our definition is sufficiently broad to include a large number of proposed strategies. <p> Acknowledgements Catriel Beeri has had a great influence on the development of the ideas presented in this paper, and in particular, the idea of using sips to guide rewriting strategies arose in joint work with him, presented in <ref> [BeR87] </ref>. Discussions with Joxan Jaffar and Jean-Louis Lassez were helpful in in seeing the applicability of these results to Constraint Logic Programs. Jeff Ullman made several helpful comments on an earlier version, and revised the abstract.
Reference: [BMSU86] <author> F. Bancilhon, D. Maier, Y. Sagiv and J. Ullman, </author> <title> ``Magic Sets and Other Strange Ways to Implement Logic Programs,'' </title> <booktitle> Proc. 5th ACM SIGMOD-SIGACT Symposium on Principles of Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: Example 1: Consider the following rules: sg (X,Y) :- flat (X,Y). sg (X,Y) :- up (X,Z1), sg.1 (Z1,Z2), flat (Z2,Z3), sg.2 (Z3,Z4), down (Z4,Y). Query: sg (john,X)? This is a non-linear version of the same-generation program <ref> [BeR87, BMSU86] </ref>. We have numbered the sg occurrences in the second rule for convenience. Given the query, the natural way to use the second rule seems to be to solve the predicates in the indicated order, using bindings from each predicate to solve the next predicate. <p> The intention is that the bottom-up evaluation of the modified set of rules simulate the sip that we have chosen for each adorned rule, thus restricting the search space. hhhhhhhhhhhhhhhh Hence the name for the strategy. The earliest version was called Magic Sets <ref> [BMSU86] </ref>, and a generalization to arbitrary range-restricted rules is called Generalized Magic Sets [BeR87]. - -- The rewriting algorithm to be described in this section is from [BeR87]. <p> Examples of such methods include Counting <ref> [BeR87, BMSU86, SZ86a, SZ86b] </ref>, the methods proposed in [HN84, Na87, Na88]. Typically, such methods seek to exploit the structure of the rules in some way that goes beyond sideways information passing, and are less generally applicable. However, our definition is sufficiently broad to include a large number of proposed strategies.
Reference: [BNRST86] <author> C. Beeri, S. Naqvi, R. Ramakrishnan, O. Shmueli and S. Tsur, </author> <title> ``Sets and Negation in a Logic Database Language (LDL1),'' </title> <booktitle> Proc. ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <year> 1987. </year>
Reference: [BPR87] <author> I. Balbin, G.S. Port, and K. Ramamohanarao, </author> <title> ``Magic Set Computation of Stratified Databases,'' </title> <type> Technical Report 87/3, </type> <institution> University of Melbourne, </institution> <year> 1987. </year>
Reference-contexts: The approach can be used to evaluate some stratified programs containing negation, and we refer the reader to hhhhhhhhhhhhhhhh * This work was supported in part by an IBM Faculty Development Award and NSF grant IRI-8804319. - -- [BNRST87], <ref> [BPR87] </ref>.) We believe that both Prolog-style evaluation and bottom-up approaches have their own advantages and are likely to be preferable in certain important domains.
Reference: [DW87] <author> S.W. Dietrich and D.S. Warren, </author> <title> ``Extension Tables: Memo Relations in Logic Programming,'' </title> <booktitle> Proc. Symposium on Logic Programming, </booktitle> <year> 1987. </year>
Reference-contexts: However, our definition is sufficiently broad to include a large number of proposed strategies. These include Prolog, versions of top-down evaluation with memoing such as QSQ [Vi86] and Extension Tables <ref> [DW87] </ref>, Static and Dynamic Filtering [KL86a, KL86b], and several parallel evaluation strategies proposed in the logic programming literature including those in [Ka87, VG86].
Reference: [GMN84] <editor> H. Gallaire, J. Minker and J.-M. Nicolas, </editor> <title> ``Logic and Data Bases: A Deductive Approach,'' </title> <journal> Computing Surveys, </journal> <volume> Vol. 16, No 2, </volume> <month> June </month> <year> 1984. </year>
Reference: [HN84] <author> L. Henschen and S. Naqvi, </author> <title> ``On Compiling Queries in Recursive First-Order Data Bases,'' </title> <journal> JACM, </journal> <volume> Vol 31, </volume> <month> January </month> <year> 1984, </year> <pages> pp 47-85. </pages>
Reference-contexts: Examples of such methods include Counting [BeR87, BMSU86, SZ86a, SZ86b], the methods proposed in <ref> [HN84, Na87, Na88] </ref>. Typically, such methods seek to exploit the structure of the rules in some way that goes beyond sideways information passing, and are less generally applicable. However, our definition is sufficiently broad to include a large number of proposed strategies.
Reference: [JL87] <author> J. Jaffar and J-L. Lassez, </author> <title> ``Constraint Logic Programming,'' </title> <booktitle> Proc. Conference on Principles of Programming Languages, </booktitle> <year> 1987. </year>
Reference: [Ka87] <author> L.V. Kale, </author> <title> ``The Reduce-Or Process Model for Parallel Evaluation of Logic Programs,'' </title> <booktitle> Proc. Intl. Conf. on Logic Programming, </booktitle> <year> 1987. </year>
Reference-contexts: These include Prolog, versions of top-down evaluation with memoing such as QSQ [Vi86] and Extension Tables [DW87], Static and Dynamic Filtering [KL86a, KL86b], and several parallel evaluation strategies proposed in the logic programming literature including those in <ref> [Ka87, VG86] </ref>. A strategy may generate additional queries, or facts, in addition to those that must be generated by conditions (1) and (2), and then we have good reason to consider it inferior to a sip-optimal strategy such as Magic Templates.
Reference: [KL86a] <author> M. Kifer and E. Lozinskii, </author> <title> ``Filtering Data Flow in Deductive Databases,'' </title> <booktitle> Proc. Intl. Conf. on Database Theory, </booktitle> <year> 1986. </year> - -- 
Reference-contexts: However, our definition is sufficiently broad to include a large number of proposed strategies. These include Prolog, versions of top-down evaluation with memoing such as QSQ [Vi86] and Extension Tables [DW87], Static and Dynamic Filtering <ref> [KL86a, KL86b] </ref>, and several parallel evaluation strategies proposed in the logic programming literature including those in [Ka87, VG86].
Reference: [KL86b] <author> M. Kifer and E. Lozinskii, </author> `` <title> A Framework for an Efficient Implementation of Deductive Databases,'' </title> <booktitle> Proc. Advanced Database Symposium, </booktitle> <address> Tokyo, </address> <year> 1986. </year>
Reference-contexts: The method does not always fully restrict the search, but it should be possible to combine the ideas with more a sophisticated version of the method, called Dynamic Filtering, defined earlier for range-restricted rules <ref> [KL86b] </ref>. A rule application is defined as follows. <p> However, our definition is sufficiently broad to include a large number of proposed strategies. These include Prolog, versions of top-down evaluation with memoing such as QSQ [Vi86] and Extension Tables [DW87], Static and Dynamic Filtering <ref> [KL86a, KL86b] </ref>, and several parallel evaluation strategies proposed in the logic programming literature including those in [Ka87, VG86].
Reference: [KL87] <author> M. Kifer and E. Lozinskii, </author> <title> ``Implementing Logic Programs As a Database System,'' </title> <booktitle> Proc. Intl. Conf. on Data Engineering, </booktitle> <year> 1987. </year>
Reference-contexts: To our knowledge, however, the first use of such facts in the deductive database literature is in <ref> [KL87] </ref>. In that paper, Kifer and Lozinskii present an evaluation method called Sygraf, and allow rules that are not range-restricted, with the objective of dealing with general logic programs. <p> In this case, the computation mimics Prolog all too faithfully. [] We do not consider how to test whether bottom-up evaluation terminates on a given program. We refer the reader to <ref> [APPRSU86, KL87, KRS88] </ref> for some work on this problem. 7. Constraint Logic Programming We now describe how Constraint Logic Programming (CLP) can be implemented using the bottom-up approach we described in earlier sections. The ability to deal with rules that are not range-restricted is crucial.
Reference: [KRS88] <author> R. Krishnamurthy, R. Ramakrishnan and O. Shmueli, </author> <title> ``A Framework for Testing Safety and Effective Computability of Extended Datalog,'' </title> <booktitle> Proc. SIGMOD, </booktitle> <year> 1988. </year>
Reference-contexts: In this case, the computation mimics Prolog all too faithfully. [] We do not consider how to test whether bottom-up evaluation terminates on a given program. We refer the reader to <ref> [APPRSU86, KL87, KRS88] </ref> for some work on this problem. 7. Constraint Logic Programming We now describe how Constraint Logic Programming (CLP) can be implemented using the bottom-up approach we described in earlier sections. The ability to deal with rules that are not range-restricted is crucial.
Reference: [LM83] <author> J-L. Lassez and M.J. Maher, </author> <title> ``Closures and Fairness in the Semantics of Programming Logic,'' </title> <booktitle> Theoretical Computer Science. </booktitle>
Reference-contexts: Q) and a database D, the result of applying (P, Q) to D, which we also refer to as the set of answers to the query on D, is the set of all facts q which are instances of the query Q, and are logical consequences of P D. (See <ref> [VK76, LM83] </ref> for fixpoint characterizations of the set of answers.) We say that two programs with queries (P, Q) and (P`, Q`) are equivalent if, for every database D, P D and P` D produce the same answers for their respective queries. 2.
Reference: [LMM88] <author> J-L. Lassez, M.J. Maher, and K. Marriott, </author> <title> ``Unification Revisited,*In Foundations of Deductive Databases and Logic Programming, </title> <editor> Ed. J. Minker, </editor> <publisher> Morgan Kauf-man, </publisher> <year> 1988. </year>
Reference-contexts: We shall only consider substitutions such that domain range is empty, and this is understood unless otherwise stated in the rest of this paper. Such substitutions are idempotent <ref> [LMM88] </ref>. An element V i t i of a substitution is called a binding. We use the notation vars (o) to denote the set of all variables in the object o. (We follow [LMM88] in this presentation.) A unifier for two terms t 1 and t 2 is a substitution s <p> Such substitutions are idempotent <ref> [LMM88] </ref>. An element V i t i of a substitution is called a binding. We use the notation vars (o) to denote the set of all variables in the object o. (We follow [LMM88] in this presentation.) A unifier for two terms t 1 and t 2 is a substitution s such that t 1 s = t 2 s.
Reference: [MW88] <author> D. Maier and D.S. Warren, </author> <title> ``Computing with Logic: Logic Programming with Prolog,'' </title> <publisher> The Benjamin/Cummings Publishing Company, </publisher> <year> 1988. </year>
Reference-contexts: The rule that generates the fact (s) containing the input argument lists must therefore generate facts with free variables in them. This implies that the program must contain at least one rule that is not range-restricted. Let us consider another program that uses this technique. The following program, from <ref> [MW88] </ref>, breaks a list into two parts. The problem is that we may not know where to break the list until we process the first part. <p> To do this efficiently without stepping through the list in the first part, we use difference lists. (For a better appreciation of the power of difference lists, the reader is referred to <ref> [MW88] </ref> for an alternative program that does not use difference lists.) all (dlist (W,R)) :- firstpart (dlist (W,M)), secondpart (dlist (M,R)). firstpart (dlist ([1, 2|X], X)) :- . When executed as a Prolog program, the only argument of all is bound to a difference list.
Reference: [Na87] <author> J.F. Naughton, </author> <title> ``One-Sided Recursions,'' </title> <booktitle> Proc. ACM SIGMOD-SIGACT Symposium on Principles of Database Systems, </booktitle> <year> 1987. </year>
Reference-contexts: Examples of such methods include Counting [BeR87, BMSU86, SZ86a, SZ86b], the methods proposed in <ref> [HN84, Na87, Na88] </ref>. Typically, such methods seek to exploit the structure of the rules in some way that goes beyond sideways information passing, and are less generally applicable. However, our definition is sufficiently broad to include a large number of proposed strategies.
Reference: [Na88] <author> J.F. Naughton, </author> <title> ``Compiling Separable Recursions,'' </title> <booktitle> Proc. Sigmod, </booktitle> <year> 1988. </year>
Reference-contexts: Examples of such methods include Counting [BeR87, BMSU86, SZ86a, SZ86b], the methods proposed in <ref> [HN84, Na87, Na88] </ref>. Typically, such methods seek to exploit the structure of the rules in some way that goes beyond sideways information passing, and are less generally applicable. However, our definition is sufficiently broad to include a large number of proposed strategies.
Reference: [RLK86] <author> J. Rohmer, R. Lescoeur and J.M. Kerisit, </author> <title> ``The Alexander Method: A Technique for the Processing of Recursive Axioms in Deductive Databases,'' </title> <journal> New Generation Computing 4, </journal> <volume> 3, </volume> <year> 1986. </year>
Reference: [SZ86a] <author> D. Sacca and C. Zaniolo, </author> <title> ``On the Implementation of a Simple Class of Logic Queries for Databases,'' </title> <booktitle> Proc. ACM SIGMOD-SIGACT Symposium on Principles of Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: Examples of such methods include Counting <ref> [BeR87, BMSU86, SZ86a, SZ86b] </ref>, the methods proposed in [HN84, Na87, Na88]. Typically, such methods seek to exploit the structure of the rules in some way that goes beyond sideways information passing, and are less generally applicable. However, our definition is sufficiently broad to include a large number of proposed strategies.
Reference: [SZ86b] <author> D. Sacca and C. Zaniolo, </author> <title> ``The Generalized Counting Method for Recursive Logic Queries,'' </title> <booktitle> Proc. Intl. Conference on Database Theory, </booktitle> <year> 1986. </year>
Reference-contexts: Examples of such methods include Counting <ref> [BeR87, BMSU86, SZ86a, SZ86b] </ref>, the methods proposed in [HN84, Na87, Na88]. Typically, such methods seek to exploit the structure of the rules in some way that goes beyond sideways information passing, and are less generally applicable. However, our definition is sufficiently broad to include a large number of proposed strategies.
Reference: [Ul85] <author> J.D. Ullman, </author> <title> ``Implementation of Logical Query Languages for Databases,'' </title> <journal> TODS, </journal> <volume> Vol. 10, No. 3, </volume> <pages> pp. 289-321, </pages> <year> 1985. </year>
Reference-contexts: This program illustrates a sideways information passing strategy that is disallowed in [BeR87] because it cannot be efficiently implemented using the rewriting methods presented there. (This reflects a decision that is followed in most of the deductive database literature, and was first discussed in <ref> [Ul85] </ref>.) Consider a query p (X)? The following is a possible sip for the first rule: -q 1- fi Y q 2 Thus, we compute the entire relation q 1, but only a subset of q 2.
Reference: [VK76] <author> M.H. Van Emden and R.A. Kowalski, </author> <title> ``The Semantics of Predicate Logic as a Programming Language,'' </title> <journal> JACM, </journal> <volume> 23, 4, </volume> <month> Oct </month> <year> 1976. </year>
Reference-contexts: Q) and a database D, the result of applying (P, Q) to D, which we also refer to as the set of answers to the query on D, is the set of all facts q which are instances of the query Q, and are logical consequences of P D. (See <ref> [VK76, LM83] </ref> for fixpoint characterizations of the set of answers.) We say that two programs with queries (P, Q) and (P`, Q`) are equivalent if, for every database D, P D and P` D produce the same answers for their respective queries. 2.
Reference: [VG86] <author> A. Van Gelder, </author> <title> ``A Message Passing Framework for Recursive Query Evaluation,'' </title> <booktitle> Proc. SIGMOD, </booktitle> <year> 1986. </year>
Reference-contexts: These include Prolog, versions of top-down evaluation with memoing such as QSQ [Vi86] and Extension Tables [DW87], Static and Dynamic Filtering [KL86a, KL86b], and several parallel evaluation strategies proposed in the logic programming literature including those in <ref> [Ka87, VG86] </ref>. A strategy may generate additional queries, or facts, in addition to those that must be generated by conditions (1) and (2), and then we have good reason to consider it inferior to a sip-optimal strategy such as Magic Templates.
Reference: [Vi86] <author> L. Vieille, </author> <title> ``Recursive Axioms in Deductive Databases: The Query/Subquery Approach,'' </title> <booktitle> Proc. Intl. Conference on Expert Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: However, our definition is sufficiently broad to include a large number of proposed strategies. These include Prolog, versions of top-down evaluation with memoing such as QSQ <ref> [Vi86] </ref> and Extension Tables [DW87], Static and Dynamic Filtering [KL86a, KL86b], and several parallel evaluation strategies proposed in the logic programming literature including those in [Ka87, VG86].
Reference: [Vi88] <author> L. Vieille, </author> <title> ``From QSQ Towards QoSaQ: Global Optimization of Recursive Queries,'' </title> <booktitle> Proc. Intl. Conf. on Expert Database Systems, </booktitle> <year> 1988. </year> - -- 
Reference-contexts: However, there are strategies which use auxiliary information to avoid generating all answers to some subqueries, and these are not covered by our definition of a ``method''. An example of such a method is QoSaQ <ref> [Vi88] </ref>, when ``global optimization'' is used. (An appropriate comparison with such methods must weigh the advantage of inferring fewer facts and goals with the cost of maintaining and using the auxiliary information.) There are also strategies that do not proceed by generating subgoals on the given program, and these strategies are
References-found: 30

