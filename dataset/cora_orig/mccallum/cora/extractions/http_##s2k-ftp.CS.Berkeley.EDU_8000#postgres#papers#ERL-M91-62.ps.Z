URL: http://s2k-ftp.CS.Berkeley.EDU:8000/postgres/papers/ERL-M91-62.ps.Z
Refering-URL: http://www.cs.umd.edu/projects/hpsl/classes/818s-s98/cmcs818s-s98.htm
Root-URL: 
Title: THE POSTGRES NEXT GENERATION DBMS  
Author: Michael Stonebraker and Greg Kemnitz 
Address: Berkeley  
Affiliation: EECS Department University of California,  
Abstract: The purpose of the POSTGRES project was to build a next generation DBMS to rectify the known deficiencies in current relational DBMSs. This system, constructed over a four year period by one full time programmer and 3-4 part time students is operational and consists of about 180,000 lines of C. POST-GRES is available free of charge and is being used by perhaps 125 sites around the world. This paper describes the major concepts of the system and details its current state. We restrict our attention to the DBMS ``backend'' functions, and make only passing mention of the front end tools available for POST-GRES. 
Abstract-found: 1
Intro-found: 1
Reference: [AGRA89] <author> Agrawal, R. and Gehani, N., </author> <title> "ODE: The Language and the Data Model," </title> <booktitle> Proc. 1989 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Portland, Or., </address> <month> May </month> <year> 1989. </year>
Reference-contexts: Such an approach would offer persistence for variables in this programming language, as well as a query language integrated with the control statements of the language. This approach has been followed in ODE <ref> [AGRA89] </ref> and many of the recent object-oriented DBMSs. Our point of view is that most data bases are accessed by programs written in several different languages, and we do not see any programming language Esperanto on the horizon.
Reference: [BITT83] <author> Bitton, D. et. al., </author> <title> ``Benchmarking Database Systems: A Systematic Approach,'' </title> <booktitle> Proc. 1983 VLDB Conference, </booktitle> <address> Cannes, France, </address> <month> Sept. </month> <year> 1983. </year>
Reference-contexts: Section 5 continues with some of the implementation philosophy of POSTGRES. Section 6 indicates the current status of the system and indicates its current performance on a subset of the Wisconsin benchmark <ref> [BITT83] </ref> and on an engineering benchmark [CATT91]. Section 7 then ends the paper with a collection of conclusions. The POSTGRES DBMS has been under construction since 1986. The initial concepts for the system were presented in [STON86] and the initial data model appeared in [ROWE87]. <p> POSTGRES PERFORMANCE At the current time (June 1991) POSTGRES Version 2.1 has been distributed for nearly three months and has been installed by at least 125 sites. In this section we indicate POSTGRES, Version 2.1 performance on both the Wisconsin benchmark <ref> [BITT83] </ref> and on an engineering benchmark [CATT91]. For the Wisconsin benchmark, we compare POSTGRES with the University of California version of INGRES which we worked on from 1974-78. Figure 1 shows the performance of the two systems for a subset of the Wisconsin benchmark executing on a Sun SPARCstation.
Reference: [CARE88] <author> Carey, M. e t. al., </author> <title> ``A Data Model and Query Language for EXODUS,'' </title> <booktitle> Proc. 1988 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Chicago, Ill., </address> <month> June </month> <year> 1988. </year>
Reference-contexts: For example to find the age of the manager of Joe, one would write: retrieve (EMP.manager.age) where EMP.name = "Joe" rather than being forced to perform some sort of a join. This nested dot notation is also found in IRIS [WILK90], ORION [KIM90], O2 [DEUX90], and EXTRA <ref> [CARE88] </ref>. Composite types can have a value which is a function which returns the correct type, e.g: replace EMP (hobbies = compute-hobbies ("Jones")) where EMP.name = "Jones" We now turn to the POSTGRES notion of functions.
Reference: [CATT91] <author> Cattell, R., </author> <title> "An Engineering Database Benchmark," </title> <editor> in J. Gray, Ed, </editor> <title> The Benchmark Handbook for Database and Transaction Processing Systems," </title> <publisher> Morgan-Kaufmann, </publisher> <address> San Mateo, Ca., </address> <year> 1991. </year>
Reference-contexts: Section 5 continues with some of the implementation philosophy of POSTGRES. Section 6 indicates the current status of the system and indicates its current performance on a subset of the Wisconsin benchmark [BITT83] and on an engineering benchmark <ref> [CATT91] </ref>. Section 7 then ends the paper with a collection of conclusions. The POSTGRES DBMS has been under construction since 1986. The initial concepts for the system were presented in [STON86] and the initial data model appeared in [ROWE87]. <p> POSTGRES PERFORMANCE At the current time (June 1991) POSTGRES Version 2.1 has been distributed for nearly three months and has been installed by at least 125 sites. In this section we indicate POSTGRES, Version 2.1 performance on both the Wisconsin benchmark [BITT83] and on an engineering benchmark <ref> [CATT91] </ref>. For the Wisconsin benchmark, we compare POSTGRES with the University of California version of INGRES which we worked on from 1974-78. Figure 1 shows the performance of the two systems for a subset of the Wisconsin benchmark executing on a Sun SPARCstation. <p> There are still substantial inefficiencies in POSTGRES, especially in the code which checks that a retrieved record is valid. We expect that subsequent tuning planned for Version 3 will get us somewhere closer to ASK-INGRES. As a second benchmark, we report the performance of POSTGRES on the benchmark in <ref> [CATT91] </ref>. In this benchmark, we compare POSTGRES with the systems reported by Cattell, namely his in-house system, an OODB from one of the commercial vendors, and a commercial RDBMS. <p> The third set of results describes a "local" configuration for which both the application program and the data base reside on the same SUN 3/280. "Warm-local" numbers are omitted because they are essentially idential to the "warm-remote" results. The numbers for the other systems were reported in <ref> [CATT91] </ref> running on a different Sun 3/280. Because the disk on the Cattell system is dramatically faster than the the disk on the POSTGRES system, the comparison is not "apples to apples".
Reference: [CLOC81] <author> Clocksin, W. and Mellish, C., </author> <title> ``Programming in Prolog,'' </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1981. </year>
Reference-contexts: Moreover, if Fred's salary is not explicitly stored, then further rules would be awakened to find the ultimate answer, and a backward chaining control ow results. This control structure was popularized in Prolog <ref> [CLOC81] </ref>. If Fred receives frequent raises and Joe's salary is rarely queried, then the backward chaining representation will be more efficient. On the other hand, if many queries are directed to Joe's salary and Fred is rarely updated, then the forward chaining alternative is preferred.
Reference: [COMM90] <author> Committee for Advanced DBMS Function, </author> <title> "Third Generation Database System Manifesto, </title> <booktitle> SIGMOD Record, </booktitle> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Lastly, there are many rules that control newspaper layout. For example, the ad copy for two major department stores can never be on facing pages. Support for such rules is desirable in this application. A second example requiring all three services is indicated in <ref> [COMM90] </ref>. Hence, we believe that most real world data management problems that will arise in the 1990s are inherently three dimensional, and require data, object, and knowledge management services. The fundamental goal of POSTGRES [STON86, STON90, KEMN91B] is to provide support for such applications. <p> CONCLUSIONS This paper has presented the design, implementation and some of the philosophy of POSTGRES. We feel that it meets most of the "litmus test" presented in <ref> [COMM90] </ref>; hence, POSTGRES capabilities may serve as a beacon for future evolution of commercial systems. We expect to produce Version 3 of POSTGRES which should be available in the third quarter of 1991.
Reference: [DATE81] <author> Date, C., </author> <title> Referential Integrity, </title> <booktitle> Proc. Seventh International VLDB Conference, </booktitle> <address> Cannes, France, </address> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: THE RULES SYSTEM 3.1. Introduction It is clear to us that all DBMSs need a rules system. Current commercial systems are required to support referential integrity <ref> [DATE81] </ref>, which is merely a simple-minded collection of rules. However, there are a large number of more general rules which an application designer would want to support.
Reference: [DEUX90] <editor> Deux, O. et. al., </editor> <title> "The Story of O2," </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: For example to find the age of the manager of Joe, one would write: retrieve (EMP.manager.age) where EMP.name = "Joe" rather than being forced to perform some sort of a join. This nested dot notation is also found in IRIS [WILK90], ORION [KIM90], O2 <ref> [DEUX90] </ref>, and EXTRA [CARE88]. Composite types can have a value which is a function which returns the correct type, e.g: replace EMP (hobbies = compute-hobbies ("Jones")) where EMP.name = "Jones" We now turn to the POSTGRES notion of functions.
Reference: [ESWA76] <author> Eswaren, K., </author> <title> ``Specification, Implementation and Interactions of a Rule Subsystem in an Integrated Database System,'' </title> <institution> IBM Research, </institution> <address> San Jose, Ca., </address> <note> Research Report RJ1820, </note> <month> August </month> <year> 1976. </year>
Reference-contexts: In building the POSTGRES rules system we were motivated by the desire to construct one general purpose rules system that could perform all of the following functions: view management triggers integrity constraints referential integrity protection version control This should be contrasted with other approaches e.g. <ref> [ESWA76, MCCA89, WIDO90] </ref> which have different goals. 3.2.
Reference: [FORG81] <author> Forgy, C., </author> <title> "The OPS5 User's Manual," </title> <institution> Carneigie Mellon Univ., </institution> <type> Technical Report, </type> <year> 1981. </year>
Reference-contexts: These additional actions may activate other rules, and a forward chaining control ow results, as was popularized in OPS5 <ref> [FORG81] </ref>. 13 POSTGRES allows events to be retrieves as well as updates. Moreover, the action can be one or more queries.
Reference: [KATZ82] <author> Katz, R. and Lehman, T., </author> <title> "Storage Structures for Versions and Alternatives," </title> <institution> Computer Science Dept., University of Wisconsin, Madison, Wisc., </institution> <type> Report 479, </type> <month> July </month> <year> 1982. </year>
Reference-contexts: Of course, it is possible to support versions by making a complete copy of the class for the version and then making subsequent updates in the copy. More efficient algorithms which make u se of differential files are presented in <ref> [KATZ82, WOOD83] </ref>. In POSTGRES any user can create a version of a class as follows: create version my-EMP from EMP This command is supported by creating two differential classes for EMP: EMP-MINUS (deleted-OID) EMP-PLUS (all-fields-in EMP, replaced-OID) and installing a collection of rules.
Reference: [KEMN91] <author> Kemnitz, G. and Stonebraker, M., </author> <title> "The POSTGRES Tutorial," </title> <institution> Electronics Research Laboratory, Memorandum M91/82, </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: Version 2 followed in June 1990, and it included a new rules system documented in [STON90B]. We are now delivering Version 2.1, which is the subject of this paper. Further information on this system can be obtained from the reference manual [KEMN91B], the POSTGRES tutorial <ref> [KEMN91] </ref> and the release notes. POSTGRES is now about 180,000 lines of code in C and has been written by a team consisting of a full time chief programmer and 3-4 part time students.
Reference: [KEMN91B] <author> Kemnitz, G. (ed.), </author> <title> The POSTGRES Reference Manual, </title> <note> Version 2.1 Electronics Research Laboratory, </note> <institution> University of California, Berkeley, CA, Report M91/10, </institution> <month> February </month> <year> 1991. </year>
Reference-contexts: A second example requiring all three services is indicated in [COMM90]. Hence, we believe that most real world data management problems that will arise in the 1990s are inherently three dimensional, and require data, object, and knowledge management services. The fundamental goal of POSTGRES <ref> [STON86, STON90, KEMN91B] </ref> is to provide support for such applications. To accomplish this objective, o bject and rule management capabilities were added to the services found in a traditional data manager. In the next two sections we describe the capabilities provided in these two areas. <p> Version 2 followed in June 1990, and it included a new rules system documented in [STON90B]. We are now delivering Version 2.1, which is the subject of this paper. Further information on this system can be obtained from the reference manual <ref> [KEMN91B] </ref>, the POSTGRES tutorial [KEMN91] and the release notes. POSTGRES is now about 180,000 lines of code in C and has been written by a team consisting of a full time chief programmer and 3-4 part time students. <p> Such types can be added to the system while it is executing and require the defining user to specify functions to convert instances of the type to and from the character string data type. Details of the syntax appear in <ref> [KEMN91B] </ref>.
Reference: [KIM90] <author> Kim, W. et. al., </author> <title> "Architecture of the ORION Next-Generation Database System," </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: For example to find the age of the manager of Joe, one would write: retrieve (EMP.manager.age) where EMP.name = "Joe" rather than being forced to perform some sort of a join. This nested dot notation is also found in IRIS [WILK90], ORION <ref> [KIM90] </ref>, O2 [DEUX90], and EXTRA [CARE88]. Composite types can have a value which is a function which returns the correct type, e.g: replace EMP (hobbies = compute-hobbies ("Jones")) where EMP.name = "Jones" We now turn to the POSTGRES notion of functions.
Reference: [MCCA89] <author> McCarthy, D. a nd Dayal, U., </author> <title> "Architecture of an Active Database System," </title> <booktitle> Proc. 1989 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Portland, Ore., </address> <month> June </month> <year> 1989. </year>
Reference-contexts: In building the POSTGRES rules system we were motivated by the desire to construct one general purpose rules system that could perform all of the following functions: view management triggers integrity constraints referential integrity protection version control This should be contrasted with other approaches e.g. <ref> [ESWA76, MCCA89, WIDO90] </ref> which have different goals. 3.2.
Reference: [ONG90] <author> Ong, L. and Goh, J., </author> <title> "A Unified Framework for Version Modeling Using Production Rules in a Database System", </title> <institution> University of California, Electronics Research Laboratory, Memo UCB/ERL M90/33, </institution> <month> April </month> <year> 1990. </year>
Reference-contexts: EMP.OID NOTIN -EMP-PLUS.replaced-OID and EMP.OID NOTIN -EMP-MINUS.deleted-OID The delete rule for the version is similarly: on delete to my-EMP then do instead append to EMP-MINUS (deleted-OID = current.OID) where EMP.OID = current.OID delete EMP-PLUS where EMP-PLUS.OID = current.OID The interested reader can derive the replace and append rules or consult <ref> [ONG90] </ref> for a complete explanation. Also, there is a performance comparison in [ONG90] which shows that a rule system implementation of versions has comparable performance to an algorithmic implementation with hard-wired code deep in the executor. <p> version is similarly: on delete to my-EMP then do instead append to EMP-MINUS (deleted-OID = current.OID) where EMP.OID = current.OID delete EMP-PLUS where EMP-PLUS.OID = current.OID The interested reader can derive the replace and append rules or consult <ref> [ONG90] </ref> for a complete explanation. Also, there is a performance comparison in [ONG90] which shows that a rule system implementation of versions has comparable performance to an algorithmic implementation with hard-wired code deep in the executor.
Reference: [OSBO86] <author> Osborne, S. and Heaven, T., </author> <title> ``The Design of a Relational System with Abstract Data Types as Domains,'' </title> <journal> ACM TODS, </journal> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: Moreover, the words record, instance, and tuple are similarly interchangeable. In fact, previous descriptions of the POSTGRES data model (i.e. [ROWE87, STON90]) used other terminology than this paper. 5 turn. Some researchers, e.g. <ref> [STON86B, OSBO86] </ref>, have argued that one should be able to construct new base types such as bits, bitstrings, encoded character strings, bitmaps, compressed integers, packed decimal numbers, radix 50 decimal numbers, money, etc.
Reference: [RICH87] <author> Richardson, J. and Carey, M., </author> <title> ``Programming Constructs for Database System Implementation in EXODUS,'' </title> <booktitle> Proc. 1987 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> San Francisco, Ca., </address> <month> May </month> <year> 1987. </year>
Reference-contexts: In addition he can define functions which in turn make calls on POSTGRES internals. In this way, he can have considerable control over the low lev el ow of control, much as is available through a DBMS toolkit such as Exodus <ref> [RICH87] </ref>, but without all the effort involved in configuring a tailored DBMS from the toolkit. The above capability is called fast path because it provides direct access to specific functions without checking the validity of parameters.
Reference: [ROWE87] <author> Rowe, L. and Stonebraker, M., </author> <title> "The POSTGRES Data Model," </title> <booktitle> Proc. 1987 VLDB Conference, </booktitle> <address> Brighton, England, </address> <month> Sept </month> <year> 1987. </year>
Reference-contexts: Section 7 then ends the paper with a collection of conclusions. The POSTGRES DBMS has been under construction since 1986. The initial concepts for the system were presented in [STON86] and the initial data model appeared in <ref> [ROWE87] </ref>. Our storage manager concepts are detailed in [STON87], and the first rule system that we implemented is discussed in [STON88]. Our first "demo-ware" was operational in 1987, and we released Version 1 of POSTGRES to a few external users in June 1989. <p> Moreover, the words record, instance, and tuple are similarly interchangeable. In fact, previous descriptions of the POSTGRES data model (i.e. <ref> [ROWE87, STON90] </ref>) used other terminology than this paper. 5 turn. Some researchers, e.g. [STON86B, OSBO86], have argued that one should be able to construct new base types such as bits, bitstrings, encoded character strings, bitmaps, compressed integers, packed decimal numbers, radix 50 decimal numbers, money, etc.
Reference: [STON86] <author> Stonebraker, M. and Rowe, L., </author> <title> The Design of POSTGRES, </title> <booktitle> Proc. 1986 ACM-SIGMOD Conference, </booktitle> <address> Washington, D.C., </address> <month> June </month> <year> 1986. </year>
Reference-contexts: A second example requiring all three services is indicated in [COMM90]. Hence, we believe that most real world data management problems that will arise in the 1990s are inherently three dimensional, and require data, object, and knowledge management services. The fundamental goal of POSTGRES <ref> [STON86, STON90, KEMN91B] </ref> is to provide support for such applications. To accomplish this objective, o bject and rule management capabilities were added to the services found in a traditional data manager. In the next two sections we describe the capabilities provided in these two areas. <p> Section 7 then ends the paper with a collection of conclusions. The POSTGRES DBMS has been under construction since 1986. The initial concepts for the system were presented in <ref> [STON86] </ref> and the initial data model appeared in [ROWE87]. Our storage manager concepts are detailed in [STON87], and the first rule system that we implemented is discussed in [STON88].
Reference: [STON86B] <author> Stonebraker, M., </author> <title> Inclusion of New Types in Relational Data Base Systems, </title> <booktitle> Proc. Second International Conference on Data Engineering, </booktitle> <address> Los Angeles, Ca., </address> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: Moreover, the words record, instance, and tuple are similarly interchangeable. In fact, previous descriptions of the POSTGRES data model (i.e. [ROWE87, STON90]) used other terminology than this paper. 5 turn. Some researchers, e.g. <ref> [STON86B, OSBO86] </ref>, have argued that one should be able to construct new base types such as bits, bitstrings, encoded character strings, bitmaps, compressed integers, packed decimal numbers, radix 50 decimal numbers, money, etc. <p> With this information it can compute the expected cost of an indexed scan and compare it with a sequential scan. The general algorithm is sketched in <ref> [STON86B] </ref>. Basically, the optimizer is table-driven off the system catalogs, which describe the present storage configuration. POSTGRES assumes that data types, operators and functions can be added and subtracted dynamically, i.e. while the system is executing.
Reference: [STON87] <author> Stonebraker, M., </author> <title> "The POSTGRES Storage System," </title> <booktitle> Proc. 1987 VLDB Conference, </booktitle> <address> Brighton, England, </address> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: Section 7 then ends the paper with a collection of conclusions. The POSTGRES DBMS has been under construction since 1986. The initial concepts for the system were presented in [STON86] and the initial data model appeared in [ROWE87]. Our storage manager concepts are detailed in <ref> [STON87] </ref>, and the first rule system that we implemented is discussed in [STON88]. Our first "demo-ware" was operational in 1987, and we released Version 1 of POSTGRES to a few external users in June 1989. A critique of Version 1 of POSTGRES appears in [STON90]. <p> The run time system must distinguish these two kinds of instances and ignore the latter ones. The techniques used are discussed in <ref> [STON87] </ref>. This storage manager should be contrasted with a conventional one where the previous record is overwritten with a new one. In this case a write-ahead log is required to maintain the previous version of each record. <p> Hence, there is no possibility of instantaneous crash recovery. Clearly a no-overwrite storage manager is superior to a conventional one if it can be implemented at comparable performance. There is a brief hand-wav e of an argument in <ref> [STON87] </ref> that alleges this might be the case. In our opinion, the argument hinges around the existence of stable main memory. In the absence of stable memory, a no-overwrite storage manager must force to disk at commit time all pages written by a transaction. <p> To support time travel, POSTGRES maintains two d ifferent physical collections of records, one for the current data and one for historical data, each with its own indexes. As noted in <ref> [STON87] </ref> there is an asynchronous demon, which we call the vacuum cleaner, running in the background which moves records which are no longer valid from the current data base to the historical data base. <p> The 20 historical data base is formatted to perform well on an archival device such as an optical disk jukebox. Fur--ther details can be obtained from <ref> [STON87] </ref>. 5. THE POSTGRES IMPLEMENTATION POSTGRES contains a fairly conventional parser, query optimizer and execution engine. Four aspects of the implementation deserve special mention, the process structure extendability dynamic loading rule wake-up and we discuss each in turn. The first aspect of our design concerns the operating system process structure.
Reference: [STON87B] <author> Stonebraker, M. et. al., </author> <title> ``Extensibility in POSTGRES,'' </title> <journal> IEEE Database Engineering, </journal> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: Consequently, a B-tree index for oorspace in DEPT supports efficient access for the collection of operators -ALT, ALE, AE, AGT, A GE-. Information on the access paths 8 available for the various operators is recorded in the POSTGRES system catalogs. As pointed out in <ref> [STON87B] </ref> it is imperative that a user be able to construct new access methods to provide efficient access to instances of non-traditional base types. For example, suppose a user introduces a new operator "!!" that returns true if two polygons overlap.
Reference: [STON88] <author> Stonebraker, M. et. al., </author> <title> "The POSTGRES Rules System," </title> <journal> IEEE Transactions on Software Engineering, </journal> <month> July </month> <year> 1988. </year> <month> 27 </month>
Reference-contexts: The POSTGRES DBMS has been under construction since 1986. The initial concepts for the system were presented in [STON86] and the initial data model appeared in [ROWE87]. Our storage manager concepts are detailed in [STON87], and the first rule system that we implemented is discussed in <ref> [STON88] </ref>. Our first "demo-ware" was operational in 1987, and we released Version 1 of POSTGRES to a few external users in June 1989. A critique of Version 1 of POSTGRES appears in [STON90]. Version 2 followed in June 1990, and it included a new rules system documented in [STON90B].
Reference: [STON90] <author> Stonebraker, M. et. al., </author> <title> "The Implementation of POSTGRES," </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: A second example requiring all three services is indicated in [COMM90]. Hence, we believe that most real world data management problems that will arise in the 1990s are inherently three dimensional, and require data, object, and knowledge management services. The fundamental goal of POSTGRES <ref> [STON86, STON90, KEMN91B] </ref> is to provide support for such applications. To accomplish this objective, o bject and rule management capabilities were added to the services found in a traditional data manager. In the next two sections we describe the capabilities provided in these two areas. <p> Our first "demo-ware" was operational in 1987, and we released Version 1 of POSTGRES to a few external users in June 1989. A critique of Version 1 of POSTGRES appears in <ref> [STON90] </ref>. Version 2 followed in June 1990, and it included a new rules system documented in [STON90B]. We are now delivering Version 2.1, which is the subject of this paper. <p> Moreover, the words record, instance, and tuple are similarly interchangeable. In fact, previous descriptions of the POSTGRES data model (i.e. <ref> [ROWE87, STON90] </ref>) used other terminology than this paper. 5 turn. Some researchers, e.g. [STON86B, OSBO86], have argued that one should be able to construct new base types such as bits, bitstrings, encoded character strings, bitmaps, compressed integers, packed decimal numbers, radix 50 decimal numbers, money, etc.
Reference: [STON90B] <author> Stonebraker, M. et. al., </author> <title> ``On Rules, Procedures Caching and Views,'' </title> <booktitle> Proc. 1990 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Atlantic City, N.J., </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Our first "demo-ware" was operational in 1987, and we released Version 1 of POSTGRES to a few external users in June 1989. A critique of Version 1 of POSTGRES appears in [STON90]. Version 2 followed in June 1990, and it included a new rules system documented in <ref> [STON90B] </ref>. We are now delivering Version 2.1, which is the subject of this paper. Further information on this system can be obtained from the reference manual [KEMN91B], the POSTGRES tutorial [KEMN91] and the release notes. <p> In addition, if Joe is hired before Fred, then the markers must be added at the time Fred's record is inserted into the DBMS. To perform these tasks POSTGRES requires other markers which are discussed in <ref> [STON90B] </ref>. Also, if a rule 14 sets a sufficient number of markers in a class, then POSTGRES can perform marker escalation and place an enclosing marker on the entire class. Again details appear in [STON90B]. <p> To perform these tasks POSTGRES requires other markers which are discussed in <ref> [STON90B] </ref>. Also, if a rule 14 sets a sufficient number of markers in a class, then POSTGRES can perform marker escalation and place an enclosing marker on the entire class. Again details appear in [STON90B]. The record-level rules system is especially efficient if there are a large number of rules, and each covers only a few instances. In this case, no extra overhead will be required unless a marked instance is actually touched. <p> In <ref> [STON90B] </ref> we present a general algorithm which can rewrite any POSTGRES command to enforce any rule. In general, if there are N rules for a given class, then each user command will turn into a total of N + 1 resulting commands.
Reference: [STON91] <author> Stonebraker, M., </author> <title> "Managing Persistent Objects in a Multi-level Store," </title> <booktitle> Proc. 1991 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Denver, Co., </address> <month> May </month> <year> 1991. </year> <note> Research Laboratory, Memorandum M91/72, </note> <month> February </month> <year> 1991. </year>
Reference-contexts: We expect many l anguage specific interfaces to be built for POSTGRES and believe that the query language plus the fast path interface available in POSTGRES offers a powerful, convenient abstraction against which to build these programming language interfaces. The reader is directed to <ref> [STON91] </ref> which discusses our approach to embedding POSTGRES capabilities in C++. 3) small number of concepts We tried to build a data model with as few c oncepts as possible. The relational model succeeded in replacing previous data models in part because of its simplicity. <p> A first look at our ideas appears in <ref> [STON91] </ref>.
Reference: [WANG88] <author> Wang, Y., </author> <title> "The PICASSO Shared Object Hierarchy," </title> <type> MS Report, </type> <institution> University of California, Berkeley, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: Tight integration of POSTGRES to any particular language requires compiler extensions and a run time system specific to that programming language. Another research group has built an implementation of persistent CLOS (Common LISP Object System) on top of POSTGRES <ref> [WANG88] </ref> and we are planning a version of persistent C++ in the future. Persistent CLOS (or persistent X for any programming language, X) is inevitably language specific. The run-time system must map the disk representation for language objects, including pointers, into the main memory representation expected by the language.
Reference: [WIDO90] <author> Widom, J. and Finkelstein, S., </author> <title> "Set-Oriented Production Rules in Relational Database Systems," </title> <booktitle> Proc. 1990 ACM-SIGMOD Conference on Management of Data, </booktitle> <address> Atlantic City, N.J., </address> <month> June </month> <year> 1990. </year>
Reference-contexts: In building the POSTGRES rules system we were motivated by the desire to construct one general purpose rules system that could perform all of the following functions: view management triggers integrity constraints referential integrity protection version control This should be contrasted with other approaches e.g. <ref> [ESWA76, MCCA89, WIDO90] </ref> which have different goals. 3.2.
Reference: [WILK90] <author> Wilkinson, K. et. al., </author> <title> "The IRIS Architecture and Implementation," </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: For example to find the age of the manager of Joe, one would write: retrieve (EMP.manager.age) where EMP.name = "Joe" rather than being forced to perform some sort of a join. This nested dot notation is also found in IRIS <ref> [WILK90] </ref>, ORION [KIM90], O2 [DEUX90], and EXTRA [CARE88]. Composite types can have a value which is a function which returns the correct type, e.g: replace EMP (hobbies = compute-hobbies ("Jones")) where EMP.name = "Jones" We now turn to the POSTGRES notion of functions. <p> Using the latter interpretation, the user can restate the above query as: retrieve (EMP.name) where EMP.overpaid Hence, overpaid is interchangeably a function defined for each instance of EMP or a new attribute for EMP. The same interpretation of such functions appears in IRIS <ref> [WILK90] </ref>. C functions are arbitrary C procedures. Hence, they hav e arbitrary semantics and can run arbitrary POSTQUEL commands during execution. Therefore, queries with C functions in the qualification cannot be optimized by the POSTGRES query optimizer.
Reference: [WOOD83] <author> Woodfill, J. and Stonebraker, M., </author> " <title> An Implementation of Hypothetical Relations," </title> <booktitle> Proc. 9th VLDB Conference, </booktitle> <address> Florence, Italy, </address> <month> Sept. </month> <year> 1983. </year> <month> 28 </month>
Reference-contexts: Of course, it is possible to support versions by making a complete copy of the class for the version and then making subsequent updates in the copy. More efficient algorithms which make u se of differential files are presented in <ref> [KATZ82, WOOD83] </ref>. In POSTGRES any user can create a version of a class as follows: create version my-EMP from EMP This command is supported by creating two differential classes for EMP: EMP-MINUS (deleted-OID) EMP-PLUS (all-fields-in EMP, replaced-OID) and installing a collection of rules.
References-found: 31

