URL: http://www.cs.brown.edu/people/dgk/Papers/constraints.ps
Refering-URL: http://www.cs.brown.edu/people/dgk/papers.html
Root-URL: http://www.cs.brown.edu/
Email: dgk@cs.brown.edu  
Title: Constraint Query Algebras  
Author: DINA Q GOLDIN AND PARIS C. KANELLAKIS 
Keyword: database queries, constraint databases, data complexity, linear programming, quantifier elimination, relational algebra  
Address: Box 1910, Brown University, Providence, RI 02912  
Affiliation: Computer Science Department,  
Note: 1-41 c Kluwer Academic Publishers, Boston. Manufactured in The Netherlands.  
Abstract: Constraint query languages are natural extensions of relational database query languages. A framework for their declarative specification (constraint calculi) and efficient implementation (low data complexity and secondary storage indexing) was presented in Kanellakis et al., 1995. Constraint query algebras form a procedural language layer between high-level declarative calculi and low-level indexing methods. Just like the relational algebra, this intermediate layer can be very useful for program optimization. In this paper, we study properties of constraint query algebras, which we present through three concrete examples. The dense order constraint algebra illustrates how the appropriate canonical form can simplify expensive operations, such as projection, and facilitate interaction with updates. The monotone two-variable linear constraint algebra illustrates the concept of strongly polynomial operations. Finally, the lazy evaluation of (non)linear constraint algebras illustrates how large numbers of (non)linear constraints could be implemented with only a small amount of costly symbolic processing. 
Abstract-found: 1
Intro-found: 1
Reference: <author> S. Abiteboul, R. Hull, V. Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference: <author> L. Agre, J. S. Vitter. </author> <title> Optimal Interval Management in External Memory. </title> <type> Manuscript, </type> <month> November </month> <year> 1995. </year>
Reference: <author> A.V. Aho, J.E. Hopcroft, J.D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms, </title> <publisher> Addison-Wesley Publishing Co., </publisher> <year> 1974. </year>
Reference-contexts: By fixing the program size and letting the database grow, one can prove that the evaluation can be performed in PTIME or even in LOGSPACE, depending on the constraints considered <ref> (for models of efficient algorithms see Aho et al., 1974) </ref>. <p> Solving this problem is equivalent to deriving a regular expression for a given finite state automaton; the size of the resulting expression is polynomial in the size of M <ref> (see Aho et al., 1974) </ref>. It follows from Lemma 6 that the number of simple non-trivial paths from u to v is polynomial in the size of M.
Reference: <author> B. Aspvall, Y. Shiloach. </author> <title> A polynomial time algorithm for solving systems of linear inequalities with two variables per inequality. </title> <journal> SIAM J. Comput., </journal> <volume> 9:4:827-845, </volume> <year> 1980. </year> <title> 36 A.K. Aylamazyan, M.M. Gilula, A.P. Stolboushkin, G.F. Schwartz. Reduction of the Relational Model with Infinite Domain to the Case of Finite Domains. </title> <journal> Proc. USSR Acad. of Science (Doklady), </journal> <volume> 286(2) </volume> <pages> 308-311, </pages> <year> 1986. </year>
Reference-contexts: Checking each of these constraints for entailment is equivalent to checking its negation for consistency with t. 3. The consistency check for dense order constraints can be implemented via a shortest-path algorithm <ref> (Aspvall and Shiloach, 1980) </ref>. For a less naive implementation, we can avoid executing the shortest-path algorithm every time by storing its results in a complete directed graph (Dechter et al., 1991). We are now ready to define canonical relations and canonical databases consisting of such canonical tuples: Definition. 1.
Reference: <author> R. Bayer, E. McCreight. </author> <title> Organization of Large Ordered Indexes. </title> <journal> Acta Informatica, </journal> <volume> 1 </volume> <pages> 173-189, </pages> <year> 1972. </year>
Reference-contexts: I/O efficient (i.e., logarithmic or constant) use of secondary storage is an additional requirement, beyond low data complexity or strong polynomiality of operations, whose satisfaction greatly contributes to relational technology. B-trees (and their variants B + -trees) are examples of important data structures for implementing relational databases <ref> (see Bayer and McCreight, 1972) </ref>. Let each secondary memory access transmit B units of data, let r be a relation with N tuples, and let us have a B + -tree on the attribute x of r. The space used in this case is O (N=B).
Reference: <author> A.H. Borning. </author> <title> The Programming Language Aspects of ThingLab, A Constraint-Oriented Simulation Laboratory. </title> <journal> ACM TOPLAS 3:4:353-387, </journal> <year> 1981. </year>
Reference-contexts: Pioneering work in constraint programming goes back to the early 1960's, e.g., Sutherland's SKETCHPAD (Sutherland, 1963). The theme has been investigated since the 1970's, e.g., in artificial intelligence (Monta-nari, 1974; Mackworth, 1977; Freuder, 1978; Steele, 1980), in graphical-interfaces <ref> (Borning, 1981) </ref>, and in logic programming languages (Jaffar and Lassez, 1987; Dincbas et al., 1988; Colmerauer, 1990). The relevant literature and contributions are too large to attempt a survey. Instead we limit our exposition to recent applications in databases.
Reference: <author> A. Brodsky, J. Jaffar, M.J. Maher. </author> <title> Toward Practical Constraint Databases. </title> <booktitle> Proc. 19th VLDB, </booktitle> <pages> 322-331, </pages> <year> 1993. </year>
Reference: <author> A. K. Chandra and D. Harel. </author> <title> Structure and Complexity of Relational Queries. </title> <journal> J. Comp. System Sci., </journal> <volume> 25 </volume> <pages> 99-128, </pages> <year> 1982. </year>
Reference-contexts: Selection: & A=B (r) is the selection on r by A = B. (1) A; B 2 ff (r) and ff (& A=B (r)) = ff (r). Remark: Additional syntax for the selection operation can incorporate constants <ref> (Chandra and Harel, 1982) </ref>.
Reference: <author> J. Chomicki, D. Goldin, G. Kuper. </author> <title> Variable Independence and Aggregation Closure. </title> <booktitle> To appear in Proc. 15th ACM PODS, </booktitle> <month> June </month> <year> 1996. </year>
Reference-contexts: Additional operators may also prove useful, such as the generalized version of the "aggregation" operator <ref> (Chomicki et al., 1996) </ref>. The specification and implementation requirements of algebraic operations are detailed in Section 2.2. A minimal requirement is that each algebraic operation must be "efficiently implementable", where a lot depends on what efficient means. <p> Extensions to the relational model, involving partial information and complex object data types, can also be applied to CDBs. For example, null values can be introduced with existential quantification in constraints. Finite complex objects (Grumbach and Su, 1995) and aggregation over finite sets can co-exist with infinite relations <ref> (Chomicki et al., 1996) </ref>. Are there efficient ways of adding these extensions to constraint query algebras? Acknowledgments Paris C. Kanellakis, one of the authors of this paper, died in a tragic accident shortly after the completion of the first draft.
Reference: <author> J. Chomicki, T. Imielinski. </author> <title> Relational Specifications of Infinite Query Answers. </title> <booktitle> Proc. ACM SIGMOD, </booktitle> <pages> 174-183, </pages> <year> 1989. </year>
Reference-contexts: The CDB framework, while being a strict generalization of the standard relational framework, also provided a unified view of some previous database research: for example, on the power of constraints for the implicit specification of temporal data <ref> (Chomicki and Imielinski, 1989) </ref>, on relational query safety (Aylamazyan et al., 1986), on conjunctive queries with inequalities (Klug, 1988) and on extending magic sets (Ramakrishnan, 1988). Constraint query algebras form a procedural language layer between high-level declarative calculi and low-level access methods.
Reference: <author> E.F. Codd. </author> <title> A Relational Model for Large Shared Data Banks. </title> <journal> CACM, </journal> <volume> 13:6:377-387, </volume> <year> 1970. </year>
Reference-contexts: Instead we limit our exposition to recent applications in databases. The declarative style of database query languages is an important aspect of database systems, that has been at the core of the relational data model since Codd's pioneering work <ref> (Codd, 1970) </ref> on the declarative relational calculus and its equivalence to the procedural relational algebra. Indeed, having such languages for ad-hoc database querying is a requirement in today's relational technology (see Abiteboul et al., 1994; Kanellakis, 1990; Ullman, 1982). <p> A generalized database is a finite set of generalized relations. (3) The syntax of a CDB calculus is the union of a relational database query language and formulas in a decidable logical theory. For example: Relational calculus 6 <ref> (Codd, 1970) </ref> + the theory of real closed fields (Tarski, 1951; Renegar, 1992); Relational calculus (or even Inflationary Datalog : , Abiteboul et al., 1994) + the theory of dense order with constants (Ferrante and Geiser, 1977). (4) The semantics of CDB is based on that of the decidable logical theory, <p> It seems reasonable to limit computations to efficient ones, i.e., PTIME manipulations of the data. The CDB query framework 7 is interesting because many combinations of database query languages and decidable theories have PTIME data complexity. 2.2. Relational Algebra From Codd's original work <ref> (Codd, 1970) </ref> it follows that: Relational Calculus on finite sets can be evaluated bottom-up in closed form. This bottom-up evaluation, with LOGSPACE data complexity (Vardi, 1982), is known as the Relational Algebra. It serves as a model for the various Constraint Query Algebras we develop.
Reference: <author> A. Colmerauer. </author> <title> An Introduction to Prolog III. </title> <journal> CACM, </journal> <volume> 33:7:69-90, </volume> <year> 1990. </year>
Reference-contexts: Constraint Databases: Perhaps one of the most important advances in constraint programming in the 1980's has been the development of Constraint Logic Programming (CLP) as a general-purpose framework for computations, e.g., in CLP (&lt;) (Jaffar and Lassez, 1987), in Prolog III <ref> (Colmerauer, 1990) </ref>, and in CHIP (Dincbas et al., 1988; Van Hentenryck, 1989). The insight that led to CLP is: the unification mechanism of standard Logic Programming can be regarded as a trivial constraint solver (for equality constraints only).
Reference: <author> R. Dechter. </author> <title> From Local to Global Consistency. </title> <journal> Artificial Intelligence, </journal> <volume> 55 </volume> <pages> 87-107, </pages> <year> 1992. </year>
Reference: <author> R. Dechter, I. Meiri, J. Pearl. </author> <title> Temporal Constraint Networks. </title> <journal> Artificial Intelligence, </journal> <volume> 49 </volume> <pages> 61-95, </pages> <year> 1991. </year>
Reference-contexts: The property has been studied for temporal constraints <ref> (Dechter et al., 1991) </ref> where it was shown that: "a decomposable constraint set equivalent to a given one can be found in time polynomial in the size of the constraints for any number of variables k". (For an extensive treatment of temporal databases using constraint programming see Koubarakis, 1993). <p> However, there are subclasses of linear constraints where projection can be performed faster. For temporal constraints (of the type x y a), which reduce to dense order constraints when a = 0, computing projections is reducible to computing shortest paths <ref> (Dechter et al., 1991) </ref>, so strong polynomiality follows. In Section 3, we present an algebra for dense order constraints that addresses all of the issues raised here. This algebra could be extended to handle temporal constraints with no performance penalty. <p> The consistency check for dense order constraints can be implemented via a shortest-path algorithm (Aspvall and Shiloach, 1980). For a less naive implementation, we can avoid executing the shortest-path algorithm every time by storing its results in a complete directed graph <ref> (Dechter et al., 1991) </ref>. We are now ready to define canonical relations and canonical databases consisting of such canonical tuples: Definition. 1. A canonical relation over variables X = (x 1 ; : : : ; x n ) is a finite set of canonical tuples over X.
Reference: <author> M. Dincbas, P. Van Hentenryck, H. Simonis, A. Aggoun, T. Graf, F. Berthier. </author> <title> The Constraint Logic Programming Language CHIP. </title> <booktitle> Proc. Fifth Generation Computer Systems, </booktitle> <address> Tokyo Japan, </address> <year> 1988. </year>
Reference: <author> J. Ferrante, J.R. Geiser. </author> <title> An Efficient Decision Procedure for the Theory of Rational Order. </title> <journal> Theoretical Computer Science, </journal> <volume> 4 </volume> <pages> 227-233, </pages> <year> 1977. </year>
Reference-contexts: For example: Relational calculus 6 (Codd, 1970) + the theory of real closed fields (Tarski, 1951; Renegar, 1992); Relational calculus (or even Inflationary Datalog : , Abiteboul et al., 1994) + the theory of dense order with constants <ref> (Ferrante and Geiser, 1977) </ref>. (4) The semantics of CDB is based on that of the decidable logical theory, by interpreting database atoms as shorthands for formulas of the theory.
Reference: <author> E. Freuder. </author> <title> Synthesizing Constraint Expressions. </title> <journal> CACM, </journal> <volume> 21:11, </volume> <year> 1978. </year>
Reference: <author> E. Freuder. </author> <title> A sufficient condition for backtrack-free search. </title> <journal> CACM, </journal> <volume> 29:1, </volume> <year> 1982. </year>
Reference-contexts: As explained in Section 2.2, this algebra also has other good properties with respect to update operations. 4 (b): In Artificial Intelligence, the property of global consistency, also known as decomposability (Montanari, 1974), is desirable because it allows a backtrack-free search <ref> (Freuder, 1982) </ref>.
Reference: <author> S. Grumbach, J. Su. </author> <title> Dense Order Constraint Databases. </title> <booktitle> Proc. 14th ACM PODS, </booktitle> <month> May </month> <year> 1995, </year> <pages> pp. 66-77. </pages>
Reference-contexts: Extensions to the relational model, involving partial information and complex object data types, can also be applied to CDBs. For example, null values can be introduced with existential quantification in constraints. Finite complex objects <ref> (Grumbach and Su, 1995) </ref> and aggregation over finite sets can co-exist with infinite relations (Chomicki et al., 1996). Are there efficient ways of adding these extensions to constraint query algebras? Acknowledgments Paris C.
Reference: <author> S. Grumbach, J. Su, C. Tollu. </author> <title> Linear Constraint Query Languages: Expressive Power and Complexity. </title> <booktitle> Proc. Workshop on Finite Model Theory, </booktitle> <address> Indiana, </address> <month> Fall </month> <year> 1994. </year>
Reference-contexts: It is relatively easy to transform a calculus into an algebra, e.g., quantifier elimination is essentially this process. For example, with Fourier 3 Motzkin elimination (Schrijver, 1986) one easily derives a "naive" algebra for linear constraint databases <ref> (Grumbach et al., 1994) </ref>. What is a "good" algebra is harder to quantify, and this is what we attempt to do here.
Reference: <author> D. S. Hochbaum, J. Naor. </author> <title> Simple and Fast Algorithms for Linear and Integer Programs with two Variables per Inequality. </title> <journal> SIAM J. Comput., </journal> <volume> 23:6:1179-1192, </volume> <year> 1994. </year>
Reference-contexts: The existence of an algorithm for linear programming that is strongly polynomial, i.e., where the complexity does not depend on the coefficient sizes, is a major open question. 5 Strongly polynomial bounds have been achieved for the linear programming problem over sets of two-variable linear constraints <ref> (Hochbaum and Naor, 1994) </ref>; its time complexity is O (mk 2 logm). They present a modification of the Fourier-Motzkin algorithm, pruning away most of the constraints that are generated, while preserving equisatisfiability of the constraint sets.
Reference: <author> J. Jaffar, J.L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> Proc. 14th ACM POPL, </booktitle> <pages> 111-119, </pages> <year> 1987. </year>
Reference-contexts: Constraint Databases: Perhaps one of the most important advances in constraint programming in the 1980's has been the development of Constraint Logic Programming (CLP) as a general-purpose framework for computations, e.g., in CLP (&lt;) <ref> (Jaffar and Lassez, 1987) </ref>, in Prolog III (Colmerauer, 1990), and in CHIP (Dincbas et al., 1988; Van Hentenryck, 1989). The insight that led to CLP is: the unification mechanism of standard Logic Programming can be regarded as a trivial constraint solver (for equality constraints only).
Reference: <author> P.C. Kanellakis. </author> <title> Elements of Relational Database Theory. </title> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <volume> Vol. B, chapter 17, </volume> <editor> (J. van Leeuwen editor), </editor> <publisher> North-Holland, </publisher> <year> 1990. </year>
Reference-contexts: The positive fragment of Relational Algebra consists of the above operations except Difference. Note that Relational Algebra is equivalent to the domain-independent Relational Calculus for both finite and infinite (i.e., unrestricted) relations <ref> (Kanellakis, 1990) </ref>. For a given query, there is no unique algebraic expression to evaluate it. Algebraic transformations (such as selection propagation and join ordering) are heuristics for transforming algebraic expressions to equivalent ones that are likely to yield faster query evaluation, mostly by reducing the amount of I/O performed.
Reference: <author> P.C. Kanellakis and D.Q. Goldin. </author> <title> Constraint Programming and Database Query Languages. </title> <booktitle> Symposium on Theoretical Aspects of Computer Software, </booktitle> <volume> LNCS 789, </volume> <pages> pp. 96-120, </pages> <address> Sendai Japan, </address> <month> April </month> <year> 1994. </year>
Reference: <author> P. C. Kanellakis, G. M. Kuper, P. Z. Revesz. </author> <title> Constraint Query Languages. </title> <journal> JCSS, </journal> <volume> vol. 51, no.1, </volume> <pages> pp. 26-52, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Just like the relational algebra, this intermediate layer can be very useful for program optimization. Here, we study properties of constraint query algebras, which we present through concrete examples. Although rule-based intermediate constraint languages have been examined <ref> (Kanellakis et al., 1995) </ref> and optimized, (Mumick et al., 1990; Srivastava and Ramakrishnan, 1992; Brodsky et al., 1993; Stuckey and Sudarshan, 1994), much remains to be done. It is relatively easy to transform a calculus into an algebra, e.g., quantifier elimination is essentially this process. <p> In this subsection we examine the issues facing any designer of a Constraint Query Algebra (CQA) over some class of constraints C. CQA Closure: First, we want to make sure that for any CDB query calculus <ref> (see Kanellakis et al., 1995) </ref> expression, there exists an equivalent CQA expression. It is also highly desirable that there be an efficient translation between the two representations. In most cases, this requirement is satisfied using the closure condition; see (a) of the previous subsection. <p> The first-order CDB calculus for dense order is relational calculus combined with the decidable theory of dense order with constants <ref> (Kanellakis et al., 1995) </ref>. Every query can be expressed semantically as a relational calculus or algebra query on unrestricted (finite or infinite) relations over D n .
Reference: <author> P. C. Kanellakis, S. Ramaswamy, D. E. Vengroff, J. S. Vitter. </author> <title> Indexing for Data Models with Constraints and Classes. </title> <booktitle> Proc. 12th ACM PODS, </booktitle> <pages> 233-243, </pages> <year> 1993. </year> <note> To appear in JCSS. </note>
Reference: <author> A. Klug. </author> <title> On Conjunctive Queries Containing Inequalities. </title> <journal> JACM, </journal> <volume> 35:1:146-160, </volume> <year> 1988. </year>
Reference-contexts: being a strict generalization of the standard relational framework, also provided a unified view of some previous database research: for example, on the power of constraints for the implicit specification of temporal data (Chomicki and Imielinski, 1989), on relational query safety (Aylamazyan et al., 1986), on conjunctive queries with inequalities <ref> (Klug, 1988) </ref> and on extending magic sets (Ramakrishnan, 1988). Constraint query algebras form a procedural language layer between high-level declarative calculi and low-level access methods. Just like the relational algebra, this intermediate layer can be very useful for program optimization.
Reference: <author> M. Koubarakis. </author> <title> Foundations of Temporal Constraint Databases. </title> <type> PhD Thesis. </type> <institution> Nat. Tech. Univ. of Athens and Imperial College. </institution> <year> 1993. </year>
Reference: <author> A.K. Mackworth. </author> <title> Consistency in Networks of Relations. </title> <booktitle> AI, </booktitle> <address> 8:1, </address> <year> 1977. </year>
Reference: <author> U. Montanari. </author> <title> Networks of Constraints: Fundamental Properties and Application to Picture Processing. </title> <journal> Information Science, </journal> <volume> 7, </volume> <year> 1974. </year>
Reference-contexts: As explained in Section 2.2, this algebra also has other good properties with respect to update operations. 4 (b): In Artificial Intelligence, the property of global consistency, also known as decomposability <ref> (Montanari, 1974) </ref>, is desirable because it allows a backtrack-free search (Freuder, 1982).
Reference: <author> I. S. Mumick, S. J. Finkelstein, H. Pirahesh, R. Ramakrishnan. </author> <title> Magic Conditions. </title> <booktitle> Proc. 9th ACM PODS, </booktitle> <pages> 314-330, </pages> <year> 1990. </year>
Reference: <author> G. Nelson. </author> <title> An n log n algorithm for the two-variable-per-constraint linear programming satisfia-bility problem. </title> <type> Technical Report AIM-319, </type> <institution> Stanford University, </institution> <year> 1978. </year>
Reference: <author> J. Paredaens, J. van den Bussche, D. Van Gucht. </author> <title> First-order Queries on Finite Structures over the Reals. </title> <booktitle> Proc. IEEE LICS, </booktitle> <year> 1995. </year>
Reference: <author> F.P. Preparata, M.I. Shamos. </author> <title> Computational Geometry: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year> <title> 37 R. Ramakrishnan. Magic Templates: A Spellbinding Approach to Logic Programs. </title> <booktitle> Proc. 5th International Conference on Logic Programming, </booktitle> <pages> 141-159, </pages> <year> 1988. </year>
Reference-contexts: The use of generalized one-dimensional indexes reduces redundancy of representation and transforms one-dimensional searching on generalized relational attribute 35 x into the problem of dynamic interval management. This is a well-known problem with many elegant solutions from computational geometry <ref> (Preparata and Shamos, 1985) </ref>. Optimal in-core dynamic interval management is one of the basic tools of computational geometry. However, I/O optimal solutions are non-trivial, even for the static case.
Reference: <author> S. Ramaswamy, S. Subramanian. </author> <title> Path Caching: A Technique for Optimal External Searching. </title> <booktitle> Proc. 13th ACM PODS, </booktitle> <pages> 14-25, </pages> <year> 1994. </year>
Reference: <author> J. Renegar. </author> <title> On the Computational Complexity and Geometry of the First-order Theory of the Reals: Parts I-III. </title> <journal> Journal of Symbolic Computation, </journal> <volume> 13 </volume> <pages> 255-352, </pages> <year> 1992. </year>
Reference: <author> H. Samet. </author> <title> The Design and Analysis of Spatial Data Structures. </title> <publisher> Addison-Wesley, </publisher> <address> Reading MA, </address> <year> 1990. </year>
Reference: <author> A. Schrijver. </author> <title> Theory of Linear and Integer Programming. </title> <publisher> John Wiley and Sons, </publisher> <year> 1986. </year>
Reference-contexts: It is relatively easy to transform a calculus into an algebra, e.g., quantifier elimination is essentially this process. For example, with Fourier 3 Motzkin elimination <ref> (Schrijver, 1986) </ref> one easily derives a "naive" algebra for linear constraint databases (Grumbach et al., 1994). What is a "good" algebra is harder to quantify, and this is what we attempt to do here. <p> What is a "good" algebra is harder to quantify, and this is what we attempt to do here. The example algebras we consider involve: (1) dense order constraints (see Fer-rante and Geiser, 1977; Kanellakis et al., 1995; Klug, 1988), (2) linear inequality constraints <ref> (see the comprehensive survey in Schrijver, 1986) </ref>, and (3) lazy evaluation of linear and nonlinear constraints (for real polynomial constraints see Tarski, 1951; for recent developments and a symbolic computation survey see Renegar, 1992, and for numerical computation see Van Hentenryck et al., 1995). <p> The argument in favor of lazy evaluation hinges on the complexity gap between performing satisfiability checks and performing variable elimination for sets of linear constraints. The former is polynomial whereas the latter is exponential <ref> (Schrijver, 1986) </ref>. What's worse, variable elimination can be exponential just because of the size of the result (Yannakakis, 1988) if a non-lazy, or "eager", representation is used. <p> This is due to the fact that computing projections onto a single variable x is equivalent to the optimization problem for a set of linear constraints, where we seek the minimum and the maximum allowable values for x. These optimization problems have polynomial complexity <ref> (Schrijver, 1986) </ref>, giving us an interval over x that is used in the indexing scheme. The extraneous variables in the lazy representation will of course need to be removed (via projection) when the relation is output to the user.
Reference: <author> D. Srivastava, R. Ramakrishnan. </author> <title> Pushing Constraint Selections. </title> <booktitle> Proc. 11th ACM PODS, </booktitle> <pages> 301-316, </pages> <year> 1992. </year>
Reference: <author> G.L. Steele. </author> <title> The Definition and Implementation of a Computer Programming Language Based on Constraints. </title> <type> Ph.D. thesis, </type> <institution> MIT, </institution> <address> AI-TR 595, </address> <year> 1980. </year>
Reference: <author> P.J. Stuckey, S. Sudarshan. </author> <title> Compiling Query Constraints. </title> <booktitle> Proc. 13th ACM PODS, </booktitle> <pages> 56-68, </pages> <year> 1994. </year>
Reference: <author> I.E. Sutherland. </author> <title> SKETCHPAD: A Man-Machine Graphical Communication System. </title> <publisher> Spartan Books, </publisher> <year> 1963. </year>
Reference-contexts: Programming with constraints as primitives (or constraint programming) is appealing because constraints are the normal language of discourse for many high-level applications. Pioneering work in constraint programming goes back to the early 1960's, e.g., Sutherland's SKETCHPAD <ref> (Sutherland, 1963) </ref>. The theme has been investigated since the 1970's, e.g., in artificial intelligence (Monta-nari, 1974; Mackworth, 1977; Freuder, 1978; Steele, 1980), in graphical-interfaces (Borning, 1981), and in logic programming languages (Jaffar and Lassez, 1987; Dincbas et al., 1988; Colmerauer, 1990).
Reference: <author> R.E. Tarjan. </author> <title> A Unified Approach to Path Problems. </title> <journal> JACM, </journal> <volume> 28:3:577-593, </volume> <year> 1981. </year>
Reference-contexts: In this subsection, we analyze the complexity of the algorithm. We start with an introduction to path expressions <ref> (Tarjan, 1981) </ref> and show a connection between the size of the path expression and the number of simple nontrivial paths in the corresponding set. We then show that Algorithm II is strongly polynomial.
Reference: <author> A. Tarski. </author> <title> A Decision Method for Elementary Algebra and Geometry. </title> <institution> University of California Press, Berkeley, California, </institution> <year> 1951. </year>
Reference: <author> J. D. Ullman. </author> <booktitle> Principles of Database Systems, </booktitle> <address> 2 nd edition. </address> <publisher> Computer Science Press, </publisher> <year> 1982. </year>
Reference: <author> P. Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: We call such variables extraneous, as opposed to essential. The approach is akin to the CLP approach to constraint stores, where many variables will not participate in the output <ref> (Van Hentenryck, 1989) </ref>. What matters is that the constraints are satisfiable, i.e., for some assignment of values to the extraneous variables, the essential variables will form a tuple in the constraint store. For 32 linear constraints, satisfiability can be guaranteed using linear programming.
Reference: <author> P. Van Hentenryck, D. McAllester, D. Kapur. </author> <title> Solving Polynomial Systems using a Branch and Prune Approach. </title> <type> Brown CS Tech. Rep. </type> <institution> CS-95-01, </institution> <year> 1995. </year> <note> To appear in the SIAM J. of Numerical Analysis. </note>
Reference-contexts: For 32 linear constraints, satisfiability can be guaranteed using linear programming. For nonlinear constraints, satisfiability can be implemented efficiently using numerical methods <ref> (Van Hentenryck et al., 1995) </ref>. Lazy Evaluation: The approach that we propose involves delaying the symbolic processing (quantifier/variable elimination) whenever possible. We call this approach lazy evaluation, borrowing this terminology from functional programming. The resulting representation of generalized relations, containing unevaluated existentially quantified variables, is called the lazy representation.
Reference: <author> M. Y. Vardi. </author> <title> The Complexity of Relational Query Languages. </title> <booktitle> Proc. 14th ACM STOC, </booktitle> <pages> 137-146, </pages> <year> 1982. </year>
Reference-contexts: Relational Algebra From Codd's original work (Codd, 1970) it follows that: Relational Calculus on finite sets can be evaluated bottom-up in closed form. This bottom-up evaluation, with LOGSPACE data complexity <ref> (Vardi, 1982) </ref>, is known as the Relational Algebra. It serves as a model for the various Constraint Query Algebras we develop. Relational Algebra is based on a small number of primitive operations on relations, i.e., sets of tuples without duplicates.

References-found: 48

