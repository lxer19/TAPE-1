URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/037.ps
Refering-URL: ftp://ftp.cs.utexas.edu/pub/boyer/cli-reports/index.html
Root-URL: http://www.cs.utexas.edu
Phone: (512) 322-9951  
Title: A Mechanically Verified Code Generator  
Author: William D. Young 
Note: This work was supported in part at Computational Logic, Inc. by the Defense Advanced Research Projects Agency, ARPA Orders 6082 and 9151. The views and conclusions contained in this document are those of the author and should not be interpreted as representing the official policies, either expressed or implied, of Computational Logic, Inc., the Defense Advanced Research Projects Agency or the U.S. Government.  
Address: 1717 W. 6th St. Suite 290 Austin, Texas 78703  
Affiliation: Computational Logic Inc.  
Date: 37 January, 1989  
Pubnum: Technical Report  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> R. Aubin. </author> <title> Mechanizing Structural Induction. </title> <type> Ph.D. </type> <institution> Th., University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <year> 1976. </year>
Reference-contexts: The first attempt to prove compilation correct via an interpreter equivalence proof seems to be the proof of McCarthy and Painter [18] of a simple expression compiler. Various extensions to this work have been reported <ref> [6, 19, 7, 1, 4] </ref>. Other interpreter equivalence proofs of direct relevance to ours are reported in [13, 21, 2].
Reference: 2. <author> W.R. Bevier. </author> <title> Kit: A Study in Operating System Verification. </title> <type> Tech. </type> <institution> Rept. CLI-28, Computational Logic, Inc., </institution> <month> August, </month> <year> 1988. </year>
Reference-contexts: Our code generator is one level of a stack of verified system components including an assembler and linking loader for Piton and a microprocessor design verified at the register transfer level [13]. Parallel research addresses the issue of verified operating system functionality <ref> [2] </ref>. The integration of these components into a vertically verified system is addressed in a companion paper [3]. 2 Because our source language is a subset of Gypsy, we have the option of verifying the correctness of user-level programs in the Gypsy Verification Environment [11]. <p> The initial value of the temporary stack in our Piton execution environment would be: index contents represents 9 unused above here 8 (INT 4202) I 7 (BOOL T) B2 6 (INT 25) A [4] 4 (INT 0) A <ref> [2] </ref> 2 (INT -294) A [0] 0 (BOOL F) B1 Piton contains instructions for storing and retrieving elements at arbitrary positions in the temporary stack. Thus the temporary stack serves as a random access "memory" in the implementation. <p> Various extensions to this work have been reported [6, 19, 7, 1, 4]. Other interpreter equivalence proofs of direct relevance to ours are reported in <ref> [13, 21, 2] </ref>. Several compiler proofs have used axiomatic semantics [8, 16] and much work has been directed toward specifying and proving compilers using denotational semantics [20, 9], The most notable previous mechanical compiler proof is by Polak [23].
Reference: 3. <author> W.R. Bevier, W.A. Hunt, J S. Moore, W.D. Young. </author> <title> Overview of the Short Stack. </title> <booktitle> Tech. Rept. In Progress, Computational Logic, </booktitle> <publisher> Inc., </publisher> <year> 1989. </year>
Reference-contexts: Parallel research addresses the issue of verified operating system functionality [2]. The integration of these components into a vertically verified system is addressed in a companion paper <ref> [3] </ref>. 2 Because our source language is a subset of Gypsy, we have the option of verifying the correctness of user-level programs in the Gypsy Verification Environment [11]. <p> The general strategy for defining such interpreter equivalence theorems and some potential pitfalls are discussed in the companion paper <ref> [3] </ref>. The actual correctness result for the Micro-Gypsy translator is the following theorem in the Boyer-Moore logic: 12 Theorem.
Reference: 4. <author> R.S. Boyer, J S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1979. </year>
Reference-contexts: The official arbiter of our claim that we have provided a rigorous formal proof of a code generator for a significant subset of Gypsy is a list of "events" in the computational logic of Boyer and Moore <ref> [4, 5] </ref>. That list is sufficient to lead the Boyer-Moore theorem prover enhanced with an interactive interface by Matt Kaufmann [14] to the proof of our main theorem. <p> The initial value of the temporary stack in our Piton execution environment would be: index contents represents 9 unused above here 8 (INT 4202) I 7 (BOOL T) B2 6 (INT 25) A <ref> [4] </ref> 4 (INT 0) A [2] 2 (INT -294) A [0] 0 (BOOL F) B1 Piton contains instructions for storing and retrieving elements at arbitrary positions in the temporary stack. Thus the temporary stack serves as a random access "memory" in the implementation. <p> Thus the temporary stack serves as a random access "memory" in the implementation. Notice that the values of both character variable CH and the integer array element A <ref> [4] </ref> are represented by the same Piton INT value at the Piton level. <p> The first attempt to prove compilation correct via an interpreter equivalence proof seems to be the proof of McCarthy and Painter [18] of a simple expression compiler. Various extensions to this work have been reported <ref> [6, 19, 7, 1, 4] </ref>. Other interpreter equivalence proofs of direct relevance to ours are reported in [13, 21, 2].
Reference: 5. <author> R. S. Boyer and J S. Moore. </author> <title> A Computational Logic Handbook. </title> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: The official arbiter of our claim that we have provided a rigorous formal proof of a code generator for a significant subset of Gypsy is a list of "events" in the computational logic of Boyer and Moore <ref> [4, 5] </ref>. That list is sufficient to lead the Boyer-Moore theorem prover enhanced with an interactive interface by Matt Kaufmann [14] to the proof of our main theorem.
Reference: 6. <author> R.M. Burstall. </author> <title> "Proving Properties of Programs by Structural Induction". </title> <journal> Computer Journal 12, </journal> <month> 1 (February </month> <year> 1969), </year> <pages> 41-48. </pages>
Reference-contexts: The first attempt to prove compilation correct via an interpreter equivalence proof seems to be the proof of McCarthy and Painter [18] of a simple expression compiler. Various extensions to this work have been reported <ref> [6, 19, 7, 1, 4] </ref>. Other interpreter equivalence proofs of direct relevance to ours are reported in [13, 21, 2].
Reference: 7. <author> R. Cartwright. </author> <title> A Practical Formal Semantic Definition and Verification System for Typed LISP. </title> <type> Ph.D. </type> <institution> Th., Stanford University, </institution> <year> 1976. </year>
Reference-contexts: A sample mg-state is (MG-STATE 'NORMAL ; current condition '((B BOOLEAN-MG (BOOLEAN-MG TRUE-MG)) ; variable alist (I INT-MG (INT-MG -24)) (K INT-MG (INT-MG 0)) (A (ARRAY-MG CHARACTER-MG 3) ((CHARACTER-MG 78) (CHARACTER-MG 73) <ref> (CHARACTER-MG 76) </ref>))) 'RUN) ; psw With respect to this mg-state, a potential entry point for our multiplication routine is the Micro-Gypsy statement (PROC-CALL-MG MG_MULTIPLY (K I J) NIL). 6 (MG_MULTIPLY ((ANS INT-MG) (J INT-MG)) ((K INT-MG (INT-MG 0)) (ZERO INT-MG (INT-MG 0)) (B BOOLEAN-MG (BOOLEAN-MG FALSE-MG))) NIL (PROG2-MG (PREDEFINED-PROC-CALL-MG MG-INTEGER-LE (B <p> and a sufficiently large clock value, the meaning assigned by our interpreter to the entry point statement (PROC-CALL-MG MG_MULTIPLY (K I J) NIL) is the following Micro-Gypsy state. (MG-STATE 'NORMAL '((B BOOLEAN-MG (BOOLEAN-MG TRUE-MG)) (I INT-MG (INT-MG -24)) (K INT-MG (INT-MG -480)) (A (ARRAY-MG CHARACTER-MG 3) ((CHARACTER-MG 78) (CHARACTER-MG 73) <ref> (CHARACTER-MG 76) </ref>))) 'RUN) Notice that this is identical to our initial state except that the value of the variable K has been set equal to the product of the values of variables I and J, as expected. <p> The first attempt to prove compilation correct via an interpreter equivalence proof seems to be the proof of McCarthy and Painter [18] of a simple expression compiler. Various extensions to this work have been reported <ref> [6, 19, 7, 1, 4] </ref>. Other interpreter equivalence proofs of direct relevance to ours are reported in [13, 21, 2].
Reference: 8. <author> L.M. Chirica and D.F. Martin. </author> <title> An Approach to Compiler Correctness. </title> <booktitle> Proceedings of the International Conference on Reliable Software, </booktitle> <month> April, </month> <year> 1975, </year> <pages> pp. 96-103. </pages>
Reference-contexts: Various extensions to this work have been reported [6, 19, 7, 1, 4]. Other interpreter equivalence proofs of direct relevance to ours are reported in [13, 21, 2]. Several compiler proofs have used axiomatic semantics <ref> [8, 16] </ref> and much work has been directed toward specifying and proving compilers using denotational semantics [20, 9], The most notable previous mechanical compiler proof is by Polak [23]. Polak uses denotational semantics to describe both the source and target languages.
Reference: 9. <author> A. Cohn. </author> <title> Machine Assisted Proofs of Recursion Implementation. </title> <type> Ph.D. </type> <institution> Th., University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <year> 1979. </year>
Reference-contexts: Other interpreter equivalence proofs of direct relevance to ours are reported in [13, 21, 2]. Several compiler proofs have used axiomatic semantics [8, 16] and much work has been directed toward specifying and proving compilers using denotational semantics <ref> [20, 9] </ref>, The most notable previous mechanical compiler proof is by Polak [23]. Polak uses denotational semantics to describe both the source and target languages. His work is less rigorous than ours; his proof has as a basis a large collection of unproved assumptions within the formal theory.
Reference: 10. <author> D.I. Good, R.L. Akers, L.M. Smith. </author> <title> Report on Gypsy 2.05. </title> <type> Tech. </type> <institution> Rept. CLI-1, Computational Logic, Inc., </institution> <month> October, </month> <year> 1986. </year>
Reference-contexts: In this paper we describe the implementation and proof of a code generator, a major component of a compiler. The source language is a subset of Gypsy (version 2.05) <ref> [10] </ref> and the target language is the Piton [21] assembly level language. Our code generator is one level of a stack of verified system components including an assembler and linking loader for Piton and a microprocessor design verified at the register transfer level [13].
Reference: 11. <author> D.I. Good, B.L. Divito, M.K. Smith. </author> <title> Using The Gypsy Methodology. </title> <type> Tech. </type> <note> Rept. Draft CLI-2, Computational Logic, </note> <institution> Inc., </institution> <month> January, </month> <year> 1988. </year>
Reference-contexts: The integration of these components into a vertically verified system is addressed in a companion paper [3]. 2 Because our source language is a subset of Gypsy, we have the option of verifying the correctness of user-level programs in the Gypsy Verification Environment <ref> [11] </ref>. Verified programs are compiled into Piton using the code generator; the resulting programs are then assembled into a load image for the FM8502 microprocessor. Thus the semantics of the verified high-level program is provably preserved through several translation steps to an implementation at the hardware level.
Reference: 12. <author> W. Henhapl and C.B. Jones. </author> <title> The Block Structure Concept and Some Possible Implementations. </title> <type> Tech. </type> <institution> Rept. 25.104, IBM Laboratories, Vienna, </institution> <year> 1970. </year>
Reference-contexts: McCarthy [17] seems to have been the first to define a language (LISP) operationally. It was realized quite early that operational (interpreter) style definitions provided a means of investigating a variety of implementations and opened the possibility of proving the equivalence of interpreters <ref> [15, 12] </ref>. The first attempt to prove compilation correct via an interpreter equivalence proof seems to be the proof of McCarthy and Painter [18] of a simple expression compiler. Various extensions to this work have been reported [6, 19, 7, 1, 4].
Reference: 13. <author> W.A. Hunt. </author> <title> The Mechanical Verification of a Microprocessor Design. </title> <type> Tech. </type> <institution> Rept. CLI-6, Computational Logic, Inc., </institution> <month> September, </month> <year> 1986. </year>
Reference-contexts: Our code generator is one level of a stack of verified system components including an assembler and linking loader for Piton and a microprocessor design verified at the register transfer level <ref> [13] </ref>. Parallel research addresses the issue of verified operating system functionality [2]. <p> We construct our p-state with an awareness that Piton is ultimately implemented on the FM8502 verified microprocessor <ref> [13] </ref>. We fix the word size at 32, for example, in Micro-Gypsy and in the p-states we generate because that is the word size of the verified Piton implementation. <p> Various extensions to this work have been reported [6, 19, 7, 1, 4]. Other interpreter equivalence proofs of direct relevance to ours are reported in <ref> [13, 21, 2] </ref>. Several compiler proofs have used axiomatic semantics [8, 16] and much work has been directed toward specifying and proving compilers using denotational semantics [20, 9], The most notable previous mechanical compiler proof is by Polak [23].
Reference: 14. <author> Matt Kaufmann. </author> <title> A User's Manual for an Interactive Enhancement to the Boyer-Moore Theorem Prover. </title> <type> Tech. </type> <institution> Rept. CLI-19, Computational Logic, Inc., </institution> <month> May, </month> <year> 1988. </year>
Reference-contexts: That list is sufficient to lead the Boyer-Moore theorem prover enhanced with an interactive interface by Matt Kaufmann <ref> [14] </ref> to the proof of our main theorem. <p> (NAT 0) (NAT 0) (NAT 0) (NAT 0))) 100 100 ;; resource limitations 32 'RUN) ;; word size and psw 20 Chapter 6 THE PROOF The correctness theorem for the Micro-Gypsy code generator has been checked mechanically by the Boyer-Moore theorem prover enhanced with an interactive interface by Matt Kaufmann <ref> [14] </ref>. In this chapter we describe the overall structure of the proof. The interested reader is directed to [26] for more details. Recall that our main theorem is a formalization of the following commuting diagram.
Reference: 15. <author> P. Lucas. </author> <title> Two Constructive Realizations of the Block Concept and Their Realization. </title> <type> Tech. </type> <institution> Rept. 25.082, IBM Laboratories, Vienna, </institution> <year> 1968. </year>
Reference-contexts: McCarthy [17] seems to have been the first to define a language (LISP) operationally. It was realized quite early that operational (interpreter) style definitions provided a means of investigating a variety of implementations and opened the possibility of proving the equivalence of interpreters <ref> [15, 12] </ref>. The first attempt to prove compilation correct via an interpreter equivalence proof seems to be the proof of McCarthy and Painter [18] of a simple expression compiler. Various extensions to this work have been reported [6, 19, 7, 1, 4].
Reference: 16. <author> D.S. Lynn. </author> <title> Interactive Compiler Proving Using Hoare Proof Rules. </title> <type> Tech. </type> <institution> Rept. ISI/RR-78-70, Information Sciences Institute, </institution> <month> January, </month> <year> 1978. </year>
Reference-contexts: Various extensions to this work have been reported [6, 19, 7, 1, 4]. Other interpreter equivalence proofs of direct relevance to ours are reported in [13, 21, 2]. Several compiler proofs have used axiomatic semantics <ref> [8, 16] </ref> and much work has been directed toward specifying and proving compilers using denotational semantics [20, 9], The most notable previous mechanical compiler proof is by Polak [23]. Polak uses denotational semantics to describe both the source and target languages.
Reference: 17. <author> John McCarthy. </author> <title> Towards a Mathematical Science of Computation. </title> <booktitle> Proceedings of the IFIP Congress, </booktitle> <address> Amsterdam, </address> <year> 1962. </year>
Reference-contexts: However, this uses the same logic and is a relatively benign set of enhancements. 27 Chapter 8 RELATED WORK We have followed a long tradition in defining our languages in an operational style. McCarthy <ref> [17] </ref> seems to have been the first to define a language (LISP) operationally. It was realized quite early that operational (interpreter) style definitions provided a means of investigating a variety of implementations and opened the possibility of proving the equivalence of interpreters [15, 12].
Reference: 18. <author> John McCarthy and J. Painter. </author> <title> Correctness of a Compiler for Arithmetic Expressions. </title> <booktitle> Proceeding of Symposium on Applied Mathematics, </booktitle> <publisher> American Mathematical Society, </publisher> <year> 1967. </year>
Reference-contexts: The first attempt to prove compilation correct via an interpreter equivalence proof seems to be the proof of McCarthy and Painter <ref> [18] </ref> of a simple expression compiler. Various extensions to this work have been reported [6, 19, 7, 1, 4]. Other interpreter equivalence proofs of direct relevance to ours are reported in [13, 21, 2].
Reference: 19. <author> R. Milner and R. Weyhrauch. </author> <title> Proving Compiler Correctness in a Mechanized Logic. </title> <booktitle> In Machine Intelligence 7, </booktitle> <publisher> Edinburgh University Press, Edinburgh, </publisher> <address> Scotland, </address> <year> 1972, </year> <pages> pp. 51-70. </pages>
Reference-contexts: The first attempt to prove compilation correct via an interpreter equivalence proof seems to be the proof of McCarthy and Painter [18] of a simple expression compiler. Various extensions to this work have been reported <ref> [6, 19, 7, 1, 4] </ref>. Other interpreter equivalence proofs of direct relevance to ours are reported in [13, 21, 2].
Reference: 20. <author> R. Milne and C. Strachey. </author> <title> A Theory of Programming Language Semantics. </title> <publisher> Chapman and Hall, </publisher> <address> London, </address> <year> 1976. </year>
Reference-contexts: Other interpreter equivalence proofs of direct relevance to ours are reported in [13, 21, 2]. Several compiler proofs have used axiomatic semantics [8, 16] and much work has been directed toward specifying and proving compilers using denotational semantics <ref> [20, 9] </ref>, The most notable previous mechanical compiler proof is by Polak [23]. Polak uses denotational semantics to describe both the source and target languages. His work is less rigorous than ours; his proof has as a basis a large collection of unproved assumptions within the formal theory.
Reference: 21. <author> J S. Moore. </author> <title> A Mechanically Verified Language Implementation. </title> <type> Tech. </type> <institution> Rept. CLI-30, Computational Logic, Inc., </institution> <month> September, </month> <year> 1988. </year>
Reference-contexts: In this paper we describe the implementation and proof of a code generator, a major component of a compiler. The source language is a subset of Gypsy (version 2.05) [10] and the target language is the Piton <ref> [21] </ref> assembly level language. Our code generator is one level of a stack of verified system components including an assembler and linking loader for Piton and a microprocessor design verified at the register transfer level [13]. Parallel research addresses the issue of verified operating system functionality [2]. <p> The Piton instruction set, its semantics, its implementation on the FM8502 microprocessor, and the proof of the correctness of this implementation is fully described in [22] and summarized in <ref> [21] </ref>. 11 Chapter 4 THE CORRECTNESS OF THE MICRO-GYPSY CODE GENERATOR The translator from Micro-Gypsy to Piton takes a Micro-Gypsy execution environment (including the program) and creates a Piton state. This is implemented as a function MAP-DOWN in the Boyer-Moore logic. <p> Various extensions to this work have been reported [6, 19, 7, 1, 4]. Other interpreter equivalence proofs of direct relevance to ours are reported in <ref> [13, 21, 2] </ref>. Several compiler proofs have used axiomatic semantics [8, 16] and much work has been directed toward specifying and proving compilers using denotational semantics [20, 9], The most notable previous mechanical compiler proof is by Polak [23].
Reference: 22. <author> J S. Moore. PITON: </author> <title> A Verified Assembly Level Language. </title> <type> Tech. </type> <institution> Rept. CLI-22, Computational Logic, Inc., </institution> <month> June, </month> <year> 1988. </year> <month> 32 </month>
Reference-contexts: The Piton instruction set, its semantics, its implementation on the FM8502 microprocessor, and the proof of the correctness of this implementation is fully described in <ref> [22] </ref> and summarized in [21]. 11 Chapter 4 THE CORRECTNESS OF THE MICRO-GYPSY CODE GENERATOR The translator from Micro-Gypsy to Piton takes a Micro-Gypsy execution environment (including the program) and creates a Piton state. This is implemented as a function MAP-DOWN in the Boyer-Moore logic.
Reference: 23. <author> W. Polak. </author> <title> Compiler Specification and Verification. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: Several compiler proofs have used axiomatic semantics [8, 16] and much work has been directed toward specifying and proving compilers using denotational semantics [20, 9], The most notable previous mechanical compiler proof is by Polak <ref> [23] </ref>. Polak uses denotational semantics to describe both the source and target languages. His work is less rigorous than ours; his proof has as a basis a large collection of unproved assumptions within the formal theory. Polak's work also does not have the larger context of the verified stack.
Reference: 24. <author> L.C. Ragland. </author> <title> A Verified Program Verifier. </title> <type> Ph.D. </type> <institution> Th., University of Texas at Austin, </institution> <year> 1973. </year>
Reference-contexts: Some of the benefits of a GVE-style proof could be gained while retaining these advantages by writing a verification condition generator for Micro-Gypsy within the Boyer-Moore framework. This is a separate research topic which we have not investigated in detail, though some research has been aimed in this direction <ref> [24] </ref>. 7 We intend to write a verified preprocessor, but this has not yet been done. 8 We in fact used Matt Kaufmann's interactive interface to the Boyer-Moore prover in our proofs.
Reference: 25. <author> W.D. Young. </author> <title> A Verified Optimizer for Pico-Piton. Internal Note 107, </title> <month> December, </month> <year> 1988, </year> <title> Computational Logic, </title> <publisher> Inc., </publisher> <address> Austin, Texas. </address>
Reference-contexts: It would be relatively easy to 30 define and prove a peephole optimizer that operated on the code generator output. This would be an interpreter equivalence proof where both the source and target language interpreters were the Piton interpreter. An initial study has been done on this <ref> [25] </ref>. 31

References-found: 25

