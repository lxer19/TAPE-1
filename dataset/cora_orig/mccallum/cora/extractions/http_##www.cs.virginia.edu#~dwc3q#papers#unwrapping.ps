URL: http://www.cs.virginia.edu/~dwc3q/papers/unwrapping.ps
Refering-URL: http://www.cs.virginia.edu/~dwc3q/homepage/resume.html
Root-URL: http://www.cs.virginia.edu
Email: Email: fsullivan,coppitg@cs.virginia.edu  
Title: Unwrapping  
Author: David W. Coppit and Kevin J. Sullivan 
Date: May 4, 1998  
Address: Thornton Hall, Charlottesville, VA 22903  
Affiliation: University of Virginia Department of Computer Science  
Pubnum: Technical Report CS-98-08  
Abstract: A key driver of software obsolescence is change in hardware and system software standards. In the area of software tools, there is now great pressure to host on Intel/Windows platforms tool functions that in the past were typically found in Unix or mainframe environments. In such cases, there can be value in reusing core parts of such legacy systems. Two standard methods for doing this are reengineering and wrapping. Reengineer-ing, being unrestricted in the changes allowed, permits the removal of obsolete parts of a system but creates the risk that changes will break the complex and brittle reused code. Wrapping involves the reuse of existing code without change, but at the cost of including obsolete elements into the new environment. In this paper we propose unwrapping as a new synthesis of these two approaches. To unwrap is to remove unwanted design elements, but with a strong emphasis on leaving core code unchanged. We discuss our preliminary use of this approach to reuse core elements of two Unix-based reliability engineering tools in a modern tool based on package-oriented programming. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Ronald C. Aronica and Donald E. Rimel Jr. </author> <title> Wrapper your legacy systems. </title> <journal> Datamation, </journal> <volume> 42(12), </volume> <month> June </month> <year> 1996. </year>
Reference-contexts: The first is reengineering, which Chikovsky and Cross define as "the examination and alteration of a subject system to reconstitute it in a new form and the subsequent implementation of the new form [10]." The second is wrapping <ref> [1, 33] </ref>, in which an existing system is wholly incorporated into a new one behind an information hiding interface. A strength and weakness of reengineering is that it tacitly sanctions arbitrary changes to existing code. The benefit is that suboptimal elements can be removed and beneficial architectures can be imposed. <p> Much of the interest comes from the business sector, where CORBA [23], OLE [5] and similar developments enable encapsulation of legacy systems behind distributed object-oriented interfaces. The theory of wrapping was addressed by Parodi [24], 8 who identified four major types of wrappers, and Aron--ica and Rimel <ref> [1] </ref> who examined implementation issues. Wiederhold's CHAIMS [25] defines a high-level language for composing large modules, often wrapped versions of legacy systems running on legacy platforms and invoked by remote procedure call.
Reference: [2] <author> Larry E. Baker Jr. </author> <title> C++ interfaces for C-language libraries. </title> <journal> Dr. Dobb's Journal, </journal> <volume> 22(8):34, </volume> <pages> 36-7, 90-1, </pages> <month> August </month> <year> 1997. </year>
Reference-contexts: Wiederhold's CHAIMS [25] defines a high-level language for composing large modules, often wrapped versions of legacy systems running on legacy platforms and invoked by remote procedure call. Baker described procedures for wrapping C-language libraries using C++ <ref> [2] </ref>, and Van Camp used wrappers to improve library portability [6]. Flint [16] wrapped legacy COBOL applications using an object-oriented wrapper. Reznick wrapped Unix applications to enhance their functionality [27]. The HP Encapsulator provides a wrapper-based framework for integrating Unix tools into the HP SoftBench environment [17].
Reference: [3] <author> Grace Baratta-Perez, Richard L. Conn, Charles A. Finnell, and Thomas J. Walsh. </author> <title> Ada system dependency analyzer tool. </title> <journal> IEEE Computer, </journal> <volume> 27(2) </volume> <pages> 49-55, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: Automated approaches to user interface reengineering such as that used by Csaba [12] and Claen, et al. [11] might be used to help unwrap and rebind complex text-based user interfaces utilizing menus and windows. Tool support for automatically identifying system dependencies, such as the work of Baratta-Perez et al. <ref> [3] </ref>, also offers a good first step in separating core code from superstructure. 6.2 Wrapping Unlike unwrapping, wrapping is now a widely known approach to legacy code integration. Much work has been done in this area.
Reference: [4] <author> Mark A. Boyd and Salvatore J. Bavuso. </author> <title> Simulation modeling for long duration spacecraft control systems. </title> <booktitle> In Proceedings of the Annual Reliability and Maintainability Symposium, </booktitle> <pages> pages 106-13, </pages> <address> At-lanta, Georgia, </address> <month> 26-28 January </month> <year> 1993. </year> <note> IEEE. </note>
Reference-contexts: Galileo is an engineering tool into which we have integrated computational cores from two Unix-based legacy fault tree analysis tools: DIFTree [18] and MCI-HARP <ref> [4] </ref>. Next, Sections 3 and 4 present details of the unwrapping of the legacy cores. Section 5 presents our evaluation of the unwrapping concept based on work done to date. Section 6 discusses research related to unwrapping. <p> common format exchanged between SplitTrees and the subtree solvers, with object translators replacing the parsers in the legacy system. 4 The MCI-HARP Case Study Our second application of unwrapping was the integration, into Galileo, of another fault tree solving engine called the Monte Carlo Integrated Hybrid Automated Reliability Predictor (MCI-HARP) <ref> [4] </ref>. Using Monte Carlo techniques, the program simulates stochastic failures of the basic elements of a fault tree to determine what ratio lead to overall system failure.
Reference: [5] <author> K. Brockschmidt. </author> <title> Inside OLE. </title> <publisher> Microsoft Press, </publisher> <address> Redmond WA, </address> <note> second edition, </note> <year> 1995. </year>
Reference-contexts: Much work has been done in this area. Much of the interest comes from the business sector, where CORBA [23], OLE <ref> [5] </ref> and similar developments enable encapsulation of legacy systems behind distributed object-oriented interfaces. The theory of wrapping was addressed by Parodi [24], 8 who identified four major types of wrappers, and Aron--ica and Rimel [1] who examined implementation issues.
Reference: [6] <author> Kenneth E. Van Camp. </author> <title> Using wrappers to improve portability of commercial libraries. </title> <journal> C Users Journal, </journal> <volume> 11(1) </volume> <pages> 35-37, 40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Wiederhold's CHAIMS [25] defines a high-level language for composing large modules, often wrapped versions of legacy systems running on legacy platforms and invoked by remote procedure call. Baker described procedures for wrapping C-language libraries using C++ [2], and Van Camp used wrappers to improve library portability <ref> [6] </ref>. Flint [16] wrapped legacy COBOL applications using an object-oriented wrapper. Reznick wrapped Unix applications to enhance their functionality [27]. The HP Encapsulator provides a wrapper-based framework for integrating Unix tools into the HP SoftBench environment [17].
Reference: [7] <author> G. Canfora, Aniello Cimitile, and M. Munro. </author> <title> A reverse engineering method for identifying reusable abstract data types. </title> <booktitle> In Proceedings of Working Conference on Reverse Engineering, </booktitle> <pages> pages 73-82, </pages> <address> Baltimore, MD, USA, </address> <month> 21-23 May </month> <year> 1993. </year> <note> IEEE. </note>
Reference-contexts: Etzkorn and Davis, for example, seek natural-language and structure-analysis-based tools for "identifying reusable subroutines or code fragments in legacy systems [15]." Similarly, the reuse re-engineering work of Cimitle, Canfora, et al. <ref> [7, 8, 9] </ref>, is founded on the basic notion of candidature, which involves the application of code analysis, often using semantically powerful tools, to identify potentially reusable elements in poorly understood legacy code.
Reference: [8] <author> G. Canfora, Aniello Cimitile, and M. Munro. </author> <title> Re 2 : Reverse-engineering and reuse re-engineering. </title> <journal> Journal of Software Maintenance: Research and Practice, </journal> <pages> pages 53-72, </pages> <month> March-April </month> <year> 1994. </year>
Reference-contexts: Etzkorn and Davis, for example, seek natural-language and structure-analysis-based tools for "identifying reusable subroutines or code fragments in legacy systems [15]." Similarly, the reuse re-engineering work of Cimitle, Canfora, et al. <ref> [7, 8, 9] </ref>, is founded on the basic notion of candidature, which involves the application of code analysis, often using semantically powerful tools, to identify potentially reusable elements in poorly understood legacy code.
Reference: [9] <author> G. Canfora, Aniello Cimitile, M. Munro, and C.J. Taylor. </author> <title> Extracting abstract data types from C programs: A case study. </title> <booktitle> In 1993 Conference on Software Maintenance, </booktitle> <pages> pages 200-9, </pages> <address> Quebec, Canada, </address> <month> 27-30 September </month> <year> 1993. </year> <journal> IEEE. </journal> <volume> 9 </volume>
Reference-contexts: Etzkorn and Davis, for example, seek natural-language and structure-analysis-based tools for "identifying reusable subroutines or code fragments in legacy systems [15]." Similarly, the reuse re-engineering work of Cimitle, Canfora, et al. <ref> [7, 8, 9] </ref>, is founded on the basic notion of candidature, which involves the application of code analysis, often using semantically powerful tools, to identify potentially reusable elements in poorly understood legacy code.
Reference: [10] <author> Elliot J. Chikofsky and James H. </author> <title> Cross II. Re--verse engineering and design recovery: A taxonomy. </title> <journal> IEEE Software, </journal> <volume> 7(1) </volume> <pages> 13-17, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: There are two traditional approaches to the exploitation of code embedded in depreciating systems. The first is reengineering, which Chikovsky and Cross define as "the examination and alteration of a subject system to reconstitute it in a new form and the subsequent implementation of the new form <ref> [10] </ref>." The second is wrapping [1, 33], in which an existing system is wholly incorporated into a new one behind an information hiding interface. A strength and weakness of reengineering is that it tacitly sanctions arbitrary changes to existing code.
Reference: [11] <author> Ingo Claen, Klaus Hennig, Ingo Mohr, and Michael Schulz. </author> <title> CUI to GUI migration: Static analysis of character-based panels. </title> <booktitle> In Proceedings. First Euromicro Conference on Software Maintenance and Reengineering, </booktitle> <pages> pages 144-9, </pages> <address> Berlin, Ger-many, 17-19 March 1997. </address> <publisher> IEEE. </publisher>
Reference-contexts: The use of semantically light-weight approaches, such as reflexion model techniques [22], promises to be especially valuable as an aid in unwrapping. Automated approaches to user interface reengineering such as that used by Csaba [12] and Claen, et al. <ref> [11] </ref> might be used to help unwrap and rebind complex text-based user interfaces utilizing menus and windows.
Reference: [12] <author> Laszlo Csaba. </author> <title> Experience with user interface reengineering: Transferring DOS panels to Windows. </title> <booktitle> In Proceedings. First Euromicro Conference on Software Maintenance and Reengineering, </booktitle> <pages> pages 150-5, </pages> <address> Berlin, Germany, 17-19 March 1997. </address> <publisher> IEEE. </publisher>
Reference-contexts: The use of semantically light-weight approaches, such as reflexion model techniques [22], promises to be especially valuable as an aid in unwrapping. Automated approaches to user interface reengineering such as that used by Csaba <ref> [12] </ref> and Claen, et al. [11] might be used to help unwrap and rebind complex text-based user interfaces utilizing menus and windows.
Reference: [13] <author> Robert DeLine, Gregory Zelesnik, and Mary Shaw. </author> <title> Lessons on converting batch systems to support interaction. </title> <booktitle> In Proceedings of the 19th International Conference on Software Engineering, </booktitle> <pages> pages 195-204, </pages> <address> Boston, Massachusetts, </address> <month> 17-23 May </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: Many of these techniques might be useful in wrapping core code once unwrapped. 6.3 Repackaging DeLine et al. describe lessons that they learned from a case study in converting batch systems to support interaction <ref> [13] </ref>. The conversion of the UNICON system required them to "break open" the computation to modify the original assumptions made by the system with regard to partial processing, error prevention, control paradigm, etc.
Reference: [14] <author> Joanne Bechta Dugan, Kishor S. Trivedi, Mark K. Smotherman, and Robert M. Geist. </author> <title> The hybrid automated reliability predictor. </title> <journal> Journal of Guidance, Control, and Dynamics, </journal> <volume> 9(3) </volume> <pages> 319-31, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: The tradeoffs made during the work described in this section were in favor of time instead of long-term system structure. MCI-HARP has had a long history, beginning in 1981 as simply HARP, developed at Duke and Clemson universities <ref> [14] </ref>. About seven years later HARP was used in a Monte Carlo simulator (MCI-HARP) built at Northwestern University [26]. For about the past five years, the system has undergone several enhancements at NASA, and is now called MCI-HARP. All told, about 20 people at four institutions have worked on it.
Reference: [15] <author> Letha H. Etzkorn and Carl G. Davis. </author> <title> Automatically identifying reusable OO legacy code. </title> <journal> IEEE Computer, </journal> <volume> 30(10) </volume> <pages> 66-71, </pages> <year> 1997. </year>
Reference-contexts: The work seeks tools and techniques to identify and then to extract candidate reusable code, which is then evaluated and reengineered for purposes of populating a reuse library. Etzkorn and Davis, for example, seek natural-language and structure-analysis-based tools for "identifying reusable subroutines or code fragments in legacy systems <ref> [15] </ref>." Similarly, the reuse re-engineering work of Cimitle, Canfora, et al. [7, 8, 9], is founded on the basic notion of candidature, which involves the application of code analysis, often using semantically powerful tools, to identify potentially reusable elements in poorly understood legacy code.
Reference: [16] <author> E. S. Flint. </author> <title> The COBOL jigsaw puzzle: Fitting object-oriented and legacy applications together. </title> <journal> IBM Systems Journal, </journal> <volume> 36(1) </volume> <pages> 49-65, </pages> <month> January </month> <year> 1997. </year>
Reference-contexts: Wiederhold's CHAIMS [25] defines a high-level language for composing large modules, often wrapped versions of legacy systems running on legacy platforms and invoked by remote procedure call. Baker described procedures for wrapping C-language libraries using C++ [2], and Van Camp used wrappers to improve library portability [6]. Flint <ref> [16] </ref> wrapped legacy COBOL applications using an object-oriented wrapper. Reznick wrapped Unix applications to enhance their functionality [27]. The HP Encapsulator provides a wrapper-based framework for integrating Unix tools into the HP SoftBench environment [17].
Reference: [17] <author> Brian D. Fromme. </author> <title> HP Encapsulator: Bridging the generation gap. </title> <journal> Hewlett-Packard Journal: Technical Information from the Labratories of Hewlett-Packard Company, </journal> <volume> 41(3) </volume> <pages> 59-68, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Flint [16] wrapped legacy COBOL applications using an object-oriented wrapper. Reznick wrapped Unix applications to enhance their functionality [27]. The HP Encapsulator provides a wrapper-based framework for integrating Unix tools into the HP SoftBench environment <ref> [17] </ref>. Many of these techniques might be useful in wrapping core code once unwrapped. 6.3 Repackaging DeLine et al. describe lessons that they learned from a case study in converting batch systems to support interaction [13].
Reference: [18] <author> Rohit Gulati and Joanne Bechta Dugan. </author> <title> A modular approach for analyzing static and dynamic fault trees. </title> <booktitle> In Proceedings of the Annual Reliability and Maintainability Symposium, </booktitle> <pages> pages 57-63, </pages> <address> Philadel-phia, Pennsylvania, </address> <month> January </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: In the next section we make the idea of unwrapping concrete by discussing the integration of legacy tool code into our fault tree analysis tool called Galileo. Galileo is an engineering tool into which we have integrated computational cores from two Unix-based legacy fault tree analysis tools: DIFTree <ref> [18] </ref> and MCI-HARP [4]. Next, Sections 3 and 4 present details of the unwrapping of the legacy cores. Section 5 presents our evaluation of the unwrapping concept based on work done to date. Section 6 discusses research related to unwrapping.
Reference: [19] <author> S. C. Johnson. </author> <title> YACC | Yet another compiler-compiler. </title> <note> Computing Science Technical Report No. 32, </note> <institution> Bell Laboratories, </institution> <address> Murray Hill, N.J., </address> <year> 1975. </year>
Reference-contexts: We accomplished this by unwrapping SplitTrees to remove its file output, and then creating a wrapper that populated the data structures of a Galileo fault tree object. Since the input routines of SplitTrees and Dyna-Solver used LEX and YACC <ref> [19, 21] </ref> we were able to leverage the semantic action rules of the parsers to determine how to populate the legacy data structures based on a given Galileo fault tree object.
Reference: [20] <author> Douglas Lea. libg++, </author> <title> the GNU C++ library. </title> <booktitle> In USENIX proceedings: C++ Conference, </booktitle> <pages> pages 243-56, </pages> <address> Denver, Colorado, </address> <month> 17-21 October </month> <year> 1988. </year> <institution> USENIX Association. </institution>
Reference-contexts: In invoking Dysol.pl and Stsol.pl, DIFTree depended on the availability of Perl, and on the meaning of shell redirection. DIFTree also depended on the Gnu C++ library <ref> [20] </ref>, since it relied on particular definitions and on a memory allocation component called Obstack. Furthermore, the code assumed a specific version of the compiler that allowed the use of constructs that later versions did not.
Reference: [21] <author> M. E. Lesk and E. Schmidt. </author> <title> Lex | A lexical analyzer generator. </title> <note> Computing Science Technical Report No. 39, </note> <institution> Bell Laboratories, </institution> <address> Murray Hill, N.J., </address> <year> 1975. </year>
Reference-contexts: We accomplished this by unwrapping SplitTrees to remove its file output, and then creating a wrapper that populated the data structures of a Galileo fault tree object. Since the input routines of SplitTrees and Dyna-Solver used LEX and YACC <ref> [19, 21] </ref> we were able to leverage the semantic action rules of the parsers to determine how to populate the legacy data structures based on a given Galileo fault tree object.
Reference: [22] <author> Gail C. Murphy, David Notkin, and Kevin Sulli-van. </author> <title> Software reflexion models: Bridging the gap between source and high-level models. </title> <booktitle> SIGSOFT Software Engineering Notes, </booktitle> <volume> 20(4) </volume> <pages> 18-28, </pages> <month> October </month> <year> 1995. </year>
Reference-contexts: We have not used semantically rich tools to date, owing to the real-world messiness of our legacy systems, which are written in multiple languages, which use Unix-based composition mechanisms, and so forth. The use of semantically light-weight approaches, such as reflexion model techniques <ref> [22] </ref>, promises to be especially valuable as an aid in unwrapping. Automated approaches to user interface reengineering such as that used by Csaba [12] and Claen, et al. [11] might be used to help unwrap and rebind complex text-based user interfaces utilizing menus and windows.
Reference: [23] <author> CORBA: </author> <title> Architecture and Specification. Object Management Group, </title> <publisher> Inc., </publisher> <year> 1995. </year>
Reference-contexts: Much work has been done in this area. Much of the interest comes from the business sector, where CORBA <ref> [23] </ref>, OLE [5] and similar developments enable encapsulation of legacy systems behind distributed object-oriented interfaces. The theory of wrapping was addressed by Parodi [24], 8 who identified four major types of wrappers, and Aron--ica and Rimel [1] who examined implementation issues.
Reference: [24] <author> John Parodi. </author> <title> Building "wrappers" for legacy software application. </title> <address> URL: http://www.digital. com/objectbroker/product/obwp_wrap.htm. </address>
Reference-contexts: Much work has been done in this area. Much of the interest comes from the business sector, where CORBA [23], OLE [5] and similar developments enable encapsulation of legacy systems behind distributed object-oriented interfaces. The theory of wrapping was addressed by Parodi <ref> [24] </ref>, 8 who identified four major types of wrappers, and Aron--ica and Rimel [1] who examined implementation issues. Wiederhold's CHAIMS [25] defines a high-level language for composing large modules, often wrapped versions of legacy systems running on legacy platforms and invoked by remote procedure call.
Reference: [25] <author> Louis Perrochon, Gio Wiederhold, and Ron Bur-back. </author> <title> A compiler for composition: </title> <editor> CHAIMS. In E. Nahouraii, editor, </editor> <booktitle> Proceedings Fifth International Symposium on Assessment of Software Tools and Technologies, </booktitle> <pages> pages 44-51, </pages> <address> Pittsburgh, PA, 2-5 June 1997. </address> <publisher> IEEE. </publisher>
Reference-contexts: The theory of wrapping was addressed by Parodi [24], 8 who identified four major types of wrappers, and Aron--ica and Rimel [1] who examined implementation issues. Wiederhold's CHAIMS <ref> [25] </ref> defines a high-level language for composing large modules, often wrapped versions of legacy systems running on legacy platforms and invoked by remote procedure call. Baker described procedures for wrapping C-language libraries using C++ [2], and Van Camp used wrappers to improve library portability [6].
Reference: [26] <author> M. E. Platt, E. E. Lewis, and F. Boehm. </author> <title> General monte carlo reliability simulation code including common mode failures and HARP fault/error-handling. </title> <type> Technical Report Contractor Report 187587, </type> <institution> NASA, Langley Research Center, </institution> <month> January </month> <year> 1991. </year>
Reference-contexts: MCI-HARP has had a long history, beginning in 1981 as simply HARP, developed at Duke and Clemson universities [14]. About seven years later HARP was used in a Monte Carlo simulator (MCI-HARP) built at Northwestern University <ref> [26] </ref>. For about the past five years, the system has undergone several enhancements at NASA, and is now called MCI-HARP. All told, about 20 people at four institutions have worked on it. Unlike DIFTree, MCI-HARP integrates computation and fault tree editing into one executable program.
Reference: [27] <author> Larry Reznick. </author> <title> Hiding UNIX applications in utility wrappers. </title> <journal> Sys Admin: The Journal for UNIX Systems Administrators, </journal> <volume> 4(5) </volume> <pages> 68-82, </pages> <month> September/ October </month> <year> 1995. </year>
Reference-contexts: Baker described procedures for wrapping C-language libraries using C++ [2], and Van Camp used wrappers to improve library portability [6]. Flint [16] wrapped legacy COBOL applications using an object-oriented wrapper. Reznick wrapped Unix applications to enhance their functionality <ref> [27] </ref>. The HP Encapsulator provides a wrapper-based framework for integrating Unix tools into the HP SoftBench environment [17].
Reference: [28] <author> Kevin J. Sullivan, Jake Cockrell, Shengtong Zhang, and David Coppit. </author> <booktitle> Package-oriented programming of engineering tools. In Proceedings of the 19th International Conference on Software Engineering, </booktitle> <pages> pages 616-617, </pages> <address> Boston, Massachusetts, </address> <month> 17-23 May </month> <year> 1997. </year> <note> IEEE. </note>
Reference-contexts: These tools are now losing significant value because of the heavy premium now placed on tools that run on personal computers. We are exploring an approach to modernizing these existing tools by integrating their computational cores into new superstructures built from multiple shrinkwrapped software packages <ref> [28] </ref>. In the next section we make the idea of unwrapping concrete by discussing the integration of legacy tool code into our fault tree analysis tool called Galileo.
Reference: [29] <author> Kevin J. Sullivan, Joanne Bechta Dugan, John Knight, et al. </author> <title> Galileo: An advanced fault tree analysis tool. </title> <address> URL: http://www.cs.virginia.edu/ ~ftree/index.html. </address>
Reference-contexts: Section 6 discusses research related to unwrapping. Section 7 concludes with a discussion of options for future work. 2 2 Case Study: Galileo The concept of unwrapping evolved during our work on the Galileo project <ref> [29] </ref>, an experiment in the use of package-oriented programming (POP) techniques in the development of software tools. Package-oriented programming is an approach to software development in which multiple shrink-wrapped packages, used as large-scale components, are integrated into systems.
Reference: [30] <author> K.J. Sullivan and J.C. Knight. </author> <title> Experience assessing an architectural approach to large-scale systematic reuse. </title> <booktitle> In Proceedings of the 18th International Conference on Software Engineering, </booktitle> <pages> pages 220-229, </pages> <address> Berlin, Germany, 25-30 March 1996. </address> <publisher> IEEE. </publisher>
Reference-contexts: Our original hope was to be able to quickly design and implement the editing and storage capabilities using POP, and then to be able to "just plug-in" different computational cores from existing systems <ref> [30] </ref>. Unfortunately we found the core elements of the existing systems to be complex and brittle. The complexity made us wary of rewriting the code (or even of changing it) for fear of getting a new implementation wrong or of breaking the existing one.
Reference: [31] <institution> Systems Techniques, Inc. Wrapping legacy systems for reuse: Repackaging vs. rebuilding. </institution> <note> URL: http: //www.systecinc.com/white/whitewrp.htm. 10 </note>
Reference-contexts: One consulting company has noted that, "Picking the right application system layer and product is critical... Wrapping large scale, monolithic applications rarely makes economic or technical sense <ref> [31] </ref>." At one end of our spectrum, then, we have complete reuse of the old core code with no unwrapping.
Reference: [32] <author> W. E. Veseley, F. F. Goldberg, N. H. Roberts, and D. F. Haasl. </author> <title> Fault Tree Handbook. </title> <editor> U. S. </editor> <publisher> Nuclear Regulatory Commission, </publisher> <address> NUREG-0492, Washing-ton DC, </address> <year> 1981. </year>
Reference-contexts: Package-oriented programming is an approach to software development in which multiple shrink-wrapped packages, used as large-scale components, are integrated into systems. Galileo is a tool for reliability engineers that provides the ability to edit, store, and solve fault trees <ref> [32] </ref>. See Figure 2. Fault trees are models of system failure, where the top-level event represents the failure of the whole system.
Reference: [33] <author> Paul Winsberg. </author> <title> Legacy code: Don't bag it, wrap it. </title> <journal> Datamation, </journal> <volume> 41(9), </volume> <month> May </month> <year> 1995. </year> <month> 11 </month>
Reference-contexts: The first is reengineering, which Chikovsky and Cross define as "the examination and alteration of a subject system to reconstitute it in a new form and the subsequent implementation of the new form [10]." The second is wrapping <ref> [1, 33] </ref>, in which an existing system is wholly incorporated into a new one behind an information hiding interface. A strength and weakness of reengineering is that it tacitly sanctions arbitrary changes to existing code. The benefit is that suboptimal elements can be removed and beneficial architectures can be imposed.
References-found: 33

