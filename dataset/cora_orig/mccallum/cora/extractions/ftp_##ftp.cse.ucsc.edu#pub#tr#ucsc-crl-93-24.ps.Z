URL: ftp://ftp.cse.ucsc.edu/pub/tr/ucsc-crl-93-24.ps.Z
Refering-URL: ftp://ftp.cse.ucsc.edu/pub/tr/README.html
Root-URL: http://www.cse.ucsc.edu
Email: max@cse.ucsc.edu  
Title: Debugging Optimized Code Without Being Misled: Currency Determination  
Author: Max Copperman 
Address: Santa Cruz, CA 95064 USA  
Affiliation: Baskin Center for Computer Engineering Information Sciences University of California, Santa Cruz  
Pubnum: UCSC-CRL-93-24  
Abstract: Optimization can cause an inconsistency between where the user expects a breakpoint to be located and the breakpoint's actual location. This paper describes a mapping between statements and breakpoint locations that ameliorates this problem. The mapping enables debugger behavior on optimized code that approximates debugger behavior on unoptimized code sufficiently closely for the user to use traditional debugging strategies. Optimization can also cause the value of a variable to be noncurrent | to differ from the value that would be predicted by a close reading of the source code. This paper presents a method of determining when this has occurred, and shows how a debugger can describe the relevant effects of optimization. The determination method is more general than previously published methods; it handles global optimization and many flow graph transformations, and it is not tightly coupled to optimizations performed by a particular compiler. Necessary compiler support is also described. Categories and Subject Descriptors: D.2.5 [Software Engineering]: Testing and Debugging | debugging aids; D.2.6 [Software Engineering]: Programming Environments; D.3.4 [Programming Languages]: Processors | code generation, compilers, optimization General Terms: Algorithms, Languages Additional Keywords and Phrases: debugging, compiler optimization, reaching definitions, noncurrent variables 
Abstract-found: 1
Intro-found: 1
Reference: [AG93a] <author> A. Adl-Tabatabai, T. Gross, </author> <title> "Evicted Variables and the Interaction of Global Register Allocation and Symbolic Debugging," </title> <booktitle> Proceedings of the POPL`93, The Twentieth Annual ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages, </booktitle> <address> Charleston, South Carolina, </address> <month> January </month> <year> 1993. </year>
Reference: [AG93b] <author> A. Adl-Tabatabai, T. Gross, </author> <title> "Detection and Recovery of Endangered Variables Caused by Instruction Scheduling," </title> <booktitle> To appear in the Proceedings of the PLDI`93, ACM SIGPLAN/93 Conference on Programming Language Design and Implementation, </booktitle> <address> Albuquerque, New Mexico, </address> <month> June </month> <year> 1993. </year>
Reference: [ASU86] <author> A. V. Aho, R. Sethi, J. D. Ullman, </author> <booktitle> "Compilers Principles, Techniques, and Tools," </booktitle> <publisher> Addison-Wesley, </publisher> <address> Menlo Park, CA, </address> <year> 1986. </year>
Reference: [Bal69] <author> R. M. Balzer, </author> <title> "EXDAMS EXtendable Debugging and Monitoring System," </title> <booktitle> Proceedings of AFIPS Spring Joint Computer Conference, </booktitle> <volume> Vol 34 pp. </volume> <pages> 125-134, </pages> <year> 1969. </year>
Reference-contexts: At that point, z had the value 3.141 (set at line 370) and y had the value 17; y was set at line 506 to y+bar (w).'. This was called flowback analysis by Balzer <ref> [Bal69] </ref>, and has been investigated by others ([MC91], [Kor88]); reaching sets may be adaptable to this purpose.
Reference: [BHS92] <author> G. Brooks, G. J. Hansen, and S. Simmons, </author> <title> "A New Approach to Debugging Optimized Code," </title> <booktitle> Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, SIGPLAN Notices, </booktitle> <volume> Vol. 27, No. 7, </volume> <pages> pp. 1-11, </pages> <address> San Francisco, California, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: If no code motion or elimination has occurred, the syntactic and semantic breakpoint for a statement are one and the same. Streepy [Str91] and Brooks et al <ref> [BHS92] </ref> describe a source-code/breakpoint-location mapping that allows breakpoints to be set at various levels of granularity, including expressions, basic blocks, and subroutines.
Reference: [BW93] <author> L. Berger, R. Wismuller, </author> <title> "Source-Level Debugging of Optimized Programs Using Data Flow Analysis", </title> <note> unpublished draft from the Department of Computer Science, </note> <institution> Munich Institute of Technology, Germany, </institution> <year> 1993. </year>
Reference-contexts: The code for S has been moved. In a particular execution, the semantic breakpoint location is reached but the syntactic breakpoint location is not. This is unexpected behavior already. An approach taken by Wismuller <ref> [BW93] </ref> is to use a more flexible mapping between source statements and breakpoints. He attempts to map a source statement to a breakpoint location in such a way that the breakpoint is reached if and only if it would be reached in unoptimized code.
Reference: [Coh91] <author> R. Cohn, </author> <title> "Source Level Debugging of Automatically Parallelized Code," </title> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <month> May </month> <year> 1991, </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 26, No. 12, </volume> <pages> pp. </pages> <month> 132-143 December </month> <year> 1991. </year>
Reference: [Coo92] <author> E. L. </author> <title> Cool, "Debugging VLIW Code After Instruction Scheduling," M.S. </title> <type> thesis, Technical Report CS/E 92-TH-009, </type> <institution> Oregon Graduate Institute, </institution> <year> 1992 </year>
Reference: [CM93] <author> M. Copperman, C. E. McDowell, </author> <title> "A Further Note on Hennessy's "Symbolic Debugging of Optimized Code", </title> <journal> ACM Transactions on Programming Languages and Systems Vol. </journal> <volume> 15, No. 2, </volume> <pages> pp. 357-365, </pages> <month> April </month> <year> 1993. </year>
Reference: [Cop93] <author> M. Copperman, </author> <title> "Debugging Optimized Code Without Being Misled," </title> <type> Doctoral thesis, </type> <institution> Computer and Information Sciences, University of California, Santa Cruz, </institution> <type> UCSC Technical Report UCSC-CRL-93-21, </type> <month> June </month> <year> 1993. </year>
Reference-contexts: Blocks may be added, deleted, coalesced, or copied; edges may be deleted, but control flow may not be radically changed. Allowable flow graph transformations are summarized in Section 4.3; they are described in detail in <ref> [Cop93] </ref>. <p> Correctness proofs are given in <ref> [Cop93] </ref>. 4.1 Paired Reaching Sets I have introduced the terms "definition" and "store" to distinguish an assignment occurring in the source or unoptimized code from an assignment occurring in the optimized (or machine) code. <p> A mechanism that allows truthful (but not expected) behavior in the presence of optimizations that violate this constraint is described in <ref> [Cop93] </ref>. 18 4. Currency Determination 1 1 2 3 3 1 2 2 2 6 6 6 6 1 1 1 2 6 DS n+1 O n+1 A node selects block j in S and block k in O i . in DS i kj between a complete bipartite subgraph. <p> Theorem 4.6 is proven in <ref> [Cop93] </ref>. 5. When a Variable is Endangered 25 5 When a Variable is Endangered When the debugger is asked to display a variable, it determines whether the variable is current. If the variable is current, the debugger displays its value without comment. <p> Handling transparency in its full generality is more complex and costly than currency determination in the absence of transparency. The constraints that a lack of pointer analysis imposes on the optimizer allow for a middle ground in terms of cost and complexity. <ref> [Cop93] </ref> describes algorithms that take advantage of these constraints. 6.4 Unconstrained Transparency If transparent assignments may be eliminated or moved, a transparent ds-pair in a Gen set may contain nulls. Furthermore, a block may contain a definition d and a store s not generated from d. <p> characteristic that the i th store in a ds-list-pair is generated from the i th definition in that ds-list-pair for all i if and only if V is current along the path from which that ds-list-pair is derived, except in the cases discussed in Section 6.6 (this is shown in <ref> [Cop93] </ref>). Definition 6.4: Let x l =&lt; x 1 ; x 2 ; : : : ; x i ; : : : ; x j ; : : : ; x n &gt; where x i and x j , are in the same equivalence class. <p> In <ref> [Cop93] </ref>, Theorem 6.6 is proven for most cases. It is shown how it fails for some exceptional cases, which are discussed below. 6.6 Cases in which the Algorithm May Err Consider the case in which a loop-invariant transparent assignment to V is moved to a loop pre-header. <p> There are other cases involving two assignments in a loop in which we would report V as current when V is endangered. I expect them to occur rarely, but I do not know that they are all semantically pathological. <ref> [Cop93] </ref> delimits the cases in which this kind of non-conservative error can occur. <p> This is shown in Figure 7.1 as arcs between elements in the definition list and elements in the instruction list. Maintenance of this relationship during optimization is discussed at length in <ref> [Cop93] </ref>, but that discussion is elided here for the sake of brevity. <p> The following debugger tasks relate to currency determination: 1. When a user sets a breakpoint at a source statement, find the breakpoint location (s). A method for finding breakpoint locations is given in <ref> [Cop93] </ref> but elided here for the sake of brevity. This requires one additional map, from source statements to definition list elements. When the breakpoint is set, the source statement and breakpoint locations must be saved in a debugger data structure BrList. 2. <p> The worst-case asymptotic cost of Algorithm PRS T is O (n 3 m (m! 2 )) (again, because of the size of the In sets), but its expected running time is also O (nm). A detailed analysis of these asymptotic costs is given in <ref> [Cop93] </ref>. <p> No optimization other than those described in one of the other object graph transformations may modify control flow in a way that changes which block is entered on a particular input. <ref> [Cop93] </ref> describes a mechanism that allows truthful (but not expected) behavior in the presence of optimizations that violate this constraint. References 49
Reference: [Cop92] <author> M. Copperman, </author> <title> "Debugging Optimized Code: Currency Determination with DataFlow," </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop , Dallas, </booktitle> <address> Texas, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: 1. Introduction 5 definitions computation is performed on a data structure that incorporates both pre-optimization and post-optimization information, eliminating the need for further computation. <ref> [Cop92] </ref> is a workshop paper that has one foot in each camp. This work is applicable in the presence of any sequential optimizations that either do not modify the flow graph of the program or modify the flow graph in a constrained manner.
Reference: [CM91b] <author> M. Copperman, C. E. McDowell, </author> <title> "Debugging Optimized Code Without Surprises," </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop , Albuquerque, </booktitle> <address> New Mexico, </address> <month> November </month> <year> 1991. </year>
Reference: [CMR88] <author> D. Coutant, S. Meloy, M. </author> <title> Ruscetta "DOC: a Practical Approach to Source-Level Debugging of Globally Optimized Code," </title> <booktitle> Proceedings of the SIGPLAN `88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pp. 125-134, </pages> <year> 1988. </year> <note> 50 References </note>
Reference: [FM80] <author> P. H. Feiler, R. Medina-Mora, </author> <title> "An Incremental Programming Environment," </title> <institution> Carnegie Mellon University Computer Science Department Report, </institution> <month> April </month> <year> 1980. </year>
Reference: [Gup90] <author> R. Gupta, </author> <title> "Debugging Code Reorganized by a Trace Scheduling Compiler," </title> <journal> Structured Programming, </journal> <volume> Vol. 11, No. 3, pp.1-10, </volume> <month> July </month> <year> 1990. </year>
Reference: [Hen82] <author> J. Hennessy, </author> <title> "Symbolic Debugging of Optimized Code," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 4, No. 3, </volume> <pages> pp. 323-344, </pages> <year> 1982. </year>
Reference-contexts: In unoptimized code, at each breakpoint the expected value of every variable is identical to its actual value. In optimized code, the actual value of a variable at some point may differ from its expected value at that point. Hennessy <ref> [Hen82] </ref> introduced the terms current, noncurrent, and endangered to describe the relationship between a variable's actual value and its expected value at a breakpoint. This relationship is described on the basis of a static analysis, one that has no information about how the breakpoint was reached.
Reference: [Kor88] <author> B. Korel, </author> <title> "PELAS Program Error-Locating Assistant System," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 14, No. 9, </volume> <pages> pp. 1253-1260, </pages> <month> September </month> <year> 1988. </year>
Reference-contexts: At that point, z had the value 3.141 (set at line 370) and y had the value 17; y was set at line 506 to y+bar (w).'. This was called flowback analysis by Balzer [Bal69], and has been investigated by others ([MC91], <ref> [Kor88] </ref>); reaching sets may be adaptable to this purpose. Another research direction is dynamic currency determination, which is how a debugger can collect the minimal execution history information needed to determine whether an endangered variable is current or noncurrent when execution is suspended at a breakpoint.
Reference: [MC91] <author> B. Miller, J. Choi, </author> <title> "Techniques for Debugging Parallel Programs with Flowback Analysis," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 13, No. 4, </volume> <pages> pp. 491-530, </pages> <year> 1991. </year>
Reference: [PS91] <author> P. P. Pineo, M. L. Soffa, </author> <title> "Debugging Parallelized Code Using Code Liberation Techniques," </title> <booktitle> Proceedings of the ACM/ONR Workshop on Parallel and Distributed Debugging, </booktitle> <month> May </month> <year> 1991, </year> <journal> SIGPLAN Notices, </journal> <volume> Vol. 26, No. 12, </volume> <pages> pp. </pages> <month> 108-119 December </month> <year> 1991. </year>
Reference: [PS88] <author> L. L. Pollock, M. L. Soffa, </author> <title> "High Level Debugging with the Aid of an Incremental Optimizer," </title> <booktitle> Hawaii International Conference on System Sciences, </booktitle> <month> January </month> <year> 1988. </year>
Reference: [PS92] <author> L. L. Pollock, M. L. Soffa, </author> <title> "Incremental Global Reoptimization of Programs," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 14, No. 2, </volume> <pages> pp. 173-200, </pages> <year> 1992. </year>
Reference: [Shu89] <author> W. S. Shu, </author> <title> "A Unified Approach to the Debugging of Optimized Programs", </title> <type> Ph.D. </type> <institution> Disssertation, Department of Computer Science, University of Nottingham, </institution> <address> England, UK, </address> <year> 1989. </year>
Reference: [ST83] <author> W. S. Shu, </author> <title> "Adapting A Debugger for Optimized Programs", </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 28, No. 4, </volume> <pages> pp. </pages> <month> 39-44 April </month> <year> 1993. </year>
Reference: [Str91] <author> L. Streepy, </author> <title> "CXdb A New View On Optimization," </title> <booktitle> Proceedings of the Supercomputer Debugging Workshop , Albuquerque, </booktitle> <month> November </month> <year> 1991. </year>
Reference-contexts: If the code generated from statement S is not contiguous, the semantic breakpoint location depends on the definition of `the action specified by the statement'. If no code motion or elimination has occurred, the syntactic and semantic breakpoint for a statement are one and the same. Streepy <ref> [Str91] </ref> and Brooks et al [BHS92] describe a source-code/breakpoint-location mapping that allows breakpoints to be set at various levels of granularity, including expressions, basic blocks, and subroutines.
Reference: [Sri86] <author> A. Srivastava, </author> <title> "Recovery of Noncurrent Variables in Source-level Debugging of Optimized Code," </title> <booktitle> Foundations of Software Technology and Theoretical Computer Science, Sixth Conference Proceedings, </booktitle> <pages> pp. 36-56, </pages> <year> 1986. </year>
Reference: [Wis93] <author> Wismueller, </author> <note> R., </note>
Reference: [WST85] <author> D. Wall, A. Srivastava, R. Templin, </author> <title> "A note on Hennessy's Symbolic Debugging of Optimized Code," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 7, No. 1, </volume> <pages> pp. 176-181, </pages> <month> Jan. </month> <year> 1985. </year>
Reference: [Wis93] <institution> Wismueller, R., Institut fur Informatik, Technische Universitat Munchen, Munich, Germany, </institution> <type> personal communication regarding current research, </type> <month> February </month> <year> 1993. </year>
Reference: [WS78] <author> H. S. Warren, Jr., H. P. Schlaeppi, </author> <title> "Design of the FDS interactive debugging system," </title> <institution> IBM Research Report RC7214, IBM Yorktown Heights, </institution> <month> July </month> <year> 1978. </year>
Reference: [Ze83b] <author> P. Zellweger, </author> <title> "An Interactive High-Level Debugger for Control-Flow Optimized Programs," </title> <journal> SIGPLAN Notices, </journal> <volume> Vol. 18, No. 8, </volume> <pages> pp. </pages> <month> 159-172 Aug. </month> <year> 1983. </year> <note> References 51 </note>
Reference: [Zel84] <author> P. Zellweger, </author> <title> "Interactive Source-Level Debugging of Optimized Programs," </title> <institution> Research Report CSL-84-5, Xerox Palo Alto Research Center, </institution> <address> Palo Alto, CA, </address> <month> May </month> <year> 1984. </year>
Reference-contexts: It is crucial that the relative ordering of variable definitions and breakpoints be available, and that breakpoints be at locations that exist in both the optimized and unoptimized versions of a program. We describe one satisfactory breakpoint model which we use throughout the paper. Zellweger <ref> [Zel84] </ref> introduced the terms syntactic and semantic breakpoints. The order in which syntactic breakpoints are reached reflects the syntactic order of source statements; the syntactic breakpoint for statement n is prior to or at the same location as the syntactic breakpoint for statement n + 1.
Reference: [ZJ90] <author> L. W. Zurawski, R. E. Johnson, </author> <title> "Debugging Optimized Code With Expected Behavior," </title> <institution> Unpublished draft from University of Illinois at Urbana-Champaign Department of Computer Science, </institution> <month> August </month> <year> 1990. </year>
References-found: 32

