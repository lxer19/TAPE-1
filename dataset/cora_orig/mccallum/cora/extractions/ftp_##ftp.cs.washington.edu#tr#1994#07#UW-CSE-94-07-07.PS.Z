URL: ftp://ftp.cs.washington.edu/tr/1994/07/UW-CSE-94-07-07.PS.Z
Refering-URL: http://www.cs.washington.edu/research/constraints/cip/kaleidoscope-oopsla-94.html
Root-URL: 
Email: bnfb@scs.carleton.ca  
Title: Implementing Constraint Imperative Programming Languages: The Kaleidoscope93 Virtual Machine  
Author: Gus Lopez, Bjorn Freeman-Benson and Alan Borning 
Note: To appear in Proceedings of OOPSLA94 Portland, Oregon,  
Date: July 1994  October 1994  
Address: Seattle, Washington 98195  514 Herzberg Building, 1125 Colonel By Drive, Ottawa, Ontario, Canada, K1S 0G9,  
Affiliation: Department of Computer Science and Engineering University of Washington  1 Carleton University, School of Computer Science,  
Pubnum: Technical Report 94-07-07  
Abstract: Constraint Imperative Programming (CIP) languages integrate declarative constraints with imperative state and destructive assignment, yielding a powerful new programming paradigm. However, CIP languages are difficult to implement efficiently due to complex interactions between the two donor paradigms. Neither the virtual machines for classical object-oriented languages, nor those for existing constraint languages, are suitable for implementing CIP languages, as each assumes a purely imperative or a purely declarative computation model. We have developed a new virtual machine for CIP languages, the K-machine, an imperative machine with an incremental constraint solver and a constraint-based, rather than value-based, data store. This virtual machine allows user-defined constraints to be defined using constraint constructor definitions which are the CIP analog to method definitions. Similar to methods, these constructors are able to reference variables indirectly through many levels of pointers. The K-machine maintains relations between objects in the presence of state change to these indirectly referenced objects. The K-machine is capable of supporting a wide variety of CIP languages, including our most recent: Kaleidoscope93. 
Abstract-found: 1
Intro-found: 1
Reference: [Ait-Kaci 90] <author> Hassan Ait-Kaci. </author> <title> The WAM: A (real) tutorial. </title> <type> Technical Report 5, </type> <institution> DEC Paris Research Laboratory, Paris, </institution> <month> January </month> <year> 1990. </year>
Reference: [Borning et al. 92] <author> Alan Borning, Bjorn Freeman-Benson, and Molly Wilson. </author> <title> Constraint hierarchies. Lisp and Symbolic Computation, </title> <address> 5(3):223270, </address> <month> September </month> <year> 1992. </year>
Reference-contexts: A constraint hierarchy can contain an arbitrary number of levels of preference (strengths). These hierarchies are useful in determining a programmers preferences when a system of constraints is under-constrained or over-constrained. Further information on constraint hierarchies can be found in <ref> [Borning et al. 92] </ref>. Due to its object-oriented nature, constraints in Kaleidoscope are considerably different from constraints in other language families.
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> Object-oriented multi-methods in Cecil. </title> <booktitle> In Proceedings of the 1992 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 3356, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Constructors are dynamically dispatched using multi-method lookup, in which all the arguments are signifi cant in selecting the constructor, rather than the more traditional single dispatching. Multi-methods are used in a number of other object-oriented languages, for example CLOS [Steele Jr. 90] and Cecil <ref> [Chambers 92] </ref>. In Kaleidoscope, multi-methods are essential, since for some constructor calls, the first argument might be unbound.
Reference: [Cohen 90] <author> Jacques Cohen. </author> <title> Constraint logic programming languages. </title> <journal> Communications of the ACM, </journal> <volume> 33(7):5268, </volume> <month> July </month> <year> 1990. </year>
Reference-contexts: Since languages in the Constraint Logic Programming family do not provide a facility for objects with mutable state, there is no automatic mechanism for re-satisfying a constraint as a result of a state change. (See references <ref> [Cohen 90] </ref>, [Colmerauer 90], [Jaffar & Lassez 87], [Van Henten-ryck 89], [Van Hentenryck et al. 92], and [Wilson & Borning 93].) Other CIP languages do not allow con Implementing Constraint Imperative Programming Languages: The Kaleidoscope93 Virtual Machine page 6 of 13 straints between arbitrary objects, and restrict constraints to instance variables.
Reference: [Colmerauer 90] <author> Alain Colmerauer. </author> <title> An introduction to Prolog III. </title> <journal> Communications of the ACM, </journal> <pages> pages 6990, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Since languages in the Constraint Logic Programming family do not provide a facility for objects with mutable state, there is no automatic mechanism for re-satisfying a constraint as a result of a state change. (See references [Cohen 90], <ref> [Colmerauer 90] </ref>, [Jaffar & Lassez 87], [Van Henten-ryck 89], [Van Hentenryck et al. 92], and [Wilson & Borning 93].) Other CIP languages do not allow con Implementing Constraint Imperative Programming Languages: The Kaleidoscope93 Virtual Machine page 6 of 13 straints between arbitrary objects, and restrict constraints to instance variables.
Reference: [Freeman-Benson & Borning 92] <author> Bjorn Freeman-Benson and Alan Borning. </author> <title> The design and implementation of Kaleidoscope90, a constraint imperative programming language. </title> <booktitle> In Proceedings of the IEEE Computer Society International Conference on Computer Languages, </booktitle> <pages> pages 174180, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: this latter form are not object-oriented because (a) they violate public-private encapsulation boundary of instance variables, and (b) they prevent the programmer from using a different implementation of the same abstraction, e.g., a top/bottom/left/right implementation of rectangles instead of a topLeft point/bottomRight point implementation. (This problem is also discussed in <ref> [Freeman-Benson & Borning 92] </ref>.) iii. If the part-whole structure of the objects were guaranteed not to change, then user-defined constraints on user-defined objects could be implemented using properly encapsulated methods that recursively descend the structure and create primitive constraints on the leaves. <p> In previous work we presented language designs for Kaleidoscope90, 91, and 93 [Freeman-Benson 91], <ref> [Freeman-Benson & Borning 92] </ref>, and [Lopez et al. 93]. Further information on the incremental local propagation algorithms used in this implementation can be found in [Freeman-Benson et al. 90] and [Sannella 93]. Other constraint-based languages include Bertrand [Leler 87] and Siri [Horn 92b], [Horn 92a].
Reference: [Freeman-Benson 91] <author> Bjorn Freeman-Benson. </author> <title> Constraint Imperative Programming. </title> <type> PhD thesis, </type> <institution> University of Washington, Department of Computer Science and Engineering, </institution> <month> July </month> <year> 1991. </year> <note> Published as Department of Computer Science and Engineering Technical Report 91-07-02. </note>
Reference-contexts: Thus, although these user interfaces may be written in high-level imperative languages, the constraint portions of the user interface are written at a low level, by hand, and enforced by a code fragments distributed throughout the programa recipe for maintenance headaches. To address this problem, we proposed, in <ref> [Freeman-Benson 91] </ref> and [Freeman-Ben-son & Borning 92], an integration of two disparate paradigms: a standard object-oriented imperative one, and a declarative constraint one. The result is named constraint imperative programming (CIP). <p> To illustrate the incremental execution of constructors, consider the Kaleidoscope program in Figure 8. The constructor +(Point, Point, Point) is chosen at line (1) following each state change, so as to maintain user-defined constraints. In fact, the Kaleidoscope91 implementation did exactly that <ref> [Freeman-Benson 91] </ref>. However, while this made constraint maintenance straightforward, most of these constructor re-executions were superuous as, in the vast majority of cases, they filled slots with exactly the same values as the slots had previously held. <p> In previous work we presented language designs for Kaleidoscope90, 91, and 93 <ref> [Freeman-Benson 91] </ref>, [Freeman-Benson & Borning 92], and [Lopez et al. 93]. Further information on the incremental local propagation algorithms used in this implementation can be found in [Freeman-Benson et al. 90] and [Sannella 93]. Other constraint-based languages include Bertrand [Leler 87] and Siri [Horn 92b], [Horn 92a].
Reference: [Freeman-Benson et al. 90] <author> Bjorn Freeman-Benson, John Maloney, and Alan Borning. </author> <title> An incremental constraint solver. </title> <journal> Communications of the ACM, </journal> <volume> 33(1):5463, </volume> <month> January </month> <year> 1990. </year>
Reference-contexts: CIP languages are general purpose programming languages; they implement general purpose multi-directional constraints, rather than a uni-directional, or dataow, subset. For an overview of constraints and constraint programing, see <ref> [Freeman-Benson et al. 90] </ref> or [Leler 87]. The three fundamental problems of CIP language implementation that our K-machine is designed to solve are as follows. mercury.bottom mercury.top thermometer.top mouse Implementing Constraint Imperative Programming Languages: The Kaleidoscope93 Virtual Machine page 3 of 13 i. <p> Incrementally satisfying constraints requires additional bookkeeping in the K-machine, but the cost is small compared to the tremendous performance advantage of incremental constraint satisfaction over repeatedly solving all constraints. Further, this design allows us to exploit the incremental properties of our local propagation solver <ref> [Freeman-Benson et al. 90] </ref>, [Sannella 93]. See Section 4.1 for more details. Implementing Constraint Imperative Programming Languages: The Kaleidoscope93 Virtual Machine page 9 of 13 since p1 and p2 contain objects of class Point. The Point object in p3 becomes the sum of p1 and p2. <p> In previous work we presented language designs for Kaleidoscope90, 91, and 93 [Freeman-Benson 91], [Freeman-Benson & Borning 92], and [Lopez et al. 93]. Further information on the incremental local propagation algorithms used in this implementation can be found in <ref> [Freeman-Benson et al. 90] </ref> and [Sannella 93]. Other constraint-based languages include Bertrand [Leler 87] and Siri [Horn 92b], [Horn 92a].
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Implementing Constraint Imperative Programming Languages: The Kaleidoscope93 Virtual Machine page 11 of 13 It would be possible, though extremely awkward, to implement CIP languages with a virtual machine from a conventional object-oriented language with a value-based data store, e.g., the Smalltalk-80 VM <ref> [Goldberg & Robson 83] </ref>. However, to do so, the Kaleidoscope compiler would have to implement the entire constraint-solving semantics of the K-machine in the code generator to ensure that the effect of a constraint-based data store was achieved.
Reference: [Horn 92a] <author> Bruce Horn. </author> <title> Constraint patterns as a basis for object-oriented constraint programming. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 218233, </pages> <address> Vancouver, British Columbia, </address> <month> October </month> <year> 1992. </year> <title> Implementing Constraint Imperative Programming Languages: The Kaleidoscope93 Virtual Machine page 13 of 13 </title>
Reference-contexts: For instance, Siri, another CIP language that is probably the closest relative to Kaleidoscope93, only resatisfies constraints between instance variables within the representation of a single object <ref> [Horn 92a] </ref>. Most constraint languages restrict constraints to those than can be expressed over built-in primitive domains. As mentioned earlier, limiting constraints to primitive domains would be overly restrictive in an object-oriented language, since user-defined domains (i.e. classes) are frequently used in object-oriented programs. <p> Further information on the incremental local propagation algorithms used in this implementation can be found in [Freeman-Benson et al. 90] and [Sannella 93]. Other constraint-based languages include Bertrand [Leler 87] and Siri [Horn 92b], <ref> [Horn 92a] </ref>. Both Ber-trand and Siri are based on an Augmented Term Rewriting virtual machine, which is not powerful enough to support all of the imperative features of Kaleidoscope such as long-lived constraints between arbitrary objects. 3.
Reference: [Horn 92b] <author> Bruce Horn. </author> <title> Properties of user interface systems and the Siri programming language. </title> <editor> In Brad Myers, editor, </editor> <booktitle> Languages for Developing User Interfaces, </booktitle> <pages> pages 211236. </pages> <publisher> Jones and Bartlett, </publisher> <address> Boston, </address> <year> 1992. </year>
Reference-contexts: Further information on the incremental local propagation algorithms used in this implementation can be found in [Freeman-Benson et al. 90] and [Sannella 93]. Other constraint-based languages include Bertrand [Leler 87] and Siri <ref> [Horn 92b] </ref>, [Horn 92a]. Both Ber-trand and Siri are based on an Augmented Term Rewriting virtual machine, which is not powerful enough to support all of the imperative features of Kaleidoscope such as long-lived constraints between arbitrary objects. 3.
Reference: [Jaffar & Lassez 87] <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the Fourteenth ACM Principles of Programming Languages Conference, </booktitle> <address> Munich, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: Since languages in the Constraint Logic Programming family do not provide a facility for objects with mutable state, there is no automatic mechanism for re-satisfying a constraint as a result of a state change. (See references [Cohen 90], [Colmerauer 90], <ref> [Jaffar & Lassez 87] </ref>, [Van Henten-ryck 89], [Van Hentenryck et al. 92], and [Wilson & Borning 93].) Other CIP languages do not allow con Implementing Constraint Imperative Programming Languages: The Kaleidoscope93 Virtual Machine page 6 of 13 straints between arbitrary objects, and restrict constraints to instance variables.
Reference: [Jaffar et al. 92a] <author> Joxan Jaffar, Spiro Michaylov, Peter Stuckey, and Roland Yap. </author> <booktitle> An abstract machine for CLP( ). In Proceedings of the ACM SIGPLAN 92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 128139, </pages> <address> San Francisco, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: For example, CLP ( ) is a constraint logic programming language whose implementation has a constraint solving engine for constraints over the real numbers [Jaffar et al. 92b]. The CLAM <ref> [Jaffar et al. 92a] </ref> is the abstract machine used in the CLP ( ) interpreter, which is based on the WAM, often used in Prolog implementations [Warren 83], [Ait Kaci 90].
Reference: [Jaffar et al. 92b] <author> Joxan Jaffar, Spiro Michaylov, Peter Stuckey, and Roland Yap. </author> <title> The CLP( ) language and system. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3):339395, </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: Similarly, it would be possible, though awkward, to implement CIP languages using a virtual machine for a pure constraint language or constraint logic language. For example, CLP ( ) is a constraint logic programming language whose implementation has a constraint solving engine for constraints over the real numbers <ref> [Jaffar et al. 92b] </ref>. The CLAM [Jaffar et al. 92a] is the abstract machine used in the CLP ( ) interpreter, which is based on the WAM, often used in Prolog implementations [Warren 83], [Ait Kaci 90].
Reference: [Leler 87] <author> William Leler. </author> <title> Constraint Programming Languages. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: CIP languages are general purpose programming languages; they implement general purpose multi-directional constraints, rather than a uni-directional, or dataow, subset. For an overview of constraints and constraint programing, see [Freeman-Benson et al. 90] or <ref> [Leler 87] </ref>. The three fundamental problems of CIP language implementation that our K-machine is designed to solve are as follows. mercury.bottom mercury.top thermometer.top mouse Implementing Constraint Imperative Programming Languages: The Kaleidoscope93 Virtual Machine page 3 of 13 i. <p> Further information on the incremental local propagation algorithms used in this implementation can be found in [Freeman-Benson et al. 90] and [Sannella 93]. Other constraint-based languages include Bertrand <ref> [Leler 87] </ref> and Siri [Horn 92b], [Horn 92a]. Both Ber-trand and Siri are based on an Augmented Term Rewriting virtual machine, which is not powerful enough to support all of the imperative features of Kaleidoscope such as long-lived constraints between arbitrary objects. 3.
Reference: [Lopez et al. 93] <author> Gus Lopez, Bjorn Freeman-Benson, and Alan Borning. </author> <title> Kaleidoscope: A constraint imperative programming language. </title> <editor> In Brian Mayoh, Enn Tougu, and Jann Penjam, editors, </editor> <title> Constraint Programming. </title> <publisher> Springer-Verlag, </publisher> <year> 1993. </year> <institution> NATO Advanced Science Institute Series, Series F: Computer and System Sciences. </institution> <note> Also published as UW CSE Technical Report 93-09-04. </note>
Reference-contexts: Most of the machinery in the K-machine exists to provide exactly such a mechanism. In the remainder of this paper, we discuss implementation considerations common to all constraint imperative programming languages, as well as our implementation of Kaleidoscope93 <ref> [Lopez et al. 93] </ref>, hereafter referred to as Kaleidoscope. The K-machine is a general CIP language virtual machine, and is not restricted to the particular choice of primitive domains, constraint solvers, and inheritance model used in Kaleidoscope. <p> In previous work we presented language designs for Kaleidoscope90, 91, and 93 [Freeman-Benson 91], [Freeman-Benson & Borning 92], and <ref> [Lopez et al. 93] </ref>. Further information on the incremental local propagation algorithms used in this implementation can be found in [Freeman-Benson et al. 90] and [Sannella 93]. Other constraint-based languages include Bertrand [Leler 87] and Siri [Horn 92b], [Horn 92a].
Reference: [Lopez et al. 94] <author> Gus Lopez, Bjorn Freeman-Benson, and Alan Borning. </author> <title> Constraints and object identity. </title> <booktitle> In Proceedings of the 1994 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 260-279, </pages> <address> Bologna, Italy, </address> <month> July </month> <year> 1994. </year>
Reference-contexts: Similar to value constraints, identity constraints are solved by local propagation, however the satisfaction of these identity constraints determines variable references instead of object values. Identity constraints and the VICS Vapo-Ware solver are discussed in <ref> [Lopez et al. 94] </ref>. 5. Related Work The special implementation needs of constraint imperative programming (class-based objects with inheritance, multi-methods, constraint solving, and dynamically bound constraints) led us to design a special-purpose virtual machine to implement Kaleidoscope.
Reference: [Sannella 93] <author> Michael Sannella. </author> <title> The SkyBlue constraint solver. </title> <type> Technical Report 92-07-02, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: Incrementally satisfying constraints requires additional bookkeeping in the K-machine, but the cost is small compared to the tremendous performance advantage of incremental constraint satisfaction over repeatedly solving all constraints. Further, this design allows us to exploit the incremental properties of our local propagation solver [Freeman-Benson et al. 90], <ref> [Sannella 93] </ref>. See Section 4.1 for more details. Implementing Constraint Imperative Programming Languages: The Kaleidoscope93 Virtual Machine page 9 of 13 since p1 and p2 contain objects of class Point. The Point object in p3 becomes the sum of p1 and p2. <p> We term these constraints value constraints, since the satisfaction of these constraints finds values for objects within their domains. The primitive constraint solver we currently use in the Kaleido-scope93 implementation is CobaltBlue. CobaltBlue is an extension of SkyBlue <ref> [Sannella 93] </ref>, and can solve simultaneous equations, multiple output and nonunique constraints incrementally by local propagation. However, the K-machine design is general enough to accommodate other solvers. CIP languages combine imperative constructs such as object identity and class membership with declarative constraints. <p> In previous work we presented language designs for Kaleidoscope90, 91, and 93 [Freeman-Benson 91], [Freeman-Benson & Borning 92], and [Lopez et al. 93]. Further information on the incremental local propagation algorithms used in this implementation can be found in [Freeman-Benson et al. 90] and <ref> [Sannella 93] </ref>. Other constraint-based languages include Bertrand [Leler 87] and Siri [Horn 92b], [Horn 92a]. Both Ber-trand and Siri are based on an Augmented Term Rewriting virtual machine, which is not powerful enough to support all of the imperative features of Kaleidoscope such as long-lived constraints between arbitrary objects. 3.
Reference: [Saraswat 93] <author> Vijay A. Saraswat. </author> <title> Concurrent Constraint Programming. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: In the purest sense, a constraint-based data store is a set of constraints which, when taken together, determine values for variables. (This is the approach used in the cc family of languages <ref> [Saraswat 93] </ref>.) Variables in this case are as in mathematics, rather than naming changeable storage locations. However, for efficiency reasons, the K-machine data store does contain traditional imperative variables, as well as the constraints that determine their values. <p> Such analysis is essential for the implementation of high-level languages, and thus we believe that a class library would be the wrong implementation technique. 3 The cc family of languages <ref> [Saraswat 93] </ref> generalize the CLP scheme to include such features as concur-rency, atomic tell, and blocking ask; if we used such a language instead of Kaleidoscope for constraint programming we could represent objects as perpetual processes that consume an (unbounded) stream of messages.
Reference: [Steele Jr. 90] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Bedford, Massachusetts, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: Constructors are dynamically dispatched using multi-method lookup, in which all the arguments are signifi cant in selecting the constructor, rather than the more traditional single dispatching. Multi-methods are used in a number of other object-oriented languages, for example CLOS <ref> [Steele Jr. 90] </ref> and Cecil [Chambers 92]. In Kaleidoscope, multi-methods are essential, since for some constructor calls, the first argument might be unbound.
Reference: [Van Hentenryck 89] <author> Pascal Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference: [Van Hentenryck et al. 92] <author> Pascal Van Hentenryck, Helmut Simonis, and Mehmet Dincbas. </author> <title> Constraint satisfaction using constraint logic programming. </title> <journal> Artificial Intelligence, </journal> <volume> 58(13):113159, </volume> <month> December </month> <year> 1992. </year>
Reference-contexts: Since languages in the Constraint Logic Programming family do not provide a facility for objects with mutable state, there is no automatic mechanism for re-satisfying a constraint as a result of a state change. (See references [Cohen 90], [Colmerauer 90], [Jaffar & Lassez 87], [Van Henten-ryck 89], <ref> [Van Hentenryck et al. 92] </ref>, and [Wilson & Borning 93].) Other CIP languages do not allow con Implementing Constraint Imperative Programming Languages: The Kaleidoscope93 Virtual Machine page 6 of 13 straints between arbitrary objects, and restrict constraints to instance variables.
Reference: [Warren 83] <author> David H. D. Warren. </author> <title> An abstract Prolog instruction set. </title> <type> Technical Report 309, </type> <institution> SRI International, </institution> <address> Menlo Park, California, </address> <month> October </month> <year> 1983. </year>
Reference-contexts: The CLAM [Jaffar et al. 92a] is the abstract machine used in the CLP ( ) interpreter, which is based on the WAM, often used in Prolog implementations <ref> [Warren 83] </ref>, [Ait Kaci 90]. To implement a CIP language using the CLAM, one would have to translate the CIP language semantics into one of the object-oriented logic programming schemes. (We in fact did this in a Kaleidoscope interpreter written in CLP ( ).
Reference: [Wilson & Borning 93] <author> Molly Wilson and Alan Borning. </author> <title> Hierarchical Constraint Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 16(3 & 4):277318, </volume> <month> July, August </month> <year> 1993. </year>
Reference-contexts: the Constraint Logic Programming family do not provide a facility for objects with mutable state, there is no automatic mechanism for re-satisfying a constraint as a result of a state change. (See references [Cohen 90], [Colmerauer 90], [Jaffar & Lassez 87], [Van Henten-ryck 89], [Van Hentenryck et al. 92], and <ref> [Wilson & Borning 93] </ref>.) Other CIP languages do not allow con Implementing Constraint Imperative Programming Languages: The Kaleidoscope93 Virtual Machine page 6 of 13 straints between arbitrary objects, and restrict constraints to instance variables.
References-found: 24

