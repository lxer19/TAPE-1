URL: http://seclab.cs.ucdavis.edu/~devanbu/teaching/260/hd.ps
Refering-URL: http://seclab.cs.ucdavis.edu/~devanbu/teaching/260/sched.html
Root-URL: http://www.cs.ucdavis.edu
Title: Building Domain-Specific Embedded Languages  
Author: Paul Hudak 
Keyword: Geometric regions are represented as functions: type Region Point -&gt; Bool  
Note: Figure 1: Example of a DSEL for a Naval Application 2  
Date: June 3, 1996  
Affiliation: Department of Computer Science Yale University  
Abstract: I have believed for a very long time that abstraction is the most important factor in writing good software. As programming language researchers we design, and as software engineers we are trained to use, a variety of abstraction mechanisms: abstract data types, higher-order functions, monads, continuations, modules, classes, objects, etc. Particular languages support some of these mechanisms well, others not so well. An important point about these mechanisms is that they are fairly general|for example, most algorithmic strategies and computational structures can be implemented using either functional or object-oriented abstraction techniques. Although generality is good, we might ask what the "ideal" abstraction for a particular application is. In my opinion, it is a programming language that is designed precisely for that application: one in which a person can quickly and effectively develop a complete software system. It is not general at all; it should capture precisely the semantics of the application domain|no more and no less. In my opinion, a domain-specific language is the "ultimate abstraction." But we know all too well how difficult designing and implementing languages is, and we can be pretty sure that we won't get it right the first time; it will evolve, and we will experience all of the difficulties associated with that evolution. So in fact the notion of a domain specific language might not be very practical. Or is it? In this position paper I will outline several techniques that I believe can lead to the effective use of this methodology. It begins with the assumption that we really don't want to build a programming language from scratch. Better, let's inherit the infrastructure of some other language|tailoring it in special ways to the domain of interest|thus yielding a domain-specific embedded language (DSEL). Building on this base, we can then concentrate on semantical issues: viz. the interpreter of the language. Interestingly, we'll see that abstraction now kicks in at this leta-level: we can use abstraction techniques to build interpreters that are themselves easy to understand, highly modular, and straightforward to evolve. In the remainder of this paper I will describe the results of using the functional language Haskell to build DSELs. Haskell has several features that make it particularly suitable for this, but other languages could also be used. On the other hand, there are features that don't exist in any language (to my knowledge) that would make things even easier; there is much more work to be done. Domain Specific Semantics It is surprisingly straightforward to design a DSEL for many specific applications. We have done so already using Haskell in several domains: parser generation, graphics, animation, simulation, music composition, and geometric region analysis, to -- so to test a point's membership in a region, we do: inRegion :: Point -&gt; Region -&gt; Bool p `inRegion` r = r p -- Given suitable definitions of "circle", "outside", and /": circle :: Radius -&gt; Region -- creates a region with given radius outside :: Region -&gt; Region -- the logical negation of a region (/") :: Region -&gt; Region -&gt; Region -- the intersection of two regions -- we can then define a function to generate an annulus: annulus :: Radius -&gt; Radius -&gt; Region annulus r1 r2 = outside (circle r1) /" circle r2 name a few. The latter domain|geometric region analysis|came about through an experiment conducted jointly by Arpa, ONR, and the Naval Surface Warfare Center. This well-documented experiment (see [Car93, CHJ93, LBK fl 94]) demonstrates not only the viability of the DSEL approach, but also its evolvability. Three different versions of the system were developed, each capturing more advanced notions of the target system, with no a priori knowledge of the changes that would be required. The modularity afforded by the DSEL made these non-trivial changes quite easy to incorporate. The resulting notation is not only easy to design, it's also easy to use and reason about. Because the domain semantics is captured concisely, it is possible even for non-programmers to understand much of the code. In the NSWC experiment, those completely unfamiliar with Haskell were able to grasp the concepts immediately; some even expressed disbelief that the code was actually executable. In Figure 1 we highlight some of the code to give the reader a feel for its simplicity and clarity. Finally, the DSEL approach is highly amenable to formal methods, for many of the reasons already mentioned. The key point is that one can reason directly within the domain semantics, rather than within the semantics of the programming language. In the NSWC experiment we straightforwardly proved several properties of our DSEL that would have been much more difficult to prove in most of the competing designs. Modular Monadic Interpreters A DSEL in Haskell can be thought of as a higher-order algebraic structure, a first-class value that has the "look and feel" of syntax. In some sense it is just a notation; its semantics is captured by an interpreter. This permits another opportunity for modular design, in turn facilitating evolution of the system since changes in the domain semantics are in many cases inevitable. The design of truly modular interpreters has been an elusive goal in the programming language community for many years. In particular, one would like to design the interpreter so that different language features can be isolated and given individualized interpretations in a "building block" manner. These building blocks can then be assembled to yield languages that have only a few, a majority, or even all of the individual language features. Progress by Moggi, Espanol, and Steele [Mog89, Ste94, Esp93] laid the groundwork for our recent effort at producing a truly 
Abstract-found: 1
Intro-found: 0
Reference: [Car93] <author> J. Caruso. </author> <title> Prototyping Demonstration Problem for the Prototech HiPer-D Joint Prototyping Demonstration Project. </title> <type> CCB Report 0.2, </type> <institution> Naval Surface Warfare Center, </institution> <month> August </month> <year> 1993. </year> <title> Last modified October 27, 1993; further changes specified by J. Caruso are described in "Addendum to Prototyping Demonstration Problem for the Prototech HiPer-D Joint Prototyping Demonstration Project," </title> <month> November 9, </month> <year> 1993. </year>
Reference: [CHJ93] <author> W.E. Carlson, P. Hudak, and M.P. Jones. </author> <title> An Experiment Using Haskell To Prototype 5 "Geometric Region Servers" for Navy Command And Control. </title> <type> Research Report 1031, </type> <institution> Department of Computer Science, Yale University, </institution> <month> November </month> <year> 1993. </year>
Reference: [Esp93] <author> David Espinosa. </author> <title> Modular Denotational Semantics. </title> <type> Unpublished manuscript, </type> <month> Decem-ber </month> <year> 1993. </year>
Reference: [LBK fl 94] <author> J.A.N. Lee, B. Blum, P. Kanellakis, H. </author> <title> Crisp, and J.A. Caruso. ProtoTech HiPer-D Joint Prototyping Demonstration Project, </title> <month> February </month> <year> 1994. </year> <pages> Unpublished; 400 pages. </pages>
Reference: [LH96] <author> Sheng Liang and Paul Hudak. </author> <title> Modular Denotational Semantics for Compiler Construction. </title> <booktitle> In European Symposium on Programming, </booktitle> <month> April </month> <year> 1996. </year>
Reference: [LHJ95] <author> Sheng Liang, Paul Hudak, and Mark Jones. </author> <title> Monad Transformers and Modular Interpreters. </title> <booktitle> In Proceedings of 22nd ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 333-343, </pages> <address> New York, </address> <month> January </month> <year> 1995. </year> <note> ACM Press. </note>
Reference: [Lia96] <author> Sheng Liang. </author> <title> Modular Monadic Semantics and Compilation. </title> <type> PhD thesis, </type> <institution> Yale University, Department of Computer Science, </institution> <month> November </month> <year> 1996. </year>
Reference: [Mog89] <author> E. Moggi. </author> <title> Computational Lambda-Calculus and Monads. </title> <booktitle> In Proceedings of Symposium on Logic in Computer Science. IEEE, </booktitle> <month> June </month> <year> 1989. </year>
Reference: [PJW93] <author> S. Peyton Jones and P. Wadler. </author> <title> Imperative Functional Programming. </title> <booktitle> In Proceedings 20th Symposium on Principles of Programming Languages. ACM, </booktitle> <month> January </month> <year> 1993. </year> <note> (to appear). </note>
Reference: [Ste94] <author> Guy L. Steele Jr. </author> <title> Building Interpreters by Composing Monads. </title> <booktitle> In Conference Record of POPL '94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Portland, Oregon, </booktitle> <pages> pages 472-492, </pages> <address> New York, </address> <month> January </month> <year> 1994. </year> <note> ACM Press. </note>
Reference: [Wad90] <author> P. Wadler. </author> <title> Comprehending Monads. </title> <booktitle> In Proceedings of Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 61-78, </pages> <address> Nice, France, </address> <month> June </month> <year> 1990. </year> <journal> ACM. </journal> <volume> 6 </volume>
References-found: 11

