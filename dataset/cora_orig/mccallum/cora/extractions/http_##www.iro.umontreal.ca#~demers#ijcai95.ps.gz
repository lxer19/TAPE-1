URL: http://www.iro.umontreal.ca/~demers/ijcai95.ps.gz
Refering-URL: http://www.iro.umontreal.ca/~demers/
Root-URL: http://www.iro.umontreal.ca
Title: Reflection in logic, functional and object-oriented programming: a Short Comparative Study  
Author: Francois-Nicola Demers and Jacques Malenfant 
Address: Montreal, Montreal, Quebec, CANADA  
Affiliation: Departement d'informatique et de recherche operationnelle Universite de  
Abstract: Reflection is a wide-ranging concept that has been studied independently in many different areas of science in general, and computer science in particular. Even in the sub-area of programming languages, it has been applied to different paradigms, especially the logic, functional and object-oriented ones. Partly because of different past influences, but also because researchers in these communities scarcely talk to each others, concepts have evolved separately, sometimes to the point where it is hard for people in one community to recognize similarities in the work of others, not to speak about cross-fertilization among them. In this paper, we propose a synthesis covering mainly the application of computation reflection to programming languages. We compare the different approaches and try to identify similar concepts hidden behind different names or constructs. We also point out the different emphasis that has been given to different concepts in each of them. We do not claim neither completeness nor closeness in our treatment. We rather aim at building bridges between programming languages communities, and address other aspects when they appear relevant. 
Abstract-found: 1
Intro-found: 1
Reference: [AMY93] <author> K. Asai, S. Matsuoka, and A. Yonezawa. </author> <title> Duplication and Partial Evaluation to Implement Reflective Languages. </title> <booktitle> In [WRM93] </booktitle>
Reference-contexts: Also, Blond made a distinction between what it calls pushy and jumpy continuations in the management of metacontinuations. Three other languages contributed to this school of reflection: Stepper [Baw88], and more recently I R [JF92] and Black <ref> [AMY93] </ref>. 3.2 Logic programming All the different issues mentionned earlier (esp. in 3.1) have also been studied in logic programming but under different names. We look at them (and also new one) in the following. In logic programming, structural reflection has been the first one to be introduced.
Reference: [AR89] <editor> H. Abramson and M.H. Rogers, eds. </editor> <booktitle> Metaprogram-ming in Logic Programming. </booktitle> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: Metaprogramming quickly became so common in Prolog that any self-respecting textbook includes the so-called vanilla meta-interpreter for Prolog written in three clauses (see, for example, [SS86]). A series of conferences devoted exclusively to metaprogramming in logic has also been organized <ref> [AR89, Bru90, Pet92, MET94] </ref>. Finally, the new language Godel [HL94] has been designed with the aim of making metaprogramming more declarative, by implementing primitively the manipulation of terms in a ground representation.
Reference: [Baw88] <author> A. Bawden. </author> <title> Reification without Evaluation. </title> <booktitle> In Proc. of ACM L&FP'88, </booktitle> <pages> pages 342-351, </pages> <year> 1988. </year>
Reference-contexts: Brown turned out to be flawed in the treatment of environments, a problem solved in Blond. Also, Blond made a distinction between what it calls pushy and jumpy continuations in the management of metacontinuations. Three other languages contributed to this school of reflection: Stepper <ref> [Baw88] </ref>, and more recently I R [JF92] and Black [AMY93]. 3.2 Logic programming All the different issues mentionned earlier (esp. in 3.1) have also been studied in logic programming but under different names. We look at them (and also new one) in the following.
Reference: [BC89] <author> J.-P. Briot and P. Cointe. </author> <title> Programming with Explicit Metaclasses in Smalltalk-80. </title> <journal> Proc. of OOPSLA'89, ACM Sigplan Not., </journal> <volume> 24(10) </volume> <pages> 419-431, </pages> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: It also solves the potential infinite metaregression by making Class its own instance. ObjVLisp is a model that has been applied first to an object system written in Lisp, but it has also been applied to Scheme, to Smalltalk (Classtalk <ref> [BC89] </ref>), and to an object-oriented extension of Prolog (ObjVProlog [MLV89, MLV90]). 3.3.2 Towards full reflection With its "object-to-the-bottom" principle, Smalltalk pio-nnered a design principle basic to reflection, which is that everything should be expressed in the terms of the language itself.
Reference: [BCL + 88] <author> M. Bugliesi, M. Cavalieri, E. Lamma, P. Mello, A. Na-tali, and F. Russo. </author> <title> Flexibility and efficiency in a prolog programming environment: Exploiting meta-programming and partial evaluation. </title> <booktitle> In Proc. of the 5th ESPRIT Conf., </booktitle> <address> Brussels, </address> <year> 1988. </year>
Reference-contexts: Although the latters are all much less powerful than the preceding ones because the predicate Demo is not entirely explicitly represented (by T h), they integrate reflective mechanisms useful for certains logical applications. Examples of the non-amalgamating systems are FOL [Wey80], R-Prolog* [Sug90], CPU [LMN91] and ALPES-IProlog <ref> [BCL + 88] </ref>. Most of these systems have tried especially to resolve practically and theoritically problems related to the logical representation of goals, clauses and variables. 3.2.1 Quote mechanism As we said earlier, in reflective systems a quote mechanism is essential.
Reference: [BGW93] <author> D.G. Bobrow, R.P. Gabriel, and J.L. White. </author> <title> CLOS in Context | The Shape of the Design Space. </title> <editor> In A. Paepcke, editor, </editor> <title> Object-Oriented Programming | The CLOS Perspective, chapter 2. </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Smith during the ECOOP/OOPSLA'90 workshop on reflection [WRM90]: "An entity's integral ability to represent, operate on, and otherwise deal with its self in the same way that it represents, operates on and deals with its primary subject matter." In programming languages, the incarnation of this defini tion appears as follows <ref> [BGW93] </ref>: "Reflection is the ability of a program to manipulate as data something representing the state of the program during its own execution. There are two aspects of such manipulation : introspection and intercession. Introspection is the ability for a program to observe and therefore reason about its own state.
Reference: [BKK + 86] <author> D.G. Bobrow, K. Kahn, G. Kiczales, L. Masinter, M. Stefik, and F. Zdybel. ComonLoops: </author> <title> Merging Lisp and Object-Oriented Programming. </title> <journal> Proc. of OOP-SLA'86, ACM Sigplan Not., </journal> <volume> 21(11) </volume> <pages> 17-29, </pages> <month> Nov. </month> <year> 1986. </year>
Reference-contexts: metaclasses do not have names and they are treated by the system in such a way to hide them as much as possible from the end-user. * all metaclasses are instances of the same class Metaclass, hence the number of metalevels is fixed and metalinks cannot be created indefinitely Loops <ref> [BKK + 86] </ref> propose a meta-architecture similar to the one of Smalltalk, except that it allows metaclasses to be created explicitly. On the other hand, metaclasses are still distinct from classes and a maximum number of metalinks is still fixed.
Reference: [Bow82] <author> K. A. Bowen. </author> <title> Logic Programming, chapter Amalgamating Language and Metalanguage in Logic Programming. </title> <publisher> Academic press, </publisher> <year> 1982. </year>
Reference-contexts: The resulting system is more expressive and problem-solving power than the original object language system alone. As said in <ref> [Bow82] </ref> (and similarly in [Wey80]), the amalgamation of languages L and M consists of L and M together with 1. a naming relation (similar to the quote mechanism of functional programming) which associates with every lin-guisting expression of L at least one variable-free term of M . <p> This relation constitutes the causal connection needed for reflective systems. 2. a representation of the derivability relation ` L by means of a predicate symbol Demo in the context of sentences T h of M . 3. the following rules called reflection principles [Fef62] <ref> [Bow82] </ref> (sometimes called downward and upward reflection [LMN91] respectively) given by: T h ` M Demo (A 0 ; B 0 ) A ` L B A ` L B T h ` M Demo (A 0 ; B 0 ) A reflective system which respects these particularities is said to <p> upward reflection [LMN91] respectively) given by: T h ` M Demo (A 0 ; B 0 ) A ` L B A ` L B T h ` M Demo (A 0 ; B 0 ) A reflective system which respects these particularities is said to be an amalgamating language <ref> [Bow82] </ref> [Dem94]. Some reflective systems have been created in a way that they could be called amalgamating systems: metaProlog [Bow85], Reflective Prolog [CL89] and the different 3-Prolog languages [Dem94] 2 . These systems are concerned mainly with the representation of the predicate Demo presented earlier. <p> Lisp is not an amalgamating language in the sense of Bowen <ref> [Bow82] </ref> because he requires an explicit representation of the language's processor. But the Lisp quote construct does amalgamate language and metalanguage: it uses a term of the base language to represent itself at the metalevel, albeit in a quoted form. <p> However, very few such experiences have been reported yet. 4 Formal notions for Reflection We discuss here of formal notions used to characterize reflection in programming languages of the three different paradigm, preceded by a historical discussion of reflection in logic freely inspired by [Per85, Per88], [Wey80], <ref> [Bow82] </ref>, [Fef62] and [Cos90]. 4.1 Historical discussion Gottlieb Frege developed the first formal quantificational logic over a period of more than two decades culminating in 1903. The idea was to have a universal language for logic. <p> Second, they provide a method for comparing the strength of formal systems." 4.2 Logic for computation A more pragmatic form of reflection principles, based on a different naming mechanism, was proposed by Weyhrauch [Wey80] and then in <ref> [Bow82] </ref>. We have already discussed the reflective principles presented in the latter. In practice, this approach leads to explicit reflection, that is, explicit calls to Demo must appear in clauses to specify that a goal should be attempted at the metalevel.
Reference: [Bow85] <author> K. A. Bowen. </author> <title> Meta-Level Programming and Knowledge Representation. </title> <journal> New Generation Computing, </journal> <volume> 3 </volume> <pages> 359-383, </pages> <year> 1985. </year>
Reference-contexts: Some reflective systems have been created in a way that they could be called amalgamating systems: metaProlog <ref> [Bow85] </ref>, Reflective Prolog [CL89] and the different 3-Prolog languages [Dem94] 2 . These systems are concerned mainly with the representation of the predicate Demo presented earlier. However all these amalgamating systems are relatively inefficient (because of the meta-programming techniques they use). <p> In [Chr90], a declarative semantics of a meta-programming language (called G CP ) concerned with metagoals is proposed. Although this language does not say offering computational reflection, it has a good structural reflection by using a kind of ground representation and also it is explicitly compared with metaProlog <ref> [Bow85] </ref>. The development of the semantics presented is quite traditional [Llo87] except that the Herbrand interpretations defined are said to be concerned with metagoals instead of with goals.
Reference: [Bru90] <author> M. Bruynooghe, </author> <title> editor. </title> <booktitle> Proceedings of the Second Workshop on Meta-programming in Logic. </booktitle> <institution> K.U. Leu-ven, Department of Comp. </institution> <address> Sc., </address> <month> April </month> <year> 1990. </year>
Reference-contexts: Metaprogramming quickly became so common in Prolog that any self-respecting textbook includes the so-called vanilla meta-interpreter for Prolog written in three clauses (see, for example, [SS86]). A series of conferences devoted exclusively to metaprogramming in logic has also been organized <ref> [AR89, Bru90, Pet92, MET94] </ref>. Finally, the new language Godel [HL94] has been designed with the aim of making metaprogramming more declarative, by implementing primitively the manipulation of terms in a ground representation.
Reference: [CF94] <author> R. Cartwright and M. Felleisen. </author> <title> Extensible denota-tional language sepecifications. </title> <booktitle> In Proc. of TACS'94, </booktitle> <volume> vol. 789. </volume> <publisher> Springer-Verlag, </publisher> <address> LNSC, </address> <month> April </month> <year> 1994. </year>
Reference-contexts: Finally, Cartwright and Felleisen <ref> [CF94] </ref> introduce a new format for denotational language specifications, extended direct semantics, that accommodates orthogonal extensions (as reflective mechanism) of a language without changing the denotations of existing phrases. It is not yet clear how the new approach could be use to formalize reflective languages.
Reference: [Chr90] <author> H. Christiansen. </author> <title> Declarative Semantics of a Metapro--gramming Language. </title> <booktitle> In [Bru90], </booktitle> <pages> pages 159-168, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: This quote mechanism is used in the reflective systems metaProlog of Bowen (and a similar language G CP <ref> [Chr90] </ref> which is not said to be reflective even if it has some reflective features) and in some of the set of 3-Prolog languages. <p> They prove soundness and completeness of their R-refutation mechanism with respect to the declarative semantics defined. However, that reflective operations in R-Prolog* could lead to somewhat dangerous situations which are not studied semantically. In <ref> [Chr90] </ref>, a declarative semantics of a meta-programming language (called G CP ) concerned with metagoals is proposed. Although this language does not say offering computational reflection, it has a good structural reflection by using a kind of ground representation and also it is explicitly compared with metaProlog [Bow85].
Reference: [CL89] <author> S. Costantini and G. A. Lanzarone. </author> <title> A metalogic programming language. </title> <booktitle> In Proc. of the 6th Int. Conference in Logic Prog. Workshop, </booktitle> <year> 1989. </year>
Reference-contexts: Some reflective systems have been created in a way that they could be called amalgamating systems: metaProlog [Bow85], Reflective Prolog <ref> [CL89] </ref> and the different 3-Prolog languages [Dem94] 2 . These systems are concerned mainly with the representation of the predicate Demo presented earlier. However all these amalgamating systems are relatively inefficient (because of the meta-programming techniques they use). For this reason, some people have tried to create non-amalgamating ones. <p> This is the case of the languages CPU and ALPES-IProlog. Only one language (Reflective Prolog <ref> [CL89] </ref>) uses an implicit reflective mechanism which is made by defining reflective operations as metalevel definitions and taking care of reflective calls by an extended resolution procedure. 3.2.3 Reification and reflection The last issue most important for reflective languages is causal connection. <p> Thus his work has tried to understand the relationship between self-reference and modal logic. 4.2.1 Declarative semantics in the logical style The next attempts to formalize of reflection are very close to the classical Horn-clause language semantics [Llo87]. In [Cos90], the declarative and procedural semantics of the Reflective Prolog <ref> [CL89] </ref>, which, on the basis of a naming mechanism (that allows the representation of terms and atomic formulas), makes a different use of amagamating languages' reflection, both procedurally and semantically.
Reference: [Coi87] <author> P. Cointe. </author> <title> Metaclasses are First Class: the ObjVLisp Model. </title> <journal> Proc. of OOPSLA'87, ACM Sigplan Not., </journal> <volume> 22(12) </volume> <pages> 156-167, </pages> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: Besides including inheritance, Smalltalk-76 introduced metaclasses, classes of classes. Note that in OOP, each object has a class, which is called its instantiation class. As an object, the Smalltalk-76 class has its own instantiation class called its metaclass. Smalltalk-80 pursued this idea, but imposed some important limits on metaclasses <ref> [Coi87] </ref>: * metaclasses do not have names and they are treated by the system in such a way to hide them as much as possible from the end-user. * all metaclasses are instances of the same class Metaclass, hence the number of metalevels is fixed and metalinks cannot be created indefinitely <p> On the other hand, metaclasses are still distinct from classes and a maximum number of metalinks is still fixed. The ObjVLisp model <ref> [Coi87] </ref> has been proposed to unify metaclasses and classes and to allow an indefinite number of metalinks to be created. After all, the only difference between classes and metaclasses is that the latter's instances can themselves have instances (i.e. they are classes).
Reference: [Cos90] <author> S. Costantini. </author> <title> Semantics of a metalogic programming language. </title> <journal> Int. Journal on Foundations of Computer Science, </journal> <volume> 1(3), </volume> <year> 1990. </year>
Reference-contexts: However, very few such experiences have been reported yet. 4 Formal notions for Reflection We discuss here of formal notions used to characterize reflection in programming languages of the three different paradigm, preceded by a historical discussion of reflection in logic freely inspired by [Per85, Per88], [Wey80], [Bow82], [Fef62] and <ref> [Cos90] </ref>. 4.1 Historical discussion Gottlieb Frege developed the first formal quantificational logic over a period of more than two decades culminating in 1903. The idea was to have a universal language for logic. <p> Thus his work has tried to understand the relationship between self-reference and modal logic. 4.2.1 Declarative semantics in the logical style The next attempts to formalize of reflection are very close to the classical Horn-clause language semantics [Llo87]. In <ref> [Cos90] </ref>, the declarative and procedural semantics of the Reflective Prolog [CL89], which, on the basis of a naming mechanism (that allows the representation of terms and atomic formulas), makes a different use of amagamating languages' reflection, both procedurally and semantically.
Reference: [Dem94] <author> F.-N. Demers. </author> <title> Reflexion de comportement et evaluation partielle en Prolog. </title> <type> Master's thesis, </type> <institution> U. de Mon-treal, DIRO, </institution> <note> Avril 1994. Tech. report no. 956. </note>
Reference-contexts: reflection [LMN91] respectively) given by: T h ` M Demo (A 0 ; B 0 ) A ` L B A ` L B T h ` M Demo (A 0 ; B 0 ) A reflective system which respects these particularities is said to be an amalgamating language [Bow82] <ref> [Dem94] </ref>. Some reflective systems have been created in a way that they could be called amalgamating systems: metaProlog [Bow85], Reflective Prolog [CL89] and the different 3-Prolog languages [Dem94] 2 . These systems are concerned mainly with the representation of the predicate Demo presented earlier. <p> M Demo (A 0 ; B 0 ) A reflective system which respects these particularities is said to be an amalgamating language [Bow82] <ref> [Dem94] </ref>. Some reflective systems have been created in a way that they could be called amalgamating systems: metaProlog [Bow85], Reflective Prolog [CL89] and the different 3-Prolog languages [Dem94] 2 . These systems are concerned mainly with the representation of the predicate Demo presented earlier. However all these amalgamating systems are relatively inefficient (because of the meta-programming techniques they use). For this reason, some people have tried to create non-amalgamating ones. <p> All the meta-interpreters in the towers are the same and stay unchanged during the whole execution. As a result, the kind of reflective computation of these models have been restricted to punctual intervention during the execution. 3-Prolog <ref> [Dem94] </ref> is a notable exception to this since it allows the program to specify that some reflective predicates must be called repeatedly, without having to explicitly insert calls to them within the program code. A repeated reflective predicate will be called between each reduction of the 3-Prolog metalevel solver.
Reference: [DM88] <author> O. Danvy and K. Malmkjaer. </author> <title> Intensions and Extensions in a Reflective Tower. </title> <booktitle> In Proc. of ACM L&FP'88, </booktitle> <pages> pages 327-341, </pages> <year> 1988. </year>
Reference-contexts: One of the salient feature of this new Brown86 is that it models the reflective tower with only one unique interpreter active at any time (a property that Danvy and Malmkjaer called single-threadedness <ref> [DM88] </ref>). In this context, a metacontinuation can be thought as a list of continuations, each one repre-sentating the state of an interpreter above the one currently active. Brown86 defines reification the act of calling a reflective procedures that receives a reification of the current arguments, environment and continuation as actuals. <p> After Fried-man and Wand, Danvy and Malmkjaer pursued the work and proposed the language Blond <ref> [DM88] </ref>. Blond is similar to Brown except in some specific aspects. Brown turned out to be flawed in the treatment of environments, a problem solved in Blond. Also, Blond made a distinction between what it calls pushy and jumpy continuations in the management of metacontinuations. <p> Although he essentially argued that denotational semantics was forcing the distinction in levels of designation to disappear, and thus evacuating the essence of reflection, the final word came from the observation that the compositionality principle of denotational semantics is irremediably impaired by reflection <ref> [DM88] </ref>. Hence, the denotational semantics approach, even though it has been helpful to understand the nature of reflection, cannot fully express its semantics.
Reference: [dR90] <author> J. </author> <title> des Rivieres. The Secret Tower of CLOS. </title> <booktitle> In [WRM90]. </booktitle>
Reference-contexts: A last point concerns the presence or absence of reflective towers in object oriented behavioral reflection. Pionnered by 3-Lisp, it was not obvious that reflective towers were involved in the forms of behavioral reflection currently implemented in OOP languages. Interestingly, des Rivieres <ref> [dR90] </ref> has shown that the CLOS MOP includes in fact a reflective tower hidden within its reification of the generic function invocation protocol.
Reference: [dRS84] <author> J. des Rivieres and B. C. Smith. </author> <booktitle> The implementation of procedurally reflective languages. In Proc. of ACM L&FP'84, </booktitle> <pages> pages 331-347, </pages> <year> 1984. </year>
Reference-contexts: M-Lisp is claimed to be a simpler, or rationalized, 2-Lisp. 3.1.2 3-Lisp and behavioral reflection Perhaps because the 2-Lisp solution to self-reference was too complicated (according to Muller), Smith's work is much more famous for his second language 3-Lisp implemented in collaboration with des Rivieres <ref> [dRS84] </ref>, which introduced computational reflection. The goal of 3-Lisp is to give programs the ability to reason about and modify their own computation represented by an expression, an environment and a continuation. <p> Another important aspect of 3-Lisp is that an implementation has been given that avoids the actual levels of meta-intepretation by using a shifting-level processor <ref> [dRS84] </ref>.
Reference: [Fef62] <author> S. Feferman. </author> <title> Transfinite Recursive Progressions of Axiomatic Theories. </title> <journal> Journal of Symbolic Logic, </journal> <volume> 27 </volume> <pages> 259-316, </pages> <year> 1962. </year>
Reference-contexts: 1 Introduction Reflection has long been studied in philosophy and formalized to some extent in logic <ref> [Fef62] </ref>. It arised naturally in artificial intelligence, where it is intimately linked to the end goal itself: reflection is viewed as the emergent property responsible, at least in part, for what is considered an "intelligent behavior". <p> This relation constitutes the causal connection needed for reflective systems. 2. a representation of the derivability relation ` L by means of a predicate symbol Demo in the context of sentences T h of M . 3. the following rules called reflection principles <ref> [Fef62] </ref> [Bow82] (sometimes called downward and upward reflection [LMN91] respectively) given by: T h ` M Demo (A 0 ; B 0 ) A ` L B A ` L B T h ` M Demo (A 0 ; B 0 ) A reflective system which respects these particularities is said <p> However, very few such experiences have been reported yet. 4 Formal notions for Reflection We discuss here of formal notions used to characterize reflection in programming languages of the three different paradigm, preceded by a historical discussion of reflection in logic freely inspired by [Per85, Per88], [Wey80], [Bow82], <ref> [Fef62] </ref> and [Cos90]. 4.1 Historical discussion Gottlieb Frege developed the first formal quantificational logic over a period of more than two decades culminating in 1903. The idea was to have a universal language for logic. <p> The main idea was concerned with the "reflection principles" mentioned earlier. The concept of reflection principle was introduced by Feferman <ref> [Fef62] </ref> where it was intended as "the description of a procedure for adding to any set of axioms A certain new axioms whose validity follows from the validity of the axioms A and which formally express, in the language of A, evident consequences of the assumption that all the theorems of
Reference: [Fer89] <author> J. Ferber. </author> <title> Computational Reflection in Class Based Object-Oriented Languages. </title> <journal> Proc. of OOPSLA'89, ACM Sigplan Not., </journal> <volume> 24(10) </volume> <pages> 317-326, </pages> <month> Oct. </month> <year> 1989. </year>
Reference-contexts: An open research problem is to decide what is the scope of a change in the lookup and apply methods and reflective computation in general <ref> [Fer89] </ref>.
Reference: [Fil94] <author> A. Filinski. </author> <title> Representing monads. </title> <booktitle> In Proc. of ACM POPL'94, </booktitle> <pages> pages 446-457, </pages> <year> 1994. </year>
Reference-contexts: In fact, monads can be used to give the semantics of various computational effects such as state, exceptions, or I/O in applicative programming languages. Would it be possible to give a monadic semantics of computational reflection? Filinski <ref> [Fil94] </ref> says: "The correspondence principle can be embodied in an introspective language extension which could be called monadic reflection by analogy to computational reflection, given by two operators: ` E : T ff and ` [E] : T ff For any E : T ff, (E) reflects the value of E
Reference: [FW84] <author> D.P. Friedman and M. Wand. </author> <title> Reification: Reflection without Metaphysics. </title> <booktitle> In Proc. of ACM L&FP'84, </booktitle> <pages> pages 348-355, </pages> <year> 1984. </year>
Reference-contexts: This implementation, although extremely operational (the words are Friedman's and Wand's ones [WF86]), was a first non-reflective description of the reflective tower. 3.1.3 3-Lisp followup In the first of a series of three papers <ref> [FW84, WF86, WF88] </ref>, Friedman and Wand undertook the task of implementing the kind of behavioral reflection offered by 3-Lisp but without resorting to a reflective tower. <p> For example, in CPU [LMN91], the reflection mechanism triggers the computation from the object-level to the meta-level domain by upward reflection and vice versa downward reflection. Note that, in the functional world, these operations are called reification and reflection respectively <ref> [FW84] </ref>. Usually, they are not executed at the same time as they should be done virtually: upward reflection is made first (to "read" reflective structures) and later in the execution, downward reflection is made (to "write" them back). <p> In fact, as mentioned earlier, Wand and Friedman tried to settle a denotational account of reflective towers <ref> [FW84] </ref>, which culminated with [WF88]. Smith has defended for a long time that the denotational framework was not the right tool to approach the problem.
Reference: [Gal93] <author> J. Gallagher. </author> <title> Tutorial on specialisation of logic programs. </title> <booktitle> In Proc. of PEPM'93, </booktitle> <pages> pages 88-98, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: (and possibly Demo), 3-Prolog U reifies the substitutions made by unification, 3-Prolog R reifies the resolvent and 3-Prolog* reifies all the different previous structures and implements an infinite reflective tower as in 3-Lisp. 3 not until now maybe in a near future [HL94] by using efficient concurrency and partial evaluation <ref> [Gal93] </ref> be reflective because they contain in their definition some explicit use of upward and downward reflection which are specific predicates creating causal connection and access to reflective structures. This is the case of the languages CPU and ALPES-IProlog.
Reference: [GWB91] <author> R.P. Gabriel, J.L. White, and D.G. Bobrow. </author> <title> CLOS: Integrating Object-Oriented and Functional Programming. </title> <journal> Comm. of the ACM, </journal> <volume> 34(9) </volume> <pages> 29-38, </pages> <year> 1991. </year>
Reference-contexts: We need a manifest description of the protocols activating the different objects in order to execute the program. The Metaobject Protocol of CLOS <ref> [KRB91, GWB91] </ref> tries to achieve exactly that.
Reference: [HD94] <author> J. Hatcliff and O. Danvy. </author> <title> A generic account of continuation-passing styles. </title> <booktitle> In Proc. of ACM POPL'94, </booktitle> <pages> pages 458-471, </pages> <year> 1994. </year>
Reference-contexts: This tendency to use a logical approach based on categorical notions seems to be quite promising to study programming languages and particularly computational reflection . Some people <ref> [HD94] </ref> have already tried to reason in the new logical frame proposed by Moggi [Mog91] and they say about it the following lines that corroborates in a way with the idea that monads could be used to model computational reflection. "Moggi's framework seems to provide a solid basis for studying both
Reference: [HL89] <author> P. M. Hill and J. W. Lloyd. </author> <title> Analysis of meta-programs. </title> <booktitle> In [AR89]. </booktitle>
Reference-contexts: The development of the semantics presented is quite traditional [Llo87] except that the Herbrand interpretations defined are said to be concerned with metagoals instead of with goals. It seems however that it is similar to the analysis of meta-programs made in <ref> [HL89] </ref> and [HL94]. 4.3 Semantics in the functional style In Section 3.1, we have presented the work of Friedman and Wand with the development of the different versions of Brown in response to 3-Lisp.
Reference: [HL94] <author> P. M. Hill and J. W. Lloyd. </author> <title> The Godel Programming Language. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Metaprogramming quickly became so common in Prolog that any self-respecting textbook includes the so-called vanilla meta-interpreter for Prolog written in three clauses (see, for example, [SS86]). A series of conferences devoted exclusively to metaprogramming in logic has also been organized [AR89, Bru90, Pet92, MET94]. Finally, the new language Godel <ref> [HL94] </ref> has been designed with the aim of making metaprogramming more declarative, by implementing primitively the manipulation of terms in a ground representation. <p> The most natural implementation is to represent all reflective objects as logical terms in the language. This technique is used in most Prolog implementation, and it expects object-level variables that are represented by meta-level variables. This representation is said to be non-ground. In the language Godel <ref> [HL94] </ref>, a ground representation (object-level variables are represented by ground logical terms) is preferred to make the quote mechanism completely uniform (all meta-objects are terms) and most powerful. <p> reification: 3-Prolog P reifies the object-level program clauses (and possibly Demo), 3-Prolog U reifies the substitutions made by unification, 3-Prolog R reifies the resolvent and 3-Prolog* reifies all the different previous structures and implements an infinite reflective tower as in 3-Lisp. 3 not until now maybe in a near future <ref> [HL94] </ref> by using efficient concurrency and partial evaluation [Gal93] be reflective because they contain in their definition some explicit use of upward and downward reflection which are specific predicates creating causal connection and access to reflective structures. This is the case of the languages CPU and ALPES-IProlog. <p> But by now, very few still work on it, mainly for efficiency reasons. 4 4 Some people still work on making the language Godel (which rei-fies the full derivability relation <ref> [HL94] </ref>) as efficient as Prolog by using partial evaluation and parallel implementation techniques. Unfortunately this is not achieved yet. Admittedly, making the language processor fully accessible is a formidable challenge to our current implementation technology. <p> The development of the semantics presented is quite traditional [Llo87] except that the Herbrand interpretations defined are said to be concerned with metagoals instead of with goals. It seems however that it is similar to the analysis of meta-programs made in [HL89] and <ref> [HL94] </ref>. 4.3 Semantics in the functional style In Section 3.1, we have presented the work of Friedman and Wand with the development of the different versions of Brown in response to 3-Lisp.
Reference: [JF92] <author> S. Jefferson and D.P. Friedman. </author> <title> A Simple Reflective Interpreter. </title> <booktitle> In [YS92], </booktitle> <pages> pages 48-58, </pages> <year> 1992. </year>
Reference-contexts: Also, Blond made a distinction between what it calls pushy and jumpy continuations in the management of metacontinuations. Three other languages contributed to this school of reflection: Stepper [Baw88], and more recently I R <ref> [JF92] </ref> and Black [AMY93]. 3.2 Logic programming All the different issues mentionned earlier (esp. in 3.1) have also been studied in logic programming but under different names. We look at them (and also new one) in the following.
Reference: [KRB91] <author> G. Kiczales, J. Des Rivieres, and D. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: We need a manifest description of the protocols activating the different objects in order to execute the program. The Metaobject Protocol of CLOS <ref> [KRB91, GWB91] </ref> tries to achieve exactly that.
Reference: [Kre68] <author> G. Kreisel. </author> <title> Reflection principles and their use for establishing the complexity of axiomatic systems. </title> <journal> In Zeitschrift Fur Mathematische Logik und Grundla-gen der Mathematik, </journal> <volume> vol. 14, </volume> <pages> pages 97-142. </pages> <year> 1968. </year>
Reference-contexts: Later in <ref> [Kre68] </ref>, different reflection principles are discussed for establishing the complexity of different axiomatic systems. In particular, Kreisel says: "Turning now to uses of reflection principles we recall two from the literature.
Reference: [LKRR92] <author> J. Lamping, G. Kiczales, L. Rodriguez, and E. Ruf. </author> <title> An Architecture for an Open Compiler. </title> <booktitle> In [YS92], </booktitle> <pages> pages 95-106, </pages> <year> 1992. </year>
Reference-contexts: Unfortunately this is not achieved yet. Admittedly, making the language processor fully accessible is a formidable challenge to our current implementation technology. An interesting approach recently explored is to provide the users with an open compiler through they could introduce modifications to the language's semantics <ref> [LKRR92] </ref>. This approach has similar properties as the metaprogram-ming approach using metainterpreters: modifications can be done once before the program execution, so they cannot depend upon the current inputs or intermediate results.
Reference: [Llo87] <author> J. W. Lloyd. </author> <booktitle> Foundations of Logic Programming: 2nd Edition. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1987. </year>
Reference-contexts: Thus his work has tried to understand the relationship between self-reference and modal logic. 4.2.1 Declarative semantics in the logical style The next attempts to formalize of reflection are very close to the classical Horn-clause language semantics <ref> [Llo87] </ref>. In [Cos90], the declarative and procedural semantics of the Reflective Prolog [CL89], which, on the basis of a naming mechanism (that allows the representation of terms and atomic formulas), makes a different use of amagamating languages' reflection, both procedurally and semantically. <p> Although this language does not say offering computational reflection, it has a good structural reflection by using a kind of ground representation and also it is explicitly compared with metaProlog [Bow85]. The development of the semantics presented is quite traditional <ref> [Llo87] </ref> except that the Herbrand interpretations defined are said to be concerned with metagoals instead of with goals.
Reference: [LMN91] <author> E. Lamma, P. Mello, and A. Natali. </author> <title> Reflection mechanisms for combining prolog databases. </title> <journal> In Software Practice and Experience, </journal> <volume> 21(6), </volume> <pages> pages 603-624, </pages> <year> 1991. </year>
Reference-contexts: relation constitutes the causal connection needed for reflective systems. 2. a representation of the derivability relation ` L by means of a predicate symbol Demo in the context of sentences T h of M . 3. the following rules called reflection principles [Fef62] [Bow82] (sometimes called downward and upward reflection <ref> [LMN91] </ref> respectively) given by: T h ` M Demo (A 0 ; B 0 ) A ` L B A ` L B T h ` M Demo (A 0 ; B 0 ) A reflective system which respects these particularities is said to be an amalgamating language [Bow82] [Dem94]. <p> Although the latters are all much less powerful than the preceding ones because the predicate Demo is not entirely explicitly represented (by T h), they integrate reflective mechanisms useful for certains logical applications. Examples of the non-amalgamating systems are FOL [Wey80], R-Prolog* [Sug90], CPU <ref> [LMN91] </ref> and ALPES-IProlog [BCL + 88]. Most of these systems have tried especially to resolve practically and theoritically problems related to the logical representation of goals, clauses and variables. 3.2.1 Quote mechanism As we said earlier, in reflective systems a quote mechanism is essential. <p> A direct one is rather about at the same moment. In most logical reflective languages, indirect causal connection is used because it is easier to implement. For example, in CPU <ref> [LMN91] </ref>, the reflection mechanism triggers the computation from the object-level to the meta-level domain by upward reflection and vice versa downward reflection. Note that, in the functional world, these operations are called reification and reflection respectively [FW84].
Reference: [Mae87] <author> P. Maes. </author> <title> Computational Reflection. </title> <type> PhD thesis, </type> <institution> Vrije Universiteit Brussel, </institution> <year> 1987. </year>
Reference-contexts: In particular, we should be able to modify its representation using the language itself. We should also be able to inspect it at run-time. Making an entity first-class is strictly included in its reification, but not the opposite. Coming back to reflection, Pattie Maes gave in her thesis <ref> [Mae87] </ref> the following definitions that summarize pretty well the notion of reflection in computational systems: * A computational system is something that reasons about and acts upon some part of the world, called the domain of the system. * A computational system can be causally connected to its domain. <p> A meta-interpreter is interesting because it is much easier to make its data available to the programs it runs than modifying the language's implementation. Maes said <ref> [Mae87] </ref>: "The main difference between a meta-level architecture and a reflective architecture is that a meta-level architecture only provides static access to the representation of the computational system, while a reflective architecture also provides a dynamic access to this representation." The kind of change we can do in the metaprogram-ming approach
Reference: [MDC94] <author> J. Malenfant, C. Dony, and P. Cointe. </author> <title> A Semantics of Introspection in a Reflective Prototype-Based Language. </title> <note> to appear in Lisp and Symbolic Computation. </note>
Reference-contexts: Interestingly, des Rivieres [dR90] has shown that the CLOS MOP includes in fact a reflective tower hidden within its reification of the generic function invocation protocol. A little later, Malenfant et al. <ref> [MDC94] </ref> have shown a similar result for languages using a more traditional lookupffiapply reflective protocol, which also give rise to reflective towers. <p> Hence, the denotational semantics approach, even though it has been helpful to understand the nature of reflection, cannot fully express its semantics. New approaches must be sought to reach the goal. 4.4 Rewriting systems Recently, Friedman and Mendhekar [MF93] as well as Malen-fant, et al. <ref> [MDC94] </ref> independently applied the theory of rewrite systems to this end, with encouraging results. The goal of Friedman and Mendhekar is to develop a programming logic for reflective languages.
Reference: [MET94] <editor> Proc. </editor> <booktitle> of the fourth Workshop on Meta-programming in Logic. </booktitle> <publisher> Springer-Verlag, LNCS 883, </publisher> <year> 1994. </year>
Reference-contexts: Metaprogramming quickly became so common in Prolog that any self-respecting textbook includes the so-called vanilla meta-interpreter for Prolog written in three clauses (see, for example, [SS86]). A series of conferences devoted exclusively to metaprogramming in logic has also been organized <ref> [AR89, Bru90, Pet92, MET94] </ref>. Finally, the new language Godel [HL94] has been designed with the aim of making metaprogramming more declarative, by implementing primitively the manipulation of terms in a ground representation.
Reference: [MF93] <author> A. Mendhekar and D.P. Friedman. </author> <title> Towards a Theory of Reflective Programming Languages. </title> <booktitle> In [WRM93]. </booktitle>
Reference-contexts: Hence, the denotational semantics approach, even though it has been helpful to understand the nature of reflection, cannot fully express its semantics. New approaches must be sought to reach the goal. 4.4 Rewriting systems Recently, Friedman and Mendhekar <ref> [MF93] </ref> as well as Malen-fant, et al. [MDC94] independently applied the theory of rewrite systems to this end, with encouraging results. The goal of Friedman and Mendhekar is to develop a programming logic for reflective languages.
Reference: [MLV89] <author> J. Malenfant, G. Lapalme, and J. Vaucher. ObjVPro-log: </author> <title> Metaclasses in Logic. </title> <booktitle> In Proc. of ECOOP'89, </booktitle> <pages> pages 257-269. </pages> <address> Cambridge U. </address> <publisher> Press, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: It also solves the potential infinite metaregression by making Class its own instance. ObjVLisp is a model that has been applied first to an object system written in Lisp, but it has also been applied to Scheme, to Smalltalk (Classtalk [BC89]), and to an object-oriented extension of Prolog (ObjVProlog <ref> [MLV89, MLV90] </ref>). 3.3.2 Towards full reflection With its "object-to-the-bottom" principle, Smalltalk pio-nnered a design principle basic to reflection, which is that everything should be expressed in the terms of the language itself.
Reference: [MLV90] <author> J. Malenfant, G. Lapalme, and J. Vaucher. </author> <title> Meta-classes for Metaprogramming in Logic. </title> <booktitle> In [Bru90], </booktitle> <pages> pages 257-271, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: It also solves the potential infinite metaregression by making Class its own instance. ObjVLisp is a model that has been applied first to an object system written in Lisp, but it has also been applied to Scheme, to Smalltalk (Classtalk [BC89]), and to an object-oriented extension of Prolog (ObjVProlog <ref> [MLV89, MLV90] </ref>). 3.3.2 Towards full reflection With its "object-to-the-bottom" principle, Smalltalk pio-nnered a design principle basic to reflection, which is that everything should be expressed in the terms of the language itself.
Reference: [MN88] <editor> P. Maes and D. Nardi, editors. </editor> <title> Meta-Level Architectures and Reflection. </title> <publisher> North-Holland, </publisher> <year> 1988. </year>
Reference: [Mog91] <author> E. Moggi. </author> <title> Notions of Computation and Monads. </title> <journal> Information and Computation, </journal> <volume> 93(1), </volume> <year> 1991. </year>
Reference-contexts: Originally proposed by Moggi as a convenient framework for structuring the semantics of languages [Mog89] <ref> [Mog91] </ref>, they were popularized by Wadler [Wad90] [Wad92] and others as a technique for structuring functional programs. In fact, monads can be used to give the semantics of various computational effects such as state, exceptions, or I/O in applicative programming languages. <p> Recently a lot of research is made to introduce new formal calculi based on a categorical semantics. In <ref> [Mog91] </ref>, it is said that "the logical approach (to express these new cal-culies compared with the more commun operational and de-notational approach) gives a consequence relation `, namely Ax ` A iff the formula A is true in all models of the set of formulas Ax, which can deal with different <p> This tendency to use a logical approach based on categorical notions seems to be quite promising to study programming languages and particularly computational reflection . Some people [HD94] have already tried to reason in the new logical frame proposed by Moggi <ref> [Mog91] </ref> and they say about it the following lines that corroborates in a way with the idea that monads could be used to model computational reflection. "Moggi's framework seems to provide a solid basis for studying both the relation between implicit and explicit representations of control and the relation between implicit
Reference: [Mog89] <author> E. Moggi. </author> <title> Computational lambda-calculus and mon-ads. </title> <booktitle> In Proc. of LICS'89. </booktitle>
Reference-contexts: Originally proposed by Moggi as a convenient framework for structuring the semantics of languages <ref> [Mog89] </ref> [Mog91], they were popularized by Wadler [Wad90] [Wad92] and others as a technique for structuring functional programs. In fact, monads can be used to give the semantics of various computational effects such as state, exceptions, or I/O in applicative programming languages.
Reference: [Mul92] <author> R. Muller. </author> <title> M-LISP: A Representation Independent Dialect of LISP with Reduction Semantics. </title> <journal> ACM TOPLAS, </journal> <volume> 14(4) </volume> <pages> 589-615, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: This decoding is automatically done by the eval function. But, this behavior is considered anomalous <ref> [Mul92] </ref>, and indeed it makes it difficult to manipulate the reified expressions. When Smith invented computational reflection and implemented it in Lisp, he was aware of this problem. <p> In 2-Lisp, no automatic decoding appears in the evaluation process. Instead, two primitives, UP and DOWN, help to mediate the metastructural hierarchy, and there is no other mean to remove quotes. More recently, Muller <ref> [Mul92] </ref> proposed M-Lisp with a similar motivation.
Reference: [Per85] <author> D. Perlis. </author> <title> Languages with self-reference I: Foundations (or: We can have everything in first-order logic!). </title> <journal> Artificial Intelligence, </journal> <volume> 25 </volume> <pages> 301-322, </pages> <year> 1985. </year>
Reference-contexts: However, very few such experiences have been reported yet. 4 Formal notions for Reflection We discuss here of formal notions used to characterize reflection in programming languages of the three different paradigm, preceded by a historical discussion of reflection in logic freely inspired by <ref> [Per85, Per88] </ref>, [Wey80], [Bow82], [Fef62] and [Cos90]. 4.1 Historical discussion Gottlieb Frege developed the first formal quantificational logic over a period of more than two decades culminating in 1903. The idea was to have a universal language for logic. <p> Frege had certain comprehension axioms that specifically created object-notations "P " for P , and stated that sentences using properties as predicates could be equivalently rephrased using properties as objects. These axioms in effect state a relationship between a name and what it names <ref> [Per85] </ref>: Has (c; "P ") $ P (c) or equivalently, but closer to Frege's notation: c 2 fxjP (x)g $ P (c). In the same year Bertrand Russell showed that Frege's system was inconsistent. <p> The main problem was thus addressed in logic as the need to find a way to collapse all levels into one without contradiction, i.e. the need to have a self-referential or universal language. In <ref> [Per85] </ref>, it has been said that quotation seems necessarily involved at some point if we are to have a self-describing language and to treat logical terms as some sort of first-class entities. <p> In practice, this approach leads to explicit reflection, that is, explicit calls to Demo must appear in clauses to specify that a goal should be attempted at the metalevel. These results remind clearly the need of meta-programming facilities to amalgamate object-level with some meta-level languages. In Perlis <ref> [Per85] </ref>, a theory of "quotation" and "unquota-tion" is presented to refer to certain statements as true and false. The author concentrates on the importance of the roles of truth and self-reference in commonsense reasoning.
Reference: [Per88] <author> D. Perlis. </author> <title> Languages with self-reference II: Knowledge, Belief, and Modality. </title> <journal> Artificial Intelligence, </journal> <volume> 34 </volume> <pages> 179-212, </pages> <year> 1988. </year>
Reference-contexts: However, very few such experiences have been reported yet. 4 Formal notions for Reflection We discuss here of formal notions used to characterize reflection in programming languages of the three different paradigm, preceded by a historical discussion of reflection in logic freely inspired by <ref> [Per85, Per88] </ref>, [Wey80], [Bow82], [Fef62] and [Cos90]. 4.1 Historical discussion Gottlieb Frege developed the first formal quantificational logic over a period of more than two decades culminating in 1903. The idea was to have a universal language for logic. <p> In Perlis [Per85], a theory of "quotation" and "unquota-tion" is presented to refer to certain statements as true and false. The author concentrates on the importance of the roles of truth and self-reference in commonsense reasoning. In his following article <ref> [Per88] </ref>, he has showed that modal logics are on no firmer ground than first-order ones when equally endowed with substitutive self-reference.
Reference: [Pet92] <editor> A. Pettorossi, editor. </editor> <booktitle> Proceedings of the Third Workshop on Meta-programming in Logic. </booktitle> <publisher> Springer-Verlag, LNCS 649, </publisher> <month> April </month> <year> 1992. </year>
Reference-contexts: Metaprogramming quickly became so common in Prolog that any self-respecting textbook includes the so-called vanilla meta-interpreter for Prolog written in three clauses (see, for example, [SS86]). A series of conferences devoted exclusively to metaprogramming in logic has also been organized <ref> [AR89, Bru90, Pet92, MET94] </ref>. Finally, the new language Godel [HL94] has been designed with the aim of making metaprogramming more declarative, by implementing primitively the manipulation of terms in a ground representation.
Reference: [Smi82] <author> B.C. Smith. </author> <title> Reflection and Semantics in a Procedural Language. </title> <type> Tech. Report 272, </type> <institution> MIT, </institution> <year> 1982. </year>
Reference-contexts: Perhaps surprisingly, it has been also applied in the area of programming languages under the name of computational reflection. Computational reflection dates from Brian Smith's seminal work in the early 80s <ref> [Smi82, Smi84] </ref>. In his way to formalize the concept of reflection, he developed two languages: 2-Lisp and 3-Lisp.
Reference: [Smi84] <author> B.C. Smith. </author> <title> Reflection and Semantics in Lisp. </title> <booktitle> In Proc. of ACM POPL'84, </booktitle> <pages> pages 23-35, </pages> <year> 1984. </year>
Reference-contexts: Perhaps surprisingly, it has been also applied in the area of programming languages under the name of computational reflection. Computational reflection dates from Brian Smith's seminal work in the early 80s <ref> [Smi82, Smi84] </ref>. In his way to formalize the concept of reflection, he developed two languages: 2-Lisp and 3-Lisp.
Reference: [SS86] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> MIT Press, </publisher> <year> 1986. </year>
Reference-contexts: Metaprogramming quickly became so common in Prolog that any self-respecting textbook includes the so-called vanilla meta-interpreter for Prolog written in three clauses (see, for example, <ref> [SS86] </ref>). A series of conferences devoted exclusively to metaprogramming in logic has also been organized [AR89, Bru90, Pet92, MET94]. Finally, the new language Godel [HL94] has been designed with the aim of making metaprogramming more declarative, by implementing primitively the manipulation of terms in a ground representation.
Reference: [Sug90] <author> H. Sugano. </author> <title> Meta and reflective computation in logic programs and its semantics. </title> <booktitle> In [Bru90]. </booktitle>
Reference-contexts: Although the latters are all much less powerful than the preceding ones because the predicate Demo is not entirely explicitly represented (by T h), they integrate reflective mechanisms useful for certains logical applications. Examples of the non-amalgamating systems are FOL [Wey80], R-Prolog* <ref> [Sug90] </ref>, CPU [LMN91] and ALPES-IProlog [BCL + 88]. Most of these systems have tried especially to resolve practically and theoritically problems related to the logical representation of goals, clauses and variables. 3.2.1 Quote mechanism As we said earlier, in reflective systems a quote mechanism is essential. <p> Derivation by resolution is extended to include forms of implicit reflection to shift between levels. Extended resolution is proved sound and complete with respect to the least reflective Herbrand model of a program. In <ref> [Sug90] </ref>, a declarative semantics of R-Prolog* is discussed. Because computational reflection is a sort of procedural notion, the usual declarative semantics given as logical consequence of programs cannot be adopted.
Reference: [Wad90] <author> P. L. Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proc. of ACM L&FP'90, </booktitle> <pages> pages 61-78, </pages> <year> 1990. </year>
Reference-contexts: Originally proposed by Moggi as a convenient framework for structuring the semantics of languages [Mog89] [Mog91], they were popularized by Wadler <ref> [Wad90] </ref> [Wad92] and others as a technique for structuring functional programs. In fact, monads can be used to give the semantics of various computational effects such as state, exceptions, or I/O in applicative programming languages.
Reference: [Wad92] <author> P. L. Wadler. </author> <title> The essence of functional programming. </title> <booktitle> In Proc. of ACM POPL'92, </booktitle> <pages> pages 1-14, </pages> <year> 1992. </year>
Reference-contexts: Originally proposed by Moggi as a convenient framework for structuring the semantics of languages [Mog89] [Mog91], they were popularized by Wadler [Wad90] <ref> [Wad92] </ref> and others as a technique for structuring functional programs. In fact, monads can be used to give the semantics of various computational effects such as state, exceptions, or I/O in applicative programming languages.
Reference: [Wey80] <author> R.W. Weyhrauch. </author> <title> Prolegomena to a Theory of Mechanized Formal Reasoning. </title> <journal> Artificial Intelligence, </journal> <volume> 13(1,2), </volume> <year> 1980. </year>
Reference-contexts: The resulting system is more expressive and problem-solving power than the original object language system alone. As said in [Bow82] (and similarly in <ref> [Wey80] </ref>), the amalgamation of languages L and M consists of L and M together with 1. a naming relation (similar to the quote mechanism of functional programming) which associates with every lin-guisting expression of L at least one variable-free term of M . <p> Although the latters are all much less powerful than the preceding ones because the predicate Demo is not entirely explicitly represented (by T h), they integrate reflective mechanisms useful for certains logical applications. Examples of the non-amalgamating systems are FOL <ref> [Wey80] </ref>, R-Prolog* [Sug90], CPU [LMN91] and ALPES-IProlog [BCL + 88]. Most of these systems have tried especially to resolve practically and theoritically problems related to the logical representation of goals, clauses and variables. 3.2.1 Quote mechanism As we said earlier, in reflective systems a quote mechanism is essential. <p> However, very few such experiences have been reported yet. 4 Formal notions for Reflection We discuss here of formal notions used to characterize reflection in programming languages of the three different paradigm, preceded by a historical discussion of reflection in logic freely inspired by [Per85, Per88], <ref> [Wey80] </ref>, [Bow82], [Fef62] and [Cos90]. 4.1 Historical discussion Gottlieb Frege developed the first formal quantificational logic over a period of more than two decades culminating in 1903. The idea was to have a universal language for logic. <p> Second, they provide a method for comparing the strength of formal systems." 4.2 Logic for computation A more pragmatic form of reflection principles, based on a different naming mechanism, was proposed by Weyhrauch <ref> [Wey80] </ref> and then in [Bow82]. We have already discussed the reflective principles presented in the latter. In practice, this approach leads to explicit reflection, that is, explicit calls to Demo must appear in clauses to specify that a goal should be attempted at the metalevel.
Reference: [WF86] <author> M. Wand and D. P. Friedman. </author> <title> The mystery of the tower revealed: a non-reflective description of the reflective tower. </title> <booktitle> In Proc. of ACM L&FP'86, </booktitle> <year> 1986. </year>
Reference-contexts: Another important aspect of 3-Lisp is that an implementation has been given that avoids the actual levels of meta-intepretation by using a shifting-level processor [dRS84]. This implementation, although extremely operational (the words are Friedman's and Wand's ones <ref> [WF86] </ref>), was a first non-reflective description of the reflective tower. 3.1.3 3-Lisp followup In the first of a series of three papers [FW84, WF86, WF88], Friedman and Wand undertook the task of implementing the kind of behavioral reflection offered by 3-Lisp but without resorting to a reflective tower. <p> This implementation, although extremely operational (the words are Friedman's and Wand's ones [WF86]), was a first non-reflective description of the reflective tower. 3.1.3 3-Lisp followup In the first of a series of three papers <ref> [FW84, WF86, WF88] </ref>, Friedman and Wand undertook the task of implementing the kind of behavioral reflection offered by 3-Lisp but without resorting to a reflective tower.
Reference: [WF88] <author> M. Wand and D. P. Friedman. </author> <title> The Mystery of the Tower Revealed: A Nonreflective Description of the Reflective Tower. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 1(1) </volume> <pages> 11-37, </pages> <year> 1988. </year>
Reference-contexts: This implementation, although extremely operational (the words are Friedman's and Wand's ones [WF86]), was a first non-reflective description of the reflective tower. 3.1.3 3-Lisp followup In the first of a series of three papers <ref> [FW84, WF86, WF88] </ref>, Friedman and Wand undertook the task of implementing the kind of behavioral reflection offered by 3-Lisp but without resorting to a reflective tower. <p> In fact, as mentioned earlier, Wand and Friedman tried to settle a denotational account of reflective towers [FW84], which culminated with <ref> [WF88] </ref>. Smith has defended for a long time that the denotational framework was not the right tool to approach the problem.
Reference: [WRM90] <editor> Proc. </editor> <booktitle> of the First Workshop on Reflection and Metalevel Architectures in Object-Oriented Programming, </booktitle> <address> OOPSLA/ECOOP'90, </address> <month> Oct. </month> <year> 1990. </year>
Reference-contexts: In a sense, the tools were taken for the concept. A link certainly exists between first-class entites, higher-order functions, metaprogramming and reflection, but no one stands for the other. Reflection has been defined in a fairly general way by Brian Smith during the ECOOP/OOPSLA'90 workshop on reflection <ref> [WRM90] </ref>: "An entity's integral ability to represent, operate on, and otherwise deal with its self in the same way that it represents, operates on and deals with its primary subject matter." In programming languages, the incarnation of this defini tion appears as follows [BGW93]: "Reflection is the ability of a program
Reference: [WRM91] <editor> Proc. </editor> <booktitle> of the Second Workshop on Reflection and Metalevel Architectures in Object-Oriented Programming, </booktitle> <address> OOPSLA'91, </address> <month> Oct. </month> <year> 1991. </year>
Reference: [WRM93] <editor> Proc. </editor> <booktitle> of the Third Workshop on Reflection and Metalevel Architectures in Object-Oriented Programming, </booktitle> <address> OOPSLA'93, </address> <month> Oct. </month> <year> 1993. </year>
Reference: [YS92] <editor> A. Yonezawa and B. Smith, editors. </editor> <booktitle> Proc. of the International Workshop on New Models for Software Architecture '92, Reflection and Meta-Level Architecture, </booktitle> <month> Nov. </month> <year> 1992. </year>
References-found: 60

