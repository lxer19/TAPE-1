URL: http://pine.cs.yale.edu:4201/home/jalg90.ps
Refering-URL: http://pine.cs.yale.edu:4201/home/jalg90-abstract.html
Root-URL: http://www.cs.yale.edu
Title: Fast Randomized Consensus using Shared Memory  
Author: James Aspnes Maurice Herlihy 
Date: September 17, 1996  
Address: Pittsburgh, PA 15213  Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie-Mellon University  School of Computer Science Carnegie-Mellon University  
Abstract: We give a new randomized algorithm for achieving consensus among asynchronous processes that communicate by reading and writing shared registers. The fastest previously known algorithm has exponential expected running time. Our algorithm is polynomial, requiring an expected O(n 4 ) operations. Applications of this algorithm include the elimination of critical sections from concurrent data structures and the construction of asymptotically unbiased shared coins.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Abrahamson. </author> <title> On achieving consensus using a shared memory. </title> <booktitle> In Seventh ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1988. </year>
Reference-contexts: The protocols are consistent, nontrivial, and they guarantee that each process decides after a finite expected number of steps. The only previously known read/write protocol, due to Abrahamson <ref> [1] </ref>, requires an expected 2 O (n 2 ) operations. Ours is significantly faster, requiring an expected n 2 writes and n 4 reads. The fetch-and-add protocol requires an expected n 2 fetch-and-add operations. The basic idea behind our protocols is quite simple. <p> By contrast, the protocols presented here, updating a register and changing process state are distinct transitions. Abrahamson <ref> [1] </ref> gives consensus protocols for both the "strong" model used by Chor, Israeli, and Li, and the more demanding "weak" model used here. As mentioned above, Abrahamson's consensus protocol for the weak model has exponential expected running time.
Reference: [2] <author> J.H. Anderson and M.G. Gouda. </author> <title> The virtue of patience: Concurrent programming with and without waiting. </title> <type> Private Communication. </type>
Reference-contexts: If the shared object X is an array of registers providing read and write operations, then consensus is known to be impossible <ref> [2, 12, 15, 21, 27] </ref>. If X is an array of registers providing test-and-set or fetch-and-add operations, then consensus is possible between two processes, but not among three [21, 27]. Nevertheless, in both cases, consensus among an arbitrary number of processes can still be achieved probabilistically.
Reference: [3] <author> M. Ben-Or. </author> <title> Another advantage of free choice: completely asynchronous agreement protocols. </title> <booktitle> In Second ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 27-30, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: Dolev, Dwork, and Stockmeyer [15] and Dwork, Lynch, and Stockmeyer [16] give a comprehensive analysis of the circumstances under which consensus can be achieved by message-passing. Randomized protocols can achieve consensus when deterministic protocols cannot. Ben-Or <ref> [3] </ref> proposes a randomized consensus protocol with exponential expected running time that tolerates up to n=5 failures, where n is the number of processes. A consensus protocol due to Bracha and Toueg [7] relies on probabilistic properties of the message-passing system.
Reference: [4] <author> M. Ben-Or and N. Linial. </author> <title> Collective coin flipping, robust voting schemes, and minima of banzhaf values. </title> <booktitle> In Twenty-sixth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 408-416, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: As mentioned above, Abrahamson's consensus protocol for the weak model has exponential expected running time. A number of protocols have been proposed for implementing shared coins in message-passing systems subject to byzantine or halting failures. (An excellent survey appears in [11].) Some constructions are direct <ref> [4, 8, 17] </ref>, and others arise as parts of protocols for consensus [13], transaction commitment [14], or byzantine agreement [6, 13, 18, 33].
Reference: [5] <author> B. Bloom. </author> <title> Constructing two-writer atomic registers. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 249-259, </pages> <year> 1987. </year>
Reference-contexts: The likelihood the adversary can force an outcome of heads in the initial round is thus (K + 1)=2K, which approaches 1=2 as K increases. 21 9 Discussion Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [5, 9, 25, 26, 30, 31, 32, 34] </ref>.
Reference: [6] <author> G. Bracha. </author> <title> An o(log n) expected rounds randomized byzantine generals algorithm. </title> <booktitle> In Seventeenth Annual Symposium on Theory of Computation, </booktitle> <year> 1985. </year>
Reference-contexts: A number of protocols have been proposed for implementing shared coins in message-passing systems subject to byzantine or halting failures. (An excellent survey appears in [11].) Some constructions are direct [4, 8, 17], and others arise as parts of protocols for consensus [13], transaction commitment [14], or byzantine agreement <ref> [6, 13, 18, 33] </ref>. The models underlying these protocols differ from ours by assuming that private channels or encryption can be used to prevent the adversary from observing certain messages and processes' internal states.
Reference: [7] <author> G. Bracha and S. Toueg. </author> <title> Resilient consensus protocols. </title> <booktitle> In Second ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 12-26, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: Randomized protocols can achieve consensus when deterministic protocols cannot. Ben-Or [3] proposes a randomized consensus protocol with exponential expected running time that tolerates up to n=5 failures, where n is the number of processes. A consensus protocol due to Bracha and Toueg <ref> [7] </ref> relies on probabilistic properties of the message-passing system. Loui and Abu-Amara [27] give several consensus protocols and impossibility results for processes that communicate through shared registers with various read-modify-write ("test-and-set") operations.
Reference: [8] <author> A. Broder and D. Dolev. </author> <title> Flipping coins in many pockets (byzantine agreement on uniformly random values. </title> <booktitle> In Twenty-Fifth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 157-170, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: As mentioned above, Abrahamson's consensus protocol for the weak model has exponential expected running time. A number of protocols have been proposed for implementing shared coins in message-passing systems subject to byzantine or halting failures. (An excellent survey appears in [11].) Some constructions are direct <ref> [4, 8, 17] </ref>, and others arise as parts of protocols for consensus [13], transaction commitment [14], or byzantine agreement [6, 13, 18, 33].
Reference: [9] <author> J.E. Burns and G.L. Peterson. </author> <title> Constructing multi-reader atomic values from non-atomic values. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 222-231, </pages> <year> 1987. </year>
Reference-contexts: The likelihood the adversary can force an outcome of heads in the initial round is thus (K + 1)=2K, which approaches 1=2 as K increases. 21 9 Discussion Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [5, 9, 25, 26, 30, 31, 32, 34] </ref>.
Reference: [10] <author> B. Chor and B. Coan. </author> <title> A simple and efficient randomized byzantine agreement algorithm. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(6):531-539, </volume> <month> June </month> <year> 1985. </year> <month> 23 </month>
Reference-contexts: The models underlying these protocols differ from ours by assuming that private channels or encryption can be used to prevent the adversary from observing certain messages and processes' internal states. Chor and Coan <ref> [10] </ref> give a randomized byzan-tine agreement protocol that does not assume private communication, but restricts when the adversary may exploit knowledge of the processes' states. 3 Model 3.1 I/O Automata Formally, we model processes and registers as I/O automata [28, 29].
Reference: [11] <author> B. Chor and C. Dwork. </author> <title> Randomization in Byzantine Agreement, vol-ume 4. </title> <publisher> JAI Press, </publisher> <year> 1987. </year>
Reference-contexts: As mentioned above, Abrahamson's consensus protocol for the weak model has exponential expected running time. A number of protocols have been proposed for implementing shared coins in message-passing systems subject to byzantine or halting failures. (An excellent survey appears in <ref> [11] </ref>.) Some constructions are direct [4, 8, 17], and others arise as parts of protocols for consensus [13], transaction commitment [14], or byzantine agreement [6, 13, 18, 33].
Reference: [12] <author> B. Chor, A. Israeli, and M. Li. </author> <title> On processor coordination using asynchronous hardware. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1987. </year>
Reference-contexts: If the shared object X is an array of registers providing read and write operations, then consensus is known to be impossible <ref> [2, 12, 15, 21, 27] </ref>. If X is an array of registers providing test-and-set or fetch-and-add operations, then consensus is possible between two processes, but not among three [21, 27]. Nevertheless, in both cases, consensus among an arbitrary number of processes can still be achieved probabilistically. <p> A consensus protocol due to Bracha and Toueg [7] relies on probabilistic properties of the message-passing system. Loui and Abu-Amara [27] give several consensus protocols and impossibility results for processes that communicate through shared registers with various read-modify-write ("test-and-set") operations. Chor, Israeli and Li <ref> [12] </ref> give two randomized consensus protocols for shared read/write registers, one for two processes, and one for three processes. 1 Their protocols, 1 The three-process protocol published in [12] has a bug: the termination condition must be strengthened to ensure consistency. 3 however, require a "strong" synchronization primitive: the ability to <p> Chor, Israeli and Li <ref> [12] </ref> give two randomized consensus protocols for shared read/write registers, one for two processes, and one for three processes. 1 Their protocols, 1 The three-process protocol published in [12] has a bug: the termination condition must be strengthened to ensure consistency. 3 however, require a "strong" synchronization primitive: the ability to flip a coin and write the result in a single atomic step.
Reference: [13] <author> B. Chor, M. Merritt, </author> <title> and D.B. Shmoys. Simple constant-time consensus protocols in realistic failure models. </title> <booktitle> In Proceedings of the Fourth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 152-160, </pages> <year> 1985. </year>
Reference-contexts: Unfortunately, implementing an unbiased shared coin is provably impossible in an asynchronous system (see Section 8 below), so it would appear that no progress 2 has been made. The key insight, however, is similar to one proposed by Chor, Merritt, and Shmoys <ref> [13] </ref>: it suffices to ensure that processes are sufficiently likely to flip the same value, and that an adversary scheduler has a sufficiently weak influence over which value is chosen. <p> A number of protocols have been proposed for implementing shared coins in message-passing systems subject to byzantine or halting failures. (An excellent survey appears in [11].) Some constructions are direct [4, 8, 17], and others arise as parts of protocols for consensus <ref> [13] </ref>, transaction commitment [14], or byzantine agreement [6, 13, 18, 33]. The models underlying these protocols differ from ours by assuming that private channels or encryption can be used to prevent the adversary from observing certain messages and processes' internal states. <p> A number of protocols have been proposed for implementing shared coins in message-passing systems subject to byzantine or halting failures. (An excellent survey appears in [11].) Some constructions are direct [4, 8, 17], and others arise as parts of protocols for consensus [13], transaction commitment [14], or byzantine agreement <ref> [6, 13, 18, 33] </ref>. The models underlying these protocols differ from ours by assuming that private channels or encryption can be used to prevent the adversary from observing certain messages and processes' internal states.
Reference: [14] <author> B. Coan and J. Lundelius. </author> <title> Transaction commit in a realistic fault model. </title> <booktitle> In Fifth ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 40-52, </pages> <month> August </month> <year> 1986. </year>
Reference-contexts: A number of protocols have been proposed for implementing shared coins in message-passing systems subject to byzantine or halting failures. (An excellent survey appears in [11].) Some constructions are direct [4, 8, 17], and others arise as parts of protocols for consensus [13], transaction commitment <ref> [14] </ref>, or byzantine agreement [6, 13, 18, 33]. The models underlying these protocols differ from ours by assuming that private channels or encryption can be used to prevent the adversary from observing certain messages and processes' internal states.
Reference: [15] <author> D. Dolev, C. Dwork, and L Stockmeyer. </author> <title> On the minimal synchronism needed for distributed consensus. </title> <journal> Journal of the ACM, </journal> <volume> 34(1) </volume> <pages> 77-97, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: If the shared object X is an array of registers providing read and write operations, then consensus is known to be impossible <ref> [2, 12, 15, 21, 27] </ref>. If X is an array of registers providing test-and-set or fetch-and-add operations, then consensus is possible between two processes, but not among three [21, 27]. Nevertheless, in both cases, consensus among an arbitrary number of processes can still be achieved probabilistically. <p> Against such a powerful adversary, it may seem surprising that consensus can be achieved by a simple protocol in polynomial expected time. 2 Related Work Fischer, Lynch, and Paterson [20] show that there is no consensus protocol for two processes that communicate by asynchronous messages. Dolev, Dwork, and Stockmeyer <ref> [15] </ref> and Dwork, Lynch, and Stockmeyer [16] give a comprehensive analysis of the circumstances under which consensus can be achieved by message-passing. Randomized protocols can achieve consensus when deterministic protocols cannot.
Reference: [16] <author> C. Dwork, N. Lynch, and L Stockmeyer. </author> <title> Consensus in the presence of partial synchrony. </title> <journal> Journal of the ACM, </journal> <volume> 35(2) </volume> <pages> 228-323, </pages> <month> April </month> <year> 1988. </year>
Reference-contexts: Dolev, Dwork, and Stockmeyer [15] and Dwork, Lynch, and Stockmeyer <ref> [16] </ref> give a comprehensive analysis of the circumstances under which consensus can be achieved by message-passing. Randomized protocols can achieve consensus when deterministic protocols cannot. Ben-Or [3] proposes a randomized consensus protocol with exponential expected running time that tolerates up to n=5 failures, where n is the number of processes.
Reference: [17] <author> C. Dwork, D. Shmoys, and L. Stockmeyer. </author> <title> Flipping persuasively in constant expected time. </title> <booktitle> In Twenty-Seventh Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 222-232, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: As mentioned above, Abrahamson's consensus protocol for the weak model has exponential expected running time. A number of protocols have been proposed for implementing shared coins in message-passing systems subject to byzantine or halting failures. (An excellent survey appears in [11].) Some constructions are direct <ref> [4, 8, 17] </ref>, and others arise as parts of protocols for consensus [13], transaction commitment [14], or byzantine agreement [6, 13, 18, 33].
Reference: [18] <author> P. Feldman and S. Micali. </author> <title> Optimal algorithms for byzantine agreement. </title> <booktitle> In Twentieth Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 148-161, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: A number of protocols have been proposed for implementing shared coins in message-passing systems subject to byzantine or halting failures. (An excellent survey appears in [11].) Some constructions are direct [4, 8, 17], and others arise as parts of protocols for consensus [13], transaction commitment [14], or byzantine agreement <ref> [6, 13, 18, 33] </ref>. The models underlying these protocols differ from ours by assuming that private channels or encryption can be used to prevent the adversary from observing certain messages and processes' internal states.
Reference: [19] <author> W. Feller. </author> <title> An Introduction to Probability Theory and its Applications, volume 1. </title> <publisher> John Wiley and Sons, </publisher> <year> 1957. </year>
Reference-contexts: It is a standard result of random walk theory <ref> [19, Ch. XIV] </ref> that the probability of reaching (K 1)n before (K + 1)n is (K + 1)=2K. One way to make certain that some process flips heads is to force two processors to disagree. <p> It is a standard result of random walk theory <ref> [19] </ref> that the expected running time of such a walk is (K + 1) 2 n 2 , i.e. O (n 2 ). 6 The Counter Abstraction The counter implementation is a straightforward adaptation of an algorithm proposed by Lamport [25] for read/write registers.
Reference: [20] <author> M. Fischer, N.A. Lynch, </author> <title> and M.S. Paterson. Impossibility of distributed commit with one faulty process. </title> <journal> Journal of the ACM, </journal> <volume> 32(2), </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: The adversary cannot, however, predict future coin flips. Against such a powerful adversary, it may seem surprising that consensus can be achieved by a simple protocol in polynomial expected time. 2 Related Work Fischer, Lynch, and Paterson <ref> [20] </ref> show that there is no consensus protocol for two processes that communicate by asynchronous messages. Dolev, Dwork, and Stockmeyer [15] and Dwork, Lynch, and Stockmeyer [16] give a comprehensive analysis of the circumstances under which consensus can be achieved by message-passing.
Reference: [21] <author> M.P. Herlihy. </author> <title> Impossibility and universality results for wait-free synchronization. </title> <booktitle> In Seventh ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1988. </year>
Reference-contexts: If there exists a consensus protocol for an object X , then one can use X to construct a wait-free implementation of any concurrent data object whose operations are total <ref> [21] </ref>. If the shared object X is an array of registers providing read and write operations, then consensus is known to be impossible [2, 12, 15, 21, 27]. <p> If the shared object X is an array of registers providing read and write operations, then consensus is known to be impossible <ref> [2, 12, 15, 21, 27] </ref>. If X is an array of registers providing test-and-set or fetch-and-add operations, then consensus is possible between two processes, but not among three [21, 27]. Nevertheless, in both cases, consensus among an arbitrary number of processes can still be achieved probabilistically. <p> If X is an array of registers providing test-and-set or fetch-and-add operations, then consensus is possible between two processes, but not among three <ref> [21, 27] </ref>. Nevertheless, in both cases, consensus among an arbitrary number of processes can still be achieved probabilistically. This paper presents two new randomized consensus protocols, one in which processes communicate by reading and writing shared registers, and one in which they communicate by applying fetch-and-add operations. <p> Fetch-and-add solves consensus deterministically for two processes, but not for three or more <ref> [21] </ref>. Figure 4 shows a weak shared coin implementation using fetch-and-add operations. <p> It is known, however, that atomic read/write registers have few, if any, interesting applications in this area <ref> [21] </ref>. <p> The results in this paper suggest an alternative position. If one can achieve consensus, one can transform a sequential implementation of any object whose operations are total (i.e., defined in every state) to a wait-free linearizable implementation <ref> [21] </ref>, where each operation requires at most n rounds of consensus. In the same way, the randomized consensus protocol presented here can be used to transform any sequential object implementation into a randomized wait-free implementation, where each operation has expected running time polynomial in the number of processes.
Reference: [22] <author> M.P. Herlihy and J.M. Wing. </author> <title> Axioms for concurrent objects. </title> <booktitle> In 14th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 13-26, </pages> <month> January </month> <year> 1987. </year> <month> 24 </month>
Reference-contexts: An invocation with no matching response is pending, and complete (H ) is the maximal subsequence of H consisting only of invocations and matching responses. If H is a history, an operation of H is a pair 2 To remain consistent with the terminology of <ref> [22] </ref>, we use "event" where Lynch and Tuttle [29] use "operation" and "history" where they use "schedule." 5 consisting of an invocation and the next matching response. <p> Operations unrelated by H are said to be concurrent. If H is sequential, H is a total order. A protocol fP 1 ; : : : ; P n ; R 1 ; : : : ; R m g is linearizable <ref> [22] </ref> if, for each history H , there exists a sequential protocol history S such that: * For all P i ; H jP i = SjP i . <p> A protocol is linearizable if all its histories are lin-earizable. Henceforth, we restrict our attention to linearizable registers, which are usually called atomic registers [26] in the literature. (A more general definition of linearizability, including comparisons with related correctness criteria, appears elsewhere <ref> [22] </ref>.) 3.3 Randomization The random non-determinism involved in the choice between coin- flip (P; 0) and coin- flip (P; 1) has a different nature from the "ordinary" non-determinism in the protocol.
Reference: [23] <author> J.G. Kemeny, J.L. Snell, and A.W. Kapp. </author> <title> Denumerable Markov Chains. </title> <address> D. </address> <publisher> Van Nostrand, </publisher> <year> 1966. </year>
Reference-contexts: We can think of ~ A;s as a measurable function from the sequence space on the set f0,1g to the sequence space ffi of protocol executions <ref> [23] </ref>. We can thus use ~ A;s to define a probability measure on ffi by transforming the probability measure on as follows: P A;s (X) = P (fCj~ A;s (C) 2 Xg) (where the probability on the left is defined only when X ffi is measurable ffi).
Reference: [24] <author> C.P. Kruskal, L. Rudolph, and M. Snir. </author> <title> Efficient synchronization on multiprocessors with shared memory. </title> <booktitle> In Fifth ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1986. </year>
Reference-contexts: Lemma 21 implies that each increment or decrement requires O (n 2 ) primitive reads, resulting in an expected O (n 4 ) primitive reads. 7 Consensus Using Fetch-And-Add The fetch-and-add operation <ref> [24] </ref> atomically adds a quantity to a register and returns the register's old value. Fetch-and-add solves consensus deterministically for two processes, but not for three or more [21]. Figure 4 shows a weak shared coin implementation using fetch-and-add operations.
Reference: [25] <author> L. Lamport. </author> <title> Concurrent reading and writing. </title> <journal> Communications of the ACM, </journal> 20(11) 806-811, November 1977. 
Reference-contexts: It is a standard result of random walk theory [19] that the expected running time of such a walk is (K + 1) 2 n 2 , i.e. O (n 2 ). 6 The Counter Abstraction The counter implementation is a straightforward adaptation of an algorithm proposed by Lamport <ref> [25] </ref> for read/write registers. The counter is represented by an n-element array of registers, one for each process. Each register has two fields: a count field incremented whenever that process alters the register's value, and a val field representing that process's contribution to the current counter value. <p> The likelihood the adversary can force an outcome of heads in the initial round is thus (K + 1)=2K, which approaches 1=2 as K increases. 21 9 Discussion Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [5, 9, 25, 26, 30, 31, 32, 34] </ref>.
Reference: [26] <author> L. Lamport. </author> <title> On interprocess communication, parts i and ii. </title> <journal> Distributed Computing, </journal> <volume> 1 </volume> <pages> 77-101, </pages> <year> 1986. </year>
Reference-contexts: In other words, the history "appears" sequential to each individual process, and this apparent sequential interleaving respects the real-time precedence ordering of operations. A protocol is linearizable if all its histories are lin-earizable. Henceforth, we restrict our attention to linearizable registers, which are usually called atomic registers <ref> [26] </ref> in the literature. (A more general definition of linearizability, including comparisons with related correctness criteria, appears elsewhere [22].) 3.3 Randomization The random non-determinism involved in the choice between coin- flip (P; 0) and coin- flip (P; 1) has a different nature from the "ordinary" non-determinism in the protocol. <p> The likelihood the adversary can force an outcome of heads in the initial round is thus (K + 1)=2K, which approaches 1=2 as K increases. 21 9 Discussion Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [5, 9, 25, 26, 30, 31, 32, 34] </ref>.
Reference: [27] <author> M.C. Loui and H.H. Abu-Amara. </author> <title> Memory Requirements for Agreement Among Unreliable Asynchronous Processes, </title> <booktitle> volume 4, </booktitle> <pages> pages 163-183. </pages> <publisher> JAI Press, </publisher> <year> 1987. </year>
Reference-contexts: If the shared object X is an array of registers providing read and write operations, then consensus is known to be impossible <ref> [2, 12, 15, 21, 27] </ref>. If X is an array of registers providing test-and-set or fetch-and-add operations, then consensus is possible between two processes, but not among three [21, 27]. Nevertheless, in both cases, consensus among an arbitrary number of processes can still be achieved probabilistically. <p> If X is an array of registers providing test-and-set or fetch-and-add operations, then consensus is possible between two processes, but not among three <ref> [21, 27] </ref>. Nevertheless, in both cases, consensus among an arbitrary number of processes can still be achieved probabilistically. This paper presents two new randomized consensus protocols, one in which processes communicate by reading and writing shared registers, and one in which they communicate by applying fetch-and-add operations. <p> Ben-Or [3] proposes a randomized consensus protocol with exponential expected running time that tolerates up to n=5 failures, where n is the number of processes. A consensus protocol due to Bracha and Toueg [7] relies on probabilistic properties of the message-passing system. Loui and Abu-Amara <ref> [27] </ref> give several consensus protocols and impossibility results for processes that communicate through shared registers with various read-modify-write ("test-and-set") operations.
Reference: [28] <author> N.A. Lynch and M. Merritt. </author> <title> Introduction to the theory of nested transactions. </title> <type> Technical Report MIT/LCS/TR-387, </type> <institution> M.I.T. Laboratory for Computer Science, </institution> <month> April </month> <year> 1986. </year>
Reference-contexts: Chor and Coan [10] give a randomized byzan-tine agreement protocol that does not assume private communication, but restricts when the adversary may exploit knowledge of the processes' states. 3 Model 3.1 I/O Automata Formally, we model processes and registers as I/O automata <ref> [28, 29] </ref>.
Reference: [29] <author> N.A. Lynch and M.R. Tuttle. </author> <title> Hierarchical correctness proofs for distributed algorithms. </title> <type> Technical Report MIT/LCS/TR-387, </type> <institution> M.I.T. Laboratory for Computer Science, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: Chor and Coan [10] give a randomized byzan-tine agreement protocol that does not assume private communication, but restricts when the adversary may exploit knowledge of the processes' states. 3 Model 3.1 I/O Automata Formally, we model processes and registers as I/O automata <ref> [28, 29] </ref>. <p> If H is a history, an operation of H is a pair 2 To remain consistent with the terminology of [22], we use "event" where Lynch and Tuttle <ref> [29] </ref> use "operation" and "history" where they use "schedule." 5 consisting of an invocation and the next matching response.
Reference: [30] <author> R. Newman-Wolfe. </author> <title> A protocol for wait-free, atomic, multi-reader shared variables. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 232-249, </pages> <year> 1987. </year>
Reference-contexts: The likelihood the adversary can force an outcome of heads in the initial round is thus (K + 1)=2K, which approaches 1=2 as K increases. 21 9 Discussion Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [5, 9, 25, 26, 30, 31, 32, 34] </ref>.
Reference: [31] <author> G.L. Peterson. </author> <title> Concurrent reading while writing. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(1) </volume> <pages> 46-55, </pages> <month> January </month> <year> 1983. </year>
Reference-contexts: The likelihood the adversary can force an outcome of heads in the initial round is thus (K + 1)=2K, which approaches 1=2 as K increases. 21 9 Discussion Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [5, 9, 25, 26, 30, 31, 32, 34] </ref>.
Reference: [32] <author> G.L. Peterson and J.E. Burns. </author> <title> Concurrent reading while writing ii: the multi-writer case. </title> <type> Technical Report GIT-ICS-86/26, </type> <institution> Georgia Institute of Technology, </institution> <month> December </month> <year> 1986. </year>
Reference-contexts: The likelihood the adversary can force an outcome of heads in the initial round is thus (K + 1)=2K, which approaches 1=2 as K increases. 21 9 Discussion Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [5, 9, 25, 26, 30, 31, 32, 34] </ref>.
Reference: [33] <author> M. Rabin. </author> <title> Randomized byzantine generals. </title> <booktitle> In Twenty-fourth Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 403-409, </pages> <month> Oc-tober </month> <year> 1983. </year>
Reference-contexts: A number of protocols have been proposed for implementing shared coins in message-passing systems subject to byzantine or halting failures. (An excellent survey appears in [11].) Some constructions are direct [4, 8, 17], and others arise as parts of protocols for consensus [13], transaction commitment [14], or byzantine agreement <ref> [6, 13, 18, 33] </ref>. The models underlying these protocols differ from ours by assuming that private channels or encryption can be used to prevent the adversary from observing certain messages and processes' internal states.
Reference: [34] <author> A.K. Singh, J.H. Anderson, and M.G. Gouda. </author> <title> The elusive atomic register revisited. </title> <booktitle> In Proceedings of the Sixth ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 206-221, </pages> <month> August </month> <year> 1987. </year> <month> 25 </month>
Reference-contexts: The likelihood the adversary can force an outcome of heads in the initial round is thus (K + 1)=2K, which approaches 1=2 as K increases. 21 9 Discussion Most recent work on wait-free synchronization has focused on the construction of atomic read/write registers <ref> [5, 9, 25, 26, 30, 31, 32, 34] </ref>.
References-found: 34

