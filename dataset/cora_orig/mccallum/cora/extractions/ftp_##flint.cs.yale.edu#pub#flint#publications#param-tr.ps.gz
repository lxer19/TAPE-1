URL: ftp://flint.cs.yale.edu/pub/flint/publications/param-tr.ps.gz
Refering-URL: http://daffy.cs.yale.edu/users/shao-zhong/papers.html
Root-URL: http://www.cs.yale.edu
Email: shao-zhong@cs.yale.edu  
Title: Parameterized Signatures and Higher-Order Modules  
Author: Zhong Shao 
Date: Revised August 1998  
Address: P.O.Box 208285 New Haven, CT 06520-8285  
Affiliation: Dept. of Computer Science Yale University  
Pubnum: Technical Report YALEU/DCS/TR-1161,  
Abstract: ML-style modules are valuable in the development and maintenance of large software systems, unfortunately, none of the existing languages support them in a fully satisfactory manner. The official SML'97 language does not allow higher-order functors, so there is no way to accurately specify the import signature of a module that refers to externally defined functors. This lack of fully syntactic signatures makes it impossible to support Modula-2 style true separate compilation. Recently, MacQueen and Tofte proposed an extension to support fully transparent higher-order modules, but their scheme still does not provide fully syntactic signatures, partly because they use a rather operational stamp-based semantics to model abstract types. In this paper, we present a module calculus that supports both fully transparent higher-order modules and fully syntactic signatures (and thus true separate compilation). We give a simple type-theoretic semantics to our calculus, and show how it can be compiled into an F ! -like -calculus extended with existential types. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Biagioni, R. Harper, P. Lee, and B. Milnes. </author> <title> Signatures for a network protocol stack: A systems application of Standard ML. </title> <booktitle> In 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 55-64, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Functors have proven to be extremely valuable in the modeling and organization of extensible systems <ref> [1, 8, 5, 29] </ref>. For example, the Fox project at CMU [1] uses ML func-tors to represent the TCP/IP protocol layers; through functor applications, different protocol layers can be mixed and matched to generate new protocol stacks with application-specific requirements. <p> Functors have proven to be extremely valuable in the modeling and organization of extensible systems [1, 8, 5, 29]. For example, the Fox project at CMU <ref> [1] </ref> uses ML func-tors to represent the TCP/IP protocol layers; through functor applications, different protocol layers can be mixed and matched to generate new protocol stacks with application-specific requirements.
Reference: [2] <author> M. Blume. </author> <title> A compilation manager for SML/NJ. as part of SML/NJ User's Guide, </title> <year> 1995. </year>
Reference-contexts: In the future, we plan to use the module calculus presented in this paper to formalize the configuration language (e.g., sources.cm file) used in Blume's Compilation Manager (CM) <ref> [2] </ref>. We also plan to extend our module calculus to support dynamic linking and mutually recursive compilation units [7]. Acknowledgement I would like to thank David MacQueen and Valery Trifonov for discussions and comments on an early version of this paper.
Reference: [3] <author> L. Cardelli and X. Leroy. </author> <title> Abstract types and the dot notation. </title> <booktitle> In Proc. Programming Concepts and Methods, </booktitle> <pages> pages 479-504. </pages> <publisher> North Holland, </publisher> <year> 1990. </year>
Reference-contexts: We show how KMC and EMC can be compiled into an F ! -like Target Calculus (FTC) [9, 30] extended with existential types and dot notations <ref> [27, 4, 3] </ref>, so our module languages are still compatible with all the standard type-based compilation techniques [15, 13, 31, 33]. <p> These simplifications does not affect our main results because all the formalism in this paper can be easily extended to handle more expressive core languages [18]. Opaque modules in KMC are modeled using existential types [27] and dot notations <ref> [4, 3] </ref>. Given a module path p of type 9s : K:M , we use c (p) to denote p's constructor compo nent (which should have kind K), and m (p) to denote the module component (which should have type [ c (p)=s]M ). <p> A module function x : M:m has the dependent product type x : M:M 0 . Dependent product is necessary because we use dot notations to access opaque modules so the return type of a function might refer to the actual argument. Dot notations <ref> [3] </ref> also require that functions in KMC be applied to module access paths only, as in m (p). This restriction is not a problem because we can always use the let expression to introduce local declarations. Polymorphic modules in KMC are parameterized over module constructors.
Reference: [4] <author> L. Cardelli and D. MacQueen. </author> <title> Persistence and type abstraction. </title> <editor> In M. P. Atkinson, P. Buneman, and R. Morrison, editors, </editor> <booktitle> Data Types and Persistence, </booktitle> <pages> pages 31-41. </pages> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference-contexts: We show how KMC and EMC can be compiled into an F ! -like Target Calculus (FTC) [9, 30] extended with existential types and dot notations <ref> [27, 4, 3] </ref>, so our module languages are still compatible with all the standard type-based compilation techniques [15, 13, 31, 33]. <p> These simplifications does not affect our main results because all the formalism in this paper can be easily extended to handle more expressive core languages [18]. Opaque modules in KMC are modeled using existential types [27] and dot notations <ref> [4, 3] </ref>. Given a module path p of type 9s : K:M , we use c (p) to denote p's constructor compo nent (which should have kind K), and m (p) to denote the module component (which should have type [ c (p)=s]M ).
Reference: [5] <author> S. Corrico, B. Ewbank, T. Griffin, J. Meale, and H. Trickey. </author> <title> A tool for developing safe and efficient database transactions. </title> <booktitle> In 15th International Switching Symposium of the World Telecommunications Congress, </booktitle> <pages> pages 173-177, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Functors have proven to be extremely valuable in the modeling and organization of extensible systems <ref> [1, 8, 5, 29] </ref>. For example, the Fox project at CMU [1] uses ML func-tors to represent the TCP/IP protocol layers; through functor applications, different protocol layers can be mixed and matched to generate new protocol stacks with application-specific requirements.
Reference: [6] <author> J. Courant. </author> <title> An applicative module calculus. </title> <editor> In M. Bidoit and M. Dauchet, editors, TAPSOFT'97: </editor> <booktitle> Theory and Practice of Software Development: </booktitle> <volume> LNCS Vol 1214, </volume> <pages> pages 622-636, </pages> <address> New York, 1997. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: Leroy [17] proposed to use applicative semantics to model full transparency, but his signature calculus only handles limited forms of functor arguments; this limitation was lifted in Courant's recent proposal <ref> [6] </ref>, but only at the expense of putting arbitrary module implementation code into the interfaces, which in turn compromises the very benefits of modularization and makes interface checking much harder. <p> Leroy [17] also proposed to use applicative semantics to model full transparency, but his signature calculus only handles limited forms of functor arguments; this limitation was lifted in Courant's recent proposal <ref> [6] </ref>, but only at the expense of putting arbitrary module implementation code into the interfaces (which in turn compromises the very benefits of modularization and makes interface checking much harder). Parameterized signatures was first proposed by Jones [14] to capture the essence of various different modular structures.
Reference: [7] <author> M. Flatt and M. Felleisen. </author> <title> Units: Cool modules for HOT languages. </title> <booktitle> In Proc. ACM SIGPLAN '98 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 236-248. </pages> <publisher> ACM Press, </publisher> <year> 1998. </year>
Reference-contexts: In the future, we plan to use the module calculus presented in this paper to formalize the configuration language (e.g., sources.cm file) used in Blume's Compilation Manager (CM) [2]. We also plan to extend our module calculus to support dynamic linking and mutually recursive compilation units <ref> [7] </ref>. Acknowledgement I would like to thank David MacQueen and Valery Trifonov for discussions and comments on an early version of this paper.
Reference: [8] <author> L. George. MLRISC: </author> <title> Customizable and reusable code generators. </title> <type> Technical memorandum, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, NJ, </address> <year> 1997. </year>
Reference-contexts: Functors have proven to be extremely valuable in the modeling and organization of extensible systems <ref> [1, 8, 5, 29] </ref>. For example, the Fox project at CMU [1] uses ML func-tors to represent the TCP/IP protocol layers; through functor applications, different protocol layers can be mixed and matched to generate new protocol stacks with application-specific requirements.
Reference: [9] <author> J. Y. Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieur. </title> <type> PhD thesis, </type> <institution> University of Paris VII, </institution> <year> 1972. </year>
Reference-contexts: Finally, we demonstrate the expressiveness of KMC and EMC by translating a version of the Abstract Module Calculus (AMC) and a version of the Transparent Module Calculus (TMC) into the EMC calculus. We show how KMC and EMC can be compiled into an F ! -like Target Calculus (FTC) <ref> [9, 30] </ref> extended with existential types and dot notations [27, 4, 3], so our module languages are still compatible with all the standard type-based compilation techniques [15, 13, 31, 33].
Reference: [10] <author> R. Harper and M. Lillibridge. </author> <title> A type-theoretic approach to higher-order modules with sharing. </title> <booktitle> In Twenty-first Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 123-137, </pages> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Standard ML [25] only supports first-order functors. MacQueen and Tofte [23, 35] recently proposed to add fully transparent higher-order modules to ML but their scheme does not provide fully syntactic signatures. Independently, Harper and Lillibridge <ref> [10] </ref> and Leroy [16] proposed to use translucent signatures to model abstract types and type sharing; their scheme supports fully syntactic signatures, but fails to propagate as much sharing as in the MacQueen-Tofte system. <p> Compilation of module programs should also be compatible with the standard type-based compila tion techniques [15, 13, 31, 33]. 1.3 Our contributions This paper presents a higher-order module calculus that satisfies all of the above properties. Previous approaches have used either strong sums [22, 11, 23] or translucent sums <ref> [10, 16, 17] </ref> to express module types. We argue that the essence of higher-order modules would be better captured by using a combination of universal and existential quantifiers (i.e., 8 and 9). <p> All strong-sum-based approaches [22, 11, 23] view SIG as a strong sum type t:t ; this does not capture abstract types in B well, so strong-sum-based approaches must use global type stamps to account for abstract types. Translucent-sum-based approaches <ref> [10, 16, 17] </ref>, on the other hand, always view SIG as a weak sum type 9t:t , this captures opaque module B well, but functor argument A is now limited to have type 9t:t. <p> EMC can also be viewed as an extension of Leroy's abstract module calculus [16, 19] but with support to fully transparent higher-order modules. The signature calculus of EMC has a nice pay-as-you-go complexity property since simple modules in EMC will still get same signatures as in Leroy's abstract calculus <ref> [16, 10] </ref> and only higher-order modules will use more complex type specifications. Finally, we demonstrate the expressiveness of KMC and EMC by translating a version of the Abstract Module Calculus (AMC) and a version of the Transparent Module Calculus (TMC) into the EMC calculus. <p> x=3.0 end structure R3 = FA (J) The actual implementation of the MacQueen-Tofte system [33] memoizes a skeleton of each functor body to support re-elaboration, but this is clearly too complex to export to the surface programmers. 2.2 Opaque signatures and abstract types The abstract approach by Harper and Lillibridge <ref> [10] </ref> and Leroy [10, 16] simply does not type-check the above equality test R1.x = R2.x. In fact, the abstract approach treats the signature S as an existential type S = 9t:t and the signature FS as a dependent product x : S:S. <p> R3 = FA (J) The actual implementation of the MacQueen-Tofte system [33] memoizes a skeleton of each functor body to support re-elaboration, but this is clearly too complex to export to the surface programmers. 2.2 Opaque signatures and abstract types The abstract approach by Harper and Lillibridge [10] and Leroy <ref> [10, 16] </ref> simply does not type-check the above equality test R1.x = R2.x. In fact, the abstract approach treats the signature S as an existential type S = 9t:t and the signature FS as a dependent product x : S:S. <p> As in any module calculus, KMC supports a form of simple modules that consist of an ordered list of type, module, and value declarations. Following Harper and Lillib-ridge <ref> [10] </ref>, we assume that each declaration in KMC simultaneously defines an internal name (e.g., x, t, v) and an external label (e.g., l x , l t , l v ). <p> Simple module is typed using the transparent record type, e.g., M = fD 1 ; :::; D n g. Transparent record (also named as transparent sum) is similar to translucent sum <ref> [10] </ref> except that all type components in a transparent record are fully defined. The type structure of KMC resembles a typical predica-tive F ! -like calculus [32]. Module kind (mknd) K characterizes module constructor (mcon) C; module type (mtyp) M models module expressions (mexp) m. <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [10, 16, 17, 20, 35, 23, 14] </ref> and mostly resolved in SML'97 [25]. The main remaining issue is on how to design a higher-order module calculus that satisfies all of the properties mentioned in our introduction. <p> The official definition of Standard ML [25] only supports first-order functors. MacQueen and Tofte [23, 35] recently proposed to add fully transparent higher-order modules to ML but their scheme does not provide fully syntactic signatures. Independently, Harper and Lillibridge <ref> [10] </ref> and Leroy [16] proposed to use translucent signatures to model abstract types and type sharing; their scheme supports fully syntactic signatures, but fails to propagate as much sharing as in the MacQueen-Tofte system.
Reference: [11] <author> R. Harper and J. C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Trans. on Programming Languages and Systems, </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Compilation of module programs should also be compatible with the standard type-based compila tion techniques [15, 13, 31, 33]. 1.3 Our contributions This paper presents a higher-order module calculus that satisfies all of the above properties. Previous approaches have used either strong sums <ref> [22, 11, 23] </ref> or translucent sums [10, 16, 17] to express module types. We argue that the essence of higher-order modules would be better captured by using a combination of universal and existential quantifiers (i.e., 8 and 9). <p> All strong-sum-based approaches <ref> [22, 11, 23] </ref> view SIG as a strong sum type t:t ; this does not capture abstract types in B well, so strong-sum-based approaches must use global type stamps to account for abstract types. <p> The ML module system was first proposed by Mac-Queen [21] and later incorporated into Standard ML [24]. Harper and Mitchell <ref> [11] </ref> show that the SML'90 module language can be translated into a typed lambda calculus (XML) with dependent types. Together with Moggi, they later show that even in the presence of dependent types, type-checking of XML is still decidable [12], thanks to the phase-distinction property of ML-style modules.
Reference: [12] <author> R. Harper, J. C. Mitchell, and E. Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Seventeenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 341-344, </pages> <address> New York, Jan 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: In other words, we think a functor is not merely a module-to-module function, but rather a module-level "polymorphic" function. This view is consistent with recent work on phase-distinction and typed cross-module compilation <ref> [12, 33] </ref>. In fact, both Harper et al [12] and Shao [33] have shown that using universal quantifications to model functors would propagate the same amount of type sharing as in the strong-sum-based approaches. <p> In other words, we think a functor is not merely a module-to-module function, but rather a module-level "polymorphic" function. This view is consistent with recent work on phase-distinction and typed cross-module compilation [12, 33]. In fact, both Harper et al <ref> [12] </ref> and Shao [33] have shown that using universal quantifications to model functors would propagate the same amount of type sharing as in the strong-sum-based approaches. <p> Notice here, inspired by recent work on phase splitting <ref> [12, 33] </ref>, we consider each functor signature as being parameterized by a higher-order constructor f which captures the sharing information in the actual functor. <p> Harper and Mitchell [11] show that the SML'90 module language can be translated into a typed lambda calculus (XML) with dependent types. Together with Moggi, they later show that even in the presence of dependent types, type-checking of XML is still decidable <ref> [12] </ref>, thanks to the phase-distinction property of ML-style modules. The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only.
Reference: [13] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 130-141, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: A higher-order module system will not be practical if it cannot be type-checked and compiled efficiently. Compilation of module programs should also be compatible with the standard type-based compila tion techniques <ref> [15, 13, 31, 33] </ref>. 1.3 Our contributions This paper presents a higher-order module calculus that satisfies all of the above properties. Previous approaches have used either strong sums [22, 11, 23] or translucent sums [10, 16, 17] to express module types. <p> We show how KMC and EMC can be compiled into an F ! -like Target Calculus (FTC) [9, 30] extended with existential types and dot notations [27, 4, 3], so our module languages are still compatible with all the standard type-based compilation techniques <ref> [15, 13, 31, 33] </ref>. The relationship among these five calculus is depicted in Figure 1. 2 Informal Development 2.1 Fully-transparent higher-order modules We first use a series of examples to show how the MacQueen-Tofte system [23] supports fully transparent higher-order modules. <p> The translation from KMC to FTC is omitted since it is quite trivial. The fact that all the module languages discussed in this paper can be compiled into an F ! -based calculus is important because immediately all important type-based compilation techniques <ref> [15, 31, 13, 26, 36] </ref> become applicable to these module languages as well.
Reference: [14] <author> M. P. Jones. </author> <title> Using parameterized signatures to express modular structure. </title> <booktitle> In Twenty-third Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 68-78, </pages> <address> New York, Jan 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: To achieve this new interpretation, we view each signature declaration as defining a parameterized type template of form s : K:M where s is a higher-order constructor variable, K is a kind, and M is a module type; we borrow from Mark Jones <ref> [14] </ref> and name such templates as parameterized signatures. 1 When we use the signature to type an opaque module, we assign the module with type 9s : K:M . <p> From the typing rules for KMC, we show that all KMC module expressions have unique type signatures. The KMC calculus can also be easily integrated with languages other than ML where module expressions do not follow the ML-like signature syntax <ref> [14] </ref>. Based on the semantics of KMC, we then present an External Module Calculus (EMC) designed for the ML-like 1 Although our notion of parameterized signatures is not precisely same as the one used by Jones [14], we do share the same philosophy of using parameterized type constructors to model inter-module <p> languages other than ML where module expressions do not follow the ML-like signature syntax <ref> [14] </ref>. Based on the semantics of KMC, we then present an External Module Calculus (EMC) designed for the ML-like 1 Although our notion of parameterized signatures is not precisely same as the one used by Jones [14], we do share the same philosophy of using parameterized type constructors to model inter-module type dependencies. In fact, our work demonstrates that Jones's original proposal can indeed be extended to model the full-scale ML-like module constructs. 2 P P P Pq AMC FTCEMC KMC languages. <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [10, 16, 17, 20, 35, 23, 14] </ref> and mostly resolved in SML'97 [25]. The main remaining issue is on how to design a higher-order module calculus that satisfies all of the properties mentioned in our introduction. <p> Parameterized signatures was first proposed by Jones <ref> [14] </ref> to capture the essence of various different modular structures. Our notion of parameterized signatures differs from 12 his in that we allow type components inside the module record.
Reference: [15] <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 177-188, </pages> <address> New York, </address> <month> Jan </month> <year> 1992. </year> <note> ACM Press. Longer version available as INRIA Tech Report. 13 </note>
Reference-contexts: A higher-order module system will not be practical if it cannot be type-checked and compiled efficiently. Compilation of module programs should also be compatible with the standard type-based compila tion techniques <ref> [15, 13, 31, 33] </ref>. 1.3 Our contributions This paper presents a higher-order module calculus that satisfies all of the above properties. Previous approaches have used either strong sums [22, 11, 23] or translucent sums [10, 16, 17] to express module types. <p> We show how KMC and EMC can be compiled into an F ! -like Target Calculus (FTC) [9, 30] extended with existential types and dot notations [27, 4, 3], so our module languages are still compatible with all the standard type-based compilation techniques <ref> [15, 13, 31, 33] </ref>. The relationship among these five calculus is depicted in Figure 1. 2 Informal Development 2.1 Fully-transparent higher-order modules We first use a series of examples to show how the MacQueen-Tofte system [23] supports fully transparent higher-order modules. <p> The translation from KMC to FTC is omitted since it is quite trivial. The fact that all the module languages discussed in this paper can be compiled into an F ! -based calculus is important because immediately all important type-based compilation techniques <ref> [15, 31, 13, 26, 36] </ref> become applicable to these module languages as well.
Reference: [16] <author> X. Leroy. </author> <title> Manifest types, modules, and separate compila-tion. </title> <booktitle> In Twenty-first Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 109-122, </pages> <address> New York, Jan 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Without higher-order functors, we have no hope of fully specifying the interfaces of arbitrary ML programs. The lack of fully syntactic (i.e., explicit) signatures also violates the fundamental principles of modularization and makes it impossible to support Modula-2 style true separate compilation <ref> [16] </ref>. 1.2 Main challenges Supporting higher-order functors with fully syntactic signatures turns out to be a very hard problem. Standard ML [25] only supports first-order functors. MacQueen and Tofte [23, 35] recently proposed to add fully transparent higher-order modules to ML but their scheme does not provide fully syntactic signatures. <p> Standard ML [25] only supports first-order functors. MacQueen and Tofte [23, 35] recently proposed to add fully transparent higher-order modules to ML but their scheme does not provide fully syntactic signatures. Independently, Harper and Lillibridge [10] and Leroy <ref> [16] </ref> proposed to use translucent signatures to model abstract types and type sharing; their scheme supports fully syntactic signatures, but fails to propagate as much sharing as in the MacQueen-Tofte system. <p> Compilation of module programs should also be compatible with the standard type-based compila tion techniques [15, 13, 31, 33]. 1.3 Our contributions This paper presents a higher-order module calculus that satisfies all of the above properties. Previous approaches have used either strong sums [22, 11, 23] or translucent sums <ref> [10, 16, 17] </ref> to express module types. We argue that the essence of higher-order modules would be better captured by using a combination of universal and existential quantifiers (i.e., 8 and 9). <p> All strong-sum-based approaches [22, 11, 23] view SIG as a strong sum type t:t ; this does not capture abstract types in B well, so strong-sum-based approaches must use global type stamps to account for abstract types. Translucent-sum-based approaches <ref> [10, 16, 17] </ref>, on the other hand, always view SIG as a weak sum type 9t:t , this captures opaque module B well, but functor argument A is now limited to have type 9t:t. <p> EMC can be viewed as a special subset of KMC, but encoded using the ML-like syntax. EMC can also be viewed as an extension of Leroy's abstract module calculus <ref> [16, 19] </ref> but with support to fully transparent higher-order modules. The signature calculus of EMC has a nice pay-as-you-go complexity property since simple modules in EMC will still get same signatures as in Leroy's abstract calculus [16, 10] and only higher-order modules will use more complex type specifications. <p> EMC can also be viewed as an extension of Leroy's abstract module calculus [16, 19] but with support to fully transparent higher-order modules. The signature calculus of EMC has a nice pay-as-you-go complexity property since simple modules in EMC will still get same signatures as in Leroy's abstract calculus <ref> [16, 10] </ref> and only higher-order modules will use more complex type specifications. Finally, we demonstrate the expressiveness of KMC and EMC by translating a version of the Abstract Module Calculus (AMC) and a version of the Transparent Module Calculus (TMC) into the EMC calculus. <p> R3 = FA (J) The actual implementation of the MacQueen-Tofte system [33] memoizes a skeleton of each functor body to support re-elaboration, but this is clearly too complex to export to the surface programmers. 2.2 Opaque signatures and abstract types The abstract approach by Harper and Lillibridge [10] and Leroy <ref> [10, 16] </ref> simply does not type-check the above equality test R1.x = R2.x. In fact, the abstract approach treats the signature S as an existential type S = 9t:t and the signature FS as a dependent product x : S:S. <p> This section presents an higher-order External Module Calculus (EMC) that follows the ML-style module syntax. EMC can be viewed as a special subset of KMC but encoded using ML-like signatures, structures, and functors. In the meantime, EMC is also an extension of Leroy's abstract module calculus <ref> [16, 19] </ref> but with support to fully transparent higher-order modules. The syntax of EMC is given in adaption from that of KMC. It is summarized in Figure 6; The complete typing rules and utility functions are given in Figures 7 to 9 and in Appendix B. <p> We also compare EMC with the stamp-base semantics of the MacQueen-Tofte system [23, 33]. 5.1 The abstract module calculus AMC We use the Abstract Module Calculus (AMC) <ref> [16] </ref> as a representative of the translucent-sum-based approach. The syntax of AMC is given in Figure 10. AMC is just a subset of EMC where we restrict the return signature (rsig) to S and remove the form of #l t (C) from the core type calculus. <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [10, 16, 17, 20, 35, 23, 14] </ref> and mostly resolved in SML'97 [25]. The main remaining issue is on how to design a higher-order module calculus that satisfies all of the properties mentioned in our introduction. <p> The official definition of Standard ML [25] only supports first-order functors. MacQueen and Tofte [23, 35] recently proposed to add fully transparent higher-order modules to ML but their scheme does not provide fully syntactic signatures. Independently, Harper and Lillibridge [10] and Leroy <ref> [16] </ref> proposed to use translucent signatures to model abstract types and type sharing; their scheme supports fully syntactic signatures, but fails to propagate as much sharing as in the MacQueen-Tofte system.
Reference: [17] <author> X. Leroy. </author> <title> Applicative functors and fully transparent higher-order modules. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 142-153, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Independently, Harper and Lillibridge [10] and Leroy [16] proposed to use translucent signatures to model abstract types and type sharing; their scheme supports fully syntactic signatures, but fails to propagate as much sharing as in the MacQueen-Tofte system. Leroy <ref> [17] </ref> proposed to use applicative semantics to model full transparency, but his signature calculus only handles limited forms of functor arguments; this limitation was lifted in Courant's recent proposal [6], but only at the expense of putting arbitrary module implementation code into the interfaces, which in turn compromises the very benefits <p> Compilation of module programs should also be compatible with the standard type-based compila tion techniques [15, 13, 31, 33]. 1.3 Our contributions This paper presents a higher-order module calculus that satisfies all of the above properties. Previous approaches have used either strong sums [22, 11, 23] or translucent sums <ref> [10, 16, 17] </ref> to express module types. We argue that the essence of higher-order modules would be better captured by using a combination of universal and existential quantifiers (i.e., 8 and 9). <p> All strong-sum-based approaches [22, 11, 23] view SIG as a strong sum type t:t ; this does not capture abstract types in B well, so strong-sum-based approaches must use global type stamps to account for abstract types. Translucent-sum-based approaches <ref> [10, 16, 17] </ref>, on the other hand, always view SIG as a weak sum type 9t:t , this captures opaque module B well, but functor argument A is now limited to have type 9t:t. <p> p:l v j : : : Elaboration context: ctxt ::= " j ; t = t j ; v : t j ; x : M j ; s : K 2.4 Relationship with applicative functors Some may wonder that our syntactic signature looks particularly similar to Leroy's applicative-functor approach <ref> [17] </ref> where he can also assign functor FA with a syntactic signature: funsig Z4 = fsig (F: FS): sig type t=F (Y).t val x: t end This similarity, however, stays only at the surface; the underlying interpretations of the two are completely different. <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [10, 16, 17, 20, 35, 23, 14] </ref> and mostly resolved in SML'97 [25]. The main remaining issue is on how to design a higher-order module calculus that satisfies all of the properties mentioned in our introduction. <p> Independently, Harper and Lillibridge [10] and Leroy [16] proposed to use translucent signatures to model abstract types and type sharing; their scheme supports fully syntactic signatures, but fails to propagate as much sharing as in the MacQueen-Tofte system. Leroy <ref> [17] </ref> also proposed to use applicative semantics to model full transparency, but his signature calculus only handles limited forms of functor arguments; this limitation was lifted in Courant's recent proposal [6], but only at the expense of putting arbitrary module implementation code into the interfaces (which in turn compromises the very
Reference: [18] <author> X. Leroy. </author> <title> A modular module system. </title> <type> Technical report 2866, </type> <institution> INRIA, </institution> <month> April </month> <year> 1996. </year>
Reference-contexts: These simplifications does not affect our main results because all the formalism in this paper can be easily extended to handle more expressive core languages <ref> [18] </ref>. Opaque modules in KMC are modeled using existential types [27] and dot notations [4, 3].
Reference: [19] <author> X. Leroy. </author> <title> A syntactic theory of type generativity and sharing. </title> <journal> Journal of Functional Programming, </journal> <volume> 6(5) </volume> <pages> 1-32, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: EMC can be viewed as a special subset of KMC, but encoded using the ML-like syntax. EMC can also be viewed as an extension of Leroy's abstract module calculus <ref> [16, 19] </ref> but with support to fully transparent higher-order modules. The signature calculus of EMC has a nice pay-as-you-go complexity property since simple modules in EMC will still get same signatures as in Leroy's abstract calculus [16, 10] and only higher-order modules will use more complex type specifications. <p> This section presents an higher-order External Module Calculus (EMC) that follows the ML-style module syntax. EMC can be viewed as a special subset of KMC but encoded using ML-like signatures, structures, and functors. In the meantime, EMC is also an extension of Leroy's abstract module calculus <ref> [16, 19] </ref> but with support to fully transparent higher-order modules. The syntax of EMC is given in adaption from that of KMC. It is summarized in Figure 6; The complete typing rules and utility functions are given in Figures 7 to 9 and in Appendix B.
Reference: [20] <author> M. Lillibridge. </author> <title> Translucent Sums: A Foundation for Higher-Order Module Systems. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1997. </year> <note> Tech Report CMU-CS-97-122. </note>
Reference-contexts: The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [10, 16, 17, 20, 35, 23, 14] </ref> and mostly resolved in SML'97 [25]. The main remaining issue is on how to design a higher-order module calculus that satisfies all of the properties mentioned in our introduction. <p> Mark Lillibridge made the following assessment on the difficulty of this problem in his Ph.D. thesis <ref> [20, page 310] </ref>: In principle it should be possible to build a system with a rich enough type system so that both separate compilation and fully transparency can be achieved at the same time.
Reference: [21] <author> D. MacQueen. </author> <title> Modules for Standard ML. </title> <booktitle> In 1984 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 198-207, </pages> <address> New York, </address> <month> August </month> <year> 1984. </year> <note> ACM Press. </note>
Reference-contexts: The ML module system was first proposed by Mac-Queen <ref> [21] </ref> and later incorporated into Standard ML [24]. Harper and Mitchell [11] show that the SML'90 module language can be translated into a typed lambda calculus (XML) with dependent types.
Reference: [22] <author> D. MacQueen. </author> <title> Using dependent types to express modular structure. </title> <booktitle> In Proc. 13th Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 277-286. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: Compilation of module programs should also be compatible with the standard type-based compila tion techniques [15, 13, 31, 33]. 1.3 Our contributions This paper presents a higher-order module calculus that satisfies all of the above properties. Previous approaches have used either strong sums <ref> [22, 11, 23] </ref> or translucent sums [10, 16, 17] to express module types. We argue that the essence of higher-order modules would be better captured by using a combination of universal and existential quantifiers (i.e., 8 and 9). <p> All strong-sum-based approaches <ref> [22, 11, 23] </ref> view SIG as a strong sum type t:t ; this does not capture abstract types in B well, so strong-sum-based approaches must use global type stamps to account for abstract types. <p> In a previous paper [33], we presented a type-preserving translation from the MacQueen-Tofte higher-order modules <ref> [22] </ref> into an F ! -based calculus, however, that algorithm turns all abstract types into concrete ones; this makes it hard to reason about type-directed operations on values with abstract types.
Reference: [23] <author> D. MacQueen and M. Tofte. </author> <title> A semantics for higher order functors. </title> <booktitle> In The 5th European Symposium on Programming, </booktitle> <pages> pages 409-423, </pages> <address> Berlin, </address> <month> April </month> <year> 1994. </year> <pages> Spinger-Verlag. </pages>
Reference-contexts: Standard ML [25] only supports first-order functors. MacQueen and Tofte <ref> [23, 35] </ref> recently proposed to add fully transparent higher-order modules to ML but their scheme does not provide fully syntactic signatures. <p> A clean semantics makes it easier to carry out formal reasonings; it is also a prerequisite for a simple signature calculus. * It should provide supports to fully transparent higher-order modules <ref> [23] </ref>. Higher-order functors should be a natural extension of first-order ones. Simple ML func-tors can propagate type sharing from the argument to the result; higher-order functors should propagate sharing in the same way. * It should support opaque types and signatures. <p> Compilation of module programs should also be compatible with the standard type-based compila tion techniques [15, 13, 31, 33]. 1.3 Our contributions This paper presents a higher-order module calculus that satisfies all of the above properties. Previous approaches have used either strong sums <ref> [22, 11, 23] </ref> or translucent sums [10, 16, 17] to express module types. We argue that the essence of higher-order modules would be better captured by using a combination of universal and existential quantifiers (i.e., 8 and 9). <p> All strong-sum-based approaches <ref> [22, 11, 23] </ref> view SIG as a strong sum type t:t ; this does not capture abstract types in B well, so strong-sum-based approaches must use global type stamps to account for abstract types. <p> The relationship among these five calculus is depicted in Figure 1. 2 Informal Development 2.1 Fully-transparent higher-order modules We first use a series of examples to show how the MacQueen-Tofte system <ref> [23] </ref> supports fully transparent higher-order modules. We start with the definitions of a signature S and a functor signature FS: signature S = sig type t val x : t end funsig FS = fsig (X: S): S The MacQueen-Tofte system uses strong sum () to express the module type. <p> MacQueen and Tofte <ref> [23] </ref> call functors such as FA as fully transparent modules since they propagate the type sharing in the actual argument (e.g., G and H) into the result (e.g., R1 and R2). Unfortunately, their scheme does not support fully syntactic signatures. <p> We also compare EMC with the stamp-base semantics of the MacQueen-Tofte system <ref> [23, 33] </ref>. 5.1 The abstract module calculus AMC We use the Abstract Module Calculus (AMC) [16] as a representative of the translucent-sum-based approach. The syntax of AMC is given in Figure 10. <p> Following the usual strong-sum-based module systems <ref> [23, 25, 33] </ref>, we distinguish module signatures (S) from module types (M and L): module signatures are used in the source programs for specifications while module types are used in the static semantics for type checking. <p> :: K type formation ` M exp formation ` m : M constructor equivalence ` C C 0 :: K type equivalence ` M M 0 kind subsumption ` K K 0 type subsumption ` M M 0 5.3 Comparison with the stamp-based semantics Most compilers for the strong-sum-based calculus <ref> [23, 25, 33] </ref> use stamps to support type generativity and abstract types. <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [10, 16, 17, 20, 35, 23, 14] </ref> and mostly resolved in SML'97 [25]. The main remaining issue is on how to design a higher-order module calculus that satisfies all of the properties mentioned in our introduction. <p> Supporting higher-order functors with fully syntactic signatures turns out to be a very hard problem. The official definition of Standard ML [25] only supports first-order functors. MacQueen and Tofte <ref> [23, 35] </ref> recently proposed to add fully transparent higher-order modules to ML but their scheme does not provide fully syntactic signatures.
Reference: [24] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1990. </year>
Reference-contexts: The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Defense Advanced Research Projects Agency or the U.S. Government. 1.1 Why higher-order modules? Standard ML <ref> [24, 25] </ref> provides a powerful module system. The main innovation of the ML module language is its support of parameterized modules (also known as functors). <p> Th translation from TMC to EMC is summarized in signatures), signatures, core expressions, access paths, and module expressions into their EMC counterparts; bc c maps 4 The Standard ML signature calculus <ref> [25, 24] </ref> enforces a similar restriction. ctxt-to-ctxt translation bc n 7! ctsp-to-ctyp translation bc n 7! t sig-to-sig translation bSc n 7! S cexp-to-cexp translation bec n 7! e path-to-path translation bpc n 7! p mexp-to-mexp translation bmc n 7! m ctyp-to-ctyp translation ` t ; t 0 mtyp-to-sig translation ` <p> The ML module system was first proposed by Mac-Queen [21] and later incorporated into Standard ML <ref> [24] </ref>. Harper and Mitchell [11] show that the SML'90 module language can be translated into a typed lambda calculus (XML) with dependent types.
Reference: [25] <author> R. Milner, M. Tofte, R. Harper, and D. MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: The views and conclusions contained in this document are those of the authors and should not be interpreted as representing the official policies, either expressed or implied, of the Defense Advanced Research Projects Agency or the U.S. Government. 1.1 Why higher-order modules? Standard ML <ref> [24, 25] </ref> provides a powerful module system. The main innovation of the ML module language is its support of parameterized modules (also known as functors). <p> The lack of fully syntactic (i.e., explicit) signatures also violates the fundamental principles of modularization and makes it impossible to support Modula-2 style true separate compilation [16]. 1.2 Main challenges Supporting higher-order functors with fully syntactic signatures turns out to be a very hard problem. Standard ML <ref> [25] </ref> only supports first-order functors. MacQueen and Tofte [23, 35] recently proposed to add fully transparent higher-order modules to ML but their scheme does not provide fully syntactic signatures. <p> Following the usual strong-sum-based module systems <ref> [23, 25, 33] </ref>, we distinguish module signatures (S) from module types (M and L): module signatures are used in the source programs for specifications while module types are used in the static semantics for type checking. <p> Th translation from TMC to EMC is summarized in signatures), signatures, core expressions, access paths, and module expressions into their EMC counterparts; bc c maps 4 The Standard ML signature calculus <ref> [25, 24] </ref> enforces a similar restriction. ctxt-to-ctxt translation bc n 7! ctsp-to-ctyp translation bc n 7! t sig-to-sig translation bSc n 7! S cexp-to-cexp translation bec n 7! e path-to-path translation bpc n 7! p mexp-to-mexp translation bmc n 7! m ctyp-to-ctyp translation ` t ; t 0 mtyp-to-sig translation ` <p> :: K type formation ` M exp formation ` m : M constructor equivalence ` C C 0 :: K type equivalence ` M M 0 kind subsumption ` K K 0 type subsumption ` M M 0 5.3 Comparison with the stamp-based semantics Most compilers for the strong-sum-based calculus <ref> [23, 25, 33] </ref> use stamps to support type generativity and abstract types. <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched [10, 16, 17, 20, 35, 23, 14] and mostly resolved in SML'97 <ref> [25] </ref>. The main remaining issue is on how to design a higher-order module calculus that satisfies all of the properties mentioned in our introduction. Supporting higher-order functors with fully syntactic signatures turns out to be a very hard problem. The official definition of Standard ML [25] only supports first-order functors. <p> and mostly resolved in SML'97 <ref> [25] </ref>. The main remaining issue is on how to design a higher-order module calculus that satisfies all of the properties mentioned in our introduction. Supporting higher-order functors with fully syntactic signatures turns out to be a very hard problem. The official definition of Standard ML [25] only supports first-order functors. MacQueen and Tofte [23, 35] recently proposed to add fully transparent higher-order modules to ML but their scheme does not provide fully syntactic signatures. <p> Our work on the external module calculus EMC shows that we can add fully transparent higher-order modules to ML-like languages while still supporting Module-2 style true separate compilation. The signature calculus in EMC is a conservative and pay-as-you-go extension of the one in SML'97 <ref> [25] </ref>: a program module that does not use higher-order functors can still have the same signature as that under the SML'97 module language. The only complexity of EMC is that signatures used to specify functor parameters are interpreted differently from those used to specify opaque modules.
Reference: [26] <author> Y. Minamide, G. Morrisett, and R. Harper. </author> <title> Typed closure conversion. </title> <booktitle> In Proc. 23rd Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <pages> pages 271-283, </pages> <address> New York, 1996. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The translation from KMC to FTC is omitted since it is quite trivial. The fact that all the module languages discussed in this paper can be compiled into an F ! -based calculus is important because immediately all important type-based compilation techniques <ref> [15, 31, 13, 26, 36] </ref> become applicable to these module languages as well.
Reference: [27] <author> J. Mitchell and G. Plotkin. </author> <title> Abstract types have existential type. </title> <booktitle> In Proc. 11th Annual ACM SIGPLAN-SIGACT Symp. on Principles of Programming Languages, </booktitle> <address> New York, 1984. </address> <publisher> ACM Press. </publisher>
Reference-contexts: We show how KMC and EMC can be compiled into an F ! -like Target Calculus (FTC) [9, 30] extended with existential types and dot notations <ref> [27, 4, 3] </ref>, so our module languages are still compatible with all the standard type-based compilation techniques [15, 13, 31, 33]. <p> These simplifications does not affect our main results because all the formalism in this paper can be easily extended to handle more expressive core languages [18]. Opaque modules in KMC are modeled using existential types <ref> [27] </ref> and dot notations [4, 3]. Given a module path p of type 9s : K:M , we use c (p) to denote p's constructor compo nent (which should have kind K), and m (p) to denote the module component (which should have type [ c (p)=s]M ).
Reference: [28] <author> G. Nelson, </author> <title> editor. Systems programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: Government. 1.1 Why higher-order modules? Standard ML [24, 25] provides a powerful module system. The main innovation of the ML module language is its support of parameterized modules (also known as functors). Unlike Modula-3 generics <ref> [28] </ref> or C++ templates [34] which are more or less macros, ML functors can be type-checked and compiled independently at its definition site; furthermore, different applications of the same functor can share a single copy of the implementation (i.e., object code), even though each application can produce modules with completely different
Reference: [29] <author> J. H. Reppy and E. R. Gansner. </author> <title> The eXene library manual. </title> <institution> Cornell Univ. Dept. of Computer Science, </institution> <month> March </month> <year> 1991. </year>
Reference-contexts: Functors have proven to be extremely valuable in the modeling and organization of extensible systems <ref> [1, 8, 5, 29] </ref>. For example, the Fox project at CMU [1] uses ML func-tors to represent the TCP/IP protocol layers; through functor applications, different protocol layers can be mixed and matched to generate new protocol stacks with application-specific requirements.
Reference: [30] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings, Colloque sur la Programmation, Lecture Notes in Computer Science, </booktitle> <volume> volume 19, </volume> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1974. </year>
Reference-contexts: Finally, we demonstrate the expressiveness of KMC and EMC by translating a version of the Abstract Module Calculus (AMC) and a version of the Transparent Module Calculus (TMC) into the EMC calculus. We show how KMC and EMC can be compiled into an F ! -like Target Calculus (FTC) <ref> [9, 30] </ref> extended with existential types and dot notations [27, 4, 3], so our module languages are still compatible with all the standard type-based compilation techniques [15, 13, 31, 33].
Reference: [31] <author> Z. Shao. </author> <title> Flexible representation analysis. </title> <booktitle> In Proc. 1997 ACM SIGPLAN International Conference on Functional Programming (ICFP'97), </booktitle> <pages> pages 85-98, </pages> <address> New York, June 1997. </address> <publisher> ACM Press. </publisher>
Reference-contexts: A higher-order module system will not be practical if it cannot be type-checked and compiled efficiently. Compilation of module programs should also be compatible with the standard type-based compila tion techniques <ref> [15, 13, 31, 33] </ref>. 1.3 Our contributions This paper presents a higher-order module calculus that satisfies all of the above properties. Previous approaches have used either strong sums [22, 11, 23] or translucent sums [10, 16, 17] to express module types. <p> We show how KMC and EMC can be compiled into an F ! -like Target Calculus (FTC) [9, 30] extended with existential types and dot notations [27, 4, 3], so our module languages are still compatible with all the standard type-based compilation techniques <ref> [15, 13, 31, 33] </ref>. The relationship among these five calculus is depicted in Figure 1. 2 Informal Development 2.1 Fully-transparent higher-order modules We first use a series of examples to show how the MacQueen-Tofte system [23] supports fully transparent higher-order modules. <p> The translation from KMC to FTC is omitted since it is quite trivial. The fact that all the module languages discussed in this paper can be compiled into an F ! -based calculus is important because immediately all important type-based compilation techniques <ref> [15, 31, 13, 26, 36] </ref> become applicable to these module languages as well.
Reference: [32] <author> Z. Shao. </author> <title> An overview of the FLINT/ML compiler. </title> <booktitle> In Proc. 1997 ACM SIGPLAN Workshop on Types in Compilation, </booktitle> <month> June </month> <year> 1997. </year>
Reference-contexts: Transparent record (also named as transparent sum) is similar to translucent sum [10] except that all type components in a transparent record are fully defined. The type structure of KMC resembles a typical predica-tive F ! -like calculus <ref> [32] </ref>. Module kind (mknd) K characterizes module constructor (mcon) C; module type (mtyp) M models module expressions (mexp) m. An elaboration context for KMC contains bindings for core variables (v), core type variables (t), module variables (x), and module type variables (s).
Reference: [33] <author> Z. Shao. </author> <title> Typed cross-module compilation. </title> <booktitle> In Proc. 1998 ACM SIGPLAN International Conference on Functional Programming (ICFP'98), page (to appear). </booktitle> <publisher> ACM Press, </publisher> <month> September </month> <year> 1998. </year>
Reference-contexts: A higher-order module system will not be practical if it cannot be type-checked and compiled efficiently. Compilation of module programs should also be compatible with the standard type-based compila tion techniques <ref> [15, 13, 31, 33] </ref>. 1.3 Our contributions This paper presents a higher-order module calculus that satisfies all of the above properties. Previous approaches have used either strong sums [22, 11, 23] or translucent sums [10, 16, 17] to express module types. <p> In other words, we think a functor is not merely a module-to-module function, but rather a module-level "polymorphic" function. This view is consistent with recent work on phase-distinction and typed cross-module compilation <ref> [12, 33] </ref>. In fact, both Harper et al [12] and Shao [33] have shown that using universal quantifications to model functors would propagate the same amount of type sharing as in the strong-sum-based approaches. <p> In other words, we think a functor is not merely a module-to-module function, but rather a module-level "polymorphic" function. This view is consistent with recent work on phase-distinction and typed cross-module compilation [12, 33]. In fact, both Harper et al [12] and Shao <ref> [33] </ref> have shown that using universal quantifications to model functors would propagate the same amount of type sharing as in the strong-sum-based approaches. <p> We show how KMC and EMC can be compiled into an F ! -like Target Calculus (FTC) [9, 30] extended with existential types and dot notations [27, 4, 3], so our module languages are still compatible with all the standard type-based compilation techniques <ref> [15, 13, 31, 33] </ref>. The relationship among these five calculus is depicted in Figure 1. 2 Informal Development 2.1 Fully-transparent higher-order modules We first use a series of examples to show how the MacQueen-Tofte system [23] supports fully transparent higher-order modules. <p> signature: funsig Z1 = fsig (F: FS): sig type t=int val x : t end But this would not work if R also contains the following code: functor J (X: S) = struct type t=real val x=3.0 end structure R3 = FA (J) The actual implementation of the MacQueen-Tofte system <ref> [33] </ref> memoizes a skeleton of each functor body to support re-elaboration, but this is clearly too complex to export to the surface programmers. 2.2 Opaque signatures and abstract types The abstract approach by Harper and Lillibridge [10] and Leroy [10, 16] simply does not type-check the above equality test R1.x = <p> Notice here, inspired by recent work on phase splitting <ref> [12, 33] </ref>, we consider each functor signature as being parameterized by a higher-order constructor f which captures the sharing information in the actual functor. <p> We also compare EMC with the stamp-base semantics of the MacQueen-Tofte system <ref> [23, 33] </ref>. 5.1 The abstract module calculus AMC We use the Abstract Module Calculus (AMC) [16] as a representative of the translucent-sum-based approach. The syntax of AMC is given in Figure 10. <p> Following the usual strong-sum-based module systems <ref> [23, 25, 33] </ref>, we distinguish module signatures (S) from module types (M and L): module signatures are used in the source programs for specifications while module types are used in the static semantics for type checking. <p> :: K type formation ` M exp formation ` m : M constructor equivalence ` C C 0 :: K type equivalence ` M M 0 kind subsumption ` K K 0 type subsumption ` M M 0 5.3 Comparison with the stamp-based semantics Most compilers for the strong-sum-based calculus <ref> [23, 25, 33] </ref> use stamps to support type generativity and abstract types. <p> The fact that all the module languages discussed in this paper can be compiled into an F ! -based calculus is important because immediately all important type-based compilation techniques [15, 31, 13, 26, 36] become applicable to these module languages as well. In a previous paper <ref> [33] </ref>, we presented a type-preserving translation from the MacQueen-Tofte higher-order modules [22] into an F ! -based calculus, however, that algorithm turns all abstract types into concrete ones; this makes it hard to reason about type-directed operations on values with abstract types.
Reference: [34] <author> B. Stroustrup, </author> <title> editor. The C++ Programming Languages, Third Edition. </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1998. </year>
Reference-contexts: Government. 1.1 Why higher-order modules? Standard ML [24, 25] provides a powerful module system. The main innovation of the ML module language is its support of parameterized modules (also known as functors). Unlike Modula-3 generics [28] or C++ templates <ref> [34] </ref> which are more or less macros, ML functors can be type-checked and compiled independently at its definition site; furthermore, different applications of the same functor can share a single copy of the implementation (i.e., object code), even though each application can produce modules with completely different interfaces.
Reference: [35] <author> M. Tofte. </author> <title> Principal signatures for high-order ML functors. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 189-199, </pages> <address> New York, Jan 1992. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Standard ML [25] only supports first-order functors. MacQueen and Tofte <ref> [23, 35] </ref> recently proposed to add fully transparent higher-order modules to ML but their scheme does not provide fully syntactic signatures. <p> The SML'90 module language, however, contains several major problems; for example, type abbreviations are not allowed in signatures, opaque signature matching is not supported, and modules are first-order only. These problems were heavily researched <ref> [10, 16, 17, 20, 35, 23, 14] </ref> and mostly resolved in SML'97 [25]. The main remaining issue is on how to design a higher-order module calculus that satisfies all of the properties mentioned in our introduction. <p> Supporting higher-order functors with fully syntactic signatures turns out to be a very hard problem. The official definition of Standard ML [25] only supports first-order functors. MacQueen and Tofte <ref> [23, 35] </ref> recently proposed to add fully transparent higher-order modules to ML but their scheme does not provide fully syntactic signatures.
Reference: [36] <author> A. Tolmach. </author> <title> Tag-free garbage collection using explicit type parameters. </title> <booktitle> In Proc. 1994 ACM Conf. on Lisp and Functional Programming, </booktitle> <pages> pages 1-11, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: The translation from KMC to FTC is omitted since it is quite trivial. The fact that all the module languages discussed in this paper can be compiled into an F ! -based calculus is important because immediately all important type-based compilation techniques <ref> [15, 31, 13, 26, 36] </ref> become applicable to these module languages as well.
References-found: 36

