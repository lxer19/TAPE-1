URL: ftp://ftp.cs.brown.edu/pub/techreports/93/cs93-16.ps.Z
Refering-URL: http://www.cs.brown.edu/publications/techreports/reports/CS-93-16.html
Root-URL: http://www.cs.brown.edu/
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Serge Abiteboul and Catriel Beeri. </author> <title> On the Power of Languages for the Manipulation of Complex Objects. </title> <type> Technical Report No. 846, </type> <institution> INRIA, </institution> <year> 1988. </year>
Reference-contexts: Complex object systems sometimes support additional types, such as lists or arrays [151], and some models allow the definition of recursive types by supporting object identity [5]. A number of languages have been proposed for complex object models (e.g. <ref> [1] </ref>, [5], [11], [69], [103], [151]). Most languages are similar in power. One difference in power is whether or not a language defines a Powerset 1 operation. Languages with Powerset are strictly more powerful than the same language without the operation [1]. <p> languages have been proposed for complex object models (e.g. <ref> [1] </ref>, [5], [11], [69], [103], [151]). Most languages are similar in power. One difference in power is whether or not a language defines a Powerset 1 operation. Languages with Powerset are strictly more powerful than the same language without the operation [1]. Another difference is the treatment (when applicable to the model), of object identity. Abiteboul and Kanellakis, for example, can produce recursive objects as the result of a query [5]. Languages for complex object models require, at least, operations for manipulation of the complex structures. <p> Abiteboul and Kanellakis, for example, can produce recursive objects as the result of a query [5]. Languages for complex object models require, at least, operations for manipulation of the complex structures. For example, a Set Collapse operator (such as <ref> [1] </ref> or [151]) takes a set (of sets) and returns the union of the set members. A similar operation can be defined for sets of 1 Powerset creates a set of all subsets of the input set. 12 single-column tuples [4]. <p> The product can be defined, similarly to the relational algebra operation, over sets of tuples (e.g. [4]). An alternative definition for product builds tuples containing one field for each set involved in the product (e.g. <ref> [1] </ref>). This allows for the product to be defined over sets of any type of object. The discussion here has been brief, and has highlighted only those features of complex object models that are useful for comparison with object-oriented models. <p> For example, the quantifier 9x x in Select (. . .) is valid since the Select operation creates a new set object when the query is executed. The set membership qualification on quantified variables means that a predicate cannot form a Powerset operation (as in <ref> [1] </ref>). The ability to compute Powerset provides additional power that we do not want to consider at this time. Image and Project The Image operation returns a single object for each object in the queried collection, while the Project operation can return multiple objects for a single object.
Reference: [2] <author> Serge Abiteboul and Nicole Bidoit. </author> <title> Non First Normal Form Relations: An Algebra Allowing Data Restructuring. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 33(3) </volume> <pages> 361-393, </pages> <month> Dec </month> <year> 1986. </year>
Reference-contexts: For example, Jaeschke and Schek [73] define the operators Nest and UnNest, to change normalized relations to nested relations and vice versa. Variations on this model include the addition of ordered lists as a type [35] and requirements for tuple keys <ref> [2, 127] </ref>. More recently, extensions to the relational model include the ability to define abstract data types [67, 128, 140]. In extended relational systems fields of tuples may contain objects with abstract types.
Reference: [3] <author> Serge Abiteboul and Richard Hull. </author> <title> IFO: A Formal Semantic Database Model. </title> <booktitle> In Proceedings of the Symposium on Principles of Database Systems, </booktitle> <pages> pages 119-129. </pages> <publisher> ACM, </publisher> <month> April </month> <year> 1984. </year>
Reference-contexts: For a more complete survey of models and languages for complex objects see [4] and [70]. 2.1.3 O-O Models Object-oriented database models incorporate features of relational and complex object models as well as semantic data models (e.g. <ref> [3] </ref>, [65], [71], [136]) and object-oriented programming languages (e.g. [53], [95]). Although there is no consensus on the definition of an object-oriented database, most agree that such databases must support modelling features including complex structures, abstract data types, encapsulation, object identity, subtyping, and late-binding of methods [8].
Reference: [4] <author> Serge Abiteboul and Paris Kanellakis. </author> <title> Database Theory Column: Query Languages for Complex Object Databases. </title> <journal> SIGACT News, </journal> <volume> 21(3) </volume> <pages> 9-18, </pages> <month> Summer </month> <year> 1990. </year>
Reference-contexts: For example, a Set Collapse operator (such as [1] or [151]) takes a set (of sets) and returns the union of the set members. A similar operation can be defined for sets of 1 Powerset creates a set of all subsets of the input set. 12 single-column tuples <ref> [4] </ref>. Other kinds of manipulations include building sets and tuples from single objects, grouping elements of a set into equivalence classes, and eliminating duplicates. The definition of Cartesian product (or join) is somewhat complicated by the complex structure of objects. <p> The definition of Cartesian product (or join) is somewhat complicated by the complex structure of objects. The product can be defined, similarly to the relational algebra operation, over sets of tuples (e.g. <ref> [4] </ref>). An alternative definition for product builds tuples containing one field for each set involved in the product (e.g. [1]). This allows for the product to be defined over sets of any type of object. <p> The discussion here has been brief, and has highlighted only those features of complex object models that are useful for comparison with object-oriented models. For a more complete survey of models and languages for complex objects see <ref> [4] </ref> and [70]. 2.1.3 O-O Models Object-oriented database models incorporate features of relational and complex object models as well as semantic data models (e.g. [3], [65], [71], [136]) and object-oriented programming languages (e.g. [53], [95]).
Reference: [5] <author> Serge Abiteboul and Paris C. Kanellakis. </author> <title> Object Identity as a Query Language Primitive. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 159-173. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Complex object systems sometimes support additional types, such as lists or arrays [151], and some models allow the definition of recursive types by supporting object identity <ref> [5] </ref>. A number of languages have been proposed for complex object models (e.g. [1], [5], [11], [69], [103], [151]). Most languages are similar in power. One difference in power is whether or not a language defines a Powerset 1 operation. <p> Complex object systems sometimes support additional types, such as lists or arrays [151], and some models allow the definition of recursive types by supporting object identity <ref> [5] </ref>. A number of languages have been proposed for complex object models (e.g. [1], [5], [11], [69], [103], [151]). Most languages are similar in power. One difference in power is whether or not a language defines a Powerset 1 operation. Languages with Powerset are strictly more powerful than the same language without the operation [1]. <p> Languages with Powerset are strictly more powerful than the same language without the operation [1]. Another difference is the treatment (when applicable to the model), of object identity. Abiteboul and Kanellakis, for example, can produce recursive objects as the result of a query <ref> [5] </ref>. Languages for complex object models require, at least, operations for manipulation of the complex structures. For example, a Set Collapse operator (such as [1] or [151]) takes a set (of sets) and returns the union of the set members. <p> A class hierarchy describes subtyping relationships between classes. Extents for types or classes must be explicitly declared and named, and any named entity may be queried. A declarative query language [10], query algebra [32], and rule-based query language <ref> [5] </ref> have been defined for this model. The declarative language and algebra work with both objects 14 and values, and build only values as query results. The rule-based language, on the other hand, is unique in its use and manipulation of object identities.
Reference: [6] <author> Alfred V. Aho, Ravi Sethi, and Jeffrey D. Ullman. </author> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA., </address> <year> 1986. </year>
Reference-contexts: be executed once and saved for use when needed in the execution of the remainder of the query. 7.5 Tree Manipulations An annotated query tree is similar to an annotated syntax tree for a query, and building an annotated tree is similar to syntactic and semantic analysis in a compiler <ref> [6] </ref>. The syntax of the query is stored in function nodes and, to some extent, in arc labels. Annotations store semantic kinds of information data types, cost information, variable usage information, etc. A region transforms a query by manipulating a tree.
Reference: [7] <author> M. M. Astrahan et al. </author> <title> System R: Relational Approach to Database Management. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 1(2) </volume> <pages> 97-137, </pages> <month> June </month> <year> 1976. </year>
Reference-contexts: Much of the current work in query optimization for object-oriented databases is based on optimization results for relational and extensible databases. We review query optimization for relational systems in Section 2.2, looking in particular at System R <ref> [7] </ref> and Ingres [139] as canonical examples. The Epoq approach to optimization, presented in Chapters 5 and 6, is a new approach to extensible query optimization for an object-oriented system. Thus, it is useful to review current research in extensible, as well as object-oriented, optimization. <p> These languages query over relations, and return relations. Details can be found in any elementary database textbook (e.g. [37], [149]). The relational calculus forms the basis for declarative user-level query languages such as SQL <ref> [7] </ref> and QUEL [139]. These languages are declarative in the sense that the result of a query is described, but the operations that must be executed to achieve the result are not made explicit by the query. <p> Two of the most well-known query optimizers are the early optimizers for System R and INGRES, so we examine these optimizers in this section. 2.2.1 System R System R is a relational database prototype developed at IBM San Jose Research Lab in the mid-1970's <ref> [7] </ref>. The SEQUEL language is provided in the Relational Data Interface and a query optimizer for that language is contained in the Relational Data System.
Reference: [8] <author> Malcolm Atkinson et al. </author> <title> The Object-Oriented Database System Manifesto. </title> <booktitle> In Proceedings of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 40-57, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: Object-oriented refers to the fact that the data modelling features for such a database are drawn from the area of object-oriented programming languages. There is much discussion about what constitutes a model for an object-oriented <ref> [8] </ref> or next generation [141] database system. Although there is no accepted common object-oriented database model, most agree that the data model should provide features such as data abstraction or encapsulation, complex object descriptions, types and subtyping, and object identity. <p> Although there is no consensus on the definition of an object-oriented database, most agree that such databases must support modelling features including complex structures, abstract data types, encapsulation, object identity, subtyping, and late-binding of methods <ref> [8] </ref>. Abstract data types and encapsulation provide the ability to model the behavior as well as the structure of data. These abstraction capabilities also separate the logical view of the data from the implementation of this view.
Reference: [9] <editor> F. Bancilhon, C. Delobel, and P. Kanellakis, editors. </editor> <title> Building an Object Oriented Database System: </title> <publisher> the Story of O 2 . Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1991. </year>
Reference-contexts: Many of the features we describe for an Epoq optimizer could be generated, although we do not address the mechanics of such generation here. 1.1.3 Object-Oriented Database Systems Object-oriented databases respond to the needs of a variety of database applications by providing flexible database modelling capabilities <ref> [9, 12, 98, 102, 157] </ref>. Object-oriented refers to the fact that the data modelling features for such a database are drawn from the area of object-oriented programming languages. There is much discussion about what constitutes a model for an object-oriented [8] or next generation [141] database system. <p> In the remainder of this section we quickly review the data models and languages for GemStone [98, 99], O 2 <ref> [9] </ref> and Orion [12]. These models give us a point of comparison for our discussion in Chapter 3 of the ENCORE model, as well as background information for our discussion in Chapter 4 of problems related to query optimization.
Reference: [10] <author> Fran~cois Bancilhon, Sophie Cluet, and Claude Delobel. </author> <title> A Query Language for the O 2 Object-Oriented Database System. </title> <booktitle> In Proceedings of the 2nd International Workshop on Database Programming Languages, </booktitle> <pages> pages 122-138, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: The structure and method implementations may or may not be hidden at the logical level. A class hierarchy describes subtyping relationships between classes. Extents for types or classes must be explicitly declared and named, and any named entity may be queried. A declarative query language <ref> [10] </ref>, query algebra [32], and rule-based query language [5] have been defined for this model. The declarative language and algebra work with both objects 14 and values, and build only values as query results.
Reference: [11] <author> Francois Bancilhon and Setrag Khoshafian. </author> <title> A Calculus for Complex Objects. </title> <booktitle> In Proceedings of the Symposium on Principles of Database Systems, </booktitle> <pages> pages 53-59. </pages> <publisher> ACM, </publisher> <month> March </month> <year> 1986. </year>
Reference-contexts: Complex object systems sometimes support additional types, such as lists or arrays [151], and some models allow the definition of recursive types by supporting object identity [5]. A number of languages have been proposed for complex object models (e.g. [1], [5], <ref> [11] </ref>, [69], [103], [151]). Most languages are similar in power. One difference in power is whether or not a language defines a Powerset 1 operation. Languages with Powerset are strictly more powerful than the same language without the operation [1].
Reference: [12] <author> Jay Banerjee et al. </author> <title> Data Model Issues for Object-Oriented Applications. </title> <journal> ACM Transactions on Office Information Systems, </journal> <volume> 5(1) </volume> <pages> 3-26, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Many of the features we describe for an Epoq optimizer could be generated, although we do not address the mechanics of such generation here. 1.1.3 Object-Oriented Database Systems Object-oriented databases respond to the needs of a variety of database applications by providing flexible database modelling capabilities <ref> [9, 12, 98, 102, 157] </ref>. Object-oriented refers to the fact that the data modelling features for such a database are drawn from the area of object-oriented programming languages. There is much discussion about what constitutes a model for an object-oriented [8] or next generation [141] database system. <p> In the remainder of this section we quickly review the data models and languages for GemStone [98, 99], O 2 [9] and Orion <ref> [12] </ref>. These models give us a point of comparison for our discussion in Chapter 3 of the ENCORE model, as well as background information for our discussion in Chapter 4 of problems related to query optimization.
Reference: [13] <author> Jay Banerjee, Won Kim, and Kyung-Chang Kim. </author> <title> Queries in Object-Oriented Databases. </title> <booktitle> In Proceedings 4th Intl. Conf. on Data Engineering, </booktitle> <pages> pages 31-38. </pages> <publisher> IEEE, </publisher> <month> Feb </month> <year> 1988. </year>
Reference-contexts: However, different systems often place different meanings on these terms and provide differing amounts of support for some of the features. For example, often object-oriented database systems allow the definition of complex objects that are not instances of abstract types <ref> [13] </ref>. The result is that the implementation of the object is exposed for manipulation by a query. <p> The component and subtyping relationships are the only two object relationships defined in this model. A declarative query language, which allows queries over a single class and the class-composition hierarchy for that class, has been implemented for the model <ref> [13] </ref>. 2.2 Relational Query Optimization Query optimization was important to the success of the relational model, and much of the current work in query optimization for extensible and object-oriented systems is based on relational query processing results. <p> For example, the nested queries common in object-oriented languages generalize nested queries in SQL. We also note proposed techniques for solving the problems, where applicable. The examples in this chapter will refer to the sample scheme of Table 4.1. The scheme represents a car-manufacturer database (similar to <ref> [13] </ref>) in which companies have departments, and vehicles are manufactured by companies. There is also a hierarchy of people which includes employees, managers (specialized employees), and students who study at a company under the direction of a manager. Some students are paid while they study (type Student-Employee).
Reference: [14] <author> D. S. Batory et al. </author> <title> GENESIS: An Extensible Database Management System. </title> <booktitle> In Zdonik and Maier [156], </booktitle> <pages> pages 500-518. 157 </pages>
Reference-contexts: The earliest extensible optimizers were designed to address the additional features provided by these systems [117]. Other systems give an implementor the tools to describe a database model and generate a new database system from that description <ref> [14, 24, 61] </ref>. The goal of this generative, or toolkit, approach to database extensibility is to allow a specialized database system to be built to meet the needs of a particular application. <p> model assumes knowledge about the representation of an abstract data type and requires providing selectivity and cost information for operators [140]. 2.3.5 GENESIS GENESIS differs from the previously described systems in that it is designed to support storage architectures for specialized applications, and not necessarily extensibility in the data model <ref> [14] </ref>. The system allows a database system to be customized by composing a set of previously defined modules into a new database system.
Reference: [15] <author> Catriel Beeri and Yoram Kornatzky. </author> <title> Algebraic Optimization of Object-Oriented Query Lan--guages. </title> <booktitle> In Proceedings ICDT, </booktitle> <address> Paris, France, </address> <year> 1990. </year>
Reference-contexts: This work is extended to handle recursive queries in [90]. Algebraic Rewrite A number of proposals have been made for o-o optimization based on the algebraic rewrite of query expressions <ref> [15, 45, 49, 80, 112, 145, 155] </ref>. For example, Beeri and Kornatzky [15] provide an extensive set of rules for bulk data types that generalize existing axioms for object-oriented algebras, and assume the use of an extensible rule-based optimizer for processing the rules on a query. <p> This work is extended to handle recursive queries in [90]. Algebraic Rewrite A number of proposals have been made for o-o optimization based on the algebraic rewrite of query expressions [15, 45, 49, 80, 112, 145, 155]. For example, Beeri and Kornatzky <ref> [15] </ref> provide an extensive set of rules for bulk data types that generalize existing axioms for object-oriented algebras, and assume the use of an extensible rule-based optimizer for processing the rules on a query. <p> For example, a method could be written in the query language understood by the optimizer. The method code could then be merged with the query and managed by the query optimizer <ref> [15] </ref>. This approach, of course, limits the expressibility of methods to that of the query language. If the optimizer gathers cost information about a method by querying the method itself [60] then type Method must define an interface that can provide the required information. <p> In other words, although the possible optimizer results can be extended, the optimization process itself is fixed. This is analogous to the single flashlight picture in the introduction to this chapter. Proposals for object-oriented optimizers either use one of these extensible approaches <ref> [15] </ref> or provide some fixed 67 sequence of optimizer processing strategies [29, 81, 146]. The Epoq approach is motivated by the desire to extend an optimizer with new strategies for optimization. In other words, the optimization process itself is extended.
Reference: [16] <author> Veronique Benzaken and Claude Delobel. </author> <title> Enhancing Performance in a Persistent Object Store: Clustering Strategies in O 2 . In Dearle et al. </title> <booktitle> [41], </booktitle> <pages> pages 403-412. </pages>
Reference-contexts: The implementor would use knowledge about which objects would be used together to ensure they would be stored and retrieved together. Other work in clustering looks at grouping objects logically using information about the object's structural (component) relationships or also inheritance relationships <ref> [16, 25, 131] </ref>. Recent research also addresses the dynamic re-organization of object clusters as structural object relationships change [27]. Related research dynamically determines prefetch units using pattern access histories [113]. Cluet and Delobel [31] use clustering and index information to limit the search for equivalent queries during query rewrite.
Reference: [17] <author> Philip A. Bernstein and Dah-Ming W. Chiu. </author> <title> Using Semi-Joins to Solve Relational Queries. </title> <journal> Journal of the ACM, </journal> <volume> 28(1) </volume> <pages> 25-40, </pages> <month> Jan </month> <year> 1981. </year>
Reference-contexts: In this case a relation plays the role of a class (the relation scheme is the type and the tuples form the extent), and edges between class nodes represent join predicates. This type of representation proved useful in processing distributed queries using semijoins <ref> [17] </ref>. A class-based representation is used for processing distributed queries in the Orion database system [75]. In this system, each type has an associated class, and attribute connections between types imply connections between the classes.
Reference: [18] <author> Philip A. Bernstein et al. </author> <title> Query Processing in a System for Distributed Databases (SDD-1). </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 6(4) </volume> <pages> 602-625, </pages> <month> Dec </month> <year> 1981. </year>
Reference-contexts: In such systems a query can be viewed as a graph of relationships between the extents. Such relationships may actually be operations on the datasets. For example, class-based representations have been used in relational query processing for determining join orderings (e.g., <ref> [18] </ref>). In this case a relation plays the role of a class (the relation scheme is the type and the tuples form the extent), and edges between class nodes represent join predicates. This type of representation proved useful in processing distributed queries using semijoins [17].
Reference: [19] <author> E. Bertino. </author> <title> A Survey of Indexing Techniques for Object-Oriented Databases. </title> <editor> In J.C. Freytag, G. Vossen, and D. Maier, editors, </editor> <title> To appear in Query Processing for Advanced Database Applications. </title> <publisher> Morgan Kaufmann Publishers, </publisher> <address> San Mateo, CA, </address> <year> 1992. </year>
Reference-contexts: One approach focuses on specific techniques that solve particular optimization problems. For example, one highly visible problem in optimization of object-oriented expressions is path expressions. Such expressions imply a navigation through objects to find the end of a path. Research in this area includes defining indexes for paths <ref> [19, 79, 97, 111] </ref>, optimization in the presence of arbitrary methods along the path 4 [20, 60, 62, 78], and the use of clustering and other storage information to determine path accesses [31, 75, 91]. An alternative approach is to define a complete system for optimization. <p> For a more complete exposition and comparison of indexing techniques for object-oriented databases see Bertino's survey <ref> [19] </ref>. Clustering Another approach that is used to speed access to paths is clustering of objects. Early work on object-based clustering strategies [68, 99] physically placed objects in clusters, or segments, according to specifications by an implementor.
Reference: [20] <author> Elisa Bertino. </author> <title> Method Precomputation in Object-Oriented Databases. </title> <journal> SIGOIS Bulletin, </journal> <volume> 12(2,3):199-212, </volume> <year> 1991. </year>
Reference-contexts: Such expressions imply a navigation through objects to find the end of a path. Research in this area includes defining indexes for paths [19, 79, 97, 111], optimization in the presence of arbitrary methods along the path 4 <ref> [20, 60, 62, 78] </ref>, and the use of clustering and other storage information to determine path accesses [31, 75, 91]. An alternative approach is to define a complete system for optimization. <p> The query tree, when fully expanded, could be input to a rule-based optimizer such as one generated by Volcano [61]. Bertino proposes to precompute the results of methods, and store those results using an index <ref> [20] </ref>. A method over an object O can be written in an arbitrary language, but cannot have input parameters (other than O), cannot have side-effects, and must only use primitive properties of O (i.e., properties whose values are stored as part of O). <p> One approach that avoids the cost of applying methods at query execution time is method precomputation <ref> [20, 78] </ref>. An alternative strategy for object-oriented models is to consider cost in the application of rewrite transformations. <p> As a simple example, type Method would have a property named cost which, when applied to a method instance, would return an expected cost for executing the method. An alternative to determining cost of method applications, of course, is to store precomputed results in tuples <ref> [20, 78] </ref>. The costs of method application are then, in many cases, transferred to compile time. Late-binding of methods also complicates the determination of method costs, since the implementation (and therefore the cost) of a method used in a query will not necessarily be known until query execution time.
Reference: [21] <author> Elisa Bertino and Paola Foscoli. </author> <title> An Analytical Model of Object-Oriented Query Costs. </title> <booktitle> In Proceedings of the Fifth International Workshop on Persistent Object Systems. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: An annotation on a data node could, for example, indicate the best cost known for building that data. On the other hand, annotations could carry information that would be used by an optimizer to calculate cost. For example, the cost model of Bertino and Foscoli <ref> [21] </ref> requires information such as type, the number of members of a set or the size of the range of a function (method) as parameters to cost computations. This information can be easily stored as annotations to nodes or arcs.
Reference: [22] <author> Elisa Bertino and Won Kim. </author> <title> Indexing Techniques for Queries on Nested Objects. </title> <type> Technical Report ACT-OODS-132-89, </type> <institution> MCC, </institution> <year> 1989. </year>
Reference-contexts: Indexes are defined for each link in a path, and can be based on object identifiers or on values of the instance variables [97]. Indexes are implemented in B + trees, and lookup of a path involves search through a sequence of trees. Bertino and Kim <ref> [22] </ref> call the GemStone style index a multi-index. Their work describes two other kinds of indexes for paths. A nested index uses a single index entry to denote the entire length of a path. As a result, one index access can find the beginning of a path given its endpoint. <p> Related research dynamically determines prefetch units using pattern access histories [113]. Cluet and Delobel [31] use clustering and index information to limit the search for equivalent queries during query rewrite. Lanzelotte et al. [91] represent clustering and index information 2 The model of Bertino and Kim <ref> [22] </ref> assumes all collections are the extents of types. Indexing collections, as opposed to extents, is also discussed in GemStone [97]. 19 in their physical database model, but then only use index information in the representation and manipulation of queries over that model. <p> For example, suppose an index from departmental secretaries to employees is required; i.e., an index is required for the path e.dept.mgr.secretary.name. 3 One question that arises is how to store this index. For example, a single index from secretary name to employee could be maintained <ref> [22] </ref>, or indices could be maintained for segments of the path and combined to give the whole path [79, 97, 111]. Another problem arises when trying to maintain such an index.
Reference: [23] <author> Michael Carey and Laura Haas. </author> <title> Extensible Database Management Systems. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 19(4) </volume> <pages> 54-60, </pages> <month> Dec </month> <year> 1990. </year>
Reference-contexts: These systems are designed to allow flexibility in designing database systems for new and different applications. The term extensible refers to the idea that the system can be extended with new processing capabilities to respond to the requirements of different systems <ref> [23] </ref>. One approach to providing this extensibility is to provide a collection of tools that can be used to generate new database systems. A more open approach is to build a database system which can be easily modified to incorporate new capabilities.
Reference: [24] <author> Michael J. Carey, David J. DeWitt, et al. </author> <title> The Architecture of the EXODUS Extensible DBMS. </title> <booktitle> In Dittrich and Dayal [44], </booktitle> <pages> pages 52-65. </pages>
Reference-contexts: The earliest extensible optimizers were designed to address the additional features provided by these systems [117]. Other systems give an implementor the tools to describe a database model and generate a new database system from that description <ref> [14, 24, 61] </ref>. The goal of this generative, or toolkit, approach to database extensibility is to allow a specialized database system to be built to meet the needs of a particular application. <p> Detailed information about the generator, or of resulting optimizers, has not been specified however. 2.3.2 EXODUS and Volcano The EXODUS database system is a toolkit that allows the specification of a database model and creation of a complex object database <ref> [24] </ref>. The toolkit includes an optimizer generator [54, 58] that builds an optimizer for a specified data model. Information describing the data model, query operations, access methods, costs, and applicable transformations are provided to the generator and a rule-based optimizer is produced.
Reference: [25] <author> Arvola Chan et al. </author> <title> Storage and Access Structures to Support a Semantic Data Model. </title> <booktitle> In Proceedings of the 8th VLDB Conference, </booktitle> <pages> pages 122-130. </pages> <publisher> ACM, </publisher> <year> 1982. </year>
Reference-contexts: The implementor would use knowledge about which objects would be used together to ensure they would be stored and retrieved together. Other work in clustering looks at grouping objects logically using information about the object's structural (component) relationships or also inheritance relationships <ref> [16, 25, 131] </ref>. Recent research also addresses the dynamic re-organization of object clusters as structural object relationships change [27]. Related research dynamically determines prefetch units using pattern access histories [113]. Cluet and Delobel [31] use clustering and index information to limit the search for equivalent queries during query rewrite.
Reference: [26] <author> Ashok K. Chandra. </author> <title> Theory of database queries. </title> <booktitle> In Proceedings of the Symposium on Principles of Database Systems, </booktitle> <pages> pages 1-9. </pages> <publisher> ACM, </publisher> <month> March </month> <year> 1988. </year>
Reference-contexts: Relational languages have also been extended with the ability to apply transitive closure, but we shall not consider such languages here. For a survey of the power of such extensions to the relational algebra see <ref> [26] </ref>. The requirement that relations be normalized (i.e. tuple field values be primitive) is eased in the non-first normal form relational model [47, 63, 100, 114, 124]. This model provides more natural modelling of one to many relationships by allowing fields of tuples to be relations. <p> When restricted to the relational model, the EQUAL operations can simulate the relational algebra and thus would support relational systems embedded in an object-oriented database. As a relational simulation, EQUAL is a complete database language <ref> [26] </ref>.
Reference: [27] <author> Ellis E. Chang and Randy H. Katz. </author> <title> Exploiting Inheritance and Structure Semantics for Effective clustering and Buffering in an Object-Oriented DBMS. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 348-357. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: Other work in clustering looks at grouping objects logically using information about the object's structural (component) relationships or also inheritance relationships [16, 25, 131]. Recent research also addresses the dynamic re-organization of object clusters as structural object relationships change <ref> [27] </ref>. Related research dynamically determines prefetch units using pattern access histories [113]. Cluet and Delobel [31] use clustering and index information to limit the search for equivalent queries during query rewrite.
Reference: [28] <author> Eugene Charniak and Drew McDermott. </author> <title> Introduction to Artificial Intelligence. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA., </address> <year> 1985. </year>
Reference-contexts: In this section we present a region control that justifies that assumption. This control is based on planning the optimization process. Planning reduces a task to primitive actions <ref> [28] </ref>. In the Epoq context, a region's task is to achieve some goal on a query, and primitive actions are subordinate region executions. Plans describe how primitive actions can be combined to achieve a task.
Reference: [29] <institution> Sophie Cluet. Langages et Optimisation de Requ^etes pour Systemes de Gestion de Base de Donnees Orientes-Objet. </institution> <type> PhD thesis, </type> <institution> Universite de Paris-Sud - Centre d'Orsay, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: In this section we first look at some particular techniques proposed for dealing with individual problems in o-o query optimization. We then look at some object-oriented query optimization systems. In particular, we will examine the optimization approach of Cluet and Delobel <ref> [29, 31] </ref>, an architecture proposed by Kemper, Moerkotte and Peithner [81], and the query processing system of Straube and Ozsu [144, 146]. 18 2.4.1 Optimization Techniques Much of the work in o-o query optimization techniques is devoted to finding efficient ways to access information referred to by a path expression. <p> This approach to update management allows the system to handle arbitrary functions. 2.4.2 Some O-O Optimization Systems Cluet and Delobel Cluet and Delobel propose a formalism that provides for the integration of type-based path processing (e.g. [75]) with algebraic query rewrite <ref> [29, 31] </ref>. They present a model in which type information is added to a query to provide additional information for rewrite rules. <p> The EQUAL algebra, through its support for the ENCORE features, is also general enough to be used as a target language for high-level, non-recursive, object-oriented languages (e.g., <ref> [29] </ref>). In the next section we review the ENCORE data model and discuss, in particular, support for abstraction and object identity. The EQUAL algebra is presented in Section 3.2, along with some examples of its use. <p> This is analogous to the single flashlight picture in the introduction to this chapter. Proposals for object-oriented optimizers either use one of these extensible approaches [15] or provide some fixed 67 sequence of optimizer processing strategies <ref> [29, 81, 146] </ref>. The Epoq approach is motivated by the desire to extend an optimizer with new strategies for optimization. In other words, the optimization process itself is extended.
Reference: [30] <author> Sophie Cluet and Claude Delobel. </author> <title> Towards a Unification of Rewrite Based Optimization Techniques for Object-Oriented Queries. </title> <editor> In Septiemes Journees Base de Donnees Avancees, Lyons, </editor> <address> France, </address> <month> Sep </month> <year> 1991. </year> <note> This paper is an early version of [31]. </note>
Reference-contexts: A major shortcoming of these representations is the lack of support for subqueries. Class-based approaches do not support subqueries at all, although Cluet and Delobel note that they are working on that problem <ref> [30] </ref>. Operator-based approaches can support queries nested as input to another query but do not support query expressions in the terms of predicates.
Reference: [31] <author> Sophie Cluet and Claude Delobel. </author> <title> A General Framework for the Optimization of Object-Oriented Queries. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 383-392. </pages> <publisher> ACM, </publisher> <month> June </month> <year> 1992. </year> <month> 158 </month>
Reference-contexts: Although we describe the work in the context of this model, our results in most cases apply more globally. The query algebra has already been used as a target for optimization of a declarative language <ref> [31] </ref>, and our architecture for query optimization presents a new approach to extensibility that applies to any database model. An object-oriented database model, such as ENCORE, is extensible in that it provides, through abstract data types, the ability to add new types with new interface methods and implementations. <p> Research in this area includes defining indexes for paths [19, 79, 97, 111], optimization in the presence of arbitrary methods along the path 4 [20, 60, 62, 78], and the use of clustering and other storage information to determine path accesses <ref> [31, 75, 91] </ref>. An alternative approach is to define a complete system for optimization. The application of algebraic transformations has formed the basis for the design of many query optimizers for object-oriented databases [49, 112, 115, 145]. <p> In this section we first look at some particular techniques proposed for dealing with individual problems in o-o query optimization. We then look at some object-oriented query optimization systems. In particular, we will examine the optimization approach of Cluet and Delobel <ref> [29, 31] </ref>, an architecture proposed by Kemper, Moerkotte and Peithner [81], and the query processing system of Straube and Ozsu [144, 146]. 18 2.4.1 Optimization Techniques Much of the work in o-o query optimization techniques is devoted to finding efficient ways to access information referred to by a path expression. <p> Recent research also addresses the dynamic re-organization of object clusters as structural object relationships change [27]. Related research dynamically determines prefetch units using pattern access histories [113]. Cluet and Delobel <ref> [31] </ref> use clustering and index information to limit the search for equivalent queries during query rewrite. Lanzelotte et al. [91] represent clustering and index information 2 The model of Bertino and Kim [22] assumes all collections are the extents of types. <p> This approach to update management allows the system to handle arbitrary functions. 2.4.2 Some O-O Optimization Systems Cluet and Delobel Cluet and Delobel propose a formalism that provides for the integration of type-based path processing (e.g. [75]) with algebraic query rewrite <ref> [29, 31] </ref>. They present a model in which type information is added to a query to provide additional information for rewrite rules. <p> In general, any optimization of common subexpressions must determine whether the optimization transformation is applicable to a single path leading to the subexpression, or to all paths. The formalism of Cluet and Delobel represents common subexpressions and optimizes them as single expressions <ref> [31] </ref>. <p> Processing of nested query expressions in SQL addresses situations where queries are nested in Where predicates [51, 38, 83, 109]. Proposals for handling nested queries in object-oriented SQL-like languages address nesting in From and Where clauses <ref> [31, 115] </ref>. The problem discussed here is equivalent to a query expression nested in an SQL Select clause. <p> The class extension graph is primarily used to determine execution orderings for traversing path expressions, distributed site selection for subquery executions, and potential parallelism in processing branches of the query tree. A representation for queries proposed by Cluet and Delobel <ref> [31] </ref> unifies algebraic rewrite, class extension optimization, and factorization of common subexpressions through a class-based representation described operationally by an algebraic expression. The representation supports Select-Project-Join queries (also Union and Intersection) where both the Select and Join involve simple predicates over class attributes. <p> This results because these representations consider operations and data as the primary objects in the representation, and subjugate predicates involving the data to adornments of the nodes or arcs [54, 64, 91, 121] or to separate structures which complement the primary representation <ref> [31] </ref>. In an optimizer for an object-oriented system, however, it is important that predicates be treated at the same level as query operators and data. Many object-oriented languages allow the expression of subqueries in any part of a query. <p> If translated to SQL-like queries, the nested queries would appear in the Select clause of the query. Thus, this region complements recently proposed techniques for dealing with SQL-like queries with nested queries in From and Where clauses <ref> [31, 38, 109, 115] </ref>. 132 The applicability predicate for this region states that it looks for queries with Image and Select operations, Project and Select operations, or Select with Exist operations.
Reference: [32] <author> Sophie Cluet et al. Reloop, </author> <title> an Algebra Based Query Language for an Object-Oriented Database System. </title> <booktitle> In Proceedings of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <pages> pages 294-316, </pages> <month> November </month> <year> 1989. </year>
Reference-contexts: The structure and method implementations may or may not be hidden at the logical level. A class hierarchy describes subtyping relationships between classes. Extents for types or classes must be explicitly declared and named, and any named entity may be queried. A declarative query language [10], query algebra <ref> [32] </ref>, and rule-based query language [5] have been defined for this model. The declarative language and algebra work with both objects 14 and values, and build only values as query results. The rule-based language, on the other hand, is unique in its use and manipulation of object identities. <p> It would also be interesting to explore the creation of arbitrary new types by the algebraic operations. EQUAL can build objects with new complex types out of parameterized sets and tuples, and other languages build values with new types constructed from their basic types (sets, tuples, lists, arrays) (e.g <ref> [32] </ref>, [150]). We would like to explore building new abstract objects in response to queries. For example, if we define an abstract data type D, we would like to write a query that can build new objects of type D.
Reference: [33] <author> E. F. Codd. </author> <title> A Relational Model of Data for Large Shared Data Banks. </title> <journal> Communications of the ACM, </journal> <volume> 13(6) </volume> <pages> 377-387, </pages> <month> June </month> <year> 1970. </year>
Reference-contexts: It provides the components for modelling database applications. As a result, the database model determines how an application can be logically presented. 2.1.1 The Relational Model The relational data model is based on the mathematical notion of relations <ref> [33] </ref>. The (normalized) relations in the database are finite sets of tuples of the same kind, where each tuple contains primitive values. This provides a simple, uniform model of data which facilitates optimization, but also limits the modelling ability. <p> Also, when two columns in different relations are drawn from the same domain, the values in those columns can be used to compute relationships. Codd defined an algebra and calculus (first order logic) for querying relations, and showed that they are equivalent <ref> [33] </ref>. These languages query over relations, and return relations. Details can be found in any elementary database textbook (e.g. [37], [149]). The relational calculus forms the basis for declarative user-level query languages such as SQL [7] and QUEL [139].
Reference: [34] <author> Thomas A. Cooper and Nancy Wogrin. </author> <title> Rule-based Programming with OPS5. </title> <publisher> Morgan Kauf-mann Publishers, Inc., </publisher> <address> San Mateo, CA, </address> <year> 1988. </year>
Reference-contexts: The store may also include other data as defined and required by a particular control. For example, the control defined in Section 6.4 can define a working memory similar to that defined for rule-based programming languages such as OPS5 <ref> [34] </ref>. The memory can then include information that helps direct the control execution. A region's store is local to the region. Any information that should be visible to other regions is passed as arguments through the region interface. <p> Planning actions induce a forward chain through rule goals to find primitive actions. Update actions modify the region's working memory with information that may be used later in the rule search. The rule language and working memory are patterned after rule-based languages such as OPS5 <ref> [34] </ref>. A major difference, though, is that the Epoq rule interpreter interleaves rule manipulation with the execution of subordinate regions. <p> A log of region actions is also maintained in working memory. This is discussed in more detail in Section 6.4.5. Abstract data types can also be used to define tuple objects, such as those used in OPS5 <ref> [34] </ref>. Such objects would be used to help control rule execution. The working memory elements can be matched in rules and, in that way, can provide information referenced in rule actions as well as information that helps control the selection of rules to execute. <p> This augmented matching can be useful for passing information between rules, as will be seen in the example of Chapter 8. It is patterned after the condition elements of OPS5 <ref> [34] </ref> extended to work with abstract objects. This style of memory predicate could also be used, for example, to test for subqueries of a query and match subqueries to variables that will be referenced in actions on the rule's right hand side. <p> priorities could be determined by prior assignment of priorities to rules (e.g., the first rule in the package has highest priority), by the number of matching conditions in a rule, by assigning priorities (such as time) to the working memory elements that are matched to rule conditions, or randomly (see <ref> [34] </ref> for example). These priorities are indicated in the SEARCH clause for the package. One built-in termination condition for a rule package is that all rules have been tried. The `empty queue' condition reflects this termination condition. <p> The planning process is influenced by intermediate results of the plan, thus planning is interleaved with the execution of subordinate regions. The Epoq planning-based control was heavily influenced by the OPS5 rule-based programming language <ref> [34] </ref> and by the reactive action packages of Firby [46]. Our rule execution system though is more directed than either of these it is very single-minded in its pursuit of tasks.
Reference: [35] <author> P. Dadam et al. </author> <title> A DBMS Prototype to Support Extended NF 2 Relations: An Integrated View on Flat Tables and Hierarchies. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 356-367. </pages> <publisher> ACM, </publisher> <month> May </month> <year> 1986. </year>
Reference-contexts: For example, Jaeschke and Schek [73] define the operators Nest and UnNest, to change normalized relations to nested relations and vice versa. Variations on this model include the addition of ordered lists as a type <ref> [35] </ref> and requirements for tuple keys [2, 127]. More recently, extensions to the relational model include the ability to define abstract data types [67, 128, 140]. In extended relational systems fields of tuples may contain objects with abstract types.
Reference: [36] <author> Scott Daniels et al. </author> <title> Query Optimization in Revelation, an Overview. </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 14(2) </volume> <pages> 58-62, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Information available about objects is used at execution time to choose among the alternatives and generate a final evaluation plan. More recently, Ioannidis et al. address the problem of parametric query optimization [72]. The Revelation architecture describes an optimizer in which methods "reveal" information about their execution <ref> [36, 60] </ref>. The revealed information is used to expand the nodes of a query tree with execution information. The query tree, when fully expanded, could be input to a rule-based optimizer such as one generated by Volcano [61].
Reference: [37] <author> C. J. Date. </author> <title> An Introduction to Database Systems, volume I. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA., 5th edition, </address> <year> 1990. </year>
Reference-contexts: Relational query optimizers exploit the simple semantics of the model and the fixed sets of operators, storage structures, and implementation techniques for the operators. The designs of such optimizers differ and are specific to the system in which the optimizer is built <ref> [37, 149] </ref>. These optimizers generally embody a set of pre-defined manipulations on some internal query representation. These manipulations apply built-in heuristics to guide the discovery of efficient strategies for database access. The access strategies are evaluated according to some cost formula, and a best strategy is selected. <p> Codd defined an algebra and calculus (first order logic) for querying relations, and showed that they are equivalent [33]. These languages query over relations, and return relations. Details can be found in any elementary database textbook (e.g. <ref> [37] </ref>, [149]). The relational calculus forms the basis for declarative user-level query languages such as SQL [7] and QUEL [139]. <p> C 2 ) thus the Coalesce results in identical set-valued attributes in t 4 and t 5 of S 3 (t 4 :C = 0 t 5 :C). 3.2.2 Examples We illustrate the operation of the algebra with some example queries on a simple object-oriented version of a Supplier-Parts-Job database <ref> [37] </ref>. Types Supplier, Part, Job and Addr are defined in Table 3.1. For the purposes of these examples, we assume that Type Object is the only supertype for each of the given types. Sets Suppliers, Parts and Jobs, with the obvious associated types, will be used for the queries.
Reference: [38] <author> Umeshwar Dayal. </author> <title> Of Nests and Trees: A Unified Approach to Processing Queries That Contain Nested Subqueries, Aggregates, and Quantifiers. </title> <booktitle> In Proceedings of the 13th VLDB Conference, </booktitle> <pages> pages 197-208, </pages> <year> 1987. </year>
Reference-contexts: Most of the optimization strategies employed focus on queries involving the Select, Project and Join operators (see [149] for a discussion of the theory upon which such strategies are based). Subsequent work in relational optimization looked at extending optimization to include other operators, for example aggregators <ref> [38, 83] </ref>. Optimization results have also been extended to include more expressive models, such as nested [86, 126] and network models [118, 123]. The relational optimizers make extensive use of heuristics based on logical query transformation rules, such as commutativity of join and pushing select past join. <p> This type of relationship can be obtained using the Ojoin operation (which is a special case of Project; see next subsection), but is often more naturally expressed using Project. Indeed, the Project operation, when used as in this example, provides the ability to do OuterJoin <ref> [38] </ref>. Ojoin The Ojoin operator is an explicit join operator used to create relationships between objects from two collections in the database. Although many relationships between objects are represented through object properties, an explicit join handles cases when a relationship is not defined in an object type. <p> A difference in the solutions is that Project does a left outer join, so could result in vehicles related to empty sets of residences. In this example, the empty sets could easily be eliminated if necessary. There is a large body of research for dealing with outerjoin operations <ref> [38, 50, 120, 122] </ref>. The two query expressions differ significantly in their use of variables. In the first query, variable reference is nested, while in the second query all variables are local to the operation using them. <p> On the other hand, if the query is initially the Project expression it would be useful to generate the Join query, especially if there are efficient techniques for dealing with Join operations. Processing of nested query expressions in SQL addresses situations where queries are nested in Where predicates <ref> [51, 38, 83, 109] </ref>. Proposals for handling nested queries in object-oriented SQL-like languages address nesting in From and Where clauses [31, 115]. The problem discussed here is equivalent to a query expression nested in an SQL Select clause. <p> Even when representing join operations, class-based representations require modification to the representation when new kinds of joins need to be considered <ref> [38] </ref>. Operator trees have been shown useful for supporting the algebraic rewrite of query expressions [121], while class-based graphs are useful for manipulating path expressions [75, 91]. A major shortcoming of these representations is the lack of support for subqueries. <p> Some nested Project operations can be transformed to Ojoin and sometimes Outerjoin operations, and there are a number of transformations for join and outerjoin operations (e.g. <ref> [38] </ref>, [50]). Thus, rather than using the kind=outerjoin annotation on an Ojoin function node, we extend the algebra with an Outerjoin operation. <p> If translated to SQL-like queries, the nested queries would appear in the Select clause of the query. Thus, this region complements recently proposed techniques for dealing with SQL-like queries with nested queries in From and Where clauses <ref> [31, 38, 109, 115] </ref>. 132 The applicability predicate for this region states that it looks for queries with Image and Select operations, Project and Select operations, or Select with Exist operations.
Reference: [39] <author> Umeshwar Dayal. </author> <title> Queries and Views in an Object-Oriented Data Model. </title> <booktitle> In Proceedings of the 2nd International Workshop on Database Programming Languages, </booktitle> <month> June </month> <year> 1989. </year>
Reference-contexts: One problem that arises in systems supporting both objects and values is the definition of types for the different kinds of entities. For example, set values are immutable collections while set objects are mutable. Mixing immutable values and mutable objects is a current area of research <ref> [39, 94] </ref>. The relationships that can be defined in an object-oriented model differ depending on the type system of the model.
Reference: [40] <author> Thomas L. Dean and Michael P. Wellman. </author> <title> Planning and Control. </title> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1991. </year>
Reference-contexts: The control, in accessing a strategy through the interface, treats each strategy as a single query transformation. We thus reduce the control problem to that of determining a sequence of query transformations. We propose a solution to this problem that is based on planning <ref> [40] </ref>. The architecture is supported by an internal representation for queries which we define as an annotated operator graph. Nodes in the graph represent objects, query operations, and arbitrary methods over objects, and arcs represent relationships between the data and functions in the query (i.e., operations and methods).
Reference: [41] <editor> Alan Dearle, Gail M. Shaw, and Stanley B. Zdonik, editors. </editor> <title> Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice. Fourth International Workshop on Persistent Object Systems, </booktitle> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1990. </year>
Reference: [42] <author> Claude Delobel, </author> <month> May </month> <year> 1989. </year> <type> Personal communication. </type>
Reference-contexts: For example, in the object-oriented model, the cost of applying a Selection operation is an important factor when deciding whether to push the Select past a Join <ref> [42] </ref>. Although this is also a recognized problem with relational queries, it is not as prevalent and, in the relational model, pushing a Select operation past a Join operation is generally accepted to be a useful transformation.
Reference: [43] <editor> K. R. Dittrich, editor. </editor> <booktitle> Advances in Object-Oriented Database Systems. International Workshop on Object-Oriented Database Systems, </booktitle> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1988. </year>
Reference: [44] <editor> Klaus Dittrich and Umeshwar Dayal, editors. </editor> <booktitle> Proceedings of the 1986 International Workshop on Object-Oriented Database Systems. </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> September </month> <year> 1986. </year>
Reference: [45] <author> Beatrice Finance and Georges Gardarin. </author> <title> A Rule-Based Query Rewriter in an Extensible DBMS. </title> <booktitle> In Proceedings of the 7th International Conference on Data Engineering, </booktitle> <pages> pages 248-256. </pages> <publisher> IEEE, </publisher> <year> 1991. </year>
Reference-contexts: An existing system can be extended by adding information to the database description, and generating another system that includes the new information. Optimizers for extensible database systems are generally based on transformation rules for a set of operators defined in the system <ref> [45, 54] </ref>. Extensibility of these optimizers results from the ability to augment the set of transformation rules. These transformations are applied to a query expression to generate equivalent, and hopefully more efficient, forms of the expression. A transformed expression often corresponds to many executable plans for database access. <p> The extensibility in this system derives from the ability to model extensions in the path model, and the generality of the optimization stages. Many subsequent systems use rewrite rules to describe the transformations that can be performed to optimize a query expression <ref> [45, 54, 115, 137] </ref>. Freytag [48] claimed that rules are sufficient for translating a user query into a query evaluation plan and, to illustrate, showed how access paths and join orders in System R optimization could be generated using transformation 16 rules. <p> Such additions are usually supported by the use of transformation rules by an optimizer, and the addition of new rules to manipulate the new operations. The kinds of rules used to describe query transformations, and the control over execution of those rules, differ in all systems <ref> [45, 54, 115, 137] </ref>. Some systems also recognize a need to support new strategies for optimization; i.e. extensibility of the optimization process itself. This is the motivation behind Epoq, presented in Chapter 5. <p> This work is extended to handle recursive queries in [90]. Algebraic Rewrite A number of proposals have been made for o-o optimization based on the algebraic rewrite of query expressions <ref> [15, 45, 49, 80, 112, 145, 155] </ref>. For example, Beeri and Kornatzky [15] provide an extensive set of rules for bulk data types that generalize existing axioms for object-oriented algebras, and assume the use of an extensible rule-based optimizer for processing the rules on a query. <p> For example, Beeri and Kornatzky [15] provide an extensive set of rules for bulk data types that generalize existing axioms for object-oriented algebras, and assume the use of an extensible rule-based optimizer for processing the rules on a query. Finance and Gardarin <ref> [45] </ref> present a rule language for specifying query rewrites that allows writing rules describing both syntactic and semantic transformations. They also have a meta-rule language that allows an implementor to define blocks of rules, iteration over blocks, and sequences of rules. <p> Almost all query optimizers (extensible or not) process a query through some fixed sequence of optimization stages (e.g., <ref> [45] </ref>, [54], [56], [64], [129], [130], [142], [152]). An Epoq optimizer can simulate this kind of sequential processing in a straightforward way. <p> As noted earlier, most extensible optimizers (e.g. <ref> [45] </ref>, [54], [56], [64], [140]) provide a fixed strategy for searching for and applying rules for query transformation. In other words, although the possible optimizer results can be extended, the optimization process itself is fixed. This is analogous to the single flashlight picture in the introduction to this chapter. <p> Region LC can choose to use this region to attain its own goal, or can choose to send the query through a sequence of modules (CNF and DP, here) each of which has its own strategy for applying its transformations to the query (similarly to <ref> [45] </ref> or [129]). LC could even try both strategies, choosing the best result, or could use the strategies in a pilot pass type of approach. 8.2.1 Region Descriptions In this section we briefly describe all of the regions in the optimizer, except the root region.
Reference: [46] <author> R. James Firby. </author> <title> Adaptive Execution in Complex Dynamic Worlds. </title> <type> PhD thesis, </type> <institution> Yale University, </institution> <month> January </month> <year> 1989. </year> <month> YALEU/CSD/RR#672. </month>
Reference-contexts: In other words, the sequence of actions that is generated as a plan is affected by the execution of those actions. This is similar to reactive planning in the domain of robot control <ref> [46, 52, 76] </ref>. 94 In the remainder of this section we present the components of the planning-based control in more detail. The working memory stores control state information and is discussed in Section 6.4.1. The rule language is presented in Section 6.4.2. <p> The planning process is influenced by intermediate results of the plan, thus planning is interleaved with the execution of subordinate regions. The Epoq planning-based control was heavily influenced by the OPS5 rule-based programming language [34] and by the reactive action packages of Firby <ref> [46] </ref>. Our rule execution system though is more directed than either of these it is very single-minded in its pursuit of tasks. Our rule engine enforces a transaction type of semantics on rules a rule is a task that (if successful) will result in a desired transformation of a query.
Reference: [47] <author> Patrick C. Fischer and Dirk Van Gucht. </author> <title> Weak Multivalued Dependencies. </title> <booktitle> In Proceedings of the Symposium on Principles of Database Systems, </booktitle> <pages> pages 266-274. </pages> <publisher> ACM, </publisher> <month> April </month> <year> 1984. </year>
Reference-contexts: For a survey of the power of such extensions to the relational algebra see [26]. The requirement that relations be normalized (i.e. tuple field values be primitive) is eased in the non-first normal form relational model <ref> [47, 63, 100, 114, 124] </ref>. This model provides more natural modelling of one to many relationships by allowing fields of tuples to be relations. Algebras for this model include the standard relational operators as well as operations for the resulting nested structures.
Reference: [48] <author> Johann Cristoph Freytag. </author> <title> A Rule-Based View of Query Optimization. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 173-180, </pages> <month> May </month> <year> 1987. </year> <month> 159 </month>
Reference-contexts: The extensibility in this system derives from the ability to model extensions in the path model, and the generality of the optimization stages. Many subsequent systems use rewrite rules to describe the transformations that can be performed to optimize a query expression [45, 54, 115, 137]. Freytag <ref> [48] </ref> claimed that rules are sufficient for translating a user query into a query evaluation plan and, to illustrate, showed how access paths and join orders in System R optimization could be generated using transformation 16 rules.
Reference: [49] <author> Cesar Galindo-Legaria and Renato Barrera. </author> <title> A Rule-Based Query Optimizer. </title> <type> Technical Report 92, </type> <institution> Centro de Investigacion y de Estudios Avanzados Del IPN, </institution> <year> 1989. </year>
Reference-contexts: An alternative approach is to define a complete system for optimization. The application of algebraic transformations has formed the basis for the design of many query optimizers for object-oriented databases <ref> [49, 112, 115, 145] </ref>. Algebraic transformations, however, do not always provide ways to deal with such problems as path expressions and method invocations. <p> This work is extended to handle recursive queries in [90]. Algebraic Rewrite A number of proposals have been made for o-o optimization based on the algebraic rewrite of query expressions <ref> [15, 45, 49, 80, 112, 145, 155] </ref>. For example, Beeri and Kornatzky [15] provide an extensive set of rules for bulk data types that generalize existing axioms for object-oriented algebras, and assume the use of an extensible rule-based optimizer for processing the rules on a query.
Reference: [50] <author> Cesar Galindo-Legaria and Arnon Rosenthal. </author> <title> How to Extend a Conventional Optimizer to Handle One- and Two-Sided Outerjoin. </title> <booktitle> In Proceedings of the 8th International Conference on Data Engineering, </booktitle> <pages> pages 402-409. </pages> <publisher> IEEE, </publisher> <year> 1992. </year>
Reference-contexts: A difference in the solutions is that Project does a left outer join, so could result in vehicles related to empty sets of residences. In this example, the empty sets could easily be eliminated if necessary. There is a large body of research for dealing with outerjoin operations <ref> [38, 50, 120, 122] </ref>. The two query expressions differ significantly in their use of variables. In the first query, variable reference is nested, while in the second query all variables are local to the operation using them. <p> Some nested Project operations can be transformed to Ojoin and sometimes Outerjoin operations, and there are a number of transformations for join and outerjoin operations (e.g. [38], <ref> [50] </ref>). Thus, rather than using the kind=outerjoin annotation on an Ojoin function node, we extend the algebra with an Outerjoin operation. <p> This is indicated by the applicability predicate that states the region is interested in queries with outerjoin operators. This region can use the transformations of Galindo-Legaria and Rosenthal <ref> [50] </ref> to simplify and reorder queries. Their algorithms require queries be represented as operator trees; the internal representation of our example optimizer meets this requirement.
Reference: [51] <author> Richard A. Ganski and Harry K. T. Wong. </author> <title> Optimization of Nested SQL Queries Revisited. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 23-33, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: On the other hand, if the query is initially the Project expression it would be useful to generate the Join query, especially if there are efficient techniques for dealing with Join operations. Processing of nested query expressions in SQL addresses situations where queries are nested in Where predicates <ref> [51, 38, 83, 109] </ref>. Proposals for handling nested queries in object-oriented SQL-like languages address nesting in From and Where clauses [31, 115]. The problem discussed here is equivalent to a query expression nested in an SQL Select clause.
Reference: [52] <author> Michael P. Georgeff and Amy L. Lansky. </author> <title> Reactive Reasoning and Planning. </title> <booktitle> In AIII-87, </booktitle> <pages> pages 677-682. </pages> <address> AIII, </address> <year> 1987. </year>
Reference-contexts: In other words, the sequence of actions that is generated as a plan is affected by the execution of those actions. This is similar to reactive planning in the domain of robot control <ref> [46, 52, 76] </ref>. 94 In the remainder of this section we present the components of the planning-based control in more detail. The working memory stores control state information and is discussed in Section 6.4.1. The rule language is presented in Section 6.4.2.
Reference: [53] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: For a more complete survey of models and languages for complex objects see [4] and [70]. 2.1.3 O-O Models Object-oriented database models incorporate features of relational and complex object models as well as semantic data models (e.g. [3], [65], [71], [136]) and object-oriented programming languages (e.g. <ref> [53] </ref>, [95]). Although there is no consensus on the definition of an object-oriented database, most agree that such databases must support modelling features including complex structures, abstract data types, encapsulation, object identity, subtyping, and late-binding of methods [8]. <p> GemStone GemStone [98, 99], developed at Servio Logic, is an early (and still current) example of an object-oriented database system implementation. The system is based on Smalltalk-80 <ref> [53] </ref>, and adds typing and support for queries to the Smalltalk data model. Objects in GemStone have unique identities, respond to messages, and have a structure defined by a set of typed instance variables. Objects with the same structure and methods are grouped in classes.
Reference: [54] <author> Goetz Graefe. </author> <title> Rule-Based Query Optimization in Extensible Database Systems. </title> <type> PhD thesis, </type> <institution> Univ. of Wisconsin-Madison, </institution> <month> November </month> <year> 1987. </year>
Reference-contexts: An existing system can be extended by adding information to the database description, and generating another system that includes the new information. Optimizers for extensible database systems are generally based on transformation rules for a set of operators defined in the system <ref> [45, 54] </ref>. Extensibility of these optimizers results from the ability to augment the set of transformation rules. These transformations are applied to a query expression to generate equivalent, and hopefully more efficient, forms of the expression. A transformed expression often corresponds to many executable plans for database access. <p> The extensibility in this system derives from the ability to model extensions in the path model, and the generality of the optimization stages. Many subsequent systems use rewrite rules to describe the transformations that can be performed to optimize a query expression <ref> [45, 54, 115, 137] </ref>. Freytag [48] claimed that rules are sufficient for translating a user query into a query evaluation plan and, to illustrate, showed how access paths and join orders in System R optimization could be generated using transformation 16 rules. <p> Detailed information about the generator, or of resulting optimizers, has not been specified however. 2.3.2 EXODUS and Volcano The EXODUS database system is a toolkit that allows the specification of a database model and creation of a complex object database [24]. The toolkit includes an optimizer generator <ref> [54, 58] </ref> that builds an optimizer for a specified data model. Information describing the data model, query operations, access methods, costs, and applicable transformations are provided to the generator and a rule-based optimizer is produced. <p> Such additions are usually supported by the use of transformation rules by an optimizer, and the addition of new rules to manipulate the new operations. The kinds of rules used to describe query transformations, and the control over execution of those rules, differ in all systems <ref> [45, 54, 115, 137] </ref>. Some systems also recognize a need to support new strategies for optimization; i.e. extensibility of the optimization process itself. This is the motivation behind Epoq, presented in Chapter 5. <p> One approach to extending the search space is to "enlarge the flashlight beam", i.e. to expand the space searched by the optimization strategy. This is the approach taken by many extensible optimizers (e.g. <ref> [54] </ref>, [59], [64], [140]). Generally, new rules for transforming query expressions are added to an optimizer and the same rule search strategy is used to find and apply these rules. The optimizer is extensible but the optimizer control strategy is fixed. <p> Normally, rule-based optimizers do pattern matching (and usually condition testing) of the query expression with the left hand sides of rules, then perform some conflict resolution if more than one rule matches a query (e.g. assign weights to rules as in <ref> [54] </ref>). This approach is not completely satisfactory for an Epoq optimizer because the regions do not behave as precisely as rules behave. 3 The dag representation for query expressions allows more than one query alternative to be represented at the same time. <p> Almost all query optimizers (extensible or not) process a query through some fixed sequence of optimization stages (e.g., [45], <ref> [54] </ref>, [56], [64], [129], [130], [142], [152]). An Epoq optimizer can simulate this kind of sequential processing in a straightforward way. <p> As noted earlier, most extensible optimizers (e.g. [45], <ref> [54] </ref>, [56], [64], [140]) provide a fixed strategy for searching for and applying rules for query transformation. In other words, although the possible optimizer results can be extended, the optimization process itself is fixed. This is analogous to the single flashlight picture in the introduction to this chapter. <p> For example, Smith and Chang [138] use transformations over an operator tree to optimize an algebraic expression, then translate that tree to determine an efficient execution plan for the expression. Operator trees manipulations have also been used to determine orderings for join methods (e.g., [87] and [91]). Graefe <ref> [54] </ref> uses operator trees to support extensibility in queries over complex objects. Since the sets of operators, access methods, and transformations are independent of the representation, any extensions are automatically supported by the representation. <p> This results because these representations consider operations and data as the primary objects in the representation, and subjugate predicates involving the data to adornments of the nodes or arcs <ref> [54, 64, 91, 121] </ref> or to separate structures which complement the primary representation [31]. In an optimizer for an object-oriented system, however, it is important that predicates be treated at the same level as query operators and data. <p> A query tree is composed of data nodes and function nodes, connected by labelled, undirected arcs. 2 This representation generalizes operator tree representations (e.g., <ref> [54] </ref>, [121]) by treating algebraic operations, other methods 1 This isn't unique to object-oriented models. <p> These children represent the parameters of the function represented by the node. In an extended representation, a data node can have more than one child. This representation allows for recording alternative methods for computing the same data. A similar approach is taken in other representations (e.g., <ref> [54] </ref>, [121]), and is particularly useful when generating alternative execution plans. <p> This region should be followed by a region that finds good join orderings. This heuristic appears in the control rules of its parent region (LC). Region GO Generated Optimizer This region was generated using the EXODUS optimizer generator <ref> [54] </ref>. It applies EQUAL rewrite rules to general queries (including those given on page 41, for example) using a simple, internal cost model to estimate query cost and direct the transformation process. The interface required by OPT is wrapped around the resulting optimizer to make it a region.
Reference: [55] <author> Goetz Graefe, </author> <title> editor. Workshop on Database Query Optimization, </title> <address> Portland, OR, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: A comprehensive survey of query optimization in centralized, relational databases can be found in Jarke and Koch [74]. Additional information on research in relational, extensible, and object-oriented optimization can be found in Graefe's 1989 optimization workshop proceedings <ref> [55] </ref> and in parts of his survey on optimization techniques for large databases [57]. 2.1 Database Models and Languages A database model is essentially a type system for databases. It provides the components for modelling database applications.
Reference: [56] <author> Goetz Graefe. Volcano, </author> <title> an Extensible and Parallel Query Evaluation System. </title> <type> Technical Report CU-CS-481-90, </type> <institution> University of Colorado at Boulder, </institution> <month> July </month> <year> 1990. </year>
Reference-contexts: Almost all query optimizers (extensible or not) process a query through some fixed sequence of optimization stages (e.g., [45], [54], <ref> [56] </ref>, [64], [129], [130], [142], [152]). An Epoq optimizer can simulate this kind of sequential processing in a straightforward way. For example, each stage of processing could be represented by a separate region, with a single level of control over those regions responsible for executing them in the desired order. <p> As noted earlier, most extensible optimizers (e.g. [45], [54], <ref> [56] </ref>, [64], [140]) provide a fixed strategy for searching for and applying rules for query transformation. In other words, although the possible optimizer results can be extended, the optimization process itself is fixed. This is analogous to the single flashlight picture in the introduction to this chapter.
Reference: [57] <author> Goetz Graefe. </author> <title> Query Evaluation Techniques for Large Databases. </title> <type> Technical Report CU-CS-579-92, </type> <institution> University of Colorado at Boulder, </institution> <year> 1992. </year> <note> To appear in ACM Computing Surveys. </note>
Reference-contexts: Additional information on research in relational, extensible, and object-oriented optimization can be found in Graefe's 1989 optimization workshop proceedings [55] and in parts of his survey on optimization techniques for large databases <ref> [57] </ref>. 2.1 Database Models and Languages A database model is essentially a type system for databases. It provides the components for modelling database applications.
Reference: [58] <author> Goetz Graefe and David J. DeWitt. </author> <title> The EXODUS Optimizer Generator. </title> <booktitle> In SIGMOD Proceedings, </booktitle> <pages> pages 160-172. </pages> <publisher> ACM, </publisher> <month> May </month> <year> 1987. </year>
Reference-contexts: Detailed information about the generator, or of resulting optimizers, has not been specified however. 2.3.2 EXODUS and Volcano The EXODUS database system is a toolkit that allows the specification of a database model and creation of a complex object database [24]. The toolkit includes an optimizer generator <ref> [54, 58] </ref> that builds an optimizer for a specified data model. Information describing the data model, query operations, access methods, costs, and applicable transformations are provided to the generator and a rule-based optimizer is produced. <p> The lower cost region (LC) takes advantage of the hierarchical structure of the Epoq approach. This region has three subordinate regions which it can use in trying to achieve its goal of lowering the expected cost of its input query expression. Region GO is a generated optimizer module <ref> [58] </ref> that uses transformation rules to do local rewrite of EQUAL queries.
Reference: [59] <author> Goetz Graefe et al. </author> <title> Extensible Query Optimization and Parallel Execution in Volcano. </title> <booktitle> In Proceedings of the Dagstuhl Query Workshop, </booktitle> <year> 1992. </year> <note> To appear. </note>
Reference-contexts: However, the internal representation for queries, and the search strategies used to find transformations, are more efficient in Volcano. Volcano also includes new support for operations that encapsulate parallel query execution, thus separating the optimized parallel query execution from the optimizer architecture <ref> [59] </ref>. 2.3.3 Starburst Starburst is an extensible relational database management system that provides modelling extensibility through the ability to add data types and operations for those types, storage and access methods, and internal processing methods (such as query transformation rules) [64, 128]. <p> One approach that avoids the cost of applying methods at query execution time is method precomputation [20, 78]. An alternative strategy for object-oriented models is to consider cost in the application of rewrite transformations. This would require cost models for high-level expressions, as noted in <ref> [59] </ref>. 4.3.1 Method Cost The determination of the cost of a query, or query operation, is complicated by the presence of methods and encapsulation. A query optimizer needs a way to ascertain method cost in the presence of encapsulation. <p> One approach to extending the search space is to "enlarge the flashlight beam", i.e. to expand the space searched by the optimization strategy. This is the approach taken by many extensible optimizers (e.g. [54], <ref> [59] </ref>, [64], [140]). Generally, new rules for transforming query expressions are added to an optimizer and the same rule search strategy is used to find and apply these rules. The optimizer is extensible but the optimizer control strategy is fixed.
Reference: [60] <author> Goetz Graefe and David Maier. </author> <title> Query Optimization in Object-Oriented Database Systems: </title>
Reference-contexts: Such expressions imply a navigation through objects to find the end of a path. Research in this area includes defining indexes for paths [19, 79, 97, 111], optimization in the presence of arbitrary methods along the path 4 <ref> [20, 60, 62, 78] </ref>, and the use of clustering and other storage information to determine path accesses [31, 75, 91]. An alternative approach is to define a complete system for optimization. <p> Information available about objects is used at execution time to choose among the alternatives and generate a final evaluation plan. More recently, Ioannidis et al. address the problem of parametric query optimization [72]. The Revelation architecture describes an optimizer in which methods "reveal" information about their execution <ref> [36, 60] </ref>. The revealed information is used to expand the nodes of a query tree with execution information. The query tree, when fully expanded, could be input to a rule-based optimizer such as one generated by Volcano [61]. <p> The method code could then be merged with the query and managed by the query optimizer [15]. This approach, of course, limits the expressibility of methods to that of the query language. If the optimizer gathers cost information about a method by querying the method itself <ref> [60] </ref> then type Method must define an interface that can provide the required information. As a simple example, type Method would have a property named cost which, when applied to a method instance, would return an expected cost for executing the method.
References-found: 60

