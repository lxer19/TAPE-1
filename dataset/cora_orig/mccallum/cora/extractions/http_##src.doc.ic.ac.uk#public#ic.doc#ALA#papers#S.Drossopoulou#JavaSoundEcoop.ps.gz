URL: http://src.doc.ic.ac.uk/public/ic.doc/ALA/papers/S.Drossopoulou/JavaSoundEcoop.ps.gz
Refering-URL: http://outoften.doc.ic.ac.uk/projects/slurp/papers.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: @doc.ic.ac.uk  
Title: Java is Type Safe Probably  
Author: Sophia Drossopoulou and Susan Eisenbach 
Address: email: sd and se  
Affiliation: Department of Computing Imperial College of Science, Technology and Medicine  
Abstract: Amidst rocketing numbers of enthusiastic Java programmers and internet applet users, there is growing concern about the security of executing Java code produced by external, unknown sources. Rather than waiting to find out empirically what damage Java programs do, we aim to examine first the language and then the environment looking for points of weakness. A proof of the soundness of the Java type system is a first, necessary step towards demonstrating which Java programs won't compromise computer security. We consider a type safe subset of Java describing primitive types, classes, inheritance, instance variables and methods, interfaces, shadowing, dynamic method binding, object creation, null and arrays. We argue that for this subset the type system is sound, by proving that program exe cution preserves the types, up to subclasses/subinterfaces.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> M. Abadi and L. Cardelli. </author> <title> A semantics of object types. </title> <booktitle> In LICS'94 Proceedings, </booktitle> <year> 1994. </year>
Reference-contexts: Java adopts the Smalltalk approach whereby all object variables are implicitly pointers. Furthermore, although there are a large number of studies of the semantics of isolated programming language features or of minimal programming languages <ref> [1] </ref>, there have not been many studies of the formal semantics of actual programming languages . In addition, the interplay of features which are very well understood in isolation, might introduce unexpected effects. Experience confirms the importance of formal studies of type systems early on during language development. <p> Objects carry their classes (similar to the Smalltalk abstract machine [15], thus we do not need store types <ref> [1] </ref>, or location typings [14]). Objects are labelled tuples, where each label contains the class in which it was declared. Array values are tuples too, and they are annotated by their type and their dimension.
Reference: 2. <author> Joseph A. Bank, Barbara Liskov, and Andrew C. Myers. </author> <title> Parameterized types and Java. </title> <booktitle> In POPL'97 Proceedings, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: The language may not have reached a stable point in its development yet: there exist differences between the language descriptions [16, 17, 13], and there are many suggestions for additional features <ref> [19, 2] </ref>. Several studies have uncovered flaws in the security of the Java system [11], and have pointed out the need for a formal semantics. Java combines the experience from the development of several object oriented languages, such as C++, Smalltalk and Clos.
Reference: 3. <author> Gerald Baumgartner and Vincent F. Russo. </author> <title> Signatures: A language extension for improving type abstraction and subtype polymorphism in C++. </title> <journal> Software-Practice & Experience, </journal> <volume> 25(8) </volume> <pages> 863-889, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Nevertheless, we feel that the introduction of some new features in Java, as well as the specific combination of features, justifies a study of the Java formal semantics. The use of interfaces, reminiscent of [9, 5] is a simplification of the signatures extension for C++ <ref> [3] </ref> and is to the best of our knowledge novel. The mechanism for dynamic method binding is that of C++, but we know of no formal definition. Java adopts the Smalltalk approach whereby all object variables are implicitly pointers. <p> Array access as described here adheres to the rules in ch. 15.12 of [13], which require full evaluation of the expression to the left of the brackets. Thus, with our operational semantics, a [(a = b)<ref> [3] </ref>] corresponds to a [b [3]]; a = b. In figure 19 we describe the creation of new objects or arrays, cf. ch. 15.8-15.9 of [13]. Essentially, a new value of the appropriate array or class type is created, and its address is returned.
Reference: 4. <author> John Boyland and Giuseppe Castagna. </author> <title> Type-safe compilation of covariant specialization: A practical case. </title> <booktitle> In ECOOP'96 Proceedings, </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: Furthermore, we chose an imperative subset right from the start, because the extension of type systems to the imperative case has sometimes uncovered new problems, (e.g. multi-methods for functional languages [7], and for imperative languages in <ref> [4] </ref>, the Damas and Milner polymorphic type systems for functional languages [10], and for the imperative extension [21]). We considered arrays, because of the known requirement for run time type checking.
Reference: 5. <author> P. Canning, William Cook, and William Olthoff. </author> <title> Interfaces for object-oriented programming. </title> <booktitle> In OOPLSA'89, </booktitle> <pages> pages 457-467, </pages> <year> 1989. </year>
Reference-contexts: Nevertheless, we feel that the introduction of some new features in Java, as well as the specific combination of features, justifies a study of the Java formal semantics. The use of interfaces, reminiscent of <ref> [9, 5] </ref> is a simplification of the signatures extension for C++ [3] and is to the best of our knowledge novel. The mechanism for dynamic method binding is that of C++, but we know of no formal definition. Java adopts the Smalltalk approach whereby all object variables are implicitly pointers.
Reference: 6. <author> Giuseppe Castagna. </author> <title> Parasitic Methods: Implementation of Multimethods for Java. </title> <type> Technical report, </type> <institution> C.N.R.S, </institution> <month> November </month> <year> 1996. </year>
Reference-contexts: In fact, introduction of the subsumption rule would make this type system non-deterministic although <ref> [6] </ref> develops a system for Java which has a subsumption rule, and in which the types of method call and field access are determined by using the minimal types of the expressions. 3.5 Extending the type rules to Java se The Java se syntax is in most parts identical to that
Reference: 7. <author> Giuseppe Castagna, Giorgio Ghelli, and Giuseppe Longo. </author> <title> A calculus for overloaded functions with subtyping. </title> <journal> Information and Computation, </journal> <volume> 117(1) </volume> <pages> 115-135, </pages> <month> 15 February </month> <year> 1995. </year>
Reference-contexts: Furthermore, we chose an imperative subset right from the start, because the extension of type systems to the imperative case has sometimes uncovered new problems, (e.g. multi-methods for functional languages <ref> [7] </ref>, and for imperative languages in [4], the Damas and Milner polymorphic type systems for functional languages [10], and for the imperative extension [21]). We considered arrays, because of the known requirement for run time type checking.
Reference: 8. <author> William Cook. </author> <title> A Proposal for making Eiffel Type-safe. </title> <editor> In S. Cook, editor, </editor> <booktitle> ECOOP'87 Proceedings, </booktitle> <pages> pages 57-70. </pages> <publisher> Cambridge University Press, </publisher> <month> July </month> <year> 1989. </year>
Reference-contexts: Experience confirms the importance of formal studies of type systems early on during language development. Eiffel, a language first introduced in 1985, was discovered to have a loophole in its type system in 1990 <ref> [8, 18] </ref>. Given the growing usage of Java, it seems important that if there are loopholes in the type system they be discovered early on.
Reference: 9. <author> William Cook, Walter Hill, and Peter Canning. </author> <title> Inheritance is not subtyping. </title> <booktitle> In POPL'90 Proceedings, </booktitle> <month> January </month> <year> 1990. </year>
Reference-contexts: Nevertheless, we feel that the introduction of some new features in Java, as well as the specific combination of features, justifies a study of the Java formal semantics. The use of interfaces, reminiscent of <ref> [9, 5] </ref> is a simplification of the signatures extension for C++ [3] and is to the best of our knowledge novel. The mechanism for dynamic method binding is that of C++, but we know of no formal definition. Java adopts the Smalltalk approach whereby all object variables are implicitly pointers.
Reference: 10. <author> Luis Damas and Robin Milner. </author> <title> Principal Type Schemes for Functional Languages. </title> <booktitle> In POPL'82 Proceedings, </booktitle> <year> 1982. </year>
Reference-contexts: Furthermore, we chose an imperative subset right from the start, because the extension of type systems to the imperative case has sometimes uncovered new problems, (e.g. multi-methods for functional languages [7], and for imperative languages in [4], the Damas and Milner polymorphic type systems for functional languages <ref> [10] </ref>, and for the imperative extension [21]). We considered arrays, because of the known requirement for run time type checking. We describe the language as in the [13] definition with the exception of method binding, which we model as described in [17], because it imposes a weaker requirement.
Reference: 11. <author> Drew Dean, Edward W. Felten, and Dan S. Wallach. </author> <title> Java security: From HotJava to Netscape and beyond. </title> <booktitle> In Proceedings of the 1996 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 190-200, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: The language may not have reached a stable point in its development yet: there exist differences between the language descriptions [16, 17, 13], and there are many suggestions for additional features [19, 2]. Several studies have uncovered flaws in the security of the Java system <ref> [11] </ref>, and have pointed out the need for a formal semantics. Java combines the experience from the development of several object oriented languages, such as C++, Smalltalk and Clos.
Reference: 12. <author> Sophia Drossopoulou and Susan Eisenbach. </author> <booktitle> Is the Java type system sound? In Proceedings of the Fourth International Workshop on Foundations of Object-Oriented Languages, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: rationale soon. 1.1 The Java subset considered so far In this paper we consider the following parts of the Java language: primitive types, classes and inheritance, instance variables and instance methods, interfaces, shadowing of instance variables, dynamic method binding, object creation with new, the null value, arrays, and some exceptions <ref> [12] </ref>. We chose this Java subset because we consider the Java way of combining classes, interfaces and dynamic method binding to be both novel and interesting.
Reference: 13. <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <month> August </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Before the first complete Java language description was available <ref> [13] </ref> use of the language was extremely widespread and the rate of increase in usage is steep. The language may not have reached a stable point in its development yet: there exist differences between the language descriptions [16, 17, 13], and there are many suggestions for additional features [19, 2]. <p> 1 Introduction Before the first complete Java language description was available [13] use of the language was extremely widespread and the rate of increase in usage is steep. The language may not have reached a stable point in its development yet: there exist differences between the language descriptions <ref> [16, 17, 13] </ref>, and there are many suggestions for additional features [19, 2]. Several studies have uncovered flaws in the security of the Java system [11], and have pointed out the need for a formal semantics. <p> We were initially attracted to Java, because of its elegant combination of several tried language features. For this work we were guided by the language descriptions, [17], <ref> [13] </ref>. We found the language description complete and unambiguous, in the sense that any question relating to semantics could be answered unambiguously by [13]. However, we discovered some rules to be more restrictive than necessary, and the reasons for some design decisions were not obvious. <p> For this work we were guided by the language descriptions, [17], <ref> [13] </ref>. We found the language description complete and unambiguous, in the sense that any question relating to semantics could be answered unambiguously by [13]. However, we discovered some rules to be more restrictive than necessary, and the reasons for some design decisions were not obvious. <p> We considered arrays, because of the known requirement for run time type checking. We describe the language as in the <ref> [13] </ref> definition with the exception of method binding, which we model as described in [17], because it imposes a weaker requirement. Namely, [17] requires methods that hide methods from superclasses or superinterfaces to have a return type that can be widened to the return type of the hidden method, whereas [13] <p> <ref> [13] </ref> definition with the exception of method binding, which we model as described in [17], because it imposes a weaker requirement. Namely, [17] requires methods that hide methods from superclasses or superinterfaces to have a return type that can be widened to the return type of the hidden method, whereas [13] requires them to have the same type. Because the first requirement is weaker, our soundness result automatically applies to the new, stricter version of Java as in [13]. 1.2 Our approach We define Java s , a safe subset of Java containing the features listed previously, a term rewrite system <p> from superclasses or superinterfaces to have a return type that can be widened to the return type of the hidden method, whereas <ref> [13] </ref> requires them to have the same type. Because the first requirement is weaker, our soundness result automatically applies to the new, stricter version of Java as in [13]. 1.2 Our approach We define Java s , a safe subset of Java containing the features listed previously, a term rewrite system to describe the Java s operational semantics and a type inference system to describe compile-time type checking. <p> Contrary to Java, Java s statements have a type and thus we can type check the return values of method bodies. The execution of Java programs requires some type information at run-time (e.g. method descriptors as in ch. 15.11 in <ref> [13] </ref>). For this reason, we define Java se , an enriched version of Java s containing compile-time type information to be used for method call and field access. Interestingly, it turns out, that in contrast to Java and Java s , Java se does enjoy a "substitution property". <p> It also contains the type definitions of all variables and methods of a class and its interface. StandardEnv should include all the predefined classes, e.g. Object and all the classes described in chapters 20-22 of <ref> [13] </ref>, but at the moment it is empty. Declarations consist of class declarations, interface declarations and identifier declarations. <p> 1 ; : : : m k : MT k g; 00 - (I) = I ext I 1 ; : : :I n fm 1 : MT 1 ; : : :m k : MT k g iff - (id) = Undef otherwise The chapters 8.2 and 9 in <ref> [13] </ref> describe restrictions imposed on component (i.e. variable or method) definitions in a class or interface. <p> new class C is declared as C ext C 0 impl I 1 ; : : : I n f v 1 : T 1 ; : : : v k : T k ; m 1 : MT 1 ; : : : m l : MT l g, <ref> [13] </ref> imposes the following requirements: there can be sequences of superinterfaces, instance variable declarations, and instance method declarations; the previous declarations are well-formed; there is no prior declaration of C there are no cyclic subclass dependencies between C 0 and C the declarations of the class C 0 , interfaces I <p> ; the MT j are method types; instance variable identifiers are unique; instance methods with the same identifier must have different argument types; a method overriding an inherited method must have a result type that widens to the result type of the overridden method here we follow [17] instead of <ref> [13] </ref> which requires the result types to be identical; we prefer the former because it is a more general definition; - "unless a class is abstract, the declarations of methods defined in each direct superinterface must be implemented either by a declaration in this class, or by an existing method declaration <p> the former because it is a more general definition; - "unless a class is abstract, the declarations of methods defined in each direct superinterface must be implemented either by a declaration in this class, or by an existing method declaration inherited from a superclass" again we follow [17] instead of <ref> [13] </ref>, and we require the implementing method to have a result type that widens to the result type of the interfaces method, instead of requiring them to be identical. <p> (a method is inherited if defined in one of the superinterfaces, and it is overridden if it has the same identifier and same argument types) must have a result type that widens to the result type of the overridden method as for classes, here too we follow [17] instead of <ref> [13] </ref>. 2.4 Properties of well-formed environments Lemma 2. If ` 3, then contains at most one declaration for any identifier, and there are no cycles in the v and relationship. <p> Note that we follow the more general rule from [17] as opposed to <ref> [13] </ref>. Lemma 5. <p> A message expression is type correct when this set contains exactly one pair. The argument types of the signature of this pair is stored as the method descriptor, c.f. ch.15.11 in <ref> [13] </ref>, and the result type of the signature is the type of the message expression. ` e i : T i i 2 f1; :::ng; n 1 MostSpec (; m; T 1 ; T 2 fi ::: fi T n ) = f (T; MT)g ` e 1 :m (e 2 <p> Every object is annotated by its class. An object consists of a sequence of labels and values. Each label also carries the class in which it was defined; this is needed for labels shadowing labels from superclasses, cf <ref> [13] </ref> ch. 9.5. For example, as in section 6, t like Phil: ff 5 , like FrPhil: croissant FrPhil is an object of class FrPhil. It inherits the field like from Phil, and has the field like from FrPhil. <p> This is because there is no explicit dereferencing operator in Java. Objects are passed as references, and they are dereferenced only implicitly, when their fields are accessed. Array access as described here adheres to the rules in ch. 15.12 of <ref> [13] </ref>, which require full evaluation of the expression to the left of the brackets. Thus, with our operational semantics, a [(a = b)[3]] corresponds to a [b [3]]; a = b. In figure 19 we describe the creation of new objects or arrays, cf. ch. 15.8-15.9 of [13]. <p> ch. 15.12 of <ref> [13] </ref>, which require full evaluation of the expression to the left of the brackets. Thus, with our operational semantics, a [(a = b)[3]] corresponds to a [b [3]]; a = b. In figure 19 we describe the creation of new objects or arrays, cf. ch. 15.8-15.9 of [13]. Essentially, a new value of the appropriate array or class type is created, and its address is returned. The fields of the array, and the components the object are assigned initial values (as defined in ch. 4.5.5. of [13]) of the type to which they belong. <p> the creation of new objects or arrays, cf. ch. 15.8-15.9 of <ref> [13] </ref>. Essentially, a new value of the appropriate array or class type is created, and its address is returned. The fields of the array, and the components the object are assigned initial values (as defined in ch. 4.5.5. of [13]) of the type to which they belong.
Reference: 14. <author> R. Harper. </author> <title> A simplified account of polymorphic references. </title> <type> Technical Report CMU-CS-93-169, </type> <institution> Carnegie Mellon University, </institution> <year> 1993. </year>
Reference-contexts: Objects carry their classes (similar to the Smalltalk abstract machine [15], thus we do not need store types [1], or location typings <ref> [14] </ref>). Objects are labelled tuples, where each label contains the class in which it was declared. Array values are tuples too, and they are annotated by their type and their dimension. This paper is organized as follows: In section 2 we give the syntax of Java s .
Reference: 15. <author> Daniel Ingalls. </author> <title> The smalltalk-76 programming system design and implementation. </title> <booktitle> In POPL'78 Proceedings, </booktitle> <pages> pages 9-15, </pages> <month> January </month> <year> 1978. </year>
Reference-contexts: The Java s simplifications of eliminating block structure and local variables allow the definition of the state as a flat structure, where addresses are mapped to objects and global variables are mapped to primitive values or addresses. Objects carry their classes (similar to the Smalltalk abstract machine <ref> [15] </ref>, thus we do not need store types [1], or location typings [14]). Objects are labelled tuples, where each label contains the class in which it was declared. Array values are tuples too, and they are annotated by their type and their dimension.
Reference: 16. <institution> The Java language specification, </institution> <month> October </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Before the first complete Java language description was available [13] use of the language was extremely widespread and the rate of increase in usage is steep. The language may not have reached a stable point in its development yet: there exist differences between the language descriptions <ref> [16, 17, 13] </ref>, and there are many suggestions for additional features [19, 2]. Several studies have uncovered flaws in the security of the Java system [11], and have pointed out the need for a formal semantics.
Reference: 17. <institution> The Java language specification, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: 1 Introduction Before the first complete Java language description was available [13] use of the language was extremely widespread and the rate of increase in usage is steep. The language may not have reached a stable point in its development yet: there exist differences between the language descriptions <ref> [16, 17, 13] </ref>, and there are many suggestions for additional features [19, 2]. Several studies have uncovered flaws in the security of the Java system [11], and have pointed out the need for a formal semantics. <p> We were initially attracted to Java, because of its elegant combination of several tried language features. For this work we were guided by the language descriptions, <ref> [17] </ref>, [13]. We found the language description complete and unambiguous, in the sense that any question relating to semantics could be answered unambiguously by [13]. However, we discovered some rules to be more restrictive than necessary, and the reasons for some design decisions were not obvious. <p> We considered arrays, because of the known requirement for run time type checking. We describe the language as in the [13] definition with the exception of method binding, which we model as described in <ref> [17] </ref>, because it imposes a weaker requirement. Namely, [17] requires methods that hide methods from superclasses or superinterfaces to have a return type that can be widened to the return type of the hidden method, whereas [13] requires them to have the same type. <p> We considered arrays, because of the known requirement for run time type checking. We describe the language as in the [13] definition with the exception of method binding, which we model as described in <ref> [17] </ref>, because it imposes a weaker requirement. Namely, [17] requires methods that hide methods from superclasses or superinterfaces to have a return type that can be widened to the return type of the hidden method, whereas [13] requires them to have the same type. <p> This is defined in chapter 5.1.4 <ref> [17] </ref>; chapter 5.1.2 in [17] defines widening of primitive types, but here we shall only be concerned with widening of references. <p> This is defined in chapter 5.1.4 <ref> [17] </ref>; chapter 5.1.2 in [17] defines widening of primitive types, but here we shall only be concerned with widening of references. <p> v C 0 ; the MT j are method types; instance variable identifiers are unique; instance methods with the same identifier must have different argument types; a method overriding an inherited method must have a result type that widens to the result type of the overridden method here we follow <ref> [17] </ref> instead of [13] which requires the result types to be identical; we prefer the former because it is a more general definition; - "unless a class is abstract, the declarations of methods defined in each direct superinterface must be implemented either by a declaration in this class, or by an <p> identical; we prefer the former because it is a more general definition; - "unless a class is abstract, the declarations of methods defined in each direct superinterface must be implemented either by a declaration in this class, or by an existing method declaration inherited from a superclass" again we follow <ref> [17] </ref> instead of [13], and we require the implementing method to have a result type that widens to the result type of the interfaces method, instead of requiring them to be identical. <p> an inherited method (a method is inherited if defined in one of the superinterfaces, and it is overridden if it has the same identifier and same argument types) must have a result type that widens to the result type of the overridden method as for classes, here too we follow <ref> [17] </ref> instead of [13]. 2.4 Properties of well-formed environments Lemma 2. If ` 3, then contains at most one declaration for any identifier, and there are no cycles in the v and relationship. <p> Note that we follow the more general rule from <ref> [17] </ref> as opposed to [13]. Lemma 5. <p> Only classes have fields. 15.11, <ref> [17] </ref>: A method is applicable if the actual parameter types can be widened to the corresponding formal parameter types. <p> Note that we have no rule of the form &lt; ff j := value; &gt; ; p : : :. This is because in Java overwriting of objects is not possible only sending messages to them, or overwriting selected instance variables. to right, cf ch. 9.3 in <ref> [17] </ref>. The first rule describes rewriting the k th expression, where all the previous expressions (i.e. e i ; i 2 f1; :::k 1g) are ground. <p> When a philosopher thinks together with a French philosopher, they produce a book. French philosophers like food; when they think together with another philosopher, they finally refer the question to a French philosopher (such method overriding was allowed in <ref> [17] </ref>). class Phil f Phil like ; Phil think (Phil y)f : : : g Book think (FrPhil y)f : : : g g class FrPhil extends Phil f Food like ; FrPhil think (Phil y)f like = oyster ; ... g g Phil aPhil ; FrPhil pascal ; ... pascal.like
Reference: 18. <author> Bertrand Meyer. </author> <title> Static typing and other mysteries of life, </title> <month> December </month> <year> 1995. </year>
Reference-contexts: Experience confirms the importance of formal studies of type systems early on during language development. Eiffel, a language first introduced in 1985, was discovered to have a loophole in its type system in 1990 <ref> [8, 18] </ref>. Given the growing usage of Java, it seems important that if there are loopholes in the type system they be discovered early on.
Reference: 19. <author> Martin Odersky and Philip Wadler. </author> <title> Pizza into Java: Translating theory into practice. </title> <booktitle> In POPL'97 Proceedings, </booktitle> <month> January </month> <year> 1997. </year>
Reference-contexts: The language may not have reached a stable point in its development yet: there exist differences between the language descriptions [16, 17, 13], and there are many suggestions for additional features <ref> [19, 2] </ref>. Several studies have uncovered flaws in the security of the Java system [11], and have pointed out the need for a formal semantics. Java combines the experience from the development of several object oriented languages, such as C++, Smalltalk and Clos.
Reference: 20. <author> Peter Sellinger. </author> <title> private communication, </title> <month> October </month> <year> 1996. </year>
Reference-contexts: method calls and bodies The renaming of the variables in the method body (i.e. stmts [z 1 =x 1 ; : : : ; z n =x n ]) is necessary in order to avoid name clashes and also, in order for the lemma 9 to hold aspointed out in <ref> [20] </ref>.
Reference: 21. <author> Mads Tofte. </author> <title> Type Inference for Polymorphic References. </title> <booktitle> In Information and Computation'80 Conference Proceedings, </booktitle> <pages> pages 1-34, </pages> <month> November </month> <year> 1980. </year>
Reference-contexts: an imperative subset right from the start, because the extension of type systems to the imperative case has sometimes uncovered new problems, (e.g. multi-methods for functional languages [7], and for imperative languages in [4], the Damas and Milner polymorphic type systems for functional languages [10], and for the imperative extension <ref> [21] </ref>). We considered arrays, because of the known requirement for run time type checking. We describe the language as in the [13] definition with the exception of method binding, which we model as described in [17], because it imposes a weaker requirement.
References-found: 21

