URL: ftp://ftp.cs.ucsd.edu/pub/team/pinwheel.ps.Z
Refering-URL: http://www.cs.ucsd.edu/users/flaviu/publications.html
Root-URL: http://www.cs.ucsd.edu
Title: The Pinwheel Asynchronous Atomic Broadcast Protocols  
Author: Flaviu Cristian and Shivakant Mishra 
Note: 4.7 milliseconds.  
Address: La Jolla, CA 920930114, USA  
Affiliation: Department of Computer Science Engineering University of California, San Diego  
Abstract: We discuss two asynchronous atomic broadcast protocols that provide fast delivery and stability times, use a small number of messages to accomplish a broadcast, distribute evenly the load of ordering messages among process group members, use efficient flow control techniques, and provide gracefully degraded performance in the presence of communication failures. We report initial performance measurements for a portable implementation on top of the UDP and Ethernet. For a group of three broadcast servers, the protocols achieve a throughput of up to a thousand independent broadcasts per second and measure average delivery and stability times of 2.9 and 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Abbadi, D. Skeen, and F. Cristian. </author> <title> An efficient fault-tolerant protocol for replicated data management. </title> <booktitle> In SIGACT/SIGMOD, </booktitle> <year> 1985. </year>
Reference-contexts: We thus assume that some membership protocol, along the lines described in <ref> [1, 14, 17, 15] </ref>, is used to ensure that all members of a group agree on the initial group state, including the list of group members. For the considered membership, all members are uniquely identified by their rank, which is an integer between 0 and N-1.
Reference: [2] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. </author> <title> Total ordering of messages in broadcast domains. </title> <type> Technical Report CS92-9, </type> <institution> Computer Science Department, The Hebrew University of Jerusalem, Israel, </institution> <year> 1992. </year>
Reference-contexts: Protocols proposed in [7, 3] are token-based. Finally, we would like to mention a third class, the communication-history based protocols, in which the ordering information is inferred independently by each group member 3 based on a fragment of communication history encoded in each protocol message <ref> [16, 13, 2] </ref>. This requires that every group member or a majority of group members send one or more messages after receiving a broadcast update; protocols typically try to reduce message traffic by piggybacking these messages on other outgoing protocol messages.
Reference: [3] <author> Y. Amir, L. Moser, M. Melliar-Smith, D. Agarwal, and P. Ciarfella. </author> <title> Fast message ordering and membership using a logical token-passing ring. </title> <booktitle> In Proceedings of Thirteenth International Conference on Distributed Computing Systems, </booktitle> <pages> pages 551-560, </pages> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1993. </year> <month> 15 </month>
Reference-contexts: The protocols investigated belong to two main classes: sequencer-based [5, 12, 4] and token-based [7] (another interesting token-based protocol optimized for broadcast channels was published after we finished our experiments <ref> [3] </ref>). Our conclusions fl Technical Report CSE93-331, 1993. Also Proc. 2d Int. Symp. on Autonomous Decentralized Systems, Phoenix, AZ, 1995. <p> In token-based protocols, there is a cyclic order among broadcast servers and a token circulates between them in this order. A member can broadcast updates only when it holds the token, which explicitly or implicitly carries sequencing information. Protocols proposed in <ref> [7, 3] </ref> are token-based. Finally, we would like to mention a third class, the communication-history based protocols, in which the ordering information is inferred independently by each group member 3 based on a fragment of communication history encoded in each protocol message [16, 13, 2]. <p> The flow control techniques proposed further improve the performance over these fixed sequencer-based protocols when updates arrive at a very fast rate or when the frequency of communication failures increases. The stability time in the Pinwheel protocols is as low as in token-based protocols <ref> [7, 3] </ref>. Furthermore, like in these protocols, the distribution of processing load is even. The use of bounded silence or newsmonger make the stability time of the Pinwheel protocol much better than those of negative acknowledgement, sequencer based protocols [4, 12].
Reference: [4] <author> K. Birman, A. Schiper, and P. Stephenson. </author> <title> Lightweight causal and atomic group multicast. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 272-314, </pages> <month> Aug </month> <year> 1991. </year>
Reference-contexts: Atomic broadcast is one of the services we intend to provide to Team users. Before deciding what atomic broadcast protocols to implement, we conducted a comparative study [9] of several known protocols that seemed to us to be sufficiently simple to implement and to have potentially interesting performance characteristics <ref> [5, 12, 7, 4] </ref>. The protocols investigated belong to two main classes: sequencer-based [5, 12, 4] and token-based [7] (another interesting token-based protocol optimized for broadcast channels was published after we finished our experiments [3]). Our conclusions fl Technical Report CSE93-331, 1993. Also Proc. 2d Int. <p> Before deciding what atomic broadcast protocols to implement, we conducted a comparative study [9] of several known protocols that seemed to us to be sufficiently simple to implement and to have potentially interesting performance characteristics [5, 12, 7, 4]. The protocols investigated belong to two main classes: sequencer-based <ref> [5, 12, 4] </ref> and token-based [7] (another interesting token-based protocol optimized for broadcast channels was published after we finished our experiments [3]). Our conclusions fl Technical Report CSE93-331, 1993. Also Proc. 2d Int. Symp. on Autonomous Decentralized Systems, Phoenix, AZ, 1995. <p> The key ideas underlying the Pinwheel protocols are then presented and the protocols are described in detail. The results of a simulation study that provides a fair comparison of the performance of our protocols and those of the protocols of <ref> [6, 12, 4] </ref> follows. We conclude by reporting performance measurements for our implementation. 2 System Model and Failure Hypotheses We assume a distributed system in which multiple processors are connected by a communication network. There is no shared memory or a common physical clock. <p> We estimate this based on the number of messages processed by a group member over this period. Our work is a consequence of a comparative study [9] of several known protocols that seemed to us to be sufficiently simple to implement and to have potentially interesting performance characteristics <ref> [5, 12, 7, 4] </ref>. The protocols investigated belong to two main classes: sequencer-based and token-based. In a sequencer-based protocol, a unique broadcast server, the sequencer, imposes a total ordering on all updates originating from all broadcast servers. Examples of sequencer-based protocols can be found in [5, 12, 4, 10]. <p> The protocols investigated belong to two main classes: sequencer-based and token-based. In a sequencer-based protocol, a unique broadcast server, the sequencer, imposes a total ordering on all updates originating from all broadcast servers. Examples of sequencer-based protocols can be found in <ref> [5, 12, 4, 10] </ref>. In token-based protocols, there is a cyclic order among broadcast servers and a token circulates between them in this order. A member can broadcast updates only when it holds the token, which explicitly or implicitly carries sequencing information. Protocols proposed in [7, 3] are token-based. <p> The delivery time provided by the Pinwheel protocols in the absence of communication failures is as low as that provided by fixed sequencer-based protocols such as <ref> [4, 12, 5] </ref>. Unlike these protocols, the Pinwheel protocols rotate the role of issuing ordinals to ensure load balance and small stability time in the absence of communication failures, and use the idea of bounded silence or newsmonger to ensure good delivery times in the presence of communication failures. <p> Furthermore, like in these protocols, the distribution of processing load is even. The use of bounded silence or newsmonger make the stability time of the Pinwheel protocol much better than those of negative acknowledgement, sequencer based protocols <ref> [4, 12] </ref>. However, in token-based protocols, a group member has to wait for the token to broadcast an update, while in the Pinwheel protocols, an update is proposed as soon as it is received from the application and is ordered as soon as the proposal is received by a decider. <p> Our simulation results show that the Pinwheel protocols have broadcast delivery times in the absence of communication failures comparable to the best delivery times achievable by sequencer-based protocols such as the Amoeba [12], Isis <ref> [4] </ref> and the Chang/Maxemchuck protocol. At high update arrival rates the Pinwheel protocols have better delivery times than the other protocols, because of our systematic use of batching and novel flow control techniques. <p> The number of messages used in a broadcast channel based environment is also as good as that of the protocols with best message complexity known [12] and <ref> [4] </ref>. <p> The number of messages used in a broadcast channel based environment is also as good as that of the protocols with best message complexity known [12] and [4]. Where the Pinwheel protocols are a clear win are in 1) providing much better stability times that <ref> [6, 12, 4] </ref>, especially at low update arrival rates or in the presence of transient communication failures, 2) distributing load more evenly among group members, and 3) ensuring improved delivery and stability times when updates arrive very fast or when communication is subject to transient failures.
Reference: [5] <author> R. Carr. </author> <title> The Tandem global update protocol. </title> <journal> Tandem Systems Review, </journal> <month> Jun </month> <year> 1985. </year>
Reference-contexts: Atomic broadcast is one of the services we intend to provide to Team users. Before deciding what atomic broadcast protocols to implement, we conducted a comparative study [9] of several known protocols that seemed to us to be sufficiently simple to implement and to have potentially interesting performance characteristics <ref> [5, 12, 7, 4] </ref>. The protocols investigated belong to two main classes: sequencer-based [5, 12, 4] and token-based [7] (another interesting token-based protocol optimized for broadcast channels was published after we finished our experiments [3]). Our conclusions fl Technical Report CSE93-331, 1993. Also Proc. 2d Int. <p> Before deciding what atomic broadcast protocols to implement, we conducted a comparative study [9] of several known protocols that seemed to us to be sufficiently simple to implement and to have potentially interesting performance characteristics [5, 12, 7, 4]. The protocols investigated belong to two main classes: sequencer-based <ref> [5, 12, 4] </ref> and token-based [7] (another interesting token-based protocol optimized for broadcast channels was published after we finished our experiments [3]). Our conclusions fl Technical Report CSE93-331, 1993. Also Proc. 2d Int. Symp. on Autonomous Decentralized Systems, Phoenix, AZ, 1995. <p> The main drawbacks of using negative acknowledgements is that they cause stability times to become large when updates are broadcast rarely and they suffer from poor performance when transient communication failures occur. Simple minded flow control techniques, such as those used in <ref> [12, 5, 6] </ref>, adversely affect performance at high update arrival rates or when communication failures occur. Finally, in fixed sequencer based protocols, the sequencer is overloaded. <p> We estimate this based on the number of messages processed by a group member over this period. Our work is a consequence of a comparative study [9] of several known protocols that seemed to us to be sufficiently simple to implement and to have potentially interesting performance characteristics <ref> [5, 12, 7, 4] </ref>. The protocols investigated belong to two main classes: sequencer-based and token-based. In a sequencer-based protocol, a unique broadcast server, the sequencer, imposes a total ordering on all updates originating from all broadcast servers. Examples of sequencer-based protocols can be found in [5, 12, 4, 10]. <p> The protocols investigated belong to two main classes: sequencer-based and token-based. In a sequencer-based protocol, a unique broadcast server, the sequencer, imposes a total ordering on all updates originating from all broadcast servers. Examples of sequencer-based protocols can be found in <ref> [5, 12, 4, 10] </ref>. In token-based protocols, there is a cyclic order among broadcast servers and a token circulates between them in this order. A member can broadcast updates only when it holds the token, which explicitly or implicitly carries sequencing information. Protocols proposed in [7, 3] are token-based. <p> In the presence of communication failures, the performance of sequencer-based protocols which rely on negative acknowledgments degrades significantly, while the performance of token based or positive acknowledgement based protocols doesn't degrade much. * Simple minded flow control techniques, such as at most one outstanding broadcast per group member used in <ref> [12, 5, 6] </ref>, adversely affect performance at high arrival rate or when communi cation failures occur. * In fixed sequencer based protocols, the sequencer is overloaded, while in token-based protocols, all group members are equally loaded. <p> The delivery time provided by the Pinwheel protocols in the absence of communication failures is as low as that provided by fixed sequencer-based protocols such as <ref> [4, 12, 5] </ref>. Unlike these protocols, the Pinwheel protocols rotate the role of issuing ordinals to ensure load balance and small stability time in the absence of communication failures, and use the idea of bounded silence or newsmonger to ensure good delivery times in the presence of communication failures.
Reference: [6] <author> J. Chang and N. Maxemchuk. </author> <title> Reliable broadcast protocols. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(3) </volume> <pages> 251-273, </pages> <month> Aug </month> <year> 1984. </year>
Reference-contexts: The main drawbacks of using negative acknowledgements is that they cause stability times to become large when updates are broadcast rarely and they suffer from poor performance when transient communication failures occur. Simple minded flow control techniques, such as those used in <ref> [12, 5, 6] </ref>, adversely affect performance at high update arrival rates or when communication failures occur. Finally, in fixed sequencer based protocols, the sequencer is overloaded. <p> These protocols use an idea of rotating sequencer to order the delivery of different updates being broadcast as the best compromise between sequencer-based and token passing-based atomic broadcast protocols. It is interesting to note that a protocol published earlier by Chang and Maxemchuck <ref> [6] </ref> (to be called the CM protocol in what follows) also used a similar idea. Indeed, our first protocol is in many ways similar, although by no means identical, to the CM protocol. <p> of a broadcast blocks until it receives a positive acknowledgment while in the Pinwheel protocols we make use of sophisticated flow control methods to avoid blocking, 2) we deal explicitly with important practical issues such as determining message stability, purging messages from local buffers and issues of buffer overflow, while <ref> [6] </ref> was vague on these issues and 3) our second protocol makes use of a new technique (see "Newsmonger") for reducing delivery and stability times at low update arrival rates and in the presence of communication failures. We have implemented the Pinwheel protocols and have evidence of their excellent performance. <p> The key ideas underlying the Pinwheel protocols are then presented and the protocols are described in detail. The results of a simulation study that provides a fair comparison of the performance of our protocols and those of the protocols of <ref> [6, 12, 4] </ref> follows. We conclude by reporting performance measurements for our implementation. 2 System Model and Failure Hypotheses We assume a distributed system in which multiple processors are connected by a communication network. There is no shared memory or a common physical clock. <p> In the presence of communication failures, the performance of sequencer-based protocols which rely on negative acknowledgments degrades significantly, while the performance of token based or positive acknowledgement based protocols doesn't degrade much. * Simple minded flow control techniques, such as at most one outstanding broadcast per group member used in <ref> [12, 5, 6] </ref>, adversely affect performance at high arrival rate or when communi cation failures occur. * In fixed sequencer based protocols, the sequencer is overloaded, while in token-based protocols, all group members are equally loaded. <p> When an arbitrary group member r receives a new proposal &lt; u; s; n &gt; from s, r first stores &lt; u; s; n &gt; in its local proposal buffer. Proposals are totally ordered by group members, who in turn, play the role of order deciders (or token sites <ref> [6] </ref>). A decider decides the place a proposal &lt; s; n &gt; will occupy in the history of delivered updates by associating a monotonically increasing ordinal number o with &lt; s; n &gt; and broadcasting a decision message containing &lt; s; n &gt; and o. <p> This improves the delivery and stability times. The use of bounded silence and newsmonger further improves the performance in the presence of communication failures or when updates arrive at a slow rate. Although the first Pinwheel protocol is similar to the CM protocol, it differs from <ref> [6] </ref> in several significant ways. First, the transfer of the role of order decider (called token site in [6]) is done explicitly in the CM protocol by either sending a message or piggybacking transfer information in another message, and the new decider sending an acknowledgement message to confirm the transfer. <p> Although the first Pinwheel protocol is similar to the CM protocol, it differs from <ref> [6] </ref> in several significant ways. First, the transfer of the role of order decider (called token site in [6]) is done explicitly in the CM protocol by either sending a message or piggybacking transfer information in another message, and the new decider sending an acknowledgement message to confirm the transfer. <p> Sixth, we deal explicitly with determining message stability, discarding messages from local buffers and issues of buffer overflow avoidance or tolerance, while <ref> [6] </ref> is vague on this practically important issue. And finally, in a point to point network, the newsmonger concept contributes substantially to reducing stability time and the time to detect a message loss, without increasing network load beyond what group membership stability would require. <p> The number of messages used in a broadcast channel based environment is also as good as that of the protocols with best message complexity known [12] and [4]. Where the Pinwheel protocols are a clear win are in 1) providing much better stability times that <ref> [6, 12, 4] </ref>, especially at low update arrival rates or in the presence of transient communication failures, 2) distributing load more evenly among group members, and 3) ensuring improved delivery and stability times when updates arrive very fast or when communication is subject to transient failures.
Reference: [7] <author> F. Cristian. </author> <title> Asynchronous atomic broadcast. </title> <journal> IBM Technical Disclosure Bulletin, </journal> <volume> 33(9) </volume> <pages> 115-116, </pages> <month> Feb </month> <year> 1991. </year> <booktitle> Also presented at the First IEEE Workshop on Management of Replicated Data, </booktitle> <address> Houston, TX, </address> <month> (Nov </month> <year> 1990). </year>
Reference-contexts: Atomic broadcast is one of the services we intend to provide to Team users. Before deciding what atomic broadcast protocols to implement, we conducted a comparative study [9] of several known protocols that seemed to us to be sufficiently simple to implement and to have potentially interesting performance characteristics <ref> [5, 12, 7, 4] </ref>. The protocols investigated belong to two main classes: sequencer-based [5, 12, 4] and token-based [7] (another interesting token-based protocol optimized for broadcast channels was published after we finished our experiments [3]). Our conclusions fl Technical Report CSE93-331, 1993. Also Proc. 2d Int. <p> The protocols investigated belong to two main classes: sequencer-based [5, 12, 4] and token-based <ref> [7] </ref> (another interesting token-based protocol optimized for broadcast channels was published after we finished our experiments [3]). Our conclusions fl Technical Report CSE93-331, 1993. Also Proc. 2d Int. Symp. on Autonomous Decentralized Systems, Phoenix, AZ, 1995. <p> Stability is important for two reasons: first, it is a measure of how long a message stays in the buffers of group members and how much buffer space a protocol needs, second, it measures how fast one can achieve strict <ref> [7] </ref> (or uniform [11, 18]) agreement on a unique broadcast history despite any number of processor or communication failures. The number of messages needed to broadcast an update includes all messages sent by different group members to complete the broadcast of the update. <p> We estimate this based on the number of messages processed by a group member over this period. Our work is a consequence of a comparative study [9] of several known protocols that seemed to us to be sufficiently simple to implement and to have potentially interesting performance characteristics <ref> [5, 12, 7, 4] </ref>. The protocols investigated belong to two main classes: sequencer-based and token-based. In a sequencer-based protocol, a unique broadcast server, the sequencer, imposes a total ordering on all updates originating from all broadcast servers. Examples of sequencer-based protocols can be found in [5, 12, 4, 10]. <p> In token-based protocols, there is a cyclic order among broadcast servers and a token circulates between them in this order. A member can broadcast updates only when it holds the token, which explicitly or implicitly carries sequencing information. Protocols proposed in <ref> [7, 3] </ref> are token-based. Finally, we would like to mention a third class, the communication-history based protocols, in which the ordering information is inferred independently by each group member 3 based on a fragment of communication history encoded in each protocol message [16, 13, 2]. <p> The flow control techniques proposed further improve the performance over these fixed sequencer-based protocols when updates arrive at a very fast rate or when the frequency of communication failures increases. The stability time in the Pinwheel protocols is as low as in token-based protocols <ref> [7, 3] </ref>. Furthermore, like in these protocols, the distribution of processing load is even. The use of bounded silence or newsmonger make the stability time of the Pinwheel protocol much better than those of negative acknowledgement, sequencer based protocols [4, 12].
Reference: [8] <author> F. Cristian, R. de Beijer, and S. Mishra. </author> <title> Comparing how well asynchronous atomic broadcast protocols perform. </title> <booktitle> In Proceedings of the Third International Workshop on Responsive Computer Systems, </booktitle> <pages> pages 192-204, </pages> <address> Lincoln, NH, </address> <month> Sep </month> <year> 1993. </year>
Reference-contexts: time Index 2 msec 5 msec Delivery time 3.0 msec 3.1 Stability time 4.7 msec 10.6 msec # of messages per broadcast 2 2 Table 1: Performance of the Pinwheel protocol 7 Comparison The Pinwheel protocols were a consequence of a simulation-based performance comparison study of different atomic broadcast protocols <ref> [8, 9] </ref>. In the Pinwheel atomic broadcast protocols, we have tried to combine different techniques used in different atomic broadcast protocols to ensure good overall performance. In this section, we will compare, both qualitatively and quantitatively, the Pinwheel protocols with all other atomic broadcast protocols that we simulated in [8, 9]. <p> protocols <ref> [8, 9] </ref>. In the Pinwheel atomic broadcast protocols, we have tried to combine different techniques used in different atomic broadcast protocols to ensure good overall performance. In this section, we will compare, both qualitatively and quantitatively, the Pinwheel protocols with all other atomic broadcast protocols that we simulated in [8, 9]. Because of the similarity between our first protocol and the CM protocol we have also simulated the CM protocol under identical conditions. 7.1 Qualitative Comparison The good overall performance of the Pinwheel protocols comes from several techniques, some of which have been used in other atomic broadcast protocols. <p> The CM protocol is proposed only for a broadcast network. 7.2 Quantitative Comparison We simulated the behavior of several sequencer-based and token-based atomic broadcast protocols in a point-to-point network and reported the results of this simulation in <ref> [8, 9] </ref>. In order to verify the improved performance of the Pinwheel protocols over these sequencer-based and token-based protocols, we simulated the Pinwheel protocols under the same computing environment and the simulation testbed and measured their performance. We have also simulated the CM protocol under identical conditions. <p> In the simulation results presented here, we simulated the sending of ten thousand updates, such that all group members process the same number of updates in the simulation. The assumptions made in this simulation are described in detail in <ref> [8, 9] </ref>, and can be summarized as follows.
Reference: [9] <author> F. Cristian, R. de Beijer, and S. Mishra. </author> <title> A performance comparison of asynchronous atomic broadcast protocols. </title> <journal> Distributed Ssystems Engineering Journal, </journal> <note> 1994 (to appear). </note>
Reference-contexts: Atomic broadcast is one of the services we intend to provide to Team users. Before deciding what atomic broadcast protocols to implement, we conducted a comparative study <ref> [9] </ref> of several known protocols that seemed to us to be sufficiently simple to implement and to have potentially interesting performance characteristics [5, 12, 7, 4]. <p> We start by defining our system model and assumptions. We then summarize the findings made in our comparative performance study <ref> [9] </ref> which provided the foundation for our work. The key ideas underlying the Pinwheel protocols are then presented and the protocols are described in detail. <p> We estimate this based on the number of messages processed by a group member over this period. Our work is a consequence of a comparative study <ref> [9] </ref> of several known protocols that seemed to us to be sufficiently simple to implement and to have potentially interesting performance characteristics [5, 12, 7, 4]. The protocols investigated belong to two main classes: sequencer-based and token-based. <p> So, we limited our comparison study to sequencer and token-based protocols. The results of our comparison <ref> [9] </ref> can be summarized as follows. * The broadcast delivery time in the absence of communication failures is much better for sequencer-based protocols than for token-based protocols. * The broadcast stability time for token-based protocols is better than that of most sequencer-based protocols (which make extensive use of negative acknowledgements to <p> time Index 2 msec 5 msec Delivery time 3.0 msec 3.1 Stability time 4.7 msec 10.6 msec # of messages per broadcast 2 2 Table 1: Performance of the Pinwheel protocol 7 Comparison The Pinwheel protocols were a consequence of a simulation-based performance comparison study of different atomic broadcast protocols <ref> [8, 9] </ref>. In the Pinwheel atomic broadcast protocols, we have tried to combine different techniques used in different atomic broadcast protocols to ensure good overall performance. In this section, we will compare, both qualitatively and quantitatively, the Pinwheel protocols with all other atomic broadcast protocols that we simulated in [8, 9]. <p> protocols <ref> [8, 9] </ref>. In the Pinwheel atomic broadcast protocols, we have tried to combine different techniques used in different atomic broadcast protocols to ensure good overall performance. In this section, we will compare, both qualitatively and quantitatively, the Pinwheel protocols with all other atomic broadcast protocols that we simulated in [8, 9]. Because of the similarity between our first protocol and the CM protocol we have also simulated the CM protocol under identical conditions. 7.1 Qualitative Comparison The good overall performance of the Pinwheel protocols comes from several techniques, some of which have been used in other atomic broadcast protocols. <p> This reduces the number of messages sent per update broadcast. Third, in the CM protocol a proposer is not allowed to initiate a new broadcast until it receives a positive acknowledgement concerning its "current" proposal. Our performance comparison study <ref> [9] </ref> showed that such sender blocking worsens the delivery time and stability time considerably when updates arrive at a very fast rate or when communication failures occur. The Pinwheel protocols use novel flow control techniques that do not block a sender after each proposal dissemination. <p> The CM protocol is proposed only for a broadcast network. 7.2 Quantitative Comparison We simulated the behavior of several sequencer-based and token-based atomic broadcast protocols in a point-to-point network and reported the results of this simulation in <ref> [8, 9] </ref>. In order to verify the improved performance of the Pinwheel protocols over these sequencer-based and token-based protocols, we simulated the Pinwheel protocols under the same computing environment and the simulation testbed and measured their performance. We have also simulated the CM protocol under identical conditions. <p> In the simulation results presented here, we simulated the sending of ten thousand updates, such that all group members process the same number of updates in the simulation. The assumptions made in this simulation are described in detail in <ref> [8, 9] </ref>, and can be summarized as follows.
Reference: [10] <author> H. Garcia-Molina and A. Spauster. </author> <title> Ordered and reliable multicast communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 9(3) </volume> <pages> 242-271, </pages> <month> Aug </month> <year> 1991. </year>
Reference-contexts: The protocols investigated belong to two main classes: sequencer-based and token-based. In a sequencer-based protocol, a unique broadcast server, the sequencer, imposes a total ordering on all updates originating from all broadcast servers. Examples of sequencer-based protocols can be found in <ref> [5, 12, 4, 10] </ref>. In token-based protocols, there is a cyclic order among broadcast servers and a token circulates between them in this order. A member can broadcast updates only when it holds the token, which explicitly or implicitly carries sequencing information. Protocols proposed in [7, 3] are token-based.
Reference: [11] <author> V. Hadzilacos and S. Toueg. </author> <title> Fault-tolerant broadcasts and related problems. </title> <editor> In S. Mullender, editor, </editor> <booktitle> Distributed Systems, </booktitle> <pages> pages 97-145. </pages> <publisher> Addison-Wesley, </publisher> <year> 1993. </year>
Reference-contexts: Stability is important for two reasons: first, it is a measure of how long a message stays in the buffers of group members and how much buffer space a protocol needs, second, it measures how fast one can achieve strict [7] (or uniform <ref> [11, 18] </ref>) agreement on a unique broadcast history despite any number of processor or communication failures. The number of messages needed to broadcast an update includes all messages sent by different group members to complete the broadcast of the update.
Reference: [12] <author> M. F. Kaashoek, A. Tanenbaum, S. F. Hummel, and H. Bal. </author> <title> An efficient reliable broadcast protocol. </title> <journal> Operating Systems Review, </journal> <volume> 23(4) </volume> <pages> 5-19, </pages> <month> Oct </month> <year> 1989. </year>
Reference-contexts: Atomic broadcast is one of the services we intend to provide to Team users. Before deciding what atomic broadcast protocols to implement, we conducted a comparative study [9] of several known protocols that seemed to us to be sufficiently simple to implement and to have potentially interesting performance characteristics <ref> [5, 12, 7, 4] </ref>. The protocols investigated belong to two main classes: sequencer-based [5, 12, 4] and token-based [7] (another interesting token-based protocol optimized for broadcast channels was published after we finished our experiments [3]). Our conclusions fl Technical Report CSE93-331, 1993. Also Proc. 2d Int. <p> Before deciding what atomic broadcast protocols to implement, we conducted a comparative study [9] of several known protocols that seemed to us to be sufficiently simple to implement and to have potentially interesting performance characteristics [5, 12, 7, 4]. The protocols investigated belong to two main classes: sequencer-based <ref> [5, 12, 4] </ref> and token-based [7] (another interesting token-based protocol optimized for broadcast channels was published after we finished our experiments [3]). Our conclusions fl Technical Report CSE93-331, 1993. Also Proc. 2d Int. Symp. on Autonomous Decentralized Systems, Phoenix, AZ, 1995. <p> The main drawbacks of using negative acknowledgements is that they cause stability times to become large when updates are broadcast rarely and they suffer from poor performance when transient communication failures occur. Simple minded flow control techniques, such as those used in <ref> [12, 5, 6] </ref>, adversely affect performance at high update arrival rates or when communication failures occur. Finally, in fixed sequencer based protocols, the sequencer is overloaded. <p> The key ideas underlying the Pinwheel protocols are then presented and the protocols are described in detail. The results of a simulation study that provides a fair comparison of the performance of our protocols and those of the protocols of <ref> [6, 12, 4] </ref> follows. We conclude by reporting performance measurements for our implementation. 2 System Model and Failure Hypotheses We assume a distributed system in which multiple processors are connected by a communication network. There is no shared memory or a common physical clock. <p> We estimate this based on the number of messages processed by a group member over this period. Our work is a consequence of a comparative study [9] of several known protocols that seemed to us to be sufficiently simple to implement and to have potentially interesting performance characteristics <ref> [5, 12, 7, 4] </ref>. The protocols investigated belong to two main classes: sequencer-based and token-based. In a sequencer-based protocol, a unique broadcast server, the sequencer, imposes a total ordering on all updates originating from all broadcast servers. Examples of sequencer-based protocols can be found in [5, 12, 4, 10]. <p> The protocols investigated belong to two main classes: sequencer-based and token-based. In a sequencer-based protocol, a unique broadcast server, the sequencer, imposes a total ordering on all updates originating from all broadcast servers. Examples of sequencer-based protocols can be found in <ref> [5, 12, 4, 10] </ref>. In token-based protocols, there is a cyclic order among broadcast servers and a token circulates between them in this order. A member can broadcast updates only when it holds the token, which explicitly or implicitly carries sequencing information. Protocols proposed in [7, 3] are token-based. <p> In the presence of communication failures, the performance of sequencer-based protocols which rely on negative acknowledgments degrades significantly, while the performance of token based or positive acknowledgement based protocols doesn't degrade much. * Simple minded flow control techniques, such as at most one outstanding broadcast per group member used in <ref> [12, 5, 6] </ref>, adversely affect performance at high arrival rate or when communi cation failures occur. * In fixed sequencer based protocols, the sequencer is overloaded, while in token-based protocols, all group members are equally loaded. <p> The delivery time provided by the Pinwheel protocols in the absence of communication failures is as low as that provided by fixed sequencer-based protocols such as <ref> [4, 12, 5] </ref>. Unlike these protocols, the Pinwheel protocols rotate the role of issuing ordinals to ensure load balance and small stability time in the absence of communication failures, and use the idea of bounded silence or newsmonger to ensure good delivery times in the presence of communication failures. <p> Furthermore, like in these protocols, the distribution of processing load is even. The use of bounded silence or newsmonger make the stability time of the Pinwheel protocol much better than those of negative acknowledgement, sequencer based protocols <ref> [4, 12] </ref>. However, in token-based protocols, a group member has to wait for the token to broadcast an update, while in the Pinwheel protocols, an update is proposed as soon as it is received from the application and is ordered as soon as the proposal is received by a decider. <p> Our simulation results show that the Pinwheel protocols have broadcast delivery times in the absence of communication failures comparable to the best delivery times achievable by sequencer-based protocols such as the Amoeba <ref> [12] </ref>, Isis [4] and the Chang/Maxemchuck protocol. At high update arrival rates the Pinwheel protocols have better delivery times than the other protocols, because of our systematic use of batching and novel flow control techniques. <p> The number of messages used in a broadcast channel based environment is also as good as that of the protocols with best message complexity known <ref> [12] </ref> and [4]. <p> The number of messages used in a broadcast channel based environment is also as good as that of the protocols with best message complexity known [12] and [4]. Where the Pinwheel protocols are a clear win are in 1) providing much better stability times that <ref> [6, 12, 4] </ref>, especially at low update arrival rates or in the presence of transient communication failures, 2) distributing load more evenly among group members, and 3) ensuring improved delivery and stability times when updates arrive very fast or when communication is subject to transient failures.
Reference: [13] <author> P. M. Melliar-Smith, L. E. Moser, and V. Agrawala. </author> <title> Broadcast protocols for distributed systems. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 1(1) </volume> <pages> 17-25, </pages> <month> Jan </month> <year> 1990. </year>
Reference-contexts: Protocols proposed in [7, 3] are token-based. Finally, we would like to mention a third class, the communication-history based protocols, in which the ordering information is inferred independently by each group member 3 based on a fragment of communication history encoded in each protocol message <ref> [16, 13, 2] </ref>. This requires that every group member or a majority of group members send one or more messages after receiving a broadcast update; protocols typically try to reduce message traffic by piggybacking these messages on other outgoing protocol messages.
Reference: [14] <author> S. Mishra, L. Peterson, and R. Schlichting. </author> <title> Consul: A communication substrate for fault-tolerant distributed programs. </title> <journal> Distributed Systems Engineering Journal, </journal> <note> 1993. to appear. </note>
Reference-contexts: We thus assume that some membership protocol, along the lines described in <ref> [1, 14, 17, 15] </ref>, is used to ensure that all members of a group agree on the initial group state, including the list of group members. For the considered membership, all members are uniquely identified by their rank, which is an integer between 0 and N-1.
Reference: [15] <author> L. E. Moser, P. M. Melliar-Smith, and V. Agrawala. </author> <title> Membership algorithms for asynchronous distributed systems. </title> <booktitle> In Proceedings of the Eleventh International Conference on Distributed Computing Systems, </booktitle> <pages> pages 480-488, </pages> <address> Arlington, TX, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: We thus assume that some membership protocol, along the lines described in <ref> [1, 14, 17, 15] </ref>, is used to ensure that all members of a group agree on the initial group state, including the list of group members. For the considered membership, all members are uniquely identified by their rank, which is an integer between 0 and N-1.
Reference: [16] <author> L. L. Peterson, N. C. Buchholz, and R. D. Schlichting. </author> <title> Preserving and using context information in interprocess communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 7(3) </volume> <pages> 217-246, </pages> <month> Aug </month> <year> 1989. </year>
Reference-contexts: Protocols proposed in [7, 3] are token-based. Finally, we would like to mention a third class, the communication-history based protocols, in which the ordering information is inferred independently by each group member 3 based on a fragment of communication history encoded in each protocol message <ref> [16, 13, 2] </ref>. This requires that every group member or a majority of group members send one or more messages after receiving a broadcast update; protocols typically try to reduce message traffic by piggybacking these messages on other outgoing protocol messages.
Reference: [17] <author> A. Ricciardi and K. Birman. </author> <title> Using process groups to implement failure detection in asynchronous environments. </title> <booktitle> In Eleventh ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Montreal, Canada, </address> <month> Aug </month> <year> 1991. </year>
Reference-contexts: We thus assume that some membership protocol, along the lines described in <ref> [1, 14, 17, 15] </ref>, is used to ensure that all members of a group agree on the initial group state, including the list of group members. For the considered membership, all members are uniquely identified by their rank, which is an integer between 0 and N-1.
Reference: [18] <author> A. Schiper and A. Sandoz. </author> <title> Uniform reliable multicast in a virtually synchronous environment. </title> <booktitle> In Proc. 13th Int. Conf. on Distributed Computing Systems, </booktitle> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1993. </year> <month> 16 </month>
Reference-contexts: Stability is important for two reasons: first, it is a measure of how long a message stays in the buffers of group members and how much buffer space a protocol needs, second, it measures how fast one can achieve strict [7] (or uniform <ref> [11, 18] </ref>) agreement on a unique broadcast history despite any number of processor or communication failures. The number of messages needed to broadcast an update includes all messages sent by different group members to complete the broadcast of the update.
References-found: 18

