URL: file://ftp.cis.ohio-state.edu/pub/tech-report/1996/TR13.ps.gz
Refering-URL: ftp://ftp.cis.ohio-state.edu/pub/tech-report/TRList.html
Root-URL: 
Title: Multitolerance in Distributed Reset  
Author: Sandeep S. Kulkarni Anish Arora 
Keyword: robustness, distributed systems, masking, nonmasking, and stabilizing fault-tolerance  
Address: Columbus, Ohio 43210 USA  
Affiliation: Department of Computer and Information Science 1 The Ohio State University  
Abstract: We design in this paper a multitolerant, distributed program that enables a process in a distributed system to reset the state of all system processes as and when necessary. More specifically, our distributed program exhibits two tolerances: (i) in the presence of any finite number of fail-stop and repair faults of processes, it is "masking" tolerant, by which we mean that it completes every distributed reset correctly; (ii) in the presence of transient faults, it is "stabilizing" tolerant, by which we mean that upon starting from an arbitrary state it eventually reaches a state from where it completes every distributed reset correctly. These tolerances are designed one by one: We first augment a fault- intolerant distributed reset program so that it becomes masking tolerant to fail-stops and repairs. We then augment the resulting program so that it becomes stabilizing tolerant to transients, while still retaining its masking tolerance to fail-stops and repairs. Of special note is the fact that our program admits a bounded space implementation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Arora and S. S. Kulkarni. Multitolerance. </author> <note> Submitted to Fault-tolerant Computing Symposium, </note> <year> 1996. </year>
Reference-contexts: Given these characteristics, it is desirable that modern distributed systems be designed to be "multitolerant" <ref> [1] </ref>, that is, tolerant to each of a number of classes of faults, in a manner that is best suited to each fault class. For instance, the systems could be "masking" tolerant to mild faults and "nonmasking" tolerant to severe faults. <p> Or, the systems could recover quickly in the likely situation where a few faults occur and take longer in the unlikely situation where many faults occur. One approach to designing a program that is multitolerant to fault classes F:1; F:2; :::F:N is as follows <ref> [1] </ref>: Begin with a fault-intolerant program. Then, add the tolerance best suited to the fault class F:1. Next, add the required tolerance best suited to the fault class F:2, while preserving the tolerance to F:1 already designed. And so on, until all N fault classes have been accounted for.
Reference: [2] <author> A. Arora and M. G. Gouda. </author> <title> Distributed reset. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 43(9) </volume> <pages> 1026-1038, </pages> <year> 1994. </year> <booktitle> Extended abstract in Proceedings of the Tenth Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <publisher> LNCS, Springer-Verlag, </publisher> <year> 1990, </year> <pages> 316-331. 20 </pages>
Reference-contexts: Distributed reset. In this paper, we demonstrate the approach outlined above by designing a multitolerant, distributed program that enables a process in a distributed system to reset the state of the system. We focus our attention on such a "distributed reset" program <ref> [2] </ref> as distributed resets are widely applicable in designing fault-tolerance. For instance, if the system is subject to process failure, reconfiguration of processes, or loss of coordination among processes, fault-tolerance may be achieved by performing a distributed reset whenever these situations arise. <p> For instance, if the system is subject to process failure, reconfiguration of processes, or loss of coordination among processes, fault-tolerance may be achieved by performing a distributed reset whenever these situations arise. Formally, a distributed reset to a distinguished global state has been defined by Arora and Gouda <ref> [2] </ref> to be an operation that upon termination leaves the system in a state that is reachable from the distinguished global state by some system computation. <p> A few bounded-space stabilizing solutions have been discovered since then by Arora and Gouda <ref> [2] </ref> and Varghese [5]. For the case of masking fault-tolerant distributed resets, Afek and Gafni [6] have shown a masking fault-tolerant solution with bounded sequence numbers, under the assumption that nodes may not fail but channels may fail and, thus, messages sent on these channels may be lost. <p> The program is easily extended to allow any process to initiate a reset request, by propagating this request towards the root along the parent tree. (The interested reader is referred to <ref> [2] </ref> for the implementation of this request propagation). Moreover, the program is systematically extended to add masking tolerance to channel failure and repairs, as well as to use message passing communication [5].
Reference: [3] <author> S. Finn. </author> <title> Resynch procedures and fail-safe network protocol. </title> <journal> IEEE Transactions on Communication, </journal> <volume> 27(6) </volume> <pages> 840-845, </pages> <year> 1979. </year>
Reference-contexts: Thus, even if faults occur while a distributed reset is in progress, all processes are reset when a distributed reset completes. Fortunately, the solution discussed above is already masking tolerant to faults that fail-stop and repair processes but do not violate the connectivity of the up processes <ref> [3] </ref>. Since the up processes remain connected in the presence of faults and they propagate every new diffusing computation that they receive, every diffusing computation is eventually propagated to and by all up processes.
Reference: [4] <author> L. Lamport and N. Lynch. </author> <booktitle> Handbook of Theoritical Computer Science: Chapter 18, Distributed Computing: Models and Methods. </booktitle> <publisher> Elsevier Science Publishers B. V., </publisher> <year> 1990. </year>
Reference-contexts: For the case of stabilizing fault-tolerance, we recall a 1990 comment by Lamport and Lynch <ref> [4] </ref> that a solution for the distributed reset problem "using a finite number of identifiers would be quite useful, but we know of no such algorithm". A few bounded-space stabilizing solutions have been discovered since then by Arora and Gouda [2] and Varghese [5].
Reference: [5] <author> G. Varghese. </author> <title> Self-stabilization by local checking and correction. </title> <type> PhD thesis, </type> <institution> MIT/LCS/TR-583, </institution> <year> 1993. </year>
Reference-contexts: A few bounded-space stabilizing solutions have been discovered since then by Arora and Gouda [2] and Varghese <ref> [5] </ref>. For the case of masking fault-tolerant distributed resets, Afek and Gafni [6] have shown a masking fault-tolerant solution with bounded sequence numbers, under the assumption that nodes may not fail but channels may fail and, thus, messages sent on these channels may be lost. <p> We note that although our reset program uses a tree that spans the up processes in the system, the use of a tree is not necessary. Analogous to the stabilizing reset program due to Varghese <ref> [5] </ref>, there exists a reset program that is masking tolerant to fail-stop and repair faults and stabilizing tolerant to transient faults, and does not use an underlying tree. Finally, in our reset program, the assumption that the distributed reset request is initiated only at the root process is not necessary. <p> Moreover, the program is systematically extended to add masking tolerance to channel failure and repairs, as well as to use message passing communication <ref> [5] </ref>.
Reference: [6] <author> Y. Afek and E. Gafni. </author> <title> Bootstrap network resynchronization. </title> <booktitle> Proceedings of 10th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 295-307, </pages> <year> 1991. </year>
Reference-contexts: A few bounded-space stabilizing solutions have been discovered since then by Arora and Gouda [2] and Varghese [5]. For the case of masking fault-tolerant distributed resets, Afek and Gafni <ref> [6] </ref> have shown a masking fault-tolerant solution with bounded sequence numbers, under the assumption that nodes may not fail but channels may fail and, thus, messages sent on these channels may be lost.
Reference: [7] <author> T. Masuzawa. </author> <title> A fault-tolerant and self-stabilizing protocol for topology problem. </title> <booktitle> Proceedings of the Second Workshop on Self-Stabilizing Systems, </booktitle> <year> 1995. </year>
Reference-contexts: As of this writing, we are not aware of any multitolerant programs for distributed reset (or any other "repeatable and total" operation, for that matter) with bounded space complexity. We note that Masuzawa has recently presented a multitolerant solution for distributed reset <ref> [7] </ref>. His solution assumes that at most K processes fail undetectably for some fixed K and that the graph is (K+1) connected; thus masking tolerance is achieved readily in his solution. To achieve stabilizing tolerance as well, his solution assumes that sequence numbers may grow unboundedly. Outline of the paper.
Reference: [8] <author> A. Arora and M. G. Gouda. </author> <title> Closure and convergence: A foundation of fault-tolerant computing. </title> <journal> IEEE Transactions on Software Engineering, </journal> 19(11) 1015-1027, 1993. 
Reference-contexts: In Section 7, we give a brief explanation of how this reset program is used in the design of multitolerant applications. Finally, we make concluding remarks in Section 8. 2 Preliminaries In this section, we first recall a formal definition of programs, faults, and fault-tolerances <ref> [8] </ref>. We then state our assumptions about the distributed systems considered in this paper. Programs. A program is a set of variables and a finite set of actions. Each variable has a predefined domain.
Reference: [9] <author> A. Arora. </author> <title> Efficient reconfiguration of trees: A case study in the methodical design of nonmasking faulttolerance. </title> <booktitle> Proceedings of the Third International Symposium on Formal Techniques in Real Time and Fault-Tolerance, </booktitle> <year> 1994. </year> <note> Submitted to Science of Computer Programming. </note>
Reference-contexts: To achieve (1), we ensure that eventually the tree spanning all up processes is restored, so that a diffusing computation can reach all up processes. To this end, we reuse a nonmasking tolerant tree program due to Arora <ref> [9] </ref> that, in the presence of fail-stop and repair faults, maintains the graph of the parent relation of all up processes to always be a forest and, when faults stop occurring, restores the graph to be a spanning tree. The details of this program are given in Section 5.1. <p> To construct a spanning tree, we use Arora's program for tree maintenance <ref> [9] </ref>, which allows fail- stops and repairs to yield states where there are multiple, possibly unrooted, trees. We briefly describe, next, how the program deals with multiple trees and unrooted trees, and thereby eventually converges to a state where there is exactly one tree spanning all processes.
Reference: [10] <author> A. Arora and S. S. Kulkarni. </author> <title> Designing masking fault-tolerance via nonmasking fault-tolerance. </title> <booktitle> Proceedings of the Fourteenth Symposium on Reliable Distributed Systems, Bad Neuenahr, </booktitle> <volume> 14 </volume> <pages> 174-185, </pages> <year> 1995. </year> <note> Submitted to IEEE Transactions on Software Engineering. </note>
Reference-contexts: stage, we transform the nonmasking fault-tolerant program into one that is masking fault- tolerant, by restricting the actions of the former program so that a process declares completion of a distributed reset only if all up processes have participated in the last reset wave. (The interested reader is referred to <ref> [10] </ref> for the foundations of this two-stage method for adding masking tolerance.) Below, in Section 5.1. we design the nonmasking program to tolerate fail-stop and repair faults.
Reference: [11] <author> S. S. Kulkarni and A. Arora. </author> <title> Multitolerant phase synchronization. </title> <type> Manuscript, </type> <year> 1996. </year>
Reference-contexts: Also, given any pair of incarnation numbers, it is easy to determine which the new incarnation number is. We briefly describe how the application and the reset program use the incarnation number. (The interested reader is referred to <ref> [11] </ref> for a detailed discussion). When to reset the local state of a process. When process j propagates a reset wave, it resets its state iff the incarnation number of parent of j is one greater (in mod 3 arithmetic) than the incarnation number of j.
Reference: [12] <author> G. Tel. </author> <title> Structure of Distributed Algorithms. </title> <type> PhD thesis, </type> <institution> University of Utrecht; also published by Cambridge University Press, </institution> <year> 1989. </year>
Reference-contexts: The program was designed by iteratively transforming a fault-intolerant program to add tolerance to each class of faults. Our solution was distinguished by the fact that it used bounded sequence numbers. We observe that distributed reset programs belong to the class of "total programs" <ref> [12] </ref>, that contain one or more "decider" actions whose outcome depends on the computation of all processes. Other programs in this class, e.g., global state snapshots, distributed consensus, garbage collection, may be made multitolerant using a structure identical to the one we have used for distributed reset.
Reference: [13] <author> M. G. Gouda and N. Multari. </author> <title> Stabilizing communication protocols. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 40(4) </volume> <pages> 448-458, </pages> <year> 1991. </year>
References-found: 13

