URL: ftp://theory.cs.uni-bonn.de/pub/reports/cs-reports/1997/85180-cs.ps.gz
Refering-URL: http://cs.uni-bonn.de/info5/publications/CS-1997-en.html
Root-URL: http://cs.uni-bonn.de
Email: Dessmark@dna.lth.se  email: carsten@cs.uni  Lingas@dna.lth.se  email: wirtgen@cs.uni  
Title: Ultrafast Randomized Parallel Construction- and Approximation Algorithms for Spanning Forests in Dense Graphs  
Author: Anders Dessmark Carsten Dorgerloh Andrzej Lingas k Jurgen Wirtgen flfl bonn.de k 
Note: bonn.de  
Address: Box 118,S-22100 Lund, Sweden, email: Anders.-  D-53117 Bonn, Germany,  Box 118,S-22100 Lund, Sweden, email: Andrzej.-  D-53117 Bonn, Germany,  
Affiliation: University of Lund  University of Bonn  University of Lund  University of Bonn Department of Computer Science, Lund University,  Department of Computer Science, Bonn University,  Department of Computer Science, Lund University,  flfl Department of Computer Science, Bonn University,  
Abstract: We present a first randomized O(log (k) n) time and O(n+m) work CRCW-PRAM algorithm for finding a spanning forest of an undirected dense graph with n vertices. Furthermore we construct a randomized O(log log n) time and O(n log n) work CREW-PRAM algorithm for finding spanning trees in random graphs. Our algorithm is optimal with respect to time, work and space. 
Abstract-found: 1
Intro-found: 1
Reference: [AKK95] <author> S. Arora, D. Karger, and M. Karpinski. </author> <title> Polynomial time approximation schemes for dense instances of np-hard problems. </title> <booktitle> In ACM STOC, </booktitle> <volume> volume 27, </volume> <pages> pages 284-293, </pages> <year> 1995. </year>
Reference-contexts: Finally, we conclude in Section 5 with open problems. 2 Notations and Definitions Let G = (V; E) be a graph with n = jV j vertices and m = jEj edges. G is called ffi-dense, if the minimum degree ffi (G) is at least ffin (see e.g. <ref> [AKK95] </ref>). Thus, for dense graphs m = (n 2 ). A dominating set for G is a subset V 0 ae V such that for all u 2 V V 0 there is a v 2 V 0 for which fu; vg 2 E.
Reference: [Bre74] <author> Richard P. Brent. </author> <title> The parallel evaluation of general arithmetic expression. </title> <journal> Journal of the ACM, </journal> <volume> 21(2) </volume> <pages> 201-206, </pages> <year> 1974. </year>
Reference-contexts: In case G is not given in adjacency matrix representation we construct one by using O (n+m) processors in constant time. By Brent's principle <ref> [Bre74] </ref> the number of processors can be reduced to O ((n + m)= log (k) n) if we allow O (log (k) n) time.
Reference: [Col88] <author> Richard Cole. </author> <title> Parallel merge sort. </title> <journal> SIAM Journal on Computing, </journal> <volume> 17(4) </volume> <pages> 770-785, </pages> <year> 1988. </year>
Reference-contexts: Hence, the number of different vertices is in the range [log n; 2 log n] with probability at least 1 O (1=n). By using Cole's parallel merge-sort <ref> [Col88] </ref> and the standard algorithm for prefix sums the removal of duplicates can be done in O (log log n) time using O (log n) processors. Denote the set of chosen vertices by R. By Lemma 1 R forms a dominating set with error-probability bounded by an arbitrary small constant.
Reference: [ER60] <author> P. Erd-os and A. Renyi. </author> <title> On the evolution of random graphs. </title> <journal> Publ. Math. Inst. Hungar. Acad. Sci., </journal> <volume> 5 </volume> <pages> 17-61, </pages> <year> 1960. </year> <month> 8 </month>
Reference-contexts: Each graph with m edges and vertices numbered 1 through n is equally likely in this model. Its behavior is very similar to the behavior of G (n; p), for p = m ( n . Erd-os and Renyi gave in <ref> [ER60] </ref> the following threshold for connectivity in G n;m . Theorem 7 ([ER60],[McD97]) If m = 1 2 n (log n + c n ) and c n ! c as n ! 1, then Pr [G n;m is connected] ! e e c as n ! 1: It follows that
Reference: [GMV91] <author> Joseph Gil, Yossi Matias, and Uzi Vishkin. </author> <title> Towards a theory of nearly constant time parallel algorithms. </title> <journal> In IEEE FOCS, </journal> <volume> volume 32, </volume> <pages> pages 698-710, </pages> <year> 1991. </year>
Reference-contexts: The function log fl n is extremely slow increasing and for instance log fl 2 65536 = 5. Ultrafast algorithms for other problems have been achieved by Gil, Matias and Vishkin <ref> [GMV91] </ref>. They used randomization to get O (log fl n)-time CRCW-PRAM algorithms for a wide range of problems including dictionaries, loadbalancing, hashing and integer chain sorting. The paper is organized as follows. Section 2 contains some definitions and notations used throughout the paper.
Reference: [HZ96] <author> Shay Halperin and Uri Zwick. </author> <title> Optimal randomized erew pram algorithms for finding spanning forests and for other basic graph connectivity problems. </title> <booktitle> In ACM-SIAM SODA, </booktitle> <volume> volume 7, </volume> <pages> pages 438-447, </pages> <year> 1996. </year>
Reference-contexts: In the parallel setting it seems that this problem is far from being trivial. Therefore, the literature on finding spanning trees and forests in parallel has a long and varied history (see e.g. <ref> [HZ96] </ref> for a summary of PRAM algorithms for those problems). [HZ96] gave the first optimal randomized EREW-PRAM algorithm for those problems which runs in O (log n) time using O ((m + n)= log n) processors. <p> In the parallel setting it seems that this problem is far from being trivial. Therefore, the literature on finding spanning trees and forests in parallel has a long and varied history (see e.g. <ref> [HZ96] </ref> for a summary of PRAM algorithms for those problems). [HZ96] gave the first optimal randomized EREW-PRAM algorithm for those problems which runs in O (log n) time using O ((m + n)= log n) processors. <p> This process is iterated for k 1 phases after which we apply the spanning forest algorithm of <ref> [HZ96] </ref> to the remaining graph. To extract the graph induced by R we use O (log 2 n) processors that in parallel read the information from the adjacency matrix of G and write this in constant time to the adjacency matrix of G [R]. <p> retrieve the vertices colored with color k 1 using the algorithm [RS85] 4. extract the subgraph of G induced by vertices colored with k 1 using the method described before. 5. find a spanning forest T for the (extracted) subgraph induced by vertices colored with k 1 using the algorithm <ref> [HZ96] </ref> 6. mark the vertices and edges of G that are in T and store for each of them the ID of the component they belong to 7. for i = k 1; :::; 1 do each processor assigned to an edge whose one endpoint v is both marked and colored <p> It follows from straightforward calculations that the expected size of the set of vertices colored with k 1 is fi (log (k1) n): Hence, the retrieval steps 3 and 4 and the construction of T in step 5 take expected time O (log (k) n) by [RS85] and <ref> [HZ96] </ref>, respectively. Step 7 takes O (k) time and O (n 2 ) processors. By Lemma 1 and Lemma 2, the probability that T in step 8 doesn't include all vertices in G is bounded by a positive constant from below. <p> Now we extract G [R] with a CREW-PRAM in time O (1), using O (log 2 n) processors. We know by Lemma 8, that G [R] is almost surely connected. Using the EREW-PRAM algorithm of Halperin and Zwick <ref> [HZ96] </ref> we construct a spanning tree in G [R]. This takes time O (log log n) with O (log n) processors. By Lemma 1 it remains to add the edges of the spanning tree which have one endpoint in V R and the other in R.
Reference: [KR88] <author> Richard M. Karp and Vijaya Ramachandran. </author> <title> A survey of parallel algorithms for shared-memory machines. </title> <note> Research Report UCB/CSD 88/408, </note> <institution> University of California, Berkeley, </institution> <year> 1988. </year>
Reference-contexts: Furthermore, each processor of a randomized PRAM has access to a random number generator which returns random 2 numbers of log n bits in constant time. More details of the PRAM models can be found, e.g., in the survey by Karp and Ramachandran <ref> [KR88] </ref>. 3 A CRCW-PRAM Algorithm for Finding Spanning Trees In this section we show how to find a spanning forest in a ffi-dense graph with O ((n + m)= log (k) n) processors on a randomized arbitrary CRCW-PRAM in O (log (k) n) time, where k 2 O (1) can be
Reference: [McD97] <author> C. McDiarmid. </author> <title> Probability. </title> <editor> In L. Beineke and R. Wilson, editors, </editor> <title> Graph Connections, </title> <booktitle> chapter 13, </booktitle> <pages> pages 194-207. </pages> <publisher> Oxford Science Publications, </publisher> <year> 1997. </year>
Reference: [MR95] <author> Rajeev Motwani and Prabhakar Raghavan. </author> <title> Randomized Algorithms. </title> <publisher> Cam-bridge University Press, </publisher> <year> 1995. </year>
Reference-contexts: Then E [X v ] c log n, where c = ffifi. Now we bound the probability that X v deviates far from its expectation by applying the Chernoff bound (see e.g. <ref> [MR95] </ref>, Theorem 4.2).
Reference: [RS85] <author> L. Rudolph and W. Steiger. </author> <title> Subset selection in parallel. </title> <booktitle> In International Conference on Parallel Processing, </booktitle> <pages> pages 11-14, </pages> <year> 1985. </year> <month> 9 </month>
Reference-contexts: Choose randomly O (log n i1 of them (using the above mentioned method) and recolor them with the color i. 3. retrieve the vertices colored with color k 1 using the algorithm <ref> [RS85] </ref> 4. extract the subgraph of G induced by vertices colored with k 1 using the method described before. 5. find a spanning forest T for the (extracted) subgraph induced by vertices colored with k 1 using the algorithm [HZ96] 6. mark the vertices and edges of G that are in <p> It follows from straightforward calculations that the expected size of the set of vertices colored with k 1 is fi (log (k1) n): Hence, the retrieval steps 3 and 4 and the construction of T in step 5 take expected time O (log (k) n) by <ref> [RS85] </ref> and [HZ96], respectively. Step 7 takes O (k) time and O (n 2 ) processors. By Lemma 1 and Lemma 2, the probability that T in step 8 doesn't include all vertices in G is bounded by a positive constant from below.
References-found: 10

