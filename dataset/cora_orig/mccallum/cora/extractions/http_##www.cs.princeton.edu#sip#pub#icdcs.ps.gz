URL: http://www.cs.princeton.edu/sip/pub/icdcs.ps.gz
Refering-URL: http://www.cs.princeton.edu/sip/pub/icdcs.html
Root-URL: http://www.cs.princeton.edu
Email: balfanz@cs.princeton.edu  li.gong@sun.com  
Title: Experience with Secure Multi-Processing in Java  
Author: Dirk Balfanz Li Gong 
Date: September 29, 1997  
Affiliation: Princeton University  JavaSoft, Sun Microsystems, Inc.  
Abstract: As Java TM is the preferred platform for the deployment of network computers, it is appealing to run multiple applications on a single Java desktop. We experimented with using the Java platform as a multi-processing, multi-user environment. Although the Java Virtual Machine (JVM) is not inherently a single-application design, we have found that the implementation of the Java Development Kit (JDK) often implicitly assumes that the Java Virtual Machine runs exactly one application at any one time. In this paper, we report the limitations we encountered and propose improvements to several aspects of the Java architecture, including its security features. We have implemented all the proposed changes in a prototype based on the in-house beta version of JDK 1.2. Our prototype uses a Bourne shell-like command line tool to launch multiple applications (such as Ap-pletviewer) within one JVM. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. Fiuchynski, D. Becker, S. Eggers, and C. Chambers. </author> <title> Extensibility, Safety, and Performance in the SPIN Operating System. </title> <booktitle> In Proceedings of the 15th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 251-266, </pages> <address> Colorado, </address> <month> December </month> <year> 1995. </year> <note> Published as ACM Operating System Review 29(5) 251-266, </note> <year> 1995. </year>
Reference-contexts: Even if the JVM runs as a process within another O/S, we should be interested in running multiple applications in one JVM. Single address-space operating system is a focal point of current research in operating systems <ref> [1, 11, 8] </ref>. Using software-based protection instead of hardware-assisted protection through multiple address spaces, these systems promise superior performance [8, 12]. Many factors contribute to this performance gain. <p> Many of today's research operating systems either use a single address space or load code into the kernel's address space to increase performance and enhance functionality of applications <ref> [1, 8] </ref>. As far as security is concerned, they use either a type-safe language [1] or provide other techniques such as proof carrying code [8] to achieve basic security properties such as memory protection. <p> Many of today's research operating systems either use a single address space or load code into the kernel's address space to increase performance and enhance functionality of applications [1, 8]. As far as security is concerned, they use either a type-safe language <ref> [1] </ref> or provide other techniques such as proof carrying code [8] to achieve basic security properties such as memory protection. However, few of those systems can at this point go beyond memory protection and provide secure services [12].
Reference: [2] <author> D. Dean. </author> <title> The Security of Static Typing with Dynamic Linking. </title> <booktitle> In Proceedings of the 4th ACM Conference on Computer and Communications Security, </booktitle> <address> Zurich, Switzerland, </address> <month> April </month> <year> 1997. </year>
Reference-contexts: Moreover, in our multi-processing environment, it is very appealing to use shared object as an inter-application communication mechanism. However, such sharing of objects between different applications in different name spaces is still a delicate task and its impact on the correctness of the Java type system needs more research <ref> [2] </ref>. Finally, it appears worthwhile to further investigate the implications of reloading certain system classes. For example, there might be a hidden assumption that there is only one copy of certain classes such as Class and String.
Reference: [3] <author> L. Gong. </author> <title> Java Security: Present and Near Future. </title> <journal> IEEE Micro, </journal> <volume> 17(3) </volume> <pages> 14-19, </pages> <month> May/June </month> <year> 1997. </year>
Reference-contexts: Note that all callbacks are called from a single event dispatcher thread. 3.3 Security Policies Since Java has specifically been designed to execute possibly untrusted mobile code, great care has been taken to specify and implement a security model <ref> [3] </ref>. The Java class libraries are written in such a way that all sensitive operations call into a centralized object, the security manager, to check whether the callee should be allowed to invoke this operation. <p> In comparison, we focussed on the latter while not paying particular to performance tuning. Recent advance in Java security has evolved from the original restricted sandbox model to a policy-based, easily configurable, fine-grained access control model <ref> [3, 4] </ref>. However, security policy is still limited to deal with code sources and not with users. This is because JVM as it stands now is normally used in a single-user environment. Our work here expands into a multi-user environment, and solves the new problems we encountered.
Reference: [4] <author> L. Gong, M. Mueller, H. Prafullchandra, and R. Schemers. </author> <title> Going Beyond the Sandbox: An Overview of the New Security Architecture in the Java TM Development Kit 1.2. </title> <booktitle> In Proceedings of the USENIX Symposium on Internet Technologies and Systems, </booktitle> <address> Monterey, California, </address> <month> Decem-ber </month> <year> 1997. </year>
Reference-contexts: This paper does not necessarily reflect the official opinions of Princeton University or Sun Microsystems. The discussion does not bind Sun Microsystems to any particular products or features. and the network origin (i.e., network location and address) of the mobile code <ref> [4] </ref>. When multiple applications run in the same JVM, we need to provide a security framework that accommodates the need to both protect the Java system from (potentially malicious) mobile code and protect (potentially mutually hostile) applications from each other. <p> If the call was initiated by an applet, the operation is forbidden. Otherwise it is allowed. In recent versions of the JDK and other Java platforms, this approach has evolved considerably <ref> [4] </ref>. The security manager no longer distinguishes between remote or local code, but follows in its decisions a policy that can be specified by the user in terms of the code source. <p> is that extend the range of the security policy so that (1) the security policy can grant permissions to a particular user and (2) the policy can also grant certain code sources the privilege to exercise the permissions of the running user. 7 We used Sun's JDK 1.2 security framework <ref> [4] </ref>, and introduced a new kind of user permission and then granting that permission to local applications. <p> In comparison, we focussed on the latter while not paying particular to performance tuning. Recent advance in Java security has evolved from the original restricted sandbox model to a policy-based, easily configurable, fine-grained access control model <ref> [3, 4] </ref>. However, security policy is still limited to deal with code sources and not with users. This is because JVM as it stands now is normally used in a single-user environment. Our work here expands into a multi-user environment, and solves the new problems we encountered.
Reference: [5] <author> J. Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Menlo Park, California, </address> <month> August </month> <year> 1996. </year>
Reference-contexts: 1 Introduction A Java Virtual Machine TM (JVM) <ref> [5, 7] </ref> is typically used to run exactly one Java application at any one time, where an application can be a Web browser and Java applets are fetched as part of Web pages and are executed within the browser.
Reference: [6] <author> B. W. Lampson and D. D. Redell. </author> <title> Experience with Processes and Monitors in Mesa. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 105-117, </pages> <month> April </month> <year> 1980. </year>
Reference-contexts: For example, the operating system Pilot [9] used a safe language <ref> [6] </ref> in a single address space to provide security without a kernel. Various approaches of software-based protection has recently been reconsidered in the context of Java [12].
Reference: [7] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <address> Menlo Park, California, </address> <year> 1997. </year>
Reference-contexts: 1 Introduction A Java Virtual Machine TM (JVM) <ref> [5, 7] </ref> is typically used to run exactly one Java application at any one time, where an application can be a Web browser and Java applets are fetched as part of Web pages and are executed within the browser.
Reference: [8] <author> G.C. Necula and P. Lee. </author> <title> Safe Kernel Extensions Without Run-Time Checking. </title> <booktitle> In Proceedings of the 2nd USENIX Symposium on Operating Systems Design and Implementation (OSDI), </booktitle> <pages> pages 229-243, </pages> <address> Seattle, Washington, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Even if the JVM runs as a process within another O/S, we should be interested in running multiple applications in one JVM. Single address-space operating system is a focal point of current research in operating systems <ref> [1, 11, 8] </ref>. Using software-based protection instead of hardware-assisted protection through multiple address spaces, these systems promise superior performance [8, 12]. Many factors contribute to this performance gain. <p> Single address-space operating system is a focal point of current research in operating systems [1, 11, 8]. Using software-based protection instead of hardware-assisted protection through multiple address spaces, these systems promise superior performance <ref> [8, 12] </ref>. Many factors contribute to this performance gain. Context switching, for example, is much less expensive if performed within one address space, because caches need not be cleared, page-table pointers don't have to be adjusted, and so on. Inter-process communication is also much cheaper in a single address space. <p> Many of today's research operating systems either use a single address space or load code into the kernel's address space to increase performance and enhance functionality of applications <ref> [1, 8] </ref>. As far as security is concerned, they use either a type-safe language [1] or provide other techniques such as proof carrying code [8] to achieve basic security properties such as memory protection. <p> As far as security is concerned, they use either a type-safe language [1] or provide other techniques such as proof carrying code <ref> [8] </ref> to achieve basic security properties such as memory protection. However, few of those systems can at this point go beyond memory protection and provide secure services [12]. In comparison, we focussed on the latter while not paying particular to performance tuning.
Reference: [9] <author> D. D. Redell, Y. K. Dalal, T. R. Horsley, H. C. Lauer, W. C. Lynch, P. R. McJones, H. G. Mur-ray, and Stephen C. Purcell. </author> <title> Pilot: An Operating System for a Personal Computer. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 81-92, </pages> <month> April </month> <year> 1980. </year>
Reference-contexts: For example, the operating system Pilot <ref> [9] </ref> used a safe language [6] in a single address space to provide security without a kernel. Various approaches of software-based protection has recently been reconsidered in the context of Java [12].
Reference: [10] <author> S. Ritchie. </author> <title> Systems Programming in Java. </title> <journal> IEEE Micro, </journal> <volume> 17(3) </volume> <pages> 30-35, </pages> <month> May/June </month> <year> 1997. </year>
Reference-contexts: Moreover, JVM sometimes does not run as a process of an O/S, but run directly on the bare hardware (e.g., JavaOS <ref> [10] </ref>). Thus, there may not always be an underlying operating system to host multiple JVMs.
Reference: [11] <author> M. I. Seltzer, Y. Endo, C. Small, and K. A. Smith. </author> <title> Dealing with Disaster: Surviving Misbehaved Kernel Extensions. </title> <booktitle> In Proceedings of the 2nd USENIX Symposium on Operating Systems Design and Implementation, </booktitle> <pages> pages 213-227, </pages> <address> Seat-tle, Washington, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Even if the JVM runs as a process within another O/S, we should be interested in running multiple applications in one JVM. Single address-space operating system is a focal point of current research in operating systems <ref> [1, 11, 8] </ref>. Using software-based protection instead of hardware-assisted protection through multiple address spaces, these systems promise superior performance [8, 12]. Many factors contribute to this performance gain.
Reference: [12] <author> D. S. Wallach, D. Balfanz, D. Dean, and E. W. Felten. </author> <title> Extensible Security Architectures for Java. </title> <booktitle> In Proceedings of the 16th ACM Symposium on Operating Systems Principles, </booktitle> <address> Saint-Malo, France, </address> <month> October </month> <year> 1997. </year>
Reference-contexts: Single address-space operating system is a focal point of current research in operating systems [1, 11, 8]. Using software-based protection instead of hardware-assisted protection through multiple address spaces, these systems promise superior performance <ref> [8, 12] </ref>. Many factors contribute to this performance gain. Context switching, for example, is much less expensive if performed within one address space, because caches need not be cleared, page-table pointers don't have to be adjusted, and so on. Inter-process communication is also much cheaper in a single address space. <p> To be more specific, we borrow a 8 application's thread group delivers the events. technique that has previously been employed to provide differently trusted code with a different view of what the system classes are <ref> [12] </ref>. In our implementation, every application gets its own copy of the System class. We use a special class loader to re-load and re-define the System class, albeit from the same class material. <p> For example, the operating system Pilot [9] used a safe language [6] in a single address space to provide security without a kernel. Various approaches of software-based protection has recently been reconsidered in the context of Java <ref> [12] </ref>. Our contribution is that our multi-processing Java environment must deal with distributed computing with mobile code and needs to explicitly address both code source-based and user-based security policies. <p> As far as security is concerned, they use either a type-safe language [1] or provide other techniques such as proof carrying code [8] to achieve basic security properties such as memory protection. However, few of those systems can at this point go beyond memory protection and provide secure services <ref> [12] </ref>. In comparison, we focussed on the latter while not paying particular to performance tuning. Recent advance in Java security has evolved from the original restricted sandbox model to a policy-based, easily configurable, fine-grained access control model [3, 4].
Reference: [13] <author> A. Wollrath, J. Waldo, and R. </author> <title> Riggs. </title> <journal> Java-Centric Distributed Computing. IEEE Micro, </journal> <volume> 17(3) </volume> <pages> 44-53, </pages> <month> May/June </month> <year> 1997. </year> <month> 12 </month>
Reference-contexts: Other applications such as downloadable stubs for remote messaging <ref> [13] </ref> or frameworks for push technology increasingly use this ability to execute mobile Java code.
References-found: 13

