URL: ftp://ftp.cs.huji.ac.il/users/transis/thesis/esti-msc.ps
Refering-URL: http://www.cs.huji.ac.il/labs/transis/thesis.html
Root-URL: http://www.cs.huji.ac.il
Title: Dynamic Voting for Consistent Primary Components  
Author: Prof. Danny Dolev 
Degree: A thesis submitted in fulfillment of the requirements for the degree of Master of Science by Esti Yeger Lotem supervised by  
Date: December 31, 1996  
Address: Jerusalem, Israel.  
Affiliation: Institute of Computer Science The Hebrew University of Jerusalem  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> P. Alsberg and J. Day. </author> <title> A Principle for Resilient Sharing of Distributed Resources. </title> <booktitle> In Proceedings of the Second International Conference on Software engineering, </booktitle> <pages> pages 562-570, </pages> <month> Oct </month> <year> 1976. </year>
Reference-contexts: These methods include the primary site approach <ref> [1] </ref>, which designates a specific site as a primary site and allows operations only within the component that contains this site, and static voting methods [32]. The comparisons reviewed below are divided into stochastic modelings [19, 20, 22], simulations [26], and empirical data [6].
Reference: [2] <author> Y. Amir. </author> <title> Replication Using Group Communication Over a Dynamic Network. </title> <type> PhD thesis, </type> <institution> Institute of Computer Science, The Hebrew University of Jerusalem, Jerusalem, Israel, </institution> <year> 1995. </year>
Reference-contexts: It may be incorporated in many distributed applications that make progress in a primary component, e.g. replication algorithms [24, 12], transaction management [23], and even infrastructure systems like the ISIS toolkit [7]. If a failure occurs in the course of the protocol, some previously suggested protocols (e.g. <ref> [22, 2] </ref>) block until all the members of the last quorum become reconnected, while our protocol, in order to make progress, requires only a majority of the members that attempted to form the last quorum to become reconnected. <p> Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in <ref> [11, 18, 26, 22, 12, 2] </ref>. Each process is equipped with an underlying membership module, e.g. [3, 5, 15]. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected. <p> This is guaranteed until a site resolves the ambiguous situation. 8.4.2 Algorithms That Block While our protocol considers two states in order to bridge the gap between two different knowledge levels, the protocols described below block until the resolution of the last quorum. The protocols in <ref> [17, 22, 2] </ref> avoid inconsistencies by running Two Phase Commit (2PC) protocols ([17, 22]), or similar mechanisms ([2]). The disadvantage of these mechanisms is that there are situations in which the system is blocked until all the members of the last quorum recover and reconnect. <p> Therefore, when a coordinator crashes or disconnects in the middle of an update, the system remains blocked until the coordinator recovers. The dynamic voting protocol in <ref> [2] </ref> uses a similar mechanism. This paper presents a replication system in which replication servers communicate via a group communication subsystem (Tran-sis [4]). Each server maintains a private copy of the database. Updates are allowed only within the primary component, which consists of a subset of the servers.
Reference: [3] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. </author> <title> Membership Algorithms for Multicast Communication Groups. </title> <booktitle> In Intl. Workshop on Distributed Algorithms proceedings (WDAG-6), (LNCS, </booktitle> <volume> 647), number 6, </volume> <pages> pages 292-312, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in [11, 18, 26, 22, 12, 2]. Each process is equipped with an underlying membership module, e.g. <ref> [3, 5, 15] </ref>. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected. Membership changes are reported to the process via special membership messages.
Reference: [4] <author> Y. Amir, D. Dolev, S. Kramer, and D. Malki. Transis: </author> <title> A Communication Sub-System for High Availability. </title> <booktitle> In FTCS conference, </booktitle> <volume> number 22, </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: Therefore, when a coordinator crashes or disconnects in the middle of an update, the system remains blocked until the coordinator recovers. The dynamic voting protocol in [2] uses a similar mechanism. This paper presents a replication system in which replication servers communicate via a group communication subsystem (Tran-sis <ref> [4] </ref>). Each server maintains a private copy of the database. Updates are allowed only within the primary component, which consists of a subset of the servers.
Reference: [5] <author> Y. Amir, L. E. Moser, P. M. Melliar-Smith, D. A. Agarwal, and P. Ciarfella. </author> <title> Fast Message Ordering and Membership using a Logical Token-Passing Ring. </title> <booktitle> In International Conference on Distributed Computing Systems, </booktitle> <volume> number 13, </volume> <pages> pages 551-560, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in [11, 18, 26, 22, 12, 2]. Each process is equipped with an underlying membership module, e.g. <ref> [3, 5, 15] </ref>. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected. Membership changes are reported to the process via special membership messages.
Reference: [6] <author> Y. Amir and A. Wool. </author> <title> Evaluating Quorum Systems over the Internet. </title> <booktitle> In The Fault-Tolerant Computing Symposium(FTCS), </booktitle> <pages> pages 26-35, </pages> <month> June </month> <year> 1996. </year>
Reference-contexts: Thus, each newly formed quorum must contain a majority of the previous one, but not necessarily a majority of the sites. Stochastic models analysis [22], simulations [26], and empirical results <ref> [6] </ref> show that dynamic voting increases system availability, by increasing the probability that a primary component exists. In fact, the results in [6] show that dynamic voting is more available than any other paradigm for maintaining a primary component. <p> Stochastic models analysis [22], simulations [26], and empirical results <ref> [6] </ref> show that dynamic voting increases system availability, by increasing the probability that a primary component exists. In fact, the results in [6] show that dynamic voting is more available than any other paradigm for maintaining a primary component. Another important benefit of the dynamic voting paradigm is in its flexibility to support a dynamically changing set of processes. <p> The comparisons reviewed below are divided into stochastic modelings [19, 20, 22], simulations [26], and empirical data <ref> [6] </ref>. All comparisons result in favor of the dynamic voting paradigm. <p> The simulations assume three and four 38 copies per object. The results are that dynamic voting outperformed both static majority voting and dynamic voting without linear voting in all cases examined. <ref> [6] </ref> presents an empirical approach to the evaluation of quorum systems: The authors collected 6 months' connectivity and operability data, of a system consisting of fourteen real computers using a wide area group communication protocol. Their system spanned two geographical sites and three different Internet segments. <p> Although the above scenarios may seem rare, they do happen in real distributed environments, as proved in <ref> [6] </ref>. Notice that with our protocol, the system can make progress in similar cases when a majority of the last quorum becomes connected. 8.4.3 Algorithms That Require A Cold Start The ISIS and Horus systems are asynchronous group communication environments that provide a membership service to processes exploiting it.
Reference: [7] <author> K. Birman and R. V. Renesse. </author> <title> Reliable Distributed Computing with the Isis Toolkit. </title> <publisher> IEEE Computer Society Press, </publisher> <year> 1994. </year>
Reference-contexts: 1 Introduction Numerous fault tolerant distributed systems, e.g. ISIS <ref> [7] </ref>, use the primary component 1 paradigm to allow a subset of the processes to function when failures occur. A majority (or quorum) of the processes is usually chosen to be the primary component in the system. <p> Our protocol's communication and memory requirements are small, and the protocol is simple to implement. It may be incorporated in many distributed applications that make progress in a primary component, e.g. replication algorithms [24, 12], transaction management [23], and even infrastructure systems like the ISIS toolkit <ref> [7] </ref>. <p> This improvement is considered part of the dynamic voting paradigm from here on. 8.2 The Primary Component Model The Primary Component Model was developed to confront the subtleties that arise in failure prone distributed systems, as part of the Virtual Synchrony Paradigm, initially proposed by the ISIS system <ref> [7] </ref>. The model defines a primary component for a group of processes as a subset of the group that can make decisions on behalf of the group as a whole. Thus progress in the group is possible, to some extent, despite failures that may encounter some of the group members.
Reference: [8] <author> T. Chandra, V. Hadzilacos, S. Toueg, and B. Charron-Bost. </author> <title> On the Impossibility of Group Membership. </title> <booktitle> In ACM Symp. on Prin. of Distributed Computing (PODC), </booktitle> <pages> pages 322-330, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: As shown in <ref> [8] </ref>, it is impossible to reach agreement upon the current membership in an asynchronous system without failure detection. Consequently, agreement on the primary component in the network is also impossible. Therefore, any protocol for this problem must assume some (not necessarily perfect) failure detection mechanism.
Reference: [9] <author> T. D. Chandra, V. Hadzilacos, and S. Toueg. </author> <title> The Weakest Failure Detector for Solving Consensus. </title> <booktitle> In ACM Symp. on Prin. of Distributed Computing (PODC), </booktitle> <pages> pages 147-158, </pages> <year> 1992. </year>
Reference-contexts: The maintenance of the primary component is based on the Chan-dra and Toueg's three phase consensus protocol [10], that solves consensus in an asynchronous environment extended with a weak failure detector. The primary component members use the consensus protocol to agree on the component's membership. As proved in <ref> [9] </ref>, consensus is solvable in such systems when at most a minority of the processes in the system may crash. Hence in Phoenix a majority of the last primary component agrees on the membership of the new primary component. This way Phoenix easily employs the dynamic voting paradigm.
Reference: [10] <author> T. D. Chandra and S. Toueg. </author> <title> Unreliable Failure Detectors for Reliable Distributed Systems. </title> <journal> Journal of ACM, </journal> <volume> 43(2) </volume> <pages> 225-267, </pages> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: A similar idea was suggested in [25], where Chandra and Toueg's three phase consensus protocol <ref> [10] </ref> is employed. The status of past quorums is resolved before the installation of new ones. When a majority of the previous quorum reconnects, at least five communication rounds are needed in order to form a new quorum. <p> The maintenance of the primary component is based on the Chan-dra and Toueg's three phase consensus protocol <ref> [10] </ref>, that solves consensus in an asynchronous environment extended with a weak failure detector. The primary component members use the consensus protocol to agree on the component's membership.
Reference: [11] <author> D. Davcev and W. Burkhard. </author> <title> Consistency and Recovery Control for Replicated Files. </title> <booktitle> In ACM Symp. on Operating Systems Principles, </booktitle> <volume> number 10, </volume> <pages> pages 87-96, </pages> <year> 1985. </year>
Reference-contexts: When partitions occur, such knowledge differences are inevitable: Once a site detaches, it is impossible for other sites to know whether it received a specific message before its detachment, or not. Some past protocols (e.g. <ref> [11, 26, 12] </ref>) lead to inconsistent results in such cases, as demonstrated by the following typical scenario: * The systems consists of five processes: a; b; c; d and e. <p> Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in <ref> [11, 18, 26, 22, 12, 2] </ref>. Each process is equipped with an underlying membership module, e.g. [3, 5, 15]. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected. <p> 8.5 discusses the restriction on the minimum quorum size employed in a previous paper, and compares it with our restriction. 8.1 The Dynamic Voting Paradigm The dynamic voting paradigm was first presented as a consistency control tool for distributed replicated database systems prone to network partitions, sites' crashes and recoveries <ref> [11] </ref>. <p> These results prove the advantages of the dynamic voting paradigm over static voting schemes and other methods for preserving consistency of replicated data. 8.4 Previously Suggested Dynamic Voting Protocols: Due to its merits and following <ref> [11] </ref>, many protocols that implement the dynamic voting paradigm were suggested, e.g. [18, 19, 20, 26, 22, 12]. This section reviews several of these protocols. <p> divided into four categories: Algorithms that are incorrect, algorithms that require a cold start, algorithms that block in more cases than our protocol blocks, and algorithms that require excessive communication. 8.4.1 Incorrect Algorithms This section contains a thorough examination of protocols that may lead to inconsistent states in the system <ref> [11, 19, 20, 26, 12] </ref>. These protocols are based on the first paper describing dynamic voting [11], presented in the data replication literature. The section begins with a description of the scheme suggested by [11], showing it leads to inconsistencies. <p> These protocols are based on the first paper describing dynamic voting <ref> [11] </ref>, presented in the data replication literature. The section begins with a description of the scheme suggested by [11], showing it leads to inconsistencies. The protocols in [19, 20, 26] closely resemble this scheme, hence only an overview of these protocols is provided. <p> These protocols are based on the first paper describing dynamic voting <ref> [11] </ref>, presented in the data replication literature. The section begins with a description of the scheme suggested by [11], showing it leads to inconsistencies. The protocols in [19, 20, 26] closely resemble this scheme, hence only an overview of these protocols is provided. The section ends with the description of [12], which slightly differs from the rest of the protocols. The scheme presented in [11] assumes the following communication <p> the scheme suggested by <ref> [11] </ref>, showing it leads to inconsistencies. The protocols in [19, 20, 26] closely resemble this scheme, hence only an overview of these protocols is provided. The section ends with the description of [12], which slightly differs from the rest of the protocols. The scheme presented in [11] assumes the following communication model: * Sites may fail and the network may partition; * Messages are not corrupted or spontaneously created; * Each site's messages arrive at other sites in FIFO order; * Each site acks the receipt of a message within a fixed time (timeout mechanism); * If <p> Being a majority of this component, they too consider themselves to be the majority component, and can also execute new updates. The existence of two majority components can lead to inconsistencies. The protocols in [18, 19, 20, 26] present extensions to the protocol presented in <ref> [11] </ref>. One contribution, presented in [18, 20, 26], is the extension of dynamic voting to dynamic linear voting. Furthermore, the communication model assumed in these papers is weaker than the communication model specified above.
Reference: [12] <author> A. El Abbadi and S. Dani. </author> <title> A Dynamic Accessibility Protocol for Replicated Databases. </title> <journal> Data and Knowledge Engineering, </journal> (6):319-332, 1991. 
Reference-contexts: Our protocol's communication and memory requirements are small, and the protocol is simple to implement. It may be incorporated in many distributed applications that make progress in a primary component, e.g. replication algorithms <ref> [24, 12] </ref>, transaction management [23], and even infrastructure systems like the ISIS toolkit [7]. <p> When partitions occur, such knowledge differences are inevitable: Once a site detaches, it is impossible for other sites to know whether it received a specific message before its detachment, or not. Some past protocols (e.g. <ref> [11, 26, 12] </ref>) lead to inconsistent results in such cases, as demonstrated by the following typical scenario: * The systems consists of five processes: a; b; c; d and e. <p> Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in <ref> [11, 18, 26, 22, 12, 2] </ref>. Each process is equipped with an underlying membership module, e.g. [3, 5, 15]. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected. <p> These results prove the advantages of the dynamic voting paradigm over static voting schemes and other methods for preserving consistency of replicated data. 8.4 Previously Suggested Dynamic Voting Protocols: Due to its merits and following [11], many protocols that implement the dynamic voting paradigm were suggested, e.g. <ref> [18, 19, 20, 26, 22, 12] </ref>. This section reviews several of these protocols. <p> divided into four categories: Algorithms that are incorrect, algorithms that require a cold start, algorithms that block in more cases than our protocol blocks, and algorithms that require excessive communication. 8.4.1 Incorrect Algorithms This section contains a thorough examination of protocols that may lead to inconsistent states in the system <ref> [11, 19, 20, 26, 12] </ref>. These protocols are based on the first paper describing dynamic voting [11], presented in the data replication literature. The section begins with a description of the scheme suggested by [11], showing it leads to inconsistencies. <p> The section begins with a description of the scheme suggested by [11], showing it leads to inconsistencies. The protocols in [19, 20, 26] closely resemble this scheme, hence only an overview of these protocols is provided. The section ends with the description of <ref> [12] </ref>, which slightly differs from the rest of the protocols. <p> Nevertheless, the protocols described in [19, 20, 26] do not overcome the problematic scenario depicted above, and, therefore, can still lead to inconsistency in the system. The protocol in <ref> [12] </ref> presents another scheme for data replication. This scheme is a combination 41 of the dynamic voting paradigm and the views approach [13, 14]. In the views approach, each site s maintains a set of sites called its view, with which it can communicate.
Reference: [13] <author> A. El Abbadi, D. Skeen, and F. Christian. </author> <title> An Efficient Fault-Tolerant Algorithm for Replicated Data Management. </title> <booktitle> In ACM SIGACT-SIGMOD Symp. on Prin. of Database Systems, </booktitle> <pages> pages 215-229, </pages> <month> March </month> <year> 1985. </year>
Reference-contexts: The protocol in [12] presents another scheme for data replication. This scheme is a combination 41 of the dynamic voting paradigm and the views approach <ref> [13, 14] </ref>. In the views approach, each site s maintains a set of sites called its view, with which it can communicate. In the integrated approach, the concept of views is used to reduce the overall cost of executing operations.
Reference: [14] <author> A. El Abbadi and S. Toueg. </author> <title> Maintaining Availability in Partitioned Replicated Databases. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 14(2) </volume> <pages> 264-290, </pages> <month> June </month> <year> 1989. </year> <month> 46 </month>
Reference-contexts: The protocol in [12] presents another scheme for data replication. This scheme is a combination 41 of the dynamic voting paradigm and the views approach <ref> [13, 14] </ref>. In the views approach, each site s maintains a set of sites called its view, with which it can communicate. In the integrated approach, the concept of views is used to reduce the overall cost of executing operations.
Reference: [15] <author> P. D. Ezhilchelvan, A. Macedo, and S. K. Shrivastava. Newtop: </author> <title> a Fault Tolerant Group Communication Protocol. </title> <booktitle> In International Conference on Distributed Computing Systems, </booktitle> <volume> number 15, </volume> <pages> pages 296-306. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in [11, 18, 26, 22, 12, 2]. Each process is equipped with an underlying membership module, e.g. <ref> [3, 5, 15] </ref>. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected. Membership changes are reported to the process via special membership messages.
Reference: [16] <author> R. Friedman and R. V. Renesse. </author> <title> Strong and Weak Virtual Synchrony in Horus. </title> <type> TR 95-1537, </type> <institution> dept. of Computer Science, Cornell University, </institution> <month> August </month> <year> 1995. </year>
Reference-contexts: As mentioned before, the problem with a conservative algorithm is that it limits the availability. When no primary component exists for a certain group, activity for this group blocks either completely (e.g. ISIS), or partially (e.g. Horus <ref> [16] </ref>), depending on the system. Therefore, the primary component maintenance algorithm must offer great availability. For this reason, many primary component maintenance algorithms employ the dynamic voting paradigm. A new primary component must contain a majority of the processes that were members of the former primary component.
Reference: [17] <author> M. Herlihy. </author> <title> A Quorum-Consensus Replication Method for Abstract Data Types. </title> <journal> ACM Trans. Comp. Syst., </journal> <volume> 4(1) </volume> <pages> 32-53, </pages> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: This is guaranteed until a site resolves the ambiguous situation. 8.4.2 Algorithms That Block While our protocol considers two states in order to bridge the gap between two different knowledge levels, the protocols described below block until the resolution of the last quorum. The protocols in <ref> [17, 22, 2] </ref> avoid inconsistencies by running Two Phase Commit (2PC) protocols ([17, 22]), or similar mechanisms ([2]). The disadvantage of these mechanisms is that there are situations in which the system is blocked until all the members of the last quorum recover and reconnect.
Reference: [18] <author> S. Jajodia. </author> <title> Managing Replicated Files in Partitioned Distributed Database Systems. </title> <booktitle> In IEEE Int'l. Conf. on Data Engineering, </booktitle> <volume> number 3, </volume> <pages> pages 412-418, </pages> <year> 1987. </year>
Reference-contexts: Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in <ref> [11, 18, 26, 22, 12, 2] </ref>. Each process is equipped with an underlying membership module, e.g. [3, 5, 15]. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected. <p> Dynamic linear voting, first presented in <ref> [18] </ref>, optimizes the above with the following mechanism to break ties between groups of equal size: A linear order, L, is imposed on all the potential processes in the system, e.g. L can be the lexicographical order over an infinite name space. <p> Moreover, whenever an operation is successfully executed, the suitable quorum dynamically changes to consist the set of accessible sites, thus adjusting the quorum to the current system configuration. A widely accepted improvement to the dynamic voting paradigm, named dynamic linear voting, was first presented in <ref> [18] </ref>. In this scheme, a linear ordering is imposed on all sites in the system. This ordering is used for breaking ties in cases where exactly half of the last quorum is accessible. <p> These results prove the advantages of the dynamic voting paradigm over static voting schemes and other methods for preserving consistency of replicated data. 8.4 Previously Suggested Dynamic Voting Protocols: Due to its merits and following [11], many protocols that implement the dynamic voting paradigm were suggested, e.g. <ref> [18, 19, 20, 26, 22, 12] </ref>. This section reviews several of these protocols. <p> Being a majority of this component, they too consider themselves to be the majority component, and can also execute new updates. The existence of two majority components can lead to inconsistencies. The protocols in <ref> [18, 19, 20, 26] </ref> present extensions to the protocol presented in [11]. One contribution, presented in [18, 20, 26], is the extension of dynamic voting to dynamic linear voting. Furthermore, the communication model assumed in these papers is weaker than the communication model specified above. <p> The existence of two majority components can lead to inconsistencies. The protocols in [18, 19, 20, 26] present extensions to the protocol presented in [11]. One contribution, presented in <ref> [18, 20, 26] </ref>, is the extension of dynamic voting to dynamic linear voting. Furthermore, the communication model assumed in these papers is weaker than the communication model specified above.
Reference: [19] <author> S. Jajodia and D. Mutchler. </author> <title> Dynamic Voting. </title> <booktitle> In ACM SIGMOD Int'l Conf. on Management of Data, </booktitle> <volume> number 3, </volume> <pages> pages 227-238, </pages> <year> 1987. </year>
Reference-contexts: These methods include the primary site approach [1], which designates a specific site as a primary site and allows operations only within the component that contains this site, and static voting methods [32]. The comparisons reviewed below are divided into stochastic modelings <ref> [19, 20, 22] </ref>, simulations [26], and empirical data [6]. All comparisons result in favor of the dynamic voting paradigm. The stochastic models presented in [19, 20, 22] share the following assumptions: * Communication links between sites are infallible. * Sites failures form independent Poisson processes, as well as sites' repairs. * <p> The comparisons reviewed below are divided into stochastic modelings <ref> [19, 20, 22] </ref>, simulations [26], and empirical data [6]. All comparisons result in favor of the dynamic voting paradigm. The stochastic models presented in [19, 20, 22] share the following assumptions: * Communication links between sites are infallible. * Sites failures form independent Poisson processes, as well as sites' repairs. * Updates are instantaneous and arrive frequently. [22] also provides a stochastic link model in which the first two assumptions are replaced by the following <p> These results prove the advantages of the dynamic voting paradigm over static voting schemes and other methods for preserving consistency of replicated data. 8.4 Previously Suggested Dynamic Voting Protocols: Due to its merits and following [11], many protocols that implement the dynamic voting paradigm were suggested, e.g. <ref> [18, 19, 20, 26, 22, 12] </ref>. This section reviews several of these protocols. <p> divided into four categories: Algorithms that are incorrect, algorithms that require a cold start, algorithms that block in more cases than our protocol blocks, and algorithms that require excessive communication. 8.4.1 Incorrect Algorithms This section contains a thorough examination of protocols that may lead to inconsistent states in the system <ref> [11, 19, 20, 26, 12] </ref>. These protocols are based on the first paper describing dynamic voting [11], presented in the data replication literature. The section begins with a description of the scheme suggested by [11], showing it leads to inconsistencies. <p> These protocols are based on the first paper describing dynamic voting [11], presented in the data replication literature. The section begins with a description of the scheme suggested by [11], showing it leads to inconsistencies. The protocols in <ref> [19, 20, 26] </ref> closely resemble this scheme, hence only an overview of these protocols is provided. The section ends with the description of [12], which slightly differs from the rest of the protocols. <p> Being a majority of this component, they too consider themselves to be the majority component, and can also execute new updates. The existence of two majority components can lead to inconsistencies. The protocols in <ref> [18, 19, 20, 26] </ref> present extensions to the protocol presented in [11]. One contribution, presented in [18, 20, 26], is the extension of dynamic voting to dynamic linear voting. Furthermore, the communication model assumed in these papers is weaker than the communication model specified above. <p> One contribution, presented in [18, 20, 26], is the extension of dynamic voting to dynamic linear voting. Furthermore, the communication model assumed in these papers is weaker than the communication model specified above. Instead of the connection vector assumption, in <ref> [19, 20, 26] </ref> a site determines its membership as the set of sites that respond to its messages. Moreover, instead of maintaining a partition vector, each site keeps the size [19, 20], or the membership [26], of the last majority component it was a member of. <p> Instead of the connection vector assumption, in [19, 20, 26] a site determines its membership as the set of sites that respond to its messages. Moreover, instead of maintaining a partition vector, each site keeps the size <ref> [19, 20] </ref>, or the membership [26], of the last majority component it was a member of. Nevertheless, the protocols described in [19, 20, 26] do not overcome the problematic scenario depicted above, and, therefore, can still lead to inconsistency in the system. <p> Moreover, instead of maintaining a partition vector, each site keeps the size [19, 20], or the membership [26], of the last majority component it was a member of. Nevertheless, the protocols described in <ref> [19, 20, 26] </ref> do not overcome the problematic scenario depicted above, and, therefore, can still lead to inconsistency in the system. The protocol in [12] presents another scheme for data replication. This scheme is a combination 41 of the dynamic voting paradigm and the views approach [13, 14].
Reference: [20] <author> S. Jajodia and D. Mutchler. </author> <title> Enhancements to the Voting Algorithm. </title> <booktitle> In Int'l. Conf. on Very Large Data Bases, </booktitle> <volume> number 13, </volume> <pages> pages 399-405, </pages> <year> 1987. </year>
Reference-contexts: These methods include the primary site approach [1], which designates a specific site as a primary site and allows operations only within the component that contains this site, and static voting methods [32]. The comparisons reviewed below are divided into stochastic modelings <ref> [19, 20, 22] </ref>, simulations [26], and empirical data [6]. All comparisons result in favor of the dynamic voting paradigm. The stochastic models presented in [19, 20, 22] share the following assumptions: * Communication links between sites are infallible. * Sites failures form independent Poisson processes, as well as sites' repairs. * <p> The comparisons reviewed below are divided into stochastic modelings <ref> [19, 20, 22] </ref>, simulations [26], and empirical data [6]. All comparisons result in favor of the dynamic voting paradigm. The stochastic models presented in [19, 20, 22] share the following assumptions: * Communication links between sites are infallible. * Sites failures form independent Poisson processes, as well as sites' repairs. * Updates are instantaneous and arrive frequently. [22] also provides a stochastic link model in which the first two assumptions are replaced by the following <p> These results prove the advantages of the dynamic voting paradigm over static voting schemes and other methods for preserving consistency of replicated data. 8.4 Previously Suggested Dynamic Voting Protocols: Due to its merits and following [11], many protocols that implement the dynamic voting paradigm were suggested, e.g. <ref> [18, 19, 20, 26, 22, 12] </ref>. This section reviews several of these protocols. <p> divided into four categories: Algorithms that are incorrect, algorithms that require a cold start, algorithms that block in more cases than our protocol blocks, and algorithms that require excessive communication. 8.4.1 Incorrect Algorithms This section contains a thorough examination of protocols that may lead to inconsistent states in the system <ref> [11, 19, 20, 26, 12] </ref>. These protocols are based on the first paper describing dynamic voting [11], presented in the data replication literature. The section begins with a description of the scheme suggested by [11], showing it leads to inconsistencies. <p> These protocols are based on the first paper describing dynamic voting [11], presented in the data replication literature. The section begins with a description of the scheme suggested by [11], showing it leads to inconsistencies. The protocols in <ref> [19, 20, 26] </ref> closely resemble this scheme, hence only an overview of these protocols is provided. The section ends with the description of [12], which slightly differs from the rest of the protocols. <p> Being a majority of this component, they too consider themselves to be the majority component, and can also execute new updates. The existence of two majority components can lead to inconsistencies. The protocols in <ref> [18, 19, 20, 26] </ref> present extensions to the protocol presented in [11]. One contribution, presented in [18, 20, 26], is the extension of dynamic voting to dynamic linear voting. Furthermore, the communication model assumed in these papers is weaker than the communication model specified above. <p> The existence of two majority components can lead to inconsistencies. The protocols in [18, 19, 20, 26] present extensions to the protocol presented in [11]. One contribution, presented in <ref> [18, 20, 26] </ref>, is the extension of dynamic voting to dynamic linear voting. Furthermore, the communication model assumed in these papers is weaker than the communication model specified above. <p> One contribution, presented in [18, 20, 26], is the extension of dynamic voting to dynamic linear voting. Furthermore, the communication model assumed in these papers is weaker than the communication model specified above. Instead of the connection vector assumption, in <ref> [19, 20, 26] </ref> a site determines its membership as the set of sites that respond to its messages. Moreover, instead of maintaining a partition vector, each site keeps the size [19, 20], or the membership [26], of the last majority component it was a member of. <p> Instead of the connection vector assumption, in [19, 20, 26] a site determines its membership as the set of sites that respond to its messages. Moreover, instead of maintaining a partition vector, each site keeps the size <ref> [19, 20] </ref>, or the membership [26], of the last majority component it was a member of. Nevertheless, the protocols described in [19, 20, 26] do not overcome the problematic scenario depicted above, and, therefore, can still lead to inconsistency in the system. <p> Moreover, instead of maintaining a partition vector, each site keeps the size [19, 20], or the membership [26], of the last majority component it was a member of. Nevertheless, the protocols described in <ref> [19, 20, 26] </ref> do not overcome the problematic scenario depicted above, and, therefore, can still lead to inconsistency in the system. The protocol in [12] presents another scheme for data replication. This scheme is a combination 41 of the dynamic voting paradigm and the views approach [13, 14].
Reference: [21] <author> S. Jajodia and D. Mutchler. </author> <title> A Hybrid Replica Control Algorithm Combining Static and Dynamic Voting. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(4), </volume> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: In our protocol, we incorporate a novel mechanism for providing this feature, in environments which allow new processes to join on the fly. Jajodia and Mutchler <ref> [21] </ref> suggest a similar idea in their hybrid algorithm. The hybrid algorithm combines dynamic voting in large quorums with static voting in quorums of size three, ruling out quorums consisting of a single process. <p> The hybrid algorithm combines dynamic voting in large quorums with static voting in quorums of size three, ruling out quorums consisting of a single process. There are situations in which our algorithm allows the system to make progress while the algorithm in <ref> [21] </ref> does not, and vice versa. This work is organized as follows: Sections 2 and 3 present the problem and the model in which we solve the problem. <p> With this restriction, every quorum containing more than nMin Quorum is an eligible quorum, where n is the number of processes in the system. This feature is intended to prevent situations in which unavailability of a tiny set of processes blocks the entire system. Jajodia and Mutchler <ref> [21] </ref> suggest a similar idea in their hybrid algorithm. The hybrid algorithm combines dynamic voting in large quorums with static voting in quorums of size three, ruling out quorums consisting of a single process. <p> With both algorithms (q; r; s) is a succeeding eligible quorum. Hence there are situations in which our algorithm allows the system to make progress while the algorithm in <ref> [21] </ref> does not, and vice versa. 9 Concluding Remarks Numerous fault tolerant distributed systems use the primary component paradigm to allow a subset of the processes to function when failures occur.
Reference: [22] <author> S. Jajodia and D. Mutchler. </author> <title> Dynamic Voting Algorithms for Maintaining the Consistency of a Replicated Database. </title> <journal> ACM Trans. Database Systems, </journal> <volume> 15(2) </volume> <pages> 230-280, </pages> <year> 1990. </year>
Reference-contexts: Thus, each newly formed quorum must contain a majority of the previous one, but not necessarily a majority of the sites. Stochastic models analysis <ref> [22] </ref>, simulations [26], and empirical results [6] show that dynamic voting increases system availability, by increasing the probability that a primary component exists. In fact, the results in [6] show that dynamic voting is more available than any other paradigm for maintaining a primary component. <p> It may be incorporated in many distributed applications that make progress in a primary component, e.g. replication algorithms [24, 12], transaction management [23], and even infrastructure systems like the ISIS toolkit [7]. If a failure occurs in the course of the protocol, some previously suggested protocols (e.g. <ref> [22, 2] </ref>) block until all the members of the last quorum become reconnected, while our protocol, in order to make progress, requires only a majority of the members that attempted to form the last quorum to become reconnected. <p> Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in <ref> [11, 18, 26, 22, 12, 2] </ref>. Each process is equipped with an underlying membership module, e.g. [3, 5, 15]. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected. <p> These methods include the primary site approach [1], which designates a specific site as a primary site and allows operations only within the component that contains this site, and static voting methods [32]. The comparisons reviewed below are divided into stochastic modelings <ref> [19, 20, 22] </ref>, simulations [26], and empirical data [6]. All comparisons result in favor of the dynamic voting paradigm. The stochastic models presented in [19, 20, 22] share the following assumptions: * Communication links between sites are infallible. * Sites failures form independent Poisson processes, as well as sites' repairs. * <p> The comparisons reviewed below are divided into stochastic modelings <ref> [19, 20, 22] </ref>, simulations [26], and empirical data [6]. All comparisons result in favor of the dynamic voting paradigm. The stochastic models presented in [19, 20, 22] share the following assumptions: * Communication links between sites are infallible. * Sites failures form independent Poisson processes, as well as sites' repairs. * Updates are instantaneous and arrive frequently. [22] also provides a stochastic link model in which the first two assumptions are replaced by the following <p> All comparisons result in favor of the dynamic voting paradigm. The stochastic models presented in [19, 20, 22] share the following assumptions: * Communication links between sites are infallible. * Sites failures form independent Poisson processes, as well as sites' repairs. * Updates are instantaneous and arrive frequently. <ref> [22] </ref> also provides a stochastic link model in which the first two assumptions are replaced by the following two assumptions: * Sites are infallible. * Link failures form independent Poisson processes, as well as links' repairs. <p> These results prove the advantages of the dynamic voting paradigm over static voting schemes and other methods for preserving consistency of replicated data. 8.4 Previously Suggested Dynamic Voting Protocols: Due to its merits and following [11], many protocols that implement the dynamic voting paradigm were suggested, e.g. <ref> [18, 19, 20, 26, 22, 12] </ref>. This section reviews several of these protocols. <p> This is guaranteed until a site resolves the ambiguous situation. 8.4.2 Algorithms That Block While our protocol considers two states in order to bridge the gap between two different knowledge levels, the protocols described below block until the resolution of the last quorum. The protocols in <ref> [17, 22, 2] </ref> avoid inconsistencies by running Two Phase Commit (2PC) protocols ([17, 22]), or similar mechanisms ([2]). The disadvantage of these mechanisms is that there are situations in which the system is blocked until all the members of the last quorum recover and reconnect. <p> Moreover, the blocking time is not analyzed in comparisons made between dynamic voting and other schemes, 42 mentioned in Section 8.3. Hence the availability offered by protocols exploiting these mechanisms is smaller than expected. This section reviews such protocols. The dynamic voting protocol in <ref> [22] </ref> uses 2PC in order to update an object: Before updating the object, the coordinator sends a prepare messages to the quorum members. Upon receiving this message, each member returns a ready message to the coordinator and blocks.
Reference: [23] <author> I. Keidar and D. Dolev. </author> <title> Increasing the Resilience of Atomic Commit, at No Additional Cost. </title> <booktitle> In ACM Symp. on Prin. of Database Systems (PODS), </booktitle> <pages> pages 245-254, </pages> <month> May </month> <year> 1995. </year> <note> Previous version available as Technical Report CS94-18, </note> <institution> The Hebrew University, Jerusalem, Isreal. </institution>
Reference-contexts: Our protocol's communication and memory requirements are small, and the protocol is simple to implement. It may be incorporated in many distributed applications that make progress in a primary component, e.g. replication algorithms [24, 12], transaction management <ref> [23] </ref>, and even infrastructure systems like the ISIS toolkit [7]. <p> These protocols do not record historical information, and therefore, in case of failures, must consider all possible histories. This imposes severe limitations on the system's ability to make progress. Our protocol uses ideas similar to those used in the majority based Three Phase Commit (3PC) <ref> [30, 23] </ref> protocols to allow a majority in the system to make progress. <p> If they succeed, then at the end of the session they form a new primary component P , which persists until the next membership change. Each process independently invokes the protocol once it receives the membership message. The protocol we present resembles Three Phase Commit (3PC) protocols <ref> [29, 30, 23] </ref>. Each session of the protocol is conducted in three steps: In the first step the connected processes exchange information about quorums in past sessions.
Reference: [24] <author> I. Keidar and D. Dolev. </author> <title> Efficient Message Ordering in Dynamic Networks. </title> <booktitle> In ACM Symp. on Prin. of Distributed Computing (PODC), </booktitle> <volume> number 15, </volume> <pages> pages 68-76, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Our protocol's communication and memory requirements are small, and the protocol is simple to implement. It may be incorporated in many distributed applications that make progress in a primary component, e.g. replication algorithms <ref> [24, 12] </ref>, transaction management [23], and even infrastructure systems like the ISIS toolkit [7].
Reference: [25] <author> C. Malloth and A. Schiper. </author> <title> View Synchronous Communication in large scale networks. In Proceedings 2nd Open Workshop of the ESPRIT project BROADCAST (number 6360), </title> <note> July 1995 (also available as a Technical Report Nr. </note> <institution> 94/84 at Ecole Polytechnique Federale de Lausanne (Switzerland), </institution> <month> October </month> <year> 1994). </year>
Reference-contexts: However, explicitly running the 3PC recovery protocol to resolve the status of past quorums before forming new ones would induce a high overhead that would make the protocol infeasible for use in practice, and also increase the chance of failure during the protocol. A similar idea was suggested in <ref> [25] </ref>, where Chandra and Toueg's three phase consensus protocol [10] is employed. The status of past quorums is resolved before the installation of new ones. When a majority of the previous quorum reconnects, at least five communication rounds are needed in order to form a new quorum. <p> Yet, with our protocol, cold start of the system is never required; Whenever a majority of the previously formed primary component becomes connected, a new primary component can be formed. 8.4.4 Algorithms Requiring Excessive Communication Phoenix <ref> [25] </ref> is an ISIS-like environment intended to run on large scale networks, that implements the primary component model. The maintenance of the primary component is based on the Chan-dra and Toueg's three phase consensus protocol [10], that solves consensus in an asynchronous environment extended with a weak failure detector.
Reference: [26] <author> J. Paris and D. </author> <title> Long. Efficient Dynamic Voting Algorithms. </title> <booktitle> Proceedings 13th Int'l. Conf. on Very Large Data Bases, </booktitle> <pages> pages 268-275, </pages> <year> 1988. </year>
Reference-contexts: Thus, each newly formed quorum must contain a majority of the previous one, but not necessarily a majority of the sites. Stochastic models analysis [22], simulations <ref> [26] </ref>, and empirical results [6] show that dynamic voting increases system availability, by increasing the probability that a primary component exists. In fact, the results in [6] show that dynamic voting is more available than any other paradigm for maintaining a primary component. <p> When partitions occur, such knowledge differences are inevitable: Once a site detaches, it is impossible for other sites to know whether it received a specific message before its detachment, or not. Some past protocols (e.g. <ref> [11, 26, 12] </ref>) lead to inconsistent results in such cases, as demonstrated by the following typical scenario: * The systems consists of five processes: a; b; c; d and e. <p> Dynamic voting protocols solve the latter problem, assuming a separate mechanism that solves the former. We assume a membership mechanism no stronger than those assumed in <ref> [11, 18, 26, 22, 12, 2] </ref>. Each process is equipped with an underlying membership module, e.g. [3, 5, 15]. When this module senses failures or recoveries, it reports to the process of the new membership, i.e. the set of processes that are currently assumed to be connected. <p> These methods include the primary site approach [1], which designates a specific site as a primary site and allows operations only within the component that contains this site, and static voting methods [32]. The comparisons reviewed below are divided into stochastic modelings [19, 20, 22], simulations <ref> [26] </ref>, and empirical data [6]. All comparisons result in favor of the dynamic voting paradigm. <p> Under the link model it is proved that dynamic voting has greater availability than any static system for fully connected five-site networks. <ref> [26] </ref> offers a simulation model that simulates an existing network, spanned over two segments and consisting of eight sites, using realistic parameters. The simulations assume three and four 38 copies per object. <p> These results prove the advantages of the dynamic voting paradigm over static voting schemes and other methods for preserving consistency of replicated data. 8.4 Previously Suggested Dynamic Voting Protocols: Due to its merits and following [11], many protocols that implement the dynamic voting paradigm were suggested, e.g. <ref> [18, 19, 20, 26, 22, 12] </ref>. This section reviews several of these protocols. <p> divided into four categories: Algorithms that are incorrect, algorithms that require a cold start, algorithms that block in more cases than our protocol blocks, and algorithms that require excessive communication. 8.4.1 Incorrect Algorithms This section contains a thorough examination of protocols that may lead to inconsistent states in the system <ref> [11, 19, 20, 26, 12] </ref>. These protocols are based on the first paper describing dynamic voting [11], presented in the data replication literature. The section begins with a description of the scheme suggested by [11], showing it leads to inconsistencies. <p> These protocols are based on the first paper describing dynamic voting [11], presented in the data replication literature. The section begins with a description of the scheme suggested by [11], showing it leads to inconsistencies. The protocols in <ref> [19, 20, 26] </ref> closely resemble this scheme, hence only an overview of these protocols is provided. The section ends with the description of [12], which slightly differs from the rest of the protocols. <p> Being a majority of this component, they too consider themselves to be the majority component, and can also execute new updates. The existence of two majority components can lead to inconsistencies. The protocols in <ref> [18, 19, 20, 26] </ref> present extensions to the protocol presented in [11]. One contribution, presented in [18, 20, 26], is the extension of dynamic voting to dynamic linear voting. Furthermore, the communication model assumed in these papers is weaker than the communication model specified above. <p> The existence of two majority components can lead to inconsistencies. The protocols in [18, 19, 20, 26] present extensions to the protocol presented in [11]. One contribution, presented in <ref> [18, 20, 26] </ref>, is the extension of dynamic voting to dynamic linear voting. Furthermore, the communication model assumed in these papers is weaker than the communication model specified above. <p> One contribution, presented in [18, 20, 26], is the extension of dynamic voting to dynamic linear voting. Furthermore, the communication model assumed in these papers is weaker than the communication model specified above. Instead of the connection vector assumption, in <ref> [19, 20, 26] </ref> a site determines its membership as the set of sites that respond to its messages. Moreover, instead of maintaining a partition vector, each site keeps the size [19, 20], or the membership [26], of the last majority component it was a member of. <p> Instead of the connection vector assumption, in [19, 20, 26] a site determines its membership as the set of sites that respond to its messages. Moreover, instead of maintaining a partition vector, each site keeps the size [19, 20], or the membership <ref> [26] </ref>, of the last majority component it was a member of. Nevertheless, the protocols described in [19, 20, 26] do not overcome the problematic scenario depicted above, and, therefore, can still lead to inconsistency in the system. The protocol in [12] presents another scheme for data replication. <p> Moreover, instead of maintaining a partition vector, each site keeps the size [19, 20], or the membership [26], of the last majority component it was a member of. Nevertheless, the protocols described in <ref> [19, 20, 26] </ref> do not overcome the problematic scenario depicted above, and, therefore, can still lead to inconsistency in the system. The protocol in [12] presents another scheme for data replication. This scheme is a combination 41 of the dynamic voting paradigm and the views approach [13, 14].
Reference: [27] <author> A. M. Ricciardi and K. P. Birman. </author> <title> Using Process Groups to Implement Failure Detection in Asynchronous Environments. </title> <booktitle> In ACM Symp. on Prin. of Distributed Computing (PODC), </booktitle> <pages> pages 341-352, </pages> <month> August </month> <year> 1991. </year>
Reference-contexts: The drawback of this approach is even more prominent in applications in which the set of participants is dynamic: one process that voluntarily leaves the system may cause all the other participants to block. Unlike some previous protocols (e.g. the protocols implemented in ISIS and Horus <ref> [27] </ref>), our protocol recovers from situations in which the primary component was lost (e.g. when the primary 1 A component is sometimes called a partition. In our terminology, a partition splits the network into several components. 2 The thesis actually presents two protocols that closely resemble one another. <p> An inherent part of their membership service is the use of the primary component model <ref> [27] </ref>: Initially, all processes are considered to be members of the primary component. The membership of the primary component is modified using the dynamic voting paradigm. At any moment at most a minority of the current primary component may be detached from the component.
Reference: [28] <author> A. M. Ricciardi, A. Schiper, and K. P. Birman. </author> <title> Understanding Partitions and the "No Partition" Assumption. </title> <booktitle> In IEEE 4th Workshop on Future Trends of Distributed Systems (FTDCS-93), </booktitle> <month> September </month> <year> 1993. </year>
Reference-contexts: Furthermore, in order to act on behalf of the group as a whole, at any time the system may contain at most 37 one primary component per each group of processes. Otherwise, contradictory decisions may be reached in other components <ref> [28] </ref>. This explains the need for a conservative algorithm for the maintenance of a primary component. As mentioned before, the problem with a conservative algorithm is that it limits the availability. When no primary component exists for a certain group, activity for this group blocks either completely (e.g.
Reference: [29] <author> D. Skeen. </author> <title> Nonblocking Commit Protocols. </title> <booktitle> In SIGMOD Intl. Conf. Management of Data, </booktitle> <pages> pages 133-142, </pages> <year> 1981. </year> <month> 47 </month>
Reference-contexts: If they succeed, then at the end of the session they form a new primary component P , which persists until the next membership change. Each process independently invokes the protocol once it receives the membership message. The protocol we present resembles Three Phase Commit (3PC) protocols <ref> [29, 30, 23] </ref>. Each session of the protocol is conducted in three steps: In the first step the connected processes exchange information about quorums in past sessions.
Reference: [30] <author> D. Skeen. </author> <title> A Quorum-Based Commit Protocol. </title> <booktitle> In Berkeley Workshop on Distributed Data Management and Computer Networks, </booktitle> <volume> number 6, </volume> <pages> pages 69-80, </pages> <month> Feb. </month> <year> 1982. </year>
Reference-contexts: These protocols do not record historical information, and therefore, in case of failures, must consider all possible histories. This imposes severe limitations on the system's ability to make progress. Our protocol uses ideas similar to those used in the majority based Three Phase Commit (3PC) <ref> [30, 23] </ref> protocols to allow a majority in the system to make progress. <p> If they succeed, then at the end of the session they form a new primary component P , which persists until the next membership change. Each process independently invokes the protocol once it receives the membership message. The protocol we present resembles Three Phase Commit (3PC) protocols <ref> [29, 30, 23] </ref>. Each session of the protocol is conducted in three steps: In the first step the connected processes exchange information about quorums in past sessions.
Reference: [31] <author> D. Skeen and M. Stonebraker. </author> <title> A Formal Model of Crash Recovery in a Distributed System. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-9 NO.3, </volume> <month> May </month> <year> 1983. </year>
Reference-contexts: Taking the conservative approach, it is inevitable that failures can occur in a way that blocks the system until some of the failures are repaired <ref> [31] </ref>. The challenge is to devise consistency control algorithms that achieve high objects availability without compromising objects consistency. Voting schemes, in particular the dynamic voting paradigm, were designed to confront this challenge. In a general voting scheme, quorums are predefined for specific operations on objects, e.g. read or write.
Reference: [32] <author> R. Thomas. </author> <title> A Majority Consensus Approach to Concurrency Control for Multiple Copy Databases. </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 4(2) </volume> <pages> 180-209, </pages> <month> June </month> <year> 1979. </year> <month> 48 </month>
Reference-contexts: These methods include the primary site approach [1], which designates a specific site as a primary site and allows operations only within the component that contains this site, and static voting methods <ref> [32] </ref>. The comparisons reviewed below are divided into stochastic modelings [19, 20, 22], simulations [26], and empirical data [6]. All comparisons result in favor of the dynamic voting paradigm.
References-found: 32

