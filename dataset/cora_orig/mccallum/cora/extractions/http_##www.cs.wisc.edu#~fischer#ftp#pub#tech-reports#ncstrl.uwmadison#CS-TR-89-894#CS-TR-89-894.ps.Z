URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-89-894/CS-TR-89-894.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-89-894/
Root-URL: http://www.cs.wisc.edu
Email: netzer@cs.wisc.edu  bart@cs.wisc.edu  
Title: Detecting Data Races in Parallel Program Executions  
Author: Robert H. B. Netzer Barton P. Miller Robert H. B. Netzer, Barton P. Miller. D. Gelernter, T. Gross, A. Nicolau, and D. Padua 
Date: August 1990.  
Note: Research supported in part by National Science Foundation grant CCR-8815928, Office of Naval Research grant N00014-89-J-1222, and a Digital Equipment Corporation External Research Grant. Copyright 1989,1990  To appear in Languages and Compilers for Parallel Computing,  eds., MIT press, 1991; also appears in Proceedings of the 3rd Workshop on Programming Languages and Compilers for Parallel Computing, Irvine, CA,  
Address: 1210 W. Dayton Street Madison, Wisconsin 53706  
Affiliation: Computer Sciences Department University of Wisconsin-Madison  
Abstract-found: 0
Intro-found: 1
Reference: 1. <author> Allen, T. R. and D. A. Padua, </author> <title> ``Debugging Fortran on a Shared Memory Machine,'' </title> <booktitle> Proc. of Intl. Conf. on Parallel Processing, </booktitle> <pages> pp. </pages> <address> 721-727 St. Charles, IL, </address> <month> (Aug. </month> <year> 1987). </year>
Reference-contexts: Detecting data races in a particular execution of a parallel program is an important part of debugging. Several methods for data race detection have been developed <ref> [1, 3, 4, 9, 15, 17] </ref>. Although these methods provide valuable tools for debugging, they do not precisely define the notion of a data race. As a result, we cannot precisely state which data races are detected by these methods. In addition, false data race reports can sometimes be generated. <p> Two approaches to this information collection and analysis have been proposed: on-the-fly and post-mortem. On-the-fly techniques [4, 9, 17] detect data races by an on-going analysis during execution that encodes information about the execution so it can be accessed quickly and discarded as it becomes obsolete. Post-mortem techniques <ref> [1, 3, 15] </ref> detect data races after execution ends by analyzing trace files that are produced during execution. Although all previous methods never fail to detect any data races actually exhibited during execution (we prove this claim in Section 7), they do not precisely locate where these data races occurred. <p> This notion is similar to the hides relation of Allen and Padua <ref> [1] </ref>. A future paper will describe how to employ these ideas to locate tangled data races that can be guaranteed feasible. 8. Conclusion This paper has addressed two issues regarding data race detection.
Reference: 2. <author> Bernstein, A. J., </author> <title> ``Analysis of Programs for Parallel Processing,'' </title> <journal> IEEE Trans. on Electronic Computers EC-15(5) pp. </journal> <month> 757-763 (Oct. </month> <year> 1966). </year> <month> 20 </month>
Reference-contexts: A section of code is guaranteed to execute atomically if the shared variables it reads and modifies are not modified by any other concurrently executing section of code <ref> [2] </ref>. If these conditions are not met, a data race is said to exist. Since nondeterministic behavior can result, a data race is a special case of the more general race condition. In this paper we focus on data race detection.
Reference: 3. <author> Choi, J.-D., B. P. Miller, and R. H. B. Netzer, </author> <title> ``Techniques for Debugging Parallel Pro--grams with Flowback Analysis,'' </title> <institution> Comp. Sci. Dept. </institution> <type> Tech. Rep. #786, </type> <institution> Univ. of Wisconsin-Madison, </institution> <month> (Aug. </month> <year> 1988). </year>
Reference-contexts: Detecting data races in a particular execution of a parallel program is an important part of debugging. Several methods for data race detection have been developed <ref> [1, 3, 4, 9, 15, 17] </ref>. Although these methods provide valuable tools for debugging, they do not precisely define the notion of a data race. As a result, we cannot precisely state which data races are detected by these methods. In addition, false data race reports can sometimes be generated. <p> Two approaches to this information collection and analysis have been proposed: on-the-fly and post-mortem. On-the-fly techniques [4, 9, 17] detect data races by an on-going analysis during execution that encodes information about the execution so it can be accessed quickly and discarded as it becomes obsolete. Post-mortem techniques <ref> [1, 3, 15] </ref> detect data races after execution ends by analyzing trace files that are produced during execution. Although all previous methods never fail to detect any data races actually exhibited during execution (we prove this claim in Section 7), they do not precisely locate where these data races occurred. <p> Since T only needs to obey the synchronization axioms, other approaches for adding edges (that result in more events being unordered by T , allowing more data races to be detected) are possible. For example, previous methods that handle semaphores <ref> [3, 4, 15] </ref> construct edges only from a V operation to the P operation it allowed to proceed. More sophisticated approaches have also been investigated [8]. 4.2. <p> Finally, the ideas presented in this paper can be applied to shared-memory parallel programs that use synchronization primitives other than semaphores, such as event variables, barriers, or rendezvous. To gain practical experience with these ideas, we are currently incorporating them into a parallel program debugger <ref> [3, 15] </ref> under development at the University of Wisconsin-Madison. Acknowledgements This research was supported in part by National Science Foundation grant CCR-8815928, Office of Naval Research grant N00014-89-J-1222, and a Digital Equipment Corporation External Research Grant.
Reference: 4. <author> Dinning, A. and E. Schonberg, </author> <title> ``An Empirical Comparison of Monitoring Algorithms for Access Anomaly Detection,'' </title> <booktitle> Proc. of ACM SIGPLAN Symp. on Principles and Practice of Parallel Programming, </booktitle> <pages> pp. </pages> <address> 1-10 Seattle, WA, </address> <month> (Mar. </month> <year> 1990). </year>
Reference-contexts: Detecting data races in a particular execution of a parallel program is an important part of debugging. Several methods for data race detection have been developed <ref> [1, 3, 4, 9, 15, 17] </ref>. Although these methods provide valuable tools for debugging, they do not precisely define the notion of a data race. As a result, we cannot precisely state which data races are detected by these methods. In addition, false data race reports can sometimes be generated. <p> These methods all analyze essentially the same information about the execution, but differ mainly in how and when that information is collected and analyzed. Two approaches to this information collection and analysis have been proposed: on-the-fly and post-mortem. On-the-fly techniques <ref> [4, 9, 17] </ref> detect data races by an on-going analysis during execution that encodes information about the execution so it can be accessed quickly and discarded as it becomes obsolete. Post-mortem techniques [1, 3, 15] detect data races after execution ends by analyzing trace files that are produced during execution. <p> For these accesses to execute concurrently, the second ``remove'' operation performed hhhhhhhhhhhhhhhhhhhhhhhhhhhhh Some methods do not actually construct a node to represent a computation event but rather represent the event by an edge connecting the two surrounding synchronization events <ref> [4, 15] </ref>. 4 fork join fork remove (L,U) loop while QueueNotEmpty remove (L,U) loop while QueueNotEmpty join Initial state of Queue: remove [200,300] remove [300,400] remove [100,200] remove [100,300] [100,200] [1,100] work on region [L,U-1] of shared array work on region [L,U-1] of shared array work on [200,299] work on [300,399] <p> Since T only needs to obey the synchronization axioms, other approaches for adding edges (that result in more events being unordered by T , allowing more data races to be detected) are possible. For example, previous methods that handle semaphores <ref> [3, 4, 15] </ref> construct edges only from a V operation to the P operation it allowed to proceed. More sophisticated approaches have also been investigated [8]. 4.2.
Reference: 5. <author> Emrath, P. A. and D. A. Padua, </author> <title> ``Automatic Detection Of Nondeterminacy in Parallel Programs,'' </title> <booktitle> Proc. of the Workshop on Parallel and Distributed Debugging, </booktitle> <pages> pp. </pages> <address> 89-99 Madison, WI, </address> <month> (May </month> <year> 1988). </year> <note> Also SIGPLAN Notices 24(1) (Jan. </note> <year> 1989). </year>
Reference-contexts: When the order of two shared-memory accesses made by different processes (to the same location) is not enforced, a race condition is said to exist <ref> [5, 6] </ref>, possibly resulting in a nondeterministic execution. In contrast, other programs are not intended to be deterministic, and for these programs synchronization is usually added to ensure that some sections of code execute as if they were atomic (i.e., to implement critical sections).
Reference: 6. <author> Emrath, P. A., S. Ghosh, and D. A. Padua, </author> <title> ``Event Synchronization Analysis for Debugging Parallel Programs,'' </title> <booktitle> Supercomputing '89, </booktitle> <pages> pp. </pages> <address> 580-588 Reno,NV, </address> <month> (Nov. </month> <year> 1989). </year>
Reference-contexts: When the order of two shared-memory accesses made by different processes (to the same location) is not enforced, a race condition is said to exist <ref> [5, 6] </ref>, possibly resulting in a nondeterministic execution. In contrast, other programs are not intended to be deterministic, and for these programs synchronization is usually added to ensure that some sections of code execute as if they were atomic (i.e., to implement critical sections).
Reference: 7. <author> Habermann, A. N., </author> <title> ``Synchronization of Communicating Processes,'' </title> <journal> Communications of the ACM 12(3) pp. </journal> <month> 171-176 (Mar. </month> <year> 1972). </year>
Reference-contexts: For all child processes, c, created by each Fork p,i and terminated at Join p,i +k , Fork p,i T T Join p,i +k 1 j c E c c We assume that in any program execution the semaphore invariant <ref> [7] </ref> is always maintained. For counting semaphores, the semaphore invariant is maintained iff at each point in the execution, the number of V operations that have either completed or have begun executing is greater than or equal to the number of P operations that have completed.
Reference: 8. <author> Helmbold, D. P., C. E. McDowell, and J.-Z. Wang, </author> <title> ``Analyzing Traces with Anonymous Synchronization,'' </title> <booktitle> Proc. of Intl. Conf. on Parallel Processing, </booktitle> <address> St. Charles, IL, </address> <month> (Aug. </month> <year> 1990). </year>
Reference-contexts: For example, previous methods that handle semaphores [3, 4, 15] construct edges only from a V operation to the P operation it allowed to proceed. More sophisticated approaches have also been investigated <ref> [8] </ref>. 4.2. Approximate Shared-Data Dependences Determining the actual shared-data dependences exhibited by an execution would in general require the relative order of all shared memory accesses to be recorded. However, in Section 2 we mentioned that previous methods record the READ and WRITE sets for each computation event.
Reference: 9. <author> Hood, R., K. Kennedy, and J. Mellor-Crummey, </author> <title> ``Parallel Program Debugging with On-the-fly Anomaly Detection,'' </title> <booktitle> Supercomputing '90, </booktitle> <address> New York, NY, </address> <month> (Nov. </month> <year> 1990). </year>
Reference-contexts: Detecting data races in a particular execution of a parallel program is an important part of debugging. Several methods for data race detection have been developed <ref> [1, 3, 4, 9, 15, 17] </ref>. Although these methods provide valuable tools for debugging, they do not precisely define the notion of a data race. As a result, we cannot precisely state which data races are detected by these methods. In addition, false data race reports can sometimes be generated. <p> These methods all analyze essentially the same information about the execution, but differ mainly in how and when that information is collected and analyzed. Two approaches to this information collection and analysis have been proposed: on-the-fly and post-mortem. On-the-fly techniques <ref> [4, 9, 17] </ref> detect data races by an on-going analysis during execution that encodes information about the execution so it can be accessed quickly and discarded as it becomes obsolete. Post-mortem techniques [1, 3, 15] detect data races after execution ends by analyzing trace files that are produced during execution.
Reference: 10. <author> Kuck, D. J., R. H. Kuhn, B. Leasure, D. A. Padua, and M. Wolfe, </author> <title> ``Dependence Graphs and Compiler Optimizations,'' </title> <booktitle> Conf. Record of the 8th ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pp. </pages> <address> 207-218 Williamsburg, VA, </address> <month> (Jan. </month> <year> 1981). </year>
Reference-contexts: This definition of data dependence is different from the standard ones <ref> [10] </ref> since we consider transitive dependences involv ing flow-, anti-, and output-dependences, and do not explicitly state the variables involved.
Reference: 11. <author> Lamport, L., </author> <title> ``How to Make a Multiprocessor Computer That Correctly Executes Mul-tiprocess Programs,'' </title> <journal> IEEE Trans. on Computers C-28(9) pp. </journal> <month> 690-691 (Sep. </month> <year> 1979). </year>
Reference-contexts: We use Lamport's theory, but restrict it to the class of shared-memory parallel programs that execute on sequentially consistent processors <ref> [11] </ref>. When the underlying hardware guarantees sequential consistency, any two events that execute concurrently can affect one another (i.e., a / b a b b a). Given sequential consistency, a single relation is sufficient to describe the temporal aspects of a system exe cution.
Reference: 12. <author> Lamport, L., </author> <title> ``Interprocess Communication,'' </title> <type> SRI Technical Report, </type> <month> (Mar. </month> <year> 1985). </year>
Reference: 13. <author> Lamport, L., </author> <title> ``The Mutual Exclusion Problem: Part I A Theory of Interprocess Communication,'' </title> <journal> Journal of the ACM 33(2) pp. </journal> <month> 313-326 (Apr. </month> <year> 1986). </year>
Reference-contexts: Our model describes programs that use counting semaphores and the fork/join construct. 3.1. General Model Our model is based on Lamport's theory of concurrent systems <ref> [13] </ref>, which provides a formalism for reasoning about concurrent systems that does not assume the existence of atomic operations. In Lamport's formalism, a concurrent system execution is modeled as a collection of operation executions.
Reference: 14. <author> Mellor-Crummey, J. M., </author> <title> ``Debugging and Analysis of Large-Scale Parallel Programs,'' </title> <type> Ph.D. Thesis, </type> <institution> also Comp. Sci. Dept. </institution> <type> Tech. Rep. 312, </type> <institution> Univ. of Rochester, </institution> <month> (Sep. </month> <year> 1989). </year>
Reference-contexts: The program execution describing this view, P S , shows the data dependences among the individual shared-memory accesses made by the execution. These single-access shared-data dependences uniquely characterize the events performed. Since the execution outcome of each statement instance depends only upon the values of the variables it reads <ref> [14] </ref>, the single-access dependences uniquely determine the program state at each step in each process. Any temporal ordering that could still allow these data dependences to occur (and that would not violate the semantics of the synchronization operations) is an ordering the execution could have exhibited. <p> Proof. We will use the result mentioned above that any single-access program execution possessing the same (single-access) shared-data dependences as those that actually occurred represents an execution the program could exhibit <ref> [14] </ref>. This theorem extends the result to higher-level program executions. Since computation events in higher-level program executions can consist of more than one shared-memory access, there may be more than one single-access program execution for which P, the actual program execution, is a higher-level view.
Reference: 15. <author> Miller, B. P. and J.-D. Choi, </author> <title> ``A Mechanism for Efficient Debugging of Parallel Programs,'' </title> <booktitle> Proc. of the Conf. on Programming Language Design and Implementation, </booktitle> <pages> pp. </pages> <address> 135-144 Atlanta, GA, </address> <month> (June </month> <year> 1988). </year> <note> Also SIGPLAN Notices 23(7) (July 1988). </note>
Reference-contexts: Detecting data races in a particular execution of a parallel program is an important part of debugging. Several methods for data race detection have been developed <ref> [1, 3, 4, 9, 15, 17] </ref>. Although these methods provide valuable tools for debugging, they do not precisely define the notion of a data race. As a result, we cannot precisely state which data races are detected by these methods. In addition, false data race reports can sometimes be generated. <p> Two approaches to this information collection and analysis have been proposed: on-the-fly and post-mortem. On-the-fly techniques [4, 9, 17] detect data races by an on-going analysis during execution that encodes information about the execution so it can be accessed quickly and discarded as it becomes obsolete. Post-mortem techniques <ref> [1, 3, 15] </ref> detect data races after execution ends by analyzing trace files that are produced during execution. Although all previous methods never fail to detect any data races actually exhibited during execution (we prove this claim in Section 7), they do not precisely locate where these data races occurred. <p> For these accesses to execute concurrently, the second ``remove'' operation performed hhhhhhhhhhhhhhhhhhhhhhhhhhhhh Some methods do not actually construct a node to represent a computation event but rather represent the event by an edge connecting the two surrounding synchronization events <ref> [4, 15] </ref>. 4 fork join fork remove (L,U) loop while QueueNotEmpty remove (L,U) loop while QueueNotEmpty join Initial state of Queue: remove [200,300] remove [300,400] remove [100,200] remove [100,300] [100,200] [1,100] work on region [L,U-1] of shared array work on region [L,U-1] of shared array work on [200,299] work on [300,399] <p> Since T only needs to obey the synchronization axioms, other approaches for adding edges (that result in more events being unordered by T , allowing more data races to be detected) are possible. For example, previous methods that handle semaphores <ref> [3, 4, 15] </ref> construct edges only from a V operation to the P operation it allowed to proceed. More sophisticated approaches have also been investigated [8]. 4.2. <p> Finally, the ideas presented in this paper can be applied to shared-memory parallel programs that use synchronization primitives other than semaphores, such as event variables, barriers, or rendezvous. To gain practical experience with these ideas, we are currently incorporating them into a parallel program debugger <ref> [3, 15] </ref> under development at the University of Wisconsin-Madison. Acknowledgements This research was supported in part by National Science Foundation grant CCR-8815928, Office of Naval Research grant N00014-89-J-1222, and a Digital Equipment Corporation External Research Grant.
Reference: 16. <author> Netzer, R. H. B. and B. P. Miller, </author> <title> ``On the Complexity of Event Ordering for Shared-Memory Parallel Program Executions,'' </title> <booktitle> Proc. of Intl. Conf. on Parallel Processing, </booktitle> <address> St. Charles, IL, </address> <month> (Aug. </month> <year> 1990). </year>
Reference-contexts: Using this extended notion of feasibility, certain tangled data races can be shown to be feasible. Second, we are examining different classes of feasible data races. We have proven that the problem of detecting all feasible data races is NP-hard <ref> [16] </ref> (even when the complete program execution is known). However, certain classes of feasible data races can be efficiently detected. Third, we are developing techniques for providing efficient data race detection in practice.
Reference: 17. <author> Nudler, I. and L. Rudolph, </author> <title> ``Tools for the Efficient Development of Efficient Parallel Programs,'' </title> <booktitle> Proc. of 1st Israeli Conf. on Computer System Engineering, (1988). </booktitle> <volume> 21 22 </volume>
Reference-contexts: Detecting data races in a particular execution of a parallel program is an important part of debugging. Several methods for data race detection have been developed <ref> [1, 3, 4, 9, 15, 17] </ref>. Although these methods provide valuable tools for debugging, they do not precisely define the notion of a data race. As a result, we cannot precisely state which data races are detected by these methods. In addition, false data race reports can sometimes be generated. <p> These methods all analyze essentially the same information about the execution, but differ mainly in how and when that information is collected and analyzed. Two approaches to this information collection and analysis have been proposed: on-the-fly and post-mortem. On-the-fly techniques <ref> [4, 9, 17] </ref> detect data races by an on-going analysis during execution that encodes information about the execution so it can be accessed quickly and discarded as it becomes obsolete. Post-mortem techniques [1, 3, 15] detect data races after execution ends by analyzing trace files that are produced during execution.
References-found: 17

