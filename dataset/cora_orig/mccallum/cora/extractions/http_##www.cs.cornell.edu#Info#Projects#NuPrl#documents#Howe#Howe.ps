URL: http://www.cs.cornell.edu/Info/Projects/NuPrl/documents/Howe/Howe.ps
Refering-URL: http://www.cs.cornell.edu/Info/Projects/NuPrl/html/publication.html
Root-URL: 
Title: Semantic Foundations for Embedding HOL in Nuprl  
Author: Douglas J. Howe 
Address: 600 Mountain Ave., Room 2B-438 Murray Hill, NJ 07974, USA.  
Affiliation: Bell Labs  
Abstract: We give a new semantics for Nuprl's constructive type theory that justifies a useful embedding of the logic of the HOL theorem prover inside Nuprl. The embedding gives Nuprl effective access to most of the large body of formalized mathematics that the HOL community has amassed over the last decade. The new semantics is dramatically simpler than the old, and gives a novel and general way of adding set-theoretic equivalence classes to untyped functional programming languages.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Part IIIA: </author> <title> SCI Coherence Overview, </title> <note> 1995. Unapproved draft IEEE-P1596-05Nov90-doc197-iii. </note>
Reference-contexts: We are currently in the process of actually using this embedding. The connection between HOL and Nuprl has been implemented, and we have begun the importation of HOL theories. The immediate goal is to use these theories in a project to use Nuprl to verify the SCI cache-coherency protocol <ref> [1] </ref>. Details on the embedding of HOL and its practical applications will be the subject of a future paper. In the last section we discuss some related work and discuss some extensions of Nuprl justified by our semantics. 2 Semantics The semantics has an operational flavour.
Reference: 2. <editor> Higher Order Logic Theorem Proving and Its Applications, </editor> <booktitle> Lecture Notes in Computer Science. </booktitle> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: A good picture of the scope and extent of this work can be obtained from the proceedings of recent meetings of the annual HOL conference (for example, <ref> [2] </ref>). Nuprl's type theory offers a number of advantages over HOL's logic. Expressive power of the type system. Nuprl has subtypes and dependent function types. Also, through the use of universes and "sigma" types, one can express modules of the kind found in Standard ML [19]. - Constructivity. <p> Let ~ 1 = f0; 2; : : :g and ~ 2 = f1; 3; : : :g. The type (x; y) : N==even (x y) will have as members ^ ~ 1 ; ^ ~ 2 and [n] for n 0. We have ^ ~ 1 &lt; <ref> [2] </ref> but not ^ ~ 2 &lt; [2]. Also, if f = x: if evenp (x) then 0 else 1 then f [2] + 0 and f ~ 2 + ^ 1. The evaluation relation + is idempotent, in the sense that if e + v then v + v. <p> The type (x; y) : N==even (x y) will have as members ^ ~ 1 ; ^ ~ 2 and [n] for n 0. We have ^ ~ 1 &lt; <ref> [2] </ref> but not ^ ~ 2 &lt; [2]. Also, if f = x: if evenp (x) then 0 else 1 then f [2] + 0 and f ~ 2 + ^ 1. The evaluation relation + is idempotent, in the sense that if e + v then v + v. <p> We have ^ ~ 1 &lt; <ref> [2] </ref> but not ^ ~ 2 &lt; [2]. Also, if f = x: if evenp (x) then 0 else 1 then f [2] + 0 and f ~ 2 + ^ 1. The evaluation relation + is idempotent, in the sense that if e + v then v + v. We use the letters u and v exclusively for values, which are terms u such that u + u.
Reference: 3. <author> S. F. Allen. </author> <title> A Non-Type-Theoretic Semantics for Type-Theoretic Language. </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1987. </year> <month> 19 </month>
Reference-contexts: Chapter 8 of the Nuprl book [5] gives a sketch of this semantics. For a better idea of the complications involved, see Allen's PhD thesis <ref> [3] </ref>. Because of this complexity, many of the existing Nuprl rules have not been completely verified, and there is a strong barrier to extending or modifying the theory. In particular, it has been a barrier to changing Nuprl's programming language to be more like SML.
Reference: 4. <author> V. Breazu-Tannen and R. Subrahmanyam. </author> <title> Logical and computational aspects of programming with sets/bags/lists. </title> <booktitle> In Automata, Languages and Programming: 18 th International Colloquium, Lecture Notes in Computer Science, </booktitle> <pages> pages 60-75. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Details on the actual HOL embedding and some of its practical applications will be given in a forthcoming paper. 18 5 Related Work, Discussion In <ref> [4] </ref>, Breazu-Tannen and Subrahmanyam give a logic for reasoning about programs using structural recursion over data types formed from constructors subject to some equations.
Reference: 5. <author> R. L. Constable, et al. </author> <title> Implementing Mathematics with the Nuprl Proof Development System. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1986. </year>
Reference-contexts: 1 Introduction Nuprl <ref> [5] </ref> and HOL [9] are interactive theorem proving systems with a number of similarities: their logics are higher-order type theories, their approaches to automated reasoning are based on that of LCF [8], and their main application has been to formal reasoning about computation. <p> This semantics is itself fairly complicated. However, for technical reasons having to do with several essential practical considerations, including reasoning about general recursive programs, and collapsing Martin-Lof's four forms of judgement into one, Nuprl requires a more refined notion of functionality. Chapter 8 of the Nuprl book <ref> [5] </ref> gives a sketch of this semantics. For a better idea of the complications involved, see Allen's PhD thesis [3]. Because of this complexity, many of the existing Nuprl rules have not been completely verified, and there is a strong barrier to extending or modifying the theory. <p> In Section 3, we show how to apply this semantics to the Nuprl logic as described in <ref> [5] </ref>. This is done by adding, to the programming language, operators representing Nuprl's type constructors, together with rules specifying how to "evaluate" instances of these constructors to get a member of V representing the set of all members of a type. <p> However, the semantics is sufficient simple that an interested reader would not have too much difficulty in verifying the rules given in the Nuprl book <ref> [5] </ref>, given the definitions and examples in this section, and the results of Section 2. Because of dependent types, the explanation of types in Nuprl is bound up with evaluation.
Reference: 6. <author> P. Dybjer. </author> <title> Inductive sets and families in Martin-Lof's type theory and their set-theoretic semantics. </title> <booktitle> In Proceedings of the B.R.A. Workshop on Logical Frameworks, Sophia-Antipolis, </booktitle> <address> France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: It is straightforward to give a classical interpretation justifying the select operator for typed variants of Martin-Lof's type theory. Such an interpretation is given by Dybjer in <ref> [6] </ref>.
Reference: 7. <author> A. Gordon. </author> <title> Functional Programming and Input/Output. </title> <publisher> Cambrige University Press, </publisher> <year> 1994. </year>
Reference-contexts: The approach to operational semantics builds on our work described in [13]. Evidence for the robustness of this approach with respect to changes in the programming language can be found, for example, in the adaptations of our approach by Pitts and Gordon, described in <ref> [20, 7] </ref>. In Section 3, we show how to apply this semantics to the Nuprl logic as described in [5].
Reference: 8. <author> M. J. Gordon, R. Milner, and C. P. Wadsworth. </author> <title> Edinburgh LCF: A Mechanized Logic of Computation, </title> <booktitle> volume 78 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: 1 Introduction Nuprl [5] and HOL [9] are interactive theorem proving systems with a number of similarities: their logics are higher-order type theories, their approaches to automated reasoning are based on that of LCF <ref> [8] </ref>, and their main application has been to formal reasoning about computation. However, the two logics are very different in a number of ways. Nuprl has a constructive type theory, based on a type theory of Martin-Lof [17].
Reference: 9. <author> M. J. C. Gordon and T. F. Melham. </author> <title> Introduction to HOL: A Theorem Proving Environment for Higher Order Logic. </title> <publisher> Cambridge University Press, </publisher> <address> Cambridge, UK, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Nuprl [5] and HOL <ref> [9] </ref> are interactive theorem proving systems with a number of similarities: their logics are higher-order type theories, their approaches to automated reasoning are based on that of LCF [8], and their main application has been to formal reasoning about computation.
Reference: 10. <author> C. A. Gunter. </author> <title> Semantics of Programming Languages. </title> <publisher> The MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: It is also used in verifying some of Nuprl's inference rules, although these verifications can also be done in terms of the operational preorder. This property is stated in Theorem 13, and its proof is inspired by the "inclusive predicates" method from denotational semantics (see, for example, Gunter's book <ref> [10] </ref>). The key idea in the proof method is the following definition. Definition 8.
Reference: 11. <author> D. J. Howe. </author> <title> Equality in lazy computation systems. </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 198-203. </pages> <publisher> IEEE Computer Society, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: We must have u = ^ff for some ff with ff &lt; u 0 . Now we just need to apply Lemma 17. The proof that ffi is operator-respecting is an extension of the method of <ref> [11, 13] </ref>. One of the main differences is that for the cases for rules (ap ) and (ap ~ ), we need to already know the restricted substitution property stated in Theorem 13. We continue to omit any mention of operators not treated in Section 2. <p> The idea for the proof of Theorem 20 first appeared in <ref> [11] </ref>. An expanded treatment of the proof method is in [12]. In [14] we gave a type theory that contained ZF set theory.
Reference: 12. <author> D. J. Howe. </author> <title> On computational open-endedness in Martin-Lof's type theory. </title> <booktitle> In Proceedings of the Sixth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 162-172. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1991. </year>
Reference-contexts: This means that the set-theoretic meaning of each U i has to be closed under the corresponding set constructors. This requires the use of inaccessible cardinals. These are defined in most set theory texts, and the reason for their use in this context is explained further in <ref> [12] </ref>. We choose the ordinal 0 in the definition of W to be the limit 14 of a countable sequence t 1 &lt; t 2 : : : of inaccessible cardinals. For each i 1, let fl i = V " Z t i . <p> The idea of adding function oracles to an untyped programming language comes from our paper <ref> [12] </ref>. <p> The idea for the proof of Theorem 20 first appeared in [11]. An expanded treatment of the proof method is in <ref> [12] </ref>. In [14] we gave a type theory that contained ZF set theory. Although that theory is in some respects similar to Nuprl, the programming language in the theory is typed in an essential way and hence the semantics cannot be applied to Nuprl.
Reference: 13. <author> D. J. Howe. </author> <title> Proving congruence of bisimulation in functional programming languages. </title> <journal> Information and Computation, </journal> <volume> 124(2) </volume> <pages> 103-112, </pages> <month> 1 Feb. </month> <year> 1996. </year>
Reference-contexts: The approach to operational semantics builds on our work described in <ref> [13] </ref>. Evidence for the robustness of this approach with respect to changes in the programming language can be found, for example, in the adaptations of our approach by Pitts and Gordon, described in [20, 7]. <p> We treat Nuprl's canonical operators generically, and omit here all of its non-canonical operators except for function application. Extending the proofs to deal with the omitted operations is completely straightforward. In <ref> [13] </ref> we define a general rule schema such that Theorem 20 below holds whenever the underlying evaluation rules fit the schema, as is the case with the rules for the omitted operators. <p> We must have u = ^ff for some ff with ff &lt; u 0 . Now we just need to apply Lemma 17. The proof that ffi is operator-respecting is an extension of the method of <ref> [11, 13] </ref>. One of the main differences is that for the cases for rules (ap ) and (ap ~ ), we need to already know the restricted substitution property stated in Theorem 13. We continue to omit any mention of operators not treated in Section 2. <p> It is straightforward to verify that the precongruence candidate has the following properties (see <ref> [13] </ref> for details): it is reflexive, it is operator respecting, if e 1 b e 2 e 3 then e 1 b e 3 , if e + v, e 0 + v 0 and v b v 0 , then v [ b ] v 0 , if e ffi
Reference: 14. <author> D. J. Howe and S. D. Stoller. </author> <title> An operational approach to combining classical set theory and functional programming languages. </title> <booktitle> In Theoretical Aspects of Computer Software, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: The idea for the proof of Theorem 20 first appeared in [11]. An expanded treatment of the proof method is in [12]. In <ref> [14] </ref> we gave a type theory that contained ZF set theory. Although that theory is in some respects similar to Nuprl, the programming language in the theory is typed in an essential way and hence the semantics cannot be applied to Nuprl.
Reference: 15. <author> P. B. Jackson. </author> <title> Exploring abstract algebra in constructive type theory. </title> <editor> In A. Bundy, editor, </editor> <booktitle> 12th Conference on Automated Deduction, Lecture Notes in Ar-tifical Intelligence. </booktitle> <publisher> Springer, </publisher> <month> June </month> <year> 1994. </year>
Reference-contexts: Most of these features have been recognized in the HOL community as desirable for HOL. See, for example, [18, 16, 21]. There have been a number of substantial applications of Nuprl (see <ref> [15] </ref> for a recent example), but there has been nothing like the sustained effort of the HOL community in formalizing mathematics useful for verification. There are two main motivations for the present work. The first is to make up for Nuprl's relative lack of libraries of mathematics.
Reference: 16. <author> B. Jacobs and T. Melham. </author> <title> Translating dependent type theory into higher order logic. </title> <booktitle> In Proceedings of the Second International Conference on Typed Lambda Calculi and Applications, volume 664 of Lecture Notes in Computer Science, </booktitle> <pages> pages 209-229. </pages> <publisher> Springer, </publisher> <year> 1993. </year>
Reference-contexts: Writing programs. Nuprl includes a programming language which, while primitive, includes many of the features, such as function definition by gen eral recursion, of a conventional functional programming language. Most of these features have been recognized in the HOL community as desirable for HOL. See, for example, <ref> [18, 16, 21] </ref>. There have been a number of substantial applications of Nuprl (see [15] for a recent example), but there has been nothing like the sustained effort of the HOL community in formalizing mathematics useful for verification. There are two main motivations for the present work.
Reference: 17. <author> P. Martin-Lof. </author> <title> Constructive mathematics and computer programming. </title> <booktitle> In Sixth International Congress for Logic, Methodology, and Philosophy of Science, </booktitle> <pages> pages 153-175, </pages> <address> Amsterdam, 1982. </address> <publisher> North Holland. </publisher>
Reference-contexts: However, the two logics are very different in a number of ways. Nuprl has a constructive type theory, based on a type theory of Martin-Lof <ref> [17] </ref>. The theory contains a programming language, and all objects have a computational interpretation. Programs are reasoned about directly in logic, and the constructivity of the theory means that programs can be synthesised from proofs. <p> Thus, for this rule to be valid, the truth of the first premise must guarantee this "functionality" of x: b. This gives rise to a "functionality semantics" for sequents. A functionality semantics is given by Martin-Lof in <ref> [17] </ref>. This semantics is itself fairly complicated. However, for technical reasons having to do with several essential practical considerations, including reasoning about general recursive programs, and collapsing Martin-Lof's four forms of judgement into one, Nuprl requires a more refined notion of functionality.
Reference: 18. <author> T. Melham. </author> <title> The HOL logic extended with quantification over type variables. Formal Methods in System Design, </title> <address> 3(1-2):7-24, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: Writing programs. Nuprl includes a programming language which, while primitive, includes many of the features, such as function definition by gen eral recursion, of a conventional functional programming language. Most of these features have been recognized in the HOL community as desirable for HOL. See, for example, <ref> [18, 16, 21] </ref>. There have been a number of substantial applications of Nuprl (see [15] for a recent example), but there has been nothing like the sustained effort of the HOL community in formalizing mathematics useful for verification. There are two main motivations for the present work.
Reference: 19. <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Nuprl's type theory offers a number of advantages over HOL's logic. Expressive power of the type system. Nuprl has subtypes and dependent function types. Also, through the use of universes and "sigma" types, one can express modules of the kind found in Standard ML <ref> [19] </ref>. - Constructivity. Experience with Nuprl has shown that for the mathematics of ordinary programs, constructivity comes at essentially no cost. Thus it seems to be a strict loss that one cannot extract programs from formal proofs in HOL. Writing programs.
Reference: 20. <author> E. Ritter and A. Pitts. </author> <title> A fully abstract translation between a -calculus with reference types and Standard ML. </title> <booktitle> In Proceedings of the Second International Conference on Typed Lambda Calculi and Applications, volume 902 of Lecture Notes in Computer Science, </booktitle> <pages> pages 397-413. </pages> <publisher> Springer, </publisher> <year> 1995. </year>
Reference-contexts: The approach to operational semantics builds on our work described in [13]. Evidence for the robustness of this approach with respect to changes in the programming language can be found, for example, in the adaptations of our approach by Pitts and Gordon, described in <ref> [20, 7] </ref>. In Section 3, we show how to apply this semantics to the Nuprl logic as described in [5].
Reference: 21. <author> M. van der Voort. </author> <title> Introducing well-founded function definitions in HOL. In Higher Order Logic Theorem Proving and Its Applications, </title> <journal> volume A-20 of IFIP Transactions, </journal> <pages> pages 117-131. </pages> <publisher> North-Holland, </publisher> <year> 1993. </year> <title> 20 This article was processed using the L a T E X macro package with LLNCS style 21 </title>
Reference-contexts: Writing programs. Nuprl includes a programming language which, while primitive, includes many of the features, such as function definition by gen eral recursion, of a conventional functional programming language. Most of these features have been recognized in the HOL community as desirable for HOL. See, for example, <ref> [18, 16, 21] </ref>. There have been a number of substantial applications of Nuprl (see [15] for a recent example), but there has been nothing like the sustained effort of the HOL community in formalizing mathematics useful for verification. There are two main motivations for the present work.
References-found: 21

