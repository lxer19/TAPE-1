URL: http://www.cs.duke.edu/~large/Papers/vldb.ps
Refering-URL: http://www.cs.duke.edu/~large/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: large@cs.duke.edu.  Email: tavi@cs.duke.edu.  Email: sridhar@research.bell-labs.com.  Email: suel@research.bell-labs.com.  Email: jsv@cs.duke.edu.  
Title: Scalable Sweeping-Based Spatial Join  
Author: Lars Arge Octavian Procopiuc Sridhar Ramaswamy Torsten Suel Jeffrey Scott Vitter 
Date: 1998  
Web: CCR9522047.  
Note: 277080129. Supported in part by U.S. Army Research Office grant DAAH049610013.  277080129. Supported in part by the U.S. Army Research Office under grant DAAH049610013 and by the National Science Foundation under grant  277080129. Supported in part by the U.S. Army Research Office under grant DAAH049610013 and by the National Science Foundation under grant CCR9522047. Part of this work was done while visiting Bell  Proceedings of the 24th VLDB Conference  
Address: Durham, NC  Durham, NC  Mountain Avenue, Box 636, Murray Hill, NJ 079740636.  Mountain Avenue, Box 636, Murray Hill, NJ 079740636.  Durham, NC  Murray Hill, NJ.  New York, USA,  
Affiliation: Center for Geometric Computing, Department of Computer Science, Duke University,  Center for Geometric Computing, Department of Computer Science, Duke University,  Information Sciences Research Center, Bell Laboratories, 600  Information Sciences Research Center, Bell Laboratories, 600  Center for Geometric Computing, Department of Computer Science, Duke University,  Laboratories,  
Abstract: In this paper, we consider the filter step of the spatial join problem, for the case where neither of the inputs are indexed. We present a new algorithm, Scalable Sweeping-Based Spatial Join (SSSJ), that achieves both efficiency on real-life data and robustness against highly skewed and worst-case data sets. The algorithm combines a method with theoretically optimal bounds on I/O transfers based on the recently proposed distribution-sweeping technique with a highly optimized implementation of internal-memory plane-sweeping. We present experimental results based on an efficient implementation of the SSSJ algorithm, and compare it to the state-of-the-art Partition-Based Spatial-Merge (PBSM) algorithm of Patel and DeWitt. Permission to copy without fee all or part of this material is granted provided that the copies are not made or distributed for direct commercial advantage, the VLDB copyright notice and the title of the publication and its date appear, and notice is given that copying is by permission of the Very Large Data Base Endowment. To copy otherwise, or to republish, requires a fee and/or special permission from the Endowment. 
Abstract-found: 1
Intro-found: 1
Reference: [Aga96] <author> Ramesh C. Agarwal. </author> <title> A super scalar sort algorithm for RISC processors. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 240246, </pages> <year> 1996. </year>
Reference-contexts: Second, it allows for a simple and fast implementation, by leveraging the performance of the highly tuned sorting routines offered by many database systems. There has been considerable work on optimized database sorts in recent years (see, e.g,, <ref> [Aga96, DDC + 97, NBC + 94] </ref>), and it appears wise to try to draw on these results. 6 Fast Plane-Sweeping Methods As mentioned already, the overall efficiency of many spatial join algorithm is greatly influenced by the internal-memory join algorithm used as a subroutine.
Reference: [AM] <author> L. Arge and P. B. Miltersen. </author> <title> On showing lower bounds for external-memory computational geometry. </title> <type> Manuscript, </type> <year> 1998. </year>
Reference-contexts: We will show that the following algorithm performs O (n log m n + t) I/O operations, and thus asymptotically matches the lower bound implied by the sorting lower bound of [AV88] (see also <ref> [AM] </ref>). It can be shown that the algorithm is also optimal in terms of CPU time.
Reference: [APR + 98] <author> L. Arge, O. Procopiuc, S. Ramaswamy, T. Suel, and J. S. Vitter. </author> <title> Theory and practice of I/O-efficient algorithms for multidimensional batched searching problems. </title> <booktitle> In Proc. ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 685694, </pages> <year> 1998. </year>
Reference-contexts: The algorithm uses several techniques for I/O-efficient computing recently proposed in computational geometry <ref> [APR + 98, GTVV93, Arg95, AVV98, Arg97] </ref>, plus the well-known internal-memory plane-sweeping technique (see, e.g., [PS85]). It achieves theoretically optimal worst-case bounds on both internal computation time and I/O transfers, while also being efficient on the more well-behaved data sets common in practice. <p> This algorithm will be used as a building block in the SSSJ algorithm described in the next section. We point out that this section is based on the results and theoretical framework developed in <ref> [APR + 98] </ref>. The algorithm uses the distribution-sweeping technique developed in [GTVV93] and further developed in [Arg95, AVV98].
Reference: [ARC93] <author> ARC/INFO. </author> <title> Understanding GISthe ARC/INFO method. </title> <address> ARC/INFO, </address> <year> 1993. </year> <note> Rev. 6 for workstations. </note>
Reference-contexts: 1 Introduction and Motivation Geographic Information Systems (GIS) have generated enormous interest in the commercial and research database communities over the last decade. Several commercial products that manage spatial data are available. These include ESRI's ARC/INFO <ref> [ARC93] </ref>, Inter-Graph's MGE [Int97], and Informix [Ube94]. GISs typically store and manage spatial data such as points, lines, poly-lines, polygons, and surfaces. Since the amount of data they manage is quite large, GISs are often disk-based systems.
Reference: [Arg95] <author> L. Arge. </author> <title> The buffer tree: A new technique for optimal I/O-algorithms. </title> <booktitle> In Proc. Workshop on Algorithms and Data Structures, </booktitle> <volume> LNCS 955, </volume> <pages> pages 334345, </pages> <year> 1995. </year> <note> A complete version appears as BRICS Technical Report RS-96-28, </note> <institution> University of Aarhus. </institution>
Reference-contexts: The algorithm uses several techniques for I/O-efficient computing recently proposed in computational geometry <ref> [APR + 98, GTVV93, Arg95, AVV98, Arg97] </ref>, plus the well-known internal-memory plane-sweeping technique (see, e.g., [PS85]). It achieves theoretically optimal worst-case bounds on both internal computation time and I/O transfers, while also being efficient on the more well-behaved data sets common in practice. <p> We point out that this section is based on the results and theoretical framework developed in [APR + 98]. The algorithm uses the distribution-sweeping technique developed in [GTVV93] and further developed in <ref> [Arg95, AVV98] </ref>. Following Aggarwal and Vitter [AV88] we use the following I/O-model: We make the assumption that each access to disk transmits one disk block with B units of data, and we count this as one I/O operation. 4 We denote the total amount of main memory by M .
Reference: [Arg97] <author> L. Arge. </author> <title> External-memory algorithms with applications in geographic information systems. </title> <editor> In M. van Kreveld, J. Nievergelt, T. Roos, and P. Wid-mayer, editors, </editor> <booktitle> Algorithmic Foundations of GIS. Springer-Verlag, Lecture Notes in Computer Science 1340, </booktitle> <year> 1997. </year>
Reference-contexts: The algorithm uses several techniques for I/O-efficient computing recently proposed in computational geometry <ref> [APR + 98, GTVV93, Arg95, AVV98, Arg97] </ref>, plus the well-known internal-memory plane-sweeping technique (see, e.g., [PS85]). It achieves theoretically optimal worst-case bounds on both internal computation time and I/O transfers, while also being efficient on the more well-behaved data sets common in practice.
Reference: [AV88] <author> A. Aggarwal and J. S. Vitter. </author> <title> The Input/Output complexity of sorting and related problems. </title> <journal> Communications of the ACM, </journal> <volume> 31(9):11161127, </volume> <year> 1988. </year>
Reference-contexts: We point out that this section is based on the results and theoretical framework developed in [APR + 98]. The algorithm uses the distribution-sweeping technique developed in [GTVV93] and further developed in [Arg95, AVV98]. Following Aggarwal and Vitter <ref> [AV88] </ref> we use the following I/O-model: We make the assumption that each access to disk transmits one disk block with B units of data, and we count this as one I/O operation. 4 We denote the total amount of main memory by M . <p> We assume that at the beginning of the algorithm, P and Q have already been sorted into one list L of intervals by their lower boundaries, which can be done in O (n log m n) I/O operations using, say, the optimal sorting algorithm from <ref> [AV88] </ref>. We will show that the following algorithm then completes the interval join in O (n + t) I/O operations. Algorithm Interval Join: (1) Scan the list in order of increasing lower boundaries, maintaining two initially empty lists L P and L Q of active intervals from P and Q. <p> The problem is to report all intersections between a rectangle in P and a rectangle in Q. We will show that the following algorithm performs O (n log m n + t) I/O operations, and thus asymptotically matches the lower bound implied by the sorting lower bound of <ref> [AV88] </ref> (see also [AM]). It can be shown that the algorithm is also optimal in terms of CPU time.
Reference: [AVV98] <author> L. Arge, D. E. Vengroff, and J. S. Vitter. </author> <title> External-memory algorithms for processing line segments in geographic information systems. </title> <note> Algorithmica (to appear in special issues on Geographical Information Systems), 1998. Extended abstract appears in Proc. of Third European Symposium on Algorithms, ESA'95. </note>
Reference-contexts: The algorithm uses several techniques for I/O-efficient computing recently proposed in computational geometry <ref> [APR + 98, GTVV93, Arg95, AVV98, Arg97] </ref>, plus the well-known internal-memory plane-sweeping technique (see, e.g., [PS85]). It achieves theoretically optimal worst-case bounds on both internal computation time and I/O transfers, while also being efficient on the more well-behaved data sets common in practice. <p> We point out that this section is based on the results and theoretical framework developed in [APR + 98]. The algorithm uses the distribution-sweeping technique developed in [GTVV93] and further developed in <ref> [Arg95, AVV98] </ref>. Following Aggarwal and Vitter [AV88] we use the following I/O-model: We make the assumption that each access to disk transmits one disk block with B units of data, and we count this as one I/O operation. 4 We denote the total amount of main memory by M .
Reference: [Ben77] <author> J. L. Bentley. </author> <title> Algorithms for Klee's rectangle problems. </title> <institution> Dept. of Computer Science, Carnegie Mellon Univ., </institution> <note> unpublished notes, </note> <year> 1977. </year>
Reference-contexts: Many optimal and suboptimal dynamic data structures for intervals have been proposed; important examples are the interval tree [Ede83], the priority search tree [McC85], and the segment tree <ref> [Ben77] </ref>. 4.2 The Square-Root Rule In most implementations of plane-sweeping algorithms, the maximum amount of memory ever needed is determined by the maximum number of rectangles that are intersected by a single horizontal line.
Reference: [BG92] <author> L. Becker and R. H. Guting. </author> <title> Rule-based optimization and query processing in an extensible geometric database system. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(2):247303, </volume> <year> 1992. </year>
Reference-contexts: all our realistic data sets of size N , this sweepline structure never grew beyond size O ( p This observation, which is known as the square-root rule in the VLSI literature (see, e.g., [GS87]), seems to have been largely overlooked in the spatial join literature (with the exception of <ref> [BG92] </ref>). It implies that for most real-life data sets, we can bypass the vertical partitioning step in our algorithm and directly perform the 1 with the exception of the work in [GS87] plane-sweeping algorithm after the initial sorting step. <p> They are also the first to consider the effect of I/O from an analytical standpoint; the algorithmic bounds they obtain are slightly suboptimal in the number of I/O operations. Their algorithm was subsequently implemented in the Gral system <ref> [BG92] </ref>, an extensible database system for geometric applications, but we are not aware of any experimental comparison with other approaches. The work in [GS87, BG92] is probably the previous contribution most closely related to our approach. <p> Their algorithm was subsequently implemented in the Gral system [BG92], an extensible database system for geometric applications, but we are not aware of any experimental comparison with other approaches. The work in <ref> [GS87, BG92] </ref> is probably the previous contribution most closely related to our approach. In particular, the algorithm that is proposed is similar to ours in that it partitions the input along a single axis.
Reference: [BHF93] <author> L. Becker, K. Hinrichs, and U. Finke. </author> <title> A new algorithm for computing joins with grid files. </title> <booktitle> In International Conference on Data Engineering, pages 190198, 1993. </booktitle> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: The performance of the resulting algorithm is sensitive to the size of the pixels chosen, in that smaller pixels leads to better filtering, but also increase the number of pixels associated with each object. In another transformational approach <ref> [BHF93] </ref>, the MBRs of spatial objects (which are rectangles in two dimensions) are transformed into points in four dimensions. The resulting points are stored in a multi-attribute data structure such as the grid file [NHS84], which is then used for the filter step.
Reference: [BKS93] <author> T. Brinkhoff, H.-P. Kriegel, and B. Seeger. </author> <title> Efficient processing of spatial joins using R-trees. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <year> 1993. </year>
Reference-contexts: There has recently been much interest in using spatial index structures like the R-tree [Gut85], R + - tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree [Sam89] to speed up the filter step of the spatial join. Brinkhoff, Kriegel, and Seeger <ref> [BKS93] </ref> propose a spatial join algorithm based on R fl -trees. Their algorithm is a carefully synchronized depth-first traversal of the two trees to be joined. <p> They construct an index for that relation on the fly, by using the index on the other relation as a starting point (the seed). Once the index is constructed, the tree join algorithm of <ref> [BKS93] </ref> is used to perform the actual join. The other major direction for research on the spatial join has focused on the case where neither of the input relations has an index. <p> Lo and Ravishankar [LR95] propose to first build indices for the relations on the fly using spatial sampling techniques and then use the tree join algorithm of <ref> [BKS93] </ref> for computing the join. Another recent paper [KS97] proposes an algorithm based on a filter tree structure. <p> Patel and DeWitt [PD96] and Lo and Ravis-hankar [LR96] both propose hash-based spatial join algorithms that use a spatial partitioning function to subdivide the input, such that each partition fits entirely in memory. Patel and DeWitt then use a plane-sweeping algorithm proposed in <ref> [BKS93] </ref> to perform the join within each partition, while Lo and Ravishankar use an indexed nested loop join. Guting and Schilling [GS87] give an interesting discussion of plane-sweeping for computing rectangle intersections, and point out the importance of the square-root rule for this problem. <p> We implemented several versions of this data structure. In the following we first give a generic description of the plane-sweeping algorithm, and then describe the different data structure implementations. We also describe the plane-sweeping algorithm used in PBSM, which we also implemented for comparison. This algorithm was proposed in <ref> [BKS93] </ref>, and does not use an interval data structure. <p> However, we expect this algorithm to perform very well for real-life data sets that have many small rectangles and that are not extremely clustered in one area. Algorithm Forward Sweep is the plane-sweeping algorithm employed by Patel and DeWitt in PBSM, and was first proposed in <ref> [BKS93] </ref>. <p> We have also studied the performance of several internal-memory plane-sweeping algorithms and their implications for the overall performance of spatial joins. In our future work, we plan to compare the performance of SSSJ against tree-based methods <ref> [BKS93] </ref>. We also plan to study the problem of higher-dimensional joins. In particular, three-dimensional joins would be interesting since they arise quite naturally in GIS.
Reference: [BKSS90] <author> N. Beckmann, H.-P. Kriegel, R. Schneider, and B. Seeger. </author> <title> The R*-tree: An efficient and robust access method for points and rectangles. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <year> 1990. </year>
Reference-contexts: The join index used in [Rot91] partially computes the result of the spatial join using a grid file. There has recently been much interest in using spatial index structures like the R-tree [Gut85], R + - tree [SRF87], R fl -tree <ref> [BKSS90] </ref>, and PMR quad-tree [Sam89] to speed up the filter step of the spatial join. Brinkhoff, Kriegel, and Seeger [BKS93] propose a spatial join algorithm based on R fl -trees. Their algorithm is a carefully synchronized depth-first traversal of the two trees to be joined.
Reference: [Chi95] <author> Y.-J. Chiang. </author> <title> Experiments on the practical I/O efficiency of geometric algorithms: Distribution sweep vs. plane sweep. </title> <booktitle> In Proc. Workshop on Algorithms and Data Structures, </booktitle> <volume> LNCS 955, </volume> <pages> pages 346357, </pages> <year> 1995. </year>
Reference-contexts: We generated two data sets of skewed rectangles, following a procedure used in <ref> [Chi95] </ref>. Each data set contains two sets of N=2 rectangles each, placed in the [0; N ] fi [0; N ] square.
Reference: [CLR90] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1990. </year>
Reference-contexts: Algorithm Tree Sweep uses a data structure that is essentially a combination of an interval tree [Ede83] and a skip list [Pug90]. More precisely, we used a simplified dynamic version of the interval tree similar to that described in Section 15.3 and Exercise 15.34 of <ref> [CLR90] </ref>, but implemented the structure using a randomized skip list instead of a balanced tree structure. (Another, though somewhat different, structure combining interval trees and skip lists has been described in [Han91].) Our reason for using a skip list is that it allows for a fairly simple but efficient implementation while
Reference: [DDC + 97] <author> A. C. Arpaci Dusseau, R. H. Arpaci Dusseau, D. E. Culler, J. M. Hellerstein, and D. A. Patterson. </author> <title> High-performance sorting on networks of workstations. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 243254, </pages> <year> 1997. </year>
Reference-contexts: Second, it allows for a simple and fast implementation, by leveraging the performance of the highly tuned sorting routines offered by many database systems. There has been considerable work on optimized database sorts in recent years (see, e.g,, <ref> [Aga96, DDC + 97, NBC + 94] </ref>), and it appears wise to try to draw on these results. 6 Fast Plane-Sweeping Methods As mentioned already, the overall efficiency of many spatial join algorithm is greatly influenced by the internal-memory join algorithm used as a subroutine.
Reference: [Ede83] <author> H. Edelsbrunner. </author> <title> A new approach to rectangle intersections, part I. </title> <journal> Int. J. Computer Mathematics, </journal> <volume> 13:209219, </volume> <year> 1983. </year>
Reference-contexts: Many optimal and suboptimal dynamic data structures for intervals have been proposed; important examples are the interval tree <ref> [Ede83] </ref>, the priority search tree [McC85], and the segment tree [Ben77]. 4.2 The Square-Root Rule In most implementations of plane-sweeping algorithms, the maximum amount of memory ever needed is determined by the maximum number of rectangles that are intersected by a single horizontal line. <p> Finally, we refer to the algorithm used in PBSM as Forward Sweep. In the following we discuss each of these algorithms. Algorithm Tree Sweep uses a data structure that is essentially a combination of an interval tree <ref> [Ede83] </ref> and a skip list [Pug90]. <p> However, on real-life data, the intersection query time is usually O (log N + T ), as most intersecting rectangles are typically close to each other in the tree. Thus, we would not expect significant improvements from more complicated, but asymptotically optimal data structures <ref> [McC85, Ede83] </ref>. Algorithm List Sweep uses a simple linked-list data structure. To decrease allocation and other overheads and improve locality, each element of the linked list can hold up to 16 rectangles.
Reference: [GS87] <author> R. H. Guting and W. Schilling. </author> <title> A practical divide-and-conquer algorithm for the rectangle intersection problem. </title> <journal> Information Sciences, </journal> <volume> 42:95112, </volume> <year> 1987. </year>
Reference-contexts: During our initial experiments, we observed that on all our realistic data sets of size N , this sweepline structure never grew beyond size O ( p This observation, which is known as the square-root rule in the VLSI literature (see, e.g., <ref> [GS87] </ref>), seems to have been largely overlooked in the spatial join literature (with the exception of [BG92]). It implies that for most real-life data sets, we can bypass the vertical partitioning step in our algorithm and directly perform the 1 with the exception of the work in [GS87] plane-sweeping algorithm after <p> literature (see, e.g., <ref> [GS87] </ref>), seems to have been largely overlooked in the spatial join literature (with the exception of [BG92]). It implies that for most real-life data sets, we can bypass the vertical partitioning step in our algorithm and directly perform the 1 with the exception of the work in [GS87] plane-sweeping algorithm after the initial sorting step. The result is a conceptually very simple algorithm, which from an I/O perspective just consists of an external sort followed by a single scan through the data. <p> Patel and DeWitt then use a plane-sweeping algorithm proposed in [BKS93] to perform the join within each partition, while Lo and Ravishankar use an indexed nested loop join. Guting and Schilling <ref> [GS87] </ref> give an interesting discussion of plane-sweeping for computing rectangle intersections, and point out the importance of the square-root rule for this problem. <p> Their algorithm was subsequently implemented in the Gral system [BG92], an extensible database system for geometric applications, but we are not aware of any experimental comparison with other approaches. The work in <ref> [GS87, BG92] </ref> is probably the previous contribution most closely related to our approach. In particular, the algorithm that is proposed is similar to ours in that it partitions the input along a single axis. <p> For most real life input data this number, which we will refer to as the maximum overlap of a data set, is actually significantly smaller than the total number of rectangles. This observation has previously been made by other researchers (see <ref> [GS87] </ref> and the references therein), and is known as the square-root rule in the VLSI literature.
Reference: [GTVV93] <author> M. T. Goodrich, J.-J. Tsay, D. E. Vengroff, and J. S. Vitter. </author> <title> External-memory computational geometry. </title> <booktitle> In Proc. IEEE Symp. on Foundations of Comp. Sci., </booktitle> <pages> pages 714723, </pages> <year> 1993. </year>
Reference-contexts: The algorithm uses several techniques for I/O-efficient computing recently proposed in computational geometry <ref> [APR + 98, GTVV93, Arg95, AVV98, Arg97] </ref>, plus the well-known internal-memory plane-sweeping technique (see, e.g., [PS85]). It achieves theoretically optimal worst-case bounds on both internal computation time and I/O transfers, while also being efficient on the more well-behaved data sets common in practice. <p> This algorithm will be used as a building block in the SSSJ algorithm described in the next section. We point out that this section is based on the results and theoretical framework developed in [APR + 98]. The algorithm uses the distribution-sweeping technique developed in <ref> [GTVV93] </ref> and further developed in [Arg95, AVV98].
Reference: [Gun93] <author> O. Gunther. </author> <title> Efficient computation of spatial joins. </title> <booktitle> In International Conference on Data Engineering, </booktitle> <pages> pages 5060, </pages> <address> 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Their algorithm is a carefully synchronized depth-first traversal of the two trees to be joined. An improvement of this algorithm was recently reported in [HJR97]. (Another interesting technique for efficiently traversing a multi-dimensional index structure was proposed in [KHT89] in a slightly different context.) G unther <ref> [Gun93] </ref> studies the tradeoffs between using join indices and spatial indices for the spatial join. Hoel and Samet [HS92] propose the use of PMR quad-trees for the spatial join and compare it against members of the R-tree family.
Reference: [Gut85] <author> A. Guttman. R-trees: </author> <title> A dynamic index structure for spatial searching. </title> <booktitle> In Proc. ACM-SIGMOD Conf. on Management of Data, </booktitle> <pages> pages 4757, </pages> <year> 1985. </year>
Reference-contexts: Rotem [Rot91] proposes a spatial join algorithm based on the join index of Valduriez [Val87]. The join index used in [Rot91] partially computes the result of the spatial join using a grid file. There has recently been much interest in using spatial index structures like the R-tree <ref> [Gut85] </ref>, R + - tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree [Sam89] to speed up the filter step of the spatial join. Brinkhoff, Kriegel, and Seeger [BKS93] propose a spatial join algorithm based on R fl -trees.
Reference: [Han91] <author> E. N. Hanson. </author> <title> The interval skip list: A data structure for finding all intervals that overlap a point. </title> <booktitle> In Proceedings of Algorithms and Data Structures (WADS '91), volume 519 of LNCS, </booktitle> <pages> pages 153 164. </pages> <publisher> Springer, </publisher> <year> 1991. </year>
Reference-contexts: a simplified dynamic version of the interval tree similar to that described in Section 15.3 and Exercise 15.34 of [CLR90], but implemented the structure using a randomized skip list instead of a balanced tree structure. (Another, though somewhat different, structure combining interval trees and skip lists has been described in <ref> [Han91] </ref>.) Our reason for using a skip list is that it allows for a fairly simple but efficient implementation while matching (in a probabilistic sense) the good worst-case behavior of a balanced tree.
Reference: [HJR97] <author> Y.-W. Huang, N. Jing, and E. A. Rundensteiner. </author> <title> Spatial joins using R-trees: Breadth-first traversal with global optimizations. </title> <booktitle> In Proc. IEEE International Conf. on Very Large Databases, </booktitle> <pages> pages 396 405, </pages> <year> 1997. </year>
Reference-contexts: Brinkhoff, Kriegel, and Seeger [BKS93] propose a spatial join algorithm based on R fl -trees. Their algorithm is a carefully synchronized depth-first traversal of the two trees to be joined. An improvement of this algorithm was recently reported in <ref> [HJR97] </ref>. (Another interesting technique for efficiently traversing a multi-dimensional index structure was proposed in [KHT89] in a slightly different context.) G unther [Gun93] studies the tradeoffs between using join indices and spatial indices for the spatial join.
Reference: [HS92] <author> E. G. Hoel and H. Samet. </author> <title> A qualitative comparison study of data structures for large linear segment databases. </title> <booktitle> In Proc. ACM SIGMOD Conf., </booktitle> <pages> page 205, </pages> <year> 1992. </year>
Reference-contexts: An improvement of this algorithm was recently reported in [HJR97]. (Another interesting technique for efficiently traversing a multi-dimensional index structure was proposed in [KHT89] in a slightly different context.) G unther [Gun93] studies the tradeoffs between using join indices and spatial indices for the spatial join. Hoel and Samet <ref> [HS92] </ref> propose the use of PMR quad-trees for the spatial join and compare it against members of the R-tree family. Lo and Ravishankar [LR94] discuss the case where exactly one of the relations does not have an index.
Reference: [Int97] <institution> Intergraph Corp. MGE 7.0, </institution> <note> http://www.inter-graph.com/iss/products/mge/mge-7.0.htm, 1997. </note>
Reference-contexts: 1 Introduction and Motivation Geographic Information Systems (GIS) have generated enormous interest in the commercial and research database communities over the last decade. Several commercial products that manage spatial data are available. These include ESRI's ARC/INFO [ARC93], Inter-Graph's MGE <ref> [Int97] </ref>, and Informix [Ube94]. GISs typically store and manage spatial data such as points, lines, poly-lines, polygons, and surfaces. Since the amount of data they manage is quite large, GISs are often disk-based systems.
Reference: [KHT89] <author> M. Kitsuregawa, L. Harada, and M. Takagi. </author> <title> Join strategies on kd-tree indexed relations. </title> <booktitle> In International Conference on Data Engineering, </booktitle> <pages> pages 8593, </pages> <address> 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Their algorithm is a carefully synchronized depth-first traversal of the two trees to be joined. An improvement of this algorithm was recently reported in [HJR97]. (Another interesting technique for efficiently traversing a multi-dimensional index structure was proposed in <ref> [KHT89] </ref> in a slightly different context.) G unther [Gun93] studies the tradeoffs between using join indices and spatial indices for the spatial join. Hoel and Samet [HS92] propose the use of PMR quad-trees for the spatial join and compare it against members of the R-tree family.
Reference: [KS97] <author> N. Koudas and K. C. Sevcik. </author> <title> Size separation spatial join. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 324335, </pages> <year> 1997. </year>
Reference-contexts: Lo and Ravishankar [LR95] propose to first build indices for the relations on the fly using spatial sampling techniques and then use the tree join algorithm of [BKS93] for computing the join. Another recent paper <ref> [KS97] </ref> proposes an algorithm based on a filter tree structure. Patel and DeWitt [PD96] and Lo and Ravis-hankar [LR96] both propose hash-based spatial join algorithms that use a spatial partitioning function to subdivide the input, such that each partition fits entirely in memory.
Reference: [LR94] <author> M.-L. Lo and C. V. Ravishankar. </author> <title> Spatial joins using seeded trees. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 209220, </pages> <year> 1994. </year>
Reference-contexts: Hoel and Samet [HS92] propose the use of PMR quad-trees for the spatial join and compare it against members of the R-tree family. Lo and Ravishankar <ref> [LR94] </ref> discuss the case where exactly one of the relations does not have an index. They construct an index for that relation on the fly, by using the index on the other relation as a starting point (the seed).
Reference: [LR95] <author> M.-L. Lo and C. V. Ravishankar. </author> <title> Generating seeded trees from data sets. </title> <booktitle> In Proc. International Symp. on Large Spatial Databases, </booktitle> <year> 1995. </year>
Reference-contexts: Once the index is constructed, the tree join algorithm of [BKS93] is used to perform the actual join. The other major direction for research on the spatial join has focused on the case where neither of the input relations has an index. Lo and Ravishankar <ref> [LR95] </ref> propose to first build indices for the relations on the fly using spatial sampling techniques and then use the tree join algorithm of [BKS93] for computing the join. Another recent paper [KS97] proposes an algorithm based on a filter tree structure.
Reference: [LR96] <author> M.-L. Lo and C. V. Ravishankar. </author> <title> Spatial hash-joins. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 247258, </pages> <year> 1996. </year>
Reference-contexts: Another recent paper [KS97] proposes an algorithm based on a filter tree structure. Patel and DeWitt [PD96] and Lo and Ravis-hankar <ref> [LR96] </ref> both propose hash-based spatial join algorithms that use a spatial partitioning function to subdivide the input, such that each partition fits entirely in memory.
Reference: [McC85] <author> E.M. McCreight. </author> <title> Priority search trees. </title> <journal> SIAM Journal of Computing, </journal> <volume> 14(2):257276, </volume> <year> 1985. </year>
Reference-contexts: Many optimal and suboptimal dynamic data structures for intervals have been proposed; important examples are the interval tree [Ede83], the priority search tree <ref> [McC85] </ref>, and the segment tree [Ben77]. 4.2 The Square-Root Rule In most implementations of plane-sweeping algorithms, the maximum amount of memory ever needed is determined by the maximum number of rectangles that are intersected by a single horizontal line. <p> However, on real-life data, the intersection query time is usually O (log N + T ), as most intersecting rectangles are typically close to each other in the tree. Thus, we would not expect significant improvements from more complicated, but asymptotically optimal data structures <ref> [McC85, Ede83] </ref>. Algorithm List Sweep uses a simple linked-list data structure. To decrease allocation and other overheads and improve locality, each element of the linked list can hold up to 16 rectangles.
Reference: [NBC + 94] <author> C. Nyberg, T. Barclay, Z. Cvetanovic, J. Gray, and D. Lomet. AlphaSort: </author> <title> A RISC machine sort. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 233242, </pages> <year> 1994. </year>
Reference-contexts: Second, it allows for a simple and fast implementation, by leveraging the performance of the highly tuned sorting routines offered by many database systems. There has been considerable work on optimized database sorts in recent years (see, e.g,, <ref> [Aga96, DDC + 97, NBC + 94] </ref>), and it appears wise to try to draw on these results. 6 Fast Plane-Sweeping Methods As mentioned already, the overall efficiency of many spatial join algorithm is greatly influenced by the internal-memory join algorithm used as a subroutine.
Reference: [NHS84] <author> J. Nievergelt, H. Hinterberger, and K.C. Sevcik. </author> <title> The grid file: An adaptable, symmetric multikey file structure. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 9(1):257276, </volume> <year> 1984. </year>
Reference-contexts: In another transformational approach [BHF93], the MBRs of spatial objects (which are rectangles in two dimensions) are transformed into points in four dimensions. The resulting points are stored in a multi-attribute data structure such as the grid file <ref> [NHS84] </ref>, which is then used for the filter step. Rotem [Rot91] proposes a spatial join algorithm based on the join index of Valduriez [Val87]. The join index used in [Rot91] partially computes the result of the spatial join using a grid file.
Reference: [OM88] <author> J. A. Orenstein and F. A. Manola. </author> <title> PROBE spatial data modeling and query processing in an image database application. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(5):611629, </volume> <year> 1988. </year>
Reference-contexts: In this section, we discuss the various approaches that have been proposed to solve the filter step. (For the rest of the paper, we will use the term spatial join to refer to the filter step of the spatial join unless explicitly stated otherwise.) An early algorithm proposed by Orenstein <ref> [Ore86, OM88, Ore89] </ref> uses a space-filling curve, called Peano curve or z-ordering, to associate each rectangle with a set of small blocks, called pixels, on that curve, and then performs a sort-merge join along the curve.
Reference: [Ore86] <author> J. A. Orenstein. </author> <title> Spatial query processing in an object-oriented database system. </title> <editor> In Carlo Zaniolo, editor, </editor> <booktitle> Proceedings of the 1986 ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 326336, </pages> <year> 1986. </year>
Reference-contexts: In this section, we discuss the various approaches that have been proposed to solve the filter step. (For the rest of the paper, we will use the term spatial join to refer to the filter step of the spatial join unless explicitly stated otherwise.) An early algorithm proposed by Orenstein <ref> [Ore86, OM88, Ore89] </ref> uses a space-filling curve, called Peano curve or z-ordering, to associate each rectangle with a set of small blocks, called pixels, on that curve, and then performs a sort-merge join along the curve.
Reference: [Ore89] <author> J. A. Orenstein. </author> <title> Redundancy in spatial databases. </title> <booktitle> SIGMOD Record (ACM Special Interest Group on Management of Data), </booktitle> <address> 18(2):294305, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: In this section, we discuss the various approaches that have been proposed to solve the filter step. (For the rest of the paper, we will use the term spatial join to refer to the filter step of the spatial join unless explicitly stated otherwise.) An early algorithm proposed by Orenstein <ref> [Ore86, OM88, Ore89] </ref> uses a space-filling curve, called Peano curve or z-ordering, to associate each rectangle with a set of small blocks, called pixels, on that curve, and then performs a sort-merge join along the curve.
Reference: [Ore90] <author> J. A. Orenstein. </author> <title> A comparison of spatial query processing techniques for native and parameter spaces. </title> <booktitle> SIGMOD Record (ACM Special Interest Group on Management of Data), </booktitle> <address> 19(2):343352, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: One technique is to bound each spatial object by the smallest axis-parallel rectangle that completely contains it. This rectangle is referred to as the spatial object's minimum bounding rectangle (MBR). Spatial operations can then be performed in two steps <ref> [Ore90] </ref>: * Filter Step: The spatial operation is performed on the approximate representation, such as the MBR. For example, when joining two spatial relations, the first step is to identify all intersecting pairs of MBRs.
Reference: [PD96] <author> J. M. Patel and D. J. DeWitt. </author> <title> Partition based spatial-merge join. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <pages> pages 259270, </pages> <year> 1996. </year>
Reference-contexts: In the case where spatial indices have been built on both relations, these indices are commonly used in the implementation of the spatial join. In this paper, we focus on the case in which neither of the inputs to the join is indexed. As discussed in <ref> [PD96] </ref> such cases arise when the relations to be joined are intermediate results, and in a parallel database environment where inputs are coming in from multiple processors. 1.1 Summary of this Paper We present a new algorithm for the filter step called Scalable Sweeping-Based Spatial Join (SSSJ). <p> We present experimental results based on an efficient implementation of the SSSJ algorithm, and compare it to the original as well as an optimized version of the state-of-the-art Partition-Based Spatial-Merge (PBSM) algorithm of Patel and De-Witt <ref> [PD96] </ref>. <p> This basic idea of partitioning space such that the data in each partition fits in memory, and then solving the problem in each partition in internal memory, has been used in many algorithms, including, e.g., the PBSM algorithm <ref> [PD96] </ref>. However, unlike most previous algorithms 1 , our algorithm only partitions the data along one axis. Another important property of our algorithm is its theoretical optimality, which is based on the fact that, unlike in most other algorithms, no data replication occurs. <p> By using an efficient partitioning heuristic, we were able to decrease the time spent on performing the internal plane-sweep in PBSM by a factor of 4 as compared to the original implementation of Patel and DeWitt <ref> [PD96] </ref>. The data we used is a standard benchmark data for the spatial join, namely the Tiger/Line data from the US Bureau of Census [Tig92]. Our experiments showed that SSSJ performs at least 25% better than the original PBSM. <p> Lo and Ravishankar [LR95] propose to first build indices for the relations on the fly using spatial sampling techniques and then use the tree join algorithm of [BKS93] for computing the join. Another recent paper [KS97] proposes an algorithm based on a filter tree structure. Patel and DeWitt <ref> [PD96] </ref> and Lo and Ravis-hankar [LR96] both propose hash-based spatial join algorithms that use a spatial partitioning function to subdivide the input, such that each partition fits entirely in memory. <p> We implemented the SSSJ algorithm along with two versions of the PBSM algorithm, one that follows exactly the description of Patel and De-Witt <ref> [PD96] </ref> and one that replaces their internal-memory plane-sweeping procedure with Striped Sweep. We refer to the original and improved PBSM as QPBSM and MPBSM, respectively. We begin by giving a sketch of the PBSM algorithm.
Reference: [PS85] <author> F. P. Preparata and M. I. Shamos. </author> <title> Computational Geometry: An Introduction. </title> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: The algorithm uses several techniques for I/O-efficient computing recently proposed in computational geometry [APR + 98, GTVV93, Arg95, AVV98, Arg97], plus the well-known internal-memory plane-sweeping technique (see, e.g., <ref> [PS85] </ref>). It achieves theoretically optimal worst-case bounds on both internal computation time and I/O transfers, while also being efficient on the more well-behaved data sets common in practice. <p> Plane sweeping is one of the most basic algorithmic paradigms in computational geometry (see, e.g., <ref> [PS85] </ref>). Simply speaking, a plane-sweeping (or sweepline) algorithm attempts to solve a geometric problem by moving a vertical or horizontal sweepline across the scene, processing objects as they are reached by the sweepline. Clearly, for any pair of intersecting rectangles there is a horizontal line that passes through both rectangles.
Reference: [Pug90] <author> W. Pugh. </author> <title> Skip lists: A probabilistic alternative to balanced trees. </title> <journal> Communications of the ACM, </journal> <volume> 33(6):668676, </volume> <month> June </month> <year> 1990. </year>
Reference-contexts: Finally, we refer to the algorithm used in PBSM as Forward Sweep. In the following we discuss each of these algorithms. Algorithm Tree Sweep uses a data structure that is essentially a combination of an interval tree [Ede83] and a skip list <ref> [Pug90] </ref>.
Reference: [Rot91] <author> D. Rotem. </author> <title> Spatial join indices. </title> <booktitle> In International Conference on Data Engineering, </booktitle> <pages> pages 500509, </pages> <address> 1991. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: In another transformational approach [BHF93], the MBRs of spatial objects (which are rectangles in two dimensions) are transformed into points in four dimensions. The resulting points are stored in a multi-attribute data structure such as the grid file [NHS84], which is then used for the filter step. Rotem <ref> [Rot91] </ref> proposes a spatial join algorithm based on the join index of Valduriez [Val87]. The join index used in [Rot91] partially computes the result of the spatial join using a grid file. <p> The resulting points are stored in a multi-attribute data structure such as the grid file [NHS84], which is then used for the filter step. Rotem <ref> [Rot91] </ref> proposes a spatial join algorithm based on the join index of Valduriez [Val87]. The join index used in [Rot91] partially computes the result of the spatial join using a grid file.
Reference: [Sam89] <author> H. Samet. </author> <title> The Design and Analyses of Spatial Data Structures. </title> <publisher> Addison Wesley, </publisher> <address> MA, </address> <year> 1989. </year>
Reference-contexts: The join index used in [Rot91] partially computes the result of the spatial join using a grid file. There has recently been much interest in using spatial index structures like the R-tree [Gut85], R + - tree [SRF87], R fl -tree [BKSS90], and PMR quad-tree <ref> [Sam89] </ref> to speed up the filter step of the spatial join. Brinkhoff, Kriegel, and Seeger [BKS93] propose a spatial join algorithm based on R fl -trees. Their algorithm is a carefully synchronized depth-first traversal of the two trees to be joined.
Reference: [SRF87] <author> T. Sellis, N. Roussopoulos, and C. Faloutsos. </author> <title> The R + -tree: A dynamic index for multi-dimensional objects. </title> <booktitle> In Proc. IEEE International Conf. on Very Large Databases, </booktitle> <year> 1987. </year>
Reference-contexts: The join index used in [Rot91] partially computes the result of the spatial join using a grid file. There has recently been much interest in using spatial index structures like the R-tree [Gut85], R + - tree <ref> [SRF87] </ref>, R fl -tree [BKSS90], and PMR quad-tree [Sam89] to speed up the filter step of the spatial join. Brinkhoff, Kriegel, and Seeger [BKS93] propose a spatial join algorithm based on R fl -trees. Their algorithm is a carefully synchronized depth-first traversal of the two trees to be joined.
Reference: [Tig92] <author> Tiger/line files (tm), </author> <title> 1992 technical documentation. </title> <type> Technical report, </type> <institution> U. S. Bureau of the Census. </institution>
Reference-contexts: The data we used is a standard benchmark data for the spatial join, namely the Tiger/Line data from the US Bureau of Census <ref> [Tig92] </ref>. Our experiments showed that SSSJ performs at least 25% better than the original PBSM. <p> We consider the standard benchmark data for spatial join, namely the US Bureau of the Census TIGER/Line <ref> [Tig92] </ref> data. These data files consist of polygonal line entities representing physical features such as rivers, roads, railroad lines, etc. We used the data for the states of New Jersey, Rhode Island, Connecticut and New York.
Reference: [Ube94] <author> M. Ubell. </author> <title> The montage extensible datablade architecture. </title> <booktitle> In Proc. SIGMOD Intl. Conf. on Management of Data, </booktitle> <year> 1994. </year>
Reference-contexts: 1 Introduction and Motivation Geographic Information Systems (GIS) have generated enormous interest in the commercial and research database communities over the last decade. Several commercial products that manage spatial data are available. These include ESRI's ARC/INFO [ARC93], Inter-Graph's MGE [Int97], and Informix <ref> [Ube94] </ref>. GISs typically store and manage spatial data such as points, lines, poly-lines, polygons, and surfaces. Since the amount of data they manage is quite large, GISs are often disk-based systems.
Reference: [Val87] <author> Patrick Valduriez. </author> <title> Join indices. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 12(2):218246, </volume> <month> June </month> <year> 1987. </year>
Reference-contexts: The resulting points are stored in a multi-attribute data structure such as the grid file [NHS84], which is then used for the filter step. Rotem [Rot91] proposes a spatial join algorithm based on the join index of Valduriez <ref> [Val87] </ref>. The join index used in [Rot91] partially computes the result of the spatial join using a grid file.
Reference: [Ven94] <author> D. E. Vengroff. </author> <title> A transparent parallel I/O environment. </title> <booktitle> In Proc. 1994 DAGS Symposium on Parallel Computation, </booktitle> <year> 1994. </year>
Reference-contexts: Instead, an estimation is used that does not take duplication into account. solid line will appear in all three partitions. 7.2 Implementation Details We implemented the three algorithms using the Transparent Parallel I/O Programming Environment (TPIE) system <ref> [Ven94, Ven95, VV96] </ref> (see also http://www.cs.duke.edu/TPIE/). TPIE is a collection of templated functions and classes to support high-level yet efficient implementations of external-memory algorithms. The basic data structure in TPIE is a stream, representing a list of objects of an arbitrary type.
Reference: [Ven95] <author> D. E. Vengroff. </author> <title> TPIE User Manual and Reference. </title> <institution> Duke University, </institution> <note> 1995 with subsequent revisions. Available via WWW at http://www.cs.duke.edu/TPIE. </note>
Reference-contexts: Instead, an estimation is used that does not take duplication into account. solid line will appear in all three partitions. 7.2 Implementation Details We implemented the three algorithms using the Transparent Parallel I/O Programming Environment (TPIE) system <ref> [Ven94, Ven95, VV96] </ref> (see also http://www.cs.duke.edu/TPIE/). TPIE is a collection of templated functions and classes to support high-level yet efficient implementations of external-memory algorithms. The basic data structure in TPIE is a stream, representing a list of objects of an arbitrary type.
Reference: [VV96] <author> D. E. Vengroff and J. S. Vitter. </author> <title> I/O-efficient scientific computation using TPIE. </title> <booktitle> In Proceedings of the Goddard Conference on Mass Storage Systems and Technologies, NASA Conference Publication 3340, </booktitle> <volume> Volume II, </volume> <pages> pages 553570, </pages> <year> 1996. </year>
Reference-contexts: Instead, an estimation is used that does not take duplication into account. solid line will appear in all three partitions. 7.2 Implementation Details We implemented the three algorithms using the Transparent Parallel I/O Programming Environment (TPIE) system <ref> [Ven94, Ven95, VV96] </ref> (see also http://www.cs.duke.edu/TPIE/). TPIE is a collection of templated functions and classes to support high-level yet efficient implementations of external-memory algorithms. The basic data structure in TPIE is a stream, representing a list of objects of an arbitrary type.
References-found: 49

