URL: http://www.cs.virginia.edu/~nr/pubs/tk-usenix.ps
Refering-URL: http://www.cs.virginia.edu/~nr/toolkit/
Root-URL: http://www.cs.virginia.edu
Title: Toolkit  
Author: Norman Ramsey Mary F. Fernandez 
Affiliation: Bell Communications Research  Department of Computer Science, Princeton University  
Note: Reprinted from 1995 Usenix Technical Conference January 16-20, 1995 New Orleans, LA The New Jersey Machine-Code  
Abstract: The toolkit's specification language uses four concepts: fields and tokens describe parts of instructions, patterns describe binary encodings of instructions or groups of instructions, and constructors map between the assembly-language and binary levels. These concepts are suitable for describing both CISC and RISC machines; we have written specifications for the MIPS R3000, SPARC, and Intel 486 instruction sets. We have used the toolkit to help write two applications: a debugger and a linker. The toolkit generates efficient code; for example, the linker emits binary up to 15% faster than it emits assembly language, making it 1.7-2 times faster to produce an a.out directly than by using the assembler. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Ball, Thomas and James R. Larus. </author> <year> 1992 </year> <month> (January). </month> <title> Optimially profiling and tracing programs. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 59-70, </pages> <address> Albuquerque, NM. </address> <note> 300 1995 Usenix Technical Conference * January 16-20, 1995 * New Orleans, </note> <author> LA Bell, C. G. and A. Newell. </author> <year> 1971. </year> <title> Computer Structures: Readings and Examples. </title> <address> New York: </address> <publisher> McGraw-Hill. </publisher>
Reference-contexts: One could store relocatable blocks and relocation closures in a file and use the collection as a machine-independent representation of object code. Such an object-code format could make it easier to write testing tools like Purify (Hast-ings and Joyce 1992), profilers and tracers like qpt <ref> (Ball and Larus 1992) </ref>, and optimizing linkers like OM (Svrivastava and Wall 1993), all of which manipulate object code.
Reference: <author> Bell, Timothy C., John G. Cleary, and Ian H. Witten. </author> <year> 1990. </year> <title> Text Compression. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: We are also investigating the use of toolkit specifications to help build compression models for arithmetic cod 1995 Usenix Technical Conference * January 16-20, 1995 * New Orleans, LA 299 ing <ref> (Bell, Cleary, and Witten 1990) </ref>. It may be in-creasingly useful to compress machine code as the gap between processor speeds and secondary storage widens.
Reference: <author> Duffy, Diane E., Allen A. McIntosh, Mark Rosenstein, and Walter Willinger. </author> <year> 1994 </year> <month> (April). </month> <title> Statistical analysis of CCSN/SS7 traffic data from working CCS subnetworks. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 12(3) </volume> <pages> 544-551. </pages>
Reference-contexts: It may be in-creasingly useful to compress machine code as the gap between processor speeds and secondary storage widens. Better compression would help reduce the storage requirements for large network traces, which can consume gigabytes <ref> (Duffy et al. 1994) </ref>. 13 Discussion Our specification language evolved from a simpler language used to recognize RISC instructions in a retargetable debugger (Ramsey 1992, Appendix B). That language had field constraints and patterns built with conjunction and disjunction, but no concatenation and no constructors.
Reference: <author> Elsner, Dean, Jay Fenlason, et al. </author> <year> 1993 </year> <month> (March). </month> <title> Using as: the GNU Assembler. Free Software Foundation. </title>
Reference-contexts: We prefer to build applications by using several simple specifications, each describing different properties of the same machine, to build different parts. The GNU assembler provides assembly and disassembly for many targets, but different techniques have been applied ad hoc to support different architectures <ref> (Elsner, Fenlason, et al. 1993) </ref>. For example, 486 instructions are recognized by hand-written C code, but MIPS instructions are recognized by selecting a mask and a sample from a table, applying the mask to the word in question, then comparing the result against the sample.
Reference: <author> Ferguson, David E. </author> <year> 1966. </year> <title> The evolution of the meta-assembly program. </title> <journal> Communications of the ACM, </journal> <volume> 9(3) </volume> <pages> 190-193. </pages>
Reference: <author> Fernandez, Mary. </author> <year> 1994 </year> <month> (November). </month> <title> Simple and effective link-time optimization of Modula-3 programs. </title> <type> Technical Report CS-TR-474-94, </type> <institution> Department of Computer Science, Princeton University. </institution>
Reference-contexts: The toolkit checks specifications for unused constructs, underspecified instructions, and inconsistencies. An instruction set can be specified with modest effort; our MIPS, SPARC, and 486 specifications are 127, 193, and 460 lines. We have two applications that use the toolkit. mld <ref> (Fernandez 1994) </ref>, a retargetable, optimizing linker, uses the toolkit to encode instructions and emit executable files. ldb (Ramsey 1992; Ramsey and Hanson 1992), a retargetable debugger, uses the toolkit to decode instructions and to implement breakpoints. The toolkit provides practical benefits, like reducing retargeting effort.
Reference: <author> Fraser, Christopher W. and David R. Hanson. </author> <year> 1991 </year> <month> (October). </month> <title> A retargetable compiler for ANSI C. </title> <journal> SIGPLAN Notices, </journal> <volume> 26(10) </volume> <pages> 29-43. </pages>
Reference-contexts: Retargeting mld requires adapting a code generator and writing code to emit an a.out file. mld's code generators are based on those used in the lcc compiler <ref> (Fraser and Hanson 1991) </ref>, which emit assembly code.
Reference: <author> Fraser, Christopher W., Robert R. Henry, and Todd A. Proebsting. </author> <year> 1992 </year> <month> (April). </month> <title> BURG|fast optimal instruction selection and tree parsing. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(4) </volume> <pages> 68-76. </pages>
Reference: <author> Griswold, Ralph E. and Madge T. Griswold. </author> <year> 1990. </year> <title> The Icon Programming Language. Second edition. </title> <address> En-glewood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference-contexts: Using the matching statement implemented by the toolkit makes it clear what the code is doing; the logic would be obscured if implemented by nested case statements. 10 Implementation The toolkit's generator and translator are 6000 lines of Icon <ref> (Griswold and Griswold 1990) </ref>.
Reference: <author> Hastings, Reed and Bob Joyce. </author> <year> 1992 </year> <month> (January). </month> <title> Purify: Fast detection of memory leaks and access errors. </title> <booktitle> In Proceedings of the Winter USENIX Conference, </booktitle> <pages> pages 125-136. </pages> <publisher> Intel Corporation. </publisher> <year> 1990. </year> <title> i486 Microprocessor Programmer's Reference Manual. International Organization for Standardization. 1987. Information Processing | Open Systems Interconnection | Specification of Abstract Syntax Notation One (ASN.1). ISO 8824 (CCITT X.208). </title> <editor> Nelson, Greg, editor. </editor> <year> 1991. </year> <title> Systems Programming with Modula-3. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall. </publisher>
Reference: <author> Ramsey, Norman and David R. Hanson. </author> <year> 1992 </year> <month> (July). </month> <title> A retargetable debugger. </title> <booktitle> ACM SIGPLAN '92 Conference on Programming Language Design and Implementation, in SIGPLAN Notices, </booktitle> <volume> 27(7) </volume> <pages> 22-31. </pages>
Reference-contexts: Better compression would help reduce the storage requirements for large network traces, which can consume gigabytes (Duffy et al. 1994). 13 Discussion Our specification language evolved from a simpler language used to recognize RISC instructions in a retargetable debugger <ref> (Ramsey 1992, Appendix B) </ref>. That language had field constraints and patterns built with conjunction and disjunction, but no concatenation and no constructors. There was no notion of instruction stream; instructions were values that fit into a machine word.
Reference: <author> Ramsey, Norman. </author> <year> 1992 </year> <month> (December). </month> <title> A Retargetable Debugger. </title> <type> PhD thesis, </type> <institution> Princeton University, Department of Computer Science. </institution> <note> Also Technical Report CS-TR-403-92. </note> . <year> 1994a </year> <month> (January). </month> <title> Correctness of trap-based breakpoint implementations. </title> <booktitle> In Proceedings of the 21st ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 15-24, </pages> <address> Portland, Oregon. </address> . <year> 1994b </year> <month> (September). </month> <title> Literate programming simplified. </title> <journal> IEEE Software, </journal> <volume> 11(5) </volume> <pages> 97-105. </pages> <note> SPARC International. </note> <year> 1992. </year> <title> The SPARC Architecture Manual, </title> <type> Version 8. </type> <address> Englewood Cliffs, NJ: </address> <publisher> Pren-tice Hall. </publisher>
Reference-contexts: Better compression would help reduce the storage requirements for large network traces, which can consume gigabytes (Duffy et al. 1994). 13 Discussion Our specification language evolved from a simpler language used to recognize RISC instructions in a retargetable debugger <ref> (Ramsey 1992, Appendix B) </ref>. That language had field constraints and patterns built with conjunction and disjunction, but no concatenation and no constructors. There was no notion of instruction stream; instructions were values that fit into a machine word.
Reference: <author> Svrivastava, Amitabh and David W. Wall. </author> <year> 1993. </year> <title> A practical system for intermodule code optimization. </title> <journal> Journal of Programming Languages, </journal> <volume> 1 </volume> <pages> 1-18. </pages> <note> Also available as WRL Research Report 92/6, De-cember 1992. </note>
Reference-contexts: Such an object-code format could make it easier to write testing tools like Purify (Hast-ings and Joyce 1992), profilers and tracers like qpt (Ball and Larus 1992), and optimizing linkers like OM <ref> (Svrivastava and Wall 1993) </ref>, all of which manipulate object code. One could add a machine-independent linker to the toolkit's library and extend the generator to generate assemblers from specifications, making it possible to take assembly code generated by existing compilers and assemble it into this new format.
Reference: <author> Wick, John Dryer. </author> <year> 1975 </year> <month> (December). </month> <title> Automatic Generation of Assemblers. </title> <type> PhD thesis, </type> <institution> Yale University. </institution>
References-found: 14

