URL: http://www.cs.bc.edu/~clote/Exp.ps.gz
Refering-URL: http://www.cs.bc.edu/techreps.html
Root-URL: http://www.cs.bc.edu
Title: A safe recursion scheme for exponential time  
Author: Peter Clote 
Abstract: Using a function algebra characterization of exponential time due to Monien [5], in the style of Bellantoni-Cook [2], we characterize exponential time functions of linear growth via a safe course-of-values recursion scheme. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. Bellantoni. </author> <title> Predicative recursion and computational complexity. </title> <type> Technical Report 264/92, </type> <institution> University of Toronto, Computer Science Department, </institution> <month> September </month> <year> 1992. </year> <pages> 164 pages. </pages>
Reference-contexts: Since publication of the Bellantoni-Cook characterization of polynomial time, many function complexity classes have been similarly characterized by safe recursion schemes without a bounding requirement: linear space, levels of the polynomial time hierarchy, logarithmic space, N C (S. Bellantoni 1 <ref> [1] </ref>; alternating logarithmic time and polylogarithmic time (S. Bloch [3]), and other classes. <p> Handley and independently D. Leivant.) 1 called safe. Often we will write normal variables as x; y; z; etc. and safe variables as a; b; c; etc. Following Bellantoni <ref> [1] </ref>, define the following initial functions. 1. (0-ary constant function) 0, or more formally 0 ( ; ). 2. (projections) I n;m ae a jn if n &lt; j n + m 3. (successor) S (; a) = a + 1 4. (predecessor) P r (; a) = ae 0 else <p> If F is a function algebra, then by F fl we denote the class of predicates whose characteristic function belongs to F. Definition 1 (Bellantoni <ref> [1] </ref>) The function f is defined by safe composition (scomp) from g; u 1 ; : : : ; u n ; v 1 ; : : : ; v m if f (~x; ~a) = g (u 1 (~x; ); : : : ; u n (~x; ); v 1 <p> By ([0; I; S; P r; C : scomp; sr] " Normal) we denote the class of functions f (~x; ) having only normal variables, such that f belongs to the function algebra [0; I; S; P r; C : scomp; sr]. Theorem 2 (Bellantoni <ref> [1] </ref>) The class E 2 of linear space computable functions equals ([0; I; S; P r; C : scomp; sr] " Normal): Define the function m 0 (0; x) = x M (x; y; ) = m 0 (I 2 (x; y; ); I 1 (x; y; )) Thus M (x; <p> Now consider the direction from right to left. We show by induction on term formation in the function algebra F that every function in F has linear growth rate and is computable in ET IM E. The following lemma is a trivial modification of <ref> [1] </ref>. Lemma 7 For each f (~x; ~a) 2 F there is a monotone increasing polynomial p f such that for all ~x; ~a f (~x; ~a) p f (~x) + max (~a): Proof: By induction on term formation in algebra F .
Reference: [2] <author> S. Bellantoni and S. Cook. </author> <title> A new recursion-theoretic characterization of the polytime functions. </title> <journal> Computational Complexity, </journal> <volume> 2 </volume> <pages> 97-110, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction In 1991 <ref> [2] </ref>, S. Bellantoni and S.A. Cook characterized the class F P of polynomial time computable functions as the smallest class of functions containing certain initial functions, and closed under safe composition and safe recursion on notation. In 1965, A. <p> Bellantoni 1 [1]; alternating logarithmic time and polylogarithmic time (S. Bloch [3]), and other classes. The purpose of this note is to similarly characterize the class of exponential time computable functions of linear growth. 2 Preliminaries Following <ref> [2] </ref>, variables are designated as normal or safe and distinguished by their position in a function f (x 1 ; : : : ; x n ; y 1 ; : : : ; y m ) | variables x i occurring to the left of the semi-colon are normal, whereas
Reference: [3] <author> S. Bloch. </author> <title> Function-algebraic characterizations of log and polylog parallel time. </title> <journal> Computational Complexity, </journal> <volume> 4(2) </volume> <pages> 175-205, </pages> <year> 1994. </year>
Reference-contexts: Since publication of the Bellantoni-Cook characterization of polynomial time, many function complexity classes have been similarly characterized by safe recursion schemes without a bounding requirement: linear space, levels of the polynomial time hierarchy, logarithmic space, N C (S. Bellantoni 1 [1]; alternating logarithmic time and polylogarithmic time (S. Bloch <ref> [3] </ref>), and other classes.
Reference: [4] <author> P. Clote. </author> <title> Computation models and function algebras. </title> <editor> In E. Griffor, editor, </editor> <booktitle> Handbook of Recursion Theory. </booktitle> <address> North Holland, </address> <note> in preparation. </note>
Reference-contexts: r by safe value recursion 2 (svr) if f (x + 1; ~y; ~a) = h (x; ~y; ~a; f (x; ~y; ~a); f (M (x; r (x; ~y; ); ); ~y; ~a)): This recursion scheme is the safe version of a scheme investigated by Monien [5] (see [6] or <ref> [4] </ref> for a presentation). <p> The class rf of rudimentary functions is [0; I; s; +; fi; comp; bmin]. An equivalent definition of rf is to replace bounded recursion by bounded minimization in Grzegorczyk's class E 2 . (See <ref> [4] </ref> for more information about such function algebras.) Definition 10 (S.
Reference: [5] <author> B. Monien. </author> <title> A recursive and grammatical characterization of exponential time languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 61-74, </pages> <year> 1977. </year>
Reference-contexts: defined from g; h; r by safe value recursion 2 (svr) if f (x + 1; ~y; ~a) = h (x; ~y; ~a; f (x; ~y; ~a); f (M (x; r (x; ~y; ); ); ~y; ~a)): This recursion scheme is the safe version of a scheme investigated by Monien <ref> [5] </ref> (see [6] or [4] for a presentation).
Reference: [6] <author> K. Wagner and G. Wechsung. </author> <title> Computational Complexity. </title> <publisher> Reidel Publishing Co., </publisher> <year> 1986. </year> <month> 8 </month>
Reference-contexts: g; h; r by safe value recursion 2 (svr) if f (x + 1; ~y; ~a) = h (x; ~y; ~a; f (x; ~y; ~a); f (M (x; r (x; ~y; ); ); ~y; ~a)): This recursion scheme is the safe version of a scheme investigated by Monien [5] (see <ref> [6] </ref> or [4] for a presentation).
References-found: 6

