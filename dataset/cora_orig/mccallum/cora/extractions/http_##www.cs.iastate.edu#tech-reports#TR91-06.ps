URL: http://www.cs.iastate.edu/tech-reports/TR91-06.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: Specifying and Verifying Object-Oriented Programs: An Overview of the Problems and a Solution TR91-06  
Author: Gary T. Leavens 
Date: February, 1991  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> C. A. R. Hoare. </author> <title> Proof of correctness of data representations. </title> <journal> Acta Informatica, </journal> <volume> 1(4) </volume> <pages> 271-281, </pages> <year> 1972. </year>
Reference-contexts: 1 Introduction Abstraction allows one to ignore unimportant details in reasoning. Not only does abstraction make arguments more succinct, but it also allows arguments to depend on weaker assumptions. For example, one reasons about an abstract data type according to its specification, ignoring details of how its objects are represented <ref> [1] </ref>. A less well-known use of abstraction, but one that is important in object-oriented programming methods, is the use of supertypes as abstractions of their subtypes. For example, windows may stand for bordered windows or menus. <p> Since the pre- and post-conditions are stated using trait functions that apply to abstract values, one must use A to obtain abstract values and then check that the pre- and post-conditions are satisfied by each operation <ref> [1] </ref>. How can the details of abstraction relations and particular programming languages be ignored? One way is to provide a mathematical abstraction of implementations. For immutable types, an adequate abstraction is an algebraic model. <p> To guarantee the preservation of simulation by message passing and assertions, it is enough to require that simulation relationships be preserved by program operations and by trait functions. This property of simulation relations is called the substitution property (as in algebraic homomorphisms). For example, if q denotes the Interval <ref> [1; 3] </ref> and r the 15 IntSet f1; 2; 3g, then q simulates r. <p> Other properties required of simulation relations are described below. Formally, simulation relations are families of binary relations, one per type, among abstract values. Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result <p> Formally, simulation relations are families of binary relations, one per type, among abstract values. Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> 3] simulates-as-IntSet <ref> [1; 3] </ref> [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. The relation "simulates-as-Interval" is not defined on the abstract values of type IntSet, because IntSet is not specified to be a subtype of Interval. The substitution property is formally defined by requiring that results are related at the expected result type, defined using ResType. For example, [1; 3] simulates-as-IntSet <p> choose on <ref> [1; 3] </ref>. The relation "simulates-as-Interval" is not defined on the abstract values of type IntSet, because IntSet is not specified to be a subtype of Interval. The substitution property is formally defined by requiring that results are related at the expected result type, defined using ResType. For example, [1; 3] simulates-as-IntSet f1; 2; 3g 4 simulates-as-Int 4 so the substitution property says that the program operation ins must preserve the simu lation: [1; 3]:ins (4) simulates-as-IntSet f1; 2; 3g:ins (4); where the results are related at the type IntSet because ResType (ins; hIntSet; Inti) = IntSet: 16 The tuple <p> The substitution property is formally defined by requiring that results are related at the expected result type, defined using ResType. For example, <ref> [1; 3] </ref> simulates-as-IntSet f1; 2; 3g 4 simulates-as-Int 4 so the substitution property says that the program operation ins must preserve the simu lation: [1; 3]:ins (4) simulates-as-IntSet f1; 2; 3g:ins (4); where the results are related at the type IntSet because ResType (ins; hIntSet; Inti) = IntSet: 16 The tuple hIntSet; Inti is used as the second argument to ResType above, because the actual arguments to ins were related at those types.
Reference: [2] <author> Alan Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 38-45, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: For example, windows may stand for bordered windows or menus. Supertypes can stand for their subtypes during specification and verification, if they are used in a disciplined fashion. Having supertypes stand for their subtypes is called supertype abstraction. Subtypes should not be confused with subclasses <ref> [2] </ref>. A class is a program module that implements an abstract data type. A subclass inherits data representation and operations from its superclasses, but a subclass may also change inherited aspects. <p> adding a new data type not cause problems for existing modules? How can one design new types so that they will not cause problems in existing software? The folklore is that if the new types are "subtypes" of one or more existing types, then the program will work without problems <ref> [2] </ref>. For example, if bordered windows are a subtype of windows, then existing code should not have problems when bordered windows are used in place of windows.
Reference: [3] <author> John V. Guttag, James J. Horning, and Jeannette M. Wing. </author> <title> The Larch family of specification languages. </title> <journal> IEEE Software, </journal> <volume> 2(4), </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: A type whose objects are all immutable is itself said to be immutable. (The formal results described below are limited to immutable types, although the general ideas also apply to programs that use mutable types.) The formal specification of IntSet is given in a Larch-style interface specification language <ref> [3] </ref>. The trait IntSetTrait (see Figure 2) specifies the abstract values of IntSet objects (mathematical sets), and gives meaning to the trait function symbols [, 2, and so on that are used in the pre- and post-conditions of the program operations null, ins, and so on. <p> In effect the meaning of a specification such as Figure 6 is given by using dynamic overloading of the trait function names that appear in assertions. For example, if one knows that the abstract values of iv1 and iv2 are the intervals <ref> [3; 27] </ref> and [15; 73], then a description of the result of the call inBoth (iv1,iv2) can be obtained by substituting the abstract values of the actuals for the formals in the post-condition of inBoth, obtaining the formula "(i 2 [3; 27]) & (i 2 [15; 73])", which is interpreted using <p> the abstract values of iv1 and iv2 are the intervals <ref> [3; 27] </ref> and [15; 73], then a description of the result of the call inBoth (iv1,iv2) can be obtained by substituting the abstract values of the actuals for the formals in the post-condition of inBoth, obtaining the formula "(i 2 [3; 27]) & (i 2 [15; 73])", which is interpreted using the version of 2 appropriate for the abstract values of intervals. Hence it is possible to discuss the testing and correctness of implementations of such specifications for all permitted arguments. <p> To guarantee the preservation of simulation by message passing and assertions, it is enough to require that simulation relationships be preserved by program operations and by trait functions. This property of simulation relations is called the substitution property (as in algebraic homomorphisms). For example, if q denotes the Interval <ref> [1; 3] </ref> and r the 15 IntSet f1; 2; 3g, then q simulates r. <p> Other properties required of simulation relations are described below. Formally, simulation relations are families of binary relations, one per type, among abstract values. Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result <p> Formally, simulation relations are families of binary relations, one per type, among abstract values. Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> 3] simulates-as-IntSet <ref> [1; 3] </ref> [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. The relation "simulates-as-Interval" is not defined on the abstract values of type IntSet, because IntSet is not specified to be a subtype of Interval. The substitution property is formally defined by requiring that results are related at the expected result type, defined using ResType. For example, [1; 3] simulates-as-IntSet <p> choose on <ref> [1; 3] </ref>. The relation "simulates-as-Interval" is not defined on the abstract values of type IntSet, because IntSet is not specified to be a subtype of Interval. The substitution property is formally defined by requiring that results are related at the expected result type, defined using ResType. For example, [1; 3] simulates-as-IntSet f1; 2; 3g 4 simulates-as-Int 4 so the substitution property says that the program operation ins must preserve the simu lation: [1; 3]:ins (4) simulates-as-IntSet f1; 2; 3g:ins (4); where the results are related at the type IntSet because ResType (ins; hIntSet; Inti) = IntSet: 16 The tuple <p> The substitution property is formally defined by requiring that results are related at the expected result type, defined using ResType. For example, <ref> [1; 3] </ref> simulates-as-IntSet f1; 2; 3g 4 simulates-as-Int 4 so the substitution property says that the program operation ins must preserve the simu lation: [1; 3]:ins (4) simulates-as-IntSet f1; 2; 3g:ins (4); where the results are related at the type IntSet because ResType (ins; hIntSet; Inti) = IntSet: 16 The tuple hIntSet; Inti is used as the second argument to ResType above, because the actual arguments to ins were related at those types. <p> For example, the assertion ((size (s) = 1) & (3 2 s)) ) (s = f3g) is valid when "s" denotes an IntSet, but is not valid when "s" denotes an Interval, since the abstract value of an Interval would have the form <ref> [3; 3] </ref>, not f3g. Thus for sound verification with subtypes, one cannot use equality (=) of abstract values with the rule of consequence or in pre- and post-conditions, except for built-in types such as Bool and Int that are assumed not to have subtypes [7].
Reference: [4] <author> J. V. Guttag and J. J. Horning. </author> <title> A Larch shared language handbook. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 6 </volume> <pages> 135-157, </pages> <year> 1986. </year>
Reference-contexts: 1 , s 2 : C] (s 1 == s 2 ) = (s 1 = s 2 ) CardToInt: trait imports Cardinal, Integer introduces toInt: Card ! Int asserts for all [c: Card] toInt (0) = 0 toInt (succ (c)) = (1 + toInt (c)) the named traits (from <ref> [4] </ref>). The renamings following with alter the text of the imported traits; for example substituting Int for E. Trait functions and their signatures are declared after introduces. The trait function "==" is an infix operator, because its declaration uses sharp signs (#) to show argument positions.
Reference: [5] <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad hoc. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, Texas, </address> <pages> pages 60-76. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: For trait functions that take two arguments of type IntSet, three versions are defined here, so that each such trait function is defined on all combinations of IntSet and Interval arguments. 7 a mapping from pairs of operation names and types to code, called a method dictionary <ref> [5] </ref>. (For space efficiency the code for an operation is shared among all objects of the same type in most implementations of object-oriented languages.) Since the method dictionary is accessible from the objects, code that invokes an object's operations does not have to depend on the types of objects.
Reference: [6] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about object-oriented programs that use subtypes (extended abstract). </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 212-223, </pages> <month> October </month> <year> 1990. </year> <booktitle> OOPSLA ECOOP '90 Proceedings, N. Meyrowitz (editor). </booktitle>
Reference-contexts: Limiting arguments to subtypes and attaching semantic constraints to subtype relationships are crucial for the modular specification and verification of functions. A method for reasoning about object-oriented programs that uses the ideas of subtype and nominal type was pioneered in the author's dissertation and further developed in <ref> [6] </ref> [7].
Reference: [7] <author> Gary T. Leavens. </author> <title> Modular verification of object-oriented programs with subtypes. </title> <type> Technical Report 90-09, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, July </month> <year> 1990. </year>
Reference-contexts: Limiting arguments to subtypes and attaching semantic constraints to subtype relationships are crucial for the modular specification and verification of functions. A method for reasoning about object-oriented programs that uses the ideas of subtype and nominal type was pioneered in the author's dissertation and further developed in [6] <ref> [7] </ref>. <p> Thus for sound verification with subtypes, one cannot use equality (=) of abstract values with the rule of consequence or in pre- and post-conditions, except for built-in types such as Bool and Int that are assumed not to have subtypes <ref> [7] </ref>. The second difference from conventional verification occurs when one explicitly exploits subtyping. Figure 5 shows an example, where in the main program some arguments to doSomething have nominal type Interval.

Reference: [1] <author> Alan Snyder. </author> <title> Encapsulation and inheritance in object-oriented programming languages. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 38-45, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: 1 Introduction Abstraction allows one to ignore unimportant details in reasoning. Not only does abstraction make arguments more succinct, but it also allows arguments to depend on weaker assumptions. For example, one reasons about an abstract data type according to its specification, ignoring details of how its objects are represented <ref> [1] </ref>. A less well-known use of abstraction, but one that is important in object-oriented programming methods, is the use of supertypes as abstractions of their subtypes. For example, windows may stand for bordered windows or menus. <p> Since the pre- and post-conditions are stated using trait functions that apply to abstract values, one must use A to obtain abstract values and then check that the pre- and post-conditions are satisfied by each operation <ref> [1] </ref>. How can the details of abstraction relations and particular programming languages be ignored? One way is to provide a mathematical abstraction of implementations. For immutable types, an adequate abstraction is an algebraic model. <p> To guarantee the preservation of simulation by message passing and assertions, it is enough to require that simulation relationships be preserved by program operations and by trait functions. This property of simulation relations is called the substitution property (as in algebraic homomorphisms). For example, if q denotes the Interval <ref> [1; 3] </ref> and r the 15 IntSet f1; 2; 3g, then q simulates r. <p> Other properties required of simulation relations are described below. Formally, simulation relations are families of binary relations, one per type, among abstract values. Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result <p> Formally, simulation relations are families of binary relations, one per type, among abstract values. Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> 3] simulates-as-IntSet <ref> [1; 3] </ref> [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. The relation "simulates-as-Interval" is not defined on the abstract values of type IntSet, because IntSet is not specified to be a subtype of Interval. The substitution property is formally defined by requiring that results are related at the expected result type, defined using ResType. For example, [1; 3] simulates-as-IntSet <p> choose on <ref> [1; 3] </ref>. The relation "simulates-as-Interval" is not defined on the abstract values of type IntSet, because IntSet is not specified to be a subtype of Interval. The substitution property is formally defined by requiring that results are related at the expected result type, defined using ResType. For example, [1; 3] simulates-as-IntSet f1; 2; 3g 4 simulates-as-Int 4 so the substitution property says that the program operation ins must preserve the simu lation: [1; 3]:ins (4) simulates-as-IntSet f1; 2; 3g:ins (4); where the results are related at the type IntSet because ResType (ins; hIntSet; Inti) = IntSet: 16 The tuple <p> The substitution property is formally defined by requiring that results are related at the expected result type, defined using ResType. For example, <ref> [1; 3] </ref> simulates-as-IntSet f1; 2; 3g 4 simulates-as-Int 4 so the substitution property says that the program operation ins must preserve the simu lation: [1; 3]:ins (4) simulates-as-IntSet f1; 2; 3g:ins (4); where the results are related at the type IntSet because ResType (ins; hIntSet; Inti) = IntSet: 16 The tuple hIntSet; Inti is used as the second argument to ResType above, because the actual arguments to ins were related at those types.
Reference: [2] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 9-16, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: For example, windows may stand for bordered windows or menus. Supertypes can stand for their subtypes during specification and verification, if they are used in a disciplined fashion. Having supertypes stand for their subtypes is called supertype abstraction. Subtypes should not be confused with subclasses <ref> [2] </ref>. A class is a program module that implements an abstract data type. A subclass inherits data representation and operations from its superclasses, but a subclass may also change inherited aspects. <p> adding a new data type not cause problems for existing modules? How can one design new types so that they will not cause problems in existing software? The folklore is that if the new types are "subtypes" of one or more existing types, then the program will work without problems <ref> [2] </ref>. For example, if bordered windows are a subtype of windows, then existing code should not have problems when bordered windows are used in place of windows.
Reference: [3] <author> Barbara Liskov. </author> <title> Data abstraction and hierarchy. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(5) </volume> <pages> 17-34, </pages> <month> May </month> <year> 1988. </year> <note> Revised version of the keynote address given at OOPSLA '87. 2 </note>
Reference-contexts: A type whose objects are all immutable is itself said to be immutable. (The formal results described below are limited to immutable types, although the general ideas also apply to programs that use mutable types.) The formal specification of IntSet is given in a Larch-style interface specification language <ref> [3] </ref>. The trait IntSetTrait (see Figure 2) specifies the abstract values of IntSet objects (mathematical sets), and gives meaning to the trait function symbols [, 2, and so on that are used in the pre- and post-conditions of the program operations null, ins, and so on. <p> In effect the meaning of a specification such as Figure 6 is given by using dynamic overloading of the trait function names that appear in assertions. For example, if one knows that the abstract values of iv1 and iv2 are the intervals <ref> [3; 27] </ref> and [15; 73], then a description of the result of the call inBoth (iv1,iv2) can be obtained by substituting the abstract values of the actuals for the formals in the post-condition of inBoth, obtaining the formula "(i 2 [3; 27]) & (i 2 [15; 73])", which is interpreted using <p> the abstract values of iv1 and iv2 are the intervals <ref> [3; 27] </ref> and [15; 73], then a description of the result of the call inBoth (iv1,iv2) can be obtained by substituting the abstract values of the actuals for the formals in the post-condition of inBoth, obtaining the formula "(i 2 [3; 27]) & (i 2 [15; 73])", which is interpreted using the version of 2 appropriate for the abstract values of intervals. Hence it is possible to discuss the testing and correctness of implementations of such specifications for all permitted arguments. <p> To guarantee the preservation of simulation by message passing and assertions, it is enough to require that simulation relationships be preserved by program operations and by trait functions. This property of simulation relations is called the substitution property (as in algebraic homomorphisms). For example, if q denotes the Interval <ref> [1; 3] </ref> and r the 15 IntSet f1; 2; 3g, then q simulates r. <p> Other properties required of simulation relations are described below. Formally, simulation relations are families of binary relations, one per type, among abstract values. Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result <p> Formally, simulation relations are families of binary relations, one per type, among abstract values. Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> Each relation "simulates-as-T" relates the abstract values of subtypes of T. For example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> example, the following lists all the relationships between <ref> [1; 3] </ref> (an Interval) and f1; 2; 3g (an IntSet): [1; 3] simulates-as-IntSet f1; 2; 3g [1; 3] simulates-as-IntSet [1; 3] [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. <p> 3] simulates-as-IntSet <ref> [1; 3] </ref> [1; 3] simulates-as-Interval [1; 3] f1; 2; 3g simulates-as-IntSet f1; 2; 3g: It is not true that f1; 2; 3g simulates-as-IntSet [1; 3], because the 2 is a possible result of choose on f1; 2; 3g, but it is not a possible result of choose on [1; 3]. The relation "simulates-as-Interval" is not defined on the abstract values of type IntSet, because IntSet is not specified to be a subtype of Interval. The substitution property is formally defined by requiring that results are related at the expected result type, defined using ResType. For example, [1; 3] simulates-as-IntSet <p> choose on <ref> [1; 3] </ref>. The relation "simulates-as-Interval" is not defined on the abstract values of type IntSet, because IntSet is not specified to be a subtype of Interval. The substitution property is formally defined by requiring that results are related at the expected result type, defined using ResType. For example, [1; 3] simulates-as-IntSet f1; 2; 3g 4 simulates-as-Int 4 so the substitution property says that the program operation ins must preserve the simu lation: [1; 3]:ins (4) simulates-as-IntSet f1; 2; 3g:ins (4); where the results are related at the type IntSet because ResType (ins; hIntSet; Inti) = IntSet: 16 The tuple <p> The substitution property is formally defined by requiring that results are related at the expected result type, defined using ResType. For example, <ref> [1; 3] </ref> simulates-as-IntSet f1; 2; 3g 4 simulates-as-Int 4 so the substitution property says that the program operation ins must preserve the simu lation: [1; 3]:ins (4) simulates-as-IntSet f1; 2; 3g:ins (4); where the results are related at the type IntSet because ResType (ins; hIntSet; Inti) = IntSet: 16 The tuple hIntSet; Inti is used as the second argument to ResType above, because the actual arguments to ins were related at those types. <p> For example, the assertion ((size (s) = 1) & (3 2 s)) ) (s = f3g) is valid when "s" denotes an IntSet, but is not valid when "s" denotes an Interval, since the abstract value of an Interval would have the form <ref> [3; 3] </ref>, not f3g. Thus for sound verification with subtypes, one cannot use equality (=) of abstract values with the rule of consequence or in pre- and post-conditions, except for built-in types such as Bool and Int that are assumed not to have subtypes [7].
Reference: [4] <author> Wilf R. LaLonde. </author> <title> Designing families of data types using exemplars. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(2) </volume> <pages> 212-248, </pages> <month> April </month> <year> 1989. </year>
Reference-contexts: 1 , s 2 : C] (s 1 == s 2 ) = (s 1 = s 2 ) CardToInt: trait imports Cardinal, Integer introduces toInt: Card ! Int asserts for all [c: Card] toInt (0) = 0 toInt (succ (c)) = (1 + toInt (c)) the named traits (from <ref> [4] </ref>). The renamings following with alter the text of the imported traits; for example substituting Int for E. Trait functions and their signatures are declared after introduces. The trait function "==" is an infix operator, because its declaration uses sharp signs (#) to show argument positions.
Reference: [5] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: For trait functions that take two arguments of type IntSet, three versions are defined here, so that each such trait function is defined on all combinations of IntSet and Interval arguments. 7 a mapping from pairs of operation names and types to code, called a method dictionary <ref> [5] </ref>. (For space efficiency the code for an operation is shared among all objects of the same type in most implementations of object-oriented languages.) Since the method dictionary is accessible from the objects, code that invokes an object's operations does not have to depend on the types of objects.
Reference: [6] <author> John C. Reynolds. </author> <title> Using category theory to design implicit conversions and generic operators. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Denmark, volume 94 of Lecture Notes in Computer Science, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer-Verlag, </publisher> <month> January </month> <year> 1980. </year>
Reference-contexts: Limiting arguments to subtypes and attaching semantic constraints to subtype relationships are crucial for the modular specification and verification of functions. A method for reasoning about object-oriented programs that uses the ideas of subtype and nominal type was pioneered in the author's dissertation and further developed in <ref> [6] </ref> [7].
Reference: [7] <author> Kim B. Bruce and Peter Wegner. </author> <title> An algebraic model of subtype and inheritance. </title> <note> To appear in Database Programming Languages, </note> <editor> Francois Bancilhon and Peter Buneman (editors), </editor> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <month> August </month> <year> 1987. </year>
Reference-contexts: Limiting arguments to subtypes and attaching semantic constraints to subtype relationships are crucial for the modular specification and verification of functions. A method for reasoning about object-oriented programs that uses the ideas of subtype and nominal type was pioneered in the author's dissertation and further developed in [6] <ref> [7] </ref>. <p> Thus for sound verification with subtypes, one cannot use equality (=) of abstract values with the rule of consequence or in pre- and post-conditions, except for built-in types such as Bool and Int that are assumed not to have subtypes <ref> [7] </ref>. The second difference from conventional verification occurs when one explicitly exploits subtyping. Figure 5 shows an example, where in the main program some arguments to doSomething have nominal type Interval.
Reference: [8] <author> Pierre America. </author> <title> A behavioural approach to subtyping in object-oriented programming languages. </title> <type> Technical Report 443, </type> <institution> Philips Research Laboratories, Nederlandse Philips Bedrijven B. V., </institution> <month> January </month> <year> 1989. </year> <note> Superseded by a later version in April 1989. </note>
Reference-contexts: Second, one must be able to interpret the expected result types given by ResType as upper bounds, even when arguments types are lowered. For example, if is the specified subtype relation, then ResType (ins; hInterval; Inti) ResType (ins; hIntSet; Inti): That is, ResType must be monotonic in <ref> [8] </ref>. These constraints on signatures, although not sufficient to guarantee modular verification, guarantee modularity of specifications. Recall that modularity of specifications means that when one adds new types to a program, one need not respecify existing functions and types.
Reference: [9] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <editor> In D. B. MacQueen G. Kahn and G. Plotkin, editors, </editor> <booktitle> Semantics of Data Types: International Symposium, Sophia-Antipolis, France, volume 173 of Lecture Notes in Computer Science, </booktitle> <pages> pages 51-66. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> June </month> <year> 1984. </year> <note> A revised version of this paper appears in Information and Computation, </note> <institution> volume 76, </institution> <type> numbers 2/3, </type> <pages> pages 138-164, </pages> <month> Febru-ary/March </month> <year> 1988. </year>
Reference: [10] <author> Luca Cardelli. </author> <title> Structural subtyping and the notion of power type. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, Calif., </address> <pages> pages 70-79. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1988. </year> <month> 3 </month>
References-found: 17

