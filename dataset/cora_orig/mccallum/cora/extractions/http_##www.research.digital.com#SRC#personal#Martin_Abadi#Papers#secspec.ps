URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/Papers/secspec.ps
Refering-URL: http://www.research.digital.com/SRC/personal/Martin_Abadi/allpapers.html
Root-URL: http://www.research.digital.com
Email: ma@pa.dec.com  
Title: Security Protocols and Specifications  
Author: Martin Abadi 
Address: Compaq  
Affiliation: Systems Research Center  
Abstract: Specifications for security protocols range from informal narrations of message flows to formal assertions of protocol properties. This paper (intended to accompany a lecture at ETAPS '99) discusses those specifications and suggests some gaps and some opportunities for further work. Some of them pertain to the traditional core of the field; others appear when we examine the context in which protocols operate. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Martin Abadi. </author> <title> Secrecy by typing in security protocols. </title> <booktitle> In Theoretical Aspects of Computer Software, volume 1281 of Lecture Notes in Computer Science, </booktitle> <pages> pages 611-638. </pages> <publisher> Springer-Verlag, </publisher> <year> 1997. </year>
Reference-contexts: For example, the process (K)chfxg K i, which sends x encrypted under a fresh key K on a channel c, preserves the secrecy of x. Previous papers on the spi calculus <ref> [6, 1] </ref> contain more substantial examples to which this concept of secrecy applies.
Reference: 2. <author> Martin Abadi. </author> <title> Protection in programming-language translations. </title> <booktitle> In Proceedings of the 25th International Colloquium on Automata, Languages and Programming, </booktitle> <pages> pages 868-883, </pages> <month> July </month> <year> 1998. </year> <note> Also Digital Equipment Corporation Systems Research Center report No. 154, </note> <month> April </month> <year> 1998. </year>
Reference-contexts: For instance, the protocol may yield a key that can be used for signing application messages. Application program interfaces (or even programming languages) should allow applications to exploit those useful properties, with clear, modular semantics, and without revealing tricky low-level cryptographic details (e.g., <ref> [12, 40, 39, 61, 2, 5, 10] </ref>). (2) Some protocols rely on fixed suites of cryptosystems. In other cases, assumptions about the properties of cryptographic operations are needed.
Reference: 3. <author> Martin Abadi. </author> <title> Two facets of authentication. </title> <booktitle> In Proceedings of the 11th IEEE Computer Security Foundations Workshop, </booktitle> <pages> pages 27-32, </pages> <year> 1998. </year>
Reference-contexts: Other objectives include forward secrecy [24], non-repudiation, and availability. Some objectives contradict others. For example, some protocols aim to guarantee anonymity rather than authenticity, or plausible deniability [54] rather than non-repudiation. Moreover, many definitions have been proposed even for such basic concepts as authenticity (e.g., <ref> [11, 30, 42, 3] </ref>). Nevertheless, there are some common themes in the treatment of protocol properties. The participants in security protocols do not operate in a closed world, but in communication with other principals. Some of those principals may be hostile, and even the participants may not be fully trusted.
Reference: 4. <author> Martin Abadi, Andrew Birrell, Raymie Stata, and Edward Wobber. </author> <title> Secure web tunneling. Computer Networks and ISDN Systems, </title> <address> 30(1-7):531-539, </address> <month> April </month> <year> 1998. </year> <booktitle> Proceedings of the 7th International World Wide Web Conference. </booktitle>
Reference-contexts: Similarly, protocols often rely on network time servers, trusted third parties, and other auxiliary participants. Detailed assumptions about these servers are sometimes absent from protocol narrations, but they are essential in reasoning about protocols. (3) Protocol messages commonly go across network interfaces, firewalls with tunnels, and administrative frontiers (e.g., <ref> [12, 61, 20, 19, 4] </ref>). In some contexts (e.g., [17]), even the protocol participants may be mobile. These traversals often require message translations (for example, marshaling and rewriting of URLs). They are subject to filtering and auditing. Furthermore, they may trigger auxiliary protocols.
Reference: 5. <author> Martin Abadi, Cedric Fournet, and Georges Gonthier. </author> <title> Secure implementation of channel abstractions. </title> <booktitle> In Proceedings of the Thirteenth Annual IEEE Symposium on Logic in Computer Science, </booktitle> <pages> pages 105-116, </pages> <month> June </month> <year> 1998. </year>
Reference-contexts: For instance, the protocol may yield a key that can be used for signing application messages. Application program interfaces (or even programming languages) should allow applications to exploit those useful properties, with clear, modular semantics, and without revealing tricky low-level cryptographic details (e.g., <ref> [12, 40, 39, 61, 2, 5, 10] </ref>). (2) Some protocols rely on fixed suites of cryptosystems. In other cases, assumptions about the properties of cryptographic operations are needed.
Reference: 6. <author> Martin Abadi and Andrew D. Gordon. </author> <title> A calculus for cryptographic protocols: The spi calculus. </title> <type> Technical Report 414, </type> <institution> University of Cambridge Computer Laboratory, </institution> <month> January </month> <year> 1997. </year> <note> A revised version appeared as Digital Equipment Corporation Systems Research Center report No. 149, January 1998, and an abridged version will appear in Information and Computation. </note>
Reference-contexts: We emphasize secrecy properties. In section 4, we view protocols in context by discussing their boundaries. These boundaries include programming interfaces, protocol negotiation, and error handling. This paper is an informal, partial overview, and does not advocate any particular methods for specification and verification. Occasionally, however, the spi calculus <ref> [6] </ref> serves in explanations of formal points. In addition, the paper suggests some gaps and some opportunities for further work. The subject of this paper seems to be reaching maturity, but also expanding. <p> A complete specification should not rely on unclear, implicit conventions about concurrency and roles. These limitations are widely recognized. They have been addressed in approaches based on process calculi (e.g., <ref> [41, 6, 47, 38, 57] </ref>) and other formal descriptions of processes (e.g., [53, 58]). The process calculi include established process calculi, such as CSP, and others specifically tailored for security protocols. <p> The process calculi include established process calculi, such as CSP, and others specifically tailored for security protocols. Here we sketch how protocols are described in the spi calculus <ref> [6] </ref>; descriptions in other process calculi would have similar features. The spi calculus is an extension of the pi calculus [50] with primitives for cryptographic operations. Spi-calculus processes can represent principals and sets of principals. <p> This notion of process equivalence (testing equivalence) has been applied to several classes of processes and with several concepts of distinguishability, sometimes allowing complexity-theoretic arguments (e.g., <ref> [21, 15, 6, 38] </ref>). Now focusing on the spi calculus, we obtain one definition of secrecy: Definition 1 (One definition of secrecy). Suppose that the process P (x) has at most x as free variable. <p> For example, the process (K)chfxg K i, which sends x encrypted under a fresh key K on a channel c, preserves the secrecy of x. Previous papers on the spi calculus <ref> [6, 1] </ref> contain more substantial examples to which this concept of secrecy applies.
Reference: 7. <author> Martin Abadi and Roger Needham. </author> <title> Prudent engineering practice for cryptographic protocols. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(1) </volume> <pages> 6-15, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: It may be understood that A and B both know the key K AB in advance and that A and B freshly generate N A and N B respectively, so N A and N B serve as nonces. As Bob Morris has pointed out <ref> [7] </ref>, the notation "Message n X ! Y : M " needs to be interpreted with care, because security protocols are not intended to operate in benign environments. The network between X and Y may be unreliable and even hostile; X and Y themselves may not deserve total trust. <p> These meanings and goals are not always explicit or evident in protocol narrations (cf. <ref> [7] </ref>). There is no universal interpretation for protocols. Two usual objectives are to guarantee authenticity and secrecy of communications: only the intended principals can send and receive certain pieces of data. Other objectives include forward secrecy [24], non-repudiation, and availability. Some objectives contradict others. <p> Some of these traversals seem to be a grow ing concern in protocol design. (4) Systems often include multiple protocols, each of them with multiple versions and options. Interactions between protocols can lead to flaws; they can be avoided by distinguishing the messages that correspond to each protocol (e.g., <ref> [7, 34] </ref>). Before executing a protocol (in a particular version, with particular options) the participants sometimes agree to do so by a process of negotiation in which they may consider alternatives. The alternatives can vary in their levels of security and efficiency.
Reference: 8. <author> Bowen Alpern and Fred B. Schneider. </author> <title> Defining liveness. </title> <journal> Information Processing Letters, </journal> <volume> 21(4) </volume> <pages> 181-185, </pages> <month> October </month> <year> 1985. </year>
Reference-contexts: Once properly formalized, this statement is either true or false for any particular behavior. Such predicates on behaviors have been studied extensively in the literature on concurrency (e.g., <ref> [8, 36] </ref>). A richer view of authenticity also takes into account concepts such as author-ity and delegation [29, 37]. Those concepts appear, for example, when we weaken the authenticity statement by allowing B to delegate the task of communicating with A and the necessary authority for this task.
Reference: 9. <author> Ross Anderson and Roger Needham. </author> <title> Robustness principles for public key protocols. </title> <booktitle> In Proceedings of Crypto '95, </booktitle> <pages> pages 236-247, </pages> <year> 1995. </year>
Reference-contexts: For example, the absence of a check in the CCITT X.509 protocol [18] allowed an attack [16]; other attacks arise when principals assume that the messages that they receive have particular forms <ref> [9] </ref>. The emission of Message n+1 follows the reception of Message n only in the simplest protocols. In general, a protocol may allow multiple messages belonging to the same session to be in flight simultaneously. The constraints on the order of messages in SSL have often been misunderstood [60].
Reference: 10. <author> Mihir Bellare, Ran Canetti, and Hugo Krawczyk. </author> <title> A modular approach to the design and analysis of authentication and key exchange protocols. </title> <booktitle> In Proceedings of the 30th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 419-428, </pages> <month> May </month> <year> 1998. </year>
Reference-contexts: For instance, the protocol may yield a key that can be used for signing application messages. Application program interfaces (or even programming languages) should allow applications to exploit those useful properties, with clear, modular semantics, and without revealing tricky low-level cryptographic details (e.g., <ref> [12, 40, 39, 61, 2, 5, 10] </ref>). (2) Some protocols rely on fixed suites of cryptosystems. In other cases, assumptions about the properties of cryptographic operations are needed.
Reference: 11. <author> Mihir Bellare and Phillip Rogaway. </author> <title> Entity authentication and key distribution. </title> <booktitle> In Advances in Cryptology|CRYPTO '93, volume 773 of Lecture Notes in Computer Science, </booktitle> <pages> pages 232-249. </pages> <publisher> Springer Verlag, </publisher> <month> August </month> <year> 1993. </year>
Reference-contexts: Other objectives include forward secrecy [24], non-repudiation, and availability. Some objectives contradict others. For example, some protocols aim to guarantee anonymity rather than authenticity, or plausible deniability [54] rather than non-repudiation. Moreover, many definitions have been proposed even for such basic concepts as authenticity (e.g., <ref> [11, 30, 42, 3] </ref>). Nevertheless, there are some common themes in the treatment of protocol properties. The participants in security protocols do not operate in a closed world, but in communication with other principals. Some of those principals may be hostile, and even the participants may not be fully trusted. <p> Some of these frameworks are simple and specialized [16], others powerful and general. A frequent, effective approach consists in formulating properties as predicates on the behaviors (sequences of states or events) of the system consisting of a protocol and its environment (e.g., <ref> [62, 11, 31, 41, 51, 53, 14, 57] </ref>).
Reference: 12. <author> Andrew D. Birrell. </author> <title> Secure communication using remote procedure calls. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 3(1) </volume> <pages> 1-14, </pages> <month> February </month> <year> 1985. </year>
Reference-contexts: For instance, the protocol may yield a key that can be used for signing application messages. Application program interfaces (or even programming languages) should allow applications to exploit those useful properties, with clear, modular semantics, and without revealing tricky low-level cryptographic details (e.g., <ref> [12, 40, 39, 61, 2, 5, 10] </ref>). (2) Some protocols rely on fixed suites of cryptosystems. In other cases, assumptions about the properties of cryptographic operations are needed. <p> Similarly, protocols often rely on network time servers, trusted third parties, and other auxiliary participants. Detailed assumptions about these servers are sometimes absent from protocol narrations, but they are essential in reasoning about protocols. (3) Protocol messages commonly go across network interfaces, firewalls with tunnels, and administrative frontiers (e.g., <ref> [12, 61, 20, 19, 4] </ref>). In some contexts (e.g., [17]), even the protocol participants may be mobile. These traversals often require message translations (for example, marshaling and rewriting of URLs). They are subject to filtering and auditing. Furthermore, they may trigger auxiliary protocols.
Reference: 13. <author> Daniel Bleichenbacher. </author> <title> Chosen ciphertext attacks against protocols based on the RSA encryption standard PKCS #1. </title> <booktitle> In Advances in Cryptology - CRYPTO'98, volume 1462 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-12. </pages> <publisher> Springer-Verlag, </publisher> <year> 1998. </year>
Reference-contexts: Yet proper handling of errors can be crucial to system security. For example, in describing attacks on protocols based on RSA's PKCS #1 standard <ref> [13] </ref>, Bleichenbacher reported that the SSL documentation does not clearly specify error conditions and the resulting alert messages, and that SSL implementations vary in their handling of errors.
Reference: 14. <author> Chiara Bodei, Pierpaolo Degano, Flemming Nielson, and Hanne Riis Nielson. </author> <title> Control flow analysis for the -calculus. </title> <booktitle> In CONCUR'98: Concurrency Theory, volume 1466 of Lecture Notes in Computer Science, </booktitle> <pages> pages 84-98. </pages> <publisher> Springer Verlag, </publisher> <month> Septem-ber </month> <year> 1998. </year>
Reference-contexts: Some of these frameworks are simple and specialized [16], others powerful and general. A frequent, effective approach consists in formulating properties as predicates on the behaviors (sequences of states or events) of the system consisting of a protocol and its environment (e.g., <ref> [62, 11, 31, 41, 51, 53, 14, 57] </ref>).
Reference: 15. <author> Michele Boreale and Rocco De Nicola. </author> <title> Testing equivalence for mobile processes. </title> <journal> Information and Computation, </journal> <volume> 120(2) </volume> <pages> 279-303, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: This notion of process equivalence (testing equivalence) has been applied to several classes of processes and with several concepts of distinguishability, sometimes allowing complexity-theoretic arguments (e.g., <ref> [21, 15, 6, 38] </ref>). Now focusing on the spi calculus, we obtain one definition of secrecy: Definition 1 (One definition of secrecy). Suppose that the process P (x) has at most x as free variable.
Reference: 16. <author> Michael Burrows, Martin Abadi, and Roger Needham. </author> <title> A logic of authentication. </title> <journal> Proceedings of the Royal Society of London A, </journal> <volume> 426 </volume> <pages> 233-271, </pages> <year> 1989. </year> <note> A preliminary version appeared as Digital Equipment Corporation Systems Research Center report No. 39, </note> <month> February </month> <year> 1989. </year>
Reference-contexts: If this check fails, A may ignore the message or report an error. (Section 4 discusses errors further.) Checks are an essential part of protocols. For example, the absence of a check in the CCITT X.509 protocol [18] allowed an attack <ref> [16] </ref>; other attacks arise when principals assume that the messages that they receive have particular forms [9]. The emission of Message n+1 follows the reception of Message n only in the simplest protocols. <p> Protocol properties have been expressed and proved in a variety of frameworks. Some of these frameworks are simple and specialized <ref> [16] </ref>, others powerful and general. A frequent, effective approach consists in formulating properties as predicates on the behaviors (sequences of states or events) of the system consisting of a protocol and its environment (e.g., [62, 11, 31, 41, 51, 53, 14, 57]).
Reference: 17. <author> L. Cardelli and A. D. Gordon. </author> <booktitle> Mobile ambients. In Foundations of Software Science and Computation Structures, First International Conference (FoSSaCS '98), volume 1378 of Lecture Notes in Computer Science, </booktitle> <pages> pages 140-155. </pages> <publisher> Springer Verlag, </publisher> <year> 1998. </year>
Reference-contexts: Detailed assumptions about these servers are sometimes absent from protocol narrations, but they are essential in reasoning about protocols. (3) Protocol messages commonly go across network interfaces, firewalls with tunnels, and administrative frontiers (e.g., [12, 61, 20, 19, 4]). In some contexts (e.g., <ref> [17] </ref>), even the protocol participants may be mobile. These traversals often require message translations (for example, marshaling and rewriting of URLs). They are subject to filtering and auditing. Furthermore, they may trigger auxiliary protocols.
Reference: 18. <author> CCITT. </author> <title> Blue Book (Recommendation X.509 and ISO 9594-8: The directory-authentication framework). </title> <type> CCITT, </type> <year> 1988. </year>
Reference-contexts: If this check fails, A may ignore the message or report an error. (Section 4 discusses errors further.) Checks are an essential part of protocols. For example, the absence of a check in the CCITT X.509 protocol <ref> [18] </ref> allowed an attack [16]; other attacks arise when principals assume that the messages that they receive have particular forms [9]. The emission of Message n+1 follows the reception of Message n only in the simplest protocols.
Reference: 19. <author> Pau-Chen Cheng, Juan A. Garay, Amir Herzberg, and Hugo Krawczyk. </author> <title> Design and implementation of modular key management protocol and IP secure tunnel on AIX. </title> <booktitle> In Proceedings of the 5th USENIX UNIX Security Symposium, </booktitle> <pages> pages 41-54, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Similarly, protocols often rely on network time servers, trusted third parties, and other auxiliary participants. Detailed assumptions about these servers are sometimes absent from protocol narrations, but they are essential in reasoning about protocols. (3) Protocol messages commonly go across network interfaces, firewalls with tunnels, and administrative frontiers (e.g., <ref> [12, 61, 20, 19, 4] </ref>). In some contexts (e.g., [17]), even the protocol participants may be mobile. These traversals often require message translations (for example, marshaling and rewriting of URLs). They are subject to filtering and auditing. Furthermore, they may trigger auxiliary protocols.
Reference: 20. <author> William Cheswick and Steven Bellovin. </author> <title> Firewalls and Internet Security. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Similarly, protocols often rely on network time servers, trusted third parties, and other auxiliary participants. Detailed assumptions about these servers are sometimes absent from protocol narrations, but they are essential in reasoning about protocols. (3) Protocol messages commonly go across network interfaces, firewalls with tunnels, and administrative frontiers (e.g., <ref> [12, 61, 20, 19, 4] </ref>). In some contexts (e.g., [17]), even the protocol participants may be mobile. These traversals often require message translations (for example, marshaling and rewriting of URLs). They are subject to filtering and auditing. Furthermore, they may trigger auxiliary protocols.
Reference: 21. <author> Rocco De Nicola and Matthew C. B. Hennessy. </author> <title> Testing equivalences for processes. </title> <journal> Theoretical Computer Science, </journal> <volume> 34 </volume> <pages> 83-133, </pages> <year> 1984. </year>
Reference-contexts: This notion of process equivalence (testing equivalence) has been applied to several classes of processes and with several concepts of distinguishability, sometimes allowing complexity-theoretic arguments (e.g., <ref> [21, 15, 6, 38] </ref>). Now focusing on the spi calculus, we obtain one definition of secrecy: Definition 1 (One definition of secrecy). Suppose that the process P (x) has at most x as free variable.
Reference: 22. <author> Dorothy E. Denning. </author> <title> Cryptography and Data Security. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1982. </year>
Reference-contexts: Other specifications are precise mathematical statements, sometimes expressed in formal calculi. These specifications have played a particularly significant role in cryptography and cryptographic protocols, but also appear in other areas, for example in information-flow analysis (e.g., <ref> [28, 22, 43, 48] </ref>). Many of these specifications serve as the basis for reasoning, with various degrees of rigor and effectiveness, during system design, implementation, and analysis. <p> There are also deeper differences between them: in particular, the first definition rules out implicit information flows <ref> [22] </ref>, while the second one does not. We leave for further work explaining when one definition is appropriate and when the other, and finding useful relations between them. Both of these definitions of secrecy rely on a simple, abstract representation of cryptographic functions.
Reference: 23. <author> Dorothy E. Denning and Giovanni Maria Sacco. </author> <title> Timestamps in key distribution protocols. </title> <journal> Communications of the ACM, </journal> <volume> 24(7) </volume> <pages> 533-535, </pages> <month> August </month> <year> 1981. </year>
Reference-contexts: For example, although precautions may be taken to avoid the compromise of session keys, an attacker might obtain one of those keys. A good protocol design will minimize the effect of such events. In particular, certificates for keys should expire <ref> [23] </ref>; and when one key is expiring, it should not be used for encrypting the new key that will replace it. It is common to separate essential security properties from other properties such as functional correctness and performance.
Reference: 24. <author> Whitfield Diffie, Paul C. van Oorschot, and Michael J. Wiener. </author> <title> Authentication and authenticated key exchanges. Designs, </title> <journal> Codes and Cryptography, </journal> <volume> 2 </volume> <pages> 107-125, </pages> <year> 1992. </year>
Reference-contexts: There is no universal interpretation for protocols. Two usual objectives are to guarantee authenticity and secrecy of communications: only the intended principals can send and receive certain pieces of data. Other objectives include forward secrecy <ref> [24] </ref>, non-repudiation, and availability. Some objectives contradict others. For example, some protocols aim to guarantee anonymity rather than authenticity, or plausible deniability [54] rather than non-repudiation. Moreover, many definitions have been proposed even for such basic concepts as authenticity (e.g., [11, 30, 42, 3]).
Reference: 25. <author> Danny Dolev, Cynthia Dwork, and Moni Naor. </author> <title> Non-malleable cryptography. </title> <booktitle> In ACM, editor, Proceedings of the Twenty Third Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 542-552, </pages> <year> 1991. </year>
Reference-contexts: It may also be important to say that B is not capable of making fN A ; N B g K AB from fN A g K AB and N B without K AB . This property is a form of non-malleability <ref> [25] </ref>. In recent years, the literature on protocols has shown an increasing awareness of subtle cryptographic issues; it may be time for some principled simplification. Similarly, protocols often rely on network time servers, trusted third parties, and other auxiliary participants.
Reference: 26. <author> Danny Dolev and Andrew C. Yao. </author> <title> On the security of public key protocols. </title> <journal> IEEE Transactions on Information Theory, </journal> <volume> IT-29(12):198-208, </volume> <month> March </month> <year> 1983. </year>
Reference-contexts: Previous papers on the spi calculus [6, 1] contain more substantial examples to which this concept of secrecy applies. Approaches based on predicates on behaviors rely on a rather different definition of secrecy, which can be traced back to the influential work of Dolev and Yao <ref> [26] </ref> and other early work in this area [35, 49, 46].
Reference: 27. <author> Alan O. Freier, Philip Karlton, and Paul C. Kocher. </author> <title> The SSL protocol: </title> <note> Version 3.0. Available at http://home.netscape.com/eng/ssl3/ssl-toc.html, March 1996. </note>
Reference-contexts: Current specifications of security mechanisms and properties vary greatly in quality, scope, purpose, and vocabulary. Some specifications are informal narrations that mix natural language and ad hoc notations. For example, the documents that describe the functioning of security protocols such as SSL <ref> [27] </ref>, SSH [63], and IKE [32] often have this style. Other specifications are precise mathematical statements, sometimes expressed in formal calculi. These specifications have played a particularly significant role in cryptography and cryptographic protocols, but also appear in other areas, for example in information-flow analysis (e.g., [28, 22, 43, 48]).
Reference: 28. <author> Morrie Gasser. </author> <title> Building a Secure Computer System. </title> <publisher> Van Nostrand Reinhold Company Inc., </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: It has long been argued that "security by obscurity" is usually inferior to open design <ref> [55, 28] </ref>. Of course, the value of writing and publishing specifications is greater when the specifications are clear, complete, and at an appropriate level of abstraction. Current specifications of security mechanisms and properties vary greatly in quality, scope, purpose, and vocabulary. <p> Other specifications are precise mathematical statements, sometimes expressed in formal calculi. These specifications have played a particularly significant role in cryptography and cryptographic protocols, but also appear in other areas, for example in information-flow analysis (e.g., <ref> [28, 22, 43, 48] </ref>). Many of these specifications serve as the basis for reasoning, with various degrees of rigor and effectiveness, during system design, implementation, and analysis.
Reference: 29. <author> Morrie Gasser and Ellen McDermott. </author> <title> An architecture for practical delegation in a distributed system. </title> <booktitle> In Proceedings of the 1990 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 20-30, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: Once properly formalized, this statement is either true or false for any particular behavior. Such predicates on behaviors have been studied extensively in the literature on concurrency (e.g., [8, 36]). A richer view of authenticity also takes into account concepts such as author-ity and delegation <ref> [29, 37] </ref>. Those concepts appear, for example, when we weaken the authenticity statement by allowing B to delegate the task of communicating with A and the necessary authority for this task. However, it is still unclear how to integrate those concepts with predicates on behaviors.
Reference: 30. <author> Dieter Gollman. </author> <booktitle> What do we mean by entity authentication? In Proceedings of the 1996 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 46-54, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Other objectives include forward secrecy [24], non-repudiation, and availability. Some objectives contradict others. For example, some protocols aim to guarantee anonymity rather than authenticity, or plausible deniability [54] rather than non-repudiation. Moreover, many definitions have been proposed even for such basic concepts as authenticity (e.g., <ref> [11, 30, 42, 3] </ref>). Nevertheless, there are some common themes in the treatment of protocol properties. The participants in security protocols do not operate in a closed world, but in communication with other principals. Some of those principals may be hostile, and even the participants may not be fully trusted.
Reference: 31. <author> James W. Gray III and John McLean. </author> <title> Using temporal logic to specify and verify cryptographic protocols (progress report). </title> <booktitle> In Proceedings of the 8th IEEE Computer Security Foundations Workshop, </booktitle> <pages> pages 108-116, </pages> <year> 1995. </year>
Reference-contexts: Some of these frameworks are simple and specialized [16], others powerful and general. A frequent, effective approach consists in formulating properties as predicates on the behaviors (sequences of states or events) of the system consisting of a protocol and its environment (e.g., <ref> [62, 11, 31, 41, 51, 53, 14, 57] </ref>).
Reference: 32. <author> D. Harkins and D. Carrel. </author> <title> RFC 2409: The Internet Key Exchange (IKE). </title> <note> Available at ftp://ftp.isi.edu/in-notes/rfc2409.txt, </note> <month> November </month> <year> 1998. </year>
Reference-contexts: Current specifications of security mechanisms and properties vary greatly in quality, scope, purpose, and vocabulary. Some specifications are informal narrations that mix natural language and ad hoc notations. For example, the documents that describe the functioning of security protocols such as SSL [27], SSH [63], and IKE <ref> [32] </ref> often have this style. Other specifications are precise mathematical statements, sometimes expressed in formal calculi. These specifications have played a particularly significant role in cryptography and cryptographic protocols, but also appear in other areas, for example in information-flow analysis (e.g., [28, 22, 43, 48]).
Reference: 33. <author> Nevin Heintze and Jon G. Riecke. </author> <title> The SLam calculus: programming with secrecy and integrity. </title> <booktitle> In Proceedings of the 25th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 365-377, </pages> <year> 1998. </year>
Reference-contexts: On the other hand, representing the protocol as a process P (x), we may express the secrecy property by saying that P (M ) and P (N ) are equivalent (or indistinguishable), for all possible values M and N for x (cf. <ref> [59, 33] </ref>). Here we say that two processes P 1 and P 2 are equivalent when no third process Q can distinguish running in parallel with P 1 from running in parallel in P 2 .
Reference: 34. <author> John Kelsey, Bruce Schneier, and David Wagner. </author> <title> Protocol interactions and the chosen protocol attack. In Security Protocols: </title> <booktitle> 5th International Workshop, volume 1361 of Lecture Notes in Computer Science, </booktitle> <pages> pages 91-104. </pages> <publisher> Springer Verlag, </publisher> <year> 1997. </year>
Reference-contexts: Some of these traversals seem to be a grow ing concern in protocol design. (4) Systems often include multiple protocols, each of them with multiple versions and options. Interactions between protocols can lead to flaws; they can be avoided by distinguishing the messages that correspond to each protocol (e.g., <ref> [7, 34] </ref>). Before executing a protocol (in a particular version, with particular options) the participants sometimes agree to do so by a process of negotiation in which they may consider alternatives. The alternatives can vary in their levels of security and efficiency.
Reference: 35. <author> Richard A. Kemmerer. </author> <title> Analyzing encryption protocols using formal verification techniques. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 7(4) </volume> <pages> 448-457, </pages> <month> May </month> <year> 1989. </year>
Reference-contexts: Approaches based on predicates on behaviors rely on a rather different definition of secrecy, which can be traced back to the influential work of Dolev and Yao [26] and other early work in this area <ref> [35, 49, 46] </ref>. According to that definition, a process preserves the secrecy of a piece of data M if the process never sends M in clear on the network, or anything that would permit the computation of M , even in interaction with an attacker.
Reference: 36. <author> Leslie Lamport. </author> <title> A simple approach to specifying concurrent systems. </title> <journal> Communications of the ACM, </journal> <volume> 32(1) </volume> <pages> 32-45, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: Once properly formalized, this statement is either true or false for any particular behavior. Such predicates on behaviors have been studied extensively in the literature on concurrency (e.g., <ref> [8, 36] </ref>). A richer view of authenticity also takes into account concepts such as author-ity and delegation [29, 37]. Those concepts appear, for example, when we weaken the authenticity statement by allowing B to delegate the task of communicating with A and the necessary authority for this task.
Reference: 37. <author> Butler Lampson, Martin Abadi, Michael Burrows, and Edward Wobber. </author> <title> Authentication in distributed systems: </title> <journal> Theory and practice. ACM Transactions on Computer Systems, </journal> <volume> 10(4) </volume> <pages> 265-310, </pages> <month> November </month> <year> 1992. </year>
Reference-contexts: Once properly formalized, this statement is either true or false for any particular behavior. Such predicates on behaviors have been studied extensively in the literature on concurrency (e.g., [8, 36]). A richer view of authenticity also takes into account concepts such as author-ity and delegation <ref> [29, 37] </ref>. Those concepts appear, for example, when we weaken the authenticity statement by allowing B to delegate the task of communicating with A and the necessary authority for this task. However, it is still unclear how to integrate those concepts with predicates on behaviors.
Reference: 38. <author> P. Lincoln, J. Mitchell, M. Mitchell, and A. Scedrov. </author> <title> A probabilistic poly-time framework for protocol analysis. </title> <booktitle> In Proceedings of the Fifth ACM Conference on Computer and Communications Security, </booktitle> <pages> pages 112-121, </pages> <year> 1998. </year>
Reference-contexts: A complete specification should not rely on unclear, implicit conventions about concurrency and roles. These limitations are widely recognized. They have been addressed in approaches based on process calculi (e.g., <ref> [41, 6, 47, 38, 57] </ref>) and other formal descriptions of processes (e.g., [53, 58]). The process calculi include established process calculi, such as CSP, and others specifically tailored for security protocols. <p> This notion of process equivalence (testing equivalence) has been applied to several classes of processes and with several concepts of distinguishability, sometimes allowing complexity-theoretic arguments (e.g., <ref> [21, 15, 6, 38] </ref>). Now focusing on the spi calculus, we obtain one definition of secrecy: Definition 1 (One definition of secrecy). Suppose that the process P (x) has at most x as free variable.
Reference: 39. <author> John Linn. </author> <title> Generic interface to security services. </title> <journal> Computer Communications, </journal> <volume> 17(7) </volume> <pages> 476-482, </pages> <month> July </month> <year> 1994. </year>
Reference-contexts: For instance, the protocol may yield a key that can be used for signing application messages. Application program interfaces (or even programming languages) should allow applications to exploit those useful properties, with clear, modular semantics, and without revealing tricky low-level cryptographic details (e.g., <ref> [12, 40, 39, 61, 2, 5, 10] </ref>). (2) Some protocols rely on fixed suites of cryptosystems. In other cases, assumptions about the properties of cryptographic operations are needed.
Reference: 40. <author> Jonn Linn. </author> <title> RFC 1508: Generic security service application program interface. </title> <note> Web page at ftp://ds.internic.net/rfc/rfc1508.txt, </note> <month> September </month> <year> 1993. </year>
Reference-contexts: For instance, the protocol may yield a key that can be used for signing application messages. Application program interfaces (or even programming languages) should allow applications to exploit those useful properties, with clear, modular semantics, and without revealing tricky low-level cryptographic details (e.g., <ref> [12, 40, 39, 61, 2, 5, 10] </ref>). (2) Some protocols rely on fixed suites of cryptosystems. In other cases, assumptions about the properties of cryptographic operations are needed.
Reference: 41. <author> Gavin Lowe. </author> <title> Breaking and fixing the Needham-Schroeder public-key protocol using FDR. In Tools and Algorithms for the Construction and Analysis of Systems, </title> <booktitle> volume 1055 of Lecture Notes in Computer Science, </booktitle> <pages> pages 147-166. </pages> <publisher> Springer Verlag, </publisher> <year> 1996. </year>
Reference-contexts: A complete specification should not rely on unclear, implicit conventions about concurrency and roles. These limitations are widely recognized. They have been addressed in approaches based on process calculi (e.g., <ref> [41, 6, 47, 38, 57] </ref>) and other formal descriptions of processes (e.g., [53, 58]). The process calculi include established process calculi, such as CSP, and others specifically tailored for security protocols. <p> Some of these frameworks are simple and specialized [16], others powerful and general. A frequent, effective approach consists in formulating properties as predicates on the behaviors (sequences of states or events) of the system consisting of a protocol and its environment (e.g., <ref> [62, 11, 31, 41, 51, 53, 14, 57] </ref>).
Reference: 42. <author> Gavin Lowe. </author> <title> A hierarchy of authentication specifications. </title> <booktitle> In Proceedings of the 10th IEEE Computer Security Foundations Workshop, </booktitle> <pages> pages 31-43, </pages> <year> 1997. </year>
Reference-contexts: Other objectives include forward secrecy [24], non-repudiation, and availability. Some objectives contradict others. For example, some protocols aim to guarantee anonymity rather than authenticity, or plausible deniability [54] rather than non-repudiation. Moreover, many definitions have been proposed even for such basic concepts as authenticity (e.g., <ref> [11, 30, 42, 3] </ref>). Nevertheless, there are some common themes in the treatment of protocol properties. The participants in security protocols do not operate in a closed world, but in communication with other principals. Some of those principals may be hostile, and even the participants may not be fully trusted.
Reference: 43. <author> Michael Luby. </author> <title> Pseudorandomness and Cryptographic Applications. </title> <publisher> Princeton University Press, </publisher> <year> 1996. </year>
Reference-contexts: Other specifications are precise mathematical statements, sometimes expressed in formal calculi. These specifications have played a particularly significant role in cryptography and cryptographic protocols, but also appear in other areas, for example in information-flow analysis (e.g., <ref> [28, 22, 43, 48] </ref>). Many of these specifications serve as the basis for reasoning, with various degrees of rigor and effectiveness, during system design, implementation, and analysis. <p> We leave for further work explaining when one definition is appropriate and when the other, and finding useful relations between them. Both of these definitions of secrecy rely on a simple, abstract representation of cryptographic functions. More detailed accounts of cryptography may include complexity-theoretic assumptions about those functions (e.g., <ref> [43] </ref>). Another, challenging subject for further work is bridging the gap between those treatments of cryptography. For instance, we may wonder whether the complexity-theoretic assumptions justify our definitions of secrecy.
Reference: 44. <author> John McLean. </author> <title> Security models. </title> <editor> In John Marciniak, editor, </editor> <booktitle> Encyclopedia of Software Engineering. </booktitle> <publisher> Wiley & Sons, </publisher> <year> 1994. </year>
Reference-contexts: However, it is still unclear how to integrate those concepts with predicates on behaviors. Furthermore, some security properties|such as noninterference|are not predicates on behaviors <ref> [44, 45] </ref>. For instance, suppose that we wish to require that a protocol preserve the secrecy of one of its parameters, x.
Reference: 45. <author> John McLean. </author> <title> A general theory of composition for a class of "possibilistic" properties. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 22(1) </volume> <pages> 53-66, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: However, it is still unclear how to integrate those concepts with predicates on behaviors. Furthermore, some security properties|such as noninterference|are not predicates on behaviors <ref> [44, 45] </ref>. For instance, suppose that we wish to require that a protocol preserve the secrecy of one of its parameters, x.
Reference: 46. <author> Catherine Meadows. </author> <title> A system for the specification and analysis of key management protocols. </title> <booktitle> In Proceedings of the 1991 IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 182-195, </pages> <year> 1991. </year>
Reference-contexts: Approaches based on predicates on behaviors rely on a rather different definition of secrecy, which can be traced back to the influential work of Dolev and Yao [26] and other early work in this area <ref> [35, 49, 46] </ref>. According to that definition, a process preserves the secrecy of a piece of data M if the process never sends M in clear on the network, or anything that would permit the computation of M , even in interaction with an attacker.
Reference: 47. <author> Catherine Meadows. </author> <title> Panel on languages for formal specification of security protocols. </title> <booktitle> In Proceedings of the 10th IEEE Computer Security Foundations Workshop, </booktitle> <pages> page 96, </pages> <year> 1997. </year>
Reference-contexts: A complete specification should not rely on unclear, implicit conventions about concurrency and roles. These limitations are widely recognized. They have been addressed in approaches based on process calculi (e.g., <ref> [41, 6, 47, 38, 57] </ref>) and other formal descriptions of processes (e.g., [53, 58]). The process calculi include established process calculi, such as CSP, and others specifically tailored for security protocols. <p> Moreover, precise specifications need not be hard to construct: in recent work, Lowe, Millen, and others have studied how to turn sequences of messages into formal specifications <ref> [47] </ref>. To date, however, formal specifications do not seem to have played a significant role for protocol implementations.
Reference: 48. <author> Alfred J. Menezes, Paul C. van Oorschot, and Scott A. Vanstone. </author> <title> Handbook of Applied Cryptography. </title> <publisher> CRC Press, </publisher> <year> 1996. </year>
Reference-contexts: Other specifications are precise mathematical statements, sometimes expressed in formal calculi. These specifications have played a particularly significant role in cryptography and cryptographic protocols, but also appear in other areas, for example in information-flow analysis (e.g., <ref> [28, 22, 43, 48] </ref>). Many of these specifications serve as the basis for reasoning, with various degrees of rigor and effectiveness, during system design, implementation, and analysis. <p> In Message 2, B responds with a similar message, including N B in the cleartext. The braces represent the encryption operation, in this case using a symmetric cryptosystem such as DES <ref> [48] </ref>. The subscripts on K AB , N A , and N B are merely hints.
Reference: 49. <author> Jonathan K. Millen, Sidney C. Clark, and Sheryl B. Freedman. </author> <title> The Interrogator: Protocol security analysis. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-13(2):274-288, </volume> <month> February </month> <year> 1987. </year>
Reference-contexts: Approaches based on predicates on behaviors rely on a rather different definition of secrecy, which can be traced back to the influential work of Dolev and Yao [26] and other early work in this area <ref> [35, 49, 46] </ref>. According to that definition, a process preserves the secrecy of a piece of data M if the process never sends M in clear on the network, or anything that would permit the computation of M , even in interaction with an attacker.
Reference: 50. <author> Robin Milner, Joachim Parrow, and David Walker. </author> <title> A calculus of mobile processes, parts I and II. </title> <journal> Information and Computation, </journal> <volume> 100 </volume> <pages> 1-40 and 41-77, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: The process calculi include established process calculi, such as CSP, and others specifically tailored for security protocols. Here we sketch how protocols are described in the spi calculus [6]; descriptions in other process calculi would have similar features. The spi calculus is an extension of the pi calculus <ref> [50] </ref> with primitives for cryptographic operations. Spi-calculus processes can represent principals and sets of principals.
Reference: 51. <author> John C. Mitchell, Mark Mitchell, and Ulrich Stern. </author> <title> Automated analysis of cryptographic protocols using MurOE. </title> <booktitle> In Proceedings of the 1997 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 141-151, </pages> <year> 1997. </year>
Reference-contexts: Some of these frameworks are simple and specialized [16], others powerful and general. A frequent, effective approach consists in formulating properties as predicates on the behaviors (sequences of states or events) of the system consisting of a protocol and its environment (e.g., <ref> [62, 11, 31, 41, 51, 53, 14, 57] </ref>).
Reference: 52. <author> Roger M. Needham and Michael D. Schroeder. </author> <title> Using encryption for authentication in large networks of computers. </title> <journal> Communications of the ACM, </journal> <volume> 21(12) </volume> <pages> 993-999, </pages> <month> December </month> <year> 1978. </year>
Reference-contexts: They are sometimes simple, high-level descriptions of sequences of messages, sometimes more detailed documents that permit the construction of interoperable implementations. Following Needham and Schroeder <ref> [52] </ref>, we may write a typical pair of messages of a protocol thus: Message 1 A ! B : fN A g K AB Message 2 B ! A : fN A ; N B g K AB Here A and B represent principals (users or computers).
Reference: 53. <author> L. C. Paulson. </author> <title> The inductive approach to verifying cryptographic protocols. </title> <booktitle> Jour--nal of Computer Security, </booktitle> <address> 6(1-2):85-128, </address> <year> 1998. </year>
Reference-contexts: A complete specification should not rely on unclear, implicit conventions about concurrency and roles. These limitations are widely recognized. They have been addressed in approaches based on process calculi (e.g., [41, 6, 47, 38, 57]) and other formal descriptions of processes (e.g., <ref> [53, 58] </ref>). The process calculi include established process calculi, such as CSP, and others specifically tailored for security protocols. Here we sketch how protocols are described in the spi calculus [6]; descriptions in other process calculi would have similar features. <p> Some of these frameworks are simple and specialized [16], others powerful and general. A frequent, effective approach consists in formulating properties as predicates on the behaviors (sequences of states or events) of the system consisting of a protocol and its environment (e.g., <ref> [62, 11, 31, 41, 51, 53, 14, 57] </ref>).
Reference: 54. <author> Michael Roe. </author> <title> Cryptography and Evidence. </title> <type> PhD thesis, </type> <institution> University of Cambridge Computer Laboratory, </institution> <year> 1997. </year> <note> Available as a technical report of the Centre for Communications Systems Research at http://www.ccsr.cam.ac.uk/techreports/. </note>
Reference-contexts: Other objectives include forward secrecy [24], non-repudiation, and availability. Some objectives contradict others. For example, some protocols aim to guarantee anonymity rather than authenticity, or plausible deniability <ref> [54] </ref> rather than non-repudiation. Moreover, many definitions have been proposed even for such basic concepts as authenticity (e.g., [11, 30, 42, 3]). Nevertheless, there are some common themes in the treatment of protocol properties.
Reference: 55. <author> Jerome H. Saltzer and Michael D. Schroeder. </author> <title> The protection of information in computer system. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 63(9) </volume> <pages> 1278-1308, </pages> <month> September </month> <year> 1975. </year>
Reference-contexts: It has long been argued that "security by obscurity" is usually inferior to open design <ref> [55, 28] </ref>. Of course, the value of writing and publishing specifications is greater when the specifications are clear, complete, and at an appropriate level of abstraction. Current specifications of security mechanisms and properties vary greatly in quality, scope, purpose, and vocabulary.
Reference: 56. <author> Fred B. Schneider, </author> <title> editor. Trust in Cyberspace. </title> <publisher> National Academy Press, </publisher> <address> pre-publication copy edition, </address> <year> 1998. </year> <note> Report of the Committee on Information Systems Trustworthiness, </note> <institution> Computer Science and Telecommunications Board, National Research Council. </institution>
Reference-contexts: In this area, theory has been relevant to practice, even in cases where the theory is simplistic or incomplete. There seems to have been less progress in treating more complex systems <ref> [56] </ref>, even those parts in the vicinity of familiar security mechanisms. For example, we still have only a limited understanding of many of the interfaces, prologues, and epilogues of practical security protocols. In this paper, we discuss specifications in the field of security, focusing on protocol specifications.
Reference: 57. <author> Steve Schneider. </author> <title> Verifying authentication protocols in CSP. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 24(9) </volume> <pages> 741-758, </pages> <month> September </month> <year> 1998. </year>
Reference-contexts: A complete specification should not rely on unclear, implicit conventions about concurrency and roles. These limitations are widely recognized. They have been addressed in approaches based on process calculi (e.g., <ref> [41, 6, 47, 38, 57] </ref>) and other formal descriptions of processes (e.g., [53, 58]). The process calculi include established process calculi, such as CSP, and others specifically tailored for security protocols. <p> Some of these frameworks are simple and specialized [16], others powerful and general. A frequent, effective approach consists in formulating properties as predicates on the behaviors (sequences of states or events) of the system consisting of a protocol and its environment (e.g., <ref> [62, 11, 31, 41, 51, 53, 14, 57] </ref>).
Reference: 58. <author> F. Javier Thayer Fabrega, Jonathan C. Herzog, and Joshua D. Guttman. </author> <title> Strand spaces: </title> <booktitle> Why is a security protocol correct? In Proceedings 1998 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 160-171, </pages> <month> May </month> <year> 1998. </year>
Reference-contexts: A complete specification should not rely on unclear, implicit conventions about concurrency and roles. These limitations are widely recognized. They have been addressed in approaches based on process calculi (e.g., [41, 6, 47, 38, 57]) and other formal descriptions of processes (e.g., <ref> [53, 58] </ref>). The process calculi include established process calculi, such as CSP, and others specifically tailored for security protocols. Here we sketch how protocols are described in the spi calculus [6]; descriptions in other process calculi would have similar features.
Reference: 59. <author> Dennis Volpano, Cynthia Irvine, and Geoffrey Smith. </author> <title> A sound type system for secure flow analysis. </title> <journal> Journal of Computer Security, </journal> <volume> 4 </volume> <pages> 167-187, </pages> <year> 1996. </year>
Reference-contexts: On the other hand, representing the protocol as a process P (x), we may express the secrecy property by saying that P (M ) and P (N ) are equivalent (or indistinguishable), for all possible values M and N for x (cf. <ref> [59, 33] </ref>). Here we say that two processes P 1 and P 2 are equivalent when no third process Q can distinguish running in parallel with P 1 from running in parallel in P 2 .
Reference: 60. <author> David Wagner and Bruce Schneier. </author> <title> Analysis of the SSL 3.0 protocol. </title> <booktitle> In Proceedings of the Second USENIX Workshop on Electronic Commerce Proceedings, </booktitle> <pages> pages 29-40, </pages> <month> November </month> <year> 1996. </year> <note> A revised version is available at http://www.cs.berkeley.edu/~daw/me.html. </note>
Reference-contexts: The emission of Message n+1 follows the reception of Message n only in the simplest protocols. In general, a protocol may allow multiple messages belonging to the same session to be in flight simultaneously. The constraints on the order of messages in SSL have often been misunderstood <ref> [60] </ref>. Other complex protocols may be similarly confusing. As a convention, it is generally assumed that many protocol executions may happen simultaneously, and that the same principal may participate in several such executions, possibly playing different roles in each of them. This convention has exceptions, however. <p> The alternatives can vary in their levels of security and efficiency. In protocols such as SSL, this process of negotiation is rather elaborate and error-prone <ref> [60] </ref>. Despite clear narrations, it offers unclear guarantees. (5) As discussed in section 2, protocol specifications often do not explain how principals react when they perceive errors. Yet proper handling of errors can be crucial to system security.
Reference: 61. <author> Edward Wobber, Martin Abadi, Michael Burrows, and Butler Lampson. </author> <title> Authentication in the Taos operating system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 12(1) </volume> <pages> 3-32, </pages> <month> February </month> <year> 1994. </year>
Reference-contexts: For instance, the protocol may yield a key that can be used for signing application messages. Application program interfaces (or even programming languages) should allow applications to exploit those useful properties, with clear, modular semantics, and without revealing tricky low-level cryptographic details (e.g., <ref> [12, 40, 39, 61, 2, 5, 10] </ref>). (2) Some protocols rely on fixed suites of cryptosystems. In other cases, assumptions about the properties of cryptographic operations are needed. <p> Similarly, protocols often rely on network time servers, trusted third parties, and other auxiliary participants. Detailed assumptions about these servers are sometimes absent from protocol narrations, but they are essential in reasoning about protocols. (3) Protocol messages commonly go across network interfaces, firewalls with tunnels, and administrative frontiers (e.g., <ref> [12, 61, 20, 19, 4] </ref>). In some contexts (e.g., [17]), even the protocol participants may be mobile. These traversals often require message translations (for example, marshaling and rewriting of URLs). They are subject to filtering and auditing. Furthermore, they may trigger auxiliary protocols.
Reference: 62. <author> Thomas Y. C. Woo and Simon S. Lam. </author> <title> A semantic model for authentication protocols. </title> <booktitle> In Proceedings of the 1993 IEEE Symposium on Research on Security and Privacy, </booktitle> <pages> pages 178-194, </pages> <year> 1993. </year>
Reference-contexts: Some of these frameworks are simple and specialized [16], others powerful and general. A frequent, effective approach consists in formulating properties as predicates on the behaviors (sequences of states or events) of the system consisting of a protocol and its environment (e.g., <ref> [62, 11, 31, 41, 51, 53, 14, 57] </ref>).
Reference: 63. <author> Tatu Ylonen. </author> <title> SSH|Secure login connections over the Internet. </title> <booktitle> In Proceedings of the Sixth USENIX Security Symposium, </booktitle> <pages> pages 37-42, </pages> <month> July </month> <year> 1996. </year>
Reference-contexts: Current specifications of security mechanisms and properties vary greatly in quality, scope, purpose, and vocabulary. Some specifications are informal narrations that mix natural language and ad hoc notations. For example, the documents that describe the functioning of security protocols such as SSL [27], SSH <ref> [63] </ref>, and IKE [32] often have this style. Other specifications are precise mathematical statements, sometimes expressed in formal calculi. These specifications have played a particularly significant role in cryptography and cryptographic protocols, but also appear in other areas, for example in information-flow analysis (e.g., [28, 22, 43, 48]).
References-found: 63

