URL: ftp://ftp.cs.dartmouth.edu/TR/TR95-266.ps.Z
Refering-URL: http://www.cs.dartmouth.edu/reports/abstracts/TR95-266/
Root-URL: http://www.cs.dartmouth.edu
Email: smoore@bbn.com  wisnie@cs.dartmouth.edu  
Title: Complexity Analysis of Two Permutations Used by Fast Cosine Transform Algorithms  
Author: Sean S. B. Moore Leonard F. Wisniewski 
Date: October 10, 1995  
Address: Cambridge, MA 02138  Hanover, NH 03755  College PCS-TR95-266  
Affiliation: BBN Systems and Technologies  Department of Computer Science Dartmouth College  Dartmouth  
Abstract: The fast cosine transform algorithms introduced in [ST91, Ste92] require fewer operations than any other known general algorithm. Similar to related fast transform algorithms (e.g., the FFT), these algorithms permute the data before, during, or after the computation of the transform. The choice of this permutation may be an important consideration in reducing the complexity of the permutation algorithm. In this paper, we derive the complexity to generate the permutation mappings used in [ST91, Ste92] for power-of-2 data sets by representing them as linear index transformations and translating them into combinational circuits. Moreover, we show that the permutation used in [Ste92] not only allows efficient implementation, but is also self-invertible, i.e., we can use the same circuit to generate the permutation mapping for both the fast cosine transform and its inverse, like the bit-reversal permutation used by FFT algorithms. These results may be useful to designers of low-level algorithms for implementing fast cosine transforms.
Abstract-found: 1
Intro-found: 1
Reference: [BM75] <author> A. Borodin and I. Munro. </author> <title> The Computational Complexity of Algebraic and Numeric Problems. </title> <publisher> Elsevier, </publisher> <address> New York, </address> <year> 1975. </year>
Reference-contexts: We refer the interested reader to the original paper [ST91] for more specific details, or to an expanded discussion in [Moo94]. The fast cosine transform algorithm uses the polynomial division tree method for evaluating a polynomial function <ref> [BM75, DHR94, Knu81, Moo94] </ref>. In the polynomial division tree model, we represent a function as a polynomial p (z).
Reference: [Chi95] <author> P. Chintrakulchai. </author> <title> Speeding Up Fractal Image Compression. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Dartmouth College, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Fast cosine transform (FCT) algorithms are essential to efficient computation in many applications such as weather modeling, data compression/decompression and convolutions on real, symmetric data <ref> [Chi95, ER82, RY90] </ref>. Recent descriptions of fast cosine transform algorithms [ST91, Ste92] claim record minimums for the number of multiplication and addition operations needed to compute an FCT. These new algorithms have been derived using the polynomial division tree computational model.
Reference: [CSW94] <author> T.H. Cormen, T. Sundquist, </author> <title> and L.F. Wisniewski. Asymptotically tight bounds for performing BMMC permutations on parallel disk systems. </title> <type> Technical Report Technical Report PCS-TR94-223, </type> <institution> Dartmouth College Department of Computer Science, </institution> <month> July </month> <year> 1994. </year> <booktitle> Preliminary version appeared in Proceedings of the 5th Annual ACM Symposium on Parallel Algorithms and Architectures. </booktitle>
Reference-contexts: Equivalently, multiplication is replaced by logical-and, and addition is replaced by exclusive-or. 6 tions also include non-BPC permutations such as the standard binary-reflected Gray code and the permutations discussed in this paper. We use several properties of characteristic matrices extensively throughout Sections 3 and 4. The following lemma from <ref> [CSW94] </ref> shows the equivalence of multiplying characteristic matrices and composing permutations when the complement vectors are zero. For permutations Y and Z , we define the composition Z ffi Y as ( Z ffi Y )(x) = Z ( Y (x)) for all x in the domain of Y . <p> Then the matrix product Z Y characterizes the composition Z ffi Y . We can decompose a characteristic matrix A into a product of several nonsingular matrices, each of which characterizes a BMMC permutation. The following corollary from <ref> [CSW94] </ref> describes the order in which we perform these permutations to effect the permutation characterized by A.
Reference: [DHR94] <author> J.R. Driscoll, D. Healy, and D. Rockmore. </author> <title> Fast spherical transforms for distance transitive graphs. </title> <type> Technical Report Technical Report PCS-TR94-223, </type> <institution> Dartmouth College Department of Mathematics and Computer Science, </institution> <year> 1994. </year>
Reference-contexts: We refer the interested reader to the original paper [ST91] for more specific details, or to an expanded discussion in [Moo94]. The fast cosine transform algorithm uses the polynomial division tree method for evaluating a polynomial function <ref> [BM75, DHR94, Knu81, Moo94] </ref>. In the polynomial division tree model, we represent a function as a polynomial p (z). <p> The derivation of the odd-upper/bit-reversal (OUR) permutation arises naturally when we consider the computation of a fast cosine transform as a fast Fourier transform, or more generally as a fast discrete monomial transform <ref> [DHR94, MHR93] </ref>.
Reference: [EHJ94] <author> A. Edelman, S. Heller, and S.L. Johnson. </author> <title> Index transformation algorithms in a linear algebra framework. </title> <journal> IEEE Transactions on Parallel and Distributed Systems, </journal> <volume> 5(12) </volume> <pages> 1302-1309, </pages> <month> December </month> <year> 1994. </year>
Reference-contexts: BMMC permutations include the subclass of BPC (bit-permute/complement) permutations which have characteristic matrices with exactly one 1 in each row and column. BPC permutations include many common permutations such as the bit-reversal permutation, matrix transposition, vector-reversal permutations, hypercube permutations, and matrix reblocking. BMMC permuta 2 Edelman, Heller, and Johnson <ref> [EHJ94] </ref> call BMMC permutations affine transformations or, if there is no complementing, linear transformations. 3 Matrix multiplication over GF (2) is like standard matrix multiplication over the reals but with all arithmetic performed modulo 2.
Reference: [ER82] <author> D.F. Elliot and K.R. Rao. </author> <title> Fast Transforms: Algorithms, Analyses, Applications. </title> <publisher> Academic Press, </publisher> <address> Orlando, </address> <year> 1982. </year>
Reference-contexts: 1 Introduction Fast cosine transform (FCT) algorithms are essential to efficient computation in many applications such as weather modeling, data compression/decompression and convolutions on real, symmetric data <ref> [Chi95, ER82, RY90] </ref>. Recent descriptions of fast cosine transform algorithms [ST91, Ste92] claim record minimums for the number of multiplication and addition operations needed to compute an FCT. These new algorithms have been derived using the polynomial division tree computational model.
Reference: [Knu81] <author> D. Knuth. </author> <booktitle> The Art of Computer Programming, Volume 2: Seminumerical Algorithms. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1981. </year>
Reference-contexts: We refer the interested reader to the original paper [ST91] for more specific details, or to an expanded discussion in [Moo94]. The fast cosine transform algorithm uses the polynomial division tree method for evaluating a polynomial function <ref> [BM75, DHR94, Knu81, Moo94] </ref>. In the polynomial division tree model, we represent a function as a polynomial p (z).
Reference: [MHR93] <author> S.S.B. Moore, D.M. Healy, and D.N. Rockmore. </author> <title> Symmetry stabilization for fast discrete monomial transforms and polynomial evaluation. Linear Algebra and its Applications Special Issue on Computational Linear Algebra in Algebraic and Related Problems, </title> <booktitle> 192 </booktitle> <pages> 249-299, </pages> <month> October </month> <year> 1993. </year> <month> 20 </month>
Reference-contexts: The derivation of the odd-upper/bit-reversal (OUR) permutation arises naturally when we consider the computation of a fast cosine transform as a fast Fourier transform, or more generally as a fast discrete monomial transform <ref> [DHR94, MHR93] </ref>. <p> The derivation of the odd-upper/bit-reversal (OUR) permutation arises naturally when we consider the computation of a fast cosine transform as a fast Fourier transform, or more generally as a fast discrete monomial transform [DHR94, MHR93]. It is shown in <ref> [MHR93] </ref> and elsewhere that for a real-valued sequence f = f (0); f (1); : : :; f (N 1) generated by evaluating a function at N points, we can compute the discrete cosine transform ^ f cos of f as the real part of the discrete Fourier transform ^ f <p> If the evaluation points on the unit circle are not uniformly spaced or we do not apply an appropriate permutation matrix, then the fast Fourier transform uses O (N lg 2 N ) operations <ref> [MHR93] </ref>.
Reference: [Moo94] <author> S. S. B. Moore. </author> <title> Efficient Stabilization Methods for Fast Polynomial Transforms. </title> <type> PhD thesis, </type> <institution> Department of Mathematics and Computer Science, Dartmouth College, </institution> <month> June </month> <year> 1994. </year>
Reference-contexts: We transpose all the matrices for the inverse FCT algorithm to obtain the forward FCT algorithm. We refer the interested reader to the original paper [ST91] for more specific details, or to an expanded discussion in <ref> [Moo94] </ref>. The fast cosine transform algorithm uses the polynomial division tree method for evaluating a polynomial function [BM75, DHR94, Knu81, Moo94]. In the polynomial division tree model, we represent a function as a polynomial p (z). <p> We refer the interested reader to the original paper [ST91] for more specific details, or to an expanded discussion in [Moo94]. The fast cosine transform algorithm uses the polynomial division tree method for evaluating a polynomial function <ref> [BM75, DHR94, Knu81, Moo94] </ref>. In the polynomial division tree model, we represent a function as a polynomial p (z). <p> -point sequence x, the permutation is (x) = x (0) ; x (2) ; : : : ; x (N2) ; x (N1) ; x (N3) ; : : : ; x (3) ; x (1) : If we compose the bit-reversal permutation with (x) 6 and apply U , <ref> [Moo94] </ref> shows that the ordering of the elements on the unit circle produces the sparse matrices needed to compute a fast discrete Fourier transform and its associated discrete cosine transform using O (N lg N ) operations. An example for N = 8 may be helpful.
Reference: [RY90] <author> K.R. Rao and P. Yip. </author> <title> Discrete Cosine Transforms: Algorithms, Advantages, Applications. </title> <publisher> Academic Press, </publisher> <address> San Diego, </address> <year> 1990. </year>
Reference-contexts: 1 Introduction Fast cosine transform (FCT) algorithms are essential to efficient computation in many applications such as weather modeling, data compression/decompression and convolutions on real, symmetric data <ref> [Chi95, ER82, RY90] </ref>. Recent descriptions of fast cosine transform algorithms [ST91, Ste92] claim record minimums for the number of multiplication and addition operations needed to compute an FCT. These new algorithms have been derived using the polynomial division tree computational model.
Reference: [ST91] <author> G. Steidl and M. Tasche. </author> <title> A polynomial approach to fast algorithms for discrete Fourier-cosine and Fourier-sine transforms. </title> <journal> Mathematics of Computation, </journal> <volume> 56(193) </volume> <pages> 281-296, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction Fast cosine transform (FCT) algorithms are essential to efficient computation in many applications such as weather modeling, data compression/decompression and convolutions on real, symmetric data [Chi95, ER82, RY90]. Recent descriptions of fast cosine transform algorithms <ref> [ST91, Ste92] </ref> claim record minimums for the number of multiplication and addition operations needed to compute an FCT. These new algorithms have been derived using the polynomial division tree computational model. <p> In the evaluation case, we do not use the quadrature matrix W. 2 In this paper, for power-of-2 data sets, we analyze the complexity of the two permutations used in the fast cosine transform algorithms described in <ref> [ST91] </ref> and [Ste92] and show that the permutation in [Ste92] exhibits properties similar to those of the bit-reversal permutation. We use the following technique to analyze the complexity of these permutations. <p> Step 3 We translate the characteristic matrix form into a combinational circuit consisting of only XOR gates. We shall see later that the characteristic matrix forms that generate the structure of the permutation matrices described in <ref> [ST91, Ste92] </ref> clearly illustrate their translation into constant-depth, logarithmic-width circuits. We show, however, that the circuit to perform the inverse permutation mapping used by the fast cosine transform algorithm in [ST91] has lg lg N -depth and logarithmic width. <p> We shall see later that the characteristic matrix forms that generate the structure of the permutation matrices described in [ST91, Ste92] clearly illustrate their translation into constant-depth, logarithmic-width circuits. We show, however, that the circuit to perform the inverse permutation mapping used by the fast cosine transform algorithm in <ref> [ST91] </ref> has lg lg N -depth and logarithmic width. Fortunately, we also show that the circuit used by the fast cosine transform algorithm in [Ste92] is constant-depth, logarithmic-width, and self-invertible. <p> We also define the class of BMMC (bit-matrix multiply/complement) permutations which includes the linear permutations used by the fast cosine transform algorithms. In Section 3, we present the permutation of <ref> [ST91] </ref>, which we call the recursive complement, or RC, permutation, and use the above methodology to analyze its complexity. In Section 4, we perform a similar analysis of the permutation of [Ste92], which we call the odd-upper/bit-reversal, or OUR, permutation, but we also show that the permutation is self-invertible. <p> Section 5 concludes. 2 Definitions and Background In this section, we define the discrete cosine transform (DCT) and give an overview of the fast cosine transform (FCT) algorithms of <ref> [ST91, Ste92] </ref> to compute the DCT. The permutations used by these FCT algorithms belong to the class of BMMC (bit-matrix multiply/complement) permutations. We also define the class of BMMC permutations and provide the linear index transformation framework which we use extensively in the next two sections. <p> Because the transformation matrix C is orthogonal (when properly normalized), the matrix-vector product for the inverse DCT in equation (3) is f = C t ^ f : The fast inverse cosine transform algorithm of <ref> [ST91] </ref> corresponds to a sparse factorization of the matrix C t such that C t = P t D t 1 D t where each matrix D t i is sparse (i.e., the matrix contains O (N ) non-zero entries) and the matrix P t is a permutation matrix. <p> We transpose all the matrices for the inverse FCT algorithm to obtain the forward FCT algorithm. We refer the interested reader to the original paper <ref> [ST91] </ref> for more specific details, or to an expanded discussion in [Moo94]. The fast cosine transform algorithm uses the polynomial division tree method for evaluating a polynomial function [BM75, DHR94, Knu81, Moo94]. In the polynomial division tree model, we represent a function as a polynomial p (z). <p> The computation recurses down the tree until each leaf in the division tree results in a remainder that is equivalent to p (x k ). In <ref> [ST91] </ref>, the polynomial division tree derivation for the DCT proceeds by first casting the inverse DCT as the evaluation of a Chebyshev polynomial p (x) such that p (x) = j=0 where we define T j (x) = cos j (arccos x) = T j as the jth Chebyshev polynomial. <p> We use the permutation effected by the permutation matrix P to reorder the data appropriately. When the size of the data set is a power of 2, the fast algorithms in <ref> [ST91] </ref> and [Ste92] both compute the correct evaluation, but perform different permutations to achieve it. In the next two sections, we shall examine these two permutations in detail and show that the permutation of [Ste92] has more appealing properties. <p> That is, we perform the permutations characterized by the factors of a matrix from right to left. In Sections 3 and 4, we use Corollary 2 to compose the component permutations A (i) used in the permutation algorithms of <ref> [ST91, Ste92] </ref> into a single permutation. We measure the combinational complexity of a permutation as the number of bit-operations required to generate the structure of the permutation matrix P using a combinational circuit to compute the mapping defined by the characteristic matrix A. <p> Therefore, when discussing the computational complexity of these permutations, we refer to the combinational complexity. The combinational circuit representation may be useful to designers of low-level implementations. In Sections 3 and 4, we translate the permutation algorithms used in the FCT algorithms presented in <ref> [ST91] </ref> and [Ste92], respectively, into a single characteristic matrix form that generates the structure of the permutation matrix. In Section 3, we show that the permutation of [ST91], which we call the recursive-complement, or RC, permutation, requires a constant-depth, logarithmic-width circuit to compute its structure, and, therefore, has a complexity of <p> In Sections 3 and 4, we translate the permutation algorithms used in the FCT algorithms presented in <ref> [ST91] </ref> and [Ste92], respectively, into a single characteristic matrix form that generates the structure of the permutation matrix. In Section 3, we show that the permutation of [ST91], which we call the recursive-complement, or RC, permutation, requires a constant-depth, logarithmic-width circuit to compute its structure, and, therefore, has a complexity of O (N lg N ) bit-operations. <p> transforms use O (N lg N ) bit-operations to compute the structure of the permutation matrix P, just like the bit-reversal permutation used by the FFT algorithm. 3 Recursive-complement (RC) permutations In this section, we describe an algorithm for performing the RC permutation used in the FCT algorithm presented in <ref> [ST91] </ref>. We translate the algorithm into a product of nonsingular matrices each of which characterizes a BMMC permutation with a special characteristic matrix form. <p> generate the OUR permutation matrix structure for the forward and inverse fast cosine transforms, just as the bit-reversal permutation generates the structure of the permutation matrices for the forward and inverse fast Fourier transforms. 19 5 Conclusion We have translated the two permutations used by the fast cosine transforms of <ref> [ST91, Ste92] </ref> into a product of familiar linear index transformation matrices. Both of these products result in linear index transformation matrices which we show how to implement using constant-depth, logarithmic-width circuits. By our definition, both permutations have a complexity of O (N lg N ) bit-operations.
Reference: [Ste92] <author> G. Steidl. </author> <title> Fast radix-p discrete cosine transform. </title> <booktitle> In Applicable Algebra in Engineering, Communication and Computing, </booktitle> <pages> pages 39-46. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year> <month> 21 </month>
Reference-contexts: 1 Introduction Fast cosine transform (FCT) algorithms are essential to efficient computation in many applications such as weather modeling, data compression/decompression and convolutions on real, symmetric data [Chi95, ER82, RY90]. Recent descriptions of fast cosine transform algorithms <ref> [ST91, Ste92] </ref> claim record minimums for the number of multiplication and addition operations needed to compute an FCT. These new algorithms have been derived using the polynomial division tree computational model. <p> In the evaluation case, we do not use the quadrature matrix W. 2 In this paper, for power-of-2 data sets, we analyze the complexity of the two permutations used in the fast cosine transform algorithms described in [ST91] and <ref> [Ste92] </ref> and show that the permutation in [Ste92] exhibits properties similar to those of the bit-reversal permutation. We use the following technique to analyze the complexity of these permutations. Step 1 We give high-level pseudocode for a series of linear permutations which generate the structure of the permutation matrix P. <p> In the evaluation case, we do not use the quadrature matrix W. 2 In this paper, for power-of-2 data sets, we analyze the complexity of the two permutations used in the fast cosine transform algorithms described in [ST91] and <ref> [Ste92] </ref> and show that the permutation in [Ste92] exhibits properties similar to those of the bit-reversal permutation. We use the following technique to analyze the complexity of these permutations. Step 1 We give high-level pseudocode for a series of linear permutations which generate the structure of the permutation matrix P. <p> Step 3 We translate the characteristic matrix form into a combinational circuit consisting of only XOR gates. We shall see later that the characteristic matrix forms that generate the structure of the permutation matrices described in <ref> [ST91, Ste92] </ref> clearly illustrate their translation into constant-depth, logarithmic-width circuits. We show, however, that the circuit to perform the inverse permutation mapping used by the fast cosine transform algorithm in [ST91] has lg lg N -depth and logarithmic width. <p> We show, however, that the circuit to perform the inverse permutation mapping used by the fast cosine transform algorithm in [ST91] has lg lg N -depth and logarithmic width. Fortunately, we also show that the circuit used by the fast cosine transform algorithm in <ref> [Ste92] </ref> is constant-depth, logarithmic-width, and self-invertible. Thus, the permutation of [Ste92] has properties similar to the bit reversal permutation, i.e., we can use the same constant-depth circuit to compute the structure of the permutation matrix for both the forward and inverse fast cosine transforms; therefore, the permutation of [Ste92] is preferable. <p> Fortunately, we also show that the circuit used by the fast cosine transform algorithm in <ref> [Ste92] </ref> is constant-depth, logarithmic-width, and self-invertible. Thus, the permutation of [Ste92] has properties similar to the bit reversal permutation, i.e., we can use the same constant-depth circuit to compute the structure of the permutation matrix for both the forward and inverse fast cosine transforms; therefore, the permutation of [Ste92] is preferable. <p> algorithm in <ref> [Ste92] </ref> is constant-depth, logarithmic-width, and self-invertible. Thus, the permutation of [Ste92] has properties similar to the bit reversal permutation, i.e., we can use the same constant-depth circuit to compute the structure of the permutation matrix for both the forward and inverse fast cosine transforms; therefore, the permutation of [Ste92] is preferable. The organization of the remainder of this paper is as follows. In Section 2, we define the discrete cosine transform (DCT) and discuss in more detail the polynomial division tree model and a fast algorithm to compute the DCT. <p> In Section 3, we present the permutation of [ST91], which we call the recursive complement, or RC, permutation, and use the above methodology to analyze its complexity. In Section 4, we perform a similar analysis of the permutation of <ref> [Ste92] </ref>, which we call the odd-upper/bit-reversal, or OUR, permutation, but we also show that the permutation is self-invertible. <p> Section 5 concludes. 2 Definitions and Background In this section, we define the discrete cosine transform (DCT) and give an overview of the fast cosine transform (FCT) algorithms of <ref> [ST91, Ste92] </ref> to compute the DCT. The permutations used by these FCT algorithms belong to the class of BMMC (bit-matrix multiply/complement) permutations. We also define the class of BMMC permutations and provide the linear index transformation framework which we use extensively in the next two sections. <p> We use the permutation effected by the permutation matrix P to reorder the data appropriately. When the size of the data set is a power of 2, the fast algorithms in [ST91] and <ref> [Ste92] </ref> both compute the correct evaluation, but perform different permutations to achieve it. In the next two sections, we shall examine these two permutations in detail and show that the permutation of [Ste92] has more appealing properties. <p> When the size of the data set is a power of 2, the fast algorithms in [ST91] and <ref> [Ste92] </ref> both compute the correct evaluation, but perform different permutations to achieve it. In the next two sections, we shall examine these two permutations in detail and show that the permutation of [Ste92] has more appealing properties. Before continuing our discussion, we provide some formal definitions to clarify the difference between the permutation represented by the permutation matrix P and the characteristic matrix 5 which generates the structure of the permutation matrix P. <p> That is, we perform the permutations characterized by the factors of a matrix from right to left. In Sections 3 and 4, we use Corollary 2 to compose the component permutations A (i) used in the permutation algorithms of <ref> [ST91, Ste92] </ref> into a single permutation. We measure the combinational complexity of a permutation as the number of bit-operations required to generate the structure of the permutation matrix P using a combinational circuit to compute the mapping defined by the characteristic matrix A. <p> Therefore, when discussing the computational complexity of these permutations, we refer to the combinational complexity. The combinational circuit representation may be useful to designers of low-level implementations. In Sections 3 and 4, we translate the permutation algorithms used in the FCT algorithms presented in [ST91] and <ref> [Ste92] </ref>, respectively, into a single characteristic matrix form that generates the structure of the permutation matrix. <p> We also show that the inverse of the RC permutation requires a lg lg N -depth, logarithmic-width circuit, resulting in a complexity of O (N lg N lg lg N ) bit-operations. In Section 4, we show how to implement the permutation of <ref> [Ste92] </ref>, which we call the odd-upper/bit-reversal, or OUR, permutation, with a constant-depth, logarithmic-width circuit which is self-invertible. <p> Second, two different algorithms, or circuits, must be employed for the forward and inverse fast cosine transforms. Third, the complexity for the inverse RC permutation is greater than the complexity for the forward RC permutation. The next section shows that the permutation algorithm used in <ref> [Ste92] </ref> does not have these limitations. 4 Odd-upper/bit-reversal (OUR) permutations In this section, we show that the algorithm for performing the permutation used by the FCT algorithm in [Ste92], which we call the OUR permutation, also maps to a constant-depth circuit. 5 We denote the inverse of a matrix A by <p> The next section shows that the permutation algorithm used in <ref> [Ste92] </ref> does not have these limitations. 4 Odd-upper/bit-reversal (OUR) permutations In this section, we show that the algorithm for performing the permutation used by the FCT algorithm in [Ste92], which we call the OUR permutation, also maps to a constant-depth circuit. 5 We denote the inverse of a matrix A by the function inv (A). 14 y 7 y 6 y 5 y 4 y 3 y 2 y 1 y 0 Output Register x 7 x 6 x <p> generate the OUR permutation matrix structure for the forward and inverse fast cosine transforms, just as the bit-reversal permutation generates the structure of the permutation matrices for the forward and inverse fast Fourier transforms. 19 5 Conclusion We have translated the two permutations used by the fast cosine transforms of <ref> [ST91, Ste92] </ref> into a product of familiar linear index transformation matrices. Both of these products result in linear index transformation matrices which we show how to implement using constant-depth, logarithmic-width circuits. By our definition, both permutations have a complexity of O (N lg N ) bit-operations. <p> Both of these products result in linear index transformation matrices which we show how to implement using constant-depth, logarithmic-width circuits. By our definition, both permutations have a complexity of O (N lg N ) bit-operations. We have also shown that the permutation of <ref> [Ste92] </ref> is a better permutation choice because it is self-invertible, which allows the same constant-depth circuit to be used for both the forward and the inverse FCT algorithms. We ask whether other applications use permutations that are in the class of BMMC permutations.
References-found: 12

