URL: ftp://ftp.eecs.umich.edu/groups/Ealgebras/whyuse.ps
Refering-URL: http://www.eecs.umich.edu/gasm/new1995.html
Root-URL: http://www.cs.umich.edu
Title: Why Use Evolving Algebras for Hardware and Software Engineering? habe oft bemerkt, dass wir uns
Author: Egon Borger Christian Morgenstern 
Note: Ich  
Address: Corso Italia 40, I-56125 Pisa, Italy  
Affiliation: Universita di Pisa, Dipartimento di Informatica,  
Abstract: In this paper I answer the question how evolving algebras can be used for the design and analysis of complex hardware and software systems. I present the salient features of this new method and illustrate them through several examples from my work on specification and verification of programming languages, compilers, protocols and architectures. The definition of a mathematical model for Hennessy and Patterson's RISC architecture DLX serves as a running example; this model is used in [24] to prove the correctness of instruction pipelining. I will point out the yet unexplored potential of the evolving algebra method for large-scale industrial applications. It needs some courage to come after three decades of intensive research in the area of formal methods and to advocate yet another general method for software and hardware design. However the huge gap between much of academic theory and the prevailing software and hardware practice is still with us, as is a wide-spread scepticism about the industrial benefit of formal methods (see the discussion in the literature about what are the right methods and criteria [32, 67, 68, 46, 77, 30, 31]) for software engineering to become a "mature engineering discipline"[53]. I accept with pleasure the invitation to explain to this audience how the new evolving algebra approach contributes to bridging this gap. I will try to convince you that it offers a mathematically well founded and rigorous but nevertheless simple discipline practical and scalable to industrial applications. The notion of evolving algebra has been discovered by Gurevich in an attempt to sharpen Turing's thesis by considerations from complexity theory (see [38]) where the notion has led to important new developments [6]. At that time I was trying to develop a mathematical model for the programming language Prolog; this led me to the idea to use the notion of evolving algebras for defining transparent and simple specifications of complex dynamic systems at various ? In: Proc. SOFSEM'95, Springer LNCS 2 Translation: I have often observed that by over-symbolizing we make the language inefficient to use in the real world. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> D. Barnocchi. L"Evidenza" nell'assiomatica aristotelica. Proteus, </author> <month> II,5 </month> <year> (1971), </year> <pages> pp. 133-144. </pages>
Reference: 2. <author> Ch. Beierle and E. Borger. </author> <title> A WAM extension for type-constraint logic programming: Specification and correctness proof. </title> <type> Research report IWBS 200, </type> <institution> IBM Ger-many Science Center, </institution> <address> Heidelberg, </address> <month> December </month> <year> 1991. </year>
Reference: 3. <author> Ch. Beierle, E. Borger, I. D - urd -anovic U. Glasser, and E. Riccobene. </author> <title> An evolving algebra solution to the steam-boiler control specification problem. Seminar on Methods for Specification and Semantics (Dagstuhl, </title> <month> June </month> <year> 1995), </year> <type> Report, </type> <year> 1995. </year>
Reference: 4. <author> D. </author> <title> Bjorner. A Formal Model of the Railway Application Domain System. </title> <note> UNU/IIST PRaCoSy Document no. SP/5/3, January 7, </note> <year> 1994, </year> <pages> pages 1-19. </pages>
Reference-contexts: I have mentioned already Russinoff's work on VHDL [72] as an example. Another instructive example is Bjorner's application domain model for the Chinese railway computing system <ref> [4] </ref>. programs; it permits one to concentrate on those behavioral features for which the program has been or is to be developed. There is no limitation imposed by, say, viewing programs as logical formulae or viewing programming as carrying out proofs (or normalizations of proofs) within a fixed deductive system. <p> A few paragraphs in this paper are direct quotations from [19]. Thanks to Franz Rammig for the occasion offered to discuss some of the ideas presented here to the panel on Formal Semantics: Practical Need or Academic Pleasure? at the annual European Design Automation Conference with EURO-VHDL in Grenoble <ref> (19.-23.9.1994) </ref>. Last but not least my thanks go to BRICS at the University of Aarhus for the invitation to an intensive and pleasant summer month which allowed me also to finish this paper.
Reference: 5. <author> D. </author> <title> Bjorner. Domain Analysis, a Prerequisite for Requirements Capture. UNU/IIST Document, </title> <year> 1995. </year>
Reference: 6. <author> A. Blass and Y. Gurevich. </author> <title> Evolving Algebras and Linear Time Hierarchy. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> Proc. of the IFIP 13th World Computer Congress 1994, </booktitle> <volume> Vol. I, </volume> <pages> pp. 383-390. </pages> <publisher> Elsevier, </publisher> <year> 1994. </year>
Reference: 7. <author> E. Borger. </author> <title> A logical operational semantics for full Prolog. Part I: Selection core and control. </title> <publisher> CSL'89. Springer LNCS 440, </publisher> <year> 1990, </year> <pages> 36-64. </pages>
Reference-contexts: but not least for helpful comments on previous versions of this paper: Dines Bjorner, Jonathan Bowen, Uwe Glasser, Yuri Gurevich, Nils Klarlund, Leslie Lamport, Jim Lipton, Erich Marschner, Peter Mosses, Alan Mycroft, Peter Pappinghaus, Lutz Plumer, 15 For example the four simple rules which constitute my evolving algebra model in <ref> [7, 8, 26] </ref> for the Prolog kernel for user-defined predicates have been implemented in two leading Prolog companies, one in the US and one in Europe.
Reference: 8. <author> E. Borger. </author> <title> A logical operational semantics for full Prolog. Part II: Built-in predicates for database manipulations. </title> <booktitle> MFCS'90. Mathematical Foundations of Computer Science (B. Rovan, </booktitle> <address> Ed.). </address> <publisher> Springer LNCS 452, </publisher> <year> 1990, </year> <pages> 1-14. </pages>
Reference-contexts: but not least for helpful comments on previous versions of this paper: Dines Bjorner, Jonathan Bowen, Uwe Glasser, Yuri Gurevich, Nils Klarlund, Leslie Lamport, Jim Lipton, Erich Marschner, Peter Mosses, Alan Mycroft, Peter Pappinghaus, Lutz Plumer, 15 For example the four simple rules which constitute my evolving algebra model in <ref> [7, 8, 26] </ref> for the Prolog kernel for user-defined predicates have been implemented in two leading Prolog companies, one in the US and one in Europe.
Reference: 9. <author> E. Borger. </author> <title> Logic Programming: The Evolving Algebra Approach. </title> <editor> In B. Pehrson and I. Simon (Eds.) </editor> <booktitle> IFIP 13th World Computer Congress 1994, Volume I: Technology and Foundations, </booktitle> <publisher> Elsevier, Amsterdam, </publisher> <pages> 391-395. </pages>
Reference-contexts: A few paragraphs in this paper are direct quotations from [19]. Thanks to Franz Rammig for the occasion offered to discuss some of the ideas presented here to the panel on Formal Semantics: Practical Need or Academic Pleasure? at the annual European Design Automation Conference with EURO-VHDL in Grenoble <ref> (19.-23.9.1994) </ref>. Last but not least my thanks go to BRICS at the University of Aarhus for the invitation to an intensive and pleasant summer month which allowed me also to finish this paper.
Reference: 10. <author> E. Borger. </author> <title> Review of: E.W. Dijkstra & C.S. Scholten: Predicate Calculus and Program Semantics. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year> <note> Science of Computer Programming 23 (1994) 1-11 and The Journal of Symbolic Logic 59 (1994) 673-678 </note>
Reference: 11. <author> E. Borger. </author> <title> Annotated bibliography on evolving algebras. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference: 12. <author> E. Borger and K. Dassler. </author> <title> Prolog: DIN papers for discussion. ISO/IEC JTCI SC22 WG17 Prolog standardization document no. </title> <type> 58, </type> <institution> NPl, </institution> <address> Middlesex, </address> <year> 1990, </year> <pages> pp. 92-114. </pages>
Reference-contexts: I have mentioned already several real-world case studies through which I wanted to test whether they support the preceding claim. One is the mathematical definition [26] of the semantics of the real programming language Prolog which went into the ISO standard (see <ref> [12] </ref>) and has been refined by a hierarchy of intermediate models to a definition|coming with a correctness proof|of its implementation on the Warren Abstract Machine.
Reference: 13. <author> E. Borger and G. Del Castillo. </author> <title> A formal method for provably correct composition of a real-life processor out of basic components (The APE100 reverse engineering project). </title> <booktitle> In Proc. of the First IEEE International Conference on Engineering of Complex Computer Systems (ICECCS'95). See also BRICS NS-95-4, </booktitle> <pages> pp. 195-222, </pages> <institution> University of Aarhus, </institution> <year> 1995. </year>
Reference-contexts: A recent example is the reverse engineering project <ref> [13] </ref> where evolving algebras have been used for a mathematical specification (leading to only four pages of abstract parallel code) of the VLSI implemented microprocessor which controls the successful dedicated massively parallel architecture APE100.
Reference: 14. <author> E. Borger, G. Del Castillo, P. Glavan and D. Rosenzweig. </author> <title> Towards a mathematical specification of the APE100 architecture: The APESE model. </title> <editor> In B. Pehrson and I. Simon, editors, </editor> <booktitle> Proc. of the IFIP 13th World Computer Congress 1994, </booktitle> <volume> Vol. I, </volume> <pages> pp. 396-401. </pages> <publisher> Elsevier, </publisher> <year> 1994. </year>
Reference: 15. <author> E. Borger and B. Demoen. </author> <title> A framework to specify database update views for Prolog. </title> <editor> In M. J. Maluszynski, editor, PLILP'91. </editor> <publisher> Springer LNCS 528, </publisher> <year> 1991, </year> <pages> 147-158. </pages>
Reference: 16. <author> E. Borger and I. D - urd -anovic. </author> <title> Correctness of compiling Occam to Transputer code. </title> <booktitle> BRICS NS-95-4, </booktitle> <pages> pp. </pages> <institution> 153-194 , University of Aarhus, </institution> <year> 1995. </year>
Reference-contexts: Another example is the recently finished project of a formal definition of Occam at the level of the user [17] which has been refined through a hierarchy of intermediate models to the Transputer level <ref> [16] </ref>, again coming with a mathematical correctness proof for the compilation of Occam programs into Transputer code.
Reference: 17. <author> E. Borger, I. D - urd -anovic, and D. Rosenzweig. </author> <title> Occam: Specification and compiler correctness. Part I: The primary model. </title> <editor> In E.-R. Olderog, editor, </editor> <booktitle> Proc. of PRO-COMET'94 (IFIP Working Conference on Programming Concepts, Methods and Calculi), </booktitle> <pages> pages 489-508. </pages> <publisher> North-Holland, </publisher> <year> 1994. </year>
Reference-contexts: Another example is the recently finished project of a formal definition of Occam at the level of the user <ref> [17] </ref> which has been refined through a hierarchy of intermediate models to the Transputer level [16], again coming with a mathematical correctness proof for the compilation of Occam programs into Transputer code.
Reference: 18. <author> E. Borger and U.Glasser. </author> <title> A formal specification of the PVM architecture. </title> <editor> In B. Pehrson and I. Simon (Eds.) </editor> <booktitle> IFIP 13th World Computer Congress 1994, Volume I: Technology and Foundations, </booktitle> <publisher> Elsevier, Amsterdam, </publisher> <pages> 402-409. </pages>
Reference: 19. <author> E. Borger and U.Glasser. </author> <title> Modelling and analysis of distributed and reactive systems using evolving algebras. </title> <booktitle> BRICS NS-95-4, </booktitle> <pages> pp. 128-153, </pages> <institution> University of Aarhus. </institution>
Reference-contexts: Simon Read, David Russinoff, Britta Schinzel, Kirsten Winter. A few paragraphs in this paper are direct quotations from <ref> [19] </ref>. Thanks to Franz Rammig for the occasion offered to discuss some of the ideas presented here to the panel on Formal Semantics: Practical Need or Academic Pleasure? at the annual European Design Automation Conference with EURO-VHDL in Grenoble (19.-23.9.1994).
Reference: 20. <author> E. Borger, U. Glasser and W. Mueller, </author> <title> The Semantics of Behavioral VHDL'93 Descriptions. </title> <booktitle> In: EURO-DAC'94 European Design Automation Conference with EURO-VHDL'94. Proc. </booktitle> <publisher> IEEE CS Press, </publisher> <address> Los Alamitos/CA, </address> <year> 1994, </year> <pages> 500-505. </pages>
Reference: 21. <author> E. Borger, U. Glasser and W. Mueller. </author> <title> Formal definition of an abstract VHDL'93 simulator by EA-machines. </title> <editor> In C. Delgado Kloos and Peter T. Breuer, editors, </editor> <booktitle> Semantics of VHDL, The Kluwer International Series in Engineering and Computer Science, </booktitle> <volume> vol. 307. </volume> <publisher> Kluwer, </publisher> <year> 1995. </year>
Reference: 22. <author> E. Borger, Y. Gurevich and D. Rosenzweig. </author> <title> The bakery algorithm: Yet another specification and verification. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference: 23. <author> E. Borger, F.J. Lopez-Fraguas and M. Rodrigues-Artalejo. </author> <title> A Model for Mathematical Analysis of Functional Logic Programs and their Implementations. </title> <editor> in: B. Pehrson and I. Simon (Eds.) </editor> <booktitle> IFIP 13th World Computer Congress 1994, </booktitle> <volume> Vol. I, </volume> <pages> pp. 410-415, </pages> <year> 1994, </year> <title> Elsevier. See the full version Towards a Mathematical Specification of Narrowing Machines, </title> <type> Report DIA 94/5, </type> <institution> Dep. Informatica y Automatica, Universidad Complutense, Madrid, </institution> <month> March </month> <year> 1994, </year> <month> pp.30. </month>
Reference-contexts: A few paragraphs in this paper are direct quotations from [19]. Thanks to Franz Rammig for the occasion offered to discuss some of the ideas presented here to the panel on Formal Semantics: Practical Need or Academic Pleasure? at the annual European Design Automation Conference with EURO-VHDL in Grenoble <ref> (19.-23.9.1994) </ref>. Last but not least my thanks go to BRICS at the University of Aarhus for the invitation to an intensive and pleasant summer month which allowed me also to finish this paper.
Reference: 24. <author> E. Borger and S. Mazzanti. </author> <title> A correctness proof for pipelining in RISC architectures. </title> <type> Manuscript, </type> <year> 1995. </year>
Reference: 25. <author> E. Borger and D. Rosenzweig. </author> <title> An analysis of Prolog database views and their uniform implementation. Prolog. </title> <institution> Paris Papers-2. ISO/IEC JTC1 SC22 WG17 Prolog Standardization Report no.80, </institution> <month> July </month> <year> 1991, </year> <pages> pp. 87-130. </pages>
Reference: 26. <author> E. Borger and D. Rosenzweig. </author> <title> A mathematical definition of full Prolog. </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1995. </year>
Reference-contexts: introduction to <ref> [26] </ref>). In a sense fixed point based descriptions of programming languages reintroduce both the 1-step computation and the state notion; but they do this in an implicit and technically more involved way. Single computation steps reappear in the form of successive approximations to the fixed points for the given equations. <p> The relevant state components reappear in the form of continuations. Again an example is provided by some denotational definitions of the semantics of Prolog programs in the literature. For each abstract domain which appears in the evolving algebra definition of the core of Prolog for user-defined predicates <ref> [26] </ref>, the denotational descriptions in [56, 33, 34] introduce a continuation: for terms, goals, (occurrences of) clauses, programs, substitutions, etc. <p> The difficulty is that the denotational Prolog models have to deal with these continuations explicitly|as constituents of the global "object" which encodes the "state"| via complicated and numerous equations which describe the effect of the Prolog computation. In the evolving algebra description of Prolog <ref> [26] </ref>, the corresponding elements of abstract domains appear without any encoding; no overhead is needed for their representation, they occur directly in the four simple rules which define the complete Prolog machine for user-defined predicates. <p> The use of evolving algebras allows one to cope with the complexity of real systems by building hierarchies of system levels. I have mentioned already several real-world case studies through which I wanted to test whether they support the preceding claim. One is the mathematical definition <ref> [26] </ref> of the semantics of the real programming language Prolog which went into the ISO standard (see [12]) and has been refined by a hierarchy of intermediate models to a definition|coming with a correctness proof|of its implementation on the Warren Abstract Machine. <p> but not least for helpful comments on previous versions of this paper: Dines Bjorner, Jonathan Bowen, Uwe Glasser, Yuri Gurevich, Nils Klarlund, Leslie Lamport, Jim Lipton, Erich Marschner, Peter Mosses, Alan Mycroft, Peter Pappinghaus, Lutz Plumer, 15 For example the four simple rules which constitute my evolving algebra model in <ref> [7, 8, 26] </ref> for the Prolog kernel for user-defined predicates have been implemented in two leading Prolog companies, one in the US and one in Europe.
Reference: 27. <author> E. Borger and D. Rosenzweig. </author> <title> The WAM definition and compiler correctness. </title> <editor> In L. C. Beierle and L. Plumer, editors, </editor> <booktitle> Logic Programming: Formal Methods and Practical Applications, Series in Computer Science and Artificial Intelligence. El-sevier Science B.V./North-Holland, </booktitle> <year> 1995. </year>
Reference-contexts: These abstract elements are subject to further refinement at the moment when their implementation becomes the issue, e.g. in the WAM <ref> [27] </ref>. Models versus Syntax.
Reference: 28. <author> E. Borger and R. Salamone. </author> <title> CLAM specification for provably correct compilation of CLP(R) programs. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference: 29. <author> E. Borger and P. Schmitt. </author> <title> A formal operational semantics for languages of type Prolog III. </title> <publisher> Springer LNCS 533, </publisher> <year> 1991, </year> <pages> 67-79. </pages>
Reference: 30. <editor> F.P. Bowen and M.G. Hinchey. </editor> <title> Ten Commandments of Formal Methods. </title> <booktitle> IEEE Computer 28(4) </booktitle> <pages> 56-63, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: I have shown that this method satisfies the conditions which are widely required for a "mature engineering discipline" ([53, p. 36]). After having finished this text I became acquainted with <ref> [30] </ref>; I must confess that the evolving algebra method seems to be an orthodox one: it obeys all the Ten Commandments of [30]. I hope to have revealed its practicality for the working computer scientist and also its potential to become a viable mathematical method especially under industrial constraints. <p> After having finished this text I became acquainted with <ref> [30] </ref>; I must confess that the evolving algebra method seems to be an orthodox one: it obeys all the Ten Commandments of [30]. I hope to have revealed its practicality for the working computer scientist and also its potential to become a viable mathematical method especially under industrial constraints. At this point the reader might wonder what are the limitations of the evolving algebra approach.
Reference: 31. <editor> F.P. Bowen and M.G. Hinchey. </editor> <title> Seven More Myths of Formal Methods. </title> <booktitle> IEEE Soft--ware 12(4) </booktitle> <pages> 34-41, </pages> <month> July </month> <year> 1995. </year>
Reference: 32. <author> F. P. Brooks, </author> <title> No Silver Bullet|Essence and Accidents of Software Engineering. </title> <booktitle> IEEE Computer 20, </booktitle> <year> 1987, </year> <pages> 10-19. </pages>
Reference: 33. <author> S.K. Debray and P. Mishra, </author> <title> Denotational and Operational Semantics for Prolog. In: </title> <journal> Journal of Logic Programming 5, </journal> <year> 1988, </year> <pages> 61-91 </pages>
Reference-contexts: Again an example is provided by some denotational definitions of the semantics of Prolog programs in the literature. For each abstract domain which appears in the evolving algebra definition of the core of Prolog for user-defined predicates [26], the denotational descriptions in <ref> [56, 33, 34] </ref> introduce a continuation: for terms, goals, (occurrences of) clauses, programs, substitutions, etc.
Reference: 34. <author> A. de Bruin and E. P. de Vink, </author> <title> Continuation semantics for Prolog with cut. </title> <booktitle> In: Theory and practice of software engineering, </booktitle> <publisher> Springer LNCS 351, </publisher> <year> 1989, </year> <pages> 178-192. </pages>
Reference-contexts: Again an example is provided by some denotational definitions of the semantics of Prolog programs in the literature. For each abstract domain which appears in the evolving algebra definition of the core of Prolog for user-defined predicates [26], the denotational descriptions in <ref> [56, 33, 34] </ref> introduce a continuation: for terms, goals, (occurrences of) clauses, programs, substitutions, etc.
Reference: 35. <author> R. DeMillo, R. Lipton and A. Perlis, </author> <title> A social process and proofs of theorems and programs. In: </title> <journal> Comm. </journal> <volume> ACM 22 (5), </volume> <pages> 271-280, </pages> <year> 1979. </year>
Reference: 36. <author> P. Deransart and G. Ferrand, </author> <title> An operational formal definition of Prolog.INRIA RR 763. </title> <booktitle> See Proc. 4th. Symposium on Logic Programming, </booktitle> <address> San Francisco 1987, </address> <institution> 162|172 and New Generation Computing, 10.2, </institution> <year> 1992, </year> <pages> 121-171. </pages>
Reference: 37. <author> W.W. Gibbs, </author> <title> Software's Chronic Crisis, </title> <publisher> Scientific American, </publisher> <month> Sept </month> <year> 1994, </year> <pages> 72-81. </pages>
Reference: 38. <author> Y. Gurevich. </author> <title> Logic and the challenge of computer science. </title> <editor> In E. Borger, editor, </editor> <booktitle> Current Trends in Theoretical Computer Science, </booktitle> <pages> pp. 1-57. </pages> <publisher> CS Press, </publisher> <year> 1988. </year>
Reference: 39. <author> Y. Gurevich. </author> <title> Logic Activities in Europe. in: </title> <journal> ACM SIGACT NEWS, </journal> <year> 1994. </year>
Reference: 40. <author> Yuri Gurevich. </author> <title> Evolving Algebra 1993: Lipari Guide. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference: 41. <author> Yuri Gurevich. Platonism, </author> <title> Constructivism, and Computer Proofs vs. Proofs by Hand. </title> <journal> In Bulletin of the EATCS, </journal> <month> October </month> <year> 1995. </year>
Reference: 42. <author> Y. Gurevich and J. Huggins. </author> <title> The semantics of the C programming language. </title> <publisher> Springer LNCS 702, </publisher> <year> 1993, </year> <note> 274-308 and LNCS 832, </note> <year> 1994, </year> <pages> 334-336. </pages>
Reference: 43. <author> Y. Gurevich and J. Huggins. </author> <title> Equivalence is in the eye of the beholder. </title> <type> CSE TR 240-95, </type> <institution> University of Michigan at Ann Arbor. </institution>
Reference: 44. <author> Y. Gurevich, J. Huggins and R. Mani. </author> <title> The Generalized Railroad Crossing Problem: An Evolving Algebra Based Solution. </title> <institution> CSE-TR-230-95, University of Michigan. </institution>
Reference: 45. <author> Y. Gurevich and R. Mani. </author> <title> Group Membership Protocol: Specification and Verification. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference: 46. <author> D. Harel, </author> <title> Biting the Silver Bullet. </title> <booktitle> IEEE Computer 25, </booktitle> <year> 1992, </year> <month> 8|20. </month>
Reference: 47. <author> F.W. von Henke, </author> <title> Putting Software Technology to Work, </title> <editor> In: K. Duncan and K. Krueger (Eds.) </editor> <booktitle> IFIP 13th World Computer Congress 1994, Vol. III, pp.345-350, 1994, </booktitle> <publisher> Elsevier, Amsterdam. </publisher>
Reference-contexts: of the fathers of the successful PVS system [65], points out that most tools which have been developed up to now "in dealing primarily with syntactic and structural aspects of software : : : fail to address major issues of software quality having to do with semantic aspects of software" <ref> [47, p.345] </ref>. The evolving algebra approach allows one to model and analyze the run-time program behaviour at the desired level of abstraction. What is considered as one step in a computation depends on the level of abstraction at which we want to build the computation model.
Reference: 48. <author> J. Hennessy and D.A. Patterson. </author> <title> Computer Architecture: a Quantitative Approach. </title> <publisher> Morgan Kaufman Publisher, </publisher> <year> 1990. </year>
Reference: 49. <author> H. Herbelin. </author> <title> Types for Proofs and Programs. Note on the ESPRIT Basic Research Action 6453 in: </title> <journal> Bulletin of the EATCS vol.54, </journal> <year> 1994, </year> <pages> 105-116. </pages>
Reference: 50. <author> C.A.R. Hoare. </author> <title> An axiomatic basis for computer programming. In: </title> <journal> Comm. ACM 12, </journal> <pages> pp. </pages> <address> 576-580 and 583, </address> <year> 1969. </year>
Reference-contexts: In this connection compare the following: 1. According to Hoare, it should be the case that "all the properties of a program and all the consequences of executing it can, in principle, be found out from the text of the program itself by means of purely deductive reasoning" <ref> [50, p. 576] </ref>. 2.
Reference: 51. <editor> C.A.R. </editor> <booktitle> Hoare, ProCoS Working Group Meeting, </booktitle> <address> Gentofte/DK 18.-20.1.1994. </address>
Reference-contexts: They work well for small examples, often invented to illustrate the method. But when it comes to real-life large systems many of them face the well known combinatorial explosion or simply fail. Developing techniques for crossing abstraction levels <ref> [51] </ref> represents one of the challenging goals of current computer science research and is of vital importance for the development of reliable safety critical systems (see the title Developing abstraction for coping with complexity of a section on safety in the IFIP 1994 World Computer Congress, op.cit.).
Reference: 52. <author> C.A.R. Hoare, </author> <title> Mathematical Models for Computing Science. </title> <type> Manuscript, </type> <month> August </month> <year> 1994, </year> <pages> 65 pp. </pages>
Reference: 53. <author> G.J. Holzmann, </author> <title> The Theory and Practice of a Formal Method: </title> <editor> NewCoRe, in: B. Pehrson and I. Simon (Eds.), </editor> <booktitle> Technology and Foundations, Information Processing '94, Volume I, Proc. of the IFIP 13th World Computer Congress 1994, IFIP Transaction A-51, </booktitle> <pages> pp. 35-44, </pages> <publisher> Elsevier, Amsterdam. </publisher>
Reference: 54. <author> J. Huggins. </author> <title> Kermit: Specification and verification. </title> <editor> In E. Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference: 55. <institution> IEEE Standard VHDL Language Reference Manual|IEEE Std 1076-1993, The Institute of Electrical and Electronics Engineering. </institution> <address> New York, NY, USA, </address> <year> 1994. </year>
Reference: 56. <author> N.D. Jones and A. Mycroft, </author> <title> Stepwise development of operational and denotational semantics for Prolog. </title> <booktitle> In: Proc. Int. Symp. on Logic Programming 2/84, </booktitle> <address> Atlantic City, </address> <publisher> IEEE, </publisher> <pages> 289-298 </pages>
Reference-contexts: Again an example is provided by some denotational definitions of the semantics of Prolog programs in the literature. For each abstract domain which appears in the evolving algebra definition of the core of Prolog for user-defined predicates [26], the denotational descriptions in <ref> [56, 33, 34] </ref> introduce a continuation: for terms, goals, (occurrences of) clauses, programs, substitutions, etc.
Reference: 57. <author> G. Kahn, </author> <title> Natural Semantics, </title> <institution> INRIA Rapport de Recherche No. </institution> <month> 601, Fevrier </month> <year> 1987. </year>
Reference: 58. <author> B. Littlewood, L. Strigini, </author> <title> The Risks of Software, in: </title> <publisher> Scientific American. </publisher> <address> Novem-ber 1992, p.38-43. </address>
Reference: 59. <author> A. J. Mansfield, </author> <title> An Explanation of the Formal Definition of Prolog. </title> <type> NPL Report DITC 149/89, </type> <institution> Teddington, </institution> <year> 1989, </year> <pages> p. 1-9. </pages>
Reference: 60. <author> R. Milner and M. Tofte, and R. Harper. </author> <title> The definition of Standard ML. </title> <address> Cambridge, Mass.: </address> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: 61. <author> R. Milner, M. Tofte, </author> <title> Commentary on Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference: 62. <author> Peter D. Mosses. </author> <title> Denotational Semantics. </title> <editor> In: Jan van Leeuwen (Ed.), </editor> <booktitle> Handbook of TCS. </booktitle> <publisher> Elsevier 1990. </publisher>
Reference: 63. <author> Peter D. Mosses. </author> <title> Action Semantics. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: The development of denotational semantics has brought us a good understanding of types and higher-order functions (in particular <ref> [63] </ref> is an example. In general, during the last years there seems to be a trend in theoretical computer science to make semantics more operational. The interest in full abstraction and observational equivalences is a related phenomenon. It is my belief that people put too much emphasis on syntax.
Reference: 64. <author> N.North, </author> <title> A denotational definition of Prolog. </title> <type> NPL, Teddington, TR DITC 106/88. </type>
Reference: 65. <author> S. Owre, J. Rushby, N. Shankar and F. von Henke, </author> <title> Formal Verification for Fault-tolerant Architectures: Prolegomena to the Design of PVS. In: </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 21, no. 2, </volume> <month> February </month> <year> 1995, </year> <month> pp.107-125. </month>
Reference-contexts: Von Henke, one of the fathers of the successful PVS system <ref> [65] </ref>, points out that most tools which have been developed up to now "in dealing primarily with syntactic and structural aspects of software : : : fail to address major issues of software quality having to do with semantic aspects of software" [47, p.345].
Reference: 66. <author> D. L. Parnas. </author> <title> Information distribution aspects of design methodology. </title> <editor> In C. V. Freiman, editor, </editor> <booktitle> Proc. of IFIP Congress 1971, Volume 1: Foundations and Systems, </booktitle> <pages> pp. 339-344. </pages> <publisher> North-Holland, </publisher> <year> 1972. </year>
Reference: 67. <author> D. L. Parnas, </author> <title> Software Aspects of Strategic Defense Systems. In: </title> <journal> Comm. ACM, </journal> <volume> 28 (12), </volume> <year> 1985, </year> <month> 1.326-1.335. </month>
Reference: 68. <author> D. L. Parnas, </author> <title> Education for Computer Professionals. </title> <booktitle> In: IEEE Computer 23, </booktitle> <year> 1990, </year> <month> 17|22. </month>
Reference: 69. <author> G. Plotkin, </author> <title> A structural approach to operational semantics, </title> <type> Internal Report, </type> <institution> CS Department, Aarhus University, DAIMI FN-19 </institution>
Reference: 70. <author> K. </author> <title> Popper, </title> <journal> Logik der Forschung.1935. </journal>
Reference: 71. <author> S. </author> <title> Read, </title> <booktitle> e-mail 25 Oct 1994, Compass Design Automation, </booktitle> <address> Columbia/MD. </address>
Reference: 72. <author> D. M. Russinoff, </author> <title> Specification and verification of gate-level VHDL models of synchronous and asynchronous circuits. In: Specification and Validation Methods, </title> <editor> Ed. E. Borger, </editor> <publisher> Oxford University Press, </publisher> <year> 1995, </year> <pages> pp. 411-459. </pages>
Reference-contexts: I have mentioned already Russinoff's work on VHDL <ref> [72] </ref> as an example. Another instructive example is Bjorner's application domain model for the Chinese railway computing system [4]. programs; it permits one to concentrate on those behavioral features for which the program has been or is to be developed.
Reference: 73. <author> D. Scott, </author> <title> Outline of a Mathematical Theory of Computation, </title> <address> PRG-2, </address> <month> November </month> <year> 1970, </year> <institution> Oxford Univ. Comp. Lab., Progr. Res. Group, pp.1-24 </institution>
Reference-contexts: I am discussing only whether these results gave as much to practical applications as the pioneers intended. Who does still remember the goal stated in <ref> [73, p. 2] </ref> that the mathematical definition of a language should enable one to determine whether a proposed implementation is correct ? I certainly do not deny that in particular contexts denotational definitions can be both elegant and useful.
Reference: 74. <author> D. Scott, C. Strachey, </author> <title> Toward a Mathematical Semantics for Computer Languages. </title> <booktitle> Proc. 21st Symp. Computers and Automata, Polyt.Inst. of Brooklyn, </booktitle> <year> 1971, </year> <pages> 19-46. </pages>
Reference: 75. <author> D.R. Smith, </author> <title> Classification Approach to Design, </title> <type> TR KES.U.93.4, </type> <institution> Kestrel Institute, </institution> <address> Palo Alto, CA, </address> <month> November </month> <year> 1993, </year> <month> pp.24 </month>
Reference: 76. <author> D.R. Smith and E.A. </author> <title> Parra, Transformational Approach to Transportation Scheduling, </title> <booktitle> in: Proc of the Eighth Knowledge-Based Software Engineering Conference, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <month> September </month> <year> 1993, </year> <pages> 60-68. </pages>
Reference: 77. <author> J. M. Wing, </author> <title> A Specifier's Introduction to Formal Methods. In: </title> <journal> IEEE Computer, </journal> <volume> 23 (9), </volume> <year> 1990, </year> <pages> 8-24. </pages>
Reference-contexts: The question therefore is not whether "mathematics" is needed or not, but how the intrinsically mathematical part of the programming activity is supported by a method, be it "formal" or not. This is expressed also by Wing <ref> [77, p. 10] </ref>: "Programs, however, are formal objects, susceptible to formal manipulation : : : Thus, programmers cannot escape from formal methods.
Reference: 78. <author> M. Wirsing. </author> <title> Handbook of Algebraic Specifications. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science B, </booktitle> <pages> pages 675-788, </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference: 79. <author> N. Wirth. </author> <title> Algorithms & Data Structures. </title> <publisher> Prentice-Hall, </publisher> <year> 1975. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
References-found: 79

