URL: http://www.csl.sri.com/reports/postscript/csl-95-12.ps.gz
Refering-URL: http://www.csl.sri.com/reports/postscript/
Root-URL: 
Title: Analyzing Tabular and State-Transition Requirements Specifications in PVS 1  
Author: Sam Owre, John Rushby, and Natarajan Shankar 
Note: Air Force Office of Scientific Research under contract F49620-95-C0044.  
Address: Menlo Park CA 94025 USA  
Affiliation: Computer Science Laboratory SRI International  
Abstract: Technical Report CSL-95-12 June 1995 (Revised April 1996) 
Abstract-found: 1
Intro-found: 1
Reference: <institution> Most papers by SRI authors can be retrieved from http://www.csl.sri.com/fm. html. </institution> <note> PVS specification files for several of the examples used here can be downloaded from http://www.csl.sri.com/pvs/examples/tables; PVS itself is available at http://www.csl.sri.com/pvs.html. </note>
Reference: [1] <author> Joanne M. Atlee. </author> <title> Native model-checking of SCR requirements. </title> <booktitle> In Fourth International SCR Workshop, </booktitle> <address> Washington, DC, </address> <month> November </month> <year> 1994. </year> <institution> Naval Research Laboratory. </institution>
Reference-contexts: AND/OR Tables and Decision Tables decision_table_TCC2.1 : |------- [2] Alt_Capt_Hold!1 [3] AC_Alt!1 &gt;= Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.1. decision_table_TCC2.2 : |------- <ref> [1] </ref> climb?(Flightphase!1) [2] Alt_Target!1 = prev_Alt_Target!1 Rule? (POSTPONE) Postponing decision_table_TCC2.2. decision_table_TCC2.3 : |------- [1] climb?(Flightphase!1) [2] AC_Alt!1 &gt; Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.3. decision_table_TCC2.4 : |------- [1] climb?(Flightphase!1) [2] Alt_Capt_Hold!1 Rule? 3.2. Decision Tables 35 false, and AC Alt is less than Acc Alt. <p> AND/OR Tables and Decision Tables decision_table_TCC2.1 : |------- [2] Alt_Capt_Hold!1 [3] AC_Alt!1 &gt;= Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.1. decision_table_TCC2.2 : |------- <ref> [1] </ref> climb?(Flightphase!1) [2] Alt_Target!1 = prev_Alt_Target!1 Rule? (POSTPONE) Postponing decision_table_TCC2.2. decision_table_TCC2.3 : |------- [1] climb?(Flightphase!1) [2] AC_Alt!1 &gt; Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.3. decision_table_TCC2.4 : |------- [1] climb?(Flightphase!1) [2] Alt_Capt_Hold!1 Rule? 3.2. Decision Tables 35 false, and AC Alt is less than Acc Alt. <p> AND/OR Tables and Decision Tables decision_table_TCC2.1 : |------- [2] Alt_Capt_Hold!1 [3] AC_Alt!1 &gt;= Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.1. decision_table_TCC2.2 : |------- <ref> [1] </ref> climb?(Flightphase!1) [2] Alt_Target!1 = prev_Alt_Target!1 Rule? (POSTPONE) Postponing decision_table_TCC2.2. decision_table_TCC2.3 : |------- [1] climb?(Flightphase!1) [2] AC_Alt!1 &gt; Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.3. decision_table_TCC2.4 : |------- [1] climb?(Flightphase!1) [2] Alt_Capt_Hold!1 Rule? 3.2. Decision Tables 35 false, and AC Alt is less than Acc Alt. As before, the four flaws identified by these false subgoals are identical to those identified by the special-purpose tool Table-Wise [23, Table 4]. <p> Atlee and Gannon [3, 4] were the first to apply this idea to SCR specifications. Their approach used a rather indirect encoding of SCR specifications and the MCB model checker. Later, Atlee <ref> [1] </ref> developed a more direct encoding suitable for the SMV symbolic model checker [30] that has subsequently been applied to large examples [40]. Here, we apply PVS's model checker directly to the PVS specifications already developed. <p> This will cause a transition to inactive mode in a state that violates the invariant of safe3. Contemplation of the intent of the specification suggests that this is acceptable: it is not the transition relation that is wrong, but our formulation of the intended invariant for inactive mode. Atlee <ref> [1, page 9] </ref> suggests that a more appropriate invariant is one that states that if the current mode is inactive and the invariants for cruise mode apply when activate goes true, then the next mode will not be inactive.
Reference: [2] <author> Joanne M. Atlee and Michael A. Buckley. </author> <title> A logic-model semantics for SCR software requirements. </title> <editor> In Steven J. Zeil, editor, </editor> <booktitle> International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 280-292, </pages> <address> San Diego, CA, Jan-uary 1996. </address> <institution> Association for Computing Machinery. </institution>
Reference-contexts: AND/OR Tables and Decision Tables decision_table_TCC2.1 : |------- <ref> [2] </ref> Alt_Capt_Hold!1 [3] AC_Alt!1 &gt;= Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.1. decision_table_TCC2.2 : |------- [1] climb?(Flightphase!1) [2] Alt_Target!1 = prev_Alt_Target!1 Rule? (POSTPONE) Postponing decision_table_TCC2.2. decision_table_TCC2.3 : |------- [1] climb?(Flightphase!1) [2] AC_Alt!1 &gt; Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.3. decision_table_TCC2.4 : |------- [1] climb?(Flightphase!1) [2] Alt_Capt_Hold!1 Rule? 3.2. <p> AND/OR Tables and Decision Tables decision_table_TCC2.1 : |------- <ref> [2] </ref> Alt_Capt_Hold!1 [3] AC_Alt!1 &gt;= Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.1. decision_table_TCC2.2 : |------- [1] climb?(Flightphase!1) [2] Alt_Target!1 = prev_Alt_Target!1 Rule? (POSTPONE) Postponing decision_table_TCC2.2. decision_table_TCC2.3 : |------- [1] climb?(Flightphase!1) [2] AC_Alt!1 &gt; Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.3. decision_table_TCC2.4 : |------- [1] climb?(Flightphase!1) [2] Alt_Capt_Hold!1 Rule? 3.2. Decision Tables 35 false, and AC Alt is less than Acc Alt. <p> AND/OR Tables and Decision Tables decision_table_TCC2.1 : |------- <ref> [2] </ref> Alt_Capt_Hold!1 [3] AC_Alt!1 &gt;= Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.1. decision_table_TCC2.2 : |------- [1] climb?(Flightphase!1) [2] Alt_Target!1 = prev_Alt_Target!1 Rule? (POSTPONE) Postponing decision_table_TCC2.2. decision_table_TCC2.3 : |------- [1] climb?(Flightphase!1) [2] AC_Alt!1 &gt; Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.3. decision_table_TCC2.4 : |------- [1] climb?(Flightphase!1) [2] Alt_Capt_Hold!1 Rule? 3.2. Decision Tables 35 false, and AC Alt is less than Acc Alt. <p> AND/OR Tables and Decision Tables decision_table_TCC2.1 : |------- <ref> [2] </ref> Alt_Capt_Hold!1 [3] AC_Alt!1 &gt;= Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.1. decision_table_TCC2.2 : |------- [1] climb?(Flightphase!1) [2] Alt_Target!1 = prev_Alt_Target!1 Rule? (POSTPONE) Postponing decision_table_TCC2.2. decision_table_TCC2.3 : |------- [1] climb?(Flightphase!1) [2] AC_Alt!1 &gt; Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.3. decision_table_TCC2.4 : |------- [1] climb?(Flightphase!1) [2] Alt_Capt_Hold!1 Rule? 3.2. Decision Tables 35 false, and AC Alt is less than Acc Alt. As before, the four flaws identified by these false subgoals are identical to those identified by the special-purpose tool Table-Wise [23, Table 4]. <p> Running: The engine is running. Toofast: The vehicle speed is above that which the system can control. 4 The same example is used in two papers by Atlee and Gannon [3, Tables 2 and 3], [4, Tables IV and V], and one by Atlee and Buckley <ref> [2, Figure 4] </ref>; however, the SCR tables are slightly different in each paper. 5 This description does not resemble any real cruise control; we use it because it has been studied by others and thereby facilitates comparison between our methods and theirs. 42 Chapter 4.
Reference: [3] <author> Joanne M. Atlee and John Gannon. </author> <title> State-based model checking of event-driven system requirements. </title> <booktitle> In SIGSOFT '91: Software for Critical Systems, </booktitle> <pages> pages 16-28, </pages> <address> New Orleans, LA, </address> <month> December </month> <year> 1991. </year> <booktitle> Published as ACM SIGSOFT Engineering Notes, </booktitle> <volume> Volume 16, Number 5. </volume>
Reference-contexts: AND/OR Tables and Decision Tables decision_table_TCC2.1 : |------- [2] Alt_Capt_Hold!1 <ref> [3] </ref> AC_Alt!1 &gt;= Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.1. decision_table_TCC2.2 : |------- [1] climb?(Flightphase!1) [2] Alt_Target!1 = prev_Alt_Target!1 Rule? (POSTPONE) Postponing decision_table_TCC2.2. decision_table_TCC2.3 : |------- [1] climb?(Flightphase!1) [2] AC_Alt!1 &gt; Acc_Alt!1 Rule? (POSTPONE) Postponing decision_table_TCC2.3. decision_table_TCC2.4 : |------- [1] climb?(Flightphase!1) [2] Alt_Capt_Hold!1 Rule? 3.2. <p> These extensions require elaborations of the treatment given here, and we ignore them for brevity. However, we do consider interacting state machines in Section 4.3. The mode transition table of Figure 4.1, taken from Atlee and Gannon <ref> [3, Table 2] </ref>, 4 describes an automobile cruise control system. 5 This system has four modes: off, inactive, cruise, and override. The system is in exactly one of these four modes at all times. <p> The table of Figure 4.1 uses the following conditions on the system's monitored variables. Ignited: The ignition is on. Running: The engine is running. Toofast: The vehicle speed is above that which the system can control. 4 The same example is used in two papers by Atlee and Gannon <ref> [3, Tables 2 and 3] </ref>, [4, Tables IV and V], and one by Atlee and Buckley [2, Figure 4]; however, the SCR tables are slightly different in each paper. 5 This description does not resemble any real cruise control; we use it because it has been studied by others and thereby <p> Notice that unlike Atlee and Gannon <ref> [3, 4] </ref>, we do not need to add axioms to ensure dis-jointness of the conditions activate, deactivate, and resume, since these follow automatically by their derivation from an enumerated type. <p> A useful class of properties can be expressed in the branching time temporal logic called CTL, and their satisfaction by the behavior induced by a given transition relation can be determined very efficiently by model checking. Atlee and Gannon <ref> [3, 4] </ref> were the first to apply this idea to SCR specifications. Their approach used a rather indirect encoding of SCR specifications and the MCB model checker.
Reference: [4] <author> Joanne M. Atlee and John Gannon. </author> <title> State-based model checking of event-driven system requirements. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 19(1) </volume> <pages> 24-40, </pages> <month> January </month> <year> 1993. </year>
Reference-contexts: Ignited: The ignition is on. Running: The engine is running. Toofast: The vehicle speed is above that which the system can control. 4 The same example is used in two papers by Atlee and Gannon [3, Tables 2 and 3], <ref> [4, Tables IV and V] </ref>, and one by Atlee and Buckley [2, Figure 4]; however, the SCR tables are slightly different in each paper. 5 This description does not resemble any real cruise control; we use it because it has been studied by others and thereby facilitates comparison between our methods <p> Notice that unlike Atlee and Gannon <ref> [3, 4] </ref>, we do not need to add axioms to ensure dis-jointness of the conditions activate, deactivate, and resume, since these follow automatically by their derivation from an enumerated type. <p> A useful class of properties can be expressed in the branching time temporal logic called CTL, and their satisfaction by the behavior induced by a given transition relation can be determined very efficiently by model checking. Atlee and Gannon <ref> [3, 4] </ref> were the first to apply this idea to SCR specifications. Their approach used a rather indirect encoding of SCR specifications and the MCB model checker.
Reference: [5] <author> Randal E. Bryant. </author> <title> Symbolic boolean manipulation with ordered binary-decision diagrams. </title> <journal> ACM Computing Surveys, </journal> <volume> 24(3) </volume> <pages> 293-318, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: However, when we try the corresponding challenge for the case where Flightphase is climb, test2: THEOREM AC_Alt = Acc_Alt =&gt; decision_table2 (climb, AC_Alt, Acc_Alt, Alt_Target, prev_Alt_Target, Alt_Capt_Hold) = Climb 5 Ordered Binary Decision Diagrams (BDDs) are a very efficient representation for reasoning about Boolean functions and propositional calculus <ref> [5] </ref>. 36 Chapter 3.
Reference: [6] <author> J. R. Burch, E. M. Clarke, K. L. McMillan, D. L. Dill, and L. J. Hwang. </author> <title> Symbolic model checking: 10 20 states and beyond. </title> <journal> Information and Computation, </journal> <volume> 98(2) </volume> <pages> 142-170, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The invention and popularization of this approach is due to Edmund Clarke and his students <ref> [6, 9, 10] </ref>. For certain classes of systems and properties, model checking is an attractive alternative, or adjunct, to verification by theorem proving, because of its largely automatic character.
Reference: [7] <author> Ricky W. Butler. </author> <title> An introduction to requirements capture using PVS (specification of a simple autopilot). </title> <type> NASA Technical Memorandum 110255, </type> <institution> NASA Langley Research Center, Hampton, VA, </institution> <month> June </month> <year> 1996. </year> <title> Forthcoming. </title> <type> 71 72 Bibliography </type>
Reference-contexts: Strictly, blank entries are unnecessary in one-dimensional tables, since the entire case can always be omitted; they are extremely valuable, however, in two-dimensional tables. For example, Figure 2.2 reproduces the quotient lookup table 18 Chapter 2. Basic Tables q (D, (P: bvec <ref> [7] </ref> | estimation_bound?(valD (D),valP (P)))): subrange (-2, 2) = LET b = -(2 - P (1)), d = -(1 - P (1)), Dp = bv2pattern (D), Ptruncp = bv2pattern (P^(6,2)) IN TABLE Ptruncp, Dp |[ 000| 001| 010| 011| 100| 101| 110| 111]| |01010| | | | | | | | <p> We argue that rather than build the treatment of interaction into the methodology, it may be best to allow this to be specified directly. 4.3.1 A Requirements Specification Our example derives from an autopilot specification developed by Ricky Butler of NASA Langley Research Center <ref> [7] </ref>. Whereas an automobile's cruise control is concerned with only a single attribute|speed|an autopilot is responsible for many attributes and the functions controlling the different attributes interact with one another.
Reference: [8] <author> J. H. Cheng and C. B. Jones. </author> <title> On the usability of logics which handle partial functions. </title> <editor> In Carroll Morgan and J. C. P. Woodcock, editors, </editor> <booktitle> Proceedings of the Third Refinement Workshop, </booktitle> <pages> pages 51-69. </pages> <publisher> Springer-Verlag Workshops in Computing, </publisher> <year> 1990. </year>
Reference-contexts: subp (i; j + 1) + 1 endif: This function is undefined if i &lt; j (when i j; subp (i; j) = i j) and it is argued that if a specification language is to admit this type of definition, then it must provide a treatment for partial functions <ref> [8] </ref>.
Reference: [9] <author> E. M. Clarke, E. A. Emerson, and A. P. Sistla. </author> <title> Automatic verification of finite-state concurrent systems using temporal logic specifications. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(2) </volume> <pages> 244-263, </pages> <month> April </month> <year> 1986. </year>
Reference-contexts: The invention and popularization of this approach is due to Edmund Clarke and his students <ref> [6, 9, 10] </ref>. For certain classes of systems and properties, model checking is an attractive alternative, or adjunct, to verification by theorem proving, because of its largely automatic character.
Reference: [10] <author> Edmund M. Clarke, Orna Grumberg, and David E. </author> <title> Long. Model checking and abstraction. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(5) </volume> <pages> 1512-1542, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: The invention and popularization of this approach is due to Edmund Clarke and his students <ref> [6, 9, 10] </ref>. For certain classes of systems and properties, model checking is an attractive alternative, or adjunct, to verification by theorem proving, because of its largely automatic character.
Reference: [11] <author> S. Faulk and P. Clements. </author> <title> The NRL Software Cost Reduction (SCR) requirements specification methodology. </title> <booktitle> In Fourth International Workshop on Software Specification and Design, </booktitle> <address> Monterey, CA, April 1987. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: Several of these methodologies derived from work at the U.S. Naval Research Laboratory (NRL) in the 1970s on software requirements for the A-7E aircraft [21,22]. Such methods include Parnas's "four variable method" [42,43], the Software Cost Reduction (SCR) method of NRL <ref> [11] </ref>, the Consortium Requirements Engineering (CoRE) method of the Software Productivity Consortium [12] and, more distantly, Harel's Statecharts [14] and its derivatives such as Leveson's Requirements State Machine Language (RSML) [29]. <p> greatest fixpoint operators [31]), PVS provides model checking for a temporal logic known as Computation Tree Logic (CTL) and transition relations defined on heriditarily finite types [35]. 3 Here, we consider the use of PVS to examine transition relations derived from the Naval Research Laboratory's SCR method for requirements specification <ref> [11] </ref>. We begin by considering how PVS can represent certain aspects of SCR specifications in a natural manner, and how it can check those specifications for well-formedness. This treatment builds directly on that developed in the previous chapter. <p> These two developments|tables and model checking|come together to provide support for the Naval Research Laboratory's SCR method for requirements specification <ref> [11] </ref>. The generic support provided for tables and for model checking in PVS may be compared with the more specialized support provided in tools such as ORA's Table-Wise [23], NRL's SCR* [18,20], and Leveson and Heimdahl's consistency checker for RSML [17].
Reference: [12] <author> Stuart Faulk, John Brackett, Paul Ward, and James Kirby, Jr. </author> <title> The CoRE method for real-time requirements. </title> <journal> IEEE Software, </journal> <volume> 9(5) </volume> <pages> 22-33, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Naval Research Laboratory (NRL) in the 1970s on software requirements for the A-7E aircraft [21,22]. Such methods include Parnas's "four variable method" [42,43], the Software Cost Reduction (SCR) method of NRL [11], the Consortium Requirements Engineering (CoRE) method of the Software Productivity Consortium <ref> [12] </ref> and, more distantly, Harel's Statecharts [14] and its derivatives such as Leveson's Requirements State Machine Language (RSML) [29].
Reference: [13] <author> N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud. </author> <title> The synchronous dataflow programming language Lustre. </title> <booktitle> Proceedings of the IEEE, </booktitle> <volume> 79(9) </volume> <pages> 1305-1320, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: We also plan to explore the rather different approach to requirements specifications used in synchronous dataflow languages, exemplified by Lustre <ref> [13] </ref>. 70
Reference: [14] <author> D. Harel et al. STATEMATE: </author> <title> A working environment for the development of complex reactive systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(4) </volume> <pages> 403-414, </pages> <month> April </month> <year> 1990. </year>
Reference-contexts: Naval Research Laboratory (NRL) in the 1970s on software requirements for the A-7E aircraft [21,22]. Such methods include Parnas's "four variable method" [42,43], the Software Cost Reduction (SCR) method of NRL [11], the Consortium Requirements Engineering (CoRE) method of the Software Productivity Consortium [12] and, more distantly, Harel's Statecharts <ref> [14] </ref> and its derivatives such as Leveson's Requirements State Machine Language (RSML) [29]. These methods are intended for reactive systems|that is, systems that operate continuously and interact with their environment|and model system requirements and behaviors as the traces (i.e., sequences of system states, inputs, and outputs) of interacting state machines.
Reference: [15] <author> Zvi Har'El and Robert P. Kurshan. </author> <title> Software for analytical development of communications protocols. </title> <journal> AT&T Technical Journal, </journal> <volume> 69(1) </volume> <pages> 45-59, </pages> <month> Jan-uary/February </month> <year> 1990. </year>
Reference-contexts: Note that the -calculus is strictly more expressive than CTL, and is also used to define "fair" versions of the CTL operators within PVS. We are currently investigating the extension of PVS's -calulus-based model checking to linear-time temporal logic (CTL is a "branching-time" logic [28]), and to language containment <ref> [15] </ref>. 4.1.
Reference: [16] <author> Mats P. E. Heimdahl. </author> <title> Experiences and lessons from the analysis of TCAS II. </title> <editor> In Steven J. Zeil, editor, </editor> <booktitle> International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 79-83, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1996. </year> <institution> Association for Computing Machinery. </institution>
Reference-contexts: For example, Heitmeyer and others at NRL have developed a mechanized toolset that performs systematic checks for well-formedness of SCR specifications and also provides a simulator for these specifications [18, 20], while Heimdahl and Leveson have developed a checker for RSML <ref> [16, 17] </ref> and Hoover and others at ORA have mechanized the decision tables used by Sherry [23]. As yet, however, these and other tools for reactive systems 1 2 Chapter 1. <p> The states and the transitions are specified separately, using Statechart-like diagrams for the latter. For that context, Heimdahl has developed tools for checking completeness and consistency of transition conditions described in AND/OR tables <ref> [16, 17] </ref>. We can reproduce these checks in PVS if the specification method is reformulated so that the transitions are specified by means of tables, rather than graphically. An existing method that has this character is due to Lance Sherry [39]. <p> Heimdahl, who with Leveson developed a completeness and consistency checking tool for the AND/OR tables of RSML [17], describes spurious error reports when that tool was applied to TCAS II <ref> [16] </ref>. These were due to the presence of arithmetic and defined functions whose properties are beyond the reach of the BDD-based 5 tautology checker incorporated in the tool. As Heimdahl notes [16, page 81], a theorem prover is needed to settle such properties. <p> These were due to the presence of arithmetic and defined functions whose properties are beyond the reach of the BDD-based 5 tautology checker incorporated in the tool. As Heimdahl notes <ref> [16, page 81] </ref>, a theorem prover is needed to settle such properties. A theorem prover such as PVS can also examine questions beyond simple completeness and consistency. <p> Heimdahl, for example, has noted that consistency analysis of the TCAS II requirements specification in RSML produced many spurious error reports because only simple propositional reasoning was available <ref> [16] </ref>. As well as being able to settle more demanding consistency and completeness checks, we have illustrated how the general theorem proving power of PVS can be used to probe tabular specifications by attempting to prove "challenge" theorems.
Reference: [17] <author> Mats P. E. Heimdahl and Nancy G. Leveson. </author> <title> Completeness and consistency analysis of state-based requirements. </title> <booktitle> In 17th International Conference on Software Engineering, </booktitle> <pages> pages 3-14, </pages> <address> Seattle, WA, </address> <month> April </month> <year> 1995. </year> <journal> IEEE Computer Society. </journal> <volume> Bibliography 73 </volume>
Reference-contexts: For example, Heitmeyer and others at NRL have developed a mechanized toolset that performs systematic checks for well-formedness of SCR specifications and also provides a simulator for these specifications [18, 20], while Heimdahl and Leveson have developed a checker for RSML <ref> [16, 17] </ref> and Hoover and others at ORA have mechanized the decision tables used by Sherry [23]. As yet, however, these and other tools for reactive systems 1 2 Chapter 1. <p> will be able to modify and adapt it to suit their own purposes, or to use it to suggest ways of using PVS to automate other methodologies. * To provide rapid prototyping and back-end support for those developing specialized tools such as NRL's SCR* toolset [18] and those for RSML <ref> [17] </ref>. <p> The states and the transitions are specified separately, using Statechart-like diagrams for the latter. For that context, Heimdahl has developed tools for checking completeness and consistency of transition conditions described in AND/OR tables <ref> [16, 17] </ref>. We can reproduce these checks in PVS if the specification method is reformulated so that the transitions are specified by means of tables, rather than graphically. An existing method that has this character is due to Lance Sherry [39]. <p> For example, PVS can settle disjointness and coverage TCCs that depend on properties more general than the simple Boolean and arithmetic relations built in to Table-Wise and similar tools. Heimdahl, who with Leveson developed a completeness and consistency checking tool for the AND/OR tables of RSML <ref> [17] </ref>, describes spurious error reports when that tool was applied to TCAS II [16]. These were due to the presence of arithmetic and defined functions whose properties are beyond the reach of the BDD-based 5 tautology checker incorporated in the tool. <p> The generic support provided for tables and for model checking in PVS may be compared with the more specialized support provided in tools such as ORA's Table-Wise [23], NRL's SCR* [18,20], and Leveson and Heimdahl's consistency checker for RSML <ref> [17] </ref>. Dedicated, lightweight tools such as these are likely to be superior to 67 68 Chapter 5. Conclusion a heavyweight, generic system such as PVS for their chosen purposes. Our goal in providing these capabilities in PVS is not to compete with specialized tools but to complement them.
Reference: [18] <author> Constance Heitmeyer, Alan Bull, Carolyn Gasarch, and Bruce Labaw. SCR*: </author> <title> A toolset for specifying and analyzing requirements. </title> <booktitle> In COMP [25], </booktitle> <pages> pages 109-122. </pages>
Reference-contexts: These methods provide organizing principles, systematic checks for well-formedness of specifications and, in some cases, simulators. For example, Heitmeyer and others at NRL have developed a mechanized toolset that performs systematic checks for well-formedness of SCR specifications and also provides a simulator for these specifications <ref> [18, 20] </ref>, while Heimdahl and Leveson have developed a checker for RSML [16, 17] and Hoover and others at ORA have mechanized the decision tables used by Sherry [23]. As yet, however, these and other tools for reactive systems 1 2 Chapter 1. <p> PVS, we hope that others will be able to modify and adapt it to suit their own purposes, or to use it to suggest ways of using PVS to automate other methodologies. * To provide rapid prototyping and back-end support for those developing specialized tools such as NRL's SCR* toolset <ref> [18] </ref> and those for RSML [17].
Reference: [19] <author> Constance Heitmeyer, Ralph Jeffords, and Bruce Labaw. </author> <title> Tools for analyzing SCR-style requirements specifications: A formal foundation. </title> <type> Technical Report 7499, </type> <institution> Naval Research Laboratory, </institution> <address> Washington DC, </address> <year> 1995. </year> <note> In press. </note>
Reference-contexts: Finally, we consider specifications composed of more than one transition relation and use PVS's model checker to decide equivalence of the behaviors induced by different transition relations. 4.1 Representing SCR Specifications in PVS In the SCR method <ref> [19] </ref>, a system is described in terms of state machines that interact with their environment by periodically sampling the values of monitored (i.e., input) variables and calculating values to be assigned to controlled (i.e., output) variables. The states of an individual state machine are called modes. <p> Current Mode Conditioned Event New Mode m 1 e 1;1 m 1;1 m 2 e 2;1 m 2;1 e p;2 m p;2 e p;k p m p;k p This is actually the way mode transition tables are presented in formal treatments of the SCR method <ref> [19] </ref> and is similar to that used in the SCR* toolset [20].
Reference: [20] <author> Constance Heitmeyer, Bruce Labaw, and Daniel Kiskis. </author> <title> Consistency checking of SCR-style requirements specifications. </title> <booktitle> In International Symposium on Requirements Engineering, </booktitle> <address> York, England, March 1995. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: These methods provide organizing principles, systematic checks for well-formedness of specifications and, in some cases, simulators. For example, Heitmeyer and others at NRL have developed a mechanized toolset that performs systematic checks for well-formedness of SCR specifications and also provides a simulator for these specifications <ref> [18, 20] </ref>, while Heimdahl and Leveson have developed a checker for RSML [16, 17] and Hoover and others at ORA have mechanized the decision tables used by Sherry [23]. As yet, however, these and other tools for reactive systems 1 2 Chapter 1. <p> m 1 e 1;1 m 1;1 m 2 e 2;1 m 2;1 e p;2 m p;2 e p;k p m p;k p This is actually the way mode transition tables are presented in formal treatments of the SCR method [19] and is similar to that used in the SCR* toolset <ref> [20] </ref>. Tables of this form can be specified in PVS using a one-dimensional vertical table to enumerate the Current Mode, with the Conditioned Event/New Mode subtables (inside the doubled lines) specified in the manner used for decision tables in the previous chapter.
Reference: [21] <author> K. L. Heninger. </author> <title> Specifying software requirements for complex systems: New techniques and their application. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-6(1):2-13, </volume> <month> January </month> <year> 1980. </year>
Reference: [22] <author> K. L. Heninger et al. </author> <title> Software requirements for the A-7E aircraft. </title> <type> NRL Report 3876, </type> <institution> Naval Research Laboratory, </institution> <month> November </month> <year> 1978. </year>
Reference: [23] <author> D. N. Hoover and Zewei Chen. Tablewise, </author> <title> a decision table tool. </title> <booktitle> In COMP [25], </booktitle> <pages> pages 97-108. </pages>
Reference-contexts: have developed a mechanized toolset that performs systematic checks for well-formedness of SCR specifications and also provides a simulator for these specifications [18, 20], while Heimdahl and Leveson have developed a checker for RSML [16, 17] and Hoover and others at ORA have mechanized the decision tables used by Sherry <ref> [23] </ref>. As yet, however, these and other tools for reactive systems 1 2 Chapter 1. <p> Some aspects of the TableWise tool <ref> [23] </ref> were prototyped in PVS in just this way. The body of this report is contained in three chapters. Chapter 2 describes PVS's representation of Parnas-style tables, and its method for generating and discharging the proof obligations that ensure completeness and consistency of tabular specifications. <p> There are many kinds of decision tables; the ones considered here are from a requirements engineering methodology developed for avionics systems by Lance Sherry of Honeywell [39], and given mechanized support in TableWise developed by Doug Hoover and others at ORA <ref> [23] </ref>. Takeoff, Climb, Climb Int Level, and Cruise should be selected. The subtable beneath the name of each operational procedure can be interpreted rather like an AND/OR table, except that the input variables can have types other than Boolean (and * instead of is used for "don't care"). <p> The second sequent identifies a similar conflict between columns 4 and 5. These flaws are identical to those identified by the special-purpose tool TableWise <ref> [23, Table 3] </ref>. The coverage TCC generated from the specification of Figure 3.4 is shown in discharge these proof obligations identifies flaws in the specification. <p> Decision Tables 35 false, and AC Alt is less than Acc Alt. As before, the four flaws identified by these false subgoals are identical to those identified by the special-purpose tool Table-Wise <ref> [23, Table 4] </ref>. Unlike PVS, TableWise presents the anomalies that it discovers in a tabular form similar to that of the original decision table; TableWise can also generate executable Ada code and English language documentation from decision tables. <p> These two developments|tables and model checking|come together to provide support for the Naval Research Laboratory's SCR method for requirements specification [11]. The generic support provided for tables and for model checking in PVS may be compared with the more specialized support provided in tools such as ORA's Table-Wise <ref> [23] </ref>, NRL's SCR* [18,20], and Leveson and Heimdahl's consistency checker for RSML [17]. Dedicated, lightweight tools such as these are likely to be superior to 67 68 Chapter 5. Conclusion a heavyweight, generic system such as PVS for their chosen purposes.
Reference: [24] <author> D. N. Hoover, David Guaspari, </author> <title> and Polar Humenn. Applications of formal methods to specification and safety of avionics software. </title> <type> NASA Contractor Report 4723, </type> <institution> NASA Langley Research Center, Hampton, VA, </institution> <month> April </month> <year> 1996. </year> <note> (Work performed by Odyssey Research Associates). </note>
Reference-contexts: The methodologies we have examined here are primarily concerned with requirements specifications for avionics applications. Hoover, Guaspari, and Humenn provide a general examination of the use of formal methods in these applications <ref> [24] </ref>. Requirements specifications are particularly challenging to formalize: because there is no "higher" specification against which to verify them, it is particularly important that they should be perspicuous and well suited to human review. Tabular forms of expression seem to serve these needs well.
Reference: [25] <institution> COMPASS '95 (Proceedings of the Ninth Annual Conference on Computer Assurance), Gaithersburg, MD, </institution> <month> June </month> <year> 1995. </year> <institution> IEEE Washington Section. </institution>
Reference: [26] <author> Ryszard Janicki. </author> <title> Towards a formal semantics of Parnas tables. </title> <booktitle> In 17th International Conference on Software Engineering, </booktitle> <pages> pages 231-240, </pages> <address> Seattle, WA, April 1995. </address> <publisher> IEEE Computer Society. </publisher>
Reference-contexts: verification of the algorithm (which can be done largely automatically in PVS) then ensures that all the nonblank table entries are correct [36]. 2.2.5 Variations Parnas [32] advocates tabular specifications and introduces several kinds of tables for defining functions and relations; these have been given a formal definition by Janicki <ref> [26] </ref>. The PVS TABLE construct corresponds only to what Parnas calls a "normal" function table. However, other attributes of the PVS specification language allow specification of certain alternative kinds of tables.
Reference: [27] <author> G. L. J. M. </author> <type> Janssen. </type> <institution> ROBDD Software. Department of Electrical Engineering, Eindhoven University of Technology, </institution> <month> October </month> <year> 1993. </year>
Reference-contexts: Complex systems are defined by several state 2 This procedure, and also the BDD-based propositional simplifier invoked by PVS's (bddsimp) command, were provided by Geert Janssen of the Electrical Engineering Department of Eindhoven University of Technology in the Netherlands <ref> [27] </ref>. 3 This capability is similar to that of the SMV model checker [30]. Note that the -calculus is strictly more expressive than CTL, and is also used to define "fair" versions of the CTL operators within PVS.
Reference: [28] <author> L. Lamport. </author> <title> Sometime is sometimes not never. </title> <booktitle> In 10th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 174-185, </pages> <address> Austin, TX, </address> <month> January </month> <year> 1983. </year>
Reference-contexts: Note that the -calculus is strictly more expressive than CTL, and is also used to define "fair" versions of the CTL operators within PVS. We are currently investigating the extension of PVS's -calulus-based model checking to linear-time temporal logic (CTL is a "branching-time" logic <ref> [28] </ref>), and to language containment [15]. 4.1.
Reference: [29] <author> Nancy G. Leveson, Mats Per Erik Heimdahl, Holly Hildreth, and Jon Damon Reese. </author> <title> Requirements specification for process-control systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 20(9) </volume> <pages> 684-707, </pages> <month> September </month> <year> 1994. </year> <note> 74 Bibliography </note>
Reference-contexts: Such methods include Parnas's "four variable method" [42,43], the Software Cost Reduction (SCR) method of NRL [11], the Consortium Requirements Engineering (CoRE) method of the Software Productivity Consortium [12] and, more distantly, Harel's Statecharts [14] and its derivatives such as Leveson's Requirements State Machine Language (RSML) <ref> [29] </ref>. These methods are intended for reactive systems|that is, systems that operate continuously and interact with their environment|and model system requirements and behaviors as the traces (i.e., sequences of system states, inputs, and outputs) of interacting state machines. <p> Then we combine a generalization of this approach with the TABLE construct to provide a treatment for a type of decision table that has been used for specifying avionics requirements. 3.1 AND/OR Tables Leveson and her colleagues use a tabular representation for Boolean expressions <ref> [29] </ref> that is quite different from any of Parnas's tables. These AND/OR tables are most easily explained by means of an example. The following table describes some conditions under which a TCAS II avionics collision avoidance system should transition from the Threat state to the Other-Traffic state [29, Figure 32]. <p> These AND/OR tables are most easily explained by means of an example. The following table describes some conditions under which a TCAS II avionics collision avoidance system should transition from the Threat state to the Other-Traffic state <ref> [29, Figure 32] </ref>. <p> The example conjecture test (which probes the second row of the table) is easily proved by the single command (grind). In the requirements specification method developed by Leveson and her colleagues <ref> [29] </ref>, AND/OR tables are used to indicate the conditions under which state transitions should occur. The states and the transitions are specified separately, using Statechart-like diagrams for the latter. For that context, Heimdahl has developed tools for checking completeness and consistency of transition conditions described in AND/OR tables [16, 17]. <p> In the future, we hope to make the implementation of PVS more "open," so that similar customizations can be made very easily. We have also shown how standard notation for function application can be adapted to provide a tolerable representation for the AND/OR tables used in RSML <ref> [29] </ref>, and then showed how this technique can be combined with the new TABLE construct to provide a treatment for the Decision Tables advocated by Sherry [39].
Reference: [30] <author> Kenneth L. McMillan. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, MA, </address> <year> 1993. </year>
Reference-contexts: are defined by several state 2 This procedure, and also the BDD-based propositional simplifier invoked by PVS's (bddsimp) command, were provided by Geert Janssen of the Electrical Engineering Department of Eindhoven University of Technology in the Netherlands [27]. 3 This capability is similar to that of the SMV model checker <ref> [30] </ref>. Note that the -calculus is strictly more expressive than CTL, and is also used to define "fair" versions of the CTL operators within PVS. <p> Atlee and Gannon [3, 4] were the first to apply this idea to SCR specifications. Their approach used a rather indirect encoding of SCR specifications and the MCB model checker. Later, Atlee [1] developed a more direct encoding suitable for the SMV symbolic model checker <ref> [30] </ref> that has subsequently been applied to large examples [40]. Here, we apply PVS's model checker directly to the PVS specifications already developed.
Reference: [31] <author> David Park. </author> <title> Finiteness is mu-ineffable. </title> <journal> Theoretical Computer Science, </journal> <volume> 3 </volume> <pages> 173-181, 19. </pages>
Reference-contexts: Using an efficient decision procedure 2 based on BDDs for a logic known as the Park's -calculus (this is basically quantified Boolean logic with least and greatest fixpoint operators <ref> [31] </ref>), PVS provides model checking for a temporal logic known as Computation Tree Logic (CTL) and transition relations defined on heriditarily finite types [35]. 3 Here, we consider the use of PVS to examine transition relations derived from the Naval Research Laboratory's SCR method for requirements specification [11].
Reference: [32] <author> David Lorge Parnas. </author> <title> Tabular representation of relations. </title> <type> Technical Report CRL Report 260, </type> <institution> Telecommunications Research Institute of Ontario (TRIO), Faculty of Engineering, McMaster University, Hamilton, </institution> <address> Ontario, Canada, </address> <month> Oc-tober </month> <year> 1992. </year>
Reference-contexts: Here is an example due to Parnas <ref> [32, Figure 1] </ref> that illustrates this. sqrt: [nonneg_real -&gt; nonneg_real] Parnas_Fig1 (y,x:real):real = TABLE %-------------------------------------% %-----------------------------------------% | x = 3 | 27+sqrt (27) | 54+sqrt (27) | y^2 +3 || %-----------------------------------------% | x &lt; 3 | 27+sqrt (-(x-3)) | y+sqrt (-(x-3)) | y^2 + (x-3)^2 || %-----------------------------------------% | x &gt; 3 <p> The TCCs of the PVS specification ensure that entries (indicated by blanks) that are believed to be inaccessible, truly are so; verification of the algorithm (which can be done largely automatically in PVS) then ensures that all the nonblank table entries are correct [36]. 2.2.5 Variations Parnas <ref> [32] </ref> advocates tabular specifications and introduces several kinds of tables for defining functions and relations; these have been given a formal definition by Janicki [26]. The PVS TABLE construct corresponds only to what Parnas calls a "normal" function table. <p> Because it is a higher-order logic with a rich type system, PVS can also deal uniformly with certain other kinds of tables that Parnas treats specially <ref> [32] </ref>. "Re lation" and "predicate expression" tables, for example, are simply tables with range type bool. <p> Thus, the following PVS specification is an example of what Parnas calls a "relation" table (from <ref> [32, Figure 4] </ref>). rel (x,y,z:real):bool = TABLE %----------------------------------------% |[ y&gt;=0 & sqrt (y)&lt;27 | y&gt;=0 & sqrt (y)&gt;=27 | y &lt; 0 ]| %--------------------------------------------% | x=3 | x^2+y^2 = z^2 | x^2 = y^2 | true || %--------------------------------------------% | x&lt;3 | y^2 = z^2 | x^2 = z^2 | false || <p> Similarly, rel (4, 9, 2.2. The PVS TABLE Construct 21 4) and rel (4,728, 4) can be proved by (grind) plus elementary properties of the sqrt function. Although the PVS TABLE construct can represent directly many of the kinds of tables introduced by Parnas <ref> [32] </ref>, we have not found a convenient way to represent what Parnas calls "inverted" tables|but neither have we found a need for these, In the next chapter, we consider rather different kinds of tables from those used by Parnas. 22 Chapter 3 AND/OR Tables and Decision Tables In this chapter, we
Reference: [33] <author> David Lorge Parnas. </author> <title> Some theorems we should prove. </title> <editor> In Jeffrey J. Joyce and Carl-Johan H. Seger, editors, </editor> <booktitle> Higher Order Logic Theorem Proving and its Applications (6th International Workshop, HUG '93), number 780 in Lecture Notes in Computer Science, </booktitle> <pages> pages 155-162, </pages> <address> Vancouver, Canada, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: For example, Parnas speaks of "vector" tables when defining a function whose value is a tuple, such as the following. x &lt; 0 x = 0 x &gt; 0 p z 5 + x x 4 x In this example from <ref> [33, Figure 1] </ref>, the interpretation is that the value of the function is a pair, whose first and second components are represented by y and z, respectively. Tuple types are directly available in PVS, so this function can be specified by simple tables. <p> system allow us to reproduce methodologies such as SCR when these are appropriate, but also allow us to depart from them when necessary. 66 Chapter 5 Conclusion We have shown previously [37] how PVS can be used to discharge the well-definedness proof obligations that arise in Parnas's tabular specification style <ref> [33] </ref>. Those proof obligations were generated by hand. In this report, we have described the COND construct, recently added to PVS, that generates the proof obligations automatically, and the TABLE construct that provides a visually appealing rendition of tabular specifications.
Reference: [34] <author> Vaughan Pratt. </author> <title> Anatomy of the Pentium bug. </title> <booktitle> In TAPSOFT '95: Theory and Practice of Software Development, number 915 in Lecture Notes in Computer Science, </booktitle> <pages> pages 97-107, </pages> <address> Aarhus, Denmark, May 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: It is worth noting that the notorious Pentium FDIV bug, which is estimated to have cost Intel $500 million, was due to an SRT quotient lookup table, very similar to that of Figure 2.2, that had bad entries in a portion of the table that was incorrectly believed to inaccessible <ref> [34] </ref>.
Reference: [35] <author> S. Rajan, N. Shankar, </author> <title> and M.K. Srivas. An integration of model-checking with automated proof checking. </title> <editor> In Pierre Wolper, editor, </editor> <booktitle> Computer-Aided Verification, CAV '95, volume 939 of Lecture Notes in Computer Science, </booktitle> <pages> pages 84-97, </pages> <address> Liege, Belgium, June 1995. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: efficient decision procedure 2 based on BDDs for a logic known as the Park's -calculus (this is basically quantified Boolean logic with least and greatest fixpoint operators [31]), PVS provides model checking for a temporal logic known as Computation Tree Logic (CTL) and transition relations defined on heriditarily finite types <ref> [35] </ref>. 3 Here, we consider the use of PVS to examine transition relations derived from the Naval Research Laboratory's SCR method for requirements specification [11].
Reference: [36] <author> H. Rue, N. Shankar, </author> <title> and M.K. Srivas. Modular verification of SRT division. </title> <editor> In R. Alur and T.A. Henzinger, editors, </editor> <booktitle> Computer-Aided Verification, CAV '96, Lecture Notes in Computer Science, </booktitle> <address> New Brunswick, NJ, </address> <month> July </month> <year> 1996. </year> <note> Springer-Verlag. To appear. </note>
Reference-contexts: The PVS TABLE Construct 19 from the PVS specification of an SRT division algorithm <ref> [36, 41] </ref>. This specification generates 23 coverage TCCs to ensure that the blank entries can never be encountered. <p> The TCCs of the PVS specification ensure that entries (indicated by blanks) that are believed to be inaccessible, truly are so; verification of the algorithm (which can be done largely automatically in PVS) then ensures that all the nonblank table entries are correct <ref> [36] </ref>. 2.2.5 Variations Parnas [32] advocates tabular specifications and introduces several kinds of tables for defining functions and relations; these have been given a formal definition by Janicki [26]. The PVS TABLE construct corresponds only to what Parnas calls a "normal" function table.
Reference: [37] <author> John Rushby and Mandayam Srivas. </author> <title> Using PVS to prove some theorems of David Parnas. </title> <editor> In Jeffrey J. Joyce and Carl-Johan H. Seger, editors, </editor> <booktitle> Higher Order Logic Theorem Proving and its Applications (6th International Workshop, HUG '93), number 780 in Lecture Notes in Computer Science, </booktitle> <pages> pages 163-173, </pages> <address> Vancouver, Canada, </address> <month> August </month> <year> 1993. </year> <note> Springer-Verlag. </note>
Reference-contexts: Overall, this "autopilot" specification demonstrates the flexibility provided by a general-purpose system such as PVS: the resources of the system allow us to reproduce methodologies such as SCR when these are appropriate, but also allow us to depart from them when necessary. 66 Chapter 5 Conclusion We have shown previously <ref> [37] </ref> how PVS can be used to discharge the well-definedness proof obligations that arise in Parnas's tabular specification style [33]. Those proof obligations were generated by hand.
Reference: [38] <author> Lance Sherry. </author> <title> Apparatus and method for controlling the vertical profile of an aircraft. </title> <institution> United States Patent 5,337,982, </institution> <month> August 16, </month> <year> 1994. </year>
Reference-contexts: That treatment used a function X to give an interpretation to a column (transposed 3 This table is a simplified version of one appearing Sherry's US patent <ref> [38, Appendix B] </ref>. Sherry's original contains several inconsistencies and incompletenesses of the kind also present in this simple example. 3.2.
Reference: [39] <author> Lance Sherry. </author> <title> A structured approach to requirements specification for software-based systems using operational procedures. </title> <booktitle> In 13th AIAA/IEEE Digital Avionics Systems Conference, </booktitle> <pages> pages 64-69, </pages> <address> Phoenix, AZ, </address> <month> October </month> <year> 1994. </year> <note> Bibliography 75 </note>
Reference-contexts: Some of these methods (notably Parnas's and SCR and, in different forms, RSML and the decision tables of Sherry <ref> [39] </ref>) also stress the use of tables to specify functions and state transition relations. These methods provide organizing principles, systematic checks for well-formedness of specifications and, in some cases, simulators. <p> We can reproduce these checks in PVS if the specification method is reformulated so that the transitions are specified by means of tables, rather than graphically. An existing method that has this character is due to Lance Sherry <ref> [39] </ref>. The next section describes a PVS treatment of Sherry's decision tables. 2 It will in a future release. 3.1. <p> There are many kinds of decision tables; the ones considered here are from a requirements engineering methodology developed for avionics systems by Lance Sherry of Honeywell <ref> [39] </ref>, and given mechanized support in TableWise developed by Doug Hoover and others at ORA [23]. Takeoff, Climb, Climb Int Level, and Cruise should be selected. <p> have also shown how standard notation for function application can be adapted to provide a tolerable representation for the AND/OR tables used in RSML [29], and then showed how this technique can be combined with the new TABLE construct to provide a treatment for the Decision Tables advocated by Sherry <ref> [39] </ref>. We then described how an independent enhancement to PVS|the incorporation of a decision procedure for Park's -calculus and its use to provide CTL model checking [35]|enables properties of finite-state transition systems to be examined automatically.
Reference: [40] <author> Tirumale Sreemani and Joanne M. Atlee. </author> <title> Feasibility of model checking software requirements. </title> <booktitle> In COMPASS '96 (Proceedings of the Ninth Annual Conference on Computer Assurance), </booktitle> <address> Gaithersburg, MD, </address> <month> June </month> <year> 1996. </year> <institution> IEEE Washington Section. </institution> <note> To appear. </note>
Reference-contexts: Their approach used a rather indirect encoding of SCR specifications and the MCB model checker. Later, Atlee [1] developed a more direct encoding suitable for the SMV symbolic model checker [30] that has subsequently been applied to large examples <ref> [40] </ref>. Here, we apply PVS's model checker directly to the PVS specifications already developed.
Reference: [41] <author> G. S. Taylor. </author> <title> Compatible hardware for division and square root. </title> <booktitle> In Proceedings of the 5th Symposium on Computer Arithmetic, </booktitle> <pages> pages 127-134. </pages> <publisher> IEEE Computer Society, </publisher> <year> 1981. </year>
Reference-contexts: The PVS TABLE Construct 19 from the PVS specification of an SRT division algorithm <ref> [36, 41] </ref>. This specification generates 23 coverage TCCs to ensure that the blank entries can never be encountered.
Reference: [42] <author> A. John van Schouwen. </author> <title> The A-7 requirements model: Re-examination for real-time systems and an application to monitoring systems. </title> <type> Technical Report 90-276, </type> <institution> Department of Computing and Information Science, Queen's University, Kingston, </institution> <address> Ontario, Canada, </address> <month> May </month> <year> 1990. </year>
Reference: [43] <author> A. John van Schouwen, David Lorge Parnas, and Jan Madey. </author> <title> Documentation of requirements for computer systems. </title> <booktitle> In IEEE International Symposium on Requirements Engineering, </booktitle> <pages> pages 198-207, </pages> <address> San Diego, CA, </address> <month> January </month> <year> 1993. </year>
Reference: [44] <author> Michael von der Beeck. </author> <title> A comparison of statecharts variants. </title> <editor> In H. Langmaack, W.-P. de Roever, and J. Vytopil, editors, </editor> <booktitle> Formal Techniques in Real-Time and Fault-Tolerant Systems, volume 863 of Lecture Notes in Computer Science, </booktitle> <pages> pages 128-148, </pages> <address> Lubeck, Germany, </address> <month> September </month> <year> 1994. </year> <note> Springer-Verlag. </note>
Reference-contexts: Matters can become much more complex when multiple, interacting transition systems are considered. In the case of Statecharts, for example, von der Beeck <ref> [44] </ref> identifies 21 different proposed semantics|most of these differ only in their treatment of interacting systems. One of the central difficulties is that of accounting for transitions due to internal events.
References-found: 45

