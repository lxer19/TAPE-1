URL: http://www.cs.utexas.edu/users/kornerup/euro-par97.ps.Z
Refering-URL: http://www.cs.utexas.edu/users/kornerup/kornerup-papers.html
Root-URL: 
Email: kornerup@cs.utexas.edu  
Title: Parlists a Generalization of Powerlists  
Author: Jacob Kornerup 
Degree: Submitted to Euro-Par 97  
Address: Austin, Austin, TX 78712;  
Affiliation: Department of Computer Sciences, The University of Texas at  
Abstract: The powerlist notation has been very successful in specifying a number of parallel algorithms in a very elegant fashion. The major criticism of the notation was the restriction that input lengths were limited to powers of two. In this paper we present parlists, an extension of the powerlist notation to lists of arbitrary positive lengths.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Will E. Adams. </author> <title> Verifying adder circuits using powerlists. </title> <type> Technical Report CS-TR-94-02, </type> <institution> University of Texas at Austin, Department of Computer Sciences, </institution> <month> March </month> <year> 1994. </year>
Reference-contexts: Lemma 2 8a; p : a 2 X ^ p 2 ParList:X : a .p = a!p / lst:p (54) 3 Adder circuits In <ref> [1] </ref> Will Adams presents powerlist descriptions for two arithmetic circuits that perform addition on natural numbers: the ripple carry adder and the carry lookahead adder. <p> The carry lookahead adder uses a prefix sum calculation to propagate carries, yielding a method that is logarithmic in the number of bits to be added, in a setting where sufficient parallelism available. Adams <ref> [1] </ref> proved that the ripple carry circuit correctly implements addition and that the carry lookahead and the ripple carry circuits are the same function. This result was achieved in the powerlist algebra. In the following we derive the carry lookahead adder and extend the equivalence result to the ParList algebra. <p> Thus, it is only necessary to specify and verify the odd case, assuming that the existing proof of the even case does not rely on properties that are specific to powerlists. The ripple carry adder <ref> [1] </ref> has the type rc : f0,1g fi ParList:f0,1g:n fi ParList:f0,1g:n ! ParList:f0,1g:n fi f0,1g where the first argument is the carry-in bit and the second and third argument are the two lists of bits that are to be added. <p> The first component of the result is the carry-out bit of the computation and the second component is a list containing the result of the addition. The following equations define rc, where (55) and (56) are taken from <ref> [1] </ref>: rc:b:hxi:hy i = (h (x + y + b) mod 2i; (x + y + b) ffi 2) (55) where t = u j v (u; c) = rc:b:p:r rc:c:(p/ a):(q/ b) = (u/ y; x) (57) where x = (a + b + d) ffi 2 y = (a <p> introduces the following associative scalar operators * : f0,1,g fi f0,1,g ! f0,1,g x * y = x if x = y (58) x if y = fi : f0,1,g fi f0,1,g ! f0,1,g x fi y = x if y 6= (60) where :0 = 1 : = In <ref> [1] </ref> the carry lookahead adder is defined by cl:b:p:q = (t; d) (61) where t = s fi r d = lst:s ? lst:r s = ps:(b!r) where ps is computed using the associative operator ?. <p> + d) ffi 2 = d ? (x * y) ^ s = s ^ (a + b + d) mod 2 = d fi (x * y) f (64) and (65) see below g true End of Proof In the last hint we used the following identities established in <ref> [1] </ref>: d ? (x * y) = (a + b + d) ffi 2 (64) 4 Related Work & Conclusion This work is built on top of the work done on powerlists. Misra presented the theory and a number of examples [10]. Adams derived and verified addition circuits [1] (as mentioned <p> established in <ref> [1] </ref>: d ? (x * y) = (a + b + d) ffi 2 (64) 4 Related Work & Conclusion This work is built on top of the work done on powerlists. Misra presented the theory and a number of examples [10]. Adams derived and verified addition circuits [1] (as mentioned in section 3) and multiplication circuits [2]. Kornerup presented a mapping strategy for powerlist onto hypercubic architectures [7] and derived the Odd-even sort in the powerlist notation [8].
Reference: 2. <author> Will E. Adams. </author> <title> Multiplication circuits in powerlists. </title> <type> Unpublished manuscript, </type> <year> 1995. </year>
Reference-contexts: Misra presented the theory and a number of examples [10]. Adams derived and verified addition circuits [1] (as mentioned in section 3) and multiplication circuits <ref> [2] </ref>. Kornerup presented a mapping strategy for powerlist onto hypercubic architectures [7] and derived the Odd-even sort in the powerlist notation [8]. The powerlist theory itself and many of Adam's results have been mechanically verified by Kapur and Subramaniam [6, 5] using the inductive theorem prover Rewrite Rule Laboratory.
Reference: 3. <author> Edsger W. Dijkstra and Carel Sholten. </author> <title> Predicate calculus and program semantics. </title> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: We use the proof format and notation presented by Dijkstra and Scholten <ref> [3] </ref>, this includes writing function application using an infix dot: f:x .
Reference: 4. <author> Ruben A. Gamboa. </author> <title> Defthms about zip and tie: Reasoning about powerlists in ACL2. </title> <type> Technical Report CS-TR-97-02, </type> <institution> The University of Texas at Austin, Department of Computer Sciences, </institution> <month> January 23 </month> <year> 1997. </year>
Reference-contexts: Kornerup presented a mapping strategy for powerlist onto hypercubic architectures [7] and derived the Odd-even sort in the powerlist notation [8]. The powerlist theory itself and many of Adam's results have been mechanically verified by Kapur and Subramaniam [6, 5] using the inductive theorem prover Rewrite Rule Laboratory. Gamboa <ref> [4] </ref> has verified many fundamental results about powerlists using the ACL2 theorem prover. His work focuses on verification of sorting algorithms. Mou and Hudak [13, 12] presented Divacon, a very general notation for describing divide-and-conquer algorithms in a functional manner.
Reference: 5. <author> D. Kapur and M. </author> <title> Mechanically verifying a family of multiplier circuits. </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <address> 1102:135-??, </address> <year> 1996. </year>
Reference-contexts: Kornerup presented a mapping strategy for powerlist onto hypercubic architectures [7] and derived the Odd-even sort in the powerlist notation [8]. The powerlist theory itself and many of Adam's results have been mechanically verified by Kapur and Subramaniam <ref> [6, 5] </ref> using the inductive theorem prover Rewrite Rule Laboratory. Gamboa [4] has verified many fundamental results about powerlists using the ACL2 theorem prover. His work focuses on verification of sorting algorithms.
Reference: 6. <author> D. Kapur and M. Subramaniam. </author> <title> Automated reasoning about parallel algorithms using powerlists. </title> <editor> In Vangalur S. Alagar and M. Nivat, editors, </editor> <booktitle> AMAST '95, volume 936 of LNCS, </booktitle> <publisher> pages 416-?? Springer-Verlag, </publisher> <year> 1995. </year>
Reference-contexts: Kornerup presented a mapping strategy for powerlist onto hypercubic architectures [7] and derived the Odd-even sort in the powerlist notation [8]. The powerlist theory itself and many of Adam's results have been mechanically verified by Kapur and Subramaniam <ref> [6, 5] </ref> using the inductive theorem prover Rewrite Rule Laboratory. Gamboa [4] has verified many fundamental results about powerlists using the ACL2 theorem prover. His work focuses on verification of sorting algorithms.
Reference: 7. <author> Jacob Kornerup. </author> <title> Mapping a functional notation for parallel programs onto hyper-cubes. </title> <journal> Information Processing Letters, </journal> <volume> 53 </volume> <pages> 153-158, </pages> <year> 1995. </year>
Reference-contexts: 1 Introduction The powerlist notation [10] has proven to be a major step forward in describing parallel algorithms succinctly. It allows the programmer to work at a high level of abstraction, by avoiding indexing notations, leading towards efficient implementations on parallel architectures <ref> [7] </ref>. The powerlist data structure is a list whose length is a power of two. In the powerlist notation it is possible to elegantly specify algorithms such as the Discrete Fast Fourier Transform without resorting to "index gymnastics" [10]. <p> Misra presented the theory and a number of examples [10]. Adams derived and verified addition circuits [1] (as mentioned in section 3) and multiplication circuits [2]. Kornerup presented a mapping strategy for powerlist onto hypercubic architectures <ref> [7] </ref> and derived the Odd-even sort in the powerlist notation [8]. The powerlist theory itself and many of Adam's results have been mechanically verified by Kapur and Subramaniam [6, 5] using the inductive theorem prover Rewrite Rule Laboratory.
Reference: 8. <author> Jacob Kornerup. </author> <note> Odd-even sort in powerlists. To appear in Information Processing Letters, </note> <year> 1997. </year>
Reference-contexts: Misra presented the theory and a number of examples [10]. Adams derived and verified addition circuits [1] (as mentioned in section 3) and multiplication circuits [2]. Kornerup presented a mapping strategy for powerlist onto hypercubic architectures [7] and derived the Odd-even sort in the powerlist notation <ref> [8] </ref>. The powerlist theory itself and many of Adam's results have been mechanically verified by Kapur and Subramaniam [6, 5] using the inductive theorem prover Rewrite Rule Laboratory. Gamboa [4] has verified many fundamental results about powerlists using the ACL2 theorem prover. His work focuses on verification of sorting algorithms.
Reference: 9. <author> Richard E. Ladner and Michael J. Fischer. </author> <title> Parallel prefix computation. </title> <journal> Journal of the ACM, </journal> <volume> 27(4) </volume> <pages> 831-838, </pages> <month> October </month> <year> 1980. </year>
Reference-contexts: higher binding power than that of . and / ; it is defined as follows: a!hbi = hbi (48) a!(p ./ q) = a!q ./ p (50) Exploring the defining equation for prefix sum (47), we can derive a scheme for computing the prefix sum, due to Ladner & Fischer <ref> [9] </ref>. This was done for powerlists by Misra [10] presenting the base and even cases. We explore the odd case.
Reference: 10. <author> Jayadev Misra. Powerlist: </author> <title> A structure for parallel recursion. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(6) </volume> <pages> 1737-1767, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: 1 Introduction The powerlist notation <ref> [10] </ref> has proven to be a major step forward in describing parallel algorithms succinctly. It allows the programmer to work at a high level of abstraction, by avoiding indexing notations, leading towards efficient implementations on parallel architectures [7]. <p> The powerlist data structure is a list whose length is a power of two. In the powerlist notation it is possible to elegantly specify algorithms such as the Discrete Fast Fourier Transform without resorting to "index gymnastics" <ref> [10] </ref>. For such algorithms the restriction to lists of lengths a power of two is not serious; they are often presented this way in the literature. However, for most algorithms the restriction is unnatural. <p> the operators are grouped in decreasing order from left to right, and operators in the same group have equal binding power: : ! . / ./ j + fi ? * ffi mod = ) ^ _ 2.1 Axioms In the following we extend the axioms of the powerlist theory <ref> [10] </ref> to an axiomatization of the ParList algebra. The ParList algebra has five constructors: h i; j; ./; . and /. <p> Let Y be a data type with the property that (Y; +; 0) is a monoid. The prefix sum ps : ParList:Y:n ! ParList:Y:n of a list p can be defined <ref> [10] </ref> as the (unique) solution to the equation (in u): u = (0!u) + p (47) where the operator ! : X fi ParList:X:n ! ParList:X:n "pushes" a scalar into the list from the left and the rightmost element of the list is lost. ! has a higher binding power than <p> This was done for powerlists by Misra <ref> [10] </ref> presenting the base and even cases. We explore the odd case. <p> Misra presented the theory and a number of examples <ref> [10] </ref>. Adams derived and verified addition circuits [1] (as mentioned in section 3) and multiplication circuits [2]. Kornerup presented a mapping strategy for powerlist onto hypercubic architectures [7] and derived the Odd-even sort in the powerlist notation [8].
Reference: 11. <author> Jayadev Misra. </author> <title> Generalized powerlists. </title> <type> Unpublished manuscript, </type> <month> May </month> <year> 1996. </year>
Reference-contexts: For such algorithms the restriction to lists of lengths a power of two is not serious; they are often presented this way in the literature. However, for most algorithms the restriction is unnatural. To remedy this, Jayadev Misra <ref> [11] </ref> generalized the powerlist notation to lists of arbitrary length by adding constructs from linear list theory. <p> We categorize parlists according to their length. The shortest parlist has length 1, it is called a singleton; hx i denotes the singleton containing the scalar x. 1 The theory presented in <ref> [11] </ref> was incomplete. The author of this paper has completed the theory and worked out the examples presented in this paper. This paper is submitted with permission from Jayadev Misra.
Reference: 12. <author> Zhijing G. Mou. </author> <title> A Formal Model for Divide-and-Conque and Its Parallel Realization. </title> <type> PhD thesis, </type> <institution> Department of Computer Science, Yale University, </institution> <month> May </month> <year> 1990. </year>
Reference-contexts: Gamboa [4] has verified many fundamental results about powerlists using the ACL2 theorem prover. His work focuses on verification of sorting algorithms. Mou and Hudak <ref> [13, 12] </ref> presented Divacon, a very general notation for describing divide-and-conquer algorithms in a functional manner. The Divacon notation is meant to capture the entire class of divide-and-conquer algorithms.
Reference: 13. <author> Zhijing G. Mou and Paul Hudak. </author> <title> An algebraic model for divide-and-conquer and its parallelism. </title> <journal> The Journal of Supercomputing, </journal> <volume> 2(3) </volume> <pages> 257-278, </pages> <month> November </month> <year> 1988. </year> <title> This article was processed using the L A T E X macro package with LLNCS style </title>
Reference-contexts: Gamboa [4] has verified many fundamental results about powerlists using the ACL2 theorem prover. His work focuses on verification of sorting algorithms. Mou and Hudak <ref> [13, 12] </ref> presented Divacon, a very general notation for describing divide-and-conquer algorithms in a functional manner. The Divacon notation is meant to capture the entire class of divide-and-conquer algorithms.
References-found: 13

