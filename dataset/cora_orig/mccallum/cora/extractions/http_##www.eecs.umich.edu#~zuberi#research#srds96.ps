URL: http://www.eecs.umich.edu/~zuberi/research/srds96.ps
Refering-URL: http://www.eecs.umich.edu/~zuberi/research/
Root-URL: http://www.cs.umich.edu
Email: fzuberi,kgshing@eecs.umich.edu  
Title: A Causal Message Ordering Scheme for Distributed Embedded Real-Time Systems  
Author: Khawar M. Zuberi and Kang G. Shin 
Address: Ann Arbor, MI 48109-2122  
Affiliation: Real-Time Computing Laboratory Department of Electrical Engineering and Computer Science The University of Michigan  
Abstract: In any distributed system, messages must be ordered according to their cause-and-effect relation to ensure correct behavior of the system. Causal ordering is also essential for services like atomic multicast and replication. In distributed real-time systems, not only must proper causal ordering be ensured, but message deadlines must be met as well. Previous algorithms which ensure such behavior include the - protocol family [1] and the MARS approach [2]. However, both these algorithms give large response times by delaying all messages for a fixed period of time. In this paper we show that for small- to medium-sized real-time systems (consisting of a few tens of nodes) as are commonly used for embedded applications, it becomes feasible to extend the -protocol so that instead of delaying all messages for a fixed period, each message is delayed according to its deadline. Our algorithm requires certain message deadlines to be adjusted by the application designer, and we show that for small-scale applications such as those used in embedded systems, this adjustment is feasible and can be automated by the use of proper CAD tools. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Cristian, H. Aghili, R. Strong, and D. Dolev, </author> <title> Atomic broadcast: From simple message diffusion to byzantine agreement, </title> <booktitle> in Proc. Int'l Symposium on Fault-Tolerant Computing, </booktitle> <pages> pp. 200-206, </pages> <month> June </month> <year> 1985. </year>
Reference-contexts: They make use of synchronized clocks to delay messages in one way or the other to ensure that the order of events seen by the application is indeed the correct order. Such schemes include the -protocol family <ref> [1] </ref> and the MARS approach [2]. Each has a simple criterion for delaying messages but the price of this simplicity is slower speed. Faster response can be obtained only by increasing network bandwidth and processor speed. <p> They both depend on the observation that temporal order is a prerequisite for causal order [2]. In other words, if event E 1 was the cause of event E 2 , then E 1 must temporally precede E 2 . 2.1. The -Protocols Under the -protocols <ref> [1] </ref>, each message m is times-tamped at the source with the time t of the send (m) event.
Reference: [2] <author> H. Kopetz, </author> <title> Sparse time versus dense time in distributed real--time systems, </title> <booktitle> in Proc. Int'l Conf. on Distributed Computing Systems, </booktitle> <pages> pp. 460-467, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The problem of ordering events in non-real-time systems has been the focus of research for more than a decade [4, 5], but has only recently been investigated for real-time systems <ref> [2, 6-9] </ref>. Real-time systems differ from non-real-time systems in that one node may affect other nodes through the external environment, which is why causal ordering schemes for non-real-time systems do not work for real-time sys tems [10, 15]. <p> They make use of synchronized clocks to delay messages in one way or the other to ensure that the order of events seen by the application is indeed the correct order. Such schemes include the -protocol family [1] and the MARS approach <ref> [2] </ref>. Each has a simple criterion for delaying messages but the price of this simplicity is slower speed. Faster response can be obtained only by increasing network bandwidth and processor speed. <p> Preserving logical order of events is enough to ensure correctness in non-real-time systems [4, 5], but not in real-time systems because of clandestine communication which can occur through what are known as hidden channels <ref> [2, 6, 10, 15] </ref>. A simple example of such communication is a process P on one node taking an action (through an actuator) and notifying other processes of it through messages. <p> Two well-known clock-based schemes which use temporal order to correctly order events in real-time systems are separated by at least 2g, otherwise they may get the same timestamp. described next. They both depend on the observation that temporal order is a prerequisite for causal order <ref> [2] </ref>. In other words, if event E 1 was the cause of event E 2 , then E 1 must temporally precede E 2 . 2.1. The -Protocols Under the -protocols [1], each message m is times-tamped at the source with the time t of the send (m) event. <p> The MARS approach delays messages at both the source as well as the destination. It is based on the sparse timebase concept <ref> [2] </ref>. The system proceeds in lock-step and each step 2 For granularity g to be meaningful, it must be larger than the precision of the clock [9]. is one clock tick of usually large granularity (in the order of a millisecond [2]). <p> It is based on the sparse timebase concept <ref> [2] </ref>. The system proceeds in lock-step and each step 2 For granularity g to be meaningful, it must be larger than the precision of the clock [9]. is one clock tick of usually large granularity (in the order of a millisecond [2]). All message send and deliver events are constrained to occur at the clock ticks and the clock granularity is larger than maximum message transmission time. So all messages sent at clock tick k will be delivered at clock tick k + 1. <p> Then, any message m j such that m j ! m i Broken line indicates a virtual message. will have D j D i as well as t j &lt; t i (event j must occur before event i if j is to causally precede i <ref> [2] </ref>). Network scheduling [16-18] will ensure that both m j and m i meet their deadlines so that m j will be sure to be received at the destination node before time D i .
Reference: [3] <author> V. Hadzilacos and S. Toueg, </author> <title> Fault-tolerant broadcasts and related problems, in Distributed Systems, </title> <editor> S. Mullender, </editor> <booktitle> editor, </booktitle> <pages> pp. 97-145, </pages> <publisher> Addison Wesley, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1993. </year>
Reference-contexts: That way, the applications can correctly assume that events occur in the order they observe, allowing application designers to write software the way they are used to in centralized systems. This ordering primitive can then be used as a basis for higher-level fault-tolerance mechanisms such as atomic multicast <ref> [3] </ref> and replication for real-time systems. The problem of ordering events in non-real-time systems has been the focus of research for more than a decade [4, 5], but has only recently been investigated for real-time systems [2, 6-9].
Reference: [4] <author> L. Lamport, </author> <title> Time, clocks, and the ordering of events in a distributed system, </title> <journal> Communications of the ACM, </journal> <volume> vol. 21, no. 7, </volume> <pages> pp. 558-565, </pages> <month> July </month> <year> 1978. </year>
Reference-contexts: This ordering primitive can then be used as a basis for higher-level fault-tolerance mechanisms such as atomic multicast [3] and replication for real-time systems. The problem of ordering events in non-real-time systems has been the focus of research for more than a decade <ref> [4, 5] </ref>, but has only recently been investigated for real-time systems [2, 6-9]. Real-time systems differ from non-real-time systems in that one node may affect other nodes through the external environment, which is why causal ordering schemes for non-real-time systems do not work for real-time sys tems [10, 15]. <p> To tackle the problem of consistent and correct ordering of events, a set of possible relationships between messages in a distributed system have been identified. The most commonly-known relationship is logical order [10, 14]: Logical Order: Logical order is usually defined based on Lamport's happens-before relationship <ref> [4] </ref>. <p> Preserving logical order of events is enough to ensure correctness in non-real-time systems <ref> [4, 5] </ref>, but not in real-time systems because of clandestine communication which can occur through what are known as hidden channels [2, 6, 10, 15].
Reference: [5] <author> K. P. Birman, </author> <title> The process group approach to reliable distributed computing, </title> <journal> Communications of the ACM, </journal> <volume> vol. 36, no. 12, </volume> <pages> pp. 37-53, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: This ordering primitive can then be used as a basis for higher-level fault-tolerance mechanisms such as atomic multicast [3] and replication for real-time systems. The problem of ordering events in non-real-time systems has been the focus of research for more than a decade <ref> [4, 5] </ref>, but has only recently been investigated for real-time systems [2, 6-9]. Real-time systems differ from non-real-time systems in that one node may affect other nodes through the external environment, which is why causal ordering schemes for non-real-time systems do not work for real-time sys tems [10, 15]. <p> Preserving logical order of events is enough to ensure correctness in non-real-time systems <ref> [4, 5] </ref>, but not in real-time systems because of clandestine communication which can occur through what are known as hidden channels [2, 6, 10, 15].
Reference: [6] <author> P. Verissimo, </author> <title> Ordering and timeliness requirements of dependable real-time programs, </title> <journal> Journal of Real-Time Systems, </journal> <volume> vol. 7, no. 2, </volume> <pages> pp. 105-128, </pages> <month> September </month> <year> 1994. </year>
Reference-contexts: Preserving logical order of events is enough to ensure correctness in non-real-time systems [4, 5], but not in real-time systems because of clandestine communication which can occur through what are known as hidden channels <ref> [2, 6, 10, 15] </ref>. A simple example of such communication is a process P on one node taking an action (through an actuator) and notifying other processes of it through messages. <p> Since all messages take time to be delivered, the temporal order is preserved and causal order results automatically. There are some limitations of all clock-driven ordering protocols (including the -protocols) as described in <ref> [6] </ref> and elsewhere, because real clocks have non-zero clock granularity 2 g and tend to drift apart from each other. This limits the system's ability to order events timestamped on different nodes.
Reference: [7] <author> H. Kopetz and K. H. Kim, </author> <title> Temporal uncertainties in interactions among real-time objects, </title> <booktitle> in Ninth Symposium on Reliable Distributed Systems, </booktitle> <pages> pp. 165-174, </pages> <month> October </month> <year> 1990. </year>
Reference: [8] <author> H. Kopetz and K. Kim, </author> <title> Consistency constraints in distributed real time systems, in Distributed Computer Control Systems, </title> <editor> M. G. Rodd and T. L. d'Epinay, </editor> <booktitle> editors, </booktitle> <pages> pp. 29-34, </pages> <publisher> Pergamon Press, </publisher> <year> 1988. </year>
Reference: [9] <author> P. Verissimo, </author> <title> Real-time communication, in Distributed Systems, </title> <editor> S. Mullender, </editor> <booktitle> editor, </booktitle> <pages> pp. 447-490, </pages> <publisher> Addison Wesley, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1993. </year>
Reference-contexts: Real-time systems differ from non-real-time systems in that one node may affect other nodes through the external environment, which is why causal ordering schemes for non-real-time systems do not work for real-time sys tems [10, 15]. Causal ordering schemes for real-time sys-tems fall into two broad categories <ref> [9] </ref>: clock-driven and timer-driven. The former makes use of a global time base whereas the latter relies on local timers. Timer-driven protocols have a shortcoming that they can order only those events which have a large time-separation (tens of milliseconds) 1 . <p> The MARS approach delays messages at both the source as well as the destination. It is based on the sparse timebase concept [2]. The system proceeds in lock-step and each step 2 For granularity g to be meaningful, it must be larger than the precision of the clock <ref> [9] </ref>. is one clock tick of usually large granularity (in the order of a millisecond [2]). All message send and deliver events are constrained to occur at the clock ticks and the clock granularity is larger than maximum message transmission time.
Reference: [10] <author> D. R. Cheriton and D. Skeen, </author> <title> Understanding the limitations of causally and totally ordered communication, </title> <booktitle> in Proc. ACM SIGOPS, </booktitle> <pages> pp. 44-57, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: Real-time systems differ from non-real-time systems in that one node may affect other nodes through the external environment, which is why causal ordering schemes for non-real-time systems do not work for real-time sys tems <ref> [10, 15] </ref>. Causal ordering schemes for real-time sys-tems fall into two broad categories [9]: clock-driven and timer-driven. The former makes use of a global time base whereas the latter relies on local timers. <p> To tackle the problem of consistent and correct ordering of events, a set of possible relationships between messages in a distributed system have been identified. The most commonly-known relationship is logical order <ref> [10, 14] </ref>: Logical Order: Logical order is usually defined based on Lamport's happens-before relationship [4]. <p> Preserving logical order of events is enough to ensure correctness in non-real-time systems [4, 5], but not in real-time systems because of clandestine communication which can occur through what are known as hidden channels <ref> [2, 6, 10, 15] </ref>. A simple example of such communication is a process P on one node taking an action (through an actuator) and notifying other processes of it through messages.
Reference: [11] <author> P. Verissimo, </author> <title> Causal delivery protocols in real-time systems: a generic model, </title> <journal> Journal of Real-Time Systems, </journal> <volume> vol. 10, no. 1, </volume> <pages> pp. 45-73, </pages> <month> September </month> <year> 1996. </year>
Reference-contexts: This way, the overhead of ordering messages shifts from run-time to design-time. The advantage is that at design-time, CAD tools can 1 In the terminology of <ref> [11] </ref>, events must be separated by at least , the steadiness of the protocol, which is usually tens of milliseconds. be used to facilitate the design process and reduce overhead. <p> In real-time systems, such virtual messages must be considered as well in addition to the real messages when properly ordering events and messages. If we extend the definitions of send and deliver to apply not only to real messages but to virtual ones as well <ref> [11] </ref> (in the above example, the send event will be the actuation and the deliver event will be its detection by a sensor), then we can define the causal order relationship between events: Causal Order: Causal order is defined based on the precedence relationship between events. <p> Our objective is to ensure that messages are delivered in accordance with their causal order. This is known as causal delivery and is defined as follows <ref> [11] </ref>: Causal Delivery: If m j ! m i and dest (m j ) dest (m i ), then causal delivery ensures deliver (m j ) ! deliver (m i ), where m i , m j can be real or virtual messages.
Reference: [12] <institution> Road vehicles Interchange of digital information Controller area network (CAN) for high-speed communication. </institution> <note> ISO 11898, 1st edition, </note> <year> 1993. </year>
Reference-contexts: Previous Work A typical distributed real-time system consists of a set of nodes interconnected by an arbitrary topology real-time communication network such as Controller Area Network (CAN) <ref> [12] </ref> and token bus [13]. In such systems, nodes usually inform each other of events by exchanging messages. Since the communication subsystem may take a variable amount of time to deliver messages, there is always the potential for messages being reordered en route to their destinations. <p> For simulation we assume a 1 Mbit/s CAN <ref> [12] </ref> network which is commonly used in embedded systems like automotive and industrial applications. Assume each of the 12 causally-related messages is 79 bits long (32 data bits plus 47 framing bits) and the 13th message is 87 bits long (40 data bits).
Reference: [13] <author> A. Tanenbaum, </author> <title> Computer Networks, </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, N.J., </address> <year> 1989. </year>
Reference-contexts: Previous Work A typical distributed real-time system consists of a set of nodes interconnected by an arbitrary topology real-time communication network such as Controller Area Network (CAN) [12] and token bus <ref> [13] </ref>. In such systems, nodes usually inform each other of events by exchanging messages. Since the communication subsystem may take a variable amount of time to deliver messages, there is always the potential for messages being reordered en route to their destinations.
Reference: [14] <author> S. Mullender, </author> <title> editor, Distributed Systems, </title> <publisher> Addison Wesley, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1993. </year>
Reference-contexts: To tackle the problem of consistent and correct ordering of events, a set of possible relationships between messages in a distributed system have been identified. The most commonly-known relationship is logical order <ref> [10, 14] </ref>: Logical Order: Logical order is usually defined based on Lamport's happens-before relationship [4].
Reference: [15] <author> P. Verissimo, P. Barnett, P. Bond, A. Hilborne, L. Rodrigues, and D. Seaton, </author> <title> Extra Performance Architecture (XPA), in Delta-4: A Generic Architecture for Dependable Distributed Computing, </title> <editor> D. Powell, </editor> <booktitle> editor, </booktitle> <pages> pp. 211-266, </pages> <publisher> Springer Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Real-time systems differ from non-real-time systems in that one node may affect other nodes through the external environment, which is why causal ordering schemes for non-real-time systems do not work for real-time sys tems <ref> [10, 15] </ref>. Causal ordering schemes for real-time sys-tems fall into two broad categories [9]: clock-driven and timer-driven. The former makes use of a global time base whereas the latter relies on local timers. <p> Preserving logical order of events is enough to ensure correctness in non-real-time systems [4, 5], but not in real-time systems because of clandestine communication which can occur through what are known as hidden channels <ref> [2, 6, 10, 15] </ref>. A simple example of such communication is a process P on one node taking an action (through an actuator) and notifying other processes of it through messages.
Reference: [16] <author> K. M. Zuberi and K. G. Shin, </author> <title> Non-preemptive scheduling of messages on Controller Area Network for real-time control applications, </title> <booktitle> in Proc. Real-Time Technology and Applications Symposium, </booktitle> <pages> pp. 240-249, </pages> <month> May </month> <year> 1995. </year>
Reference-contexts: For CAN networks, clocks can be synchronized to give a g as small as 20s [20]. In our simulations, we allow for some extra variance and let g = 30s. We simulate both the deadline-monotonic (DM) scheduling algorithm [17] and the mixed-traffic scheduler (MTS) algorithm <ref> [16] </ref> while varying both n as well as d m . DM is a fixed-priority scheduler which prioritizes messages according to the tightness of their relative deadlines. MTS is a combination of DM and the earliest-deadline (ED) scheduler. <p> In embedded real-time infeasible under DM. infeasible under MTS. systems, message deadlines are typically at least a few hundred microseconds <ref> [16] </ref>. The minimum ffi must be greater than the response time of the fastest actuator in the system. From Table 1, we see that even the fastest actuators have response times of at least several hundred microseconds.
Reference: [17] <author> K. Tindell, A. Burns, and A. J. Wellings, </author> <title> Calculating Controller Area Network (CAN) message response times, </title> <journal> Control Engineering Practice, </journal> <volume> vol. 3, no. 8, </volume> <pages> pp. 1163-1169, </pages> <year> 1995. </year>
Reference-contexts: For CAN networks, clocks can be synchronized to give a g as small as 20s [20]. In our simulations, we allow for some extra variance and let g = 30s. We simulate both the deadline-monotonic (DM) scheduling algorithm <ref> [17] </ref> and the mixed-traffic scheduler (MTS) algorithm [16] while varying both n as well as d m . DM is a fixed-priority scheduler which prioritizes messages according to the tightness of their relative deadlines. MTS is a combination of DM and the earliest-deadline (ED) scheduler.
Reference: [18] <author> C.-C. Han and K. G. Shin, </author> <title> Real-time communication in FieldBus multiaccess networks, </title> <booktitle> in Proc. Real-Time Technology and Applications Symposium, </booktitle> <pages> pp. 86-95, </pages> <month> May </month> <year> 1995. </year>
Reference: [19] <author> H. Kopetz and W. Ochsenreiter, </author> <title> Clock synchronization in distributed real-time systems, </title> <journal> IEEE Trans. on Computers, </journal> <volume> vol. 36, no. 8, </volume> <pages> pp. 933-940, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Now, we modify this scheme to work with realistic clock synchronization with non-zero granularity g. Clocks on two nodes can be out of sync by any value less than g. Known clock synchronization schemes for LANs can ensure g to be as small as 10-20 s <ref> [19, 20] </ref>. As with other clock-based ordering schemes (Section 2), two events must be separated by at least 2g for the system to be able to order them properly. A non-zero g combined with virtual messages creates the problem shown in Figure 2. <p> The minimum ffi must be greater than the response time of the fastest actuator in the system. From Table 1, we see that even the fastest actuators have response times of at least several hundred microseconds. On the other hand, g is usually as small as tens of microseconds <ref> [19, 20] </ref> for LANs commonly used in embedded systems. So, if d 1 = d m = 400s, then d 2 will be 800s for ideal clocks which will reduce to 740s for non-ideal clocks for g = 30s, a decrease of only 7.5%.
Reference: [20] <author> M. Gergeleit and H. Streich, </author> <title> Implementing a distributed high-resolution real-time clock using the CAN-bus, </title> <booktitle> in Proc. 1st International CAN Conference, </booktitle> <month> September </month> <year> 1994. </year>
Reference-contexts: Now, we modify this scheme to work with realistic clock synchronization with non-zero granularity g. Clocks on two nodes can be out of sync by any value less than g. Known clock synchronization schemes for LANs can ensure g to be as small as 10-20 s <ref> [19, 20] </ref>. As with other clock-based ordering schemes (Section 2), two events must be separated by at least 2g for the system to be able to order them properly. A non-zero g combined with virtual messages creates the problem shown in Figure 2. <p> Assume each of the 12 causally-related messages is 79 bits long (32 data bits plus 47 framing bits) and the 13th message is 87 bits long (40 data bits). For CAN networks, clocks can be synchronized to give a g as small as 20s <ref> [20] </ref>. In our simulations, we allow for some extra variance and let g = 30s. We simulate both the deadline-monotonic (DM) scheduling algorithm [17] and the mixed-traffic scheduler (MTS) algorithm [16] while varying both n as well as d m . <p> The minimum ffi must be greater than the response time of the fastest actuator in the system. From Table 1, we see that even the fastest actuators have response times of at least several hundred microseconds. On the other hand, g is usually as small as tens of microseconds <ref> [19, 20] </ref> for LANs commonly used in embedded systems. So, if d 1 = d m = 400s, then d 2 will be 800s for ideal clocks which will reduce to 740s for non-ideal clocks for g = 30s, a decrease of only 7.5%.
Reference: [21] <author> K. Muller, </author> <title> Actuators, in Automotive Electronics Handbook, </title> <editor> R. K. Jurgen, </editor> <booktitle> editor, </booktitle> <pages> pp. </pages> <address> 10.1-10.34, </address> <publisher> McGraw-Hill, </publisher> <address> New York, NY, </address> <year> 1995. </year>
Reference-contexts: Conclusion Ordering messages according to their causal relationships in a distributed real-time system is necessary to ensure correct and reliable behavior and is also useful for build Actuator Response Time Automotive actuators Switching time for solenoid valves in ABS <ref> [21] </ref> 4-10ms Switching time for fuel injectors [21] 0.65-1.5ms Motors Minimum stepper motor pulse 0.83ms response time [22] (1200 pulses/sec) Industrial valves Solenoid valve (50% step change) [23] 0.6-3s Table 1. Response times for some commonly used actuators. ing atomic multicast, replication, and other such higher level services. <p> Conclusion Ordering messages according to their causal relationships in a distributed real-time system is necessary to ensure correct and reliable behavior and is also useful for build Actuator Response Time Automotive actuators Switching time for solenoid valves in ABS <ref> [21] </ref> 4-10ms Switching time for fuel injectors [21] 0.65-1.5ms Motors Minimum stepper motor pulse 0.83ms response time [22] (1200 pulses/sec) Industrial valves Solenoid valve (50% step change) [23] 0.6-3s Table 1. Response times for some commonly used actuators. ing atomic multicast, replication, and other such higher level services.
Reference: [22] <author> M. S. Sarma, </author> <title> Electric Machines: Steady-State Theory and Dynamic Performance, </title> <publisher> West Publishing Company, </publisher> <address> St. Paul, MN, </address> <note> second edition, </note> <year> 1994. </year>
Reference-contexts: causal relationships in a distributed real-time system is necessary to ensure correct and reliable behavior and is also useful for build Actuator Response Time Automotive actuators Switching time for solenoid valves in ABS [21] 4-10ms Switching time for fuel injectors [21] 0.65-1.5ms Motors Minimum stepper motor pulse 0.83ms response time <ref> [22] </ref> (1200 pulses/sec) Industrial valves Solenoid valve (50% step change) [23] 0.6-3s Table 1. Response times for some commonly used actuators. ing atomic multicast, replication, and other such higher level services. Causal order must be preserved while ensuring that all messages meet their deadlines a requirement of all real-time systems.
Reference: [23] <author> V. Liantonio, </author> <title> Conceptual advancements in the solenoid powered control valve art, in Developments in Valves and Actuators for Fluid Control, </title> <editor> D. R. Airey, </editor> <booktitle> editor, </booktitle> <pages> pp. 25-36, </pages> <publisher> Scientific And Technical Information, Oxford, </publisher> <year> 1990. </year>
Reference-contexts: ensure correct and reliable behavior and is also useful for build Actuator Response Time Automotive actuators Switching time for solenoid valves in ABS [21] 4-10ms Switching time for fuel injectors [21] 0.65-1.5ms Motors Minimum stepper motor pulse 0.83ms response time [22] (1200 pulses/sec) Industrial valves Solenoid valve (50% step change) <ref> [23] </ref> 0.6-3s Table 1. Response times for some commonly used actuators. ing atomic multicast, replication, and other such higher level services. Causal order must be preserved while ensuring that all messages meet their deadlines a requirement of all real-time systems.
References-found: 23

