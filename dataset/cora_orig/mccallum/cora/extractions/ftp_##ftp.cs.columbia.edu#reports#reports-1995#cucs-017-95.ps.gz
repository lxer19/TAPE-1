URL: ftp://ftp.cs.columbia.edu/reports/reports-1995/cucs-017-95.ps.gz
Refering-URL: http://www.cs.columbia.edu/~library/1995.html
Root-URL: http://www.cs.columbia.edu
Title: Tractable Reasoning in Knowledge Representation Systems  
Author: Mukesh Dalal 
Date: July 1995  
Address: New York, NY 10027  
Affiliation: Department of Computer Science Columbia University  
Pubnum: CUCS-017-95  
Abstract: 1 This is an updated version of the Rutgers University Computer Science Technical Report DCS-TR-321 published in May 1995. This material is partially based upon work supported by the National Science Foundation under Grant No. IRI-94-10117. 2 Email: dalal@cs.columbia.edu 
Abstract-found: 1
Intro-found: 1
Reference: [AB75] <author> A.R. Anderson and N.D Belnap. </author> <title> Entailment, the logic of relevance and neccessity. </title> <publisher> Princeton University Press, </publisher> <year> 1975. </year>
Reference-contexts: Intuitively, relevance logic allows equivalences based on the properties of logical operators such as commutativity, associativity, distributivity, De Morgan's laws and double negation <ref> [AB75] </ref>; for example, f _::g j= B _ , for any formula and . It also allows inferring clauses from their subclauses; for example, f (P _Q)g j= B (P _Q_R). However, relevance logic blocks chaining; for example, fP; :P _ Qg 6j= B Q.
Reference: [AHU74] <author> A.V. Aho, J.E. Hopcroft, and J.D. Ullman. </author> <title> The design and analysis of computer algorithms. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: These algorithms use several standard algorithmic "tricks" presented in the literature for reducing the time complexity (c.f. <ref> [AHU74] </ref>). 3.2 Alternative Propagation Rules We introduce the new propagation rules that are implemented by our algorithms. <p> This distinction is used in MergeOccurs. For keeping track of initialized occurs entries, we use a global list, EXT, which will have pointers to all these initialized entries, and an array N.Sanity (indexed by atoms) with each new internal node N created by Factor (see <ref> [AHU74] </ref>). The general idea is that if for some atom A, location N.Occurs [A] is initialized then a new entry is created in EXT that will point back to the initialized location, and N.Sanity [A] will be set to point to this new entry in EXT.
Reference: [Arn85] <author> S. Arnborg. </author> <title> Efficient algorithms for combinatorial problems on graphs with bounded decomposability | a survey. </title> <journal> BIT, </journal> <volume> 25 </volume> <pages> 2-23, </pages> <year> 1985. </year>
Reference-contexts: And, given a binary constraint network that is known to have induced width bounded by k, <ref> [Arn85, Dec91] </ref> provide tractable algorithms for finding an ordering that achieves this bound, and hence can be passed to Adaptive-Consistency. <p> And, given a binary constraint network that is known to have induced width bounded by k, [Arn85, Dec91] provide tractable algorithms for finding an ordering that achieves this bound, and hence can be passed to Adaptive-Consistency. Also, we observe that Arnborg <ref> [Arn85] </ref> showed that determining the induced width of any specific graph is an NP-complete problem, so it is not practical to determine it "at run time".
Reference: [BB70] <author> G. Birkhoff and T.C. Bartee. </author> <title> Modern Applied Algebra. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1970. </year>
Reference-contexts: Moreover, the number of prime implicates of a formula can be exponential in the size of the formula. 3 The prime implicates of a theory are the minimal clauses that are logically entailed by the theory <ref> [BB70] </ref> 29 ------------------------------------------------------- fi (^(B 1 ); B 2 ) ) fi (B 1 ; B 2 ) _ (ff; ff; B) ) _ (ff; B) _ (^( 0 ; : : : ; n ); B 1 ) ) ^(_ ( 0 ; B 1 ); : : : ; <p> Further, for any theory and number p, if and k p then E (; k) E (; p). Since we are dealing with only finite theories, E () is always finite. 4.2.4 Lattices and Fixed-Points We now review some definitions and results regarding lattices and fixed-points <ref> [BB70] </ref>. Consider any binary relation defined on a finite set S: If is a partial order, i.e., reflexive, transitive, and antisymmetric, then (S; ) is called a partially ordered set (or poset).
Reference: [BD88] <author> M. Boddy and T. Dean. </author> <title> Solving time dependent planning problems. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, Brown University, </institution> <year> 1988. </year>
Reference-contexts: Since we show that each theory has a complete reasoner in the family, it can be used for specifying the partial answers of an "anytime reasoner". Anytime reasoners <ref> [BD88] </ref> are complete reasoners that provide partial answers even if they are stopped prematurely; the completeness of the answer improves with the time used in computing the answer. They could also be used for providing a quick "first cut" to a problem, which can be later improved. <p> Moreover, FP is proved to be more complete than CNF-BCP, a previously-proposed extension of BCP to non-clausal theories. We know of no other reasoner for arbitrary propositional theories that is tractable and at least as complete as FP. There is a considerable interest in developing anytime reasoners <ref> [BD88] </ref>, which are complete reasoners that provide partial answers even if they are stopped prematurely; the completeness of the answer improves with the time used in computing the answer. Anytime reasoners could be also used for providing a quick "first-cut" to a problem, which can be improved later.
Reference: [BE89] <author> A. Borgida and D.W. Etherington. </author> <title> Hierarchical knowledge bases and efficient disjunctive reasoning. </title> <editor> In R.J. Brachman, H.J. Levesque, and R. Reiter, editors, </editor> <booktitle> Proceedings First International Conference on Principles of Knowledge Representation and Reasoning, </booktitle> <pages> pages 33-43. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1989. </year>
Reference-contexts: A variant of the incomplete/unsound approach is to explicitly approximate the knowledge told to the KB, and/or the queries asked of it, into some other language for which the reasoning is tractable. As in the work on null values in databases [IL82], domain abstraction [Imi87], and knowledge compilation <ref> [SK91, BE89] </ref>, the idea in this approach is to "bound" the error by reporting possibly more than one answer. Note that this approach relies on finding tractable languages to which the formulas are approximated. This work makes contributions to the first three approaches to the intractability problem. <p> Approximations: This work contributes indirectly towards the fourth approach (mentioned in Section 1.1) to the intractability of reasoning, namely, explicitly approximating the information told to the KR system, and/or the queries asked of it. In related work [DE92] (based on earlier work in <ref> [BE89] </ref>), we restrict the internal representation to a tractable subset of the highly expressive Ask and Tell languages; information and queries in the expressive languages are then suitably approximated by the formulas in the tractable language.
Reference: [Bel77] <author> N. D. Belnap. </author> <title> A useful four-valued logic. </title> <editor> In G. Epstein and J. M. Dunn, editors, </editor> <booktitle> Modern Uses of Multiple-Valued Logics. </booktitle> <publisher> Reidel, </publisher> <year> 1977. </year>
Reference-contexts: Typical examples of this approach include Boolean Constraint Propagation (BCP) [McA80, McA90] (a variant of unit resolution [CL73]) and tautological entailment <ref> [Bel77, Lev84b, Fri87] </ref>, both of which are sound but incomplete. The general difficulty with this approach is in characterizing (preferably syntactically) the class of queries that will be answered correctly, or the degree of error in the possibly-incorrect answer. 3. <p> Relevance Logic and RP-Entailment Belnap <ref> [Bel77] </ref> presented a 4-valued model-theory for PC, called relevance logic, whose entailment relation, say j= B , is strictly weaker than j=, the entailment relation for classical 2-valued model theory.
Reference: [BFL83] <author> R.J. Brachman, R.E. Fikes, and H.J. Levesque. </author> <title> Krypton: A functional approach to knowledge representation. </title> <journal> IEEE Computer, </journal> <volume> 16(10) </volume> <pages> 67-73, </pages> <year> 1983. </year>
Reference-contexts: Thus, Tell and Ask operations implement some form of deductive reasoning. The logics most commonly used are first-order logic and propositional logic [Men64, Yas94], since L T ell and L Ask are usually subsets of their underlying languages. It has been cogently argued <ref> [BFL83] </ref> that for the computational services of a KR system to be dependable, their worst-case time requirements should be small enough to allow adequate response in all critical situations.
Reference: [Bun92] <author> H.K. Buning. </author> <title> On generalized Horn formulas and k-resolution. </title> <journal> Information Processing Letters, </journal> <note> 1992. To be published. </note>
Reference-contexts: Buning <ref> [Bun92] </ref> defined k-resolution, a restriction on resolution that at least one parent must have at most k literals, and showed that k-resolution is refutation complete for k1 ; but refutation-incomplete for k : k-resolution can be used to define a family of tractable entailment relations: ` B k iff [ f:
Reference: [CK89] <author> J. Crawford and B. Kuipers. </author> <title> Towards a theory of access-limited logic for knowledge representation. </title> <booktitle> In Proceedings First International Conference on Principles of Knowledge Representation and Reasoning (KR'89), </booktitle> <pages> pages 67-78, </pages> <year> 1989. </year>
Reference-contexts: It then follows that [ 0 ` FPE 2 f , 2 f . Access-Limited Logics (ALL) Crawford and Kuipers <ref> [CK89, CK91] </ref> presents ALL, a logic that attempts to formalize the access limitations that are inherent in a network-structured knowledge base. ALL allows retrieving only those assertions that are reachable by following an available access path. It is shown that if the access paths are bounded then reasoning is tractable.
Reference: [CK91] <author> J.M. Crawford and B.J. Kuipers. </author> <title> Negation and proof by contradiction in access-limited logic. </title> <booktitle> In Proceedings Ninth National Conference on Artificial Intelligence (AAAI-91), </booktitle> <pages> pages 897-903, </pages> <year> 1991. </year>
Reference-contexts: Hence, the R-intricacy of any theory is the least k for which ` R k is complete. Some other families of increasingly complete consequence relations have been previously proposed (c.f. <ref> [CS92b, CK91] </ref>). Another such family can also be directly obtained from the tractable satisfiability classes proposed in [GS88]. We will compare our family ` FPE k with these. <p> It then follows that [ 0 ` FPE 2 f , 2 f . Access-Limited Logics (ALL) Crawford and Kuipers <ref> [CK89, CK91] </ref> presents ALL, a logic that attempts to formalize the access limitations that are inherent in a network-structured knowledge base. ALL allows retrieving only those assertions that are reachable by following an available access path. It is shown that if the access paths are bounded then reasoning is tractable.
Reference: [CKT91] <author> P. Cheeseman, B. Kanefsky, and W.M. Taylor. </author> <title> Where the really hard problems are. </title> <booktitle> In Proceedings Twelveth International Joint Conference on Artificial Intelligence (IJCAI-91), </booktitle> <pages> pages 331-412, </pages> <year> 1991. </year>
Reference-contexts: We need to implement them and experiment with reasoning 153 problems in order to determine their efficacy. These problems could be randomly generated or may be obtained from some "real-world" application. Recently, there have been some interesting empirical results regarding the difficulty of solving randomly-generated reasoning problems (c.f. see <ref> [CKT91, MSL92] </ref>). It would be useful to determine whether similar results hold for our algorithms. Approximations: This work contributes indirectly towards the fourth approach (mentioned in Section 1.1) to the intractability of reasoning, namely, explicitly approximating the information told to the KR system, and/or the queries asked of it.
Reference: [CL73] <author> C. Chang and R.C. Lee. </author> <title> Symbolic Logic and Mechanical Theorem Proving. </title> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1973. </year>
Reference-contexts: An incomplete reasoner may fail to infer some information warranted by the underlying logic, while an unsound 1 reasoner may infer information that is not warranted by the underlying logic. Typical examples of this approach include Boolean Constraint Propagation (BCP) [McA80, McA90] (a variant of unit resolution <ref> [CL73] </ref>) and tautological entailment [Bel77, Lev84b, Fri87], both of which are sound but incomplete. The general difficulty with this approach is in characterizing (preferably syntactically) the class of queries that will be answered correctly, or the degree of error in the possibly-incorrect answer. 3.
Reference: [Coo71] <author> S.A. Cook. </author> <title> The complexity of theorem proving procedures. </title> <booktitle> In Proceedings Third Annual ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 151-158, </pages> <year> 1971. </year>
Reference-contexts: PCE can also be viewed as first-order predicate calculus, FOPC, with equality [Men64] but without: 1. any variables and quantifiers, and 2. any functions other than constants; except in the axioms (including equality) and the rules of inference. 155 Appendix B A Ptime CNF Transformation Although there is a well-known <ref> [Coo71] </ref> clausal form transformation that does not cause exponential increase in size of theories, it requires adding new atoms corresponding to their subformulas.
Reference: [Coo76] <author> S. A. Cook. </author> <title> A short proof of the pigeon hole principle using extended resolution. </title> <journal> ACM SIGACT News, </journal> <volume> 8 </volume> <pages> 28-32, </pages> <address> Oct.-Dec. </address> <year> 1976. </year>
Reference-contexts: We now show that these criteria are not necessary for tractability by presenting a tractable class, call it C 3 , of theories which violate both the criteria. 118 Class C 3 is obtained by encoding the pigeon-hole principle (c.f. <ref> [Coo76, CS88] </ref>), according to which it is not possible to assign n + 1 pigeons to n holes (for any number n) such that no two pigeons are in the same hole.
Reference: [Cra92] <author> J. Crawford, </author> <title> editor. </title> <booktitle> Proceedings of the AAAI Workshop on Tractable Reasoning. American Association for Artificial Intelligence, </booktitle> <address> San Jose, California, </address> <year> 1992. </year> <month> 175 </month>
Reference-contexts: Studying ways to make this tradeoff between expressiveness and tractability, also known as the intractability problem, is a central focus of research in KR. There are several general approaches to the intractability problem (c.f. <ref> [Cra92] </ref>): 1. Restrict the expressiveness of the KR system (i.e., the language for telling it information and/or the language of asking queries) so that the two operations are provably tractable.
Reference: [Cra94] <author> J. M. Crawford. </author> <type> Personal Communication, </type> <year> 1994. </year>
Reference-contexts: They define a family ` k ALL of entailment relation such that only k nesting of preliminary queries are allowed for inference in ` k ALL . Although the exact relation between ` FPE k and ` k ALL is still open, the following example <ref> [Cra94] </ref> shows that ` 2 ALL is not stronger than ` FPE 2 .
Reference: [CS88] <author> Chvatal and Szemeredi. </author> <title> Many hard examples for resolution. </title> <journal> Journal of the ACM, </journal> <volume> 35(4):759, </volume> <month> oct. </month> <year> 1988. </year>
Reference-contexts: We now show that these criteria are not necessary for tractability by presenting a tractable class, call it C 3 , of theories which violate both the criteria. 118 Class C 3 is obtained by encoding the pigeon-hole principle (c.f. <ref> [Coo76, CS88] </ref>), according to which it is not possible to assign n + 1 pigeons to n holes (for any number n) such that no two pigeons are in the same hole.
Reference: [CS92a] <author> M. Cadoli and M. Schaerf. </author> <title> Approximation in concept description languages. </title> <editor> In B. Nebel, C. Rich, and W. Swartout, editors, </editor> <booktitle> Principles of Knowledge Representation and Reasoning: Proceedings of the Third International Conference (KR'92), </booktitle> <pages> pages 330-341, </pages> <address> Cambridge, Massachusetts, 1992. </address> <publisher> Morgan Kaufmann Publishers. </publisher>
Reference-contexts: For any given task, an appropriate rea-soner is selected, based on the specific requirements of the task. Typical examples of this approach include the hierarchy of satisfiability problems [GS88] and the family of approximate entailments <ref> [CS92a] </ref>. In addition to the difficulty in characterizing queries that will be answered correctly by the various reasoners in the family, this approach presents issues concerning the reuse of earlier computation when different reasoners from the family are used. 4. <p> They could also be used for providing a quick "first cut" to a problem, which can be later improved. Although families of increasingly-complete tractable reasoners were previously-known for the clausal case (c.f. <ref> [GS88, CS92a] </ref>), we do not know of any other such family of reasoners for arbitrary propositional theories. Our technique for generating these reasoners is based on restricting the length of the clauses used in chaining (i.e., Modus Ponens). <p> Since fP; :P _ Qg 6j= RP Q and fP; :P _ Qg ` FPE 0 Q, it then follows that ` FPE 0 is strictly stronger than both j= B and j= RP . 113 Approximate Entailment Cadoli and Schaerf <ref> [CS92a] </ref> parameterized j= RP by sets of propositions: their entailment relation j= 3 S is defined using a 3-valued model theory which restricts each atom in the set S to the traditional 2 values. 4 Intuitively, the logic allows chaining on the atoms in the set S; for example, if P <p> Although the exact relation between ` FPE k and ` k ALL is still open, the following example [Cra94] shows that ` 2 ALL is not stronger than ` FPE 2 . Consider the theory containing the following clauses: 4 <ref> [CS92a] </ref> also defines a family of unsound but complete entailment relations, using a similar idea. 114 (:P _ Q _ U ) (:P _ :Q _ S _ W ) (P _ R _ V ) (P _ :R _ S _ X) It can be verified by an exhaustive case <p> Extending FP, we developed a family of increasingly-complete tractable reasoners which could be used for specifying the partial answers of an anytime reasoner. Although families of increasingly-complete tractable reasoners were previously known for the clausal case (c.f. <ref> [GS88, CS92a] </ref>), we know of no other such family of reasoners for arbitrary propositional theories. Our technique for generating these reasoners is based on restricting the length of the clauses used in chaining (i.e., Modus Ponens).
Reference: [CS92b] <author> M. Cadoli and M. Schaerf. </author> <title> Tractable reasoning via approximation. </title> <booktitle> In [Cra92], </booktitle> <pages> pages 12-15, </pages> <year> 1992. </year>
Reference-contexts: Hence, the R-intricacy of any theory is the least k for which ` R k is complete. Some other families of increasingly complete consequence relations have been previously proposed (c.f. <ref> [CS92b, CK91] </ref>). Another such family can also be directly obtained from the tractable satisfiability classes proposed in [GS88]. We will compare our family ` FPE k with these.
Reference: [Dav91] <author> E. Davis. </author> <title> Lucid representations. </title> <type> Technical Report 565, </type> <institution> New York University, Dept. of Computer Science, </institution> <month> June </month> <year> 1991. </year>
Reference-contexts: Developing appropriate notions of vividness and techniques for compiling theories into vivid theories has already generated considerable interest in the KR community (c.f. <ref> [Lev86, Dav91] </ref>). Our final contribution is to the description of tractable cases of reasoning (the first approach to intractability).
Reference: [de 89] <author> J. de Kleer. </author> <title> A comparison of ATMS and CSP techniques. </title> <booktitle> In Proceedings Eleventh International Joint Conference on Artificial Intelligence (IJCAI-89), </booktitle> <pages> pages 290-296, </pages> <year> 1989. </year>
Reference-contexts: The following inference rule, adapted from <ref> [de 89] </ref>, provides a deductive system for the facts that are inferred from a theory using Horn Pebbling: _ (p); _ (:p; ff 1 ; : : : ; ff n ) DHP ------------------------------------------------------- fi (_ (p); _ (~ p; B 1 ); B 2 ) ) fi (_ (p); _ <p> An atom p in a theory is pebbled iff either _ (p) or f is inferable from using the above inference rule. As observed by <ref> [de 89] </ref>, the second antecedent clause, which is a superclause of the consequence clause in the inference rule, may be removed from the theory after this rule is applied, since its further use can be replaced by the consequence clause. <p> However, Clausal BCP is incomplete even for positive literals; for example, the literal R that is entailed by the theory [[(P _ Q); (:P _ R); (:Q _ R)]] cannot be inferred using Clausal BCP. Adapting from <ref> [de 89] </ref> again, the following inference rule provides a deductive system for facts inferred by Clausal BCP: _ (ff); _ (~ ff; ff 1 ; : : : ; ff n ) This generalizes the inference rule for Horn Pebbling, since ff is now allowed to be a negative literal also.
Reference: [de 90] <author> J. de Kleer. </author> <title> Exploiting locality in a TMS. </title> <booktitle> In Proceedings Eight National Conference on Artificial Intelligence (AAAI-90), </booktitle> <pages> pages 264-271, </pages> <year> 1990. </year>
Reference-contexts: However, none of its previously-proposed extensions to the non-clausal case are known to be tractable (i.e., provably in PTIME). There are many applications where reasoning with non-clausal theories is required, for example, in verifying automatically generated update constraints [GTT92] and in the applications of logical "Truth Maintenance Systems" (TMS) <ref> [de 90, McA90, Mar91] </ref>. We develop fact propagation (FP), which tractably extends BCP to non-clausal theories. We present a quadratic-time algorithm for FP, which runs in linear time for clausal theories. Moreover, FP is proved to be more complete than CNF-BCP, a previously-proposed extension of BCP to non-clausal theories. <p> Moreover, the satisfiability problem (SAT) can be trivially reduced to the general problem of determining whether a fact is logically entailed by an arbitrary (possibly, non-clausal) formula. Thus, the fact-inference problem for Formula BCP is CoNP-Hard, i.e., intractable. Prime BCP <ref> [de 90] </ref> has been proposed as an algorithm for implementing Formula BCP. The basic idea is to first compute all the prime implicates 3 of each formula in the given theory, and then use Clausal BCP on the theory containing just these prime implicates. <p> The basic idea is to first compute all the prime implicates 3 of each formula in the given theory, and then use Clausal BCP on the theory containing just these prime implicates. For any theory, Prime BCP infers the same facts as Formula BCP <ref> [de 90] </ref>: thus, Prime BCP is also incomplete, and the fact-inference problem for Prime BCP is also CoNP-Hard, i.e., intractable. <p> _ (ff; B) _ (^( 0 ; : : : ; n ); B 1 ) ) ^(_ ( 0 ; B 1 ); : : : ; _ ( n ; B 1 )) where ff's are literals, 's are formulas, and B's are bags of formulas. ------------------------------------------------------ CNF-BCP <ref> [de 90] </ref> infers facts by first transforming the given theory into conjunctive normal form (CNF) and then using Clausal BCP. We first provide a non-traditional definition of CNF transformation and then discuss CNF-BCP. Intuitively, the CNF transformation of a theory produces a logically equivalent clausal theory using simple syntactic operations. <p> The algorithm CNF-BCP has exponential time complexity in the worst case, since the CNF transformation itself may lead to an exponential increase in the size of the theory. CNF transformations may also spoil the natural structure of theories (for example, locality <ref> [de 90] </ref>). Since there is no known PTIME algorithm for inferring the facts specified by CNF-BCP, the fact-inference problem for CNF-BCP is not known to be tractable. 2.5.5 Discussion BCP algorithms perform two distinct tasks: inferring facts (literals) from a theory, and simplifying a theory.
Reference: [DE92] <author> M. Dalal and D. W. Etherington. </author> <title> Tractable approximate deduction using limited vocabularies. </title> <booktitle> In Proceedings Ninth Canadian Conference on Artificial Intelligence (AI '92), </booktitle> <pages> pages 206-212, </pages> <address> Vancou-ver, Canada, </address> <year> 1992. </year>
Reference-contexts: Approximations: This work contributes indirectly towards the fourth approach (mentioned in Section 1.1) to the intractability of reasoning, namely, explicitly approximating the information told to the KR system, and/or the queries asked of it. In related work <ref> [DE92] </ref> (based on earlier work in [BE89]), we restrict the internal representation to a tractable subset of the highly expressive Ask and Tell languages; information and queries in the expressive languages are then suitably approximated by the formulas in the tractable language.
Reference: [Dec91] <author> R. Dechter. </author> <title> Constraint satisfaction. In S.C. </title> <editor> Shapiro, editor, </editor> <booktitle> Encyclopedia of AI (2nd Edition). </booktitle> <publisher> John Wiley and Sons, </publisher> <year> 1991. </year>
Reference-contexts: For a more detailed description, the interested reader is referred to <ref> [Mac87, Dec91, DH91] </ref>. <p> to be a backtrack-free network with respect to this ordering. 125 All backtrack-free networks are consistent by definition, and it is known that any consistent binary network can be transformed into an equivalent (i.e., having the same solutions) backtrack-free network with respect to any given ordering by adding new constraints <ref> [Dec91] </ref>. (The transformation from Figure 5.2 to Figure 5.3 is an example of such a transformation.) It is important to remember that, as illustrated later, these new constraints may be of arbitrary arity even if we start with a binary constraint network. <p> And, given a binary constraint network that is known to have induced width bounded by k, <ref> [Arn85, Dec91] </ref> provide tractable algorithms for finding an ordering that achieves this bound, and hence can be passed to Adaptive-Consistency. <p> Also, we observe that Arnborg [Arn85] showed that determining the induced width of any specific graph is an NP-complete problem, so it is not practical to determine it "at run time". However, it has been argued in <ref> [Dec91] </ref> that the bounded induced width criterion can be used as a theoretical tool for identifying tractable families of CSPs. Functional Constraints There have been other approaches for identifying tractable instances of CSP. <p> It follows directly from the definitions that any constraint network C is k-consistent iff the translated theory Tr (C) is k-consistent with respect to S . Thus, techniques in the literature to achieve higher levels of local consistency of constraint networks <ref> [Dec91] </ref> also achieve higher levels of local consistency of the translated theory with respect to S . We will show that, in a similar way, our technique of vivification achieves higher levels of local consistency of the translated theory with respect to D .
Reference: [Der89] <author> N. Dershowitz. </author> <title> Completion and its applications. </title> <editor> In H. Ait-Kaci and M. Nivat, editors, </editor> <booktitle> Resolution of Equations in Algebraic Structures, </booktitle> <volume> volume 2, chapter 2, </volume> <pages> pages 31-85. </pages> <publisher> Academic Press, Inc., </publisher> <year> 1989. </year>
Reference-contexts: We will use "finite PC" to denote PC restricted to finite theories. It follows that finite PC is a syntactic variant of PCE without equality. 2.4 Rewrite Systems for PCE We present a variant notion of rewrite systems <ref> [DJ90, KB70, Hue80, Der89] </ref> applicable to theories in PCE, in which groups of rewrite rules are represented by rule schemas that contain meta-variables. These rewrite systems will be used to rewrite theories into logically equivalent theories that are syntactically simpler, based on a measure of simplicity defined in this section.
Reference: [DG84] <author> W.F. Dowling and J.H. Gallier. </author> <title> Linear-time algorithms for testing the satisfiability of propositional Horn formulae. </title> <journal> Journal of Logic Programming, </journal> <volume> 1(3) </volume> <pages> 267-284, </pages> <year> 1984. </year>
Reference-contexts: Restrict the expressiveness of the KR system (i.e., the language for telling it information and/or the language of asking queries) so that the two operations are provably tractable. Typical examples of this approach include the use of the Horn subset of propositional logic, which is tractable <ref> [DG84] </ref>, and work in relational databases [Ull88], where L T ell is often just ground facts, but L Ask is function-free first-order logic. The problem with this approach is that such KR systems are generally too weak to deal with most applications [DP91]. 2. <p> It can also use the fact ff, which is part of the input, to work in a goal-directed fashion. Thus, the time complexity of the fact-inference problem for A could be lower than the time complexity of the algorithm A itself. 2.5.1 Horn Pebbling Dowling and Gallier <ref> [DG84] </ref> developed a linear-time algorithm for determining satisfiability of Horn theories that also obtains all the positive literals that are logically entailed by the input theory. We will first present this "Horn Pebbling" algorithm and then specify it using an inference system and a rewrite system. <p> An efficient algorithm for implementing the pebbling game is presented in <ref> [DG84] </ref>. If all the atoms that appear in the theory are known a priori (say, in a list provided as part of the input), then the algorithm terminates in time O (n), where n is the total number of occurrences of literals in the theory. <p> This encoding facilitates the reading of input to the algorithm AFP and creating the appropriate data structures. The complexity of AFP is measured in the size of this encoding. Similar, though not identical, encodings have been used by various others researchers (c.f. <ref> [DG84, MSL92] </ref>).
Reference: [DH91] <author> Y. Deville and P.V. Hentenryck. </author> <title> An efficient arc consistency algorithm for a class of CSP problems. </title> <booktitle> In Proceedings Twelveth International Joint Conference on Artificial Intelligence (IJCAI-91), </booktitle> <pages> pages 325-330, </pages> <year> 1991. </year>
Reference-contexts: We then show that some tractable classes already presented in the literature do have bounded intricacy. These include tractable classes of OR-databases [IMV94] and CSPs <ref> [DP88, DH91] </ref>. We also describe some new tractable classes using the bounded intricacy criterion. These include the first non-obvious tractable class in disjunctive logic programs [LJR92], and a new tractable family of classes in CSP. <p> For constraint satisfaction problems, we show that the induced width [DP88] of any inconsistent network is always greater than the intricacy of its translated theory (within a difference of 2), and that the intricacy of the translation of any network with only functional constraints <ref> [DH91] </ref> is 1. We then present a new family of tractable networks based on bounded intricacy that combines the intuitions behind bounded induced-width and functional constraints. For disjunctive databases, we show that the translations of each tractable class of querying identified in [IMV94] have bounded intricacy. <p> Determining consistency is known to be intractable [Fre78] even for constraint networks, a restricted class of CSPs in which all the constraints are explicitly provided as sets of tuples. Identifying classes of constraint networks for which consistency is provably tractable has generated considerable interest (c.f. <ref> [Fre82, DP87, DH91] </ref>). In this section, we present a quadratic-time translation of constraint networks to a restricted class of theories in PC (i.e., PCE without equality), called constraint theories. <p> It follows from the results of previous sections that the consistency problem is tractable for classes of constraint theories with bounded intricacy. We show that some tractable classes of constraint networks previously identified, for example, in <ref> [Fre82, DP87, DH91] </ref>, translate to classes of constraint theories with bounded intricacy. We also use this criterion to describe a new, more inclusive tractable class of constraint networks. Since the rewrite system FPE is identical to FP for PCE without equality, we use FP in this section. <p> For a more detailed description, the interested reader is referred to <ref> [Mac87, Dec91, DH91] </ref>. <p> A class C of binary constraint networks is tractable iff the consistency problem for C is in PTIME. Since the consistency problem for the class of all binary constraint networks is CoNP-Complete [Mac87], identifying classes of constraint networks for which consistency is provably tractable has generated considerable interest (c.f. <ref> [Fre82, DP87, DH91] </ref>). Most techniques to identify tractable families of CSP rely on the topology of the underlying constraint network. For example, Freuder [Fre82, Fre85] observed that CSPs whose networks are trees can be solved in linear time. <p> However, it has been argued in [Dec91] that the bounded induced width criterion can be used as a theoretical tool for identifying tractable families of CSPs. Functional Constraints There have been other approaches for identifying tractable instances of CSP. Deville and Van Hentenryck <ref> [DH91] </ref> use the "semantics" of the constraints to identify a new tractable class of CSPs. A constraint c (x; y) is said to be functional iff for each value in c (x), there is at most one value in c (y) (and vice versa) that satisfies the constraint. [DH91] presents a <p> Van Hentenryck <ref> [DH91] </ref> use the "semantics" of the constraints to identify a new tractable class of CSPs. A constraint c (x; y) is said to be functional iff for each value in c (x), there is at most one value in c (y) (and vice versa) that satisfies the constraint. [DH91] presents a quadratic-time algorithm for determining consistency of binary networks where all the constraints are functional. (The algorithm also performs "arc-consistency" [Fre85] for consistent networks in this class.) An example of a network in this class can be obtained from the network of Figure 5.2 by removing the tuple (1; <p> (y) = fv 1 ; : : : ; v p gg) lfp (T Tr (C);k+1 ) It then follows from Proposition 5.4 that Tr (C) is not (k + 1)-consistent. 5.4.5 Functional Constraints and Intricacy We now consider functional networks, which include the networks in the tractable class of <ref> [DH91] </ref>, and show that the intricacy of any inconsistent functional network is at most 1. <p> We now present a class of non-functional binary networks with bounded functional width but unbounded induced width. Thus, it will follow from from Theorem 5.15 that this class is tractable; however, this tractability claim does not follow from the results in [DP88] and <ref> [DH91] </ref>. This class generalizes the example network C3 given earlier in this section to more than 3 nodes, and adds similar networks that are inconsistent.
Reference: [DJ90] <author> N. Dershowitz and J.-P. Jounnaud. </author> <title> Rewrite systems. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics, chapter 6, </booktitle> <pages> pages 243-320. </pages> <publisher> The MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: We will use "finite PC" to denote PC restricted to finite theories. It follows that finite PC is a syntactic variant of PCE without equality. 2.4 Rewrite Systems for PCE We present a variant notion of rewrite systems <ref> [DJ90, KB70, Hue80, Der89] </ref> applicable to theories in PCE, in which groups of rewrite rules are represented by rule schemas that contain meta-variables. These rewrite systems will be used to rewrite theories into logically equivalent theories that are syntactically simpler, based on a measure of simplicity defined in this section. <p> Since this can only happen a finite number of times, every sequence of rewriting terminates. However, the ordering should satisfy certain properties, which are analogous to the notion of termination orderings <ref> [DJ90] </ref>: Definition 2.17 An ordering &gt; on terms is closed under replacement iff for any terms s; t; p; q: if p &gt; q and s is a subterm of t at position then t [p s] &gt; t [q s]. <p> Also, if &gt; is compatible with equality then a term can be replaced by a syntactically equivalent term without effecting its order with respect to other terms. The next lemma shows how these properties can be used for proving termination. Lemma 2.5 (based on <ref> [DJ90] </ref>) A rewrite system R is terminating if there is a well-ordering &gt; on terms such that &gt; is closed under replacement, &gt; is compatible with equality, and l &gt; r for each rewrite rule (instance) l ) r in R. <p> Recall that B (b) denotes the number of occurrences of the element 20 b in the bag B. For example, if a b, then [[a; b; a]] mul [[b; a; b; b]]. Since is a well-ordering, mul is also a well-ordering <ref> [DJ90] </ref>. We now use this multiset ordering and the number of occurrences of literals and connectives to extend the well-ordering to the set of terms. <p> Proposition 2.6 The ordering on terms is a well-ordering, is closed under replacement, and is compatible with equality. Proof: Since among terms is a lexicographic combination of four well-orderings, it follows that among terms is also a well-ordering <ref> [DJ90] </ref>.
Reference: [DP87] <author> R. Dechter and J. Pearl. </author> <title> Network-based heuristics for constraint satisfaction problems. </title> <journal> Artificial Intelligence, </journal> <volume> 34(1) </volume> <pages> 1-38, </pages> <year> 1987. </year>
Reference-contexts: Determining consistency is known to be intractable [Fre78] even for constraint networks, a restricted class of CSPs in which all the constraints are explicitly provided as sets of tuples. Identifying classes of constraint networks for which consistency is provably tractable has generated considerable interest (c.f. <ref> [Fre82, DP87, DH91] </ref>). In this section, we present a quadratic-time translation of constraint networks to a restricted class of theories in PC (i.e., PCE without equality), called constraint theories. <p> It follows from the results of previous sections that the consistency problem is tractable for classes of constraint theories with bounded intricacy. We show that some tractable classes of constraint networks previously identified, for example, in <ref> [Fre82, DP87, DH91] </ref>, translate to classes of constraint theories with bounded intricacy. We also use this criterion to describe a new, more inclusive tractable class of constraint networks. Since the rewrite system FPE is identical to FP for PCE without equality, we use FP in this section. <p> A class C of binary constraint networks is tractable iff the consistency problem for C is in PTIME. Since the consistency problem for the class of all binary constraint networks is CoNP-Complete [Mac87], identifying classes of constraint networks for which consistency is provably tractable has generated considerable interest (c.f. <ref> [Fre82, DP87, DH91] </ref>). Most techniques to identify tractable families of CSP rely on the topology of the underlying constraint network. For example, Freuder [Fre82, Fre85] observed that CSPs whose networks are trees can be solved in linear time. <p> Most techniques to identify tractable families of CSP rely on the topology of the underlying constraint network. For example, Freuder [Fre82, Fre85] observed that CSPs whose networks are trees can be solved in linear time. Dechter and Pearl <ref> [DP87] </ref> defined a topological property of networks called induced width, and showed that for any network for which there is a number k that bounds the induced width, it is possible to determine the consistency of the network in time polynomial in its size but exponential in k. <p> However, we do not require that some spanning trees of edges representing functional constraints be known. 5.4.6 A New Family of Tractable Classes Let us combine the intuitions behind the two tractable classes of the previous sections: 1. As we saw in Lemma 5.10, the adaptive-consistency algorithm of <ref> [DP87] </ref> is "simulated" by our fixpoint construction, with the induced width of a network bounded below by the intricacy of its translation. 135 2. Once a node is assigned a value, functional constraints allow fact propagation to obtain values that must be assigned to other nodes.
Reference: [DP88] <author> R. Dechter and J. Pearl. </author> <title> Network-based heuristics for constraint satisfaction problems. </title> <journal> Artificial Intelligence, </journal> <volume> 34(1) </volume> <pages> 1-38, </pages> <year> 1988. </year>
Reference-contexts: We then show that some tractable classes already presented in the literature do have bounded intricacy. These include tractable classes of OR-databases [IMV94] and CSPs <ref> [DP88, DH91] </ref>. We also describe some new tractable classes using the bounded intricacy criterion. These include the first non-obvious tractable class in disjunctive logic programs [LJR92], and a new tractable family of classes in CSP. <p> The problems we consider are all polynomially reducible to the (un)satisfiability problem for PCE | each instance of the problem is translated to a theory in PCE, whose satisfiability provides the answer for that instance. For constraint satisfaction problems, we show that the induced width <ref> [DP88] </ref> of any inconsistent network is always greater than the intricacy of its translated theory (within a difference of 2), and that the intricacy of the translation of any network with only functional constraints [DH91] is 1. <p> For disjunctive databases, we show that the translations of each tractable class of querying identified in [IMV94] have bounded intricacy. Our proofs of these results rely crucially on the results in <ref> [DP88, IMV94] </ref>. For disjunctive logic programming [LJR92], we identify a new family of tractable programs based on bounded intricacy criterion. <p> value of x, and it considers only those constraints all of whose variables are from the set parents (x)[fxg. (Note that since only constraints involving parents (x) are added to the new network, the sets parents (y) do not change for y = x or nodes y examined before x.) <ref> [DP88] </ref> proves that the network C is unsatisfiable iff there is a node x such that all valuations over parents (x) are ruled out during the call to Consistency (x; parents (x)). Otherwise, the output network is backtrack-free. <p> A class of binary networks with bounded functional width is then shown to have bounded intricacy, and thus tractable. As with bounded induced width, the proof of this claim is also based on the correctness of the Adaptive-Consistency algorithm <ref> [DP88] </ref>. An important difference is that rather than using all the variables of a valuation ruled out by Adaptive-Consistency in constructing the constraint clause in the fixpoint, only the variables in its seed are needed. <p> We now present a class of non-functional binary networks with bounded functional width but unbounded induced width. Thus, it will follow from from Theorem 5.15 that this class is tractable; however, this tractability claim does not follow from the results in <ref> [DP88] </ref> and [DH91]. This class generalizes the example network C3 given earlier in this section to more than 3 nodes, and adds similar networks that are inconsistent.
Reference: [DP91] <author> J. Doyle and R. Patil. </author> <title> Two theses of knowledge representation: language restrictions, taxanomic classification, and the utility of representation services. </title> <journal> Artificial Intelligence, </journal> <volume> 48(3) </volume> <pages> 261-297, </pages> <year> 1991. </year>
Reference-contexts: In other words, Tell and Ask operations should be tractable, which is usually taken to mean that they be in PTIME [GJ79, Yas94]. On the other hand, the language (s) of KR systems should be expressive enough to represent the rich variety of knowledge used in any intelligent activity <ref> [DP91] </ref>. Not unexpectedly, there is a tradeoff between the expressiveness of a KR system and the tractability of its services | increasing the expressiveness generally decreases the tractability [LB85]. <p> The problem with this approach is that such KR systems are generally too weak to deal with most applications <ref> [DP91] </ref>. 2. Provide a fast, but incomplete (or possibly even unsound), reasoner for the KR system. An incomplete reasoner may fail to infer some information warranted by the underlying logic, while an unsound 1 reasoner may infer information that is not warranted by the underlying logic.
Reference: [Fit90] <author> M. </author> <title> Fitting. First-order logic and automated theorem proving. Texts and monographs in computer science. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: Generalized connectives, which allow any number of arguments <ref> [Fit90] </ref>, are used because facts inferred using FP will depend on the grouping of the formulas, which are always in negation normal form. <p> Note: The logical constants t and f are not considered to be literals. Formulas are usually built from atoms using some fixed set of connectives. Our formulas are constructed from literals using only the connectives conjunction (^) and disjunction (_). Following <ref> [Fit90] </ref>, we allow any number of arguments for these connectives. This allows more flexibility in specifying formulas, since facts inferred from a formula using FP will depend on how its components are grouped with respect to these connectives. <p> It presents a new tool for proving that a family of problems arising in some application is tractable. 154 Appendix A Axiomatic Proof Theory for PCE An axiomatization of PCE is obtained in the usual way by adding the propositional variants of reflexivity and substitutivity axioms for equality <ref> [Fit90] </ref> to an axiomatization of PC [Men64]. For the purpose of this axiomatization alone, we use the abbreviation ! ' to denote the formula _ (~ ; ').
Reference: [Fre78] <author> E.C. Freuder. </author> <title> Synthesizing constraint expressions. </title> <journal> Communications of the ACM, </journal> <volume> 21(11) </volume> <pages> 958-966, </pages> <year> 1978. </year>
Reference-contexts: Many important problems in AI and Computer Science can be viewed as special cases of constraint satisfaction | for example, map-coloring, scheduling, temporal reasoning, circuit design, and diagnostic reasoning (see [Kum92] for references and more examples). A CSP <ref> [Mac77, Fre78] </ref> is specified by a finite set of "variables" and a set of constraints on subsets of these variables. <p> A CSP is said to be consistent iff there is an assignment of a value to each variable such that all the constraints are satisfied; such an assignment is called a solution of the CSP. Determining consistency is known to be CoNP-Complete <ref> [Fre78] </ref> even for constraint networks, a restricted class of CSPs in which all the constraints are either unary or binary, and are explicitly provided as sets of tuples. Constraint networks are often represented by a graph whose nodes represent variables and unary constraints, and whose arcs represent binary constraints. <p> and disjunctive logic programs. 122 ------------------------------------------------------ A A A A A A (3,9)g f (1,7), f (1,4), (4,9), f (4,7), f1,3g A - - - A A A A A f (4,7), f (1,7), f (1,4)g f1g A ------------------------------------------------------ 5.4 Constraint Satisfaction Problems 5.4.1 Overview A constraint satisfaction problem (CSP) <ref> [Mac77, Fre78] </ref> is specified by a finite set of variables and a set of constraints on subsets of these variables limiting the values they can take. For example, a constraint might restrict the value of a variable to be greater than that of another variable. <p> A CSP is said to be consistent iff there is an assignment of a value to each variable such that all the constraints are satisfied. Determining consistency is known to be intractable <ref> [Fre78] </ref> even for constraint networks, a restricted class of CSPs in which all the constraints are explicitly provided as sets of tuples. Identifying classes of constraint networks for which consistency is provably tractable has generated considerable interest (c.f. [Fre82, DP87, DH91]).
Reference: [Fre82] <author> E.C. Freuder. </author> <title> A sufficient condition for backtract-free search. </title> <journal> Journal of the ACM, </journal> <volume> 29(1) </volume> <pages> 24-32, </pages> <month> January </month> <year> 1982. </year> <month> 176 </month>
Reference-contexts: Determining consistency is known to be intractable [Fre78] even for constraint networks, a restricted class of CSPs in which all the constraints are explicitly provided as sets of tuples. Identifying classes of constraint networks for which consistency is provably tractable has generated considerable interest (c.f. <ref> [Fre82, DP87, DH91] </ref>). In this section, we present a quadratic-time translation of constraint networks to a restricted class of theories in PC (i.e., PCE without equality), called constraint theories. <p> It follows from the results of previous sections that the consistency problem is tractable for classes of constraint theories with bounded intricacy. We show that some tractable classes of constraint networks previously identified, for example, in <ref> [Fre82, DP87, DH91] </ref>, translate to classes of constraint theories with bounded intricacy. We also use this criterion to describe a new, more inclusive tractable class of constraint networks. Since the rewrite system FPE is identical to FP for PCE without equality, we use FP in this section. <p> A class C of binary constraint networks is tractable iff the consistency problem for C is in PTIME. Since the consistency problem for the class of all binary constraint networks is CoNP-Complete [Mac87], identifying classes of constraint networks for which consistency is provably tractable has generated considerable interest (c.f. <ref> [Fre82, DP87, DH91] </ref>). Most techniques to identify tractable families of CSP rely on the topology of the underlying constraint network. For example, Freuder [Fre82, Fre85] observed that CSPs whose networks are trees can be solved in linear time. <p> Most techniques to identify tractable families of CSP rely on the topology of the underlying constraint network. For example, Freuder <ref> [Fre82, Fre85] </ref> observed that CSPs whose networks are trees can be solved in linear time. <p> Thus, this transformation is not at all conducive for reasoning with clausal BCP. 157 Appendix C Local Consistency in CSP Approximate methods to determine all solutions of a constraint network strengthen the constraints to obtain an equivalent network such that some local consistency criteria are satisfied <ref> [Fre82] </ref>. We show that this processing of networks is closely related to our notion of vivification of constraint theories, as defined in Section 4.4. Definition C.1 [from [Fre82]] For any k 2 N , a constraint network C is said to be k-consistent iff for any set of k 1 variables <p> determine all solutions of a constraint network strengthen the constraints to obtain an equivalent network such that some local consistency criteria are satisfied <ref> [Fre82] </ref>. We show that this processing of networks is closely related to our notion of vivification of constraint theories, as defined in Section 4.4. Definition C.1 [from [Fre82]] For any k 2 N , a constraint network C is said to be k-consistent iff for any set of k 1 variables along with values for each that satisfy all the constraints among them, there exists a value for any kth variable such that the the k values together <p> A theory is strong k-consistent with respect to iff it is j-consistent with respect to for each j k. Notice that we are dealing with three (different but related) notions of k-consistency in this section. First is k-consistency for constraint networks as defined in <ref> [Fre82] </ref>, second is k-consistency for logical theories, as defined in Section 5.3, and the third is k-consistency of a constraint theory with respect to a local consistency criterion, as defined above.
Reference: [Fre85] <author> E.C. Freuder. </author> <title> A sufficient condition for backtract-bounded search. </title> <journal> Journal of the ACM, </journal> <volume> 32(4):755--761, </volume> <month> october </month> <year> 1985. </year>
Reference-contexts: Most techniques to identify tractable families of CSP rely on the topology of the underlying constraint network. For example, Freuder <ref> [Fre82, Fre85] </ref> observed that CSPs whose networks are trees can be solved in linear time. <p> is said to be functional iff for each value in c (x), there is at most one value in c (y) (and vice versa) that satisfies the constraint. [DH91] presents a quadratic-time algorithm for determining consistency of binary networks where all the constraints are functional. (The algorithm also performs "arc-consistency" <ref> [Fre85] </ref> for consistent networks in this class.) An example of a network in this class can be obtained from the network of Figure 5.2 by removing the tuple (1; 8) from the constraint c (A; C), and the tuples (4; 7) and (4; 8) from the constraint c (B; C). 5.4.3
Reference: [Fri87] <author> A.M. Frisch. </author> <title> Inference without chaining. </title> <booktitle> In Proceedings Tenth International Joint Conference on Artificial Intelligence (IJCAI-87), </booktitle> <pages> pages 515-519, </pages> <year> 1987. </year>
Reference-contexts: Typical examples of this approach include Boolean Constraint Propagation (BCP) [McA80, McA90] (a variant of unit resolution [CL73]) and tautological entailment <ref> [Bel77, Lev84b, Fri87] </ref>, both of which are sound but incomplete. The general difficulty with this approach is in characterizing (preferably syntactically) the class of queries that will be answered correctly, or the degree of error in the possibly-incorrect answer. 3. <p> The entailment holds iff each clause in is a superclause of some clause in . Frisch <ref> [Fri87] </ref> presented a 3-valued model-theory for PC, whose entailment relation, j= RP , is strictly stronger than j= B but strictly weaker than j=. For the CNF case, he proved that j= RP can also be determined in O (jj j j) time. <p> For example, j= RP (P _ :P ) but 6j= B (P _ :P ). Since j= RP iff is a tautology iff : is unsatisfiable <ref> [Fri87] </ref>, it then follows that j= RP is intractable, in general (specially when is in disjunctive normal form). Since none of the entailment relations ` FPE k is complete, it follows that j= RP in not weaker than any of them. <p> If we restrict our attention to CNF theories and formulas for which both j= B and j= RP are tractable, it follows from the RP-decision theorem for facts <ref> [Fri87] </ref> and the semantics of conjunction that j= RP iff each either clause in is a superclause of some clause in or has complimentary literals. In either of these cases, ` FPE , because of properties C, D, and E of FP.
Reference: [GJ79] <author> M. Garey and D. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <editor> Freeman, W. H., </editor> <address> NY, </address> <year> 1979. </year>
Reference-contexts: In other words, Tell and Ask operations should be tractable, which is usually taken to mean that they be in PTIME <ref> [GJ79, Yas94] </ref>. On the other hand, the language (s) of KR systems should be expressive enough to represent the rich variety of knowledge used in any intelligent activity [DP91]. <p> We start with an widely used exemplar of the second approach: (Clausal) BCP is an efficient (linear-time) reasoning method (i.e., reasoner) for answering clausal propositional queries posed to a KR system that is told clausal propositional information, a problem which is known to be NP-Complete <ref> [GJ79, Yas94] </ref>. BCP is sound (i.e., logically correct) and incomplete (i.e., does not answer all queries). However, none of its previously-proposed extensions to the non-clausal case are known to be tractable (i.e., provably in PTIME).
Reference: [GS88] <author> G. Gallo and M.G. Scutella. </author> <title> Polynomially solvable satisfiability problems. </title> <journal> Information Processing Letters, </journal> <volume> 29 </volume> <pages> 221-227, </pages> <year> 1988. </year>
Reference-contexts: An extension to the incomplete/unsound approach employs a family of incomplete/unsound reasoners, which differ in their correctness and complexity of reasoning. For any given task, an appropriate rea-soner is selected, based on the specific requirements of the task. Typical examples of this approach include the hierarchy of satisfiability problems <ref> [GS88] </ref> and the family of approximate entailments [CS92a]. In addition to the difficulty in characterizing queries that will be answered correctly by the various reasoners in the family, this approach presents issues concerning the reuse of earlier computation when different reasoners from the family are used. 4. <p> They could also be used for providing a quick "first cut" to a problem, which can be later improved. Although families of increasingly-complete tractable reasoners were previously-known for the clausal case (c.f. <ref> [GS88, CS92a] </ref>), we do not know of any other such family of reasoners for arbitrary propositional theories. Our technique for generating these reasoners is based on restricting the length of the clauses used in chaining (i.e., Modus Ponens). <p> Hence, the R-intricacy of any theory is the least k for which ` R k is complete. Some other families of increasingly complete consequence relations have been previously proposed (c.f. [CS92b, CK91]). Another such family can also be directly obtained from the tractable satisfiability classes proposed in <ref> [GS88] </ref>. We will compare our family ` FPE k with these. We continue to use R to refer to any admissible rewrite system. 4.5.1 A Complete Consequence Relation For any admissible rewrite system R, the consequence relation ` R is sound but may be incomplete. <p> Thus, for each number k there is a set S of size k + 2 such that j= 3 S is not weaker than ` FPE k . Thus, the two families of entailments are incomparable. Bounded Resolution Gallo and Scutella <ref> [GS88] </ref> built a hierarchy, = 0 ; 1 ; : : : ; of classes of theories in PC, such that for each k ; the satisfiability problem is solvable in O (n k+1 ) time, where n is the size of the theory. <p> Extending FP, we developed a family of increasingly-complete tractable reasoners which could be used for specifying the partial answers of an anytime reasoner. Although families of increasingly-complete tractable reasoners were previously known for the clausal case (c.f. <ref> [GS88, CS92a] </ref>), we know of no other such family of reasoners for arbitrary propositional theories. Our technique for generating these reasoners is based on restricting the length of the clauses used in chaining (i.e., Modus Ponens).
Reference: [GTT92] <author> T. Griffin, H. Trickey, and C. Tuckey. </author> <title> Update constraints for relational databases. </title> <type> unpublished draft, </type> <year> 1992. </year>
Reference-contexts: However, none of its previously-proposed extensions to the non-clausal case are known to be tractable (i.e., provably in PTIME). There are many applications where reasoning with non-clausal theories is required, for example, in verifying automatically generated update constraints <ref> [GTT92] </ref> and in the applications of logical "Truth Maintenance Systems" (TMS) [de 90, McA90, Mar91]. We develop fact propagation (FP), which tractably extends BCP to non-clausal theories. We present a quadratic-time algorithm for FP, which runs in linear time for clausal theories.
Reference: [Hue80] <author> G. Huet. </author> <title> Confluent reductions: abstract properties and applications to term rewriting systems. </title> <journal> Journal of the ACM, </journal> <volume> 27(4) </volume> <pages> 797-821, </pages> <year> 1980. </year>
Reference-contexts: We will use "finite PC" to denote PC restricted to finite theories. It follows that finite PC is a syntactic variant of PCE without equality. 2.4 Rewrite Systems for PCE We present a variant notion of rewrite systems <ref> [DJ90, KB70, Hue80, Der89] </ref> applicable to theories in PCE, in which groups of rewrite rules are represented by rule schemas that contain meta-variables. These rewrite systems will be used to rewrite theories into logically equivalent theories that are syntactically simpler, based on a measure of simplicity defined in this section.
Reference: [IL82] <author> T. Imielinski and W. Lipski. </author> <title> A systematic approach to relational database theory. </title> <booktitle> In SIGMOD, </booktitle> <year> 1982. </year>
Reference-contexts: A variant of the incomplete/unsound approach is to explicitly approximate the knowledge told to the KB, and/or the queries asked of it, into some other language for which the reasoning is tractable. As in the work on null values in databases <ref> [IL82] </ref>, domain abstraction [Imi87], and knowledge compilation [SK91, BE89], the idea in this approach is to "bound" the error by reporting possibly more than one answer. Note that this approach relies on finding tractable languages to which the formulas are approximated.
Reference: [Imi87] <author> T. Imielinski. </author> <title> Domain abstraction and limited reasoning. </title> <booktitle> In Proceedings Tenth International Joint Conference on Artificial Intelligence (IJCAI-87), </booktitle> <pages> pages 997-1003, </pages> <address> Milan, </address> <year> 1987. </year>
Reference-contexts: A variant of the incomplete/unsound approach is to explicitly approximate the knowledge told to the KB, and/or the queries asked of it, into some other language for which the reasoning is tractable. As in the work on null values in databases [IL82], domain abstraction <ref> [Imi87] </ref>, and knowledge compilation [SK91, BE89], the idea in this approach is to "bound" the error by reporting possibly more than one answer. Note that this approach relies on finding tractable languages to which the formulas are approximated.
Reference: [IMV94] <author> T. Imielinski, R. v. d. Meyden, and K. V. Vadaparty. </author> <title> Complexity tailored design: A new design methodology for databases with incomplete information. </title> <note> To appear in Journal of Computer and System Sciences (A preliminary version appeared in PODS-89), </note> <year> 1994. </year>
Reference-contexts: We then show that some tractable classes already presented in the literature do have bounded intricacy. These include tractable classes of OR-databases <ref> [IMV94] </ref> and CSPs [DP88, DH91]. We also describe some new tractable classes using the bounded intricacy criterion. These include the first non-obvious tractable class in disjunctive logic programs [LJR92], and a new tractable family of classes in CSP. <p> We then present a new family of tractable networks based on bounded intricacy that combines the intuitions behind bounded induced-width and functional constraints. For disjunctive databases, we show that the translations of each tractable class of querying identified in <ref> [IMV94] </ref> have bounded intricacy. Our proofs of these results rely crucially on the results in [DP88, IMV94]. For disjunctive logic programming [LJR92], we identify a new family of tractable programs based on bounded intricacy criterion. <p> For disjunctive databases, we show that the translations of each tractable class of querying identified in [IMV94] have bounded intricacy. Our proofs of these results rely crucially on the results in <ref> [DP88, IMV94] </ref>. For disjunctive logic programming [LJR92], we identify a new family of tractable programs based on bounded intricacy criterion. <p> above tractable class together show that the new tractable classes, which are based on bounded functional width, strictly subsume those based on bounded induced width and those based on functional constraints. 139 5.5 Databases with Disjunctive Information OR-databases extend the relational data model by allowing explicit representation of disjunctive information <ref> [IMV94] </ref>: tuples in a relation contain either ordinary constants or so-called OR-objects, each of which is associated with a set of constants, called its domain; an Or-object intuitively represents the potential values that may appear in that position. <p> Each OR-database therefore can be thought of as representing many relational databases, obtained by replacing every OR-object by some value in its domain. In <ref> [IMV94] </ref>, as part of the database schema, one can impose some restrictions on the occurrence of OR-objects; for example one can restrict attention to the repeated occurrences or the columns of the relations in which they can appear. <p> A query is said to be true in an OR-database iff it is true in all the possible relational databases associated with it. Although querying OR-databases is intractable in general, <ref> [IMV94] </ref> identifies maximal conditions for tractable querying for several kinds of schemata. These conditions are based on syntactic features of the queries, which can be tested efficiently. <p> In this section, we first reduce the querying problem to the (un)satisfiability problem in PCE by translating each instance of querying to a theory in PCE. We then show that the translations of each tractable class of querying identified in <ref> [IMV94] </ref> have bounded intricacy. Our proof for this relies crucially on the results of [IMV94]. Also, since intricacy is only a sufficient condition for tractability, we cannot use it to show that these classes are maximal classes for tractable querying. <p> We then show that the translations of each tractable class of querying identified in <ref> [IMV94] </ref> have bounded intricacy. Our proof for this relies crucially on the results of [IMV94]. Also, since intricacy is only a sufficient condition for tractability, we cannot use it to show that these classes are maximal classes for tractable querying. It turns out that the precise definitions of the tractable classes of queries given in [IMV94] are not used in our proofs. <p> proof for this relies crucially on the results of <ref> [IMV94] </ref>. Also, since intricacy is only a sufficient condition for tractability, we cannot use it to show that these classes are maximal classes for tractable querying. It turns out that the precise definitions of the tractable classes of queries given in [IMV94] are not used in our proofs. It suffices for our purposes that the tractable algorithms of [IMV94] are correct for these classes. Since the precise definitions are also technically quite involved, we do not reproduce them here. The interested reader may refer to [IMV94]. 5.5.1 Terminology and Notation In this <p> It turns out that the precise definitions of the tractable classes of queries given in <ref> [IMV94] </ref> are not used in our proofs. It suffices for our purposes that the tractable algorithms of [IMV94] are correct for these classes. Since the precise definitions are also technically quite involved, we do not reproduce them here. The interested reader may refer to [IMV94]. 5.5.1 Terminology and Notation In this section, we start by using full first-order predicate calculus in order to describe the problem of querying <p> tractable classes of queries given in <ref> [IMV94] </ref> are not used in our proofs. It suffices for our purposes that the tractable algorithms of [IMV94] are correct for these classes. Since the precise definitions are also technically quite involved, we do not reproduce them here. The interested reader may refer to [IMV94]. 5.5.1 Terminology and Notation In this section, we start by using full first-order predicate calculus in order to describe the problem of querying databases. <p> Upper-case letters are used to denote corresponding sets of objects; for example, O denotes a set of OR-objects. The following definitions concerning OR-databases are mostly taken from <ref> [IMV94] </ref>. <p> such instance is a usual relational database. 5 In using the tuple notation, we always implicitly assume that the lengths are consistent; for example, the number of symbols in ~u must be equal to the arity of predicate P in the expression P (~u). 6 These are called models in <ref> [IMV94] </ref>. 140 Similarly, ~u denotes the result of substituting (o) for each occurrence of an OR-object o in the tuple ~u of constants and OR-objects. <p> We need an appro priate domain for generating the ground instances: 7 <ref> [IMV94] </ref> denotes such a literal by l P (~x; ~y). 8 This relation is denoted by j= in [IMV94]. "Satisfies" here should be taken in the relational database sense: the database yields a model for the query formula. 141 ------------------------------------------------------ 1 ff 1 1 3 ff 1 2 = 9x9y (P <p> We need an appro priate domain for generating the ground instances: 7 <ref> [IMV94] </ref> denotes such a literal by l P (~x; ~y). 8 This relation is denoted by j= in [IMV94]. "Satisfies" here should be taken in the relational database sense: the database yields a model for the query formula. 141 ------------------------------------------------------ 1 ff 1 1 3 ff 1 2 = 9x9y (P (x; y) ^ R (y; x)) query P (1; ff) R (1; 1) P (3; ff) R (1; <p> More generally, it can be seen that a tuple ~a of constants is an answer to query (~x) over database D iff Tr (D; ;~a) is unsatisfiable. 142 5.5.3 Tractable Algorithms for Querying We now review the tractable algorithms presented in <ref> [IMV94] </ref>. Our proofs will be based on the correctness of these algorithms. The recursive procedure EntailsI 9 is used for querying a Type I database D. EntailsI recursively evaluates a tractable proper query, (~x), by evaluating the subquery obtained by removing the first literal. <p> If o = ff, then for each d in Dom (o) = f1; 2g, there is a tuple h1; ffi in P and constant b = 1 such that tuple 9 The exact names of the algorithms and their exact steps differ from those in <ref> [IMV94] </ref>, since they use the same name for more than one algorithm, and the notation is somewhat different. The essential ideas, however, remain the same. 143 h1; di is in A 2 . Thus, the query is answered "yes". <p> The algorithm returns "yes" iff the domain of some OR-object becomes empty in this process. 5.5.4 Describing Tractable Queries Using Intricacy We will show that the translations of the tractable cases identified in <ref> [IMV94] </ref> produce classes of theories with bounded intricacy. We will prove our claim for each of the three types of databases by induction on the length of the queries. Our proofs will be based on the correctness of the algorithms presented in [IMV94], which are reviewed in Section 5.5.3, for answering <p> the translations of the tractable cases identified in <ref> [IMV94] </ref> produce classes of theories with bounded intricacy. We will prove our claim for each of the three types of databases by induction on the length of the queries. Our proofs will be based on the correctness of the algorithms presented in [IMV94], which are reviewed in Section 5.5.3, for answering the tractable queries. The basic idea is to show that any tuple is in the answer set for a database iff the translated theory is not k-consistent, where k is a fixed number determined by the query. <p> Since the translated theory is unsatisfiable iff the tuple is in the answer set, we will obtain the desired result, i.e., the intricacy of each unsatisfiable theory is at most k. Our proofs of non k-consistency will essentially "simulate" the algorithms of <ref> [IMV94] </ref>, in the sense that queries will be recursively decomposed in the same way as in the algorithms. There are two intermediate lemmas. <p> The next three propositions prove our claim for type I, II, and III databases, respectively. As remarked earlier, the precise definitions of the tractable classes of queries given in <ref> [IMV94] </ref> are not used in our proofs. It suffices for our purposes that the tractable algorithms of [IMV94] are correct for these classes. <p> The next three propositions prove our claim for type I, II, and III databases, respectively. As remarked earlier, the precise definitions of the tractable classes of queries given in <ref> [IMV94] </ref> are not used in our proofs. It suffices for our purposes that the tractable algorithms of [IMV94] are correct for these classes. Proposition 5.18 For any type I database D, any tractable proper query (~x), and any tuple ~a of constants: ~a 2 (D) iff Tr (D; ; ~a) is not k-consistent, where k is the number of OR-arguments in the query. <p> Using Lemma 5.16, we obtain Tr (D; ;~a) is not p-consistent, where p is the number of OR-objects in ~u. Since p k, we obtain from Proposition 4.12 that Tr (D; ;~a) is not k-consistent. (inductive case, n &gt; 1): It follows from Lemma 4.1 of <ref> [IMV94] </ref> that the query is of the form (~x 1 ; ~x 2 ; ~x 3 ) = 9~y 1 ; ~y 2 P (~x 1 ; ~x 2 ; ~y 1 ; ~y 2 ) ^ 1 (~x 2 ; ~x 3 ; ~y 2 ), where the inductive conditions <p> Suppose ~a = ~a 1 ~a 2 ~a 3 2 (D). We obtain from EntailsI of <ref> [IMV94] </ref> that there is a tuple ~u 1 ~u 2 of constants and OR-objects such that for any valuation of OR-objects in ~u 1 ~u 2 , we have P (~a 1 ; ~a 2 ; ~u 1 ; ~u 2 ) 2 D and ~a 2 ~a 3 ~u 2 <p> Proof: The proof of Proposition 5.18 will work for this proposition as well, though it will use EntailsII instead of EntailsI and Lemma 5.4 instead of Lemma 4.1 of <ref> [IMV94] </ref>. In the base case, when the query (~x) is 10 Though EntailsI uses a stronger condition, in which each P (~a 1 ;~a 2 ; ~u 1 ; ~u 2 ) should come from the same tuple in the database D, the weaker version suffices for our proof. <p> We now prove the claim for type III databases, based on the correctness of the algorithm EntailsIII 0 (the modified version of the algorithm given in Figure 5 of <ref> [IMV94] </ref>) of Section 5.5.3. The basic idea in our proof is to show that each value removed from a domain forces the corresponding literal in the fixpoint. <p> We obtain from EntailsIII 0 that there is a tuple ~u of constants and OR-objects such that P (~a~u) 2 D, and ~x; ~y unifies with ~a~u. For the inductive case (n &gt; 0), it follows from Lemma 5.4 <ref> [IMV94] </ref> that the query (~x) is of the form (~x 1 ; ~x 2 ; ~x 3 ) = 9~y 1 ; ~y 2 P (~x 1 ; ~x 2 ; ~y 1 ; ~y 2 ) ^ 1 (~x 2 ; ~x 3 ; ~y 2 ), where the inductive <p> The bound on the intricacy in each case is the number of OR-arguments in the query . 147 Since the syntactic criteria of <ref> [IMV94] </ref> provide a complete characterization of tractable queries, it follows that bounded intricacy also provides a complete characterization of these tractable queries: a proper closed query is tractable with respect to a schema S ( is also required to be normal if S is of type II or III) iff there <p> Note that our proofs rely crucially on the results in <ref> [IMV94] </ref>. Moreover, the characterization of tractable queries in [IMV94] is syntactic and can be checked very efficiently, while determining intricacy of any given theory is not known to be an easy problem. <p> Note that our proofs rely crucially on the results in <ref> [IMV94] </ref>. Moreover, the characterization of tractable queries in [IMV94] is syntactic and can be checked very efficiently, while determining intricacy of any given theory is not known to be an easy problem. However, we have shown that our notion of "bounded intricacy" does cover exactly all the tractable closed proper queries for the OR-databases considered in [IMV94]. 5.6 Disjunctive <p> queries in <ref> [IMV94] </ref> is syntactic and can be checked very efficiently, while determining intricacy of any given theory is not known to be an easy problem. However, we have shown that our notion of "bounded intricacy" does cover exactly all the tractable closed proper queries for the OR-databases considered in [IMV94]. 5.6 Disjunctive Logic Programming For our purposes, a disjunctive logic program (DLP) [LJR92] is a basic clausal theory in PC, without the equality predicate : =. A class of DLP is tractable iff the satisfiability problem for it is tractable.
Reference: [KB70] <author> D.E. Knuth and P. E. Bendix. </author> <title> Simple word problems in universal algebras. </title> <editor> In J. Leech, editor, </editor> <booktitle> Computational problems in abstract algebra, </booktitle> <pages> pages 263-297. </pages> <publisher> Pergamon Press, </publisher> <year> 1970. </year>
Reference-contexts: Termination, which ensures that every sequence of rule applications terminates, allows us to prove confluence using the Knuth-Bendix approach <ref> [KB70] </ref> and helps us in developing the tractable algorithm. Modularity, which ensures that parts of a theory are independently rewritable before rewriting the entire theory, is useful 1 The actual measure of simplicity is formally presented in Definition 2.18. 8 for knowledge bases that are built incrementally. <p> We will use "finite PC" to denote PC restricted to finite theories. It follows that finite PC is a syntactic variant of PCE without equality. 2.4 Rewrite Systems for PCE We present a variant notion of rewrite systems <ref> [DJ90, KB70, Hue80, Der89] </ref> applicable to theories in PCE, in which groups of rewrite rules are represented by rule schemas that contain meta-variables. These rewrite systems will be used to rewrite theories into logically equivalent theories that are syntactically simpler, based on a measure of simplicity defined in this section. <p> Thus, each term can be reduced by using a terminating rewrite system to a normal form in a finite number of rewriting steps. Consequently, any process based on a terminating rewrite system always terminates. Proving confluence for terminating systems, which is usually done using an approach first presented in <ref> [KB70] </ref>, is easier than for non-terminating systems. Formally, a rewrite system R is terminating if there is no infinite chain t 1 ) R t 2 ) R : : : of terms. A rewrite system R is convergent if it is both confluent and terminating. <p> Since the ordering among terms does not depend on the ordering of arguments, &gt; is compatible with respect to equality. 21 Proving Confluence A terminating rewrite system can be proved confluent using the approach first presented in <ref> [KB70] </ref>. <p> l 2 is a subterm of l 1 at some position , then there is some r such that r 1 ) fl R r and l 1 [r 2 l 2 ] ) fl The significance of this definition becomes evident in the following result: Lemma 2.7 (based on <ref> [KB70] </ref>) A terminating rewrite system R is confluent if each pair of rule instances in R is confluent. Proof: Any terminating rewrite system R is confluent iff it is locally confluent [New42]. Hence, it suffices to prove local confluence. <p> We also have to verify that instances of R 1 are confluent with those of R 1 itself. (The reader is cautioned that there are two differences from the approach in <ref> [KB70] </ref>: we cannot ignore all "variable overlaps", and we will use various techniques to reduce the cases of non-variable overlap to be considered.) We have been and will continue to treat rule schemas by taking prototypical instances of them, and seeing how they can overlap (remembering the conditions imposed on the <p> In the example given earlier, s 2 is indeed a variable overlap. Typically, in rewrite systems <ref> [KB70] </ref> variable overlaps are ignored while proving confluence, since the two rules can be interchanged to obtain the same common term (as illustrated by s 2 ). <p> It would be useful to develop a systematic approach for generating and selecting among these admissible rewrite systems, possibly in a task-specific way. A possible approach might be in the style of the automated completion algorithm of Knuth and Bendix <ref> [KB70] </ref> which systematically adds rewrite rules for obtaining confluent rewrite systems. Efficient Vivification and Reasoning: We introduced a transformation (Viv) on theories that makes them vivid, i.e., converts them into logically equivalent theories for which an efficient refutation-reasoner based on FP is complete in inferring clauses.
Reference: [Kum92] <author> V. Kumar. </author> <title> Algorithms for constraint satisfaction problems: A survey. </title> <journal> AI Magazine, </journal> <volume> 13(1) </volume> <pages> 32-44, </pages> <year> 1992. </year>
Reference-contexts: CSPs deal with assigning values to variables so that some given constraints are satisfied. Many important problems in AI and Computer Science can be viewed as special cases of constraint satisfaction | for example, map-coloring, scheduling, temporal reasoning, circuit design, and diagnostic reasoning (see <ref> [Kum92] </ref> for references and more examples). A CSP [Mac77, Fre78] is specified by a finite set of "variables" and a set of constraints on subsets of these variables.
Reference: [LB85] <author> H.J. Levesque and R.J. Brachman. </author> <title> A fundamental tradeoff in knowledge representation and reasoning (revised version). </title> <editor> In R.J. Brachman and H.J. Levesque, editors, </editor> <booktitle> Readings in Knowledge Representation, </booktitle> <pages> pages 41-70. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, California, </address> <year> 1985. </year>
Reference-contexts: Not unexpectedly, there is a tradeoff between the expressiveness of a KR system and the tractability of its services | increasing the expressiveness generally decreases the tractability <ref> [LB85] </ref>. Studying ways to make this tradeoff between expressiveness and tractability, also known as the intractability problem, is a central focus of research in KR. There are several general approaches to the intractability problem (c.f. [Cra92]): 1.
Reference: [Lev84a] <author> H.J. Levesque. </author> <title> Foundations of a functional approach to knowledge representation. </title> <journal> Artificial Intelligence, </journal> <volume> 23(2) </volume> <pages> 155-212, </pages> <year> 1984. </year>
Reference-contexts: The field of Knowledge Representation and Reasoning (KR) deals with building and studying systems, known as KR systems, that represent knowledge and draw conclusions from it. KR systems are often used as embedded utilities or subsystems providing computational services. Levesque <ref> [Lev84a] </ref> has characterized a KR system as an abstract server supporting two kinds of operations: Telling the system some additional information (in some restricted formal language L T ell ), and Asking it queries (in some, possibly different, language L Ask ).
Reference: [Lev84b] <author> H.J. Levesque. </author> <title> A logic of implicit and explicit belief. </title> <booktitle> Proceedings National Conference on Artificial Intelligence (AAAI-84), </booktitle> <pages> pages 198-202, </pages> <year> 1984. </year>
Reference-contexts: Typical examples of this approach include Boolean Constraint Propagation (BCP) [McA80, McA90] (a variant of unit resolution [CL73]) and tautological entailment <ref> [Bel77, Lev84b, Fri87] </ref>, both of which are sound but incomplete. The general difficulty with this approach is in characterizing (preferably syntactically) the class of queries that will be answered correctly, or the degree of error in the possibly-incorrect answer. 3. <p> It also allows inferring clauses from their subclauses; for example, f (P _Q)g j= B (P _Q_R). However, relevance logic blocks chaining; for example, fP; :P _ Qg 6j= B Q. Levesque <ref> [Lev84b] </ref> presented a logic of implicit and explicit beliefs, where explicit beliefs are obtained using the j= B entailment, and proved that j= B can be determined in O (jj j j) time, if the theory and the formula are both in CNF.
Reference: [Lev86] <author> H.J. Levesque. </author> <title> Making believers out of computers. </title> <journal> Artificial Intelligence, </journal> <volume> 30 </volume> <pages> 81-108, </pages> <year> 1986. </year>
Reference-contexts: Developing appropriate notions of vividness and techniques for compiling theories into vivid theories has already generated considerable interest in the KR community (c.f. <ref> [Lev86, Dav91] </ref>). Our final contribution is to the description of tractable cases of reasoning (the first approach to intractability). <p> We first define ` F P , a refutation reasoner based on FP. We identify some restricted cases in which it is complete, for example, for reasoning with Horn clauses. Any theory for which ` F P is complete for inferring clauses is called vivid, a term inspired by <ref> [Lev86] </ref>, where vivid theories are ones where an answer can be "read off" quickly. By adding some inference rules, which allow chaining on previously inferred formulas, we extend ` F P to a sound and complete reasoner. <p> Let us call vivid any theory for which ` FPE is complete for inferring clauses. The term "vivid" is inspired by <ref> [Lev86] </ref>, where vivid theories are ones where an answer can be "read off" quickly.
Reference: [LJR92] <author> J. Lobo, Minker J., and A. Rajasekar. </author> <title> Foundations of disjunctive logic programming. </title> <publisher> MIT Press, </publisher> <year> 1992. </year>
Reference-contexts: These include tractable classes of OR-databases [IMV94] and CSPs [DP88, DH91]. We also describe some new tractable classes using the bounded intricacy criterion. These include the first non-obvious tractable class in disjunctive logic programs <ref> [LJR92] </ref>, and a new tractable family of classes in CSP. <p> For disjunctive databases, we show that the translations of each tractable class of querying identified in [IMV94] have bounded intricacy. Our proofs of these results rely crucially on the results in [DP88, IMV94]. For disjunctive logic programming <ref> [LJR92] </ref>, we identify a new family of tractable programs based on bounded intricacy criterion. We show bounded intricacy for a class C of theories by proving that there is a number k such that f is in lfp (T R;;k ) for each unsatisfiable theory in C. <p> However, we have shown that our notion of "bounded intricacy" does cover exactly all the tractable closed proper queries for the OR-databases considered in [IMV94]. 5.6 Disjunctive Logic Programming For our purposes, a disjunctive logic program (DLP) <ref> [LJR92] </ref> is a basic clausal theory in PC, without the equality predicate : =. A class of DLP is tractable iff the satisfiability problem for it is tractable.
Reference: [Llo87] <author> J.W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> 2 edition, </address> <year> 1987. </year>
Reference-contexts: Since T R;;k is a monotonic operator over a finite lattice, it has a least fixpoint [Tar55], which can also be characterized using the ordinal powers of T R;;k , defined in the usual manner (c.f. <ref> [Llo87] </ref>): Definition 4.11 For any theory and any k 2 N , the ordinal powers of the operator T R;;k are defined as follows: T R;;k "0 = ; T R;;k "! = [fT R;;k "n j n 2 N g Using [Tar55], it follows from Lemma 4.11 that the least
Reference: [Mac77] <author> A. K. Macworth. </author> <title> Consistency in networks of relations. </title> <journal> Artificial Intelligence, </journal> <volume> 8(1) </volume> <pages> 99-118, </pages> <year> 1977. </year>
Reference-contexts: Many important problems in AI and Computer Science can be viewed as special cases of constraint satisfaction | for example, map-coloring, scheduling, temporal reasoning, circuit design, and diagnostic reasoning (see [Kum92] for references and more examples). A CSP <ref> [Mac77, Fre78] </ref> is specified by a finite set of "variables" and a set of constraints on subsets of these variables. <p> and disjunctive logic programs. 122 ------------------------------------------------------ A A A A A A (3,9)g f (1,7), f (1,4), (4,9), f (4,7), f1,3g A - - - A A A A A f (4,7), f (1,7), f (1,4)g f1g A ------------------------------------------------------ 5.4 Constraint Satisfaction Problems 5.4.1 Overview A constraint satisfaction problem (CSP) <ref> [Mac77, Fre78] </ref> is specified by a finite set of variables and a set of constraints on subsets of these variables limiting the values they can take. For example, a constraint might restrict the value of a variable to be greater than that of another variable.
Reference: [Mac87] <author> A.K. Mackworth. </author> <title> Constraint satisfaction. In S.C. </title> <editor> Shapiro, editor, </editor> <booktitle> Encyclopedia of AI, </booktitle> <pages> pages 205-211. </pages> <publisher> John Wiley and Sons, </publisher> <year> 1987. </year>
Reference-contexts: For a more detailed description, the interested reader is referred to <ref> [Mac87, Dec91, DH91] </ref>. <p> A class C of binary constraint networks is tractable iff the consistency problem for C is in PTIME. Since the consistency problem for the class of all binary constraint networks is CoNP-Complete <ref> [Mac87] </ref>, identifying classes of constraint networks for which consistency is provably tractable has generated considerable interest (c.f. [Fre82, DP87, DH91]). Most techniques to identify tractable families of CSP rely on the topology of the underlying constraint network.
Reference: [Mar91] <author> J. P. Martins. </author> <title> The truth, the whole truth, and nothing but the truth: An indexed bibliography to the literature of Truth Maintenance Systems. </title> <journal> The AI Magazine, </journal> <volume> 11(5) </volume> <pages> 7-25, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: However, none of its previously-proposed extensions to the non-clausal case are known to be tractable (i.e., provably in PTIME). There are many applications where reasoning with non-clausal theories is required, for example, in verifying automatically generated update constraints [GTT92] and in the applications of logical "Truth Maintenance Systems" (TMS) <ref> [de 90, McA90, Mar91] </ref>. We develop fact propagation (FP), which tractably extends BCP to non-clausal theories. We present a quadratic-time algorithm for FP, which runs in linear time for clausal theories. Moreover, FP is proved to be more complete than CNF-BCP, a previously-proposed extension of BCP to non-clausal theories.
Reference: [McA80] <author> D. McAllester. </author> <title> An outlook on truth maintenance. </title> <type> Memo 551, </type> <institution> MIT AI Lab, </institution> <month> August </month> <year> 1980. </year> <month> 177 </month>
Reference-contexts: An incomplete reasoner may fail to infer some information warranted by the underlying logic, while an unsound 1 reasoner may infer information that is not warranted by the underlying logic. Typical examples of this approach include Boolean Constraint Propagation (BCP) <ref> [McA80, McA90] </ref> (a variant of unit resolution [CL73]) and tautological entailment [Bel77, Lev84b, Fri87], both of which are sound but incomplete. <p> For clausal theories, this extension should have the same time complexity as BCP. BCP <ref> [McA80, McA90] </ref> is an efficient (linear time) but incomplete method for reasoning with finite clausal theories in propositional logic. For example, BCP transforms the theory fP; :Q; (:P _Q_R)g to fP; :Q; Rg. <p> In order to prove confluence, we will show that each pair of rules is confluent (Lemma 2.7). The number of pairs to be considered will be reduced using Propositions 2.9, 2.10, and 2.8. 2.5 BCP : Boolean Constraint Propagation We review variants of boolean constraint propagation (BCP) <ref> [McA80, McA90] </ref> that have been proposed in the literature. We show that some of them can be specified using simple rewrite systems. Recall that BCP is an incomplete method for simplifying finite clausal theories in propositional logic and for inferring facts entailed by a given theory. <p> The first rewrite rule ensures that HP is convergent. Note that once f is pebbled, all facts are derivable. It then follows that the set of facts inferable from a theory using Horn Pebbling is exactly facts ( 0 ), where ) ! 2.5.2 Clausal BCP Clausal BCP <ref> [McA80] </ref> generalizes Horn Pebbling to any clausal theory. Its worst-case time complexity is the same as Horn Pebbling, i.e., O (n) when all the atoms are known a priori. <p> ) CBCP [[(:P ); (:Q); (:R); (Q _ R)]] (2nd rule ) ) CBCP [[(:P ); (:Q); (:R); (R)]] (2nd rule ) ) CBCP [[(:P ); (:Q); (:R); f]] (2nd rule, () = f ) ) CBCP [[f ]] (1st rule ) 2.5.3 Formula BCP and Prime BCP Formula BCP <ref> [McA80, McA90] </ref> extends Clausal BCP to any propositional theory. <p> We made contributions to three out of the four approaches listed in Chapter 1 for dealing with the intractability problem. In this chapter, we review our contributions, discuss the limitations of our approach, and suggest directions for future research 6.1 Contributions Boolean Constraint Propagation (BCP) <ref> [McA80, McA90] </ref> is widely used for linear-time but incomplete reasoning with clausal propositional theories. However, none of its extensions to the non-clausal case, that have been proposed previously, are known to be tractable (i.e., provably in PTIME). We developed fact propagation (FP), which tractably extends BCP to non-clausal theories.
Reference: [McA90] <author> D. McAllester. </author> <title> Truth maintenance. </title> <booktitle> In Proceedings Eight National Conference on Artificial Intelli--gence (AAAI-90), </booktitle> <pages> pages 1109-1116, </pages> <year> 1990. </year>
Reference-contexts: An incomplete reasoner may fail to infer some information warranted by the underlying logic, while an unsound 1 reasoner may infer information that is not warranted by the underlying logic. Typical examples of this approach include Boolean Constraint Propagation (BCP) <ref> [McA80, McA90] </ref> (a variant of unit resolution [CL73]) and tautological entailment [Bel77, Lev84b, Fri87], both of which are sound but incomplete. <p> However, none of its previously-proposed extensions to the non-clausal case are known to be tractable (i.e., provably in PTIME). There are many applications where reasoning with non-clausal theories is required, for example, in verifying automatically generated update constraints [GTT92] and in the applications of logical "Truth Maintenance Systems" (TMS) <ref> [de 90, McA90, Mar91] </ref>. We develop fact propagation (FP), which tractably extends BCP to non-clausal theories. We present a quadratic-time algorithm for FP, which runs in linear time for clausal theories. Moreover, FP is proved to be more complete than CNF-BCP, a previously-proposed extension of BCP to non-clausal theories. <p> For clausal theories, this extension should have the same time complexity as BCP. BCP <ref> [McA80, McA90] </ref> is an efficient (linear time) but incomplete method for reasoning with finite clausal theories in propositional logic. For example, BCP transforms the theory fP; :Q; (:P _Q_R)g to fP; :Q; Rg. <p> In order to prove confluence, we will show that each pair of rules is confluent (Lemma 2.7). The number of pairs to be considered will be reduced using Propositions 2.9, 2.10, and 2.8. 2.5 BCP : Boolean Constraint Propagation We review variants of boolean constraint propagation (BCP) <ref> [McA80, McA90] </ref> that have been proposed in the literature. We show that some of them can be specified using simple rewrite systems. Recall that BCP is an incomplete method for simplifying finite clausal theories in propositional logic and for inferring facts entailed by a given theory. <p> ) CBCP [[(:P ); (:Q); (:R); (Q _ R)]] (2nd rule ) ) CBCP [[(:P ); (:Q); (:R); (R)]] (2nd rule ) ) CBCP [[(:P ); (:Q); (:R); f]] (2nd rule, () = f ) ) CBCP [[f ]] (1st rule ) 2.5.3 Formula BCP and Prime BCP Formula BCP <ref> [McA80, McA90] </ref> extends Clausal BCP to any propositional theory. <p> We made contributions to three out of the four approaches listed in Chapter 1 for dealing with the intractability problem. In this chapter, we review our contributions, discuss the limitations of our approach, and suggest directions for future research 6.1 Contributions Boolean Constraint Propagation (BCP) <ref> [McA80, McA90] </ref> is widely used for linear-time but incomplete reasoning with clausal propositional theories. However, none of its extensions to the non-clausal case, that have been proposed previously, are known to be tractable (i.e., provably in PTIME). We developed fact propagation (FP), which tractably extends BCP to non-clausal theories.
Reference: [McC95] <author> T. McCarty. </author> <type> Personal Communication, </type> <year> 1995. </year>
Reference-contexts: Note that the exact details of the satisfiable theories in the class C 3 is not important | the only requirement is that the condition of Theorem 5.2 is violated, i.e., there is no number k which bounds the intricacy of all satisfiable theories in C 3 . McCarty <ref> [McC95] </ref> observed that theories in class C 3 can not be enumerated easily, since it contains all satisfiable theories and no unsatisfiable theory other than pigeon-hole theories.
Reference: [Men64] <author> E. Mendelson. </author> <title> Introduction to Mathematical Logic. </title> <publisher> Van Nostrand, </publisher> <address> Princeton, N.J., </address> <year> 1964. </year>
Reference-contexts: This relationship between the information told to the system and the answers to queries is usually specified by an entailment (logical consequence) relation in some formal logic. Thus, Tell and Ask operations implement some form of deductive reasoning. The logics most commonly used are first-order logic and propositional logic <ref> [Men64, Yas94] </ref>, since L T ell and L Ask are usually subsets of their underlying languages. It has been cogently argued [BFL83] that for the computational services of a KR system to be dependable, their worst-case time requirements should be small enough to allow adequate response in all critical situations. <p> The cardinality jSj of any set, bag, or tuple S is the number of elements (including duplicates) in S. 2.3 PCE : Propositional Calculus with Equality and Generalized Connectives We present a variant, PCE, of propositional calculus, PC <ref> [Men64] </ref>, which has equality as well as generalized conjunction and disjunction. Generalized connectives, which allow any number of arguments [Fit90], are used because facts inferred using FP will depend on the grouping of the formulas, which are always in negation normal form. <p> subclause of ' and there is no clause such that is a proper subclause of and is a proper subclause of '. 2.3.2 Semantics A model-theoretic semantics for the propositional language PCE is obtained in the usual way by mapping the atoms to the truth values true and f alse <ref> [Men64] </ref>, with the additional requirement that each mapping be consistent with equality. Thus, we avoid the additional machinery of defining domains and mapping the constants of PCE to objects in a domain. <p> In this section, we presented a sound and incomplete inference technique. In later sections, we will present other sound inference techniques. 14 2.3.5 Discussion Our calculus, PCE, differs from the standard propositional calculus, PC, <ref> [Men64] </ref> in several ways: 1. PC requires atoms to be only propositions, while PCE allows atoms to be also built from predicates and constants; 2. PCE allows the special equality predicate : = in atoms, while PC does not allow this predicate; 3. <p> tool for proving that a family of problems arising in some application is tractable. 154 Appendix A Axiomatic Proof Theory for PCE An axiomatization of PCE is obtained in the usual way by adding the propositional variants of reflexivity and substitutivity axioms for equality [Fit90] to an axiomatization of PC <ref> [Men64] </ref>. For the purpose of this axiomatization alone, we use the abbreviation ! ' to denote the formula _ (~ ; '). <p> PCE can also be viewed as first-order predicate calculus, FOPC, with equality <ref> [Men64] </ref> but without: 1. any variables and quantifiers, and 2. any functions other than constants; except in the axioms (including equality) and the rules of inference. 155 Appendix B A Ptime CNF Transformation Although there is a well-known [Coo71] clausal form transformation that does not cause exponential increase in size of
Reference: [MSL92] <author> D. Mitchell, B. Selman, and L. Levesque. </author> <title> Hard and easy distribution of SAT problems. </title> <booktitle> In Proceedings Tenth National Conference on Artificial Intelligence (AAAI-92), </booktitle> <pages> pages 459-465, </pages> <year> 1992. </year>
Reference-contexts: This encoding facilitates the reading of input to the algorithm AFP and creating the appropriate data structures. The complexity of AFP is measured in the size of this encoding. Similar, though not identical, encodings have been used by various others researchers (c.f. <ref> [DG84, MSL92] </ref>). <p> We need to implement them and experiment with reasoning 153 problems in order to determine their efficacy. These problems could be randomly generated or may be obtained from some "real-world" application. Recently, there have been some interesting empirical results regarding the difficulty of solving randomly-generated reasoning problems (c.f. see <ref> [CKT91, MSL92] </ref>). It would be useful to determine whether similar results hold for our algorithms. Approximations: This work contributes indirectly towards the fourth approach (mentioned in Section 1.1) to the intractability of reasoning, namely, explicitly approximating the information told to the KR system, and/or the queries asked of it.
Reference: [New42] <author> M. H. A. Newman. </author> <title> On theories with a combinatorial definition of equivalence. </title> <journal> Annals of Mathematics, </journal> <volume> 43(2) </volume> <pages> 223-243, </pages> <year> 1942. </year>
Reference-contexts: Proof: Any terminating rewrite system R is confluent iff it is locally confluent <ref> [New42] </ref>. Hence, it suffices to prove local confluence. Suppose t ) R t 1 using rule R 1 = (l 1 ) r 1 ) and t ) R t 2 using rule R 2 = (l 2 ) r 2 ).
Reference: [Rd87] <author> R. Reiter and J. de Kleer. </author> <title> Foundations of assumption-based truth maintenance systems: Preliminary report. </title> <booktitle> In Proceedings Sixth National Conference on Artificial Intelligence (AAAI-87), </booktitle> <pages> pages 183-188, </pages> <year> 1987. </year>
Reference-contexts: be monotonic in both its arguments, let us call the lowest value k for which Viv (; k) is vivid to be the intricacy 1 A strict interpretation of "reading off" quickly the answers of clausal queries would require a vivid knowledge base to explicitly contain all the prime implicants <ref> [Rd87] </ref>: a clause is then entailed iff the knowledge base contains a subclause of the clause. The problem with this approach is that vivifying even some Horn theories, which are already vivid according to our definition, leads to an exponential blow-up in their sizes.
Reference: [SK91] <author> B. Selman and H. Kautz. </author> <title> Knowledge compilation using Horn approximations. </title> <booktitle> In Proceedings Ninth National Conference on Artificial Intelligence (AAAI-91), </booktitle> <pages> pages 904-909, </pages> <year> 1991. </year>
Reference-contexts: A variant of the incomplete/unsound approach is to explicitly approximate the knowledge told to the KB, and/or the queries asked of it, into some other language for which the reasoning is tractable. As in the work on null values in databases [IL82], domain abstraction [Imi87], and knowledge compilation <ref> [SK91, BE89] </ref>, the idea in this approach is to "bound" the error by reporting possibly more than one answer. Note that this approach relies on finding tractable languages to which the formulas are approximated. This work makes contributions to the first three approaches to the intractability problem. <p> For a knowledge base that will be accessed frequently, it makes sense to consider some kind of a "compilation" process that finds a logically equivalent vivid theory. (In fact, even approximate vivid knowledge bases are of interest, as illustrated in <ref> [SK91] </ref>.) It turns out that such a compilation is possible for our ` FPE relation: we present a function Viv, defined in terms of lattice-theoretic fixed-points, such that for every there is a k for which Viv (; k) is vivid.
Reference: [Tar55] <author> A. Tarski. </author> <title> A lattice-theoretical fixpoint theorem and its applications. </title> <journal> Pacific J. Math., </journal> <volume> 5 </volume> <pages> 285-309, </pages> <year> 1955. </year>
Reference-contexts: The least fixpoint, lfp (T ), of T is a fixpoint of T such that lfp (T ) B for any fixpoint B of T . In general, an operator may have no fixpoint or no least fixpoint or may have several fixpoints. However, it follows from Tarski <ref> [Tar55] </ref> that any monotonic operator over a complete lattice has a (unique) least fixpoint. 4.3 Admissible Rewrite Systems We abstract out those properties of FPE that will be needed for our proofs, and condense them into a set of necessary conditions. <p> Since T R;;k is a monotonic operator over a finite lattice, it has a least fixpoint <ref> [Tar55] </ref>, which can also be characterized using the ordinal powers of T R;;k , defined in the usual manner (c.f. [Llo87]): Definition 4.11 For any theory and any k 2 N , the ordinal powers of the operator T R;;k are defined as follows: T R;;k "0 = ; T R;;k <p> R;;k , defined in the usual manner (c.f. [Llo87]): Definition 4.11 For any theory and any k 2 N , the ordinal powers of the operator T R;;k are defined as follows: T R;;k "0 = ; T R;;k "! = [fT R;;k "n j n 2 N g Using <ref> [Tar55] </ref>, it follows from Lemma 4.11 that the least fixpoint lfp (T R;;k ) of T R;;k is given by T R;;k "!. We will refer to lfp (T R;;k ) as the kth fixpoint of ; k is said to be the index of this fixpoint.
Reference: [Ull88] <author> J.D. Ullman. </author> <booktitle> Principles of Database and Knowledge-Base Systems, </booktitle> <volume> volume 1. </volume> <publisher> computer science press, </publisher> <address> Rockville, MD, </address> <year> 1988. </year>
Reference-contexts: Typical examples of this approach include the use of the Horn subset of propositional logic, which is tractable [DG84], and work in relational databases <ref> [Ull88] </ref>, where L T ell is often just ground facts, but L Ask is function-free first-order logic. The problem with this approach is that such KR systems are generally too weak to deal with most applications [DP91]. 2.
Reference: [Yas94] <author> A. Yasuhara. </author> <title> Logic, Computability and Complexity. </title> <note> Submitted for publication, 1994. 178 </note>
Reference-contexts: This relationship between the information told to the system and the answers to queries is usually specified by an entailment (logical consequence) relation in some formal logic. Thus, Tell and Ask operations implement some form of deductive reasoning. The logics most commonly used are first-order logic and propositional logic <ref> [Men64, Yas94] </ref>, since L T ell and L Ask are usually subsets of their underlying languages. It has been cogently argued [BFL83] that for the computational services of a KR system to be dependable, their worst-case time requirements should be small enough to allow adequate response in all critical situations. <p> In other words, Tell and Ask operations should be tractable, which is usually taken to mean that they be in PTIME <ref> [GJ79, Yas94] </ref>. On the other hand, the language (s) of KR systems should be expressive enough to represent the rich variety of knowledge used in any intelligent activity [DP91]. <p> We start with an widely used exemplar of the second approach: (Clausal) BCP is an efficient (linear-time) reasoning method (i.e., reasoner) for answering clausal propositional queries posed to a KR system that is told clausal propositional information, a problem which is known to be NP-Complete <ref> [GJ79, Yas94] </ref>. BCP is sound (i.e., logically correct) and incomplete (i.e., does not answer all queries). However, none of its previously-proposed extensions to the non-clausal case are known to be tractable (i.e., provably in PTIME).
References-found: 66

