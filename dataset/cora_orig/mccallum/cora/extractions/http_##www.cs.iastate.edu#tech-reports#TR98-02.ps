URL: http://www.cs.iastate.edu/tech-reports/TR98-02.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Class-Based and Algebraic Models of Objects data types; F.3.2 [Logics and Meanings of Programs] Semantics
Author: Gary T. Leavens and Don Pigozzi sematics. Gary T. Leavens and Don Pigozzi, . 
Keyword: object-oriented, record, generic function, type, subtype, algebraic model, category-sorted algebra, order-sorted algebra, semantics, type theory. 1998 CR Categories: D.3.1 [Programming Languages] Formal Definitions and Theory Semantics; D.3.3 [Programming Languages] Language Constructs  
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Note: TR #98-02 April 1998  Abstract  Submitted for publication. c  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> Martn Abadi and Luca Cardelli. </author> <title> A Theory of Objects. </title> <booktitle> Monographs in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1996. </year>
Reference-contexts: For those more familiar with such models, we also relate our style of model to order-sorted and category-sorted models. 2 Semantics of Objects and Message Passing Many semantics of OO languages have appeared in the literature. (See Abadi and Cardelli's book <ref> [1] </ref> and Castagna's book [9] for surveys.) Since we are concerned with client code, we can largely avoid the knotty semantical problems of modeling inheritance (see, for example [3, 15, 16, 28]). Instead, we focus on the semantics of objects and message passing from the client's point-of-view. <p> Our aim is to relate the semantics of client expressions in class-based single-dispatching languages to those in multiple-dispatching languages. We start with the class-based single-dispatching languages. 2.1 Record-based Models One way to model objects in an OO language is as a record containing data and method (operation) fields <ref> [1, 7] </ref>. Although this model of objects is somewhat naive [1, Section 6.7], it has the virtue of familiarity and simplicity. This kind of model is most appropriate for prototype languages such as Self [49, 51] and others [19, 37]. <p> We start with the class-based single-dispatching languages. 2.1 Record-based Models One way to model objects in an OO language is as a record containing data and method (operation) fields [1, 7]. Although this model of objects is somewhat naive <ref> [1, Section 6.7] </ref>, it has the virtue of familiarity and simplicity. This kind of model is most appropriate for prototype languages such as Self [49, 51] and others [19, 37]. <p> We calls such languages static, class-based languages. We study static, class-based languages in this paper because they can be simulated by multiple-dispatch generic function languages, which are closer to our algebraic models. (Furthermore, prototype-based languages have been very extensively studied already <ref> [1] </ref>.) The reader should keep in mind, however, that we are limiting ourselves to a subset of the single-dispatching languages. We now describe models for static, class-based single-dispatching languages in detail. <p> This object is called self in Smalltalk, and this in Java. It is also called the implicit or default argument of a method. A method obtains access to self in one of two ways <ref> [1, Section 6.7] </ref>. * Methods can be constructed as fixpoints of premethods (functionals that take self as an argument) [16, 15, 28], which builds in self. * Methods can be explicitly passed self as the method's first argument when called [43]. 3 These two variations turn out to be equivalent [5], <p> premethods (functionals that take self as an argument) [16, 15, 28], which builds in self. * Methods can be explicitly passed self as the method's first argument when called [43]. 3 These two variations turn out to be equivalent [5], although the first variation has problems in explaining method update <ref> [1, Section 6.7.2] </ref>. For our purposes the second variation is more convenient. We therefore give the following semantics for identifier, message send, and tupling expressions. <p> We will sometimes abbreviate product types using vector notation, such as ~ D. To handle recursive types, such as the types of methods that return self, the type environment will associate class names to method dictionary types. This is similar to using recursive type binders ( types) <ref> [1, Chapter 9] </ref>. <p> This reflects the type system's static knowledge about classes. Note, however, that, although class names are used, subtyping is decided structurally. In effect, this is very similar to the use of a recursive type binder (usually written <ref> [1, Chapter 9] </ref>). (As usual, the hypotheses are above the horizontal line, the conclusion below, the rule name in square brackets to the left, and side conditions to the right. <p> types [fun] is called the "contravariant rule." One consequence of this rule is that if a method dictionary type RM D is a subtype of RM D 0 , then the argument types of the common methods in RM D must be supertypes of their types in RM D 0 <ref> [8, 17, 1] </ref>. <p> If c ` RM D RM D 0 then domain (RM D 0 ) domain (RM D): Type checking client expressions with respect to a type environment boils down to the following rules, which are again adapted from Cardelli's rules <ref> [1, 7] </ref>. (As usual, the type environment, written ( r ; c ), is written to the left of the turnstile (`) in judgements that expressions have a given type.) 13 [id] ( r ; c ) ` I: T if r (I) = T c ` T 0 [l: T <p> E 1 : T 1 ; : : : ; ( r ; c ) ` E n : T n if n 0 In the [msg] rule, we depend on the subtyping rules to massage the type of E 0 instead of using a subsumption rule (as does Cardelli <ref> [1, 7] </ref>), but this detail has no great weight. We note the following facts about this proof system for later use. Its proof is an easy consequence of the definitions.
Reference: [2] <author> Ken Arnold and James Gosling. </author> <title> The Java Programming Language. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <note> second edition, </note> <year> 1998. </year>
Reference-contexts: Our research on such questions has been mostly model-theoretic [18, 29, 30, 31, 32, 33, 34, 35, 36]. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 [24], C++ [50], Eiffel [42] and Java <ref> [2, 25] </ref>. Such single-dispatching languages seem to be better modeled by models in which objects resemble records, and message passing is modeled by looking up a method in the object record.
Reference: [3] <author> Gilad Bracha and William Cook. </author> <title> Mixin-based inheritance. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 25(10) </volume> <pages> 303-311, </pages> <month> October </month> <year> 1990. </year> <booktitle> OOPSLA ECOOP '90 Proceedings, N. Meyrowitz (editor). </booktitle>
Reference-contexts: 2 Semantics of Objects and Message Passing Many semantics of OO languages have appeared in the literature. (See Abadi and Cardelli's book [1] and Castagna's book [9] for surveys.) Since we are concerned with client code, we can largely avoid the knotty semantical problems of modeling inheritance (see, for example <ref> [3, 15, 16, 28] </ref>). Instead, we focus on the semantics of objects and message passing from the client's point-of-view. Our aim is to relate the semantics of client expressions in class-based single-dispatching languages to those in multiple-dispatching languages.
Reference: [4] <author> Kim Bruce, Luca Cardelli, Giuseppe Castagna, The Hopkins Object Group, Gary T. Leavens, and Benjamin Pierce. </author> <title> On binary methods. </title> <journal> Theory and Practice of Object Systems, </journal> <volume> 1(3) </volume> <pages> 221-242, </pages> <year> 1995. </year>
Reference-contexts: Multiple dispatch has some expressiveness advantages 5 in practice, since the dispatch can be done symmetrically [11]. In particular, the generic function model helps solve part of the "binary method problem" <ref> [4] </ref>. Since generic functions are found in the second part of the environment, the syntax used with this model is typically chosen to match this semantics. That is, instead of writing E 0 .l (E 1 ), one writes l (E 0 ; E 1 ). <p> We now discuss how to simulate each model with the other. 2.3.1 Simulating Generic Functions in the Record Model Because of the second difference noted above, simulating the generic function model with the record model is not very elegant <ref> [4] </ref>. There are at least two ways to go about such a simulation, however. One simulation simulates an n-ary generic function 1 that can handle k different types of arguments in each argument position by k n+1 k methods in the record model [4, 27]. <p> There are at least two ways to go about such a simulation, however. One simulation simulates an n-ary generic function 1 that can handle k different types of arguments in each argument position by k n+1 k methods in the record model <ref> [4, 27] </ref>. <p> Each of these methods knows both its second argument's type and the type of self, so they can actually do the addition. A second simulation of the generic function model by the record model uses objects that act like tuples of objects <ref> [4, Section 3.2] </ref>. In this simulation, one forms the argument tuple sent to a generic function object into a single object, whose type acts like the product of the argument types of the generic function. <p> On the one hand, the known simulations of the generic function model by the record model are not as easy, and engender an explosion in either the number of methods or the number of objects <ref> [4] </ref>. Hence, as a practical programming matter, one can fairly say that multiple-dispatching languages are more flexible (expressive) than single-dispatching languages. <p> Chapter 3 of that book is comparable to what we have done so far, in that Castagna treats a static, class-based singly-dispatched language (KOOL) and compares it to a language with CLOS-style generic functions (CBL). He shows how to add encapsulated multi-methods (see Section 3.1.11 and <ref> [4] </ref>) to KOOL. Unlike our models, the languages Castagna treats are full languages, and he thus compares aspects of the implementation of objects that we ignore. <p> We first related static, class-based record models to class-based generic function models. The generic function models can be seen as a rearrangement of the information in the record models. However, this rearrangement has some practical advantages for programming <ref> [4, 11] </ref>. While the generic function models have various advantages, it is important to note the assumptions behind our simulation of the record model by the generic function model. We believe that the simulation is only possible for a static, class-based record model.
Reference: [5] <author> Kim B. Bruce. </author> <title> The equivalence of two semantic definitions for inheritance in object-oriented languages. </title> <editor> In Stephen Brookes, Michael Main, Austin Melton, Michael Mislove, and David Schmidt, editors, </editor> <booktitle> Mathematical Foundations of Programming Semantics, 7th International Conference, </booktitle> <address> PA, USA, </address> <month> March </month> <year> 1991, </year> <booktitle> Proceedings, volume 598 of Lecture Notes in Computer Science, </booktitle> <pages> pages 102-124. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: [1, Section 6.7]. * Methods can be constructed as fixpoints of premethods (functionals that take self as an argument) [16, 15, 28], which builds in self. * Methods can be explicitly passed self as the method's first argument when called [43]. 3 These two variations turn out to be equivalent <ref> [5] </ref>, although the first variation has problems in explaining method update [1, Section 6.7.2]. For our purposes the second variation is more convenient. We therefore give the following semantics for identifier, message send, and tupling expressions.
Reference: [6] <author> Kim B. Bruce and Peter Wegner. </author> <title> An algebraic model of subtype and inheritance. </title> <editor> In Francois Ban~cilhon and Peter Buneman, editors, </editor> <booktitle> Advances in Database Programming Languages, </booktitle> <pages> pages 75-96. </pages> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <month> August </month> <year> 1990. </year>
Reference-contexts: However, they can also be seen as an abstraction of generic function languages in which subtypes are required to be subsets <ref> [6, 41] </ref>. In order-sorted algebras, the carrier sets of subtypes must be subsets of the carrier sets of their supertypes. Another way of putting this, used in the definition below, is that a supertype's carrier set is the union of the carrier sets of its subtypes.
Reference: [7] <author> Luca Cardelli. </author> <title> A semantics of multiple inheritance. </title> <journal> Information and Computation, </journal> 76(2/3):138-164, February/March 1988. A revised version of the paper that appeared in the 1984 Semantics of Data Types Symposium, LNCS <volume> 173, </volume> pages <pages> 51-66. </pages>
Reference-contexts: Our aim is to relate the semantics of client expressions in class-based single-dispatching languages to those in multiple-dispatching languages. We start with the class-based single-dispatching languages. 2.1 Record-based Models One way to model objects in an OO language is as a record containing data and method (operation) fields <ref> [1, 7] </ref>. Although this model of objects is somewhat naive [1, Section 6.7], it has the virtue of familiarity and simplicity. This kind of model is most appropriate for prototype languages such as Self [49, 51] and others [19, 37]. <p> Hence, U must have all the methods of T , and perhaps some extra methods. 12 Cardelli was the first to propose a sound type system that can statically determine subtyping for the function, and immutable record and variant types <ref> [7] </ref>. We adapt Cardelli's algorithm for deciding subtype relationships to our situation in the following inference rules. These rules are given with respect to the class part of the type environment, c , which maps class names to method dictionary types. This reflects the type system's static knowledge about classes. <p> If c ` RM D RM D 0 then domain (RM D 0 ) domain (RM D): Type checking client expressions with respect to a type environment boils down to the following rules, which are again adapted from Cardelli's rules <ref> [1, 7] </ref>. (As usual, the type environment, written ( r ; c ), is written to the left of the turnstile (`) in judgements that expressions have a given type.) 13 [id] ( r ; c ) ` I: T if r (I) = T c ` T 0 [l: T <p> E 1 : T 1 ; : : : ; ( r ; c ) ` E n : T n if n 0 In the [msg] rule, we depend on the subtyping rules to massage the type of E 0 instead of using a subsumption rule (as does Cardelli <ref> [1, 7] </ref>), but this detail has no great weight. We note the following facts about this proof system for later use. Its proof is an easy consequence of the definitions. <p> This kind of model is related to the ideal model used by MacQueen et al. [38, 39, 40]. It was originally designed to deal with recursive types, but was adapted by Cardelli and others to give a semantics to models of object-oriented languages <ref> [7] </ref>. 4.4 Category-Sorted Algebras If the carrier sets of all types are disjoint from the carrier sets of every other type, including their supertypes, then one can assign unique types to values in the algebra's carrier set. <p> If A be a subtype polymorphic -algebra, then toOSA (A) is an order-sorted -algebra. To summarize, it is possible to translate each kind of algebraic model into the others. The translation to order-sorted algebras is a semantic counterpart to the subsumption rule of various type systems (e.g., <ref> [7] </ref>), in which if o has type S and S T , then o has type T . The of translation to category-sorted algebras is a semantic counterpart to the implementation of OO languages, in which each object typically has a unique type tag.
Reference: [8] <author> Luca Cardelli and Peter Wegner. </author> <title> On understanding types, data abstraction and polymorphism. </title> <journal> ACM Computing Surveys, </journal> <volume> 17(4) </volume> <pages> 471-522, </pages> <month> December </month> <year> 1985. </year>
Reference-contexts: types [fun] is called the "contravariant rule." One consequence of this rule is that if a method dictionary type RM D is a subtype of RM D 0 , then the argument types of the common methods in RM D must be supertypes of their types in RM D 0 <ref> [8, 17, 1] </ref>.
Reference: [9] <author> Giuseppe Castagna. </author> <title> Object-Oriented Programming: A Unified Foundation. </title> <booktitle> Progress in Theoretical Computer Science. </booktitle> <publisher> Birkhauser, </publisher> <address> Boston, </address> <year> 1997. </year>
Reference-contexts: For those more familiar with such models, we also relate our style of model to order-sorted and category-sorted models. 2 Semantics of Objects and Message Passing Many semantics of OO languages have appeared in the literature. (See Abadi and Cardelli's book [1] and Castagna's book <ref> [9] </ref> for surveys.) Since we are concerned with client code, we can largely avoid the knotty semantical problems of modeling inheritance (see, for example [3, 15, 16, 28]). Instead, we focus on the semantics of objects and message passing from the client's point-of-view. <p> In this kind of model, objects only contain data, not methods. The methods are moved outside the object <ref> [9, 10] </ref>. All methods with the same name are grouped into a generic function, which also has that name. Hence we call this kind of model a generic function model. To be symmetric with the class-based record model presented above, we present a class-based generic function model as well. <p> fM 1 ; : : : ; M n g where n 0 The order of the method types in fM 1 ; : : : ; M n g does not matter, and the argument types of each of the M i must all be pairwise distinct. (See also <ref> [9] </ref> for a monotonicity requirement on such types that we are postponing discussing until later.) Since there are no method dictionaries in the generic function model, it is not immediately obvious how to do decide subtype relationships structurally. <p> For this reason, and also to promote information hiding, generic function languages often feature by-name type checking. This is the case, for example, in Cecil [13], and in the theoretical work of Castagna et al. <ref> [9, 10] </ref>. 14 Since there is no structural information about class names, the rules for de-termining subtype relationships rely on an assumed subtype ordering on atomic (i.e., non-tuple) class names. This assumed ordering is given the name A in the rules below; it is a preorder on type names. <p> Class names that are tuples are handled by the rules below. The following rules determining subtyping relationships in this model. The rule [gf-g] is from the &-calculus <ref> [9, Page 46] </ref>[10]. [refl-g] A ` T T [tran-g] A ` S U; A ` U T [base-g] A ` S T if (S; T ) 2 A [fun-g] A ` (T ! S) (T 0 ! S 0 ) [prod-g] A ` T 1 T 0 n 1 ; : <p> These questions determine whether generic function types are well formed in the sense that a call to a generic function will be able to select a unique most-specific method <ref> [9, 10, 13] </ref>. Such considerations have not concerned us, since we have only worried about type checking for client expressions, and have assumed that appropriate methods were reflected in the type of a generic function. <p> This is the monotonicity property [45], 18 which says that as more information is known about the values of expressions, the type of the expression does not become larger, but can only become a subtype of the type originally inferred for it <ref> [9, 10] </ref>. In terms of an operational semantics, this says that if E reduces to E 0 , then the type of E 0 must be a subtype of the type of E. <p> One way to describe this condition is to require that in each generic function type fD 1 ! D 0 1 ; : : : ; D n ! D 0 n g, whenever A ` D i D j then D 0 i D 0 j <ref> [9, Page 45] </ref>. We shall see another way of describing this condition in the next section. <p> Few have studied the relationship between the single-dispatching and multiple-dispatching languages in detail. One notable exception is Castagna. In his recent book <ref> [9] </ref>, Castagna treats the theory of generic function languages in detail. Chapter 3 of that book is comparable to what we have done so far, in that Castagna treats a static, class-based singly-dispatched language (KOOL) and compares it to a language with CLOS-style generic functions (CBL).
Reference: [10] <author> Giuseppe Castagna, Giorgio Ghelli, and Giuseppe Longo. </author> <title> A calculus for overloaded functions with subtyping. </title> <journal> Information and Computation, </journal> <volume> 117(1) </volume> <pages> 115-135, </pages> <month> February </month> <year> 1995. </year> <note> A preliminary version appeared in ACM Conference on LISP and Functional Programming, June 1992 (pp. 182-192). </note>
Reference-contexts: In this kind of model, objects only contain data, not methods. The methods are moved outside the object <ref> [9, 10] </ref>. All methods with the same name are grouped into a generic function, which also has that name. Hence we call this kind of model a generic function model. To be symmetric with the class-based record model presented above, we present a class-based generic function model as well. <p> For this reason, and also to promote information hiding, generic function languages often feature by-name type checking. This is the case, for example, in Cecil [13], and in the theoretical work of Castagna et al. <ref> [9, 10] </ref>. 14 Since there is no structural information about class names, the rules for de-termining subtype relationships rely on an assumed subtype ordering on atomic (i.e., non-tuple) class names. This assumed ordering is given the name A in the rules below; it is a preorder on type names. <p> These questions determine whether generic function types are well formed in the sense that a call to a generic function will be able to select a unique most-specific method <ref> [9, 10, 13] </ref>. Such considerations have not concerned us, since we have only worried about type checking for client expressions, and have assumed that appropriate methods were reflected in the type of a generic function. <p> This is the monotonicity property [45], 18 which says that as more information is known about the values of expressions, the type of the expression does not become larger, but can only become a subtype of the type originally inferred for it <ref> [9, 10] </ref>. In terms of an operational semantics, this says that if E reduces to E 0 , then the type of E 0 must be a subtype of the type of E.
Reference: [11] <author> Craig Chambers. </author> <title> Object-oriented multi-methods in Cecil. </title> <editor> In Ole Lehrmann Madsen, editor, </editor> <booktitle> ECOOP '92, European Conference on Object-Oriented Programming, Utrecht, The Netherlands, volume 615 of Lecture Notes in Computer Science, </booktitle> <pages> pages 33-56. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1992. </year> <month> 27 </month>
Reference-contexts: Such single-dispatching languages seem to be better modeled by models in which objects resemble records, and message passing is modeled by looking up a method in the object record. By contrast, the models we use resemble multiple-dispatching OO languages such as CLOS [44], Dylan [48], and Cecil <ref> [11, 12] </ref>. fl The work of both authors was supported in part by NSF grant CCR-9593168. 1 In this paper we describe and relate these various kinds of models. In doing so we also establish some connections between class-based single-dispatching and multiple-dispatching OO languages. <p> This contrasts with the record model, in which the method selected is based on the class of the first (implicit) argument only. Multiple dispatch has some expressiveness advantages 5 in practice, since the dispatch can be done symmetrically <ref> [11] </ref>. In particular, the generic function model helps solve part of the "binary method problem" [4]. Since generic functions are found in the second part of the environment, the syntax used with this model is typically chosen to match this semantics. <p> We first related static, class-based record models to class-based generic function models. The generic function models can be seen as a rearrangement of the information in the record models. However, this rearrangement has some practical advantages for programming <ref> [4, 11] </ref>. While the generic function models have various advantages, it is important to note the assumptions behind our simulation of the record model by the generic function model. We believe that the simulation is only possible for a static, class-based record model.
Reference: [12] <author> Craig Chambers. </author> <title> The Cecil language specifica-tion and rationale: </title> <note> Version 2.0. Available from http://www.cs.washington.edu/research/projects/cecil/www/Papers/cecil-spec.html, December 1995. </note>
Reference-contexts: Such single-dispatching languages seem to be better modeled by models in which objects resemble records, and message passing is modeled by looking up a method in the object record. By contrast, the models we use resemble multiple-dispatching OO languages such as CLOS [44], Dylan [48], and Cecil <ref> [11, 12] </ref>. fl The work of both authors was supported in part by NSF grant CCR-9593168. 1 In this paper we describe and relate these various kinds of models. In doing so we also establish some connections between class-based single-dispatching and multiple-dispatching OO languages.
Reference: [13] <author> Craig Chambers and Gary T. Leavens. </author> <title> Typechecking and modules for multi-methods. </title> <journal> TOPLAS, </journal> <volume> 17(6) </volume> <pages> 805-843, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: For this reason, and also to promote information hiding, generic function languages often feature by-name type checking. This is the case, for example, in Cecil <ref> [13] </ref>, and in the theoretical work of Castagna et al. [9, 10]. 14 Since there is no structural information about class names, the rules for de-termining subtype relationships rely on an assumed subtype ordering on atomic (i.e., non-tuple) class names. <p> These questions determine whether generic function types are well formed in the sense that a call to a generic function will be able to select a unique most-specific method <ref> [9, 10, 13] </ref>. Such considerations have not concerned us, since we have only worried about type checking for client expressions, and have assumed that appropriate methods were reflected in the type of a generic function.
Reference: [14] <author> Craig Chambers and Gary T. Leavens. BeCecil, </author> <title> a core object-oriented language with block structure and multimethods: Semantics and typing. </title> <type> Technical Report 96-17a, </type> <institution> Department of Computer Science, Iowa State University, 226 Atanasoff Hall, Ames, Iowa 50011, </institution> <month> April </month> <year> 1997. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note> <institution> Also University of Washington Department of Computer Science and Engineering TR number UW-CSE-96-12-02. </institution>
Reference-contexts: Taking methods out of classes points out one problem with the generic function model, which is how to achieve information hiding. That can be solved by scoping <ref> [14] </ref>, but the solution is outside the scope of this paper, since it does not concern client expressions. We remind the reader that our simulation will only work for static, class-based languages.
Reference: [15] <author> William Cook and Jens Palsberg. </author> <title> A denotational semantics of inheritance and its correctness. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 24(10) </volume> <pages> 433-443, </pages> <month> October </month> <year> 1989. </year> <booktitle> OOPSLA '89 Conference Proceedings, </booktitle> <editor> Norman Meyerowitz (editor), </editor> <month> October </month> <year> 1989, </year> <institution> New Orleans, Louisiana. </institution>
Reference-contexts: 2 Semantics of Objects and Message Passing Many semantics of OO languages have appeared in the literature. (See Abadi and Cardelli's book [1] and Castagna's book [9] for surveys.) Since we are concerned with client code, we can largely avoid the knotty semantical problems of modeling inheritance (see, for example <ref> [3, 15, 16, 28] </ref>). Instead, we focus on the semantics of objects and message passing from the client's point-of-view. Our aim is to relate the semantics of client expressions in class-based single-dispatching languages to those in multiple-dispatching languages. <p> It is also called the implicit or default argument of a method. A method obtains access to self in one of two ways [1, Section 6.7]. * Methods can be constructed as fixpoints of premethods (functionals that take self as an argument) <ref> [16, 15, 28] </ref>, which builds in self. * Methods can be explicitly passed self as the method's first argument when called [43]. 3 These two variations turn out to be equivalent [5], although the first variation has problems in explaining method update [1, Section 6.7.2].
Reference: [16] <author> William R. Cook. </author> <title> A denotational semantics of inheritance. </title> <type> Technical Report CS-89-33, </type> <institution> Department of Computer Science, Brown University, </institution> <address> Providence, Rhode Island, </address> <month> May </month> <year> 1989. </year>
Reference-contexts: 2 Semantics of Objects and Message Passing Many semantics of OO languages have appeared in the literature. (See Abadi and Cardelli's book [1] and Castagna's book [9] for surveys.) Since we are concerned with client code, we can largely avoid the knotty semantical problems of modeling inheritance (see, for example <ref> [3, 15, 16, 28] </ref>). Instead, we focus on the semantics of objects and message passing from the client's point-of-view. Our aim is to relate the semantics of client expressions in class-based single-dispatching languages to those in multiple-dispatching languages. <p> It is also called the implicit or default argument of a method. A method obtains access to self in one of two ways [1, Section 6.7]. * Methods can be constructed as fixpoints of premethods (functionals that take self as an argument) <ref> [16, 15, 28] </ref>, which builds in self. * Methods can be explicitly passed self as the method's first argument when called [43]. 3 These two variations turn out to be equivalent [5], although the first variation has problems in explaining method update [1, Section 6.7.2].
Reference: [17] <author> Scott Danforth and Chris Tomlinson. </author> <title> Type theories and object-oriented programming. </title> <journal> ACM Computing Surveys, </journal> <volume> 20(1) </volume> <pages> 29-72, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: types [fun] is called the "contravariant rule." One consequence of this rule is that if a method dictionary type RM D is a subtype of RM D 0 , then the argument types of the common methods in RM D must be supertypes of their types in RM D 0 <ref> [8, 17, 1] </ref>.
Reference: [18] <author> Krishna Kishore Dhara and Gary T. Leavens. </author> <title> Weak behavioral sub-typing for types with mutable objects. </title> <editor> In S. Brookes, M. Main, A. Melton, and M. Mislove, editors, </editor> <booktitle> Mathematical Foundations of Programming Semantics, Eleventh Annual Conference, volume 1 of Electronic Notes in Theoretical Computer Science. </booktitle> <publisher> Elsevier, </publisher> <year> 1995. </year> <note> http://www.elsevier.nl/locate/entcs/volume1.html. </note>
Reference-contexts: 1 Introduction Along with the promise of reuse, object-oriented (OO) techniques bring several challenges. A key problem that our research addresses is how to verify (or reason about) code that uses message passing and subtype polymorphism. Our research on such questions has been mostly model-theoretic <ref> [18, 29, 30, 31, 32, 33, 34, 35, 36] </ref>. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 [24], C++ [50], Eiffel [42] and Java [2, 25].
Reference: [19] <author> Christophe Dony, Jacques Malenfant, and Pierre Cointe. </author> <title> Prototype-based languages: From a taxonomy to constructive proposals and their validation. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 27(10) </volume> <pages> 201-217, </pages> <month> October </month> <year> 1992. </year> <booktitle> OOPSLA '92 Proceedings, Andreas Paepcke (editor). </booktitle>
Reference-contexts: Although this model of objects is somewhat naive [1, Section 6.7], it has the virtue of familiarity and simplicity. This kind of model is most appropriate for prototype languages such as Self [49, 51] and others <ref> [19, 37] </ref>. The inclusion of methods in objects allows great flexibility, since, for example, a program can create an unbounded number of objects, each with different methods. Including methods in objects is somewhat of an abstraction of the most popular class-based languages, Smalltalk-80, C++, Eiffel, and Java.
Reference: [20] <author> Hartmut Ehrig and Bernd Mahr. </author> <title> Fundamentals of Algebraic Specification 1: Equations and Initial Semantics, </title> <booktitle> volume 6 of EATCS Monographs on Theoretical Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1985. </year>
Reference-contexts: Hence Goguen and Meseguer's definition of a signature with subtyping is essentially equivalent to the one we use by Reynolds. 4.2 Subtype Polymorphic Algebras It is traditional in algebraic models to ignore internal structure in data; this is the main idea behind the algebraic approach to specification <ref> [20, 21, 26] </ref>. The standard mathematical structure used in universal algebra, an algebra, is an abstraction of the code used in an OO program.
Reference: [21] <author> J. A. Goguen, J. W. Thatcher, and E. G. Wagner. </author> <title> An initial algebra approach to the specification, correctness and implementation of abstract data types. </title> <editor> In Raymond T. Yeh, editor, </editor> <booktitle> Current Trends in Programming Methodology, </booktitle> <volume> volume 4, </volume> <pages> pages 80-149. </pages> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1978. </year>
Reference-contexts: Hence Goguen and Meseguer's definition of a signature with subtyping is essentially equivalent to the one we use by Reynolds. 4.2 Subtype Polymorphic Algebras It is traditional in algebraic models to ignore internal structure in data; this is the main idea behind the algebraic approach to specification <ref> [20, 21, 26] </ref>. The standard mathematical structure used in universal algebra, an algebra, is an abstraction of the code used in an OO program.
Reference: [22] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Order-sorted algebra I: Equational deduction for multiple inheritance, overloading, exceptions, and partial operations. </title> <type> Technical Report SRI-CSL-89-10, </type> <institution> Computer Science Laboratory, SRI International, </institution> <month> July </month> <year> 1980. </year>
Reference-contexts: This abstraction step takes one from the generic function models described above to various algebraic models. 4.1 Signatures Another way to capture the monotonicity requirement for generic function types is found in the work of Reynolds [45, 46] and of Goguen and Meseguer <ref> [22, 23] </ref> on algebraic models. In the tradition of universal algebra, this work collects the type information into a mathematical structure. We call this structure a "signature with subtyping" (to distinguish it from signatures without subtypes). <p> The above definition essentially follows Reynolds [45, Pages 217-218]. The set OP is what we called "Label" in the two models of objects discussed above. In Goguen and Meseguer's work on order sorted algebra [23] <ref> [22, pp. 8-9] </ref>, there is a "monotonicity" condition on signatures that has the same effect as the monotonicity condition on ResType above. Their "regularity" condition on signatures has the effect of allowing the result type of an operator to be given as a function of the arguments. <p> In the second the carrier sets are expected to be disjoint. Although these variations primarily concern the carrier sets, they also affect the mathematics of the operation interpretations. 4.3 Order-Sorted Algebras Goguen and Meseguer's order-sorted algebras were originally designed to solve expressiveness problems in algebraic specification <ref> [22, 23] </ref>. However, they can also be seen as an abstraction of generic function languages in which subtypes are required to be subsets [6, 41]. In order-sorted algebras, the carrier sets of subtypes must be subsets of the carrier sets of their supertypes. <p> A subtype polymorphic -algebra A is a order-sorted -algebra if and only if for each T 2 TYPE , A T = ^ A T . Our definition of order-sorted algebras differs from Goguen and Meseguer's <ref> [22, Page 10] </ref> only in that they do not use polymorphic operation interpretations. Instead, they index operation symbols by their types. This is equivalent to writing operation symbols with subscripts, such as g ~ S;U 0 . Goguen and Meseguer give interpretations symbols separately for each index. <p> This condition is that g A ~ S;U 0 equals g A ~ T ;U on A ~ S <ref> [22, Page 10] </ref>. This kind of model is related to the ideal model used by MacQueen et al. [38, 39, 40].
Reference: [23] <author> Joseph A. Goguen and Jose Meseguer. </author> <title> Order-sorted algebra solves the constructor-selector, multiple representation and coercion problems. </title> <booktitle> In Symposium on Logic in Computer Science, </booktitle> <address> Ithaca, NY, </address> <pages> pages 18-29. </pages> <publisher> IEEE, </publisher> <month> June </month> <year> 1987. </year>
Reference-contexts: This abstraction step takes one from the generic function models described above to various algebraic models. 4.1 Signatures Another way to capture the monotonicity requirement for generic function types is found in the work of Reynolds [45, 46] and of Goguen and Meseguer <ref> [22, 23] </ref> on algebraic models. In the tradition of universal algebra, this work collects the type information into a mathematical structure. We call this structure a "signature with subtyping" (to distinguish it from signatures without subtypes). <p> The above definition essentially follows Reynolds [45, Pages 217-218]. The set OP is what we called "Label" in the two models of objects discussed above. In Goguen and Meseguer's work on order sorted algebra <ref> [23] </ref> [22, pp. 8-9], there is a "monotonicity" condition on signatures that has the same effect as the monotonicity condition on ResType above. Their "regularity" condition on signatures has the effect of allowing the result type of an operator to be given as a function of the arguments. <p> In the second the carrier sets are expected to be disjoint. Although these variations primarily concern the carrier sets, they also affect the mathematics of the operation interpretations. 4.3 Order-Sorted Algebras Goguen and Meseguer's order-sorted algebras were originally designed to solve expressiveness problems in algebraic specification <ref> [22, 23] </ref>. However, they can also be seen as an abstraction of generic function languages in which subtypes are required to be subsets [6, 41]. In order-sorted algebras, the carrier sets of subtypes must be subsets of the carrier sets of their supertypes.
Reference: [24] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80, The Language and its Implementation. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1983. </year>
Reference-contexts: Our research on such questions has been mostly model-theoretic [18, 29, 30, 31, 32, 33, 34, 35, 36]. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 <ref> [24] </ref>, C++ [50], Eiffel [42] and Java [2, 25]. Such single-dispatching languages seem to be better modeled by models in which objects resemble records, and message passing is modeled by looking up a method in the object record.
Reference: [25] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java Language Specification. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1996. </year>
Reference-contexts: Our research on such questions has been mostly model-theoretic [18, 29, 30, 31, 32, 33, 34, 35, 36]. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 [24], C++ [50], Eiffel [42] and Java <ref> [2, 25] </ref>. Such single-dispatching languages seem to be better modeled by models in which objects resemble records, and message passing is modeled by looking up a method in the object record.
Reference: [26] <author> J. Guttag and J. J. Horning. </author> <title> The algebraic specification of abstract data types. </title> <journal> Acta Informatica, </journal> <volume> 10(1) </volume> <pages> 27-52, </pages> <year> 1978. </year>
Reference-contexts: Hence Goguen and Meseguer's definition of a signature with subtyping is essentially equivalent to the one we use by Reynolds. 4.2 Subtype Polymorphic Algebras It is traditional in algebraic models to ignore internal structure in data; this is the main idea behind the algebraic approach to specification <ref> [20, 21, 26] </ref>. The standard mathematical structure used in universal algebra, an algebra, is an abstraction of the code used in an OO program.
Reference: [27] <author> Daniel H. H. Ingalls. </author> <title> A simple technique for handling multiple polymor-phism. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 347-349, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOP-SLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: There are at least two ways to go about such a simulation, however. One simulation simulates an n-ary generic function 1 that can handle k different types of arguments in each argument position by k n+1 k methods in the record model <ref> [4, 27] </ref>.
Reference: [28] <author> Samuel Kamin. </author> <title> Inheritance in smalltalk-80: A denotational definition. </title> <booktitle> In Conference Record of the Fifteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Diego, Calif., </address> <pages> pages 80-87. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1988. </year>
Reference-contexts: 2 Semantics of Objects and Message Passing Many semantics of OO languages have appeared in the literature. (See Abadi and Cardelli's book [1] and Castagna's book [9] for surveys.) Since we are concerned with client code, we can largely avoid the knotty semantical problems of modeling inheritance (see, for example <ref> [3, 15, 16, 28] </ref>). Instead, we focus on the semantics of objects and message passing from the client's point-of-view. Our aim is to relate the semantics of client expressions in class-based single-dispatching languages to those in multiple-dispatching languages. <p> It is also called the implicit or default argument of a method. A method obtains access to self in one of two ways [1, Section 6.7]. * Methods can be constructed as fixpoints of premethods (functionals that take self as an argument) <ref> [16, 15, 28] </ref>, which builds in self. * Methods can be explicitly passed self as the method's first argument when called [43]. 3 These two variations turn out to be equivalent [5], although the first variation has problems in explaining method update [1, Section 6.7.2].
Reference: [29] <author> Gary T. Leavens. </author> <title> Modular verification of object-oriented programs with subtypes. </title> <type> Technical Report 90-09, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, July </month> <year> 1990. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: 1 Introduction Along with the promise of reuse, object-oriented (OO) techniques bring several challenges. A key problem that our research addresses is how to verify (or reason about) code that uses message passing and subtype polymorphism. Our research on such questions has been mostly model-theoretic <ref> [18, 29, 30, 31, 32, 33, 34, 35, 36] </ref>. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 [24], C++ [50], Eiffel [42] and Java [2, 25].
Reference: [30] <author> Gary T. Leavens. </author> <title> Modular specification and verification of object-oriented programs. </title> <journal> IEEE Software, </journal> <volume> 8(4) </volume> <pages> 72-80, </pages> <month> July </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Along with the promise of reuse, object-oriented (OO) techniques bring several challenges. A key problem that our research addresses is how to verify (or reason about) code that uses message passing and subtype polymorphism. Our research on such questions has been mostly model-theoretic <ref> [18, 29, 30, 31, 32, 33, 34, 35, 36] </ref>. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 [24], C++ [50], Eiffel [42] and Java [2, 25].
Reference: [31] <author> Gary T. Leavens and Don Pigozzi. </author> <title> Typed homomorphic relations extended with subtypes. </title> <editor> In Stephen Brookes, editor, </editor> <booktitle> Mathematical Foundations of Programming Semantics '91, volume 598 of Lecture Notes in Computer Science, </booktitle> <pages> pages 144-167. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1992. </year>
Reference-contexts: 1 Introduction Along with the promise of reuse, object-oriented (OO) techniques bring several challenges. A key problem that our research addresses is how to verify (or reason about) code that uses message passing and subtype polymorphism. Our research on such questions has been mostly model-theoretic <ref> [18, 29, 30, 31, 32, 33, 34, 35, 36] </ref>. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 [24], C++ [50], Eiffel [42] and Java [2, 25].
Reference: [32] <author> Gary T. Leavens and Don Pigozzi. </author> <title> An exact algebraic characterization of behavioral subtyping. </title> <type> Technical Report 96-15, </type> <institution> Department of Computer Science, Iowa State University, Ames, Iowa, </institution> <month> 50011, November </month> <year> 1996. </year> <note> Available by anonymous ftp from ftp.cs.iastate.edu, and by e-mail from almanac@cs.iastate.edu. 29 </note>
Reference-contexts: 1 Introduction Along with the promise of reuse, object-oriented (OO) techniques bring several challenges. A key problem that our research addresses is how to verify (or reason about) code that uses message passing and subtype polymorphism. Our research on such questions has been mostly model-theoretic <ref> [18, 29, 30, 31, 32, 33, 34, 35, 36] </ref>. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 [24], C++ [50], Eiffel [42] and Java [2, 25].
Reference: [33] <author> Gary T. Leavens and Don Pigozzi. </author> <title> The behavior-realization adjunction and generalized homomorphic relations. </title> <journal> Theoretical Computer Science, </journal> <volume> 177 </volume> <pages> 183-216, </pages> <year> 1997. </year>
Reference-contexts: 1 Introduction Along with the promise of reuse, object-oriented (OO) techniques bring several challenges. A key problem that our research addresses is how to verify (or reason about) code that uses message passing and subtype polymorphism. Our research on such questions has been mostly model-theoretic <ref> [18, 29, 30, 31, 32, 33, 34, 35, 36] </ref>. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 [24], C++ [50], Eiffel [42] and Java [2, 25].
Reference: [34] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about object-oriented programs that use subtypes (extended abstract). </title> <editor> In N. Meyrowitz, editor, </editor> <booktitle> OOPSLA ECOOP '90 Proceedings, volume 25(10) of ACM SIGPLAN Notices, </booktitle> <pages> pages 212-223. </pages> <publisher> ACM, </publisher> <month> October </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Along with the promise of reuse, object-oriented (OO) techniques bring several challenges. A key problem that our research addresses is how to verify (or reason about) code that uses message passing and subtype polymorphism. Our research on such questions has been mostly model-theoretic <ref> [18, 29, 30, 31, 32, 33, 34, 35, 36] </ref>. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 [24], C++ [50], Eiffel [42] and Java [2, 25].
Reference: [35] <author> Gary T. Leavens and William E. Weihl. </author> <title> Specification and verification of object-oriented programs using supertype abstraction. </title> <journal> Acta Informatica, </journal> <volume> 32(8) </volume> <pages> 705-778, </pages> <month> November </month> <year> 1995. </year>
Reference-contexts: 1 Introduction Along with the promise of reuse, object-oriented (OO) techniques bring several challenges. A key problem that our research addresses is how to verify (or reason about) code that uses message passing and subtype polymorphism. Our research on such questions has been mostly model-theoretic <ref> [18, 29, 30, 31, 32, 33, 34, 35, 36] </ref>. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 [24], C++ [50], Eiffel [42] and Java [2, 25].
Reference: [36] <author> Gary Todd Leavens. </author> <title> Verifying object-oriented programs that use subtypes. </title> <type> Technical Report 439, </type> <institution> Massachusetts Institute of Technology, Laboratory for Computer Science, </institution> <month> February </month> <year> 1989. </year> <title> The author's Ph.D. </title> <type> thesis. </type>
Reference-contexts: 1 Introduction Along with the promise of reuse, object-oriented (OO) techniques bring several challenges. A key problem that our research addresses is how to verify (or reason about) code that uses message passing and subtype polymorphism. Our research on such questions has been mostly model-theoretic <ref> [18, 29, 30, 31, 32, 33, 34, 35, 36] </ref>. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 [24], C++ [50], Eiffel [42] and Java [2, 25].
Reference: [37] <author> Henry Lieberman. </author> <title> Using prototypical objects to implement shared behavior in object oriented systems. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 21(11) </volume> <pages> 214-223, </pages> <month> November </month> <year> 1986. </year> <booktitle> OOPSLA '86 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <month> September </month> <year> 1986, </year> <institution> Portland, Oregon. </institution>
Reference-contexts: Although this model of objects is somewhat naive [1, Section 6.7], it has the virtue of familiarity and simplicity. This kind of model is most appropriate for prototype languages such as Self [49, 51] and others <ref> [19, 37] </ref>. The inclusion of methods in objects allows great flexibility, since, for example, a program can create an unbounded number of objects, each with different methods. Including methods in objects is somewhat of an abstraction of the most popular class-based languages, Smalltalk-80, C++, Eiffel, and Java.
Reference: [38] <author> D. B. MacQueen and Ravi Sethi. </author> <title> A semantic model of types for applicative languages. </title> <booktitle> In ACM Symp. on LISP and Functional Programming, </booktitle> <pages> pages 243-252. </pages> <publisher> ACM, </publisher> <year> 1982. </year>
Reference-contexts: This condition is that g A ~ S;U 0 equals g A ~ T ;U on A ~ S [22, Page 10]. This kind of model is related to the ideal model used by MacQueen et al. <ref> [38, 39, 40] </ref>.
Reference: [39] <author> David MacQueen, Gordon Plotkin, and Ravi Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Salt Lake City, Utah, </address> <pages> pages 165-174. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1984. </year>
Reference-contexts: This condition is that g A ~ S;U 0 equals g A ~ T ;U on A ~ S [22, Page 10]. This kind of model is related to the ideal model used by MacQueen et al. <ref> [38, 39, 40] </ref>.
Reference: [40] <author> David MacQueen, Gordon Plotkin, and Ravi Sethi. </author> <title> An ideal model for recursive polymorphic types. </title> <journal> Information and Control, </journal> 71(1/2):95-130, Oct./Nov. 1986. 
Reference-contexts: This condition is that g A ~ S;U 0 equals g A ~ T ;U on A ~ S [22, Page 10]. This kind of model is related to the ideal model used by MacQueen et al. <ref> [38, 39, 40] </ref>.
Reference: [41] <author> Narciso Marti-Oliet and Jose Meseguer. </author> <title> Inclusions and subtypes. </title> <type> Technical Report SRI-CSL-90-16, </type> <institution> Computer Science Laboratory, SRI International, </institution> <address> 333 Ravenswood Ave., Menlo Park, Calif., </address> <month> December </month> <year> 1990. </year>
Reference-contexts: However, they can also be seen as an abstraction of generic function languages in which subtypes are required to be subsets <ref> [6, 41] </ref>. In order-sorted algebras, the carrier sets of subtypes must be subsets of the carrier sets of their supertypes. Another way of putting this, used in the definition below, is that a supertype's carrier set is the union of the carrier sets of its subtypes.
Reference: [42] <author> Bertrand Meyer. </author> <title> Object-oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, N.Y., </address> <note> second edition, </note> <year> 1997. </year>
Reference-contexts: Our research on such questions has been mostly model-theoretic [18, 29, 30, 31, 32, 33, 34, 35, 36]. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 [24], C++ [50], Eiffel <ref> [42] </ref> and Java [2, 25]. Such single-dispatching languages seem to be better modeled by models in which objects resemble records, and message passing is modeled by looking up a method in the object record.
Reference: [43] <author> John C. Mitchell. </author> <title> Toward a typed foundation for method specialization and inheritance. </title> <booktitle> In Conference Record of the Seventeenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, Calif., </address> <pages> pages 109-124. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1990. </year>
Reference-contexts: method obtains access to self in one of two ways [1, Section 6.7]. * Methods can be constructed as fixpoints of premethods (functionals that take self as an argument) [16, 15, 28], which builds in self. * Methods can be explicitly passed self as the method's first argument when called <ref> [43] </ref>. 3 These two variations turn out to be equivalent [5], although the first variation has problems in explaining method update [1, Section 6.7.2]. For our purposes the second variation is more convenient. We therefore give the following semantics for identifier, message send, and tupling expressions.
Reference: [44] <author> Andreas Paepcke. </author> <title> Object-Oriented Programming: The CLOS Perspective. </title> <publisher> The MIT Press, </publisher> <year> 1993. </year> <month> 30 </month>
Reference-contexts: Such single-dispatching languages seem to be better modeled by models in which objects resemble records, and message passing is modeled by looking up a method in the object record. By contrast, the models we use resemble multiple-dispatching OO languages such as CLOS <ref> [44] </ref>, Dylan [48], and Cecil [11, 12]. fl The work of both authors was supported in part by NSF grant CCR-9593168. 1 In this paper we describe and relate these various kinds of models. In doing so we also establish some connections between class-based single-dispatching and multiple-dispatching OO languages.
Reference: [45] <author> John C. Reynolds. </author> <title> Using category theory to design implicit conversions and generic operators. </title> <editor> In Neil D. Jones, editor, </editor> <booktitle> Semantics-Directed Compiler Generation, Proceedings of a Workshop, Aarhus, Denmark, volume 94 of Lecture Notes in Computer Science, </booktitle> <pages> pages 211-258. </pages> <publisher> Springer-Verlag, </publisher> <month> Jan-uary </month> <year> 1980. </year>
Reference-contexts: However, there is at least one property of generic function types as a whole that is a concern for client-side checking. This is the monotonicity property <ref> [45] </ref>, 18 which says that as more information is known about the values of expressions, the type of the expression does not become larger, but can only become a subtype of the type originally inferred for it [9, 10]. <p> This abstraction step takes one from the generic function models described above to various algebraic models. 4.1 Signatures Another way to capture the monotonicity requirement for generic function types is found in the work of Reynolds <ref> [45, 46] </ref> and of Goguen and Meseguer [22, 23] on algebraic models. In the tradition of universal algebra, this work collects the type information into a mathematical structure. We call this structure a "signature with subtyping" (to distinguish it from signatures without subtypes). <p> Note that the set of types is no longer closed under the formation of product types, but in this respect we follow the algebraic tradition of "flat" argument lists. The above definition essentially follows Reynolds <ref> [45, Pages 217-218] </ref>. The set OP is what we called "Label" in the two models of objects discussed above. <p> The notion that somehow, values of subtype objects are similar to values of supertype objects can be captured by using coercion functions. These coercion functions map values of a subtype into the carrier set of their supertype. This is the idea behind Reynolds's "category-sorted algebras" <ref> [45, 46] </ref>. 3 Definition 4.5 Let = (TYPE ; ; OP; ResType) be a signature with subtyp-ing. <p> That is, if A S A T , then there is an identity injection i S!T defined by i S!T (o) = o that can act as a coercion function <ref> [45, Page 217] </ref>. Using these as the coercion functions almost makes an order-sorted algebra into a category-sorted algebra, but our definition of a category-sorted algebra also requires that the carrier sets of each type be disjoint.
Reference: [46] <author> John C. Reynolds. </author> <title> Three approaches to type structure. </title> <editor> In Hartmut Ehrig, Christiane Floyd, Maurice Nivat, and James Thatcher, editors, </editor> <booktitle> Mathematical Foundations of Software Development, Proceedings of the International Joint Conference on Theory and Practice of Software Development (TAP-SOFT), Berlin. Volume 1: Colloquium on Trees in Algebra and Programming (CAAP '85), volume 185 of Lecture Notes in Computer Science, </booktitle> <pages> pages 97-138. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <month> March </month> <year> 1985. </year>
Reference-contexts: This abstraction step takes one from the generic function models described above to various algebraic models. 4.1 Signatures Another way to capture the monotonicity requirement for generic function types is found in the work of Reynolds <ref> [45, 46] </ref> and of Goguen and Meseguer [22, 23] on algebraic models. In the tradition of universal algebra, this work collects the type information into a mathematical structure. We call this structure a "signature with subtyping" (to distinguish it from signatures without subtypes). <p> The notion that somehow, values of subtype objects are similar to values of supertype objects can be captured by using coercion functions. These coercion functions map values of a subtype into the carrier set of their supertype. This is the idea behind Reynolds's "category-sorted algebras" <ref> [45, 46] </ref>. 3 Definition 4.5 Let = (TYPE ; ; OP; ResType) be a signature with subtyp-ing.
Reference: [47] <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc., </publisher> <address> Boston, Mass., </address> <year> 1986. </year>
Reference-contexts: We therefore give the following semantics for identifier, message send, and tupling expressions. In this semantics, the environment is written as ( r ; c ) and we ignore mutation. (The typographical conventions used is this semantics are from Schmidt's book <ref> [47] </ref>. The cases expression is used for disjoint union types, with functions of the form "inX" being injections into the disjoint union from the domain X and "isX" being a test to see if an element of the disjoint union was injected from X.
Reference: [48] <author> Andrew Shalit. </author> <title> The Dylan Reference Manual: The Definitive Guide to the New Object-Oriented Dynamic Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1997. </year>
Reference-contexts: Such single-dispatching languages seem to be better modeled by models in which objects resemble records, and message passing is modeled by looking up a method in the object record. By contrast, the models we use resemble multiple-dispatching OO languages such as CLOS [44], Dylan <ref> [48] </ref>, and Cecil [11, 12]. fl The work of both authors was supported in part by NSF grant CCR-9593168. 1 In this paper we describe and relate these various kinds of models. In doing so we also establish some connections between class-based single-dispatching and multiple-dispatching OO languages.
Reference: [49] <author> Randall B. Smith and David Ungar. </author> <title> Programming as an experience: The inspiration for self. </title> <editor> In Walter Olthoff, editor, </editor> <booktitle> ECOOP '95 - Object-Oriented Programming 9th European Conference, Aarhus, Denmark, number 952 in Lecture Notes in Computer Science, </booktitle> <pages> pages 303-330. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1995. </year>
Reference-contexts: Although this model of objects is somewhat naive [1, Section 6.7], it has the virtue of familiarity and simplicity. This kind of model is most appropriate for prototype languages such as Self <ref> [49, 51] </ref> and others [19, 37]. The inclusion of methods in objects allows great flexibility, since, for example, a program can create an unbounded number of objects, each with different methods.
Reference: [50] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language: Third Edition. </title> <publisher> Addison-Wesley Publishing Co., </publisher> <address> Reading, Mass., </address> <year> 1997. </year>
Reference-contexts: Our research on such questions has been mostly model-theoretic [18, 29, 30, 31, 32, 33, 34, 35, 36]. However, the models we use may seem, at first glance, to have little to do with standard OO programming languages, such as Smalltalk-80 [24], C++ <ref> [50] </ref>, Eiffel [42] and Java [2, 25]. Such single-dispatching languages seem to be better modeled by models in which objects resemble records, and message passing is modeled by looking up a method in the object record.
Reference: [51] <author> David Ungar and Randall B. Smith. </author> <title> Self: The power of simplicity. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 22(12) </volume> <pages> 227-241, </pages> <month> December </month> <year> 1987. </year> <booktitle> OOPSLA '87 Conference Proceedings, </booktitle> <editor> Norman Meyrowitz (editor), </editor> <address> October 1987, Orlando, Florida. </address>
Reference-contexts: Although this model of objects is somewhat naive [1, Section 6.7], it has the virtue of familiarity and simplicity. This kind of model is most appropriate for prototype languages such as Self <ref> [49, 51] </ref> and others [19, 37]. The inclusion of methods in objects allows great flexibility, since, for example, a program can create an unbounded number of objects, each with different methods.
Reference: [52] <author> Philip Wadler and Stephen Blott. </author> <title> How to make ad-hoc polymorphism less ad hoc. </title> <booktitle> In Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Austin, Texas, </address> <pages> pages 60-76. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year> <month> 31 </month>
Reference-contexts: Method dictionaries map method names (labels) to methods <ref> [52] </ref>. The class of an object is contained in the object itself.
References-found: 52

