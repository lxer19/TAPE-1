URL: ftp://ftp.fas.sfu.ca/pub/cs/han/dood/dood95.ps
Refering-URL: http://fas.sfu.ca/cs/research/groups/DB/sections/publication/dood/dood.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fzhaohui, han@cs.sfu.ca  
Title: Normalization and Compilation of Deductive and Object-Oriented Database Programs for Efficient Query Evaluation  
Author: Zhaohui Xie and Jiawei Han 
Keyword: Deductive and object-oriented database, compilation, recur sive query evaluation, query optimization.  
Web: g  
Address: Burnaby, B.C., Canada V5A 1S6  
Affiliation: School of Computing Science Simon Fraser University  
Abstract: A normalization process is proposed to serve not only as a preprocessing stage for compilation and evaluation but also as a tool for classifying recursions. Then the query-independent compilation and chain-based evaluation method can be extended naturally to process a class of DOOD programs and queries. The query-independent compilation captures the bindings that could be difficult to be captured otherwise. The chain-based evaluation explores query constraints, integrity constraints, recursion structures, and other features of the programs with a set of interesting techniques, such as chain-following, chain-split, and constraint pushing. Therefore, with this normalization and compilation process, a class of DOOD queries can be evaluated efficiently in deductive and object-oriented databases. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> W. Chen, M. Kifer, and D. S. Warren. Hilog: </author> <title> A foundation for higher-order logic programming. </title> <journal> J. Logic Programming, </journal> <volume> 15 </volume> <pages> 187-230, </pages> <year> 1993. </year>
Reference-contexts: The saving on navigation cost could be significant if nested attributes are involved. Obviously, query evaluation methods should capture query constraints, especially constraints on higher-order variables and apply the constraints at the early stage of query evaluations. Although a DOOD program can be encoded into a first-order logic program <ref> [1, 9] </ref>, the transformation may produce many predicates and rules. These predicates represent the access of attributes or the invocation of methods. Thus this process may change simple recursions into complex ones. Example 2. (Transforming a DOOD program into a Datalog program). <p> Programs are first translated into Horn clause-like programs such as Data-log, and then evaluated with the existing deductive query evaluation methods. Although object-orientation is not explicitly supported, XSB [10] provides a platform for implementing object-orientation with Hilog <ref> [1] </ref> syntax. XSB implements 2 See Definition 4. Hilog by transforming higher-order terms into first-order forms with apply/N, and then compiling and optimizing the first-order forms.
Reference: 2. <author> S. Greco, N. Leone, and P. Rullo. </author> <title> COMPLEX: an object-oriented logic programming system. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 4 </volume> <pages> 344-359, </pages> <year> 1992. </year>
Reference-contexts: Thus the transformation from a DOOD program to a Datalog program may produce more complex recursions than the original ones in DOOD programs. 2 There are research prototypes which integrate object-orientation with deductive database languages, e.g., COMPLEX <ref> [2] </ref>, ConceptBase [8] and Coral++ [11]. However, these systems typically extend deductive database languages such as Datalog with limited object-oriented features [2, 8] or a C++ type system [11]. Programs are first translated into Horn clause-like programs such as Data-log, and then evaluated with the existing deductive query evaluation methods. <p> However, these systems typically extend deductive database languages such as Datalog with limited object-oriented features <ref> [2, 8] </ref> or a C++ type system [11]. Programs are first translated into Horn clause-like programs such as Data-log, and then evaluated with the existing deductive query evaluation methods. Although object-orientation is not explicitly supported, XSB [10] provides a platform for implementing object-orientation with Hilog [1] syntax.
Reference: 3. <author> J. Han. </author> <title> Constraint-based query evaluation in deductive databases. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 6 </volume> <pages> 96-107, </pages> <year> 1994. </year>
Reference-contexts: The above rule is transformed into the following rule, Attr (C; X; F; U ) Attr (C; Y; F; U 1 ); Attr (C; Y; g; U 1 ); p (X; Y; U; U 1 ): which is a non-linearly recursive rule <ref> [3] </ref>. Obviously, a DOOD (single) linear recursion may be transformed into a non-linear recursion. <p> XSB implements 2 See Definition 4. Hilog by transforming higher-order terms into first-order forms with apply/N, and then compiling and optimizing the first-order forms. In this paper, we propose to extend the query-independent compilation and chain-based evaluation approach <ref> [7, 4, 3] </ref> and to explore the regularities of connections among variables in object molecules, based on the following considerations. The query-independent compilation captures the bindings that could be difficult to be captured by other methods [7]. <p> ) = T rue if i = 0, r i (X i1 ; X i ) = T rue if i = 0, 2 The chain-based approach includes the algorithms for testing finite evaluabil--ity and termination, and a set of evaluation techniques such as chain following, chain-split and constraint pushing <ref> [4, 3] </ref>. Since some functional predicates and built-in predicates are defined on infinite domains, the number of answers to a query may be infinite. Sometimes, even though the result is finite, inappropriate evaluation methods may lead to infinite intermediate results.
Reference: 4. <author> J. Han. </author> <title> Chain-split evaluation in deductive databases. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 7 </volume> <pages> 261-273, </pages> <year> 1995. </year>
Reference-contexts: XSB implements 2 See Definition 4. Hilog by transforming higher-order terms into first-order forms with apply/N, and then compiling and optimizing the first-order forms. In this paper, we propose to extend the query-independent compilation and chain-based evaluation approach <ref> [7, 4, 3] </ref> and to explore the regularities of connections among variables in object molecules, based on the following considerations. The query-independent compilation captures the bindings that could be difficult to be captured by other methods [7]. <p> ) = T rue if i = 0, r i (X i1 ; X i ) = T rue if i = 0, 2 The chain-based approach includes the algorithms for testing finite evaluabil--ity and termination, and a set of evaluation techniques such as chain following, chain-split and constraint pushing <ref> [4, 3] </ref>. Since some functional predicates and built-in predicates are defined on infinite domains, the number of answers to a query may be infinite. Sometimes, even though the result is finite, inappropriate evaluation methods may lead to infinite intermediate results.
Reference: 5. <author> J. Han and L. V. S. Lakshmanan. </author> <title> Evaluation of regular nonlinear recursions by deductive database techniques. </title> <journal> Information Systems, </journal> <note> 20, 1995 (to appear). </note>
Reference-contexts: In fact, our method is also applicable to the evaluation of more general class of recursions such as nested linear and non-linear recursions <ref> [12, 5] </ref>. Instead of transforming DOOD programs into Horn-like programs, the DOOD programs are preprocessed into normalized forms. The normalization process helps not only compile and evaluate DOOD recursions but also classify recursions. <p> The integration of this normalization and compilation technique extends the power of the LogicBase system from linear, nested linear and certain classes of nonlinear recursive programs <ref> [5] </ref> to a more general class of DOOD programs. It is interesting to see how the other deductive evaluation methods can be extended elegantly to handle DOOD recursions.
Reference: 6. <author> J. Han, L. Liu, and Z. Xie. LogicBase: </author> <title> A deductive database system prototype. </title> <booktitle> In Proc. 3rd Int'l Conf. on Information and Knowledge Management, </booktitle> <pages> pp. 226-233, </pages> <address> Gaithersburg, Maryland, </address> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: The normalization process helps not only compile and evaluate DOOD recursions but also classify recursions. Our method described here for normalization and compilation of the DOOD programs for efficient query evaluation has been integrated into the LogicBase project <ref> [6] </ref>, which has previously demonstrated its effectiveness and efficiency in the implementation of sophisticated, declarative recursive programs and queries (such as n-queen recursions, permutation-sort programs, etc.) in deductive databases and logic programming.
Reference: 7. <author> J. Han and K. Zeng. </author> <title> Automatic generation of compiled forms for linear recursions. </title> <journal> Information Systems, </journal> <volume> 17 </volume> <pages> 299-322, </pages> <year> 1992. </year>
Reference-contexts: XSB implements 2 See Definition 4. Hilog by transforming higher-order terms into first-order forms with apply/N, and then compiling and optimizing the first-order forms. In this paper, we propose to extend the query-independent compilation and chain-based evaluation approach <ref> [7, 4, 3] </ref> and to explore the regularities of connections among variables in object molecules, based on the following considerations. The query-independent compilation captures the bindings that could be difficult to be captured by other methods [7]. <p> The query-independent compilation captures the bindings that could be difficult to be captured by other methods <ref> [7] </ref>. The chain-based evaluation explores query constraints, integrity constraints, recursion structures, and other features of the programs with a set of interesting techniques, such as chain-following, chain-split and constraint pushing.
Reference: 8. <author> M. Jeusfeld and M. Staudt. </author> <title> Query optimization in deductive object bases. </title> <editor> In J. C. Freytag, D. Maier, and G. Vossen, editors, </editor> <booktitle> Query Processing for Advanced Database Systems, </booktitle> <pages> pp. 146-176. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference-contexts: Thus the transformation from a DOOD program to a Datalog program may produce more complex recursions than the original ones in DOOD programs. 2 There are research prototypes which integrate object-orientation with deductive database languages, e.g., COMPLEX [2], ConceptBase <ref> [8] </ref> and Coral++ [11]. However, these systems typically extend deductive database languages such as Datalog with limited object-oriented features [2, 8] or a C++ type system [11]. Programs are first translated into Horn clause-like programs such as Data-log, and then evaluated with the existing deductive query evaluation methods. <p> However, these systems typically extend deductive database languages such as Datalog with limited object-oriented features <ref> [2, 8] </ref> or a C++ type system [11]. Programs are first translated into Horn clause-like programs such as Data-log, and then evaluated with the existing deductive query evaluation methods. Although object-orientation is not explicitly supported, XSB [10] provides a platform for implementing object-orientation with Hilog [1] syntax.
Reference: 9. <author> M. Kifer, G. Lausen, and J. Wu. </author> <title> Logical foundations for object-oriented and frame-based languages. </title> <journal> In Journal of ACM, </journal> <volume> 42, </volume> <year> 1995. </year>
Reference-contexts: In DOOD systems, however, data are grouped around objects described by syntactic notions such as object molecules. Therefore, it is natural to adapt the deductive recursive query evaluation methods and to focus on the evaluation of variables and object molecules. Higher-order features complicate unifications <ref> [9] </ref>. Variables are allowed to appear in the places where class, attribute and method names do. Conventional most general unifiers may not exist and are replaced by the complete sets of most general unifiers [9]. <p> Higher-order features complicate unifications <ref> [9] </ref>. Variables are allowed to appear in the places where class, attribute and method names do. Conventional most general unifiers may not exist and are replaced by the complete sets of most general unifiers [9]. Thus the complexity of the algorithms for unifying two object molecules could be exponential since the number of alternative matches between the two object molecules could be exponential. <p> The saving on navigation cost could be significant if nested attributes are involved. Obviously, query evaluation methods should capture query constraints, especially constraints on higher-order variables and apply the constraints at the early stage of query evaluations. Although a DOOD program can be encoded into a first-order logic program <ref> [1, 9] </ref>, the transformation may produce many predicates and rules. These predicates represent the access of attributes or the invocation of methods. Thus this process may change simple recursions into complex ones. Example 2. (Transforming a DOOD program into a Datalog program). <p> It handles elegantly DOOD features including higher-order ones. Instead of translating programs into Datalog, the method extends the query-independent compilation and chain-based evaluation to process DOOD recursions with normalization. In the rest of the paper, we will use F-logic <ref> [9] </ref> as a research vehicle for the investigation of DOOD query evaluation. F-logic is a logic with higher-order syntax. <p> A rule is non-recursive if none of the object molecules in the rule body is at the same deduction level as the header. 6 Either P 1 can be unified into O 1 or O 1 can be unified into P 1 (see <ref> [9, 12] </ref>). Recursive rule. A rule is recursive if one or more of object molecules in the rule body are at the same deduction level as the header. Linearly recursive rule.
Reference: 10. <author> K. Sagonas, T. Swift, and D. S. Warren. </author> <title> XSB as an efficient deductive database engine. </title> <booktitle> In Proc. 1994 ACM SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pp. 442-453, </pages> <address> Minneapolis, MN, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: The following is a DOOD linearly recursive rule 2 , X : C [F ! U ] Y : C [F ! U 1 ; g ! U 1 ]; p (X; Y; U; U 1 ): where p is a predicate. A transformation similar to using apply/n <ref> [10] </ref> is to translate an attribute into a predicate. <p> Programs are first translated into Horn clause-like programs such as Data-log, and then evaluated with the existing deductive query evaluation methods. Although object-orientation is not explicitly supported, XSB <ref> [10] </ref> provides a platform for implementing object-orientation with Hilog [1] syntax. XSB implements 2 See Definition 4. Hilog by transforming higher-order terms into first-order forms with apply/N, and then compiling and optimizing the first-order forms.
Reference: 11. <author> D. Srivastava, R. Ramakrishnan, P. Seshadri, and S. Sudarshan. </author> <title> Coral++: Adding object-orientation to a logic database language. </title> <booktitle> In Proc. 19th Int. Conf. Very Large Data Bases, </booktitle> <pages> pp. 158-170, </pages> <address> Dublin, Ireland, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: 1 Introduction Although recursive query evaluation has been investigated extensively in deduc tive database systems, it is not well understood whether and how the existing recursive query evaluation methods can be extended naturally to handle DOOD recursive queries <ref> [11] </ref>. In deductive databases, data are conceptually grouped by properties (and often expressed by predicates). The information about one object, e.g., a student, may be spread in different relations which, in turn, are characterized by predicates. <p> Thus the transformation from a DOOD program to a Datalog program may produce more complex recursions than the original ones in DOOD programs. 2 There are research prototypes which integrate object-orientation with deductive database languages, e.g., COMPLEX [2], ConceptBase [8] and Coral++ <ref> [11] </ref>. However, these systems typically extend deductive database languages such as Datalog with limited object-oriented features [2, 8] or a C++ type system [11]. Programs are first translated into Horn clause-like programs such as Data-log, and then evaluated with the existing deductive query evaluation methods. <p> recursions than the original ones in DOOD programs. 2 There are research prototypes which integrate object-orientation with deductive database languages, e.g., COMPLEX [2], ConceptBase [8] and Coral++ <ref> [11] </ref>. However, these systems typically extend deductive database languages such as Datalog with limited object-oriented features [2, 8] or a C++ type system [11]. Programs are first translated into Horn clause-like programs such as Data-log, and then evaluated with the existing deductive query evaluation methods. Although object-orientation is not explicitly supported, XSB [10] provides a platform for implementing object-orientation with Hilog [1] syntax. XSB implements 2 See Definition 4.
Reference: 12. <author> Z. Xie. </author> <title> Query Evaluation in Deductive and Object-Oriented Databases. </title> <type> PhD thesis, </type> <institution> School of Computing Science, Simon Fraser University, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: A rule is non-recursive if none of the object molecules in the rule body is at the same deduction level as the header. 6 Either P 1 can be unified into O 1 or O 1 can be unified into P 1 (see <ref> [9, 12] </ref>). Recursive rule. A rule is recursive if one or more of object molecules in the rule body are at the same deduction level as the header. Linearly recursive rule. <p> Each chain element is a sequence of connected non-recursive object molecules, called a chain generating path. Chain generating paths characterize the periodic property and the regularity of a DOOD linear recursion in expansion. Theorem 6. A single linear recursion can be compiled into chain-forms. Proof. See <ref> [12] </ref>. Example 4. (Compiling a linear recursion into chain form). The following is a linear recursion. The first rule is a linearly recursive rule whereas the second is the exit rule. <p> After the normalization and rectification <ref> [12] </ref>, they become L : Listv [A@M ! N ] L = nil; M = N; apply append (T; A); apply list (T; Listv): L : Listv [A@M ! N ] L 1 : Listv [A@M ! N 1 ]; apply cons (X; L 1 ; L); apply cons (X; N <p> In fact, our method is also applicable to the evaluation of more general class of recursions such as nested linear and non-linear recursions <ref> [12, 5] </ref>. Instead of transforming DOOD programs into Horn-like programs, the DOOD programs are preprocessed into normalized forms. The normalization process helps not only compile and evaluate DOOD recursions but also classify recursions.
References-found: 12

