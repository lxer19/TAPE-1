URL: ftp://ftp.cs.jhu.edu/pub/scott/fods.ps.Z
Refering-URL: http://www.cs.jhu.edu/~scott/homepage/papers.html
Root-URL: http://www.cs.jhu.edu
Email: scott@cs.jhu.edu  
Title: From Operational to Denotational Semantics  
Author: Scott F. Smith 
Date: September 2, 1992  
Address: Baltimore, MD 21218  
Affiliation: Department of Computer Science The Johns Hopkins University  
Abstract: In this paper it is shown how operational semantic methods may be naturally extended to encompass many of the concepts of denotational semantics. This work builds on the standard development of an operational semantics as an interpreter and operational equivalence. The key addition is an operational ordering on sets of terms. From properties of this ordering a closure construction directly yields a fully abstract continuous cpo model. Furthermore, it is not necessary to construct the cpo, for principles such as soundness of fixed-point induction may be obtained by direct reasoning from this new ordering. The end result is that traditional denotational techniques may be applied in a purely operational setting in a natural fashion, a matter of practical importance for developing semantics of realistic programming languages. 
Abstract-found: 1
Intro-found: 1
Reference: [Abr90] <author> S. Abramsky. </author> <title> The lazy lambda calculus. </title> <booktitle> In Research Topics in Functional Programming, </booktitle> <pages> pages 65-116. </pages> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: It also should be mentioned that for simple functional languages like L studied here, denotational models can be altered by various means to achieve fully abstract models <ref> [EHdR92, Abr90] </ref>. 2 Milner, in one of the classic papers of denotational semantics, constructs a fully abstract cpo starting from an operational ordering on terms . Milner proves both respect of computation and congruence by purely syntactic means. <p> This notion in fact originates with Milner [Mil77], and Milner proves the Context Lemma that implies = ap is exactly = obs . fl Abramsky <ref> [Abr90] </ref> and Howe [How89] define an ordering closely related to = ciu and = ap , applicative bisimulation a = bisim b.
Reference: [Blo90] <author> B. Bloom. </author> <title> Can LCF be topped? Information and Computation, </title> <booktitle> 87 </booktitle> <pages> 264-301, </pages> <year> 1990. </year>
Reference-contexts: However, denotational semantics suffers some shortcomings that limits its usefulness, the most well-known being the full abstraction problem. For most languages, equality of the domain does not exactly correspond to the operational equality. A full discussion of this issue is outside the scope of this paper; see for instance <ref> [Sto88, Blo90] </ref>. This paper outlines an approach whereby a purely operational theory of a programming language may be enriched in a natural fashion to incorporate the "denotational" properties listed above. In this paper we carry out the program for a small deterministic functional language L. <p> Proof. Direct from the definitions. qed. We briefly mention some related alternate notions of equivalence that have been proposed for deterministic languages. Bloom's applicative congruence = ap <ref> [Blo90] </ref> for the simply typed language PCF may be viewed as a further restriction on the observation contexts to be those applicative contexts (ffi)(a 0 )(a 1 ) : : : (a n ) that drive the term in the hole to ground type. <p> It is possible to now prove a limited number of contexts suffices for observing differences, and thus &lt; and = are equivalent to &lt; obs and = obs , respectively. This Lemma is similar to Mason and Talcott's ciu theorem [MT91], Milner's Context Lemma [Mil77], and to what Bloom <ref> [Blo90] </ref> calls operational extensionality. Lemma 3.16 (Limited Contexts) (i) a &lt; obs b iff a &lt; (ii) a = obs b iff a = b Proof. (i) ): Show R [[[a oe ]]]# implies R [[[b oe ]]]#.
Reference: [dS69] <author> J. W. deBakker and D. Scott. </author> <title> A theory of programs. </title> <booktitle> unpublished notes, </booktitle> <year> 1969. </year>
Reference: [EHdR92] <author> L. Egidi, F. Honsell, and S. R. della Rocca. </author> <title> Operational, denotational, and logical descriptions: a case study. </title> <note> Fundamenta Informaticae, 1992. (to appear). </note>
Reference-contexts: It also should be mentioned that for simple functional languages like L studied here, denotational models can be altered by various means to achieve fully abstract models <ref> [EHdR92, Abr90] </ref>. 2 Milner, in one of the classic papers of denotational semantics, constructs a fully abstract cpo starting from an operational ordering on terms . Milner proves both respect of computation and congruence by purely syntactic means.
Reference: [FFK87] <author> M. Felleisen, D. Friedman, and E. Kohlbecker. </author> <title> A syntactic theory of sequential control. </title> <journal> Theoretical Computer Science, </journal> <volume> 52 </volume> <pages> 205-237, </pages> <year> 1987. </year>
Reference-contexts: First, an operational semantics for untyped computations is given. We present a rewriting interpreter like the v ! relation of [Plo75], using the more convenient notion of a reduction context (a.k.a. evaluation context) taken from <ref> [FFK87] </ref>. Closed terms are either computations or values. Call-by-value evaluation is deterministic, so at most one reduction applies. C [ffi] denotes a context, a term C with occurrences of atomic holes "ffi" in which another term a may be placed, C [a]. <p> It is necessary to show that every term a can be uniquely factored into a form a = R [[[a 0 ]]] where a 0 is a redex to guarantee a deterministic evaluator for L has been defined <ref> [FFK87] </ref>. Lemma 3.4 (Unique Factorization) If a 7! 1 b then a = R [[[c]]] for some unique reduction context R [[[*]]] and redex c. Proof. By induction on the term structure.
Reference: [GMW79] <author> M. J. Gordon, R. Milner, and C. P. Wadsworth. </author> <title> Edinburgh LCF: A Mechanized Logic of Computation, </title> <booktitle> volume 78 of Lecture notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1979. </year>
Reference-contexts: This allows results (such as Scott fixed-point induction, section 4.3) which have in the past needed continuous cpo models for justification to be proven directly using operational orderings. One concrete example is all the rules of the LCF programming logic <ref> [GMW79] </ref> can be shown sound by this method. This might at first seem surprising, because the rules of LCF were inspired by Scott's domain model.
Reference: [How89] <author> D. J. Howe. </author> <title> Equality in lazy computation systems. </title> <booktitle> In Proceedings of the Fourth Annual Symposium on Logic in Computer Science, </booktitle> <pages> pages 198-203. </pages> <publisher> IEEE, </publisher> <year> 1989. </year>
Reference-contexts: Numerous basic properties are desired, including the respect of computation, for instance requiring plus (3; 2) = 5, and congruence. A number of researchers have developed methods to directly prove these and other basic properties without recourse to domain theory; see for instance Milner [Mil77], Howe <ref> [How89] </ref>, and Mason and Talcott [MT91]. <p> This notion in fact originates with Milner [Mil77], and Milner proves the Context Lemma that implies = ap is exactly = obs . fl Abramsky [Abr90] and Howe <ref> [How89] </ref> define an ordering closely related to = ciu and = ap , applicative bisimulation a = bisim b.
Reference: [Iga72] <author> S. Igarashi. </author> <title> Admissibility of fixed-point induction in first-order logic of typed theories. </title> <type> Technical Report Stan-CS-72-287, </type> <institution> Stanford University Computer Science Department, </institution> <year> 1972. </year>
Reference-contexts: It is a simple matter to extend this theorem to logical formulas in which statements C [Y v (f )] &lt; C 0 [Y v (f )] occur, although only certain admissible formulae admit to fixed-point induction; see <ref> [Pau87, Iga72] </ref>.
Reference: [Man74] <author> Z. Manna. </author> <title> Mathematical Theory of Computation. </title> <publisher> McGraw-Hill, </publisher> <year> 1974. </year>
Reference-contexts: This will be born out in the ideal completion construction in section 5, where the standard definition of ideal completion is modified exactly as just described to construct a cpo. 4.3 Fixed-point induction One of the most useful induction principles is the Scott fixed-point induction principle ([dS69]; see also <ref> [Man74] </ref>). The justification of fixed-point induction necessitates functions be continuous in a domain. All that is needed to justify fixed-point induction here is the Fixed Point Approximation Lemma (4.6) and the &lt; S Substitutivity Theorem (4.4).
Reference: [Mil77] <author> R. Milner. </author> <title> Fully abstract models of typed -calculi. </title> <journal> Theoretical Computer Science, </journal> <volume> 4 </volume> <pages> 1-22, </pages> <year> 1977. </year>
Reference-contexts: Numerous basic properties are desired, including the respect of computation, for instance requiring plus (3; 2) = 5, and congruence. A number of researchers have developed methods to directly prove these and other basic properties without recourse to domain theory; see for instance Milner <ref> [Mil77] </ref>, Howe [How89], and Mason and Talcott [MT91]. <p> This notion in fact originates with Milner <ref> [Mil77] </ref>, and Milner proves the Context Lemma that implies = ap is exactly = obs . fl Abramsky [Abr90] and Howe [How89] define an ordering closely related to = ciu and = ap , applicative bisimulation a = bisim b. <p> It is possible to now prove a limited number of contexts suffices for observing differences, and thus &lt; and = are equivalent to &lt; obs and = obs , respectively. This Lemma is similar to Mason and Talcott's ciu theorem [MT91], Milner's Context Lemma <ref> [Mil77] </ref>, and to what Bloom [Blo90] calls operational extensionality. Lemma 3.16 (Limited Contexts) (i) a &lt; obs b iff a &lt; (ii) a = obs b iff a = b Proof. (i) ): Show R [[[a oe ]]]# implies R [[[b oe ]]]#.
Reference: [MPS84] <author> D. B. MacQueen, G. Plotkin, and R. Sethi. </author> <title> An ideal model of types. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1984. </year>
Reference-contexts: Theories of program equivalence arise directly from domain orderings. The notions of directed set, least upper bound and continuity lead to a least fixed-point induction principle. Ideal sets, defined in terms of least upper bounds, are a general notion of data type <ref> [MPS84] </ref>. However, denotational semantics suffers some shortcomings that limits its usefulness, the most well-known being the full abstraction problem. For most languages, equality of the domain does not exactly correspond to the operational equality.
Reference: [MT91] <author> I. A. Mason and C. L. Talcott. </author> <title> Equivalence in functional languages with effects. </title> <journal> Journal of Functional Programming, </journal> <volume> 1 </volume> <pages> 287-327, </pages> <year> 1991. </year>
Reference-contexts: A number of researchers have developed methods to directly prove these and other basic properties without recourse to domain theory; see for instance Milner [Mil77], Howe [How89], and Mason and Talcott <ref> [MT91] </ref>. <p> We define such an alternate notion in this paper, restricting contexts to be closed instances of all uses of an expression. This equivalence is thus called ciu equivalence = ciu , following <ref> [MT91] </ref>. a = ciu b means a and b behave identically when closed (the closed instances part) and placed in any reduction context R [[[*]]] (the uses part). <p> Theorem 3.12 ( = Congruence) If a = b then C [a] = C [b]. The proof given here is derived from the proof found in <ref> [MT91] </ref>. Mason and Talcott prove this property by direct induction on the length of the computation C [a]. <p> It is possible to now prove a limited number of contexts suffices for observing differences, and thus &lt; and = are equivalent to &lt; obs and = obs , respectively. This Lemma is similar to Mason and Talcott's ciu theorem <ref> [MT91] </ref>, Milner's Context Lemma [Mil77], and to what Bloom [Blo90] calls operational extensionality. Lemma 3.16 (Limited Contexts) (i) a &lt; obs b iff a &lt; (ii) a = obs b iff a = b Proof. (i) ): Show R [[[a oe ]]]# implies R [[[b oe ]]]#. <p> The methods used to develop the operational theory herein are simple, and we plan to show in future papers applicability to a wide range of languages, including typed, nondeterministic, and imperative languages. Concrete evidence of feasibility of this task is the work of Talcott and Mason <ref> [Tal89, MT91] </ref>, where, working with languages wth first-class continuations and memories, they use the same general techniques to prove a subset of the basic results obtained here. Acknowledgements I owe many thanks to Carolyn Talcott for important suggestions and comments. Thanks also to Albert Meyer for useful comments. 18
Reference: [Pau87] <author> L. C. Paulson. </author> <title> Logic and Computation: Interactive Proof with Cambridge LCF. </title> <address> Cam-bridge, </address> <year> 1987. </year>
Reference-contexts: It is a simple matter to extend this theorem to logical formulas in which statements C [Y v (f )] &lt; C 0 [Y v (f )] occur, although only certain admissible formulae admit to fixed-point induction; see <ref> [Pau87, Iga72] </ref>.
Reference: [Plo75] <author> G. Plotkin. </author> <title> Call-by-name, call-by-value, and the -calculus. </title> <booktitle> Theoretical Computer Science, </booktitle> <pages> pages 125-159, </pages> <year> 1975. </year>
Reference-contexts: A term is closed if all variables occurring are bound. a = b means a and b are identical modulo ff-conversion. First, an operational semantics for untyped computations is given. We present a rewriting interpreter like the v ! relation of <ref> [Plo75] </ref>, using the more convenient notion of a reduction context (a.k.a. evaluation context) taken from [FFK87]. Closed terms are either computations or values. Call-by-value evaluation is deterministic, so at most one reduction applies.
Reference: [Plo77] <author> G. Plotkin. </author> <title> LCF considered as a programming language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5 </volume> <pages> 223-255, </pages> <year> 1977. </year>
Reference: [Sco76] <author> D. Scott. </author> <title> Data types as lattices. </title> <journal> SIAM J. Computing, </journal> <volume> 5 </volume> <pages> 522-587, </pages> <year> 1976. </year>
Reference: [Smi92a] <author> S. F. Smith. </author> <title> From operational to denotational semantics. </title> <booktitle> In MFPS 1991, volume 598 of Lecture notes in Computer Science, </booktitle> <pages> pages 54-76. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: We choose call-by-value evaluation because it is slightly more challenging than call-by-name; an earlier version of this work incorporated call-by-name evaluation <ref> [Smi92a] </ref>.
Reference: [Smi92b] <author> S. F. Smith. </author> <title> Partial computations in constructive type theory. </title> <note> Submitted to Journal of Logic and Computation, 1992. 19 </note>
Reference-contexts: One alternative for a programming logic the above proof suggests is to axiomatize = S in a theory, and then derive instances of fixed-point induction as necessary; such a logic is defined in <ref> [Smi92b] </ref>. 4.4 An Operational Theory of L Now that the mathematical development is complete, we may collect together the basic results which form the core of a purely operational theory of L. (i) &lt; / = Properties Lemma (3.11). (ii) &lt; Substitutivity Theorem (3.15). (iii) &lt; Extensionality Lemma (3.17). (iv) &lt;
Reference: [Sto88] <author> A. Stoughton. </author> <title> Fully abstract models of programming languages. </title> <booktitle> Research notes in the-oretical computer science. </booktitle> <publisher> Pitman, </publisher> <year> 1988. </year>
Reference-contexts: However, denotational semantics suffers some shortcomings that limits its usefulness, the most well-known being the full abstraction problem. For most languages, equality of the domain does not exactly correspond to the operational equality. A full discussion of this issue is outside the scope of this paper; see for instance <ref> [Sto88, Blo90] </ref>. This paper outlines an approach whereby a purely operational theory of a programming language may be enriched in a natural fashion to incorporate the "denotational" properties listed above. In this paper we carry out the program for a small deterministic functional language L. <p> We construct a completion embedding of &lt; into a cpo, using a minor variation on the standard ideal completion construction, following the development of <ref> [Sto88] </ref>. It should be emphasized there is no reason to carry out the completion of &lt; for purposes of giving programs meaning; the main purpose of this argument is to show how close a rich operational theory can be to a good cpo model.
Reference: [Tal89] <author> C. L. Talcott. </author> <title> Programming and proving with function and control abstractions. </title> <type> Technical Report STAN-CS-89-1288, </type> <institution> Stanford University, Stanford, </institution> <address> CA 94305, </address> <year> 1989. </year> <month> 20 </month>
Reference-contexts: proving substitutivity of an ordering &lt; S on directed sets of terms which then leads to direct proofs of least fixed point and fixed point induction theorems, two theorems that have tradionally required domain theory to prove (with the exception of Talcott's direct proof of the least fixed point principle <ref> [Tal89] </ref>). The relations &lt; and &lt; S and associated properties can then be used to construct fully abstract cpos, showing a rich operational theory has expressive power comparable to domain theory. <p> The methods used to develop the operational theory herein are simple, and we plan to show in future papers applicability to a wide range of languages, including typed, nondeterministic, and imperative languages. Concrete evidence of feasibility of this task is the work of Talcott and Mason <ref> [Tal89, MT91] </ref>, where, working with languages wth first-class continuations and memories, they use the same general techniques to prove a subset of the basic results obtained here. Acknowledgements I owe many thanks to Carolyn Talcott for important suggestions and comments. Thanks also to Albert Meyer for useful comments. 18
References-found: 20

