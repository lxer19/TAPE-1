URL: ftp://ftp.cs.concordia.ca/pub/laks/papers/infoSystems94.ps.gz
Refering-URL: http://www.cs.concordia.ca/~faculty/laks/papers.html
Root-URL: http://www.cs.concordia.ca
Title: EVALUATION OF REGULAR NONLINEAR RECURSIONS BY DEDUCTIVE DATABASE TECHNIQUES  
Author: Jiawei Han and Laks V.S. Lakshmanan 
Keyword: Key words: Deductive database, logic programming, declarative programs, implementation techniques, recursive query evaluation, nonlinear recursion, regular nonlinear recursion.  
Address: Canada V5A 1S6  Montreal, Quebec, Canada H3G 1M8  
Affiliation: 1 School of Computing Science, Simon Fraser University, British Columbia,  Department of Computer Science, Concordia University,  
Note: Pergamon Information Systems Vol. 19, No. 4, pp. 33-54, 1994 Copyright c 1994 Elsevier Science Ltd Printed in Great Britain. All rights reserved  in final revised form  
Phone: 0306-4379/94 $7.00 0.00  2  
Date: (Received 18 June 1993;  1 November 1993)  
Abstract: Nonlinear recursion is one of the most challenging classes of logic programs for efficient evaluation in logic programming systems. We identify one popular class of nonlinear recursion, regular nonlinear recursion, and investigate its efficient implementation by a deductive database approach. The approach performs a detailed query binding analysis based on query information, constraint information and the structure of a recursion, selects an appropriate predicate evaluation order and generates an efficient query evaluation plan. Interesting query evaluation techniques, such as chain-following, chain-split, and constraint pushing, are developed for the efficient evaluation of different kinds of queries. Furthermore, the technique can be extended to the evaluation of regular nonlinear recursions in HiLog and F-logic programs. The study not only presents a method for the evaluation of regular nonlinear recursions in a declarative way but also demonstrates the power of the deductive database approach in the analysis and evaluation of sophisticated logic programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. D. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proc. 5th ACM Symp. Principles of Database Systems, </booktitle> <pages> pp. 1-15, </pages> <address> Cambridge, MA (1986). </address>
Reference-contexts: 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [14, 1, 2, 4, 42, 22, 31, 39, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research [14, 1, 2, 4, 42, 22, 31, 39, 11]. Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets <ref> [1] </ref>, counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. <p> 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research [14, 1, 2, 4, 42, 22, 31, 39, 11]. Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets <ref> [1] </ref>, counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions.
Reference: [2] <author> F. Bancilhon and R. Ramakrishnan. </author> <title> An amateur's introduction to recursive query processing strategies. </title> <booktitle> In Proc. 1986 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pp. 16-52, </pages> <address> Washington, DC (1986). </address>
Reference-contexts: 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [14, 1, 2, 4, 42, 22, 31, 39, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> In Section 5, we discuss the extension of the method to the evaluation of HiLog and F-logic programs, the efficiency of the evaluation method in comparison with others, and the implementation considerations. The study is summarized in Section 6. 2. REGULAR AND IRREGULAR NONLINEAR RECURSIONS Like many researchers <ref> [39, 2] </ref>, we assume that a deductive database is partitioned into three portions: (i) an extensional database (EDB) (a set of database relations), (ii) an intensional database (IDB) (a set of predicates defined by Horn-clause rules), and (iii) a set of integrity constraints (ICs). <p> Similar to the notations used in the magic sets transformation <ref> [2, 39] </ref>, a superscript b or f is used to adorn a variable to indicate the variable being bound or free, and a string of b's and f 's used to adorn a predicate to indicate the bindings of its corresponding arguments. <p> The nonlinear recursions which are linearizable (such as ancestor) are excluded from this discussion since they can be transformed into equivalent linear ones and be evaluated efficiently by linear recursive query evaluation techniques <ref> [2] </ref>. Since a functional recursion should be first rectified into a function-free one, many previously developed query evaluation techniques [2, 11] for function-free recursions may still be applicable to the rectified recursions. However, a rectified functional predicate may correspond to an infinite relation. <p> Since a functional recursion should be first rectified into a function-free one, many previously developed query evaluation techniques <ref> [2, 11] </ref> for function-free recursions may still be applicable to the rectified recursions. However, a rectified functional predicate may correspond to an infinite relation. The semi-naive bottom-up evaluation may not terminate on such recursions. <p> Similar to the dynamic query plan generation and query optimization in relational systems [39], one can only expect to derive suboptimal query evaluation plans at a reasonable cost of query optimization <ref> [2, 24] </ref>. 5. DISCUSSION 5.1. Evaluation of nonlinear recursions in F-Logic and HiLog programs Studies on deductive and object-oriented databases have led to several interesting logic-based languages, such as F-logic [21], HiLog [8], XSQL [20], etc.
Reference: [3] <author> C. Beeri, P. Kanellakis, F. Bancilhon, and R. Ramakrishnan. </author> <title> Bounds on the propagation of selection into logic programs. </title> <booktitle> In Proc. 6th ACM Symp. Principles of Database Systems, </booktitle> <pages> pp. 214-226, </pages> <address> San Diego, CA (1987). </address>
Reference-contexts: It is performed using the methods discussed in Section 3. Step 2 is necessary and correct since the correct ordering of the predicates will lead to finite and efficient evaluation. Step 3 is correct because the most selective information should be pushed into the rectified chain for initial processing <ref> [3] </ref>. The iterative query evaluation can be determined by the query binding analysis because the binding information can be passed to the next iteration based on the regularity of the recursion.
Reference: [4] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the power of magic. </title> <booktitle> In Proc. 6th ACM Symp. Principles of Database Systems, </booktitle> <pages> pp. 269-283, </pages> <address> San Diego, CA (1987). </address>
Reference-contexts: 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [14, 1, 2, 4, 42, 22, 31, 39, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research [14, 1, 2, 4, 42, 22, 31, 39, 11]. Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets [1], counting [1], generalized magic sets <ref> [4] </ref>, generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. <p> Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets [1], counting [1], generalized magic sets <ref> [4] </ref>, generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. <p> For brevity, this is not shown in the paper. The evaluation of query "? qsort (<ref> [4; 9; 5] </ref>; Y s):" proceeds as follows. * The evaluation of (20) leads to qsort ([4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (25) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 &gt; 4; <p> It in turn derives "XLs = []" and "Bs = [5]" in (27) and "XLs = []" and "XBs = [9; 5]" in (26). (25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; <ref> [4; 9; 5] </ref>); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (28) * The evaluation of "qsort ([]; Ls)" applying the rule (21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (XXs; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (XXs; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (XXs; Y s), in which the second argument is bound but the first one is free. <p> In this case, the answer to the query will be all of the possible alternatives in XXs corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (XXs; <ref> [4; 5; 9] </ref>)", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. <p> In this case, the answer to the query will be all of the possible alternatives in XXs corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f <ref> [4, 5, 9] </ref>, [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> In this case, the answer to the query will be all of the possible alternatives in XXs corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], <ref> [4, 9, 5] </ref>, [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> In this case, the answer to the query will be all of the possible alternatives in XXs corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], <ref> [5, 4, 9] </ref>, [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], <ref> [5, 9, 4] </ref>, [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], <ref> [9, 4, 5] </ref>, [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], <ref> [9, 5, 4] </ref>g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; <ref> [9; 4; 5] </ref>)" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. Constraint pushing in chain-based evaluation Constraint-based evaluation [17, 15, 10] is used when a query provides constraints which may help reduce the search space in the iterative evaluation. <p> However, constraint information provided in the query but not directly associated with the starting point should also be explored for efficient evaluation. Example 12 Suppose the query on the quick sort recursion is posed as, "?qsort ([5jXs]; <ref> [4; 5; 9] </ref>)". <p> The evaluation of query "? qsort ([5jXs]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; <p> The evaluation of query "? qsort ([5jXs]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> The evaluation of query "? qsort ([5jXs]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> The evaluation of query "? qsort ([5jXs]; [4; 5; 9])" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append (<ref> [4] </ref>; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> 9])" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; <ref> [4; 5; 9] </ref>) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> However, its following predicate cons (5; Bs; XBs) will remove all the other possibilities and leave only one valid answer, "Ls = <ref> [4] </ref>" and "XBs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is <p> However, its following predicate cons (5; Bs; XBs) will remove all the other possibilities and leave only one valid answer, "Ls = <ref> [4] </ref>" and "XBs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); <p> However, its following predicate cons (5; Bs; XBs) will remove all the other possibilities and leave only one valid answer, "Ls = <ref> [4] </ref>" and "XBs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; <p> the other possibilities and leave only one valid answer, "Ls = <ref> [4] </ref>" and "XBs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; <p> "Ls = <ref> [4] </ref>" and "XBs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition <p> The evaluation for qsort (Littles; <ref> [4] </ref>) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition <p> <ref> [4] </ref>) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; <p> (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = <ref> [4; 9] </ref>: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be Xs = <p> performed as follows. partition (Xs; 5; <ref> [4] </ref>; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be Xs = f [4; 9]; [9; 4]g. <p> <ref> [4] </ref>); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be Xs = f [4; 9]; [9; 4]g. <p> % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; <ref> [4] </ref>; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be Xs = f [4; 9]; [9; 4]g. <p> cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs 0 ; Xs): % which derives Xs = <ref> [9; 4] </ref>: Therefore, the answer to the query should be Xs = f [4; 9]; [9; 4]g. Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([XjXs]; [4; 5; 9]); X &gt; 4". <p> partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be Xs = f <ref> [4; 9] </ref>; [9; 4]g. Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([XjXs]; [4; 5; 9]); X &gt; 4". The analysis will derive a similar query evaluation plan and generate all the possible answers for X and Xs. 2 4.5. <p> 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs 0 ; Xs): % which derives Xs = <ref> [9; 4] </ref>: Therefore, the answer to the query should be Xs = f [4; 9]; [9; 4]g. Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([XjXs]; [4; 5; 9]); X &gt; 4". The analysis will derive a similar query evaluation plan and generate all the possible answers for X and Xs. 2 4.5. <p> Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([XjXs]; <ref> [4; 5; 9] </ref>); X &gt; 4". The analysis will derive a similar query evaluation plan and generate all the possible answers for X and Xs. 2 4.5. <p> Furthermore, the evaluation is tuple-oriented, which is inefficient in database environments. Recent studies in deductive database research have proposed the use of the generalized magic sets method in the evaluation of nonlinear recursions <ref> [4, 39, 9] </ref>. The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation.
Reference: [5] <author> A. Brodsky and Y. Sagiv. </author> <title> On termination of datalog programs. </title> <booktitle> In Proc. 1st Int. Conf. Deductive and Object-Oriented Databases (DOOD'89), </booktitle> <pages> pp. 95-112, </pages> <address> Kyoto, Japan (1989). </address>
Reference-contexts: However, a weakly finitely evaluable recursive query guarantees only a finite intermediate relation at each iteration but not the termination of iterative processing. Monotonicity constraints are often useful for the termination of iterative processing <ref> [5, 6, 40] </ref>. <p> Chain-split is also performed in the evaluation of append bbf . For brevity, this is not shown in the paper. The evaluation of query "? qsort ([4; 9; 5]; Y s):" proceeds as follows. * The evaluation of (20) leads to qsort ([4; 9; 5]; Y s) cons (4; <ref> [9; 5] </ref>; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (25) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 <p> For brevity, this is not shown in the paper. The evaluation of query "? qsort (<ref> [4; 9; 5] </ref>; Y s):" proceeds as follows. * The evaluation of (20) leads to qsort ([4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (25) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 &gt; 4; <p> s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (25) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; <ref> [5] </ref>; [9; 5]); 9 &gt; 4; partition ([5]; 4; XLs; Bs); cons (9; Bs; XBs): (26) * This leads to the evaluation of "partition ([5]; 4; XLs; Bs)", partition ([5]; 4; XLs; Bs) cons (5; []; [5]); 5 &gt; 4; partition ([]; 4; XLs; Bs 0 ); cons (5; Bs 0 <p> cons (4; <ref> [9; 5] </ref>; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (25) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 &gt; 4; partition ([5]; 4; XLs; Bs); cons (9; Bs; XBs): (26) * This leads to the evaluation of "partition ([5]; 4; XLs; Bs)", partition ([5]; 4; XLs; Bs) cons (5; []; [5]); 5 &gt; 4; partition ([]; 4; XLs; Bs 0 ); cons (5; Bs 0 ; <p> 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; <ref> [5] </ref>; [9; 5]); 9 &gt; 4; partition ([5]; 4; XLs; Bs); cons (9; Bs; XBs): (26) * This leads to the evaluation of "partition ([5]; 4; XLs; Bs)", partition ([5]; 4; XLs; Bs) cons (5; []; [5]); 5 &gt; 4; partition ([]; 4; XLs; Bs 0 ); cons (5; Bs 0 ; Bs): (27) * The evaluation of "partition ([]; 4; XLs; Bs 0 )" applying rule (24) derives "XLs = []" and "Bs 0 = []". <p> It in turn derives "XLs = []" and "Bs = <ref> [5] </ref>" in (27) and "XLs = []" and "XBs = [9; 5]" in (26). (25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; <p> It in turn derives "XLs = []" and "Bs = [5]" in (27) and "XLs = []" and "XBs = <ref> [9; 5] </ref>" in (26). (25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (28) * The evaluation of "qsort ([]; Ls)" <p> It in turn derives "XLs = []" and "Bs = [5]" in (27) and "XLs = []" and "XBs = <ref> [9; 5] </ref>" in (26). (25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (28) * The evaluation of "qsort ([]; Ls)" applying the rule (21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; <p> It in turn derives "XLs = []" and "Bs = [5]" in (27) and "XLs = []" and "XBs = [9; 5]" in (26). (25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; <ref> [4; 9; 5] </ref>); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (28) * The evaluation of "qsort ([]; Ls)" applying the rule (21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads <p> It in turn derives "XLs = []" and "Bs = [5]" in (27) and "XLs = []" and "XBs = <ref> [9; 5] </ref>" in (26). (25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (28) * The evaluation of "qsort ([]; Ls)" applying the rule (21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads to "Bs = [5; 9]" by a similar <p> ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (28) * The evaluation of "qsort ([]; Ls)" applying the rule (21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads to "Bs = <ref> [5; 9] </ref>" by a similar process applying the rule (20). Finally, "cons (4; [5; 9]; [4; 5; 9]), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". <p> cons (4; Bs; XBs); append (Ls; XBs; Y s): (28) * The evaluation of "qsort ([]; Ls)" applying the rule (21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads to "Bs = <ref> [5; 9] </ref>" by a similar process applying the rule (20). Finally, "cons (4; [5; 9]; [4; 5; 9]), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (XXs; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (XXs; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (XXs; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (XXs; Y s), in which the second argument is bound but the first one is free. <p> In this case, the answer to the query will be all of the possible alternatives in XXs corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (XXs; <ref> [4; 5; 9] </ref>)", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. <p> In this case, the answer to the query will be all of the possible alternatives in XXs corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f <ref> [4, 5, 9] </ref>, [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> In this case, the answer to the query will be all of the possible alternatives in XXs corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], <ref> [4, 9, 5] </ref>, [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> In this case, the answer to the query will be all of the possible alternatives in XXs corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], <ref> [5, 4, 9] </ref>, [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], <ref> [5, 9, 4] </ref>, [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], <ref> [9, 4, 5] </ref>, [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], <ref> [9, 5, 4] </ref>g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; <ref> [9; 4; 5] </ref>)" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. Constraint pushing in chain-based evaluation Constraint-based evaluation [17, 15, 10] is used when a query provides constraints which may help reduce the search space in the iterative evaluation. <p> However, constraint information provided in the query but not directly associated with the starting point should also be explored for efficient evaluation. Example 12 Suppose the query on the quick sort recursion is posed as, "?qsort ([5jXs]; <ref> [4; 5; 9] </ref>)". <p> The evaluation of query "? qsort ([5jXs]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; <p> The evaluation of query "? qsort ([5jXs]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> The evaluation of query "? qsort ([5jXs]; [4; 5; 9])" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; <ref> [5; 9] </ref>; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> The evaluation of query "? qsort ([5jXs]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> The evaluation of query "? qsort ([5jXs]; [4; 5; 9])" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; <ref> [5; 9] </ref>; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> 9])" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; <ref> [4; 5; 9] </ref>) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> However, its following predicate cons (5; Bs; XBs) will remove all the other possibilities and leave only one valid answer, "Ls = [4]" and "XBs = <ref> [5; 9] </ref>". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition <p> Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([XjXs]; <ref> [4; 5; 9] </ref>); X &gt; 4". The analysis will derive a similar query evaluation plan and generate all the possible answers for X and Xs. 2 4.5. <p> The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases [39, 26, 13, 7, 28, 29] and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols <ref> [32, 5, 19, 34, 10] </ref>. In this sense, it is a continuation of the traditional work in deductive databases. The general philosophy of our evaluation method is, however, different from that of the generalized magic sets method.
Reference: [6] <author> A. Brodsky and Y. Sagiv. </author> <title> Inference of inequality constraints in logic programs. </title> <booktitle> In Proc. 10th ACM Symp. Principles of Database Systems, </booktitle> <pages> pp. 227-240, </pages> <address> Denver, CO (1991). </address>
Reference-contexts: However, a weakly finitely evaluable recursive query guarantees only a finite intermediate relation at each iteration but not the termination of iterative processing. Monotonicity constraints are often useful for the termination of iterative processing <ref> [5, 6, 40] </ref>. <p> The discovery of relationships or constraints among argument sizes in logic programs has been studied recently <ref> [40, 41, 6, 36, 30] </ref>. The discovery of the relationships of list length among the list-typed arguments belongs to this category. Example 8 According to the definition of the hanoi recursion, the following properties about the length of the list arguments can be observed. 1.
Reference: [7] <author> F. Bry. </author> <title> Query evaluation in recursive databases: Bottom-up and top-down reconciled. </title> <editor> In W. Kim, J.-M. Nicolas, and S. Nishio, editors, </editor> <booktitle> Deductive and Object-Oriented Databases, </booktitle> <pages> pp. 25-44. </pages> <address> Elsevier Science (1990). </address>
Reference-contexts: The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases <ref> [39, 26, 13, 7, 28, 29] </ref> and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols [32, 5, 19, 34, 10]. In this sense, it is a continuation of the traditional work in deductive databases.
Reference: [8] <author> W. Chen, M. Kifer, and D. S. Warren. Hilog: </author> <title> A foundation for higher-order logic programming. </title> <journal> J. Logic Programming, </journal> <volume> 15 </volume> <month> 187-230 </month> <year> (1993). </year>
Reference-contexts: DISCUSSION 5.1. Evaluation of nonlinear recursions in F-Logic and HiLog programs Studies on deductive and object-oriented databases have led to several interesting logic-based languages, such as F-logic [21], HiLog <ref> [8] </ref>, XSQL [20], etc. Interestingly, the chain-based evaluation method can be extended naturally to the evaluation of regular nonlinear recursions in such programs. Taking HiLog as an example, the quick sort program presented in Example 11 can be extended to incorporate module facility in HiLog [8]. <p> such as F-logic [21], HiLog <ref> [8] </ref>, XSQL [20], etc. Interestingly, the chain-based evaluation method can be extended naturally to the evaluation of regular nonlinear recursions in such programs. Taking HiLog as an example, the quick sort program presented in Example 11 can be extended to incorporate module facility in HiLog [8]. Example 13 The quick sort recursion shown in Example 11 can be turned into a module definition in HiLog to provide an alternative semantics for modular logic programming. Similar to [8], let P artition be an internal predicate, Sort be an external predicate, append and cons be global predicates defined <p> an example, the quick sort program presented in Example 11 can be extended to incorporate module facility in HiLog <ref> [8] </ref>. Example 13 The quick sort recursion shown in Example 11 can be turned into a module definition in HiLog to provide an alternative semantics for modular logic programming. Similar to [8], let P artition be an internal predicate, Sort be an external predicate, append and cons be global predicates defined outside of the module, and Order be a parameter which can be instantiated to any binary predicate of the user's choice.
Reference: [9] <author> D. Chimenti, R. Gamboa, R. Krishnamurthy, S. Naqvi, S. Tsur, and C. Zaniolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 2 </volume> <month> 76-90 </month> <year> (1990). </year>
Reference-contexts: Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. However, many application programs involve complex recursions with function symbols <ref> [38, 9, 39, 27] </ref>. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs. <p> Chain-split is also performed in the evaluation of append bbf . For brevity, this is not shown in the paper. The evaluation of query "? qsort ([4; 9; 5]; Y s):" proceeds as follows. * The evaluation of (20) leads to qsort ([4; 9; 5]; Y s) cons (4; <ref> [9; 5] </ref>; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (25) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 <p> For brevity, this is not shown in the paper. The evaluation of query "? qsort (<ref> [4; 9; 5] </ref>; Y s):" proceeds as follows. * The evaluation of (20) leads to qsort ([4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (25) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 &gt; 4; <p> cons (4; <ref> [9; 5] </ref>; [4; 9; 5]); partition ([9; 5]; 4; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (25) * The evaluation of "partition ([9; 5]; 4; Littles; Bigs)" leads to partition ([9; 5]; 4; XLs; XBs) cons (9; [5]; [9; 5]); 9 &gt; 4; partition ([5]; 4; XLs; Bs); cons (9; Bs; XBs): (26) * This leads to the evaluation of "partition ([5]; 4; XLs; Bs)", partition ([5]; 4; XLs; Bs) cons (5; []; [5]); 5 &gt; 4; partition ([]; 4; XLs; Bs 0 ); cons (5; Bs 0 ; <p> It in turn derives "XLs = []" and "Bs = [5]" in (27) and "XLs = []" and "XBs = <ref> [9; 5] </ref>" in (26). (25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (28) * The evaluation of "qsort ([]; Ls)" <p> It in turn derives "XLs = []" and "Bs = [5]" in (27) and "XLs = []" and "XBs = <ref> [9; 5] </ref>" in (26). (25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (28) * The evaluation of "qsort ([]; Ls)" applying the rule (21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; <p> It in turn derives "XLs = []" and "Bs = [5]" in (27) and "XLs = []" and "XBs = [9; 5]" in (26). (25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; <ref> [4; 9; 5] </ref>); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (28) * The evaluation of "qsort ([]; Ls)" applying the rule (21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads <p> It in turn derives "XLs = []" and "Bs = [5]" in (27) and "XLs = []" and "XBs = <ref> [9; 5] </ref>" in (26). (25) now becomes qsort (4; 9; 5]; Y s) cons (4; [9; 5]; [4; 9; 5]); partition ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (28) * The evaluation of "qsort ([]; Ls)" applying the rule (21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads to "Bs = [5; 9]" by a similar <p> ([9; 5]; 4; []; [9; 5]); qsort ([]; Ls); qsort ([9; 5]; Bs); cons (4; Bs; XBs); append (Ls; XBs; Y s): (28) * The evaluation of "qsort ([]; Ls)" applying the rule (21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads to "Bs = <ref> [5; 9] </ref>" by a similar process applying the rule (20). Finally, "cons (4; [5; 9]; [4; 5; 9]), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". <p> cons (4; Bs; XBs); append (Ls; XBs; Y s): (28) * The evaluation of "qsort ([]; Ls)" applying the rule (21) derives "Ls = []", and the evaluation of "qsort ([9; 5]; Bs)" leads to "Bs = <ref> [5; 9] </ref>" by a similar process applying the rule (20). Finally, "cons (4; [5; 9]; [4; 5; 9]), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (XXs; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (XXs; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (XXs; Y s), in which the second argument is bound but the first one is free. <p> Finally, "cons (4; [5; 9]; <ref> [4; 5; 9] </ref>), append ([]; [4; 5; 9]; Y s)" leads to "Y s = [4; 5; 9]". Similar query binding analysis can be performed on qsort fb (XXs; Y s), in which the second argument is bound but the first one is free. <p> In this case, the answer to the query will be all of the possible alternatives in XXs corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (XXs; <ref> [4; 5; 9] </ref>)", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. <p> In this case, the answer to the query will be all of the possible alternatives in XXs corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f <ref> [4, 5, 9] </ref>, [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> In this case, the answer to the query will be all of the possible alternatives in XXs corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], <ref> [4, 9, 5] </ref>, [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> In this case, the answer to the query will be all of the possible alternatives in XXs corresponding to a sorted list Y s. For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], <ref> [5, 4, 9] </ref>, [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], <ref> [5, 9, 4] </ref>, [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], <ref> [9, 4, 5] </ref>, [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], <ref> [9, 5, 4] </ref>g"; whereas the evaluation of "? qsort (XXs; [9; 4; 5])" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. <p> For example, the evaluation of a query, "? qsort (XXs; [4; 5; 9])", will lead to "XXs = f [4, 5, 9], [4, 9, 5], [5, 4, 9], [5, 9, 4], [9, 4, 5], [9, 5, 4]g"; whereas the evaluation of "? qsort (XXs; <ref> [9; 4; 5] </ref>)" will lead to no answer. 2 46 Jiawei Han and Laks V.S. Lakshmanan 4.4. Constraint pushing in chain-based evaluation Constraint-based evaluation [17, 15, 10] is used when a query provides constraints which may help reduce the search space in the iterative evaluation. <p> However, constraint information provided in the query but not directly associated with the starting point should also be explored for efficient evaluation. Example 12 Suppose the query on the quick sort recursion is posed as, "?qsort ([5jXs]; <ref> [4; 5; 9] </ref>)". <p> The evaluation of query "? qsort ([5jXs]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; <p> The evaluation of query "? qsort ([5jXs]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> The evaluation of query "? qsort ([5jXs]; [4; 5; 9])" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; <ref> [5; 9] </ref>; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> The evaluation of query "? qsort ([5jXs]; <ref> [4; 5; 9] </ref>)" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> The evaluation of query "? qsort ([5jXs]; [4; 5; 9])" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; <ref> [9] </ref>; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> The evaluation of query "? qsort ([5jXs]; [4; 5; 9])" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; <ref> [5; 9] </ref>; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> The evaluation of query "? qsort ([5jXs]; [4; 5; 9])" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; [4; 5; 9]) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; <ref> [9] </ref>; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> 9])" proceeds as follows. * The evaluation of (34) leads to qsort ([5jXs]; <ref> [4; 5; 9] </ref>) cons (5; Xs; [5jXs]); append ([4]; [5; 9]; [4; 5; 9]); cons (5; [9]; [5; 9]); qsort (Littles; [4]); qsort (Bigs; [9]); partition fbbb (Xs; 5; Littles; Bigs): (35) Notice that append (Ls; XBs; [4; 5; 9]) may derive a set of values for Ls and XBs. <p> However, its following predicate cons (5; Bs; XBs) will remove all the other possibilities and leave only one valid answer, "Ls = [4]" and "XBs = <ref> [5; 9] </ref>". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; [9]) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition <p> However, its following predicate cons (5; Bs; XBs) will remove all the other possibilities and leave only one valid answer, "Ls = [4]" and "XBs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; <ref> [9] </ref>) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs <p> However, its following predicate cons (5; Bs; XBs) will remove all the other possibilities and leave only one valid answer, "Ls = [4]" and "XBs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; <ref> [9] </ref>) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of <p> other possibilities and leave only one valid answer, "Ls = [4]" and "XBs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; <ref> [9] </ref>) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): <p> = [4]" and "XBs = [5; 9]". * The evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; <ref> [9] </ref>) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; <p> evaluation for qsort (Littles; [4]) leads to "Littles = [4]"; whereas that for qsort (Bigs; <ref> [9] </ref>) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs <p> that for qsort (Bigs; <ref> [9] </ref>) leads to "Bigs = [9]", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = <p> "Bigs = <ref> [9] </ref>", and the requirement becomes the evaluation for "partition (Xs; 5; [4]; [9])". * The evaluation of "partition (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs <p> (Xs; 5; [4]; [9])" is performed as follows. partition (Xs; 5; [4]; [9]) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = <ref> [4; 9] </ref>: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be Xs = <p> as follows. partition (Xs; 5; [4]; <ref> [9] </ref>) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be Xs = f [4; 9]; [9; 4]g. <p> 5; [4]; <ref> [9] </ref>) cons (4; []; [4]); partition (Xs 0 ; 5; []; [9]); % which derives Xs 0 = [9]: Evaluation of Regular Nonlinear Recursions 47 4 5; cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be Xs = f [4; 9]; [9; 4]g. <p> cons (4; Xs 0 ; Xs): % which derives Xs = [4; 9]: partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs 0 ; Xs): % which derives Xs = <ref> [9; 4] </ref>: Therefore, the answer to the query should be Xs = f [4; 9]; [9; 4]g. Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([XjXs]; [4; 5; 9]); X &gt; 4". <p> partition (Xs; 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs 0 ; Xs): % which derives Xs = [9; 4]: Therefore, the answer to the query should be Xs = f <ref> [4; 9] </ref>; [9; 4]g. Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([XjXs]; [4; 5; 9]); X &gt; 4". The analysis will derive a similar query evaluation plan and generate all the possible answers for X and Xs. 2 4.5. <p> 5; [4]; [9]) cons (9; []; [9]); partition (Xs 0 ; 5; [4]; []); % which derives Xs 0 = [4]: 9 &gt; 5; cons (9; Xs 0 ; Xs): % which derives Xs = <ref> [9; 4] </ref>: Therefore, the answer to the query should be Xs = f [4; 9]; [9; 4]g. Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([XjXs]; [4; 5; 9]); X &gt; 4". The analysis will derive a similar query evaluation plan and generate all the possible answers for X and Xs. 2 4.5. <p> Similar query binding analysis can be performed for queries with even weaker partial bindings, such as "? qsort ([XjXs]; <ref> [4; 5; 9] </ref>); X &gt; 4". The analysis will derive a similar query evaluation plan and generate all the possible answers for X and Xs. 2 4.5. <p> Furthermore, the evaluation is tuple-oriented, which is inefficient in database environments. Recent studies in deductive database research have proposed the use of the generalized magic sets method in the evaluation of nonlinear recursions <ref> [4, 39, 9] </ref>. The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation.
Reference: [10] <author> J. Han. </author> <title> Constraint-based reasoning in deductive databases. </title> <booktitle> In Proc. 7th Int. Conf. Data Engineering, </booktitle> <pages> pp. 257-265, </pages> <address> Kobe, Japan (1991). </address>
Reference-contexts: Query processing terminates when all such generated tuples are eliminated. 2 The algorithm which determines a set of sufficient conditions for the termination of query evaluation and transforms query or integrity constraints into termination restraint, when applicable, is similar to the one for the class of linear programs <ref> [10] </ref> and will not be presented here to save space. <p> After the exit portion is evaluated, the buffered portion should obtain sufficient binding information for evaluation (because the recursion is weakly finitely evaluable), and the evaluation proceeds by patching up the corresponding buffered values in the evaluation. This kind of evaluation is called chain-split evaluation <ref> [10] </ref>. <p> Lakshmanan 4.4. Constraint pushing in chain-based evaluation Constraint-based evaluation <ref> [17, 15, 10] </ref> is used when a query provides constraints which may help reduce the search space in the iterative evaluation. A query constraint instantiates or adds constraint information to an IDB predicate. <p> Instantiate other constraint information and push those constraints, when possible, into the adorned chain predicate (s) for efficient evaluation based on the principles of constraint-based recursive query evaluation <ref> [10] </ref>. 5. <p> The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases [39, 26, 13, 7, 28, 29] and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols <ref> [32, 5, 19, 34, 10] </ref>. In this sense, it is a continuation of the traditional work in deductive databases. The general philosophy of our evaluation method is, however, different from that of the generalized magic sets method. <p> Without such knowledge, it is difficult to fully explore various kinds of constraints, query instantiations, and argument relationships in a recursion for efficient query processing. For example, the pushing of some monotonicity constraints into chain expressions for efficient processing cannot be realized in the magic sets evaluation <ref> [10] </ref>. More studies need to be performed on the magic sets method to explore the regularity of the structures of a recursion in the efficient evaluation of functional recursions. In the following example, we compare the chain-based evaluation with other techniques in the evaluation of the hanoi recursion. <p> A detailed discussion based on this approach for the class of linear programs appears in <ref> [10] </ref>. 6. CONCLUSIONS We investigated the efficient evaluation of an important class of nonlinear recursion, regular nonlinear recursion, in deductive database and logic programming systems based on a deductive database approach.
Reference: [11] <author> J. Han. </author> <title> Compilation-based list processing in deductive databases. </title> <editor> In A. Pirotte, C. Delobel, and G. Gottlob, editors, </editor> <booktitle> Extending Database Technology - EDBT'92 [Lecture Notes in Computer Science 580], </booktitle> <pages> pp. 104-119. </pages> <publisher> Springer-Verlag (1992). </publisher>
Reference-contexts: 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [14, 1, 2, 4, 42, 22, 31, 39, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> However, many application programs involve complex recursions with function symbols [38, 9, 39, 27]. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs. In recent studies of compilation and evaluation of functional recursions <ref> [23, 22, 11] </ref>, some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions [35, 33, 43, 25]. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions. <p> Since a functional recursion should be first rectified into a function-free one, many previously developed query evaluation techniques <ref> [2, 11] </ref> for function-free recursions may still be applicable to the rectified recursions. However, a rectified functional predicate may correspond to an infinite relation. The semi-naive bottom-up evaluation may not terminate on such recursions. <p> However, a rectified functional predicate may correspond to an infinite relation. The semi-naive bottom-up evaluation may not terminate on such recursions. A chain-based evaluation method <ref> [11] </ref> is developed in this section for the evaluation of a regular functional nonlinear recursion, which views the recursion as a set of growing sequence of chains in which every chain is a set of connected predicates with certain regular patterns.
Reference: [12] <author> J. Han, L. Liu, and Z. Xie. LogicBase: </author> <title> A deductive database system prototype. </title> <booktitle> In Proc. 3rd Int'l Conf. on Information and Knowledge Management, </booktitle> <pages> pp. 226-233, </pages> <address> Gaithersburg, Maryland (1994). </address>
Reference-contexts: The method developed in this study has been implemented in the LogicBase project <ref> [12] </ref>. Our study is confined to regular nonlinear recursions. We believe that most practically interesting nonlinear recursions are regular ones. It is an interesting research topic to explore query analysis and evaluation of irregular nonlinear recursions.
Reference: [13] <author> J. Han and K. Zeng. </author> <title> Automatic generation of compiled forms for linear recursions. </title> <journal> Information Systems, </journal> <volume> 17 </volume> <month> 299-322 </month> <year> (1992). </year>
Reference-contexts: ; X 3 ; Y 2 ); b (X 3 ; Y 1 ; Y 2 ): (14) Similarly, the nonlinear recursion r, defined by f (14), (15)g, is irregular. 2 An irregular linear recursion can be transformed into an equivalent, regular linear recursion by a normalization process described in <ref> [13] </ref>. However, it is an open problem to determine what kind of irregular nonlinear recursions can be regularized. This paper confines its domain of study to regular nonlinear recursions. 3. <p> The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases <ref> [39, 26, 13, 7, 28, 29] </ref> and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols [32, 5, 19, 34, 10]. In this sense, it is a continuation of the traditional work in deductive databases.
Reference: [14] <author> L. J. Henschen and S. Naqvi. </author> <title> On compiling queries in recursive first-order databases. </title> <journal> J. ACM, </journal> <volume> 31 </volume> <month> 47-85 </month> <year> (1984). </year>
Reference-contexts: 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [14, 1, 2, 4, 42, 22, 31, 39, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions.
Reference: [15] <author> T. Imielinski. </author> <title> Intelligent query answering in rule based systems. </title> <journal> J. Logic Programming, </journal> <volume> 4 </volume> <month> 229-257 </month> <year> (1987). </year>
Reference-contexts: Lakshmanan 4.4. Constraint pushing in chain-based evaluation Constraint-based evaluation <ref> [17, 15, 10] </ref> is used when a query provides constraints which may help reduce the search space in the iterative evaluation. A query constraint instantiates or adds constraint information to an IDB predicate.
Reference: [16] <author> Y. E. Ioannidis and R. Ramakrishnan. </author> <title> Efficient transitive closure algorithms. </title> <booktitle> In Proc. 14th Int. Conf. Very Large Data Bases, </booktitle> <pages> pp. 382-394, </pages> <address> Long Beach, CA (1988). </address>
Reference-contexts: 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research [14, 1, 2, 4, 42, 22, 31, 39, 11]. Some interesting query evaluation techniques, such as transitive closure algorithms <ref> [16, 18] </ref>, magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions.
Reference: [17] <author> J. Jaffar and J-L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proc. 14th ACM Symp. Principles of Programming Languages, </booktitle> <pages> pp. 111-119, </pages> <address> Munich, Germany (1987). </address>
Reference-contexts: Lakshmanan 4.4. Constraint pushing in chain-based evaluation Constraint-based evaluation <ref> [17, 15, 10] </ref> is used when a query provides constraints which may help reduce the search space in the iterative evaluation. A query constraint instantiates or adds constraint information to an IDB predicate. <p> Furthermore, our study has been focused on the static control of query execution [24], in which the flow of execution is predetermined at query compilation and analysis time, which is different from many artificial intelligence systems which adopt dynamic control in query execution <ref> [17, 26] </ref>. Although static control, exercised by a query optimizer, is suitable for finding all the answers to a query, the dynamic control of the search process, exercised by the system at run time, may further reduce search space, enhance performance, and produce a few but knowledgeable answers.
Reference: [18] <author> B. Jiang. </author> <title> A suitable algorithm for computing partial transitive closures. </title> <booktitle> In Proc. 6th Int. Conf. Data Engineering, </booktitle> <pages> pp. 264-271, </pages> <address> Los Angeles, CA (1990). </address>
Reference-contexts: 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research [14, 1, 2, 4, 42, 22, 31, 39, 11]. Some interesting query evaluation techniques, such as transitive closure algorithms <ref> [16, 18] </ref>, magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions.
Reference: [19] <author> D. B. Kemp, K. Ramamohanarao, I. Balbin, and K. Meenakshi. </author> <title> Propagating constraints in recursive deductive databases. </title> <booktitle> In Proc. 1989 North American Conf. Logic Programming, </booktitle> <pages> pp. 981-998, </pages> <address> Cleveland, OH (1989). </address>
Reference-contexts: The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases [39, 26, 13, 7, 28, 29] and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols <ref> [32, 5, 19, 34, 10] </ref>. In this sense, it is a continuation of the traditional work in deductive databases. The general philosophy of our evaluation method is, however, different from that of the generalized magic sets method.
Reference: [20] <author> M. Kifer, W. Kim, and Y. Sagiv. </author> <title> Querying object-oriented database. </title> <booktitle> In Proc. 1992 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pp. 393-402, </pages> <address> San Diego, CA (1992). </address> <booktitle> Evaluation of Regular Nonlinear Recursions 55 </booktitle>
Reference-contexts: DISCUSSION 5.1. Evaluation of nonlinear recursions in F-Logic and HiLog programs Studies on deductive and object-oriented databases have led to several interesting logic-based languages, such as F-logic [21], HiLog [8], XSQL <ref> [20] </ref>, etc. Interestingly, the chain-based evaluation method can be extended naturally to the evaluation of regular nonlinear recursions in such programs. Taking HiLog as an example, the quick sort program presented in Example 11 can be extended to incorporate module facility in HiLog [8].
Reference: [21] <author> M. Kifer, G. Lausen, and J. Wu. </author> <booktitle> Logical foundations of object-oriented and frame-based languages. In J. ACM (1993). </booktitle>
Reference-contexts: DISCUSSION 5.1. Evaluation of nonlinear recursions in F-Logic and HiLog programs Studies on deductive and object-oriented databases have led to several interesting logic-based languages, such as F-logic <ref> [21] </ref>, HiLog [8], XSQL [20], etc. Interestingly, the chain-based evaluation method can be extended naturally to the evaluation of regular nonlinear recursions in such programs. Taking HiLog as an example, the quick sort program presented in Example 11 can be extended to incorporate module facility in HiLog [8].
Reference: [22] <author> M. Kifer, R. Ramakrishnan, and A. Silberschatz. </author> <title> An axiomatic approach to deciding finiteness of queries in deductive databases. </title> <booktitle> In Proc. 7th ACM Symp. Principles of Database Systems, </booktitle> <pages> pp. 52-60, </pages> <address> Austin, TX (1988). </address>
Reference-contexts: 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [14, 1, 2, 4, 42, 22, 31, 39, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> However, many application programs involve complex recursions with function symbols [38, 9, 39, 27]. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs. In recent studies of compilation and evaluation of functional recursions <ref> [23, 22, 11] </ref>, some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions [35, 33, 43, 25]. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions. <p> For example, f (X 1 ; : : : ; X k ) = V is transformed to f (X 1 ; : : : ; X k ; V ). A similar transformation is also discussed in <ref> [32, 22] </ref>. Since the transformation maps a functional logical rule to a function-free one, the compilation and analysis of a functional recursion can be performed in the framework of a function-free one. Notice that the transformation converts constructors to predicates. <p> A predicate r is finitely evaluable under a set of bindings B if there exist only a finite set of distinct tuples satisfying the predicate r under B. The concepts of finiteness constraint and weak finiteness were first introduced in <ref> [32, 22, 34] </ref>. Definition 8 A finiteness constraint over a predicate r is of the form X ! Y where X and Y are sets of arguments (more precisely, argument positions).
Reference: [23] <author> R. Krishnamurthy, R. Ramakrishnan, and O. Shmueli. </author> <title> A framework for testing safety and effective computability of extended datalog. </title> <booktitle> In Proc. 1988 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pp. 154-163, </pages> <address> Chicago, IL (1988). </address>
Reference-contexts: However, many application programs involve complex recursions with function symbols [38, 9, 39, 27]. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs. In recent studies of compilation and evaluation of functional recursions <ref> [23, 22, 11] </ref>, some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions [35, 33, 43, 25]. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions.
Reference: [24] <author> R. Krishnamurthy and C. Zaniolo. </author> <title> Optimization in a logic based language for knowledge and data intensive applications. </title> <booktitle> In Extending Database Technology (EDBT'88) [Lecture Notes in Computer Science 303], </booktitle> <pages> pp. 16-33, </pages> <publisher> Springer-Verlag (1988). </publisher>
Reference-contexts: The evaluation of a set of chains is similar to the evaluation of a set of connected relational expressions to which 42 Jiawei Han and Laks V.S. Lakshmanan optimization method developed for relational query optimization can be largely applied <ref> [24] </ref>. The analysis of the structure of a recursion, the available query constraints and integrity constraints may lead to appropriate ordering of predicates in the evaluation, the maximal usage of query and integrity constraints and other optimization techniques. <p> However, the theorem does not claim the optimality of the algorithm. This is because the actual generation and selection of the query evaluation plan is a sophisticated and costly process, exponential to the size of the set of predicates in the recursion and the number of available access paths <ref> [24] </ref>. Similar to the dynamic query plan generation and query optimization in relational systems [39], one can only expect to derive suboptimal query evaluation plans at a reasonable cost of query optimization [2, 24]. 5. DISCUSSION 5.1. <p> Similar to the dynamic query plan generation and query optimization in relational systems [39], one can only expect to derive suboptimal query evaluation plans at a reasonable cost of query optimization <ref> [2, 24] </ref>. 5. DISCUSSION 5.1. Evaluation of nonlinear recursions in F-Logic and HiLog programs Studies on deductive and object-oriented databases have led to several interesting logic-based languages, such as F-logic [21], HiLog [8], XSQL [20], etc. <p> The remaining unused subset will be submitted for evaluation only when not enough answers to the query have been generated. Furthermore, our study has been focused on the static control of query execution <ref> [24] </ref>, in which the flow of execution is predetermined at query compilation and analysis time, which is different from many artificial intelligence systems which adopt dynamic control in query execution [17, 26].
Reference: [25] <author> L. V. S. Lakshmanan, K. Ashraf, and J. Han. </author> <title> Homomorphic tree embeddings and their applications to recursive program optimization. </title> <booktitle> In Proc. 1993 Conf. Logic in Computer Science, </booktitle> <address> Montreal, Canada (1993). </address>
Reference-contexts: In recent studies of compilation and evaluation of functional recursions [23, 22, 11], some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions <ref> [35, 33, 43, 25] </ref>. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions. Indeed, there are interesting classes of programs, such as those involving divide and conquer techniques, which are inherently nonlinear. It is important to develop techniques for efficient evaluation of such functional nonlinear recursions.
Reference: [26] <author> M. J. Maher and P. J. Stuckey. </author> <title> Expanding query power in constraint logic programming languages. </title> <booktitle> In Proc. 1989 North American Conf. Logic Programming, </booktitle> <pages> pp. 20-36, </pages> <address> Cleveland, OH (1989). </address>
Reference-contexts: The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases <ref> [39, 26, 13, 7, 28, 29] </ref> and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols [32, 5, 19, 34, 10]. In this sense, it is a continuation of the traditional work in deductive databases. <p> Furthermore, our study has been focused on the static control of query execution [24], in which the flow of execution is predetermined at query compilation and analysis time, which is different from many artificial intelligence systems which adopt dynamic control in query execution <ref> [17, 26] </ref>. Although static control, exercised by a query optimizer, is suitable for finding all the answers to a query, the dynamic control of the search process, exercised by the system at run time, may further reduce search space, enhance performance, and produce a few but knowledgeable answers.
Reference: [27] <author> S. Naqvi and S. Tsur. </author> <title> A Logical Data Language for Data and Knowledge Bases. </title> <publisher> Computer Science Press (1989). </publisher>
Reference-contexts: Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. However, many application programs involve complex recursions with function symbols <ref> [38, 9, 39, 27] </ref>. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs. <p> Example 4 Many recursions encountered in practical applications are regular ones. For example, the recursions ackermann ((7) - (9)) [37] and blue-blooded frenchman ((11) - (10)) <ref> [27] </ref> are both regular ones. ackermann (0; N; s (N )): (7) ackermann (s (M ); 0; V al) ackermann (M; s (0); V al): (8) ackermann (s (M ); s (N ); V al) ackermann (s (M ); N; V al 1 ); ackermann (M; V al 1 ; V
Reference: [28] <author> J. F. Naughton. </author> <title> Compiling separable recursions. </title> <booktitle> In Proc. 1988 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pp. 312-319, </pages> <address> Chicago, IL (1988). </address>
Reference-contexts: The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases <ref> [39, 26, 13, 7, 28, 29] </ref> and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols [32, 5, 19, 34, 10]. In this sense, it is a continuation of the traditional work in deductive databases.
Reference: [29] <author> J. F. Naughton, R. Ramakrishnan, Y. Sagiv, and J. D. Ullman. </author> <title> Efficient evaluation of right-, left-, and multi-linear rules. </title> <booktitle> In Proc. 1989 ACM-SIGMOD Int. Conf. Management of Data, </booktitle> <pages> pp. 235-242, </pages> <address> Portland, Oregon (1989). </address>
Reference-contexts: The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases <ref> [39, 26, 13, 7, 28, 29] </ref> and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols [32, 5, 19, 34, 10]. In this sense, it is a continuation of the traditional work in deductive databases.
Reference: [30] <author> L. Plumer. </author> <title> Termination proofs for logic programs based on predicate inequalities. </title> <booktitle> In Proc. 7th Int. Conf. on Logic Programming, </booktitle> <pages> pp. 634-648, </pages> <address> Jerusalem (1990). </address>
Reference-contexts: The discovery of relationships or constraints among argument sizes in logic programs has been studied recently <ref> [40, 41, 6, 36, 30] </ref>. The discovery of the relationships of list length among the list-typed arguments belongs to this category. Example 8 According to the definition of the hanoi recursion, the following properties about the length of the list arguments can be observed. 1.
Reference: [31] <author> R. Ramakrishnan. </author> <title> Magic templates: A spellbinding approach to logic programs. </title> <booktitle> In Proc. Int. Conf. Logic Programming, </booktitle> <pages> pp. 140-159, </pages> <address> Seattle, WA (1988). </address>
Reference-contexts: 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [14, 1, 2, 4, 42, 22, 31, 39, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions.
Reference: [32] <author> R. Ramakrishnan, F. Bancilhon, and A. Silberschatz. </author> <title> Safety of recursive Horn clauses with infinite relations. </title> <booktitle> In Proc. 6th ACM Symp. Principles of Database Systems, </booktitle> <pages> pp. 328-339, </pages> <address> San Diego, CA (1987). </address>
Reference-contexts: For example, f (X 1 ; : : : ; X k ) = V is transformed to f (X 1 ; : : : ; X k ; V ). A similar transformation is also discussed in <ref> [32, 22] </ref>. Since the transformation maps a functional logical rule to a function-free one, the compilation and analysis of a functional recursion can be performed in the framework of a function-free one. Notice that the transformation converts constructors to predicates. <p> A predicate r is finitely evaluable under a set of bindings B if there exist only a finite set of distinct tuples satisfying the predicate r under B. The concepts of finiteness constraint and weak finiteness were first introduced in <ref> [32, 22, 34] </ref>. Definition 8 A finiteness constraint over a predicate r is of the form X ! Y where X and Y are sets of arguments (more precisely, argument positions). <p> The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases [39, 26, 13, 7, 28, 29] and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols <ref> [32, 5, 19, 34, 10] </ref>. In this sense, it is a continuation of the traditional work in deductive databases. The general philosophy of our evaluation method is, however, different from that of the generalized magic sets method.
Reference: [33] <author> R. Ramakrishnan, Y. Sagiv, J.D. Ullman, and M. Vardi. </author> <title> Proof-tree transformation theorems and their applications. </title> <booktitle> In Proc. 8th ACM Symp. Principles of Database Systems, </booktitle> <pages> pp. 172-181, </pages> <address> Philadelphia, PA (1989). </address>
Reference-contexts: In recent studies of compilation and evaluation of functional recursions [23, 22, 11], some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions <ref> [35, 33, 43, 25] </ref>. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions. Indeed, there are interesting classes of programs, such as those involving divide and conquer techniques, which are inherently nonlinear. It is important to develop techniques for efficient evaluation of such functional nonlinear recursions.
Reference: [34] <author> Y. Sagiv and M. Vardi. </author> <title> Safety of datalog queries over infinite databases. </title> <booktitle> In Proc. 8th ACM Symp. Principles of Database Systems, </booktitle> <pages> pp. 160-171, </pages> <address> Philadelphia, PA (1989). </address>
Reference-contexts: A predicate r is finitely evaluable under a set of bindings B if there exist only a finite set of distinct tuples satisfying the predicate r under B. The concepts of finiteness constraint and weak finiteness were first introduced in <ref> [32, 22, 34] </ref>. Definition 8 A finiteness constraint over a predicate r is of the form X ! Y where X and Y are sets of arguments (more precisely, argument positions). <p> The term weak finite evaluability is used here to distinguish (strong) finite evaluability which requires the evaluation of a query not only produces a finite intermediate relation at each step but also terminates and generates a finite, complete set of answers <ref> [34] </ref>. <p> The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases [39, 26, 13, 7, 28, 29] and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols <ref> [32, 5, 19, 34, 10] </ref>. In this sense, it is a continuation of the traditional work in deductive databases. The general philosophy of our evaluation method is, however, different from that of the generalized magic sets method.
Reference: [35] <author> Y. P. Saraiya. </author> <title> Linearising nonlinear recursions in polynomial time. </title> <booktitle> In Proc. 8th ACM Symp. Principles of Database Systems, </booktitle> <pages> pp. 182-189, </pages> <address> Philadelphia, PA (1989). </address>
Reference-contexts: In recent studies of compilation and evaluation of functional recursions [23, 22, 11], some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions <ref> [35, 33, 43, 25] </ref>. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions. Indeed, there are interesting classes of programs, such as those involving divide and conquer techniques, which are inherently nonlinear. It is important to develop techniques for efficient evaluation of such functional nonlinear recursions.
Reference: [36] <author> K. Sohn and A. van Gelder. </author> <title> Termination detection in logic programs using argument sizes. </title> <booktitle> In Proc. 10th ACM Symp. Principles of Database Systems, </booktitle> <pages> pp. 216-226, </pages> <address> Denver, CO (1991). </address>
Reference-contexts: The discovery of relationships or constraints among argument sizes in logic programs has been studied recently <ref> [40, 41, 6, 36, 30] </ref>. The discovery of the relationships of list length among the list-typed arguments belongs to this category. Example 8 According to the definition of the hanoi recursion, the following properties about the length of the list arguments can be observed. 1.
Reference: [37] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> The MIT Press (1986). </publisher>
Reference-contexts: It means that Y is an ancestor of X if Y is a parent of X, or if there exist a person W such that Y is an ancestor of W , and W is an ancestor of X. The notations used in this paper are similar to Prolog <ref> [37] </ref>. 2 ancestor (X; Y ) parent (X; Y ): (1) ancestor (X; Y ) ancestor (X; W ); ancestor (W; Y ): (2) Example 2 The recursion hanoi, defined by f (3), (4)g, is a functional (i.e., function-bearing) nonlinear recursion. It defines the Towers of Hanoi puzzle [37], that is, <p> to Prolog <ref> [37] </ref>. 2 ancestor (X; Y ) parent (X; Y ): (1) ancestor (X; Y ) ancestor (X; W ); ancestor (W; Y ): (2) Example 2 The recursion hanoi, defined by f (3), (4)g, is a functional (i.e., function-bearing) nonlinear recursion. It defines the Towers of Hanoi puzzle [37], that is, moving N discs from peg Evaluation of Regular Nonlinear Recursions 35 A to peg B using peg C as an intermediary. <p> Example 4 Many recursions encountered in practical applications are regular ones. For example, the recursions ackermann ((7) - (9)) <ref> [37] </ref> and blue-blooded frenchman ((11) - (10)) [27] are both regular ones. ackermann (0; N; s (N )): (7) ackermann (s (M ); 0; V al) ackermann (M; s (0); V al): (8) ackermann (s (M ); s (N ); V al) ackermann (s (M ); N; V al 1 ); <p> This kind of evaluation is called chain-split evaluation [10]. Example 11 The quick sort recursion, qsort, defined by the following program (adopted from <ref> [37] </ref>) is a strongly regular nonlinear recursion because every argument in the head of each recursive rule of qsort and partition is static-regular. qsort ([XjXs]; Y s) partition (Xs; X; Littles; Bigs); qsort (Littles; Ls); qsort (Bigs; Bs); append (Ls; [XjBs]; Y s): (10) qsort ([]; []): (11) partition ([XjXs]; Y; <p> In comparison with other query evaluation methods A chain-based query evaluation method has been developed for the efficient evaluation of regular nonlinear recursions. It is important to compare the method with other implementation techniques for the evaluation of logic programs. Prolog implementations <ref> [37] </ref> can be applied to the evaluation of both regular and irregular nonlinear recursions. In this context, Prolog implementations cover a larger class of logic programs than the chain-based evaluation method. However, a Prolog implementation cannot guarantee the termination of an evaluation.
Reference: [38] <author> S. Tsur. </author> <title> Deductive databases in action. </title> <booktitle> In Proc. 10th ACM Symp. Principles of Database Systems, </booktitle> <pages> pp. 142-153, </pages> <address> Denver, CO (1991). </address>
Reference-contexts: Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. However, many application programs involve complex recursions with function symbols <ref> [38, 9, 39, 27] </ref>. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs.
Reference: [39] <author> J. D. Ullman. </author> <title> Principles of Database and Knowledge-Base Systems, </title> <journal> Vols. </journal> <volume> 1 & 2. </volume> <publisher> Computer Science Press (1989). </publisher>
Reference-contexts: 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [14, 1, 2, 4, 42, 22, 31, 39, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. However, many application programs involve complex recursions with function symbols <ref> [38, 9, 39, 27] </ref>. It is important to perform a systematic study on the efficient evaluation of function-bearing recursions (called functional recursions) in both data-intensive and logic-intensive programs. <p> In Section 5, we discuss the extension of the method to the evaluation of HiLog and F-logic programs, the efficiency of the evaluation method in comparison with others, and the implementation considerations. The study is summarized in Section 6. 2. REGULAR AND IRREGULAR NONLINEAR RECURSIONS Like many researchers <ref> [39, 2] </ref>, we assume that a deductive database is partitioned into three portions: (i) an extensional database (EDB) (a set of database relations), (ii) an intensional database (IDB) (a set of predicates defined by Horn-clause rules), and (iii) a set of integrity constraints (ICs). <p> Such a relation cannot be represented by a finite EDB relation. Thus the evaluation of a functional predicate should still rely on its corresponding function definition. A functional predicate can also be transformed back to its functional form, when necessary, which is called the predicate-function transformation. As discussed in <ref> [39] </ref>, logical rules in different forms should be rectified to facilitate the compilation and analysis. <p> For example, the linear recursion sg (twisted same generation relatives) <ref> [39] </ref>, defined by f (12), (13)g, is irregular. sg (X; Y ) parent (X; Xp); sg (Y p; Xp); parent (Y; Y p): (12) sg (X; Y ) sibling (X; Y ): (13) r (X; X 1 ; Y ) a (X; Y ); r (X 1 ; X 2 ; <p> In other words, a finiteness constraint X ! Y over a predicate r implies that each value of attribute X corresponds to a finite set of Y values in r. Finiteness constraint is strictly weaker than the functional dependency studied in database theory <ref> [39] </ref>. It holds trivially for all finite predicates. Since EDB relations are finite, the arguments in EDB relations satisfy finiteness constraints. <p> Similar to the notations used in the magic sets transformation <ref> [2, 39] </ref>, a superscript b or f is used to adorn a variable to indicate the variable being bound or free, and a string of b's and f 's used to adorn a predicate to indicate the bindings of its corresponding arguments. <p> Similar to the dynamic query plan generation and query optimization in relational systems <ref> [39] </ref>, one can only expect to derive suboptimal query evaluation plans at a reasonable cost of query optimization [2, 24]. 5. DISCUSSION 5.1. <p> In this case, it is unnecessary to perform function-predicate transformation on such structures. This is because when an object structure is not to be altered in a program, the resolution operation on the structure is essentially simple structure (or term) matching, which can be implemented fairly efficiently <ref> [39] </ref>. It is unnecessary to delay the resolution on such object structures by a function-predicate transformation. This improvement, though not essential in the program analysis, will save the cost of processing if the database is large. 5.2. <p> Furthermore, the evaluation is tuple-oriented, which is inefficient in database environments. Recent studies in deductive database research have proposed the use of the generalized magic sets method in the evaluation of nonlinear recursions <ref> [4, 39, 9] </ref>. The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. <p> The method applies set-oriented processing and confines the search to the portion of the database relevant to a query, which improves search efficiency in the semi-naive evaluation. The method developed here is based on the previous studies on the compilation and efficient evaluation of recursions in deductive databases <ref> [39, 26, 13, 7, 28, 29] </ref> and the work on safetiness, monotonicity and termination in the evaluation of deductive database programs with function symbols [32, 5, 19, 34, 10]. In this sense, it is a continuation of the traditional work in deductive databases.
Reference: [40] <author> J. D. Ullman and A. van Gelder. </author> <title> Efficient tests for top-down termination of logical rules. </title> <journal> J. ACM, </journal> <volume> 35 </volume> <month> 345-373 </month> <year> (1988). </year>
Reference-contexts: However, a weakly finitely evaluable recursive query guarantees only a finite intermediate relation at each iteration but not the termination of iterative processing. Monotonicity constraints are often useful for the termination of iterative processing <ref> [5, 6, 40] </ref>. <p> The discovery of relationships or constraints among argument sizes in logic programs has been studied recently <ref> [40, 41, 6, 36, 30] </ref>. The discovery of the relationships of list length among the list-typed arguments belongs to this category. Example 8 According to the definition of the hanoi recursion, the following properties about the length of the list arguments can be observed. 1.
Reference: [41] <author> A. van Gelder. </author> <title> Deriving constraints among argument sizes in logic programs. </title> <booktitle> In Proc. 9th ACM Symp. Principles of Database Systems, </booktitle> <pages> pp. 47-60, </pages> <address> Nashville, TN (1990). </address>
Reference-contexts: The discovery of relationships or constraints among argument sizes in logic programs has been studied recently <ref> [40, 41, 6, 36, 30] </ref>. The discovery of the relationships of list length among the list-typed arguments belongs to this category. Example 8 According to the definition of the hanoi recursion, the following properties about the length of the list arguments can be observed. 1.
Reference: [42] <author> L. Vieille. </author> <title> From QSQ towards QoSaQ: Global optimization of recursive queries. </title> <booktitle> In Proc. 2nd Int. Conf. Expert Database Systems, </booktitle> <pages> pp. 743-778, </pages> <address> Vienna, VA (1988). </address>
Reference-contexts: 1. INTRODUCTION Efficient evaluation of different kinds of recursions has been studied extensively in deductive database and logic programming research <ref> [14, 1, 2, 4, 42, 22, 31, 39, 11] </ref>. Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach [42], etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. <p> Some interesting query evaluation techniques, such as transitive closure algorithms [16, 18], magic sets [1], counting [1], generalized magic sets [4], generalized counting [4], query-subquery approach <ref> [42] </ref>, etc. have been proposed and implemented for efficient evaluation of different kinds of recursions. Many of these methods are confined to function-free recursions or are applicable only to transitive closure or linear recursions. However, many application programs involve complex recursions with function symbols [38, 9, 39, 27].
Reference: [43] <author> W. Zhang, C.T. Yu, and D. Troy. </author> <title> Necessary and sufficient condition to linearize doubly recursive programs in logic databases. </title> <journal> ACM Trans. Database Syst., </journal> <volume> 15 </volume> <month> 459-482 </month> <year> (1990). </year>
Reference-contexts: In recent studies of compilation and evaluation of functional recursions [23, 22, 11], some interesting techniques have been proposed for the evaluation of linear and nested linear functional recursions. A subclass of nonlinear recursions can be transformed into linear or multiple linear recursions <ref> [35, 33, 43, 25] </ref>. Clearly not all nonlinear recursions can be transformed into equivalent linear recursions. Indeed, there are interesting classes of programs, such as those involving divide and conquer techniques, which are inherently nonlinear. It is important to develop techniques for efficient evaluation of such functional nonlinear recursions.
References-found: 43

