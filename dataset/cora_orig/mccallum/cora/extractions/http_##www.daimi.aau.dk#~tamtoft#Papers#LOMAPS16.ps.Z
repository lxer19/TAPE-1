URL: http://www.daimi.aau.dk/~tamtoft/Papers/LOMAPS16.ps.Z
Refering-URL: http://www.daimi.aau.dk/~tamtoft/papers.html
Root-URL: http://www.daimi.aau.dk
Email: e-mail:ffnielson,hrnielson,tamtoftg@daimi.aau.dk  
Title: Polymorphic Subtyping for Effect Analysis: the Algorithm  
Author: Flemming Nielson Hanne Riis Nielson Torben Amtoft 
Address: Denmark  
Affiliation: Computer Science Department, Aarhus University,  
Abstract: We study an annotated type and effect system that integrates let-polymorphism, effects, and subtyping into an annotated type and effect system for a fragment of Concurrent ML. First we define a type inference algorithm and then construct procedures for constraint normalisation and simplification. Next these algorithms are proved syntactically sound with respect to the annotated type and effect system. 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> T. Amtoft, F. Nielson, H.R. Nielson, J. Ammann: </author> <title> Polymorphic subtypes for effect analysis: the dynamic semantics. </title> <booktitle> This volume of SLNCS, </booktitle> <year> 1997. </year>
Reference-contexts: The semantic soundness of the generalisation rule (and of the overall system) was proved in <ref> [1] </ref> and relied heavily on the upwards closure. <p> fig and if it is upwards closed: that is f~ff ~ fig C 0 " A type t is trivially well-formed. 2 Requiring a type scheme to be well-formed (in particular upwards closed) is a crucial feature in the approach of [11], the semantic soundness of which was established in <ref> [1] </ref>. (con) C; A ` c : TypeOf (c) & ; (id) C; A ` x : A (x) & ; C; A [x : t 1 ] ` e : t 2 & b (app) (C 1 [ C 2 ); A ` e 1 e 2 : t 1 <p> We then have: Semantic Soundness. It is possible 4 to apply the subject reduction result <ref> [1, Theorem 41] </ref> which (loosely speaking) says: all configurations which arise during execution of e can be typed. Conservative extension.
Reference: 2. <author> Y.-C. Fuh and P. Mishra: </author> <title> Polymorphic subtype inference: closing the theory-practice gap. </title> <booktitle> In Proc. TAPSOFT '89. </booktitle> <volume> SLNCS 352, </volume> <year> 1989. </year>
Reference-contexts: Still the algorithm will produce a rather unwieldy number of constraints; to reduce this number dramatically we may apply an algorithm R (defined in Sect. 5) which adapts the techniques of <ref> [2, 15] </ref>. The resulting algorithm W (which uses F and R) has been implemented, and in Sect. 6 we shall see that the output produced by our prototype is quite readable and informative. Soundness. <p> The techniques used are basically those of [15] and <ref> [2] </ref>, adapted to our framework. The transformation R may be described as a non-deterministic rewriting process, operating over triples of form (C; t; b), and with respect to a fixed environment A.
Reference: 3. <author> Y.-C. Fuh and P. Mishra: </author> <title> Type inference with subtypes. </title> <journal> Theoretical Computer Science, </journal> <volume> 73, </volume> <year> 1990. </year>
Reference-contexts: In order to incorporate subtyping we also need to generate type constraints as in <ref> [3, 15] </ref> (in these papers there may also be inclusions between base types such as int real). <p> The constraints generated by W have to be massaged so as to satisfy certain invariants ("atomicity" and "simplicity") and for this we devise the algorithm F (Sect. 4), inspired by <ref> [3] </ref>. Still the algorithm will produce a rather unwieldy number of constraints; to reduce this number dramatically we may apply an algorithm R (defined in Sect. 5) which adapts the techniques of [2, 15]. <p> C; A ` e : oe & b then C 0 ; A ` e : oe & b (and has the same shape). 3 The Inference Algorithm In designing an inference algorithm W for the type inference system we are (cf. the Introduction) motivated by the overall approach of <ref> [15, 3] </ref>. One ingredient (called W 0 ) of this will be to perform a syntax-directed traversal of the expression in order to determine its type and behaviour; this will involve constructing a constraint set for expressing the required relationship between the type and behaviour variables. <p> Atomicity. As in <ref> [8, 3, 15] </ref> we shall want the type constraints to match and shall decompose them into atomic constraints; in our setting these will not contain base types as we have no ordering among those. Definition 6. <p> The algorithm follows the overall approach of [15, 5] except that as in <ref> [3] </ref> there are no explicit unification steps; these all take place as part of the F transformation. The only novel ingredient of our approach shows up in the clause for let as we shall explain shortly. <p> This is helpful for reducing the size of constraint sets and type schemes. 2 4 Algorithm F We are now going to define the algorithm F which "forces type constraints to match" by transforming them into atomic constraints; the algorithm closely resembles <ref> [3, procedure MATCH] </ref>. The algorithm may be described as a non-deterministic rewriting process. <p> The type part is isomorphic to the initial constraints, so this process may con-tinue forever: we perform a second match and produce a second substitution R 2 , etc. To detect this situation we follow <ref> [3] </ref> in making use of the equivalence relation and extend it with ff 1 ff 2 after the first match that produced R 1 ; the intuition is that ff 1 and ff 2 eventually must be bound to types having the same shape. <p> Proof. We first address termination and for this purpose we (much as in <ref> [3] </ref>) define an ordering on triples (S; C; ) as follows: (S 0 ; C 0 ; 0 ) is less than (S; C; ) if either the number of equivalence classes in FV (C 0 ) wrt. 0 is less than the number of equivalence classes in FV (C) wrt.
Reference: 4. <author> F. Henglein and C. Mossin: </author> <title> Polymorphic binding-time analysis. </title> <booktitle> In Proc. ESOP '94, </booktitle> <pages> pages 287-301. </pages> <address> SLNCS 788, </address> <year> 1994. </year>
Reference-contexts: Compared with the literature we do not attempt to collect information about the regions in which communications take place [17, 20]; neither do we enable polymorphic recursion in the type annotations as in <ref> [4, 20] </ref>; on the other hand we do allow behaviours to contain annotated types.
Reference: 5. <author> M.P. Jones: </author> <title> A theory of qualified types. </title> <booktitle> In Proc. ESOP '92, </booktitle> <pages> pages 287-306. </pages> <address> SLNCS 582, </address> <year> 1992. </year>
Reference-contexts: Actually it could call itself recursively, rather than calling W, in all but one place 2 : the call to W immediately prior to the use of GEN to generalise the type of the let-bound identifier to a type scheme. The algorithm follows the overall approach of <ref> [15, 5] </ref> except that as in [3] there are no explicit unification steps; these all take place as part of the F transformation. The only novel ingredient of our approach shows up in the clause for let as we shall explain shortly.
Reference: 6. <author> P. Jouvelot and D.K. Gifford: </author> <title> Algebraic reconstruction of types and effects. </title> <booktitle> In Proc. POPL'91, </booktitle> <pages> pages 303-310. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: from which all other unifiers can be derived; but as we shall aim at a theory which facilitates extension to more complex behaviours (such as those presented in [10]) where it seems unlikely that we can use results from unification theory, we shall refrain from such attempts and instead follow <ref> [6] </ref> and generate behaviour constraints: that is, in the process of unifing t 1 ! b t 2 and t 0 1 ! b 0 2 we generate constraints relating b and b 0 .
Reference: 7. <author> R. Milner: </author> <title> A theory of type polymorphism in programming. </title> <journal> Journal of Computer Systems, </journal> <volume> 17 </volume> <pages> 348-375, </pages> <year> 1978. </year>
Reference-contexts: The semantic soundness of the generalisation rule (and of the overall system) was proved in [1] and relied heavily on the upwards closure. The goal of this paper is to produce a type reconstruction algorithm in the spirit of Milner's algorithm W <ref> [7] </ref>: given an expression e and an environment A, the recursively defined function W will produce a substitution S, a type t, and a behaviour b. The definition in [7] employs unification: if e 1 has been given type t 0 ! t 1 and e 2 has been given type <p> The goal of this paper is to produce a type reconstruction algorithm in the spirit of Milner's algorithm W <ref> [7] </ref>: given an expression e and an environment A, the recursively defined function W will produce a substitution S, a type t, and a behaviour b. The definition in [7] employs unification: if e 1 has been given type t 0 ! t 1 and e 2 has been given type t 2 then in order to type e 1 e 2 one must unify t 0 and t 2 . <p> Decomposition is valid because types constitute a "free algebra": two types are equal if and only if they have the same top-level constructor and also their subcomponents are equal. However, this will not be the case for behaviours, and therefore W of <ref> [7] </ref> cannot immediately be generalised to work on annotated types. We thus have to rethink the unification algorithm.
Reference: 8. <author> J.C. Mitchell: </author> <title> Type inference with simple subtypes. </title> <journal> Journal of Functional Programming, </journal> <volume> 1(3), </volume> <year> 1991. </year>
Reference-contexts: Atomicity. As in <ref> [8, 3, 15] </ref> we shall want the type constraints to match and shall decompose them into atomic constraints; in our setting these will not contain base types as we have no ordering among those. Definition 6. <p> Consequently the "extended occur check" Dom (R 2 ) " FV (ff 2 com fi 2 ) = ; fails. 2 Remark. Matching bears certain similarities to unification and can actually be defined in terms of unification. In <ref> [8] </ref> matching is performed by first doing unification and then the resulting substitution is transformed such that it "maps into fresh variables".
Reference: 9. <author> F. Nielson and H.R. Nielson: </author> <title> Constraints for polymorphic behaviours for Concurrent ML. </title> <booktitle> In Proc. </booktitle> <address> CCL'94. SLNCS 845, </address> <year> 1994. </year>
Reference-contexts: In order to achieve this we must follow [16] and [21] and demand that all types in question are (what <ref> [9] </ref> calls) simple, that is all behaviour annotations are variables (as is the case for int ! fi int). Definition 4.
Reference: 10. <author> H.R. Nielson and F. Nielson: </author> <title> Higher-order concurrent programs with finite communication topology. </title> <booktitle> In Proc. POPL'94, </booktitle> <pages> pages 84-97. </pages> <publisher> ACM Press, </publisher> <year> 1994. </year>
Reference-contexts: associativity and commutativity properties one might adapt results from unification theory [13] to get a unification algorithm producing a set of unifiers from which all other unifiers can be derived; but as we shall aim at a theory which facilitates extension to more complex behaviours (such as those presented in <ref> [10] </ref>) where it seems unlikely that we can use results from unification theory, we shall refrain from such attempts and instead follow [6] and generate behaviour constraints: that is, in the process of unifing t 1 ! b t 2 and t 0 1 ! b 0 2 we generate constraints <p> In many ways this would seem a sensible solution in that the actual structure of the type is of only minor importance. Motivated by the goals of <ref> [10] </ref> of eventually incorporating more causal in formation also for behaviours, we shall favour another solution. This involves adding a new behaviour of form RECfi:b.
Reference: 11. <author> H.R. Nielson, F. Nielson, T. Amtoft: </author> <title> Polymorphic subtypes for effect analysis: the static semantics. </title> <booktitle> This volume of SLNCS, </booktitle> <year> 1997. </year>
Reference-contexts: 1 Introduction In a recent paper <ref> [11] </ref> we developed an annotated type and effect system for a fragment of Concurrent ML [12]. <p> Compared with the literature we do not attempt to collect information about the regions in which communications take place [17, 20]; neither do we enable polymorphic recursion in the type annotations as in [4, 20]; on the other hand we do allow behaviours to contain annotated types. In <ref> [11] </ref> it was demonstrated that one must be very careful when deciding the set of variables over which to generalise in the inference rule for let: not only should this set be disjoint from the set of variables occurring in the behaviour (as is standard in effect systems, e.g. [17]) but <p> indirect way through communication; this is quite analogous to the way the absence of recursive types in the simply typed -calculi forbids defining the Y combinator and instead requires recursion to be an explicit primitive in the language. 2 Inference System In this section we briefly recapitulate the inference system <ref> [11] </ref>. <p> 0 contain at least one variable among f~ff ~ fig and if it is upwards closed: that is f~ff ~ fig C 0 " A type t is trivially well-formed. 2 Requiring a type scheme to be well-formed (in particular upwards closed) is a crucial feature in the approach of <ref> [11] </ref>, the semantic soundness of which was established in [1]. (con) C; A ` c : TypeOf (c) & ; (id) C; A ` x : A (x) & ; C; A [x : t 1 ] ` e : t 2 & b (app) (C 1 [ C 2 ); <p> The type inference system. As expected (and proved in <ref> [11] </ref>) we have the following results, crucial for showing soundness of our inference algorithm, saying that we can apply a sub stitution or strengthen the constraint set, and still get a valid judgement: Lemma 2. <p> it would no longer hold in general that the substitution S used in Lemma 23 is simple; so if we were to extend R with the rules in Figure 9 we would lose the property that the inference tree "constructed by" the inference algorithm is "simple". 6 Experimental Results In <ref> [11] </ref> we considered the program fn f =&gt; let id = fn y =&gt; (if true then f else fn x =&gt; (sync (send (channel (), y)); x)); in id id which demonstrated the power of our inference system relative to some other approaches. <p> Conservative extension. Let S 0 be a substitution which unifies all type variables and let C b be the behaviour constraints of C; from Lemma 2 and Lemma 3 we get S 0 C b ; [ ] ` e : S 0 t & S 0 b so <ref> [11, Theorem 21] </ref> (loosely speak ing) tells us that if e is a sequential ML-program then e can be assigned a type using the ML type system. 8 Solvability of the Constraints Generated Typability of an expression e might be taken to mean 9t; b : ;; [ ] ` e <p> Clearly this solves all type constraints of C in the sense that all type constraints of S 0 1 C are of the form (ff fl ff fl ) and 4 As C is well-formed and [ ] is a "channel environment", and as we can assume by <ref> [11, Lemma 16] </ref> that the inference is "normalised". hence instances of the axiom of reflexivity. (A less crude approach would be to consider each (ff 1 ff 2 ) of C in turn and perform a most general unification of ff 1 with ff 2 .) A crude approach to defining <p> We then have ; ` S 0 3 S 0 1 C as desired. 9 Conclusion We have developed an inference algorithm for an annotated type and effect system that integrates polymorphism, subtyping and effects <ref> [11] </ref>. Although the development was performed for a fragment of Concurrent ML we believe it equally applicable to Standard ML with references.
Reference: 12. <author> P. Panangaden and J.H. Reppy: </author> <title> The essence of Concurrent ML. In ML with Con-currency: Design, Analysis, Implementation and Application (editor: Flemming Nielson), </title> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: 1 Introduction In a recent paper [11] we developed an annotated type and effect system for a fragment of Concurrent ML <ref> [12] </ref>. Judgements are of form C; A ` e : oe & b with e an expression, b a "behaviour", oe a type or a type scheme (to incorporate ML-style let-polymorphism), C a set of constraints among types and behaviours, and A an environment.
Reference: 13. <author> J.H. Siekmann: </author> <title> Unification theory. </title> <journal> J. Symbolic Computation, </journal> <volume> 7 </volume> <pages> 207-274, </pages> <year> 1989. </year>
Reference-contexts: We thus have to rethink the unification algorithm. As the behaviours of this paper satisfy certain associativity and commutativity properties one might adapt results from unification theory <ref> [13] </ref> to get a unification algorithm producing a set of unifiers from which all other unifiers can be derived; but as we shall aim at a theory which facilitates extension to more complex behaviours (such as those presented in [10]) where it seems unlikely that we can use results from unification
Reference: 14. <author> G.S. Smith: </author> <title> Polymorphic type inference for languages with overloading and sub-typing. </title> <type> Ph.D thesis from Cornell, </type> <year> 1991. </year>
Reference-contexts: Matching bears certain similarities to unification and can actually be defined in terms of unification. In [8] matching is performed by first doing unification and then the resulting substitution is transformed such that it "maps into fresh variables". In <ref> [14, Fig. 3.7] </ref> it is first checked whether it is possible to unify a certain set of equations, derived from the constraint set; if this is the case then the algorithm behaves similar to the one presented here except that the equivalence relation is no longer needed. 2 To formalise the <p> In order to maintain soundness we must therefore demand that fl =2 FV (A). The rule (cycle) collapses cycles in the graph; due to the remark above a cycle which involves two elements of FV (A) cannot be eliminated. (In <ref> [14] </ref> it holds that ; ` t 1 j t 2 implies t 1 = t 2 so if fl and fl 0 belong to the same cycle in C then all substitutions that solve C can be written on the form S 0 [fl 7! fl 0 ], hence cycle
Reference: 15. <author> G.S. Smith: </author> <title> Polymorphic inference with overloading and subtyping. </title> <booktitle> In SLNCS 668, Proc. TAPSOFT '93, </booktitle> <year> 1993. </year> <title> Also see: Principal type schemes for functional programs with overloading and subtyping: </title> <booktitle> Science of Computer Programming 23, </booktitle> <pages> pp. 197-226, </pages> <year> 1994. </year>
Reference-contexts: In order to incorporate subtyping we also need to generate type constraints as in <ref> [3, 15] </ref> (in these papers there may also be inclusions between base types such as int real). <p> Still the algorithm will produce a rather unwieldy number of constraints; to reduce this number dramatically we may apply an algorithm R (defined in Sect. 5) which adapts the techniques of <ref> [2, 15] </ref>. The resulting algorithm W (which uses F and R) has been implemented, and in Sect. 6 we shall see that the output produced by our prototype is quite readable and informative. Soundness. <p> C; A ` e : oe & b then C 0 ; A ` e : oe & b (and has the same shape). 3 The Inference Algorithm In designing an inference algorithm W for the type inference system we are (cf. the Introduction) motivated by the overall approach of <ref> [15, 3] </ref>. One ingredient (called W 0 ) of this will be to perform a syntax-directed traversal of the expression in order to determine its type and behaviour; this will involve constructing a constraint set for expressing the required relationship between the type and behaviour variables. <p> Atomicity. As in <ref> [8, 3, 15] </ref> we shall want the type constraints to match and shall decompose them into atomic constraints; in our setting these will not contain base types as we have no ordering among those. Definition 6. <p> Actually it could call itself recursively, rather than calling W, in all but one place 2 : the call to W immediately prior to the use of GEN to generalise the type of the let-bound identifier to a type scheme. The algorithm follows the overall approach of <ref> [15, 5] </ref> except that as in [3] there are no explicit unification steps; these all take place as part of the F transformation. The only novel ingredient of our approach shows up in the clause for let as we shall explain shortly. <p> The definition of C 0 thus establishes the part of the well-formedness condition that requires each constraint to involve at least one bound variable. 2 Interestingly, this is exactly the place where the algorithm of <ref> [15] </ref> makes use of constraint simplification in the "close" function; however, our prototype implementation suggests that the choice embodied in the definition of W gives faster performance. <p> The techniques used are basically those of <ref> [15] </ref> and [2], adapted to our framework. The transformation R may be described as a non-deterministic rewriting process, operating over triples of form (C; t; b), and with respect to a fixed environment A. <p> We now explain the rules: (redund) removes constraints which are redundant due to the ordering being reflexive and transitive; applying this rule repeatedly is called "transitive reduction" in <ref> [15] </ref> and is essential for a compact representation of the constraints. The remaining rules all replace some variable fl by another variable fl 0 .
Reference: 16. <author> J.P. Talpin and P. Jouvelot: </author> <title> Polymorphic type, region and effect inference. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(3), </volume> <pages> pages 245-271, </pages> <year> 1992. </year>
Reference-contexts: In order to achieve this we must follow <ref> [16] </ref> and [21] and demand that all types in question are (what [9] calls) simple, that is all behaviour annotations are variables (as is the case for int ! fi int). Definition 4.
Reference: 17. <author> J.P. Talpin and P. Jouvelot: </author> <title> The type and effect discipline. </title> <journal> Information and Computation, </journal> <volume> 111, </volume> <year> 1994. </year>
Reference-contexts: In our approach types are annotated with behaviour information (for example the function type t 1 ! b t 2 ). Compared with the literature we do not attempt to collect information about the regions in which communications take place <ref> [17, 20] </ref>; neither do we enable polymorphic recursion in the type annotations as in [4, 20]; on the other hand we do allow behaviours to contain annotated types. <p> In [11] it was demonstrated that one must be very careful when deciding the set of variables over which to generalise in the inference rule for let: not only should this set be disjoint from the set of variables occurring in the behaviour (as is standard in effect systems, e.g. <ref> [17] </ref>) but it should also be upwards closed with respect to a constraint set. The semantic soundness of the generalisation rule (and of the overall system) was proved in [1] and relied heavily on the upwards closure. <p> Clearly this solves all behaviour constraints in C that were of the form (fi 1 fi 2 ) since in S 0 2 S 0 they appear as (fi fl fi fl ). (A less crude approach would be to adopt the ideas of canonical solution from <ref> [17] </ref> but this is best combined with the construction of S 0 3 below.) The remaining non-trivial constraints in S 0 2 S 0 1 C are of form ft i chang fi fl with i 2 f1 : : : ng and n 0. <p> If fi fl does not occur in any of t 1 ; ; t n we could follow <ref> [17] </ref> and define S 0 3 by letting it map fi fl to fi fl [ ft 1 chang [ [ ft n chang and perhaps even dispense with the "fi fl [ ". This situation corresponds to the scenario in [17] where the type inference algorithm enforces that fi fl <p> t 1 ; ; t n we could follow <ref> [17] </ref> and define S 0 3 by letting it map fi fl to fi fl [ ft 1 chang [ [ ft n chang and perhaps even dispense with the "fi fl [ ". This situation corresponds to the scenario in [17] where the type inference algorithm enforces that fi fl does not occur in t 1 ; ; t n by terminating with failure if the condition is not met. <p> However, we shall take the view that it is too demanding to always forbid such use of the communication capabilities and we thus depart from <ref> [17] </ref>. It is important to note that a simple solution could be found if we changed the representation of constraints to record their free variables only: then a constraint (ft i chang fi fl ) is replaced by f (fl fi fl ) j fl 2 FV (t i )g.
Reference: 18. <author> Y.-M. Tang: </author> <title> Control flow analysis by effect systems and abstract interpretation. </title> <type> PhD thesis, </type> <institution> Ecoles des Mines de Paris, </institution> <year> 1994. </year>
Reference-contexts: The presence of type constraints as well as behaviour constraints is a consequence of our overall design: types and behaviours should be inferred simultaneously "from scratch", as is done by the algorithm W presented in Sect. 3. This should be compared with the approach in <ref> [18] </ref> where an effect system with subtyping but without polymorphism is presented; as the "underlying" types are given in advance it is sufficient to generate behaviour constraints.
Reference: 19. <author> M. Tofte. </author> <title> Type inference for polymorphic references. </title> <journal> Information and Computation, </journal> <volume> 89 </volume> <pages> 1-34, </pages> <year> 1990. </year>
Reference-contexts: Behaviours record channel allocations and thereby the set of "dangerous variables", cf. <ref> [19] </ref> (where these are called "imperative" variables) and [21]. A subtyping relation is defined using a subeffecting relation on behaviours, with the usual contravariant ordering for function space but there is no inclusion between base types.
Reference: 20. <author> M. Tofte and L. Birkedal: </author> <title> Region-annotated types and type schemes, </title> <note> 1996. Submitted for publication. </note>
Reference-contexts: In our approach types are annotated with behaviour information (for example the function type t 1 ! b t 2 ). Compared with the literature we do not attempt to collect information about the regions in which communications take place <ref> [17, 20] </ref>; neither do we enable polymorphic recursion in the type annotations as in [4, 20]; on the other hand we do allow behaviours to contain annotated types. <p> Compared with the literature we do not attempt to collect information about the regions in which communications take place [17, 20]; neither do we enable polymorphic recursion in the type annotations as in <ref> [4, 20] </ref>; on the other hand we do allow behaviours to contain annotated types. <p> In [21] a "direct" as well as an "indirect" inference system is presented; the "indirect" is geared towards an algorithm and requires simplicity and employs constraints. A perhaps more uniform approach is given in <ref> [20] </ref> where arrows are annotated with pairs of form *:OE with * an effect variable and with OE a set of region or effect variables; one can think of this as an arrow annotated by * together with the constraint OE *. Atomicity.
Reference: 21. <author> A.K. Wright: </author> <title> Typing references by effect inference. </title> <booktitle> In Proc. ESOP '92, </booktitle> <pages> pages 473-491. </pages> <address> SLNCS 582, </address> <year> 1992. </year>
Reference-contexts: Behaviours record channel allocations and thereby the set of "dangerous variables", cf. [19] (where these are called "imperative" variables) and <ref> [21] </ref>. A subtyping relation is defined using a subeffecting relation on behaviours, with the usual contravariant ordering for function space but there is no inclusion between base types. In our approach types are annotated with behaviour information (for example the function type t 1 ! b t 2 ). <p> This involves (much as in <ref> [21] </ref>) taking downwards closure of a set of variables with respect to a constraint set. In Sect. 8 we shall see that the constraints generated by W can always be solved provided recursive behaviour systems are admitted. <p> In order to achieve this we must follow [16] and <ref> [21] </ref> and demand that all types in question are (what [9] calls) simple, that is all behaviour annotations are variables (as is the case for int ! fi int). Definition 4. <p> There is a discrepancy between the inference system and the algorithm in the sense that non-simple types are allowed in the former, in order to increase ex-pressibility, but disallowed in the latter. In <ref> [21] </ref> a "direct" as well as an "indirect" inference system is presented; the "indirect" is geared towards an algorithm and requires simplicity and employs constraints. <p> The exclusion of the set FV (A; b) C# (rather than just FV (A; b)) is necessary in order to ensure f~ff ~ fig C 0 " = f~ff ~ fig which (cf. the remarks concerning Def. 1) is essential for semantic soundness; the computation of "Indirect Free Variables" of <ref> [21] </ref> is very similar to our notion of downwards closure. <p> Finally we have chosen FV (t) as the "universe" in which to perform the set difference; this universe must be large enough that we may still hope for syntactic completeness and all of FV (t), FV (t) (similar to what is in fact taken in <ref> [21] </ref>) and FV (t) C" apparently too small for this (except for the latter they are not even upwards closed). Fact 9. Let oe = GEN (A; b)(C; t); if C is well-formed then so is oe. Proof.
References-found: 21

