URL: http://www.research.microsoft.com/~ymwang/papers/SRDS-1993.ps
Refering-URL: http://www.research.microsoft.com/~ymwang/papers/SRDS93CR.htm
Root-URL: http://www.research.microsoft.com
Title: Lazy Checkpoint Coordination for Bounding Rollback Propagation  
Author: Yi-Min Wang and W. Kent Fuchs 
Affiliation: Coordinated Science Laboratory University of Illinois at Urbana-Champaign  
Abstract: In this paper, we propose the technique of lazy checkpoint coordination which preserves process autonomy while employing communication-induced checkpoint coordination for bounding rollback propagation. The notion of laziness is introduced to control the coordination frequency and allow a flexible trade-off between the cost of checkpoint coordination and the average rollback distance. Worst-case overhead analysis provides a means for estimating the extra checkpoint overhead. Communication trace-driven simulation for several parallel programs is used to evaluate the benefits of the proposed scheme. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> K. Tsuruoka, A. Kaneko, and Y. Nishihara, </author> <title> Dynamic recovery schemes for distributed processes, </title> <booktitle> in Proc. IEEE 2nd Symp. on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pp. 124-130, </pages> <year> 1981. </year>
Reference-contexts: The interval between c i;x and c i;x+1 is called the xth checkpoint interval of p i . Each message is tagged with the current checkpoint interval number and the process number of the sender, and each receiver p i performs direct dependency tracking <ref> [1, 28] </ref> as follows: if a message sent from (j; y) is processed in (i; x), the direct dependency of c i;x+1 on c j;y is recorded. A garbage collection procedure can be periodically invoked by any process p i . <p> A garbage collection procedure can be periodically invoked by any process p i . First, p i collects the direct dependency information from all the other processes to construct the checkpoint graph <ref> [1] </ref> as shown in Fig. 1 (b). Then the rollback propagation algorithm (Fig. 2) is applied to the checkpoint graph to determine the global recovery line 2 (black vertices), before which all the checkpoints are obsolete and can be discarded.
Reference: [2] <author> B. Bhargava and S. R. Lian, </author> <title> Independent checkpointing and concurrent rollback for recovery An optimistic approach, </title> <booktitle> in Proc. IEEE Symp. on Reliable Distr. Syst., </booktitle> <pages> pp. 3-12, </pages> <year> 1988. </year>
Reference-contexts: When any process initiates a rollback, it starts a similar procedure for recovery. The current volatile states of the surviving processes are treated as additional virtual checkpoints <ref> [2] </ref> for constructing an extended checkpoint graph of which the recovery line is called the local recovery line (shaded vertices) and indicates the consistent rollback state. 3 Lazy Checkpoint Coordination 3.1 Motivation We will refer to the checkpoints initiated independently by each process as basic checkpoints and those triggered by 2
Reference: [3] <author> Y. M. Wang and W. K. Fuchs, </author> <title> Optimistic message logging for independent checkpointing in message-passing systems, </title> <booktitle> in Proc. IEEE Symp. on Reliable Distr. Syst., </booktitle> <pages> pp. 147-154, </pages> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: However, in a general nondeterministic execution, cascading rollback propagation may result in the domino effect [4] which can prevent progression of the recovery line. It has been shown that message reordering [5] and message logging <ref> [3] </ref> can effectively reduce rollback propagation. In order to entirely eliminate the possibility of domino effects, extra checkpoints need to be taken based on the communication history. <p> In contrast, when the receiver of a message m 0 rolls back and unreceives m 0 , the sender needs not roll back to unsend m 0 if m 0 can be retrieved from a message log <ref> [3, 11, 12, 27] </ref> or through a reliable end-to-end transmission protocol [14, 22]. During normal execution, each process periodically and independently saves its state as a checkpoint on stable storage. The interval between c i;x and c i;x+1 is called the xth checkpoint interval of p i .
Reference: [4] <author> B. Randell, </author> <title> System structure for software fault tolerance, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. SE-1, No. 2, </volume> <pages> pp. 220-232, </pages> <month> June </month> <year> 1975. </year>
Reference-contexts: 1 Introduction Uncoordinated checkpointing [1-3] for parallel and distributed systems allows maximum process autonomy and independent design of recovery capability for each process. However, in a general nondeterministic execution, cascading rollback propagation may result in the domino effect <ref> [4] </ref> which can prevent progression of the recovery line. It has been shown that message reordering [5] and message logging [3] can effectively reduce rollback propagation. In order to entirely eliminate the possibility of domino effects, extra checkpoints need to be taken based on the communication history.
Reference: [5] <author> Y. M. Wang and W. K. Fuchs, </author> <title> Scheduling message processing for reducing rollback propagation, </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 204-211, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: However, in a general nondeterministic execution, cascading rollback propagation may result in the domino effect [4] which can prevent progression of the recovery line. It has been shown that message reordering <ref> [5] </ref> and message logging [3] can effectively reduce rollback propagation. In order to entirely eliminate the possibility of domino effects, extra checkpoints need to be taken based on the communication history.
Reference: [6] <author> K. H. Kim, J. H. You, and A. Abouelnaga, </author> <title> A scheme for coordinated execution of independently designed recoverable distributed processes, </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 130-135, </pages> <year> 1986. </year>
Reference-contexts: It has been shown that message reordering [5] and message logging [3] can effectively reduce rollback propagation. In order to entirely eliminate the possibility of domino effects, extra checkpoints need to be taken based on the communication history. Kim et al. <ref> [6] </ref> and Venkatesh et al. [7] employ transitive dependency tracking and insert a checkpoint before processing any message that introduces a new dependency. Russel [8] proves that, by inserting a checkpoint between every pair of consecutive send and receive events (in that order), domino-free recovery is ensured.
Reference: [7] <author> K. Venkatesh, T. Radhakrishnan, and H. F. Li, </author> <title> Optimal checkpointing and local recording for domino-free rollback recovery, </title> <journal> Information Processing Letters, </journal> <volume> Vol. 25, </volume> <pages> pp. 295-303, </pages> <month> July </month> <year> 1987. </year>
Reference-contexts: It has been shown that message reordering [5] and message logging [3] can effectively reduce rollback propagation. In order to entirely eliminate the possibility of domino effects, extra checkpoints need to be taken based on the communication history. Kim et al. [6] and Venkatesh et al. <ref> [7] </ref> employ transitive dependency tracking and insert a checkpoint before processing any message that introduces a new dependency. Russel [8] proves that, by inserting a checkpoint between every pair of consecutive send and receive events (in that order), domino-free recovery is ensured.
Reference: [8] <author> D. L. Russel, </author> <title> State restoration in systems of communicating processes, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. SE-6, No. 2, </volume> <pages> pp. 183-194, </pages> <month> Mar. </month> <year> 1980. </year>
Reference-contexts: In order to entirely eliminate the possibility of domino effects, extra checkpoints need to be taken based on the communication history. Kim et al. [6] and Venkatesh et al. [7] employ transitive dependency tracking and insert a checkpoint before processing any message that introduces a new dependency. Russel <ref> [8] </ref> proves that, by inserting a checkpoint between every pair of consecutive send and receive events (in that order), domino-free recovery is ensured.
Reference: [9] <author> A. Borg, J. Baumbach, and S. Glazer, </author> <title> A message system supporting fault-tolerance, </title> <booktitle> in Proc. 9th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pp. 90-99, </pages> <year> 1983. </year>
Reference: [10] <author> M. L. Powell and D. L. Presotto, </author> <title> Publishing: A reliable broadcast communication mechanism, </title> <booktitle> in Proc. 9th ACM Symp. on Operating Systems Principles, </booktitle> <pages> pp. 100-109, </pages> <year> 1983. </year>
Reference: [11] <author> R. E. Strom and S. Yemini, </author> <title> Optimistic recovery in distributed systems, </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> Vol. 3, No. 3, </volume> <pages> pp. 204-226, </pages> <month> Aug. </month> <year> 1985. </year>
Reference-contexts: In contrast, when the receiver of a message m 0 rolls back and unreceives m 0 , the sender needs not roll back to unsend m 0 if m 0 can be retrieved from a message log <ref> [3, 11, 12, 27] </ref> or through a reliable end-to-end transmission protocol [14, 22]. During normal execution, each process periodically and independently saves its state as a checkpoint on stable storage. The interval between c i;x and c i;x+1 is called the xth checkpoint interval of p i .
Reference: [12] <author> R. E. Strom, D. F. Bacon, and S. A. Yemini, </author> <title> Volatile logging in n-fault-tolerant distributed systems, </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 44-49, </pages> <year> 1988. </year>
Reference-contexts: Russel [8] proves that, by inserting a checkpoint between every pair of consecutive send and receive events (in that order), domino-free recovery is ensured. The log-based approach [9-17] assumes the piecewise deterministic execution model <ref> [12] </ref> where a process execution consists of a number of deterministic state intervals, each started by a nondeterministic event. <p> In contrast, when the receiver of a message m 0 rolls back and unreceives m 0 , the sender needs not roll back to unsend m 0 if m 0 can be retrieved from a message log <ref> [3, 11, 12, 27] </ref> or through a reliable end-to-end transmission protocol [14, 22]. During normal execution, each process periodically and independently saves its state as a checkpoint on stable storage. The interval between c i;x and c i;x+1 is called the xth checkpoint interval of p i .
Reference: [13] <author> A. P. Sistla and J. L. Welch, </author> <title> Efficient distributed recovery using message logging, </title> <booktitle> in Proc. 8th ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pp. 223-238, </pages> <year> 1989. </year>
Reference: [14] <author> D. B. Johnson and W. Zwaenepoel, </author> <title> Recovery in distributed systems using optimistic message logging and checkpoint-ing, </title> <journal> J. of Algorithms, </journal> <volume> Vol. 11, </volume> <pages> pp. 462-491, </pages> <year> 1990. </year>
Reference-contexts: In contrast, when the receiver of a message m 0 rolls back and unreceives m 0 , the sender needs not roll back to unsend m 0 if m 0 can be retrieved from a message log [3, 11, 12, 27] or through a reliable end-to-end transmission protocol <ref> [14, 22] </ref>. During normal execution, each process periodically and independently saves its state as a checkpoint on stable storage. The interval between c i;x and c i;x+1 is called the xth checkpoint interval of p i .
Reference: [15] <author> T. T.-Y. Juang and S. Venkatesan, </author> <title> Crash recovery with little overhead, </title> <booktitle> in Proc. IEEE Int'l Conf. on Distributed Computing Systems, </booktitle> <pages> pp. 454-461, </pages> <year> 1991. </year>
Reference: [16] <author> E. N. Elnozahy and W. Zwaenepoel, Manetho: </author> <title> Transparent rollback-recovery with low overhead, limited rollback and fast output commit, </title> <journal> IEEE Trans. on Computers, </journal> <volume> Vol. 41, No. 5, </volume> <pages> pp. 526-531, </pages> <month> May </month> <year> 1992. </year>
Reference: [17] <author> B. H. L. Alvisi and K. Marzullo, </author> <title> Nonblocking and orphan-free message logging protocols, </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 145-154, </pages> <year> 1993. </year>
Reference: [18] <author> Y. M. Wang, Y. Huang, and W. K. Fuchs, </author> <title> Progressive retry for software error recovery in distributed systems, </title> <booktitle> in Proc. IEEE Fault-Tolerant Computing Symposium, </booktitle> <pages> pp. 138-144, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Office of the Chief of Naval Research under Contract N00014-91-J-1283, and in part by the National Aeronautics and Space Administration (NASA) under Grant NASA NAG 1-613, in cooperation with the Illinois Computer Laboratory for Aerospace Systems and Software (ICLASS). shown that logging a nondeterministic event equivalently places a logical checkpoint <ref> [18] </ref> at the end of the ensuing state interval, and these extra logical checkpoints serve to eliminate the domino effect. Coordinated checkpointing achieves domino-free recovery by sacrificing a certain degree of process autonomy and incurring run-time and extra message overhead.
Reference: [19] <author> K. G. Shin and Y.-H. Lee, </author> <title> Evaluation of error recovery blocks used for cooperating processes, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. 10, No. 6, No. 6, </volume> <pages> pp. 692-700, </pages> <year> 1984. </year>
Reference-contexts: Whenever a process takes a basic checkpoint, coordination messages (dotted lines) are broadcast to request the cooperation in making a consistent set of checkpoints <ref> [19] </ref>. Let B be the total number of basic checkpoints and I be the total number of induced checkpoints. We define the induction ratio as R = B which is a measure of the overhead for performing communication-induced checkpoint coordination.
Reference: [20] <author> K. M. Chandy and L. Lamport, </author> <title> Distributed snapshots: Determining global states of distributed systems, </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> Vol. 3, No. 1, </volume> <pages> pp. 63-75, </pages> <month> Feb. </month> <year> 1985. </year>
Reference: [21] <author> T. H. Lai and T. H. Yang, </author> <title> On distributed snapshots, </title> <journal> Information Processing Letters, </journal> <volume> Vol. 25, </volume> <pages> pp. 153-158, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: An extra checkpoint will be induced on p 0 only when message m 1 indicates that the assumption has failed (Fig. 3 (c)). From another point of view, such a scheme lazily delays the broadcast of the coordination messages and implicitly piggybacks them on future normal messages <ref> [21] </ref>. Both checkpoint and message overhead can therefore be reduced. However, given a basic checkpoint pattern, the number of induced checkpoints in the above scheme is determined by the communication pattern and is not otherwise controllable.
Reference: [22] <author> R. Koo and S. Toueg, </author> <title> Checkpointing and rollback-recovery for distributed systems, </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. SE-13, No. 1, </volume> <pages> pp. 23-31, </pages> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: In contrast, when the receiver of a message m 0 rolls back and unreceives m 0 , the sender needs not roll back to unsend m 0 if m 0 can be retrieved from a message log [3, 11, 12, 27] or through a reliable end-to-end transmission protocol <ref> [14, 22] </ref>. During normal execution, each process periodically and independently saves its state as a checkpoint on stable storage. The interval between c i;x and c i;x+1 is called the xth checkpoint interval of p i .
Reference: [23] <author> K. Li, J. F. Naughton, and J. S. Plank, </author> <title> Checkpointing mul-ticomputer applications, </title> <booktitle> in Proc. IEEE Symp. on Reliable Distr. Syst., </booktitle> <pages> pp. 2-11, </pages> <year> 1991. </year> <title> ratio) as a function of laziness. basic CPIs) as a function of laziness. </title>
Reference: [24] <author> M. F. Kaashoek, R. Michiels, H. E. Bal, and A. S. Tanen-baum, </author> <title> Transparent fault-tolerance in parallel Orca programs, </title> <type> Tech. Rep. </type> <institution> IR-258, Vrije Universiteit, </institution> <address> Amsterdam, </address> <month> Oct. </month> <year> 1991. </year>
Reference: [25] <author> D. Briatico, A. Ciuffoletti, and L. Simoncini, </author> <title> A distributed domino-effect free recovery algorithm, </title> <booktitle> in Proc. IEEE 4th Symp. on Reliability in Distributed Software and Database Systems, </booktitle> <pages> pp. 207-215, </pages> <year> 1984. </year>
Reference-contexts: We will use the term eager checkpoint coordination for the coordination action performed when checkpoints are initiated, as described above. In contrast, processes in a system with lazy checkpoint coordination only coordinate their corresponding checkpoints when message communication indicates a violation of checkpoint consistency. Bri-atico et al. <ref> [25] </ref> force the receiver of a message m to take a checkpoint before processing m if the sender's checkpoint interval number tagged on m is greater than that of the receiver. Checkpoints with the same ordinal numbers are therefore always guaranteed to be consistent. <p> Only corresponding checkpoints with ordinal numbers nZ, where n is an integer, are required to be consistent with each other for bounding rollback propagation. Overhead analysis shows that our generalization can significantly reduce the number of extra checkpoints compared to the previous work <ref> [25] </ref> which corresponds to the case of Z = 1. 2 Checkpointing and Rollback Recovery The system considered in this paper consists of a number of concurrent processes for which all process communication is through message passing. <p> It demonstrates that the Q-bound provides a good estimate of the induction ratio. The large difference in the ratio between Z = 1 and Z 2 confirms that our generalization of the idea of communication-induced checkpoint coordination as described in <ref> [25] </ref> can significantly reduce the extra checkpoint overhead. Fig. 6 plots the average rollback distances in terms of the number of average basic CPIs for the four programs. We use 0.5 for Z = 1 and (Z 1)=2 for Z 2 in the Estimated curve.
Reference: [26] <author> R. D. Schlichting and F. B. Schneider, </author> <title> Fail-stop processors: An approach to designing fault-tolerant computing systems, </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> Vol. 1, No. 3, </volume> <pages> pp. 222-238, </pages> <month> Aug. </month> <year> 1983. </year>
Reference-contexts: Processes are assumed to run on fail-stop processors <ref> [26] </ref> and, for the purpose of presentation, each process is considered an individual recovery unit. In order to allow general nondeterministic execution, we do not assume a piecewise deterministic model.
Reference: [27] <author> A. Borg, W. Blau, W. Graetsch, F. Herrmann, and W. Oberle, </author> <title> Fault tolerance under UNIX, </title> <journal> ACM Trans. on Computer Systems, </journal> <volume> Vol. 7, No. 1, </volume> <pages> pp. 1-24, </pages> <month> Feb. </month> <year> 1989. </year>
Reference-contexts: In contrast, when the receiver of a message m 0 rolls back and unreceives m 0 , the sender needs not roll back to unsend m 0 if m 0 can be retrieved from a message log <ref> [3, 11, 12, 27] </ref> or through a reliable end-to-end transmission protocol [14, 22]. During normal execution, each process periodically and independently saves its state as a checkpoint on stable storage. The interval between c i;x and c i;x+1 is called the xth checkpoint interval of p i .
Reference: [28] <author> Y. M. Wang, A. Lowry, and W. K. Fuchs, </author> <title> Consistent global checkpoints based on direct dependencytracking. </title> <type> Research Report RC 18465, </type> <institution> IBM T.J. Watson Research Center, </institution> <address> York-town Heights, New York, </address> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: The interval between c i;x and c i;x+1 is called the xth checkpoint interval of p i . Each message is tagged with the current checkpoint interval number and the process number of the sender, and each receiver p i performs direct dependency tracking <ref> [1, 28] </ref> as follows: if a message sent from (j; y) is processed in (i; x), the direct dependency of c i;x+1 on c j;y is recorded. A garbage collection procedure can be periodically invoked by any process p i .
Reference: [29] <author> Y. M. Wang, P. Y. Chung, I. J. Lin, and W. K. Fuchs, </author> <title> Checkpoint space reclamation for independent checkpointing in message-passing systems. </title> <type> Tech. Rep. </type> <institution> CRHC-92-06, Coordinated Science Laboratory, University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: Then the rollback propagation algorithm (Fig. 2) is applied to the checkpoint graph to determine the global recovery line 2 (black vertices), before which all the checkpoints are obsolete and can be discarded. Alternatively, an optimal garbage collection algorithm <ref> [29] </ref> can be used to minimize the space overhead by discarding all the garbage checkpoints marked X in Fig. 1 (b). When any process initiates a rollback, it starts a similar procedure for recovery.
Reference: [30] <author> Y. M. Wang and W. K. </author> <title> Fuchs,Lazy checkpoint coordination for bounding rollback propagation. </title> <type> Tech. Rep. </type> <institution> CRHC-92-26, Coordinated Science Laboratory, University of Illinois at Urbana-Champaign, </institution> <year> 1992. </year>
Reference-contexts: By the construction of P 0 , it is not hard to see that, for any n, P 0 always has the earliest c P fl;nZ among all communication patterns, given the basic checkpoint pattern. (Formal proofs can be found in the complete technical report <ref> [30] </ref>.) Hence, P 0 must possess the largest number of c P fl;nZ 's.
Reference: [31] <author> W. Shu and L. V. Kale, </author> <title> Chare kernel A runtime support system for parallel computations, </title> <journal> J. Parallel and Distributed Computing, </journal> <volume> Vol. 11, </volume> <pages> pp. 198-211, </pages> <year> 1991. </year>
Reference-contexts: Case (a)) and Eq. (2), we then define the refined upper bound, called the Q-bound, as follows Q-bound = M (N 1) M (Z1) where [N M ] = 1 if N M is true and 0 otherwise. 5 Experimental Results Four parallel programs written in the Chare Kernel language <ref> [31] </ref> are used for the communication trace-driven simulation. The Chare Kernel has been developed as a machine-independent message-driven parallel language. Program traces used in this paper are collected from an Encore Multimax 510.
References-found: 31

