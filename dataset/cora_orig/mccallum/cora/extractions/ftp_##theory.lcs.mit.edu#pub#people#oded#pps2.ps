URL: ftp://theory.lcs.mit.edu/pub/people/oded/pps2.ps
Refering-URL: http://theory.lcs.mit.edu/~oded/pps.html
Root-URL: 
Title: A Taxonomy of Proof Systems  
Author: Oded Goldreich 
Note: This is a revised version of a survey which has appeared in Complexity Theory Retrospective II, L.A. Hemaspaan dra and A. Selman (eds.), 1996.  
Date: September 1996  
Address: Rehovot, Israel.  
Affiliation: Department of Computer Science and Applied Mathematics Weizmann Institute of Science,  
Abstract: Several alternative formulations of the concept of an efficient proof system are nowadays coexisting in our field. These systems include the classical formulation of N P, interactive proof systems (giving rise to the class IP), computationally-sound proof systems, and probabilistically checkable proofs (PCP), which are closely related to multi-prover interactive proofs (MIP). Although these notions are sometimes introduced using the same generic phrases, they are actually very different in motivation, applications and expressive power. The main objective of this essay is to try to clarify these differences. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> W. Aiello, M. Bellare and R. Venkatesan. </author> <title> Knowledge on the Average Perfect, Statistical and Logarithmic. </title> <booktitle> In 27th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 469-478, </pages> <year> 1995. </year>
Reference-contexts: An extensive treatment of zero-knowledge can be found in [41]. Zero-knowledge is the lowest level of several knowledge-complexity hierarchies that quantify the "amount of knowledge revealed" by a proof system. Definitions and results concerning these hierarchies can be found in [46], [45] and <ref> [1] </ref>. 2.1.3 How powerful should the ("completeness") prover be? Assume that a language L is in IP. This means that there is a verifier V that can be convinced to accept any input in L but cannot be convinced to accept an input not in L.
Reference: [2] <author> W. Aiello and J. H-astad. </author> <title> Statistical Zero-Knowledge Languages can be Recognized in Two Rounds. </title> <journal> Journal of Computer and System Science, </journal> <volume> Vol. 42, </volume> <pages> pages 327-345, </pages> <year> 1991. </year>
Reference-contexts: This result should be contrasted with the results regarding the complexity of almost-perfect zero-knowledge proof systems, namely, that such proof systems exist only for languages in IP (2) " coIP (2) <ref> [2, 35] </ref>. 4 Also, a recent result indicates that one-way functions are essential for the existence of zero-knowledge proofs for hard languages (i.e., languages that cannot be decided in average polynomial time) [67].
Reference: [3] <author> S. Arora. </author> <title> Probabilistic Checking of Proofs and the Hardness of Approximation Problems. </title> <type> PhD thesis, </type> <institution> U.C. Berkeley, </institution> <year> 1994. </year> <note> Available from ECCC. </note>
Reference-contexts: For a proof of N P PCP (f (); f ()) with f (n) = O (log n log log n), see [32]. The proof of the quoted result is more complex and can be found in [6, 5] (see also <ref> [3, 72] </ref>). 8 Below we prove that Theorem 2 implies the rephrased form. The converse is proven by starting with an amplifying reduction of 3SAT to itself and constructing a pcp system for 3SAT as follows.
Reference: [4] <author> S. Arora and C. Lund. </author> <title> Hardness of Approximations. In Approximation Algorithms for NP-hard Problems, </title> <editor> D. Hochbaum ed., PWS, </editor> <year> 1996. </year>
Reference-contexts: It follows that, unless P = N P, there exist no polynomial-time approximation schemes (i.e., a sequence of polynomial-time approximation algorithms, one for each constant approximation ratio) for any problem in the class MAX-SNP-complete. Results for approximation problems not in the class MAX-SNP can be derived as well see <ref> [4] </ref>. An alternative perspective, aimed at obtaining tight non-approximability results, is presented in [15].
Reference: [5] <author> S. Arora, C. Lund, R. Motwani, M. Sudan and M. Szegedy. </author> <title> Proof Verification and Intractability of Approximation Problems. </title> <booktitle> In 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 14-23, </pages> <year> 1992. </year>
Reference-contexts: Hence, PCP (log; poly) N P. Proof Sketch: Observe that guessing the best oracle amounts to guessing only 2 r (n) poly (n) many oracle values. 2 These upper bounds turn out to be tight, but proving this is much more difficult (to say the least). 7 Theorem 2 <ref> [8, 32, 6, 5] </ref> N P is contained in PCP (log; O (1)). 7 Corollary 1 (The PCP characterization of NP) N P = PCP (log; O (1)). <p> For a proof of N P PCP (f (); f ()) with f (n) = O (log n log log n), see [32]. The proof of the quoted result is more complex and can be found in <ref> [6, 5] </ref> (see also [3, 72]). 8 Below we prove that Theorem 2 implies the rephrased form. The converse is proven by starting with an amplifying reduction of 3SAT to itself and constructing a pcp system for 3SAT as follows. <p> Again, additional motivation for this challenge came from the relevance of such a result to the study of approximation problems (see subsection 3.2). The new challenge was met by Arora, Lund, Motwani, Sudan and Szegedy <ref> [5] </ref> and is captured by the equation N P = PCP (log; O (1)): (4) In addition to building on the ideas of Arora and Safra [6], the above result of [5] utilizes ideas and techniques from the works on self-testing/self-correcting [25], degree-tests for multi-variant polynomials [40, 70], and parallelization of <p> The new challenge was met by Arora, Lund, Motwani, Sudan and Szegedy <ref> [5] </ref> and is captured by the equation N P = PCP (log; O (1)): (4) In addition to building on the ideas of Arora and Safra [6], the above result of [5] utilizes ideas and techniques from the works on self-testing/self-correcting [25], degree-tests for multi-variant polynomials [40, 70], and parallelization of multi-prover proof systems [56]. 16 3.1.6 Computationally Sound Proof Systems Argument systems were defined in 1986 by Brassard, Chaum and Crepeau [27], but their complexity-theoretic significance became apparent only in 1992. <p> These facts were observed 17 by Arora, Lund, Motwani, Sudan and Szegedy <ref> [5] </ref>. <p> They also observed that, since Max3SAT is in the class MAX-SNP [68], it followed that each complete problem in that class (e.g., Max2SAT, MaxCUT, MinVC) is hard to approximate to within some constant factor. 21 The results of <ref> [32, 6, 5] </ref> have renewed interest in the complexity of approximation problems, after many years of frustration. Subsequent work established the hardness of approximation problems via the following two approaches. 1st approach: generic reductions from PCP/MIP.
Reference: [6] <author> S. Arora and S. Safra. </author> <title> Probabilistic Checkable Proofs: A New Characterization of NP. </title> <booktitle> In 33rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 1-13, </pages> <year> 1992. </year>
Reference-contexts: Hence, PCP (log; poly) N P. Proof Sketch: Observe that guessing the best oracle amounts to guessing only 2 r (n) poly (n) many oracle values. 2 These upper bounds turn out to be tight, but proving this is much more difficult (to say the least). 7 Theorem 2 <ref> [8, 32, 6, 5] </ref> N P is contained in PCP (log; O (1)). 7 Corollary 1 (The PCP characterization of NP) N P = PCP (log; O (1)). <p> For a proof of N P PCP (f (); f ()) with f (n) = O (log n log log n), see [32]. The proof of the quoted result is more complex and can be found in <ref> [6, 5] </ref> (see also [3, 72]). 8 Below we prove that Theorem 2 implies the rephrased form. The converse is proven by starting with an amplifying reduction of 3SAT to itself and constructing a pcp system for 3SAT as follows. <p> This challenge was met by Arora and Safra <ref> [6] </ref>. <p> The new challenge was met by Arora, Lund, Motwani, Sudan and Szegedy [5] and is captured by the equation N P = PCP (log; O (1)): (4) In addition to building on the ideas of Arora and Safra <ref> [6] </ref>, the above result of [5] utilizes ideas and techniques from the works on self-testing/self-correcting [25], degree-tests for multi-variant polynomials [40, 70], and parallelization of multi-prover proof systems [56]. 16 3.1.6 Computationally Sound Proof Systems Argument systems were defined in 1986 by Brassard, Chaum and Crepeau [27], but their complexity-theoretic significance <p> They also observed that, since Max3SAT is in the class MAX-SNP [68], it followed that each complete problem in that class (e.g., Max2SAT, MaxCUT, MinVC) is hard to approximate to within some constant factor. 21 The results of <ref> [32, 6, 5] </ref> have renewed interest in the complexity of approximation problems, after many years of frustration. Subsequent work established the hardness of approximation problems via the following two approaches. 1st approach: generic reductions from PCP/MIP.
Reference: [7] <author> L. Babai. </author> <title> Trading Group Theory for Randomness. </title> <booktitle> In 17th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 421-420, </pages> <year> 1985. </year>
Reference-contexts: Interactive proof systems gained much attention also due to the interest in the construction of zero-knowledge proofs for languages in N P, presented in [43] (assuming the existence of one-way functions). Babai <ref> [7] </ref>, independently 17 of [48], suggested a different formulation of interactive proofs, termed Arthur-Merlin Games (and giving rise to the class AM).
Reference: [8] <author> L. Babai, L. Fortnow, L. Levin, and M. Szegedy. </author> <title> Checking Computations in Polylogarithmic Time. </title> <booktitle> In 23rd ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 21-31, </pages> <year> 1991. </year>
Reference-contexts: Typical applications for probabilistically checkable proofs arise from settings in which the prover is "committed" to a single "proof" and cannot modify it depending on previous queries of the verifier. See, for example, <ref> [8, 55] </ref>. 2.2.3 The expressive power of PCP Clearly, PCP (poly; 0) equals coRP, whereas PCP (0; poly) equals N P. It is easy to prove an upper bound on the nondeterministic time complexity of languages in the PCP hierarchy. <p> Hence, PCP (log; poly) N P. Proof Sketch: Observe that guessing the best oracle amounts to guessing only 2 r (n) poly (n) many oracle values. 2 These upper bounds turn out to be tight, but proving this is much more difficult (to say the least). 7 Theorem 2 <ref> [8, 32, 6, 5] </ref> N P is contained in PCP (log; O (1)). 7 Corollary 1 (The PCP characterization of NP) N P = PCP (log; O (1)). <p> more complex; see [36, 73]. 2.2.4 PCP and Approximation Interestingly, Theorem 2 can be rephrased without mentioning the class P CP at all. 8 Instead, a new type of polynomial-time reduction, which we call amplifying, emerges. 7 The result N P PCP (poly log; poly log) can be found in <ref> [8] </ref>, although this paper uses a different model and terminology. Furthermore, N P PCP (log; poly log) is easily obtained from [8], by using standard de-randomization techniques. For a proof of N P PCP (f (); f ()) with f (n) = O (log n log log n), see [32]. <p> at all. 8 Instead, a new type of polynomial-time reduction, which we call amplifying, emerges. 7 The result N P PCP (poly log; poly log) can be found in <ref> [8] </ref>, although this paper uses a different model and terminology. Furthermore, N P PCP (log; poly log) is easily obtained from [8], by using standard de-randomization techniques. For a proof of N P PCP (f (); f ()) with f (n) = O (log n log log n), see [32]. <p> The first development was the discovery that the BFL proof system can be "scaled-down" 19 from N EX P to N P. This important discovery was made independently by two sets of authors: Babai, Fortnow, Levin and Szegedy <ref> [8] </ref> and Feige, Goldwasser, Lovasz and Safra [31]. 20 However, the manner in which the BFL proof is scaled-down is different in the two papers, and so are the consequences of the scaling-down. Babai, Fortnow, Levin and Szegedy start by considering only inputs encoded using a special error-correcting code. <p> (by a Random Access Machine). (The fact that the verification procedure never reads the entire "proof" should not come as a surprise, as the procedures of [60, 71, 9] also have this property.) Thus, once "statements" and "proofs" are in the right (error-correcting) form, verification is "super-fast." Babai et. al. <ref> [8] </ref> stress the practical aspects of transparent proofs specifically, for rapidly checking transcripts of long computations. 19 The term "scaled-down" is used here as a (standard) technical term. <p> so, I do not mean to underestimate the technical difficulty of obtaining these results. 20 At a later stage, Szegedy improved the randomness and query complexities of the system in [31] and joined the latter paper, which has appeared as [32]. 15 In the proof system of Babai et. al. <ref> [8] </ref>, the total running time of the verifier is reduced (i.e., "scaled-down") to polylogarithmic. In contrast, in the proof system of Feige, Goldwasser, Lovasz and Safra [31], the verifier stays polynomial-time and only two more refined complexity measures, specifically the randomness and query complexities, are reduced to polylogarithmic. <p> = PCP (poly; poly); (1) the result of Feige, Goldwasser, Lovasz, Safra and Szegedy [32] is restated as N P PCP (f (); f ()) ; where f (n) = O (log n log log n). (2) It should be stressed that the result of Babai, Fortnow, Levin and Szegedy <ref> [8] </ref> also implies a containment of the above form (with f (n) = poly log n). Interest in the new complexity class became immense since Feige et. al. [31, 32] demonstrated its relevance to proving the intractability of approximating some combinatorial problems (specifically, Max-Clique). <p> The proof system constructed by Arora and Safra is very complex, involving recursive use of proof systems and concatenation tests that are much more efficient than the length of strings being tested. (Interestingly, the idea of encoding inputs in an error-correcting form, as suggested in <ref> [8] </ref>, is essential to make this recursion work.) Actually, Arora and Safra showed that N P = PCP (log; f ()) ; where f (n) = o (log n). (3) Hence, a new challenge arose, namely, further reducing the query complexity in particular to a constant while maintaining the logarithmic randomness <p> The contribution of program checking techniques to the results concerning IP and PCP has been discussed above. Here I wish to further discuss the opposite direction in which various proof systems have yielded applications to program checking. In <ref> [8] </ref>, Babai, Fortnow, Levin and Szegedy stress the application of their result to program checking. At the expense of having a powerful computer do some extra work, its computation can be checked by a much weaker computer. <p> This certificate can then be checked in time that is negligible (also in a Turing Machine model) compared to the original computation time. Both the results of <ref> [8] </ref> and [63] refer to program checking in a sense different from Blum's (cf. [23]), namely, the computation of a program on a specific input is checked against the program itself (rather than against a functional description of what is supposed to do).
Reference: [9] <author> L. Babai, L. Fortnow, and C. Lund. </author> <title> Non-Deterministic Exponential Time has Two-Prover Interactive Protocols. </title> <journal> Computational Complexity, </journal> <volume> Vol. 1, No. 1, </volume> <pages> pages 3-40, </pages> <year> 1991. </year> <note> Preliminary version in 31st FOCS, </note> <year> 1990. </year>
Reference-contexts: Subsequently, Shamir used the technique to show that IP = P SP ACE [71], and Babai, Fortnow and Lund used it to show that MIP = N EX P <ref> [9] </ref>. The technique of Lund, Fortnow, Karloff and Nisan has been inspired by ideas coming from works on "program checking" (cf., [23]). <p> Another idea that is implicit in [60] and made explicit in the subsequent works of <ref> [71, 9] </ref> is the representation, introduced by Beaver and Feigenbaum [11], of Boolean formulae as multi-linear polynomials. <p> Hence, MIP has played a role in the historical development leading to the characterization of IP. 3.1.4 Scaling Down the BFL Proof System Yields a New Class The abovementioned multi-prover proof system of Babai, Fortnow and Lund <ref> [9] </ref> (hereafter referred to as the BFL proof system) has been the starting point for fundamental developments regarding N P. The first development was the discovery that the BFL proof system can be "scaled-down" 19 from N EX P to N P. <p> L 2 N P) into transparent proofs that can be verified as vouching for the correctness of the encoded assertion in (probabilistic) polylogarithmic time (by a Random Access Machine). (The fact that the verification procedure never reads the entire "proof" should not come as a surprise, as the procedures of <ref> [60, 71, 9] </ref> also have this property.) Thus, once "statements" and "proofs" are in the right (error-correcting) form, verification is "super-fast." Babai et. al. [8] stress the practical aspects of transparent proofs specifically, for rapidly checking transcripts of long computations. 19 The term "scaled-down" is used here as a (standard) technical <p> Namely, P CP (r (); q ()) denotes the class of languages having probabilistically checkable proofs in which, on input x, the verifier tosses at most r (jxj) coins and makes at most q (jxj) (Boolean) queries to the proof. Hence, whereas the result of Babai, Fortnow and Lund <ref> [9] </ref> can be restated as N E X P = PCP (poly; poly); (1) the result of Feige, Goldwasser, Lovasz, Safra and Szegedy [32] is restated as N P PCP (f (); f ()) ; where f (n) = O (log n log log n). (2) It should be stressed that
Reference: [10] <author> L. Babai and S. Moran. </author> <title> Arthur-Merlin Games: A Randomized Proof System and a Hierarchy of Complexity Classes. </title> <journal> Journal of Computer and System Science, </journal> <volume> Vol. 36, </volume> <pages> pages 254-276, </pages> <year> 1988. </year>
Reference-contexts: Concerning the finer structure of the IP-hierarchy, the following is known: * For every integer function, f , so that f (n) 2 for all n, the class IP (O (f ())) collapses to the class IP (f ()), and in particular IP (O (1)) collapses to IP (2) <ref> [10] </ref>. * The class IP (2) contains languages not known to be in N P, e.g., Graph Non-Isomorphism [43]. 2 See [60] for the general technique and [71] for its application yielding the quoted result. 3 * The class IP (2) is contained in N P=poly (i.e., nonuniform-NP), analogously to BPP
Reference: [11] <author> D. Beaver and J. Feigenbaum. </author> <title> Hiding Instances in Multioracle Queries. </title> <booktitle> In 7th Symposium on Theoretical Aspects of Computer Science, </booktitle> <publisher> Springer Verlag, LNCS Vol. </publisher> <pages> 415, pages 37-48, </pages> <year> 1990. </year>
Reference-contexts: Another idea that is implicit in [60] and made explicit in the subsequent works of [71, 9] is the representation, introduced by Beaver and Feigenbaum <ref> [11] </ref>, of Boolean formulae as multi-linear polynomials. It may be of interest to note that the technique of Lund et. al. has been first applied in the context of multi-prover interactive proofs, yielding P ]P MIP, and that the result quoted above (concerning IP) followed later.
Reference: [12] <author> M. Bellare. </author> <title> Interactive Proofs and Approximation: Reductions from Two Provers in One Round. </title> <booktitle> In Proc. 2nd Israel Symp. on Theory of Computing and Systems (ISTCS93), </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pages 266-274, </pages> <year> 1993. </year>
Reference-contexts: Subsequent work established the hardness of approximation problems via the following two approaches. 1st approach: generic reductions from PCP/MIP. That is, reducing the evaluation of the acceptance probability of a PCP/MIP system directly to the approximation problem being considered (cf., Bellare <ref> [12] </ref>, Lund and Yannakakis [61]).
Reference: [13] <author> M. Bellare and O. Goldreich. </author> <title> On Defining Proofs of Knowledge. </title> <booktitle> In Crypto92, </booktitle> <publisher> Springer Verlag, LNCS Vol. </publisher> <pages> 740, pages 390-420, </pages> <year> 1992. </year> <month> 21 </month>
Reference-contexts: not known to be reducible to standard complexity assumptions; yet, plausibility arguments towards the existence of the former can be found in [63]. 2.4.2 Proofs of Knowledge The concept of a proof of knowledge is very appealing, yet its precise formulation is much more complex than one may expect; see <ref> [13] </ref>. A key notion in the definition is that of a knowledge extractor. <p> The concept of proofs of knowledge was introduced in the paper of Goldwasser, Micali and Rackoff [48], but it is only recently that it has been given a satisfactory formal treatment <ref> [13] </ref>. 3.2 PCP and Approximation As stated above, probabilistic checkable proofs became the focus of so much attention due to their relation to the difficulty of approximation. The relation between PCP and approximation was first pointed out by Feige, Goldwasser, Lovasz and Safra [31] (see [32]).
Reference: [14] <author> M. Bellare, O. Goldreich and S. Goldwasser. </author> <title> Randomness in interactive proofs. </title> <journal> Computa--tional Complexity, </journal> <volume> Vol. 4, No. 1, </volume> <pages> pages 319-354, </pages> <year> 1993. </year>
Reference-contexts: In general, one may consider the error probability (in the soundness condition) as another parameter. It is not hard to see that the error probability in interactive proofs can be reduced by independent sequential and/or parallel repetitions. Actually, this holds even for somewhat dependent parallel repetitions; see <ref> [14] </ref>, which is instructive also for the simpler case of independent parallel repetitions. On the other hand, requiring zero soundness error, in interactive proof systems, restricts their existence to languages in N P [38].
Reference: [15] <author> M. Bellare, O. Goldreich and M. Sudan. </author> <title> Free Bits, PCPs and Non-Approximability - Towards Tight Results. </title> <booktitle> Extended abstract in 36th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 422-431, </pages> <year> 1995. </year> <note> Full version appeared as TR95-024 of ECCC. </note>
Reference-contexts: Furthermore, error reduction can be obtained at very moderate cost in the randomness complexity (cf. <ref> [15] </ref>). Parallel repetition is a much more complex matter (than in the context of interactive proof systems); see [69] (and do not get misled by an error in an early version of [36]). <p> Results for approximation problems not in the class MAX-SNP can be derived as well see [4]. An alternative perspective, aimed at obtaining tight non-approximability results, is presented in <ref> [15] </ref>. I believe that amplifying reductions are interesting for their own sake and may find other applications in complexity theory. 2.3 Computationally Sound Proof Systems In the two settings just discussed (i.e., MIP and PCP) the restrictions imposed on the prover were of a "physical" nature. <p> Furthermore, sometimes such a reduction is coupled with a new PCP/MIP system that is more efficient in some parameters yielding stronger negative results than those obtained by reducing previously known PCP/MIP systems (cf., Bellare, Goldwasser, Lund and Russell [17], Bellare and Sudan [18] and Bellare, Goldreich and Sudan <ref> [15] </ref>). Lastly, it is important to select the "right" complexity parameters to be optimized (cf., [17, 33, 18]). For an elaborate discussion of the latter point see [15]. 2nd approach: reductions among approximation problems. <p> obtained by reducing previously known PCP/MIP systems (cf., Bellare, Goldwasser, Lund and Russell [17], Bellare and Sudan [18] and Bellare, Goldreich and Sudan <ref> [15] </ref>). Lastly, it is important to select the "right" complexity parameters to be optimized (cf., [17, 33, 18]). For an elaborate discussion of the latter point see [15]. 2nd approach: reductions among approximation problems. The newly acquired collection of hard approximation problems motivates and facilitates attempts to prove the hardness of new problems by using approximation-preserving reductions.
Reference: [16] <author> M. Bellare and S. Goldwasser. </author> <title> The Complexity of Decision versus Search. </title> <journal> SIAM J. on Computing, </journal> <volume> Vol. 23, No. 1, </volume> <pages> pages 97-119, </pages> <year> 1994. </year>
Reference-contexts: This interpretation generalizes the notion of self-reducibility of NP languages. (By self-reducibility of an NP language we mean that the search problem of finding an NP-witness is Cook-reducible to deciding membership in the language. Thus, every NP-complete language has a relatively efficient proof system.) See <ref> [16] </ref>. 3rd interpretation: A prover is considered relatively efficient if it can be implemented by a probabilistic machine that runs in time that is polynomial in the deterministic complexity of the language. This interpretation relates the difficulty of convincing a "lazy" verifier to the complexity of finding the truth alone. <p> Open Problem 3: Regarding subsection 2.1.3, it will be interesting to understand the limitations of "relatively efficient provers" according to the 2nd and 3rd interpretations. A better understanding of the self-reducibility on NP-languages is also long due. A specific challenge (cf., <ref> [16] </ref>): provide an NP-proof system for Quadratic Non-Residucity (QNR), using a probabilistic polynomial-time prover with access to QNR language.
Reference: [17] <author> M. Bellare, S. Goldwasser, C. Lund and A. Russell. </author> <title> Efficient Probabilistically Checkable Proofs and Applications to Approximation. </title> <booktitle> In 25th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 294-304, </pages> <year> 1993. </year> <note> A revised version is available from the authors. </note>
Reference-contexts: Furthermore, sometimes such a reduction is coupled with a new PCP/MIP system that is more efficient in some parameters yielding stronger negative results than those obtained by reducing previously known PCP/MIP systems (cf., Bellare, Goldwasser, Lund and Russell <ref> [17] </ref>, Bellare and Sudan [18] and Bellare, Goldreich and Sudan [15]). Lastly, it is important to select the "right" complexity parameters to be optimized (cf., [17, 33, 18]). For an elaborate discussion of the latter point see [15]. 2nd approach: reductions among approximation problems. <p> Lastly, it is important to select the "right" complexity parameters to be optimized (cf., <ref> [17, 33, 18] </ref>). For an elaborate discussion of the latter point see [15]. 2nd approach: reductions among approximation problems. The newly acquired collection of hard approximation problems motivates and facilitates attempts to prove the hardness of new problems by using approximation-preserving reductions.
Reference: [18] <author> M. Bellare and M. Sudan. </author> <title> Improved Non-Approximability Results. </title> <booktitle> In 26th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 184-193, </pages> <year> 1994. </year>
Reference-contexts: Furthermore, sometimes such a reduction is coupled with a new PCP/MIP system that is more efficient in some parameters yielding stronger negative results than those obtained by reducing previously known PCP/MIP systems (cf., Bellare, Goldwasser, Lund and Russell [17], Bellare and Sudan <ref> [18] </ref> and Bellare, Goldreich and Sudan [15]). Lastly, it is important to select the "right" complexity parameters to be optimized (cf., [17, 33, 18]). For an elaborate discussion of the latter point see [15]. 2nd approach: reductions among approximation problems. <p> Lastly, it is important to select the "right" complexity parameters to be optimized (cf., <ref> [17, 33, 18] </ref>). For an elaborate discussion of the latter point see [15]. 2nd approach: reductions among approximation problems. The newly acquired collection of hard approximation problems motivates and facilitates attempts to prove the hardness of new problems by using approximation-preserving reductions.
Reference: [19] <author> M. Ben-Or, O. Goldreich, S. Goldwasser, J. H-astad, J. Kilian, S. Micali and P. Rogaway. </author> <title> Everything Provable is Probable in Zero-Knowledge. </title> <booktitle> In Crypto88, </booktitle> <publisher> Springer Verlag, LNCS Vol. </publisher> <pages> 403, pages 37-56, </pages> <year> 1990 </year>
Reference-contexts: The most important result concerning zero-knowledge is that, assuming the existence of one-way functions, each language in N P (and actually even in IP) has a zero-knowledge interactive proof system; see [43, 64, 50] (and <ref> [19] </ref>, respectively). <p> Actually, under the same assumption, zero-knowledge proofs exists for any language in IP <ref> [51, 19] </ref>, but the latter elegant result has almost no applications. Subsequently, zero-knowledge proofs have become the focus of much attention in cryptographic circles and, as one may expect, many interesting results followed.
Reference: [20] <author> M. Ben-Or, S. Goldwasser, J. Kilian and A. Wigderson. </author> <title> Multi-Prover Interactive Proofs: How to Remove Intractability. </title> <booktitle> In 20th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 113-131, </pages> <year> 1988. </year>
Reference-contexts: The advantage in using such a split system is that it enables the presentation of (perfect) zero-knowledge proof systems for any language in N P, using no intractability assumptions <ref> [20] </ref>. 6 This is implicit in the universal quantifier used in the soundness condition. 6 2.2.2 Probabilistically Checkable Proofs (PCP) When viewed in terms of an interactive proof system, the probabilistically checkable proof (PCP) setting consists of a prover that is memoryless. <p> Interestingly, Babai underestimated the power of the new class, conjecturing that the class AM (even with an unbounded number of rounds) is "very close" to N P. 3.1.2 Multi-Prover Interactive Proof Systems A generalization of interactive proofs to multi-prover interactive proofs has been suggested by Ben-Or, Goldwasser, Kilian and Wigderson <ref> [20] </ref>. Again, the main motivation came from zero-knowledge aspects; specifically, introducing multi-prover zero-knowledge proofs for N P without 17 Here "independence" does not mean concurrently.
Reference: [21] <author> M. Blum, A. De Santis, S. Micali, and G. Persiano. </author> <title> Non-Interactive Zero-Knowledge Proof Systems. </title> <journal> SIAM J. on Computing, </journal> <volume> Vol. 20, No. 6, </volume> <pages> pages 1084-1118, </pages> <year> 1991. </year>
Reference-contexts: Yet, in most "non-interactive" models, both the prover and the verifier interact with a (trusted) random string (cf., <ref> [22, 21] </ref>) or even query a random oracle (cf., the so-called "Guaranteed CS-proofs" of [63]). However, in addition to NP-proofs, there is another model that is truly non-interactive, namely, the so-called Cryptographic CS-proof [63].
Reference: [22] <author> M. Blum, P. Feldman and S. Micali. </author> <title> Non-Interactive Zero-Knowledge and its Applications. </title> <booktitle> In 20th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 103-112, </pages> <year> 1988. </year>
Reference-contexts: Yet, in most "non-interactive" models, both the prover and the verifier interact with a (trusted) random string (cf., <ref> [22, 21] </ref>) or even query a random oracle (cf., the so-called "Guaranteed CS-proofs" of [63]). However, in addition to NP-proofs, there is another model that is truly non-interactive, namely, the so-called Cryptographic CS-proof [63]. <p> The latter idea can be traced back to a paper of Fiat and Shamir [34] 3.1.7 Other Types of Proof Systems The setting of non-interactive proofs was first introduced by Blum, Feldman and Micali <ref> [22] </ref>.
Reference: [23] <author> M. Blum and S. Kannan. </author> <title> Designing Programs that Check their Work. </title> <booktitle> In 21st ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 86-97, </pages> <year> 1989. </year>
Reference-contexts: The technique of Lund, Fortnow, Karloff and Nisan has been inspired by ideas coming from works on "program checking" (cf., <ref> [23] </ref>). In particular, their interactive proof system for the permanent combines Lipton's "self-testing" procedure for the permanent (which represents the permanent as a multi-linear polynomial) [59], and the "downwards self-reducibility" procedure of Blum, Luby and Rubinfeld [25]. <p> Typical examples are given in the works of Lund and Yannakakis [61], Khanna, Linial and Safra [53], and Furer [37]. 3.3 Interactive Proofs and Program Checking When introducing the concept of program checking, Blum (cf. <ref> [23] </ref>) was indeed aware of its relation to interactive proof systems. In particular, his program checker for Graph Isomorphism mimics the interactive proof of [43]. Subsequently, the development paths of the two concepts (i.e., program checking and efficient proof systems) have continued to intersect. <p> This certificate can then be checked in time that is negligible (also in a Turing Machine model) compared to the original computation time. Both the results of [8] and [63] refer to program checking in a sense different from Blum's (cf. <ref> [23] </ref>), namely, the computation of a program on a specific input is checked against the program itself (rather than against a functional description of what is supposed to do).
Reference: [24] <author> M. Blum and S. Micali. </author> <title> How to Generate Cryptographically Strong Sequences of PseudoRandom Bits. </title> <journal> SIAM J. Comput., </journal> <volume> Vol. 13, </volume> <pages> pages 850-864, </pages> <year> 1984. </year> <booktitle> In 23rd FOCS, </booktitle> <pages> pages 80-91, </pages> <year> 1982. </year>
Reference-contexts: However, most of the complexity-theoretic impact of the former notion was on the theory of pseudorandomness (cf., for example, <ref> [24, 75] </ref> and [66, 65]) which has evolved almost concurrently to the evolution of interactive proof systems. The wide applicability of zero-knowledge proofs has been demonstrated by Goldreich, Micali and Wigderson [43].
Reference: [25] <author> M. Blum, M. Luby and R. Rubinfeld. </author> <title> Self-Testing/Correcting with Applications to Numerical Problems. </title> <journal> Journal of Computer and System Science, </journal> <volume> Vol. 47, No. 3, </volume> <pages> pages 549-595, </pages> <year> 1993. </year> <note> Preliminary version in 22th STOC, </note> <year> 1990. </year>
Reference-contexts: In particular, their interactive proof system for the permanent combines Lipton's "self-testing" procedure for the permanent (which represents the permanent as a multi-linear polynomial) [59], and the "downwards self-reducibility" procedure of Blum, Luby and Rubinfeld <ref> [25] </ref>. Another idea that is implicit in [60] and made explicit in the subsequent works of [71, 9] is the representation, introduced by Beaver and Feigenbaum [11], of Boolean formulae as multi-linear polynomials. <p> was met by Arora, Lund, Motwani, Sudan and Szegedy [5] and is captured by the equation N P = PCP (log; O (1)): (4) In addition to building on the ideas of Arora and Safra [6], the above result of [5] utilizes ideas and techniques from the works on self-testing/self-correcting <ref> [25] </ref>, degree-tests for multi-variant polynomials [40, 70], and parallelization of multi-prover proof systems [56]. 16 3.1.6 Computationally Sound Proof Systems Argument systems were defined in 1986 by Brassard, Chaum and Crepeau [27], but their complexity-theoretic significance became apparent only in 1992.
Reference: [26] <author> R. Boppana, J. H-astad, and S. Zachos. </author> <title> Does Co-NP Have Short Interactive Proofs? Information Processing Letters, </title> <journal> Vol. </journal> <volume> 25, </volume> <pages> pages 127-132, </pages> <month> May </month> <year> 1987. </year>
Reference-contexts: N P, e.g., Graph Non-Isomorphism [43]. 2 See [60] for the general technique and [71] for its application yielding the quoted result. 3 * The class IP (2) is contained in N P=poly (i.e., nonuniform-NP), analogously to BPP P=poly. * If coN P IP (2) then the polynomial-time hierarchy collapses <ref> [26] </ref>. It is conjectured that coN P is not contained in IP (2), and consequently that interactive proofs with an unbounded number of message exchanges are more powerful than interactive proofs in which only a bounded (i.e., constant) number of messages are exchanged. <p> early works, and in particular in [27], argument systems are negligently referred to as "interactive proofs." This is quite confusing since arguments differ from interactive proofs not only by definition but also in expressive power (unless PSPACE IP (1)) and in zero-knowledge properties [27, 35] (unless the polynomial-time hierarchy collapses <ref> [26] </ref>). 12 Actually, there are three variants of this model see [62, 63]. In the current subsection we concentrate on the "interactive" variant of [62].
Reference: [27] <author> G. Brassard, D. Chaum and C. Crepeau. </author> <title> Minimum Disclosure Proofs of Knowledge. </title> <journal> Journal of Computer and System Science, </journal> <volume> Vol. 37, No. 2, </volume> <pages> pages 156-189, </pages> <year> 1988. </year> <note> Preliminary version by Brassard and Crepeau in 27th FOCS, </note> <year> 1986. </year>
Reference-contexts: The family F is called collision-free if it is collision-free w.r.t. all polynomials, and is called strongly collision-free if, for some * &gt; 0, it is collision-free w.r.t. the function f (n) def . 11 In some early works, and in particular in <ref> [27] </ref>, argument systems are negligently referred to as "interactive proofs." This is quite confusing since arguments differ from interactive proofs not only by definition but also in expressive power (unless PSPACE IP (1)) and in zero-knowledge properties [27, 35] (unless the polynomial-time hierarchy collapses [26]). 12 Actually, there are three variants <p> f (n) def . 11 In some early works, and in particular in [27], argument systems are negligently referred to as "interactive proofs." This is quite confusing since arguments differ from interactive proofs not only by definition but also in expressive power (unless PSPACE IP (1)) and in zero-knowledge properties <ref> [27, 35] </ref> (unless the polynomial-time hierarchy collapses [26]). 12 Actually, there are three variants of this model see [62, 63]. In the current subsection we concentrate on the "interactive" variant of [62]. <p> An additional advantage of argument systems is that, under strong intractability assumptions, there exist perfect zero-knowledge arguments (rather than computational zero-knowledge interactive proofs) for any language in N P <ref> [27] </ref>. 10 Collision-free functions exist assuming the intractability of factoring integers (i.e., in polynomial time). Strong collision-free functions exist if integers cannot be factored in time 2 n * , for some * &gt; 0. <p> of Arora and Safra [6], the above result of [5] utilizes ideas and techniques from the works on self-testing/self-correcting [25], degree-tests for multi-variant polynomials [40, 70], and parallelization of multi-prover proof systems [56]. 16 3.1.6 Computationally Sound Proof Systems Argument systems were defined in 1986 by Brassard, Chaum and Crepeau <ref> [27] </ref>, but their complexity-theoretic significance became apparent only in 1992. This happened when Kilian, using early results on P CP (due to [32]), showed that, under some intractability assumptions, every language in N P has a computationally-sound proof in which the randomness and communication complexities are polylogarithmic [55].
Reference: [28] <author> G. Brassard and C. Crepeau. </author> <title> Zero-Knowledge Simulation of Boolean Circuits. </title> <booktitle> In Crypto86, </booktitle> <publisher> Springer Verlag, LNCS Vol. </publisher> <pages> 263, pages 223-233, </pages> <year> 1987. </year> <month> 22 </month>
Reference-contexts: Subsequently, zero-knowledge proofs have become the focus of much attention in cryptographic circles and, as one may expect, many interesting results followed. But this is a story for a separate essay. 22 Some sources credit Brassard and Crepeau <ref> [28] </ref> for independently discovering the same result.
Reference: [29] <author> R. Chang, B. Chor, O. Goldreich, J. Hartmanis, J. H-astad, D. Ranjan, and P. Rohatgi. </author> <title> The Random Oracle Hypothesis is False. </title> <journal> Journal of Computer and System Science, </journal> <volume> Vol. 49, No. 1, </volume> <pages> pages 24-39, </pages> <year> 1994. </year>
Reference-contexts: Interestingly, this technique "does not relativize." and, furthermore, yields results (e.g., IP = PSP ACE) that are false relative to most oracles, providing a dramatic refutation of the "Random Oracle Hypothesis"; see <ref> [29] </ref>.
Reference: [30] <author> S. A. Cook. </author> <title> The Complexity of Theorem-Proving Procedures. </title> <booktitle> In 3rd ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 151-158, </pages> <year> 1971. </year>
Reference-contexts: systems, and then pass to the story of their applications to deriving hardness results for approximation problems, program checking and zero-knowledge proofs. 3.1 The Evolution of Proof Systems The story of N P is well-known (except maybe for the fact that NP-completeness was discovered by Levin [58] independently of Cook <ref> [30] </ref> and Karp [52]; see Trakhtenbrot's survey of Russian research on NP [74]).
Reference: [31] <author> U. Feige, S. Goldwasser, L. Lovasz and S. Safra. </author> <title> On the Complexity of Approximating the Maximum Size of a Clique. </title> <type> Unpublished manuscript, </type> <year> 1990. </year>
Reference-contexts: The first development was the discovery that the BFL proof system can be "scaled-down" 19 from N EX P to N P. This important discovery was made independently by two sets of authors: Babai, Fortnow, Levin and Szegedy [8] and Feige, Goldwasser, Lovasz and Safra <ref> [31] </ref>. 20 However, the manner in which the BFL proof is scaled-down is different in the two papers, and so are the consequences of the scaling-down. Babai, Fortnow, Levin and Szegedy start by considering only inputs encoded using a special error-correcting code. <p> Doing so, I do not mean to underestimate the technical difficulty of obtaining these results. 20 At a later stage, Szegedy improved the randomness and query complexities of the system in <ref> [31] </ref> and joined the latter paper, which has appeared as [32]. 15 In the proof system of Babai et. al. [8], the total running time of the verifier is reduced (i.e., "scaled-down") to polylogarithmic. In contrast, in the proof system of Feige, Goldwasser, Lovasz and Safra [31], the verifier stays polynomial-time <p> of the system in <ref> [31] </ref> and joined the latter paper, which has appeared as [32]. 15 In the proof system of Babai et. al. [8], the total running time of the verifier is reduced (i.e., "scaled-down") to polylogarithmic. In contrast, in the proof system of Feige, Goldwasser, Lovasz and Safra [31], the verifier stays polynomial-time and only two more refined complexity measures, specifically the randomness and query complexities, are reduced to polylogarithmic. This eliminates the need to assume that the input is in a special error-correcting form, and yields a more appealing (i.e., less cumbersome) complexity class. <p> Interest in the new complexity class became immense since Feige et. al. <ref> [31, 32] </ref> demonstrated its relevance to proving the intractability of approximating some combinatorial problems (specifically, Max-Clique). I will elaborate on this aspect of their work in subsection 3.2. <p> The relation between PCP and approximation was first pointed out by Feige, Goldwasser, Lovasz and Safra <ref> [31] </ref> (see [32]). Specifically, they showed how to construct a graph representing the possible computations of a pcp verifier on a specific input so that the size of the maximum clique in this graph equals the accepting probability (scaled down by an easy to determine factor).
Reference: [32] <author> U. Feige, S. Goldwasser, L. Lovasz, S. Safra, and M. Szegedy. </author> <title> Approximating Clique is almost NP-complete. </title> <booktitle> In 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 2-12, </pages> <year> 1991. </year>
Reference-contexts: Hence, PCP (log; poly) N P. Proof Sketch: Observe that guessing the best oracle amounts to guessing only 2 r (n) poly (n) many oracle values. 2 These upper bounds turn out to be tight, but proving this is much more difficult (to say the least). 7 Theorem 2 <ref> [8, 32, 6, 5] </ref> N P is contained in PCP (log; O (1)). 7 Corollary 1 (The PCP characterization of NP) N P = PCP (log; O (1)). <p> Furthermore, N P PCP (log; poly log) is easily obtained from [8], by using standard de-randomization techniques. For a proof of N P PCP (f (); f ()) with f (n) = O (log n log log n), see <ref> [32] </ref>. The proof of the quoted result is more complex and can be found in [6, 5] (see also [3, 72]). 8 Below we prove that Theorem 2 implies the rephrased form. <p> Doing so, I do not mean to underestimate the technical difficulty of obtaining these results. 20 At a later stage, Szegedy improved the randomness and query complexities of the system in [31] and joined the latter paper, which has appeared as <ref> [32] </ref>. 15 In the proof system of Babai et. al. [8], the total running time of the verifier is reduced (i.e., "scaled-down") to polylogarithmic. <p> Hence, whereas the result of Babai, Fortnow and Lund [9] can be restated as N E X P = PCP (poly; poly); (1) the result of Feige, Goldwasser, Lovasz, Safra and Szegedy <ref> [32] </ref> is restated as N P PCP (f (); f ()) ; where f (n) = O (log n log log n). (2) It should be stressed that the result of Babai, Fortnow, Levin and Szegedy [8] also implies a containment of the above form (with f (n) = poly log <p> Interest in the new complexity class became immense since Feige et. al. <ref> [31, 32] </ref> demonstrated its relevance to proving the intractability of approximating some combinatorial problems (specifically, Max-Clique). I will elaborate on this aspect of their work in subsection 3.2. <p> This fact provided a very strong motivation for trying to reduce these complexities and obtain a tight characterization of N P in terms of P CP (; ). 3.1.5 Tightening the Relation between NP and PCP Once the work of Feige et. al. <ref> [32] </ref> had been presented, the challenge was clear: showing that N P equals PCP (log; log). This challenge was met by Arora and Safra [6]. <p> This happened when Kilian, using early results on P CP (due to <ref> [32] </ref>), showed that, under some intractability assumptions, every language in N P has a computationally-sound proof in which the randomness and communication complexities are polylogarithmic [55]. Consequently, Micali suggested three new types of computationally-sound proof systems that he calls CS-proofs [62, 63]. <p> The relation between PCP and approximation was first pointed out by Feige, Goldwasser, Lovasz and Safra [31] (see <ref> [32] </ref>). Specifically, they showed how to construct a graph representing the possible computations of a pcp verifier on a specific input so that the size of the maximum clique in this graph equals the accepting probability (scaled down by an easy to determine factor). <p> They also observed that, since Max3SAT is in the class MAX-SNP [68], it followed that each complete problem in that class (e.g., Max2SAT, MaxCUT, MinVC) is hard to approximate to within some constant factor. 21 The results of <ref> [32, 6, 5] </ref> have renewed interest in the complexity of approximation problems, after many years of frustration. Subsequent work established the hardness of approximation problems via the following two approaches. 1st approach: generic reductions from PCP/MIP.
Reference: [33] <author> U. Feige and J. Kilian. </author> <title> Two Prover Protocols Low Error at Affordable Rates. </title> <booktitle> In 26th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 172-183, </pages> <year> 1994. </year>
Reference-contexts: Lastly, it is important to select the "right" complexity parameters to be optimized (cf., <ref> [17, 33, 18] </ref>). For an elaborate discussion of the latter point see [15]. 2nd approach: reductions among approximation problems. The newly acquired collection of hard approximation problems motivates and facilitates attempts to prove the hardness of new problems by using approximation-preserving reductions.
Reference: [34] <author> A. Fiat and A. Shamir. </author> <title> How to Prove Yourself: Practical Solution to Identification and Signature Problems. </title> <booktitle> In Crypto86, </booktitle> <publisher> Springer Verlag, LNCS Vol. </publisher> <pages> 263, pages 186-189, </pages> <year> 1987. </year>
Reference-contexts: The latter idea can be traced back to a paper of Fiat and Shamir <ref> [34] </ref> 3.1.7 Other Types of Proof Systems The setting of non-interactive proofs was first introduced by Blum, Feldman and Micali [22]. <p> A specific challenge (cf., [16]): provide an NP-proof system for Quadratic Non-Residucity (QNR), using a probabilistic polynomial-time prover with access to QNR language. Open Problem 4: Try to provide firm grounds for the heuristics of making proof systems noninteractive by use of "random public functions" (cf., <ref> [34, 63] </ref>): I advise not to try to define the latter notion (in a general form), but rather devise some ad-hoc method, using some specific but widely believed complexity assumptions (e.g., hardness of deciding Quadratic Residucity modulo a composite number), for this specific application.
Reference: [35] <author> L. Fortnow, </author> <title> The Complexity of Perfect Zero-Knowledge. </title> <booktitle> Advances in Computing Research: a research annual, Vol. 5 (Randomness and Computation, </booktitle> <editor> S. Micali, </editor> <publisher> ed.), </publisher> <pages> pages 327-343, </pages> <year> 1989. </year>
Reference-contexts: This result should be contrasted with the results regarding the complexity of almost-perfect zero-knowledge proof systems, namely, that such proof systems exist only for languages in IP (2) " coIP (2) <ref> [2, 35] </ref>. 4 Also, a recent result indicates that one-way functions are essential for the existence of zero-knowledge proofs for hard languages (i.e., languages that cannot be decided in average polynomial time) [67]. <p> Non-zero error probability is 3 The verifier is not necessarily the one specified (i.e., V ) yet, for sake of simplicity this issue is ignored here. 4 See also an appendix in [45] indicating an error in <ref> [35] </ref>. 4 essential also to zero-knowledge proofs (which otherwise exist only for coRP [44]). Hence, besides the apparent strengthening of expressive power, interactive proof systems do offer some properties (specifically, zero-knowledge) that cannot be offered by an NP-proof system. An extensive treatment of zero-knowledge can be found in [41]. <p> f (n) def . 11 In some early works, and in particular in [27], argument systems are negligently referred to as "interactive proofs." This is quite confusing since arguments differ from interactive proofs not only by definition but also in expressive power (unless PSPACE IP (1)) and in zero-knowledge properties <ref> [27, 35] </ref> (unless the polynomial-time hierarchy collapses [26]). 12 Actually, there are three variants of this model see [62, 63]. In the current subsection we concentrate on the "interactive" variant of [62].
Reference: [36] <author> L. Fortnow, J. Rompel and M. Sipser. </author> <title> On the Power of Multi-Prover Interactive Protocols. </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. 134, </volume> <pages> pages 545-557, </pages> <year> 1994. </year> <note> Preliminary version in Proc. 3rd IEEE Symp. on Structure in Complexity Theory, </note> <year> 1988. </year>
Reference-contexts: Furthermore, error reduction can be obtained at very moderate cost in the randomness complexity (cf. [15]). Parallel repetition is a much more complex matter (than in the context of interactive proof systems); see [69] (and do not get misled by an error in an early version of <ref> [36] </ref>). On the other hand, nonzero error probability is essential to the above results as otherwise one can eliminate randomness altogether and use PCP (0; q ()) DTIME (2 q poly). <p> The translation in the first direction is easy (i.e., just prefix each verifier-message by the identity of the prover), but the translation in the other direction is more complex; see <ref> [36, 73] </ref>. 2.2.4 PCP and Approximation Interestingly, Theorem 2 can be rephrased without mentioning the class P CP at all. 8 Instead, a new type of polynomial-time reduction, which we call amplifying, emerges. 7 The result N P PCP (poly log; poly log) can be found in [8], although this paper <p> Yet, the complexity theoretic prospects of the new class, denoted MIP, have not been ignored. A more appealing, to my taste, formulation of the class MIP has been presented by Fortnow, Rompel and Sipser <ref> [36] </ref>. The latter formulation exactly coincides with the formulation now known as probabilistically checkable proofs (i.e., PCP). 3.1.3 Algebraic Methods Demonstrate the Power of Interactive Proofs The amazing power of interactive proof systems has been demonstrated by using algebraic methods. <p> This eliminates the need to assume that the input is in a special error-correcting form, and yields a more appealing (i.e., less cumbersome) complexity class. This complexity class is a refinement of the class introduced in <ref> [36] </ref>. The refinement is obtained by specifying the randomness and query complexities.
Reference: [37] <author> M. Furer. </author> <title> Improved Hardness Results for Approximating the Chromatic Number. </title> <booktitle> In 36th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 414-421, </pages> <year> 1995. </year>
Reference-contexts: The newly acquired collection of hard approximation problems motivates and facilitates attempts to prove the hardness of new problems by using approximation-preserving reductions. Typical examples are given in the works of Lund and Yannakakis [61], Khanna, Linial and Safra [53], and Furer <ref> [37] </ref>. 3.3 Interactive Proofs and Program Checking When introducing the concept of program checking, Blum (cf. [23]) was indeed aware of its relation to interactive proof systems. In particular, his program checker for Graph Isomorphism mimics the interactive proof of [43].
Reference: [38] <author> M. Furer, O. Goldreich, Y. Mansour, M. Sipser, and S. Zachos. </author> <title> On Completeness and Soundness in Interactive Proof Systems. </title> <booktitle> Advances in Computing Research: a research annual, Vol. 5 (Randomness and Computation, </booktitle> <editor> S. Micali, </editor> <publisher> ed.), </publisher> <pages> pages 429-442, </pages> <year> 1989. </year>
Reference-contexts: Actually, this holds even for somewhat dependent parallel repetitions; see [14], which is instructive also for the simpler case of independent parallel repetitions. On the other hand, requiring zero soundness error, in interactive proof systems, restricts their existence to languages in N P <ref> [38] </ref>. <p> Furthermore, IP (1; poly) contains BP P (see [57] or <ref> [38] </ref>). Hence, IP IP (1; poly) contains BP P [ N P, whereas we currently do not know whether N P contains BP P. <p> The latter restricted proof systems are called Arthur-Merlin games or public-coin interactive proofs. In addition, aside from the zero-level and 1-level, the IP-hierarchy equals an analogous two-sided error hierarchy <ref> [38] </ref>. In the latter proof systems the completeness condition is relaxed so that the verifier is required to accept each x 2 L with probability at least 2 3 . 2.1.2 Zero-Knowledge and Knowledge Complexity Zero-knowledge is a central notion in cryptography.
Reference: [39] <author> M.R. Garey and D.S. Johnson. </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completeness. </title> <editor> W. H. </editor> <publisher> Freeman, </publisher> <year> 1979. </year>
Reference: [40] <author> P. Gemmell, R. Lipton, R. Rubinfeld, M. Sudan, and A. Wigderson. </author> <title> Self-Testing/Correcting for Polynomials and for Approximate Functions. </title> <booktitle> In 23th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 32-42, </pages> <year> 1991. </year>
Reference-contexts: Motwani, Sudan and Szegedy [5] and is captured by the equation N P = PCP (log; O (1)): (4) In addition to building on the ideas of Arora and Safra [6], the above result of [5] utilizes ideas and techniques from the works on self-testing/self-correcting [25], degree-tests for multi-variant polynomials <ref> [40, 70] </ref>, and parallelization of multi-prover proof systems [56]. 16 3.1.6 Computationally Sound Proof Systems Argument systems were defined in 1986 by Brassard, Chaum and Crepeau [27], but their complexity-theoretic significance became apparent only in 1992.
Reference: [41] <author> O. Goldreich. </author> <title> Foundation of Cryptography Fragments of a Book. </title> <month> February </month> <year> 1995. </year> <note> Available from ECCC. </note>
Reference-contexts: Hence, besides the apparent strengthening of expressive power, interactive proof systems do offer some properties (specifically, zero-knowledge) that cannot be offered by an NP-proof system. An extensive treatment of zero-knowledge can be found in <ref> [41] </ref>. Zero-knowledge is the lowest level of several knowledge-complexity hierarchies that quantify the "amount of knowledge revealed" by a proof system.
Reference: [42] <author> O. Goldreich and J. H-astad. </author> <title> On the Message Complexity of Interactive Proof Systems. </title> <booktitle> TR96-018 of ECCC, </booktitle> <month> March </month> <year> 1996. </year>
Reference-contexts: Cryptographic CS-proofs are short "certificates" that can be efficiently verified (like NP-proofs), are "relatively easy" to find for inputs in the language, but are very hard to find (rather than do not exist) for inputs not in the language. Namely, for 15 See <ref> [42] </ref> for further investigations. 11 IP arguments CS-proof PCP MIP restrictions none poly-time polynomial memoryless split on prover + aux. input in Dtime (i.e., oracle) entity motivation generalize restrict IP augment see (as I see it) NP (see Remark 1) NP Remark 2 expressive PSPACE IP (1) PH EXP 16 scalable:
Reference: [43] <author> O. Goldreich, S. Micali and A. Wigderson. </author> <title> Proofs that Yield Nothing but their Validity or All Languages in NP Have Zero-Knowledge Proof Systems. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 38, No. 1, </volume> <pages> pages 691-729, </pages> <year> 1991. </year> <note> Preliminary version in 27th FOCS, 1986. 23 </note>
Reference-contexts: Then, IP (M; R) = [ m2M;r2R IP (m (); r ()): Finally, IP (m ()) def = IP (m (); poly) and IP def = IP (poly). 1 We avoid the definition of "interacting machines." This definition can be found in <ref> [48, 43] </ref>. 2 In Item (1), we have followed the common convention of specifying both the verifier and the prover. <p> , so that f (n) 2 for all n, the class IP (O (f ())) collapses to the class IP (f ()), and in particular IP (O (1)) collapses to IP (2) [10]. * The class IP (2) contains languages not known to be in N P, e.g., Graph Non-Isomorphism <ref> [43] </ref>. 2 See [60] for the general technique and [71] for its application yielding the quoted result. 3 * The class IP (2) is contained in N P=poly (i.e., nonuniform-NP), analogously to BPP P=poly. * If coN P IP (2) then the polynomial-time hierarchy collapses [26]. <p> The most important result concerning zero-knowledge is that, assuming the existence of one-way functions, each language in N P (and actually even in IP) has a zero-knowledge interactive proof system; see <ref> [43, 64, 50] </ref> (and [19], respectively). <p> Even in this case, the interactive proof need not consist of the prover sending the auxiliary input to the verifier; for example, an alternative procedure may allow the prover to be zero-knowledge (see <ref> [43] </ref>). This interpretation is adequate and in fact crucial for applications in which such an auxiliary input is available to the otherwise polynomial-time parties. <p> Typically, the auxiliary input is available in cryptographic applications in which both the input and an NP-witness for it are generated by some party who later wishes to prove (in zero-knowledge) that the input is in the language. 5 See <ref> [43] </ref>. 2nd interpretation: A prover is considered relatively efficient if it can be implemented by a probabilistic polynomial-time oracle machine with oracle access to the language L itself. <p> The first evidence of the surprising power of interactive proofs was given by Goldreich, Micali and Wigderson, who presented an interactive proof system for Graph Non-Isomorphism <ref> [43] </ref>, a language not known to be in N P. Interactive proof systems gained much attention also due to the interest in the construction of zero-knowledge proofs for languages in N P, presented in [43] (assuming the existence of one-way functions). <p> was given by Goldreich, Micali and Wigderson, who presented an interactive proof system for Graph Non-Isomorphism <ref> [43] </ref>, a language not known to be in N P. Interactive proof systems gained much attention also due to the interest in the construction of zero-knowledge proofs for languages in N P, presented in [43] (assuming the existence of one-way functions). Babai [7], independently 17 of [48], suggested a different formulation of interactive proofs, termed Arthur-Merlin Games (and giving rise to the class AM). <p> In particular, his program checker for Graph Isomorphism mimics the interactive proof of <ref> [43] </ref>. Subsequently, the development paths of the two concepts (i.e., program checking and efficient proof systems) have continued to intersect. The contribution of program checking techniques to the results concerning IP and PCP has been discussed above. <p> The wide applicability of zero-knowledge proofs has been demonstrated by Goldreich, Micali and Wigderson <ref> [43] </ref>. Most importantly, they showed how to construct zero-knowledge proof systems for any language in N P. 22 Their construction uses a cryptographic primitive called a commitment scheme that may be implemented using any one-way function [50, 64].
Reference: [44] <author> O. Goldreich and Y. Oren. </author> <title> Definitions and Properties of Zero-Knowledge Proof Systems. </title> <journal> Journal of Cryptology, </journal> <volume> Vol. 7, No. 1, </volume> <pages> pages 1-32, </pages> <year> 1994. </year>
Reference-contexts: Non-zero error probability is 3 The verifier is not necessarily the one specified (i.e., V ) yet, for sake of simplicity this issue is ignored here. 4 See also an appendix in [45] indicating an error in [35]. 4 essential also to zero-knowledge proofs (which otherwise exist only for coRP <ref> [44] </ref>). Hence, besides the apparent strengthening of expressive power, interactive proof systems do offer some properties (specifically, zero-knowledge) that cannot be offered by an NP-proof system. An extensive treatment of zero-knowledge can be found in [41]. <p> In particular, zero-knowledge has motivated the first leap beyond N P taken when interactive proofs were conceived by Goldwasser, Micali and Rackoff [48]. The reason being that a more liberal notion of a proof seemed (and in fact is <ref> [44] </ref>) necessary in order to enable simulation of the transcript without ability to perform the interaction ("in real time").
Reference: [45] <author> O. Goldreich, R. Ostrovsky and E. Petrank, </author> <title> Knowledge Complexity and Computational Complexity. </title> <booktitle> In 26th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 534-543, </pages> <year> 1994. </year>
Reference-contexts: Non-zero error probability is 3 The verifier is not necessarily the one specified (i.e., V ) yet, for sake of simplicity this issue is ignored here. 4 See also an appendix in <ref> [45] </ref> indicating an error in [35]. 4 essential also to zero-knowledge proofs (which otherwise exist only for coRP [44]). Hence, besides the apparent strengthening of expressive power, interactive proof systems do offer some properties (specifically, zero-knowledge) that cannot be offered by an NP-proof system. <p> An extensive treatment of zero-knowledge can be found in [41]. Zero-knowledge is the lowest level of several knowledge-complexity hierarchies that quantify the "amount of knowledge revealed" by a proof system. Definitions and results concerning these hierarchies can be found in [46], <ref> [45] </ref> and [1]. 2.1.3 How powerful should the ("completeness") prover be? Assume that a language L is in IP. This means that there is a verifier V that can be convinced to accept any input in L but cannot be convinced to accept an input not in L.
Reference: [46] <author> O. Goldreich and E. Petrank. </author> <title> Quantifying Knowledge Complexity. </title> <booktitle> In 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 59-68, </pages> <year> 1991. </year>
Reference-contexts: An extensive treatment of zero-knowledge can be found in [41]. Zero-knowledge is the lowest level of several knowledge-complexity hierarchies that quantify the "amount of knowledge revealed" by a proof system. Definitions and results concerning these hierarchies can be found in <ref> [46] </ref>, [45] and [1]. 2.1.3 How powerful should the ("completeness") prover be? Assume that a language L is in IP. This means that there is a verifier V that can be convinced to accept any input in L but cannot be convinced to accept an input not in L.
Reference: [47] <author> S. Goldwasser and S. Micali. </author> <title> Probabilistic Encryption. </title> <journal> Journal of Computer and System Science, </journal> <volume> Vol. 28, No. 2, </volume> <pages> pages 270-299, </pages> <year> 1984. </year> <note> Preliminary version in 14th STOC, </note> <year> 1982. </year>
Reference-contexts: The notion of computational indistinguishability, introduced by Goldwasser and Micali (in the context of defining security of encryption schemes <ref> [47] </ref>) and Yao (in full generality [75]), is central to the definition of zero-knowledge. However, most of the complexity-theoretic impact of the former notion was on the theory of pseudorandomness (cf., for example, [24, 75] and [66, 65]) which has evolved almost concurrently to the evolution of interactive proof systems.
Reference: [48] <author> S. Goldwasser, S. Micali and C. Rackoff. </author> <title> The Knowledge Complexity of Interactive Proof Systems. </title> <journal> SIAM Journal on Computing, </journal> <volume> Vol. 18, </volume> <pages> pages 186-208, </pages> <year> 1989. </year> <note> Preliminary version in 17th STOC, </note> <year> 1985. </year>
Reference-contexts: Then, IP (M; R) = [ m2M;r2R IP (m (); r ()): Finally, IP (m ()) def = IP (m (); poly) and IP def = IP (poly). 1 We avoid the definition of "interacting machines." This definition can be found in <ref> [48, 43] </ref>. 2 In Item (1), we have followed the common convention of specifying both the verifier and the prover. <p> Our story thus starts with the definition of interactive proof systems. 3.1.1 Interactive Proof Systems Motivated by the desire to formulate the most general type of "proofs" that may be used within cryptographic protocols, Goldwasser, Micali and Rackoff introduced the notion of an interactive proof system <ref> [48] </ref>. Although the main thrust of their paper is the introduction of a special type of interactive proofs (i.e., ones that are zero-knowledge), the computational complexity potential of the class of languages possessing interactive proof systems, denoted IP , has been pointed out. <p> Interactive proof systems gained much attention also due to the interest in the construction of zero-knowledge proofs for languages in N P, presented in [43] (assuming the existence of one-way functions). Babai [7], independently 17 of <ref> [48] </ref>, suggested a different formulation of interactive proofs, termed Arthur-Merlin Games (and giving rise to the class AM). <p> The concept of proofs of knowledge was introduced in the paper of Goldwasser, Micali and Rackoff <ref> [48] </ref>, but it is only recently that it has been given a satisfactory formal treatment [13]. 3.2 PCP and Approximation As stated above, probabilistic checkable proofs became the focus of so much attention due to their relation to the difficulty of approximation. <p> In particular, zero-knowledge has motivated the first leap beyond N P taken when interactive proofs were conceived by Goldwasser, Micali and Rackoff <ref> [48] </ref>. The reason being that a more liberal notion of a proof seemed (and in fact is [44]) necessary in order to enable simulation of the transcript without ability to perform the interaction ("in real time").
Reference: [49] <author> S. Goldwasser and M. Sipser. </author> <title> Private Coins versus Public Coins in Interactive Proof Systems. </title> <booktitle> Advances in Computing Research: a research annual, Vol. 5 (Randomness and Computation, </booktitle> <editor> S. Micali, </editor> <publisher> ed.), </publisher> <pages> pages 73-90, </pages> <year> 1989. </year>
Reference-contexts: The IP-hierarchy (i.e., IP ()) equals an analogous hierarchy in which the verifier is restricted to send the outcome of any coin it tosses <ref> [49] </ref>. The latter restricted proof systems are called Arthur-Merlin games or public-coin interactive proofs. In addition, aside from the zero-level and 1-level, the IP-hierarchy equals an analogous two-sided error hierarchy [38]. <p> Syntactically, Arthur-Merlin Games are a restricted form of interactive proof systems, yet Goldwasser and Sipser have subsequently shown that these restricted systems are as powerful as the general ones; namely, AM = IP <ref> [49] </ref>.
Reference: [50] <author> J. H-astad, R. Impagliazzo, L.A. Levin and M. Luby. </author> <title> Construction of Pseudorandom Generator from any One-Way Function. </title> <note> To appear in SIAM J. on Computing. Preliminary versions by Impagliazzo et. </note> <editor> al. </editor> <booktitle> in 21st STOC (1989) and H-astad in 22nd STOC (1990). </booktitle>
Reference-contexts: The most important result concerning zero-knowledge is that, assuming the existence of one-way functions, each language in N P (and actually even in IP) has a zero-knowledge interactive proof system; see <ref> [43, 64, 50] </ref> (and [19], respectively). <p> Most importantly, they showed how to construct zero-knowledge proof systems for any language in N P. 22 Their construction uses a cryptographic primitive called a commitment scheme that may be implemented using any one-way function <ref> [50, 64] </ref>. Actually, under the same assumption, zero-knowledge proofs exists for any language in IP [51, 19], but the latter elegant result has almost no applications. Subsequently, zero-knowledge proofs have become the focus of much attention in cryptographic circles and, as one may expect, many interesting results followed.
Reference: [51] <author> R. Impagliazzo and M. Yung. </author> <title> Direct Zero-Knowledge Computations. </title> <booktitle> In Crypto87, </booktitle> <publisher> Springer Verlag, LNCS Vol. </publisher> <pages> 293, pages 40-51, </pages> <year> 1987. </year>
Reference-contexts: Actually, under the same assumption, zero-knowledge proofs exists for any language in IP <ref> [51, 19] </ref>, but the latter elegant result has almost no applications. Subsequently, zero-knowledge proofs have become the focus of much attention in cryptographic circles and, as one may expect, many interesting results followed.
Reference: [52] <author> R.M. Karp. </author> <title> Reducibility Among Combinatorial Problems. In Complexity of Computer Computations, </title> <editor> (Raymond E. Miller and James W. Thatcher, eds.), </editor> <publisher> Plenum Press, </publisher> <pages> pages 85-103, </pages> <year> 1972. </year>
Reference-contexts: pass to the story of their applications to deriving hardness results for approximation problems, program checking and zero-knowledge proofs. 3.1 The Evolution of Proof Systems The story of N P is well-known (except maybe for the fact that NP-completeness was discovered by Levin [58] independently of Cook [30] and Karp <ref> [52] </ref>; see Trakhtenbrot's survey of Russian research on NP [74]).
Reference: [53] <author> S. Khanna, N. Linial and S. Safra. </author> <title> On the Hardness of Approximating the Chromatic Number. </title> <booktitle> In Proc. 2nd Israel Symp. on Theory of Computing and Systems (ISTCS93), </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pages 250-260, </pages> <year> 1993. </year>
Reference-contexts: The newly acquired collection of hard approximation problems motivates and facilitates attempts to prove the hardness of new problems by using approximation-preserving reductions. Typical examples are given in the works of Lund and Yannakakis [61], Khanna, Linial and Safra <ref> [53] </ref>, and Furer [37]. 3.3 Interactive Proofs and Program Checking When introducing the concept of program checking, Blum (cf. [23]) was indeed aware of its relation to interactive proof systems. In particular, his program checker for Graph Isomorphism mimics the interactive proof of [43].
Reference: [54] <author> S. Khanna, R. Motwani, M. Sudan and U. Vazirani. </author> <title> On Syntatic versus Computational Views of Approximability. </title> <booktitle> In 35th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 819-830, </pages> <year> 1994. </year>
Reference-contexts: Thus, given a satisfiable 3CNF formula, it is as hard to find a truth assignment that satisfies a fraction of its clauses as it is to find a truth assignment that satisfies all clauses. Consequently, for any approximation problem in the class MAX-SNP-complete (cf. [68] and <ref> [54] </ref>), there exists a constant so that approximating the problem up to this constant is NP-hard. It follows that, unless P = N P, there exist no polynomial-time approximation schemes (i.e., a sequence of polynomial-time approximation algorithms, one for each constant approximation ratio) for any problem in the class MAX-SNP-complete.
Reference: [55] <author> J. Kilian. </author> <title> A Note on Efficient Zero-Knowledge Proofs and Arguments. </title> <booktitle> In 24th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 723-732, </pages> <year> 1992. </year>
Reference-contexts: Typical applications for probabilistically checkable proofs arise from settings in which the prover is "committed" to a single "proof" and cannot modify it depending on previous queries of the verifier. See, for example, <ref> [8, 55] </ref>. 2.2.3 The expressive power of PCP Clearly, PCP (poly; 0) equals coRP, whereas PCP (0; poly) equals N P. It is easy to prove an upper bound on the nondeterministic time complexity of languages in the PCP hierarchy. <p> Strong collision-free functions exist if integers cannot be factored in time 2 n * , for some * &gt; 0. Theorem 5 <ref> [55] </ref>: Let L 2 N P and assume the existence of collision-free functions (resp., strong collision-free functions). <p> This happened when Kilian, using early results on P CP (due to [32]), showed that, under some intractability assumptions, every language in N P has a computationally-sound proof in which the randomness and communication complexities are polylogarithmic <ref> [55] </ref>. Consequently, Micali suggested three new types of computationally-sound proof systems that he calls CS-proofs [62, 63].
Reference: [56] <author> D. Lapidot and A. Shamir. </author> <title> Fully Parallelized Multi Prover Protocols for NEXP-time. </title> <booktitle> In 32nd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 13-18, </pages> <year> 1991. </year>
Reference-contexts: by the equation N P = PCP (log; O (1)): (4) In addition to building on the ideas of Arora and Safra [6], the above result of [5] utilizes ideas and techniques from the works on self-testing/self-correcting [25], degree-tests for multi-variant polynomials [40, 70], and parallelization of multi-prover proof systems <ref> [56] </ref>. 16 3.1.6 Computationally Sound Proof Systems Argument systems were defined in 1986 by Brassard, Chaum and Crepeau [27], but their complexity-theoretic significance became apparent only in 1992.
Reference: [57] <author> C. Lautemann. </author> <title> BPP and the Polynomial Hierarchy. </title> <journal> Information Processing Letters, </journal> <volume> Vol. 17 (4), </volume> <pages> pages 215-217, </pages> <year> 1983. </year>
Reference-contexts: Furthermore, IP (1; poly) contains BP P (see <ref> [57] </ref> or [38]). Hence, IP IP (1; poly) contains BP P [ N P, whereas we currently do not know whether N P contains BP P.
Reference: [58] <author> L. Levin. </author> <title> Universal'nye perebornye zadachi (Universal Search Problems: in Russian). </title> <journal> Problemy Peredachi Informatsii, </journal> <volume> 9 (3), </volume> <pages> pages 265-266, </pages> <year> 1973. </year>
Reference-contexts: the evolution of proof systems, and then pass to the story of their applications to deriving hardness results for approximation problems, program checking and zero-knowledge proofs. 3.1 The Evolution of Proof Systems The story of N P is well-known (except maybe for the fact that NP-completeness was discovered by Levin <ref> [58] </ref> independently of Cook [30] and Karp [52]; see Trakhtenbrot's survey of Russian research on NP [74]).
Reference: [59] <author> R.J. Lipton. </author> <title> New Directions in Testing, </title> <type> Unpublished manuscript, </type> <year> 1989. </year> <month> 24 </month>
Reference-contexts: The technique of Lund, Fortnow, Karloff and Nisan has been inspired by ideas coming from works on "program checking" (cf., [23]). In particular, their interactive proof system for the permanent combines Lipton's "self-testing" procedure for the permanent (which represents the permanent as a multi-linear polynomial) <ref> [59] </ref>, and the "downwards self-reducibility" procedure of Blum, Luby and Rubinfeld [25]. Another idea that is implicit in [60] and made explicit in the subsequent works of [71, 9] is the representation, introduced by Beaver and Feigenbaum [11], of Boolean formulae as multi-linear polynomials.
Reference: [60] <author> C. Lund, L. Fortnow, H. Karloff, and N. Nisan. </author> <title> Algebraic Methods for Interactive Proof Systems. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 39, No. 4, </volume> <pages> pages 859-868, </pages> <year> 1992. </year> <note> Preliminary version in 31st FOCS, </note> <year> 1990. </year>
Reference-contexts: The main result concerning interactive proof systems is that they exist for any language recognizable in polynomial space. Namely, Theorem 1 <ref> [60, 71] </ref> IP = PSPACE. 2 Theorem 1, was established using algebraic methods. <p> f (n) 2 for all n, the class IP (O (f ())) collapses to the class IP (f ()), and in particular IP (O (1)) collapses to IP (2) [10]. * The class IP (2) contains languages not known to be in N P, e.g., Graph Non-Isomorphism [43]. 2 See <ref> [60] </ref> for the general technique and [71] for its application yielding the quoted result. 3 * The class IP (2) is contained in N P=poly (i.e., nonuniform-NP), analogously to BPP P=poly. * If coN P IP (2) then the polynomial-time hierarchy collapses [26]. <p> The basic technique has been introduced by Lund, Fortnow, Karloff and Nisan, who applied it to show that the polynomial-time hierarchy (and actually P ]P ) is in IP <ref> [60] </ref>. Subsequently, Shamir used the technique to show that IP = P SP ACE [71], and Babai, Fortnow and Lund used it to show that MIP = N EX P [9]. <p> In particular, their interactive proof system for the permanent combines Lipton's "self-testing" procedure for the permanent (which represents the permanent as a multi-linear polynomial) [59], and the "downwards self-reducibility" procedure of Blum, Luby and Rubinfeld [25]. Another idea that is implicit in <ref> [60] </ref> and made explicit in the subsequent works of [71, 9] is the representation, introduced by Beaver and Feigenbaum [11], of Boolean formulae as multi-linear polynomials. <p> L 2 N P) into transparent proofs that can be verified as vouching for the correctness of the encoded assertion in (probabilistic) polylogarithmic time (by a Random Access Machine). (The fact that the verification procedure never reads the entire "proof" should not come as a surprise, as the procedures of <ref> [60, 71, 9] </ref> also have this property.) Thus, once "statements" and "proofs" are in the right (error-correcting) form, verification is "super-fast." Babai et. al. [8] stress the practical aspects of transparent proofs specifically, for rapidly checking transcripts of long computations. 19 The term "scaled-down" is used here as a (standard) technical
Reference: [61] <author> C. Lund and M. Yannakakis. </author> <title> On the Hardness of Approximating Minimization Problems, </title> <journal> Journal of the ACM, </journal> <volume> Vol. 41, </volume> <pages> pages 960-981, </pages> <year> 1994. </year> <note> Preliminary version in 25th STOC, </note> <year> 1993. </year>
Reference-contexts: Subsequent work established the hardness of approximation problems via the following two approaches. 1st approach: generic reductions from PCP/MIP. That is, reducing the evaluation of the acceptance probability of a PCP/MIP system directly to the approximation problem being considered (cf., Bellare [12], Lund and Yannakakis <ref> [61] </ref>). Furthermore, sometimes such a reduction is coupled with a new PCP/MIP system that is more efficient in some parameters yielding stronger negative results than those obtained by reducing previously known PCP/MIP systems (cf., Bellare, Goldwasser, Lund and Russell [17], Bellare and Sudan [18] and Bellare, Goldreich and Sudan [15]). <p> The newly acquired collection of hard approximation problems motivates and facilitates attempts to prove the hardness of new problems by using approximation-preserving reductions. Typical examples are given in the works of Lund and Yannakakis <ref> [61] </ref>, Khanna, Linial and Safra [53], and Furer [37]. 3.3 Interactive Proofs and Program Checking When introducing the concept of program checking, Blum (cf. [23]) was indeed aware of its relation to interactive proof systems. In particular, his program checker for Graph Isomorphism mimics the interactive proof of [43].
Reference: [62] <author> S. Micali. </author> <type> CS Proofs. Unpublished manuscript, </type> <year> 1992. </year>
Reference-contexts: referred to as "interactive proofs." This is quite confusing since arguments differ from interactive proofs not only by definition but also in expressive power (unless PSPACE IP (1)) and in zero-knowledge properties [27, 35] (unless the polynomial-time hierarchy collapses [26]). 12 Actually, there are three variants of this model see <ref> [62, 63] </ref>. In the current subsection we concentrate on the "interactive" variant of [62]. <p> In the current subsection we concentrate on the "interactive" variant of <ref> [62] </ref>. A brief discussion of the "non-interactive" variants of [63] is postponed to subsection 2.4. 13 Again, this means a running time polynomial in the length of the common input. 14 Below, we consider the expressing power of both models. <p> The only difference is that here the potential provers are uniform probabilistic machines, with no auxiliary inputs, running in time polynomial in the deterministic complexity of the language. A result analogous to Theorem 5 is obtainable also in the current setting. Specifically, Theorem 6 <ref> [62] </ref>: Let L 2 EX P . Then, assuming the existence of strong collision-free functions, there exists a CS-proof system for L. <p> Consequently, Micali suggested three new types of computationally-sound proof systems that he calls CS-proofs <ref> [62, 63] </ref>. Micali showed that Kilian's construction can be applied also for languages beyond N P, and more importantly that using interaction with a trusted random oracle allows one to get rid of the interaction between the parties as well as of the intractability assumptions [63].
Reference: [63] <author> S. Micali. </author> <title> CS Proofs. </title> <booktitle> In 35th IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 436-453, </pages> <year> 1994. </year>
Reference-contexts: See <ref> [63] </ref>. 5 For example, suppose a party generates a composite number by multiplying together two primes, and that it later wishes to prove in (in zero-knowledge) that the number it has chosen indeed has this form. <p> referred to as "interactive proofs." This is quite confusing since arguments differ from interactive proofs not only by definition but also in expressive power (unless PSPACE IP (1)) and in zero-knowledge properties [27, 35] (unless the polynomial-time hierarchy collapses [26]). 12 Actually, there are three variants of this model see <ref> [62, 63] </ref>. In the current subsection we concentrate on the "interactive" variant of [62]. <p> In the current subsection we concentrate on the "interactive" variant of [62]. A brief discussion of the "non-interactive" variants of <ref> [63] </ref> is postponed to subsection 2.4. 13 Again, this means a running time polynomial in the length of the common input. 14 Below, we consider the expressing power of both models. <p> Yet, in most "non-interactive" models, both the prover and the verifier interact with a (trusted) random string (cf., [22, 21]) or even query a random oracle (cf., the so-called "Guaranteed CS-proofs" of <ref> [63] </ref>). However, in addition to NP-proofs, there is another model that is truly non-interactive, namely, the so-called Cryptographic CS-proof [63]. <p> in most "non-interactive" models, both the prover and the verifier interact with a (trusted) random string (cf., [22, 21]) or even query a random oracle (cf., the so-called "Guaranteed CS-proofs" of <ref> [63] </ref>). However, in addition to NP-proofs, there is another model that is truly non-interactive, namely, the so-called Cryptographic CS-proof [63]. Cryptographic CS-proofs are short "certificates" that can be efficiently verified (like NP-proofs), are "relatively easy" to find for inputs in the language, but are very hard to find (rather than do not exist) for inputs not in the language. <p> Unfortunately, the existence of (non-trivial) Cryptographic CS-proofs is not known to be reducible to standard complexity assumptions; yet, plausibility arguments towards the existence of the former can be found in <ref> [63] </ref>. 2.4.2 Proofs of Knowledge The concept of a proof of knowledge is very appealing, yet its precise formulation is much more complex than one may expect; see [13]. A key notion in the definition is that of a knowledge extractor. <p> Consequently, Micali suggested three new types of computationally-sound proof systems that he calls CS-proofs <ref> [62, 63] </ref>. Micali showed that Kilian's construction can be applied also for languages beyond N P, and more importantly that using interaction with a trusted random oracle allows one to get rid of the interaction between the parties as well as of the intractability assumptions [63]. <p> Micali showed that Kilian's construction can be applied also for languages beyond N P, and more importantly that using interaction with a trusted random oracle allows one to get rid of the interaction between the parties as well as of the intractability assumptions <ref> [63] </ref>. The latter idea can be traced back to a paper of Fiat and Shamir [34] 3.1.7 Other Types of Proof Systems The setting of non-interactive proofs was first introduced by Blum, Feldman and Micali [22]. <p> This holds in a Random Access Machine computation model. Recently, Micali showed that using "Cryptographic CS-proofs" (see this chapter's Technical Part) one can transform programs to ones that in addition to the result of the computation supply a very short certificate of the validity of the computation <ref> [63] </ref>. This certificate can then be checked in time that is negligible (also in a Turing Machine model) compared to the original computation time. Both the results of [8] and [63] refer to program checking in a sense different from Blum's (cf. [23]), namely, the computation of a program on a <p> that in addition to the result of the computation supply a very short certificate of the validity of the computation <ref> [63] </ref>. This certificate can then be checked in time that is negligible (also in a Turing Machine model) compared to the original computation time. Both the results of [8] and [63] refer to program checking in a sense different from Blum's (cf. [23]), namely, the computation of a program on a specific input is checked against the program itself (rather than against a functional description of what is supposed to do). <p> A specific challenge (cf., [16]): provide an NP-proof system for Quadratic Non-Residucity (QNR), using a probabilistic polynomial-time prover with access to QNR language. Open Problem 4: Try to provide firm grounds for the heuristics of making proof systems noninteractive by use of "random public functions" (cf., <ref> [34, 63] </ref>): I advise not to try to define the latter notion (in a general form), but rather devise some ad-hoc method, using some specific but widely believed complexity assumptions (e.g., hardness of deciding Quadratic Residucity modulo a composite number), for this specific application.
Reference: [64] <author> M. Naor. </author> <title> Bit Commitment using Pseudorandom Generators. </title> <journal> Journal of Cryptology, </journal> <volume> Vol. 4, </volume> <pages> pages 151-158, </pages> <year> 1991. </year>
Reference-contexts: The most important result concerning zero-knowledge is that, assuming the existence of one-way functions, each language in N P (and actually even in IP) has a zero-knowledge interactive proof system; see <ref> [43, 64, 50] </ref> (and [19], respectively). <p> Most importantly, they showed how to construct zero-knowledge proof systems for any language in N P. 22 Their construction uses a cryptographic primitive called a commitment scheme that may be implemented using any one-way function <ref> [50, 64] </ref>. Actually, under the same assumption, zero-knowledge proofs exists for any language in IP [51, 19], but the latter elegant result has almost no applications. Subsequently, zero-knowledge proofs have become the focus of much attention in cryptographic circles and, as one may expect, many interesting results followed.
Reference: [65] <author> N. Nisan. </author> <title> Pseudorandom Generators for Space-Bounded Computation. </title> <journal> Combinatorica, </journal> <volume> Vol. 12, No. 4, </volume> <pages> pages 449-461, </pages> <year> 1992. </year> <note> Preliminary version in 22nd STOC, </note> <year> 1990. </year>
Reference-contexts: However, most of the complexity-theoretic impact of the former notion was on the theory of pseudorandomness (cf., for example, [24, 75] and <ref> [66, 65] </ref>) which has evolved almost concurrently to the evolution of interactive proof systems. The wide applicability of zero-knowledge proofs has been demonstrated by Goldreich, Micali and Wigderson [43].
Reference: [66] <author> N. Nisan and A. Wigderson. </author> <title> Hardness vs Randomness. </title> <journal> Journal of Computer and System Science, </journal> <volume> Vol. 49, No. 2, </volume> <pages> pages 149-167, </pages> <year> 1994. </year> <note> Preliminary version in 29th FOCS, </note> <year> 1988. </year>
Reference-contexts: However, most of the complexity-theoretic impact of the former notion was on the theory of pseudorandomness (cf., for example, [24, 75] and <ref> [66, 65] </ref>) which has evolved almost concurrently to the evolution of interactive proof systems. The wide applicability of zero-knowledge proofs has been demonstrated by Goldreich, Micali and Wigderson [43].
Reference: [67] <author> R. Ostrovsky and A. Wigderson. </author> <title> One-Way Functions are essential for Non-Trivial Zero-Knowledge, </title> <booktitle> In Proc. 2nd Israel Symp. on Theory of Computing and Systems (ISTCS93), </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pages 3-17, </pages> <year> 1993. </year>
Reference-contexts: zero-knowledge proof systems, namely, that such proof systems exist only for languages in IP (2) " coIP (2) [2, 35]. 4 Also, a recent result indicates that one-way functions are essential for the existence of zero-knowledge proofs for hard languages (i.e., languages that cannot be decided in average polynomial time) <ref> [67] </ref>.
Reference: [68] <author> C. H. Papadimitriou and M. Yannakakis. </author> <title> Optimization, Approximation, and Complexity Classes. </title> <journal> Journal of Computer and System Science, </journal> <volume> Vol. 43, </volume> <pages> pages 425-440, </pages> <year> 1991. </year> <note> Preliminary version in 20th STOC, </note> <year> 1988. </year>
Reference-contexts: Thus, given a satisfiable 3CNF formula, it is as hard to find a truth assignment that satisfies a fraction of its clauses as it is to find a truth assignment that satisfies all clauses. Consequently, for any approximation problem in the class MAX-SNP-complete (cf. <ref> [68] </ref> and [54]), there exists a constant so that approximating the problem up to this constant is NP-hard. <p> These facts were observed 17 by Arora, Lund, Motwani, Sudan and Szegedy [5]. They also observed that, since Max3SAT is in the class MAX-SNP <ref> [68] </ref>, it followed that each complete problem in that class (e.g., Max2SAT, MaxCUT, MinVC) is hard to approximate to within some constant factor. 21 The results of [32, 6, 5] have renewed interest in the complexity of approximation problems, after many years of frustration.
Reference: [69] <author> R. Raz. </author> <title> A Parallel Repetition Theorem. </title> <booktitle> In 27th ACM Symposium on the Theory of Computing, </booktitle> <pages> pages 447-456, </pages> <year> 1995. </year>
Reference-contexts: Furthermore, error reduction can be obtained at very moderate cost in the randomness complexity (cf. [15]). Parallel repetition is a much more complex matter (than in the context of interactive proof systems); see <ref> [69] </ref> (and do not get misled by an error in an early version of [36]). On the other hand, nonzero error probability is essential to the above results as otherwise one can eliminate randomness altogether and use PCP (0; q ()) DTIME (2 q poly).
Reference: [70] <author> R. Rubinfeld and M. Sudan. </author> <title> Robust Characterizations of Polynomials with Applications to Program Checking. </title> <journal> SIAM J. of Computing, </journal> <volume> Vol. 25, No. 2, </volume> <pages> pages 252-271, </pages> <year> 1996. </year> <note> Preliminary version in 3rd SODA, </note> <year> 1992. </year>
Reference-contexts: Motwani, Sudan and Szegedy [5] and is captured by the equation N P = PCP (log; O (1)): (4) In addition to building on the ideas of Arora and Safra [6], the above result of [5] utilizes ideas and techniques from the works on self-testing/self-correcting [25], degree-tests for multi-variant polynomials <ref> [40, 70] </ref>, and parallelization of multi-prover proof systems [56]. 16 3.1.6 Computationally Sound Proof Systems Argument systems were defined in 1986 by Brassard, Chaum and Crepeau [27], but their complexity-theoretic significance became apparent only in 1992.
Reference: [71] <author> A. Shamir. </author> <title> IP=PSPACE. </title> <journal> Journal of the ACM, </journal> <volume> Vol. 39, No. 4, </volume> <pages> pages 869-877, </pages> <year> 1992. </year> <note> Preliminary version in 31st FOCS, </note> <year> 1990. </year>
Reference-contexts: The main result concerning interactive proof systems is that they exist for any language recognizable in polynomial space. Namely, Theorem 1 <ref> [60, 71] </ref> IP = PSPACE. 2 Theorem 1, was established using algebraic methods. <p> the class IP (O (f ())) collapses to the class IP (f ()), and in particular IP (O (1)) collapses to IP (2) [10]. * The class IP (2) contains languages not known to be in N P, e.g., Graph Non-Isomorphism [43]. 2 See [60] for the general technique and <ref> [71] </ref> for its application yielding the quoted result. 3 * The class IP (2) is contained in N P=poly (i.e., nonuniform-NP), analogously to BPP P=poly. * If coN P IP (2) then the polynomial-time hierarchy collapses [26]. <p> The basic technique has been introduced by Lund, Fortnow, Karloff and Nisan, who applied it to show that the polynomial-time hierarchy (and actually P ]P ) is in IP [60]. Subsequently, Shamir used the technique to show that IP = P SP ACE <ref> [71] </ref>, and Babai, Fortnow and Lund used it to show that MIP = N EX P [9]. The technique of Lund, Fortnow, Karloff and Nisan has been inspired by ideas coming from works on "program checking" (cf., [23]). <p> Another idea that is implicit in [60] and made explicit in the subsequent works of <ref> [71, 9] </ref> is the representation, introduced by Beaver and Feigenbaum [11], of Boolean formulae as multi-linear polynomials. <p> L 2 N P) into transparent proofs that can be verified as vouching for the correctness of the encoded assertion in (probabilistic) polylogarithmic time (by a Random Access Machine). (The fact that the verification procedure never reads the entire "proof" should not come as a surprise, as the procedures of <ref> [60, 71, 9] </ref> also have this property.) Thus, once "statements" and "proofs" are in the right (error-correcting) form, verification is "super-fast." Babai et. al. [8] stress the practical aspects of transparent proofs specifically, for rapidly checking transcripts of long computations. 19 The term "scaled-down" is used here as a (standard) technical
Reference: [72] <author> M. Sudan. </author> <title> Efficient Checking of Polynomials and Proofs and the Hardness of Approximation Problems. </title> <publisher> ACM Distinguished Theses, Springer Verlag, LNCS Vol. </publisher> <address> 1001, </address> <year> 1995. </year>
Reference-contexts: For a proof of N P PCP (f (); f ()) with f (n) = O (log n log log n), see [32]. The proof of the quoted result is more complex and can be found in [6, 5] (see also <ref> [3, 72] </ref>). 8 Below we prove that Theorem 2 implies the rephrased form. The converse is proven by starting with an amplifying reduction of 3SAT to itself and constructing a pcp system for 3SAT as follows.
Reference: [73] <author> A. Ta-Shma. </author> <title> A Note on PCP vs. MIP. </title> <type> TR 94-12, </type> <institution> Institute of Computer Science, Hebrew University, Israel, </institution> <year> 1994. </year> <note> To appear in Information Processing Letters. </note>
Reference-contexts: The translation in the first direction is easy (i.e., just prefix each verifier-message by the identity of the prover), but the translation in the other direction is more complex; see <ref> [36, 73] </ref>. 2.2.4 PCP and Approximation Interestingly, Theorem 2 can be rephrased without mentioning the class P CP at all. 8 Instead, a new type of polynomial-time reduction, which we call amplifying, emerges. 7 The result N P PCP (poly log; poly log) can be found in [8], although this paper
Reference: [74] <author> B.A. Trakhtenbrot. </author> <title> A Survey of Russian Approaches to Perebor (Brute-Force Search) Algorithms. </title> <journal> Annals of the History of Computing, </journal> <volume> Vol. 6, No. 4, </volume> <pages> pages 384-400, </pages> <year> 1984. </year>
Reference-contexts: hardness results for approximation problems, program checking and zero-knowledge proofs. 3.1 The Evolution of Proof Systems The story of N P is well-known (except maybe for the fact that NP-completeness was discovered by Levin [58] independently of Cook [30] and Karp [52]; see Trakhtenbrot's survey of Russian research on NP <ref> [74] </ref>). Our story thus starts with the definition of interactive proof systems. 3.1.1 Interactive Proof Systems Motivated by the desire to formulate the most general type of "proofs" that may be used within cryptographic protocols, Goldwasser, Micali and Rackoff introduced the notion of an interactive proof system [48].
Reference: [75] <author> A.C. Yao. </author> <title> Theory and Application of Trapdoor Functions. </title> <booktitle> In 23rd IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 80-91, </pages> <year> 1982. </year> <month> 25 </month>
Reference-contexts: The notion of computational indistinguishability, introduced by Goldwasser and Micali (in the context of defining security of encryption schemes [47]) and Yao (in full generality <ref> [75] </ref>), is central to the definition of zero-knowledge. However, most of the complexity-theoretic impact of the former notion was on the theory of pseudorandomness (cf., for example, [24, 75] and [66, 65]) which has evolved almost concurrently to the evolution of interactive proof systems. <p> However, most of the complexity-theoretic impact of the former notion was on the theory of pseudorandomness (cf., for example, <ref> [24, 75] </ref> and [66, 65]) which has evolved almost concurrently to the evolution of interactive proof systems. The wide applicability of zero-knowledge proofs has been demonstrated by Goldreich, Micali and Wigderson [43].
References-found: 75

