URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-93-1161/CS-TR-93-1161.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-93-1161/
Root-URL: http://www.cs.wisc.edu
Title: ALGEBRAS FOR OBJECT-ORIENTED QUERY LANGUAGES  
Author: by SCOTT LEE VANDENBERG 
Degree: A thesis submitted in partial fulfillment of the requirements for the degree of Doctor of Philosophy (Computer Sciences) at the  
Date: 1993  
Affiliation: UNIVERSITY OF WISCONSIN-MADISON  
Abstract-found: 0
Intro-found: 1
Reference: [Abit88a] <author> S. Abiteboul and C. Beeri, </author> <title> "On the Power of Languages for the Manipulation of Complex Objects," </title> <type> Tech. Report No. 846, </type> <institution> INRIA, </institution> <month> May </month> <year> 1988. </year>
Reference-contexts: These features make algebraic specification desirable for a data model/retrieval language. In recent years it has become apparent that the relational model is not always the right choice for a particular application [Kent79, Care88a, Schw86], and many new data models have been proposed <ref> [Abit88b, Lecl87, Fish87, Maie86c, Bane87, Mano86, Roth88, Sche86, Kupe85, Abit88a] </ref>. <p> These models allow values in a relation to be either scalars (as in the relational model) or entire relations. The relational algebra was extended with two operators to reflect the new structuring capabilities. More recently, algebraic techniques have been applied to complex object data models <ref> [Abit88a] </ref>, which extend the NF models by removing the restriction that all data has to be either a relation or a scalar. <p> In addition, several "generic" algebras for non-relational systems have been proposed. These are not geared toward any particular system or implementation. (It should be mentioned that several calculi for objects with complex structure have been defined; some notable ones are found in <ref> [Banc86, Maie86a, Abit88a] </ref>.) In the following sections we describe the basic concepts and operations of these algebras, regardless of their connections with actual systems. <p> Indeed, several research efforts have rejected these operators in favor of more "basic" operations <ref> [Aris83, Abit88a] </ref>. Joins in the Vanderbilt algebra are defined as they are for the AIM algebra; i.e., they are identical to the relational natural join when scalar attributes are involved and are defined using the operator when relation-valued 24 attributes are being joined. <p> In most other algebras such copying is implicit. It was made explicit here to conform to the model's formal definition, which leaves database schemas and instances unchanged during query processing (it merely adds to what is already there). 2.3.4. A Complex Object Algebra In <ref> [Abit88a] </ref>, an algebra and calculus are developed for a model whose objects are sets of values constructed from the set and tuple type constructors in an arbitrary fashion; this is a pure complex object model. <p> It was also proved that adding arbitrary functions and predicates to both the algebra and calculus does not affect their equivalence <ref> [Abit88a] </ref>. The algebra can easily simulate the nest and unnest operators of the NF 2 algebras, although they are not primitives in the complex object algebra. 2.3.5. An Algebra for Office Forms In [Guti89] an algebra for structured office documents is presented. <p> Its effect can be simulated by unnesting then renesting in the NF 2 algebra, the difference being that ord erings are preserved with d. 37) Unpacking (m): This acts like an order-preserving version of the "set-collapse" operator of <ref> [Abit88a] </ref>. <p> These functions can be arbitrary methods, as in most 50 object-oriented models. There are also union, intersection, and difference operators, all based on object identity. The "flatten" operation is like the "set-collapse" operation of <ref> [Abit88a] </ref>: it turns a set of sets into a set. The NF 2 operators nest and unnest are also provided. An explicit duplicate elimination operator is available and there is an operator called "coalesce" to eliminate duplicates at a certain level of nesting within an object. <p> More work remains to be done in this area. In particular, the amenability of such monolithic operators as the VERSO "restruct" and the "replace" of <ref> [Abit88a] </ref> to standard algebraic optimization techniques needs to be investigated. That is, a small set of extremely powerful operators may allow too few alternatives for query processing. Conversely, a large set of extremely primitive operators may allow too many alternatives (in the sense that optimization may become too slow). <p> Conversely, a large set of extremely primitive operators may allow too many alternatives (in the sense that optimization may become too slow). There are several dimensions along which we can compare algebras in general: 1) Is the algebra set-oriented? This makes many proofs much easier (e.g. <ref> [Abit88a] </ref>) but may lead to less natural data representations. 2) What drove the design of the algebra? Most operators of VERSO [Abit86], for example, were designed as recursive filters for the VERSO virtual machine, while other were driven by the need to correspond to a calculus. 3) Which of its operators <p> object structure, which is not present in complex object models. 4) Which of its operators are second-order? A true second-order operator will allow its function parameter to be optimized in the same way as its data input is optimized, removing the need for special sublanguages for operators as required in <ref> [Abit88a] </ref>. 63 CHAPTER 3 SUMMARY OF MOTIVATIONS AND RELATED WORK This chapter discusses work that is more directly related to the remainder of the thesis. In Section 3.1 we describe other work that was relevant to the design of EXTRA and EXCESS. <p> Some of our multiset operators are similar to those of [Daya82], but [Daya82] restricts itself to the (value-based) relational model and includes the redundant intersection operator. The SET_APPLY looping operator described below was inspired by LISP's map-car function. It resembles other algebraic operators <ref> [Abit88a, Guti89, Daya87] </ref>, but is unique in that it allows the application of any algebraic expression to the elements of the multiset and needs no special syntax to apply the expression (as is needed with the r operator of [Abit88a], e.g.). <p> It resembles other algebraic operators [Abit88a, Guti89, Daya87], but is unique in that it allows the application of any algebraic expression to the elements of the multiset and needs no special syntax to apply the expression (as is needed with the r operator of <ref> [Abit88a] </ref>, e.g.). Several of the array operators and all of the array transformation rules are new. There is an array looping operator similar to SET_APPLY. The ARR_EXTRACT operator extracts a single element from an array, and the result is not an array containing the element but simply the element itself. <p> This model is an extension of the relational model which allows both scalar- and relation-valued attributes. Algebras for integrating set-valued fields [Ozso87] and aggregates [Ozso87, Klug82] into the relational model have also been designed. All of these algebras are direct extensions of the relational algebra. Complex object models <ref> [Abit88a, Hull87] </ref> generalize nested relations by removing the restriction that every entity must be a set of tuples containing either scalars or other sets of tuples as attribute values, recursively. A "complex object" can use the set and tuple type constructors arbitrarily. <p> Example: Let A = [ 1 2 3 5 ]. Then SET (A) = - [ 1 2 3 5 ] -. 7) Destroy a Set (SET_COLLAPSE): The SET_COLLAPSE operator takes a multiset of multisets and returns the + of all the member multisets. A similar operator appears in <ref> [Abit88a] </ref>. Example: Let A = - 1, 2, 3 -, - 2, 3, 3 - -. <p> That is, a predicate is an operation (called COMP) which returns its (unmodified) input exactly when the predicate is satisfied (true). Otherwise a null value is returned. COMP is a partial function. (Similar approaches are taken in <ref> [Osbo88, Abit88a] </ref>.) Comparisons (COMP): This operator takes a single structure as input and compares it to an arbitrary algebraic predicate using one of a fixed set of comparators. <p> The result is a multiset of 1-tuples obtained by projecting the "name" attribute. 5.4. Algebraic Expressiveness The EXCESS algebra was designed to implement the EXCESS query language, not to reflect a database-style calculus such as those of <ref> [Banc86, Abit88a] </ref>. Thus the interesting question of expressive equivalence for this algebra is not whether it can express exactly the queries of some formal calculus but whether it can express exactly the queries of EXCESS. <p> The complete proof (presented in Appendix B) describes the details of how primary components are used to ensure the semantics 116 of EXCESS queries. ii) Reduction of algebra to EXCESS: The other direction of the proof is a traditional case-based inductive proof like those found in <ref> [Ullm89, Abit88a, Roth88] </ref>. We omit most of the cases of the inductive step as our goal here is simply to give a flavor of the proof and to demonstrate that the proof is straightforward, due mainly to the simplicity of the algebraic operators and their resemblance to constructs in EXCESS.
Reference: [Abit86] <author> S. Abiteboul and N. Bidoit, </author> <title> "Non First Normal Form Relations: An Algebra Allowing Data Restructuring," </title> <journal> J. Computer and System Sciences 33, </journal> <year> 1986. </year>
Reference-contexts: In the first query, the || e operator could have been used in place of the s- combination; in this case the result would have been the same since the join attributes are scalar. 2.2.5. The VERSO Algebra VERSO is a relational database machine developed at INRIA <ref> [Abit86] </ref>. The intention of the design was that all of the algebraic operations were to be performed by a filter, with the exception of the restructuring operation (see below). Not surprisingly, the VERSO algebra is defined to operate on nested relations. Like SQL/NF, however, it imposes the important PNF restriction. <p> This operation is not recur sive, although <ref> [Abit86] </ref> mentions that a recursive version could easily be defined. 5) Renaming (rename): This operator allows one to give new names to any part of a VERSO format. 6) Union (): This is exactly the same as the SQL/NF e operator. <p> purposes, it is enough to realize that it subsumes the functionality of the nest and unnest operators and that it can be used for essentially arbitrary restructuring, as long as the result format makes sense relative to the original format (where "makes sense" is given a precise formal meaning in <ref> [Abit86] </ref>). An example of a VERSO format specification is: title author (publ_name num_pgs date) * This is our Book schema as defined earlier. The VERSO algebra does not provide for null values. <p> There are several dimensions along which we can compare algebras in general: 1) Is the algebra set-oriented? This makes many proofs much easier (e.g. [Abit88a]) but may lead to less natural data representations. 2) What drove the design of the algebra? Most operators of VERSO <ref> [Abit86] </ref>, for example, were designed as recursive filters for the VERSO virtual machine, while other were driven by the need to correspond to a calculus. 3) Which of its operators are recursive? For example, the NF 2 algebra of [Colb89] has 5 recursive operators, but other NF 2 alge 62 bras <p> The relational algebra was followed by algebras for nested (non-first normal form) relations <ref> [Abit86, Roth88, Sche86, Aris83, Colb89, Desh87, Fisc83, Jaes82b] </ref>. This model is an extension of the relational model which allows both scalar- and relation-valued attributes. Algebras for integrating set-valued fields [Ozso87] and aggregates [Ozso87, Klug82] into the relational model have also been designed.
Reference: [Abit88b] <author> S. Abiteboul and R. Hull, </author> <title> "Update Propagation in a Formal Semantic Model," </title> <journal> IEEE Data Eng. Bulletin 11(2), </journal> <month> June </month> <year> 1988. </year>
Reference-contexts: These features make algebraic specification desirable for a data model/retrieval language. In recent years it has become apparent that the relational model is not always the right choice for a particular application [Kent79, Care88a, Schw86], and many new data models have been proposed <ref> [Abit88b, Lecl87, Fish87, Maie86c, Bane87, Mano86, Roth88, Sche86, Kupe85, Abit88a] </ref>. <p> A similar algebra is defined for the 56 EXTREM data model [Scho87b]; the operations differ only in some details. EXTREM is a semantic data model implemented on top of a flat relational system and using some of the constructs of the IFO semantic data model <ref> [Abit88b] </ref>. Chen [Chen84] also proposed an algebra for the E/R model. This algebra operates on data which is restricted to allow only binary directional relationships. The operators provided for this model are as follows: Select, union, difference, and intersection can be applied to sets of values or to entity sets.
Reference: [Abit89] <author> S. Abiteboul and P. Kanellakis, </author> <title> "Object Identity as a Query Language Primitive", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Portland, Oregon, </address> <month> June, </month> <year> 1989. </year>
Reference-contexts: This treatment also enables the algebra to be defined using only one form of equality, instead of one form for OIDs and one for values, as is done in [Shaw90, Osbo88]. <ref> [Abit89] </ref> defines two separate languages, one enforcing object identity and one not supporting it at all, but we mix the two semantics in a single algebraic language, and we give references the status of a type constructor with the same privileges as the multiset, array, and tuple constructors. <p> The ALGRES algebra [Ceri87] is similar but it also supports a least fixpoint operation and unordered relations. Object identity was added to complex structures in the LDM algebra [Kupe85] and in IQL <ref> [Abit89] </ref>. Finally, the algebraic approach has also been extended to cover temporal databases [Tans89, Clif85]. Algebraic transformation rules for the relational algebra can be found in [Ullm89]. [Scho86] presents such rules for the nested relational model. <p> EXCESS [Vand91]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. Smalltalk and ORION [Gold83, Bane87]) choose to support only objects in the type system and to model values as a special case of objects. IQL <ref> [Abit89] </ref> defines two separate languages, one enforcing object identity and one not supporting it at all.
Reference: [Abit90] <author> S. Abiteboul, E. Simon, and V. Vianu, </author> <title> "Non-deterministic languages to express deterministic transformations", </title> <booktitle> Proc. ACM PODS Conf.fR, </booktitle> <address> Nashville, TN, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: AQUA's dup_elim can be thought of as a generalization of other duplicate elimination operators (e.g. that of ENCORE/EQUAL [Shaw90]). A set-theoretic choose operator appears in the algebras of Osborne and MDM [Osbo88, Rich92]. Non-determinism is also present in <ref> [Abit90] </ref>, which describes a witness operator which operates in a logical (rather than an algebraic) setting and creates a set of possible interpretations of a formula, resulting in non-determinism. Most ``pure'' object-oriented models (such as [Gold83, Maie86c] and others) provide and enforce encapsulation of data types.
Reference: [Agra87] <author> R. Agrawal, </author> <title> "Alpha: An Extension of Relational Algebra to Express a Class of Recursive Queries", </title> <booktitle> Proc. IEEE Intl. Conf. on Data Engineering, </booktitle> <address> Los Angeles, CA, </address> <year> 1987. </year>
Reference-contexts: Whether or not a relational algebra with a powerset operator would be equivalent to this algebra is an interesting question (recall that this equivalence holds for the NF 2 algebra). The ALPHA algebra <ref> [Agra87] </ref> also extends the traditional relational algebra to support recursion, but in this case it is extended with Klug's support for aggregates [Klug82] and one more operator, known as a.
Reference: [Aho79] <author> A. Aho and J. Ullman, </author> <title> "Universality of Data Retrieval Languages", </title> <booktitle> Proc. ACM Conf. on Principles of Programming Languages, </booktitle> <address> San Antonio, Texax, </address> <year> 1979. </year>
Reference-contexts: The operations include the standard set functions, user-defined ADT or FAD operations, a filter operation which applies a function to all elements of a cross-product of sets, a grouping operation, and a pump operation designed to facilitate parallelization of aggregate computations. A least fixpoint (LFP) operator is defined in <ref> [Aho79] </ref> and some algebraic transformations using it are also given. Whether or not a relational algebra with a powerset operator would be equivalent to this algebra is an interesting question (recall that this equivalence holds for the NF 2 algebra).
Reference: [Alba91] <author> A. Albano, G. Ghelli, and R. Orsini, </author> <title> "Objects for a Database Programming Language", in Bulk Types & Persistent Data: </title> <booktitle> The Third International Workshop on Database Programming Languages, </booktitle> <editor> ed. P. Kanellakis and J. Schmidt, Nafplion, </editor> <address> Greece, </address> <publisher> Morgan Kaufmann, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: The use of a type constructor to represent abstraction enables all objects in an AQUA database to exist in one seamless type system. Our approach is similar to that of <ref> [Alba91] </ref>, but in that model not everything is an object, so their equivalent to our abstraction constructor must enforce many more of the facets of ``objectness'' than must ours. 69 Another goal of AQUA is to provide algebraic support for ordered data types such as lists, trees, and graphs.
Reference: [Andr87] <author> T. Andrews and C. Harris, </author> <title> "Combining Language and Database Advances in an Object-Oriented Development Environment," </title> <booktitle> Proc. 2nd OOPSLA Conf., </booktitle> <address> Orlando, FL, </address> <year> 1987. </year>
Reference-contexts: While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Banc88, Lecl87, Horn87, Andr87, Bane87, Maie86c] </ref>, and several flavors of object-oriented models have been identified [Ditt86]. <p> As we will see in the next section, despite their semantic differences, own, ref, and own ref attributes are all treated uniformly in the EXCESS query language for query simplicity. Thus, casual users can ignore the distinction, viewing attributes simply as other objects, as in most object-oriented data models <ref> [Lecl87, Horn87, Andr87, Bane87, Maie86c] </ref>. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 Note: All objects must have a "home" as an own ref component of some other object in order to exist in the database. Named, persistent, top-level objects are automatically made own ref components of the database in which they are created.
Reference: [Aris83] <author> H. Arisawa, K. Moriya, and T. Miura, </author> <title> "Operations and the Properties on Non-First-Normal-Form Relational Databases," </title> <booktitle> Proc. VLDB Conf., </booktitle> <address> Florence, Italy, </address> <month> October, </month> <year> 1983. </year>
Reference-contexts: Indeed, several research efforts have rejected these operators in favor of more "basic" operations <ref> [Aris83, Abit88a] </ref>. Joins in the Vanderbilt algebra are defined as they are for the AIM algebra; i.e., they are identical to the relational natural join when scalar attributes are involved and are defined using the operator when relation-valued 24 attributes are being joined. <p> The algebra for their "B-Relational" data model includes the standard NF 2 extensions as found in the DASDBS and AIM algebras as well as support for semantic concepts such as generalization and association. In <ref> [Aris83] </ref>, Arisawa et al develop update algorithms for nested relations, but along the way define some very primitive operations on tuples (primitive in the sense that they may be used to define more complex operations such as nest and unnest as well as to describe subtler changes to a relation). <p> This value is removed from the proper attribute of the original tuple. In addition, <ref> [Aris83] </ref> defines a canonical form for nested relations, which is the nesting of a 1NF relation along each of its attributes in any order. Only one level of nesting is considered. In [Tans89] an algebra is described which extends the NF 2 algebra to handle time-varying data. <p> The relational algebra was followed by algebras for nested (non-first normal form) relations <ref> [Abit86, Roth88, Sche86, Aris83, Colb89, Desh87, Fisc83, Jaes82b] </ref>. This model is an extension of the relational model which allows both scalar- and relation-valued attributes. Algebras for integrating set-valued fields [Ozso87] and aggregates [Ozso87, Klug82] into the relational model have also been designed.
Reference: [Astr76] <author> M. Astrahan, M. Blasgen, D. Chamberlin, K. Eswaran, J. Gray, P. Griffiths, W. King, R. Lorie, P. McJones, J. Mehl, G. Putzolu, I. Traiger, B. Wade, and V. Watson, </author> <title> "System R: A Relational Approach to Database Management", </title> <journal> ACM TODS 1(2), </journal> <month> June </month> <year> 1976. </year>
Reference-contexts: This mimics the SQL notion of nested queries <ref> [Astr76] </ref>. 8) Keying (c): This operator is introduced to eliminate the problem of non-invertible unnestings (see previous section). c appends a key column to a relation before it is unnested then renested, and this ensures that nesting after an unnest will result in the original NF 2 relation [Jaes85a].
Reference: [Atki91] <author> M. Atkinson, C. Lecluse, P. Philbrow, and P. Richard, </author> <title> "Design Issues in a Map Language", in Bulk Types & Persistent Data: </title> <booktitle> The Third International Workshop on Database Programming Languages, </booktitle> <editor> ed. P. Kanellakis and J. Schmidt, Nafplion, </editor> <address> Greece, </address> <publisher> Morgan Kaufmann, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: Unlike ILOG [Hull90] and others, we avoid explicit identifiers in the model, viewing them as an implementation concern, and reflecting the distinctions between objects and values by using varying semantics. 68 It has been pointed out by Atkinson et al <ref> [Atki91] </ref> that in object-oriented systems, a type may supply its own method for testing equality. This capability, however, introduces problems such as what the meaning is of operators like set union that depend on equality for their own semantics. <p> Thus two distinct Person objects may actually have the same social security number, but for the user's purposes they should be treated as being the same person. The utility of such an ability has also been pointed out in <ref> [Atki91] </ref>. As other examples of the usefulness of type-specific equalities, we can of course point to shallow and deep equality. There are other less obvious applications, however.
Reference: [Banc88] <author> F. Bancilhon, G. Barbedette, V. Benzaken, C. Delobel, S. Gamerman, C. Lecluse, P. Pfeffer, P. Richard, and F. Velez, </author> <title> "The Design and Implementation of O 2 an Object-Oriented Database System," </title> <type> Tech. Report 20-88, </type> <institution> Altair, </institution> <month> April </month> <year> 1988. </year>
Reference-contexts: While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Banc88, Lecl87, Horn87, Andr87, Bane87, Maie86c] </ref>, and several flavors of object-oriented models have been identified [Ditt86]. <p> to subsume much of the 3 modeling and querying functionality of object-oriented and other advanced systems. 1 The result is a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models [Dada86, Sche86], DAPLEX [Ship81], ORION [Bane87], Trellis/Owl [Scha86], O 2 <ref> [Banc88] </ref>, STDM [Cope84], and STDM's descendant, GemStone [Maie86c]. <p> Neither GemStone nor Orion have support for own attributes (except perhaps in implementing their small atomic types). And while GEM had both own and ref attributes, its type system was less rich and sets of references were not permitted. Since the original development of EXTRA/EXCESS, O 2 <ref> [Banc88] </ref> has adopted own and ref attributes. The EXCESS query language is related to those of DAPLEX [Ship81], GEM [Zani83], NF 2 systems [Dada86, Sche86], and POSTGRES [Rowe87]. Implicit joins were taken directly from GEM, and originated in DAPLEX. <p> Our handling of range variables was heavily influenced by that of POSTGRES [Rowe87]. In addition, EXCESS 64 goes beyond its predecessors in several respects. Our mix of object- and value-oriented semantics, again, was unique among query languages, until the introduction of certain constructs to the O 2 <ref> [Banc88] </ref> query language. Also, EXCESS provides a cleaner treatment of arrays than we have seen elsewhere. The only point for comparison here is POSTQUEL, which only operates on one-dimensional arrays of base types.
Reference: [Banc87] <author> F. Bancilhon, T. Briggs, S. Khoshafian, and P. Valduriez, </author> <title> "FAD, a Powerful and Simple Database Language," </title> <booktitle> Proc. VLDB Conf., </booktitle> <address> Brighton, England, </address> <year> 1987. </year>
Reference-contexts: Cartesian product may be applied to value sets only. There are also operators to compose, decompose, invert, and create relationships. The last operation has the Cartesian product of two entity sets as a special case. An algebra has also been developed for FAD <ref> [Banc87] </ref>, but in FAD (as in IRIS [Fish87]) the real optimization work is performed by a relational optimizer -- FAD expressions are first translated to flat relational algebra. FAD was used as a backend for the LDL system developed at MCC [Tsur86].
Reference: [Banc86] <author> F. Bancilhon and S. Khoshafian, </author> <title> "A Calculus for Complex Objects," </title> <booktitle> Proc. ACM PODS Conf., </booktitle> <address> Cam-bridge, MA, </address> <month> March </month> <year> 1986. </year>
Reference-contexts: In addition, several "generic" algebras for non-relational systems have been proposed. These are not geared toward any particular system or implementation. (It should be mentioned that several calculi for objects with complex structure have been defined; some notable ones are found in <ref> [Banc86, Maie86a, Abit88a] </ref>.) In the following sections we describe the basic concepts and operations of these algebras, regardless of their connections with actual systems. <p> The is operator is useful for comparing references, returning true if two references refer to the same 84 object. Thus, is is a test for object equality rather than (recursive) value equality in the sense of <ref> [Banc86] </ref>. An isnot operator is also provided for convenience in testing that two references do not refer to the same object. As in GEM, these are the only comparison operators applicable to references. <p> The result is a multiset of 1-tuples obtained by projecting the "name" attribute. 5.4. Algebraic Expressiveness The EXCESS algebra was designed to implement the EXCESS query language, not to reflect a database-style calculus such as those of <ref> [Banc86, Abit88a] </ref>. Thus the interesting question of expressive equivalence for this algebra is not whether it can express exactly the queries of some formal calculus but whether it can express exactly the queries of EXCESS.
Reference: [Bane87] <author> J. Banerjee, H.-T. Chou, J. Garza, W. Kim, D. Woelk, N. Ballou, and H.-J. Kim, </author> <title> "Data Model Issues for Object-Oriented Applications," </title> <journal> ACM Trans. Office Info. Sys. </journal> <volume> 5(1), </volume> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: These features make algebraic specification desirable for a data model/retrieval language. In recent years it has become apparent that the relational model is not always the right choice for a particular application [Kent79, Care88a, Schw86], and many new data models have been proposed <ref> [Abit88b, Lecl87, Fish87, Maie86c, Bane87, Mano86, Roth88, Sche86, Kupe85, Abit88a] </ref>. <p> While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Banc88, Lecl87, Horn87, Andr87, Bane87, Maie86c] </ref>, and several flavors of object-oriented models have been identified [Ditt86]. <p> query language, which are intended to subsume much of the 3 modeling and querying functionality of object-oriented and other advanced systems. 1 The result is a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models [Dada86, Sche86], DAPLEX [Ship81], ORION <ref> [Bane87] </ref>, Trellis/Owl [Scha86], O 2 [Banc88], STDM [Cope84], and STDM's descendant, GemStone [Maie86c]. <p> EXTRA's ref notion was based on GEM reference attributes [Zani83], and own ref is closely related to weak entities in the E-R model [Chen76] and composite objects in ORION <ref> [Bane87] </ref>. EXTRA also goes beyond these systems in certain ways, however. In particular, EXTRA's mix of own, ref, and own ref attributes yields a relatively unique mix of (structural) object- and value-orientation. Neither GemStone nor Orion have support for own attributes (except perhaps in implementing their small atomic types). <p> In attempting to support both values and objects, some systems (e.g. EXCESS [Vand91]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. Smalltalk and ORION <ref> [Gold83, Bane87] </ref>) choose to support only objects in the type system and to model values as a special case of objects. IQL [Abit89] defines two separate languages, one enforcing object identity and one not supporting it at all. <p> Figure 4.3 shows how this conflict can be resolved via renaming. POSTGRES would ignore this conflict because the conflicting dept attributes are of the same data type [Rowe87], while TAXIS would simply disallow the conflict [Nixo87]. EXTRA is closest to ORION <ref> [Bane87] </ref> in its handling of conflicts, except that we provide no automatic resolution. <p> Sets of base types, constructed types, and reference types are all possible in EXTRA. This leads to a very powerful facility for modeling complex objects, as nested relations (ala NF 2 data models) can be supported via sets of tuples, and sets with shared subobjects (ala <ref> [Bane87, Lecl87] </ref>) can be supported via sets of references. As an example, Figure 4.5 shows the definition for the Department type and the creation of a persistent set (Departments) of objects of this type. <p> As we will see in the next section, despite their semantic differences, own, ref, and own ref attributes are all treated uniformly in the EXCESS query language for query simplicity. Thus, casual users can ignore the distinction, viewing attributes simply as other objects, as in most object-oriented data models <ref> [Lecl87, Horn87, Andr87, Bane87, Maie86c] </ref>. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 Note: All objects must have a "home" as an own ref component of some other object in order to exist in the database. Named, persistent, top-level objects are automatically made own ref components of the database in which they are created. <p> EXTRA separates the notions of type and instance; thus, users can collect related objects together in semantically meaningful sets and arrays, which can then be queried, rather than having to settle for queries over type extents as in many data models (e.g., <ref> [Ship81, Bane87, Lecl87, Mylo80, Rowe87] </ref>). EXTRA provides tuple, set, fixed-length array, and variable-length array as type constructors. In addition, there are three kinds of values, own, ref, and own ref (although casual users such as query writers need not be concerned with this distinction). <p> This is substitutability, the usual semantics for single or multiple inheritance (see e.g. <ref> [Bane87] </ref>). However, the domains of multisets, arrays, and tuples are actually constructed using the domains of their components, while the domain of a "ref" node is simply a set of OIDs with no relationship to the structure of the component objects.
Reference: [Bato87] <author> D. Batory, </author> <title> "Principles of Database Management System Extensibility," </title> <journal> IEEE Database Eng. Bulletin 10, </journal> <month> June </month> <year> 1987. </year>
Reference-contexts: One approach to dealing with complex objects (also known as "structural object-orientation" [Ditt86]) is to provide procedures as a data type [Ston87a]. Another approach is to permit relation-valued attributes [Dada86, Sche86]. A third approach is to take a functional view of data <ref> [Ship81, Mano86, Bato87] </ref>. In addition, a common theme among many of these efforts is to extend the database system's data definition facilities with support for some form of sub-typing.
Reference: [Beer90] <author> C. Beeri and Y. Kornatzky, </author> <title> "Algebraic Optimization of Object-Oriented Query Languages", </title> <booktitle> Proc. Intl. Conf. Database Theory, </booktitle> <address> Paris, France, </address> <month> December </month> <year> 1990. </year>
Reference-contexts: Algebraic transformation rules for the relational algebra can be found in [Ullm89]. [Scho86] presents such rules for the nested relational model. Some rules for complex object models with identity are proposed in [Osbo88, Shaw90]; these rules are mainly straightforward extensions of relational or nested relational transformation rules. 67 Finally, <ref> [Beer90] </ref> proposes a meta-level algebra for collections of complex objects with identity and includes some transformation rules that go beyond what is done in the relational model. This algebra, however, does not correspond to a specific data model but rather to a higher-level notion of collections of objects. <p> For an introduction to AQUA's support for other ordered data types, see [Subr93]. Much of the previous work with ordering deals with order as in sequences or arrays; very little work has been done on trees or graphs. <ref> [Beer90] </ref> proposes an object-oriented query processing paradigm where the objects are built of primitive objects, an explicit object identity type constructor, and bulk type constructors. Then operations and optimizations are presented which apply to any bulk type constructor definable in their paradigm. <p> In this approach, lists, arrays, and trees can all be defined, and a subset of the useful operations on such structures is described in the paper. These operations include a ``pump'' function, which is similar to AQUA's fold operation [Leun93]. Since the operations described in <ref> [Beer90] </ref> are intended to be applicable to any bulk type, not just to lists and trees, they are too general for our purposes -- we wish to distinguish between ordered and unordered types, and we provide a richer set of operations. <p> Furthermore, many of their operations are not described precisely, the existence of certain other operations is assumed, and they do not have any operations like the ones we propose. [Ross92] extends <ref> [Beer90] </ref> by providing precise conversion operations between various bulk types and transformation rules involving the pump and aggregation operators on trees. We develop a notation for expressing patterns in trees based on results presented in [That68, Done70]. 3.2.3. <p> First, it is capable of simulating most of the algebras mentioned in Chapter 2 as long as these algebras do not contain the powerset operator (with the obvious exception of <ref> [Beer90] </ref>, which is really a "higher-level" algebra). <p> This also allows for transformations that involve nodes in the stored query tree interacting with nodes in the invoking query tree; some examples of this can be found in <ref> [Beer90] </ref>. Thus we want to be able to optimize the algebraic query tree for the method while taking such query-specific information into account. This strategy encounters difficulties when method definitions are allowed to be overridden by subtypes, as is allowed in EXTRA. <p> These transformations capture those of the relational and multiset algebras from the literature [Ullm82, Ullm89, Kort91, Knut81] as well as most transformations described for more advanced data models <ref> [Beer90, Scho86] </ref>. We do not claim that this list is complete, but we believe that it is either complete or very close to complete. The rules are presented without proof. In most cases the proof is a straightforward application of the operator definitions. A.1.
Reference: [Bloo87] <author> Bloom, T., and Zdonik, S., </author> <booktitle> "Issues in the Design of Object-Oriented Database Programming Languages," Proc. 2nd OOPSLA Conf., </booktitle> <address> Orlando, FL, </address> <year> 1987. </year>
Reference-contexts: In fact, the former kind of object-oriented DBMS almost seems like a step back to the days of navigational data manipulation languages, as it is not obvious how one will support ad-hoc queries (or optimize accesses effectively) for such systems <ref> [Bloo87, Ullm87] </ref>. This thesis will address these issues, among others. Another direction in data model evolution, one which has spawned such efforts as [Codd79, Dada86, Sche86, Schw86, Rowe87], is to extend the relational model in some way. <p> This makes it possible for a database to include more than one collection of instances of a given type, which can be quite useful in scientific and engineering applications [Lohm83, Kemp87]. While this separation is common in programming languages, it is less common in the database world <ref> [Bloo87] </ref>. As an example, the commands in Figure 4.1 define a new schema type called Person, which is a tuple type.
Reference: [Bune91] <author> P. Buneman and A. Ohori, </author> <title> "A Type System that Reconciles Classes and Extents", in Bulk Types & Persistent Data: </title> <booktitle> The Third International Workshop on Database Programming Languages, </booktitle> <editor> ed. P. Kanellakis and J. </editor> <address> 189 Schmidt, Nafplion, Greece, </address> <publisher> Morgan Kaufmann, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: We are not aware of another model that takes this approach, nor of one that takes the clearly-separated, 3-level view of an object that we do (type, semantics, and implementation). Buneman and Ohori exhibit a similar philosophy, though, in their distinction between a kind and a type <ref> [Bune91] </ref>.
Reference: [Care88a] <author> M. Carey, D. DeWitt, G. Graefe, D. Haight, J. Richardson, D. Schuh, E. Shekita, and S. Vandenberg, </author> <title> "The EXODUS Extensible DBMS Project: An Overview", in Readings in Object-Oriented Database Systems, </title> <editor> ed. S. Zdonik and D. Maier, </editor> <publisher> Morgan Kaufmann, </publisher> <address> San Mateo, CA, </address> <year> 1990. </year>
Reference-contexts: These features make algebraic specification desirable for a data model/retrieval language. In recent years it has become apparent that the relational model is not always the right choice for a particular application <ref> [Kent79, Care88a, Schw86] </ref>, and many new data models have been proposed [Abit88b, Lecl87, Fish87, Maie86c, Bane87, Mano86, Roth88, Sche86, Kupe85, Abit88a]. <p> In addition, a common theme among many of these efforts is to extend the database system's data definition facilities with support for some form of sub-typing. The EXTRA/EXCESS system was designed partially to test the viability of the EXODUS extensible DBMS toolkit <ref> [Care88a] </ref>, and partially to provide a platform for research into advanced data models. <p> Notice that if the DEREF in this query were instead a more complicated subquery, the advantage of this particular optimization would be even greater. 5.7. Comments on a Partial Implementation EXTRA/EXCESS was partially implemented using the EXODUS extensible DBMS toolkit <ref> [Care88a] </ref> at the University of Wisconsin-Madison. A complete parser and implementation methods for some of the algebraic operators were implemented, as was a partially functional DML processor. For the purposes of this thesis, we are most interested in the query processing component.
Reference: [Care88b] <author> M. Carey, D. DeWitt, and S. Vandenberg, </author> <title> "A Data Model and Query Language for EXODUS," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Chicago, Illinois, </address> <year> 1988. </year>
Reference-contexts: LauRel is based on the nested relational model and presumably will make use of the Waterloo algebra. Planned extensions to the algebra include support for aggregate computations. The LauRel system also supports references to objects, much as in <ref> [Care88b] </ref>. The user-level language of this system, called SQL/W, is designed to support null values (the original Waterloo algebra as described here is not). The LauRel system is still in the design phase. <p> This is similar to POSTGRES's notion of user-defined POSTQUEL functions and the functions and procedures of EXCESS <ref> [Care88b] </ref>, but in those systems, the ability to define functions allows one to add operations to an existing, non-encapsulated type (i.e., encapsulation is not enforced in those systems but it is in AQUA). <p> Every type is essentially an abstract data type -- however, the base types and all types built using the usual type constructors have a fixed set of standard operations available on them (e.g. join and union for sets). As mentioned in <ref> [Care88b] </ref> and [Rowe87], it is often desirable to be able to add other methods to such types. In addition, it is frequently desirable 131 to specify a type whose representation is completely unknown to the data model of the DBMS.
Reference: [Ceri87] <author> S. Ceri, S. Crespi-Reghizzi, L. Lavazza, and R. Zicari, "ALGRES: </author> <title> A System for the Specification and Prototyping of Complex Databases," </title> <type> Tech. Report 87-018, </type> <institution> Dipartimento di Elettronica, Politecnico di Milano, </institution> <year> 1987. </year>
Reference-contexts: Links between atoms are preserved (to the extent possible) during query processing. The algebra is an extension to the relational algebra, with the same operators but each extended to operate on molecules. The ALGRES system <ref> [Ceri87] </ref> is intended to be used for rapid specification and prototyping of complex database systems. It supports the NF 2 model with several additions: tuple-valued attributes, a closure operator to enable least fixpoint computations, aggregates, and an embedding in a computationally complete logic programming 58 language. <p> We provide original operators for additive union, grouping, set creation, and looping, as well as other operators that have appeared elsewhere. The transformation rules involving these new operators are new, as are most of the other multiset transformations we provide. ENCORE/EQUAL [Shaw90] and ALGRES <ref> [Ceri87] </ref> provide both sets and multisets, but the semantics of their multiset operations are not specified. Some of our multiset operators are similar to those of [Daya82], but [Daya82] restricts itself to the (value-based) relational model and includes the redundant intersection operator. <p> A "complex object" can use the set and tuple type constructors arbitrarily. An algebra that operates on ordered nested relations (plus tuple-valued attributes and ordered sets of scalars) was proposed in [Guti89]. The ALGRES algebra <ref> [Ceri87] </ref> is similar but it also supports a least fixpoint operation and unordered relations. Object identity was added to complex structures in the LDM algebra [Kupe85] and in IQL [Abit89]. Finally, the algebraic approach has also been extended to cover temporal databases [Tans89, Clif85].
Reference: [Cham75] <author> D. Chamberlin, J. Gray, and I. Traiger, </author> <title> "Views, Authorization, and Locking in a Relational Database System," </title> <booktitle> Proc. Nat'l. Computer Conf., </booktitle> <address> Anaheim, CA, </address> <year> 1975. </year>
Reference-contexts: This is similar to the distinction between virtual member functions and regular member functions in C++ [Stro86]. 95 4.3.2.3. Achieving Data Abstraction We provide an authorization mechanism along the lines of the System R <ref> [Cham75] </ref> and IDM [IDM500] protection systems; this mechanism is described in [Vand88a, Vand88b]. Both individual users and user groups (including a special "all-users" group) will be recognized, and protection units will be specified via EXCESS queries.
Reference: [Chan88] <author> A. Chandra, </author> <title> "Theory of Database Queries", </title> <booktitle> Proc. ACM PODS Conf., </booktitle> <year> 1988. </year>
Reference-contexts: As the discussion moves beyond NF 2 models and systems, the implementation status and examples will largely be omitted. We will not discuss the relative power of the underlying data models, exhaustive sets of algebraic equivalence rules, or other theoretical language issues. Many of these issues are covered in <ref> [Pare88, VanG87, VanG86, Hull87, Hull89a, Chan88] </ref>. The purpose of this survey is to convey some idea of the general nature of database algebras in 9 the hope of gaining some insight into why certain operations exist and of identifying common themes among these algebras. <p> Furthermore, we do not address here the issues of computable queries and complexity classes, as is discussed in <ref> [Chan88] </ref>. It is, of course, crucial that any EXCESS query be expressible in the algebra. This direction of the proof is constructive, and thus it also provides a complete semantics for the EXCESS query language.
Reference: [Chen76] <author> P. Chen, </author> <title> "The Entity-Relationship Model Toward a Unified View of Data," </title> <journal> ACM TODS 1(1), </journal> <month> March </month> <year> 1976. </year>
Reference-contexts: An interesting algebra for the relational model with duplicates appears in [Daya82]. This algebra redefines the set-theoretic operations to be the corresponding multiset-theoretic operations and adds a duplicate elimination operator. It also includes the (redundant) multiset intersection operator. In [Pare85] an algebra for Entity-Relationship <ref> [Chen76] </ref> databases is presented. Its operations include a relationship join (similar to an outer join) to build results based on stored relationships, Cartesian product (defined as in the VERSO algebra), selection, duplicate elimination, renaming, union, intersection, and difference. <p> EXTRA's ref notion was based on GEM reference attributes [Zani83], and own ref is closely related to weak entities in the E-R model <ref> [Chen76] </ref> and composite objects in ORION [Bane87]. EXTRA also goes beyond these systems in certain ways, however. In particular, EXTRA's mix of own, ref, and own ref attributes yields a relatively unique mix of (structural) object- and value-orientation.
Reference: [Chen84] <author> P. Chen, </author> <title> "An Algebra for a Directional Binary Entity-Relationship Model", </title> <booktitle> Proc. IEEE Intl. Conf. on Data Engineering, </booktitle> <address> Los Angeles, CA, </address> <month> April </month> <year> 1984. </year>
Reference-contexts: A similar algebra is defined for the 56 EXTREM data model [Scho87b]; the operations differ only in some details. EXTREM is a semantic data model implemented on top of a flat relational system and using some of the constructs of the IFO semantic data model [Abit88b]. Chen <ref> [Chen84] </ref> also proposed an algebra for the E/R model. This algebra operates on data which is restricted to allow only binary directional relationships. The operators provided for this model are as follows: Select, union, difference, and intersection can be applied to sets of values or to entity sets.
Reference: [Clif85] <author> J. Clifford and A. Tansel, </author> <title> "On an Algebra for Historical Relational Databases: Two Views", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Austin, TX, </address> <year> 1985. </year>
Reference-contexts: The first subsection describes algebras which are nearly relational or based mainly on the relational algebra. Algebras closely resembling the NF 2 or complex object algebras are presented in the next subsection. 2.3.9.1. Relational-Like Algebras In <ref> [Clif85] </ref> an extension to the relational model is presented which allows for historical queries on a relation. Attributes are viewed as either unchanging, time-varying, or time-valued (i.e., their value is, e.g., a date). Three different forms of nulls are introduced to handle incomplete information about time. <p> The ALGRES algebra [Ceri87] is similar but it also supports a least fixpoint operation and unordered relations. Object identity was added to complex structures in the LDM algebra [Kupe85] and in IQL [Abit89]. Finally, the algebraic approach has also been extended to cover temporal databases <ref> [Tans89, Clif85] </ref>. Algebraic transformation rules for the relational algebra can be found in [Ullm89]. [Scho86] presents such rules for the nested relational model.
Reference: [Codd70] <author> E. Codd, </author> <title> "A Relational Model of Data for Large Shared Data Banks," </title> <type> CACM 13(6), </type> <month> June </month> <year> 1970. </year>
Reference-contexts: INTRODUCTION The relational model of data <ref> [Codd70] </ref> has been very successful both commercially and in terms of the research opportunities it has provided. One of the major reasons for this is that the model lends itself to an execution paradigm that can be expressed as an algebra [Codd70, Ullm89]. <p> INTRODUCTION The relational model of data [Codd70] has been very successful both commercially and in terms of the research opportunities it has provided. One of the major reasons for this is that the model lends itself to an execution paradigm that can be expressed as an algebra <ref> [Codd70, Ullm89] </ref>. An algebraic execution engine is used to process queries and to optimize them by rewriting algebraic expressions into different algebraic expressions that produce the same answer in a (hopefully) more efficient manner. <p> The central feature of a DBMS is its data model, the formal abstraction which it uses to map real-world entities onto (logical) database entities. Many different DBMSs may implement the same abstract data model (e.g. the relational model <ref> [Codd70] </ref>). As seen in the previous section, data models are becoming increasingly powerful and complex, and with this power and complexity comes the need to ensure correct and efficient execution of queries on data with increasingly complex structure. 1.2.1. <p> In 1970 Codd proposed the relational data model and algebra <ref> [Codd70] </ref>. Informally, a relational system models all data as 2-dimensional tables of values. These tables are manipulated using the five operators of the relational algebra. <p> The next section covers nested relational algebras. Section 2.3 discusses algebras for more powerful data models, including the complex object and object-oriented models. In Section 2.4 we summarize the major features of each algebra and draw some conclusions. 2.1. The Relational Algebra The relational model was first described in <ref> [Codd70] </ref> and became the model of choice for standard business data processing applications in the 1980s. The model consists of three things: 1) Relations, 2) An algebra to operate on those relations, and 3) Rules and guidelines for database design and maintenance (including integrity constraints, etc.). <p> This is expressed as hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 Codd's original proposal <ref> [Codd70] </ref> consisted of a different, but equipollent, set of operators: p, column permutation, join, composition, and restriction. <p> The Vanderbilt Algebra The algebra for NF 2 relations described in [Fisc83] was not defined for use with a particular system, but rather as a general algebra for use with any NF 2 system, just as Codd's relational algebra <ref> [Codd70] </ref> was intended to apply to any number of relational systems. The objects operated on by the Vanderbilt algebra are exactly the NF 2 rela tions, as with the DASDBS algebra. That is, a relation can have atomic- and relation-valued attributes. <p> The operators involving the meta-data allow graph traversal and transitive closure. It is interesting to note that in RM/T everything is stored in a relation-- i.e., an entire database as described in [Codd79] is a set of relations, as in <ref> [Codd70] </ref>. There is no notion of "complex objects"; rather, the concepts associated with such objects are modeled using additional relations. 2.3.9.2. NF -Like and Other Algebras The PDM algebra was developed for use with the PROBE project at CCA [Mano86, Daya87].
Reference: [Codd79] <author> E. Codd, </author> <title> "Extending the Relational Model to Capture More Meaning," </title> <journal> ACM TODS 4(4), </journal> <month> Dec. </month> <year> 1979. </year>
Reference-contexts: This thesis will address these issues, among others. Another direction in data model evolution, one which has spawned such efforts as <ref> [Codd79, Dada86, Sche86, Schw86, Rowe87] </ref>, is to extend the relational model in some way. <p> Only the last three operators extend the original relational algebra. Grouping is similar to the EXTRA/EXCESS GRP operator (see [Vand91] and Chapter 5). The tuple extension operator adds a field (which is functionally dependent on the key) to a tuple. Renaming changes column names. Codd's RM/T (Relational Model/Tasmania) model <ref> [Codd79] </ref> is a fairly complicated object-oriented extension to the relational model with both object- and value-based semantics. It also supports many of the concepts 57 described in the semantic database literature. <p> The operators involving the meta-data allow graph traversal and transitive closure. It is interesting to note that in RM/T everything is stored in a relation-- i.e., an entire database as described in <ref> [Codd79] </ref> is a set of relations, as in [Codd70]. There is no notion of "complex objects"; rather, the concepts associated with such objects are modeled using additional relations. 2.3.9.2. NF -Like and Other Algebras The PDM algebra was developed for use with the PROBE project at CCA [Mano86, Daya87].
Reference: [Codd80] <author> E. Codd, </author> <title> "Data Models in Database Management," </title> <booktitle> Proc. Workshop on Data Abstraction, Databases, and Conceptual Modeling", </booktitle> <address> Pingree Park, Colorado, </address> <year> 1980. </year>
Reference-contexts: Notice that this definition says nothing about "updates", or changes to the set of objects to which the operators apply. This is the reason that update semantics in most systems are governed by a concept separate from the algebra, namely, integrity rules <ref> [Codd80] </ref>. A large number of recent systems operate on objects much more complex than those found in relational systems. A few of these have a corresponding algebra which they could use to optimize queries, but most do not. In addition, several "generic" algebras for non-relational systems have been proposed.
Reference: [Colb89] <author> L. Colby, </author> <title> "A Recursive Algebra and Query Optimization for Nested Relations", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Portland, Oregon, </address> <year> 1989. </year>
Reference-contexts: These two operators can be used, for example, to simulate a relational join. An algebra for nested relations which defines each of the seven standard operators recursively is described in <ref> [Colb89] </ref>. The recursive nature of the DASDBS select and project operators is incorporated here, as is the recursive nature of the SQL/NF set operations. Recursive join definitions are also included. <p> What drove the design of the algebra? Most operators of VERSO [Abit86], for example, were designed as recursive filters for the VERSO virtual machine, while other were driven by the need to correspond to a calculus. 3) Which of its operators are recursive? For example, the NF 2 algebra of <ref> [Colb89] </ref> has 5 recursive operators, but other NF 2 alge 62 bras have 0, 1, or 2, etc. The more recursive operators, the less need for nesting and unnesting. <p> The relational algebra was followed by algebras for nested (non-first normal form) relations <ref> [Abit86, Roth88, Sche86, Aris83, Colb89, Desh87, Fisc83, Jaes82b] </ref>. This model is an extension of the relational model which allows both scalar- and relation-valued attributes. Algebras for integrating set-valued fields [Ozso87] and aggregates [Ozso87, Klug82] into the relational model have also been designed.
Reference: [Cope84] <author> G. Copeland and D. Maier, </author> <title> "Making Smalltalk a Database System," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Boston, MA, </address> <year> 1984. </year>
Reference-contexts: much of the 3 modeling and querying functionality of object-oriented and other advanced systems. 1 The result is a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models [Dada86, Sche86], DAPLEX [Ship81], ORION [Bane87], Trellis/Owl [Scha86], O 2 [Banc88], STDM <ref> [Cope84] </ref>, and STDM's descendant, GemStone [Maie86c]. <p> Implicit joins were taken directly from GEM, and originated in DAPLEX. The EXCESS treatment of queries over nested sets is similar in flavor to that of NF 2 query languages, although the path syntax for handling deeply nested queries was influenced by DAPLEX and the early STDM paper <ref> [Cope84] </ref>. Our handling of range variables was heavily influenced by that of POSTGRES [Rowe87]. In addition, EXCESS 64 goes beyond its predecessors in several respects. <p> Thus, our earlier query involving children of second floor employees could have been written as: retrieve (C.name) from C in Employees.kids where Employees.dept.floor = 2 EXCESS also provides a path syntax in order to simplify the task of formulating queries over nested sets of objects <ref> [Ship81, Cope84] </ref>. As an example, the statement "range of C is Employees.kids" means that for each employee object in the Employees set, C will iterate over all the children of the employee.
Reference: [Dada86] <author> P. Dadam, K. Kuespert, F. Andersen, H. Blanken, R. Erbe, J. Guenauer, V. Lum, P. Pistor, and G. Walch, </author> <title> "A DBMS Prototype to Support Extended NF 2 Relations: An Integrated View of Flat Tables and Hierarchies," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Washington, DC, </address> <year> 1986. </year>
Reference-contexts: This thesis will address these issues, among others. Another direction in data model evolution, one which has spawned such efforts as <ref> [Codd79, Dada86, Sche86, Schw86, Rowe87] </ref>, is to extend the relational model in some way. <p> One approach to dealing with complex objects (also known as "structural object-orientation" [Ditt86]) is to provide procedures as a data type [Ston87a]. Another approach is to permit relation-valued attributes <ref> [Dada86, Sche86] </ref>. A third approach is to take a functional view of data [Ship81, Mano86, Bato87]. In addition, a common theme among many of these efforts is to extend the database system's data definition facilities with support for some form of sub-typing. <p> model and the associated EXCESS query language, which are intended to subsume much of the 3 modeling and querying functionality of object-oriented and other advanced systems. 1 The result is a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models <ref> [Dada86, Sche86] </ref>, DAPLEX [Ship81], ORION [Bane87], Trellis/Owl [Scha86], O 2 [Banc88], STDM [Cope84], and STDM's descendant, GemStone [Maie86c]. <p> Also note that we chose to call the result "num_pgs", but we could have called it anything. Currently, a prototype implementation of DASDBS is running and several geographical and bibliographic systems have been implemented on top of the kernel. 2.2.2. The AIM Algebra The AIM project at IBM-Heidelberg <ref> [Dada86, Pist86, Jaes85a] </ref> is designed to handle an extension of the NF 2 data model, with the goal of supporting non-traditional database applications. The major extension is the ability to handle ordered lists (arrays), multisets, and tuple-valued attributes. <p> Since the original development of EXTRA/EXCESS, O 2 [Banc88] has adopted own and ref attributes. The EXCESS query language is related to those of DAPLEX [Ship81], GEM [Zani83], NF 2 systems <ref> [Dada86, Sche86] </ref>, and POSTGRES [Rowe87]. Implicit joins were taken directly from GEM, and originated in DAPLEX. <p> In addition, if an employee is deleted, so are his or her kids. This provides a capability very similar to that provided by NF data models <ref> [Dada86, Sche86] </ref>. If the kids attribute were instead declared to be of type "- own ref Person -", the deletion semantics would be the same, but children could then be referenced from elsewhere in the database (by ref attributes of other objects). <p> In this section we present the design of the EXCESS query language. While EXCESS is based on QUEL [Ston76], we have borrowed ideas from the QUEL extensions developed for GEM [Zani83] and POSTGRES [Rowe87, Ston87b] as well as work on SQL extensions for handling NF 2 data <ref> [Dada86, Sche86] </ref>.
Reference: [Dani91] <author> S. Daniels, G. Graefe, T. Keller, D. Maier, D. Schmidt, and B. Vance, </author> <title> "Query Optimization in Revelation, an Overview", </title> <journal> IEEE Data Engineering Bulletin, </journal> <volume> 14(2), </volume> <month> June </month> <year> 1991. </year>
Reference-contexts: In other words, attributes (not tuples) have timestamps. There are also operators to build up and 59 destroy individual temporal atoms. The algebra of the Revelation system <ref> [Grae88, Dani91] </ref> uses extended relational operators and requests objects to "reveal" an expression (in this algebra) for execution (the request may be refused).
Reference: [Daya87] <author> U. Dayal, M. DeWitt, D. Goldhirsch, J. </author> <title> Orenstein, </title> <type> "PROBE Final Report", Tech. Report CCA-87-02, </type> <institution> Computer Corporation of America, </institution> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: There is no notion of "complex objects"; rather, the concepts associated with such objects are modeled using additional relations. 2.3.9.2. NF -Like and Other Algebras The PDM algebra was developed for use with the PROBE project at CCA <ref> [Mano86, Daya87] </ref>. The model is derived mainly from DAPLEX [Ship81], and it is object-based. <p> Some of our multiset operators are similar to those of [Daya82], but [Daya82] restricts itself to the (value-based) relational model and includes the redundant intersection operator. The SET_APPLY looping operator described below was inspired by LISP's map-car function. It resembles other algebraic operators <ref> [Abit88a, Guti89, Daya87] </ref>, but is unique in that it allows the application of any algebraic expression to the elements of the multiset and needs no special syntax to apply the expression (as is needed with the r operator of [Abit88a], e.g.).
Reference: [Daya82] <author> U. Dayal, N. Goodman, and R. Katz, </author> <title> "An Extended Relational Algebra with Control Over Duplicate Elimination", </title> <booktitle> Proc. ACM PODS Conf., </booktitle> <year> 1982. </year>
Reference-contexts: For this algebra, the fundamental operators (in addition to the relational operators) are pack, unpack, and two operators which convert time-varying attributes into regular attributes and vice-versa. An interesting algebra for the relational model with duplicates appears in <ref> [Daya82] </ref>. This algebra redefines the set-theoretic operations to be the corresponding multiset-theoretic operations and adds a duplicate elimination operator. It also includes the (redundant) multiset intersection operator. In [Pare85] an algebra for Entity-Relationship [Chen76] databases is presented. <p> The transformation rules involving these new operators are new, as are most of the other multiset transformations we provide. ENCORE/EQUAL [Shaw90] and ALGRES [Ceri87] provide both sets and multisets, but the semantics of their multiset operations are not specified. Some of our multiset operators are similar to those of <ref> [Daya82] </ref>, but [Daya82] restricts itself to the (value-based) relational model and includes the redundant intersection operator. The SET_APPLY looping operator described below was inspired by LISP's map-car function. <p> ENCORE/EQUAL [Shaw90] and ALGRES [Ceri87] provide both sets and multisets, but the semantics of their multiset operations are not specified. Some of our multiset operators are similar to those of <ref> [Daya82] </ref>, but [Daya82] restricts itself to the (value-based) relational model and includes the redundant intersection operator. The SET_APPLY looping operator described below was inspired by LISP's map-car function.
Reference: [Desh88] <author> A. Deshpande and D. Van Gucht, </author> <title> "An Implementation for Nested Relational Databases," </title> <booktitle> Proc. VLDB Conf., </booktitle> <address> Los Angeles, CA, </address> <year> 1988. </year>
Reference-contexts: The second example is a little simpler. It merely requires some restructuring to get the proper attributes to the top level and allow their projection. 2.2.6. The NRDM Algebra The Nested Relational Data Model (NRDM) is a system being developed and implemented at Indiana University <ref> [Desh88] </ref>. Once again, the domain of objects is the set of relations with relation-valued attributes, just as in the previous algebras. This algebra also enforces the PNF restriction on its data, which again has an effect on the definition of the algebraic operations.
Reference: [Desh87] <author> V. Deshpande and P.-A. Larson, </author> <title> "An Algebra for Nested Relations," </title> <institution> Research Report CS-87-65, University of Waterloo, </institution> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: This equality holds iff a certain functional dependency holds on the relation: all non scalar fields must be functionally dependent on the set of scalar fields. This is known variously as Partitioned Nor mal Form (PNF) <ref> [Roth88, Desh87] </ref>, Nested Normal Form [Hull88], hierarchical structures, and the ability to provide a set-free denotation for set-valued objects [Hull88]. <p> In the second query, it is still necessary to use the m before doing the projection, since p is not as "extended" as s. 2.2.7. The Waterloo Algebra The algebra for nested relations developed at the University of Waterloo <ref> [Desh87] </ref>, like that designed at Van-derbilt, was not designed with any particular system in mind, but as a general tool for studying and guiding the implementation of nested relational database systems. <p> We thus can create a "subrelation" with as many attributes as we like. Each of these attributes will be the result of some algebra expression applied to the path specified in the subrelation constructor. (Note that these algebra expressions may themselves contain subrelation constructors.) In <ref> [Desh87] </ref> the join and natural join operators are also defined, but these are not fundamental as they are defined in terms of and s, just as in the relational algebra. Note that here we have the problem with the unnesting of empty subrelations as we did in VERSO. <p> Also, like all the previous algebras, the Waterloo algebra is value-based in nature. 37 A system known as LauRel <ref> [Desh87] </ref> is being developed at the University of Waterloo. LauRel is based on the nested relational model and presumably will make use of the Waterloo algebra. Planned extensions to the algebra include support for aggregate computations. The LauRel system also supports references to objects, much as in [Care88b]. <p> The relational algebra was followed by algebras for nested (non-first normal form) relations <ref> [Abit86, Roth88, Sche86, Aris83, Colb89, Desh87, Fisc83, Jaes82b] </ref>. This model is an extension of the relational model which allows both scalar- and relation-valued attributes. Algebras for integrating set-valued fields [Ozso87] and aggregates [Ozso87, Klug82] into the relational model have also been designed.
Reference: [Ditt86] <author> K. Dittrich, </author> <title> "Object-Oriented Database Systems: The Notion and the Issues," </title> <booktitle> Proc. Int'l. Workshop on Object-Oriented Database Systems, </booktitle> <address> Pacific Grove, CA, </address> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: A number of database researchers seem to believe that object-oriented database systems are the future [Fish87, Khos87, Banc88, Lecl87, Horn87, Andr87, Bane87, Maie86c], and several flavors of object-oriented models have been identified <ref> [Ditt86] </ref>. However, there is little consensus as to what an object-oriented database system should be; such systems today range from object-oriented programming languages with persistence to full database systems based on data models that would have been called "semantic data models" in the past. <p> One approach to dealing with complex objects (also known as "structural object-orientation" <ref> [Ditt86] </ref>) is to provide procedures as a data type [Ston87a]. Another approach is to permit relation-valued attributes [Dada86, Sche86]. A third approach is to take a functional view of data [Ship81, Mano86, Bato87].
Reference: [Done70] <author> J. Doner, </author> <title> "Tree Acceptors and Some of their Applications", </title> <journal> J. Computer and System Sciences 4, </journal> <year> 1970. </year>
Reference-contexts: We develop a notation for expressing patterns in trees based on results presented in <ref> [That68, Done70] </ref>. 3.2.3. <p> To extend the standard regular expression notation to trees, we build on the results of <ref> [Done70, That68] </ref>. These papers present generalizations of finite automata which can recognize trees rather than just strings. [That68] proves the closure of these generalized automata under union, concatenation, and Kleene *. <p> All of the subsequent results of this chapter hold when multiple concatenation point symbols are allowed. For simplicity of presentation we restrict ourselves to just l. We have just defined a semantics for the |, Kleene *, and concatenation operations, based on results of <ref> [Done70, That68] </ref>. We now describe the syntax that will enable us to express these patterns inside an algebraic query.
Reference: [Dorn78] <author> L. L. Dornhoff and F. E. Hohn, </author> <title> Applied Modern Algebra, </title> <publisher> Macmillan, </publisher> <address> New York, </address> <year> 1978. </year>
Reference-contexts: the algebra and EXCESS. 8 CHAPTER 2 A SURVEY OF DATABASE ALGEBRAS An algebra is formally defined as a pair (S, Q), where S is a (possibly infinite) set of objects and Q is a (possibly infinite) set of n-ary operators, each of which is closed with respect to S <ref> [Dorn78] </ref>. These operations will have certain properties (e.g. commutativity) which make rearrangement of some algebraic expressions possible; this is what makes algebras so desirable for query optimization. Such equivalences are proved by demonstrating an isomorphic mapping between the sets represented by two different expressions.
Reference: [Fisc83] <author> P. C. Fischer and S. J. Thomas, </author> <title> "Operators for Non-First-Normal-Form Relations," </title> <booktitle> Proc. IEEE COMP-SAC, </booktitle> <year> 1983. </year>
Reference-contexts: Neither of these features is reflected in the algebra, however. 2.2.3. The Vanderbilt Algebra The algebra for NF 2 relations described in <ref> [Fisc83] </ref> was not defined for use with a particular system, but rather as a general algebra for use with any NF 2 system, just as Codd's relational algebra [Codd70] was intended to apply to any number of relational systems. <p> That is, all possible unnestings are performed. Note that the order in which these are performed is irrelevant, since UNNEST A=S (UNNEST B=T UNNEST B=T (UNNEST A=S (R)) <ref> [Fisc83] </ref>. These operators are all of course composable and are defined to operate on any NF 2 relation (s). In other words, there are no normal form or other restrictions imposed on the data. However, since there is no mention of null values in [Fisc83], we assume that they are not <p> B=T UNNEST B=T (UNNEST A=S (R)) <ref> [Fisc83] </ref>. These operators are all of course composable and are defined to operate on any NF 2 relation (s). In other words, there are no normal form or other restrictions imposed on the data. However, since there is no mention of null values in [Fisc83], we assume that they are not supported. A large number of algebraic equivalences for these operators are given in [Fisc83], but here we will only mention that several desirable algebraic properties do not hold without certain restrictions on the data. <p> In other words, there are no normal form or other restrictions imposed on the data. However, since there is no mention of null values in <ref> [Fisc83] </ref>, we assume that they are not supported. A large number of algebraic equivalences for these operators are given in [Fisc83], but here we will only mention that several desirable algebraic properties do not hold without certain restrictions on the data. Among these is the commutativity of the NEST operator, as described in a previous section. <p> The relational algebra was followed by algebras for nested (non-first normal form) relations <ref> [Abit86, Roth88, Sche86, Aris83, Colb89, Desh87, Fisc83, Jaes82b] </ref>. This model is an extension of the relational model which allows both scalar- and relation-valued attributes. Algebras for integrating set-valued fields [Ozso87] and aggregates [Ozso87, Klug82] into the relational model have also been designed.
Reference: [Fish89] <author> D. Fishman, J. Annevelink, E. Chow, T. Connors, J. Davis, W. Hasan, C. Hoch, W. Kent, S. Leichner, P. Lyngbaek, B. Mahbod, M. Neimat, T. Risch, M. Shan, and W. Wilkinson, </author> <title> "Overview of the Iris DBMS", in Object-Oriented Concepts, Databases, and Applications, </title> <editor> ed. W. Kim and F. Lochovsky, </editor> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year> <month> 190 </month>
Reference-contexts: We thus have a consistent semantics for the domains of all EXTRA types, including those using multiple inheritance among named tuple types and optional object identity. Note also that these semantics allow type migration <ref> [Fish89] </ref> to occur, as long as substitutability is preserved along the way. 5.2. The Algebraic Operators The orthogonal nature of the type constructors of EXCESS (and those of the algebra) has been incorporated into the operator definitions.
Reference: [Fish87] <author> D. Fishman, D. Beech, H. Cate, E. Chow, T. Connors, J. Davis, N. Derrett, C. Hoch, W. Kent, P. Lyng-baek, B. Mahbod, M. Neimat, T. Ryan, and M. Shan, </author> <title> "Iris: An Object-Oriented Database Management System," </title> <journal> ACM Trans. Office Info. Sys. </journal> <volume> 5(1), </volume> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: These features make algebraic specification desirable for a data model/retrieval language. In recent years it has become apparent that the relational model is not always the right choice for a particular application [Kent79, Care88a, Schw86], and many new data models have been proposed <ref> [Abit88b, Lecl87, Fish87, Maie86c, Bane87, Mano86, Roth88, Sche86, Kupe85, Abit88a] </ref>. <p> While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Banc88, Lecl87, Horn87, Andr87, Bane87, Maie86c] </ref>, and several flavors of object-oriented models have been identified [Ditt86]. <p> There are also operators to compose, decompose, invert, and create relationships. The last operation has the Cartesian product of two entity sets as a special case. An algebra has also been developed for FAD [Banc87], but in FAD (as in IRIS <ref> [Fish87] </ref>) the real optimization work is performed by a relational optimizer -- FAD expressions are first translated to flat relational algebra. FAD was used as a backend for the LDL system developed at MCC [Tsur86]. <p> Lastly, our approach to user-defined set functions is more general than the corresponding POSTGRES approach to user-defined aggregates. With respect to schema types, our support for EXCESS functions is similar to the functions of DAPLEX [Ship81] and IRIS <ref> [Fish87] </ref>, and also to the parameterized procedures of POSTGRES [Ston87a]. Our approach to user-defined procedures is rooted in the stored commands of the IDM database machine [IDM500], as is our approach to encapsulation through authorization, but EXCESS procedures are a much more general mechanism. <p> A function may return a result of any type, including a schema type, a set of some schema type, etc. Updates through functions are not permitted. By way of comparison, EXCESS functions are similar to functions in DAPLEX [Ship81] and IRIS <ref> [Fish87] </ref>. They can also be viewed as a simplified form of POSTGRES procedure attributes [Ston87a]; in particular, they are like parameterized procedure attributes.
Reference: [Fren90] <author> J. French, A. Jones, and J. Pfaltz, </author> <title> "Summary of the Final Report of the NSF Workshop on Scientific Database Management", </title> <booktitle> SIGMOD Record 19, </booktitle> <year> 1990. </year>
Reference-contexts: Ordered Types in AQUA Lately there has been a lot of interest in bulk types like lists, trees, and graphs that are not supported by traditional data models and query algebras. This interest is fueled by the fact that much data in the scientific domain is inherently ordered <ref> [Fren90, Fren91, Land91] </ref>. Scientific applications have a need to store ordered types such as time-series data and genome sequences, and textual databases often store information that is structured as a tree. These applications store huge volumes of data and must locate information from these structures very efficiently.
Reference: [Fren91] <author> K. Frenkel, </author> <title> "The Human Genome Project and Informatics", </title> <type> CACM 34, </type> <year> 1991. </year>
Reference-contexts: Ordered Types in AQUA Lately there has been a lot of interest in bulk types like lists, trees, and graphs that are not supported by traditional data models and query algebras. This interest is fueled by the fact that much data in the scientific domain is inherently ordered <ref> [Fren90, Fren91, Land91] </ref>. Scientific applications have a need to store ordered types such as time-series data and genome sequences, and textual databases often store information that is structured as a tree. These applications store huge volumes of data and must locate information from these structures very efficiently.
Reference: [Gold83] <author> A. Goldberg and D. Robson, </author> <title> Smalltalk-80: The Language and its Implementation, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: In attempting to support both values and objects, some systems (e.g. EXCESS [Vand91]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. Smalltalk and ORION <ref> [Gold83, Bane87] </ref>) choose to support only objects in the type system and to model values as a special case of objects. IQL [Abit89] defines two separate languages, one enforcing object identity and one not supporting it at all. <p> Non-determinism is also present in [Abit90], which describes a witness operator which operates in a logical (rather than an algebraic) setting and creates a set of possible interpretations of a formula, resulting in non-determinism. Most ``pure'' object-oriented models (such as <ref> [Gold83, Maie86c] </ref> and others) provide and enforce encapsulation of data types. In AQUA the notion of type is more general: not everything is forced to be of an encapsulated, abstract data type whose only interface is that provided by the definer of the type.
Reference: [Gott88] <author> G. Gottlob and R. Zicari, </author> <title> "Closed World Databases Opened Through Null Values", </title> <booktitle> Proc. VLDB Conf., </booktitle> <address> Los Angeles, CA, </address> <year> 1988. </year>
Reference-contexts: In the COMP operator, equality (and thus multiset membership, which is conceptually an equality test against every occurrence in a multiset) is based solely on value equality. The special null constants are given a semantic interpretation, as shown in the following table from <ref> [Gott88] </ref>, which shows the truth-values resulting from the com parison of two constants to determine either equality or multiset membership: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii set tup arr ref val iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii set , (), (=) ( | - - ) iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii tup (=) ( | - - ) iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii arr ( | - ), <p> There is only one instance of "nothing"; it is always the same. It is also useful to pose queries which treat null values as a symbolic constant rather than as a semantic constant <ref> [Zani83, Gott88] </ref>. Thus we allow two auxiliary comparators, == and , which force the null constants unk and dne to be treated like any other constants. <p> val2 unk dne iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii val1 val1=val2 F F iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii unk F T F iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii dne F F T iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c The final truth-value of a predicate will be determined using the following truth-tables for and , also derived from <ref> [Gott88] </ref>: iiiiiiiiiiiiiiiiiiiiiiiiiiiii P1 P2 F T UNK iiiiiiiiiiiiiiiiiiiiiiiiiiiii iiiiiiiiiiiiiiiiiiiiiiiiiiiii F F F F iiiiiiiiiiiiiiiiiiiiiiiiiiiii T F T UNK iiiiiiiiiiiiiiiiiiiiiiiiiiiii UNK F UNK UNK iiiiiiiiiiiiiiiiiiiiiiiiiiiiic c c c c c c c c c c c c c c c iiiiiiiiiiiiii P P iiiiiiiiiiiiii iiiiiiiiiiiiii F T iiiiiiiiiiiiii T F iiiiiiiiiiiiii UNK
Reference: [Grae89] <author> G. Graefe, ed., </author> <title> Workshop on Database Query Optimization, </title> <type> CSE Tech. Report 89-005, </type> <institution> Oregon Graduate Center, Portland, Oregon, </institution> <month> May 30, </month> <year> 1989. </year>
Reference-contexts: An excellent survey of query optimization appears in [Jark84]. An overview of some recent research in the area can be found in <ref> [Grae89] </ref>. 1.2.2. A Brief History The word "algebra" is derived from the Arabic "al-jabr", a word first used for this purpose by the 9th-century Arab mathematician al-Khwarizmi, and brought over into the Latin by Robert of Chester in 1145.
Reference: [Grae87] <author> G. Graefe and D. DeWitt, </author> <title> "The EXODUS Optimizer Generator," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> San Fran-cisco, CA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: This is different than [Ston87b], where operators but not functions are optimized. Third, we will support the addition of both new access methods and new join methods (written by expert users, or "database implementors") to the DBMS through the rule-based optimization techniques detailed in <ref> [Grae87] </ref>. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 8 The function/procedure distinction here is based on the existence or absence of a return value. We may relax our side-effect-free assumption for functions eventually, and it is a convention and not a constraint that the system will enforce. 92 4.3.2. <p> For the purposes of this thesis, we are most interested in the query processing component. Query processing is designed to operate as follows: 1) Translate the parse tree into an algebraic operator tree; 2) Optimize this tree using an optimizer generated by the EXODUS optimizer generator <ref> [Grae87] </ref>; 3) Convert the optimized plan tree into a storable, interpretable plan tree; 4) 126 Interpret the plan tree. Here we outline what was completed and present a brief critique of the EXODUS optimizer generator. An algorithm for step (1) was implemented in the E programming language [Rich87].
Reference: [Grae88] <author> G. Graefe and D. Maier, </author> <title> "Query Optimization in Object-Oriented Database Systems: The REVELATION Project", </title> <type> Tech. Report CS/E 88-025, </type> <institution> Dept. of Computer Science and Engineering, Oregon Graduate Center, </institution> <year> 1988. </year>
Reference-contexts: In other words, attributes (not tuples) have timestamps. There are also operators to build up and 59 destroy individual temporal atoms. The algebra of the Revelation system <ref> [Grae88, Dani91] </ref> uses extended relational operators and requests objects to "reveal" an expression (in this algebra) for execution (the request may be refused). <p> Both attributes and methods are inherited by a subtype. A method, in 118 EXTRA/EXCESS, is simply an EXCESS statement (or sequence of them) defined to operate on structures of a certain EXTRA type and returning a structure of some EXTRA type. (In some proposals <ref> [Grae88, Kort88] </ref>, methods are written in a general purpose programming language and database-style optimization is used only if the method is expressible in the algebra.) When an EXCESS method is defined, it is translated into an algebraic query tree that will execute the method.
Reference: [Gray84] <author> P. Gray, </author> <title> Logic, Algebra, and Databases, </title> <publisher> Ellis Horwood Ltd., </publisher> <address> West Sussex, England, </address> <year> 1984. </year>
Reference-contexts: The form of recursion supported is one that traverses a directed graph from a set of initial nodes. The ASTRID algebra <ref> [Gray84] </ref> is an extension of the relational algebra which provides the following operations: union, difference, Cartesian product, intersection, join, set division, selection, projection, grouping, renaming, and tuple extension. Only the last three operators extend the original relational algebra.
Reference: [Guti89] <author> R. Guting, R. Zicari, and D. Choy, </author> <title> "An Algebra for Structured Office Documents", </title> <journal> ACM Trans. Office Info. Sys. </journal> <volume> 7(2), </volume> <month> April </month> <year> 1989. </year>
Reference-contexts: The algebra can easily simulate the nest and unnest operators of the NF 2 algebras, although they are not primitives in the complex object algebra. 2.3.5. An Algebra for Office Forms In <ref> [Guti89] </ref> an algebra for structured office documents is presented. The model is essentially a nested relational model with sets replaced by sequences (ordered lists). The types of the algebraic objects are numeric, boolean, text, and complex, where "complex" indicates nested sequences of tuples. <p> The algebra does not assume PNF. There are two more algebras which resemble the NF 2 algebra. The first is NTD (Nested Table Data model) [Scho87b], which is an algebra for office forms; it has the same goals and domain of application as the algebra of <ref> [Guti89] </ref> discussed above. The NF 2D model (also described in [Scho87b]) is essentially the NF 2 model with the added ability to provide for schema evolution. With this in mind, the description in [Scho87b] provides an expansion operator to alter the structure of attributes in the schema. <p> This allows more natural algebraic representations of some entities. This many-sortedness allows us easily to model the arbitrary structure of EXCESS types and entities. The algebra of <ref> [Guti89] </ref> is many-sorted in the sense that arithmetic is part of the database algebra, but the portion of the algebra corresponding to the usual notion of database algebras is not many-sorted, giving it a much different flavor than the EXCESS algebra. <p> Some of our multiset operators are similar to those of [Daya82], but [Daya82] restricts itself to the (value-based) relational model and includes the redundant intersection operator. The SET_APPLY looping operator described below was inspired by LISP's map-car function. It resembles other algebraic operators <ref> [Abit88a, Guti89, Daya87] </ref>, but is unique in that it allows the application of any algebraic expression to the elements of the multiset and needs no special syntax to apply the expression (as is needed with the r operator of [Abit88a], e.g.). <p> There is also an array creation operator and an operator to collapse an array of arrays. The notion of sequences supported in the NST algebra <ref> [Guti89] </ref> is similar, but not identical, to our notion of arrays. NST does not support unordered sets or fixed-length arrays. Also, our operators can be used in such a way that the ordering properties of the arrays can either be preserved or not, depending on the requirements of the query. <p> A "complex object" can use the set and tuple type constructors arbitrarily. An algebra that operates on ordered nested relations (plus tuple-valued attributes and ordered sets of scalars) was proposed in <ref> [Guti89] </ref>. The ALGRES algebra [Ceri87] is similar but it also supports a least fixpoint operation and unordered relations. Object identity was added to complex structures in the LDM algebra [Kupe85] and in IQL [Abit89]. Finally, the algebraic approach has also been extended to cover temporal databases [Tans89, Clif85]. <p> The | - - symbol is an array ana log to the symbol for multisets (the same symbol is used for the same purpose in <ref> [Guti89] </ref>).
Reference: [Gutt85] <author> J. Guttag, J. Horning, and J. Wing, </author> <title> "The Larch Family of Specification Languages", </title> <journal> IEEE Software, </journal> <volume> 2(5), </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: AQUA characterizes the distinction between ``objects'' and ``values'' as the difference between entities (objects) with mutable and immutable semantics; this provides a much cleaner formalism, and was partially inspired by systems such as Larch <ref> [Gutt85] </ref>. By cleanly separating the notions of type (a syntactic concept) and semantics we provide a model that treats both values and objects as first-class citizens and has a simpler type system. <p> We therefore add a second level to our system by requiring each type to have one or more semantics. The semantics of a type might loosely be thought of as axioms (in the style of Larch <ref> [Gutt85] </ref>) that describe properties of the operations on a type. The particular language used for describing semantics is a topic of future research. At the bottom of this two layered system, there is an additional layer that provides for multiple implementations (at least one) for each semantics.
Reference: [Gyss89] <author> M. Gyssens, J. Paredaens, and D. Van Gucht, </author> <title> "A Grammar-Based Approach Towards Unifying Hierarchical Data Models", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Portland, Oregon, </address> <year> 1989. </year>
Reference-contexts: The operation "createobj" creates a new object with its own identity, and the "unique" operation removes duplicate identifiers based on the values of certain columns of the objects pointed to by the identifiers. In <ref> [Gyss89] </ref> an algebra was introduced for an intriguing model which represents all hierarchical structures as formal context-free grammars. This seems to be a very powerful formalism, but its utility has yet to be determined.
Reference: [Gyss88] <author> M. Gyssens and D. Van Gucht, </author> <title> "The Powerset Algebra as a Result of Adding Programming Constructs to the Nested Relational Algebra," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Chicago, Illinois, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: This is slightly unfortunate, as the two algebras are different in several respects, but the differences are not captured by these queries. In particular, the n and join operators are not the same. 2.2.8. The Powerset Algebra This algebra <ref> [Gyss88] </ref> came about as a result of the fact that, when the PNF restriction is not imposed, the nested relational algebra is less powerful than the nested relational calculus [Hull87]. This algebra was developed to demonstrate certain theoretical aspects of nested relations, and is not associated with any particular system. <p> It is also interesting to note that the Powerset algebra is equivalent to adding a least fixpoint operator to the nested algebra without powerset and is also equivalent to adding some programming constructs to the nested algebra without powerset (e.g., looping) <ref> [Gyss88] </ref>. The addition of P also makes exactly one of the n and operators redundant (but not both) [Gyss88]. Null values are not supported in this algebra (but is), so we encounter a problem similar to that described above for the VERSO algebra when we wish to unnest empty relations. <p> algebra is equivalent to adding a least fixpoint operator to the nested algebra without powerset and is also equivalent to adding some programming constructs to the nested algebra without powerset (e.g., looping) <ref> [Gyss88] </ref>. The addition of P also makes exactly one of the n and operators redundant (but not both) [Gyss88]. Null values are not supported in this algebra (but is), so we encounter a problem similar to that described above for the VERSO algebra when we wish to unnest empty relations. The algebra is also value-based. <p> This is because the powerset operator, which returns the set of all subsets of its input set, is inherently exponential in nature and (in at least some algebras) allows for the formulation of least fixpoint queries in the algebra <ref> [Gyss88] </ref>. Second, it has been observed that the addition of the powerset operator to some algebras has the same effect as adding while-loops with arbitrary conditions [Gyss88]. We emphasize that such loops are fundamentally different from the style of loop exemplified by the SET_APPLY operator. <p> input set, is inherently exponential in nature and (in at least some algebras) allows for the formulation of least fixpoint queries in the algebra <ref> [Gyss88] </ref>. Second, it has been observed that the addition of the powerset operator to some algebras has the same effect as adding while-loops with arbitrary conditions [Gyss88]. We emphasize that such loops are fundamentally different from the style of loop exemplified by the SET_APPLY operator. The latter style of loop executes a statement on each element of a (multi)set in turn.
Reference: [Hoff82] <author> C. Hoffmann and M. O'Donnell, </author> <title> "Pattern Matching in Trees", </title> <type> JACM 29(1), </type> <month> January </month> <year> 1982. </year>
Reference-contexts: We will also define some operations which are capable of retrieving subtrees that extend "down" (and "up") the tree as far as possible. Initially, however, we will concentrate on finding only matching subtrees, according to our definition (which is standard; see <ref> [Karp72, Hoff82] </ref>). 143 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh a a b b a hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh a a hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Note that we could just as easily have defined sub_select to return a set of nodes corresponding to the roots of the matched subtrees. Logically, however, we desire the entire subtree. <p> Logically, however, we desire the entire subtree. An implementation could of course return only the roots if desired, materializing the rest of the subtree (s) on demand. The next section discusses the sub_select operator in more detail and explains its definition further. The definition conforms to that used in <ref> [Karp72, Hoff82] </ref>. Apply (f) (T) applies the function f to the ``content'' of each cell (node) of the tree to transform the existing object into a new object. The edge set remains the same. <p> Algorithms and Indexes In this section we briefly discuss the applicability of various tree-matching algorithms and the desirability of various forms of indexing on trees and forests. Most of the algorithms proposed for tree matching <ref> [Karp72, Hoff82] </ref> solve the following problem: Given a tree T2 (or a finite set of trees) return all the locations where T2 occurs in tree T1. Note that T2 is a tree, not a pattern. <p> They also can imitate union to some extent because T2 can be a set of trees. [Karp72] presents some of the earliest tree-matching algorithms. These are improved on by using additional preprocessing in <ref> [Hoff82] </ref>. The latter paper presents 8 algorithms for solving the tree matching problem, and describes the space and time complexities of each. These algorithms are all ways to process our algebra query sub_select (P 1 2 n where the P i have no concatenation or Kleene * operators. <p> Implementation techniques for the tree-based operations need to be evaluated under the assumption that some data will reside on disk. The relative efficiencies of the algorithms described in <ref> [Hoff82] </ref> may no longer hold if disk-based data is taken into account. 165 APPENDIX A Transformation Rules of the EXCESS Algebra This appendix contains a list of transformation rules (involving both primitive and derived operators) in the EXCESS algebra.
Reference: [Horn87] <author> M. Hornick and S. Zdonik, </author> <title> "A Shared, Segmented Memory System for an Object-Oriented Database," </title> <journal> ACM Trans. Office Info. Sys. </journal> <volume> 5(1), </volume> <month> Jan. </month> <year> 1987. </year>
Reference-contexts: While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Banc88, Lecl87, Horn87, Andr87, Bane87, Maie86c] </ref>, and several flavors of object-oriented models have been identified [Ditt86]. <p> As we will see in the next section, despite their semantic differences, own, ref, and own ref attributes are all treated uniformly in the EXCESS query language for query simplicity. Thus, casual users can ignore the distinction, viewing attributes simply as other objects, as in most object-oriented data models <ref> [Lecl87, Horn87, Andr87, Bane87, Maie86c] </ref>. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 Note: All objects must have a "home" as an own ref component of some other object in order to exist in the database. Named, persistent, top-level objects are automatically made own ref components of the database in which they are created.
Reference: [Houb87] <author> G. J. Houben and J. Paredaens, </author> <title> "The R 2 -Algebra: An Extension of an Algebra for Nested Relations," </title> <type> Tech. Report 87/20, </type> <institution> Dept. of Math. and Computing Sci., Computing Sci. Section, Eindhoven Univ. of Tech., </institution> <month> December </month> <year> 1987. </year>
Reference-contexts: However, some results in [Hull89b] suggest that allowing inhomogeneous sets may actually add a great deal of expressivity to the algebra. 2.3.8. The R Algebra This algebra <ref> [Houb87] </ref> is an extension of a nested relational algebra; it is not associated with a particular implementation or system.
Reference: [Hull87] <author> R. Hull, </author> <title> "A Survey of Theoretical Research on Typed Complex Database Objects", in Databases, </title> <editor> ed. J. Paredaens, </editor> <publisher> Academic Press, </publisher> <address> London, </address> <year> 1987. </year>
Reference-contexts: As the discussion moves beyond NF 2 models and systems, the implementation status and examples will largely be omitted. We will not discuss the relative power of the underlying data models, exhaustive sets of algebraic equivalence rules, or other theoretical language issues. Many of these issues are covered in <ref> [Pare88, VanG87, VanG86, Hull87, Hull89a, Chan88] </ref>. The purpose of this survey is to convey some idea of the general nature of database algebras in 9 the hope of gaining some insight into why certain operations exist and of identifying common themes among these algebras. <p> No formal calculus has been defined for the DASDBS system, but the algebra presented here would need to be extended with an operator known as the powerset operator (P; see subsequent sections) in order for it to be equivalent to any of the calculi defined for nested relations <ref> [Hull87] </ref>. Such a calculus would have to be strictly more powerful than the relational calculus in the sense that it would have to allow the construction of relation-valued as well as tuple-valued objects--this gives it some of the flavor of a second-order system. <p> In particular, the n and join operators are not the same. 2.2.8. The Powerset Algebra This algebra [Gyss88] came about as a result of the fact that, when the PNF restriction is not imposed, the nested relational algebra is less powerful than the nested relational calculus <ref> [Hull87] </ref>. This algebra was developed to demonstrate certain theoretical aspects of nested relations, and is not associated with any particular system. There are no restrictions on the nested relations that can be operated upon by this algebra. <p> This model is an extension of the relational model which allows both scalar- and relation-valued attributes. Algebras for integrating set-valued fields [Ozso87] and aggregates [Ozso87, Klug82] into the relational model have also been designed. All of these algebras are direct extensions of the relational algebra. Complex object models <ref> [Abit88a, Hull87] </ref> generalize nested relations by removing the restriction that every entity must be a set of tuples containing either scalars or other sets of tuples as attribute values, recursively. A "complex object" can use the set and tuple type constructors arbitrarily.
Reference: [Hull88] <author> R. Hull, </author> <title> "Four Views of Complex Objects: A Sophisticate's Introduction", </title> <type> draft, </type> <institution> Dept. of Computer Science, Univ. of Southern California, </institution> <address> Los Angeles, California, </address> <month> May </month> <year> 1988. </year>
Reference-contexts: This equality holds iff a certain functional dependency holds on the relation: all non scalar fields must be functionally dependent on the set of scalar fields. This is known variously as Partitioned Nor mal Form (PNF) [Roth88, Desh87], Nested Normal Form <ref> [Hull88] </ref>, hierarchical structures, and the ability to provide a set-free denotation for set-valued objects [Hull88]. <p> This is known variously as Partitioned Nor mal Form (PNF) [Roth88, Desh87], Nested Normal Form <ref> [Hull88] </ref>, hierarchical structures, and the ability to provide a set-free denotation for set-valued objects [Hull88]. <p> That is, other queries may operate on data which is not in PNF. This is of interest since it has been shown that restricting one's data to PNF, for both user-defined and intermediate data, reduces the algebraic power to that of the relational algebra <ref> [Hull88] </ref>. Intuitively, this is because in PNF one no longer needs to explicitly describe a set in order to get a handle on that set.
Reference: [Hull89a] <author> R. Hull and J. Su, </author> <title> "On Accessing Object-Oriented Databases: Expressive Power, Complexity, and Restrictions", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Portland, Oregon, </address> <year> 1989. </year>
Reference-contexts: As the discussion moves beyond NF 2 models and systems, the implementation status and examples will largely be omitted. We will not discuss the relative power of the underlying data models, exhaustive sets of algebraic equivalence rules, or other theoretical language issues. Many of these issues are covered in <ref> [Pare88, VanG87, VanG86, Hull87, Hull89a, Chan88] </ref>. The purpose of this survey is to convey some idea of the general nature of database algebras in 9 the hope of gaining some insight into why certain operations exist and of identifying common themes among these algebras.
Reference: [Hull89b] <author> R. Hull and J. Su, </author> <title> "Untyped Sets, Invention, and Computable Queries", </title> <booktitle> Proc. ACM PODS Conf., </booktitle> <year> 1989. </year>
Reference-contexts: However, some results in <ref> [Hull89b] </ref> suggest that allowing inhomogeneous sets may actually add a great deal of expressivity to the algebra. 2.3.8. The R Algebra This algebra [Houb87] is an extension of a nested relational algebra; it is not associated with a particular implementation or system.
Reference: [Hull90] <author> R. Hull and M. Yoshikawa, </author> <title> "ILOG: Declarative creation and manipulation of object identifiers", </title> <booktitle> Proc. VLDB Conf., </booktitle> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference-contexts: Buneman and Ohori exhibit a similar philosophy, though, in their distinction between a kind and a type [Bune91]. Unlike ILOG <ref> [Hull90] </ref> and others, we avoid explicit identifiers in the model, viewing them as an implementation concern, and reflecting the distinctions between objects and values by using varying semantics. 68 It has been pointed out by Atkinson et al [Atki91] that in object-oriented systems, a type may supply its own method for
Reference: [IDM500] <institution> IDM 500 Software Reference Manual, </institution> <note> version 1.4, </note> <institution> Britton-Lee Inc., Los Gatos, </institution> <address> CA. </address>
Reference-contexts: With respect to schema types, our support for EXCESS functions is similar to the functions of DAPLEX [Ship81] and IRIS [Fish87], and also to the parameterized procedures of POSTGRES [Ston87a]. Our approach to user-defined procedures is rooted in the stored commands of the IDM database machine <ref> [IDM500] </ref>, as is our approach to encapsulation through authorization, but EXCESS procedures are a much more general mechanism. The recently proposed procedures of SQL3 are similar to those provided by EXCESS. 3.2. <p> EXCESS functions and procedures are inherited through the type lattice in a manner similar to inheritance for attributes, giving EXTRA an object-oriented flavor. The goal of these facilities is to provide support for derived data, for writing "stored commands" (as in the IDM-500 query facility <ref> [IDM500] </ref>), and for data abstraction of the kind described by Weber [Webe78]. 4.3.2.1. EXCESS Functions As illustrated in an example in Section 4.1.3, associating functions with schema types provides a mechanism for defining derived attributes. <p> This kind of procedure is similar in flavor to the stored commands of the IDM database machine <ref> [IDM500] </ref>. However, it is much more general, as we support the use of a where clause for binding procedure parameters and we invoke the procedure for all possible bindings (instead of just once, with constant parameters). <p> This is similar to the distinction between virtual member functions and regular member functions in C++ [Stro86]. 95 4.3.2.3. Achieving Data Abstraction We provide an authorization mechanism along the lines of the System R [Cham75] and IDM <ref> [IDM500] </ref> protection systems; this mechanism is described in [Vand88a, Vand88b]. Both individual users and user groups (including a special "all-users" group) will be recognized, and protection units will be specified via EXCESS queries. <p> For example, one could choose to grant access to a given schema type only via its EXCESS functions and procedures, effectively making the schema type an abstract data type in its own right. (In fact, IDM stored commands are recommended for regulating database activity in a similar way <ref> [IDM500] </ref>.) Features such as the modules of [Webe78] or the object semantics of an object-oriented data model can thus be captured via a single, more general mechanism. 4.3.3.
Reference: [Jaes82a] <author> G. Jaeschke, </author> <title> "An Algebra of Power Set Type Relations," </title> <type> Tech. Report 82.12.002, </type> <institution> IBM Heidelberg Scientific Center, </institution> <month> Dec. </month> <year> 1982. </year>
Reference-contexts: Their algebra is similar to the NF 2 algebra presented in the previous section, but also incorporates features from the VERSO and SQL/NF algebras (see elsewhere in this section for descriptions of these). It is an extension of the powerset algebra described in <ref> [Jaes82a] </ref>, which is essentially identical to the earliest version of the DASDBS algebra [Jaes82b]. (Briefly, the extension to 1NF relations in this early algebra consisted of the ability to have the domain of a column in a relation be P i where D is a scalar domain and P i represents
Reference: [Jaes85a] <author> G. Jaeschke, </author> <title> "Recursive Algebra for Relations with Relation Valued Attributes," </title> <type> Tech. Report 85.03.002, </type> <institution> IBM Heidelberg Scientific Center, </institution> <month> March </month> <year> 1985. </year>
Reference-contexts: Also note that we chose to call the result "num_pgs", but we could have called it anything. Currently, a prototype implementation of DASDBS is running and several geographical and bibliographic systems have been implemented on top of the kernel. 2.2.2. The AIM Algebra The AIM project at IBM-Heidelberg <ref> [Dada86, Pist86, Jaes85a] </ref> is designed to handle an extension of the NF 2 data model, with the goal of supporting non-traditional database applications. The major extension is the ability to handle ordered lists (arrays), multisets, and tuple-valued attributes. <p> The algebra has been published in two forms, a recursive form <ref> [Jaes85a] </ref> and a non-recursive form [Jaes85b]; here we discuss the recursive form since it is more natural considering the hierarchical nature of the data and has been proved equivalent to the non-recursive algebra. (The difference between these versions of the algebra is that the operator definitions in the recursive version are <p> nested queries [Astr76]. 8) Keying (c): This operator is introduced to eliminate the problem of non-invertible unnestings (see previous section). c appends a key column to a relation before it is unnested then renested, and this ensures that nesting after an unnest will result in the original NF 2 relation <ref> [Jaes85a] </ref>. This is needed only when there is not already a key column in the relation. Note that if the AIM model supported object identity, and each tuple were regarded as an object, this operator would be superfluous. 9) Renaming (r): This operator renames an attribute of a nested relation. <p> We thus have a set-free denotation of any set. In the AIM algebra, the c operator is viewed as being invoked automatically as needed to preserve PNF, and this implies a loss of expressive power. Alternatively, <ref> [Jaes85a] </ref> could have chosen to make the c operator optional and explicit (rather than something that happens "under the covers") and thus not give up the extra expressivity provided by the NF algebra.
Reference: [Jaes85b] <author> G. Jaeschke, </author> <title> "Nonrecursive Algebra for Relations with Relation Valued Attributes," </title> <type> Tech. Report 85.03.001, </type> <institution> IBM Heidelberg Scientific Center, </institution> <month> March </month> <year> 1985. </year> <month> 191 </month>
Reference-contexts: The algebra has been published in two forms, a recursive form [Jaes85a] and a non-recursive form <ref> [Jaes85b] </ref>; here we discuss the recursive form since it is more natural considering the hierarchical nature of the data and has been proved equivalent to the non-recursive algebra. (The difference between these versions of the algebra is that the operator definitions in the recursive version are sometimes defined in terms of
Reference: [Jaes82b] <author> G. Jaeschke and H.-J. Schek, </author> <title> "Remarks on the Algebra of Non First Normal Form Relations," </title> <booktitle> Proc. ACM PODS Conf., </booktitle> <address> Los Angeles, CA, </address> <year> 1982. </year>
Reference-contexts: This is followed by algebraic transformations and access path selection. There is no limit to the level of nesting of the relations. (However, the earliest version of this algebra <ref> [Jaes82b] </ref> did not allow for general nested relations, but only for nesting of single attributes defined over scalar domains. That is, the domain of a column could be a scalar, a set of scalars, a set of sets of scalars, etc. <p> It is an extension of the powerset algebra described in [Jaes82a], which is essentially identical to the earliest version of the DASDBS algebra <ref> [Jaes82b] </ref>. (Briefly, the extension to 1NF relations in this early algebra consisted of the ability to have the domain of a column in a relation be P i where D is a scalar domain and P i represents the powerset operator applied i times to its argument. <p> The n operation, though, is commutative only if a certain multi-valued dependency (MVD) holds: n A B B A (R) if D fifi A, where D = attrs (R) - -A, B-. This becomes an iff relationship if we replace the MVD by a weak MVD 3 <ref> [Jaes82b] </ref>. (Of course, these relationships also hold for the DASBDS algebra, and for any algebra with the same operator definitions.) As mentioned above, one interesting thing about the c operator is that it enforces (albeit at a low level) the PNF restriction on the relations in the database. <p> The relational algebra was followed by algebras for nested (non-first normal form) relations <ref> [Abit86, Roth88, Sche86, Aris83, Colb89, Desh87, Fisc83, Jaes82b] </ref>. This model is an extension of the relational model which allows both scalar- and relation-valued attributes. Algebras for integrating set-valued fields [Ozso87] and aggregates [Ozso87, Klug82] into the relational model have also been designed.
Reference: [Jark84] <author> M. Jarke and J. Koch, </author> <title> "Query Optimization in Database Systems," </title> <journal> ACM Comp. Surveys 16(2), </journal> <month> June </month> <year> 1984. </year>
Reference-contexts: Other types of semantic information can be used in this phase of optimization, for example knowledge about allowable value ranges of 6 user-defined types or abstract data types (ADTs). An excellent survey of query optimization appears in <ref> [Jark84] </ref>. An overview of some recent research in the area can be found in [Grae89]. 1.2.2.
Reference: [Karp72] <author> R. Karp, R. Miller, and A. Rosenberg, </author> <title> "Rapid Identification of Repeated Patterns in Strings, Trees, and Arrays", </title> <booktitle> Proc. 4th Annual ACM Symp. on Theory of Comp., </booktitle> <address> Denver, CO, </address> <year> 1972. </year>
Reference-contexts: We will also define some operations which are capable of retrieving subtrees that extend "down" (and "up") the tree as far as possible. Initially, however, we will concentrate on finding only matching subtrees, according to our definition (which is standard; see <ref> [Karp72, Hoff82] </ref>). 143 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh a a b b a hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh a a hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh Note that we could just as easily have defined sub_select to return a set of nodes corresponding to the roots of the matched subtrees. Logically, however, we desire the entire subtree. <p> Logically, however, we desire the entire subtree. An implementation could of course return only the roots if desired, materializing the rest of the subtree (s) on demand. The next section discusses the sub_select operator in more detail and explains its definition further. The definition conforms to that used in <ref> [Karp72, Hoff82] </ref>. Apply (f) (T) applies the function f to the ``content'' of each cell (node) of the tree to transform the existing object into a new object. The edge set remains the same. <p> Clearly a similar definition can be provided for n-ary trees for any n. For trees with unbounded numbers of children, however, such an expression is not possible. An important special case of tree patterns are those in which we are only interested in the structure of the tree <ref> [Karp72] </ref>, not in the contents of the nodes. The "?" symbol makes such patterns easy to express in our notation. As a further notational convenience, as mentioned above, we assume that any node not present in a pattern is nil. <p> Algorithms and Indexes In this section we briefly discuss the applicability of various tree-matching algorithms and the desirability of various forms of indexing on trees and forests. Most of the algorithms proposed for tree matching <ref> [Karp72, Hoff82] </ref> solve the following problem: Given a tree T2 (or a finite set of trees) return all the locations where T2 occurs in tree T1. Note that T2 is a tree, not a pattern. <p> They also can imitate union to some extent because T2 can be a set of trees. <ref> [Karp72] </ref> presents some of the earliest tree-matching algorithms. These are improved on by using additional preprocessing in [Hoff82]. The latter paper presents 8 algorithms for solving the tree matching problem, and describes the space and time complexities of each.
Reference: [Kemp87] <author> A. Kemper and M. Wallrath, </author> <title> "An Analysis of Geometric Modeling in Database Systems," </title> <journal> ACM Comp. Surveys 19(1), </journal> <month> March </month> <year> 1987. </year>
Reference-contexts: This makes it possible for a database to include more than one collection of instances of a given type, which can be quite useful in scientific and engineering applications <ref> [Lohm83, Kemp87] </ref>. While this separation is common in programming languages, it is less common in the database world [Bloo87]. As an example, the commands in Figure 4.1 define a new schema type called Person, which is a tuple type.
Reference: [Kent79] <author> W. Kent, </author> <title> "Limitations of Record-Based Information Models," </title> <journal> ACM TODS 4(1), </journal> <month> March </month> <year> 1979. </year>
Reference-contexts: These features make algebraic specification desirable for a data model/retrieval language. In recent years it has become apparent that the relational model is not always the right choice for a particular application <ref> [Kent79, Care88a, Schw86] </ref>, and many new data models have been proposed [Abit88b, Lecl87, Fish87, Maie86c, Bane87, Mano86, Roth88, Sche86, Kupe85, Abit88a]. <p> These objects can be as simple or as complex as desired; EXTRA does not constrain the type structure of the named (or "top level") objects in the database. The advantages of going beyond a simple record-based model are detailed in <ref> [Kent79] </ref>. EXTRA separates the definition of types from the declaration of their instances, and it provides a type system based on a type lattice with multiple inheritance. The type system includes tuple, set, and array as type constructors that may be composed arbitrarily to form new types.
Reference: [Kern78] <author> B. Kernighan and D. Ritchie, </author> <title> The C Programming Language, </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1978. </year>
Reference-contexts: applications where it might be useful, for example, to see the results of a join of two arrays of tuples printed out in an order specified by their ordering in the original arrays. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 2 Multi-dimensional arrays can be constructed using arrays of arrays, as in the C programming language <ref> [Kern78] </ref>. 107 The operations which can be performed on arrays are: extract a subarray, concatenate two arrays, create an array, extract an element from an array, apply an algebraic expression to all elements of an array, collapse an array of arrays into an array, take the Cartesian product of two arrays,
Reference: [Khos86] <author> S. Khoshafian and G. Copeland, </author> <title> "Object Identity," </title> <booktitle> Proc. 1st OOPSLA Conf., </booktitle> <address> Portland, OR, </address> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: To support these different cases, EXTRA provides three different kinds of attribute value semantics: own attributes, ref attributes, and own ref attributes. An own attribute is simply a value, not a first-class object; it lacks identity in the sense of <ref> [Khos86] </ref>. By default, all attributes are taken to be own attributes unless otherwise specified.
Reference: [Khos87] <author> S. Khoshafian and P. Valduriez, </author> <title> "Sharing, Persistence, and Object Orientation: A Database Perspective," </title> <type> Tech. Report DB-106-87, </type> <institution> MCC, </institution> <month> April </month> <year> 1987. </year>
Reference-contexts: While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Banc88, Lecl87, Horn87, Andr87, Bane87, Maie86c] </ref>, and several flavors of object-oriented models have been identified [Ditt86].
Reference: [Kim88] <author> W. Kim, </author> <title> "A Model of Queries for Object-Oriented Databases", </title> <type> Tech. Report ACA-ST-365-88, </type> <institution> MCC, Austin, TX, </institution> <month> November </month> <year> 1988. </year>
Reference-contexts: It is an intermediate language. The relational algebra performs this function in the relational model, and is one reason why the model of query processing in relational systems is so attractive. Other paradigms, such as rule rewriting strategies (for recursive queries), query graphs, tableaux, and other methods <ref> [Kim88] </ref> have been proposed to fill this role, but algebras remain the favorite, probably due to their simplicity and mathematical rigor. In addition, equipollence proofs between algebra and first-order calculi have well-known proof techniques.
Reference: [Kim87] <author> W. Kim, J. Banerjee, H.-T. Chou, J. Garza, and D. Woelk, </author> <title> "Composite Object Support in an Object-Oriented Database System," </title> <booktitle> Proc. 2nd OOPSLA Conf., </booktitle> <address> Orlando, FL, </address> <year> 1987. </year>
Reference-contexts: an object need to be "full-fledged objects," but where the object should still be treated as a whole, hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh define type Department: ( name: char [ ], floor: int4, numemps: int4, employees: - ref Employee - ) create Departments: own ref Department - hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 75 as in ORION's composite objects <ref> [Kim87] </ref>. To support these different cases, EXTRA provides three different kinds of attribute value semantics: own attributes, ref attributes, and own ref attributes. An own attribute is simply a value, not a first-class object; it lacks identity in the sense of [Khos86]. <p> If the kids attribute were instead declared to be of type "- own ref Person -", the deletion semantics would be the same, but children could then be referenced from elsewhere in the database (by ref attributes of other objects). As with composite objects in ORION <ref> [Kim87] </ref>, however, a Person instance in the kids set of one Employee instance could not be in the kids set of another Employee instance simultaneously.
Reference: [King81] <author> J. King, "QUIST: </author> <title> A System for Semantic Query Optimization in Relational Databases", </title> <booktitle> Proc. VLDB Conf., </booktitle> <address> Cannes, France, </address> <month> August </month> <year> 1981. </year>
Reference-contexts: Some systems <ref> [Shen87, King81] </ref> include another phase in the optimization process. This phase is called semantic query optimization, and consists of generating syntactically different but semantically equivalent versions of the original (calculus) query using user-supplied information such as integrity constraints.
Reference: [Klau85] <author> A. Klausner and N. Goodman, </author> <title> "Multirelations Semantics and Languages," </title> <booktitle> Proc. VLDB Conf., </booktitle> <address> Stock-holm, Sweden, </address> <year> 1985. </year>
Reference-contexts: For agg-op, EXCESS provides all of the usual built-in aggregates (e.g., sum, count, hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 4 Using over in this way facilitates certain queries that would otherwise be difficult to express using QUEL unique aggregates or aggregates with SQL-like unique clauses, and it also renders such uniqueness clauses unnecessary <ref> [Klau85] </ref>. 85 As a first example, the following EXCESS query will find the average salary of all employees: retrieve (avgsal = avg (E.salary from E in Employees)) In order to fulfill our design goal of a clear, consistent rule for range variable binding, we use Pascal-like scop-ing rules for range variables.
Reference: [Klug82] <author> A. Klug, </author> <title> "Equivalence of Relational Algebra and Relational Calculus Query Languages Having Aggregate Functions," </title> <type> JACM 29(3), </type> <month> July </month> <year> 1982. </year>
Reference-contexts: Algebras described in detail here include algebras for relational aggregates, summary tables, images, complex objects, object-oriented systems, and office documents. In the final subsection we briefly describe some other algebras encountered in the literature. 2.3.1. An Algebra for Aggregates In <ref> [Klug82] </ref> an algebra is developed which extends the relational algebra to include aggregate computations. This algebra is intended to be used by any relational system which might need it, and was also part of a system called ABE (Aggregate-By-Example, an extension of IBM's Query-By-Example, or QBE). <p> This causes some of the usual algebraic identities to not hold, making query optimization more difficult. Essentially, the solution adopted was to define aggregate functions to operate over entire relations rather than on projections of these relations. This eliminates the need for the notion of duplicates. In <ref> [Klug82] </ref> a calculus is defined for this algebra and their equipollence is proved. Clearly, these languages are value-based. Null values are not allowed. <p> The elements of another relation direct (i.e. form a template for) this grouping; we 43 do not go into the details here. An equivalent calculus has been defined for the summary table algebra [Ozso87]. Like the algebra, it is an extension of the calculus defined in <ref> [Klug82] </ref>. It should also be noted that the aggregates operate only on a single scalar column and that the result of applying an aggregate to an empty set is null, which here means "does not exist". When an aggregate itself encounters a null value, it is ignored. <p> An alternate historical algebra is presented in the same paper; this algebra supports the aggregate formation operator as described in <ref> [Klug82, Ozso83] </ref> and the pack and unpack operators as described in [Ozso83]. For this algebra, the fundamental operators (in addition to the relational operators) are pack, unpack, and two operators which convert time-varying attributes into regular attributes and vice-versa. <p> The ALPHA algebra [Agra87] also extends the traditional relational algebra to support recursion, but in this case it is extended with Klug's support for aggregates <ref> [Klug82] </ref> and one more operator, known as a. The a operator provides support for a limited form of recursion and is integrated into the algebra in such a way as to allow traditional algebraic query optimization to take place. <p> The relational algebra was followed by algebras for nested (non-first normal form) relations [Abit86, Roth88, Sche86, Aris83, Colb89, Desh87, Fisc83, Jaes82b]. This model is an extension of the relational model which allows both scalar- and relation-valued attributes. Algebras for integrating set-valued fields [Ozso87] and aggregates <ref> [Ozso87, Klug82] </ref> into the relational model have also been designed. All of these algebras are direct extensions of the relational algebra.
Reference: [Kort88] <author> H. Korth, </author> <title> "Optimization of Object-Retrieval Queries (extended abstract)," </title> <institution> Dept. of Computer Sciences, Univ. of Texas, Austin, Texas, </institution> <month> April </month> <year> 1988. </year>
Reference-contexts: There are also operators to build up and 59 destroy individual temporal atoms. The algebra of the Revelation system [Grae88, Dani91] uses extended relational operators and requests objects to "reveal" an expression (in this algebra) for execution (the request may be refused). The algebra of <ref> [Kort88] </ref> is designed for a similar system and contains several implementations of the join operator on nested relations; the algebra used there is similar to the Vanderbilt algebra. <p> Both attributes and methods are inherited by a subtype. A method, in 118 EXTRA/EXCESS, is simply an EXCESS statement (or sequence of them) defined to operate on structures of a certain EXTRA type and returning a structure of some EXTRA type. (In some proposals <ref> [Grae88, Kort88] </ref>, methods are written in a general purpose programming language and database-style optimization is used only if the method is expressible in the algebra.) When an EXCESS method is defined, it is translated into an algebraic query tree that will execute the method.
Reference: [Kort91] <author> H. Korth and A. Silberschatz, </author> <title> Database System Concepts, second edition, </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Figure 2.2 contains an example instance of the Books relation. Relations are manipulated using the relational algebra, which is equipollent to the relational calculus (and hence to first-order predicate calculus). We give brief descriptions of the five standard relational operators as defined in <ref> [Kort91] </ref> or [Ullm89]: 1) Union (): Two relations can be combined into one using a standard set-theoretic union (duplicate tuples are eliminated). <p> This is expressed as hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 Codd's original proposal [Codd70] consisted of a different, but equipollent, set of operators: p, column permutation, join, composition, and restriction. Since then, however, the standard definitions have treated s, p, , , and as the fundamental operations <ref> [Kort91, Ullm89] </ref>. 2 The closed-world assumption (CWA) states that anything that can not be inferred from the data in the database is false. 17 follows. p [ p [publ_name] (s [name = publ_name] (copies (p [name, s [state = "NY"] (locations)] (Publishers)))) ] (s [title = "Moby Dick"] (Books)) A more <p> It is interesting to note that this inductive proof forms the outline of an algorithm to translate EXCESS to an initial algebra expression for optimization; thus, it is a constructive proof. This algorithm works basically like one of the methods for translating a QUEL-like relational query into relational algebra <ref> [Kort91] </ref>: everything in the retrieval list is combined using either joins or cross-products, then the criteria of the 115 "where" clause are applied, then the actual information desired is "projected" to form the final result. <p> These transformations capture those of the relational and multiset algebras from the literature <ref> [Ullm82, Ullm89, Kort91, Knut81] </ref> as well as most transformations described for more advanced data models [Beer90, Scho86]. We do not claim that this list is complete, but we believe that it is either complete or very close to complete. The rules are presented without proof. <p> In addition, any conjunct may be negated. The TUP_CAT is necessary because the result of is a set or ordered pairs. Here we use "field1" as a shorthand for TUP_EXTRACT field1 (INPUT), etc. This kind of join follows the definitions of <ref> [Kort91] </ref>. An equi-join-like operator is obtained by restricting Q to be f 1 2 f = f , where the f i are of the form TUP_EXTRACT j (INPUT).
Reference: [Knut81] <author> D. Knuth, </author> <booktitle> The Art of Computer Programming, Volume 2: Seminumerical Algorithms, 2nd edition, </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1981. </year>
Reference-contexts: Null values are treated as constants unless specified otherwise. Each operator of the algebra takes one or two structures as input and produces a single, entirely new structure as output. 103 5.2.1. Multiset Operations A multiset <ref> [Knut81, Liu77] </ref> (also called a "bag" or "collection") is a set that allows a specific element to appear more than once in the set. Every existing object has an associated cardinality in every multiset S, referred to as card S (x), and card S (x) 0. <p> These transformations capture those of the relational and multiset algebras from the literature <ref> [Ullm82, Ullm89, Kort91, Knut81] </ref> as well as most transformations described for more advanced data models [Beer90, Scho86]. We do not claim that this list is complete, but we believe that it is either complete or very close to complete. The rules are presented without proof.
Reference: [Kupe85] <author> G. M. Kuper, </author> <title> "The Logical Data Model: A New Approach to Database Logic," </title> <type> PhD. Thesis, </type> <institution> Dept. of Computer Science, Stanford University, Stanford, </institution> <address> CA, </address> <month> Sept. </month> <year> 1985. </year>
Reference-contexts: These features make algebraic specification desirable for a data model/retrieval language. In recent years it has become apparent that the relational model is not always the right choice for a particular application [Kent79, Care88a, Schw86], and many new data models have been proposed <ref> [Abit88b, Lecl87, Fish87, Maie86c, Bane87, Mano86, Roth88, Sche86, Kupe85, Abit88a] </ref>. <p> To put these department names into a set-valued attribute, we would use the P operator as follows: P Dept (Emp) For each (Name, Salary) pair we will now have a set of Dept attributes. 2.3.3. The LDM Algebra The Logical Data Model (LDM <ref> [Kupe85] </ref>) is an extended complex object model which uses surrogates to refer to every object in the database (and in that sense it is an object-oriented model -- everything is an object). Objects are built recursively from scalars, sets, tuples, and the union type constructor. <p> Even leaf nodes of the schema graph can contain more than one surrogate. The following operators are allowed on objects conforming to an LDM schema (we present the algebra as defined in <ref> [Kupe85] </ref>): 1) Copying (`): This operator takes either a scalar schema graph node or a simple constant (not yet placed into any actual LDM schema graph node) as input. <p> The LDM algebra <ref> [Kupe85] </ref> forces object identity on everything in the database. A new approach for processing queries involving overridden methods is proposed. <p> An algebra that operates on ordered nested relations (plus tuple-valued attributes and ordered sets of scalars) was proposed in [Guti89]. The ALGRES algebra [Ceri87] is similar but it also supports a least fixpoint operation and unordered relations. Object identity was added to complex structures in the LDM algebra <ref> [Kupe85] </ref> and in IQL [Abit89]. Finally, the algebraic approach has also been extended to cover temporal databases [Tans89, Clif85]. Algebraic transformation rules for the relational algebra can be found in [Ullm89]. [Scho86] presents such rules for the nested relational model. <p> A database is defined as a multiset of structures. A structure is an ordered pair (S, I), where S is a schema and I is an instance. Schemas are digraphs (as in LDM <ref> [Kupe85] </ref>) whose nodes represent type constructors and whose edges represent a "component-of" relationship. That is, an edge from A to B signifies that B is a component of A.
Reference: [Land91] <author> E. Lander, R. Langridge, and D. Saccocio, </author> <title> "Mapping and Interpreting Biological Information", </title> <type> CACM 34, </type> <year> 1991. </year>
Reference-contexts: Ordered Types in AQUA Lately there has been a lot of interest in bulk types like lists, trees, and graphs that are not supported by traditional data models and query algebras. This interest is fueled by the fact that much data in the scientific domain is inherently ordered <ref> [Fren90, Fren91, Land91] </ref>. Scientific applications have a need to store ordered types such as time-series data and genome sequences, and textual databases often store information that is structured as a tree. These applications store huge volumes of data and must locate information from these structures very efficiently.
Reference: [Lecl87] <author> C. Lecluse, P. Richard, and F. Velez, </author> <title> "O 2 , an Object-Oriented Data Model," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Chicago, IL, </address> <year> 1988. </year>
Reference-contexts: These features make algebraic specification desirable for a data model/retrieval language. In recent years it has become apparent that the relational model is not always the right choice for a particular application [Kent79, Care88a, Schw86], and many new data models have been proposed <ref> [Abit88b, Lecl87, Fish87, Maie86c, Bane87, Mano86, Roth88, Sche86, Kupe85, Abit88a] </ref>. <p> While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Banc88, Lecl87, Horn87, Andr87, Bane87, Maie86c] </ref>, and several flavors of object-oriented models have been identified [Ditt86]. <p> Sets of base types, constructed types, and reference types are all possible in EXTRA. This leads to a very powerful facility for modeling complex objects, as nested relations (ala NF 2 data models) can be supported via sets of tuples, and sets with shared subobjects (ala <ref> [Bane87, Lecl87] </ref>) can be supported via sets of references. As an example, Figure 4.5 shows the definition for the Department type and the creation of a persistent set (Departments) of objects of this type. <p> As we will see in the next section, despite their semantic differences, own, ref, and own ref attributes are all treated uniformly in the EXCESS query language for query simplicity. Thus, casual users can ignore the distinction, viewing attributes simply as other objects, as in most object-oriented data models <ref> [Lecl87, Horn87, Andr87, Bane87, Maie86c] </ref>. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 Note: All objects must have a "home" as an own ref component of some other object in order to exist in the database. Named, persistent, top-level objects are automatically made own ref components of the database in which they are created. <p> EXTRA separates the notions of type and instance; thus, users can collect related objects together in semantically meaningful sets and arrays, which can then be queried, rather than having to settle for queries over type extents as in many data models (e.g., <ref> [Ship81, Bane87, Lecl87, Mylo80, Rowe87] </ref>). EXTRA provides tuple, set, fixed-length array, and variable-length array as type constructors. In addition, there are three kinds of values, own, ref, and own ref (although casual users such as query writers need not be concerned with this distinction).
Reference: [Leun93] <author> T. Leung, G. Mitchell, B. Subramanian, B. Vance, S. Vandenberg, and S. Zdonik, </author> <title> "The AQUA Data Model and Algebra", </title> <booktitle> Fourth International Workshop on Database Programming Languages, </booktitle> <address> New York, New York, </address> <year> 1993, </year> <note> to appear. </note>
Reference-contexts: It also does not support several of the constructs of EXTRA/EXCESS, such as references and grouping. 3.2.2. The AQUA Algebra Here we address only the features of AQUA that are most relevant to the contributions of this thesis. One of the primary goals of AQUA <ref> [Leun93] </ref> is to provide a model general enough to simulate the constructs of any object-oriented data model (and most value-oriented models), no matter what choices it makes with respect to certain features (bulk types, encapsulation, identity versus value, notions of equality, inheritance, and operations). <p> In this approach, lists, arrays, and trees can all be defined, and a subset of the useful operations on such structures is described in the paper. These operations include a ``pump'' function, which is similar to AQUA's fold operation <ref> [Leun93] </ref>. Since the operations described in [Beer90] are intended to be applicable to any bulk type, not just to lists and trees, they are too general for our purposes -- we wish to distinguish between ordered and unordered types, and we provide a richer set of operations. <p> In the following subsections we describe the AQUA model and type system, AQUA's approach to modeling abstraction, its support for multiple definitions of equality, and operators and techniques for processing queries over tree-structured objects. 129 6.1. The AQUA Model and Type System AQUA <ref> [Leun93] </ref> is based on an object-oriented data model. All objects have identity, and these identities allow us to distinguish between objects using identity-based equality. AQUA is closed in the sense that all of its operators return objects that are defined in the model. <p> The rules provide valuable optimizations for object-oriented queries and the proof provides a complete semantics for EXCESS queries as well as an algorithm for translating an EXCESS query into the algebra. Clearly, the algebra is closed. The AQUA data model and algebra has been proposed <ref> [Leun93] </ref> as an input language for object-oriented query optimizers. It has been designed to cover the functionality of many existing query languages, and to provide the maximum potential for optimization. AQUA supports abstraction, varying notions of equality among objects, and 163 ordered type constructors (e.g. trees).
Reference: [Liu77] <author> C. L. Liu, </author> <title> Elements of Discrete Mathematics, </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1977. </year>
Reference-contexts: Null values are treated as constants unless specified otherwise. Each operator of the algebra takes one or two structures as input and produces a single, entirely new structure as output. 103 5.2.1. Multiset Operations A multiset <ref> [Knut81, Liu77] </ref> (also called a "bag" or "collection") is a set that allows a specific element to appear more than once in the set. Every existing object has an associated cardinality in every multiset S, referred to as card S (x), and card S (x) 0.
Reference: [Lohm83] <author> G. Lohman, J. Stoltzfus, A. Benson, M. Martin, and A. Cardenas, </author> <title> "Remotely-Sensed Geophysical Databases: Experience and Implications for Generalized DBMS," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> San Jose, CA, </address> <year> 1983. </year>
Reference-contexts: This makes it possible for a database to include more than one collection of instances of a given type, which can be quite useful in scientific and engineering applications <ref> [Lohm83, Kemp87] </ref>. While this separation is common in programming languages, it is less common in the database world [Bloo87]. As an example, the commands in Figure 4.1 define a new schema type called Person, which is a tuple type.
Reference: [Maie86a] <author> D. Maier, </author> <title> "A Logic for Objects," </title> <type> Tech. Report CS/E-86-012, </type> <institution> Oregon Grad. Center, Beaverton, Oregon, </institution> <month> Nov. </month> <year> 1986. </year>
Reference-contexts: In addition, several "generic" algebras for non-relational systems have been proposed. These are not geared toward any particular system or implementation. (It should be mentioned that several calculi for objects with complex structure have been defined; some notable ones are found in <ref> [Banc86, Maie86a, Abit88a] </ref>.) In the following sections we describe the basic concepts and operations of these algebras, regardless of their connections with actual systems.
Reference: [Maie86b] <author> D. Maier and J. Stein, </author> <title> "Indexing in an Object-Oriented DBMS," </title> <type> Tech. Report CS/E-86-006, </type> <institution> Oregon Grad. Center, Beaverton, Oregon, </institution> <month> May </month> <year> 1986. </year>
Reference-contexts: of Figure 4.6) we define the following method that returns the social security number of an Employee's kid with name "kname": define Employee function get_ssnum (kname: char []) returns int4 ( retrieve (this.kids.ssnum) where (this.kids.name = kname) ) we may be able to take advantage of indices or cached attributes <ref> [Maie86b, Shek89] </ref> if a particular Employee (or set of Employees) has such enhancements. This also allows for transformations that involve nodes in the stored query tree interacting with nodes in the invoking query tree; some examples of this can be found in [Beer90].
Reference: [Maie86c] <author> D. Maier, J. Stein, A. Otis, and A. Purdy, </author> <title> "Development of an Object-Oriented DBMS," </title> <booktitle> Proc. 1st OOPSLA Conf., </booktitle> <address> Portland, OR, </address> <year> 1986. </year> <month> 192 </month>
Reference-contexts: These features make algebraic specification desirable for a data model/retrieval language. In recent years it has become apparent that the relational model is not always the right choice for a particular application [Kent79, Care88a, Schw86], and many new data models have been proposed <ref> [Abit88b, Lecl87, Fish87, Maie86c, Bane87, Mano86, Roth88, Sche86, Kupe85, Abit88a] </ref>. <p> While a number of new data models have been proposed in the past few years, there appears to be no consensus on the horizon. A number of database researchers seem to believe that object-oriented database systems are the future <ref> [Fish87, Khos87, Banc88, Lecl87, Horn87, Andr87, Bane87, Maie86c] </ref>, and several flavors of object-oriented models have been identified [Ditt86]. <p> and querying functionality of object-oriented and other advanced systems. 1 The result is a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models [Dada86, Sche86], DAPLEX [Ship81], ORION [Bane87], Trellis/Owl [Scha86], O 2 [Banc88], STDM [Cope84], and STDM's descendant, GemStone <ref> [Maie86c] </ref>. <p> EXTRA and EXCESS are described fully in Chapter 4. The EXTRA data model and EXCESS query language designs represent a synthesis and extension of ideas drawn from a number of other data models. The data structuring facilities of the EXTRA data model are probably closest to those of GemStone <ref> [Maie86c] </ref>, as GemStone provides both tuple and array constructors, and data is organized into user-maintained extents rather than system-maintained type extents. <p> Non-determinism is also present in [Abit90], which describes a witness operator which operates in a logical (rather than an algebraic) setting and creates a set of possible interpretations of a formula, resulting in non-determinism. Most ``pure'' object-oriented models (such as <ref> [Gold83, Maie86c] </ref> and others) provide and enforce encapsulation of data types. In AQUA the notion of type is more general: not everything is forced to be of an encapsulated, abstract data type whose only interface is that provided by the definer of the type. <p> As we will see in the next section, despite their semantic differences, own, ref, and own ref attributes are all treated uniformly in the EXCESS query language for query simplicity. Thus, casual users can ignore the distinction, viewing attributes simply as other objects, as in most object-oriented data models <ref> [Lecl87, Horn87, Andr87, Bane87, Maie86c] </ref>. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 Note: All objects must have a "home" as an own ref component of some other object in order to exist in the database. Named, persistent, top-level objects are automatically made own ref components of the database in which they are created.
Reference: [Maki77] <author> A. Makinouchi, </author> <title> "A Consideration on Normal Form of Not-Necessarily-Normalized Relations in the Relational Data Model", </title> <booktitle> Proc. VLDB Conf., </booktitle> <address> Tokyo, Japan, </address> <year> 1977. </year>
Reference-contexts: In 1970 Codd proposed the relational data model and algebra [Codd70]. Informally, a relational system models all data as 2-dimensional tables of values. These tables are manipulated using the five operators of the relational algebra. In 1977, Makinouchi <ref> [Maki77] </ref> proposed eliminating the flat 2-dimensional restriction, resulting in a body of work on non-first normal form (NF 2 ) relational models (also called nested relational models). These models allow values in a relation to be either scalars (as in the relational model) or entire relations.
Reference: [Mano86] <author> F. Manola and U. Dayal, "PDM: </author> <title> An Object-Oriented Data Model," </title> <booktitle> Proc. Int'l. Workshop on Object-Oriented Database Sys., Asilomar, </booktitle> <address> CA, </address> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: These features make algebraic specification desirable for a data model/retrieval language. In recent years it has become apparent that the relational model is not always the right choice for a particular application [Kent79, Care88a, Schw86], and many new data models have been proposed <ref> [Abit88b, Lecl87, Fish87, Maie86c, Bane87, Mano86, Roth88, Sche86, Kupe85, Abit88a] </ref>. <p> One approach to dealing with complex objects (also known as "structural object-orientation" [Ditt86]) is to provide procedures as a data type [Ston87a]. Another approach is to permit relation-valued attributes [Dada86, Sche86]. A third approach is to take a functional view of data <ref> [Ship81, Mano86, Bato87] </ref>. In addition, a common theme among many of these efforts is to extend the database system's data definition facilities with support for some form of sub-typing. <p> There is no notion of "complex objects"; rather, the concepts associated with such objects are modeled using additional relations. 2.3.9.2. NF -Like and Other Algebras The PDM algebra was developed for use with the PROBE project at CCA <ref> [Mano86, Daya87] </ref>. The model is derived mainly from DAPLEX [Ship81], and it is object-based.
Reference: [Mits89] <author> B. Mitschang, </author> <title> "Extending the Relational Algebra to Capture Complex Objects", </title> <booktitle> Proc. VLDB Conf., </booktitle> <address> Amsterdam, The Netherlands, </address> <year> 1989. </year>
Reference-contexts: Its operators are renaming, insertion (replace a terminal with a non-terminal), deletion (inverse of insertion), copy ing, and permutation. No expressivity or complexity results exist for this model yet. The MAD (Molecule-Atom Data Model) algebra described in <ref> [Mits89] </ref> has some interesting features. The model consists of "atoms", corresponding to real-world entities, and "molecules", corresponding to collections of atoms related by "links". Links between atoms are preserved (to the extent possible) during query processing.
Reference: [Mylo80] <author> J. Mylopoulos, P. Bernstein, and H. Wong, </author> <title> "A Language Facility for Designing Database-Intensive Applications", </title> <journal> ACM TODS 5(2), </journal> <month> June </month> <year> 1980. </year>
Reference-contexts: EXTRA separates the notions of type and instance; thus, users can collect related objects together in semantically meaningful sets and arrays, which can then be queried, rather than having to settle for queries over type extents as in many data models (e.g., <ref> [Ship81, Bane87, Lecl87, Mylo80, Rowe87] </ref>). EXTRA provides tuple, set, fixed-length array, and variable-length array as type constructors. In addition, there are three kinds of values, own, ref, and own ref (although casual users such as query writers need not be concerned with this distinction).
Reference: [Nixo87] <author> B. Nixon, L. Chung, D. Lauzon, A. Borgida, J. Mylopoulos, and M. Stanley, </author> <title> "Implementation of a Compiler for a Semantic Data Model: Experiences with TAXIS," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> San Francisco, CA, </address> <year> 1987. </year>
Reference-contexts: Figure 4.3 shows how this conflict can be resolved via renaming. POSTGRES would ignore this conflict because the conflicting dept attributes are of the same data type [Rowe87], while TAXIS would simply disallow the conflict <ref> [Nixo87] </ref>. EXTRA is closest to ORION [Bane87] in its handling of conflicts, except that we provide no automatic resolution.
Reference: [Ong84] <author> J. Ong, D. Fogg, and M. Stonebraker, </author> <title> "Implementation of Data Abstraction in the Relational Database System INGRES," </title> <booktitle> SIGMOD Record 14(1), </booktitle> <month> March </month> <year> 1984. </year>
Reference-contexts: Also, EXCESS provides a cleaner treatment of arrays than we have seen elsewhere. The only point for comparison here is POSTQUEL, which only operates on one-dimensional arrays of base types. Finally, ADT and access method extensibility in EXTRA/EXCESS were heavily influenced by the work of Stonebraker <ref> [Ong84, Ston86] </ref> and the resulting extension facilities in POSTGRES [Ston87b]. Our work here differs mostly in minor respects. Because ADTs in our system are written E, the system's internal language, adding ADTs is perhaps simpler here. <p> Since some users may prefer a more symmetric function call syntax, EXCESS will also accept this expression in the form "Add (CnumPair.val1, CnumPair.val2)". In addition to supporting standard ADT function invocation, we follow the lead of <ref> [Ong84, Ston86, Ston87b] </ref> and support the registration of operators as an alternative function invocation syntax.
Reference: [Osbo88] <author> S. Osborn, </author> <title> "Identity, Equality, and Query Optimization", in Advances in Object-Oriented Database Systems, </title> <editor> ed. K. Dittrich, </editor> <booktitle> Lecture Notes in Computer Science no. </booktitle> <volume> 334, </volume> <publisher> Springer-Verlag, </publisher> <address> Berlin, Germany, </address> <year> 1988. </year>
Reference-contexts: Also, these top-level sets (and top-level multisets) contain only OIDs. Query results are collections of an existing type or of a tuple type constructed during the query. Some relational-like query optimization techniques are also presented in [Shaw90]. 51 2.3.7. An Object-Oriented Database Algebra <ref> [Osbo88] </ref> describes an object-oriented data model and algebra. Structurally, the model supports scalar values and the tuple and set type constructors, as well as inheritance among tuple types. One important extension, though, is that sets need not be homogeneous. <p> Otherwise the result is obj if Pred applied to obj is true 52 and null if it is false. Several algebraic transformation rules are given in <ref> [Osbo88] </ref>. An interesting consideration is whether one wants to allow transformations that preserve equality or only those that preserve identity as well. [Osbo88] also states that the expressive power of the algebra is somewhat limited, as it can not simulate the nest and unnest operators of the NF 2 algebras, nor <p> Otherwise the result is obj if Pred applied to obj is true 52 and null if it is false. Several algebraic transformation rules are given in <ref> [Osbo88] </ref>. An interesting consideration is whether one wants to allow transformations that preserve equality or only those that preserve identity as well. [Osbo88] also states that the expressive power of the algebra is somewhat limited, as it can not simulate the nest and unnest operators of the NF 2 algebras, nor can it do, for example, general transitive closures. <p> This treatment also enables the algebra to be defined using only one form of equality, instead of one form for OIDs and one for values, as is done in <ref> [Shaw90, Osbo88] </ref>. [Abit89] defines two separate languages, one enforcing object identity and one not supporting it at all, but we mix the two semantics in a single algebraic language, and we give references the status of a type constructor with the same privileges as the multiset, array, and tuple constructors. <p> Finally, the algebraic approach has also been extended to cover temporal databases [Tans89, Clif85]. Algebraic transformation rules for the relational algebra can be found in [Ullm89]. [Scho86] presents such rules for the nested relational model. Some rules for complex object models with identity are proposed in <ref> [Osbo88, Shaw90] </ref>; these rules are mainly straightforward extensions of relational or nested relational transformation rules. 67 Finally, [Beer90] proposes a meta-level algebra for collections of complex objects with identity and includes some transformation rules that go beyond what is done in the relational model. <p> Duplicate elimination for both sets and multisets, as defined in AQUA, is original. AQUA's dup_elim can be thought of as a generalization of other duplicate elimination operators (e.g. that of ENCORE/EQUAL [Shaw90]). A set-theoretic choose operator appears in the algebras of Osborne and MDM <ref> [Osbo88, Rich92] </ref>. Non-determinism is also present in [Abit90], which describes a witness operator which operates in a logical (rather than an algebraic) setting and creates a set of possible interpretations of a formula, resulting in non-determinism. <p> That is, a predicate is an operation (called COMP) which returns its (unmodified) input exactly when the predicate is satisfied (true). Otherwise a null value is returned. COMP is a partial function. (Similar approaches are taken in <ref> [Osbo88, Abit88a] </ref>.) Comparisons (COMP): This operator takes a single structure as input and compares it to an arbitrary algebraic predicate using one of a fixed set of comparators.
Reference: [Ozso87] <author> G. Ozsoyoglu, Z. Ozsoyoglu, and V. Matos, </author> <title> "Extending Relational Algebra and Relational Calculus with Set-Valued Attributes and Aggregate Functions," </title> <journal> ACM TODS 12(4), </journal> <month> Dec. </month> <year> 1987. </year>
Reference-contexts: The projection is performed after the aggregate and keeps only the second and fourth columns of the result of the aggregate. 42 2.3.2. The Summary Table Algebra The algebra for summary tables <ref> [Ozso83, Ozso87] </ref> is basically an extension of Klug's algebra for aggregates (described in the previous section) to handle set-valued attributes. The domain of interest is thus relations that have both scalar fields and fields that are sets of scalars. <p> Thus new levels are not created when X is already a set-valued attribute. This is the difference between P and n. Three more non-fundamental operators are also defined in <ref> [Ozso87] </ref>. The Q-join and selection are defined as a cross-product followed by a restriction. A join is defined only if the join attributes are Q-compatible; thus either both attributes are scalar or both are set-valued or Q is . <p> The elements of another relation direct (i.e. form a template for) this grouping; we 43 do not go into the details here. An equivalent calculus has been defined for the summary table algebra <ref> [Ozso87] </ref>. Like the algebra, it is an extension of the calculus defined in [Klug82]. It should also be noted that the aggregates operate only on a single scalar column and that the result of applying an aggregate to an empty set is null, which here means "does not exist". <p> The relational algebra was followed by algebras for nested (non-first normal form) relations [Abit86, Roth88, Sche86, Aris83, Colb89, Desh87, Fisc83, Jaes82b]. This model is an extension of the relational model which allows both scalar- and relation-valued attributes. Algebras for integrating set-valued fields <ref> [Ozso87] </ref> and aggregates [Ozso87, Klug82] into the relational model have also been designed. All of these algebras are direct extensions of the relational algebra. <p> The relational algebra was followed by algebras for nested (non-first normal form) relations [Abit86, Roth88, Sche86, Aris83, Colb89, Desh87, Fisc83, Jaes82b]. This model is an extension of the relational model which allows both scalar- and relation-valued attributes. Algebras for integrating set-valued fields [Ozso87] and aggregates <ref> [Ozso87, Klug82] </ref> into the relational model have also been designed. All of these algebras are direct extensions of the relational algebra.
Reference: [Ozso83] <author> Z. Ozsoyoglu and M. Ozsoyoglu, </author> <title> "An Extension of Relational Algebra for Summary Tables," </title> <booktitle> Proc. 2nd Intl. Workshop on Statistical Database Mgmt., </booktitle> <institution> Lawrence Berkeley Labs., Univ. of California, Berkeley, </institution> <year> 1983. </year>
Reference-contexts: The projection is performed after the aggregate and keeps only the second and fourth columns of the result of the aggregate. 42 2.3.2. The Summary Table Algebra The algebra for summary tables <ref> [Ozso83, Ozso87] </ref> is basically an extension of Klug's algebra for aggregates (described in the previous section) to handle set-valued attributes. The domain of interest is thus relations that have both scalar fields and fields that are sets of scalars. <p> An alternate historical algebra is presented in the same paper; this algebra supports the aggregate formation operator as described in <ref> [Klug82, Ozso83] </ref> and the pack and unpack operators as described in [Ozso83]. For this algebra, the fundamental operators (in addition to the relational operators) are pack, unpack, and two operators which convert time-varying attributes into regular attributes and vice-versa. <p> An alternate historical algebra is presented in the same paper; this algebra supports the aggregate formation operator as described in [Klug82, Ozso83] and the pack and unpack operators as described in <ref> [Ozso83] </ref>. For this algebra, the fundamental operators (in addition to the relational operators) are pack, unpack, and two operators which convert time-varying attributes into regular attributes and vice-versa. An interesting algebra for the relational model with duplicates appears in [Daya82].
Reference: [Pare88] <author> J. Paredaens and D. Van Gucht, </author> <title> "Possibilities and Limitations of Using Flat Operators in Nested Algebra Expressions," </title> <booktitle> Proc. ACM PODS Conf., </booktitle> <year> 1988. </year>
Reference-contexts: As the discussion moves beyond NF 2 models and systems, the implementation status and examples will largely be omitted. We will not discuss the relative power of the underlying data models, exhaustive sets of algebraic equivalence rules, or other theoretical language issues. Many of these issues are covered in <ref> [Pare88, VanG87, VanG86, Hull87, Hull89a, Chan88] </ref>. The purpose of this survey is to convey some idea of the general nature of database algebras in 9 the hope of gaining some insight into why certain operations exist and of identifying common themes among these algebras.
Reference: [Pare85] <author> C. Parent and S. Spaccapietra, </author> <title> "An Algebra for a General Entity-Relationship Model," </title> <journal> IEEE Trans. Software Eng. </journal> <volume> 11(7), </volume> <month> July </month> <year> 1985. </year>
Reference-contexts: An interesting algebra for the relational model with duplicates appears in [Daya82]. This algebra redefines the set-theoretic operations to be the corresponding multiset-theoretic operations and adds a duplicate elimination operator. It also includes the (redundant) multiset intersection operator. In <ref> [Pare85] </ref> an algebra for Entity-Relationship [Chen76] databases is presented. Its operations include a relationship join (similar to an outer join) to build results based on stored relationships, Cartesian product (defined as in the VERSO algebra), selection, duplicate elimination, renaming, union, intersection, and difference.
Reference: [Pist86] <author> P. Pistor and F. Andersen, </author> <title> "Designing a Generalized NF2 Model with an SQL-Type Language Interface," </title> <booktitle> Proc. VLDB Conf., </booktitle> <address> Kyoto, Japan, </address> <month> Aug. </month> <year> 1986. </year>
Reference-contexts: Also note that we chose to call the result "num_pgs", but we could have called it anything. Currently, a prototype implementation of DASDBS is running and several geographical and bibliographic systems have been implemented on top of the kernel. 2.2.2. The AIM Algebra The AIM project at IBM-Heidelberg <ref> [Dada86, Pist86, Jaes85a] </ref> is designed to handle an extension of the NF 2 data model, with the goal of supporting non-traditional database applications. The major extension is the ability to handle ordered lists (arrays), multisets, and tuple-valued attributes.
Reference: [Rich92] <author> J. Richardson, </author> <title> "Supporting Lists in a Data Model (A Timely Approach)", </title> <booktitle> Proc. VLDB Conf., </booktitle> <address> Vancouver, Canada, </address> <year> 1992. </year>
Reference-contexts: These operations hide the looping structure that would be present in an algorithm that executes them. By and large, these operations have been confined to manipulations on sets. While there has been some recent work on extending query languages to other bulk types like sequences <ref> [Rich92] </ref>, additional research is needed. Thus AQUA provides support for the ordered data types graph, tree, and list. The results presented in Chapter 6 are some of my individual contributions to AQUA. 1.2. <p> Duplicate elimination for both sets and multisets, as defined in AQUA, is original. AQUA's dup_elim can be thought of as a generalization of other duplicate elimination operators (e.g. that of ENCORE/EQUAL [Shaw90]). A set-theoretic choose operator appears in the algebras of Osborne and MDM <ref> [Osbo88, Rich92] </ref>. Non-determinism is also present in [Abit90], which describes a witness operator which operates in a logical (rather than an algebraic) setting and creates a set of possible interpretations of a formula, resulting in non-determinism.
Reference: [Rich87] <author> J. Richardson and M. Carey, </author> <title> "Programming Constructs for Database System Implementation in EXODUS," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> San Francisco, CA, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: We distinguish between these two kinds of type extensions because of the different facilities that are provided for implementing them: ADTs are written in the E programming language <ref> [Rich87] </ref>, using the type system and general-purpose programming facilities provided by E. Schema types are created using the type system provided by the EXTRA data model and the higher-level but more restrictive programming facilities offered by the EXCESS query language. <p> extends C++ with a number of features to aid programmers in data 89 base system programming, including "dbclasses" for persistent storage, class generators for implementing "generic" classes and functions, iterators for use as a control abstraction in writing set operations, and built-in class generators for typed files and variable-length arrays <ref> [Rich87] </ref>. Suppose that we wanted to add complex number as a new ADT. First, we would need to implement the ADT as a dbclass (much like a C++ class) in E. Figure 4.7 gives a slightly simplified E interface definition for the Complex dbclass. <p> In particular, one could introduce a "median" aggregate function for sets of integers, but not one that works for any totally ordered type [Ston87b]. The EXCESS approach to such extensions is based on features provided by the E programming language <ref> [Rich87] </ref>. E provides a facility for writing generic functions, and it supports the specification of constraints on the generic type (e.g., any type that has boolean "less_than" and "equals" member functions). <p> Here we outline what was completed and present a brief critique of the EXODUS optimizer generator. An algorithm for step (1) was implemented in the E programming language <ref> [Rich87] </ref>. It is based on the equipollence proof presented in Appendix B. Steps (3) and (4) were partially implemented. The difficult part of the implementation is the production of a working optimizer using the optimizer generator.
Reference: [Rich91] <author> J. Richardson and P. Schwarz, </author> <title> "MDM: An object-oriented data model", in Bulk Types & Persistent Data: </title> <booktitle> The Third International Workshop on Database Programming Languages, </booktitle> <editor> ed. P. Kanellakis and J. Schmidt, Naf-plion, </editor> <address> Greece, </address> <publisher> Morgan Kaufmann, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: Many models (e.g. MDM <ref> [Rich91] </ref>) do not have this flexibility. The AQUA approach to this problem is closely related to duplicate elimination and non-determinism, as shall be seen. Duplicate elimination for both sets and multisets, as defined in AQUA, is original.
Reference: [Ritt87] <author> G. X. Ritter and J. N. Wilson, </author> <title> "Image Algebra: A Unified Approach to Image Processing", </title> <booktitle> Proc. SPIE Medical Imaging Conf., </booktitle> <address> Newport Beach, CA, </address> <month> February </month> <year> 1987. </year>
Reference-contexts: Attributes for which this property is desired must be singled out as 60 dynamic so that the expansion operator can make use of information about the possible domains of that attribute at run-time. Finally, we mention an algebra defined to operate on the domain of images <ref> [Ritt87] </ref>. This algebra demonstrates the utility of the algebraic paradigm outside of the standard data models found in the usual DBMS literature, giving further evidence of the universality of the approach. In this algebra, the objects to operated upon are real-valued images (elements of R n for some n).
Reference: [Ross92] <author> P. Ross, </author> <title> "Bulk Data Types: A Theoretical Approach", </title> <type> MSc Thesis, </type> <institution> Computer Science Department, Hebrew University, Jerusalem, Israel, </institution> <month> September </month> <year> 1992. </year>
Reference-contexts: Furthermore, many of their operations are not described precisely, the existence of certain other operations is assumed, and they do not have any operations like the ones we propose. <ref> [Ross92] </ref> extends [Beer90] by providing precise conversion operations between various bulk types and transformation rules involving the pump and aggregation operators on trees. We develop a notation for expressing patterns in trees based on results presented in [That68, Done70]. 3.2.3.
Reference: [Roth87] <author> M. Roth, H. Korth, and D. Batory, "SQL/NF: </author> <title> A Query Language for 1NF Relational Databases," </title> <journal> Inform. Systems 12(1), </journal> <year> 1987. </year>
Reference-contexts: The same is true for the second UNNEST of the first example but not the first UNNEST of that example. 2.2.4. The SQL/NF Algebra SQL/NF <ref> [Roth87, Roth88] </ref> is an extension of the SQL relational query language to handle non-first normal form relations. SQL/NF makes some other improvements and adjustments to SQL as well, but we do not describe these here.
Reference: [Roth88] <author> M. Roth, H. Korth, and A. Silberschatz, </author> <title> "Extended Algebra and Calculus for 1NF Relational Databases," </title> <journal> ACM TODS, </journal> <volume> 13(4), </volume> <month> December </month> <year> 1988. </year>
Reference-contexts: These features make algebraic specification desirable for a data model/retrieval language. In recent years it has become apparent that the relational model is not always the right choice for a particular application [Kent79, Care88a, Schw86], and many new data models have been proposed <ref> [Abit88b, Lecl87, Fish87, Maie86c, Bane87, Mano86, Roth88, Sche86, Kupe85, Abit88a] </ref>. <p> This equality holds iff a certain functional dependency holds on the relation: all non scalar fields must be functionally dependent on the set of scalar fields. This is known variously as Partitioned Nor mal Form (PNF) <ref> [Roth88, Desh87] </ref>, Nested Normal Form [Hull88], hierarchical structures, and the ability to provide a set-free denotation for set-valued objects [Hull88]. <p> The same is true for the second UNNEST of the first example but not the first UNNEST of that example. 2.2.4. The SQL/NF Algebra SQL/NF <ref> [Roth87, Roth88] </ref> is an extension of the SQL relational query language to handle non-first normal form relations. SQL/NF makes some other improvements and adjustments to SQL as well, but we do not describe these here. <p> One important restriction made in the SQL/NF algebra is the PNF restriction mentioned previously. This has an effect on how the operators are defined, as will be seen shortly. The set of operators for the algebra is as follows: 1) Select (s): <ref> [Roth88] </ref> claims not to extend the relational s operator, but their proofs use a s which is extended with the ability to specify set-valued constants. This is the notion of s we adopt here. <p> See Figure 2.11 for an example (Figure 2.11 is taken directly from <ref> [Roth88] </ref>). 26 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh d4 d3 d3 d2 d2 d2 d2 d2 d2 d2 d1 d1 d1 d1 c4 c3 c3 c2 c2 c2 c2 c1 c1 c1 c1 c1 c1 c1 D C Y B X A a4 a3 a2 a1a1 b4 b3 b3 b2 b2 b1 b1 b1 e b1 <p> In other words, for any particular instance of such an operator, it can be replaced by a sequence of these seven operators (but there is no such definition of them in the general case) <ref> [Roth88] </ref>. A formal calculus corresponding to the SQL/NF algebra has been defined [Roth88] and proved equivalent to the algebra. This calculus has been proved to be strictly more powerful than the given algebra unless one adds the P operator to the algebra. <p> In other words, for any particular instance of such an operator, it can be replaced by a sequence of these seven operators (but there is no such definition of them in the general case) <ref> [Roth88] </ref>. A formal calculus corresponding to the SQL/NF algebra has been defined [Roth88] and proved equivalent to the algebra. This calculus has been proved to be strictly more powerful than the given algebra unless one adds the P operator to the algebra. However, when we are restricted to the domain of PNF relations, as here, the algebra and calculus become equivalent. <p> Null values are not supported. No calculus has been defined to correspond specifically to this algebra, but, like with the other algebras, it is not hard to envisage an adaptation of the SQL/NF calculus <ref> [Roth88] </ref> to this algebra. It also shares with all of the previously defined algebras the characteristic of being value-based. There are no formal results on the expressive power of this algebra, but it almost certainly has the same expressive power as VERSO and SQL/NF, due to the PNF restriction. <p> This of course implies that the calculus of <ref> [Roth88] </ref> could also be adapted for use with the Waterloo algebra with only minor modifications (no calculus has been designed to correspond specifically to the Waterloo algebra). <p> There are some fairly clean and interesting results concerning the power of this algebra. For our purposes, it is most important to note that, when it is not restricted to PNF relations, it is equipollent to the NF 2 calculus of 39 <ref> [Roth88] </ref> (no calculus was defined specifically for the Powerset algebra). <p> The relational algebra was followed by algebras for nested (non-first normal form) relations <ref> [Abit86, Roth88, Sche86, Aris83, Colb89, Desh87, Fisc83, Jaes82b] </ref>. This model is an extension of the relational model which allows both scalar- and relation-valued attributes. Algebras for integrating set-valued fields [Ozso87] and aggregates [Ozso87, Klug82] into the relational model have also been designed. <p> The complete proof (presented in Appendix B) describes the details of how primary components are used to ensure the semantics 116 of EXCESS queries. ii) Reduction of algebra to EXCESS: The other direction of the proof is a traditional case-based inductive proof like those found in <ref> [Ullm89, Abit88a, Roth88] </ref>. We omit most of the cases of the inductive step as our goal here is simply to give a flavor of the proof and to demonstrate that the proof is straightforward, due mainly to the simplicity of the algebraic operators and their resemblance to constructs in EXCESS.
Reference: [Rowe87] <author> L. Rowe and M. Stonebraker, </author> <title> "The POSTGRES Data Model," </title> <booktitle> Proc. VLDB Conf., </booktitle> <address> Brighton, England, </address> <year> 1987. </year>
Reference-contexts: This thesis will address these issues, among others. Another direction in data model evolution, one which has spawned such efforts as <ref> [Codd79, Dada86, Sche86, Schw86, Rowe87] </ref>, is to extend the relational model in some way. <p> present the EXTRA data model and the associated EXCESS query language, which are intended to subsume much of the 3 modeling and querying functionality of object-oriented and other advanced systems. 1 The result is a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES <ref> [Rowe87] </ref>, NF 2 models [Dada86, Sche86], DAPLEX [Ship81], ORION [Bane87], Trellis/Owl [Scha86], O 2 [Banc88], STDM [Cope84], and STDM's descendant, GemStone [Maie86c]. <p> Since the original development of EXTRA/EXCESS, O 2 [Banc88] has adopted own and ref attributes. The EXCESS query language is related to those of DAPLEX [Ship81], GEM [Zani83], NF 2 systems [Dada86, Sche86], and POSTGRES <ref> [Rowe87] </ref>. Implicit joins were taken directly from GEM, and originated in DAPLEX. The EXCESS treatment of queries over nested sets is similar in flavor to that of NF 2 query languages, although the path syntax for handling deeply nested queries was influenced by DAPLEX and the early STDM paper [Cope84]. <p> Our handling of range variables was heavily influenced by that of POSTGRES <ref> [Rowe87] </ref>. In addition, EXCESS 64 goes beyond its predecessors in several respects. Our mix of object- and value-oriented semantics, again, was unique among query languages, until the introduction of certain constructs to the O 2 [Banc88] query language. <p> But AQUA does support such types, and does so using the ``abstraction'' type constructor, allowing any database object, encapsulated or not, to be described using a single uniform type system. This is similar to the ADT concept provided by POSTGRES <ref> [Rowe87] </ref> but much more general in the sense that any type definable in the AQUA type system can be abstracted into a true encapsulated type, and an abstraction in AQUA is a first-class citizen of the type system -- the abstraction constructor has the same status as any other constructor. <p> Figure 4.3 shows how this conflict can be resolved via renaming. POSTGRES would ignore this conflict because the conflicting dept attributes are of the same data type <ref> [Rowe87] </ref>, while TAXIS would simply disallow the conflict [Nixo87]. EXTRA is closest to ORION [Bane87] in its handling of conflicts, except that we provide no automatic resolution. <p> EXTRA separates the notions of type and instance; thus, users can collect related objects together in semantically meaningful sets and arrays, which can then be queried, rather than having to settle for queries over type extents as in many data models (e.g., <ref> [Ship81, Bane87, Lecl87, Mylo80, Rowe87] </ref>). EXTRA provides tuple, set, fixed-length array, and variable-length array as type constructors. In addition, there are three kinds of values, own, ref, and own ref (although casual users such as query writers need not be concerned with this distinction). <p> In this section we present the design of the EXCESS query language. While EXCESS is based on QUEL [Ston76], we have borrowed ideas from the QUEL extensions developed for GEM [Zani83] and POSTGRES <ref> [Rowe87, Ston87b] </ref> as well as work on SQL extensions for handling NF 2 data [Dada86, Sche86]. <p> Range Variables and Their Types EXCESS provides several different mechanisms for specifying the set of objects over which a variable is to range. Most are similar to the mechanisms of GEM [Zani83] and POSTQUEL <ref> [Rowe87] </ref>, but EXCESS also provides support for universal quantification (to simplify certain kinds of set queries). The simplest form of range statement has the traditional QUEL syntax, i.e., "range of &lt;Variable&gt; is &lt;Range_Specification&gt;". <p> The query aggre hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 5 Our scoping rules are similar to those of POSTQUEL <ref> [Rowe87] </ref>. 86 gates over Employee.kids, a set-valued attribute, and partitions the data using an attribute of Employee.dept, which is a single-valued reference attribute. <p> Every type is essentially an abstract data type -- however, the base types and all types built using the usual type constructors have a fixed set of standard operations available on them (e.g. join and union for sets). As mentioned in [Care88b] and <ref> [Rowe87] </ref>, it is often desirable to be able to add other methods to such types. In addition, it is frequently desirable 131 to specify a type whose representation is completely unknown to the data model of the DBMS.
Reference: [Scha86] <author> C. Schaffert, T. Cooper, B. Bullis, M. Kilian, and C. Wilpot, </author> <title> "An Introduction to Trellis/Owl," </title> <booktitle> Proc. 1st OOPSLA Conf., </booktitle> <address> Portland, OR, </address> <month> Sept. </month> <year> 1986. </year>
Reference-contexts: which are intended to subsume much of the 3 modeling and querying functionality of object-oriented and other advanced systems. 1 The result is a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models [Dada86, Sche86], DAPLEX [Ship81], ORION [Bane87], Trellis/Owl <ref> [Scha86] </ref>, O 2 [Banc88], STDM [Cope84], and STDM's descendant, GemStone [Maie86c].
Reference: [Sche85] <author> H.-J. Schek, </author> <title> "Towards a Basic Relational NF 2 Algebra Processor," </title> <booktitle> Proc. Int. Conf. on FODO, </booktitle> <address> Kyoto, Japan, </address> <year> 1985. </year>
Reference-contexts: The DASDBS Algebra The main feature of the DASDBS (Darmstadt Database System) <ref> [Sche85, Sche86, Scho86, Scho87a] </ref> is an application-independent kernel based on non-first normal form (NF 2 ) relations. (An NF 2 relation is one in which attribute values are not restricted to scalars--they can be relations (sets of tuples) as well.) Specific applications will hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii title author copies iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii publ_name num_pgs
Reference: [Sche86] <author> H.-J. Schek and M. Scholl, </author> <title> "The Relational Model with Relation-Valued Attributes," </title> <journal> Inform. Sys. </journal> <volume> 11(2), </volume> <year> 1986. </year> <month> 193 </month>
Reference-contexts: These features make algebraic specification desirable for a data model/retrieval language. In recent years it has become apparent that the relational model is not always the right choice for a particular application [Kent79, Care88a, Schw86], and many new data models have been proposed <ref> [Abit88b, Lecl87, Fish87, Maie86c, Bane87, Mano86, Roth88, Sche86, Kupe85, Abit88a] </ref>. <p> This thesis will address these issues, among others. Another direction in data model evolution, one which has spawned such efforts as <ref> [Codd79, Dada86, Sche86, Schw86, Rowe87] </ref>, is to extend the relational model in some way. <p> One approach to dealing with complex objects (also known as "structural object-orientation" [Ditt86]) is to provide procedures as a data type [Ston87a]. Another approach is to permit relation-valued attributes <ref> [Dada86, Sche86] </ref>. A third approach is to take a functional view of data [Ship81, Mano86, Bato87]. In addition, a common theme among many of these efforts is to extend the database system's data definition facilities with support for some form of sub-typing. <p> model and the associated EXCESS query language, which are intended to subsume much of the 3 modeling and querying functionality of object-oriented and other advanced systems. 1 The result is a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models <ref> [Dada86, Sche86] </ref>, DAPLEX [Ship81], ORION [Bane87], Trellis/Owl [Scha86], O 2 [Banc88], STDM [Cope84], and STDM's descendant, GemStone [Maie86c]. <p> The DASDBS Algebra The main feature of the DASDBS (Darmstadt Database System) <ref> [Sche85, Sche86, Scho86, Scho87a] </ref> is an application-independent kernel based on non-first normal form (NF 2 ) relations. (An NF 2 relation is one in which attribute values are not restricted to scalars--they can be relations (sets of tuples) as well.) Specific applications will hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii title author copies iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii publ_name num_pgs <p> This is essentially the same as the DASDBS <ref> [Sche86] </ref> s operator. 36 6) Cartesian Product (): This is defined exactly as in the relational algebra. 7) Nest (n): This is defined just as in the DASDBS and AIM algebras, with the exception that at least one of the attributes not being nested must be scalar to help ensure the <p> Since the original development of EXTRA/EXCESS, O 2 [Banc88] has adopted own and ref attributes. The EXCESS query language is related to those of DAPLEX [Ship81], GEM [Zani83], NF 2 systems <ref> [Dada86, Sche86] </ref>, and POSTGRES [Rowe87]. Implicit joins were taken directly from GEM, and originated in DAPLEX. <p> The relational algebra was followed by algebras for nested (non-first normal form) relations <ref> [Abit86, Roth88, Sche86, Aris83, Colb89, Desh87, Fisc83, Jaes82b] </ref>. This model is an extension of the relational model which allows both scalar- and relation-valued attributes. Algebras for integrating set-valued fields [Ozso87] and aggregates [Ozso87, Klug82] into the relational model have also been designed. <p> In addition, if an employee is deleted, so are his or her kids. This provides a capability very similar to that provided by NF data models <ref> [Dada86, Sche86] </ref>. If the kids attribute were instead declared to be of type "- own ref Person -", the deletion semantics would be the same, but children could then be referenced from elsewhere in the database (by ref attributes of other objects). <p> In this section we present the design of the EXCESS query language. While EXCESS is based on QUEL [Ston76], we have borrowed ideas from the QUEL extensions developed for GEM [Zani83] and POSTGRES [Rowe87, Ston87b] as well as work on SQL extensions for handling NF 2 data <ref> [Dada86, Sche86] </ref>.
Reference: [Scho86] <author> M. H. Scholl, </author> <title> "Theoretical Foundations of Algebraic Optimization Utilizing Unnormalized Relations," </title> <booktitle> Proc. Intl. Conf. Database Theory, </booktitle> <address> Rome, </address> <year> 1986. </year>
Reference-contexts: The DASDBS Algebra The main feature of the DASDBS (Darmstadt Database System) <ref> [Sche85, Sche86, Scho86, Scho87a] </ref> is an application-independent kernel based on non-first normal form (NF 2 ) relations. (An NF 2 relation is one in which attribute values are not restricted to scalars--they can be relations (sets of tuples) as well.) Specific applications will hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii title author copies iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii publ_name num_pgs <p> The first five operators are the standard operators needed for relational completeness. In <ref> [Scho86] </ref>, it is proved that some of these seven operators are actually redundant. A truly minimal subset need only consist of s, , m, and p. The use of s and p within selection formulae is also redundant. <p> Object identity was added to complex structures in the LDM algebra [Kupe85] and in IQL [Abit89]. Finally, the algebraic approach has also been extended to cover temporal databases [Tans89, Clif85]. Algebraic transformation rules for the relational algebra can be found in [Ullm89]. <ref> [Scho86] </ref> presents such rules for the nested relational model. <p> These transformations capture those of the relational and multiset algebras from the literature [Ullm82, Ullm89, Kort91, Knut81] as well as most transformations described for more advanced data models <ref> [Beer90, Scho86] </ref>. We do not claim that this list is complete, but we believe that it is either complete or very close to complete. The rules are presented without proof. In most cases the proof is a straightforward application of the operator definitions. A.1.
Reference: [Scho87a] <author> M. H. Scholl, H.-B. Paul, and H.-J. Schek, </author> <title> "Supporting Flat Relations by a Nested Relational Kernel," </title> <booktitle> Proc. VLDB Conf, </booktitle> <address> Brighton, England, </address> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: The DASDBS Algebra The main feature of the DASDBS (Darmstadt Database System) <ref> [Sche85, Sche86, Scho86, Scho87a] </ref> is an application-independent kernel based on non-first normal form (NF 2 ) relations. (An NF 2 relation is one in which attribute values are not restricted to scalars--they can be relations (sets of tuples) as well.) Specific applications will hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii title author copies iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii publ_name num_pgs
Reference: [Scho87b] <author> M. H. Scholl and H.-J. Schek, eds., </author> <title> Theory and Applications of Nested Relations and Complex Objects: </title> <booktitle> An International Workshop, </booktitle> <address> Darmstadt, Germany, </address> <month> April </month> <year> 1987. </year>
Reference-contexts: That is, whenever the absence of PNF within a relation can cause a problem, the keying operator may be used to artificially impose PNF on the relation. However, there are no restrictions placed on the actual data in the database. Also, it has been observed <ref> [Scho87b] </ref> that the m operation can be modelled, optimally, using joins (we do not present the actual transformation here). <p> Existing relationships are "inherited" by the results of queries in the obvious manner. A similar algebra is defined for the 56 EXTREM data model <ref> [Scho87b] </ref>; the operations differ only in some details. EXTREM is a semantic data model implemented on top of a flat relational system and using some of the constructs of the IFO semantic data model [Abit88b]. Chen [Chen84] also proposed an algebra for the E/R model. <p> Ordered sets and multisets are also supported. Queries are actually executed over an INFORMIX relational database--that is, an ALGRES query is translated to a flat algebra expression before execution. ALGRES is a value-based system. SIRIUS is a distributed DBMS developed at INRIA <ref> [Scho87b] </ref>. It is designed to be a somewhat extended relational (value-based) system which uses an NF 2 model much in the same way that DASDBS does (i.e., as a vehicle upon which more sophisticated models may be developed). <p> In addition to the DASDBS-like NF 2 model, SIRIUS provides user-defined ADTs, derived attributes (as seen in R 2 ), null values, and full integrity constraint specification capabilities. Another extended algebra has been developed in the context of the ANNEX project at the University of Nice <ref> [Scho87b] </ref>. The algebra for their "B-Relational" data model includes the standard NF 2 extensions as found in the DASDBS and AIM algebras as well as support for semantic concepts such as generalization and association. <p> The algebra does not assume PNF. There are two more algebras which resemble the NF 2 algebra. The first is NTD (Nested Table Data model) <ref> [Scho87b] </ref>, which is an algebra for office forms; it has the same goals and domain of application as the algebra of [Guti89] discussed above. The NF 2D model (also described in [Scho87b]) is essentially the NF 2 model with the added ability to provide for schema evolution. <p> The first is NTD (Nested Table Data model) <ref> [Scho87b] </ref>, which is an algebra for office forms; it has the same goals and domain of application as the algebra of [Guti89] discussed above. The NF 2D model (also described in [Scho87b]) is essentially the NF 2 model with the added ability to provide for schema evolution. With this in mind, the description in [Scho87b] provides an expansion operator to alter the structure of attributes in the schema. This allows an attribute to change its structure dynamically without changing its meaning. <p> The NF 2D model (also described in <ref> [Scho87b] </ref>) is essentially the NF 2 model with the added ability to provide for schema evolution. With this in mind, the description in [Scho87b] provides an expansion operator to alter the structure of attributes in the schema. This allows an attribute to change its structure dynamically without changing its meaning.
Reference: [Schw86] <author> P. Schwarz, W. Chang, J. Freytag, G. Lohman, J. McPherson, C. Mohan, and H. Pirahesh, </author> <title> "Extensibility in the Starburst Database System," </title> <booktitle> Proc. Intl. Workshop on Object-Oriented Database Sys., </booktitle> <address> Pacific Grove, CA, </address> <month> Sep-tember </month> <year> 1986. </year>
Reference-contexts: These features make algebraic specification desirable for a data model/retrieval language. In recent years it has become apparent that the relational model is not always the right choice for a particular application <ref> [Kent79, Care88a, Schw86] </ref>, and many new data models have been proposed [Abit88b, Lecl87, Fish87, Maie86c, Bane87, Mano86, Roth88, Sche86, Kupe85, Abit88a]. <p> This thesis will address these issues, among others. Another direction in data model evolution, one which has spawned such efforts as <ref> [Codd79, Dada86, Sche86, Schw86, Rowe87] </ref>, is to extend the relational model in some way.
Reference: [Seth89] <author> R. Sethi, </author> <title> Programming Languages Concepts and Constructs, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1989. </year>
Reference-contexts: This results a paradigm for tree pattern matching that is quite similar to the hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh a d e hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 148 hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh a c l f hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh execution model of Prolog and to unification <ref> [Seth89] </ref>. All of the subsequent results of this chapter hold when multiple concatenation point symbols are allowed. For simplicity of presentation we restrict ourselves to just l. We have just defined a semantics for the |, Kleene *, and concatenation operations, based on results of [Done70, That68].
Reference: [Shaw90] <author> G. Shaw and S. Zdonik, </author> <title> "A query algebra for object-oriented databases", </title> <booktitle> Proc. IEEE Intl. Conf. on Data Engineering, </booktitle> <address> Los Angeles, CA, </address> <month> Feb. </month> <year> 1990. </year>
Reference-contexts: Thus EXTRA/EXCESS supports many of the features commonly present in object-oriented systems and supports some additional features. More recently, a system called AQUA (A QUery Algebra) is the result of a joint effort among researchers who have participated in the design of previous object-oriented algebras <ref> [Shaw90, Vanc92, Vand91] </ref>. AQUA has been designed to address a number of detailed modeling issues that we believe needed further work, but the primary goal of this work has been the design of an algebra that would serve as the input to a broad class of query optimizers. <p> In the complex object models, there is no restriction on the ordering or number of applications of these constructors. There is no standard algebra for such objects, but several algebras have been pro posed. Finally, algebras have been defined for some object-oriented data models <ref> [Yu91, Shaw90, Vand91, Vanc92] </ref>. These models can be viewed as extending the complex object models with the notions of object identity, 7 inheritance, and methods (procedures defined to operate on objects of a certain type). There is no accepted standard here either. <p> Each field in a result tuple is either unchanged or is operated on by one of several expressions parameterizing the l operator. This operator can also add fields to the tuples if desired. 2.3.6. ENCORE/EQUAL An algebra for the ENCORE/EQUAL object-oriented database system is presented in <ref> [Shaw90] </ref>. This is a purely object-based system. The model is a standard object-oriented one with the capacity to distinguish between sets of object identifiers and multisets of object identifiers, although the exact semantics of multisets are left unspecified. <p> Also, these top-level sets (and top-level multisets) contain only OIDs. Query results are collections of an existing type or of a tuple type constructed during the query. Some relational-like query optimization techniques are also presented in <ref> [Shaw90] </ref>. 51 2.3.7. An Object-Oriented Database Algebra [Osbo88] describes an object-oriented data model and algebra. Structurally, the model supports scalar values and the tuple and set type constructors, as well as inheritance among tuple types. One important extension, though, is that sets need not be homogeneous. <p> We provide original operators for additive union, grouping, set creation, and looping, as well as other operators that have appeared elsewhere. The transformation rules involving these new operators are new, as are most of the other multiset transformations we provide. ENCORE/EQUAL <ref> [Shaw90] </ref> and ALGRES [Ceri87] provide both sets and multisets, but the semantics of their multiset operations are not specified. Some of our multiset operators are similar to those of [Daya82], but [Daya82] restricts itself to the (value-based) relational model and includes the redundant intersection operator. <p> This treatment also enables the algebra to be defined using only one form of equality, instead of one form for OIDs and one for values, as is done in <ref> [Shaw90, Osbo88] </ref>. [Abit89] defines two separate languages, one enforcing object identity and one not supporting it at all, but we mix the two semantics in a single algebraic language, and we give references the status of a type constructor with the same privileges as the multiset, array, and tuple constructors. <p> Finally, the algebraic approach has also been extended to cover temporal databases [Tans89, Clif85]. Algebraic transformation rules for the relational algebra can be found in [Ullm89]. [Scho86] presents such rules for the nested relational model. Some rules for complex object models with identity are proposed in <ref> [Osbo88, Shaw90] </ref>; these rules are mainly straightforward extensions of relational or nested relational transformation rules. 67 Finally, [Beer90] proposes a meta-level algebra for collections of complex objects with identity and includes some transformation rules that go beyond what is done in the relational model. <p> Other models have claimed similar goals, but not necessarily in all these areas at once, and our mechanisms for achieving these goals differ substantially from those of our predecessors. Many of the specific constructs of AQUA were inspired by or drawn from the EXTRA/EXCESS system [Vand91], ENCORE/EQUAL <ref> [Shaw90] </ref>, and Revelation [Vanc92]. In attempting to support both values and objects, some systems (e.g. EXCESS [Vand91]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. <p> The AQUA approach to this problem is closely related to duplicate elimination and non-determinism, as shall be seen. Duplicate elimination for both sets and multisets, as defined in AQUA, is original. AQUA's dup_elim can be thought of as a generalization of other duplicate elimination operators (e.g. that of ENCORE/EQUAL <ref> [Shaw90] </ref>). A set-theoretic choose operator appears in the algebras of Osborne and MDM [Osbo88, Rich92]. Non-determinism is also present in [Abit90], which describes a witness operator which operates in a logical (rather than an algebraic) setting and creates a set of possible interpretations of a formula, resulting in non-determinism.
Reference: [Shek89] <author> E. Shekita and M. Carey, </author> <title> "Performance Enhancement Through Replication in an Object-Oriented DBMS", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Portland, Oregon, </address> <year> 1989. </year>
Reference-contexts: of Figure 4.6) we define the following method that returns the social security number of an Employee's kid with name "kname": define Employee function get_ssnum (kname: char []) returns int4 ( retrieve (this.kids.ssnum) where (this.kids.name = kname) ) we may be able to take advantage of indices or cached attributes <ref> [Maie86b, Shek89] </ref> if a particular Employee (or set of Employees) has such enhancements. This also allows for transformations that involve nodes in the stored query tree interacting with nodes in the invoking query tree; some examples of this can be found in [Beer90].
Reference: [Shen87] <author> S. Shenoy and Z. Ozsoyoglu, </author> <title> "A System for Semantic Query Optimization", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> San Francisco, California, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: Some systems <ref> [Shen87, King81] </ref> include another phase in the optimization process. This phase is called semantic query optimization, and consists of generating syntactically different but semantically equivalent versions of the original (calculus) query using user-supplied information such as integrity constraints.
Reference: [Ship81] <author> D. Shipman, </author> <title> "The Functional Data Model and the Data Language DAPLEX", </title> <journal> ACM TODS 6(1), </journal> <month> March </month> <year> 1981. </year>
Reference-contexts: One approach to dealing with complex objects (also known as "structural object-orientation" [Ditt86]) is to provide procedures as a data type [Ston87a]. Another approach is to permit relation-valued attributes [Dada86, Sche86]. A third approach is to take a functional view of data <ref> [Ship81, Mano86, Bato87] </ref>. In addition, a common theme among many of these efforts is to extend the database system's data definition facilities with support for some form of sub-typing. <p> associated EXCESS query language, which are intended to subsume much of the 3 modeling and querying functionality of object-oriented and other advanced systems. 1 The result is a synthesis and extension of ideas from other data models and systems, including GEM [Zani83], POSTGRES [Rowe87], NF 2 models [Dada86, Sche86], DAPLEX <ref> [Ship81] </ref>, ORION [Bane87], Trellis/Owl [Scha86], O 2 [Banc88], STDM [Cope84], and STDM's descendant, GemStone [Maie86c]. <p> There is no notion of "complex objects"; rather, the concepts associated with such objects are modeled using additional relations. 2.3.9.2. NF -Like and Other Algebras The PDM algebra was developed for use with the PROBE project at CCA [Mano86, Daya87]. The model is derived mainly from DAPLEX <ref> [Ship81] </ref>, and it is object-based. The operations of the algebra include those of the relational algebra (projection, Cartesian product, union, difference, intersection, and selection) plus several others: outer versions of the union, difference, and intersection operators (PDM supports two types of nulls, "don't know" and "don't care"). <p> And while GEM had both own and ref attributes, its type system was less rich and sets of references were not permitted. Since the original development of EXTRA/EXCESS, O 2 [Banc88] has adopted own and ref attributes. The EXCESS query language is related to those of DAPLEX <ref> [Ship81] </ref>, GEM [Zani83], NF 2 systems [Dada86, Sche86], and POSTGRES [Rowe87]. Implicit joins were taken directly from GEM, and originated in DAPLEX. <p> Lastly, our approach to user-defined set functions is more general than the corresponding POSTGRES approach to user-defined aggregates. With respect to schema types, our support for EXCESS functions is similar to the functions of DAPLEX <ref> [Ship81] </ref> and IRIS [Fish87], and also to the parameterized procedures of POSTGRES [Ston87a]. Our approach to user-defined procedures is rooted in the stored commands of the IDM database machine [IDM500], as is our approach to encapsulation through authorization, but EXCESS procedures are a much more general mechanism. <p> EXTRA separates the notions of type and instance; thus, users can collect related objects together in semantically meaningful sets and arrays, which can then be queried, rather than having to settle for queries over type extents as in many data models (e.g., <ref> [Ship81, Bane87, Lecl87, Mylo80, Rowe87] </ref>). EXTRA provides tuple, set, fixed-length array, and variable-length array as type constructors. In addition, there are three kinds of values, own, ref, and own ref (although casual users such as query writers need not be concerned with this distinction). <p> Thus, our earlier query involving children of second floor employees could have been written as: retrieve (C.name) from C in Employees.kids where Employees.dept.floor = 2 EXCESS also provides a path syntax in order to simplify the task of formulating queries over nested sets of objects <ref> [Ship81, Cope84] </ref>. As an example, the statement "range of C is Employees.kids" means that for each employee object in the Employees set, C will iterate over all the children of the employee. <p> Using the extensibility features described in Section 4.3, it is possible to define a HireEmployee procedure that encapsulates the appropriate pair of update queries as a single command. This effect could be achieved automatically by adding a facility for inverse relationship maintenance, similar to that provided by DAPLEX <ref> [Ship81] </ref>. 87 insert into D.employees (E) from D in Departments, E in Employees where E.name="Smith" and D.name = "Computer Sciences" To add a child of Smith's to the database, the following query would be used: copy to E.kids (name="Anne", street = E.street, city = E.city, zip = E.city, birthday = "10/10/79") <p> A function may return a result of any type, including a schema type, a set of some schema type, etc. Updates through functions are not permitted. By way of comparison, EXCESS functions are similar to functions in DAPLEX <ref> [Ship81] </ref> and IRIS [Fish87]. They can also be viewed as a simplified form of POSTGRES procedure attributes [Ston87a]; in particular, they are like parameterized procedure attributes.
Reference: [Ston76] <author> M. Stonebraker, E. Wong, P. Kreps, and G. </author> <title> Held, "The Design and Implementation of INGRES", </title> <journal> ACM TODS 1(3), </journal> <month> Sept. </month> <year> 1976. </year>
Reference-contexts: In this section we present the design of the EXCESS query language. While EXCESS is based on QUEL <ref> [Ston76] </ref>, we have borrowed ideas from the QUEL extensions developed for GEM [Zani83] and POSTGRES [Rowe87, Ston87b] as well as work on SQL extensions for handling NF 2 data [Dada86, Sche86].
Reference: [Ston87a] <author> M. Stonebraker, J. Anton, and E. Hanson, </author> <title> "Extending a Database System with Procedures," </title> <journal> ACM TODS 12(3), </journal> <month> Sept. </month> <year> 1987. </year>
Reference-contexts: One approach to dealing with complex objects (also known as "structural object-orientation" [Ditt86]) is to provide procedures as a data type <ref> [Ston87a] </ref>. Another approach is to permit relation-valued attributes [Dada86, Sche86]. A third approach is to take a functional view of data [Ship81, Mano86, Bato87]. In addition, a common theme among many of these efforts is to extend the database system's data definition facilities with support for some form of sub-typing. <p> Lastly, our approach to user-defined set functions is more general than the corresponding POSTGRES approach to user-defined aggregates. With respect to schema types, our support for EXCESS functions is similar to the functions of DAPLEX [Ship81] and IRIS [Fish87], and also to the parameterized procedures of POSTGRES <ref> [Ston87a] </ref>. Our approach to user-defined procedures is rooted in the stored commands of the IDM database machine [IDM500], as is our approach to encapsulation through authorization, but EXCESS procedures are a much more general mechanism. The recently proposed procedures of SQL3 are similar to those provided by EXCESS. 3.2. <p> Updates through functions are not permitted. By way of comparison, EXCESS functions are similar to functions in DAPLEX [Ship81] and IRIS [Fish87]. They can also be viewed as a simplified form of POSTGRES procedure attributes <ref> [Ston87a] </ref>; in particular, they are like parameterized procedure attributes. We do not support true procedure attributes, or "EXCESS as a data type," because procedure attributes are not needed for representing complex object structures in EXTRA as they are in POSTGRES.
Reference: [Ston87b] <author> M. Stonebraker, J. Anton, and M. Hirohama, </author> <title> "Extendability in POSTGRES," </title> <journal> IEEE Database Eng. Bulletin 10, </journal> <month> June </month> <year> 1987. </year>
Reference-contexts: The only point for comparison here is POSTQUEL, which only operates on one-dimensional arrays of base types. Finally, ADT and access method extensibility in EXTRA/EXCESS were heavily influenced by the work of Stonebraker [Ong84, Ston86] and the resulting extension facilities in POSTGRES <ref> [Ston87b] </ref>. Our work here differs mostly in minor respects. Because ADTs in our system are written E, the system's internal language, adding ADTs is perhaps simpler here. <p> Predefined base types include integers of various sizes, single and double-precision floating point numbers, booleans, character strings, and enumerations. EXTRA also supports the addition of new base types (through an ADT facility similar to those of <ref> [Ston86, Ston87b] </ref>) like the Date type in Figure 4.1. ADT support will be covered in a later section. The type constructors of EXTRA include tuple (e.g., Person is a tuple type), fixed length arrays, variable length arrays, sets, and references. <p> In this section we present the design of the EXCESS query language. While EXCESS is based on QUEL [Ston76], we have borrowed ideas from the QUEL extensions developed for GEM [Zani83] and POSTGRES <ref> [Rowe87, Ston87b] </ref> as well as work on SQL extensions for handling NF 2 data [Dada86, Sche86]. <p> Since some users may prefer a more symmetric function call syntax, EXCESS will also accept this expression in the form "Add (CnumPair.val1, CnumPair.val2)". In addition to supporting standard ADT function invocation, we follow the lead of <ref> [Ong84, Ston86, Ston87b] </ref> and support the registration of operators as an alternative function invocation syntax. <p> Existing EXCESS operators can be overloaded, as illustrated here. In addition, it is possible to introduce new operators (any legal EXCESS identifier or sequence of punctuation characters may be used). For new operators, we require the precedence and associativity of the operator to be specified, much as in <ref> [Ston87b] </ref>. Prefix operators can also be defined, and the number of arguments that an operator can have is not restricted. How 91 ever, functions with three or more arguments cannot be defined as infix operators, and functions that are overloaded within a single dbclass may not be defined as operators. <p> Finally, it is important that the query optimizer be given sufficient information to recognize the applicability of alternative access methods and join methods when optimizing queries involving ADTs. We will follow an approach similar to that outlined in <ref> [Ston86, Ston87b] </ref> for addressing this issue, with a few differences. First, optimizer-specific information will not be specified via the EXCESS/EXTRA interface. Instead, it will be given in tabular form to a utility responsible for managing optimizer information. <p> Second, ADT functions and operators will be treated uniformly for query optimization purposes. This is different than <ref> [Ston87b] </ref>, where operators but not functions are optimized. <p> Support for this form of extension has been included in POSTGRES, but in a limited form. In particular, one could introduce a "median" aggregate function for sets of integers, but not one that works for any totally ordered type <ref> [Ston87b] </ref>. The EXCESS approach to such extensions is based on features provided by the E programming language [Rich87]. E provides a facility for writing generic functions, and it supports the specification of constraints on the generic type (e.g., any type that has boolean "less_than" and "equals" member functions).
Reference: [Ston86] <author> M. Stonebraker, </author> <title> "Inclusion of New Types in Relational Database Systems," </title> <booktitle> Proc. IEEE Intl. Conf. on Data Engineering, </booktitle> <address> Los Angeles, CA, </address> <month> Feb. </month> <year> 1986. </year>
Reference-contexts: Also, EXCESS provides a cleaner treatment of arrays than we have seen elsewhere. The only point for comparison here is POSTQUEL, which only operates on one-dimensional arrays of base types. Finally, ADT and access method extensibility in EXTRA/EXCESS were heavily influenced by the work of Stonebraker <ref> [Ong84, Ston86] </ref> and the resulting extension facilities in POSTGRES [Ston87b]. Our work here differs mostly in minor respects. Because ADTs in our system are written E, the system's internal language, adding ADTs is perhaps simpler here. <p> Predefined base types include integers of various sizes, single and double-precision floating point numbers, booleans, character strings, and enumerations. EXTRA also supports the addition of new base types (through an ADT facility similar to those of <ref> [Ston86, Ston87b] </ref>) like the Date type in Figure 4.1. ADT support will be covered in a later section. The type constructors of EXTRA include tuple (e.g., Person is a tuple type), fixed length arrays, variable length arrays, sets, and references. <p> Since some users may prefer a more symmetric function call syntax, EXCESS will also accept this expression in the form "Add (CnumPair.val1, CnumPair.val2)". In addition to supporting standard ADT function invocation, we follow the lead of <ref> [Ong84, Ston86, Ston87b] </ref> and support the registration of operators as an alternative function invocation syntax. <p> Finally, it is important that the query optimizer be given sufficient information to recognize the applicability of alternative access methods and join methods when optimizing queries involving ADTs. We will follow an approach similar to that outlined in <ref> [Ston86, Ston87b] </ref> for addressing this issue, with a few differences. First, optimizer-specific information will not be specified via the EXCESS/EXTRA interface. Instead, it will be given in tabular form to a utility responsible for managing optimizer information. <p> Instead, it will be given in tabular form to a utility responsible for managing optimizer information. The EXCESS query optimizer will do table lookup to determine method applicability for ADTs (so that ADTs can be easily added dynamically). These tables will be similar to the access method templates of <ref> [Ston86] </ref>, but expression-level optimizer information (e.g., associativity, commutativity, complementary function pairs, etc.) will also be represented in tabular form at this level. Second, ADT functions and operators will be treated uniformly for query optimization purposes. This is different than [Ston87b], where operators but not functions are optimized.
Reference: [Stra90] <author> D. Straube and M. Ozsu, </author> <title> "Queries and query processsing in object-oriented database systems", </title> <journal> ACM Trans. Office Info. Sys., </journal> <volume> 8(4), </volume> <month> Oct </month> <year> 1990. </year>
Reference-contexts: The join algorithms proposed all proceed by first unnesting the relations involved. Some restrictions include the requirement that objects be instances of exactly one class and that recursive structures are not permitted. <ref> [Stra90] </ref> presents an algebra (and equivalent calculus) for an object-oriented system. The operators provided are union, difference, selection, and mapping. The "map" operator performs a sequence of class method applications to every element in a set. The selection operator returns the members of a set which satisfy a predicate.
Reference: [Stro86] <author> B. Stroustrup, </author> <title> The C++ Programming Language, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: To add a new ADT, the person responsible for adding the type begins by writing (and debugging) the code for the type in the E programming language. E is an extension of C++ <ref> [Stro86] </ref> that was developed as part of the EXODUS project. E serves as the implementation language for access methods and operators for systems developed using EXODUS. <p> However, a single definition (i.e., the definition applicable to the Employee type) will be statically selected for such a query. This is similar to the distinction between virtual member functions and regular member functions in C++ <ref> [Stro86] </ref>. 95 4.3.2.3. Achieving Data Abstraction We provide an authorization mechanism along the lines of the System R [Cham75] and IDM [IDM500] protection systems; this mechanism is described in [Vand88a, Vand88b].
Reference: [Subr93] <author> B. Subramanian, S. Zdonik, T. Leung, and S. Vandenberg, </author> <title> "Ordered Types in the AQUA Data Model", </title> <booktitle> Fourth International Workshop on Database Programming Languages, </booktitle> <address> New York, New York, </address> <year> 1993, </year> <note> to appear. </note>
Reference-contexts: In Chapter 6 of this thesis we are concerned mainly with trees. For an introduction to AQUA's support for other ordered data types, see <ref> [Subr93] </ref>. <p> These applications store huge volumes of data and must locate information from these structures very efficiently. They thus require database support for ordered data structures like lists, trees, and graphs. hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 Parts of this section summarize <ref> [Subr93] </ref>. 140 Viewing lists, trees, and graphs as types in their own right allows us to utilize their specialized properties for query optimization and gives us more flexibility in defining operations over them. <p> If it is 0, the tree is effectively a set. If it is 1, the tree is effectively a list. We now briefly describe the relevant operators on trees. Most of the tree operators have been derived from the corresponding graph operators (see <ref> [Subr93] </ref>). The basic tree operators of AQUA that are of interest here are: sources (T), sinks (T), im_ancestor (T, x), im_descendent (T, x), select (p) (T), sub_select (T2) (T1), apply (f) (T), and find_path (T, x). The other tree operators are described in detail in [Subr93]. <p> the corresponding graph operators (see <ref> [Subr93] </ref>). The basic tree operators of AQUA that are of interest here are: sources (T), sinks (T), im_ancestor (T, x), im_descendent (T, x), select (p) (T), sub_select (T2) (T1), apply (f) (T), and find_path (T, x). The other tree operators are described in detail in [Subr93]. Sources (T) returns the set of nodes of T that have no incoming edges. This set will contain only the root of T. Sinks (T) returns the set of nodes of T that have no outgoing edges (i.e., the leaves of T). <p> Im_descendent (T, x) returns the set of nodes in T that are children of x. Select (p) (T) selects all nodes of T that satisfy the predicate p. See <ref> [Subr93] </ref> for a discussion of how edges are preserved in the result tree. This selection operator is not of primary concern to us here. Sub_select (P) (T) returns copies of all subtrees of T that match P. <p> These operators generalize similar AQUA operators for lists <ref> [Subr93] </ref>. Note that in general, the all_anc operator should return more than just the children of the nodes on the path back to the root.
Reference: [Tans89] <author> A. Tansel and L. Garnett, </author> <title> "Nested Historical Relations", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Portland, Oregon, </address> <year> 1989. </year>
Reference-contexts: This value is removed from the proper attribute of the original tuple. In addition, [Aris83] defines a canonical form for nested relations, which is the nesting of a 1NF relation along each of its attributes in any order. Only one level of nesting is considered. In <ref> [Tans89] </ref> an algebra is described which extends the NF 2 algebra to handle time-varying data. The entities in this temporal model are called temporal atoms, which are ordered pairs consisting of a value and a set of times during which that value is valid. <p> The ALGRES algebra [Ceri87] is similar but it also supports a least fixpoint operation and unordered relations. Object identity was added to complex structures in the LDM algebra [Kupe85] and in IQL [Abit89]. Finally, the algebraic approach has also been extended to cover temporal databases <ref> [Tans89, Clif85] </ref>. Algebraic transformation rules for the relational algebra can be found in [Ullm89]. [Scho86] presents such rules for the nested relational model.
Reference: [That68] <author> J. Thatcher and J. Wright, </author> <title> "Generalized Finite Automata Theory with an Application to a Decision Problem of Second-Order Logic", </title> <journal> Math. Sys. Theory 2(1), </journal> <year> 1968. </year>
Reference-contexts: We develop a notation for expressing patterns in trees based on results presented in <ref> [That68, Done70] </ref>. 3.2.3. <p> To extend the standard regular expression notation to trees, we build on the results of <ref> [Done70, That68] </ref>. These papers present generalizations of finite automata which can recognize trees rather than just strings. [That68] proves the closure of these generalized automata under union, concatenation, and Kleene *. <p> To extend the standard regular expression notation to trees, we build on the results of [Done70, That68]. These papers present generalizations of finite automata which can recognize trees rather than just strings. <ref> [That68] </ref> proves the closure of these generalized automata under union, concatenation, and Kleene *. These are exactly the three operators of regular expressions, and we now describe a notation that allows their application to terms that represent trees. <p> Intuitively, then, any notation for concatenation of tree patterns must indicate which child "b" is supposed to be in the expression "ab". hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh a c hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 147 To represent this, we use (as in <ref> [That68] </ref>) a special symbol to indicate the concatenation points -- the points in the expression where the second term is to be appended to the first. Let us first examine this graphically. In Figure 6.5 we have two trees. The special symbol l in a node indicates a concatenation point. <p> All of the subsequent results of this chapter hold when multiple concatenation point symbols are allowed. For simplicity of presentation we restrict ourselves to just l. We have just defined a semantics for the |, Kleene *, and concatenation operations, based on results of <ref> [Done70, That68] </ref>. We now describe the syntax that will enable us to express these patterns inside an algebraic query.
Reference: [Tsur86] <author> S. Tsur and C. Zaniolo, </author> <title> "LDL: A Logic-Based Data Language", </title> <booktitle> Proc. VLDB Conf., </booktitle> <address> Kyoto, Japan, </address> <month> August </month> <year> 1986. </year>
Reference-contexts: An algebra has also been developed for FAD [Banc87], but in FAD (as in IRIS [Fish87]) the real optimization work is performed by a relational optimizer -- FAD expressions are first translated to flat relational algebra. FAD was used as a backend for the LDL system developed at MCC <ref> [Tsur86] </ref>. The filter operation, for example, is translated into a series of binary filters which are then processed using relational joins. FAD is an object-based system.
Reference: [Ullm87] <author> J. Ullman, </author> <title> "Database Theory Past and Future," </title> <booktitle> Proc. ACM PODS Conf., </booktitle> <address> San Diego, CA, </address> <month> March </month> <year> 1987. </year>
Reference-contexts: In fact, the former kind of object-oriented DBMS almost seems like a step back to the days of navigational data manipulation languages, as it is not obvious how one will support ad-hoc queries (or optimize accesses effectively) for such systems <ref> [Bloo87, Ullm87] </ref>. This thesis will address these issues, among others. Another direction in data model evolution, one which has spawned such efforts as [Codd79, Dada86, Sche86, Schw86, Rowe87], is to extend the relational model in some way.
Reference: [Ullm82] <author> J. Ullman, </author> <title> Principles of Database Systems, </title> <publisher> Computer Science Press, </publisher> <address> Rockville, Maryland, </address> <year> 1982. </year>
Reference-contexts: These transformations capture those of the relational and multiset algebras from the literature <ref> [Ullm82, Ullm89, Kort91, Knut81] </ref> as well as most transformations described for more advanced data models [Beer90, Scho86]. We do not claim that this list is complete, but we believe that it is either complete or very close to complete. The rules are presented without proof.
Reference: [Ullm89] <author> J. Ullman, </author> <title> Principles of Database and Knowledge-Base Systems, </title> <type> 2 vols., </type> <institution> Computer Science Press, Rock-ville, Maryland, </institution> <year> 1989. </year>
Reference-contexts: INTRODUCTION The relational model of data [Codd70] has been very successful both commercially and in terms of the research opportunities it has provided. One of the major reasons for this is that the model lends itself to an execution paradigm that can be expressed as an algebra <ref> [Codd70, Ullm89] </ref>. An algebraic execution engine is used to process queries and to optimize them by rewriting algebraic expressions into different algebraic expressions that produce the same answer in a (hopefully) more efficient manner. <p> Figure 2.2 contains an example instance of the Books relation. Relations are manipulated using the relational algebra, which is equipollent to the relational calculus (and hence to first-order predicate calculus). We give brief descriptions of the five standard relational operators as defined in [Kort91] or <ref> [Ullm89] </ref>: 1) Union (): Two relations can be combined into one using a standard set-theoretic union (duplicate tuples are eliminated). <p> This is expressed as hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 1 Codd's original proposal [Codd70] consisted of a different, but equipollent, set of operators: p, column permutation, join, composition, and restriction. Since then, however, the standard definitions have treated s, p, , , and as the fundamental operations <ref> [Kort91, Ullm89] </ref>. 2 The closed-world assumption (CWA) states that anything that can not be inferred from the data in the database is false. 17 follows. p [ p [publ_name] (s [name = publ_name] (copies (p [name, s [state = "NY"] (locations)] (Publishers)))) ] (s [title = "Moby Dick"] (Books)) A more <p> We explore tradeoffs between this method and a more "obvious" approach. Here we briefly review the the contents of the survey in Chapter 2, by tracing the basic development of database algebras and transformation rules: The relational algebra (as presented in <ref> [Ullm89] </ref>) has five operators: select (s), project (p), Cartesian product (), union (), and difference (-). The relational algebra was followed by algebras for nested (non-first normal form) relations [Abit86, Roth88, Sche86, Aris83, Colb89, Desh87, Fisc83, Jaes82b]. <p> Object identity was added to complex structures in the LDM algebra [Kupe85] and in IQL [Abit89]. Finally, the algebraic approach has also been extended to cover temporal databases [Tans89, Clif85]. Algebraic transformation rules for the relational algebra can be found in <ref> [Ullm89] </ref>. [Scho86] presents such rules for the nested relational model. <p> COMP is a partial function. (Similar approaches are taken in [Osbo88, Abit88a].) Comparisons (COMP): This operator takes a single structure as input and compares it to an arbitrary algebraic predicate using one of a fixed set of comparators. It bears a resemblance to the relational select operator <ref> [Ullm89] </ref>, but it operates on a single structure rather than a set of tuples. There are three truth-values in our predicate system: T (true), F (false), and UNK (unknown). Note that UNK is a truth value, while unk is a data value. <p> The complete proof (presented in Appendix B) describes the details of how primary components are used to ensure the semantics 116 of EXCESS queries. ii) Reduction of algebra to EXCESS: The other direction of the proof is a traditional case-based inductive proof like those found in <ref> [Ullm89, Abit88a, Roth88] </ref>. We omit most of the cases of the inductive step as our goal here is simply to give a flavor of the proof and to demonstrate that the proof is straightforward, due mainly to the simplicity of the algebraic operators and their resemblance to constructs in EXCESS. <p> These transformations capture those of the relational and multiset algebras from the literature <ref> [Ullm82, Ullm89, Kort91, Knut81] </ref> as well as most transformations described for more advanced data models [Beer90, Scho86]. We do not claim that this list is complete, but we believe that it is either complete or very close to complete. The rules are presented without proof.
Reference: [Vanc92] <author> B. Vance, </author> <title> "Towards an object-oriented query algebra", </title> <type> Tech. Report CS/E91-008, </type> <institution> Dept. of Computer Science and Eng., Oregon Graduate Institute, Beaverton, </institution> <address> OR, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Thus EXTRA/EXCESS supports many of the features commonly present in object-oriented systems and supports some additional features. More recently, a system called AQUA (A QUery Algebra) is the result of a joint effort among researchers who have participated in the design of previous object-oriented algebras <ref> [Shaw90, Vanc92, Vand91] </ref>. AQUA has been designed to address a number of detailed modeling issues that we believe needed further work, but the primary goal of this work has been the design of an algebra that would serve as the input to a broad class of query optimizers. <p> In the complex object models, there is no restriction on the ordering or number of applications of these constructors. There is no standard algebra for such objects, but several algebras have been pro posed. Finally, algebras have been defined for some object-oriented data models <ref> [Yu91, Shaw90, Vand91, Vanc92] </ref>. These models can be viewed as extending the complex object models with the notions of object identity, 7 inheritance, and methods (procedures defined to operate on objects of a certain type). There is no accepted standard here either. <p> Many of the specific constructs of AQUA were inspired by or drawn from the EXTRA/EXCESS system [Vand91], ENCORE/EQUAL [Shaw90], and Revelation <ref> [Vanc92] </ref>. In attempting to support both values and objects, some systems (e.g. EXCESS [Vand91]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. <p> Another goal of AQUA is the modelling of more complex structured data such as trees, unions, N-dimensional arrays, etc. These structures are not supported in EXCESS. Finally, EXCESS queries have limited expressive power. AQUA is designed to model certain recursive queries and other powerful querying facilities such as accumulation <ref> [Vanc92] </ref>. The AQUA model and algebra are extensions of EXTRA and EXCESS. Any EXCESS algebra query can be expressed in AQUA and can look nearly identical to its EXCESS counterpart, as many of the EXCESS operators have been almost directly incorporated into AQUA.
Reference: [Vand88a] <author> S. Vandenberg, </author> <title> "The EXTRA/EXCESS Data Dictionary," EXODUS working document, </title> <institution> Univ. of Wisconsin-Madison, </institution> <year> 1988. </year>
Reference-contexts: In Section 4.2, we present the EXCESS query language, including its facilities for querying complex objects, performing updates, and computing aggregates. Section 4.3 discusses the support provided in EXTRA and EXCESS for user-defined types and operations. [Vand88b] is a complete user's manual for the EXTRA and EXCESS languages, and <ref> [Vand88a] </ref> describes an EXTRA database for storing catalog information about an EXTRA/EXCESS DBMS. 4.1. The EXTRA Data Model In the EXTRA data model, a database is a collection of named, persistent objects. <p> This is similar to the distinction between virtual member functions and regular member functions in C++ [Stro86]. 95 4.3.2.3. Achieving Data Abstraction We provide an authorization mechanism along the lines of the System R [Cham75] and IDM [IDM500] protection systems; this mechanism is described in <ref> [Vand88a, Vand88b] </ref>. Both individual users and user groups (including a special "all-users" group) will be recognized, and protection units will be specified via EXCESS queries.
Reference: [Vand88b] <author> S. Vandenberg, </author> <title> "EXTRA/EXCESS User Manual," EXODUS working document, </title> <institution> Univ. of Wisconsin-Madison, </institution> <year> 1988. </year> <month> 194 </month>
Reference-contexts: In Section 4.2, we present the EXCESS query language, including its facilities for querying complex objects, performing updates, and computing aggregates. Section 4.3 discusses the support provided in EXTRA and EXCESS for user-defined types and operations. <ref> [Vand88b] </ref> is a complete user's manual for the EXTRA and EXCESS languages, and [Vand88a] describes an EXTRA database for storing catalog information about an EXTRA/EXCESS DBMS. 4.1. The EXTRA Data Model In the EXTRA data model, a database is a collection of named, persistent objects. <p> This is similar to the distinction between virtual member functions and regular member functions in C++ [Stro86]. 95 4.3.2.3. Achieving Data Abstraction We provide an authorization mechanism along the lines of the System R [Cham75] and IDM [IDM500] protection systems; this mechanism is described in <ref> [Vand88a, Vand88b] </ref>. Both individual users and user groups (including a special "all-users" group) will be recognized, and protection units will be specified via EXCESS queries.
Reference: [Vand89] <author> S. Vandenberg, </author> <title> "Practical Complex Object Algebras," </title> <booktitle> in [Grae89]. </booktitle>
Reference-contexts: In the context of AQUA, the algebraic goals relevant to this thesis are to provide mechanisms for various notions of equality; a consistent treatment of abstraction; and operators and optimizations for selection queries on trees. See <ref> [Vand89] </ref> for more discussion on algebraic design in general. 70 CHAPTER 4 EXTRA AND EXCESS This chapter describes the EXTRA data model and EXCESS query language. The chapter is organized as follows: Section 4.1 presents the data modeling facilities of EXTRA, including a number of examples.
Reference: [Vand90] <author> S. Vandenberg and D. DeWitt, </author> <title> "An Algebra for Complex Objects with Arrays and Identity", </title> <type> Tech. Report #918, </type> <institution> Computer Sciences Dept., Univ. of Wisconsin-Madison, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: An arc from A to B in such a graph is used in place of the linear algebraic expression B (A), meaning of course that the input of B is the result of A. More examples can be found in <ref> [Vand90] </ref> and in Section 5.6. Example 1: Example 2: The query in Figure 5.4 is a functional join [Zani83] that retrieves the names of the departments of all employees who work in Madison.
Reference: [Vand91] <author> S. Vandenberg and D. DeWitt, </author> <title> "Algebraic Support for Complex Objects with Arrays, Identity, and Inheritance", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Denver, CO, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: Thus EXTRA/EXCESS supports many of the features commonly present in object-oriented systems and supports some additional features. More recently, a system called AQUA (A QUery Algebra) is the result of a joint effort among researchers who have participated in the design of previous object-oriented algebras <ref> [Shaw90, Vanc92, Vand91] </ref>. AQUA has been designed to address a number of detailed modeling issues that we believe needed further work, but the primary goal of this work has been the design of an algebra that would serve as the input to a broad class of query optimizers. <p> In the complex object models, there is no restriction on the ordering or number of applications of these constructors. There is no standard algebra for such objects, but several algebras have been pro posed. Finally, algebras have been defined for some object-oriented data models <ref> [Yu91, Shaw90, Vand91, Vanc92] </ref>. These models can be viewed as extending the complex object models with the notions of object identity, 7 inheritance, and methods (procedures defined to operate on objects of a certain type). There is no accepted standard here either. <p> Only the last three operators extend the original relational algebra. Grouping is similar to the EXTRA/EXCESS GRP operator (see <ref> [Vand91] </ref> and Chapter 5). The tuple extension operator adds a field (which is functionally dependent on the key) to a tuple. Renaming changes column names. Codd's RM/T (Relational Model/Tasmania) model [Codd79] is a fairly complicated object-oriented extension to the relational model with both object- and value-based semantics. <p> Other models have claimed similar goals, but not necessarily in all these areas at once, and our mechanisms for achieving these goals differ substantially from those of our predecessors. Many of the specific constructs of AQUA were inspired by or drawn from the EXTRA/EXCESS system <ref> [Vand91] </ref>, ENCORE/EQUAL [Shaw90], and Revelation [Vanc92]. In attempting to support both values and objects, some systems (e.g. EXCESS [Vand91]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. <p> Many of the specific constructs of AQUA were inspired by or drawn from the EXTRA/EXCESS system <ref> [Vand91] </ref>, ENCORE/EQUAL [Shaw90], and Revelation [Vanc92]. In attempting to support both values and objects, some systems (e.g. EXCESS [Vand91]) choose to support only values in the type system and to model objects by using explicit identifiers. Other systems (e.g. Smalltalk and ORION [Gold83, Bane87]) choose to support only objects in the type system and to model values as a special case of objects.
Reference: [VanG87] <author> D. Van Gucht, </author> <title> "On the Expressive Power of the Extended Relational Algebra for the Unnormalized Relational Model," </title> <booktitle> Proc. ACM PODS Conf., </booktitle> <year> 1987. </year>
Reference-contexts: As the discussion moves beyond NF 2 models and systems, the implementation status and examples will largely be omitted. We will not discuss the relative power of the underlying data models, exhaustive sets of algebraic equivalence rules, or other theoretical language issues. Many of these issues are covered in <ref> [Pare88, VanG87, VanG86, Hull87, Hull89a, Chan88] </ref>. The purpose of this survey is to convey some idea of the general nature of database algebras in 9 the hope of gaining some insight into why certain operations exist and of identifying common themes among these algebras.
Reference: [VanG86] <author> D. Van Gucht and P. Fischer, </author> <title> "Some Classes of Multilevel Relational Structures," </title> <booktitle> Proc. ACM PODS Conf., </booktitle> <year> 1986. </year>
Reference-contexts: As the discussion moves beyond NF 2 models and systems, the implementation status and examples will largely be omitted. We will not discuss the relative power of the underlying data models, exhaustive sets of algebraic equivalence rules, or other theoretical language issues. Many of these issues are covered in <ref> [Pare88, VanG87, VanG86, Hull87, Hull89a, Chan88] </ref>. The purpose of this survey is to convey some idea of the general nature of database algebras in 9 the hope of gaining some insight into why certain operations exist and of identifying common themes among these algebras.
Reference: [Webe78] <author> H. Weber, </author> <title> "A Software Engineering View of Database Systems," </title> <booktitle> Proc. VLDB Conf., </booktitle> <year> 1978. </year>
Reference-contexts: The goal of these facilities is to provide support for derived data, for writing "stored commands" (as in the IDM-500 query facility [IDM500]), and for data abstraction of the kind described by Weber <ref> [Webe78] </ref>. 4.3.2.1. EXCESS Functions As illustrated in an example in Section 4.1.3, associating functions with schema types provides a mechanism for defining derived attributes. <p> to grant access to a given schema type only via its EXCESS functions and procedures, effectively making the schema type an abstract data type in its own right. (In fact, IDM stored commands are recommended for regulating database activity in a similar way [IDM500].) Features such as the modules of <ref> [Webe78] </ref> or the object semantics of an object-oriented data model can thus be captured via a single, more general mechanism. 4.3.3.
Reference: [Yu91] <author> L. Yu and S. Osborn, </author> <title> "An Evaluation Framework for Algebraic Object-Oriented Query Models", </title> <booktitle> Proc. IEEE Intl. Conf. on Data Engineering, </booktitle> <address> Kobe, Japan, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: In the complex object models, there is no restriction on the ordering or number of applications of these constructors. There is no standard algebra for such objects, but several algebras have been pro posed. Finally, algebras have been defined for some object-oriented data models <ref> [Yu91, Shaw90, Vand91, Vanc92] </ref>. These models can be viewed as extending the complex object models with the notions of object identity, 7 inheritance, and methods (procedures defined to operate on objects of a certain type). There is no accepted standard here either.

References-found: 149

