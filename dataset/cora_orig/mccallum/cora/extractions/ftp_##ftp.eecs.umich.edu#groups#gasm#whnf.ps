URL: ftp://ftp.eecs.umich.edu/groups/gasm/whnf.ps
Refering-URL: http://www.eecs.umich.edu/gasm/papers.html
Root-URL: http://www.cs.umich.edu
Title: Stepwise Refinement of an Abstract State Machine for WHNF-Reduction of -Terms  
Author: Hans Tonino Joost Visser 
Date: August 11, 1997  
Abstract-found: 0
Intro-found: 1
Reference: [Bar84] <author> H.P. Barendregt. </author> <title> The Lambda Calculus. Its Syntax and Semantics. </title> <booktitle> Studies in Logic and the Foundations of Mathematics. </booktitle> <publisher> North-Holland, </publisher> <address> revised edition, </address> <year> 1984. </year>
Reference-contexts: of C has a run of A as its image (correctness), and every run of A is image of a run of C (completeness). 2.3 -Calculus Lambda reduction is the process of rewriting lambda expressions to simpler ones (for a comprehensive account of the -calculus we refer the reader to <ref> [Bar84] </ref>).
Reference: [BR94a] <author> Egon Borger and Dean Rosenzweig. </author> <title> A mathematical definition of full Prolog. </title> <booktitle> Science of Computer Programming, </booktitle> <year> 1994. </year>
Reference-contexts: Also, the first section of the article A Mathematical Definition of Full Prolog <ref> [BR94a, x1] </ref> can be consulted. We will adhere to the notation used in that paper. 2.2 Operational Equivalence of Abstract State Machines In [BR94b], a notion of operational equivalence between two ASMs is defined.
Reference: [BR94b] <author> Egon Borger and Dean Rosenzweig. </author> <title> The WAM |definition and compiler correctness. </title> <editor> In L. Plumer and C. Beierle, editors, </editor> <title> Logic Programming: Formal Methods and Practical Applications. </title> <publisher> Elsevier Science Publishers, </publisher> <year> 1994. </year>
Reference-contexts: We expect that for more complex problems repetitions of both kinds of refinement may be appropriate. We also discuss the adequacy of the refinements. The first two ASMs can be shown to be operationally equivalent according to the definition found in <ref> [BR94b] </ref>. For the last two ASMs the situation is more complicated. Intuitively, the third ASM clearly is a refinement of the second ASM. However, the third ASM does more than the second one: the representation of terms makes use of sharing. <p> In this respect the notion of operational equivalence is perhaps too strong. We will argue that the implementation is adequate in a weaker sense. 3 This work is related to the work by Borger and Rosenzweig such as, for example, reported in <ref> [BR94b] </ref>. In that paper they introduced the method of stepwise refinement applied to ASM design. <p> Also, the first section of the article A Mathematical Definition of Full Prolog [BR94a, x1] can be consulted. We will adhere to the notation used in that paper. 2.2 Operational Equivalence of Abstract State Machines In <ref> [BR94b] </ref>, a notion of operational equivalence between two ASMs is defined.
Reference: [Gur91] <author> Yuri Gurevich. </author> <title> Evolving algebras, a tutorial introduction. </title> <journal> Bulletin of the European Association for Theoretical Computer Science, </journal> <volume> 43 </volume> <pages> 264-284, </pages> <month> February </month> <year> 1991. </year>
Reference-contexts: For an introduction to abstract state machines, the reader is referred to two papers written by Yuri Gurevich, Evolving Algebras: A Tutorial Introduction <ref> [Gur91] </ref> and Evolving Algebras 1993: Lipari Guide [Gur95] (note that abstract state machines were formerly called evolving algebras). Also, the first section of the article A Mathematical Definition of Full Prolog [BR94a, x1] can be consulted.
Reference: [Gur95] <author> Yuri Gurevich. </author> <title> Evolving algebras 1993; Lipari guide. </title> <editor> In Egon Borger, editor, </editor> <title> Specification and Validation Methods. </title> <publisher> Oxford University Press, </publisher> <year> 1995. </year>
Reference-contexts: For an introduction to abstract state machines, the reader is referred to two papers written by Yuri Gurevich, Evolving Algebras: A Tutorial Introduction [Gur91] and Evolving Algebras 1993: Lipari Guide <ref> [Gur95] </ref> (note that abstract state machines were formerly called evolving algebras). Also, the first section of the article A Mathematical Definition of Full Prolog [BR94a, x1] can be consulted.
Reference: [Pey87] <editor> Simon L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1987. </year> <month> 18 </month>
Reference-contexts: Lambda expressions can be pictured as trees as follows: J J @ J @ BA B x The left-branching chain of application nodes (labelled with `@') is called the spine of the expression (see e.g. <ref> [Pey87] </ref>). A lambda expression of the following form: (x:B)A where B and A are arbitrary lambda expressions and x is a variable, is called a reducible expression, or redex. B is called the body and A is called the argument of the redex. <p> Obviously, this can lead to sharing. Finally, we note that the copying process and the substitution process are carried out simultaneously. For more details about sharing the reader should consult <ref> [Pey87] </ref>.
References-found: 6

