URL: http://ftp.eecs.umich.edu/people/yenmin/ieee_tse.ps
Refering-URL: http://ftp.eecs.umich.edu/people/yenmin/
Root-URL: http://www.eecs.umich.edu
Title: Designing An Agent Synthesis System For Cross RPC Communication 1  
Author: Yen-Min Huang and Chinya V. Ravishankar 
Keyword: Index Term Heterogeneous RPC, RPC Agent Synthesis, RPC Runtime.  
Address: Ann Arbor, Michigan 48109-2122  
Affiliation: Department of Electrical Engineering and Computer Science The University of Michigan,  
Abstract: Remote procedure call (RPC) is the most popular paradigm used today to build distributed systems and applications. As a consequence, the term RPC has grown to include a range of vastly different protocols above the transport layer. A resulting problem is that programs often use different RPC protocols, cannot be interconnected directly, and building a solution for each case in a large heterogeneous environment is prohibitively expensive. In this paper, we describe the design of a system that can synthesize programs (RPC agents) to accommodate RPC heterogeneities. Because of its synthesis capability, our system also facilitates the design and implementation of new RPC protocols through rapid prototyping. We have built a prototype system to validate the design and to estimate the agent development costs and cross-RPC performance. Our evaluation shows that our synthesis approach provides a more general solution than existing approaches [1, 2, 3, 4, 5], and with lower software development and maintenance costs while maintaining a reasonable cross-RPC performance. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. N. Bershad, D. T. Ching, E. D. Lazowska, J. Sanislo, and M. Schwartz. </author> <title> A Remote Procedure Call Facility for Interconnecting Heterogeneous Computer Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(8) </volume> <pages> 880-894, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: Our solution is a hybrid of these four classes of solutions. In general, solutions based on protocol libraries or architecture provide programmers with a library interface and an architecture for constructing protocols. The interface and the architecture are engineered by factoring out common protocol functionalities and abstractions. HCS/HRPC <ref> [1] </ref>, x-kernel [20, 21] 14 , and TACT [2] 15 are examples of this type of solution. However, library architectures are restricted by the number of implementations provided in their libraries.
Reference: [2] <author> J. Auerbach. TACT: </author> <title> A Protocol Conversion Toolkit. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 8(1) </volume> <pages> 143-159, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: We define an RPC protocol simply as a protocol above the transport layer. Although the general scheme discussed here can be applied to other layers, we limit our discussion to the heterogeneity issues above the transport layer. For accommodating heterogeneities at the transport layer, readers can refer to <ref> [2] </ref> for more information. Two RPC systems can be very different. <p> In general, solutions based on protocol libraries or architecture provide programmers with a library interface and an architecture for constructing protocols. The interface and the architecture are engineered by factoring out common protocol functionalities and abstractions. HCS/HRPC [1], x-kernel [20, 21] 14 , and TACT <ref> [2] </ref> 15 are examples of this type of solution. However, library architectures are restricted by the number of implementations provided in their libraries. Therefore, introducing a new RPC protocol often requires updates to every library on the network, which is not desirable in large heterogeneous distributed environments.
Reference: [3] <author> Sun Microsystems. </author> <title> Open Network Computing - RPC Programming, </title> <month> March </month> <year> 1991. </year>
Reference: [4] <author> J. W. Stamos and D. E. Gifford. </author> <title> Implementing Remote Evaluation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(7) </volume> <pages> 710-722, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: While all remote-evaluation systems have similar code distribution mechanisms, the context and the language used in these systems are very different. For example, HDS/NCL [5] uses a special-purpose programming language NCL (based on LISP) to implement a heterogeneous network file system. Another example is REV <ref> [4] </ref>, which is embedded in the programming language CLU for supporting general purpose remote evaluation. Because our goal is to accommodate RPC protocol heterogeneities, which is very different from the focus of such earlier work, our system provides programmers a special protocol construction language (Cicero) for describing RPC protocols.
Reference: [5] <author> J. R. Falcone. </author> <title> A Programmable Interface Language for Heterogeneous Distributed Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(4) </volume> <pages> 331-351, </pages> <year> 1987. </year>
Reference-contexts: While all remote-evaluation systems have similar code distribution mechanisms, the context and the language used in these systems are very different. For example, HDS/NCL <ref> [5] </ref> uses a special-purpose programming language NCL (based on LISP) to implement a heterogeneous network file system. Another example is REV [4], which is embedded in the programming language CLU for supporting general purpose remote evaluation.
Reference: [6] <author> A. P. Birrell and B. J. Nelson. </author> <title> Implementing Remote Procedure Call. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 2(1) </volume> <pages> 39-59, </pages> <month> January </month> <year> 1984. </year>
Reference-contexts: 1 Introduction Remote Procedure Call (RPC) <ref> [6] </ref> is perhaps the most popular paradigm used today to build distributed applications. Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. <p> 1 Introduction Remote Procedure Call (RPC) [6] is perhaps the most popular paradigm used today to build distributed applications. Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC <ref> [6, 7, 8] </ref>, asynchronous RPC [9, 10, 11], fault tolerant RPC [12], broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) [7, 8, 13, 14], RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13].
Reference: [7] <author> Sun Microsystems. </author> <title> Remote Procedure Call Protocol Specification Version 2 (RFC 1057). Network Information Center, </title> <booktitle> SRI International, </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Remote Procedure Call (RPC) [6] is perhaps the most popular paradigm used today to build distributed applications. Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC <ref> [6, 7, 8] </ref>, asynchronous RPC [9, 10, 11], fault tolerant RPC [12], broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) [7, 8, 13, 14], RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13]. <p> Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC [6, 7, 8], asynchronous RPC [9, 10, 11], fault tolerant RPC [12], broadcast RPC <ref> [7, 8, 13] </ref>, maybe RPC (no-return RPC) [7, 8, 13, 14], RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13]. With emerging applications like multi-media conferencing and distributed real-time applications, it is conceivable that even more RPC protocols will be designed and implemented. <p> Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC [6, 7, 8], asynchronous RPC [9, 10, 11], fault tolerant RPC [12], broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) <ref> [7, 8, 13, 14] </ref>, RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13]. With emerging applications like multi-media conferencing and distributed real-time applications, it is conceivable that even more RPC protocols will be designed and implemented.
Reference: [8] <author> T. H. Dineen, P. J. Leach, N. W. Mishkin, J. N. Pato, and G. L. Wyant. </author> <title> The Network Computing Architecture and System: An Environment for Developing Distributed Applications. </title> <booktitle> In Proc. of the Summer USENIX Conference, </booktitle> <pages> pages 385-398, </pages> <address> Phoenix, Arizona, </address> <year> 1987. </year>
Reference-contexts: 1 Introduction Remote Procedure Call (RPC) [6] is perhaps the most popular paradigm used today to build distributed applications. Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC <ref> [6, 7, 8] </ref>, asynchronous RPC [9, 10, 11], fault tolerant RPC [12], broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) [7, 8, 13, 14], RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13]. <p> Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC [6, 7, 8], asynchronous RPC [9, 10, 11], fault tolerant RPC [12], broadcast RPC <ref> [7, 8, 13] </ref>, maybe RPC (no-return RPC) [7, 8, 13, 14], RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13]. With emerging applications like multi-media conferencing and distributed real-time applications, it is conceivable that even more RPC protocols will be designed and implemented. <p> Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC [6, 7, 8], asynchronous RPC [9, 10, 11], fault tolerant RPC [12], broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) <ref> [7, 8, 13, 14] </ref>, RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13]. With emerging applications like multi-media conferencing and distributed real-time applications, it is conceivable that even more RPC protocols will be designed and implemented. <p> Examples are synchronous RPC [6, 7, 8], asynchronous RPC [9, 10, 11], fault tolerant RPC [12], broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) [7, 8, 13, 14], RPC with atomic transactions [15], and RPC with call-back mechanism <ref> [8, 13] </ref>. With emerging applications like multi-media conferencing and distributed real-time applications, it is conceivable that even more RPC protocols will be designed and implemented.
Reference: [9] <author> B. Liskov and L. Shrira. </author> <title> Promises: Linguistic Support for Efficient Asynchronous Procedure Calls in Distributed System. </title> <booktitle> In Proc. of the SIGPLAN'88 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 260-267, </pages> <month> June </month> <year> 1988. </year> <month> 25 </month>
Reference-contexts: 1 Introduction Remote Procedure Call (RPC) [6] is perhaps the most popular paradigm used today to build distributed applications. Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC [6, 7, 8], asynchronous RPC <ref> [9, 10, 11] </ref>, fault tolerant RPC [12], broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) [7, 8, 13, 14], RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13].
Reference: [10] <author> E. F. Walker, R. Floyd, and P. Neves. </author> <title> Asynchronous Remote Operation Execution in Distrib--uted Systems. </title> <booktitle> In Proc. of 10th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 253-259, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Remote Procedure Call (RPC) [6] is perhaps the most popular paradigm used today to build distributed applications. Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC [6, 7, 8], asynchronous RPC <ref> [9, 10, 11] </ref>, fault tolerant RPC [12], broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) [7, 8, 13, 14], RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13].
Reference: [11] <author> A. L. Ananda, B. H. Tay, and E. K. Koh. </author> <title> ASTRA An Asynchronous Remote Procedural Call Facility. </title> <booktitle> In Proc. of 11th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 172-179, </pages> <month> May </month> <year> 1991. </year>
Reference-contexts: 1 Introduction Remote Procedure Call (RPC) [6] is perhaps the most popular paradigm used today to build distributed applications. Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC [6, 7, 8], asynchronous RPC <ref> [9, 10, 11] </ref>, fault tolerant RPC [12], broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) [7, 8, 13, 14], RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13].
Reference: [12] <author> K. S. Yap, P. Jalote, and S. Tripathi. </author> <title> Fault Tolerant Remote Procedure Call. </title> <booktitle> In Proc. of 8th International Conference on Distributed Computing Systems, </booktitle> <pages> pages 48-54, </pages> <address> San Jose, CA, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Remote Procedure Call (RPC) [6] is perhaps the most popular paradigm used today to build distributed applications. Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC [6, 7, 8], asynchronous RPC [9, 10, 11], fault tolerant RPC <ref> [12] </ref>, broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) [7, 8, 13, 14], RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13]. With emerging applications like multi-media conferencing and distributed real-time applications, it is conceivable that even more RPC protocols will be designed and implemented.
Reference: [13] <author> L. Zahn, T. H. Dineen, P. J. Leach, E. A. Martin, N. W. Mishkin, J. N. Pato, and G. L. Wyant. </author> <title> Network Computing Architecture. </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1990. </year>
Reference-contexts: Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC [6, 7, 8], asynchronous RPC [9, 10, 11], fault tolerant RPC [12], broadcast RPC <ref> [7, 8, 13] </ref>, maybe RPC (no-return RPC) [7, 8, 13, 14], RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13]. With emerging applications like multi-media conferencing and distributed real-time applications, it is conceivable that even more RPC protocols will be designed and implemented. <p> Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC [6, 7, 8], asynchronous RPC [9, 10, 11], fault tolerant RPC [12], broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) <ref> [7, 8, 13, 14] </ref>, RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13]. With emerging applications like multi-media conferencing and distributed real-time applications, it is conceivable that even more RPC protocols will be designed and implemented. <p> Examples are synchronous RPC [6, 7, 8], asynchronous RPC [9, 10, 11], fault tolerant RPC [12], broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) [7, 8, 13, 14], RPC with atomic transactions [15], and RPC with call-back mechanism <ref> [8, 13] </ref>. With emerging applications like multi-media conferencing and distributed real-time applications, it is conceivable that even more RPC protocols will be designed and implemented.
Reference: [14] <author> D. K. Gifford and N. Glasser. </author> <title> Remote Pipes and Procedures for Efficient Distributed Communication. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(3) </volume> <pages> 258-283, </pages> <month> August </month> <year> 1988. </year>
Reference-contexts: Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC [6, 7, 8], asynchronous RPC [9, 10, 11], fault tolerant RPC [12], broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) <ref> [7, 8, 13, 14] </ref>, RPC with atomic transactions [15], and RPC with call-back mechanism [8, 13]. With emerging applications like multi-media conferencing and distributed real-time applications, it is conceivable that even more RPC protocols will be designed and implemented.
Reference: [15] <author> B. Liskov and R. Scheifler. </author> <title> Guardians and Actions: Linguistic Support for Robust, Distributed Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3) </volume> <pages> 381-404, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: Many RPC semantics have been designed and implemented in recent years to meet application-specific requirements. Examples are synchronous RPC [6, 7, 8], asynchronous RPC [9, 10, 11], fault tolerant RPC [12], broadcast RPC [7, 8, 13], maybe RPC (no-return RPC) [7, 8, 13, 14], RPC with atomic transactions <ref> [15] </ref>, and RPC with call-back mechanism [8, 13]. With emerging applications like multi-media conferencing and distributed real-time applications, it is conceivable that even more RPC protocols will be designed and implemented.
Reference: [16] <author> Y. Huang and C. V. Ravishankar. Cicero: </author> <title> Linguistic Support For Protocol Implementation. </title> <type> Technical report, </type> <institution> Dept. of EECS, The University of Michigan, Ann Arbor, Michigan, </institution> <year> 1993. </year>
Reference-contexts: As a result, Cicero, a protocol construction language, is developed for describing RPC protocols. However, we will only briefly describe Cicero in this paper because the semantics of Cicero language constructs are orthogonal issues to the synthesis scheme and are described elsewhere <ref> [16] </ref>. 3 Nestor: Runtime Support For Agent Synthesis The major difference between our runtime Nestor and the traditional RPC runtime is that Nestor provides additional support for facilitating agent synthesis. <p> Agent performance depends on two factors: the Cicero runtime overhead and the performance of the communication primitives provided by the Cicero communication library. The Cicero runtime overhead is about 0.3ms on average, which most comes from the overheads of thread management and mutual exclusion support <ref> [16] </ref>. The performance of the communication primitives is represented by the performance of an RPC protocol constructed using these primitives. These RPC protocols, ATM1-RPC/UDP and ATM1-RPC/TCP, are constructed on top of UDP and TCP respectively with at-most-once semantics.
Reference: [17] <author> C. V Ravishankar and R. Finkel. </author> <title> Linguistic Support for Dataflow. </title> <type> Technical Report CSE-TR-14-89, </type> <institution> Dept. of EECS, The University of Michigan, Ann Arbor, Michigan, </institution> <year> 1989. </year>
Reference-contexts: To prepare readers for the example, we will first briefly introduce Cicero and its constructs. Cicero is an event-driven specification language derived from POST <ref> [17] </ref>. Unlike specifications in languages like LOTOS [18] Estelle [19], which are declarative (non-executable), Cicero specifications are constructive (executable). This feature allows programmers to provide execution information to guide the protocol synthesis process in generating efficient implementations. Cicero has five constructs: emit, when, cond, bundle, and escape.
Reference: [18] <author> ISO. </author> <title> Information Processing Systems Open System Interconnection - LOTOS A Formal Description Technique Based on the Temperal Ordering of Observational Behavior, </title> <year> 1985. </year>
Reference-contexts: To prepare readers for the example, we will first briefly introduce Cicero and its constructs. Cicero is an event-driven specification language derived from POST [17]. Unlike specifications in languages like LOTOS <ref> [18] </ref> Estelle [19], which are declarative (non-executable), Cicero specifications are constructive (executable). This feature allows programmers to provide execution information to guide the protocol synthesis process in generating efficient implementations. Cicero has five constructs: emit, when, cond, bundle, and escape. The emit construct is used to generate event instances.
Reference: [19] <author> ISO. </author> <title> Information Processing Systems Open System Interconnection - Estelle (Formal Description Technique Based on an Extended State Transition Model) , 1987. </title>
Reference-contexts: To prepare readers for the example, we will first briefly introduce Cicero and its constructs. Cicero is an event-driven specification language derived from POST [17]. Unlike specifications in languages like LOTOS [18] Estelle <ref> [19] </ref>, which are declarative (non-executable), Cicero specifications are constructive (executable). This feature allows programmers to provide execution information to guide the protocol synthesis process in generating efficient implementations. Cicero has five constructs: emit, when, cond, bundle, and escape. The emit construct is used to generate event instances.
Reference: [20] <author> L. Peterson, N. Hutchinson, S. O'Malley, and H. Rao. </author> <title> The x-kernel: A Platform for Accessing Internet Resources. </title> <journal> IEEE Computer, </journal> <volume> 23(5) </volume> <pages> 23-33, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: In general, solutions based on protocol libraries or architecture provide programmers with a library interface and an architecture for constructing protocols. The interface and the architecture are engineered by factoring out common protocol functionalities and abstractions. HCS/HRPC [1], x-kernel <ref> [20, 21] </ref> 14 , and TACT [2] 15 are examples of this type of solution. However, library architectures are restricted by the number of implementations provided in their libraries.
Reference: [21] <author> S. W. O'Malley and L. L. Peterson. </author> <title> A Dynamic Network Archtitecture. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 10(2), </volume> <month> May </month> <year> 1992. </year> <month> 26 </month>
Reference-contexts: In general, solutions based on protocol libraries or architecture provide programmers with a library interface and an architecture for constructing protocols. The interface and the architecture are engineered by factoring out common protocol functionalities and abstractions. HCS/HRPC [1], x-kernel <ref> [20, 21] </ref> 14 , and TACT [2] 15 are examples of this type of solution. However, library architectures are restricted by the number of implementations provided in their libraries.
Reference: [22] <author> J. M. Purtilo. </author> <title> The Polylith Software Bus. </title> <type> Technical Report TR-2469, </type> <institution> Computer Science and Institute for Advanced Computer Studies, University of Maryland, </institution> <year> 1990. </year>
Reference-contexts: The protocol descriptions are then used to synthesize RPC agents. Remote interface synthesis schemes generate communication code according to some interface definition, so that procedures/modules written in different languages can communicate with each other in a heterogeneous environment. Examples of this type of scheme are the POLYLITH software bus <ref> [22] </ref> and the Horus stub generator [23]. All these solutions are focused on resolving heterogeneities of data types and data representations. They all provide mappings from local data types and data representation to predefined data types and representations.
Reference: [23] <author> P. B. Gibbons. </author> <title> A Stub Generator For Multilanguage RPC in Heterogeneous Environments. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(1) </volume> <pages> 77-87, </pages> <month> January </month> <year> 1987. </year>
Reference-contexts: Remote interface synthesis schemes generate communication code according to some interface definition, so that procedures/modules written in different languages can communicate with each other in a heterogeneous environment. Examples of this type of scheme are the POLYLITH software bus [22] and the Horus stub generator <ref> [23] </ref>. All these solutions are focused on resolving heterogeneities of data types and data representations. They all provide mappings from local data types and data representation to predefined data types and representations.
Reference: [24] <author> J. P. Ansart, P. D. Amer, V. Chari, J. F. Lenotre, L. Lumbroso, E. Mariani, and E. Mat-tera. </author> <title> Software Tools for Estelle. </title> <editor> In B. Sarikaya and G. V. Bochmanni, editors, </editor> <title> Protocol Specification, Testing and Verification VI (IFIP/WG 6.1), </title> <address> Amsterdam, The Netherlands, </address> <publisher> North-Holland, </publisher> <year> 1987. </year>
Reference-contexts: Although our system also uses this approach to resolve heterogeneities in data types and representations, it also allows programmers to synthesize RPC agents to interconnect programs using different RPC protocols. This feature is absent in remote interface synthesis solutions. The work on specification compilers <ref> [24, 25, 26, 27] </ref> has been focused on generating correct implementations from the formal protocol specifications like in languages LOTOS and Estelle.
Reference: [25] <author> J. P. Briand, M. C. Fehri, L. Logrippo, and A. Obaid. </author> <title> Executing LOTOS Specifications. </title> <editor> In B. Sarikaya and G. V. Bochmanni, editors, </editor> <title> Protocol Specification, Testing and Verification VI (IFIP/WG 6.1), </title> <address> Amsterdam, The Netherlands, </address> <publisher> North-Holland, </publisher> <year> 1987. </year>
Reference-contexts: Although our system also uses this approach to resolve heterogeneities in data types and representations, it also allows programmers to synthesize RPC agents to interconnect programs using different RPC protocols. This feature is absent in remote interface synthesis solutions. The work on specification compilers <ref> [24, 25, 26, 27] </ref> has been focused on generating correct implementations from the formal protocol specifications like in languages LOTOS and Estelle.
Reference: [26] <author> S. T. Vuong, A. C. Lau, and R. I. Chan. </author> <title> Semiautomatic Implementation of Protocols Using an Estelle-C Compiler. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(3) </volume> <pages> 384-393, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Although our system also uses this approach to resolve heterogeneities in data types and representations, it also allows programmers to synthesize RPC agents to interconnect programs using different RPC protocols. This feature is absent in remote interface synthesis solutions. The work on specification compilers <ref> [24, 25, 26, 27] </ref> has been focused on generating correct implementations from the formal protocol specifications like in languages LOTOS and Estelle.
Reference: [27] <author> D. P. Anderson. </author> <title> Automated Protocol Implementation with RTAG. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 14(3) </volume> <pages> 291-300, </pages> <month> March </month> <year> 1988. </year>
Reference-contexts: Although our system also uses this approach to resolve heterogeneities in data types and representations, it also allows programmers to synthesize RPC agents to interconnect programs using different RPC protocols. This feature is absent in remote interface synthesis solutions. The work on specification compilers <ref> [24, 25, 26, 27] </ref> has been focused on generating correct implementations from the formal protocol specifications like in languages LOTOS and Estelle.
Reference: [28] <author> L. Svobodova. </author> <title> Implementing OSI Systems. </title> <journal> IEEE Journal on Selected Areas in Communications, </journal> <volume> 7(7) </volume> <pages> 1115-1130, </pages> <month> September </month> <year> 1989. </year>
Reference-contexts: However, the portions of a protocol implementation that can be generated depend on the environment and the specification language used, and the efficiency of generated code is also a concern <ref> [28] </ref>. Code quality is an important consideration, especially in the RPC context. Based on a protocol construction language, our prototype implementation can produce synthesized RPC agents with performance competitive with handcrafted RPC implementations.
Reference: [29] <author> C. Pu, H. Massalin, and J. Ioannidis. </author> <title> The Synthesis Kernel. </title> <journal> Computing Systems, </journal> <volume> 1(1) </volume> <pages> 11-32, </pages> <month> Winter </month> <year> 1988. </year> <month> 27 </month>
Reference-contexts: This apparent paradox arises because synthesis can always tailor code for each case to improve performance, while handcrafted solutions usually incur overhead when targeting the general case. A good example of this principle is seen in the Synthesis kernel <ref> [29] </ref>, which provides significant speedup for UNIX kernel calls by generating specialized kernel routines for specific situations.
References-found: 29

