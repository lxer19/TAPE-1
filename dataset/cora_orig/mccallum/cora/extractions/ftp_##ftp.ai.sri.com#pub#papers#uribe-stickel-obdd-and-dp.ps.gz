URL: ftp://ftp.ai.sri.com/pub/papers/uribe-stickel-obdd-and-dp.ps.gz
Refering-URL: http://www.ai.sri.com/~stickel/ldpp.html
Root-URL: 
Email: uribe@cs.stanford.edu  stickel@ai.sri.com  
Phone: 2  
Title: Ordered Binary Decision Diagrams and the Davis-Putnam Procedure  
Author: Tomas E. Uribe and Mark E. Stickel 
Address: Stanford, CA 94305  Menlo Park, CA 94025  
Affiliation: 1 Computer Science Department Stanford University,  Artificial Intelligence Center SRI International,  
Date: September 1994.  
Note: In J.P. Jouannaud (ed.), Lecture Notes in Computer Science, Vol. 845: 1 st International Conference on Constraints in Computational Logics. Springer-Verlag,  
Abstract: We compare two prominent decision procedures for propositional logic: Ordered Binary Decision Diagrams (obdds) and the Davis-Putnam procedure. Experimental results indicate that the Davis-Putnam procedure outperforms obdds in hard constraint-satisfaction problems, while obdds are clearly superior for Boolean functional equivalence problems from the circuit domain, and, in general, problems that require the schematization of a large number of solutions that share a common structure. The two methods illustrate the different and often complementary strengths of constraint-oriented and search-oriented procedures.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Anuchitanukul, A., and Manna, Z. </author> <title> Differential BDDs. </title> <type> Technical Report STAN-CS-TR-94-1525, </type> <institution> Computer Science Department, Stanford University, </institution> <address> Stan-ford, CA, </address> <month> Sept. </month> <year> 1994. </year>
Reference-contexts: So is the possibility of using obdds to replace clauses in a nonclausal version of the Davis-Putnam procedure, in the style of similar algorithms in [23] and [13]. Finally, we should mention the refinement of the obdd idea recently proposed by Anuchitanukul and Manna <ref> [1] </ref>, which can achieve more compact representations by ignoring node labels when collapsing isomorphic subgraphs. Another area for future work is to compare obdds with efficient implementations of other Boolean manipulation methods.
Reference: 2. <author> Bahar, R. I., Frohm, E. A., Gaona, C. M., Hachtel, G. D., Macii, E., Pardo, A., and Somenzi, F. </author> <title> Algebraic decision diagrams and their applications. </title> <booktitle> In IEEE Intl. Conf. on Computer-Aided Design (Nov. </booktitle> <year> 1993), </year> <pages> pp. 188-191. </pages>
Reference-contexts: In Minato's zero-suppressed obdds [29], variables are assumed to have a default value of false. Multi-terminal binary decision diagrams (mtbdds) are a generalization of obdds where terminal nodes correspond to the elements of an arbitrary finite domain (not just true and false) <ref> [2, 14] </ref>. Multi-valued decision diagrams (mdds) are a similar extension where branches can be more than binary [25]. All these extensions seem well-suited, in particular, for the quasigroup problems, and such an application is left as another intriguing future experiment.
Reference: 3. <editor> Benhamou, F., and Colmerauer, A., Eds. </editor> <booktitle> Constraint Logic Programming: Selected Research. </booktitle> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: These were already used in [12] together with the Knuth-Bendix completion procedure to prove Boolean equivalences for circuit verification. To yield competitive performance, adequate caching and structure-sharing techniques could also be used. 11 See <ref> [3] </ref> for this and many other descriptions of Boolean constraint solving within the CLP scheme. Acknowledgements Thanks to Alan Hu, Sanjeev Khanna, Liz Wolf and Jerry Yang, who provided many useful comments. Thanks also to Richard Waldinger, who suggested trying out the Mutilated Checkerboard problem.
Reference: 4. <author> Boy de la Tour, T., and Chaminade, G. </author> <title> The use of renaming to improve the efficiency of clausal theorem proving. </title> <booktitle> In Art. Int. IV: Methodology, Systems, Applications (1990), </booktitle> <editor> P. Jorrand and V. Sgurev, Eds., </editor> <publisher> Elsevier, </publisher> <pages> pp. 3-12. </pages>
Reference-contexts: For this, Boolean functions were rewritten in terms of ^, _ and :, and each equation l = r was interpreted as l $ r. We introduced new "intermediate" variables to keep the clausal forms small; this is a simple instance of the transformation proposed in <ref> [4] </ref>. Otherwise, the standard transformation produced an impracti-cally large number of clauses.
Reference: 5. <author> Brace, K. S., Rudell, R. L., and Bryant, R. E. </author> <title> Efficient implementation of a BDD package. </title> <booktitle> In 27 th Design Automation Conf. </booktitle> <year> (1990), </year> <pages> pp. 40-45. </pages>
Reference-contexts: obdd representations can be efficiently manipulated due mainly to three factors: computing Boolean operations over functions represented by obdds can be speeded up by taking into account the fixed variable ordering, structure can be shared among obdds, and, finally, the results of combination operations can be cached for future reference <ref> [5] </ref>. Given the obdd representation of functions f and g under a fixed variable ordering, the time needed to compute obdds representing the basic Boolean combinations (^, _, etc.) of f and g is polynomial in the product of the sizes of their obdds [6]. <p> For an overview of obdds directed to the automated deduction community, see [30]. The experiments reported here used the obdd C library written by David E. Long [26], which follows the guidelines described in <ref> [5] </ref>. 3 The Davis-Putnam Procedure The Davis-Putnam procedure 3 [16, 17] is an algorithm for deciding the satis-fiability of formulas in the propositional calculus.
Reference: 6. <author> Bryant, R. E. </author> <title> Graph-based algorithms for Boolean function manipulation. </title> <journal> IEEE Trans. on Computers 35, </journal> <month> 8 (Aug. </month> <year> 1986), </year> <pages> 677-691. </pages>
Reference-contexts: 1 Introduction We compare two of the most successful decision procedures for propositional logic: Ordered Binary Decision Diagrams <ref> [6] </ref> and the Davis-Putnam procedure [16, 17]. These methods were developed and used in different research communities with different applications in mind, and there has been a striking lack of comparison of their capabilities. Nevertheless, the topic is a matter of some curiosity. <p> However, a comparison of the two methods described here and such others is beyond the scope and main intentions of this paper (see Section 5 for more on related work). 2 Ordered Binary Decision Diagrams Ordered Binary Decision Diagrams (hereafter referred to as obdds) were introduced by Bryant <ref> [6] </ref> as a tool for the efficient representation and manipulation of Boolean functions. <p> Given the obdd representation of functions f and g under a fixed variable ordering, the time needed to compute obdds representing the basic Boolean combinations (^, _, etc.) of f and g is polynomial in the product of the sizes of their obdds <ref> [6] </ref>. Thus, as Bryant [8] points out, complex computations that are formulated as a sequence of operations on obdds remain tractable as long as the obdd sizes remain relatively small.
Reference: 7. <author> Bryant, R. E. </author> <title> On the complexity of VLSI implementations and graph representations of Boolean functions with application to integer multiplication. </title> <journal> IEEE Trans. on Computers 40, </journal> <month> 2 (Feb. </month> <year> 1991), </year> <pages> 205-213. </pages>
Reference-contexts: Tightening these bounds appears to be an interesting exercise in combinatorics, from which we refrain. For more general techniques for proving lower bounds on obdd representations see <ref> [7] </ref>, where Bryant proves an exponential lower bound for integer multiplication. (Nonetheless, McMillan [28] has characterized a large class of circuits with polynomial-size obdd representations.) It is possible for two sets of constraints that are "intractable" on their own to be combined efficiently into a polynomial-sized one.
Reference: 8. <author> Bryant, R. E. </author> <title> Symbolic Boolean manipulation with ordered binary-decision diagrams. </title> <journal> ACM Computing Surveys 24, </journal> <month> 3 (Sept. </month> <year> 1992), </year> <pages> 293-318. </pages>
Reference-contexts: Given the obdd representation of functions f and g under a fixed variable ordering, the time needed to compute obdds representing the basic Boolean combinations (^, _, etc.) of f and g is polynomial in the product of the sizes of their obdds [6]. Thus, as Bryant <ref> [8] </ref> points out, complex computations that are formulated as a sequence of operations on obdds remain tractable as long as the obdd sizes remain relatively small. <p> See <ref> [8] </ref> for a survey of obdds and their applications, the most successful of which is the symbolic model checking of finite-state hardware specifications [9, 26, 28]. For an overview of obdds directed to the automated deduction community, see [30]. <p> Consider the Boolean function f i that is true iff there is at least one queen in row i. Under this ordering, f i can be represented with an obdd of size linear in n. In general, we have the following (see <ref> [8] </ref>): Proposition 1. A Boolean function is called symmetric if its value depends only on the number of true arguments. The size for an obdd representation of a symmetric function of n arguments is independent of the variable ordering and has an upper bound of n 2 .
Reference: 9. <author> Burch, J. R., Clarke, E. M., McMillan, K. L., Dill, D. L., and Hwang, L. J. </author> <title> Symbolic modelchecking: 10 20 states and beyond. </title> <booktitle> Information and Computation 98, </booktitle> <month> 2 (June </month> <year> 1992), </year> <pages> 142-170. </pages>
Reference-contexts: See [8] for a survey of obdds and their applications, the most successful of which is the symbolic model checking of finite-state hardware specifications <ref> [9, 26, 28] </ref>. For an overview of obdds directed to the automated deduction community, see [30]. The experiments reported here used the obdd C library written by David E.
Reference: 10. <author> Butler, K. M., Ross, D. E., Kapur, R., and Mercer, M. R. </author> <title> Heuristics to compute variable ordering for efficient manipulation of ordered binary decision diagrams. </title> <booktitle> In 28 th Design Automation Conf. </booktitle> <year> (1991), </year> <pages> pp. 417-420. </pages>
Reference-contexts: We will discuss this problem at length in Section 4; for now, we note that most work on variable ordering heuristics is in the circuit domain (e.g., <ref> [10] </ref>), and that the current best algorithm for computing an optimal ordering for a given formula is exponential in the number of variables [19].
Reference: 11. <author> B uttner, W., and Simonis, H. </author> <title> Embedding Boolean expressions into logic programming. </title> <journal> J. of Symbolic Computation 4, </journal> <month> 2 (Oct. </month> <year> 1987), </year> <pages> 191-205. </pages>
Reference-contexts: Obdds have been successfully combined with interactive theorem-provers [24], and have been found useful in Constraint Logic Programming languages that include Boolean constraints <ref> [11, 32] </ref>. But except for the work of A. Rauzy [31], little comparative analysis of obdds has been done in this setting.
Reference: 12. <author> Chandrasekhar, M. S., Privitera, J. P., and Conradt, K. W. </author> <title> Application of term rewriting techniques to hardware design verification. </title> <booktitle> In 24 th Design Automation Conf. </booktitle> <year> (1987), </year> <pages> pp. 277-282. </pages>
Reference-contexts: Another area for future work is to compare obdds with efficient implementations of other Boolean manipulation methods. For instance, Hsiang [21] presents a system of rewrite rules that yields a canonical form, built using ^ and xor operations, for any Boolean expression. These were already used in <ref> [12] </ref> together with the Knuth-Bendix completion procedure to prove Boolean equivalences for circuit verification. To yield competitive performance, adequate caching and structure-sharing techniques could also be used. 11 See [3] for this and many other descriptions of Boolean constraint solving within the CLP scheme.
Reference: 13. <author> Claesen, L. J., Ed. </author> <title> Formal VLSI Correctness Verification|VLSI Design Methods, vol. II. </title> <publisher> Elsevier, </publisher> <year> 1990. </year> <title> Chap. 2, Efficient Tautology Checking Algorithms. </title>
Reference-contexts: We end this section by pointing out that obdds did not exhibit good performance on the ordered semigroup problems from [36]. 4.5 Boolean Equivalence Benchmarks Finally, we compared the two approaches using the IFIP Boolean equivalence benchmarks from <ref> [13] </ref>, also discussed by Moore [30]. These benchmarks can be described as lists of equations of the form v = exp, where v is a Boolean variable and exp is a Boolean expression. <p> All these extensions seem well-suited, in particular, for the quasigroup problems, and such an application is left as another intriguing future experiment. So is the possibility of using obdds to replace clauses in a nonclausal version of the Davis-Putnam procedure, in the style of similar algorithms in [23] and <ref> [13] </ref>. Finally, we should mention the refinement of the obdd idea recently proposed by Anuchitanukul and Manna [1], which can achieve more compact representations by ignoring node labels when collapsing isomorphic subgraphs. Another area for future work is to compare obdds with efficient implementations of other Boolean manipulation methods.
Reference: 14. <author> Clarke, E. M., Fujita, M., McGeer, P. C., McMillan, K., Yang, J. C.-Y., and Zhao, X. </author> <title> Multi-terminal binary decision diagrams: an efficient data structure for matrix representation. </title> <booktitle> In Proc. Intl. Workshop on Logic Synthesis (May 1993). </booktitle>
Reference-contexts: In Minato's zero-suppressed obdds [29], variables are assumed to have a default value of false. Multi-terminal binary decision diagrams (mtbdds) are a generalization of obdds where terminal nodes correspond to the elements of an arbitrary finite domain (not just true and false) <ref> [2, 14] </ref>. Multi-valued decision diagrams (mdds) are a similar extension where branches can be more than binary [25]. All these extensions seem well-suited, in particular, for the quasigroup problems, and such an application is left as another intriguing future experiment.
Reference: 15. <author> Crawford, J. M., and Auton, L. D. </author> <title> Experimental results on the crossover point in satisfiability problems. </title> <booktitle> In Proc. 11 th Nat. Conf. on AI (1993), </booktitle> <pages> pp. 21-27. </pages>
Reference-contexts: Ldpp implements the Davis-Putnam procedure without logical refinements, and is fairly efficient because of the way it performs the crucial assign operation. Ldpp uses reversible destructive list operations, similarly to Zhang's Sato [41], Crawford and Au-ton's Tableau <ref> [15] </ref>, and Letz's Semprop theorem provers. All of the following problems were also run using Sato, a discrimination tree-based implementation written in C, with comparable results. <p> On the other hand, obdds do not seem well-suited to clausal form, in the absence of heuristics. For instance, we tested unsatisfiable random 3-SAT problems with a 4:29 clause-to-variable ratio, experimentally determined to generate the "hardest" such problems <ref> [15] </ref>. For problems with 172 clauses over 40 propositions, the average obdd time was 173.92 seconds, for an average maximum size of 245,305 nodes, while the average ldpp time was 0.19 second, with an average of 64.75 branches.
Reference: 16. <author> Davis, M., Logemann, G., and Loveland, D. </author> <title> A machine program for theorem-proving. </title> <journal> Comm. ACM 5, </journal> <month> 7 (July </month> <year> 1962), </year> <pages> 394-397. </pages>
Reference-contexts: 1 Introduction We compare two of the most successful decision procedures for propositional logic: Ordered Binary Decision Diagrams [6] and the Davis-Putnam procedure <ref> [16, 17] </ref>. These methods were developed and used in different research communities with different applications in mind, and there has been a striking lack of comparison of their capabilities. Nevertheless, the topic is a matter of some curiosity. <p> For an overview of obdds directed to the automated deduction community, see [30]. The experiments reported here used the obdd C library written by David E. Long [26], which follows the guidelines described in [5]. 3 The Davis-Putnam Procedure The Davis-Putnam procedure 3 <ref> [16, 17] </ref> is an algorithm for deciding the satis-fiability of formulas in the propositional calculus. <p> Splitting on a literal in a positive clause reduces the number or size of nonunit positive clauses, pushing the problem closer to the tractable case of Horn clauses. 3 Or, more accurately, the Davis-Logemann-Loveland procedure, after <ref> [16] </ref>. DP (S; M) 1. If S = fg (S is the satisfiable empty set of clauses), return fMg. 2. If fg 2 S (S contains the unsatisfiable empty clause), return fg. 3.
Reference: 17. <author> Davis, M., and Putnam, H. </author> <title> A computing procedure for quantification theory. </title> <editor> J. </editor> <booktitle> ACM 7 (1960), </booktitle> <pages> 201-215. </pages>
Reference-contexts: 1 Introduction We compare two of the most successful decision procedures for propositional logic: Ordered Binary Decision Diagrams [6] and the Davis-Putnam procedure <ref> [16, 17] </ref>. These methods were developed and used in different research communities with different applications in mind, and there has been a striking lack of comparison of their capabilities. Nevertheless, the topic is a matter of some curiosity. <p> For an overview of obdds directed to the automated deduction community, see [30]. The experiments reported here used the obdd C library written by David E. Long [26], which follows the guidelines described in [5]. 3 The Davis-Putnam Procedure The Davis-Putnam procedure 3 <ref> [16, 17] </ref> is an algorithm for deciding the satis-fiability of formulas in the propositional calculus.
Reference: 18. <author> Devadas, S. </author> <title> Comparing two-level and ordered binary decision diagram represen-tations of logic functions. </title> <journal> IEEE Trans. on Computer-Aided Design of Integrated Circuits and Systems 12, </journal> <month> 5 (May </month> <year> 1993), </year> <pages> 722-723. </pages>
Reference-contexts: Also, the obdd representation is not always more compact than clausal form: Devadas <ref> [18] </ref> describes a class of functions with polynomial sum-of-products representation (so that their complements have polynomial clausal form) but with an exponential obdd representation under any variable ordering. 5 Conclusions In general, we can say that obdds are well-suited for representing large numbers of solutions that share a recursive structure (e.g.,
Reference: 19. <author> Friedman, S. J., and Supowitz, K. J. </author> <title> Finding the optimal variable ordering for binary decision diagrams. </title> <journal> IEEE Trans. on Computers 39, </journal> <month> 5 (May </month> <year> 1990), </year> <pages> 710-713. </pages>
Reference-contexts: We will discuss this problem at length in Section 4; for now, we note that most work on variable ordering heuristics is in the circuit domain (e.g., [10]), and that the current best algorithm for computing an optimal ordering for a given formula is exponential in the number of variables <ref> [19] </ref>. A basic feature of solving constraint-satisfaction problems using obdds alone is that there is no search: the problem-solving process consists entirely of constructing an obdd representation for a Boolean function that satisfies a given set of constraints. Thus, the final result represents all solutions.
Reference: 20. <author> Fujita, M., Slaney, J., and Bennett, F. </author> <title> Automatic generation of some results in finite algebra. </title> <booktitle> In Proc. 13 th Intl. Joint Conf. on AI (1993), </booktitle> <pages> pp. 52-57. </pages>
Reference-contexts: 27,265 584 12 76.92 155,196 868 4.4 Quasigroup Existence Problems The next class of problems we investigated is more substantial: quasigroup existence problems, some of which were open until recently settled with the assistance of automated reasoning programs, including the ldpp, ddpp and Sato implementations of the Davis-Putnam procedure (see <ref> [20, 37] </ref>). Briefly, the "QG5" quasigroup problem is finding an n by n multiplication table over the elements f1; : : : ; ng that satisfies the equation ((ba)b)b = a for all elements a and b. <p> Hasegawa and by Sato, and n = 18 is the next open one). Two sets of extra constraints used to restrict the search in <ref> [20] </ref> and [37] were also of great help in finding solutions using obdds. The first reduces the number of isomorphic copies (but does not affect the existence of solutions) by assuming that x n 6= z whenever z + 1 &lt; x.
Reference: 21. <author> Hsiang, J. </author> <title> Refutational theorem proving using term-rewriting systems. </title> <booktitle> Artificial Intelligence 3, </booktitle> <month> 25 (Mar. </month> <year> 1985), </year> <pages> 255-300. </pages>
Reference-contexts: Another area for future work is to compare obdds with efficient implementations of other Boolean manipulation methods. For instance, Hsiang <ref> [21] </ref> presents a system of rewrite rules that yields a canonical form, built using ^ and xor operations, for any Boolean expression. These were already used in [12] together with the Knuth-Bendix completion procedure to prove Boolean equivalences for circuit verification.
Reference: 22. <author> Hu, A. J., and Dill, D. L. </author> <title> Reducing BDD size by exploiting functional dependencies. </title> <booktitle> In 30 th Design Automation Conf. </booktitle> <year> (1993), </year> <pages> pp. 266-271. </pages>
Reference-contexts: Large obdd sizes occur when variables dependent on each other are far apart in the ordering (see <ref> [22] </ref>). In the variable ordering we used, constraints within rows will produce small obdd sizes, while those within columns will generate large ones. Constraints that jump around the table will tend to produce large obdds.
Reference: 23. <author> Jeong, S.-W., and Somenzi, F. </author> <title> A new algorithm for the binate covering problem and its application to the minimization of Boolean relations. </title> <booktitle> In IEEE Intl. Conf. on Computer-Aided Design (1992), </booktitle> <pages> pp. 417-420. </pages>
Reference-contexts: All these extensions seem well-suited, in particular, for the quasigroup problems, and such an application is left as another intriguing future experiment. So is the possibility of using obdds to replace clauses in a nonclausal version of the Davis-Putnam procedure, in the style of similar algorithms in <ref> [23] </ref> and [13]. Finally, we should mention the refinement of the obdd idea recently proposed by Anuchitanukul and Manna [1], which can achieve more compact representations by ignoring node labels when collapsing isomorphic subgraphs.
Reference: 24. <author> Joyce, J., and Seger, C.-J. </author> <title> Linking BDD-based symbolic evaluation to interactive theorem-proving. </title> <booktitle> In 30 th Design Automation Conf. </booktitle> <year> (1993), </year> <pages> pp. 469-474. </pages>
Reference-contexts: Obdds have been successfully combined with interactive theorem-provers <ref> [24] </ref>, and have been found useful in Constraint Logic Programming languages that include Boolean constraints [11, 32]. But except for the work of A. Rauzy [31], little comparative analysis of obdds has been done in this setting.
Reference: 25. <author> Kam, T. Y. K., and Brayton, R. K. </author> <title> Multi-valued decision diagrams. </title> <type> Technical Report UCB/ERL M90/125, </type> <institution> University of California, Berkeley, </institution> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Multi-terminal binary decision diagrams (mtbdds) are a generalization of obdds where terminal nodes correspond to the elements of an arbitrary finite domain (not just true and false) [2, 14]. Multi-valued decision diagrams (mdds) are a similar extension where branches can be more than binary <ref> [25] </ref>. All these extensions seem well-suited, in particular, for the quasigroup problems, and such an application is left as another intriguing future experiment.
Reference: 26. <author> Long, D. E. </author> <title> Model Checking, Abstraction, and Compositional Verification. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon Univ., </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: See [8] for a survey of obdds and their applications, the most successful of which is the symbolic model checking of finite-state hardware specifications <ref> [9, 26, 28] </ref>. For an overview of obdds directed to the automated deduction community, see [30]. The experiments reported here used the obdd C library written by David E. <p> For an overview of obdds directed to the automated deduction community, see [30]. The experiments reported here used the obdd C library written by David E. Long <ref> [26] </ref>, which follows the guidelines described in [5]. 3 The Davis-Putnam Procedure The Davis-Putnam procedure 3 [16, 17] is an algorithm for deciding the satis-fiability of formulas in the propositional calculus. <p> Other Davis-Putnam heuristics, perhaps specific to the circuit domain, are yet to be explored; so are refinements that exploit symmetry or use more elaborate backtracking techniques. 10 Dynamic variable ordering for obdds [33] further expands the space of strategies. Experiments with the methods of Long's package <ref> [26] </ref> yielded negative results. 5.1 Related and Future Work Unfortunately, there seems to be little work directly related to that reported in this paper, which we hope will encourage more extensive experimental efforts and more detailed theoretical analyses in the future.
Reference: 27. <author> McCarthy, J. </author> <title> A tough nut for proof procedures. </title> <type> AI Memo 16, </type> <institution> Stanford University, </institution> <month> July </month> <year> 1964. </year>
Reference-contexts: in a time comparable to that taken by ldpp for n = 11. 4.3 The Mutilated Checkerboard Problem A classic problem in Artificial Intelligence is the Mutilated Checkerboard Problem: whether one can cover with dominoes an n fi n checkerboard from which two squares from opposite corners have been removed <ref> [27] </ref>. Although there is an elegant proof of the impossibility of doing so in the general case, 8 here we focus only on the corresponding satisfiability problems for particular values of n.
Reference: 28. <author> McMillan, K. L. </author> <title> Symbolic Model Checking. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1993. </year>
Reference-contexts: See [8] for a survey of obdds and their applications, the most successful of which is the symbolic model checking of finite-state hardware specifications <ref> [9, 26, 28] </ref>. For an overview of obdds directed to the automated deduction community, see [30]. The experiments reported here used the obdd C library written by David E. <p> Tightening these bounds appears to be an interesting exercise in combinatorics, from which we refrain. For more general techniques for proving lower bounds on obdd representations see [7], where Bryant proves an exponential lower bound for integer multiplication. (Nonetheless, McMillan <ref> [28] </ref> has characterized a large class of circuits with polynomial-size obdd representations.) It is possible for two sets of constraints that are "intractable" on their own to be combined efficiently into a polynomial-sized one.
Reference: 29. <author> Minato, S. </author> <title> Zero-supressed BDDs for set manipulation in combinatorial problems. </title> <booktitle> In 30 th Design Automation Conf. </booktitle> <year> (1993), </year> <pages> pp. 272-277. </pages>
Reference-contexts: We have considered only one particular way of using obdds in classical automated deduction tasks, and there may be other, more fruitful uses. Similarly, numerous variants of the obdd method have been recently proposed as more specialized alternatives for different tasks. In Minato's zero-suppressed obdds <ref> [29] </ref>, variables are assumed to have a default value of false. Multi-terminal binary decision diagrams (mtbdds) are a generalization of obdds where terminal nodes correspond to the elements of an arbitrary finite domain (not just true and false) [2, 14].
Reference: 30. <author> Moore, J. S. </author> <title> Introduction to the OBDD algorithm for the ATP community. </title> <type> Technical Report 84, </type> <institution> Computational Logic, Inc., Austin, Texas, </institution> <month> Oct. </month> <year> 1992. </year>
Reference-contexts: When isomorphic subgraphs are merged, the obdd representation is canonical given a fixed ordering on the variables: two functions are equal if and only if they are represented by the same obdd. As Moore <ref> [30] </ref> points out, obdd representations can be efficiently manipulated due mainly to three factors: computing Boolean operations over functions represented by obdds can be speeded up by taking into account the fixed variable ordering, structure can be shared among obdds, and, finally, the results of combination operations can be cached for <p> See [8] for a survey of obdds and their applications, the most successful of which is the symbolic model checking of finite-state hardware specifications [9, 26, 28]. For an overview of obdds directed to the automated deduction community, see <ref> [30] </ref>. The experiments reported here used the obdd C library written by David E. Long [26], which follows the guidelines described in [5]. 3 The Davis-Putnam Procedure The Davis-Putnam procedure 3 [16, 17] is an algorithm for deciding the satis-fiability of formulas in the propositional calculus. <p> We end this section by pointing out that obdds did not exhibit good performance on the ordered semigroup problems from [36]. 4.5 Boolean Equivalence Benchmarks Finally, we compared the two approaches using the IFIP Boolean equivalence benchmarks from [13], also discussed by Moore <ref> [30] </ref>. These benchmarks can be described as lists of equations of the form v = exp, where v is a Boolean variable and exp is a Boolean expression. <p> That is, the obdd procedure is incremental . Also, as Moore <ref> [30] </ref> points out, it is particularly easy to test the equivalence of two functions using obdds: simply determine if they have the same normal form, which can be done with a single pointer comparison in an efficient implementation. Table 4.
Reference: 31. <author> Rauzy, A. </author> <title> Using enumerative methods for Boolean unification. In [3]. </title> <publisher> MIT Press, </publisher> <year> 1993, </year> <journal> ch. </journal> <volume> 13, </volume> <pages> pp. 237-251. </pages>
Reference-contexts: Obdds have been successfully combined with interactive theorem-provers [24], and have been found useful in Constraint Logic Programming languages that include Boolean constraints [11, 32]. But except for the work of A. Rauzy <ref> [31] </ref>, little comparative analysis of obdds has been done in this setting.
Reference: 32. <author> Rauzy, A. </author> <title> Notes on the design of an open Boolean solver. </title> <note> In Proc. Intl. Conf. on Logic Programming (1994). To appear. </note>
Reference-contexts: Obdds have been successfully combined with interactive theorem-provers [24], and have been found useful in Constraint Logic Programming languages that include Boolean constraints <ref> [11, 32] </ref>. But except for the work of A. Rauzy [31], little comparative analysis of obdds has been done in this setting.
Reference: 33. <author> Rudell, R. </author> <title> Dynamic variable ordering for ordered binary decision diagrams. </title> <booktitle> In IEEE Intl. Conf. on Computer-Aided Design (Nov. </booktitle> <year> 1993), </year> <pages> pp. 42-47. </pages>
Reference-contexts: Other Davis-Putnam heuristics, perhaps specific to the circuit domain, are yet to be explored; so are refinements that exploit symmetry or use more elaborate backtracking techniques. 10 Dynamic variable ordering for obdds <ref> [33] </ref> further expands the space of strategies.
Reference: 34. <author> Selman, B., Levesque, H., and Mitchell, D. </author> <title> A new method for solving hard satisfiability problems. </title> <booktitle> In Proc. 10 th Nat. Conf. on AI (July 1992), </booktitle> <pages> pp. 440-446. </pages>
Reference-contexts: Hill-climbing procedures can find models for hard 3-SAT problems beyond the reach of the methods considered here <ref> [34] </ref> (but have so far been found to be ineffective for finding models of satisfiable quasigroup problems [40]); however, they suffer from being incomplete, and thus are not decision procedures that can be used in refutational theorem proving or to effectively enumerate all the solutions for a given problem.
Reference: 35. <author> Simonis, H., and Dincbas, M. </author> <title> Propositional calculus problems in CHIP. In [3]. </title> <publisher> MIT Press, </publisher> <year> 1993, </year> <journal> ch. </journal> <volume> 15, </volume> <pages> pp. 269-285. </pages>
Reference-contexts: This research was supported by the National Science Foundation under Grant CCR 8922330. There are, of course, other methods for solving propositional problems, in-cluding integer linear programming and the many approaches used within the Constraint Logic Programming (CLP) framework (e.g., <ref> [35] </ref>). In particular, CLP systems|where binary decision diagrams themselves have been used to represent Boolean constraints|have proved to be effective for a wide range of problems, including encouraging preliminary results for the quasigroup ones [39].
Reference: 36. <author> Slaney, J. </author> <title> Finder version 3.0 | notes and guide. </title> <type> Technical report, </type> <institution> Centre for Information Science Research, Australian National University, </institution> <year> 1993. </year>
Reference-contexts: first the classic n-queens puzzle|placing n queens on an n fin chess board so that no two queens attack each other|not because the puzzle has any intrinsic interest to us, 4 but because it is a simple and well-known constraint satisfaction benchmark that illustrates interesting issues concerning obdds. 4 Slaney <ref> [36] </ref> presents a thoughtful critique of this problem as a CSP benchmark. The problem was encoded in obdd form using a Boolean variable for each of the n 2 positions in the board; an assignment of true to a variable indicates a queen in the corresponding position. <p> And again, memory limitations place obdds at a disadvantage due to the exponential growth in the maximum obdd size. We end this section by pointing out that obdds did not exhibit good performance on the ordered semigroup problems from <ref> [36] </ref>. 4.5 Boolean Equivalence Benchmarks Finally, we compared the two approaches using the IFIP Boolean equivalence benchmarks from [13], also discussed by Moore [30].
Reference: 37. <author> Slaney, J., Fujita, M., and Stickel, M. </author> <title> Automated reasoning and exhaustive search: Quasigroup existence problems. Computers and Mathematics with Applications (1993). </title> <note> To appear. </note>
Reference-contexts: Nevertheless, the topic is a matter of some curiosity. After the successful application of the Davis-Putnam procedure to previously open quasigroup existence problems <ref> [37] </ref>, the question of how well obdds would do on the same problems arose repeatedly. Here we have tried to answer that and similar questions. <p> Ldpp (the List-based Davis-Putnam Prover) is a LISP implementation of the Davis-Putnam procedure written by Mark Stickel, and a successor of the earlier ddpp used to solve quasigroup problems in <ref> [37] </ref>. Ldpp implements the Davis-Putnam procedure without logical refinements, and is fairly efficient because of the way it performs the crucial assign operation. Ldpp uses reversible destructive list operations, similarly to Zhang's Sato [41], Crawford and Au-ton's Tableau [15], and Letz's Semprop theorem provers. <p> 27,265 584 12 76.92 155,196 868 4.4 Quasigroup Existence Problems The next class of problems we investigated is more substantial: quasigroup existence problems, some of which were open until recently settled with the assistance of automated reasoning programs, including the ldpp, ddpp and Sato implementations of the Davis-Putnam procedure (see <ref> [20, 37] </ref>). Briefly, the "QG5" quasigroup problem is finding an n by n multiplication table over the elements f1; : : : ; ng that satisfies the equation ((ba)b)b = a for all elements a and b. <p> Hasegawa and by Sato, and n = 18 is the next open one). Two sets of extra constraints used to restrict the search in [20] and <ref> [37] </ref> were also of great help in finding solutions using obdds. The first reduces the number of isomorphic copies (but does not affect the existence of solutions) by assuming that x n 6= z whenever z + 1 &lt; x.
Reference: 38. <author> Subramanian, S. </author> <title> A Mechanized Framework for Specifying Problem Domains and Verifying Plans. </title> <type> PhD thesis, </type> <institution> Dept. of Comp. Science, U. of Texas, Austin, </institution> <year> 1993. </year>
Reference-contexts: The obdd strategy followed the variable ordering, consecutively adding all the constraints for each square. Most reasonable strategies yielded good performance; however, some that proved faster for n 12 could not be completed for n = 13 because of obdd exponential space requirements. 8 Subramanian <ref> [38] </ref> presents an interactive, mechanical verification of this theorem using Nqthm, the Boyer-Moore prover. Table 2.
Reference: 39. <author> Wallace, M. </author> <type> Personal communication. </type> <institution> ECRC, Munich, Germany, </institution> <month> July </month> <year> 1993. </year>
Reference-contexts: In particular, CLP systems|where binary decision diagrams themselves have been used to represent Boolean constraints|have proved to be effective for a wide range of problems, including encouraging preliminary results for the quasigroup ones <ref> [39] </ref>.
Reference: 40. <author> Walsh, T. </author> <type> Personal communication. </type> <institution> University of Edinburgh, </institution> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: Hill-climbing procedures can find models for hard 3-SAT problems beyond the reach of the methods considered here [34] (but have so far been found to be ineffective for finding models of satisfiable quasigroup problems <ref> [40] </ref>); however, they suffer from being incomplete, and thus are not decision procedures that can be used in refutational theorem proving or to effectively enumerate all the solutions for a given problem. This research was supported by the National Science Foundation under Grant CCR 8922330.
Reference: 41. <author> Zhang, H. Sato: </author> <title> A decision procedure for propositional logic. Association for Automated Reasoning Newsletter, </title> <month> 22 (Mar. </month> <year> 1993), </year> <pages> 1-3. </pages>
Reference-contexts: Ldpp implements the Davis-Putnam procedure without logical refinements, and is fairly efficient because of the way it performs the crucial assign operation. Ldpp uses reversible destructive list operations, similarly to Zhang's Sato <ref> [41] </ref>, Crawford and Au-ton's Tableau [15], and Letz's Semprop theorem provers. All of the following problems were also run using Sato, a discrimination tree-based implementation written in C, with comparable results.
Reference: 42. <author> Zhang, H., and Stickel, M. E. </author> <title> Implementing the Davis-Putnam algorithm by tries. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, University of Iowa, </institution> <month> Aug. </month> <year> 1994. </year>
Reference-contexts: Ldpp uses reversible destructive list operations, similarly to Zhang's Sato [41], Crawford and Au-ton's Tableau [15], and Letz's Semprop theorem provers. All of the following problems were also run using Sato, a discrimination tree-based implementation written in C, with comparable results. See <ref> [42] </ref> for a detailed description of ldpp and Sato. 4 Experimental Results 4.1 The n-Queens Puzzle We consider first the classic n-queens puzzle|placing n queens on an n fin chess board so that no two queens attack each other|not because the puzzle has any intrinsic interest to us, 4 but because
References-found: 42

