URL: ftp://ftp.cs.umass.edu/pub/osl/papers/vldb93.ps.Z
Refering-URL: http://www.cs.umass.edu/~brown/
Root-URL: 
Title: Update Logging for Persistent Programming Languages: A Comparative Performance Evaluation  
Author: Antony L. Hosking Eric W. Brown J. Eliot B. Moss 
Address: Amherst, MA 01003 USA  
Affiliation: Object Systems Laboratory Department of Computer Science University of Massachusetts  
Abstract: If persistent programming languages are to be accepted they must provide many of the standard features of traditional database systems, including resilience in the face of system failures in which the volatile database (in-memory database buffers) is lost. Ensuring the consistency of the database requires the generation of recovery information sufficient to restore the database to a consistent state after a crash. This paper examines a range of schemes for the efficient generation of recovery information in persistent programming languages, and evaluates their relative performance within an implementation of Persistent Smalltalk. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> M. P. Atkinson, P. J. Bailey, K. J. Chisholm, P. W. Cockshott, and R. Morrison. </author> <title> An approach to persistent programming. </title> <journal> The Computer Journal, </journal> <volume> 26(4) </volume> <pages> 360-365, </pages> <month> Nov. </month> <year> 1983. </year>
Reference-contexts: 1 Introduction Persistent programming languages combine the features of database systems and programming languages to allow the seamless manipulation of data, without regard for its potential lifetime, be it transient or persistent <ref> [1] </ref>. Useful persistent programming languages must support resilience in the face of system failures, an important feature of any database system. A crash results in the loss of the volatile part of the database, including all updates to persistent data that have not yet been propagated to the stable database.
Reference: [2] <author> M. J. Carey, D. J. DeWitt, J. E. Richardson, and E. J. Shekita. </author> <title> Storage management for objects in EXODUS. </title> <editor> In W. Kim and F. H. Lochovsky, editors, </editor> <booktitle> Object-Oriented Concepts, Databases, and Applications, chapter 14, </booktitle> <pages> pages 341-369. </pages> <publisher> ACM Press/Addison-Wesley, </publisher> <address> New York, New York, </address> <year> 1989. </year>
Reference-contexts: The systems considered in that study include version 1.2 of Ob-jectStore [11, 15], a commercially available object-oriented DBMS, and a number of software architectures based on the EXODUS Storage Manager (ESM) <ref> [2, 16] </ref>. Several of the architectures based on ESM require object updates to be carried out via a call interface, which modifies the object in the client buffer pool and generates a log record based on the changes.
Reference: [3] <author> R. G. G. Cattell and J. Skeen. </author> <title> Object operations benchmark. </title> <journal> ACM Trans. Database Syst., </journal> <volume> 17(1) </volume> <pages> 1-31, </pages> <month> Mar. </month> <year> 1992. </year>
Reference-contexts: unswizzling and comparison of objects that are unmodified but just happen to lie in a dirty card. 5 Experiments We draw on the benchmarks used by White and DeWitt [22] for comparison of the update schemes, who in turn based their benchmarks on those of the object operations benchmark, OO1 <ref> [3] </ref>. 5.1 The benchmark database We use the OO1 benchmark database, consisting of a collection of 20,000 part objects, indexed by part numbers in the range 1 through 20,000 with exactly three connections from each part to other parts.
Reference: [4] <author> K. Elhardt and R. Bayer. </author> <title> A database cache for high performance and fast restart in database systems. </title> <journal> ACM Trans. Database Syst., </journal> <volume> 9(4) </volume> <pages> 503-525, </pages> <month> Dec. </month> <year> 1984. </year>
Reference-contexts: The incorporation of transaction models in persistent programming languages remains an open topic of research. We are not directly concerned with that issue here, and merely remark that our recovery model could easily be integrated into any transaction model based on the database cache <ref> [4] </ref>. 3 Related work This work is loosely related to the performance study by White and DeWitt [22] which compares the overall performance of various object faulting and pointer swizzling schemes for persistent programming languages. <p> The general approach to logging and recovery used by all these systems was originally devised by Elhardt and Bayer for the database cache <ref> [4] </ref>. The database cache was designed for fast transaction commit and rapid recovery after a crash. Modifications are always applied to copies of original database pages in main memory (the cache) so that transaction abort merely requires deletion of the copies.
Reference: [5] <author> A. Goldberg and D. Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: A comparison of alternative schemes for object faulting within this basic architecture appears elsewhere [9]. 2.1 Persistent Smalltalk Our implementation of Smalltalk is based on the definition of Goldberg and Robson <ref> [5] </ref>. The implementation consists of two components: the virtual machine and the virtual image. The virtual machine implements a bytecode instruction set to which Smalltalk source code is compiled, as well as other primitive functionality. <p> The virtual machine implements a bytecode instruction set to which Smalltalk source code is compiled, as well as other primitive functionality. While we have retained the standard bytecode instruction set, our implementation of the virtual machine differs somewhat from that described in <ref> [5] </ref>. The virtual image is derived from an early commercial version of Smalltalk with minor modifications. It implements (in Smalltalk) all the functionality of a Smalltalk development environment, including editors, browsers, the bytecode compiler, class libraries, etc., all of which are first-class objects in the Smalltalk sense.
Reference: [6] <author> J. N. Gray. </author> <title> Notes on database operating systems. </title> <editor> In R. Bayer et al., editors, </editor> <booktitle> Operating Systems: An Advanced Course, Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: Here we go beyond a comparison of logging granularities and investigate different methods for noting modifications. The database cache, and in fact all of the logging schemes described here, are versions of the write ahead log from traditional database systems <ref> [6, 21, 7] </ref>. However, they are distinguished by the fact that they are intended for nontraditional database applications, in which the characteristics of data access and manipulation are quite different from traditional (e.g., relational) database systems, requiring new Page 4 mechanisms and semantics for transactions, logging, and recovery.
Reference: [7] <author> T. Haerder and A. Reuter. </author> <title> Principles of transaction-oriented database recovery. </title> <journal> ACM Comput. Surv., </journal> <volume> 15 </volume> <pages> 287-318, </pages> <month> Dec. </month> <year> 1983. </year>
Reference-contexts: Here we go beyond a comparison of logging granularities and investigate different methods for noting modifications. The database cache, and in fact all of the logging schemes described here, are versions of the write ahead log from traditional database systems <ref> [6, 21, 7] </ref>. However, they are distinguished by the fact that they are intended for nontraditional database applications, in which the characteristics of data access and manipulation are quite different from traditional (e.g., relational) database systems, requiring new Page 4 mechanisms and semantics for transactions, logging, and recovery.
Reference: [8] <author> A. L. Hosking. </author> <title> Main memory management for persistence, </title> <address> Oct. </address> <year> 1991. </year> <title> Position paper presented at the OOPSLA '91 Workshop on Garbage Collection. </title>
Reference-contexts: Outside of that constraint, the buffer manager is free to use any appropriate buffer replacement policy. Management of swizzled objects in the virtual memory address space of the program is described in <ref> [8] </ref>. That scheme is compatible with the recovery model, since modified objects that have been selected for replacement will be unswizzled and logged in a checkpoint fashion. The recovery model is indifferent to concurrency, which can be introduced to the architecture in two ways.
Reference: [9] <author> A. L. Hosking and J. E. B. Moss. </author> <title> Object fault handling for persistent programming languages: A performance evaluation. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <address> Washington, DC, </address> <month> Sept. </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: The particular mechanism used here is not relevant to this study, since it is kept constant, while the recovery support schemes are varied. A comparison of alternative schemes for object faulting within this basic architecture appears elsewhere <ref> [9] </ref>. 2.1 Persistent Smalltalk Our implementation of Smalltalk is based on the definition of Goldberg and Robson [5]. The implementation consists of two components: the virtual machine and the virtual image.
Reference: [10] <author> A. L. Hosking, J. E. B. Moss, and D. Stefanovic. </author> <title> A comparative performance evaluation of write barrier implementations. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 92-109, </pages> <address> Vancouver, Canada, </address> <month> Oct. </month> <year> 1992. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 27, </volume> <month> 10 (Oct. </month> <year> 1992). </year>
Reference-contexts: We are interested in quantifying the overheads of more lightweight mechanisms, inspired by our experience as programming language implementors in facing similar problems of update detection in other domains such as garbage collection <ref> [10] </ref>. 4 Noting updates The lightweight mechanisms used for detecting updates in this study are drawn from solutions to the write barrier problem in garbage collection: the act of storing a pointer in an object is noted in order to minimise the number of pointer locations that must be examined during <p> lightweight mechanisms used for detecting updates in this study are drawn from solutions to the write barrier problem in garbage collection: the act of storing a pointer in an object is noted in order to minimise the number of pointer locations that must be examined during any given garbage collection <ref> [10] </ref>. Similarly, efficient checkpointing requires keeping track of all updates to objects, to minimise the number of locations that must be unswizzled and logged.
Reference: [11] <author> C. Lamb, G. Landis, J. Orenstein, and D. Weinreb. </author> <title> The ObjectStore database system. </title> <journal> Commun. ACM, </journal> <volume> 34(10) </volume> <pages> 50-63, </pages> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: The systems considered in that study include version 1.2 of Ob-jectStore <ref> [11, 15] </ref>, a commercially available object-oriented DBMS, and a number of software architectures based on the EXODUS Storage Manager (ESM) [2, 16].
Reference: [12] <author> J. E. B. Moss. </author> <title> Design of the Mneme persistent object store. </title> <journal> ACM Trans. Inf. Syst., </journal> <volume> 8(2) </volume> <pages> 103-139, </pages> <month> Apr. </month> <year> 1990. </year>
Reference-contexts: We use the Mneme persistent object store <ref> [12] </ref> to manage the storage and retrieval of objects from disk. Mneme groups persistent objects into segments for transfer to and from secondary storage, buffering the segments in main memory on the client machine as necessary.
Reference: [13] <author> J. E. B. Moss. </author> <title> Working with persistent objects: To swizzle or not to swizzle. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 18(8) </volume> <pages> 657-673, </pages> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: In particular, since Mneme uses object identifiers to refer to objects while the program uses virtual memory pointers, object references are converted to direct memory pointers for manipulation by the program. This conversion of identifiers to pointers is known as swizzling <ref> [13] </ref>. For the purposes of this study objects are copied one at a time from the buffer pool, as opposed to all the objects of a segment being copied at once.
Reference: [14] <author> J. E. B. Moss, B. Leban, and P. K. Chrysanthis. </author> <title> Finer grained concurrency control for the database cache. </title> <booktitle> In Proceedings of the Third International Conference on Data Engineering, </booktitle> <pages> pages 96-103, </pages> <address> Los Angeles, CA, </address> <month> Feb. </month> <year> 1987. </year> <note> IEEE. </note>
Reference-contexts: Recovery involves reconstructing the cache from the safe. To keep the safe to a manageable size, it is periodically cleaned by removing log entries that are no longer necessary for recovery. Elhardt and Bayer require locking and logging at the granularity of a page. Moss et al. <ref> [14] </ref> extend the database cache algorithms to allow locking and logging at a finer granularity. The goal of their extension is to increase concurrency and, ultimately, performance.
Reference: [15] <institution> Object Design, Inc. ObjectStore User Guide, </institution> <month> Oct. </month> <year> 1990. </year> <note> Release 1.0. </note>
Reference-contexts: The systems considered in that study include version 1.2 of Ob-jectStore <ref> [11, 15] </ref>, a commercially available object-oriented DBMS, and a number of software architectures based on the EXODUS Storage Manager (ESM) [2, 16].
Reference: [16] <author> D. Schuh, M. Carey, and D. DeWitt. </author> <title> Persistence in E revisitedimplementation experiences. </title> <editor> In A. Dearle, G. M. Shaw, and S. B. Zdonik, editors, </editor> <booktitle> Proceedings of the Fourth International Workshop on Persistent Object Systems, </booktitle> <pages> pages 345-359, </pages> <address> Martha's Vineyard, Massachusetts, </address> <month> Sept. </month> <year> 1990. </year> <title> Published as Implementing Persistent Object Bases: </title> <booktitle> Principles and Practice, </booktitle> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: The systems considered in that study include version 1.2 of Ob-jectStore [11, 15], a commercially available object-oriented DBMS, and a number of software architectures based on the EXODUS Storage Manager (ESM) <ref> [2, 16] </ref>. Several of the architectures based on ESM require object updates to be carried out via a call interface, which modifies the object in the client buffer pool and generates a log record based on the changes.
Reference: [17] <author> R. A. Shaw. </author> <title> Improving garbage collector performance in virtual memory. </title> <type> Technical Report CSL-TR-87-323, </type> <institution> Stanford University, </institution> <month> Mar. </month> <year> 1987. </year>
Reference-contexts: to get the base of the card table, a shift to determine the index, an add to 2 An operating system could more efficiently supply the information needed in the page protection scheme if it offered appropriate calls to obtain the page dirty bits maintained by most memory management hardware <ref> [17] </ref>. 3 We first heard of this idea from Paul Wilson. Page 5 determine the byte entry's address, and a byte store of zero. 4 At checkpoint time the dirty cards containing persistent objects are scanned, to perform unswizzling and determine any differences that must be logged.
Reference: [18] <author> V. Singhal, S. V. Kakkad, and P. R. Wilson. </author> <title> Texas, an efficient, portable persistent store. </title> <booktitle> In Proceedings of the Fifth International Workshop on Persistent Object Systems, </booktitle> <pages> pages 11-33, </pages> <address> San Miniato, Italy, </address> <month> Sept. </month> <year> 1992. </year>
Reference-contexts: We explore this issue directly here, addressing the specific question of which method of generating recovery information is best, and what factors determine a method's effectiveness, all in the context of persistent programming languages. The Texas system <ref> [18, 23] </ref> uses a page mapping scheme similar to ObjectStore to fault objects and swizzle pointers. When a persistent object is to be assigned a virtual address, a page of virtual memory is reserved (and access protected) for the page in the persistent store that contains the object.
Reference: [19] <author> P. G. Sobalvarro. </author> <title> A lifetime-based garbage collector for LISP systems on general-purpose computers, 1988. B.S. </title> <type> Thesis, </type> <institution> Dept. of EECS, Massachusetts Institute of Technology, </institution> <address> Cambridge. </address>
Reference-contexts: They divide the memory into aligned logical regions of size 2 k bytesthe address of the first byte in the region will have k low bits zero. These regions are called cards, after <ref> [19, 24] </ref>. Each card has a corresponding entry in a card table indicating whether the card contains updated locations. Mapping an address to an entry in this table is simple: one shifts the address right by k and uses the result as an index into the table.
Reference: [20] <author> D. Ungar. </author> <title> Generation scavenging: A non-disruptive high performance storage reclamation algorithm. </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 157-167, </pages> <address> Pittsburgh, Pennsylvania, </address> <month> Apr. </month> <year> 1984. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 19, </volume> <month> 5 (May </month> <year> 1984). </year>
Reference-contexts: The drawback of this approach is additional checkpoint overhead required to scan the cached objects to find those that have been marked. To avoid scanning, the second scheme uses a remembered set <ref> [20] </ref> to record persistent objects that have been modified. A checkpoint need only process the entries in the remembered set to locate the objects that must be unswizzled and possibly logged. The remembered set is implemented as a dynamic hash table.
Reference: [21] <author> J. S. M. Verhofstad. </author> <title> Recovery techniques for database systems. </title> <journal> ACM Comput. Surv., </journal> <volume> 10(2) </volume> <pages> 167-195, </pages> <month> June </month> <year> 1978. </year>
Reference-contexts: Here we go beyond a comparison of logging granularities and investigate different methods for noting modifications. The database cache, and in fact all of the logging schemes described here, are versions of the write ahead log from traditional database systems <ref> [6, 21, 7] </ref>. However, they are distinguished by the fact that they are intended for nontraditional database applications, in which the characteristics of data access and manipulation are quite different from traditional (e.g., relational) database systems, requiring new Page 4 mechanisms and semantics for transactions, logging, and recovery.
Reference: [22] <author> S. J. White and D. J. DeWitt. </author> <title> A performance study of alternative object faulting and pointer swizzling strategies. </title> <booktitle> In Proceedings of the Eighteenth International Conference on Very Large Data Bases, </booktitle> <address> Vancouver, Canada, </address> <month> Aug. </month> <year> 1992. </year>
Reference-contexts: We are not directly concerned with that issue here, and merely remark that our recovery model could easily be integrated into any transaction model based on the database cache [4]. 3 Related work This work is loosely related to the performance study by White and DeWitt <ref> [22] </ref> which compares the overall performance of various object faulting and pointer swizzling schemes for persistent programming languages. <p> However, larger cards imply unnecessary checkpoint overhead to perform unswizzling and comparison of objects that are unmodified but just happen to lie in a dirty card. 5 Experiments We draw on the benchmarks used by White and DeWitt <ref> [22] </ref> for comparison of the update schemes, who in turn based their benchmarks on those of the object operations benchmark, OO1 [3]. 5.1 The benchmark database We use the OO1 benchmark database, consisting of a collection of 20,000 part objects, indexed by part numbers in the range 1 through 20,000 with
Reference: [23] <author> P. R. Wilson and S. V. Kakkad. </author> <title> Pointer swizzling at page fault time: Efficiently and compatibly supporting huge address spaces on standard hardware. </title> <booktitle> In Proceedings of the 1992 International Workshop on Object Orientation in Operating Systems, </booktitle> <pages> pages 364-377, </pages> <address> Paris, France, Sept. 1992. </address> <publisher> IEEE Press. </publisher>
Reference-contexts: We explore this issue directly here, addressing the specific question of which method of generating recovery information is best, and what factors determine a method's effectiveness, all in the context of persistent programming languages. The Texas system <ref> [18, 23] </ref> uses a page mapping scheme similar to ObjectStore to fault objects and swizzle pointers. When a persistent object is to be assigned a virtual address, a page of virtual memory is reserved (and access protected) for the page in the persistent store that contains the object.
Reference: [24] <author> P. R. Wilson and T. G. Moher. </author> <title> Design of the Opportunistic Garbage Collector. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 23-35, </pages> <address> New Orleans, Louisiana, </address> <month> Oct. </month> <year> 1989. </year> <journal> ACM SIGPLAN Not. </journal> <volume> 24, </volume> <month> 10 (Oct. </month> <year> 1989). </year> <pages> Page 12 </pages>
Reference-contexts: They divide the memory into aligned logical regions of size 2 k bytesthe address of the first byte in the region will have k low bits zero. These regions are called cards, after <ref> [19, 24] </ref>. Each card has a corresponding entry in a card table indicating whether the card contains updated locations. Mapping an address to an entry in this table is simple: one shifts the address right by k and uses the result as an index into the table.
References-found: 24

