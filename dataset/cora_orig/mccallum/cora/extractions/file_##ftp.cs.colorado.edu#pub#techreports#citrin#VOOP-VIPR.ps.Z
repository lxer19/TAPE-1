URL: file://ftp.cs.colorado.edu/pub/techreports/citrin/VOOP-VIPR.ps.Z
Refering-URL: http://www.cs.colorado.edu/current/faculty/compilers.html
Root-URL: http://www.cs.colorado.edu
Title: To appear in Visual Object-Oriented Programming: Concepts and Environments, The Design of a Completely Visual
Author: Margaret Burnett, Adele Goldberg, Ted Lewis, Wayne Citrin Michael Doherty Benjamin Zorn 
Address: Boulder  
Affiliation: Department of Computer Science University of Colorado at  
Note: editors. 1994.  
Abstract: Object-oriented languages provide powerful programming features such as polymorphism, inheritance, and dynamic dispatch. While these features allow complex programs to be written more easily, they also make debugging and understanding these programs more difficult. Object-oriented languages have relied on simple visualization tools such as class browsers to aid programmers in understanding their programs. In this paper, we argue that a completely visual object-oriented programming language, Vipr, has significant advantages over textual object-oriented languages. We describe how Vipr represents all aspects of object-oriented programs including objects, classes, inheritance, polymorphism, and dynamic dispatch. By completely visual, we mean that the semantics of programs written in our language can be entirely described by simple graphical rules. Vipr provides a framework for and integrates existing methods of understanding the structure and execution of visual programs. Also, we discuss the programming environment support required by Vipr and argue why the language, with this environment, will be usable by expert programmers for solving large problems.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. Bell and C. Lewis. ChemTrains: </author> <title> A language for creating behaving pictures. </title> <booktitle> In Proceedings of the 1993 IEEE Symposium on Visual Languages, </booktitle> <pages> pages 188-195, </pages> <address> Bergen, Norway, </address> <year> 1993. </year>
Reference-contexts: If the "before" part of a before/after pair matches part of the state, the state is transformed to 6 conform to the "after" part of the pair. BITPICT [11] is one of the simplest of such languages, in that its before/after pairs are simple pixel patterns. ChemTrains <ref> [1] </ref> and Vampire [16] allow more complex visual entities and relations, and also permit variables in the transformation rules. <p> Because the array "shapes" and variable "s" have not been initialized, we see that they currently indicate a pseudo-instance of the shape class, with all possible subclasses available. 19 main () - int i = 0; double sum; shape *shapes [2], *s; shapes [0] = new square; shapes <ref> [1] </ref> = new circle; while (i &lt; 2) - s = shapes [i]; // Statement 1 sum += s-&gt;area (); i += 1; cout &lt;< "Total Area = " &lt;< sum &lt;< ""n"; - 20 21 Figures 16, 17, and 18 show the dynamic execution of this program at Statement 1
Reference: [2] <author> A. Borning. </author> <title> Programming language aspects of ThingLab. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 3(4) </volume> <pages> 353-387, </pages> <year> 1981. </year>
Reference-contexts: In Rehearsal World, however, methods may be defined by demonstration as well as textually, but the representations of methods maintained by the system are textual Smalltalk. Demonstrational systems are a natural application for visual object-orientation. Borning's ThingLab <ref> [2] </ref> is probably the most famous such system. ThingLab employs a constraint model rather than an imperative model, however, and while the constraints may be represented graphically [3], the methods for resolving the constraints are displayed textually. A number of other visual languages provide object-oriented features. <p> Because the array "shapes" and variable "s" have not been initialized, we see that they currently indicate a pseudo-instance of the shape class, with all possible subclasses available. 19 main () - int i = 0; double sum; shape *shapes <ref> [2] </ref>, *s; shapes [0] = new square; shapes [1] = new circle; while (i &lt; 2) - s = shapes [i]; // Statement 1 sum += s-&gt;area (); i += 1; cout &lt;< "Total Area = " &lt;< sum &lt;< ""n"; - 20 21 Figures 16, 17, and 18 show the
Reference: [3] <author> A. Borning. </author> <title> Defining constraints graphically. </title> <booktitle> In Proceedings of CHI'86|Human Factors in Computing, </booktitle> <pages> pages 137-143. </pages> <publisher> ACM Press, </publisher> <year> 1986. </year>
Reference-contexts: Demonstrational systems are a natural application for visual object-orientation. Borning's ThingLab [2] is probably the most famous such system. ThingLab employs a constraint model rather than an imperative model, however, and while the constraints may be represented graphically <ref> [3] </ref>, the methods for resolving the constraints are displayed textually. A number of other visual languages provide object-oriented features. Prograph [8, 9], for example, provides a class system where the hierarchy is presented graphically.
Reference: [4] <author> M. Burnett. </author> <title> Abstraction in the Demand-Driven, Temporal-Assignment, Visual Language Model. </title> <type> PhD thesis, </type> <institution> University of Kansas, </institution> <year> 1991. </year>
Reference-contexts: A number of other visual languages provide object-oriented features. Prograph [8, 9], for example, provides a class system where the hierarchy is presented graphically. Inheritance, instance variables, dynamic dispatch, and polymorphism are all provided in Prograph, although dynamic 7 dispatch and polymorphism are not shown graphically. Forms/3 <ref> [4, 5] </ref> , although not explicitly an object-oriented language, offers data abstraction and polymorphism. Class inheritance is not provided. 4 An Introduction to Vipr Vipr is a programming language and not a program representation.
Reference: [5] <author> M. Burnett. </author> <title> Types and type inference in a visual programming language. </title> <booktitle> In Proc. IEEE Symposium on Visual Languages, </booktitle> <address> Bergen, NORWAY, 1993. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: A number of other visual languages provide object-oriented features. Prograph [8, 9], for example, provides a class system where the hierarchy is presented graphically. Inheritance, instance variables, dynamic dispatch, and polymorphism are all provided in Prograph, although dynamic 7 dispatch and polymorphism are not shown graphically. Forms/3 <ref> [4, 5] </ref> , although not explicitly an object-oriented language, offers data abstraction and polymorphism. Class inheritance is not provided. 4 An Introduction to Vipr Vipr is a programming language and not a program representation.
Reference: [6] <author> Wayne Citrin, Michael Doherty, and Benjamin Zorn. </author> <title> Control constructs in a completely visual imperative programming language. </title> <type> Technical Report CU-CS-672-93, </type> <institution> Department of Computer Science, University of Colorado, Boulder, Boulder, CO, </institution> <month> September </month> <year> 1993. </year>
Reference-contexts: as we have mentioned, one of the most significant features of Vipr is that its semantics may be defined exclusively in terms of graphical transformation rules, with no reference at all to any other textual language. 4.1 Control Constructs Although the control constructs of Vipr are interesting in themselves (see <ref> [6] </ref> for details) a detailed discussion is outside the scope of this paper and we only provide sufficient information to appreciate the unusual aspects of a completely visual programming language and to understand the subsequent discussion of objects and how they are handled in the language.
Reference: [7] <author> Wayne Citrin, Michael Doherty, and Benjamin Zorn. </author> <title> Formal semantics of control constructs in a completely visual imperative language. </title> <type> Technical Report CU-CS-673-93, </type> <institution> Department of Computer Science, University of Colorado, Boulder, Boulder, CO, </institution> <month> September </month> <year> 1993. </year> <note> In preparation. 25 </note>
Reference-contexts: The distinction between existing graphical representations and Vipr is that Vipr is intended to be an executable specification. That is, programs written in Vipr are intended to be executed and we have defined graphical rewrite rules that define the semantics of that execution <ref> [7] </ref>. Unlike Vipr, program representations are not executable and are simply intended to make some aspect of a textual language more understandable.
Reference: [8] <author> P. T. Cox, F. R. Giles, and T. Pietrzykowski. Prograph: </author> <title> a step towards liberating programming from textual conditioning. </title> <booktitle> In Proc. 1989 IEEE Workshop on Visual Languages, </booktitle> <address> Rome, ITALY, 1989. </address> <publisher> IEEE Computer Society Press. </publisher>
Reference-contexts: Borning's ThingLab [2] is probably the most famous such system. ThingLab employs a constraint model rather than an imperative model, however, and while the constraints may be represented graphically [3], the methods for resolving the constraints are displayed textually. A number of other visual languages provide object-oriented features. Prograph <ref> [8, 9] </ref>, for example, provides a class system where the hierarchy is presented graphically. Inheritance, instance variables, dynamic dispatch, and polymorphism are all provided in Prograph, although dynamic 7 dispatch and polymorphism are not shown graphically.
Reference: [9] <author> P. T. Cox and T. Pietrzykowski. </author> <title> Using a pictorial representation to combine dataflow and object-orientation in a language independent programming paradigm. </title> <booktitle> In Proc. Intl. Computer Science Conference, </booktitle> <address> Hong Kong, </address> <year> 1988. </year>
Reference-contexts: Borning's ThingLab [2] is probably the most famous such system. ThingLab employs a constraint model rather than an imperative model, however, and while the constraints may be represented graphically [3], the methods for resolving the constraints are displayed textually. A number of other visual languages provide object-oriented features. Prograph <ref> [8, 9] </ref>, for example, provides a class system where the hierarchy is presented graphically. Inheritance, instance variables, dynamic dispatch, and polymorphism are all provided in Prograph, although dynamic 7 dispatch and polymorphism are not shown graphically.
Reference: [10] <author> W. Finzer and L. Gould. </author> <title> Programming by rehersal. </title> <journal> Byte, </journal> <pages> pages 187-210, </pages> <month> June </month> <year> 1984. </year>
Reference-contexts: The methods by which they interact with each other are defined in Smalltalk. These methods are displayed in pop-up windows, which may be hidden while the program executes. Finzer and Gould's Rehearsal World <ref> [10] </ref> is a similar Smalltalk-based visual environment in which the objects, but not the methods, are visualized. In Rehearsal World, however, methods may be defined by demonstration as well as textually, but the representations of methods maintained by the system are textual Smalltalk.
Reference: [11] <author> G. W. Furnas. </author> <title> New graphical reasoning models for understanding graphical interfaces. </title> <booktitle> In Proceedings of CHI'91, </booktitle> <pages> pages 71-78, </pages> <address> Anaheim, CA, April 1981. </address> <publisher> ACM Press. </publisher>
Reference-contexts: State consists of a set of graphical entities and their relationships. If the "before" part of a before/after pair matches part of the state, the state is transformed to 6 conform to the "after" part of the pair. BITPICT <ref> [11] </ref> is one of the simplest of such languages, in that its before/after pairs are simple pixel patterns. ChemTrains [1] and Vampire [16] allow more complex visual entities and relations, and also permit variables in the transformation rules.
Reference: [12] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: the Language and Its Implementation. </title> <booktitle> Series in Computer Science. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Palo Alto, CA, </address> <year> 1983. </year>
Reference-contexts: While our language allows every aspect of program 1 execution to be explicit and visual, we provide for a programming environment to hide as much detail as the user desires. Object-oriented languages, such as Smalltalk <ref> [12] </ref> and C++ [25], facilitate programming by providing powerful features such as inheritance, polymorphism, and dynamic dispatch. Such features can greatly reduce the amount of code needed to solve a specific problem and also facilitate code reuse.
Reference: [13] <author> V Haarslev and R. Moeller. </author> <title> A framework for visualizing object-oriented systems. </title> <booktitle> In Proceedings of ECOOP/OOPSLA'90, </booktitle> <pages> pages 237-244, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: We address each of these tools in turn and discuss their individual weaknesses. Class Browsers These tools provide a static view of a program's class hierarchy (e.g., <ref> [13] </ref>). Browsers are not intended to be used to understand the dynamic behavior of a program and the browsing metaphor does not extend to understanding other aspects of the static program structure. Thus, a programmer requires additional environment support beyond browsers to understand, modify, and debug object-oriented programs.
Reference: [14] <author> K. M. Kahn. </author> <title> Towards visual concurrent constraint programming. </title> <type> Technical Report SSL-91-092, </type> <institution> Xerox PARC, </institution> <address> Palo Alto, CA, </address> <year> 1992. </year>
Reference-contexts: Investigators have noted the importance of smooth transitions and animation in dynamic visualizations [22] and Kahn incorporated it into his Pictorial Janus system <ref> [14] </ref>. Another problematic aspect of the Vipr language is the use of arrows. Arrows represent connections between things and too many arrows make a program confusing. We anticipate that a support environment will allow connections indicated by arrows to also be indicated using textual names.
Reference: [15] <author> K. M. Kahn and V. A. Saraswat. </author> <title> Complete visualizations of concurrent programs and their executions. </title> <booktitle> In Proceedings of the 1990 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 7-15, </pages> <address> Skokie, IL, </address> <month> October </month> <year> 1990. </year>
Reference-contexts: In this paper, we argue that a completely visual object-oriented programming language, Vipr (Visual Imperative PRogramming), has significant advantages over textual object-oriented languages. The design of Vipr was inspired by Kahn's Pictorial Janus <ref> [15] </ref>. In Vipr, programs are represented as nested circles and language features such as continuations and dynamic dispatch, which exist implicitly in the textual representation, can be made explicit. <p> The most significant such language is Pictorial Janus <ref> [15] </ref>, which was originally designed to model the execution of the constraint logic programming language Janus, but whose execution semantics may be derived from graphical rules applied to the visual representation. <p> The design of Vipr is closely related to Kahn's Pictorial Janus <ref> [15] </ref>. While Pictorial Janus visually models constraint logic programming, and therefore makes allowances for nondeterminism, Vipr is intended to model conventional imperative constructs (with the addition of objects and class inheritance). It is modeled after C++, and is statically scoped and typed.
Reference: [16] <author> D. W. McIntyre and E. P. Glinert. </author> <title> Visual tools for creating iconic programming environments. </title> <booktitle> In Proceedings of the 1992 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 162-168, </pages> <address> Seattle, WA, </address> <month> September </month> <year> 1992. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: BITPICT [11] is one of the simplest of such languages, in that its before/after pairs are simple pixel patterns. ChemTrains [1] and Vampire <ref> [16] </ref> allow more complex visual entities and relations, and also permit variables in the transformation rules.
Reference: [17] <author> Ross P. Morley, Pieter S. van der Meulen, and Peter Baltus. </author> <title> Getting a grasp on interactive simulation. </title> <editor> In Raimund K. Ege, editor, </editor> <booktitle> Proceedings of the SCS Multiconference on Object-Oriented Simulation, </booktitle> <pages> pages 151-157, </pages> <address> Anaheim, CA, </address> <month> January </month> <year> 1991. </year>
Reference-contexts: Domain-Specific Execution Visualizations These tools include toolkits for building domain-specific visualizations of the execution of programs, including object-oriented programs. With such toolkits, programmers can visualize state-transition diagrams, oscilloscopes, logic circuits, or any of a number of simulation applications (e.g., <ref> [17] </ref>). These toolkits are ad hoc because they do not provide a general framework for understanding the behavior of programs, but instead allow applications in particular domains to be visualized.
Reference: [18] <author> B. A. Myers. Incense: </author> <title> A system for displaying data structures. </title> <booktitle> In Computer Graphics: SIGGRAPH '83 Conference Proceedings, </booktitle> <pages> pages 115-125, </pages> <month> July </month> <year> 1983. </year>
Reference-contexts: Thus, a programmer requires additional environment support beyond browsers to understand, modify, and debug object-oriented programs. Data Structure Visualizers These tools range widely in their complexity and include extensions to debuggers to display lists or trees (e.g., <ref> [18, 19] </ref>). As an example of a text-based data structure visualizer, almost every Lisp environment provides automatic code and data pretty-printing support. Common Lisp has such support built into its definition [24].
Reference: [19] <author> B. A. Myers, R. Chandhok, and A. Sareen. </author> <title> Automatic data visualization for novice pascal programmers. </title> <booktitle> In Proceedings of the 1988 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 192-198, </pages> <address> Pittsburgh, PA, </address> <month> October </month> <year> 1988. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: Thus, a programmer requires additional environment support beyond browsers to understand, modify, and debug object-oriented programs. Data Structure Visualizers These tools range widely in their complexity and include extensions to debuggers to display lists or trees (e.g., <ref> [18, 19] </ref>). As an example of a text-based data structure visualizer, almost every Lisp environment provides automatic code and data pretty-printing support. Common Lisp has such support built into its definition [24].
Reference: [20] <author> F. Penz. </author> <title> Visual programming in the ObjectWorld. </title> <journal> Journal of Visual Languages and Computing, </journal> <volume> 2 </volume> <pages> 17-41, </pages> <month> March </month> <year> 1991. </year>
Reference-contexts: More commonly, visual object-oriented environments use visual representations to define the relationships between classes, and to create new classes by assembling prototypes of previously defined classes. ObjectWorld and Rehearsal World are typical systems of this type. Penz's ObjectWorld <ref> [20] </ref> does model an imperative object-oriented language, however, only the objects themselves are represented visually. The methods by which they interact with each other are defined in Smalltalk. These methods are displayed in pop-up windows, which may be hidden while the program executes.
Reference: [21] <author> Carl Ponder and Bill Bush. </author> <title> Polymorphism considered harmful. </title> <journal> SIGPLAN Notices, </journal> <volume> 27(6) </volume> <pages> 76-79, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: This situation may require care in programming because all possible runtime behaviors need to be considered to ensure that a program will execute correctly. This problem has led some researchers to wonder aloud whether using polymorphism is the modern equivalent of programming with goto's <ref> [21] </ref>. Object-oriented programming requires the programmer to understand a complex execution model of method invocation. Unlike simple call/return semantics, method invocation semantics may involve dynamic method lookup, which is a concept generally unfamiliar to procedural programmers.
Reference: [22] <author> George G. Robertson, Jock D. Mackinlay, and Stuart K. Card. </author> <title> Cone trees: Animated 3D visualizations of hierarchical information. </title> <booktitle> In Proceedings of the Conference on Human Factors in Computing Systems (CHI'91), </booktitle> <pages> pages 189-194, </pages> <year> 1991. </year>
Reference-contexts: We also anticipate that the environment will smoothly animate transitions between computation steps (i.e., growing and shrinking elements as necessary) in order to make the visualization of execution easier to follow. Investigators have noted the importance of smooth transitions and animation in dynamic visualizations <ref> [22] </ref> and Kahn incorporated it into his Pictorial Janus system [14]. Another problematic aspect of the Vipr language is the use of arrows. Arrows represent connections between things and too many arrows make a program confusing.
Reference: [23] <author> G. Rogers. </author> <title> Visual programming with objects and relations. </title> <booktitle> In Proceedings of the 1988 IEEE Workshop on Visual Languages, </booktitle> <pages> pages 29-36, </pages> <address> Pittsburgh, PA, </address> <month> October </month> <year> 1988. </year> <journal> IEEE Computer Society. </journal>
Reference-contexts: In fact, most of them simply visualize objects, but set aside the problem of how methods should be visualized. Rogers <ref> [23] </ref> proposed an object-oriented visual language in which classes and methods are defined in terms of relations between objects. This language does employ visual representations of methods, but the relational approach taken in this system does not appear to be applicable to the visual modeling of an imperative language.
Reference: [24] <author> Guy L. Steele, Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> 2nd edition, </address> <year> 1990. </year>
Reference-contexts: As an example of a text-based data structure visualizer, almost every Lisp environment provides automatic code and data pretty-printing support. Common Lisp has such support built into its definition <ref> [24] </ref>. The problem with this approach is that one can only view program data with such tools and not the program itself (except, to a limited extent, in Lisp, where program and data have the same form).
Reference: [25] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley Series in Computer Science. Addison-Wesley, </publisher> <address> Reading, MA, 2nd edition, </address> <year> 1991. </year> <month> 26 </month>
Reference-contexts: While our language allows every aspect of program 1 execution to be explicit and visual, we provide for a programming environment to hide as much detail as the user desires. Object-oriented languages, such as Smalltalk [12] and C++ <ref> [25] </ref>, facilitate programming by providing powerful features such as inheritance, polymorphism, and dynamic dispatch. Such features can greatly reduce the amount of code needed to solve a specific problem and also facilitate code reuse.
References-found: 25

