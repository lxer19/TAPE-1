URL: ftp://ftp.cs.unc.edu/pub/users/sc/COMP140-F95/L1995-10-19.PS.Z
Refering-URL: http://www.cs.unc.edu/~sc/teaching/COMP140-F1995/lectures.html
Root-URL: http://www.cs.unc.edu
Title: COMP 140: Introduction to Translator Systems Interpreters  
Author: Siddhartha Chatterjee 
Keyword: 2 Interpretation and binding time  
Note: Reference: Calingaert, xx5.1-5.2.  
Date: 19 October 1995  
Abstract: 1 Where are we? Up to now, we have dealt with the front end of the translation process, which consists of building an intermediate representation of a source program from the characters in a file that forms the external representation of the program. This happened in stages. First, we grouped characters into tokens, turning the stream of characters into a stream of tokens. This happened in the lexical analyzer. Next, we added phrase structure to this stream of tokens and converted it into an abstract syntax tree. Finally, we performed semantic analysis to ensure that the program was meaningful. The two end results of this phase of translation are the AST and the symbol table. Between them, they hold all the information that we care about. This concludes the analysis of the source program. Now we are ready to start the synthesis of the target program, which may be either in the form of generating assembly or machine code for a target machine, or in the form of performing the program actions interpretively. In today's lecture, we will deal with the subject of interpretation. Interpretation refers to performing the actions listed in some source program, whereas generation refers to producing a target program that encodes the actions of the source program in terms of a different set of (more primitive) actions. Every translation scheme is a combination of generation and interpretation. When we generate machine code, the hardware executes the actions in the machine code program, changing the contents of the CPU and of memory in the process. When we write an interpreter, actions are executed by software rather than hardware. In essence, we build a abstract virtual machine that provides an operation set that is closer to the application domain; however, these operations are not implemented directly in the hardware. Thus, we have a smaller number of operations, but each one runs more slowly than a machine instruction. Depending on the difference in complexity between the operations and the machine instructions, we may experience minimal or substantial slowdown. For example, if the operations are linear algebra routines, the slowdown factor is likely to be less than 10. On the other hand, if the operations are the machine instructions of a new CPU we are simulating at the instruction, a slowdown factor of 10 3 is quite common. If we are simulating the CPU at the transistor, the slowdown factor may be as high as 10 6 . The choice between interpretation and generation is closely related to the issue of binding time. Binding time refers to the phase of translation when the value of an attribute is determined. For example, the type of a variable is usually determined and fixed at compile time, more specifically during parsing. The location of 
Abstract-found: 1
Intro-found: 1
References-found: 0

