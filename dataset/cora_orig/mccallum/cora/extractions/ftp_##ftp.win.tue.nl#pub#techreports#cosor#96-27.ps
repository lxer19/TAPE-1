URL: ftp://ftp.win.tue.nl/pub/techreports/cosor/96-27.ps
Refering-URL: http://www.win.tue.nl/math/bs/cosor96.html
Root-URL: http://www.win.tue.nl
Email: email address: slam@bs.win.tue.nl  
Title: Minimizing total completion time in a two-machine flowshop: analysis of special cases  
Author: J.A. Hoogeveen T. Kawaguchi 
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  Oita 870-11, Japan  
Affiliation: Eindhoven University of Technology  Department of Mathematics and Computing Science Eindhoven University of Technology  Department of Computer Science and Intelligent Systems Oita University  
Date: 96-27, 1996,  August 20, 1996  
Pubnum: Memorandum COSOR  
Abstract: We consider the problem of minimizing total completion time in a two-machine flowshop. We present a heuristic with worst-case bound 2fi=(ff + fi), where ff and fi denote the minimum and maximum processing time of all operations. Furthermore, we analyze four special cases: equal processing times on the first machine, equal processing times on the second machine, processing a job on the first machine takes time no more than its processing on the second machine, and processing a job on the first machine takes time no less than its processing on the second machine. We prove that the first special case is N P-hard in the strong sense and present an O(n log n) approximation algorithm for it with worst-case bound 4=3; we show that the other three cases are solvable in polynomial time. 1980 Mathematics Subject Classification (Revision 1991): 90B35. Keywords and Phrases: Flowshop, total completion time, N P-hardness, heuristics, worst-case analysis, special cases, polynomial algorithms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R.H. Ahmadi and U. </author> <title> Bagchi (1990). Improved lower bounds for minimizing the sum of completion times on n jobs over m machines in a flow shop. </title> <journal> European Journal of Operational Research 44, </journal> <pages> 331-336. </pages>
Reference-contexts: We derive the lower bound stated in the lemma by combining two lower bounds. The first of these stems from C 2;[j] = maxfC 2;[j1] ; C 1 [j] g + B [j] C 2;[j1] + B [j] , which implies that C [j] A <ref> [1] </ref> + P j j = 1; : : : ; n; hence, n X C [j] nA [1] + j=1 k=1 n X (n j + 1)B [j] : The second lower bound comes from C 2 [j] = maxfC 2;[j1] ; C 1 [j] g + B [j] C <p> The first of these stems from C 2;[j] = maxfC 2;[j1] ; C 1 [j] g + B [j] C 2;[j1] + B [j] , which implies that C [j] A <ref> [1] </ref> + P j j = 1; : : : ; n; hence, n X C [j] nA [1] + j=1 k=1 n X (n j + 1)B [j] : The second lower bound comes from C 2 [j] = maxfC 2;[j1] ; C 1 [j] g + B [j] C 1 [j] + B [j] , which implies that C [j] P j k=1 A [k] + B <p> B [j] , for j = 1; : : : ; n; hence, n X C [j] j=1 k=1 n X B [j] = j=1 n X B [j] : Adding up these bounds yields 2 j=1 n X (n j + 1)(A [j] + B [j] ) + nA <ref> [1] </ref> + j=1 n X (n j + 1)(A j + B j ) + n min fA j g + j=1 as the term P n j=1 (n j + 1)(A [j] + B [j] ) is minimized by matching the largest (A [j] + B [j] ) value to <p> Suppose that Target Sum is answered affirmatively. Consider the permutation schedule F <ref> [1] </ref> ; G [1] ; H 1 ; : : : ; F [q] ; G [q] ; H q ; E 1 ; E 2 ; E 3 without any avoidable idle time on M 1 , where F [j] and G [j] are the jobs corresponding to the elements <p> Suppose that Target Sum is answered affirmatively. Consider the permutation schedule F <ref> [1] </ref> ; G [1] ; H 1 ; : : : ; F [q] ; G [q] ; H q ; E 1 ; E 2 ; E 3 without any avoidable idle time on M 1 , where F [j] and G [j] are the jobs corresponding to the elements in T j <p> G [q] ; H q ; E 1 ; E 2 ; E 3 without any avoidable idle time on M 1 , where F [j] and G [j] are the jobs corresponding to the elements in T j (j = 1; : : : ; q); this 6 F <ref> [1] </ref> G [1] H 1 F [2] G [2] H 2 F [q] G [q] H q E 1 E 2 E 3 schedule is depicted in Figure 1. A straightforward computation shows that this schedule has total delay time no more than y. <p> ; H q ; E 1 ; E 2 ; E 3 without any avoidable idle time on M 1 , where F [j] and G [j] are the jobs corresponding to the elements in T j (j = 1; : : : ; q); this 6 F <ref> [1] </ref> G [1] H 1 F [2] G [2] H 2 F [q] G [q] H q E 1 E 2 E 3 schedule is depicted in Figure 1. A straightforward computation shows that this schedule has total delay time no more than y. <p> r X C 2;[j] (oe); where N j (j = 1; : : : ; q) is defined as the number of short jobs that are processed between J [j] and J [j+1] , and N 0 is defined as the number of short jobs that are processed before J <ref> [1] </ref> . <p> where n j (j = 1; : : : ; q) is defined as the total amount of work of short jobs executed between J [j] and J [j+1] on M 1 , and n 0 is defined as the total amount of work of short jobs executed before J <ref> [1] </ref> by M 1 . Note that P C j = M Z for any permutation schedule that satisfies conditions (1) and (2). We now allow preemption of the short jobs. <p> We only mention terms in which something has changed. We start with k = 1; see Figure 3 for an illustration of this case. For the jobs that are processed before J <ref> [1] </ref> in oe and , we get the following expression for M Z (oe) M Z (), where n 0 refers to oe: oe [1] [2] [1] [2] M Z (oe) M Z () = bn 0 c (bn 0 c + 1)=2 + (n 0 bn 0 c)dn 0 e <p> We start with k = 1; see Figure 3 for an illustration of this case. For the jobs that are processed before J <ref> [1] </ref> in oe and , we get the following expression for M Z (oe) M Z (), where n 0 refers to oe: oe [1] [2] [1] [2] M Z (oe) M Z () = bn 0 c (bn 0 c + 1)=2 + (n 0 bn 0 c)dn 0 e If bn 0 c = bn 0 + c, then this expression can be rewritten as M Z (oe) M Z () = dn <p> We start with k = 1; see Figure 3 for an illustration of this case. For the jobs that are processed before J <ref> [1] </ref> in oe and , we get the following expression for M Z (oe) M Z (), where n 0 refers to oe: oe [1] [2] [1] [2] M Z (oe) M Z () = bn 0 c (bn 0 c + 1)=2 + (n 0 bn 0 c)dn 0 e If bn 0 c = bn 0 + c, then this expression can be rewritten as M Z (oe) M Z () = dn 0 + <p> M Z (oe) M Z () = dn 0 + e: (4) If bn 0 c = bn 0 + c 1, then it equals M Z (oe) M Z () = dn 0 e n 0 dn 0 e : (5) For the jobs that are processed between J <ref> [1] </ref> and J [2] in oe and , we get M Z (oe) M Z () = (n 1 + 1)C 1;[2] (n 1 + 1 )(C 1;[2] + ) = (n 0 + 1); (6) since C 1;[2] + = n 0 + n 1 + 2. <p> Hence, n 0 &lt; 1. 2 We want to get rid of the portion of the short job that is executed by M 1 before J <ref> [1] </ref> . Thereto, we need our final relaxation. We relax the constraint that A j = 1 for each job J j a little bit by allowing the existence of one dustbin job J 0 . <p> A straightforward computation shows that interchanging J [i] and J [k] does not increase MZ fl and does not violate the additional constraints. We proceed in this way until the long jobs are in the right order. 2 Renumber the long jobs such that B <ref> [1] </ref> B [2] : : : B [r] . Lemma 11 implies that M Z fl = j=1 r X C 2;[j] ; where C 2;[j] = 1 + P j n q B [q] 1. <p> Lemma 11 implies that M Z fl = j=1 r X C 2;[j] ; where C 2;[j] = 1 + P j n q B [q] 1. Lemma 12 There exists a relaxed instance that maximizes the ratio P C j =M Z fl in which B <ref> [1] </ref> = : : : = B [q] = X=q 1, where X denotes the total length of the first operations of the short jobs and the dustbin job. Proof. Let J denote a relaxed instance that maximizes the ratio P C j =M Z fl . <p> Hence, we must have X P q j=1 (B [j] 1); in a similar fashion we show that X = P q What is left to show is that B <ref> [1] </ref> = : : : = B [q] . Suppose to the contrary that P q X q but that not all B j (j = 1; : : : ; q) are equal. <p> Since P C j (J ) is equal to a constant plus qX + P q j=1 (q + 1 j)B [j] , equalizing B <ref> [1] </ref> ; : : : ; B [q] increases P C j (J ). <p> X and q, by choosing B j = X=q 1 for j = 1; : : : ; q. 2 Lemma 13 There exists a relaxed instance that maximizes the ratio P C j =M Z fl in which B [q+1] = : : : = B [r] = B <ref> [1] </ref> . Proof. Suppose to the contrary that B [j] &gt; B [1] for some j 2 fq + 1; : : : ; rg. Observing P C j and MZ fl , it follows immediately that decreasing B [j] to B [1] decreases P M Z fl with the same <p> = 1; : : : ; q. 2 Lemma 13 There exists a relaxed instance that maximizes the ratio P C j =M Z fl in which B [q+1] = : : : = B [r] = B <ref> [1] </ref> . Proof. Suppose to the contrary that B [j] &gt; B [1] for some j 2 fq + 1; : : : ; rg. Observing P C j and MZ fl , it follows immediately that decreasing B [j] to B [1] decreases P M Z fl with the same amount; hence, this decrease increases the ratio P Lemma 14 For any <p> : : : = B [r] = B <ref> [1] </ref> . Proof. Suppose to the contrary that B [j] &gt; B [1] for some j 2 fq + 1; : : : ; rg. Observing P C j and MZ fl , it follows immediately that decreasing B [j] to B [1] decreases P M Z fl with the same amount; hence, this decrease increases the ratio P Lemma 14 For any relaxed instance J , P Proof. The instance J is completely characterized by B [1] , q, and r; we replace B [1] by B to facilitate notation. <p> C j and MZ fl , it follows immediately that decreasing B [j] to B <ref> [1] </ref> decreases P M Z fl with the same amount; hence, this decrease increases the ratio P Lemma 14 For any relaxed instance J , P Proof. The instance J is completely characterized by B [1] , q, and r; we replace B [1] by B to facilitate notation. The number of short jobs amounts to q (B 1); without loss of generality, we assume that there is no dust bin job. <p> immediately that decreasing B [j] to B <ref> [1] </ref> decreases P M Z fl with the same amount; hence, this decrease increases the ratio P Lemma 14 For any relaxed instance J , P Proof. The instance J is completely characterized by B [1] , q, and r; we replace B [1] by B to facilitate notation. The number of short jobs amounts to q (B 1); without loss of generality, we assume that there is no dust bin job. <p> We prove the theorem by showing that C j (oe) C [j] () for j = 1; : : : ; n. The proof is based on induction. For j = 1, we have that C 1 (oe) = A 1 +B A <ref> [1] </ref> +B = C [1] (). Suppose that C j (oe) C [j] () for j = 1; : : : ; k. <p> We prove the theorem by showing that C j (oe) C [j] () for j = 1; : : : ; n. The proof is based on induction. For j = 1, we have that C 1 (oe) = A 1 +B A <ref> [1] </ref> +B = C [1] (). Suppose that C j (oe) C [j] () for j = 1; : : : ; k. We have that C k+1 (oe) = maxfC k (oe); P k+1 and C [k+1] () = maxfC [k] (); P k+1 j=1 A [j] g + B. <p> This implies that any optimal schedule for 19 F 2jA j B j j C j must correspond to a Pareto optimal point for ( P n that is, there exists no other point ( P n W [j] ; I <ref> [1] </ref> ; : : : ; I [n] ) such that each component is no more than the corresponding component of ( P n j=1 W [j] ; I [1] ; : : : ; I [n] ). <p> Pareto optimal point for ( P n that is, there exists no other point ( P n W [j] ; I <ref> [1] </ref> ; : : : ; I [n] ) such that each component is no more than the corresponding component of ( P n j=1 W [j] ; I [1] ; : : : ; I [n] ). We call a schedule that corresponds to a Pareto optimal point a Pareto optimal schedule. <p> We call a schedule that corresponds to a Pareto optimal point a Pareto optimal schedule. In theory, we can solve F 2jA j B j j P C j by identifying all Pareto optimal points for ( j=1 W [j] ; I <ref> [1] </ref> ; : : : ; I [n] ). Unfortunately, the number of Pareto optimal points is not polynomially bounded, and therefore enumerating all Pareto optimal points is no sensible approach. <p> A repetition of this argument shows that oe is an optimal schedule. 2 Theorem 20 Let oe be obtained by the Smallest Index rule for F 2jA j B j ; I [j] K j j P Then the point ( P W [j] (oe); I <ref> [1] </ref> (oe); : : : ; I [n] (oe)) is Pareto optimal. Proof. <p> This special structure enables us to partition the schedule in blocks. Start with J <ref> [1] </ref> . Block Z 1 contains J [1] and all lower indexed successors of J [1] , after which we get the next job as the first job in block Z 2 , etc. 22 Theorem 23 The blocks satisfy the following properties: 1. <p> This special structure enables us to partition the schedule in blocks. Start with J <ref> [1] </ref> . Block Z 1 contains J [1] and all lower indexed successors of J [1] , after which we get the next job as the first job in block Z 2 , etc. 22 Theorem 23 The blocks satisfy the following properties: 1. <p> This special structure enables us to partition the schedule in blocks. Start with J <ref> [1] </ref> . Block Z 1 contains J [1] and all lower indexed successors of J [1] , after which we get the next job as the first job in block Z 2 , etc. 22 Theorem 23 The blocks satisfy the following properties: 1. The jobs in a block are scheduled in order of index, except for the first one. 2.
Reference: [2] <author> R.W. Conway, W.L. Maxwell, and L.W. </author> <title> Miller (1967). Theory of Scheduling, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts. </address>
Reference-contexts: E 1 ; E 2 ; E 3 without any avoidable idle time on M 1 , where F [j] and G [j] are the jobs corresponding to the elements in T j (j = 1; : : : ; q); this 6 F [1] G [1] H 1 F <ref> [2] </ref> G [2] H 2 F [q] G [q] H q E 1 E 2 E 3 schedule is depicted in Figure 1. A straightforward computation shows that this schedule has total delay time no more than y. <p> ; E 2 ; E 3 without any avoidable idle time on M 1 , where F [j] and G [j] are the jobs corresponding to the elements in T j (j = 1; : : : ; q); this 6 F [1] G [1] H 1 F <ref> [2] </ref> G [2] H 2 F [q] G [q] H q E 1 E 2 E 3 schedule is depicted in Figure 1. A straightforward computation shows that this schedule has total delay time no more than y. <p> We start with k = 1; see Figure 3 for an illustration of this case. For the jobs that are processed before J [1] in oe and , we get the following expression for M Z (oe) M Z (), where n 0 refers to oe: oe [1] <ref> [2] </ref> [1] [2] M Z (oe) M Z () = bn 0 c (bn 0 c + 1)=2 + (n 0 bn 0 c)dn 0 e If bn 0 c = bn 0 + c, then this expression can be rewritten as M Z (oe) M Z () = dn 0 <p> For the jobs that are processed before J [1] in oe and , we get the following expression for M Z (oe) M Z (), where n 0 refers to oe: oe [1] <ref> [2] </ref> [1] [2] M Z (oe) M Z () = bn 0 c (bn 0 c + 1)=2 + (n 0 bn 0 c)dn 0 e If bn 0 c = bn 0 + c, then this expression can be rewritten as M Z (oe) M Z () = dn 0 + e: <p> M Z () = dn 0 + e: (4) If bn 0 c = bn 0 + c 1, then it equals M Z (oe) M Z () = dn 0 e n 0 dn 0 e : (5) For the jobs that are processed between J [1] and J <ref> [2] </ref> in oe and , we get M Z (oe) M Z () = (n 1 + 1)C 1;[2] (n 1 + 1 )(C 1;[2] + ) = (n 0 + 1); (6) since C 1;[2] + = n 0 + n 1 + 2. <p> A straightforward computation shows that interchanging J [i] and J [k] does not increase MZ fl and does not violate the additional constraints. We proceed in this way until the long jobs are in the right order. 2 Renumber the long jobs such that B [1] B <ref> [2] </ref> : : : B [r] . Lemma 11 implies that M Z fl = j=1 r X C 2;[j] ; where C 2;[j] = 1 + P j n q B [q] 1.
Reference: [3] <author> F. Della Croce, V. Narayan, and R. </author> <title> Tadei (1996). The two-machine total completion time flow shop problem. </title> <journal> European Journal of Operational Research 90, </journal> <pages> 227-237. </pages>
Reference: [4] <author> M.R. Garey, D.S. Johnson, and R. </author> <title> Sethi (1976). The complexity of flowshop and jobshop scheduling. </title> <journal> Mathematics of Operations Research 13, </journal> <pages> 330-348. </pages>
Reference: [5] <author> M.R. Garey and D.S. </author> <title> Johnson (1979). Computers and Intractability: A Guide to the Theory of NP-Completeness, </title> <publisher> Freeman, </publisher> <address> San Francisco. </address>
Reference: [6] <author> R.L. Graham, E.L. Lawler, J.K. Lenstra, and A.H.G. </author> <title> Rinnooy Kan (1979). Optimization and approximation in deterministic sequencing and scheduling: a survey. </title> <journal> Annals of Discrete Mathematics 5, </journal> <pages> 287-326. </pages>
Reference: [7] <author> T. Gonzalez and S. </author> <title> Sahni (1978). Flowshop and jobshop schedules: Complexity and approximation. </title> <journal> Operations Research 26, </journal> <pages> 36-52. </pages>
Reference: [8] <author> J.A. Hoogeveen and S.L. van de Velde (1995). </author> <title> Stronger Lagrangian bounds by use of slack variables: applications to machine scheduling problems. </title> <booktitle> Mathematical Programming 70, </booktitle> <pages> 173-190. 28 </pages>
Reference: [9] <author> E. Ignall and L. </author> <title> Schrage (1965). Application of the branch and bound tech-nique for some flow-shop scheduling problems. </title> <journal> Operations Research 13, </journal> <pages> 400-412. </pages>
Reference: [10] <author> W.H. Kohler and K. </author> <title> Steiglitz (1975). Exact, approximate and guaranteed accuracy algorithms for the flowshop problem n/2/F/F. </title> <journal> Journal ACM 22, </journal> <pages> 106-114. </pages>
Reference: [11] <author> C. Rajendran and D. </author> <title> Chaudhuri (1991A). An efficient heuristic approach to the scheduling of jobs in a flow-shop. </title> <journal> European Journal of Operational Research 61, </journal> <pages> 318-325. </pages>
Reference: [12] <author> C. Rajendran and D. </author> <title> Chaudhuri (1991B). A flowshop scheduling algorithm to minimize total flowtime. </title> <journal> Journal of the Operations Research Society of Japan 34, </journal> <pages> 28-46. </pages>
Reference: [13] <author> S.C. Sarin and D. </author> <month> Eybl </month> <year> (1978). </year> <title> The two-machine mean-flowtime flowshop problem and some special cases. Talk at ORSA/TIMS, </title> <address> Los Angeles, </address> <month> November </month> <year> 1978. </year>
Reference: [14] <author> C. </author> <month> Smutnicki </month> <year> (1995). </year> <title> Minimizing mean flow time in the permutation flow shop. A worst-case study. </title> <type> Technical Report PRE 10/95, </type> <institution> Institute of Engineering Cybernetics, Wroclaw. </institution>
Reference: [15] <author> W. </author> <month> Szwarc </month> <year> (1983). </year> <title> The flow-shop problem with mean completion time criterion. </title> <journal> IIE Transactions 15, </journal> <pages> 172-176. </pages>
Reference: [16] <author> S.L. van de Velde (1990). </author> <title> Minimizing the sum of the job completion times in the two-machine flow shop by Lagrangian relaxation. </title> <journal> Annals of Operations Research 26, </journal> <pages> 257-268. </pages>
References-found: 16

