URL: http://theory.lcs.mit.edu/~rajsbaum/sicomp.ps
Refering-URL: http://theory.lcs.mit.edu/~rajsbaum/
Root-URL: 
Email: Email: hagit@cs.technion.ac.il.  amir@watson.ibm.com.  UNAM. Email: rajsbaum@theory.lcs.mit.edu.  
Phone: 2  3  
Title: Optimal Clock Synchronization under Different Delay Assumptions  
Author: Hagit Attiya Amir Herzberg Sergio Rajsbaum 
Note: Supported by grant No. 92-0233 from the United States-Israel Binational Science Foundation (BSF), Jerusalem, Israel, Technion V.P.R.|Argentinian Research Fund and the fund for the promotion of research in the Technion.  Partially supported by DGAPA Projects, National Autonomous University of Mexico (UNAM). Email: amir@yktvmh.bitnet or  On leave from Instituto de Matematicas, UNAM, Mexico. Partially supported by DGAPA Projects,  
Address: 32000, Israel.  P.O. Box 704, Yorktown Heights, NY 10598, USA.  545 Technology Square, Cambridge, MA 02139, USA.  
Affiliation: 1 Department of Computer Science, Technion, Haifa  IBM T. J. Watson Research Center,  MIT Laboratory for Computer Science,  
Date: October 25, 1994  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> F. Cristian, </author> <title> "Probabilistic Clock Synchronization," </title> <journal> Dist. Comp., </journal> <volume> 3 (1989), </volume> <pages> pp. 146-158. </pages>
Reference-contexts: The technique used to attain this notion of time is known as clock synchronization. Synchronized clocks are useful for various applications such as control of real-time processes, transaction processing in database systems, and communication protocols. Recently, several software protocols that support clock synchronization in communication networks have been proposed <ref> [1, 7, 13, 15, 16] </ref>; system designers have been advocating the use of synchronized clocks [10]. <p> Most previous formal work on deterministic clock synchronization addressed only a restricted version of the first assumption where the delay upper bounds are finite. However, an observation of <ref> [1] </ref> shows that in many actual links, there is some minimal delay (e.g., due to the actual transmission rate and processing time), while there is no known upper bound. <p> Some techniques for developing clock synchronization algorithms for broadcast networks appeared in [3]. Another important open question is to achieve optimal clock synchronization in systems where the probabilistic properties of the message delay distribution are known. This assumption is at the heart of most practical algorithms for clock synchronization <ref> [1, 13] </ref>. We believe the setting developed here allows one to address this assumption, and that this will lead to improvements in these important algorithms. Finally, an obvious open problem is to make our results to be fault-tolerant, following the many works addressing fault-tolerant clock synchronization.
Reference: [2] <author> D. Dolev, J. Halpern and H. R. </author> <title> Strong, "On the Possibility and Impossibility of Achieving Clock Synchronization," </title> <journal> J. Comp. and Sys. Sci., 32:2 (1986) pp. </journal> <pages> 230-250. </pages>
Reference-contexts: Clock synchronization algorithms under this assumption, whose precision is optimal in the worst case, are described in [4, 11]. Subsequent work concentrated on clocks that may drift and on fault-tolerance (e.g., <ref> [2, 7, 20, 21] </ref>, see survey in [19]). To achieve high precision, these algorithms require the existence of tight lower and upper bounds on message delay.
Reference: [3] <author> D. Dolev, R. Reischuk and H. R. </author> <title> Strong, "Observable Clock Synchronization," </title> <booktitle> 13th ACM Symp. on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1994, </year> <pages> pp. 284-293. </pages>
Reference-contexts: This work also generalizes some of our results to clocks that drift. Other follow-up work include an investigation of the problem from the knowledge theoretic point of view [14]. Some techniques for developing clock synchronization algorithms for broadcast networks appeared in <ref> [3] </ref>. Another important open question is to achieve optimal clock synchronization in systems where the probabilistic properties of the message delay distribution are known. This assumption is at the heart of most practical algorithms for clock synchronization [1, 13].
Reference: [4] <author> J. Halpern, N. Megiddo and A. A. Munshi, </author> <title> "Optimal Precision in the Presence of Uncertainty," </title> <journal> J. Complexity, </journal> <volume> 1 (1985), </volume> <pages> pp. 170-196. </pages>
Reference-contexts: A relatively simple case is when local clocks are accurate, i.e., run at the same speed, and there are upper and lower bounds for the delay on each link. Clock synchronization algorithms under this assumption, whose precision is optimal in the worst case, are described in <ref> [4, 11] </ref>. Subsequent work concentrated on clocks that may drift and on fault-tolerance (e.g., [2, 7, 20, 21], see survey in [19]). To achieve high precision, these algorithms require the existence of tight lower and upper bounds on message delay. <p> Such mixtures are quite common in practical, heterogeneous systems. For example, there are systems in which several local area (broadcast) networks are connected by bridges or (long distance) links. Our work extends the results of Halpern, Megiddo and Munshi <ref> [4] </ref>. Halpern et al. use linear programming techniques which do not illuminate the inherent difficulties of synchronizing clocks. We believe that our work gives a more precise understanding of the problem, explicitly showing what are the requirements of each step and thereby facilitating adaptation to other delay assumptions. <p> Their results are a special case of the general methodology developed here, in which exactly one message is sent on each link, and upper and lower bounds on delays are known. In fact, the algorithm we obtain for this specific setting is essentially the one in <ref> [4] </ref>. Previous definitions of optimal clock synchronization were based on the worst (largest) difference between clocks of two processors in any execution. For some of the assumptions that we study in this paper, e.g., when no upper bounds on the delays are known, this worst case is inherently unbounded. <p> For some of the assumptions that we study in this paper, e.g., when no upper bounds on the delays are known, this worst case is inherently unbounded. Moreover, as already stated in <ref> [4] </ref>, we would like to award algorithms that exploit favorable conditions, and achieve precision that is as good as can be in each specific instance. <p> We give a precise definition of optimality for each specific execution, and show that it is achieved by our algorithms (and hence also by the algorithm of <ref> [4] </ref>). When trying to crystallize these ideas, it turned out that the decision of which messages to send should be separated from the method for adjusting the clocks based on the local message histories. Our framework shows how to optimally adjust the clocks, given any set of local message histories. <p> Since messages are unique, t p (m) and t q (m) can be computed from the views of p and q. 5.1 Bounds on the Delay In the systems considered in <ref> [4, 11] </ref>, there is an upper and a lower bound on the transmission delay, for any edge. We extend this assumption by allowing edges without upper bounds, in which case we say that the upper bound is 1. <p> Moreover, the results apply to cases where different links satisfy different assumptions, or the same link satisfies several assumptions. This work extends results of Halpern, Megiddo and Munshi <ref> [4] </ref>, and introduces a new notion of optimality on any specific instance. The specific delay assumptions analyzed here are typical of realistic systems, and it seems relatively easy to perform similar analysis for additional delay assumptions.
Reference: [5] <author> J. Halpern and I. Suzuki, </author> <title> "Clock Synchronization and the Power of Broadcasting," </title> <booktitle> Proc. Allerton Conference, </booktitle> <year> 1990, </year> <pages> pp. 588-597. </pages>
Reference-contexts: The second assumption follows experimental results (cf. [13]), showing that message delays in opposite directions of a bi-directional link are usually very close. The last assumption is useful 2 for broadcast networks that are used in many local area networks; this is the assumption used in <ref> [5, 18] </ref>. Our composition theorem implies that our algorithms apply to systems where the same pair of processors satisfies several different delay assumptions. Such mixtures are quite common in practical, heterogeneous systems. <p> We do not assume that there is any bound on the delay of any individual message. Optimal clock synchronization algorithms for multicast networks which have a bound on the differences in delay for different processors are presented in <ref> [5, 18] </ref>. Our solution demon strates the usefulness of the reductions of the preceding sections. To provide optimal clock synchronization under the multicast assumption we need only to find a way of defining local shifts. This, somewhat surprisingly, turns out to be an easy task.
Reference: [6] <author> R. M. Karp, </author> <title> "A Characterization of the Minimum Cycle Mean in a Digraph," </title> <journal> Disc. Math., </journal> <volume> 23 (1978), </volume> <pages> pp. 309-311. </pages>
Reference-contexts: The correction for each processor p 2 P is dist w (r; p)|the distance in the (complete) directed graph relative to the weights w (p; q) = A max The value of ~ A max ff can be computed in Step 1 by using an algorithm of Karp <ref> [6] </ref>, that runs in O (n 3 ) time. By Lemma 3.7, this is equivalent to computing A max ff . By definition, A max ff A ff () = ms ff ()=jj, for any cycle .
Reference: [7] <author> H. Kopetz and W. Ochsenreiter, </author> <title> "Clock Synchronization in Distributed Real-Time Systems," </title> <journal> IEEE Trans. Comp., </journal> <month> 36:8 (August </month> <year> 1987), </year> <pages> pp. 933-939. </pages>
Reference-contexts: The technique used to attain this notion of time is known as clock synchronization. Synchronized clocks are useful for various applications such as control of real-time processes, transaction processing in database systems, and communication protocols. Recently, several software protocols that support clock synchronization in communication networks have been proposed <ref> [1, 7, 13, 15, 16] </ref>; system designers have been advocating the use of synchronized clocks [10]. <p> Clock synchronization algorithms under this assumption, whose precision is optimal in the worst case, are described in [4, 11]. Subsequent work concentrated on clocks that may drift and on fault-tolerance (e.g., <ref> [2, 7, 20, 21] </ref>, see survey in [19]). To achieve high precision, these algorithms require the existence of tight lower and upper bounds on message delay. <p> To achieve high precision, these algorithms require the existence of tight lower and upper bounds on message delay. However, in real systems it is often the uncertainty of message delay, rather than clock drift, that causes most of the difficulty in synchronizing clocks <ref> [13, 7] </ref>. <p> Synchronization to real time is often useful, and is achieved by practical protocols which usually deal also with multiple, imperfect real time clocks, e.g., the Internet NTP [13]. 2 To deal with the small drift which does exist, the clock synchronization mechanism is invoked periodically; e.g. Kopetz and Ochsenreiter <ref> [7] </ref>. 1 obtained for a natural family of local delay assumptions; this family includes all the assump-tions studied in previous theoretical work. A delay assumption is local if it is specified for a pair of processors, for example, processors connected by a link.
Reference: [8] <author> L. Lamport, </author> <title> "Time, Clocks and the Ordering of Events in Distributed Systems," </title> <journal> Communications of the ACM, </journal> <month> 21:7 (July </month> <year> 1978), </year> <pages> pp. 558-565. </pages>
Reference: [9] <author> L. Lamport and P. Melliar-Smith, </author> <title> "Synchronizing Clocks in the Presence of Faults," </title> <journal> Journal of the ACM, </journal> <month> 32:1 (January </month> <year> 1985), </year> <pages> pp. 52-78. </pages>
Reference: [10] <author> B. Liskov, </author> <title> "Practical Uses of Synchronized Clocks in Distributed Systems," </title> <booktitle> invited talk at the 9th ACM Symp. on Principles of Distributed Computing, </booktitle> <year> 1990. </year> <note> Appeared in Distributed Computing, </note> <month> 6 </month> <year> (1993), </year> <pages> pp. 211-219. </pages>
Reference-contexts: Recently, several software protocols that support clock synchronization in communication networks have been proposed [1, 7, 13, 15, 16]; system designers have been advocating the use of synchronized clocks <ref> [10] </ref>. The quality of synchronization is measured by its precision, i.e., how close together it brings the clocks at different processors. 1 The precision influences the correctness and the efficiency of applications using the synchronized clocks.
Reference: [11] <author> J. Lundelius and N. Lynch, </author> <title> "An Upper and Lower Bound for Clock Synchronization," Info. and Control, </title> <booktitle> 62:2/3 (August/September 1984), </booktitle> <pages> pp. 190-204. </pages>
Reference-contexts: A relatively simple case is when local clocks are accurate, i.e., run at the same speed, and there are upper and lower bounds for the delay on each link. Clock synchronization algorithms under this assumption, whose precision is optimal in the worst case, are described in <ref> [4, 11] </ref>. Subsequent work concentrated on clocks that may drift and on fault-tolerance (e.g., [2, 7, 20, 21], see survey in [19]). To achieve high precision, these algorithms require the existence of tight lower and upper bounds on message delay. <p> This implies that ff 0 can be obtained by "shifting" the steps of the processors in ff. In the rest of this section, we formalize this notion of shifting and study its properties. This technique was originally introduced by Lundelius and Lynch <ref> [11] </ref> to prove lower bounds on the precision achieved by clock synchronization algorithms in complete graphs. Formally, given a history of processor p and a real number s, a new history 0 = shift (; s) is defined by 0 (t) = (t + s) for all t. <p> That is, all tuples are shifted earlier in 0 by s if s is positive, and later by s if s is negative. Clearly, the views do not change with shifting. Furthermore: Lemma 3.1 (Lundelius and Lynch <ref> [11] </ref>) Let be a history of processor p and let s be a real number. Then 0 = shift (; s) is a history of p and S 0 = S s. <p> Since messages are unique, t p (m) and t q (m) can be computed from the views of p and q. 5.1 Bounds on the Delay In the systems considered in <ref> [4, 11] </ref>, there is an upper and a lower bound on the transmission delay, for any edge. We extend this assumption by allowing edges without upper bounds, in which case we say that the upper bound is 1.
Reference: [12] <author> K. Marzullo, </author> <title> Loosely-Coupled Distributed Services: A Distributed Time Service, </title> <type> Ph.D. thesis, </type> <institution> Stanford University, </institution> <year> 1983. </year>
Reference: [13] <author> D. Mills, </author> <title> "Network Time Protocol (Version 2) Specification and Implementation," </title> <journal> IEEE Trans. Comm., </journal> <volume> Vol. 39, No. </volume> <month> 10 (October </month> <year> 1991), </year> <pages> pp. 1482-1493. </pages>
Reference-contexts: The technique used to attain this notion of time is known as clock synchronization. Synchronized clocks are useful for various applications such as control of real-time processes, transaction processing in database systems, and communication protocols. Recently, several software protocols that support clock synchronization in communication networks have been proposed <ref> [1, 7, 13, 15, 16] </ref>; system designers have been advocating the use of synchronized clocks [10]. <p> To achieve high precision, these algorithms require the existence of tight lower and upper bounds on message delay. However, in real systems it is often the uncertainty of message delay, rather than clock drift, that causes most of the difficulty in synchronizing clocks <ref> [13, 7] </ref>. <p> It is easy to adapt our results to reach this goal if a perfect real time clock is available. Synchronization to real time is often useful, and is achieved by practical protocols which usually deal also with multiple, imperfect real time clocks, e.g., the Internet NTP <ref> [13] </ref>. 2 To deal with the small drift which does exist, the clock synchronization mechanism is invoked periodically; e.g. Kopetz and Ochsenreiter [7]. 1 obtained for a natural family of local delay assumptions; this family includes all the assump-tions studied in previous theoretical work. <p> However, an observation of [1] shows that in many actual links, there is some minimal delay (e.g., due to the actual transmission rate and processing time), while there is no known upper bound. The second assumption follows experimental results (cf. <ref> [13] </ref>), showing that message delays in opposite directions of a bi-directional link are usually very close. The last assumption is useful 2 for broadcast networks that are used in many local area networks; this is the assumption used in [5, 18]. <p> Some techniques for developing clock synchronization algorithms for broadcast networks appeared in [3]. Another important open question is to achieve optimal clock synchronization in systems where the probabilistic properties of the message delay distribution are known. This assumption is at the heart of most practical algorithms for clock synchronization <ref> [1, 13] </ref>. We believe the setting developed here allows one to address this assumption, and that this will lead to improvements in these important algorithms. Finally, an obvious open problem is to make our results to be fault-tolerant, following the many works addressing fault-tolerant clock synchronization.
Reference: [14] <author> Y. Moses and B. Bloom, </author> <title> "Knowledge, Timed Precedence and Clocks," </title> <booktitle> 13th ACM Symp. on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1994, </year> <pages> pp. 294-303. </pages>
Reference-contexts: Extensions of our work to the truely distributed case appear in [17]. This work also generalizes some of our results to clocks that drift. Other follow-up work include an investigation of the problem from the knowledge theoretic point of view <ref> [14] </ref>. Some techniques for developing clock synchronization algorithms for broadcast networks appeared in [3]. Another important open question is to achieve optimal clock synchronization in systems where the probabilistic properties of the message delay distribution are known.
Reference: [15] <author> Y. Ofek, </author> <title> "Generating a Fault-Tolerant Global Clock Using High-Speed Control Signals for the MetaNet Architecture," </title> <journal> IEEE Trans. Comm., </journal> <volume> Vol. 42, No. </volume> <month> 5 (May </month> <year> 1994), </year> <pages> pp. 2179-2188. </pages>
Reference-contexts: The technique used to attain this notion of time is known as clock synchronization. Synchronized clocks are useful for various applications such as control of real-time processes, transaction processing in database systems, and communication protocols. Recently, several software protocols that support clock synchronization in communication networks have been proposed <ref> [1, 7, 13, 15, 16] </ref>; system designers have been advocating the use of synchronized clocks [10].
Reference: [16] <author> Open Software Foundation, </author> <title> Introduction to OSF DCE, OSF, </title> <address> Cambridge, Massechusetts, </address> <month> December </month> <year> 1991. </year>
Reference-contexts: The technique used to attain this notion of time is known as clock synchronization. Synchronized clocks are useful for various applications such as control of real-time processes, transaction processing in database systems, and communication protocols. Recently, several software protocols that support clock synchronization in communication networks have been proposed <ref> [1, 7, 13, 15, 16] </ref>; system designers have been advocating the use of synchronized clocks [10].
Reference: [17] <author> B. Patt-Shamir and S. Rajsbaum, </author> <title> "A Theory of Clock Synchronization," </title> <booktitle> Proc. 26th ACM Symp. on Theory of Computing, </booktitle> <year> 1994, </year> <pages> pp. 810-819. </pages>
Reference-contexts: That is, any additional communication, required for exchanging the views, is bound to change the views themselves. A solution may require the definition of optimality to be relaxed. Extensions of our work to the truely distributed case appear in <ref> [17] </ref>. This work also generalizes some of our results to clocks that drift. Other follow-up work include an investigation of the problem from the knowledge theoretic point of view [14]. Some techniques for developing clock synchronization algorithms for broadcast networks appeared in [3].
Reference: [18] <author> K. Sugihara and I. Suzuki, </author> <title> "Nearly Optimal Clock Synchronization Under Unbounded Message Transmission Time," </title> <booktitle> Proc. 1988 International Conference on Parallel Processing III, </booktitle> <year> 1988, </year> <pages> pp. 14-17. </pages>
Reference-contexts: The second assumption follows experimental results (cf. [13]), showing that message delays in opposite directions of a bi-directional link are usually very close. The last assumption is useful 2 for broadcast networks that are used in many local area networks; this is the assumption used in <ref> [5, 18] </ref>. Our composition theorem implies that our algorithms apply to systems where the same pair of processors satisfies several different delay assumptions. Such mixtures are quite common in practical, heterogeneous systems. <p> We do not assume that there is any bound on the delay of any individual message. Optimal clock synchronization algorithms for multicast networks which have a bound on the differences in delay for different processors are presented in <ref> [5, 18] </ref>. Our solution demon strates the usefulness of the reductions of the preceding sections. To provide optimal clock synchronization under the multicast assumption we need only to find a way of defining local shifts. This, somewhat surprisingly, turns out to be an easy task.
Reference: [19] <author> B. Simons, J. L. Welch and N. Lynch, </author> <title> An Overview of Clock Synchronization, </title> <type> IBM Technical Report RJ 6505, </type> <month> October </month> <year> 1988. </year>
Reference-contexts: Clock synchronization algorithms under this assumption, whose precision is optimal in the worst case, are described in [4, 11]. Subsequent work concentrated on clocks that may drift and on fault-tolerance (e.g., [2, 7, 20, 21], see survey in <ref> [19] </ref>). To achieve high precision, these algorithms require the existence of tight lower and upper bounds on message delay. However, in real systems it is often the uncertainty of message delay, rather than clock drift, that causes most of the difficulty in synchronizing clocks [13, 7].
Reference: [20] <author> T. Srikanth and S. Toueg, </author> <title> "Optimal Clock Synchronization," </title> <journal> Journal of the ACM, </journal> <month> 34:3 (July </month> <year> 1987), </year> <pages> pp. 626-645. </pages>
Reference-contexts: Clock synchronization algorithms under this assumption, whose precision is optimal in the worst case, are described in [4, 11]. Subsequent work concentrated on clocks that may drift and on fault-tolerance (e.g., <ref> [2, 7, 20, 21] </ref>, see survey in [19]). To achieve high precision, these algorithms require the existence of tight lower and upper bounds on message delay.
Reference: [21] <author> J. L. Welch and N. Lynch, </author> <title> "A New Fault-Tolerant Algorithm for Clock Synchronization," </title> <journal> Info. and Comp., </journal> <month> 77:1 (April </month> <year> 1988), </year> <pages> pp. 1-36. 26 </pages>
Reference-contexts: Clock synchronization algorithms under this assumption, whose precision is optimal in the worst case, are described in [4, 11]. Subsequent work concentrated on clocks that may drift and on fault-tolerance (e.g., <ref> [2, 7, 20, 21] </ref>, see survey in [19]). To achieve high precision, these algorithms require the existence of tight lower and upper bounds on message delay.
References-found: 21

