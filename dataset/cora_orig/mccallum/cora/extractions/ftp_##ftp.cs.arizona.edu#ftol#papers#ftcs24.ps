URL: ftp://ftp.cs.arizona.edu/ftol/papers/ftcs24.ps
Refering-URL: http://www.cs.arizona.edu/cactus/public.html
Root-URL: http://www.cs.arizona.edu
Title: Implementing Fault Tolerance with an Attribute and Functional Based Model  
Author: Masato Suzuki, Takuya Katayama Richard D. Schlichting 
Address: Tatsunokuchi, Ishikawa 92312, JAPAN Tucson, Arizona 85721, USA  
Affiliation: School of Information Science Dept. of Computer Science Japan Adv. Inst. of Science and Technology The University of Arizona  
Abstract: Programs constructed using techniques that allow software or operational faults to be tolerated are typically written using an imperative computational model. Here, an alternative is described in which such programs are written using an attribute and functional based model called FTAG. The basic model is introduced first, followed by a description of mechanisms that allow a variety of standard fault-tolerance techniques to be realized in a straightforward way. Techniques that can be accommodated include replication and checkpointing to tolerate operational faults, and recovery blocks and N-version programming to tolerate software faults. Several examples are given to illustrate these techniques, including a replicated name server and a fault-tolerant sort that uses recovery blocks. These examples also serve to highlight the advantages of FTAG when compared to traditional imperative approaches, such as a declarative style, separation of semantic and syntactic definitions, and the simplicity of a functional foundation. Finally, an outline of how this model can be implemented in a computer system containing multiple processors is given. 
Abstract-found: 1
Intro-found: 1
Reference: [Avi85] <author> A. Avizienis. </author> <title> The N-Version approach to fault-tolerant software. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(12):1491-1501, </volume> <year> 1985. </year>
Reference-contexts: These include such things as recovery blocks [Ran75] and N-version programming <ref> [Avi85] </ref> for dealing with software faults, and checkpointing [BHG87], atomic actions [Lis85], and the replicated state machine approach [Sch90] for dealing with operational faults. All of these simplify the problems associated with faults by providing the programmer with higher-level models or abstractions. <p> To tolerate software faults, multiple versions of a program are implemented and executed in parallel; N-version programming is one realization of this technique <ref> [Avi85] </ref>. To tolerate operational faults, multiple copies of the same program are executed in parallel on separate machines with independent failure modes; the replicated state machine approach [Sch90] is a formalization of this technique.
Reference: [BHG87] <author> P. A. Bernstein, V. Hadzilacos, and N. Goodman. </author> <title> Con-currency Control and Recovery in Database Systems. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <year> 1987. </year>
Reference-contexts: These include such things as recovery blocks [Ran75] and N-version programming [Avi85] for dealing with software faults, and checkpointing <ref> [BHG87] </ref>, atomic actions [Lis85], and the replicated state machine approach [Sch90] for dealing with operational faults. All of these simplify the problems associated with faults by providing the programmer with higher-level models or abstractions. <p> To illustrate these points, we now describe how redoing can be used to implement recovery blocks, a technique used primarily to handle software faults [Ran75], and checkpointing, a technique used to recover from operational faults <ref> [BHG87] </ref>. In the recovery block method, multiple implementations M 1 ; : : : ; M k are prepared for a module M .
Reference: [HNS89] <author> R. Harper, , G. Nagle, and M. Serrano. </author> <title> Use of a functional programming model for fault tolerant parallel programming. </title> <booktitle> In Proceedings of the Nineteenth Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 20-26, </pages> <address> Chicago, IL, </address> <month> Jun </month> <year> 1989. </year>
Reference-contexts: Any others are still kept in object base, but are invisible to normal computations (step (c)). 5 Conclusions FTAG is a computational model that is well-suited for writing fault-tolerant software due to its functional and attributed nature. Although others have noted similar advantages with respect to functional programming <ref> [HNS89, JA91] </ref>, our work goes beyond these efforts by developing a formal computational model based on these ideas and exploiting the advantages of the approach in software that can tolerate operational and/or software faults. FTAG is also unique in exploiting the advantages of attribute grammars as well as functional programming.
Reference: [JA91] <author> R. Jagannathan and E. Ashcroft. </author> <title> Fault tolerance in parallel implementations of functional languages. </title> <booktitle> In Proceedings of the 21st Symposium on Fault Tolerant Computing, </booktitle> <pages> pages 256-263, </pages> <address> Montreal, Canada, </address> <month> Jun </month> <year> 1991. </year>
Reference-contexts: Any others are still kept in object base, but are invisible to normal computations (step (c)). 5 Conclusions FTAG is a computational model that is well-suited for writing fault-tolerant software due to its functional and attributed nature. Although others have noted similar advantages with respect to functional programming <ref> [HNS89, JA91] </ref>, our work goes beyond these efforts by developing a formal computational model based on these ideas and exploiting the advantages of the approach in software that can tolerate operational and/or software faults. FTAG is also unique in exploiting the advantages of attribute grammars as well as functional programming.
Reference: [Kat81] <author> T. Katayama. HFP, </author> <title> a hierarchical and functional programming based on attribute grammars. </title> <booktitle> In Proceedings of the Fifth International Conference on Software Engineering, </booktitle> <pages> pages 343-353, </pages> <year> 1981. </year>
Reference-contexts: A more formal description of the model can be found in [SKS93]. 2 An Overview of the FTAG Computational Model In this section, we introduce the FTAG computational model. The model is based on the HFP (Hierarchical and Functional Process) model <ref> [Kat81] </ref>, which is in turn derived from attribute grammars. The basics of the model are outlined first, followed by a description of facilities for redoing [SIK93], replication, and stable object access. 2.1 The Basic Model In FTAG, every computation consists of a collection of pure mathematical functions called modules.
Reference: [Lam81] <author> B. Lampson. </author> <title> Atomic transactions. </title> <booktitle> In Distributed SystemsArchitecture and Implementation, </booktitle> <pages> pages 246-265. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: A more realistic choice is to store the values on secondary storage using an abstraction that we will refer to as a stable object base. As a form of stable storage <ref> [Lam81] </ref>, values stored in this object base are assumed to survive failures. Given the greater access times for the object base relative to primary memory, it is important to control which values actually get stored in the object base. <p> Hence, M 21 can be made a restartable action <ref> [Lam81] </ref> as follows by having M 22 check its input attribute and redo M 2 should it have const N = 1000000 (fla large numberfl) type V = array 1::N of v calc (i j v) ) ::: (flan expensive calculationfl) main ( j V ) ) for i = 1::N
Reference: [Lis85] <author> B. Liskov. </author> <title> The Argus language and system. </title> <editor> In M. Paul and H.J. Siegert, editors, </editor> <title> Distributed Systems: Methods and Tools for Specification, </title> <booktitle> Lecture Notes in Computer Science, </booktitle> <volume> Volume 190, chapter 7, </volume> <pages> pages 343-430. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1985. </year>
Reference-contexts: These include such things as recovery blocks [Ran75] and N-version programming [Avi85] for dealing with software faults, and checkpointing [BHG87], atomic actions <ref> [Lis85] </ref>, and the replicated state machine approach [Sch90] for dealing with operational faults. All of these simplify the problems associated with faults by providing the programmer with higher-level models or abstractions.
Reference: [Ran75] <author> B. Randell. </author> <title> System structure for software fault tolerance. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-1(2):220-232, </volume> <month> Jun </month> <year> 1975. </year>
Reference-contexts: These include such things as recovery blocks <ref> [Ran75] </ref> and N-version programming [Avi85] for dealing with software faults, and checkpointing [BHG87], atomic actions [Lis85], and the replicated state machine approach [Sch90] for dealing with operational faults. All of these simplify the problems associated with faults by providing the programmer with higher-level models or abstractions. <p> Here, we assume that all failures of interest are manifested by incorrect attribute values that can be tested by a conditional. Such an assumption is common for software faults <ref> [Ran75] </ref>, while operational faults such as crashed processors can be translated into a distinguished value ? (bottom) that is assigned to the appropriate attribute values by the underlying system. The simplest case of redoing is illustrated in Figure 3. <p> The state rollback is implicit and automatic since the remaining parts of the tree contain all the input values needed to redo the calculation. To illustrate these points, we now describe how redoing can be used to implement recovery blocks, a technique used primarily to handle software faults <ref> [Ran75] </ref>, and checkpointing, a technique used to recover from operational faults [BHG87]. In the recovery block method, multiple implementations M 1 ; : : : ; M k are prepared for a module M .
Reference: [Sch90] <author> F. Schneider. </author> <title> Implementing fault-tolerant services using the state machine approach: A tutorial. </title> <journal> ACM Computing Surveys, </journal> <volume> 22(4) </volume> <pages> 299-319, </pages> <month> Dec </month> <year> 1990. </year>
Reference-contexts: These include such things as recovery blocks [Ran75] and N-version programming [Avi85] for dealing with software faults, and checkpointing [BHG87], atomic actions [Lis85], and the replicated state machine approach <ref> [Sch90] </ref> for dealing with operational faults. All of these simplify the problems associated with faults by providing the programmer with higher-level models or abstractions. Despite the inherent differences in these approaches, one common thread is that they all have typically been con ceived and expressed using an imperative computational model. <p> To tolerate operational faults, multiple copies of the same program are executed in parallel on separate machines with independent failure modes; the replicated state machine approach <ref> [Sch90] </ref> is a formalization of this technique. The FTAG model can be used to realize either type of replication is a straightforward and intuitive way.
Reference: [SIK93] <author> M. Suzuki, A. Iwai, and T. Katayama. </author> <title> A formal model of re-exection in software process. </title> <booktitle> In Proceedings of the Second Internatiocal Conference on Software Process, </booktitle> <pages> pages 84-99, </pages> <address> Berlin, Germany, </address> <month> Feb </month> <year> 1993. </year>
Reference-contexts: The model is based on the HFP (Hierarchical and Functional Process) model [Kat81], which is in turn derived from attribute grammars. The basics of the model are outlined first, followed by a description of facilities for redoing <ref> [SIK93] </ref>, replication, and stable object access. 2.1 The Basic Model In FTAG, every computation consists of a collection of pure mathematical functions called modules. Each module has multiple inputs and outputs.
Reference: [SKS93] <author> M. Suzuki, T. Katayama, and R. D. Schlichting. </author> <title> A functional and attribute based computational model for fault-tolerant software. </title> <type> Technical Report TR 93-8, </type> <institution> Dept of Computer Science, University of Arizona, </institution> <address> Tucson, AZ, </address> <year> 1993. </year>
Reference-contexts: This paper concentrates on explaining FTAG from an intuitive point of view, illustrating its use for fault-tolerant software, and describing how it can be implemented in a computer system with multiple processors. A more formal description of the model can be found in <ref> [SKS93] </ref>. 2 An Overview of the FTAG Computational Model In this section, we introduce the FTAG computational model. The model is based on the HFP (Hierarchical and Functional Process) model [Kat81], which is in turn derived from attribute grammars. <p> Such values can be specified explicitly as described below or determined implicitly in certain cases (e.g., when inherited attribute values may be needed for redoing) as described in <ref> [SKS93] </ref>. Certain activities such as redoing are also facilitated if attribute values in the object base that would normally be overwritten in the object base are retained instead.
References-found: 11

