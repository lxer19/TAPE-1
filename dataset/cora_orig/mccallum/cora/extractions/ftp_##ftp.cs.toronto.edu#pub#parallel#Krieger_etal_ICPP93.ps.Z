URL: ftp://ftp.cs.toronto.edu/pub/parallel/Krieger_etal_ICPP93.ps.Z
Refering-URL: http://www.eecg.toronto.edu/~okrieg/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: A Fair Fast Scalable Reader-Writer Lock  
Author: Orran Krieger, Michael Stumm, Ron Unrau, and Jonathan Hanna 
Address: Toronto, Toronto, Canada, M5S 1A4  
Affiliation: Department of Electrical and Computer Engineering University of  
Note: Proc. Intl. Conf. on Parallel Processing, 1993.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> T. E. Anderson. </author> <title> The performance of spin lock alternatives for shared-memory multiprocessors. </title> <journal> IEEE Tran. on Par. and Dis. Sys., </journal> <volume> 1(1) </volume> <pages> 6-16, </pages> <year> 1990. </year>
Reference-contexts: Several researchers have shown how to implement scalable exclusive locks, that is, exclusive locks that can become contended without resulting in memory or interconnection network contention <ref> [1, 2, 5] </ref>. These algorithms depend either on cache hardware support or on the existence of local memory, where accesses to local memory involve lower latency than accesses to remote memory (and involve no network traffic).
Reference: [2] <author> G. Graunke and S. Thakkar. </author> <title> Synchronization Algorithms for Shared-Memory Multiprocessors. </title> <journal> IEEE Computer, </journal> <volume> 23(6) </volume> <pages> 60-69, </pages> <month> June </month> <year> 1990. 1990. </year>
Reference-contexts: Several researchers have shown how to implement scalable exclusive locks, that is, exclusive locks that can become contended without resulting in memory or interconnection network contention <ref> [1, 2, 5] </ref>. These algorithms depend either on cache hardware support or on the existence of local memory, where accesses to local memory involve lower latency than accesses to remote memory (and involve no network traffic).
Reference: [3] <author> Gerard J. Holzmann. </author> <title> Design and Validation of Computer Protocols. </title> <publisher> Prentice Hall, </publisher> <year> 1991. </year>
Reference-contexts: A full description of this algorithm is contained in [4]. To verify both versions of our algorithm, we used a state space searching tool <ref> [3] </ref> to do a full search of the state space for small numbers of requesters, and a partial search for larger numbers of requesters. Although partial searches cannot prove correctness, our tests have found all of our (previous) errors very quickly.
Reference: [4] <author> Orran Krieger, Michael Stumm, Ron Unrau, and Jonathan Hanna. </author> <title> A fair fast scalable reader-writer lock. </title> <institution> CSRI, University of Toronto, </institution> <year> 1993. </year>
Reference-contexts: A full description of this algorithm is contained in <ref> [4] </ref>. To verify both versions of our algorithm, we used a state space searching tool [3] to do a full search of the state space for small numbers of requesters, and a partial search for larger numbers of requesters.
Reference: [5] <author> J. M. Mellor-Crummey and M. L. Scott. </author> <title> Algorithms for Scalable Synchronization on Shared-Memory Multiprocessors. </title> <journal> ACM Trans. on Comp. Sys., </journal> <volume> 9(1), </volume> <month> Feb. </month> <year> 1991. </year>
Reference-contexts: Several researchers have shown how to implement scalable exclusive locks, that is, exclusive locks that can become contended without resulting in memory or interconnection network contention <ref> [1, 2, 5] </ref>. These algorithms depend either on cache hardware support or on the existence of local memory, where accesses to local memory involve lower latency than accesses to remote memory (and involve no network traffic). <p> With the singly linked list used by Mellor-Crummey and Scott's exclusive lock, this problem can be solved at the cost of some requests occasionally being served out of order <ref> [5] </ref>. However, with our doubly linked list the problem becomes much more difficult to handle. 4 PERFORMANCE The variant of our algorithm that uses only fetch and store was implemented in C code on the Hector multiprocessor [8].
Reference: [6] <author> J. M. Mellor-Crummey and M. L. Scott. </author> <title> Scalable Reader-Writer Synchronization for Shared-Memory Multiprocessors. </title> <booktitle> In Third ACM SIG-PLAN Symp. on PPOPP, </booktitle> <year> 1991. </year>
Reference-contexts: These algorithms depend either on cache hardware support or on the existence of local memory, where accesses to local memory involve lower latency than accesses to remote memory (and involve no network traffic). Mellor-Crummey and Scott <ref> [6] </ref> recognized the need for scalable RW locks and developed an implementation for the BBN TC2000. Their results indicate that their algorithm performs well, however, it depends on the rich set of atomic operations provided by the BBN TC2000. <p> Finally, the only atomic operation required by our algorithm is fetch and store. Therefore, it can be used on multiprocessors that do not support the rich set of atomic operations provided by the BBN TC2000. 2 BACKGROUND Mellor-Crummey and Scott's scalable RW lock is derived from their exclusive lock <ref> [6] </ref>, which uses atomic operations to build a singly linked list of waiting processors (Fig. 1a). The processor at the list head has the lock and new processors add themselves to the list tail.
Reference: [7] <author> M. Stumm, R. Unrau, and O. Krieger. </author> <title> Designing a Scalable Operating System for Shared Memory Multiprocessors. </title> <booktitle> In Usenix Workshop on Micro-kernels and Other Kernel Architectures, </booktitle> <year> 1992. </year>
Reference-contexts: The particular system used is a 16 processor system that runs at 16MHz and uses MC88100 processors. The experiments where performed as regular user programs running on a fully configured Hurricane operating system <ref> [7] </ref>. RW lock to a simple exponential backoff RW lock when p processors continuously acquire and release locks for reading. The different curves for each lock type show the performance when the locks are held for varying amounts of time.
Reference: [8] <author> Zvonko G. Vranesic, Michael Stumm, Ron White, and David Lewis. </author> <title> "The Hector Multiprocessor". </title> <journal> IEEE Computer, </journal> <volume> 24(1), </volume> <month> January </month> <year> 1991. </year> <pages> Page 4 </pages>
Reference-contexts: However, with our doubly linked list the problem becomes much more difficult to handle. 4 PERFORMANCE The variant of our algorithm that uses only fetch and store was implemented in C code on the Hector multiprocessor <ref> [8] </ref>. The particular system used is a 16 processor system that runs at 16MHz and uses MC88100 processors. The experiments where performed as regular user programs running on a fully configured Hurricane operating system [7].
References-found: 8

