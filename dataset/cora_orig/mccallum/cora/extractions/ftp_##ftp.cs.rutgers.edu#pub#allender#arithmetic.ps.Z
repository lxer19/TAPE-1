URL: ftp://ftp.cs.rutgers.edu/pub/allender/arithmetic.ps.Z
Refering-URL: http://www.cs.rutgers.edu/~allender/publications/
Root-URL: http://www.cs.rutgers.edu
Email: manindra@iitk.ernet.in  allender@cs.rutgers.edu  sdatta@paul.rutgers.edu  
Title: On TC 0 AC 0 and Arithmetic Circuits terms of AC 0 circuits might provide
Author: Manindra Agrawal Eric Allender Samir Datta 
Note: Using the naming conventions of [FFK94, CMTV96], this yields: ization of TC 0 in  Part of this research was done while visiting the University of Ulm under an Alexander von Humboldt Fellowship. Supported in part by NSF grant CCR-9509603.Portions of the work were performed while this author was a visiting  Supported in part by a Rutgers University Graduate Excellence Fel lowship and by NSF grant CCR-9509603. forms for #AC 0  
Address: Kanpur 208016, India  P.O. Box 1179 Piscataway, NJ 08855-1179,USA  P.O. Box 1179 Piscataway, NJ 08855-1179,USA  Chennai, India  
Affiliation: Department of Computer Science Indian Institute of Technology  Department of Computer Science Rutgers University  Department of Computer Science Rutgers University  scholar at the Institute of Mathematical Sciences,  
Abstract: Continuing a line of investigation that has studied the function classes #P [Val79b], #SAC 1 [Val79a, Vin91, AJMV], #L [AJ93b, Vin91, AO94], and #NC 1 [CMTV96], we study the class of functions #AC 0 . One way to define #AC 0 is as the class of functions computed by constant-depth polynomial-size arithmetic circuits of unbounded fan-in addition and multiplication gates. In contrast to the preceding function classes, for which we know no nontrivial lower bounds, lower bounds for #AC 0 follow easily from established circuit lower bounds. One of our main results is a characterization of TC 0 in terms of #AC 0 : A language A is in TC 0 if and only if there is a #AC 0 function f and a number k such that x 2 A () f(x) = 2 jxj k TC 0 = PAC 0 = C = AC 0 : Another restatement of this characterization is that TC 0 can be simulated by constant-depth arithmetic circuits, with a single threshold gate. We hope that perhaps this character Our characterization differs markedly from earlier characterizations of TC 0 in terms of arithmetic circuits over finite fields [RT92, BFS92]. Using our model of arithmetic circuits, computation over finite fields yields ACC 0 . We also prove a number of closure properties and normal 
Abstract-found: 1
Intro-found: 1
Reference: [AH94] <author> E. Allender and U. Hertrampf, </author> <title> Depth Reduction for Circuits of Unbounded Fan-In. Information and Computation, </title> <address> 112(2):217238, </address> <year> 1994. </year>
Reference-contexts: Assume that #AC 0 k = #AC 0 k+1 for some k &gt; 0. It follows then that #AC 0 = #AC 0 k . Let A be a language in AC 0 but not in depth k AC 0 [2]. (See, for instance Proposition 11 in <ref> [AH94] </ref>. We can choose A to be the mod 3 of the first log a n bits, for some a.) The characteristic function of A is in #AC 0 , and therefore, in #AC 0 k by our assumption.
Reference: [ABO96] <author> E. Allender, R. Beals, and M. Ogihara. </author> <title> The complexity of matrix rank and feasible systems of linear equations. </title> <booktitle> In Proc. 28th ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 161167, </pages> <year> 1996. </year>
Reference-contexts: PP and PL were first studied in [Gil77] and have been considered in many papers; C = P was studied in [Wag86] and elsewhere, and C = L was studied in <ref> [ABO96] </ref> (see also [ST]). PNC 1 and C = NC 1 were defined and studied in [CMTV96] (see also [Mac]). A main result of this paper is that PAC 0 and C = AC 0 coincide with TC 0 .
Reference: [AJ93a] <author> E. Allender and J. Jiao. </author> <title> Depth reduction for noncommutative arithmetic circuits. </title> <booktitle> In Proc. 25th ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 515522, </pages> <year> 1993. </year>
Reference: [AJ93b] <author> C. Alvarez and B. Jenner. </author> <title> A very hard log-space counting class. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 107:330, </address> <year> 1993. </year>
Reference-contexts: Counting Classes Certainly the best-known counting class is Valiant's class #P [Val79b], consisting of functions that map x to the number of accepting computations of an NP-machine on input x. Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention <ref> [AJ93b, Vin91, Tod, MV] </ref>. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant [Vin91, Tod, Val92, MV].
Reference: [AJMV] <author> E. Allender, J. Jiao, M. Mahajan, and V. Vinay. </author> <title> Non-commutative arithmetic circuits: depth reduction and size lower bounds. </title> <note> To appear in Theoretical Computer Science. Preliminary versions appeared as [AJ93a, MV94]. </note>
Reference: [All] <author> E. Allender. </author> <title> The permanent requires large uniform threshold circuits. </title> <note> Submitted. A preliminary version of this paper appeared as [All96]. </note>
Reference-contexts: as multiplication, division, and sorting, as well as being a computational model for neural nets [RT92, CSV84, PS88].) It remains an open question as to whether every function in #P has TC 0 circuits (although it is at least known that not all #P functions have Dlogtime-uniform TC 0 circuits <ref> [All] </ref>). The main contribution of this paper is to present a new connection between AC 0 and TC 0 . We characterize TC 0 as being the class of languages that arises in several ways from counting the number of accepting subtrees of AC 0 circuits. <p> It is currently an open question whether a given bit of the permanent can be computed as the high-order bit of Dlogtime-uniform #AC 0 functions, although if the inclusion PAC 0 TC 0 holds also in the Dlogtime-uniform setting, then a negative answer would follow from the lower bound of <ref> [All] </ref>. The main obstacle to proving a Dlogtime-uniform analog to Theorem 17 seems to the problem of finding a generator for the multiplicative group Z p .
Reference: [All89] <author> E. Allender. </author> <title> P-uniform circuit complexity. </title> <journal> J. ACM, </journal> <volume> 36:912928, </volume> <year> 1989. </year>
Reference-contexts: If there is an efficient algorithm for constructing C n , given n, then the family is said to be uniform, where different notions of efficient give rise to different notions of uniformity. We will consider P-uniform, logspace-uniform, and Dlogtime-uniform circuit families. For P-uniform circuits <ref> [BCH86, All89] </ref>, the mapping n 7! C n is computable in polynomial time, for logspace-uniform circuits [Ruz81], the mapping is computable in logspace. Dlogtime-uniformity requires a somewhat more careful definition; we refer the reader to [BIS90].
Reference: [All96] <author> E. Allender. </author> <title> A note on uniform circuit lower bounds for the counting hierarchy. </title> <booktitle> In International Conference on Computing and Combinatorics Conference (COCOON), volume 1090 of Lecture Notes in Computer Science, </booktitle> <pages> pages 127135. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference: [AO94] <author> E. Allender and M. Ogihara. </author> <title> Relationships among PL, #L, and the determinant. </title> <booktitle> In Proc. 9th IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 267278, </pages> <year> 1994. </year>
Reference-contexts: In order to develop this in a general setting, it is useful to define the Gap classes. The class GapP was defined in [FFK94], and by anal ogy GapL was studied in <ref> [Vin91, AO94] </ref>, and GapNC 1 was studied in [CMTV96]. In all of these cases, there are two equivalent definitions: 1. GapC is the class of functions that are the difference of two #C functions. 2.
Reference: [BCH86] <author> P. Beame, S. Cook, and H. J. </author> <title> Hoover. Log depth circuits for division and related problems. </title> <journal> SIAM J. Comput., </journal> <volume> 15:9941003, </volume> <year> 1986. </year>
Reference-contexts: If there is an efficient algorithm for constructing C n , given n, then the family is said to be uniform, where different notions of efficient give rise to different notions of uniformity. We will consider P-uniform, logspace-uniform, and Dlogtime-uniform circuit families. For P-uniform circuits <ref> [BCH86, All89] </ref>, the mapping n 7! C n is computable in polynomial time, for logspace-uniform circuits [Ruz81], the mapping is computable in logspace. Dlogtime-uniformity requires a somewhat more careful definition; we refer the reader to [BIS90]. <p> Getting rid of the P-uniformity condition in Theorem 11 seems closely-related to the problem of finding logspace-uniform (or Dlogtime-uniform) circuits for iterated integer multiplication, which in turn is equivalent to obtaining more uniform circuits for division <ref> [BCH86, IL95, RT92] </ref>. Another direction worth investigating concerns branch ing programs.
Reference: [BFS92] <author> J. Boyar, G. Frandsen, and G. Sturtivant. </author> <title> An arithmetical model of computation equivalent to threshold circuits. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 93:303319, </address> <year> 1992. </year>
Reference-contexts: Corollary 24 In the Logspace-Uniform Setting, TC 0 = C = AC 0 circ = PAC 0 circ : 5. Arithmetic Circuits over Finite Fields There has been earlier work characterizing TC 0 in terms of finite fields <ref> [BFS92, FVB94, RT92] </ref>. However, this earlier work provides no connection to AC 0 , and the characterizations involve having a different finite field for each input length.
Reference: [B97] <author> D. A. </author> <title> Mix Barrington, </title> <type> Personal Communication, </type> <year> 1997. </year>
Reference-contexts: Lemma 4 below, we have, #N (x) k1 X 2 ki1 Y #M j (x) 5 k1 X h i 4 j=0 3 = 2 kq 1 (n) j=1 = 2 kq 1 (n) #M (x): The proof is now complete except for the following lemmas. (As David Mix Barrington <ref> [B97] </ref> has pointed out, this first lemma can be understood intuitively as computing the volume of a k-dimensional cube of side a with a piece removed.) Lemma 4 Let a, a 1 ; : : : ; a k be integers, where a 0 = 1. <p> It may be interesting to point out that, when one uses our notion of arithmetic circuits over finite fields, one obtains a characterization of ACC 0 . (It has been pointed out to us by David Mix Barrington <ref> [B97] </ref> that this is in some sense implicit in the work of Smolensky [Smo87].) We need the following fact from number theory.
Reference: [BIS90] <author> D. A. Mix Barrington, N. Immerman, and H. </author> <title> Straubing. </title> <journal> On uniformity within NC 1 . Journal of Computer and System Sciences, </journal> <volume> 41:274 306, </volume> <year> 1990. </year>
Reference-contexts: We will consider P-uniform, logspace-uniform, and Dlogtime-uniform circuit families. For P-uniform circuits [BCH86, All89], the mapping n 7! C n is computable in polynomial time, for logspace-uniform circuits [Ruz81], the mapping is computable in logspace. Dlogtime-uniformity requires a somewhat more careful definition; we refer the reader to <ref> [BIS90] </ref>. Although Dlogtime-uniformity is widely-regarded as being the right notion of uniformity to use when discussing small circuit complexity classes such as TC 0 and AC 0 , only a few of our theorems mention Dlogtime-uniformity.
Reference: [BT88] <author> D. A. Mix Barrington and D. Therien. </author> <title> Finite monoids and the fine structure of NC 1 . Journal of the ACM, </title> <address> 35:941952, </address> <year> 1988. </year>
Reference-contexts: Another direction worth investigating concerns branch ing programs. It is shown in [CMTV96] that #NC 1 is closely related to the problem of counting paths in bounded-width branching programs, and it is also known that AC 0 is the class of languages accepted by branching programs over acyclic monoids <ref> [BT88] </ref>. Is there some characterization of #AC 0 or DiffAC 0 in terms of branching programs? Is there a related algebraic characterization? Acknowledgements We would like to thank Richard Bumby, David Mix Bar-rington, Pierre McKenzie, Denis Therien, Noam Nisan and Dieter van Melkebeek for discussions and suggestions on the material.
Reference: [CMTV96] <author> H. Caussinus, P. McKenzie, D. Therien, and H. Vollmer. </author> <title> Nondeterministic NC 1 computation. </title> <booktitle> In Proceedings, 11th Annual IEEE Conference on Computational Complexity, </booktitle> <pages> pages 1221, </pages> <year> 1996. </year>
Reference-contexts: The counting classes that result in this way by arith-metizing the Boolean circuit classes SAC 1 and NC 1 were studied in [Vin91] (where it was shown that #SAC 1 corresponds to counting the accepting paths of a NAuxPDA) and in <ref> [CMTV96] </ref> (where it was shown that #NC 1 is closely-related to counting paths in bounded-width branching programs). In this paper, we study #AC 0 . <p> In order to develop this in a general setting, it is useful to define the Gap classes. The class GapP was defined in [FFK94], and by anal ogy GapL was studied in [Vin91, AO94], and GapNC 1 was studied in <ref> [CMTV96] </ref>. In all of these cases, there are two equivalent definitions: 1. GapC is the class of functions that are the difference of two #C functions. 2. <p> PP and PL were first studied in [Gil77] and have been considered in many papers; C = P was studied in [Wag86] and elsewhere, and C = L was studied in [ABO96] (see also [ST]). PNC 1 and C = NC 1 were defined and studied in <ref> [CMTV96] </ref> (see also [Mac]). A main result of this paper is that PAC 0 and C = AC 0 coincide with TC 0 . However, there are two difficulties that must be overcome before we can even state this theorem. <p> Another direction worth investigating concerns branch ing programs. It is shown in <ref> [CMTV96] </ref> that #NC 1 is closely related to the problem of counting paths in bounded-width branching programs, and it is also known that AC 0 is the class of languages accepted by branching programs over acyclic monoids [BT88].
Reference: [CSV84] <author> A. Chandra, L. Stockmeyer, and U. Vishkin. </author> <title> Constant depth reducibility. </title> <journal> SIAM Journal on Computing, </journal> <volume> 13:423439, </volume> <year> 1984. </year>
Reference-contexts: is only poorly understood, in spite of having been the object of many investigations. (The class TC 0 is of special interest in computer science, since it characterizes the computational complexity of such important operations as multiplication, division, and sorting, as well as being a computational model for neural nets <ref> [RT92, CSV84, PS88] </ref>.) It remains an open question as to whether every function in #P has TC 0 circuits (although it is at least known that not all #P functions have Dlogtime-uniform TC 0 circuits [All]). <p> This circuit is clearly Logspace uniform from the Logspace computability of f . Composing this circuit with the circuit for g yields the required circuit. * (of Lemma 23-2) Straightforward. * (of Lemma 23-3) This is well known (e.g. see <ref> [CSV84] </ref>). * (of Lemma 23-4) sum k = mod k ffi sum. Result fol lows from Lemmas 22-4, 23-3 and 23-1. * (of Lemma 23-5) Let g = ind g ffi mod p . Then prod p = pow g ffisum p1 ffi~g.
Reference: [DGS86] <author> L. Denenberg, Y. Gurevich, and S. Shelah. </author> <title> De-finability by constant-depth polynomial-size circuits. </title> <journal> Information and Control, </journal> <volume> 70:216240, </volume> <year> 1986. </year>
Reference-contexts: For any func tion g (n) 6= log O (1) n, the function f (x) since this function is 0 iff f (x) &lt; g (n), and thus the underlying Boolean AC 0 circuit would be computing the g (n)- threshold function, which is not in AC 0 <ref> [FKPS85, DGS86] </ref>. This argument leaves open the question of what happens when g (n) 6= O (1) but g (n) = log O (1) n. For g in this range, the g (n) threshold is computable in AC 0 [FKPS85, DGS86], but the currently-known proofs of this fact do not preserve <p> the g (n)- threshold function, which is not in AC 0 <ref> [FKPS85, DGS86] </ref>. This argument leaves open the question of what happens when g (n) 6= O (1) but g (n) = log O (1) n. For g in this range, the g (n) threshold is computable in AC 0 [FKPS85, DGS86], but the currently-known proofs of this fact do not preserve the number of accepting subtrees. Open Question 6 Are the functions P log n and i x i 4.
Reference: [DL91] <author> George I. Davida and Bruce Litow. </author> <title> Fast parallel arithmetic via modular representation. </title> <journal> SIAM Journal on Computing, </journal> <volume> 20(4):756765, </volume> <month> August </month> <year> 1991. </year>
Reference-contexts: So we just need to show that each of the q 0 be computed using Logspace-uniform TC 0 circuits. But this follows from Lemma 23-7,8 below. (We remark that, instead of relying on [DMS94], it is also possible to make use of similar results of <ref> [Lit92, DL91] </ref>.
Reference: [DMS94] <author> Paul F. Dietz, Ioan I. Macarie, and Joel I. Seiferas. </author> <title> Bits and relative order from residues, space efficiently. </title> <journal> Information Processing Letters, </journal> <volume> 50(3):123127, </volume> <month> 9 May </month> <year> 1994. </year>
Reference-contexts: Remainder Theorem we know that the number in question (i.e. the number with residues x i modulo p i ) is X k = A k q k P k : Essentially we need to find out the first bit of the fractional representation of A k =P k . <ref> [DMS94] </ref> shows how to do this in Logspace. We show that their method is amenable to a TC 0 circuit implementation. <p> The essential idea is to compute the first 3dlog 2 ie bits of each of the fractions t i;j (x) = ((x j c i;j ) mod p j )=p j (for 1 j i k) and find the sums q 0 P i approximating A i =P i . <ref> [DMS94] </ref> show that if the fractional part of q 0 k (x) contains any zeros, then the first bit of the fractional part of q 0 k (x) is equal to the first bit of the fractional part of A k =P k (which is the bit that we need to <p> If the fractional parts of q 0 (x) and of q 0 (x 0 ) are both all ones, then <ref> [DMS94] </ref> show that the computation can be repeated using q 0 k1 approximating A k1 =P k1 (which in this case has the same bit as A k =P k ). <p> So we just need to show that each of the q 0 be computed using Logspace-uniform TC 0 circuits. But this follows from Lemma 23-7,8 below. (We remark that, instead of relying on <ref> [DMS94] </ref>, it is also possible to make use of similar results of [Lit92, DL91]. It seems to us that the construction of [DMS94] results in a simpler circuit.) Lemma 22 The following are computable in O (log n) space where in the following x is n bits long and p; p <p> But this follows from Lemma 23-7,8 below. (We remark that, instead of relying on <ref> [DMS94] </ref>, it is also possible to make use of similar results of [Lit92, DL91]. It seems to us that the construction of [DMS94] results in a simpler circuit.) Lemma 22 The following are computable in O (log n) space where in the following x is n bits long and p; p i ; g; k; z are all O (log n) bits long. 1.
Reference: [Ete95] <author> K. Etessami. </author> <title> Counting quantifiers, successor relations, and logarithmic space. </title> <booktitle> In Proc. 10th IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 211, </pages> <year> 1995. </year>
Reference-contexts: can check if the graph on f1; : : : ; pg with edges i ! ig (modp) is a cycle. (It is a cycle if and only if g is a generator.) The problem of checking if a general graph is a cycle is complete for logspace (see, e.g., <ref> [Ete95] </ref>), and thus any argument han dling the Dlogtime-uniform TC 0 case will almost certainly need to make use of special properties of this graph.
Reference: [FFK94] <author> Stephen A. Fenner, Lance J. Fortnow, and Stu-art A. Kurtz. </author> <title> Gap-definable counting classes. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 48(1):116148, </volume> <month> February </month> <year> 1994. </year>
Reference-contexts: Language Classes Counting classes such as #P and #L are closely related to associated language classes such as PP and PL. In order to develop this in a general setting, it is useful to define the Gap classes. The class GapP was defined in <ref> [FFK94] </ref>, and by anal ogy GapL was studied in [Vin91, AO94], and GapNC 1 was studied in [CMTV96]. In all of these cases, there are two equivalent definitions: 1. GapC is the class of functions that are the difference of two #C functions. 2. <p> For large enough constant k, the function ((2 n k f (x)) + g (x)) is in #AC 0 , by Theorem 3. 3.2. Closure Properties We begin with some simple closure properties. In <ref> [FFK94] </ref> the notions of weak sum and weak product were defined as follows: Definition 8 Let C be a class of functions. * C is closed under weak sum if, for any f 2 C and any k, the function g (x) = P n k * C is closed under <p> Proof.(of Theorem 9) Notice that once we know that #AC 0 is closed under the choose operation, it follows immediately that DiffAC 0 is closed as well (using essentially the same proof as that of Closure Property 5 in <ref> [FFK94] </ref>). We proceed by induction on the depth of the counting circuit computing the #AC 0 function. If the circuit has depth 0, then the claim follows trivially as f (x) assumes values 0 and 1 only. <p> By Corollary 6, f (x) is of the form h (x)2 jxj l for some #AC 0 function h and some constant l. (This corollary shows that TC 0 is the AC 0 -analog of the class LWPP studied in <ref> [FFK94] </ref>. We refer the reader to [FFK94] for further details.) Corollary 16 is probably nearly the strongest result in this direction that one can prove. <p> By Corollary 6, f (x) is of the form h (x)2 jxj l for some #AC 0 function h and some constant l. (This corollary shows that TC 0 is the AC 0 -analog of the class LWPP studied in <ref> [FFK94] </ref>. We refer the reader to [FFK94] for further details.) Corollary 16 is probably nearly the strongest result in this direction that one can prove. For instance, one might seek to strengthen Corollary 16 to obtain g (n) = 1. (This corresponds to the AC 0 -analog of the class SPP studied in [FFK94].) Note that if <p> the reader to <ref> [FFK94] </ref> for further details.) Corollary 16 is probably nearly the strongest result in this direction that one can prove. For instance, one might seek to strengthen Corollary 16 to obtain g (n) = 1. (This corresponds to the AC 0 -analog of the class SPP studied in [FFK94].) Note that if g (n) = 1, then the characteristic function of A is in GapAC 0 . However, it follows from Proposition 27 that any such language A is in AC 0 [2].
Reference: [FKPS85] <author> R. Fagin, M. Klawe, N. Pippenger, and L. Stockmeyer. Bounded-depth, </author> <title> polynomial-size circuits for symmetric functions. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 36:239250, </address> <year> 1985. </year>
Reference-contexts: For any func tion g (n) 6= log O (1) n, the function f (x) since this function is 0 iff f (x) &lt; g (n), and thus the underlying Boolean AC 0 circuit would be computing the g (n)- threshold function, which is not in AC 0 <ref> [FKPS85, DGS86] </ref>. This argument leaves open the question of what happens when g (n) 6= O (1) but g (n) = log O (1) n. For g in this range, the g (n) threshold is computable in AC 0 [FKPS85, DGS86], but the currently-known proofs of this fact do not preserve <p> the g (n)- threshold function, which is not in AC 0 <ref> [FKPS85, DGS86] </ref>. This argument leaves open the question of what happens when g (n) 6= O (1) but g (n) = log O (1) n. For g in this range, the g (n) threshold is computable in AC 0 [FKPS85, DGS86], but the currently-known proofs of this fact do not preserve the number of accepting subtrees. Open Question 6 Are the functions P log n and i x i 4.
Reference: [FVB94] <author> G. Frandsen, M. Valence, and D. </author> <title> Mix Barring-ton. Some results on uniform arithmetic circuit complexity. </title> <journal> Mathematical Systems Theory, </journal> <volume> 27, </volume> <year> 1994. </year>
Reference-contexts: Corollary 24 In the Logspace-Uniform Setting, TC 0 = C = AC 0 circ = PAC 0 circ : 5. Arithmetic Circuits over Finite Fields There has been earlier work characterizing TC 0 in terms of finite fields <ref> [BFS92, FVB94, RT92] </ref>. However, this earlier work provides no connection to AC 0 , and the characterizations involve having a different finite field for each input length.
Reference: [Gil77] <author> J. Gill. </author> <title> Computational complexity of probabilistic Turing machines. </title> <journal> SIAM Journal on Computing, </journal> <volume> 6:675695, </volume> <year> 1977. </year>
Reference-contexts: PP and PL were first studied in <ref> [Gil77] </ref> and have been considered in many papers; C = P was studied in [Wag86] and elsewhere, and C = L was studied in [ABO96] (see also [ST]). PNC 1 and C = NC 1 were defined and studied in [CMTV96] (see also [Mac]).
Reference: [HW79] <author> G. H. Hardy and E. M. Wright. </author> <title> An Introduction to the Theory of Numbers. </title> <publisher> Oxford press, </publisher> <address> USA, </address> <year> 1979. </year>
Reference-contexts: We will need the following variant of the Chinese Remainder Theorem: Theorem 18 (see e.g. <ref> [HW79] </ref>) Given primes p 1 ; p 2 ; : : : ; p s and an integer x, there are unique integers x 1 ; x 2 ; : : : ; x s (modulo p 1 ; p 2 ; : : : ; p s respectively), satisfying x <p> More explicitly, x = A s q s P s where A s = j=1 c s;j = (P s =p j ) mod p j ; And the following variant of the prime-number theorem: Theorem 19 (see e.g. <ref> [HW79] </ref>) For sufficiently large val ues of n, the product of all primes less than n exceeds 2 n . <p> Theorem 25 (Dirichlet) (see e.g. <ref> [HW79] </ref>) For any two rel-atively prime numbers q and r, there exist infinitely many primes in the sequence fqn + rg 1 n=1 .
Reference: [IL95] <author> N. Immerman and S. Landau. </author> <title> The complexity of iterated multiplication. Information and Computation, </title> <address> 116:103116, </address> <year> 1995. </year>
Reference-contexts: Getting rid of the P-uniformity condition in Theorem 11 seems closely-related to the problem of finding logspace-uniform (or Dlogtime-uniform) circuits for iterated integer multiplication, which in turn is equivalent to obtaining more uniform circuits for division <ref> [BCH86, IL95, RT92] </ref>. Another direction worth investigating concerns branch ing programs.
Reference: [Lit92] <author> B. Litow. </author> <title> On iterated integer product. </title> <journal> Information Processing Letters, </journal> <volume> 42(5):269272, </volume> <month> 03 July </month> <year> 1992. </year>
Reference-contexts: So we just need to show that each of the q 0 be computed using Logspace-uniform TC 0 circuits. But this follows from Lemma 23-7,8 below. (We remark that, instead of relying on [DMS94], it is also possible to make use of similar results of <ref> [Lit92, DL91] </ref>.
Reference: [Mac] <author> I. Macarie. </author> <title> Space-efficient deterministic simulation of probabilistic automata. </title> <note> To appear in SIAM J. Comput. Preliminary version appeared as [Mac94]. </note>
Reference-contexts: PNC 1 and C = NC 1 were defined and studied in [CMTV96] (see also <ref> [Mac] </ref>). A main result of this paper is that PAC 0 and C = AC 0 coincide with TC 0 . However, there are two difficulties that must be overcome before we can even state this theorem.
Reference: [Mac94] <author> I. Macarie. </author> <title> Space-efficient deterministic simulation of probabilistic automata. </title> <booktitle> In 11th Symposium on Theoretical Aspects of Computing (STACS), volume 775 of Lecture Notes in Computer Science, </booktitle> <pages> pages 109122. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [MV] <author> M. Mahajan and V. Vinay. </author> <title> A combinatorial algorithm for the determinant. </title> <note> To appear in Proc. SODA '97. </note>
Reference-contexts: Counting Classes Certainly the best-known counting class is Valiant's class #P [Val79b], consisting of functions that map x to the number of accepting computations of an NP-machine on input x. Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention <ref> [AJ93b, Vin91, Tod, MV] </ref>. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant [Vin91, Tod, Val92, MV]. <p> Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention [AJ93b, Vin91, Tod, MV]. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant <ref> [Vin91, Tod, Val92, MV] </ref>.
Reference: [MV94] <author> M. Mahajan and V. Vinay. </author> <title> Non-commutative computation, depth reduction and skew circuits. </title> <booktitle> In Proc. 14th FST&TCS, volume 880 of Lecture Notes in Computer Science, </booktitle> <pages> pages 4859. </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference: [PS88] <author> I. Parberry and G. Schnitger. </author> <title> Parallel computation with threshold functions. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 36:278302, </volume> <year> 1988. </year>
Reference-contexts: is only poorly understood, in spite of having been the object of many investigations. (The class TC 0 is of special interest in computer science, since it characterizes the computational complexity of such important operations as multiplication, division, and sorting, as well as being a computational model for neural nets <ref> [RT92, CSV84, PS88] </ref>.) It remains an open question as to whether every function in #P has TC 0 circuits (although it is at least known that not all #P functions have Dlogtime-uniform TC 0 circuits [All]). <p> Theorem 11 P-uniform TC 0 P-uniform C = AC 0 and Dlogtime-uniform TC 0 Dlogtime-uniform C = AC 0 circ . Proof. We will need to use the following well-known fact (see e.g. <ref> [PS88] </ref>), Fact 12 A problem is in TC 0 if and only if it is accepted by a constant-depth family of exact-threshold gates ET m m=2 r gate has s inputs and outputs 1 iff exactly r of them are 1). Q m j=1;j6=m=2 (m=2 j).
Reference: [Raz87] <author> A. A. Razborov. </author> <title> Lower bounds on the size of bounded depth networks over a complete basis with logical addition. </title> <booktitle> Mathematicheskie Za-metki, 41:598607, 1987. English translation in Mathematical Notes of the Academy of Sciences of the USSR 41 </booktitle> <pages> 333-338, </pages> <year> 1987. </year>
Reference-contexts: However, it follows from Proposition 27 that any such language A is in AC 0 [2]. Thus the lower bound of <ref> [Raz87] </ref> (showing that MAJORITY is not in AC 0 [2]) shows that we cannot improve Corollary 16 to obtain g (n) = 1. More generally, observe that the function g (n) has lots of small divisors. This is no accident. <p> Lower Bounds, and Conclusions We know many lower bounds for #AC 0 . For instance, the Mod 3 function is not in #AC 0 , as a consequence of Proposition 27 and the circuit lower bounds in <ref> [Raz87] </ref>. At the end of Section 3.2 we saw that some functions related to the symmetric polynomials are not in #AC 0 .
Reference: [RR94] <author> A. A. Razborov and S. Rudich. </author> <title> Natural proofs. </title> <booktitle> In Proceedings, 26th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 204213, </pages> <year> 1994. </year>
Reference-contexts: Note that <ref> [RR94] </ref> argues that, if certain popular cryptographic assumptions are true, then there are no natural proofs of lower bounds for TC 0 circuits.
Reference: [RT92] <author> J. Reif and S. Tate. </author> <title> On threshold circuits and polynomial computation. </title> <journal> SIAM J. Comput., </journal> <volume> 21:896908, </volume> <year> 1992. </year>
Reference-contexts: is only poorly understood, in spite of having been the object of many investigations. (The class TC 0 is of special interest in computer science, since it characterizes the computational complexity of such important operations as multiplication, division, and sorting, as well as being a computational model for neural nets <ref> [RT92, CSV84, PS88] </ref>.) It remains an open question as to whether every function in #P has TC 0 circuits (although it is at least known that not all #P functions have Dlogtime-uniform TC 0 circuits [All]). <p> Proposition 13 C = AC 0 PAC 0 (under all considered notions of uniformity). Proposition 14 P-uniform (non-uniform) GapAC 0 P-uniform (non-uniform) FTC 0 . (This is a simple consequence of the fact that unbounded fan-in addition and multiplication are in P-uniform TC 0 <ref> [RT92] </ref>.) Corollary 15 In the P-Uniform and Non-Uniform Settings, C = AC 0 = PAC 0 = TC 0 = C = AC 0 circ = PAC 0 circ : Note that one interpretation of the preceding corollary is that TC 0 languages can be computed with just constant-depth arithmetic and <p> Corollary 24 In the Logspace-Uniform Setting, TC 0 = C = AC 0 circ = PAC 0 circ : 5. Arithmetic Circuits over Finite Fields There has been earlier work characterizing TC 0 in terms of finite fields <ref> [BFS92, FVB94, RT92] </ref>. However, this earlier work provides no connection to AC 0 , and the characterizations involve having a different finite field for each input length. <p> Getting rid of the P-uniformity condition in Theorem 11 seems closely-related to the problem of finding logspace-uniform (or Dlogtime-uniform) circuits for iterated integer multiplication, which in turn is equivalent to obtaining more uniform circuits for division <ref> [BCH86, IL95, RT92] </ref>. Another direction worth investigating concerns branch ing programs.
Reference: [Ruz81] <author> W. Ruzzo. </author> <title> On uniform circuit complexity. </title> <journal> Journal of Computer and System Sciences, </journal> <volume> 21:365383, </volume> <year> 1981. </year>
Reference-contexts: We will consider P-uniform, logspace-uniform, and Dlogtime-uniform circuit families. For P-uniform circuits [BCH86, All89], the mapping n 7! C n is computable in polynomial time, for logspace-uniform circuits <ref> [Ruz81] </ref>, the mapping is computable in logspace. Dlogtime-uniformity requires a somewhat more careful definition; we refer the reader to [BIS90].
Reference: [Smo87] <author> R. Smolensky. </author> <title> Algebraic methods in the theory of lower bounds for Boolean circuit complexity. </title> <booktitle> In Proceedings, 19th ACM Symposium on Theory of Computing, </booktitle> <pages> pages 7782, </pages> <year> 1987. </year>
Reference-contexts: may be interesting to point out that, when one uses our notion of arithmetic circuits over finite fields, one obtains a characterization of ACC 0 . (It has been pointed out to us by David Mix Barrington [B97] that this is in some sense implicit in the work of Smolensky <ref> [Smo87] </ref>.) We need the following fact from number theory. Theorem 25 (Dirichlet) (see e.g. [HW79]) For any two rel-atively prime numbers q and r, there exist infinitely many primes in the sequence fqn + rg 1 n=1 .
Reference: [ST] <author> M. Santha and S. Tan. </author> <title> Verifying the determinant in parallel. </title> <note> To appear in Computational Complexity. A preliminary version of this paper appeared in Proceedings of the 5th ACM-SIGSAM International Symposium on Symbolic and Algebraic Computation, </note> <year> 1994. </year>
Reference-contexts: PP and PL were first studied in [Gil77] and have been considered in many papers; C = P was studied in [Wag86] and elsewhere, and C = L was studied in [ABO96] (see also <ref> [ST] </ref>). PNC 1 and C = NC 1 were defined and studied in [CMTV96] (see also [Mac]). A main result of this paper is that PAC 0 and C = AC 0 coincide with TC 0 .
Reference: [Tod] <author> S. </author> <title> Toda. Counting problems computationally equivalent to the determinant. </title> <type> Manuscript. </type>
Reference-contexts: Counting Classes Certainly the best-known counting class is Valiant's class #P [Val79b], consisting of functions that map x to the number of accepting computations of an NP-machine on input x. Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention <ref> [AJ93b, Vin91, Tod, MV] </ref>. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant [Vin91, Tod, Val92, MV]. <p> Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention [AJ93b, Vin91, Tod, MV]. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant <ref> [Vin91, Tod, Val92, MV] </ref>.
Reference: [Tod92] <author> S. </author> <title> Toda. Classes of arithmetic circuits capturing the complexity of computing the determinant. </title> <journal> IEICE Trans. Inf. and Syst., </journal> <volume> E75-D:116 124, </volume> <year> 1992. </year>
Reference-contexts: of accepting subtrees of a circuit C is (a) equal to the output of the arithmetized version of C, (which we denote by #C) and (b) provides a natural notion of counting the number of proofs that C accepts.) The arithmetic circuits corresponding to #L were studied further by Toda <ref> [Tod92] </ref>.
Reference: [Val79a] <author> L. Valiant. </author> <title> Completeness classes in algebra. </title> <booktitle> In Proc. 11th ACM Symposium on Theory of Computing (STOC), </booktitle> <pages> pages 249261, </pages> <year> 1979. </year>
Reference: [Val79b] <author> L. Valiant. </author> <title> The complexity of computing the Permanent. </title> <booktitle> Theoretical Computer Science, </booktitle> <address> 8:189201, </address> <year> 1979. </year>
Reference-contexts: Equivalently, we characterize TC 0 in terms of constant-depth arithmetic circuits. In order to make these notions precise, we need to dis cuss counting and enumeration classes. 1.1. Counting Classes Certainly the best-known counting class is Valiant's class #P <ref> [Val79b] </ref>, consisting of functions that map x to the number of accepting computations of an NP-machine on input x. Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention [AJ93b, Vin91, Tod, MV]. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while <p> #P <ref> [Val79b] </ref>, consisting of functions that map x to the number of accepting computations of an NP-machine on input x. Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention [AJ93b, Vin91, Tod, MV]. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant [Vin91, Tod, Val92, MV].
Reference: [Val92] <author> L. Valiant. </author> <title> Why is boolean complexity theory difficult? In M. </title> <editor> S. Paterson, editor, </editor> <title> Boolean Function Complexity, </title> <booktitle> volume 169 of London Mathematical Society Lecture Notes Series, </booktitle> <pages> pages 8494. </pages> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention [AJ93b, Vin91, Tod, MV]. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant <ref> [Vin91, Tod, Val92, MV] </ref>.
Reference: [Ven92] <author> H. Venkateswaran. </author> <title> Circuit definitions of nondeterministic complexity classes. </title> <journal> SIAM Journal on Computing, </journal> <volume> 21:655670, </volume> <year> 1992. </year>
Reference-contexts: that #P and #L can also be characterized in terms of uniform arithmetic circuits, as follows: NP and NL both have characterizations in terms of uniform Boolean circuits. (NP sets are accepted by uniform exponential-size circuits of polynomial algebraic degree, and NL sets are accepted by uniform polynomial-size skew circuits <ref> [Ven92] </ref>. <p> Alternatively, #P and #L arise by counting the number of accepting subtrees for the corresponding classes of Boolean circuits. (See <ref> [Ven92] </ref> for a formal definition of this notion; for our purposes it is sufficient to know that the number of accepting subtrees of a circuit C is (a) equal to the output of the arithmetized version of C, (which we denote by #C) and (b) provides a natural notion of counting
Reference: [Vin91] <author> V. Vinay. </author> <title> Counting auxiliary pushdown automata and semi-unbounded arithmetic circuits. </title> <booktitle> In Proc. 6th IEEE Structure in Complexity Theory Conference, </booktitle> <pages> pages 270284, </pages> <year> 1991. </year>
Reference-contexts: Counting Classes Certainly the best-known counting class is Valiant's class #P [Val79b], consisting of functions that map x to the number of accepting computations of an NP-machine on input x. Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention <ref> [AJ93b, Vin91, Tod, MV] </ref>. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant [Vin91, Tod, Val92, MV]. <p> Recently, the class #L (counting accepting computations of an NL-machine) has also received considerable attention [AJ93b, Vin91, Tod, MV]. #P characterizes the complexity of computing the permanent of a matrix [Val79b], while #L characterizes the complexity of computing the determinant <ref> [Vin91, Tod, Val92, MV] </ref>. <p> The counting classes that result in this way by arith-metizing the Boolean circuit classes SAC 1 and NC 1 were studied in <ref> [Vin91] </ref> (where it was shown that #SAC 1 corresponds to counting the accepting paths of a NAuxPDA) and in [CMTV96] (where it was shown that #NC 1 is closely-related to counting paths in bounded-width branching programs). In this paper, we study #AC 0 . <p> In order to develop this in a general setting, it is useful to define the Gap classes. The class GapP was defined in [FFK94], and by anal ogy GapL was studied in <ref> [Vin91, AO94] </ref>, and GapNC 1 was studied in [CMTV96]. In all of these cases, there are two equivalent definitions: 1. GapC is the class of functions that are the difference of two #C functions. 2.
Reference: [Wag86] <author> K. W. Wagner. </author> <title> The complexity of combinatorial problems with succinct input representation. </title> <journal> Acta Informatica, </journal> <volume> 23:325356, </volume> <year> 1986. </year>
Reference-contexts: PP and PL were first studied in [Gil77] and have been considered in many papers; C = P was studied in <ref> [Wag86] </ref> and elsewhere, and C = L was studied in [ABO96] (see also [ST]). PNC 1 and C = NC 1 were defined and studied in [CMTV96] (see also [Mac]). A main result of this paper is that PAC 0 and C = AC 0 coincide with TC 0 .
Reference: [Yam96] <author> T. Yamakami. </author> <title> Uniform AC 0 Counting Circuits. </title> <type> Manuscript, </type> <year> 1996. </year>
Reference-contexts: Let #AC 0 = S k . 1 Why study #AC 0 ? Our motivation comes in large part from a desire to obtain more lower bounds in circuit com-1 Tomo Yamakami <ref> [Yam96] </ref> has recently defined #AC 0 somewhat dif ferently, and his definition does not appear comparable to ours. plexity.
References-found: 47

