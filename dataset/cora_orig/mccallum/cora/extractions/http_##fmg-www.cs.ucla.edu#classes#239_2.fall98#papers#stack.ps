URL: http://fmg-www.cs.ucla.edu/classes/239_2.fall98/papers/stack.ps
Refering-URL: http://fmg-www.cs.ucla.edu/classes/239_2.fall98/weekly.html
Root-URL: http://www.cs.ucla.edu
Title: File System Development with Stackable Layers several ways. Complex filing services are constructed from layer
Author: John S. Heidemann Gerald J. Popek 
Address: Los Angeles  Los Angeles, CA, 90024,  
Affiliation: Department of Computer Science University of California,  UCLA,  
Note: To appear, ACM Transactions on Computer Systems.  Stackable file system design addresses these issues in  each of which may be provided by independent parties. There are no syntactic  The authors can be reached at 3680 Boelter Hall,  or by electronic mail to johnh@cs.ucla.edu or  
Pubnum: Technical Report CSD-930019  
Email: popek@cs.ucla.edu.  
Date: July 1993  Last revised 7 July 1993.  
Abstract: Filing services have experienced a number of innovations in recent years, but many of these promising ideas have failed to enter into broad use. One reason is that current filing environments present several barriers to new development. For example, file systems today typically stand alone instead of building on the work of others, and support of new filing services often requires changes which invalidate existing work. This paper discusses stackable layering in detail and presents design techniques it enables. We describe an implementation providing these facilities that exhibits very high performance. By lowering barriers to new filing design, stackable layering offers the potential of broad third party file system development not feasible today. fl This work was sponsored by the Defense Advanced Research Projects Agency under contracts F29601-87-C-0072 and N00174-91-C-0107. Also, John Heidemann was sponsored by a USENIX scholarship for the 1990-91 academic year, and Gerald Popek is affiliated with Locus Computing Corporation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> Unix International Stackable Files Working Group. Requirements for stackable files. </institution> <note> Internal memorandum., </note> <year> 1992. </year>
Reference-contexts: When these facilities are provided in an address space independent manner, this framework enables a number of new development approaches. 15 While Rosenthal's model can be extended to support nonlinear stacking <ref> [1] </ref>, the result is, in effect two different "stacking" methods. 19 Widespread adoption of a framework such as that de-scribed in this paper will permit independent development of filing services by many parties, while individual developers can benefit from the ability to leverage others' work while moving forward independently.
Reference: [2] <author> Richard G. Guy, John S. Heidemann, Wai Mak, Thomas W. Page, Jr., Gerald J. Popek, and Dieter Rothmeier. </author> <title> Implementation of the Ficus replicated file system. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 63-71. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: However, there are also times when non-linear stacks are desirable. Fan-out occurs when a layer references "out" to multiple layers beneath it. Figure 3 illustrates how this structure is used to provide replication in Ficus <ref> [2] </ref>. Fan-in allows multiple clients access to a particular layer. If each stack layer is separately named, it is possible for knowledgeable programs to choose to avoid upper stack layers. <p> Fan-in allows a backup program to directly access the compressed version. An example of the use of cooperating layers in the Ficus replicated file system <ref> [2] </ref> is shown in Figure 3. The Ficus logical and physical layers correspond roughly to a client and server of a replicated service. A remote access layer is placed between them when necessary. 3.5 Compatibility with Layers The flexibility stacking provides promotes rapid interface and layer evolution.
Reference: [3] <author> David Hendricks. </author> <title> A filesystem for software development. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 333-340. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Limited file system stacking is possible with the standard vnode interface using the mount mechanism. Sun Microsystems' NFS [13], loopback, and translucent <ref> [3] </ref> file systems take this approach. Information associated with the mount command identifies the existing stack layer and where the new layer should be attached into the filing name space. 4.2 Extensibility in the UCLA Interface Accommodation of interface evolution is a critical problem with existing interfaces. <p> Section 2 compares stackable filing and the standard vnode interface. We build upon its abstractions and approach to modularity to provide stackable filing. The standard vnode interface has been used to provide basic file system stacking. Sun's loopback and translucent file systems <ref> [3] </ref>, and early versions of the Ficus file system were all built with a standard vnode interface.
Reference: [4] <author> John Howard, Michael Kazar, Sherri Menees, Da-vid Nichols, Mahadev Satyanarayanan, Robert Side-botham, and Michael West. </author> <title> Scale and performance in a distributed file system. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1) </volume> <pages> 51-81, </pages> <month> February </month> <year> 1988. </year>
Reference-contexts: The first step compares a kernel supporting only the UCLA interface with a standard kernel. To do so, we consider two benchmarks: the modified Andrew benchmark <ref> [8, 4] </ref> and the recursive copy and removal of large subdirectory trees. In addition, we examine the effect of adding multiple layers in the new interface. The Andrew benchmark has several phases, each of which examines different file system activities.
Reference: [5] <author> Norman C. Hutchinson, Larry L. Peterson, Mark B. Ab-bott, and Sean O'Malley. </author> <title> RPC in the x-Kernel: Evaluating new design techniques. </title> <booktitle> In Proceedings of the Twelfth Symposium on Operating Systems Principles, </booktitle> <pages> pages 91-101. </pages> <publisher> ACM, </publisher> <month> December </month> <year> 1989. </year>
Reference-contexts: Our experience shows that layers are most easily reusable and composable when each encompasses a single abstraction. This experience parallels those encountered in designing composable network protocols in the x-kernel <ref> [5] </ref> and tool development with the Unix shells [9]. As an example of this problem in the context of file system layering, consider the stack presented in Figure 1. <p> Ritchie's conclusion is that Streams significantly reduce complexity and improve maintainability of this portion of the kernel. Since their development Streams have been widely adopted. The x-kernel is an operating system nucleus designed to simplify network protocol implementation by implementing all protocols as stackable layers <ref> [5] </ref>. Key features are a uniform protocol interface, allowing arbitrary protocol composition; run-time choice of protocol stacks, allowing selection based on efficiency; and very inexpensive layer transition. The x-kernel demonstrates the effectiveness of layering in new protocol development in the network environment, and that performance need not suffer.
Reference: [6] <author> Michael J. Karels and Marshall Kirk McKusick. </author> <title> Toward a compatible filesystem interface. </title> <booktitle> In Proceedings of the European Unix User's Group, </booktitle> <pages> page 15. </pages> <address> EUUG, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: Each sub-tree is allowed a completely separate implementation. Data encapsulation requires that these abstract data types for files and subtrees be manipulated only by a restricted set of operations. The operations supported by vnodes, the abstract data type for "files", vary according to implementation (see [7] and <ref> [6] </ref> for semantics of typical operations). To allow this generic treatment of vnodes, binding of desired function to correct implementation is delayed until kernel initialization. This is implemented by asso 7 ciating with each vnode type an operations vector iden-tifying the correct implementation of each operation for that vnode type.
Reference: [7] <author> S. R. Kleiman. Vnodes: </author> <title> An architecture for multiple file system types in Sun Unix. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 238-247. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: We describe this implementation here, beginning with a summary of the vnode interface and then examining important differences in our stackable interface. 4.1 Existing File System Interfaces Sun's vnode interface is a good example of several "file system switches" developed for the Unix operating system <ref> [7, 11] </ref>. All have the same goal, to support multiple file system types in the same operating system. The vnode interface has been quite successful in this respect, providing dozens of different filing services in several versions of Unix. <p> Each sub-tree is allowed a completely separate implementation. Data encapsulation requires that these abstract data types for files and subtrees be manipulated only by a restricted set of operations. The operations supported by vnodes, the abstract data type for "files", vary according to implementation (see <ref> [7] </ref> and [6] for semantics of typical operations). To allow this generic treatment of vnodes, binding of desired function to correct implementation is delayed until kernel initialization. <p> But with stacking it is not uncommon to employ multiple remote-access layers. It is less clear how to express this characteristic in traditional object-oriented terms. 18 6.3 Modular File Systems Sun's vnode interface <ref> [7] </ref> served as a foundation for our stackable file systems work. Section 2 compares stackable filing and the standard vnode interface. We build upon its abstractions and approach to modularity to provide stackable filing. The standard vnode interface has been used to provide basic file system stacking.
Reference: [8] <author> John K. Ousterhout. </author> <booktitle> Why aren't operating systems get-ing faster as fast as hardware? In USENIX Conference Proceedings, </booktitle> <pages> pages 247-256. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: The first step compares a kernel supporting only the UCLA interface with a standard kernel. To do so, we consider two benchmarks: the modified Andrew benchmark <ref> [8, 4] </ref> and the recursive copy and removal of large subdirectory trees. In addition, we examine the effect of adding multiple layers in the new interface. The Andrew benchmark has several phases, each of which examines different file system activities.
Reference: [9] <author> Rob Pike and Brian Kernighan. </author> <title> Program design in the UNIX environment. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1595-1605, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: Our experience shows that layers are most easily reusable and composable when each encompasses a single abstraction. This experience parallels those encountered in designing composable network protocols in the x-kernel [5] and tool development with the Unix shells <ref> [9] </ref>. As an example of this problem in the context of file system layering, consider the stack presented in Figure 1. A compression layer is stacked over a standard Unix file system (UFS); the UFS handles file services while the compression layer periodically compresses rarely used files. <p> We will consider each of these in turn. 6.1 Other Stackable Systems The key characteristics of a stackable file system are its symmetric interface and a flexible method of joining these layers. Unix shell programming provides an early example of combining independently developed modules with a syntactically identical interface <ref> [9] </ref>. Ritchie applied these principles to one kernel subsystem with the Streams device I/O system [10]. Ritchie's system constructs terminal and network protocols by composing stackable modules which may be added and removed during operation.
Reference: [10] <author> Dennis M. Ritchie. </author> <title> A stream input-output system. </title> <journal> AT&T Bell Laboratories Technical Journal, </journal> <volume> 63(8) </volume> <pages> 1897-1910, </pages> <month> October </month> <year> 1984. </year>
Reference-contexts: Unix shell programming provides an early example of combining independently developed modules with a syntactically identical interface [9]. Ritchie applied these principles to one kernel subsystem with the Streams device I/O system <ref> [10] </ref>. Ritchie's system constructs terminal and network protocols by composing stackable modules which may be added and removed during operation. Ritchie's conclusion is that Streams significantly reduce complexity and improve maintainability of this portion of the kernel. Since their development Streams have been widely adopted.
Reference: [11] <author> R. Rodriguez, M. Koehler, and R. Hyde. </author> <title> The generic file system. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 260-269. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1986. </year>
Reference-contexts: We describe this implementation here, beginning with a summary of the vnode interface and then examining important differences in our stackable interface. 4.1 Existing File System Interfaces Sun's vnode interface is a good example of several "file system switches" developed for the Unix operating system <ref> [7, 11] </ref>. All have the same goal, to support multiple file system types in the same operating system. The vnode interface has been quite successful in this respect, providing dozens of different filing services in several versions of Unix.
Reference: [12] <author> David S. H. Rosenthal. </author> <title> Evolving the vnode interface. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 107-118. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: These implementations highlight the primary differences between the standard vnode interface and our stackable environment; with support for extensibility and explicit support for stacking, the UCLA interface is significantly easier to employ (see Section 5.2.1). 6.4 Rosenthal's Stackable Interface Rosenthal <ref> [12] </ref> has also recently explored stackable filing. Although conceptually similar to our work, the approaches differ with regard to stack configuration, stack view consistency, and extensibility. Stack configuration in Rosenthal's model is accomplished by two new operations, push and pop.
Reference: [13] <author> Russel Sandberg, David Goldberg, Steve Kleiman, Dan Walsh, and Bob Lyon. </author> <title> Design and implementation of the Sun Network File System. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 119-130. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1985. </year>
Reference-contexts: Limited file system stacking is possible with the standard vnode interface using the mount mechanism. Sun Microsystems' NFS <ref> [13] </ref>, loopback, and translucent [3] file systems take this approach.
Reference: [14] <author> David C. Steere, James J. Kistler, and M. Satyanara-yanan. </author> <title> Efficient user-level file cache management on the Sun vnode interface. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 325-332. </pages> <publisher> USENIX, </publisher> <month> June </month> <year> 1990. </year>
Reference-contexts: Finally, NFS-like RPC interfaces to user-level services burden the concept of modularity with particular choices of process execution and protection. A naive approach can easily interpose repeated data copies between the hardware and the user. Although performance can be improved by in-kernel caching <ref> [14] </ref>, portability is reduced and the result is not fully satisfactory. <p> Another transport service (the "u-to-k layer") allows user-level calls on vnodes that exist inside the kernel. With this framework layers may be developed and executed as user code. Although inter-address space RPC has real cost, caching may provide reasonable performance for an out-of-kernel file system <ref> [14] </ref> in some cases, particularly if other characteristics of the filing service have inherently high latency (for example, hierarchical storage management). Nevertheless, many filing services will find the cost of frequent RPCs overly expensive. Stackable layering offers valuable flexibility in this case.
Reference: [15] <author> Neil Webber. </author> <title> Operating system support for portable filesystem extensions. </title> <booktitle> In USENIX Conference Proceedings, </booktitle> <pages> pages 219-228. </pages> <publisher> USENIX, </publisher> <month> January </month> <year> 1993. </year> <month> 20 </month>
Reference-contexts: A remote access layer is placed between them when necessary. 3.5 Compatibility with Layers The flexibility stacking provides promotes rapid interface and layer evolution. Unfortunately, rapid change often rapidly results in incompatibility. Interface change and incompatibility today often prevent the use of existing filing abstractions <ref> [15] </ref>. A goal of our design is to provide approaches to cope with interface change in a binary-only environment. File system interface evolution takes a number of forms. Third parties wish to extend interfaces to provide new services. <p> Information associated with the mount command identifies the existing stack layer and where the new layer should be attached into the filing name space. 4.2 Extensibility in the UCLA Interface Accommodation of interface evolution is a critical problem with existing interfaces. Incompatible change and the lock-step release problem <ref> [15] </ref> are serious concerns of developers today. The ability to add to the set of filing services without disrupting existing practices is a requirement of diverse third party filing development and would greatly ease vendor evolution of existing systems.
References-found: 15

