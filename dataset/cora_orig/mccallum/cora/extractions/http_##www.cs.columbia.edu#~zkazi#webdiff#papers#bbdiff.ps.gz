URL: http://www.cs.columbia.edu/~zkazi/webdiff/papers/bbdiff.ps.gz
Refering-URL: http://www.cs.columbia.edu/~zkazi/webdiff/biblio.html
Root-URL: http://www.cs.columbia.edu
Email: fchaw,hectorg@cs.stanford.edu  
Title: Meaningful Change Detection in Structured Data  
Author: Sudarshan S. Chawathe Hector Garcia-Molina 
Address: 94305  
Affiliation: Computer Science Department, Stanford University, Stanford, California  
Abstract: Detecting changes by comparing data snapshots is an important requirement for difference queries, active databases, and version and configuration management. In this paper we focus on detecting meaningful changes in hierarchically structured data, such as nested-object data. This problem is much more challenging than the corresponding one for relational or flat-file data. In order to describe changes better, we base our work not just on the traditional "atomic" insert, delete, update operations, but also on operations that move an entire sub-tree of nodes, and that copy an entire sub-tree. These operations allows us to describe changes in a semantically more meaningful way. Since this change detection problem is N P-hard, in this paper we present a heuristic change detection algorithm that yields close to "minimal" descriptions of the changes, and that has fewer restrictions than previous algorithms. Our algorithm is based on transforming the change detection problem to a problem of computing a minimum-cost edge cover of a bipartite graph. We study the quality of the solution produced by our algorithm, as well as the running time, both analytically and experimentally. 
Abstract-found: 1
Intro-found: 1
Reference: [CGM97] <author> S. Chawathe and H. Garcia-Molina. </author> <title> Meaningful change detection in structured data. </title> <note> Available at url http://www-db.stanford.edu, 1997. Extended version. </note>
Reference-contexts: Due to space constraints, we describe the remaining edit operations only informally below; the formal definitions are in <ref> [CGM97] </ref>. * Deletion: This operation is the inverse of the insertion operation. Intuitively, del (n) causes n to disappear from the tree; the children of n are now the children of the (old) parent of n. <p> Due to space limitations, we illustrate the definition of the edge cover induced by an edit script informally using an example; the formal definition is in <ref> [CGM97] </ref>. Example 4.1 Consider the edit script from Example 2.1, and the initial tree T 1 from Figure 1. <p> Therefore, a structured edit script cannot copy a subtree containing 100 nodes if 99 of them are needed, because it would be unable to delete the unwanted copy of the 100th node. An analogous situation exists for ins and glu operations. Our algorithms <ref> [CGM97] </ref> actually do permit such deletions (called ghost deletions) after copies, and insertions (called ghost insertions) before glues. For similar reasons, we also permit certain move operations to occur before the cpy phase. <p> Due to space constraints, we do not present the full details of our algorithm CtoS (cover-to-script) in this paper, and present instead a brief explanation of the basic ideas behind the algorithm. The detailed algorithm is presented in <ref> [CGM97] </ref>. The algorithm proceeds in phases that roughly reflect the phases of a structured edit script described above. We refer to edges belonging to the given edge cover K as K-edges. We say two nodes are matched to each other if there is a K-edge connecting them. <p> The glue and delete phases of the algorithm are analogous to the copy and insert phases, respectively. The details are in <ref> [CGM97] </ref>. 5 Finding the Edge Cover In this section we describe how mh-diff finds a minimal edge cover of the induced graph. The resulting cover will serve as input to algorithm CtoS (Section 4). <p> The following lemma, proved in <ref> [CGM97] </ref>, states that the above scheme of distributing the cost of an edge cover over its component edges is a sound one; that is, adding up the cost edge-wise yields the overall cost of the edge cover (i.e., the cost of the corresponding edit script). <p> Furthermore, the following lemma, proved in <ref> [CGM97] </ref>, states that the above definitions of c ub (e) and c lb (e), are upper and lower bounds, respectively, on the fair cost contribution c K (e) of edge e to any minimal edge cover K that contains e. <p> Note that the above pruning rules are simpler to apply if we let e 2 and e 3 be the minimum-cost edge incident on m and n, respectively. The following lemma, proved in <ref> [CGM97] </ref>, tells us that the pruning rules are conservative: Lemma 5.3 Let E p be the set of edges pruned by repeated application of Pruning Rules 1 and 2. Let K 1 be any minimal edge cover of the graph B.
Reference: [CGMH + 94] <author> S. Chawathe, H. Garcia-Molina, J. Hammer, K. Ireland, Y. Papakonstantinou, J. Ullman, and J. Widom. </author> <title> The Tsimmis project: Integration of heterogeneous information sources. </title> <booktitle> In Proceedings of 100th Anniversary Meeting of the Information Processing Society of Japan, </booktitle> <pages> pages 7-18, </pages> <address> Tokyo, Japan, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: Due to space constraints, we do not describe the details of this search phase in this paper. We have used our implementation to compute the differences between query results as part of the Tsimmis and C 3 projects at Stanford <ref> [CGMH + 94, WU95] </ref>. These projects use the oem data model, which is a simple labeled-object model to represent tree-structured query results.
Reference: [CRGMW96] <author> S. Chawathe, A. Rajaraman, H. Garcia-Molina, and J. Widom. </author> <title> Change detection in hierarchically structured information. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 493-504, </pages> <address> Montreal, Quebec, </address> <month> June </month> <year> 1996. </year>
Reference-contexts: In this transformation, the costs of the edit operations are translated into costs on the edges of the cover. In an earlier paper <ref> [CRGMW96] </ref> we studied a much simpler version of the change detection problem. <p> Here, on the other hand, here we drop these restrictions, and introduce copy operations. This leads to an algorithm that is very different from the one in <ref> [CRGMW96] </ref>, and that yields a heuristic solution in worst-case O (n 3 ) time, where n is the number of nodes, but most often in roughly O (n 2 ) time. <p> Assuming the cost of label update is always lower than the cost of the corresponding insertion and deletion will result in an edit script that simply updates all the labels in the trees. While this is technically sound, it is not the semantically desirable result for this example. In <ref> [CRGMW96] </ref> we defined a variant of the change detection problem for ordered trees, using subtree moves as an edit operation in addition to insertions, deletions, and updates, and presented an efficient algorithm for solving it. That algorithm uses domain characteristics to find a solution efficiently. <p> That algorithm uses domain characteristics to find a solution efficiently. A major drawback of the algorithm in <ref> [CRGMW96] </ref> is that it assumes that the number of duplicates (or near duplicates) in the labels found in the input trees is very small. Another drawback of of the algorithm in [CRGMW96] is that it assumes each node of the input trees has a special tag that describes its semantics. (For <p> That algorithm uses domain characteristics to find a solution efficiently. A major drawback of the algorithm in <ref> [CRGMW96] </ref> is that it assumes that the number of duplicates (or near duplicates) in the labels found in the input trees is very small. Another drawback of of the algorithm in [CRGMW96] is that it assumes each node of the input trees has a special tag that describes its semantics. (For example, an ordered tree representing a document may have tags "paragraph," "section," etc.) Furthermore, that algorithm assumes the existence of a total order &lt; t over these tags such that a <p> Secondly, we consider a rich set of edit operations, including copy and move operations, that make the edit script computed more meaningful and intuitively usable. Furthermore, we do not assume that the nodes of the input trees are "tagged" in a manner required by the algorithm in <ref> [CRGMW96] </ref>, nor do we assume the absence of duplicates (or near duplicates) in the labels of the nodes in the input trees.
Reference: [HHS + ] <author> M. Haertel, D. Hayes, R. Stallman, L. Tower, P. Eg-gert., and W. Davison. </author> <title> The gnu diff program. Texinfo system documentation. </title> <note> Available by anonymous ftp from prep.ai.mit.edu. </note>
Reference-contexts: The idea of a longest common subsequence replaces the idea of a trace in this simpler problem. A variant of the algorithm presented in [Mye86] for computing the longest common subsequence is implemented in the gnudiff <ref> [HHS + ] </ref> program. All these algorithms work with strings, that is, with flat-file, or relational data, and are not suitable for computing changes in structured data.
Reference: [Law76] <author> E. Lawler. </author> <title> Combinatorial Optimization: Networks and Matroids. </title> <publisher> Holt, Rinehart and Winston, </publisher> <year> 1976. </year>
Reference-contexts: Once we have a cost defined for each edge in the pruned induced graph, we can find a minimum-cost edge cover using standard techniques based on reducing the edge cover problem to a weighted matching problem <ref> [PS82, Law76] </ref>. For example, if the edges [7; 61], [7; 63], [9; 61], and [9; 63], have costs 0, 1.3, 0.2, and 2.4, respectively, then we generate an edge cover that includes [7; 61] and [9; 61], and excludes [7; 63] and [9; 61]. <p> Since finding a minimum-cost edge cover for a bipartite graph with fixed edge costs is a problem that has been previously studied in the literature <ref> [PS82, Law76] </ref>, we do not present the details in this paper. 4 Edge Covers and Edit Scripts In this section, we describe algorithm CtoS, which generates an edit script between two trees, given an edge cover of their induced graph.
Reference: [LGM96] <author> W. Labio and H. Garcia-Molina. </author> <title> Efficient snapshot differential algorithms for data warehousing. </title> <booktitle> In Proceedings of the International Conference on Very Large Data Bases, </booktitle> <address> Bombay, India, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: Thus, our algorithm cannot treat the data as "flat" information, e.g., as files with records or relations with tuples. This means that techniques developed for flat change detection <ref> [Mye86, LGM96] </ref> are not applicable here. Algorithm mh-diff has two additional important features: * It does not rely on the existence of node (atomic object) identifiers that can match nodes in one tree to nodes in the other. In many applications such identifiers do not exist.
Reference: [Mye86] <author> E. Myers. </author> <title> An O(N D) difference algorithm and its variations. </title> <journal> Algorithmica, </journal> <volume> 1(2) </volume> <pages> 251-266, </pages> <year> 1986. </year>
Reference-contexts: Thus, our algorithm cannot treat the data as "flat" information, e.g., as files with records or relations with tuples. This means that techniques developed for flat change detection <ref> [Mye86, LGM96] </ref> are not applicable here. Algorithm mh-diff has two additional important features: * It does not rely on the existence of node (atomic object) identifiers that can match nodes in one tree to nodes in the other. In many applications such identifiers do not exist. <p> These papers also introduce the structure of a "trace" or a matching between the characters of the strings being compared as a useful tool for computing an edit script. A simpler change detection problem for strings, using only insertions and deletions as edit operations has been studied extensively <ref> [Mye86, WMG90] </ref>. The idea of a longest common subsequence replaces the idea of a trace in this simpler problem. A variant of the algorithm presented in [Mye86] for computing the longest common subsequence is implemented in the gnudiff [HHS + ] program. <p> A simpler change detection problem for strings, using only insertions and deletions as edit operations has been studied extensively [Mye86, WMG90]. The idea of a longest common subsequence replaces the idea of a trace in this simpler problem. A variant of the algorithm presented in <ref> [Mye86] </ref> for computing the longest common subsequence is implemented in the gnudiff [HHS + ] program. All these algorithms work with strings, that is, with flat-file, or relational data, and are not suitable for computing changes in structured data.
Reference: [PS82] <author> C. Papadimitriou and K. Steiglitz. </author> <title> Combinatorial Optimization. </title> <publisher> Prentice-Hall, </publisher> <year> 1982. </year>
Reference-contexts: Once we have a cost defined for each edge in the pruned induced graph, we can find a minimum-cost edge cover using standard techniques based on reducing the edge cover problem to a weighted matching problem <ref> [PS82, Law76] </ref>. For example, if the edges [7; 61], [7; 63], [9; 61], and [9; 63], have costs 0, 1.3, 0.2, and 2.4, respectively, then we generate an edge cover that includes [7; 61] and [9; 61], and excludes [7; 63] and [9; 61]. <p> Since finding a minimum-cost edge cover for a bipartite graph with fixed edge costs is a problem that has been previously studied in the literature <ref> [PS82, Law76] </ref>, we do not present the details in this paper. 4 Edge Covers and Edit Scripts In this section, we describe algorithm CtoS, which generates an edit script between two trees, given an edge cover of their induced graph. <p> e lb (e). (We could have also use the upper bound, or an average of both bounds, since this is only an estimate.) Then, given these constant estimated costs, we compute a minimum-cost edge cover by reducing the edge cover problem to a bipartite weighted matching problem, as suggested in <ref> [PS82] </ref>. Since the weighted matching problem can be solved using standard techniques, we do not present the details in this paper, noting only that given a bipartite graph with n nodes and e edges, the weighted matching problem can be solved in time O (ne). <p> The next three modules together compute a minimum-cost edge cover of the pruned induced graph using the reduction of the edge cover problem to a weighted matching problem <ref> [PS82] </ref>. That is, the pruned induced graph is first translated (by Module 3) into an instance of a weighted matching problem. This weighted matching problem is solved using a package (Module 4) [Rot] based on standard techniques [PS82]. <p> using the reduction of the edge cover problem to a weighted matching problem <ref> [PS82] </ref>. That is, the pruned induced graph is first translated (by Module 3) into an instance of a weighted matching problem. This weighted matching problem is solved using a package (Module 4) [Rot] based on standard techniques [PS82]. The output of the weighted matching solver is a minimum-cost matching, which is translated by Module 5 into K 0 , a minimum-cost edge cover of the pruned induced graph.
Reference: [Rot] <author> E. Rothberg. </author> <title> The wmatch program for finding a maximum-weight matching for undirected graphs. Live OR collection. </title> <note> Available at url http://www.orsoc.org.uk. </note>
Reference-contexts: That is, the pruned induced graph is first translated (by Module 3) into an instance of a weighted matching problem. This weighted matching problem is solved using a package (Module 4) <ref> [Rot] </ref> based on standard techniques [PS82]. The output of the weighted matching solver is a minimum-cost matching, which is translated by Module 5 into K 0 , a minimum-cost edge cover of the pruned induced graph.
Reference: [SWZS94] <author> D. Shasha, J. Wang, K. Zhang, and F. Shih. </author> <title> Exact and approximate algorithms for unordered tree matching. </title> <journal> IEEE Transactions on Systems, Man, and Cybernetics, </journal> <volume> 24(4) </volume> <pages> 668-678, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: A proof of the N P-hardness of a similar change detection problem (using insertion, deletion, and label-update) for unordered trees is presented in [ZWS95], which also presents an algorithm for a restricted version of the change detection problem. In <ref> [SWZS94] </ref>, the authors present an enumerative (exponential time) algorithm for the change detection problem for unordered trees, as well as heuristic algorithms based on search techniques such as simulated annealing. <p> In [SWZS94], the authors present an enumerative (exponential time) algorithm for the change detection problem for unordered trees, as well as heuristic algorithms based on search techniques such as simulated annealing. An important assumption made by the algorithms in <ref> [ZS89, SZ90, ZWS95, SWZS94] </ref> is that the cost of updating any label to any other label is always less than the cost of deleting a node with the old label and inserting a node with the new label.
Reference: [SZ90] <author> D. Shasha and K. Zhang. </author> <title> Fast algorithms for the unit cost editing distance between trees. </title> <journal> Journal of Algorithms, </journal> <volume> 11 </volume> <pages> 581-621, </pages> <year> 1990. </year>
Reference-contexts: A variant of the algorithm presented in [Mye86] for computing the longest common subsequence is implemented in the gnudiff [HHS + ] program. All these algorithms work with strings, that is, with flat-file, or relational data, and are not suitable for computing changes in structured data. In <ref> [ZS89, SZ90] </ref>, the authors define a change detection problem for ordered trees, using insertion, deletion, and label-update as the edit operations, observing its added difficulty compared to the equivalent problem for strings; they also present an efficient dynamic-programming based algorithm to solve that problem. <p> In [SWZS94], the authors present an enumerative (exponential time) algorithm for the change detection problem for unordered trees, as well as heuristic algorithms based on search techniques such as simulated annealing. An important assumption made by the algorithms in <ref> [ZS89, SZ90, ZWS95, SWZS94] </ref> is that the cost of updating any label to any other label is always less than the cost of deleting a node with the old label and inserting a node with the new label.
Reference: [Wag75] <author> R. Wagner. </author> <title> On the complexity of the extended string-to-string correction problem. </title> <booktitle> In Seventh ACM Symposium on the Theory of Computation, </booktitle> <year> 1975. </year>
Reference-contexts: For example, [WF74] defines a string-to-string correction problem as the problem of finding the best sequence of insert, delete, and update operations that transform one string to another. The problem is developed further in <ref> [Wag75] </ref>, which adds the "swap" operation to the list of edit operations. These papers also introduce the structure of a "trace" or a matching between the characters of the strings being compared as a useful tool for computing an edit script.
Reference: [WF74] <author> R. Wagner and M. Fischer. </author> <title> The string-to-string correction problem. </title> <journal> Journal of the Association of Computing Machinery, </journal> <volume> 21(1) </volume> <pages> 168-173, </pages> <month> January </month> <year> 1974. </year>
Reference-contexts: In the two cases where mh-diff missed, the resulting script cost about 15% more that the minimum cost possible. 7 Related Work The general problem of detecting changes from snapshots of data has been studied before from different angles. For example, <ref> [WF74] </ref> defines a string-to-string correction problem as the problem of finding the best sequence of insert, delete, and update operations that transform one string to another. The problem is developed further in [Wag75], which adds the "swap" operation to the list of edit operations.
Reference: [WMG90] <author> S. Wu, U. Manber, and G.Myers. </author> <title> An O(N P ) sequence comparison algorithm. </title> <journal> Information Processing Letters, </journal> <volume> 35 </volume> <pages> 317-323, </pages> <month> September </month> <year> 1990. </year>
Reference-contexts: These papers also introduce the structure of a "trace" or a matching between the characters of the strings being compared as a useful tool for computing an edit script. A simpler change detection problem for strings, using only insertions and deletions as edit operations has been studied extensively <ref> [Mye86, WMG90] </ref>. The idea of a longest common subsequence replaces the idea of a trace in this simpler problem. A variant of the algorithm presented in [Mye86] for computing the longest common subsequence is implemented in the gnudiff [HHS + ] program.
Reference: [WU95] <author> J. Widom and J. Ullman. </author> <title> The C 3 project: Changes, consistency, and configurations in heterogeneous distributed information systems. </title> <note> Unpublished manuscript; available at url http://www-db.stanford.edu, 1995. </note>
Reference-contexts: Due to space constraints, we do not describe the details of this search phase in this paper. We have used our implementation to compute the differences between query results as part of the Tsimmis and C 3 projects at Stanford <ref> [CGMH + 94, WU95] </ref>. These projects use the oem data model, which is a simple labeled-object model to represent tree-structured query results.
Reference: [ZS89] <author> K. Zhang and D. Shasha. </author> <title> Simple fast algorithms for the editing distance between trees and related problems. </title> <journal> SIAM Journal of Computing, </journal> <volume> 18(6) </volume> <pages> 1245-1262, </pages> <year> 1989. </year>
Reference-contexts: A variant of the algorithm presented in [Mye86] for computing the longest common subsequence is implemented in the gnudiff [HHS + ] program. All these algorithms work with strings, that is, with flat-file, or relational data, and are not suitable for computing changes in structured data. In <ref> [ZS89, SZ90] </ref>, the authors define a change detection problem for ordered trees, using insertion, deletion, and label-update as the edit operations, observing its added difficulty compared to the equivalent problem for strings; they also present an efficient dynamic-programming based algorithm to solve that problem. <p> In [SWZS94], the authors present an enumerative (exponential time) algorithm for the change detection problem for unordered trees, as well as heuristic algorithms based on search techniques such as simulated annealing. An important assumption made by the algorithms in <ref> [ZS89, SZ90, ZWS95, SWZS94] </ref> is that the cost of updating any label to any other label is always less than the cost of deleting a node with the old label and inserting a node with the new label.
Reference: [ZWS95] <author> K. Zhang, J. Wang, and D. Shasha. </author> <title> On the editing distance between undirected acyclic graphs. </title> <booktitle> International Journal of Foundations of Computer Science, </booktitle> <year> 1995. </year>
Reference-contexts: A proof of the N P-hardness of a similar change detection problem (using insertion, deletion, and label-update) for unordered trees is presented in <ref> [ZWS95] </ref>, which also presents an algorithm for a restricted version of the change detection problem. In [SWZS94], the authors present an enumerative (exponential time) algorithm for the change detection problem for unordered trees, as well as heuristic algorithms based on search techniques such as simulated annealing. <p> In [SWZS94], the authors present an enumerative (exponential time) algorithm for the change detection problem for unordered trees, as well as heuristic algorithms based on search techniques such as simulated annealing. An important assumption made by the algorithms in <ref> [ZS89, SZ90, ZWS95, SWZS94] </ref> is that the cost of updating any label to any other label is always less than the cost of deleting a node with the old label and inserting a node with the new label.
References-found: 17

