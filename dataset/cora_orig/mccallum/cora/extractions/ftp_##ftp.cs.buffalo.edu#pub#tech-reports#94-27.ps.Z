URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/94-27.ps.Z
Refering-URL: ftp://ftp.cs.buffalo.edu/pub/tech-reports/README.html
Root-URL: 
Email: E-Mail: fbharat,govin-kg@cs.buffalo.edu  E-Mail: mantha@wrc.xerox.com  
Title: Preference Logic Grammars  
Author: Kannan Govindarajan Bharat Jayaraman Surya Mantha 
Address: Buffalo, NY 14260  Building 128  Webster, NY 14580  
Affiliation: Department of Computer Science State University of New York at Buffalo  System Sciences Laboratory  Xerox, Webster Research Center  
Abstract: Preference Logic Grammars (PLGs) are introduced in this paper as a declarative means of resolving ambiguity in Logic Grammars. An application of PLGs of special interest is optimal parsing, which is an extension of parsing wherein costs are associated with the different (ambiguous) parses of a string and the preferred parse is the one with least cost. Many problems can be viewed as optimal parsing problems, e.g., code generation, document layout, etc. We show that PLGs are an extension of Definite Clause Translation Grammars (DCTGs). Just as DCTGs can be directly translated into Constraint Logic Programs (CLPs), PLGs can be translated into Preference Logic Programs (PLPs). The computational model for preference logic programs keeps track of alternative proof paths (parses) and prunes paths that are not optimal. We also consider the problem of incremental optimal parsing, motivated by the document layout application: We describe how to augment the computational model to support restricted incremental querying, which captures changes to the input that an editor for documents might make. Our proposed incremental strategy reuses portions of the computation of the previous optimal parse to construct the new optimal parse. 
Abstract-found: 1
Intro-found: 1
Reference: [Abr84] <author> H. Abramson. </author> <title> Definite Clause Translation Grammars. </title> <booktitle> In Proc. International Symposium on Logic Programming, </booktitle> <pages> pages 233-241, </pages> <address> Atlantic City, 1984. </address> <publisher> IEEE, Computer Society Press. </publisher>
Reference-contexts: We show in this paper how the criteria for laying out paragraphs|which a formatter such as T E Xor L a T E Xwould use [KP81]|can be specified declaratively using a logic grammar. We develop our approach starting from Definite Clause Translation Grammars (DCTGs) <ref> [Abr84] </ref>. DCTGs are a particular kind of Logic Grammar, and can be viewed as the logical counterpart of attribute grammars [Knu68], since they allow a clear separation between the syntactic and semantic components of the specification. <p> discusses the operational semantics of Preference Logic Programs for computing the optimal parse; section 5 discusses how to modify the operational semantics to support incremental optimal parsing; and, finally, section 6 presents conclusions and the current status of the work. 2 Definite Clause Translation Grammars DCTGs were introduced by Abramson <ref> [Abr84] </ref>, and can be viewed as a logical counterpart of attribute grammars [Knu68]. In attribute grammars, syntax is specified by context-free rules, and semantics are specified by attributes attached to nonterminal nodes in the derivation trees and by function definitions that define the attributes.
Reference: [AD89] <author> H. Abramson and V. Dahl. </author> <title> Logic Grammars. Symbolic Computation. </title> <publisher> Springer-Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Logic Grammars combine these two formalisms, and can be used for specifying syntactic and semantic constraints in a variety of parsing applications, from programming languages to natural languages <ref> [AD89] </ref>. Several forms of Logic Grammars have been researched over the last two decades. <p> We also describe how under certain reasonable monotonicity conditions, we can make both the optimal parsing algorithm and the incremental version more efficient. The rest of this paper is organized as follows: Section 2 discusses Definite Clause Translation Grammars <ref> [AD89] </ref> and their use in representing document structures; section 3 introduces Preference Logic Grammars, shows their use for ambiguity resolution and optimal parsing, and briefly discusses the translation of PLGs into Preference Logic Programs; section 4 discusses the operational semantics of Preference Logic Programs for computing the optimal parse; section 5 <p> In order to specify the computation of some semantic value X of a property prop of the tree N, we write: N^^prop (X) The following is a simple DCTG from <ref> [AD89] </ref> that specifies the grammar and semantics of bitstrings. bit ::= ``0'' bitval (0,_). bit ::= ``1'' bitval (V,Scale) ::- V = 2^Scale. 2 bitstring ::= [] &lt;:&gt; length (0), value (0,_). bitstring ::= bit^^B, bitstring^^B1 &lt;:&gt; (length (Length) ::- B1^^length (Length1), Length = Length1 +1), (value (Value,ScaleB) ::- B^^bitval (VB,ScaleB),
Reference: [AGT89] <author> A. V. Aho, M. Ganapathi, and S. Tjiang. </author> <title> Code Generation using Tree Matching and Dynamic Programming. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(4) </volume> <pages> 491-516, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: This problem is an extension of the standard parsing problem in that costs are associated with the different (ambiguous) parses of a string, and the preferred parse of the string is the one with least cost. Many applications such as optimal layout of documents [BMW92], code generation <ref> [AGT89] </ref>, etc., can be viewed as optimal parsing problems. We show in this paper how the criteria for laying out paragraphs|which a formatter such as T E Xor L a T E Xwould use [KP81]|can be specified declaratively using a logic grammar.
Reference: [BMW92] <author> A. Brown, S. Mantha, and T. Wakayama. </author> <title> The Declarative Semantics of Document Processing. </title> <booktitle> In Proc. of the First International Workshop on Principles of Document Processing, </booktitle> <year> 1992. </year>
Reference-contexts: This problem is an extension of the standard parsing problem in that costs are associated with the different (ambiguous) parses of a string, and the preferred parse of the string is the one with least cost. Many applications such as optimal layout of documents <ref> [BMW92] </ref>, code generation [AGT89], etc., can be viewed as optimal parsing problems. We show in this paper how the criteria for laying out paragraphs|which a formatter such as T E Xor L a T E Xwould use [KP81]|can be specified declaratively using a logic grammar. <p> CLP programs rather than definite clauses is that we want to interpret function symbols such as + and predicate symbols such as = over appropriate domains. 2.2 Specifying Document Structures using DCTGs We now demonstrate the usefulness of DCTGs for specifying document structures starting from the attribute grammars specifications of <ref> [BMW92] </ref>. Logically, a paragraph is a sequence of lines where each line is a sequence of words. <p> Given a description of a document and a sequence of words representing its content, we are interested in a parse that has a particular property. For instance, we may be interested in the parse of a sequence of words from &lt;para&gt; that has the least badness. <ref> [BMW92] </ref> augmented attribute grammars with minimization directives that specified which attributes had to be minimized in the preferred parse. Similarly, we extend DCTGs with statements that specify the preferred parse. <p> We believe that the use of preferential statements in logic grammars is concise, natural, and declarative. Although this extension was originally motivated by the extension to attribute grammars to specify document layout <ref> [BMW92] </ref>, this paper shows that the ideas are applicable in a broader setting. Thus far we have considered only representative problems from the areas of document representation and programming language syntax.
Reference: [Fag93] <author> F. Fages. </author> <title> On the Semantics of Optimization Predicates in CLP Languages. </title> <booktitle> In Proc. of 13th Annual Conference on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <year> 1993. </year>
Reference-contexts: The derivation scheme is an extension of SLD-resolution where some of the derivation paths get pruned due to the arbiter: the arbiter can thus be thought of as offering control advice to the SLD engine about which paths are better. Unlike the negation based approach of <ref> [GGZ91, Fag93] </ref>, our derivation scheme performs optimization by explicit selection, i.e. it prunes paths that compute sub-optimal solutions.
Reference: [GGZ91] <author> S. Ganguly, S. Greco, and C. Zaniolo. </author> <title> Minimum and Maximum Predicates in Logic Programming. </title> <booktitle> In Proc. Tenth ACM Symp. on Principles of Database Systems, </booktitle> <pages> pages 154-163, </pages> <year> 1991. </year>
Reference-contexts: The derivation scheme is an extension of SLD-resolution where some of the derivation paths get pruned due to the arbiter: the arbiter can thus be thought of as offering control advice to the SLD engine about which paths are better. Unlike the negation based approach of <ref> [GGZ91, Fag93] </ref>, our derivation scheme performs optimization by explicit selection, i.e. it prunes paths that compute sub-optimal solutions.
Reference: [GJM94] <author> K. Govindarajan, B. Jayaraman, and S. Mantha. </author> <title> Preference Logic Programming : Optimization as Inference. </title> <type> Technical Report 94-12, </type> <institution> Dept. of Computer Science, SUNY at Buffalo, </institution> <month> April </month> <year> 1994. </year> <note> Submitted for Publication. 14 </note>
Reference-contexts: We refer to the resulting class of grammars as Preference Logic Grammars (PLGs). Just as DCTGs can be translated into Constraint Logic Programs [JL87, vH89, JM], PLGs can be translated into Preference Logic Programs <ref> [GJM94] </ref>. The operational semantics of Preference Logic Programs constructs the optimal parse by keeping track of alternative parses and pruning parses that are suboptimal. <p> (Adjustment), absolute (Adjustment, AbsAdjust), Badness = AbsAdjust*3), (guard (Guard) ::- adjustment (Adjustment), Adjustment &lt; lineshrinkbound, Adjustment &gt; linestretchbound). 3 Preference Logic Grammars and Preference Logic Programs We now introduce a simple extension of DCTGs called Preference Logic Grammars (PLGs), and show how they can be translated into Preference Logic Programs <ref> [GJM94] </ref>. 6 3.1 Preference Logic Grammars The grammars specifying document structures, such as the one in the previous section, are extremely ambiguous. Given a description of a document and a sequence of words representing its content, we are interested in a parse that has a particular property. <p> We now briefly describe Preference Logic Programs <ref> [GJM94] </ref> and then show that PLGs can be translated into Preference Logic Programs. 3.2 Preference Logic Programming Preference Logic Programs have two parts, a first order theory T and an arbiter A. The first-order theory has three kinds of predicates: 1. <p> The third clause and the ! clause make up the optimization program T O . The only Opt-predicate is sh dist and the only O-predicate is sh path. The C-predicates are path, edge and =. <ref> [GJM94] </ref> describes the model theory of preference logic programs in detail and provides many other examples of preference logic programs. 3.3 From PLGs to Preference Logic Programs The translation of PLGs to PLPs builds on the translation from DCTGs to CLPs. <p> A PTSLD-derivation T 0 ; : : : ; T s is complete if it ends in a complete tree. T s is said to be the result of the complete PTSLD-derivation. <ref> [GJM94] </ref> also introduces the notion of a preferential consequence and the PTSLD-derivation scheme is sound but incomplete for computing answers with respect to this notion of consequence. We now describe the extension of the derivation scheme to the case when the core program is a constraint logic program. <p> We still need to test our methodology on more problems, especially 13 from the domain of natural language processing, where we believe the use of preferential statements for selection (as opposed to optimization) has a potential role. In a related paper <ref> [GJM94] </ref>, we have further elaborated on the paradigm of preference logic programming|its uses, declarative and operational semantics. Our proposed operational semantics has the potential to be efficiently implemented, although we have not yet done so at the time of writing this paper.
Reference: [GM80] <author> Carlo Ghezzi and Dino Mandrioli. </author> <title> Augmenting Parsers to Support Incrementality. </title> <journal> Journal of the ACM, </journal> <volume> 27(3) </volume> <pages> 564-579, </pages> <month> July </month> <year> 1980. </year>
Reference-contexts: Our approach was also motivated by previous works on incremental attribute evaluation in language-based editors [Rep84], augmented parsers for supporting incrementality <ref> [GM80] </ref>, and expanded querying power in constraint logic programming languages [MS89, vH90]. We now briefly describe the incremental algorithm to perform optimal parsing. <p> Once a partial parse in a PTSLD tree on input In1 is in the region z, i.e., has scanned past the change in the input, we can check for a matching condition to determine whether we can reuse portions of parses from the previous PTSLD derivation using the <ref> [GM80] </ref> matching condition. The operational semantics will have to be modified to store pointers from the each position in the input list to an appropriate position in the list of trees making up the derivation tree. <p> If a change is made starting at some position in the input list, we can recover the tree in the old PTSLD derivation from which we can start the current derivation using these pointers. These pointers serve the same purpose that the pointers in the threaded parse tree that <ref> [GM80] </ref> serve. 6 Conclusions and Status We have presented an extension of DCTGs called Preference Logic Grammars, and shown their use for ambiguity resolution in logic grammars and for specifying optimal parsing problems. We believe that the use of preferential statements in logic grammars is concise, natural, and declarative.
Reference: [JL87] <author> J. Jaffar and J. L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. 14th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 111-119, </pages> <address> Munich, </address> <month> January </month> <year> 1987. </year>
Reference-contexts: We show in this paper that a simple extension of DCTGs provides a natural means of specifying ambiguity resolution and optimal parsing problems. We refer to the resulting class of grammars as Preference Logic Grammars (PLGs). Just as DCTGs can be translated into Constraint Logic Programs <ref> [JL87, vH89, JM] </ref>, PLGs can be translated into Preference Logic Programs [GJM94]. The operational semantics of Preference Logic Programs constructs the optimal parse by keeping track of alternative parses and pruning parses that are suboptimal. <p> In attribute grammars, syntax is specified by context-free rules, and semantics are specified by attributes attached to nonterminal nodes in the derivation trees and by function definitions that define the attributes. Attribute grammars and DCTGs can be readily translated into Constraint Logic Programs over some appropriate domain <ref> [JL87, vH89, JM] </ref>. It may be noted that we need Constraint Logic Programs rather than Definite Clause Programs because we are interested in interpreting the functions defining the attributes over an appropriate domain.
Reference: [JM] <author> J. Jaffar and M. J. Maher. </author> <title> Constraint Logic Programming : A Survey. </title> <note> To appear in the Journal of Logic Programming. </note>
Reference-contexts: We show in this paper that a simple extension of DCTGs provides a natural means of specifying ambiguity resolution and optimal parsing problems. We refer to the resulting class of grammars as Preference Logic Grammars (PLGs). Just as DCTGs can be translated into Constraint Logic Programs <ref> [JL87, vH89, JM] </ref>, PLGs can be translated into Preference Logic Programs [GJM94]. The operational semantics of Preference Logic Programs constructs the optimal parse by keeping track of alternative parses and pruning parses that are suboptimal. <p> In attribute grammars, syntax is specified by context-free rules, and semantics are specified by attributes attached to nonterminal nodes in the derivation trees and by function definitions that define the attributes. Attribute grammars and DCTGs can be readily translated into Constraint Logic Programs over some appropriate domain <ref> [JL87, vH89, JM] </ref>. It may be noted that we need Constraint Logic Programs rather than Definite Clause Programs because we are interested in interpreting the functions defining the attributes over an appropriate domain.
Reference: [Knu68] <author> D. E. Knuth. </author> <title> Semantics of Context-Free Languages. </title> <journal> Mathematical Systems Theory, </journal> <volume> 2(2) </volume> <pages> 127-145, </pages> <year> 1968. </year>
Reference-contexts: We develop our approach starting from Definite Clause Translation Grammars (DCTGs) [Abr84]. DCTGs are a particular kind of Logic Grammar, and can be viewed as the logical counterpart of attribute grammars <ref> [Knu68] </ref>, since they allow a clear separation between the syntactic and semantic components of the specification. We show in this paper that a simple extension of DCTGs provides a natural means of specifying ambiguity resolution and optimal parsing problems. <p> parse; section 5 discusses how to modify the operational semantics to support incremental optimal parsing; and, finally, section 6 presents conclusions and the current status of the work. 2 Definite Clause Translation Grammars DCTGs were introduced by Abramson [Abr84], and can be viewed as a logical counterpart of attribute grammars <ref> [Knu68] </ref>. In attribute grammars, syntax is specified by context-free rules, and semantics are specified by attributes attached to nonterminal nodes in the derivation trees and by function definitions that define the attributes.
Reference: [KP81] <author> D. E. Knuth and M. F. Plass. </author> <title> Breaking Paragraphs into Lines. </title> <journal> Software Practice and Experience, </journal> <volume> 11 </volume> <pages> 1119-1184, </pages> <year> 1981. </year>
Reference-contexts: This view of a paragraph can be captured by the following context free grammar with regular right hand sides as in Backus-Naur Form grammars: &lt;para&gt; ::= &lt;line&gt; + &lt;line&gt; ::= [unit]+ Knuth and Plass <ref> [KP81] </ref> describe how to lay out a sequence of words forming a paragraph by computing the badness of the paragraph which depends on the badness of the lines that make up the paragraph. <p> The badness of a line is determined by the properties of the line such as the total width of the characters that make up the line, the number of white spaces in the line, the stretchability and shrinkability of the white spaces, the desired length of the line, etc. <ref> [KP81] </ref> insists that each line in the paragraph be such that the ratio of the difference between actual length and the desired length and the stretchability or shrinkability (the adjustment ratio) be bounded. <p> Functions SUM i and NUM compute the sum of and number of relevant objects in the parse tree rooted at the appropriate nonterminal. Clearly, the attribute grammar captures the essence of the attributes necessary to layout a paragraph as described in <ref> [KP81] </ref>. The document structure described above can be written in the DCTG formalism in a very natural way. <p> Note further that the nodes n 1 and n 2 in the definition need not be different nodes, i.e. one solution to the set of constraints may block another solution to the set of constraints. The operational semantics presented here mimics the execution of the line-breaking algorithm in <ref> [KP81] </ref> for that example. The list of active modes in any tree in the derivation, corresponds to the active list in the line breaking algorithm in [KP81]. 5 Incremental Computation We outline a simple extension to the operational semantics to handle incremental optimal parsing. <p> The operational semantics presented here mimics the execution of the line-breaking algorithm in <ref> [KP81] </ref> for that example. The list of active modes in any tree in the derivation, corresponds to the active list in the line breaking algorithm in [KP81]. 5 Incremental Computation We outline a simple extension to the operational semantics to handle incremental optimal parsing. Incrementality is a very important component of interactive systems.
Reference: [Mal] <author> J. Maluszynski. </author> <title> Attribute Grammars and Logic Programs : A Comparison of Concepts. </title> <editor> In H. Albas and B. Melichar, editors, </editor> <title> Attribute Grammars, </title> <booktitle> Applications and Systems, number 545 in LNCS, </booktitle> <pages> pages 330-357. </pages> <publisher> Springer-Verlag. </publisher>
Reference-contexts: No distinction is made between inherited and synthesized attributes in the notation. The use of logical variables that unify with parse trees eliminates the need for this distinction. 2.1 From DCTGs to Logic Programs DCTGs can be directly translated into Constraint Logic Programs <ref> [Mal] </ref>: Each clause in the CLP program is derived from a grammar rule and the predicate symbols in the program are derived from nonterminal symbols in the grammar.
Reference: [Man91] <author> S. Mantha. </author> <title> First-Order Preference Theories and their Applications. </title> <type> PhD thesis, </type> <institution> University of Utah, </institution> <month> November </month> <year> 1991. </year>
Reference-contexts: The symbol Pf is the monadic modal operator of preference introduced in <ref> [Man91] </ref>. Such rules are called preference rules and specify that the preferred parse from the nonterminal para is the one whose badness property is the least in the ordering &lt;. We now turn to an example illustrating how to specify the criteria for resolving ambiguity in context free grammars.
Reference: [MS89] <author> M. J. Maher and P. J. Stuckey. </author> <title> Expanding Query Power in Constraint Logic Programming Languages. </title> <editor> In Ewing L. Lusk and Ross A. Overbeek, editors, </editor> <booktitle> Proceedings of the North American Conference on Logic Programming, </booktitle> <pages> pages 20-36, </pages> <address> Cleveland, Ohio, USA, </address> <year> 1989. </year>
Reference-contexts: Our approach was also motivated by previous works on incremental attribute evaluation in language-based editors [Rep84], augmented parsers for supporting incrementality [GM80], and expanded querying power in constraint logic programming languages <ref> [MS89, vH90] </ref>. We now briefly describe the incremental algorithm to perform optimal parsing.
Reference: [Rep84] <author> T. W. Reps. </author> <title> Generating Language-based Environments. </title> <type> PhD thesis, </type> <institution> Cornell University, Department of Computer Science, </institution> <address> Ithaca, NY, 1984. </address> <publisher> ACM Distinguished Dissertation Series, MIT Press. </publisher>
Reference-contexts: The operational semantics of Preference Logic Programs constructs the optimal parse by keeping track of alternative parses and pruning parses that are suboptimal. Motivated by the document layout application and the language-based editors of <ref> [Rep84] </ref>, we address the problem of incremental optimal parsing, whose natural application is a WYSIWYG document editor: The updates that a document editor makes to a document is modelled in the PLP framework by a sequence of queries to the program that is the result of translating the PLG. <p> Our approach was also motivated by previous works on incremental attribute evaluation in language-based editors <ref> [Rep84] </ref>, augmented parsers for supporting incrementality [GM80], and expanded querying power in constraint logic programming languages [MS89, vH90]. We now briefly describe the incremental algorithm to perform optimal parsing.
Reference: [vH89] <author> P. van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: We show in this paper that a simple extension of DCTGs provides a natural means of specifying ambiguity resolution and optimal parsing problems. We refer to the resulting class of grammars as Preference Logic Grammars (PLGs). Just as DCTGs can be translated into Constraint Logic Programs <ref> [JL87, vH89, JM] </ref>, PLGs can be translated into Preference Logic Programs [GJM94]. The operational semantics of Preference Logic Programs constructs the optimal parse by keeping track of alternative parses and pruning parses that are suboptimal. <p> In attribute grammars, syntax is specified by context-free rules, and semantics are specified by attributes attached to nonterminal nodes in the derivation trees and by function definitions that define the attributes. Attribute grammars and DCTGs can be readily translated into Constraint Logic Programs over some appropriate domain <ref> [JL87, vH89, JM] </ref>. It may be noted that we need Constraint Logic Programs rather than Definite Clause Programs because we are interested in interpreting the functions defining the attributes over an appropriate domain.
Reference: [vH90] <author> P. van Hentenryck. </author> <title> Incremental constraint satisfaction in logic programming. </title> <editor> In David H. D. Warren and Peter Szeredi, editors, </editor> <booktitle> Proceedings of the Seventh International Conference on Logic Programming, </booktitle> <pages> pages 189-202, </pages> <address> Jerusalem, 1990. </address> <publisher> The MIT Press. </publisher> <pages> 15 </pages>
Reference-contexts: Our approach was also motivated by previous works on incremental attribute evaluation in language-based editors [Rep84], augmented parsers for supporting incrementality [GM80], and expanded querying power in constraint logic programming languages <ref> [MS89, vH90] </ref>. We now briefly describe the incremental algorithm to perform optimal parsing.
References-found: 18

