URL: http://rakaposhi.eas.asu.edu/refsearch-kr94-proc.ps
Refering-URL: http://rakaposhi.eas.asu.edu/yochan.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: rao@asu.edu  
Title: Refinement Search as a Unifying Framework for analyzing Planning Algorithms  
Author: Subbarao Kambhampati 
Address: Tempe, AZ 85287-5406  
Affiliation: Department of Computer Science and Engineering Arizona State University,  
Date: May 1994  
Note: To appear in Proc. Principles of Knowledge Rep. and Reasoning (KRR),  constraints.  
Abstract:  
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Barrett and D. Weld. </author> <title> Partial Order Planning: Evaluating Possible Efficiency Gains. </title> <type> CSE TR 92-05-01, </type> <institution> University of Washington, </institution> <month> June </month> <year> 1992. </year>
Reference-contexts: The paper is organized as follows: Section 2 provides the preliminaries of refinement search, develops a model for 1 The work of Barrett and Weld <ref> [1] </ref> as well as Minton et. al. [16, 17] are certainly steps in the right direction. However, they do not tell the full story since the comparison there was between a specific partial order and total order planner. <p> It is easy to see that as long as the action o 3 preserves p, S will belong to the candidate set of P. This is because there exists a candidate mapping, M : ft 1 ! S <ref> [1] </ref>; t 2 ! S [3]g according to which S satisfies all the constraints of P (the interval preservation constraint ht 1 ; p; t 2 i is satisfied as long as o 3 preserves p). <p> (O (n 4 ) for TWEAK rep; (O (n 4 ) for TWEAK rep; NP-hard with ADL) NP-hard with ADL) UA [16] MTC-based O (n 4 ) MTC-based O (n 4 ) None Unambiguous ordering Nonlin [26] MTC (Q&A) based Arbitrary O (1) Goal Protection via Q&A Conflict Resolution TOCL <ref> [1] </ref> Protection based O (1) Arbitrary O (1) Contributor protection Total ordering Pedestal [14] Protection based O (1) Arbitrary O (1) Interval Protection Total ordering SNLP [15] Protection based Arbitrary Contributor protection Conflict resolution UCPOP [22] O (1) O (1) MP, MP-I [8] Protection based Arbitrary (Multi) contributor protection Conflict resolution <p> However, they can be used as a basis for selection heuristics (viz., to prefer partial plans which have already satisfied filter conditions). 15 Finally, Refine-Plan can also be extended to cover planning models other than plan-space planning. To cover state-space planners (cf. <ref> [1] </ref>), we need to allow Refine-Plan to use incomplete establishment refinements, and backtrack over goal-selection to make the overall search complete.
Reference: [2] <author> D. Chapman. </author> <title> Planning for conjunctive goals. </title> <journal> Artificial Intelligence, </journal> <volume> 32:333--377, </volume> <year> 1987. </year>
Reference-contexts: The precondition formulas can also have disjunction, but disjunction is not allowed in the effects formula. The subset of this representation where both formulas can be represented as conjunctions of function-less first order literals, and all the variables have infinite domains, is called the TWEAK representation (c.f. <ref> [2, 10] </ref>). 3 From the above definitions, it is clear that any potential solution for a planning problem must be a ground operator sequence. Thus, viewed as a refinement search, the candidate space, K, of a planning problem, is the set of all ground operator sequences. <p> The termination criteria of all-sol correspond closely to the notion of necessary correctness of a partially ordered plan, first introduced by Chapman <ref> [2] </ref>. Existing planning systems implement All-sol in two different ways: Planners such as Chapman's TWEAK [2] use the modal truth criterion to explicitly check that all the safe ground linearizations correspond to solutions (we will call these the MTC-based constructors). <p> The termination criteria of all-sol correspond closely to the notion of necessary correctness of a partially ordered plan, first introduced by Chapman <ref> [2] </ref>. Existing planning systems implement All-sol in two different ways: Planners such as Chapman's TWEAK [2] use the modal truth criterion to explicitly check that all the safe ground linearizations correspond to solutions (we will call these the MTC-based constructors). <p> It selects a precondition hC; si of the plan (where C is a precondition of a step s), and refines (i.e., adds constraints to) the partial plan such that different steps act as contributors of C to s in different refinements. Chapman <ref> [2] </ref> and Pednault [19] provide theories of sound and complete establishment refinement. <p> Consistency Check: (Optional) If the partial plan is inconsis tent (i.e., has no safe ground linearizations), prune it. 5. Return the refined partial plan (if it is not pruned). planning Planner Soln. Constructor Goal Selection Book-keeping Tractability Refinements Tweak <ref> [2] </ref> MTC-based MTC-based None None (O (n 4 ) for TWEAK rep; (O (n 4 ) for TWEAK rep; NP-hard with ADL) NP-hard with ADL) UA [16] MTC-based O (n 4 ) MTC-based O (n 4 ) None Unambiguous ordering Nonlin [26] MTC (Q&A) based Arbitrary O (1) Goal Protection via <p> strategy used to select the particular precondition hC; si to be established, (called goal selection strategy) can be arbitrary, can depend on some ranking based on precondition abstraction [24], and/or demand driven (e.g. select a goal only when it is not already necessarily true according to the modal truth criterion <ref> [2] </ref>). <p> Chapman's TWEAK <ref> [2] </ref> is such a planner. However, such a planner is not guaranteed to respect its previous establishment decisions while making new ones, and thus may have a high degree of redundancy. <p> However, at the same time they increase the cost of refinement C (specifically the C s factor). For example, MTC-based solution constructor has to reason with all safe ground linearization of the plan explicitly, and can thus be intractable for general partial orderings involving ADL actions <ref> [10, 2] </ref>. Protection-based constructor, on the other hand need only check that the agenda is empty, and that there are no unresolved conflicts (which can be done in O (1) time). Book-keeping techniques aim to reduce the redundancy factor d . <p> For example, if our objective is to judge the utility of specific protection (book-keeping) strategies, we could keep everything else constant and vary only the book-keeping step in Refine-Plan. In contrast, when we compare TWEAK <ref> [2] </ref> with SNLP [15], we are not only varying the protection strategies, but also the goal selection, conflict resolution and termination (solution constructor) strategies, making it difficult to form meaningful hypotheses from empirical results. 11 q (m; n) is the probability that a randomly chosen urn will contain at least one
Reference: [3] <author> G. Collins and L. Pryor. </author> <title> Achieving the functionality of filter conditions in partial order planner. </title> <booktitle> In Proc. 10th AAAI, </booktitle> <year> 1992. </year>
Reference: [4] <author> K. Erol, D. Nau and J. Hendler. </author> <title> Toward a general framework for hierarchical task-network planning. </title> <booktitle> In Proc. of AAAI Spring Symp. on Foundations of Automatic Planning. </booktitle> <year> 1993. </year>
Reference-contexts: conditions thus provide a way for the domain writer to disallow certain types of solutions (e.g., building an airport in a city for the express purpose of going from there to another city) even if they satisfy the standard definition of plan solutions 14 In the past, some researchers (e.g. <ref> [4] </ref>) have claimed (mistakenly) that intermediate goals of this type cannot be modeled in classical planning without hierarchical task reduction. (see Definition 5). Filter conditions can be modeled as point truth constraints, and included in the auxiliary solution constraints (without adding them to the agenda) [12]. <p> To cover state-space planners (cf. [1]), we need to allow Refine-Plan to use incomplete establishment refinements, and backtrack over goal-selection to make the overall search complete. The HTN planners (cf. <ref> [27, 4] </ref>) can be modeled by extending the refinement algorithm such that its main refinement operation is task reduction rather than establishment (with establishment refinement being a particular way of reducing tasks); see [12]. 7 Conclusion In this paper, I have shown that refinement search provides a unifying framework for understanding
Reference: [5] <author> M.G. Georgeff. </author> <title> Planning. In Readings in Planning. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1990. </year>
Reference-contexts: Most classical planning techniques have traditionally concentrated on the sub-class of behavioral constraints called the goals of attainment <ref> [5] </ref>, which essentially constrain the agent's attention to behaviors that end in world states satisfying desired properties.
Reference: [6] <author> J. Jaffar and J. L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of POPL-87, </booktitle> <pages> pages 111--119, </pages> <year> 1987. </year>
Reference-contexts: Instead, the candidate sets are typically implicitly represented as generalized constraint sets associated with search nodes (c.f. <ref> [6] </ref>) such that every potential candidate that is consistent with the constraints in that constraint set is taken to belong to the candidate set of the search node.
Reference: [7] <author> S. Kambhampati. </author> <title> Planning as Refinement Search: A unified framework for comparative analysis of Search Space Size 15 Some researchers [3] have suggested that filter conditions cannot be used in partial order planning without loss of completeness. I believe that this confusion is mainly a result of seeing filter conditions as filtering out refinement possibilities, as against solutions. and Performance. </title> <type> Technical Report 93-004, </type> <institution> Arizona State University, </institution> <month> June, </month> <year> 1993. </year> <month> 16 </month>
Reference-contexts: While all the book-keeping strategies described above avoid considering same precondition for establishment more than once, only the contributor protection eliminates the redundancy of overlapping candidate sets, by making estab 9 See <ref> [7] </ref> for a coherent reconstruction of the ideas underlying goal protection strategies. lishment refinement systematic. Specifically, we have: Proposition 5 Establishment refinement with exhaustive causal links is systematic in that partial plans in different branches of the search tree will have non-overlapping candidate sets (thus = 1). <p> This property can be proven from the fact that contributor protections provide a way of uniquely naming steps independent of the symbol table mapping (see <ref> [15, 7] </ref>). <p> Pre-ordering techniques can also make other plan handling steps, such as MTC-based goal selection and MTC-based solution constructor, tractable (c.f. <ref> [16, 7] </ref>). For example, unambiguous plans also allow polynomial check for necessary truth of any condition in the plan. Polynomial necessary truth check can be useful in MTC-based goal selection and termination tests. <p> This jF d j vs. C tradeoff also applies to other types of search-space reduction techniques such as deferment of conflict resolution <ref> [21, 7] </ref>. Since conflict resolution is an optional step in Refine-Plan, the planner can be selective about which conflicts to resolve, without affecting the completeness or the systematicity of Refine-Plan. <p> binding consistency check, can lead to refinement of inconsistent plans, thereby reducing d and increasing jF d j. 5.1.1 Depth First Search Regimes Although the above analysis dealt with breadth-first search regimes, the Refine-Plan algorithm also allows us to analyze the performance of different planning algorithms in depth first regimes <ref> [7] </ref>. Here, the critical factor in estimating the explored search space size is the probability that the planner picks a refinement that contains at least one solution candidate. Even small changes in this probability, which we shall call success probability, can have dramatic effects on performance. <p> It could thus strike a good balance between systematic planners such as SNLP and unsystematic, but polynomial-time refinement 12 Note that this definition of interaction is more general than the one used by UA [17]. It is required because of the contributor protections used by SNLP-UA (see <ref> [7] </ref>). 13 For actions with conditional effects, a necessary conflict can be confronted by planning to make the preservation preconditions true for the interacting step. planners such as UA.
Reference: [8] <author> S. Kambhampati. </author> <title> Multi-Contributor Causal Structures for Planning: A Formalization and Evaluation. </title> <institution> Arizona State University Technical Report, CS TR-92-019, </institution> <month> July </month> <year> 1992. </year> <note> (To appear in Artificial Intelligence. A preliminary version appears in the Proc. of First Intl. Conf. on AI Planning Systems, </note> <year> 1992). </year>
Reference-contexts: (1) Goal Protection via Q&A Conflict Resolution TOCL [1] Protection based O (1) Arbitrary O (1) Contributor protection Total ordering Pedestal [14] Protection based O (1) Arbitrary O (1) Interval Protection Total ordering SNLP [15] Protection based Arbitrary Contributor protection Conflict resolution UCPOP [22] O (1) O (1) MP, MP-I <ref> [8] </ref> Protection based Arbitrary (Multi) contributor protection Conflict resolution SNLP-UA Protection based O (1)/ Arbitrary O (1)/ Contributor protection Unambiguous Ordering (cf. <p> The protection strategies used by classical partial order planners come in two main varieties: interval protection (aka causal link protection, or protection intervals), and contributor protection (aka exhaustive causal link protection <ref> [8] </ref>). They can both be represented in terms of the interval preservation constraints. Suppose the planner just established a condition c at step s with the help of the effects of the step s 0 . <p> Finally, the interval protections and contributor protections can also be generalized to allow for multiple contributors supporting a given condition (see <ref> [8] </ref> for a motivation and formal treatment of this idea).
Reference: [9] <author> S. Kambhampati. </author> <title> On the Utility of Systematicity: Understanding tradeoffs between redundancy and commitment in partial order planning. </title> <booktitle> In Proceedings of IJCAI-93, </booktitle> <year> 1993. </year>
Reference: [10] <author> S. Kambhampati and D.S. Nau. </author> <title> On the Nature and Role of Modal Truth Criteria in Planning. </title> <type> Tech. Report. </type> <institution> ISR-TR-93-30, University of Maryland, </institution> <month> March, </month> <year> 1993. </year>
Reference-contexts: The precondition formulas can also have disjunction, but disjunction is not allowed in the effects formula. The subset of this representation where both formulas can be represented as conjunctions of function-less first order literals, and all the variables have infinite domains, is called the TWEAK representation (c.f. <ref> [2, 10] </ref>). 3 From the above definitions, it is clear that any potential solution for a planning problem must be a ground operator sequence. Thus, viewed as a refinement search, the candidate space, K, of a planning problem, is the set of all ground operator sequences. <p> In Pednault's theory, establishment of a condition c at a step s essentially involves selecting some step s 0 (either 8 And also separates checking truth of a proposition from plan ning to make that proposition true, see <ref> [10] </ref>. Algorithm Find-Plan (I; G) Parameters: sol: Solution constructor function. 1. <p> However, at the same time they increase the cost of refinement C (specifically the C s factor). For example, MTC-based solution constructor has to reason with all safe ground linearization of the plan explicitly, and can thus be intractable for general partial orderings involving ADL actions <ref> [10, 2] </ref>. Protection-based constructor, on the other hand need only check that the agenda is empty, and that there are no unresolved conflicts (which can be done in O (1) time). Book-keeping techniques aim to reduce the redundancy factor d . <p> Unfortunately both the all-sol and all-eager-constructor are NP-hard in general, as the problem of finding necessary and possible truth of a proposition in a partially ordered plan can respectively be reduced to them <ref> [10] </ref>.
Reference: [11] <author> S. Kambhampati. </author> <title> Design Tradeoffs in Partial Order (Plan Space) Planning. </title> <note> Submitted to AIPS-94 and AAAI-94. </note>
Reference-contexts: This is equal to probability that a randomly chosen urn will have all m balls plus the probability that it will have m 1 balls and so on plus the probability that it will have 1 ball. In <ref> [11] </ref>, I exploit this experimental methodology to compare the empirical performance of a variety of normalized instantiations of Refine-Plan algorithm. These experiments reveal that the most important cause for the performance differentials among different refinement planners are the differences in the tractability refinements they employ. <p> It is required because of the contributor protections used by SNLP-UA (see [7]). 13 For actions with conditional effects, a necessary conflict can be confronted by planning to make the preservation preconditions true for the interacting step. planners such as UA. In <ref> [11] </ref>, I provide empirical compar-isons between SNLP-UA and other possible instantiations of Refine-Plan. 5.3.2 Polynomial eager solution-constructors As discussed in Section 4.1, all-sol, the solution constructor used in all existing plan-space planners returns with success only when all the safe ground linearizations of the partial plan are solutions.
Reference: [12] <author> S. Kambhampati. </author> <title> HTN Planning: What? Why? and When? ASU Technical Report in preparation, </title> <year> 1994. </year>
Reference-contexts: Filter conditions can be modeled as point truth constraints, and included in the auxiliary solution constraints (without adding them to the agenda) <ref> [12] </ref>. Since they are (non-monotonic) solution constraints, they cannot be used to prune partial plans. <p> The HTN planners (cf. [27, 4]) can be modeled by extending the refinement algorithm such that its main refinement operation is task reduction rather than establishment (with establishment refinement being a particular way of reducing tasks); see <ref> [12] </ref>. 7 Conclusion In this paper, I have shown that refinement search provides a unifying framework for understanding the performance tradeoffs in plan-space planning.
Reference: [13] <author> C. Knoblock and Q. Yang. </author> <title> A Comparison of the SNLP and TWEAK planning algorithms. </title> <booktitle> In Proc. of AAAI Spring Symp. on Foundations of Automatic Planning. </booktitle> <year> 1993. </year>
Reference-contexts: In such cases, comparisons must inevitably be based on empirical studies. The unified framework offers help in designing focused empirical studies. In the past, empirical analyses tended to focus on a wholistic ``black-box'' comparisons of brand-name planning algorithms, such as TWEAK vs. SNLP (c.f. <ref> [13] </ref>). It is hard to draw meaningful conclusions from such comparisons, since when seen as instantiations of our Refine-Plan algorithm, they differ on a variety of dimensions (see Table 1). <p> This distinction removes many misunderstandings about plan-space planning algorithms. For example, it clarifies that the only motivation for total ordering plan-space planners is tractability of refinement. Similarly, in the past it has been erroneously claimed ( e.g. <ref> [13] </ref>) that the system-aticity of SNLP increases the effective depth of the solution.
Reference: [14] <author> D. McDermott. </author> <title> Regression Planning. </title> <journal> Intl. Jour. Intelligent Systems, </journal> <volume> 6 </volume> <pages> 357-416, </pages> <year> 1991. </year>
Reference-contexts: A solution S is said to be minimal if no operator sequence obtained by removing some of the operators from S is also a solution. Traditionally, the completeness of a planner is measured in terms of its ability to find minimal solutions (cf. <ref> [22, 19, 14] </ref>): Definition 6 (Planner Completeness) A planning algorithm is said to be complete if it can find all minimal solutions for every solvable problem. 3.1 Refinement Search Semantics for Partial Plans When plan-space planning is viewed as a refinement search, the constraint sets associated with search nodes can be <p> rep; NP-hard with ADL) NP-hard with ADL) UA [16] MTC-based O (n 4 ) MTC-based O (n 4 ) None Unambiguous ordering Nonlin [26] MTC (Q&A) based Arbitrary O (1) Goal Protection via Q&A Conflict Resolution TOCL [1] Protection based O (1) Arbitrary O (1) Contributor protection Total ordering Pedestal <ref> [14] </ref> Protection based O (1) Arbitrary O (1) Interval Protection Total ordering SNLP [15] Protection based Arbitrary Contributor protection Conflict resolution UCPOP [22] O (1) O (1) MP, MP-I [8] Protection based Arbitrary (Multi) contributor protection Conflict resolution SNLP-UA Protection based O (1)/ Arbitrary O (1)/ Contributor protection Unambiguous Ordering (cf. <p> They can both be represented in terms of the interval preservation constraints. Suppose the planner just established a condition c at step s with the help of the effects of the step s 0 . For planners using interval protection (e.g., PEDESTAL <ref> [14] </ref>), the bookkeeping constraint requires that no candidate of the partial plan can have p deleted between operators corresponding to s 0 and s. It can thus be modeled in terms of interval preservation constraint hs 0 ; p; si.
Reference: [15] <author> D. McAllester and D. Rosenblitt. </author> <title> Systematic Nonlinear Planning. </title> <booktitle> In Proc. 9th AAAI, </booktitle> <year> 1991. </year>
Reference-contexts: Existing planning systems implement All-sol in two different ways: Planners such as Chapman's TWEAK [2] use the modal truth criterion to explicitly check that all the safe ground linearizations correspond to solutions (we will call these the MTC-based constructors). Planners such as SNLP <ref> [15] </ref> and UCPOP [22] depend on protection strategies and conflict resolution (see below) to indirectly guarantee the safety and necessary correctness required by all-sol (we call these protection based constructors). <p> ) MTC-based O (n 4 ) None Unambiguous ordering Nonlin [26] MTC (Q&A) based Arbitrary O (1) Goal Protection via Q&A Conflict Resolution TOCL [1] Protection based O (1) Arbitrary O (1) Contributor protection Total ordering Pedestal [14] Protection based O (1) Arbitrary O (1) Interval Protection Total ordering SNLP <ref> [15] </ref> Protection based Arbitrary Contributor protection Conflict resolution UCPOP [22] O (1) O (1) MP, MP-I [8] Protection based Arbitrary (Multi) contributor protection Conflict resolution SNLP-UA Protection based O (1)/ Arbitrary O (1)/ Contributor protection Unambiguous Ordering (cf. <p> This property can be proven from the fact that contributor protections provide a way of uniquely naming steps independent of the symbol table mapping (see <ref> [15, 7] </ref>). <p> For example, if our objective is to judge the utility of specific protection (book-keeping) strategies, we could keep everything else constant and vary only the book-keeping step in Refine-Plan. In contrast, when we compare TWEAK [2] with SNLP <ref> [15] </ref>, we are not only varying the protection strategies, but also the goal selection, conflict resolution and termination (solution constructor) strategies, making it difficult to form meaningful hypotheses from empirical results. 11 q (m; n) is the probability that a randomly chosen urn will contain at least one ball, when m <p> These can be replaced without affecting the systematicity property. Similarly, our framework not only clarifies the relation between the unambiguous planners such as UA [17] and causal-link based planners such as SNLP <ref> [15] </ref>, it also suggests fruitful ways of integrating the ideas in the two planning techniques (cf.
Reference: [16] <author> S. Minton, J. Bresina and M. Drummond. </author> <title> Commitment Strategies in Planning: A Comparative Analysis. </title> <booktitle> In Proc. 12th IJCAI, </booktitle> <year> 1991. </year>
Reference-contexts: The paper is organized as follows: Section 2 provides the preliminaries of refinement search, develops a model for 1 The work of Barrett and Weld [1] as well as Minton et. al. <ref> [16, 17] </ref> are certainly steps in the right direction. However, they do not tell the full story since the comparison there was between a specific partial order and total order planner. <p> Return the refined partial plan (if it is not pruned). planning Planner Soln. Constructor Goal Selection Book-keeping Tractability Refinements Tweak [2] MTC-based MTC-based None None (O (n 4 ) for TWEAK rep; (O (n 4 ) for TWEAK rep; NP-hard with ADL) NP-hard with ADL) UA <ref> [16] </ref> MTC-based O (n 4 ) MTC-based O (n 4 ) None Unambiguous ordering Nonlin [26] MTC (Q&A) based Arbitrary O (1) Goal Protection via Q&A Conflict Resolution TOCL [1] Protection based O (1) Arbitrary O (1) Contributor protection Total ordering Pedestal [14] Protection based O (1) Arbitrary O (1) Interval <p> Two possible pre-ordering techniques are total ordering and unambiguous ordering <ref> [16] </ref>. Total ordering orders every pair of steps in the plan, while unambiguous ordering orders a pair of steps only when one of the steps has an effect c, and the other step either negates c or needs c as a precondition (implying that the two steps may interact). <p> Pre-ordering techniques can also make other plan handling steps, such as MTC-based goal selection and MTC-based solution constructor, tractable (c.f. <ref> [16, 7] </ref>). For example, unambiguous plans also allow polynomial check for necessary truth of any condition in the plan. Polynomial necessary truth check can be useful in MTC-based goal selection and termination tests. <p> For example, unambiguous plans also allow polynomial check for necessary truth of any condition in the plan. Polynomial necessary truth check can be useful in MTC-based goal selection and termination tests. In fact, unambiguous plans were originally used in UA <ref> [16] </ref> for this purpose. 4.5.2 Conflict Resolution Refinements Conflict resolution refines a given partial plan with the aim of compiling the auxiliary constraints into the ordering and binding constraints.
Reference: [17] <author> S. Minton, M. Drummond, J. Bresina and A. Philips. </author> <title> Total Order vs. Partial Order Planning: </title> <booktitle> Factors Influencing Performance In Proc. </booktitle> <address> KR-92, </address> <year> 1992. </year>
Reference-contexts: The paper is organized as follows: Section 2 provides the preliminaries of refinement search, develops a model for 1 The work of Barrett and Weld [1] as well as Minton et. al. <ref> [16, 17] </ref> are certainly steps in the right direction. However, they do not tell the full story since the comparison there was between a specific partial order and total order planner. <p> The only time we will expect reduction in search space size is if the added refinements distribute the solutions in a non-uniform fashion, thereby changing the apparent solution density (c.f. <ref> [17] </ref>). 5.2 Facilitation of Well-founded Empirical Comparisons Given the variety of ways in which Refine-Plan can be instantiated, it is important to understand the comparative advantages of the various instantiations. <p> It could thus strike a good balance between systematic planners such as SNLP and unsystematic, but polynomial-time refinement 12 Note that this definition of interaction is more general than the one used by UA <ref> [17] </ref>. It is required because of the contributor protections used by SNLP-UA (see [7]). 13 For actions with conditional effects, a necessary conflict can be confronted by planning to make the preservation preconditions true for the interacting step. planners such as UA. <p> These can be replaced without affecting the systematicity property. Similarly, our framework not only clarifies the relation between the unambiguous planners such as UA <ref> [17] </ref> and causal-link based planners such as SNLP [15], it also suggests fruitful ways of integrating the ideas in the two planning techniques (cf.
Reference: [18] <author> J. Pearl. </author> <title> Heuristics: Intelligent Search Strategies for Computer Problem Solving. </title> <publisher> Addison-Wesley (1984). </publisher>
Reference-contexts: Section 6 discusses how the generalized algorithm can be extended to handle richer types of goals (e.g. maintenance goals, intermediate goals), and other types of planning models (e.g. HTN planning, state-space planning). Section 7 presents the concluding remarks. 2 Refinement search Preliminaries A refinement search (or split-and-prune search <ref> [18] </ref>) can be visualized as a process of starting with the set of all potential candidates for solving the problem, and splitting the set repeatedly until a solution candidate can be picked up from one of the sets in bounded time.
Reference: [19] <author> E.P.D. Pednault. </author> <title> Synthesizing Plans that contain actions with Context-Dependent Effects. </title> <journal> Computational Intelligence, </journal> <volume> Vol. 4, </volume> <month> 356-372 </month> <year> (1988). </year>
Reference-contexts: The operators (aka actions) in classical planning are modeled as general state transformation functions. We will be assuming that the domain operators are described in ADL <ref> [19, 20] </ref> representation with Precondition and Effect formulas. The precondition and effect formulas are function-less first order predicate logic sentences involving conjunction, negation and quantification. The precondition formulas can also have disjunction, but disjunction is not allowed in the effects formula. <p> A solution S is said to be minimal if no operator sequence obtained by removing some of the operators from S is also a solution. Traditionally, the completeness of a planner is measured in terms of its ability to find minimal solutions (cf. <ref> [22, 19, 14] </ref>): Definition 6 (Planner Completeness) A planning algorithm is said to be complete if it can find all minimal solutions for every solvable problem. 3.1 Refinement Search Semantics for Partial Plans When plan-space planning is viewed as a refinement search, the constraint sets associated with search nodes can be <p> These include the preconditions and secondary preconditions <ref> [19] </ref> of all the actions introduced during planning process (see Section 4). A is sometimes referred to as the agenda of the plan. <p> The algorithms are modular in that individual steps can be analyzed and instantiated relatively independently. Furthermore, the algorithms do not assume any specific restrictions on action representation, and can be used by any planner using ADL action representation <ref> [19] </ref>. The refinement process starts with the partial plan P ; , which contains the steps t 0 and t 1 , and has its agenda and auxiliary solution constraints initialized to the top level goals of attainment (preconditions of t 1 ). <p> It selects a precondition hC; si of the plan (where C is a precondition of a step s), and refines (i.e., adds constraints to) the partial plan such that different steps act as contributors of C to s in different refinements. Chapman [2] and Pednault <ref> [19] </ref> provide theories of sound and complete establishment refinement. <p> The last strategy, called MTC-based goal selection, involves reasoning about truth of a condition in a partially ordered plan, and can be intractable for general partial orderings consisting of ADL <ref> [19] </ref> actions (see Table 1, as well as the discussion of pre-ordering strategies in Section 4.5.1.). 4.3 Book Keeping and Protecting establishments It is possible to do establishment refinement without bookkeeping step. Chapman's TWEAK [2] is such a planner. <p> Specifically, the partial plan is refined (by adding ordering, binding or secondary preconditions <ref> [19] </ref> to the plan) until each possible violation of the auxiliary candidate constraint (called conflict) is individually resolved. The definition of conflict depends upon the specific type 10 In the case of total ordering, this holds vacuously true since the plan has only one linearization of auxiliary constraint. <p> Resolving the conflict involves either making s 0 not intervene between s i and s j (by adding either the ordering s 0 s i or the ordering s j s 0 ), or adding secondary (preservation) preconditions of s 0 , required to make s 0 preserve c <ref> [19] </ref>, to the plan agenda (and the corresponding PTCs to the auxiliary solution constraints; see Section 3.1). When all conflicts are resolved this way, the resulting refinements will have the property that all their ground linearizations are safe.
Reference: [20] <author> E.P.D. Pednault. </author> <title> Generalizing nonlinear planning to handle complex goals and actions with context dependent effects. </title> <booktitle> In Proc. IJCAI-91. </booktitle> , <year> 1991. </year>
Reference-contexts: The operators (aka actions) in classical planning are modeled as general state transformation functions. We will be assuming that the domain operators are described in ADL <ref> [19, 20] </ref> representation with Precondition and Effect formulas. The precondition and effect formulas are function-less first order predicate logic sentences involving conjunction, negation and quantification. The precondition formulas can also have disjunction, but disjunction is not allowed in the effects formula.
Reference: [21] <author> M.A. Peot and D.E. Smith. </author> <title> Threat-Removal Strategies for Nonlinear Planning. </title> <booktitle> In Proc. Eleventh AAAI, </booktitle> <year> 1993. </year>
Reference-contexts: This jF d j vs. C tradeoff also applies to other types of search-space reduction techniques such as deferment of conflict resolution <ref> [21, 7] </ref>. Since conflict resolution is an optional step in Refine-Plan, the planner can be selective about which conflicts to resolve, without affecting the completeness or the systematicity of Refine-Plan.
Reference: [22] <author> J.S. Penberthy and D. Weld. UCPOP: </author> <title> A Sound, Complete, Partial Order Planner for ADL. </title> <booktitle> In Proc. </booktitle> <address> KR-92, </address> <year> 1992. </year>
Reference-contexts: A solution S is said to be minimal if no operator sequence obtained by removing some of the operators from S is also a solution. Traditionally, the completeness of a planner is measured in terms of its ability to find minimal solutions (cf. <ref> [22, 19, 14] </ref>): Definition 6 (Planner Completeness) A planning algorithm is said to be complete if it can find all minimal solutions for every solvable problem. 3.1 Refinement Search Semantics for Partial Plans When plan-space planning is viewed as a refinement search, the constraint sets associated with search nodes can be <p> Existing planning systems implement All-sol in two different ways: Planners such as Chapman's TWEAK [2] use the modal truth criterion to explicitly check that all the safe ground linearizations correspond to solutions (we will call these the MTC-based constructors). Planners such as SNLP [15] and UCPOP <ref> [22] </ref> depend on protection strategies and conflict resolution (see below) to indirectly guarantee the safety and necessary correctness required by all-sol (we call these protection based constructors). <p> Nonlin [26] MTC (Q&A) based Arbitrary O (1) Goal Protection via Q&A Conflict Resolution TOCL [1] Protection based O (1) Arbitrary O (1) Contributor protection Total ordering Pedestal [14] Protection based O (1) Arbitrary O (1) Interval Protection Total ordering SNLP [15] Protection based Arbitrary Contributor protection Conflict resolution UCPOP <ref> [22] </ref> O (1) O (1) MP, MP-I [8] Protection based Arbitrary (Multi) contributor protection Conflict resolution SNLP-UA Protection based O (1)/ Arbitrary O (1)/ Contributor protection Unambiguous Ordering (cf.
Reference: [23] <author> J.S. Penberthy. </author> <title> Planning with continuous change. </title> <type> Ph.D. Thesis. </type> <institution> CS-TR 93-12-01. University of Washington. </institution> <year> 1993. </year>
Reference-contexts: consider the goal of making a round trip from Phoenix to San Francisco. 14 Since the initial and final location of the agent is Phoenix, this goal cannot be modeled as a goal of attainment, i.e., a precondition of t 1 (unless time is modeled explicitly in the action representation <ref> [23] </ref>). However, we can deal with this goal by adding an additional dummy step (say t D ) to the plan such that t D has a precondition At (P hoenix) and t 1 has a precondition At (SF O), and t 0 t D t 1 .
Reference: [24] <author> E. Sacerdoti. </author> <title> Planning in a Hierarchy of Abstraction Spaces. </title> <journal> Artificial Intelligence, </journal> <volume> 5(2), </volume> <year> 1975. </year>
Reference-contexts: Goal Selection: The strategy used to select the particular precondition hC; si to be established, (called goal selection strategy) can be arbitrary, can depend on some ranking based on precondition abstraction <ref> [24] </ref>, and/or demand driven (e.g. select a goal only when it is not already necessarily true according to the modal truth criterion [2]).
Reference: [25] <author> D.E. Smith and M.A. Peot. </author> <title> Postponing threats in partial-order planning. </title> <booktitle> In Proc. Eleventh AAAI, </booktitle> <year> 1993. </year>
Reference-contexts: Specifically, we have: Proposition 6 Given a partial plan whose auxiliary candidate constraints contain interval preservation constraints, checking if there exists a safe ground linearization of the plan is NP-hard. This proposition directly follows from the result in <ref> [25] </ref>, which shows that checking whether there exists a conflict-free ground linearization of a partial plan with interval protection constraints is NP-hard. 4.5 Tractability refinements Since, as observed above, the consistency check is NP-hard in general, each call to Refine-Plan is also NP-hard. <p> This tends to reduce the fringe size, jF d j. Book keeping constraints do however tend to increase the cost of consistency check. In particular, checking the consistency of a partial plan containing interval preservation constraints is NP-hard even for ground plans in TWEAK representation (c.f. <ref> [25] </ref>). Tractability refinements primarily aim to reduce the C c component of refinement cost. In terms of search space size, tractability refinements further refine the plans coming out of the establishment stage, thus increasing the (b t component of the) branching factor. This jF d j vs. <p> However, checking whether a general partially ordered plan is consistent with respect to a set of exhaustive causal links is NP-hard in general <ref> [25] </ref>. This raises the interesting question: Is it possible to write a partial order planning algorithm that is both strongly systematic and has a polynomial time refinement cycle? Our modular framework makes it easy to synthesize such an algorithm.
Reference: [26] <author> A. Tate. </author> <title> Generating Project Networks. </title> <booktitle> In Proceedings of IJCAI-77, pages 888--893, </booktitle> <address> Boston, MA, </address> <year> 1977. </year>
Reference-contexts: Constructor Goal Selection Book-keeping Tractability Refinements Tweak [2] MTC-based MTC-based None None (O (n 4 ) for TWEAK rep; (O (n 4 ) for TWEAK rep; NP-hard with ADL) NP-hard with ADL) UA [16] MTC-based O (n 4 ) MTC-based O (n 4 ) None Unambiguous ordering Nonlin <ref> [26] </ref> MTC (Q&A) based Arbitrary O (1) Goal Protection via Q&A Conflict Resolution TOCL [1] Protection based O (1) Arbitrary O (1) Contributor protection Total ordering Pedestal [14] Protection based O (1) Arbitrary O (1) Interval Protection Total ordering SNLP [15] Protection based Arbitrary Contributor protection Conflict resolution UCPOP [22] O <p> While most planners use one or the other type of protection strategies exclusively for all conditions, planners like NONLIN and O-Plan <ref> [26, 27] </ref> post different book-keeping constraints for different types of conditions. Finally, the interval protections and contributor protections can also be generalized to allow for multiple contributors supporting a given condition (see [8] for a motivation and formal treatment of this idea). <p> Many refinement planners (especially the so-called task reduction planners) use extensions such as condition-typing <ref> [26] </ref>, time-windows [27] and resource based reasoning [27, 28]. Many of these extensions can be covered with the auxiliary constraint mechanism. Time windows and resource reasoning aim to prune partial plans that are infeasible in terms of their temporal constraints and resource requirements. <p> These can, in principle, be modeled in terms of monotonic auxiliary constraints. Condition typing allows the domain user to specify how various preconditions of an operator should be treated during planning <ref> [26] </ref>. In particular, some planners use the notion of filter conditions, which are the applicability conditions of the operators that should never be explicitly considered for establishment.
Reference: [27] <author> K. Currie and A. Tate. O-Plan: </author> <title> The Open Planning Architecture. </title> <journal> Artificial Intelligence, </journal> <volume> 51(1), </volume> <year> 1991. </year>
Reference-contexts: While most planners use one or the other type of protection strategies exclusively for all conditions, planners like NONLIN and O-Plan <ref> [26, 27] </ref> post different book-keeping constraints for different types of conditions. Finally, the interval protections and contributor protections can also be generalized to allow for multiple contributors supporting a given condition (see [8] for a motivation and formal treatment of this idea). <p> Many refinement planners (especially the so-called task reduction planners) use extensions such as condition-typing [26], time-windows <ref> [27] </ref> and resource based reasoning [27, 28]. Many of these extensions can be covered with the auxiliary constraint mechanism. Time windows and resource reasoning aim to prune partial plans that are infeasible in terms of their temporal constraints and resource requirements. <p> Many refinement planners (especially the so-called task reduction planners) use extensions such as condition-typing [26], time-windows [27] and resource based reasoning <ref> [27, 28] </ref>. Many of these extensions can be covered with the auxiliary constraint mechanism. Time windows and resource reasoning aim to prune partial plans that are infeasible in terms of their temporal constraints and resource requirements. These can, in principle, be modeled in terms of monotonic auxiliary constraints. <p> To cover state-space planners (cf. [1]), we need to allow Refine-Plan to use incomplete establishment refinements, and backtrack over goal-selection to make the overall search complete. The HTN planners (cf. <ref> [27, 4] </ref>) can be modeled by extending the refinement algorithm such that its main refinement operation is task reduction rather than establishment (with establishment refinement being a particular way of reducing tasks); see [12]. 7 Conclusion In this paper, I have shown that refinement search provides a unifying framework for understanding
Reference: [28] <author> D. Wilkins. </author> <title> Practical Planning. </title> <note> Morgan Kaufmann (1988). 16 Technical reports available via anonymous ftp from enws318.eas.asu.edu:pub/rao </note>
Reference-contexts: Many refinement planners (especially the so-called task reduction planners) use extensions such as condition-typing [26], time-windows [27] and resource based reasoning <ref> [27, 28] </ref>. Many of these extensions can be covered with the auxiliary constraint mechanism. Time windows and resource reasoning aim to prune partial plans that are infeasible in terms of their temporal constraints and resource requirements. These can, in principle, be modeled in terms of monotonic auxiliary constraints.
References-found: 28

