URL: http://www.cs.iastate.edu/tech-reports/TR93-28a.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: 
Title: An Operational Semantics of Firing Rules for Structured Analysis Style Data Flow Diagrams Keywords: structured
Author: Gary T. Leavens, Tim Wahls, Albert L. Baker, and Kari Lyle TR #-a 
Address: 226 Atanasoff Hall  Ames, Iowa 50011-1040, USA  
Affiliation: Department of Computer Science  Iowa State University  
Date: December 1993 (revised December 1993)  
Abstract: 1993 CR Categories: D.2.1 [Software Engineering] Requirements/Specifications | languages, methodologies, tools; D.2.2 [Software Engineering] Tools and Techniques | structured analysis, data flow diagrams, D.2.10 [Software Engineering] Design | methodologies, representation; D.3.1 [Programming Languages] Formal Definitions and Theory | semantics, syntax; F.3.2 [Logics and Meanings of Programs] Specifying and Verifying and Reasoning about Programs | specification techniques; F.3.2 [Logics and Meanings of Programs] Semantics of Programming Languages | operational semantics. c fl Gary T. Leavens, Tim Wahls, Albert L. Baker, and Kari Lyle 1993. All rights reserved; this report has been submitted for publication, and the copyright will be tranferred to the publisher. 
Abstract-found: 1
Intro-found: 1
Reference: [AR91] <author> E. Astesiano and G. Reggio. </author> <title> SMoLCS Driven Concurrent Calculi. </title> <editor> In Hartmut Ehrig et al., editors, TAPSOFT'87, </editor> <booktitle> Proceedings of the International Joint Conference on Theory and Practice of Software Development, Pisa, Italy, Volume 1, volume 245 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: France distinguishes two kinds of bubbles (data trans-forms and state transforms) and two kinds of flows (data and control). He does not put types on flows as we do. France's operational semantics of extended DFDs use a framework similar to ours: algebraic state transition systems (ASTSs) <ref> [AR91] </ref> [Ast91]. The main difference in the formal framework is that France's semantics use transition systems to model all parts of a DFD, not just the firing rules. This gives the semantics a nicely compositional flavor, and allows an easy treatment of hierarchical DFDs [Fra92, page 333].
Reference: [Ast91] <author> Edigio Astesiano. </author> <title> Inductive and Operational Semantics. </title> <editor> In E. J. Neuhold and M. Paul, editors, </editor> <booktitle> Formal Description of Programming Concepts, IFIP State-of-the-Art Reports, </booktitle> <pages> pages 51-136. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: France distinguishes two kinds of bubbles (data trans-forms and state transforms) and two kinds of flows (data and control). He does not put types on flows as we do. France's operational semantics of extended DFDs use a framework similar to ours: algebraic state transition systems (ASTSs) [AR91] <ref> [Ast91] </ref>. The main difference in the formal framework is that France's semantics use transition systems to model all parts of a DFD, not just the firing rules. This gives the semantics a nicely compositional flavor, and allows an easy treatment of hierarchical DFDs [Fra92, page 333].
Reference: [BJ82] <author> Dines Bjorner and Cliff B. Jones. </author> <title> Formal Specification and Software Development. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> London, </address> <year> 1982. </year>
Reference-contexts: In other words, DFDs did not provide a math-ematically sound definition of the functionality of software systems and so have not been comparable to some of the increasingly popular model-based specification techniques, e.g., VDM <ref> [BJ82] </ref> [Jon86] Z [Hay87] [Spi88], and the Larch family of specification languages [GHW85] [GHG + 93]. However, if we can increase the formality of DFDs without doing serious harm to their intuitive appeal, then we have a mutually beneficial application of formal methods.
Reference: [CJ91] <author> Soren Christensen and Leif Obel Jepsen. </author> <title> Modelling and Simulation of a Network Management System using Hierarchical Coloured Petri Nets (extended version). </title> <type> Technical Report DAIMI PB 349, </type> <institution> Computer Science Department, Aarhus University, </institution> <month> Apr </month> <year> 1991. </year>
Reference-contexts: While this could be regarded as a mere graphical convenience, it would be useful to have an operational semantics of DFDs that took the hierarchy into account (as in the semantics of colored petri nets [HJS90] <ref> [CJ91] </ref>).
Reference: [Col91] <author> David L. Coleman. </author> <title> Formalized structured analysis specifications. </title> <type> PhD thesis, </type> <institution> Iowa State University, Ames, Iowa, </institution> <month> 50011, </month> <year> 1991. </year>
Reference-contexts: Neither the flow name nor the type alone are sufficient to uniquely identify a flow in our example; having both labels eliminates a common source of ambiguity <ref> [Col91] </ref>. 1 In SA, DeMarco [DeM78] and others (e.g., [War86]) make a distinction between "discrete" and "continuous" flows. However, some authors seem to consider continuous flows as continuous in the sense of calculus (i.e., real-valued, differentiable). <p> DeMarco and Ward seem to think of them as continuously existing (i.e., like a shared variable) even when read. We adopt this latter interpretation, but to avoid confusion, we use different terminology <ref> [Col91] </ref>. Flows labeled with a double arrowhead are called persistent flows, which can be considered to be shared variables; flows with a single arrowhead are a consumable flows, which can be considered to be unbounded FIFO queues. <p> In a persistent flow, the shared variable that the flow represents can be written by the bubble at the source of the flow, and read by the target bubble <ref> [Col91] </ref>. Reading from a persistent flow does not change the information in the flow. The only persistent flows in our example go from bubbles to themselves; for example, f custs is used to model a the bubble Generate-Sales-Order's local storage. <p> We have not described this translation formally because we did not want to go into the details of the graphical syntax of DFDs <ref> [Col91] </ref> [Tse91], although we have given an example of one such translation. However, using some such formal description of the structure of DFDs it is easy to give a completely formal description of their semantics. <p> Even if the sources stop sending outputs into the DFD, the rest of the DFD may be able to continue running. This would be normal in many applications. 6 Adding Stores In traditional SA, a store is a passive holder of data [DeM78] <ref> [Col91] </ref>. Multiple bubbles can access a single store for both reading and writing, but the store itself does not transform data. In fact, a store is usually thought of simply as a file, which is a rather low level of abstraction for a specification. <p> Finally, to support the change in the type Read , the initial read mapping must return an empty multiset for each bubble, rather than the function f : ?. r initial def 8 Discussion 8.1 Related Work 8.1.1 De Marco and Yourdon DFDs used in traditional structured analysis (SA) [DeM78] <ref> [Col91, page 15] </ref> has a very informal flavor and some features that are not present in our formalization. On the one hand 23 there are graphical conventions, which are not a part of our formalization. <p> On the one hand 23 there are graphical conventions, which are not a part of our formalization. For example, De Marco's notations to indicate "conjunction" (*) and "disjunction" () of flows may be helpful in visualizing a system. Similarly, graphical distinctions between "data" and "control" flows [You89] <ref> [Col91, pages 27-28] </ref> may also help visualize some designs. Our formal model can encode this kind of information in a general way. <p> A converging flow may mean either: * that there are several flows which all have their sinks in the same bubble, or * that several "elementary packets of data" are to be joined "to form a complex packet" (such as a tuple) <ref> [Col91, page 16] </ref>. In our model one can express the first by having several separate flows. The second requires introducing a bubble to accept each of the "converging" flows and specifying how it combines them. This avoids any possible ambiguity. De Marco's diverging flows are ambiguous in the same way. <p> Hatley and Pirbhai have a similar notion of continuity [HP87] <ref> [Col91, Section 5.3.2] </ref>. Since such data can only be modeled in a computer by discrete data, there seems to be no good reason to model this distinction. Instead, we have adopted Ward's semantics for continuous flows as shared variables [War86, page 203] as a feature of flows in our model. <p> Instead, we have adopted Ward's semantics for continuous flows as shared variables [War86, page 203] as a feature of flows in our model. This feature of flows is orthogonal to the type of data on the flow. This is the distinction between consumable and persistent flows <ref> [Col91, Section 5.3.4] </ref>. The traditional view of stores is that they represent files [War86, page 199]. However, for files, they seem strangely active, since flows both go into and come out of stores. <p> It would be interesting to make a formal connection between such a semantics of DFDs and our work. 8.1.5 Coleman The static semantics of SA specifications (including notational issues) are treated in a recent dissertation by Coleman <ref> [Col91] </ref>. <p> Coleman describes a notation for P-specs based on first-order logic <ref> [Col91, Chapter 7] </ref>. Coleman also describes how one could give an operational semantics of SA specifications [Col91, Section 9.2] using what amounts to colored Petri nets (values are used instead of Ward's tokens) and first-order logical assertions for the transition firing rules. <p> Coleman describes a notation for P-specs based on first-order logic [Col91, Chapter 7]. Coleman also describes how one could give an operational semantics of SA specifications <ref> [Col91, Section 9.2] </ref> using what amounts to colored Petri nets (values are used instead of Ward's tokens) and first-order logical assertions for the transition firing rules. Our initial model can be seen as a formalization of his suggestions. <p> Our initial model can be seen as a formalization of his suggestions. Coleman's gives several different possible models of stores, one of which <ref> [Col91, Figure 8.2] </ref> is the one we adopt. However, he ignores stores in his sketch of the operational semantics of DFDs. Coleman does not treat a bubble firing concurrently with itself. 8.1.6 France France works with DFDs that have several additional features, and he also gives a formal semantics [Fra92].
Reference: [DeM78] <author> Tom DeMarco. </author> <title> Structured Analysis and System Specification. </title> <publisher> Yourdon , Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1978. </year>
Reference-contexts: The informal technique we address is Structured Analysis (SA). SA is an approach to the development of software systems which has received wide-spread use in the software engineering community for over 15 years <ref> [DeM78] </ref> [WM85] [You89]. Within SA, the specification phase of software development is based on Data Flow Diagrams (DFDs). Most Computer-aided Software Engineering (CASE) tools support the development of DFDs, and the DFD component of SA specifications is a major factor in its popularity. <p> Neither the flow name nor the type alone are sufficient to uniquely identify a flow in our example; having both labels eliminates a common source of ambiguity [Col91]. 1 In SA, DeMarco <ref> [DeM78] </ref> and others (e.g., [War86]) make a distinction between "discrete" and "continuous" flows. However, some authors seem to consider continuous flows as continuous in the sense of calculus (i.e., real-valued, differentiable). DeMarco and Ward seem to think of them as continuously existing (i.e., like a shared variable) even when read. <p> Even if the sources stop sending outputs into the DFD, the rest of the DFD may be able to continue running. This would be normal in many applications. 6 Adding Stores In traditional SA, a store is a passive holder of data <ref> [DeM78] </ref> [Col91]. Multiple bubbles can access a single store for both reading and writing, but the store itself does not transform data. In fact, a store is usually thought of simply as a file, which is a rather low level of abstraction for a specification. <p> ) Finally, to support the change in the type Read , the initial read mapping must return an empty multiset for each bubble, rather than the function f : ?. r initial def 8 Discussion 8.1 Related Work 8.1.1 De Marco and Yourdon DFDs used in traditional structured analysis (SA) <ref> [DeM78] </ref> [Col91, page 15] has a very informal flavor and some features that are not present in our formalization. On the one hand 23 there are graphical conventions, which are not a part of our formalization. <p> On the other hand, De Marco's DFDs do have some features that are semantic and are not directly modeled by our operational semantics: converging and diverging flows <ref> [DeM78] </ref>. The problem with both of these notions is that they are ambiguous.
Reference: [Fra92] <author> Robert B. </author> <title> France. Semantically Extended Data Flow Diagrams: A Formal Specification Tool. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 18(4) </volume> <pages> 329-346, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: However, he ignores stores in his sketch of the operational semantics of DFDs. Coleman does not treat a bubble firing concurrently with itself. 8.1.6 France France works with DFDs that have several additional features, and he also gives a formal semantics <ref> [Fra92] </ref>. France's "queued flows" are what we call consumable flows, and his 25 "variables" are our persistent flows. France distinguishes two kinds of bubbles (data trans-forms and state transforms) and two kinds of flows (data and control). He does not put types on flows as we do. <p> The main difference in the formal framework is that France's semantics use transition systems to model all parts of a DFD, not just the firing rules. This gives the semantics a nicely compositional flavor, and allows an easy treatment of hierarchical DFDs <ref> [Fra92, page 333] </ref>. France gives an explicit notation for P-specs, and also describes additional graphical conventions for DFDs. France's DFDs have syntactic and semantic restrictions that seem to be intended to enforce good methodology, but which also make them less general than ours. <p> For example, each bubble must have an output flow (page 330) and nested loops are not allowed inside infinite loops in his P-spec statement language (page 337). France treats stores the same as he treats other parts of a DFD, as ASTSs <ref> [Fra92, pages 336-337] </ref>; hence stores need more description than necessary in our model, and can be more general. France's notion of convergence and divergence is apparently the same as Ward and Mellor's (see France's Figure 2, p. 330). France calls these "binders" and "splitters". <p> Since he does not treat them in his formal semantics, his notions appear to suffer the same problems (no precise description of how the splitting or aggregation is done). France does not allow bubbles to fire concurrently with themselves because each bubble has only one copy of its variables <ref> [Fra92, pages 344-345] </ref>. Firing in a DFD is apparently an atomic step, since "outputs are solely dependent on current inputs" [Fra92, page 342]; so France's model includes explicit ways to make bubbles concurrent. <p> France does not allow bubbles to fire concurrently with themselves because each bubble has only one copy of its variables [Fra92, pages 344-345]. Firing in a DFD is apparently an atomic step, since "outputs are solely dependent on current inputs" <ref> [Fra92, page 342] </ref>; so France's model includes explicit ways to make bubbles concurrent.
Reference: [GHG + 93] <author> John V. Guttag, James J. Horning, S.J. Garland, K.D. Jones, A. Modet, and J.M. Wing. </author> <title> Larch: Languages and Tools for Formal Specification. </title> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1993. </year>
Reference-contexts: In other words, DFDs did not provide a math-ematically sound definition of the functionality of software systems and so have not been comparable to some of the increasingly popular model-based specification techniques, e.g., VDM [BJ82] [Jon86] Z [Hay87] [Spi88], and the Larch family of specification languages [GHW85] <ref> [GHG + 93] </ref>. However, if we can increase the formality of DFDs without doing serious harm to their intuitive appeal, then we have a mutually beneficial application of formal methods. Moreover, we have the possibility of adjustable formality; developers can "turn up" the level of formality as desired or needed.
Reference: [GHW85] <author> John V. Guttag, James J. Horning, and Jeannette M. Wing. </author> <title> The Larch Family of Specification Languages. </title> <journal> IEEE Software, </journal> <volume> 2(4), </volume> <month> September </month> <year> 1985. </year>
Reference-contexts: In other words, DFDs did not provide a math-ematically sound definition of the functionality of software systems and so have not been comparable to some of the increasingly popular model-based specification techniques, e.g., VDM [BJ82] [Jon86] Z [Hay87] [Spi88], and the Larch family of specification languages <ref> [GHW85] </ref> [GHG + 93]. However, if we can increase the formality of DFDs without doing serious harm to their intuitive appeal, then we have a mutually beneficial application of formal methods.
Reference: [Hay87] <author> I. Hayes, </author> <title> editor. Specification Case Studies. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <year> 1987. </year>
Reference-contexts: In other words, DFDs did not provide a math-ematically sound definition of the functionality of software systems and so have not been comparable to some of the increasingly popular model-based specification techniques, e.g., VDM [BJ82] [Jon86] Z <ref> [Hay87] </ref> [Spi88], and the Larch family of specification languages [GHW85] [GHG + 93]. However, if we can increase the formality of DFDs without doing serious harm to their intuitive appeal, then we have a mutually beneficial application of formal methods.
Reference: [Hen90] <author> Matthew Hennessy. </author> <title> The Semantics of Programming Languages: an Elementary Introduction using Structural Operational Semantics. </title> <publisher> John Wiley and Sons, </publisher> <address> New York, N.Y., </address> <year> 1990. </year>
Reference-contexts: Using our results, one could settle on a standard syntax and semantics for SA specifications. Our formal description uses the techniques of operational semantics [Plo77] <ref> [Hen90] </ref>, which are easier to understand than those of denotational (fixed-point) semantics. Operational techniques also directly lend themselves to the construction of interpreters. In brief, the meaning of a SA specification is a set of sequences of configurations of the DFD. <p> The conditions above the horizontal line must hold for the transition to be taken; they should be thought of as a hypothesis. That is, if the conditions 16 above horizontal line hold, then the transition below the line may take place <ref> [Hen90] </ref>. bm (b) = idle; Enabled (b)(fs) = true; bm 0 = [b 7! working]bm; (fs 0 ; r 0 ) 2 Consume (b)(fs; r) (bm; r; fs) ! (bm 0 ; r 0 ; fs 0 ) The following transition rule states that if b is working, then it may <p> However, in general, it is difficult to deal with persistent inputs and outputs to and from the sources and sinks within such a framework. Furthermore, this alternative does not give one much information, because it ignores how the sources acted. An operational semantics in Plotkin's structural style [Plo77] <ref> [Hen90] </ref> usually has a set of terminal configurations, from which no transitions are possible. This will not always be the case for DFDs with sources, since the sources may always be able to fire, as in our example.
Reference: [HJS90] <author> Peter Huber, Kurt Jensen, and Robert M. Shapiro. </author> <title> Hierarchies in Coloured Petri Nets. </title> <editor> In G. Rosenberg, editor, </editor> <booktitle> Advances in Petra nets 1990, volume 483 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <address> New York, N.Y., </address> <year> 1990. </year> <month> 28 </month>
Reference-contexts: While this could be regarded as a mere graphical convenience, it would be useful to have an operational semantics of DFDs that took the hierarchy into account (as in the semantics of colored petri nets <ref> [HJS90] </ref> [CJ91]). <p> Tse's work [Tse91] only deals with the syntax of DFDs, not their semantics. 8.1.4 Colored Petri Nets Another way to give a fuller account semantics to DFDs would be to use Tse and Pong's approach with colored Petri nets [Jen91] <ref> [HJS90] </ref>. It would be interesting to make a formal connection between such a semantics of DFDs and our work. 8.1.5 Coleman The static semantics of SA specifications (including notational issues) are treated in a recent dissertation by Coleman [Col91].
Reference: [HP87] <author> D. J. Hatley and I. Pirbhai. </author> <title> Strategies for Real-Time System Specification. </title> <publisher> Dorset House, </publisher> <address> New York, N.Y., </address> <year> 1987. </year>
Reference-contexts: Hatley and Pirbhai have a similar notion of continuity <ref> [HP87] </ref> [Col91, Section 5.3.2]. Since such data can only be modeled in a computer by discrete data, there seems to be no good reason to model this distinction.
Reference: [Jen91] <author> Kurt Jensen. </author> <title> Coloured Petri Nets: A High Level Language for System Analysis and Design. </title> <editor> In G. Rozenberg, editor, </editor> <booktitle> Advances in Petri Nets 1990, volume 483 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> Also a technical report from the CS Dept, </note> <institution> Aarhus University, DAIMI PB-338, </institution> <month> Nov. </month> <year> 1990. </year>
Reference-contexts: Tse's work [Tse91] only deals with the syntax of DFDs, not their semantics. 8.1.4 Colored Petri Nets Another way to give a fuller account semantics to DFDs would be to use Tse and Pong's approach with colored Petri nets <ref> [Jen91] </ref> [HJS90]. It would be interesting to make a formal connection between such a semantics of DFDs and our work. 8.1.5 Coleman The static semantics of SA specifications (including notational issues) are treated in a recent dissertation by Coleman [Col91].
Reference: [Jon86] <author> Cliff B. Jones. </author> <title> Systematic software development using VDM. </title> <booktitle> International Series in Computer Science. </booktitle> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, N.J., </address> <year> 1986. </year>
Reference-contexts: In other words, DFDs did not provide a math-ematically sound definition of the functionality of software systems and so have not been comparable to some of the increasingly popular model-based specification techniques, e.g., VDM [BJ82] <ref> [Jon86] </ref> Z [Hay87] [Spi88], and the Larch family of specification languages [GHW85] [GHG + 93]. However, if we can increase the formality of DFDs without doing serious harm to their intuitive appeal, then we have a mutually beneficial application of formal methods.
Reference: [Lyl92] <author> Kari Ann Lyle. </author> <title> Refinement in Data Flow Diagrams. </title> <type> Master's thesis, </type> <institution> Iowa State University, Ames, Iowa 50011, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: However, there is no way to make a bubble concurrent with itself, and so no way to specify a bubble that may be refined into as system of bubbles that may process inputs in slightly different orders, which we permit by allowing a bubble to fire concurrently with itself <ref> [Lyl92] </ref>. 8.2 Towards Practical Applications The initial state may seem rather difficult to use, but one can set up the enabling rules so that the first thing each bubble does is to initialize itself in a more reasonable way.
Reference: [Pet77] <author> J. L. Peterson. </author> <title> Petri Nets. </title> <journal> ACM Computing Surveys, </journal> <volume> 9(3) </volume> <pages> 221-252, </pages> <month> September </month> <year> 1977. </year>
Reference-contexts: We call a snapshot at certain well-defined points of such an execution a configuration; it is similar to a marking of a Petri net <ref> [Pet77] </ref>.
Reference: [Plo77] <author> G. D. Plotkin. </author> <title> LCF Considered as a Programming Language. </title> <journal> Theoretical Computer Science, </journal> <volume> 5 </volume> <pages> 223-255, </pages> <year> 1977. </year>
Reference-contexts: Using our results, one could settle on a standard syntax and semantics for SA specifications. Our formal description uses the techniques of operational semantics <ref> [Plo77] </ref> [Hen90], which are easier to understand than those of denotational (fixed-point) semantics. Operational techniques also directly lend themselves to the construction of interpreters. In brief, the meaning of a SA specification is a set of sequences of configurations of the DFD. <p> However, in general, it is difficult to deal with persistent inputs and outputs to and from the sources and sinks within such a framework. Furthermore, this alternative does not give one much information, because it ignores how the sources acted. An operational semantics in Plotkin's structural style <ref> [Plo77] </ref> [Hen90] usually has a set of terminal configurations, from which no transitions are possible. This will not always be the case for DFDs with sources, since the sources may always be able to fire, as in our example.
Reference: [Sch86] <author> David A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Allyn and Bacon, Inc., </publisher> <address> Boston, Mass., </address> <year> 1986. </year>
Reference-contexts: Function application is left associative 4 The notation f : e denotes a function that takes an argument, and returns the value of the expression e with the argument substituted for f <ref> [Sch86] </ref>. 8 The function r e describes part of a configuration where the bubble Bill-Customer has read the order co from the flow f creditBC (see Table 1), and where Collections has read the payment pmt from f payment and an empty to-do list from f to-do . 3.3 Information on <p> The pair follows the in of the let in notation <ref> [Sch86] </ref>, with the first element of the pair before the comma, and the second after. 13 Checking c-local can be based on the definition of In, used in its construction.
Reference: [Spi88] <author> J. M. Spivey. </author> <title> Understanding Z: a Specification Language and its Formal Semantics. </title> <publisher> Cambridge University Press, </publisher> <address> New York, N.Y., </address> <year> 1988. </year>
Reference-contexts: In other words, DFDs did not provide a math-ematically sound definition of the functionality of software systems and so have not been comparable to some of the increasingly popular model-based specification techniques, e.g., VDM [BJ82] [Jon86] Z [Hay87] <ref> [Spi88] </ref>, and the Larch family of specification languages [GHW85] [GHG + 93]. However, if we can increase the formality of DFDs without doing serious harm to their intuitive appeal, then we have a mutually beneficial application of formal methods.
Reference: [TP89] <author> T. H. Tse and L. Pong. </author> <title> Towards a Formal Foundation for Demarco Data Flow Diagrams. </title> <journal> The Computer Journal, </journal> <volume> 32(1) </volume> <pages> 1-12, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: interpretation of the DFD), because the transitions between markings cannot depend on the values of data on the flows or the exact functions computed by bubbles. 8.1.3 Tse and Pong Tse and Pong recognize that: "Transitions and places of Petri nets correspond, respectively, to processes and data flows of DFDs" <ref> [TP89, page 1] </ref>. They also give an algebraic model of DFDs, but do not formalize the translation between pictures and their algebraic model. However, their semantics using Petri nets also ignores the values on the flows and so cannot describe the full behavior of a DFD.
Reference: [Tse91] <author> T. H. Tse. </author> <title> A Unifying Framework for Structured Analysis and Design Models, </title> <booktitle> volume 11 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge Univerity Press, </publisher> <address> New York, N.Y., </address> <year> 1991. </year>
Reference-contexts: We have not described this translation formally because we did not want to go into the details of the graphical syntax of DFDs [Col91] <ref> [Tse91] </ref>, although we have given an example of one such translation. However, using some such formal description of the structure of DFDs it is easy to give a completely formal description of their semantics. <p> They also give an algebraic model of DFDs, but do not formalize the translation between pictures and their algebraic model. However, their semantics using Petri nets also ignores the values on the flows and so cannot describe the full behavior of a DFD. Tse's work <ref> [Tse91] </ref> only deals with the syntax of DFDs, not their semantics. 8.1.4 Colored Petri Nets Another way to give a fuller account semantics to DFDs would be to use Tse and Pong's approach with colored Petri nets [Jen91] [HJS90].
Reference: [War86] <author> Paul T. Ward. </author> <title> The Transformation Schema: An Extension of the Data Flow Diagram to Represent Control and Timing. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(2), </volume> <month> February </month> <year> 1986. </year>
Reference-contexts: Neither the flow name nor the type alone are sufficient to uniquely identify a flow in our example; having both labels eliminates a common source of ambiguity [Col91]. 1 In SA, DeMarco [DeM78] and others (e.g., <ref> [War86] </ref>) make a distinction between "discrete" and "continuous" flows. However, some authors seem to consider continuous flows as continuous in the sense of calculus (i.e., real-valued, differentiable). DeMarco and Ward seem to think of them as continuously existing (i.e., like a shared variable) even when read. <p> Again our model does not suffer from the ambiguity inherent in De Marco's DFDs. Ward, in <ref> [War86] </ref> gives notation to disambiguate these two senses of converging and diverging flows, but leaves the process by which tupling and splitting of data is achieved implicit. Similarly, our model can represent "dialogue flows" by two separate flows. <p> We have, however, laid the foundation for such a semantics by letting bubbles fire concurrently with themselves. 8.1.2 Ward Ward <ref> [War86] </ref> distinguishes discrete from continuous data flows; that is between discrete and analog data, which he defines as "a set of values defined continuously over a time interval" [War86, page 199]. Hatley and Pirbhai have a similar notion of continuity [HP87] [Col91, Section 5.3.2]. <p> We have, however, laid the foundation for such a semantics by letting bubbles fire concurrently with themselves. 8.1.2 Ward Ward [War86] distinguishes discrete from continuous data flows; that is between discrete and analog data, which he defines as "a set of values defined continuously over a time interval" <ref> [War86, page 199] </ref>. Hatley and Pirbhai have a similar notion of continuity [HP87] [Col91, Section 5.3.2]. Since such data can only be modeled in a computer by discrete data, there seems to be no good reason to model this distinction. <p> Hatley and Pirbhai have a similar notion of continuity [HP87] [Col91, Section 5.3.2]. Since such data can only be modeled in a computer by discrete data, there seems to be no good reason to model this distinction. Instead, we have adopted Ward's semantics for continuous flows as shared variables <ref> [War86, page 203] </ref> as a feature of flows in our model. This feature of flows is orthogonal to the type of data on the flow. This is the distinction between consumable and persistent flows [Col91, Section 5.3.4]. The traditional view of stores is that they represent files [War86, page 199]. <p> This feature of flows is orthogonal to the type of data on the flow. This is the distinction between consumable and persistent flows [Col91, Section 5.3.4]. The traditional view of stores is that they represent files <ref> [War86, page 199] </ref>. However, for files, they seem strangely active, since flows both go into and come out of stores. <p> Ward also includes in his extension of DFDs something called a "buffer", which is highly ambiguous. He says that a "buffer is an abstraction on a stack or a queue" <ref> [War86, page 200] </ref>. Stacks and (LIFO) queues certainly have different behavior. Ward gives a semantics of DFDs based "loosely on the execution of a Petri net" [War86, pages 203-205]. However, his semantics are somewhat informal and ambiguous. <p> He says that a "buffer is an abstraction on a stack or a queue" [War86, page 200]. Stacks and (LIFO) queues certainly have different behavior. Ward gives a semantics of DFDs based "loosely on the execution of a Petri net" <ref> [War86, pages 203-205] </ref>. However, his semantics are somewhat informal and ambiguous. For example, he does not clear up the ambiguity in the potential behavior of buffers.
Reference: [WBL93] <author> Tim Wahls, Albert L. Baker, and Gary T. Leavens. </author> <title> An Executable Semantics for a Formalized Data Flow Diagram Specification Language. </title> <type> Technical Report 93-27, </type> <institution> Department of Computer Science, Iowa State University, 226 Atanasoff Hall, Ames, Iowa 50011, </institution> <month> November </month> <year> 1993. </year> <note> Submitted for publication. Available by anonymous ftp from ftp.cs.iastate.edu or by e-mail from almanac@cs.iastate.edu. </note>
Reference-contexts: The main problem with practical application of this work is to give a syntax for P-specs and to give its formal semantics using these ideas <ref> [WBL93] </ref>. 8.3 Conclusions In this paper we have described a formal foundation for the semantics of SA specifications by giving a structural operational semantics of DFDs.
Reference: [WM85] <author> Paul T. Ward and Stephen J. Mellor. </author> <title> Structured Development for Real-Time Systems, volume 1: Introduction and Tools. </title> <publisher> Yourdon, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1985. </year>
Reference-contexts: The informal technique we address is Structured Analysis (SA). SA is an approach to the development of software systems which has received wide-spread use in the software engineering community for over 15 years [DeM78] <ref> [WM85] </ref> [You89]. Within SA, the specification phase of software development is based on Data Flow Diagrams (DFDs). Most Computer-aided Software Engineering (CASE) tools support the development of DFDs, and the DFD component of SA specifications is a major factor in its popularity.
Reference: [You89] <author> Edward Yourdon. </author> <title> Modern Structured Analysis. </title> <publisher> Yourdon Press computing series. Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1989. </year> <month> 29 </month>
Reference-contexts: The informal technique we address is Structured Analysis (SA). SA is an approach to the development of software systems which has received wide-spread use in the software engineering community for over 15 years [DeM78] [WM85] <ref> [You89] </ref>. Within SA, the specification phase of software development is based on Data Flow Diagrams (DFDs). Most Computer-aided Software Engineering (CASE) tools support the development of DFDs, and the DFD component of SA specifications is a major factor in its popularity. <p> On the one hand 23 there are graphical conventions, which are not a part of our formalization. For example, De Marco's notations to indicate "conjunction" (*) and "disjunction" () of flows may be helpful in visualizing a system. Similarly, graphical distinctions between "data" and "control" flows <ref> [You89] </ref> [Col91, pages 27-28] may also help visualize some designs. Our formal model can encode this kind of information in a general way.
References-found: 26

