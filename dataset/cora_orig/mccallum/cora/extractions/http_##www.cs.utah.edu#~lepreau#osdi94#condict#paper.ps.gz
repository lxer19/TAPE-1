URL: http://www.cs.utah.edu/~lepreau/osdi94/condict/paper.ps.gz
Refering-URL: http://www.cs.utah.edu/~lepreau/osdi94/condict/abstract.html
Root-URL: 
Title: 24 June 1994 Microkernel Modularity with Integrated Kernel Performance Page 1 Microkernel Modularity with Integrated
Address: 1 Cambridge Center Cambride, MA 02142  
Affiliation: Research Institute  
Abstract: Microkernel-based operating systems are often much slower than comparable integrated kernels, mainly because system calls use RPC between protection domains, and because data copies between user processes and the OS require VM manipulations. The use of multiple domains has traditionally been viewed as the basis for microkernel modularity, but in fact modularity within the OS need not be implemented with this overhead, because the modules trust one another. By collocating the OSF/1 server and the Mach microkernel within a single domain, and transparently short-circuiting the message-based RPCs into a more efficient form, we obtained performance no worse than 8% slower than the equivalent OSF/1 integrated kernel on demanding workload benchmarks. When collocated, a servers threads remain pre-emptible and all of its text and data remain pageable. Because the location transparency of Mach RPC is preserved, the same binary server program can run collocated with Mach, or as an ordinary user task (with lower performance). Further, since the short-circuiting code is generated by MIG, multiple servers can be simultaneously collocated with Mach, as performance needs dictate, with no changes to the MIG declarations. For all of these reasons, we preserve modularity while significantly improving performance. 
Abstract-found: 1
Intro-found: 1
Reference: [Acc86] <author> M. Accetta, R. Baron, W. Bolosky, D. Golub, R. Rashid, A. Tevanian, and M. Young, </author> <title> Mach: A New Kernel Foundation for Unix Development, </title> <booktitle> Proceedings of the USENIX Summer 86 Conference, </booktitle> <month> July </month> <year> 1986. </year>
Reference-contexts: 1. Introduction and Background In the late 1980s, operating system designs consisting of a microkernel (MK) with one or more server tasks layered on top of it became increasingly popular with researchers and developers <ref> [Acc86, Hil92, Ren88, Roz92] </ref>. Today, in the mid-1990s, they have not yet achieved the same popularity with the product divisions of OS vendors, nor with end users. There are good reasons for both of these situations, which we examine below.
Reference: [Bat92] <author> Nariman Batlivala, Barry Gleason, Jim Hamrick, Scott Lurndal, Darren Price, and James Soddy, </author> <title> Experience with SVR4 over Chorus, </title> <booktitle> Proceedings of the USENIX Workshop on Micro-kernels and Other Kernel Architectures, </booktitle> <pages> pp. 223-241, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Other differences result from dissimilarities between Mach and Chorus. But perhaps the most important distinction is this: although Chorus V3 has been applied to re-implement existing Unix versions (see e.g. <ref> [Bat92] </ref>), we are unaware of any published performance comparison between an optimized Chorus implementation of a given OS and an equivalent IK implementation. We believe our analysis of MK overhead and how it can be made negligible under Mach provides valuable validation for MK proponents of all stripes.
Reference: [Ber90] <author> Brian N. Bershad, Thomas E. Anderson, Edward D. Lazowska, and Henry M. Levy, </author> <title> Lightweight Remote Procedure Call, </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 8(1) </volume> <pages> 37-55, </pages> <month> February </month> <year> 1990. </year> <title> 24 June 1994 Microkernel Modularity with Integrated Kernel Performance Page 15 </title>
Reference-contexts: QNX supports fragmented non-contiguous messages, but physically copies everything, rather than using VM remapping for larger sizes. Our system supports both, transparently, and avoids the overhead completely in short-circuited RPC. The work of Bershad et al. on lightweight RPC <ref> [Ber90] </ref> optimizes for cross-domain RPC within a single machine, but uses full thread migration, which reduces the functionality of thread control and causes robustness and compatibility problems that do not occur with Utahs partial thread migration.
Reference: [Ber92] <author> Brian Bershad, </author> <title> The Increasing Irrelevance of IPC Performance for Micro-kernel-based Operating Systems, </title> <booktitle> Proceedings of the USENIX Workshop on Micro-Kernels and Other Kernel Architectures, </booktitle> <pages> pp. 205-212, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: Since we cannot avoid large overhead in cross-domain RPCs with non-trivial arguments, and we cannot safely reduce the number of RPCs between the user and the OS server using emulation, we disagree with the claim of <ref> [Ber92] </ref> that the performance of IPC is increasingly irrelevant for microkernel-based operating systems. On the contrary, it is the foremost problem with such systems. Copyin/Copyout. The next largest overhead is the cost of copying data between user processes and the servers.
Reference: [Bri91] <author> Allan Bricker, Michel Gien, Marc Guillemont, Jim Lipkis, Douglas Orr, and Marc Rozier, </author> <title> A New Look at Microkernel-Based Unix Operating Systems: Lessons in Performance and Compatibility, </title> <booktitle> Proceedings of the EurO-pen Spring 91 Conference, </booktitle> <month> May, </month> <year> 1991. </year>
Reference-contexts: Our work integrates, extends and generalizes these two research projects, which was necessary to achieve our performance and modularity goals. There are many similarities between kernel collocation in our work and the supervisor actors introduced in Chorus V3 <ref> [Bri91, Roz92] </ref>, though our implementation is more exible, in that we permit the same server image to run either collocated or in user mode, and automatically select the most efficient RPC path in either case. Other differences result from dissimilarities between Mach and Chorus.
Reference: [Cla92] <author> Raymond K. Clark, E. Douglas Jensen, and Franklin D. Reynolds, </author> <title> An Architectural Overview of the Alpha Real-Time Distributed Kernel, </title> <booktitle> Proceedings of the USENIX Workshop on Micro-kernels and Other kernel Architectures, </booktitle> <pages> pp. 127-146, </pages> <month> April </month> <year> 1992. </year>
Reference: [Dea93] <author> Randall W. Dean, </author> <title> Using Continuations to Build a User-Level Threads Library, </title> <booktitle> Proceedings of the USENIX Mach III Symposium, </booktitle> <address> pp.137-152, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: listing them all here, but some of the most significant were the following, each of which addresses one of the problems shown in Figure 2: A new version of C-threads in which context-switching is based on the use of depressed priority, instead of the sending of messages, as reported in <ref> [Dea93] </ref>. A uniprocessor configuration of the OSF/1 server, in which all significant server activity happens with a global lock held, preventing pre-emption of server threads, and allowing the fine-grained (and expensive) per-data structure locks to be removed.
Reference: [Dru92] <author> Peter Druschel, Larry L. Peterson, and Norman C. Hutchinson, </author> <title> Beyond Micro-Kernel Design: Decoupling Modularity and Protection in Lipto, </title> <booktitle> Proceedings of the Twelfth International Conference on Distributed Computing Systems, </booktitle> <pages> pp. 512-520, </pages> <month> June </month> <year> 1992. </year>
Reference: [For93a] <author> Bryan Ford, Mike Hibler, and Jay Lepreau, </author> <title> Notes on Thread Models in Mach 3.0, </title> <institution> University of Utah Computer Science Dept., TR UUCS-93-012, </institution> <month> April </month> <year> 1993. </year>
Reference: [For93b] <author> Bryan Ford and Jay Lepreau, </author> <title> Evolving Mach 3.0 to Use Migrating Threads, </title> <institution> University of Utah Computer Science Dept., TR UUCS-93-022, </institution> <month> November </month> <year> 1993. </year>
Reference-contexts: The algorithm at the core of both new RPC mechanisms is the partial thread migration developed at the University of Utah <ref> [For93b] </ref>. Although it is not the most efficient light-weight RPC possible, the Utah approach is a useful compromise to avoid making servers aware of which kind of RPC they are currently using, while preserving the full functionality of Mach. <p> The other project, <ref> [For93b] </ref>, defined an elegant form of (partially) migrating RPC that preserved all the semantics of Machs message-based RPC, while speeding up null RPC 3-fold.
Reference: [Ham93] <author> Graham Hamilton, Panos Kougiouris, </author> <title> The Spring Nucleus: A Microkernel for Objects, </title> <institution> Sun Microsystems Laboratories, SMLI TR-93-14, </institution> <month> April </month> <year> 1993. </year>
Reference-contexts: Our new form of RPC has the full generality of RPCs implemented with mach_msg (), but dynamically chooses the most performant mechanism based on the relationship between the protection domains of caller and callee. The RPC mechanism in Spring <ref> [Ham93] </ref> is quite similar in structure to our work; a portion of the thread migrates, failure and control semantics are similar, and they have chosen to optimize for round-trip RPC rather than building RPC out of one-way messages.
Reference: [Hil92] <author> Dan Hildebrand, </author> <title> An Architectural Overview of QNX, </title> <booktitle> Proceedings of the USENIX Workshop on Micro-kernels and Other Kernel Architectures, </booktitle> <pages> pp. 113-126, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: 1. Introduction and Background In the late 1980s, operating system designs consisting of a microkernel (MK) with one or more server tasks layered on top of it became increasingly popular with researchers and developers <ref> [Acc86, Hil92, Ren88, Roz92] </ref>. Today, in the mid-1990s, they have not yet achieved the same popularity with the product divisions of OS vendors, nor with end users. There are good reasons for both of these situations, which we examine below. <p> In all of these mechanisms, the full generality and power of the Mach interface generator (MIG) is available to the programmer. The commercial MK-based system with the largest installed base is QNX <ref> [Hil92] </ref>. QNX exceeds typical Unix I/O throughput, using a user-mode OS server. However, only synchronous, one-way message passing is supported. We achieve nearly twice the rate of null system call execution when using a collocated server.
Reference: [Joh93] <author> D.B.Johnson and W.Zwaenepoel, </author> <title> The Peregrine High-Performance RPC System, </title> <journal> Software -- Practice and Experience, </journal> <volume> 23(2) </volume> <pages> 201-221, </pages> <month> Feb. </month> <year> 1993. </year>
Reference: [Lep93] <author> Jay Lepreau, Mike Hibler, Bryan Ford, and Jeff Law, </author> <title> In-Kernel Servers on Mach 3.0: Implementation and Performance, </title> <booktitle> Proceedings of the USENIX Mach III Symposium, </booktitle> <pages> pp. 39-55, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Related Work Our work has benefited greatly from, and in some sense is an extension of, two related projects at the Utah University, which began independently but eventually developed into a fruitful collaboration. One, <ref> [Lep93] </ref>, improved the performance of an OSF/1 MK system running on a Hewlett-Packard PA-RISC system, by loading the OS server into the kernel and avoiding the use of messages in the system call path.
Reference: [Lie93] <author> Jochen Liedtke, </author> <title> Improving IPC by Kernel Design, </title> <booktitle> Proceedings of the 14th ACM Symposium on Operating Systems Principles, </booktitle> <pages> pp. 175-188, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The work of Bershad et al. on lightweight RPC [Ber90] optimizes for cross-domain RPC within a single machine, but uses full thread migration, which reduces the functionality of thread control and causes robustness and compatibility problems that do not occur with Utahs partial thread migration. With L3, Liedtke <ref> [Lie93] </ref> achieves excellent cross-domain RPC speeds through a complete redesign of the IPC subsystem, rigorously following several design principles that keep IPC performance paramount. We did not have the luxury of changing existing source or binary interfaces.
Reference: [Pat93] <author> Simon Patience, </author> <title> Redirecting System Calls in Mach 3.0, an Alternative to the Emulator, </title> <booktitle> Proceedings of the USENIX Mach III Symposium, </booktitle> <pages> pp. 57-74. </pages>
Reference-contexts: It may refuse to ever relinquish the lock, or it may put arbitrary illegal values into any shared memory it can access, and the OS server must protect against this. There are many more problems associated with untrusted emulators (see <ref> [Pat93] </ref>), forcing us to conclude that the performance advantages of an emulator library are outweighed by the complexity and robustness problems it introduces.
Reference: [Ren88] <author> Robert van Renesse, Hans van Staveren, Andrew Tanenbaum, </author> <title> Performance of the Worlds Fastest Distributed Operating System, </title> <journal> Operating Systems Review, </journal> <volume> 22(4), </volume> <pages> pp 23-24, </pages> <month> October </month> <year> 1988. </year>
Reference-contexts: 1. Introduction and Background In the late 1980s, operating system designs consisting of a microkernel (MK) with one or more server tasks layered on top of it became increasingly popular with researchers and developers <ref> [Acc86, Hil92, Ren88, Roz92] </ref>. Today, in the mid-1990s, they have not yet achieved the same popularity with the product divisions of OS vendors, nor with end users. There are good reasons for both of these situations, which we examine below.
Reference: [Roz92] <author> M. Rozier, V. Abrossimov, F. Armand, I. Boule, M. Gien, M. Guillemont, F. Herrmann, C. Kaiser, S. Lan-glois, P. Leonard, and W. Neuhauser, </author> <title> Overview of the Chorus Distributed Operating System, </title> <booktitle> Proceedings of the USENIX Workshop on Micro-kernels and other Kernel Architectures, </booktitle> <pages> pp. 39-69, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: 1. Introduction and Background In the late 1980s, operating system designs consisting of a microkernel (MK) with one or more server tasks layered on top of it became increasingly popular with researchers and developers <ref> [Acc86, Hil92, Ren88, Roz92] </ref>. Today, in the mid-1990s, they have not yet achieved the same popularity with the product divisions of OS vendors, nor with end users. There are good reasons for both of these situations, which we examine below. <p> Our work integrates, extends and generalizes these two research projects, which was necessary to achieve our performance and modularity goals. There are many similarities between kernel collocation in our work and the supervisor actors introduced in Chorus V3 <ref> [Bri91, Roz92] </ref>, though our implementation is more exible, in that we permit the same server image to run either collocated or in user mode, and automatically select the most efficient RPC path in either case. Other differences result from dissimilarities between Mach and Chorus.
References-found: 18

