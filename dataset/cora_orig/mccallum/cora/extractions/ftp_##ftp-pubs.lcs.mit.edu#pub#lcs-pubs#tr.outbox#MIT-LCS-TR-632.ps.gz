URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-632.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/tr600.html
Root-URL: 
Title: Time Optimal Self-Stabilizing Spanning Tree Algorithms  
Author: by Sudhanshu Madan Aggarwal Nancy A. Lynch Roberto Segala 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degrees of Bachelor of Science and Master of Science in Electrical Engineering and Computer Science at the  c Sudhanshu Madan Aggarwal, MCMXCIV. All rights reserved. The author hereby grants to MIT permission to reproduce and distribute publicly paper and electronic copies of this thesis document in whole or in part, and to grant others the right to do so. Author  Certified by Dr. Shay Kutten  Thesis Supervisor Certified by  Professor of Computer Science Thesis Supervisor Certified by  Thesis Supervisor Accepted by: Frederic R. Morgenthaler Chairman, Departmental Committee on Graduate Students  
Note: Manager Distributed Computing, IBM T. J.  
Date: May 1994  May 20, 1994  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY  Department of Electrical Engineering and Computer Science  Watson Research Center  Research Associate, MIT Laboratory for Computer Science  
Abstract-found: 0
Intro-found: 1
Reference: [AB89] <author> Yehuda Afek and Geoffrey Brown. </author> <title> Self-stabilization of the alternating bit protocol. </title> <booktitle> In Proc. 8th Symposium on Reliable Distributed Systems, </booktitle> <month> October </month> <year> 1989. </year>
Reference: [AG90] <author> Anish Arora and Mohamed G. Gouda. </author> <title> Distributed reset. </title> <booktitle> In Proc. 10th Conf. on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 316-331. </pages> <publisher> Springer-Verlag (LNCS 472), </publisher> <year> 1990. </year>
Reference-contexts: They presented the technique of "local checking" and "local detection," used in 14 many subsequent papers. <ref> [AG90] </ref> gave an ID-based self-stabilizing spanning tree protocol with time complexity O (N 2 ), where N is a pre-specified bound on the network size n. [APV91] gave an ID-based self-stabilizing spanning tree protocol (based on a reset protocol) that stabilizes in O (n) time. [DIM91] gave a self-stabilizing spanning tree <p> a Monte-Carlo spanning tree protocol for anonymous networks that works in O (ffi) time; however, their protocol is not self-stabilizing. (A Monte-Carlo algorithm terminates in bounded time but succeeds with probability p &lt; 1; a Las-Vegas algorithm may not terminate in bounded time but always succeeds.) With the exception of <ref> [AG90] </ref>, all the other works mentioned above do not assume any prior knowledge of the network size n or the diameter ffi. [DIM91] also mentioned a self-stabilizing spanning tree protocol for anonymous networks that requires O (ffi) time (and is thus time-optimal), but requires prior knowledge of a bound N on
Reference: [AK93] <author> Sudhanshu Aggarwal and Shay Kutten. </author> <title> Time Optimal Self-Stabilizing Spanning Tree Algorithms. </title> <booktitle> In Proc. 13th Conf. on Foundations of Software Technology and Theoretical Computer Science, </booktitle> <pages> pages 400-410. </pages> <publisher> Springer-Verlag (LNCS 761), </publisher> <year> 1993. </year>
Reference: [AKMPV93] <author> Baruch Awerbuch, Shay Kutten, Yishay Mansour, Boaz Patt-Shamir, and George Vargh-ese. </author> <title> Time Optimal Self-Stabilizing Synchronization. </title> <booktitle> In Proceedings of the 25th Annual ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Recently, <ref> [AKMPV93] </ref> have developed a time-optimal self-stabilizing spanning tree protocol for ID-based networks; they, too, require prior knowledge of a bound D on the diameter of the network. <p> Both our protocols stabilize in expected O (ffi) time. Thus, with respect to the O (ffi log n)-time protocol of [DIM91], we decrease the time complexity to O (ffi), and compared to their O (ffi)-time protocol, we do not need a bound N on the network size. Unlike <ref> [AKMPV93] </ref>, we do not need a bound D on the diameter. Note that for random graphs, the expected diameter ffi is comparable to log n. For real networks, such as the Internet, the diameter is usually less than log n.
Reference: [AKY90] <author> Yehuda Afek, Shay Kutten, and Moti Yung. </author> <title> Memory-efficient self-stabilization on general networks. </title> <booktitle> In Proc. 4th Workshop on Distributed Algorithms, </booktitle> <address> Italy, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: Previous Work Following the pioneering work of [Dij74], there has been considerable work in this area. [Ang 80] showed that no deterministic algorithm can construct a spanning tree in an anonymous symmetric network. <ref> [AKY90] </ref> gave an ID-based self-stabilizing spanning tree protocol with a stabilization time of O (n 2 ) and a randomized protocol for anonymous networks that runs in O (n log n) time. <p> In this final state, all nodes would have the same ID; thus coalescing would cease at this point. To detect such "multiple highest priorities," <ref> [AKY90] </ref> and [DIM 91] proposed the method of recoloring trees. In typical recoloring schemes, each tree is associated with a randomly chosen color. The root chooses a color at random from a small set of "colors" C of constant size (e.g. C =f0, 1, 2, 3g). <p> Since tree colors are chosen randomly, neighboring nodes that belong to different trees will assume different sequences of colors over time; this fact can be exploited to let such neighbors detect their affiliation to different trees. In the scheme proposed by <ref> [AKY90] </ref>, the sequence of colors chosen by a root to color its tree is "alternating" of the form (c 1 , c s , c 2 , c s , c 3 , c s , : : :), where c s is a special color, "no-color," and c i 6= <p> If a node v detects another tree, its root is informed of the condition. When a root learns of the existence of another tree rooted at the same ID, in the <ref> [AKY90] </ref> and [DIM91] schemes the root extends its ID by a randomly chosen bit and continues the protocol. <p> In such a schedule, the trees can continue the recoloring process indefinitely without ever detecting each other. An idea proposed in <ref> [AKY90] </ref> modifies the scheme so that it can accomodate an adversarial scheduler.
Reference: [AM89] <author> Yehuda Afek and Yossi Matias. </author> <title> Simple and Efficient Election Algorithms for Anonymous Networks. </title> <booktitle> In 3rd International Workshop on Distributed Algorithms, </booktitle> <address> Nice, France, </address> <month> Septem-ber </month> <year> 1989. </year>
Reference-contexts: ), where N is a pre-specified bound on the network size n. [APV91] gave an ID-based self-stabilizing spanning tree protocol (based on a reset protocol) that stabilizes in O (n) time. [DIM91] gave a self-stabilizing spanning tree algorithm for anonymous networks that runs in expected O (ffi log n) time. <ref> [AM89] </ref> gave a Monte-Carlo spanning tree protocol for anonymous networks that works in O (ffi) time; however, their protocol is not self-stabilizing. (A Monte-Carlo algorithm terminates in bounded time but succeeds with probability p &lt; 1; a Las-Vegas algorithm may not terminate in bounded time but always succeeds.) With the exception <p> The final root is determined by the state s set by the adversary at the start of the algorithm|the root is one of the nodes that believes in the highest ID. 30 Chapter 4 A Key Approach to Representing IDs 4.1 The Afek-Matias Probability Distribution In <ref> [AM89] </ref>, Afek and Matias proposed a probability distribution which can be used to break symmetry in sets of unknown size. Let p be a pair (s; t) of integers, and let pairs be ordered lexicographically. [AM89] proposed a probability distribution on s and t, such that if several (say k) pairs <p> 30 Chapter 4 A Key Approach to Representing IDs 4.1 The Afek-Matias Probability Distribution In <ref> [AM89] </ref>, Afek and Matias proposed a probability distribution which can be used to break symmetry in sets of unknown size. Let p be a pair (s; t) of integers, and let pairs be ordered lexicographically. [AM89] proposed a probability distribution on s and t, such that if several (say k) pairs (s i ; t i ) are randomly computed, there is a unique highest pair with probability at least *, where * is a constant independent of k. <p> The first property is the main result of <ref> [AM89] </ref>: Theorem 4.1 For any k, P k (UNIQH) 1=2. The next two theorems are proved in appendix A: Theorem 4.2 For any k; i, P k (UNIQH j (Highest &gt; i)) 1=2. <p> If a root is thus informed of the existence of a competing tree (i.e. another tree with the same root ID), it attempts to break symmetry by extending its ID (action 46 Append-Entry u () ID u ID u :x where x is an entry chosen by the Afek-Matias <ref> [AM89] </ref> scheme New-Color u () if color u = 0 then return color randomly chosen from f1, 2, 3g else return 0 Reset-Color u (color) /* reset local recoloring-related variables */ color u color mode u broadcast other-trees u false 8v 2 Nbrs (u) , nbr-color uv undefined self-color uv undefined
Reference: [Ang80] <author> Dana Angluin. </author> <title> Local and global properties in networks of processes. </title> <booktitle> In Proceedings of the 12th Annual ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1980. </year>
Reference: [AP90] <author> Baruch Awerbuch and David Peleg. </author> <title> Network synchronization with polylogarithmic overhead. </title> <booktitle> In 31st Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1990. </year>
Reference: [APPS92] <author> Baruch Awerbuch, Boaz Patt-Shamir, David Peleg, and Mike Saks. </author> <title> Adapting to asynchronous dynamic networks. </title> <booktitle> In Proceedings of the 24th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 557-570, </pages> <month> May </month> <year> 1992. </year>
Reference: [APV91] <author> Baruch Awerbuch, Boaz Patt-Shamir, and George Varghese. </author> <title> Self-stabilization by local checking and correction. </title> <booktitle> In 32nd Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 268-277, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: They presented the technique of "local checking" and "local detection," used in 14 many subsequent papers. [AG90] gave an ID-based self-stabilizing spanning tree protocol with time complexity O (N 2 ), where N is a pre-specified bound on the network size n. <ref> [APV91] </ref> gave an ID-based self-stabilizing spanning tree protocol (based on a reset protocol) that stabilizes in O (n) time. [DIM91] gave a self-stabilizing spanning tree algorithm for anonymous networks that runs in expected O (ffi log n) time. [AM89] gave a Monte-Carlo spanning tree protocol for anonymous networks that works in
Reference: [APV92] <author> Baruch Awerbuch, Boaz Patt-Shamir, and George Varghese. </author> <title> Self-stabilizing network protocols. </title> <type> Unpublished manuscript, </type> <year> 1992. </year> <month> 116 </month>
Reference: [AS88] <author> Baruch Awerbuch and Michael Sipser. </author> <title> Dynamic networks are as fast as static networks. </title> <booktitle> In 29th Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 206-220, </pages> <month> October </month> <year> 1988. </year>
Reference: [AV91] <author> Baruch Awerbuch and George Varghese. </author> <title> Distributed program checking: a paradigm for building self-stabilizing distributed protocols. </title> <booktitle> In 32nd Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 258-267, </pages> <month> October </month> <year> 1991. </year>
Reference: [Awe85] <author> Baruch Awerbuch. </author> <title> Complexity of network synchronization. </title> <journal> J. ACM, </journal> <volume> 32(4) </volume> <pages> 804-823, </pages> <month> Octo-ber </month> <year> 1985. </year>
Reference: [BP89] <author> J.E. Burns and J. Pachl. </author> <title> Uniform self-stabilizing rings. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 11(2) </volume> <pages> 330-344, </pages> <year> 1989. </year>
Reference: [Dij74] <author> Edsger W. Dijkstra. </author> <title> Self stabilization in spite of distributed control. </title> <journal> Comm. ACM, </journal> <volume> 17 </volume> <pages> 643-644, </pages> <year> 1974. </year>
Reference-contexts: Nodes may crash or get corrupted; links may fail or deliver erroneous messages. Further, nodes or links may enter or leave the network at any time. A very important concept in the context of this problem is that of self-stabilization, first introduced by Dijkstra <ref> [Dij74] </ref>. Self-stabilization implies the ability of the system to recover from any transient fault that changes the state of the system. Dijkstra gave the example of a token-ring network which is always supposed to have exactly one token. <p> Similarly, it may or may not "know" in advance a bound on the diameter ffi. Of course, the more "knowledge" a protocol "is given" about the network, the easier it becomes to achieve its objectives. Previous Work Following the pioneering work of <ref> [Dij74] </ref>, there has been considerable work in this area. [Ang 80] showed that no deterministic algorithm can construct a spanning tree in an anonymous symmetric network. [AKY90] gave an ID-based self-stabilizing spanning tree protocol with a stabilization time of O (n 2 ) and a randomized protocol for anonymous networks that
Reference: [DIM91] <author> Shlomi Dolev, Amos Israeli, and Shlomo Moran. </author> <title> Uniform self-stabilizing leader election. </title> <booktitle> In Proc. 5th Workshop on Distributed Algorithms, </booktitle> <pages> pages 167-180, </pages> <year> 1991. </year>
Reference-contexts: in 14 many subsequent papers. [AG90] gave an ID-based self-stabilizing spanning tree protocol with time complexity O (N 2 ), where N is a pre-specified bound on the network size n. [APV91] gave an ID-based self-stabilizing spanning tree protocol (based on a reset protocol) that stabilizes in O (n) time. <ref> [DIM91] </ref> gave a self-stabilizing spanning tree algorithm for anonymous networks that runs in expected O (ffi log n) time. [AM89] gave a Monte-Carlo spanning tree protocol for anonymous networks that works in O (ffi) time; however, their protocol is not self-stabilizing. (A Monte-Carlo algorithm terminates in bounded time but succeeds with <p> algorithm terminates in bounded time but succeeds with probability p &lt; 1; a Las-Vegas algorithm may not terminate in bounded time but always succeeds.) With the exception of [AG90], all the other works mentioned above do not assume any prior knowledge of the network size n or the diameter ffi. <ref> [DIM91] </ref> also mentioned a self-stabilizing spanning tree protocol for anonymous networks that requires O (ffi) time (and is thus time-optimal), but requires prior knowledge of a bound N on the network size. <p> We present both a randomized Las-Vegas algorithm for anonymous networks and a deterministic version for ID-based networks. Both our protocols stabilize in expected O (ffi) time. Thus, with respect to the O (ffi log n)-time protocol of <ref> [DIM91] </ref>, we decrease the time complexity to O (ffi), and compared to their O (ffi)-time protocol, we do not need a bound N on the network size. Unlike [AKMPV93], we do not need a bound D on the diameter. <p> Note that for random graphs, the expected diameter ffi is comparable to log n. For real networks, such as the Internet, the diameter is usually less than log n. Thus, decreasing the 15 time complexity from O (ffi log n) (as in <ref> [DIM91] </ref>) to O (ffi) represents an improvement in the time required to less than the square root of that required earlier. Both of our protocols employ a novel technique in self-stabilization. A major concern in self-stabilizing systems has been contending with "wrong information". <p> Our technique, on the other hand, is to modify incorrect information instead of perform the expensive process of eliminating it. (A similar idea to that of "correcting information" was implicitly used by <ref> [DIM91] </ref>.) The modification is done locally but in a careful manner: local modifications of wrong information have important desirable global consequences. We do it without incurring the large overhead of global operations such as reset etc. Compared to [DIM91], we do stronger corrections (but still without causing global overhead). <p> (A similar idea to that of "correcting information" was implicitly used by <ref> [DIM91] </ref>.) The modification is done locally but in a careful manner: local modifications of wrong information have important desirable global consequences. We do it without incurring the large overhead of global operations such as reset etc. Compared to [DIM91], we do stronger corrections (but still without causing global overhead). <p> If a node v detects another tree, its root is informed of the condition. When a root learns of the existence of another tree rooted at the same ID, in the [AKY90] and <ref> [DIM91] </ref> schemes the root extends its ID by a randomly chosen bit and continues the protocol.
Reference: [LSS94] <author> Nancy Lynch, Isaac Saias, and Roberto Segala. </author> <title> Proving Time Bounds for Randomized Distributed Algorithms. </title> <booktitle> To appear in Proc. 13th Conf. on Principles of Distributed Computing, </booktitle> <month> August </month> <year> 1994. </year>
Reference-contexts: Processors communicate by performing write operations on their registers and read operations on the shared registers of their neighbors. All reads and writes are atomic|reads/writes behave as though they occur instantaneously. A network communicating through shared memory, as described above, can be modeled as a probabilistic automaton ([SL94], <ref> [LSS94] </ref>). 2.1 Probabilistic Automata In this section we give only a simplified version of the model of [SL94] which is sufficient for our purposes. 2.1.1 Automata Definition 2.1 A probabilistic automaton M consists of four components: * a set states (M ) of states. * a nonempty set start (M )
Reference: [SL94] <author> Roberto Segala and Nancy Lynch. </author> <title> A model for randomized concurrent systems. </title> <type> Manuscript, </type> <year> 1994 </year>
Reference-contexts: All reads and writes are atomic|reads/writes behave as though they occur instantaneously. A network communicating through shared memory, as described above, can be modeled as a probabilistic automaton (<ref> [SL94] </ref>, [LSS94]). 2.1 Probabilistic Automata In this section we give only a simplified version of the model of [SL94] which is sufficient for our purposes. 2.1.1 Automata Definition 2.1 A probabilistic automaton M consists of four components: * a set states (M ) of states. * a nonempty set start (M ) states (M ) of start states. * a set acts (M ) of actions. * a transition <p> The following definition provides a general way of doing this. Definition 2.7 An adversary schema for a probabilistic automaton M , denoted by Advs, is a subset of Advs M . 2.2 Composability In this section, we introduce a key theorem of <ref> [SL94] </ref>, the composability theorem. The statement U t ! p Advs U 0 means that, starting from any state of U and under any adversary A of Advs, the probability of reaching a state of U 0 within time t is at least p.
Reference: [Var92] <author> George Varghese. </author> <title> Self-Stabilization by Local Checking and Correction. </title> <type> PhD thesis, </type> <institution> MIT Lab. for Computer Science, </institution> <year> 1992. </year> <month> 117 </month>
References-found: 20

