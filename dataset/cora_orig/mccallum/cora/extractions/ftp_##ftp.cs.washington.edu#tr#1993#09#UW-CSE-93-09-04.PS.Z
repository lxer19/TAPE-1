URL: ftp://ftp.cs.washington.edu/tr/1993/09/UW-CSE-93-09-04.PS.Z
Refering-URL: http://www.cs.washington.edu/research/constraints/cip/kaleidoscope-asi.html
Root-URL: 
Email: bnfb@scs.carleton.ca  
Title: Kaleidoscope: A Constraint Imperative Programming Language Constraint Imperative Programming (CIP) family of languages integrates constraints
Author: Gus Lopez, Bjorn Freeman-Benson, and Alan Borning Gus Lopez and Alan Borning Bjorn Freeman-Benson 
Address: Seattle, Washington 98195 Herzberg Building USA Ottawa, Ontario K1S 5B6 flopez,borningg@cs.washington.edu CANADA  
Affiliation: Dept. of Computer Science Engineering, FR-35 School of Computer Science University of Washington Carleton University  
Note: Authors' addresses:  The  This is a preliminary version of a paper that will appear in Constraint Programming, B. Mayoh, E. T~ougu, J. Penjam (Eds.), NATO Advanced Science Institute Series, Series F: Computer and System Sciences, Springer-Verlag, 1993.  
Abstract: Technical Report 93-09-04 Department of Computer Science and Engineering University of Washington September 1993 Abstract defined domains. We discuss characteristics of the CIP family and provide a rationale for its creation. The synergy of constraints and objects imposes additional challenges for the provision of constructs, such as object identity and class membership, that are well-understood in conventional language paradigms. We discuss the benefits and challenges of combining the constraint and imperative paradigms, and present our current ideas in the context of the design and implementation of the Kaleidoscope'93 language. 
Abstract-found: 1
Intro-found: 1
Reference: [Borning et al. 92] <author> Alan Borning, Bjorn Freeman-Benson, and Molly Wilson. </author> <title> Constraint hierarchies. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 5(3) </volume> <pages> 223-270, </pages> <month> September </month> <year> 1992. </year>
Reference-contexts: Should we change just A, change just C, change both A and C, undo the change to B, or what?) However, constraint hierarchies have additional uses for expressing preferences in planning, layout and other domains. (See <ref> [Borning et al. 92] </ref> for more information.) In addition to constraints of varying strength, Kaleidoscope has constraints of varying duration. Constraint durations specify the period of validity for constraints. The most flexible model would allow constraints to be asserted and retracted at arbitrary points in time. <p> Other constraint languages include Steele's language [Steele Jr. 80], Bertrand [Leler 87], and Siri [Horn 92a, Horn 92b]. (Of these, Siri, another constraint imperative language, is the closest to Kaleidoscope.) For discussions of related work beyond this brief mention, see <ref> [Borning et al. 92, Freeman-Benson & Borning 92b, Freeman-Benson 91] </ref>. The first version of Kaleidoscope, Kaleidoscope'90, had a Smalltalk-like syntax and served as a proof of concept for CIP. Its successor, Kaleidoscope'91, had several features lacking from Kaleido scope'90: a conventional Algol-like syntax, multi-methods, and eager constraint solving semantics. <p> However, the perturbation model seems more natural for imperative programmers, and seems to offer more opportunities for improving the efficiency of our implementation. (The refinement and perturbation models are compared at greater length in <ref> [Borning et al. 92] </ref>.) Kaleidoscope'91 had a restriction that concurrent constraints execute in nested time scopes since the effects of constructor execution could not be visible until the completion of the constructor [Freeman-Benson 91].
Reference: [Chambers 92] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <booktitle> In Proceedings of the 1992 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 33-56, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: The best-known language that supports multi-methods is the Common Lisp Object System [Steele Jr. 90]; another example is Cecil <ref> [Chambers 92] </ref>. For traditional object-oriented languages, multi-methods represent a useful but optional extension to the basic mechanism.
Reference: [Cohen 90] <author> Jacques Cohen. </author> <title> Constraint logic programming languages. </title> <journal> Communications of the ACM, </journal> <volume> 33(7) </volume> <pages> 52-68, </pages> <month> July </month> <year> 1990. </year>
Reference: [Colmerauer 90] <author> Alain Colmerauer. </author> <title> An introduction to Prolog III. </title> <journal> Communications of the ACM, </journal> <pages> pages 69-90, </pages> <month> July </month> <year> 1990. </year>
Reference: [Freeman-Benson & Borning 92a] <author> Bjorn Freeman-Benson and Alan Borning. </author> <title> The design and implementation of Kaleidoscope'90, a constraint imperative programming language. </title> <booktitle> In Proceedings of the IEEE Computer Society International Conference on Computer Languages, </booktitle> <pages> pages 174-180, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: To address this problem, we proposed constraint imperative programming (CIP), an integration of two disparate paradigms: a standard object-oriented imperative one, and a declarative constraint one <ref> [Freeman-Benson 91, Freeman-Benson & Borning 92a, Freeman-Benson & Borning 92b] </ref>. Compare the two code fragments in Table 1, which allow the user to drag the mercury of a thermometer up and down. The version on the left uses only standard imperative constructs.
Reference: [Freeman-Benson & Borning 92b] <author> Bjorn Freeman-Benson and Alan Borning. </author> <title> Integrating constraints with an object-oriented language. </title> <booktitle> In Proceedings of the 1992 European Conference on Object-Oriented Programming, </booktitle> <pages> pages 268-286, </pages> <month> June </month> <year> 1992. </year> <month> 11 </month>
Reference-contexts: To address this problem, we proposed constraint imperative programming (CIP), an integration of two disparate paradigms: a standard object-oriented imperative one, and a declarative constraint one <ref> [Freeman-Benson 91, Freeman-Benson & Borning 92a, Freeman-Benson & Borning 92b] </ref>. Compare the two code fragments in Table 1, which allow the user to drag the mercury of a thermometer up and down. The version on the left uses only standard imperative constructs. <p> Other constraint languages include Steele's language [Steele Jr. 80], Bertrand [Leler 87], and Siri [Horn 92a, Horn 92b]. (Of these, Siri, another constraint imperative language, is the closest to Kaleidoscope.) For discussions of related work beyond this brief mention, see <ref> [Borning et al. 92, Freeman-Benson & Borning 92b, Freeman-Benson 91] </ref>. The first version of Kaleidoscope, Kaleidoscope'90, had a Smalltalk-like syntax and served as a proof of concept for CIP. Its successor, Kaleidoscope'91, had several features lacking from Kaleido scope'90: a conventional Algol-like syntax, multi-methods, and eager constraint solving semantics.
Reference: [Freeman-Benson 91] <author> B.N. Freeman-Benson. </author> <title> Constraint Imperative Programming. </title> <type> PhD thesis, </type> <institution> Uni--versity of Washington, Department of Computer Science and Engineering, </institution> <month> July </month> <year> 1991. </year> <note> Published as Department of Computer Science and Engineering Technical Report 91-07-02. </note>
Reference-contexts: To address this problem, we proposed constraint imperative programming (CIP), an integration of two disparate paradigms: a standard object-oriented imperative one, and a declarative constraint one <ref> [Freeman-Benson 91, Freeman-Benson & Borning 92a, Freeman-Benson & Borning 92b] </ref>. Compare the two code fragments in Table 1, which allow the user to drag the mercury of a thermometer up and down. The version on the left uses only standard imperative constructs. <p> Other constraint languages include Steele's language [Steele Jr. 80], Bertrand [Leler 87], and Siri [Horn 92a, Horn 92b]. (Of these, Siri, another constraint imperative language, is the closest to Kaleidoscope.) For discussions of related work beyond this brief mention, see <ref> [Borning et al. 92, Freeman-Benson & Borning 92b, Freeman-Benson 91] </ref>. The first version of Kaleidoscope, Kaleidoscope'90, had a Smalltalk-like syntax and served as a proof of concept for CIP. Its successor, Kaleidoscope'91, had several features lacking from Kaleido scope'90: a conventional Algol-like syntax, multi-methods, and eager constraint solving semantics. <p> for improving the efficiency of our implementation. (The refinement and perturbation models are compared at greater length in [Borning et al. 92].) Kaleidoscope'91 had a restriction that concurrent constraints execute in nested time scopes since the effects of constructor execution could not be visible until the completion of the constructor <ref> [Freeman-Benson 91] </ref>. Concurrent constraints allow such things as variable swapping without a temporary (e.g. y := x jj x := y) but we have relaxed these restrictions in Kaleidoscope'93, making nested time scopes unnecessary, although at some cost in expressiveness. <p> The objects as streams of values semantics was mirrored in the implementation by representing variables as streams of objects. Furthermore, the semantics of Kaleidoscope'91 forced constructors to execute in nested time scopes <ref> [Freeman-Benson 91] </ref>. Kaleidoscope'91 had an explicit notion of time. In order to prevent the arbitrary advancement of time, the effects within a constructor were local to that constructor via this nested time scope. Handling these nested time scopes led to inefficiencies in the implementation.
Reference: [Freeman-Benson et al. 90] <author> B. Freeman-Benson, J. Maloney, and A. Borning. </author> <title> An incremental constraint solver. </title> <journal> Communications of the ACM, </journal> <volume> 33(1) </volume> <pages> 54-63, </pages> <month> January </month> <year> 1990. </year>
Reference-contexts: The execution of a constructor might trigger additional constructors to execute. This process continues until the remaining constraints are primitive constraints, which are solved by SkyBlue [Sannella 93], the incremental local propagation solver used for Kaleidoscope'93 primitives. (SkyBlue is a new algorithm that extends our earlier DeltaBlue algorithm <ref> [Freeman-Benson et al. 90, Sannella et al. 93] </ref> to allow constraints with multiple outputs, and that provides better handling of cycles.) Structure constraints, as described in Section 5, are grouped semantically with value constraints, and thus share the same implementation.
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: The requirements for CIP support are: object-oriented-support, preferably class-based with inheritance; multi-methods; constraint solving; and dynamically bound constraints. It would be possible, yet extremely awkward, to implement Kaleidoscope with a virtual machine from a conventional object-oriented language with a value-based data store, for example the Smalltalk-80 virtual machine <ref> [Goldberg & Robson 83] </ref>. However, to do so, the compiler would have to implement the entire semantics of the K-machine in the code generator to ensure that the effect of a constraint-based data store was achieved.
Reference: [Horn 92a] <author> Bruce Horn. </author> <title> Constraint patterns as a basis for object-oriented constraint programming. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, </booktitle> <pages> pages 218-233, </pages> <address> Vancouver, British Columbia, </address> <month> October </month> <year> 1992. </year>
Reference-contexts: Other constraint languages include Steele's language [Steele Jr. 80], Bertrand [Leler 87], and Siri <ref> [Horn 92a, Horn 92b] </ref>. (Of these, Siri, another constraint imperative language, is the closest to Kaleidoscope.) For discussions of related work beyond this brief mention, see [Borning et al. 92, Freeman-Benson & Borning 92b, Freeman-Benson 91]. <p> However, to use the CLAM, one would have to translate the Kaleidoscope semantics into one of the object-oriented logic programming schemes. Other constraint-based languages include Bertrand [Leler 87] and Siri <ref> [Horn 92a] </ref>. Both Bertrand and Siri are based on an Augmented Term Rewriting virtual machine, which is not powerful enough to support all of the imperative features of Kaleidoscope. Table 3 lists the complete set of K-codes (K-machine instructions).
Reference: [Horn 92b] <author> Bruce Horn. </author> <title> Properties of user interface systems and the Siri programming language. </title> <editor> In Brad Myers, editor, </editor> <booktitle> Languages for Developing User Interfaces, </booktitle> <pages> pages 211-236. </pages> <publisher> Jones and Bartlett, </publisher> <address> Boston, </address> <year> 1992. </year>
Reference-contexts: Other constraint languages include Steele's language [Steele Jr. 80], Bertrand [Leler 87], and Siri <ref> [Horn 92a, Horn 92b] </ref>. (Of these, Siri, another constraint imperative language, is the closest to Kaleidoscope.) For discussions of related work beyond this brief mention, see [Borning et al. 92, Freeman-Benson & Borning 92b, Freeman-Benson 91].
Reference: [Jaffar & Lassez 87] <author> Joxan Jaffar and Jean-Louis Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proceedings of the Fourteenth ACM Principles of Programming Languages Conference, </booktitle> <address> Munich, </address> <month> January </month> <year> 1987. </year>
Reference: [Jaffar et al. 92] <author> Joxan Jaffar, Spiro Michaylov, Peter Stuckey, and Roland Yap. </author> <title> The CLP(R) language and system. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3) </volume> <pages> 339-395, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: Similarly, it would be possible, yet awkward, to implement Kaleidoscope using the virtual machine for a pure constraint language. For example, CLP (R) is a constraint logic programming language whose implementation has a constraint solving engine for constraints over the real numbers <ref> [Jaffar et al. 92] </ref>. The CLAM is the abstract machine used in the CLP (R) interpreter, which is based on the WAM, often used in Prolog implementations [Warren 83]. However, to use the CLAM, one would have to translate the Kaleidoscope semantics into one of the object-oriented logic programming schemes.
Reference: [Leler 87] <author> William Leler. </author> <title> Constraint Programming Languages. </title> <publisher> Addison-Wesley, </publisher> <year> 1987. </year>
Reference-contexts: Other constraint languages include Steele's language [Steele Jr. 80], Bertrand <ref> [Leler 87] </ref>, and Siri [Horn 92a, Horn 92b]. (Of these, Siri, another constraint imperative language, is the closest to Kaleidoscope.) For discussions of related work beyond this brief mention, see [Borning et al. 92, Freeman-Benson & Borning 92b, Freeman-Benson 91]. <p> However, to use the CLAM, one would have to translate the Kaleidoscope semantics into one of the object-oriented logic programming schemes. Other constraint-based languages include Bertrand <ref> [Leler 87] </ref> and Siri [Horn 92a]. Both Bertrand and Siri are based on an Augmented Term Rewriting virtual machine, which is not powerful enough to support all of the imperative features of Kaleidoscope. Table 3 lists the complete set of K-codes (K-machine instructions).
Reference: [Sannella 93] <author> Michael Sannella. </author> <title> The SkyBlue Constraint Solver. </title> <type> Technical Report 92-07-02, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <month> February </month> <year> 1993. </year>
Reference-contexts: For constraints of long duration, the constraint re-executes each time of any of its variables (or the subparts of those variables) changes identity. The execution of a constructor might trigger additional constructors to execute. This process continues until the remaining constraints are primitive constraints, which are solved by SkyBlue <ref> [Sannella 93] </ref>, the incremental local propagation solver used for Kaleidoscope'93 primitives. (SkyBlue is a new algorithm that extends our earlier DeltaBlue algorithm [Freeman-Benson et al. 90, Sannella et al. 93] to allow constraints with multiple outputs, and that provides better handling of cycles.) Structure constraints, as described in Section 5, are
Reference: [Sannella et al. 93] <author> Michael Sannella, John Maloney, Bjorn Freeman-Benson, and Alan Borning. </author> <title> Multi-way versus One-way Constraints in User Interfaces: Experience with the DeltaBlue Algorithm. </title> <journal> Software|Practice and Experience, </journal> <volume> 23(5) </volume> <pages> 529-566, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The execution of a constructor might trigger additional constructors to execute. This process continues until the remaining constraints are primitive constraints, which are solved by SkyBlue [Sannella 93], the incremental local propagation solver used for Kaleidoscope'93 primitives. (SkyBlue is a new algorithm that extends our earlier DeltaBlue algorithm <ref> [Freeman-Benson et al. 90, Sannella et al. 93] </ref> to allow constraints with multiple outputs, and that provides better handling of cycles.) Structure constraints, as described in Section 5, are grouped semantically with value constraints, and thus share the same implementation.
Reference: [Saraswat 89] <author> Vijay A. Saraswat. </author> <title> Concurrent Constraint Programming Languages. </title> <type> PhD thesis, </type> <institution> Carnegie-Mellon University, Computer Science Department, </institution> <month> January </month> <year> 1989. </year>
Reference: [Steele Jr. 80] <author> Guy L. Steele Jr. </author> <title> The Definition and Implementation of a Computer Programming Language Based on Constraints. </title> <type> PhD thesis, </type> <institution> MIT, </institution> <month> August </month> <year> 1980. </year> <note> Published as MIT-AI TR 595, </note> <month> August </month> <year> 1980. </year>
Reference-contexts: Other constraint languages include Steele's language <ref> [Steele Jr. 80] </ref>, Bertrand [Leler 87], and Siri [Horn 92a, Horn 92b]. (Of these, Siri, another constraint imperative language, is the closest to Kaleidoscope.) For discussions of related work beyond this brief mention, see [Borning et al. 92, Freeman-Benson & Borning 92b, Freeman-Benson 91].
Reference: [Steele Jr. 90] <author> Guy L. Steele Jr. </author> <title> Common Lisp: The Language. </title> <publisher> Digital Press, </publisher> <address> Bedford, Mas-sachusetts, </address> <note> second edition, </note> <year> 1990. </year>
Reference-contexts: The best-known language that supports multi-methods is the Common Lisp Object System <ref> [Steele Jr. 90] </ref>; another example is Cecil [Chambers 92]. For traditional object-oriented languages, multi-methods represent a useful but optional extension to the basic mechanism.
Reference: [Van Hentenryck 89] <author> Pascal Van Hentenryck. </author> <title> Constraint Satisfaction in Logic Programming. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1989. </year>
Reference: [Van Hentenryck et al. 92] <author> Pascal Van Hentenryck, Helmut Simonis, and Mehmet Dincbas. </author> <title> Constraint satisfaction using constraint logic programming. </title> <journal> Artificial Intelligence, </journal> <volume> 58(1-3):113-159, </volume> <month> December </month> <year> 1992. </year>
Reference: [Warren 83] <author> David H. D. Warren. </author> <title> An abstract prolog instruction set. </title> <type> Technical Report 309, </type> <institution> SRI Internatonal, </institution> <address> Menlo Park, California, </address> <month> October </month> <year> 1983. </year> <month> 12 </month>
Reference-contexts: The CLAM is the abstract machine used in the CLP (R) interpreter, which is based on the WAM, often used in Prolog implementations <ref> [Warren 83] </ref>. However, to use the CLAM, one would have to translate the Kaleidoscope semantics into one of the object-oriented logic programming schemes. Other constraint-based languages include Bertrand [Leler 87] and Siri [Horn 92a].
Reference: [Wilson & Borning 93] <author> Molly Wilson and Alan Borning. </author> <title> Hierarchical constraint logic programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 16(3 & 4):277-318, July, August 1993. 13 </volume>
References-found: 23

