URL: http://www-csag.cs.uiuc.edu/papers/comp-oop.ps
Refering-URL: http://www-csag.cs.uiuc.edu/projects/concert/implementation.html
Root-URL: http://www.cs.uiuc.edu
Email: fjplevyak,achieng@cs.uiuc.edu  
Phone: (217) 244-7116  
Title: Automatic Interprocedural Optimization for Object-Oriented Languages  
Author: John Plevyak and Andrew A. Chien 
Note: Submittted for Publication  
Date: February 29, 1996  
Address: 1304 W. Springfield Avenue Urbana, IL 61801  
Affiliation: Department of Computer Science  
Abstract: The structure of object-oriented programs differs from that of procedural programs, requiring special compilation techniques to obtain efficiency. Object-orientation introduce additional layers of abstraction which separate the implementations of data structures and algorithms from their points of use. The result is smaller functions, increased data dependence of control flow, and an increase in potential aliasing. We present an automatic interprocedural optimization framework, which resolves these differences through interprocedural analysis and transformation; enabling a dynamically-typed pure object-oriented language to match the performance of C on a set of standard procedural benchmarks. For two standard object-oriented benchmarks we also compare this framework to the supplied annotations (e.g. inline, virtual and templates) for the hybrid OO-procedural language C++ [51], and show that the framework obtains up to 6 times the performance of the annotated C++ code.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> O. Agesen, J. Palsberg, and M. Schwartzbach. </author> <title> Type inference of Self: Analysis of objects with dynamic and multiple inheritance. </title> <booktitle> In Proceedings of ECOOP '93, </booktitle> <year> 1993. </year>
Reference-contexts: In terms of object-oriented languages, the constraint based approach [39, 38] has been most recently extended to greater degrees of flow sensitivity by Agesen <ref> [1, 2] </ref> using the Cartesian product of the classes of function arguments. In contrast, our analysis [41] is flow sensitive with respect to both the classes of function arguments and the classes of member variables of data structures.
Reference: [2] <author> Ole Agesen. </author> <title> The cartesian product algorithm: Simple and precise type inference of parametric polymorphism. </title> <booktitle> In Proceedings of ECOOP '95, </booktitle> <pages> pages 2-26. </pages> <note> Springer-Verlag Lecture Notes in Computer Science No. 952, </note> <year> 1995. </year>
Reference-contexts: In terms of object-oriented languages, the constraint based approach [39, 38] has been most recently extended to greater degrees of flow sensitivity by Agesen <ref> [1, 2] </ref> using the Cartesian product of the classes of function arguments. In contrast, our analysis [41] is flow sensitive with respect to both the classes of function arguments and the classes of member variables of data structures.
Reference: [3] <author> Alexander Aiken, Edward L. Wimmers, and T. K. Lakshman. </author> <title> Soft typing with conditional types. </title> <booktitle> In Twenty First Symposium on Principles of Programming Languages, </booktitle> <pages> pages 151-162, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Likewise, the template repository [52], used to minimize the number of redundant instantiations of templates automatically, depends on global information. Many analyses, and in particular alias and type analysis, require information about the whole program [40, 55, 45], however summarization techniques exist <ref> [3] </ref> which can enable separate compilation. C++ addresses this problem by summarizing and importing parts of the program in header files and by compiling specialized versions of classes and functions (template instantiations) at link time [52].
Reference: [4] <author> Gerald Baumgarter and Vince F. Russo. </author> <title> Signatures: A language extension for improving type abstraction and subtype polymorphism in C++. </title> <journal> Software Practice and Experience, </journal> <volume> 25(8) </volume> <pages> 863-889, </pages> <month> August </month> <year> 1995. </year>
Reference-contexts: Second, the compiler can no longer inline member functions since they may differ between the different actual classes. 1 The type system may impose restrictions, requiring a common base class (declared type), template or signature <ref> [4] </ref>. 1 We present an automatic interprocedural compilation framework based on interprocedural analysis and transformation which breaks through encapsulation and automatically builds specialized versions of polymorphic abstractions. Thus we can produce implementation of object-oriented programs using high level abstractions which are as efficient as their procedural equivalents.
Reference: [5] <author> Brad Calder and Dirk Grunwald. </author> <title> Reducing indirect function call overhead in C++ programs. </title> <booktitle> In Twenty-first Symposium on Principles of Programming Languages, </booktitle> <pages> pages 397-408. </pages> <booktitle> ACM SIGPLAN, </booktitle> <year> 1994. </year>
Reference-contexts: Data dependent control flow complicates inlining, increases the cost of function calls and decreases the precision of interprocedural analysis. Inlining, if it can be done at all, must be done conditionally, based on the class of the target object <ref> [10, 27, 5] </ref>. Function calls are more expensive since they require a set of 2 conditionals [28], or an indirect function call [52]. <p> We discussed its use in the removal of dynamic dispatch in [42]. Using a simple analysis, which determines that a virtual function is never redefined, virtual functions can be statically bound at link time <ref> [5, 22] </ref>. However, inlining and optimization at link time requires decompilation techniques [35, 37]. Moreover, some transformations are difficult or impossible at this level. <p> For C++, analysis that can determine the types of pointers [40] has been undertaken based on pointer alias analysis technology [34]. The resulting information can be used to statically bind virtual functions. The interprocedural call graph produced by our flow analysis should enhance these results. Likewise, Calder and Grunwald <ref> [5] </ref> also showed that relatively simple analysis can be used to statically bind many virtual functions. They propose using runtime checks (if conversion) to select 13 the appropriate virtual function at the call site and even inlining, but do not present implementation results.
Reference: [6] <author> Brad Calder, Dirk Grunwald, and Benjamin Zorn. </author> <title> Quantifying differences between C and C++ programs. </title> <type> Technical Report CU-CS-698-94, </type> <institution> University of Colorado, Boulder, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: OO programs tend to have smaller functions, more data dependent control flow, and more potential aliases than procedural programs <ref> [27, 6] </ref>. These features can decrease performance, and their effects compound. The increased data dependence of control flow means that more of the function calls will require indirection (virtual function calls). <p> Using inheritance, the programmer partitions the program into functions representing a general solution and a set of variation points. These variation points are likewise delimited by function boundaries. The effects of object-orientation on program characteristics have been confirmed empirically for C++ and C. In one study, Calder et al. <ref> [6] </ref> found that the instructions to invocation ratio for C++ was less than half that of C (48.7 vs. 152.8). Moreover, the basic block size for C++ was slightly smaller than that of C. <p> The cloning phase uses static estimation [54] and a set of optimization criteria to determine which specific instances of general polymorphic classes and function to create. The specialization phase optimizes classes by constructing new dispatch tables, unboxing and specializing functions by statically binding and `if conversion' <ref> [7, 28, 6] </ref> of virtual function calls.
Reference: [7] <author> C. Chambers and D. Ungar. </author> <title> Customization: Optimizing compiler technology for Self, a dynamically-typed object-oriented programming language. </title> <booktitle> In Proceedings of SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 146-60, </pages> <year> 1989. </year>
Reference-contexts: The cloning phase uses static estimation [54] and a set of optimization criteria to determine which specific instances of general polymorphic classes and function to create. The specialization phase optimizes classes by constructing new dispatch tables, unboxing and specializing functions by statically binding and `if conversion' <ref> [7, 28, 6] </ref> of virtual function calls. <p> Cloning and specialization have been studied in the context of FORTRAN by Cooper [17] and Hall [24, 25]. In the context of object-oriented programs, customization <ref> [7] </ref> by Chambers and Ungar and later specialization [18] by Dean, Chambers and Grove have addressed the problem of selecting versions of functions to duplicate based on the classes of the functions arguments. <p> Self bound-checks arrays, produces BigNums when small integer operations overflow, and provides full source level debugging of optimized code. Nevertheless, our inlining system in similar to <ref> [7, 8, 10, 29, 27] </ref> in the use of class information and specialized function versions.
Reference: [8] <author> C. Chambers and D. Ungar. </author> <title> Iterative type analysis and extended message splitting. </title> <booktitle> In Proceedings of the SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 150-60, </pages> <year> 1990. </year> <month> 14 </month>
Reference-contexts: These are addressed with standard low level optimizations. 3.5.1 Inlining We inline based on heuristics using a combination of static estimation [54] and size constraints to remove the cost of crossing procedure boundaries. The effect of splitting <ref> [8] </ref> which preserves the information obtained by runtime type or function pointer checks within functions, can be obtained by merging checks with identical 7 conditions [44]. <p> Self bound-checks arrays, produces BigNums when small integer operations overflow, and provides full source level debugging of optimized code. Nevertheless, our inlining system in similar to <ref> [7, 8, 10, 29, 27] </ref> in the use of class information and specialized function versions.
Reference: [9] <author> C. Chambers, D. Ungar, and E. Lee. </author> <title> An efficient implementation of Self, a dynamically-typed object-oriented language based on prototypes. </title> <booktitle> In OOPSLA '89 Conference Proceedings, </booktitle> <pages> pages 49-70, </pages> <month> July </month> <year> 1989. </year>
Reference-contexts: That is, the dispatch is converted into a set of conditioned statically bound calls where the conditions test either the class of the target object or the virtual function index of a virtual function pointer <ref> [9] </ref>. In later phases, these statically bound calls can be inlined. For our example, the specialized classes Array2D (int) and Array2D (float) are created with the knowledge of the types of inner, outer and the array elements.
Reference: [10] <author> Craig Chambers. </author> <title> The Design and Implementation of the Self Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, </institution> <address> CA, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: Data dependent control flow complicates inlining, increases the cost of function calls and decreases the precision of interprocedural analysis. Inlining, if it can be done at all, must be done conditionally, based on the class of the target object <ref> [10, 27, 5] </ref>. Function calls are more expensive since they require a set of 2 conditionals [28], or an indirect function call [52]. <p> However, such a high level approach has implementation consequences. Local translations, such as those undertaken for hybrid languages, are sufficient only to produce inefficient code. Differentiating primitive types and invoking dynamically bound functions at run time can be expensive, requiring more aggressive techniques <ref> [10, 27] </ref>. Finally, since every function call is nominally virtual and every reference nominally polymorphic, pure object-oriented languages represent a "worst case" for a compiler. 2.6 Basis of Comparison We use a pure object-oriented languages as a basis for evaluating the effectiveness of the compilation framework. <p> The Stanford Integer Benchmarks, Richards and Delta Blue were used to evaluate the Self language by Chambers <ref> [10] </ref> and later by Holzle [27]. The Stanford Integer Benchmarks are small procedural codes. The CA versions use encapsulated objects for the primary data structures, but otherwise follow the C code structure. <p> Self bound-checks arrays, produces BigNums when small integer operations overflow, and provides full source level debugging of optimized code. Nevertheless, our inlining system in similar to <ref> [7, 8, 10, 29, 27] </ref> in the use of class information and specialized function versions.
Reference: [11] <author> A. A. Chien, U. S. Reddy, J. Plevyak, and J. Dolby. </author> <title> ICC++ a C++ dialect for high performance parallel computing. </title> <booktitle> In Proceedings of the 2nd International Symposium on Object Technologies for Advanced Software. </booktitle> <publisher> Springer-Verlag, LNCS 742, </publisher> <year> 1996. </year>
Reference-contexts: This framework is implemented in and our experiments were conducted using the Concert [12] compiler to which we have recently added a front end for a C++ dialect (ICC++ <ref> [11] </ref>). We intend to use this platform to continue the evaluation of automatic interprocedural optimization. 7 Acknowledgments We thank Vijay Karamcheti, Julian Dolby, Xingbin Zhang and the other members of the Concert project for their work on the Concert System.
Reference: [12] <author> Andrew Chien, Vijay Karamcheti, and John Plevyak. </author> <title> The Concert system compiler and runtime support for efficient fine-grained concurrent object-oriented programs. </title> <type> Technical Report UIUCDCS-R-93-1815, </type> <institution> Department of Computer Science, University of Illinois, Urbana, Illinois, </institution> <month> June </month> <year> 1993. </year>
Reference-contexts: With these optimizations, matrix multiply of multi-dimensional arrays in CA is as fast as C (see Section 4), even though the array operations are abstracted and ostensibly require much more work. 3.6 Context This optimization framework is embodied in the Concert <ref> [12] </ref> retargetable compiler for concurrent object-oriented languages which currently supports both Concurrent Aggregates (CA) and ICC++ (a parallel dialect of C++). In this paper we are concerned only with the sequential subset of CA. <p> We have shown that this framework applied to a dynamically-typed pure object-oriented language can improve performance up to 6 times over C++. This framework is implemented in and our experiments were conducted using the Concert <ref> [12] </ref> compiler to which we have recently added a front end for a C++ dialect (ICC++ [11]).
Reference: [13] <author> Andrew A. Chien. </author> <title> Concurrent aggregates: Using multiple-access data abstractions to manage complexity in concurrent programs. </title> <booktitle> In In Proceedings of the Workshop on Object-Based Concurrent Programming at OOPSLA '90., 1990. Appeared in OOPS Messenger, </booktitle> <volume> Volume 2, Number 2, </volume> <month> April </month> <year> 1991. </year>
Reference-contexts: The benchmarks were translated from C and C++ into the sequential subset of Concurrent Aggregates (CA) <ref> [14, 13, 15] </ref>. CA is a simple object-oriented language resembling Smalltalk with Lisp syntax.
Reference: [14] <author> Andrew A. Chien. </author> <title> Concurrent Aggregates: Supporting Modularity in Massively-Parallel Programs. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1993. </year>
Reference-contexts: The benchmarks were translated from C and C++ into the sequential subset of Concurrent Aggregates (CA) <ref> [14, 13, 15] </ref>. CA is a simple object-oriented language resembling Smalltalk with Lisp syntax.
Reference: [15] <author> Andrew A. Chien, Vijay Karamcheti, John Plevyak, and Xingbin Zhang. </author> <title> Concurrent Aggregates language report 2.0. </title> <note> Available via anonymous ftp from cs.uiuc.edu in /pub/csag or from http://www-csag.cs.uiuc.edu/, September 1993. </note>
Reference-contexts: The benchmarks were translated from C and C++ into the sequential subset of Concurrent Aggregates (CA) <ref> [14, 13, 15] </ref>. CA is a simple object-oriented language resembling Smalltalk with Lisp syntax.
Reference: [16] <editor> W. Clinger and J. Rees (editors). </editor> <title> Revised 4 report on the algorithmic lanuguage scheme. </title> <booktitle> ACM Lisp Pointers IV, </booktitle> <month> July-September </month> <year> 1991. </year>
Reference-contexts: However, these features are not unique to object-orientation. For example, in Smalltalk and Self if an addition of two small integers causes an overflow, the result is a BigNum. Such systems are part of Scheme <ref> [16] </ref> and Common Lisp [32]. Likewise, array bounds and null pointer checks are part of the Pascal/Modula family.
Reference: [17] <author> K. Cooper, K. Kennedy, and L. Torczon. </author> <title> The impact of interprocedural analysis and optimization in the R n environment. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 8(4) </volume> <pages> 491-523, </pages> <month> October </month> <year> 1986. </year>
Reference-contexts: In contrast, our analysis [41] is flow sensitive with respect to both the classes of function arguments and the classes of member variables of data structures. Cloning and specialization have been studied in the context of FORTRAN by Cooper <ref> [17] </ref> and Hall [24, 25]. In the context of object-oriented programs, customization [7] by Chambers and Ungar and later specialization [18] by Dean, Chambers and Grove have addressed the problem of selecting versions of functions to duplicate based on the classes of the functions arguments.
Reference: [18] <author> Jeffrey Dean, Craig Chambers, and David Grove. </author> <title> Selective specialization for object-oriented languages. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 93-102, </pages> <year> 1995. </year>
Reference-contexts: Cloning and specialization have been studied in the context of FORTRAN by Cooper [17] and Hall [24, 25]. In the context of object-oriented programs, customization [7] by Chambers and Ungar and later specialization <ref> [18] </ref> by Dean, Chambers and Grove have addressed the problem of selecting versions of functions to duplicate based on the classes of the functions arguments. Their decisions have been based on the classes of target objects, class hierarchy analysis [19] and/or profiling information.
Reference: [19] <author> Jeffrey Dean, Dave Grove, and Craig Chambers. </author> <title> Optimization of object-oriented programs using static class hierarchy analysis. </title> <type> Technical Report TR 94-12-01, </type> <institution> Department of Computer Science and Engineering, University of Washington, </institution> <address> Seattle, Washington, </address> <month> December </month> <year> 1994. </year>
Reference-contexts: Their decisions have been based on the classes of target objects, class hierarchy analysis <ref> [19] </ref> and/or profiling information. Our cloning and specialization technique is based on global flow analysis and includes specialization of data structures (classes). We discussed its use in the removal of dynamic dispatch in [42].
Reference: [20] <author> Jack J. Dongarra, Roldan Pozo, and David W. Walker. </author> <title> LAPACK++: A design overview of object-oriented extensions for high performance linear algebra. </title> <booktitle> In Proceedings of Supercomputing'93, </booktitle> <pages> pages 162-171, </pages> <year> 1993. </year>
Reference-contexts: The Array2D template encapsulates a contiguously allocated two dimensional array object. The function at () accesses an element of that array by the standard technique of linearizing the indices <ref> [20] </ref>. In isolation, this member function requires a memory access to retrieve inner. Inlined into the for loop below, the load of inner cannot be removed from the loop unless it can show that inner cannot be changed by compute.
Reference: [21] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Moreover, the programmer is not required to alter the program expression in order to obtain this efficiency. For a set of standard procedural benchmarks, we show that a dynamically-typed pure object-oriented language (see Section 2.5) can match the efficiency of C [33]. In hybrid languages, like C++ <ref> [21] </ref>, programmers can summarize interprocedu-ral information and direct optimization through inline hints, careful placement of virtual declarations, and the use of derivation with templates [52]. <p> As a result, C++ preserves C data types and call mechanisms and can be implemented by locally mapping object-oriented features to the underlying procedural programming model. For example, the messages of Smalltalk [23] can be implemented as indirect calls through a virtual function table <ref> [21] </ref>. By annotating the program with information about where to use object-oriented features, the programmer provides interprocedural information to the compiler and directs optimization. For example, non-virtual member functions cannot be overridden, enabling them to be called without indirection.
Reference: [22] <author> Mary F. Fernandez. </author> <title> Simple and effective link-time optimization of modula-3 programs. </title> <booktitle> In Proceedings of the 1995 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 103-115, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: We discussed its use in the removal of dynamic dispatch in [42]. Using a simple analysis, which determines that a virtual function is never redefined, virtual functions can be statically bound at link time <ref> [5, 22] </ref>. However, inlining and optimization at link time requires decompilation techniques [35, 37]. Moreover, some transformations are difficult or impossible at this level.
Reference: [23] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The language and its implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: As a result, C++ preserves C data types and call mechanisms and can be implemented by locally mapping object-oriented features to the underlying procedural programming model. For example, the messages of Smalltalk <ref> [23] </ref> can be implemented as indirect calls through a virtual function table [21]. By annotating the program with information about where to use object-oriented features, the programmer provides interprocedural information to the compiler and directs optimization. <p> For example, non-virtual member functions cannot be overridden, enabling them to be called without indirection. Similarly, inline indicates that a particular transformation would likely be profitable. 3 2.5 Dynamically-typed Pure OOPLs Dynamically-typed pure object-oriented languages <ref> [23, 53] </ref> eliminate some of the distinctions made in hybrid languages. They do not distinguish between objects and primitive types or virtual and non-virtual functions. They have no type declarations, prototypes, inline hints or templates. They do not require or enable programmers to choose implementation mechanisms. <p> In CA, classes simply list their instance variables and superclass; methods the class they are on, their arguments and an expression to evaluate; and expressions are either a message send or a basic control structure 2 (see of primitives <ref> [23] </ref> and can be overridden. Moreover, in CA, like Self [53], accessor methods must be used to manipulate instance variables. <p> of compilation are: * Analysis Context sensitive interprocedural flow analysis * Cloning Selection of classes and functions to be specialized * Specialization Creation of class and functions with specialized information * Optimization Enabled standard optimizations 2 These structures are not strictly necessary; see Section 5.1 for a discussion of blocks <ref> [23] </ref>. 4 The analysis phase constructs an interprocedural call graph which is used for other analyses and general interprocedural optimizations (e.g. constant propagation). The cloning phase uses static estimation [54] and a set of optimization criteria to determine which specific instances of general polymorphic classes and function to create. <p> In the case of Delta Blue, this difference is attributable to many calls to small functions. For example, in object-oriented fashion, Delta Blue uses a general List container object with a member function which applies a function pointer (or selector <ref> [23] </ref>) across its elements (e.g. do: in Smalltalk or map in Scheme). The CA compiler clones and inlines both call sites, turning this into a simple C style loop containing operations directly on the elements, while the C++ compiler does not. <p> In particular, we chose to concentrate on the most uniquely object-oriented feature: virtual functions (also called late binding or dynamic dispatch) on polymorphic variables. Other features common in pure object-oriented languages include variations on generic arithmetic, run time error checking and blocks <ref> [23, 53] </ref>. However, these features are not unique to object-orientation. For example, in Smalltalk and Self if an addition of two small integers causes an overflow, the result is a BigNum. Such systems are part of Scheme [16] and Common Lisp [32].
Reference: [24] <author> M. W. Hall. </author> <title> Managing Interprocedural Optimization. </title> <type> PhD thesis, </type> <institution> Rice University, </institution> <year> 1991. </year>
Reference-contexts: In contrast, our analysis [41] is flow sensitive with respect to both the classes of function arguments and the classes of member variables of data structures. Cloning and specialization have been studied in the context of FORTRAN by Cooper [17] and Hall <ref> [24, 25] </ref>. In the context of object-oriented programs, customization [7] by Chambers and Ungar and later specialization [18] by Dean, Chambers and Grove have addressed the problem of selecting versions of functions to duplicate based on the classes of the functions arguments.
Reference: [25] <author> Mary W. Hall, John M. Mellor-Crummey, Alan Clarle, and Rene G. Rodr iguez. FIAT: </author> <title> A framework for inter-procedural analysis and transformation. </title> <booktitle> In Proceedings of the Sixth Workshop for Languages and Compilers for Parallel Machines, </booktitle> <pages> pages 522-545, </pages> <month> August </month> <year> 1993. </year>
Reference-contexts: In contrast, our analysis [41] is flow sensitive with respect to both the classes of function arguments and the classes of member variables of data structures. Cloning and specialization have been studied in the context of FORTRAN by Cooper [17] and Hall <ref> [24, 25] </ref>. In the context of object-oriented programs, customization [7] by Chambers and Ungar and later specialization [18] by Dean, Chambers and Grove have addressed the problem of selecting versions of functions to duplicate based on the classes of the functions arguments.
Reference: [26] <author> Robert Harper and Greg Morrisett. </author> <title> Compiling polymorphism using intensional type analysis. </title> <booktitle> In Twenty-second Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 130-141. </pages> <booktitle> ACM SIGPLAN, </booktitle> <year> 1995. </year>
Reference-contexts: Functions are specialized with respect to the types of their arguments and local variables, and wrapper functions are constructed which map between boxed and unboxed representations for arguments when a dynamic dispatch is required to functions with incompatible specialized arguments <ref> [47, 26, 36] </ref>. The interprocedural call graph is then updated with respect to the realized call graph. Since it was generated during analysis over contexts, the edges for a function are simply those of all its contexts.
Reference: [27] <author> Urs Holzle. </author> <title> Adaptive Optimization for SELF: Reconciling High Performance with Exporatory Programming. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, </institution> <address> CA, </address> <month> August </month> <year> 1994. </year>
Reference-contexts: OO programs tend to have smaller functions, more data dependent control flow, and more potential aliases than procedural programs <ref> [27, 6] </ref>. These features can decrease performance, and their effects compound. The increased data dependence of control flow means that more of the function calls will require indirection (virtual function calls). <p> Data dependent control flow complicates inlining, increases the cost of function calls and decreases the precision of interprocedural analysis. Inlining, if it can be done at all, must be done conditionally, based on the class of the target object <ref> [10, 27, 5] </ref>. Function calls are more expensive since they require a set of 2 conditionals [28], or an indirect function call [52]. <p> However, such a high level approach has implementation consequences. Local translations, such as those undertaken for hybrid languages, are sufficient only to produce inefficient code. Differentiating primitive types and invoking dynamically bound functions at run time can be expensive, requiring more aggressive techniques <ref> [10, 27] </ref>. Finally, since every function call is nominally virtual and every reference nominally polymorphic, pure object-oriented languages represent a "worst case" for a compiler. 2.6 Basis of Comparison We use a pure object-oriented languages as a basis for evaluating the effectiveness of the compilation framework. <p> The Stanford Integer Benchmarks, Richards and Delta Blue were used to evaluate the Self language by Chambers [10] and later by Holzle <ref> [27] </ref>. The Stanford Integer Benchmarks are small procedural codes. The CA versions use encapsulated objects for the primary data structures, but otherwise follow the C code structure. <p> Two different test cases are provided for Delta Blue, Chain which builds a chain of Equal constraints, and Projection which builds two sets of variables related by ScaleOffset constraints. The C++ codes are annotated by declaring functions virtual only when necessary <ref> [27] </ref>, including inline accessors, and, in Delta Blue, by the use of a List template. 4.2 Methodology We compare the performance of CA codes translated from the original sources. 4 Our compiler uses the GNU compiler [49] as a back end, enabled us to control for instruction selection and scheduling differences <p> Self bound-checks arrays, produces BigNums when small integer operations overflow, and provides full source level debugging of optimized code. Nevertheless, our inlining system in similar to <ref> [7, 8, 10, 29, 27] </ref> in the use of class information and specialized function versions.
Reference: [28] <author> Urs Holzle, Craig Chambers, and David Ungar. </author> <title> Optimizing dynamically-typed object-oriented languages iwth polymorphic inline caches. </title> <booktitle> In ECOOP'91 Conference Proceedings. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> Lecture Notes in Computer Science 512. </note>
Reference-contexts: Inlining, if it can be done at all, must be done conditionally, based on the class of the target object [10, 27, 5]. Function calls are more expensive since they require a set of 2 conditionals <ref> [28] </ref>, or an indirect function call [52]. Finally, since data dependence causes interprocedural control flow to be ambiguous, analyses which depend on such information become less precise. 2.3 Aliasing Since objects may be referenced by pointer, their instance (member) variables are potentially aliased. <p> The cloning phase uses static estimation [54] and a set of optimization criteria to determine which specific instances of general polymorphic classes and function to create. The specialization phase optimizes classes by constructing new dispatch tables, unboxing and specializing functions by statically binding and `if conversion' <ref> [7, 28, 6] </ref> of virtual function calls. <p> Nevertheless, our inlining system in similar to [7, 8, 10, 29, 27] in the use of class information and specialized function versions. However, their speculative inlining information is derived from the local prediction and preserving of information, polymorphic inline caches <ref> [28] </ref>, or profiling. 6 Summary and Future Work Object-oriented programs differ from procedural ones, requiring interprocedural optimization for efficiency. The compiler must be able to break through the layers of abstraction in the program specification to build an efficient implementation.
Reference: [29] <author> Urs Holzle and David Ungar. </author> <title> Optimizing dynamically-dispatched calls with run-time type feedback. </title> <booktitle> In Proceedings of the 1994 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 326-336, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Self bound-checks arrays, produces BigNums when small integer operations overflow, and provides full source level debugging of optimized code. Nevertheless, our inlining system in similar to <ref> [7, 8, 10, 29, 27] </ref> in the use of class information and specialized function versions.
Reference: [30] <institution> International Organization for Standardization. </institution> <note> Ada 95 Reference Manual, version 6.0 edition, Dec 1994. 15 </note>
Reference-contexts: The other significant property of object-oriented programs is an emphasis on code reuse. Abstractions are described by difference (inheritance) or by parameterization (templates [51] or generics <ref> [30] </ref>). The actual arguments to a function can be of any class which supports the operations used by the function. 1 This polymorphism enables a single function to operate on many types of data by using the abstraction. This presents two problems for the compiler.
Reference: [31] <author> Suresh Jagannathan and Stephen Weeks. </author> <title> A unified treatment of flow analysis in higher-order languages. </title> <booktitle> In Twenty-second Symposium on Principles of Programming Languages, </booktitle> <pages> pages 393-407. </pages> <booktitle> ACM SIGPLAN, </booktitle> <year> 1995. </year>
Reference-contexts: be encoded using the blocks of Smalltalk and Self, which are essentially the anonymous closures of Lisp and other functional languages. 5.2 Related Work Many researchers have applied interprocedural flow sensitive analysis to determine type and/or class information from Shivers [48] through Stefanescu and Zhoi [50] and Jagannathan and Weeks <ref> [31] </ref>. In terms of object-oriented languages, the constraint based approach [39, 38] has been most recently extended to greater degrees of flow sensitivity by Agesen [1, 2] using the Cartesian product of the classes of function arguments.
Reference: [32] <author> Guy L. Steele Jr. </author> <title> Common LISP: The Language. </title> <note> Digital Press, second edition, </note> <year> 1990. </year>
Reference-contexts: However, these features are not unique to object-orientation. For example, in Smalltalk and Self if an addition of two small integers causes an overflow, the result is a BigNum. Such systems are part of Scheme [16] and Common Lisp <ref> [32] </ref>. Likewise, array bounds and null pointer checks are part of the Pascal/Modula family.
Reference: [33] <author> Brian W. Kernighan and Dennis M. Ritchie. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1978. </year>
Reference-contexts: Moreover, the programmer is not required to alter the program expression in order to obtain this efficiency. For a set of standard procedural benchmarks, we show that a dynamically-typed pure object-oriented language (see Section 2.5) can match the efficiency of C <ref> [33] </ref>. In hybrid languages, like C++ [21], programmers can summarize interprocedu-ral information and direct optimization through inline hints, careful placement of virtual declarations, and the use of derivation with templates [52].
Reference: [34] <author> W. Landi and B. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In ACM SIGPLAN Symposium on Programming Language Design and Implementation, </booktitle> <pages> pages 235-249, </pages> <year> 1992. </year>
Reference-contexts: Interprocedural alias analysis [55, 45] can determine when a member variable may be accessed through a pointer or in a called function. For C++, analysis that can determine the types of pointers [40] has been undertaken based on pointer alias analysis technology <ref> [34] </ref>. The resulting information can be used to statically bind virtual functions. The interprocedural call graph produced by our flow analysis should enhance these results. Likewise, Calder and Grunwald [5] also showed that relatively simple analysis can be used to statically bind many virtual functions.
Reference: [35] <author> James R. Larus and Eric Schnarr. Eel: </author> <title> Machine-independent executable editing. </title> <booktitle> In Proceedings of the 1995 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 291-300, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: We discussed its use in the removal of dynamic dispatch in [42]. Using a simple analysis, which determines that a virtual function is never redefined, virtual functions can be statically bound at link time [5, 22]. However, inlining and optimization at link time requires decompilation techniques <ref> [35, 37] </ref>. Moreover, some transformations are difficult or impossible at this level.
Reference: [36] <author> Xavier Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Proc. 19th symp. Principles of Programming Languages, </booktitle> <pages> pages 177-188. </pages> <publisher> ACM press, </publisher> <year> 1992. </year>
Reference-contexts: Functions are specialized with respect to the types of their arguments and local variables, and wrapper functions are constructed which map between boxed and unboxed representations for arguments when a dynamic dispatch is required to functions with incompatible specialized arguments <ref> [47, 26, 36] </ref>. The interprocedural call graph is then updated with respect to the realized call graph. Since it was generated during analysis over contexts, the edges for a function are simply those of all its contexts.
Reference: [37] <institution> Digital Western Research Laboratory Om Project. </institution> <note> http://www.research.digital.com/wrl/projects/om/om.html, October 1995. </note>
Reference-contexts: We discussed its use in the removal of dynamic dispatch in [42]. Using a simple analysis, which determines that a virtual function is never redefined, virtual functions can be statically bound at link time [5, 22]. However, inlining and optimization at link time requires decompilation techniques <ref> [35, 37] </ref>. Moreover, some transformations are difficult or impossible at this level.
Reference: [38] <author> N. Oxhtj, J. Palsberg, and M. Schwartzbach. </author> <title> Making type inference practical. </title> <booktitle> In Proceedings of OOPSLA '92, </booktitle> <year> 1992. </year>
Reference-contexts: In terms of object-oriented languages, the constraint based approach <ref> [39, 38] </ref> has been most recently extended to greater degrees of flow sensitivity by Agesen [1, 2] using the Cartesian product of the classes of function arguments.
Reference: [39] <author> J. Palsberg and M. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proceedings of OOPSLA '91, </booktitle> <pages> pages 146-61, </pages> <year> 1991. </year>
Reference-contexts: These parameterizing classes and functions may themselves be parameterized, enabling deep and/or recursive call paths or data structures to be analyzed. The technique used is iterative context sensitive flow analysis [41], which operates by constructing an approximation of the interprocedural data flow graph by abstract interpretation of function dispatch <ref> [39] </ref>, and iteratively extending the context sensitivity. The result of analysis is context sensitive information where a context is given in terms of call paths for functions and creation points for objects. <p> In terms of object-oriented languages, the constraint based approach <ref> [39, 38] </ref> has been most recently extended to greater degrees of flow sensitivity by Agesen [1, 2] using the Cartesian product of the classes of function arguments.
Reference: [40] <author> Hemant D. Pande and Barbara G. Ryder. </author> <title> Static type determination and aliasing in c++. </title> <type> Technical Report LCSR-TR-250, </type> <institution> Laboratory of Computer Science Research, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: Likewise, the template repository [52], used to minimize the number of redundant instantiations of templates automatically, depends on global information. Many analyses, and in particular alias and type analysis, require information about the whole program <ref> [40, 55, 45] </ref>, however summarization techniques exist [3] which can enable separate compilation. C++ addresses this problem by summarizing and importing parts of the program in header files and by compiling specialized versions of classes and functions (template instantiations) at link time [52]. <p> Interprocedural alias analysis [55, 45] can determine when a member variable may be accessed through a pointer or in a called function. For C++, analysis that can determine the types of pointers <ref> [40] </ref> has been undertaken based on pointer alias analysis technology [34]. The resulting information can be used to statically bind virtual functions. The interprocedural call graph produced by our flow analysis should enhance these results.
Reference: [41] <author> John Plevyak and Andrew A. Chien. </author> <title> Precise concrete type inference of object-oriented programs. </title> <booktitle> In Proceedings of OOPSLA'94, Object-Oriented Programming Systems, Languages and Architectures, </booktitle> <pages> pages 324-340, </pages> <year> 1994. </year>
Reference-contexts: These parameterizing classes and functions may themselves be parameterized, enabling deep and/or recursive call paths or data structures to be analyzed. The technique used is iterative context sensitive flow analysis <ref> [41] </ref>, which operates by constructing an approximation of the interprocedural data flow graph by abstract interpretation of function dispatch [39], and iteratively extending the context sensitivity. <p> In terms of object-oriented languages, the constraint based approach [39, 38] has been most recently extended to greater degrees of flow sensitivity by Agesen [1, 2] using the Cartesian product of the classes of function arguments. In contrast, our analysis <ref> [41] </ref> is flow sensitive with respect to both the classes of function arguments and the classes of member variables of data structures. Cloning and specialization have been studied in the context of FORTRAN by Cooper [17] and Hall [24, 25].
Reference: [42] <author> John Plevyak and Andrew A. Chien. </author> <title> Type directed cloning for object-oriented programs. </title> <booktitle> In Proceedings of the Workshop for Languages and Compilers for Parallel Computing, </booktitle> <pages> pages 566-580, </pages> <year> 1995. </year>
Reference-contexts: In order to ensure that the selected functions and classes can be created and specialized, other functions and classes may have to be cloned. For example, in Figure 3, a specialization of innerproduct () induces a specialization of mm (). An iterative algorithm <ref> [42] </ref> is used to determine which additional functions and classes should be specialized. Function specialization induces specialization of the caller when the calling context is required to determine which specialized functions to call. <p> Since many small virtual function call bodies contain only a few instructions, and since the interprocedural call graph can be used to determine when a function is not called by anyone and eliminate it, inlining need not result in a large code size increase <ref> [42] </ref>. <p> Their decisions have been based on the classes of target objects, class hierarchy analysis [19] and/or profiling information. Our cloning and specialization technique is based on global flow analysis and includes specialization of data structures (classes). We discussed its use in the removal of dynamic dispatch in <ref> [42] </ref>. Using a simple analysis, which determines that a virtual function is never redefined, virtual functions can be statically bound at link time [5, 22]. However, inlining and optimization at link time requires decompilation techniques [35, 37]. Moreover, some transformations are difficult or impossible at this level.
Reference: [43] <author> John Plevyak, Vijay Karamcheti, Xingbin Zhang, and Andrew Chien. </author> <title> A hybrid execution model for fine-grained languages on distributed memory multicomputers. </title> <booktitle> In Proceedings of Supercomputing'95, </booktitle> <year> 1995. </year>
Reference-contexts: In this paper we are concerned only with the sequential subset of CA. Readers interested in transformations specific to concurrent languages and parallel implementations are directed toward <ref> [44, 43] </ref>. 4 Results We use a standard benchmark suite to evaluate and compare the performance of CA, C and C++. The Stanford Integer Benchmarks, Richards and Delta Blue were used to evaluate the Self language by Chambers [10] and later by Holzle [27].
Reference: [44] <author> John Plevyak, Xingbin Zhang, and Andrew A. Chien. </author> <title> Obtaining sequential efficiency in concurrent object-oriented programs. </title> <booktitle> In Proceedings of the ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 311-321, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: The effect of splitting [8] which preserves the information obtained by runtime type or function pointer checks within functions, can be obtained by merging checks with identical 7 conditions <ref> [44] </ref>. Since many small virtual function call bodies contain only a few instructions, and since the interprocedural call graph can be used to determine when a function is not called by anyone and eliminate it, inlining need not result in a large code size increase [42]. <p> In this paper we are concerned only with the sequential subset of CA. Readers interested in transformations specific to concurrent languages and parallel implementations are directed toward <ref> [44, 43] </ref>. 4 Results We use a standard benchmark suite to evaluate and compare the performance of CA, C and C++. The Stanford Integer Benchmarks, Richards and Delta Blue were used to evaluate the Self language by Chambers [10] and later by Holzle [27].
Reference: [45] <author> Erik Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the 1995 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Likewise, the template repository [52], used to minimize the number of redundant instantiations of templates automatically, depends on global information. Many analyses, and in particular alias and type analysis, require information about the whole program <ref> [40, 55, 45] </ref>, however summarization techniques exist [3] which can enable separate compilation. C++ addresses this problem by summarizing and importing parts of the program in header files and by compiling specialized versions of classes and functions (template instantiations) at link time [52]. <p> For instance, the semantic connection has been lost between the (link time constant) size and offsets within a data structure and the functions which operate on it, preventing high level data structure transformations like inlining of objects which the C++ programmer can achieve through templates. Interprocedural alias analysis <ref> [55, 45] </ref> can determine when a member variable may be accessed through a pointer or in a called function. For C++, analysis that can determine the types of pointers [40] has been undertaken based on pointer alias analysis technology [34].
Reference: [46] <author> Michael Sannella, John Maloney, Bjorn Freeman-Benson, and Alan Borning. </author> <title> Multi-way versus one-way constraints in user interfaces: Experience with the deltablue algorithm. </title> <journal> Software Practice and Experience, </journal> <volume> 23(5) </volume> <pages> 529-566, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: Richards is an operating system simulator which creates a number of different tasks which are stored in a queue and periodically executed. Delta Blue <ref> [46] </ref> is a constraint solver which builds a network, solves it a number of times and removes the constraints. Two different test cases are provided for Delta Blue, Chain which builds a chain of Equal constraints, and Projection which builds two sets of variables related by ScaleOffset constraints.
Reference: [47] <author> Zhong Shao and Andrew W. Appel. </author> <title> A type-based compiler for standard ML. </title> <booktitle> In SIGPLAN Conference on Programming Language Design and Implement ation, </booktitle> <pages> pages 116-129, </pages> <year> 1995. </year>
Reference-contexts: Functions are specialized with respect to the types of their arguments and local variables, and wrapper functions are constructed which map between boxed and unboxed representations for arguments when a dynamic dispatch is required to functions with incompatible specialized arguments <ref> [47, 26, 36] </ref>. The interprocedural call graph is then updated with respect to the realized call graph. Since it was generated during analysis over contexts, the edges for a function are simply those of all its contexts.
Reference: [48] <author> Olin Shivers. </author> <title> Control-Flow Analysis of Higher-Order Languages. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University Department of Computer Science, </institution> <address> Pittsburgh, PA, </address> <month> May </month> <year> 1991. </year> <note> also CMU-CS-91-145. </note>
Reference-contexts: Finally, all control structures could be encoded using the blocks of Smalltalk and Self, which are essentially the anonymous closures of Lisp and other functional languages. 5.2 Related Work Many researchers have applied interprocedural flow sensitive analysis to determine type and/or class information from Shivers <ref> [48] </ref> through Stefanescu and Zhoi [50] and Jagannathan and Weeks [31]. In terms of object-oriented languages, the constraint based approach [39, 38] has been most recently extended to greater degrees of flow sensitivity by Agesen [1, 2] using the Cartesian product of the classes of function arguments.
Reference: [49] <author> Richard Stallman. </author> <title> The GNU C Compiler. Free Software Foundation, </title> <year> 1991. </year>
Reference-contexts: The C++ codes are annotated by declaring functions virtual only when necessary [27], including inline accessors, and, in Delta Blue, by the use of a List template. 4.2 Methodology We compare the performance of CA codes translated from the original sources. 4 Our compiler uses the GNU compiler <ref> [49] </ref> as a back end, enabled us to control for instruction selection and scheduling differences by using the same version (2.7.1) for both the back end of our compiler and the C and C++ benchmarks. All tests were conducted on an unloaded 75Mhz SPARCStation-20 with Supercache running Solaris 2.4.
Reference: [50] <author> Dan Stefanescu and Yuli Zhou. </author> <title> An equational framework for the flow analysis of higher-order functional programs. </title> <booktitle> In Proceedings of ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 318-327, </pages> <year> 1994. </year>
Reference-contexts: Finally, all control structures could be encoded using the blocks of Smalltalk and Self, which are essentially the anonymous closures of Lisp and other functional languages. 5.2 Related Work Many researchers have applied interprocedural flow sensitive analysis to determine type and/or class information from Shivers [48] through Stefanescu and Zhoi <ref> [50] </ref> and Jagannathan and Weeks [31]. In terms of object-oriented languages, the constraint based approach [39, 38] has been most recently extended to greater degrees of flow sensitivity by Agesen [1, 2] using the Cartesian product of the classes of function arguments.
Reference: [51] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison Wesley, </publisher> <address> second edition, </address> <year> 1991. </year>
Reference-contexts: The other significant property of object-oriented programs is an emphasis on code reuse. Abstractions are described by difference (inheritance) or by parameterization (templates <ref> [51] </ref> or generics [30]). The actual arguments to a function can be of any class which supports the operations used by the function. 1 This polymorphism enables a single function to operate on many types of data by using the abstraction. This presents two problems for the compiler. <p> Consequentially, the object-oriented features are distinguished from procedural features (e.g. in C++ object are different from primitive types and virtual from non-virtual functions <ref> [51] </ref>). As a result, C++ preserves C data types and call mechanisms and can be implemented by locally mapping object-oriented features to the underlying procedural programming model. For example, the messages of Smalltalk [23] can be implemented as indirect calls through a virtual function table [21].
Reference: [52] <author> Bjarne Stroustrup. </author> <title> The Design and Evolution of C++. </title> <address> Addsion-Wesley, </address> <year> 1994. </year>
Reference-contexts: In hybrid languages, like C++ [21], programmers can summarize interprocedu-ral information and direct optimization through inline hints, careful placement of virtual declarations, and the use of derivation with templates <ref> [52] </ref>. For two standard object-oriented benchmarks, we show that the annotations provided by the programmer are not sufficient and that our automatic approach improves performance by up to 6 times over the C++ versions. The remainder of this paper is organized as follows. <p> Inlining, if it can be done at all, must be done conditionally, based on the class of the target object [10, 27, 5]. Function calls are more expensive since they require a set of 2 conditionals [28], or an indirect function call <ref> [52] </ref>. Finally, since data dependence causes interprocedural control flow to be ambiguous, analyses which depend on such information become less precise. 2.3 Aliasing Since objects may be referenced by pointer, their instance (member) variables are potentially aliased. <p> When a function has been so specialized, and is called from a context which requires dynamic dispatch, the virtual function index <ref> [52] </ref> and target object class no longer uniquely determine the function. <p> The necessity for interprocedural optimization for object-oriented programs comes as no surprise. The assumption of interprocedural optimization as a part of C++ implementations is embodied in the inline hints, and the implicit inline hints associated with declaring code in class definitions. Likewise, the template repository <ref> [52] </ref>, used to minimize the number of redundant instantiations of templates automatically, depends on global information. Many analyses, and in particular alias and type analysis, require information about the whole program [40, 55, 45], however summarization techniques exist [3] which can enable separate compilation. <p> C++ addresses this problem by summarizing and importing parts of the program in header files and by compiling specialized versions of classes and functions (template instantiations) at link time <ref> [52] </ref>. Thus, fully automatic interprocedural optimization is the logical extension of current C++ practice. 5.1 Object-Oriented Language Features In this paper, we focus on the additional complexity that object-orientation introduces.
Reference: [53] <author> David Ungar and Randall B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In Proceedings of OOPSLA '87, </booktitle> <pages> pages 227-41. </pages> <booktitle> ACM SIGPLAN, </booktitle> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: For example, non-virtual member functions cannot be overridden, enabling them to be called without indirection. Similarly, inline indicates that a particular transformation would likely be profitable. 3 2.5 Dynamically-typed Pure OOPLs Dynamically-typed pure object-oriented languages <ref> [23, 53] </ref> eliminate some of the distinctions made in hybrid languages. They do not distinguish between objects and primitive types or virtual and non-virtual functions. They have no type declarations, prototypes, inline hints or templates. They do not require or enable programmers to choose implementation mechanisms. <p> In CA, classes simply list their instance variables and superclass; methods the class they are on, their arguments and an expression to evaluate; and expressions are either a message send or a basic control structure 2 (see of primitives [23] and can be overridden. Moreover, in CA, like Self <ref> [53] </ref>, accessor methods must be used to manipulate instance variables. <p> In particular, we chose to concentrate on the most uniquely object-oriented feature: virtual functions (also called late binding or dynamic dispatch) on polymorphic variables. Other features common in pure object-oriented languages include variations on generic arithmetic, run time error checking and blocks <ref> [23, 53] </ref>. However, these features are not unique to object-orientation. For example, in Smalltalk and Self if an addition of two small integers causes an overflow, the result is a BigNum. Such systems are part of Scheme [16] and Common Lisp [32]. <p> Moreover, the application of these techniques to cloning or specialization as yet to be explored. This work most closely resembles that done for the Self language <ref> [53] </ref>. While we obtained better raw speed, the Self language and its integrated program development environment impose substantial restrictions which make direct comparison extremely difficult. Self bound-checks arrays, produces BigNums when small integer operations overflow, and provides full source level debugging of optimized code.
Reference: [54] <author> Tim A. Wagner, Vance Maverick, Susan L. Graham, and Michael A. Harrison. </author> <title> Accurate static estimators for program optimization. </title> <booktitle> In Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 85-96, </pages> <address> Orlando, Florida USA, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: The cloning phase uses static estimation <ref> [54] </ref> and a set of optimization criteria to determine which specific instances of general polymorphic classes and function to create. The specialization phase optimizes classes by constructing new dispatch tables, unboxing and specializing functions by statically binding and `if conversion' [7, 28, 6] of virtual function calls. <p> These are addressed with standard low level optimizations. 3.5.1 Inlining We inline based on heuristics using a combination of static estimation <ref> [54] </ref> and size constraints to remove the cost of crossing procedure boundaries. The effect of splitting [8] which preserves the information obtained by runtime type or function pointer checks within functions, can be obtained by merging checks with identical 7 conditions [44].
Reference: [55] <author> Robert P. Wilson and Monica S. Lam. </author> <title> Efficient context-sensitive pointer analysis for c programs. </title> <booktitle> In Proceedings of the 1995 ACM SIGPLAN Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 1-12, </pages> <month> June </month> <year> 1995. </year> <month> 16 </month>
Reference-contexts: Likewise, the template repository [52], used to minimize the number of redundant instantiations of templates automatically, depends on global information. Many analyses, and in particular alias and type analysis, require information about the whole program <ref> [40, 55, 45] </ref>, however summarization techniques exist [3] which can enable separate compilation. C++ addresses this problem by summarizing and importing parts of the program in header files and by compiling specialized versions of classes and functions (template instantiations) at link time [52]. <p> For instance, the semantic connection has been lost between the (link time constant) size and offsets within a data structure and the functions which operate on it, preventing high level data structure transformations like inlining of objects which the C++ programmer can achieve through templates. Interprocedural alias analysis <ref> [55, 45] </ref> can determine when a member variable may be accessed through a pointer or in a called function. For C++, analysis that can determine the types of pointers [40] has been undertaken based on pointer alias analysis technology [34].
References-found: 55

