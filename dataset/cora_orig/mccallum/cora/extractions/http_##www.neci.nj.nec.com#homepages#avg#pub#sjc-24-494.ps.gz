URL: http://www.neci.nj.nec.com/homepages/avg/pub/sjc-24-494.ps.gz
Refering-URL: http://www.neci.nj.nec.com/homepages/avg/webpub/node2.html
Root-URL: 
Title: Scaling Algorithms for the Shortest Paths Problem  
Author: Andrew V. Goldberg 
Keyword: shortest paths problem, graph theory, networks, scaling.  
Note: AMS(MOS) subject classifications: 68Q20, 68Q25, 68R10, 05C70.  
Date: November 1993  
Address: Stanford, CA, 94305  
Affiliation: Computer Science Department Stanford University  
Abstract: We describe a new method for designing scaling algorithms for the single-source shortest paths problem, and use this method to obtain an O( algorithm for the problem. (Here n and m is the number of nodes and arcs in the input network and N is essentially the absolute value of the most negative arc length, and arc lengths are assumed to be integral.) This improves previous bounds for the problem. The method extends to related problems. 1 Introduction In this paper we study the shortest paths problem where arc lengths can be p
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. E. Bellman. </author> <title> On a Routing Problem. </title> <journal> Quart. Appl. Math., </journal> <volume> 16 </volume> <pages> 87-90, </pages> <year> 1958. </year>
Reference-contexts: Previously known algorithms for the problem are as follows. The classical Bellman-Ford algorithm <ref> [1, 8] </ref> runs in O (nm) time. Our bound is better than this bound for N = o (2 p n ). Scaling algorithms of Gabow [12] and of Gabow and Tarjan [13] are dominated by an assignment subroutine.
Reference: [2] <author> R. G. Bland and D. L. Jensen. </author> <title> On the Computational Behavior of a Polynomial-Time Network Flow Algorithm. </title> <journal> Math. Prog., </journal> <volume> 54 </volume> <pages> 1-41, </pages> <year> 1992. </year>
Reference-contexts: algorithm runs in O ( p nm log N ) time, where n and m are the number of nodes and arcs of the input network, respectively, and the arc costs are at least N . 1 Our approach is related to the cost-scaling approach to the minimum-cost flow problem <ref> [2, 14, 18, 21] </ref>. Previously known algorithms for the problem are as follows. The classical Bellman-Ford algorithm [1, 8] runs in O (nm) time. Our bound is better than this bound for N = o (2 p n ).
Reference: [3] <author> B. V. Cherkassky, A. V. Goldberg, and T. Radzik. </author> <title> Shortest Paths Algorithms: Theory and Experimental Evaluation. </title> <type> Technical Report STAN-CS-93-1480, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1993. </year>
Reference-contexts: Preliminary experiments with the algorithm of this paper, conducted as a part of the experimental study described in <ref> [3] </ref>, suggest that the algorithm is not the best one to use in practice. Although on some problem families the algorithm significantly outperformed the classical methods, it was dominated by the algorithm of [16] on all problem classes studied. The algorithms we discussed scale * by a factor of two.
Reference: [4] <author> T. H. Cormen, C. E. Leiserson, and R. L. Rivest. </author> <title> Introduction to Algorithms. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: the fastest known algorithms, but are somewhat simpler. 2 Preliminaries The input to the single-source shortest paths problem is (G; s; l), where G = (V; E) is a directed graph, l : E ! R is a length function, and s 2 V is the source node. (See e.g. <ref> [4, 23] </ref>.) The goal is to find shortest paths distances from s to all other nodes of G or to find a negative length cycle in G. If G has a negative length cycle, we say that the problem is infeasible. We assume that the length function is integral.
Reference: [5] <author> R. B. Dial. </author> <title> Algorithm 360: Shortest Path Forest with Topological Ordering. </title> <journal> Comm. ACM, </journal> <volume> 12 </volume> <pages> 632-633, </pages> <year> 1969. </year>
Reference-contexts: Second, we implement the search for the nodes reachable from w i 's in the admissible graph in a way similar to Dial's implementation <ref> [5] </ref> of Dijkstra's algorithm. 4 Our implementation uses a priority queue that holds items with integer key values in the range [0; : : : ; 2n]; the amortized cost of the priority queue operations is constant. <p> The algorithm performance is likely to be better than the above worst-case bound suggests. 9 Chain Elimination Using Dijkstra's Algorithm In this section we show yet another implementation of Eliminate-Chain. This implementation uses Dial's implementation of Dijkstra's algorithm <ref> [5] </ref>, and does not use the Cut-Relabel operation explicitly. Let be a path in G p . <p> Lemma 9.1 The above version of Eliminate-Chain can be implemented to run in linear time. Proof. The fact that all steps of Eliminate-Chain except for the shortest paths computation take linear time is obvious. The shortest paths computation takes linear time if Dial's implementation <ref> [5] </ref> of Dijkstra's algorithm is used. This is because l 0 is nonnegative and the source is connected to the other nodes by arcs of length at most n. Lemma 9.2 1. p 0 is integral. 2. 8a 2 E, l p 0 1. 3.
Reference: [6] <author> E. W. Dijkstra. </author> <title> A Note on Two Problems in Connection with Graphs. </title> <journal> Numer. Math., </journal> <volume> 1 </volume> <pages> 269-271, </pages> <year> 1959. </year>
Reference-contexts: As noted by an anonymous referee, it is easy to see that C can be replaced by N. 1 between our method and Dijkstra's shortest path algorithm <ref> [6] </ref>. The flexibility of our method may lead to better running time bounds. The shortest paths problem is closely related to other problems, such as the minimum-cost flow, assignment, and minimum-mean length cycle problems. Our method for the shortest paths problem extends to these problems. <p> We call such a problem Dijkstra's shortest paths problem <ref> [6] </ref>. Given a feasible price function p, the shortest paths problem can be solved as follows. Let d be a solution to the Dijkstra's shortest paths problem (G; s; l p ).
Reference: [7] <author> R. P. </author> <title> Dilworth. A Decomposition Theorem for Partially Ordered Sets. </title> <journal> Annals for Math., </journal> <volume> 51 </volume> <pages> 161-166, </pages> <year> 1950. </year>
Reference-contexts: to S reduces the number of improvable nodes by at least p k. (The eliminate-chain operation is described in the next section.) An iteration takes linear time and is based on the results of Sections 5 and 7 and the following lemma, which is related to Dilworth's Theorem (see e.g. <ref> [7] </ref>). Lemma 6.1 Suppose G p is acyclic. Then there exists a chain S E such that S contains at least p k improvable arcs or a closed set S V such that relabeling S reduces the number of improvable nodes by at least p k.
Reference: [8] <author> L. R. Ford, Jr. and D. R. Fulkerson. </author> <title> Flows in Networks. </title> <publisher> Princeton Univ. Press, </publisher> <address> Princeton, NJ, </address> <year> 1962. </year>
Reference-contexts: Previously known algorithms for the problem are as follows. The classical Bellman-Ford algorithm <ref> [1, 8] </ref> runs in O (nm) time. Our bound is better than this bound for N = o (2 p n ). Scaling algorithms of Gabow [12] and of Gabow and Tarjan [13] are dominated by an assignment subroutine.
Reference: [9] <author> G. Frederickson. </author> <title> Fast Algorithms for Shortest Paths in Planar Graphs, with Applications. </title> <journal> SIAM J. Comput., </journal> <volume> 16 </volume> <pages> 1004-1022, </pages> <year> 1987. </year>
Reference-contexts: The former algorithm runs in O (n 3=4 m log N ) time; the latter algorithm runs in O ( p nm log (nN )) time. 2 Our bound dominates these bounds. The fastest shortest paths algorithm currently known for planar graphs <ref> [9, 19] </ref> runs in O (n 1:5 ) time. Our algorithm runs in O (n 1:5 log N) time on planar graphs and is competitive for small values of N. Our framework is very flexible. In Sections 8 and 9 we describe two variations of the O ( p algorithm.
Reference: [10] <author> M. L. Fredman and R. E. Tarjan. </author> <title> Fibonacci Heaps and Their Uses in Improved Network Optimization Algorithms. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 34 </volume> <pages> 596-615, </pages> <year> 1987. </year>
Reference-contexts: The admissible graph is defined by G p = (V; E p ). If the length function is nonnegative, the shortest paths problem can be solved in O (m + n log n) time <ref> [10] </ref>, or in O (m + n log n= log log n) time [11] in a random access machine computation model that allows certain word operations. We call such a problem Dijkstra's shortest paths problem [6].
Reference: [11] <author> M. L. Fredman and D. E. Willard. </author> <title> Trans-dichotomous Algorithms for Minimum Spanning Trees and Shortest Paths. </title> <booktitle> In Proc. 31st IEEE Annual Symposium on Foundations of Computer Science, </booktitle> <pages> pages 719-725, </pages> <year> 1990. </year>
Reference-contexts: The admissible graph is defined by G p = (V; E p ). If the length function is nonnegative, the shortest paths problem can be solved in O (m + n log n) time [10], or in O (m + n log n= log log n) time <ref> [11] </ref> in a random access machine computation model that allows certain word operations. We call such a problem Dijkstra's shortest paths problem [6]. Given a feasible price function p, the shortest paths problem can be solved as follows.
Reference: [12] <author> H. N. Gabow. </author> <title> Scaling Algorithms for Network Problems. </title> <journal> J. of Comp. and Sys. Sci., </journal> <volume> 31 </volume> <pages> 148-168, </pages> <year> 1985. </year>
Reference-contexts: Previously known algorithms for the problem are as follows. The classical Bellman-Ford algorithm [1, 8] runs in O (nm) time. Our bound is better than this bound for N = o (2 p n ). Scaling algorithms of Gabow <ref> [12] </ref> and of Gabow and Tarjan [13] are dominated by an assignment subroutine. The former algorithm runs in O (n 3=4 m log N ) time; the latter algorithm runs in O ( p nm log (nN )) time. 2 Our bound dominates these bounds. <p> Part of this work was done while the author was visiting IBM Almaden Research Center and supported by ONR Contract N00014-91-C-0026. 1 We assume that N 2 so that log N &gt; 0. 2 In <ref> [12, 13] </ref> these bounds are stated in terms of C, the maximum absolute value of arc costs. As noted by an anonymous referee, it is easy to see that C can be replaced by N. 1 between our method and Dijkstra's shortest path algorithm [6]. <p> Then for every a 2 E, l p (a) 0. Proof. The lemma follows from the fact that l p (a) is integral and l p (a) &gt; 1. Bit scaling, first applied to the shortest paths problem by Gabow <ref> [12] </ref>, can be used instead of successive approximation in all algorithms described in this paper. The bit scaling version of our method rounds lengths up to a certain precision, initially the smallest power of two that is greater 2 than N .
Reference: [13] <author> H. N. Gabow and R. E. Tarjan. </author> <title> Faster Scaling Algorithms for Network Problems. </title> <journal> SIAM J. Comput., </journal> <pages> pages 1013-1036, </pages> <year> 1989. </year>
Reference-contexts: Previously known algorithms for the problem are as follows. The classical Bellman-Ford algorithm [1, 8] runs in O (nm) time. Our bound is better than this bound for N = o (2 p n ). Scaling algorithms of Gabow [12] and of Gabow and Tarjan <ref> [13] </ref> are dominated by an assignment subroutine. The former algorithm runs in O (n 3=4 m log N ) time; the latter algorithm runs in O ( p nm log (nN )) time. 2 Our bound dominates these bounds. <p> Part of this work was done while the author was visiting IBM Almaden Research Center and supported by ONR Contract N00014-91-C-0026. 1 We assume that N 2 so that log N &gt; 0. 2 In <ref> [12, 13] </ref> these bounds are stated in terms of C, the maximum absolute value of arc costs. As noted by an anonymous referee, it is easy to see that C can be replaced by N. 1 between our method and Dijkstra's shortest path algorithm [6]. <p> In the special case of the assignment problem, the analysis of the improved shortest path algorithm can be extended to obtain an O ( p nm log (nC)) time algorithm. This bound matches the fastest known scaling bound <ref> [13] </ref>, but the algorithm is different. The idea is to define the admissible graph and improvable arcs so that an improvable node has exactly one improvable arc going into it and the residual capacity of this arc is one.
Reference: [14] <author> A. V. Goldberg. </author> <title> Efficient Graph Algorithms for Sequential and Parallel Computers. </title> <type> PhD thesis, </type> <institution> M.I.T., </institution> <month> January </month> <year> 1987. </year> <note> (Also available as Technical Report TR-374, </note> <institution> Lab. for Computer Science, M.I.T., </institution> <year> 1987). </year>
Reference-contexts: algorithm runs in O ( p nm log N ) time, where n and m are the number of nodes and arcs of the input network, respectively, and the arc costs are at least N . 1 Our approach is related to the cost-scaling approach to the minimum-cost flow problem <ref> [2, 14, 18, 21] </ref>. Previously known algorithms for the problem are as follows. The classical Bellman-Ford algorithm [1, 8] runs in O (nm) time. Our bound is better than this bound for N = o (2 p n ). <p> The problem, however, is that our way of dealing with the first case of Lemma 6.1 does not work without scaling. 10 Our definition of *-feasibility corresponds to that of *-optimality for minimum cost flows <ref> [14, 18] </ref>. If one follows [14, 18] faithfully, however, one would define *-feasibility using l p (a) * instead of (2) and not consider arcs with zero reduced costs admissible. Under these definitions, the admissible graph cannot have zero length cycles, so there is no need for decycle. <p> The problem, however, is that our way of dealing with the first case of Lemma 6.1 does not work without scaling. 10 Our definition of *-feasibility corresponds to that of *-optimality for minimum cost flows <ref> [14, 18] </ref>. If one follows [14, 18] faithfully, however, one would define *-feasibility using l p (a) * instead of (2) and not consider arcs with zero reduced costs admissible. Under these definitions, the admissible graph cannot have zero length cycles, so there is no need for decycle.
Reference: [15] <author> A. V. Goldberg. </author> <title> An Efficient Implementation of a Scaling Minimum-Cost Flow Algorithm. </title> <booktitle> In Proc. 3rd Integer Prog. and Combinatorial Opt. Conf., </booktitle> <pages> pages 251-266, </pages> <year> 1993. </year>
Reference-contexts: The techniques introduced in this paper have a practical impact. In particular, the techniques of Section 8 proved to be crucial in our implementation of price update computation in a minimum-cost flow algorithm <ref> [15] </ref>, which resulted in a significant improvement of performance. Preliminary experiments with the algorithm of this paper, conducted as a part of the experimental study described in [3], suggest that the algorithm is not the best one to use in practice.
Reference: [16] <author> A. V. Goldberg and T. Radzik. </author> <title> A Heuristic Improvement of the Bellman-Ford Algorithm. </title> <journal> Applied Math. Let., </journal> <volume> 6 </volume> <pages> 3-6, </pages> <year> 1993. </year>
Reference-contexts: Although on some problem families the algorithm significantly outperformed the classical methods, it was dominated by the algorithm of <ref> [16] </ref> on all problem classes studied. The algorithms we discussed scale * by a factor of two. Any factor greater then one can be used instead without affecting the asymptotic time bounds. The method can be modified to maintain a tentative shortest path tree.
Reference: [17] <author> A. V. Goldberg and R. E. Tarjan. </author> <title> Finding Minimum-Cost Circulations by Canceling Negative Cycles. </title> <journal> J. Assoc. Comput. Mach., </journal> <volume> 36 </volume> <pages> 873-886, </pages> <year> 1989. </year>
Reference-contexts: In our discussion below, we assume that the reader is familiar with <ref> [17, 18] </ref>. We denote the reduced costs by c p and the residual graph by G f . We define admissible arcs to be residual arcs with negative reduced costs, as in [17, 18]. Without loss of generality, we assume that a feasible initial circulation is available. <p> In our discussion below, we assume that the reader is familiar with <ref> [17, 18] </ref>. We denote the reduced costs by c p and the residual graph by G f . We define admissible arcs to be residual arcs with negative reduced costs, as in [17, 18]. Without loss of generality, we assume that a feasible initial circulation is available. A simple algorithm based on the cut-relabel operation does the following at each iteration. First, it canceles admissible cycles; this can be done in O (m log n) time (see e.g. [17]). <p> Without loss of generality, we assume that a feasible initial circulation is available. A simple algorithm based on the cut-relabel operation does the following at each iteration. First, it canceles admissible cycles; this can be done in O (m log n) time (see e.g. <ref> [17] </ref>). Next, the algorithm picks an improvable node v, finds the set S of nodes reachable from v in the admissible graph, and executes cut-relabel (S). <p> We can also use the tighten operation to obtain a minimum-cost flow algorithm with the same running time. These algorithms are variations of the tighten-and-cancel algorithms of <ref> [17] </ref>. In the above minimum-cost flow algorithms, the admissible graph changes due to flow augmentations in addition to price changes. Because of this fact, our analysis of the improved algorithms for the shortest paths problem does not seem to extend to the minimum-cost flow problem. <p> Under these definitions, the admissible graph cannot have zero length cycles, so there is no need for decycle. However, these definitions seem to lead to an O (log (nN )) bound on the number of iterations of the scaling loop of the method. The tighten operation described in <ref> [17] </ref> also leads to an implementation of the method that runs in O (log (nN )) iterations of the scaling loop. The techniques introduced in this paper have a practical impact.
Reference: [18] <author> A. V. Goldberg and R. E. Tarjan. </author> <title> Finding Minimum-Cost Circulations by Successive Approximation. </title> <journal> Math. of Oper. Res., </journal> <volume> 15 </volume> <pages> 430-466, </pages> <year> 1990. </year>
Reference-contexts: algorithm runs in O ( p nm log N ) time, where n and m are the number of nodes and arcs of the input network, respectively, and the arc costs are at least N . 1 Our approach is related to the cost-scaling approach to the minimum-cost flow problem <ref> [2, 14, 18, 21] </ref>. Previously known algorithms for the problem are as follows. The classical Bellman-Ford algorithm [1, 8] runs in O (nm) time. Our bound is better than this bound for N = o (2 p n ). <p> Thus bit scaling can be viewed as a special case of successive approximation. The work on the minimum-cost flow problem <ref> [18] </ref> shows that successive approximation is more general than bit scaling; in particular, the former can be easily used to obtain strongly polynomial algorithms. We describe bit scaling version in the algorithms . This allows us to avoid certain technical details and slightly simplifies the presentation. <p> In our discussion below, we assume that the reader is familiar with <ref> [17, 18] </ref>. We denote the reduced costs by c p and the residual graph by G f . We define admissible arcs to be residual arcs with negative reduced costs, as in [17, 18]. Without loss of generality, we assume that a feasible initial circulation is available. <p> In our discussion below, we assume that the reader is familiar with <ref> [17, 18] </ref>. We denote the reduced costs by c p and the residual graph by G f . We define admissible arcs to be residual arcs with negative reduced costs, as in [17, 18]. Without loss of generality, we assume that a feasible initial circulation is available. A simple algorithm based on the cut-relabel operation does the following at each iteration. First, it canceles admissible cycles; this can be done in O (m log n) time (see e.g. [17]). <p> The problem, however, is that our way of dealing with the first case of Lemma 6.1 does not work without scaling. 10 Our definition of *-feasibility corresponds to that of *-optimality for minimum cost flows <ref> [14, 18] </ref>. If one follows [14, 18] faithfully, however, one would define *-feasibility using l p (a) * instead of (2) and not consider arcs with zero reduced costs admissible. Under these definitions, the admissible graph cannot have zero length cycles, so there is no need for decycle. <p> The problem, however, is that our way of dealing with the first case of Lemma 6.1 does not work without scaling. 10 Our definition of *-feasibility corresponds to that of *-optimality for minimum cost flows <ref> [14, 18] </ref>. If one follows [14, 18] faithfully, however, one would define *-feasibility using l p (a) * instead of (2) and not consider arcs with zero reduced costs admissible. Under these definitions, the admissible graph cannot have zero length cycles, so there is no need for decycle.
Reference: [19] <author> R. J. Lipton and R. E. Tarjan. </author> <title> A Separator Theorem for Planar Graphs. </title> <journal> SIAM J. of Appl. math., </journal> <volume> 36 </volume> <pages> 177-189, </pages> <year> 1979. </year>
Reference-contexts: The former algorithm runs in O (n 3=4 m log N ) time; the latter algorithm runs in O ( p nm log (nN )) time. 2 Our bound dominates these bounds. The fastest shortest paths algorithm currently known for planar graphs <ref> [9, 19] </ref> runs in O (n 1:5 ) time. Our algorithm runs in O (n 1:5 log N) time on planar graphs and is competitive for small values of N. Our framework is very flexible. In Sections 8 and 9 we describe two variations of the O ( p algorithm.
Reference: [20] <author> S. T. McCormick. </author> <title> A Note on Approximate Binary Search Algorithms for Mean Cuts and Cycles. </title> <institution> UBC Faculty of Commerce and Buisiness Administration, unpublishd manuscript, </institution> <year> 1992. </year>
Reference-contexts: The shortest paths problem is closely related to other problems, such as the minimum-cost flow, assignment, and minimum-mean length cycle problems. Our method for the shortest paths problem extends to these problems. In Section 10 we sketch extensions to the minimum-cost flow and assignment problems. McCormick <ref> [20] </ref> shows an extension to the minimum-mean cycle problem.
Reference: [21] <author> H. Rock. </author> <title> Scaling Techniques for Minimal Cost Network Flows. </title> <editor> In U. Pape, editor, </editor> <booktitle> Discrete Structures and Algorithms, </booktitle> <pages> pages 181-191. </pages> <editor> Carl Hansen, </editor> <address> Munich, </address> <year> 1980. </year>
Reference-contexts: algorithm runs in O ( p nm log N ) time, where n and m are the number of nodes and arcs of the input network, respectively, and the arc costs are at least N . 1 Our approach is related to the cost-scaling approach to the minimum-cost flow problem <ref> [2, 14, 18, 21] </ref>. Previously known algorithms for the problem are as follows. The classical Bellman-Ford algorithm [1, 8] runs in O (nm) time. Our bound is better than this bound for N = o (2 p n ).
Reference: [22] <author> R. E. Tarjan. </author> <title> Depth-First Search and Linear Graph Algorithms. </title> <journal> SIAM J. Comput., </journal> <volume> 1 </volume> <pages> 146-160, </pages> <year> 1972. </year>
Reference-contexts: A feasible price function on the contracted graph extends to a feasible price function on the original graph in a straight-forward way. Our algorithm uses an O (m)-time subroutine decycle (G p ) that works as follows. Find strongly connected components of G p (see e.g. <ref> [22] </ref>); if a component contains a negative reduced cost arc, G has a negative length cycle; otherwise, contract each component. (Note that the prices of nodes in each contracted component change by the same amount, so the reduced costs of arcs with both ends in the same component do not change.)
Reference: [23] <author> R. E. Tarjan. </author> <title> Data Structures and Network Algorithms. </title> <institution> Society for Industrial and Applied Mathematics, </institution> <address> Philadelphia, PA, </address> <year> 1983. </year> <month> 12 </month>
Reference-contexts: the fastest known algorithms, but are somewhat simpler. 2 Preliminaries The input to the single-source shortest paths problem is (G; s; l), where G = (V; E) is a directed graph, l : E ! R is a length function, and s 2 V is the source node. (See e.g. <ref> [4, 23] </ref>.) The goal is to find shortest paths distances from s to all other nodes of G or to find a negative length cycle in G. If G has a negative length cycle, we say that the problem is infeasible. We assume that the length function is integral.
References-found: 23

