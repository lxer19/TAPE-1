URL: file://ftp.di.unipi.it/pub/Papers/giacobazzi/alp96.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: giaco@di.unipi.it  franz@math.unipd.it  
Title: Complementing Logic Program Semantics  
Author: Roberto Giacobazzi Francesco Ranzato 
Address: Corso Italia 40, 56125 Pisa, Italy  Via Belzoni 7, 35131 Padova, Italy  
Affiliation: Dipartimento di Informatica, Universita di Pisa  Dipartimento di Matematica Pura ed Applicata, Universita di Padova  
Abstract: We consider abstract interpretation, and in particular the basic operators of reduced product and complementation of abstract domains, as a tool to systematically derive denotational semantics by composition and decomposition. Reduced product allows to perform the logical conjunction of semantics, while complementation characterizes what is left from a semantics when the information concerning a given observable property is "subtracted" from it. We apply this idea to the case of logic programming, characterizing in a uniform algebraic setting, the interaction between a number of well known declarative semantics for logic programs.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> K.R. Apt and M. Gabbrielli. </author> <title> Declarative interpretations reconsidered. </title> <booktitle> In Proc. </booktitle> <pages> ICLP '94 , pp. 74-89, </pages> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Operational Semantics Clark's semantics is considered a logical semantics for programs (cf. <ref> [1] </ref>). Instead, the s-semantics captures the operational notion of computed answer substitution. Clark's semantics is here characterized by the closure x : # x 2 uco (-(Atom) ), where Atom is a poset.
Reference: 2. <author> K.L. Clark. </author> <title> Predicate logic as a computational formalism. Res. </title> <type> Report DOC 79/59, </type> <institution> Dept. of Computing, Imperial College, </institution> <address> London, </address> <year> 1979. </year>
Reference-contexts: Recall that # is a computed answer substitution for a goal G and a program P iff G # fl Clark's semantics, denoted by C, has been introduced in <ref> [2] </ref>. In [12], it was proved that C is fully abstract with respect to the "more abstract" notion of correct answer substitution. Recall that # is a correct answer substitution for a goal G and a program P iff G#! fl P fl.
Reference: 3. <author> M. Comini and G. Levi. </author> <title> An algebraic theory of observables. </title> <booktitle> In Proc. </booktitle> <pages> ILPS '94 , pp. 172-186, </pages> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: Logic programming is an example of high-level programming language enjoying a simple semantic definition. Due to its semantic simplicity, logic programming is probably the programming language where the abstract interpretation-based approach to semantics design was mostly successful, as shown by the increasing literature in this field (cf. <ref> [3, 4, 17, 19] </ref>). Our approach gives rise to a hierarchy of declarative semantics for logic programs where semantics, and the corresponding observable properties, can be manipulated algebraically by complementation and reduced product.
Reference: 4. <author> M. Comini, G. Levi, and M.C. Meo. </author> <title> Compositionality of SLD-derivations and their abstractions. </title> <booktitle> In Proc. </booktitle> <pages> ILPS '95 , pp. 561-575, </pages> <publisher> The MIT Press, </publisher> <year> 1995. </year>
Reference-contexts: Logic programming is an example of high-level programming language enjoying a simple semantic definition. Due to its semantic simplicity, logic programming is probably the programming language where the abstract interpretation-based approach to semantics design was mostly successful, as shown by the increasing literature in this field (cf. <ref> [3, 4, 17, 19] </ref>). Our approach gives rise to a hierarchy of declarative semantics for logic programs where semantics, and the corresponding observable properties, can be manipulated algebraically by complementation and reduced product.
Reference: 5. <author> A. Cortesi, G. File, R. Giacobazzi, C. Palamidessi, and F. Ranzato. </author> <title> Complementation in abstract interpretation. </title> <booktitle> In Proc. </booktitle> <volume> SAS '95 , LNCS 983, </volume> <pages> pp. 100-117, </pages> <year> 1995. </year>
Reference-contexts: The following result is recalled from [18]. Theorem 3.1 ([18]) If C is meet-continuous then uco (C ) is pseudo-complemented. This result has been firstly applied in abstract interpretation for analysis in <ref> [5] </ref>, using the above notion of complementation, which is more precisely formulated as follows: whenever C is meet-continuous, the complement C ~ D exists, and it is defined as: C ~ D = tf 2 uco (C ) j ( D u )(C ) = C g: Assume that C v
Reference: 6. <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. </title> <booktitle> In Proc. ACM POPL '77 , pp. </booktitle> <pages> 238-252, </pages> <year> 1977. </year>
Reference: 7. <author> P. Cousot and R. Cousot. </author> <title> Systematic design of program analysis frameworks. </title> <booktitle> In Proc. ACM POPL '79 , pp. </booktitle> <pages> 269-282, </pages> <year> 1979. </year>
Reference-contexts: D is called an abstraction (or abstract interpretation) of C , and C a concretization of D, while D is a proper abstraction if fl ffi ff 6= x :x . An alternative, but equivalent, approach to abstract interpretation is by closure operators (cf. <ref> [7] </ref>). Let hL; ; _; ^; ?; &gt;i be a complete lattice. An (upper ) closure operator on L is an operator : L ! L monotonic, idempotent and extensive (viz. 8x 2 L: x (x )). <p> The standard least fixpoint semantics is therefore given by the semantic valuation mapping [[]] : Program ! D defined as [[P ]] = lfp (T P ). It is well known in abstract interpretation (cf. <ref> [7] </ref>) that each domain abstraction uniquely determines the best correct approximation for any semantic operation. This leads in our case to the notion of abstract least fixpoint semantics.
Reference: 8. <author> P. Cousot and R. Cousot. </author> <title> Inductive definitions, semantics and abstract interpretation. </title> <booktitle> In Proc. ACM POPL '92 , pp. </booktitle> <pages> 83-94, </pages> <year> 1992. </year>
Reference-contexts: Denotational semantics models possible behaviours of a program: the degree of accuracy of this process depends both on the semantic evaluation mapping and on the semantic domain. Hence, varying these two parameters, one may get semantics at different levels of abstraction. Following <ref> [8] </ref>, it is possible to use the framework of abstract interpretation to establish the relationships between various semantics at different levels of abstraction. <p> We adopt here the closure operator approach to abstract interpretation, which is completely equivalent to the more frequently used Galois connection approach (see Section 2), followed, e.g., in <ref> [8] </ref>, while having the advantage of a higher mathematical simplicity. Assume that for the considered programming language a standard denotational definition [[]] : Program ! D is fixed. An abstraction of the standard semantics is obtained by considering any closure operator on the semantic domain.
Reference: 9. <author> P. Cousot and R. Cousot. </author> <title> Abstract interpretation and application to logic programs. </title> <journal> J. of Logic Programming, </journal> <volume> 13(2,3):103-179, </volume> <year> 1992. </year>
Reference-contexts: In fact, the abstract semantics of the program is not defined as the given abstraction () of the standard semantics of the program, viz. (lfp (T )), and, in general, lfp (ffiT ) 6= (lfp (T )). However, it is known (see e.g. <ref> [9] </ref>) that for any monotonic operator T , (lfp (T )) lfp (ffiT ) holds. Completeness of the abstraction is a well known sufficient condition assuring that the equality holds (see [9, 21]). <p> However, it is known (see e.g. [9]) that for any monotonic operator T , (lfp (T )) lfp (ffiT ) holds. Completeness of the abstraction is a well known sufficient condition assuring that the equality holds (see <ref> [9, 21] </ref>). The abstraction 2 uco (D) is complete if ffiT = ffiT ffi; analogously, the abstraction given by the Galois insertion (D; ff; A; fl) is complete if ffffiT = ffffiT ffiflffiff.
Reference: 10. <author> M.H. van Emden and R.A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <editor> J. </editor> <booktitle> of the ACM , 23(4) </booktitle> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: Recall that # is a correct answer substitution for a goal G and a program P iff G#! fl P fl. Finally, Herbrand's semantics, denoted by H, coincides with the least Herbrand model of the program, and has been fully characterized by van Emden and Kowalski in <ref> [10] </ref>. In what follows, we assume that a first-order language L is given.
Reference: 11. <author> M. Falaschi and G. Levi. </author> <title> Finite failure and partial computations in concurrent logic languages. </title> <journal> TCS , 75(7) </journal> <pages> 45-66, </pages> <year> 1990. </year>
Reference-contexts: A consequence of Theorem 6.2-(i) is that the semantics S ~ C corresponds precisely to the fully abstract semantics for partial computed answer substitutions introduced in <ref> [11] </ref>. Recall that a substitution # is a partial computed answer for the goal G in the program P iff there exists G 0 and such that G fl (cf. [11]). <p> that the semantics S ~ C corresponds precisely to the fully abstract semantics for partial computed answer substitutions introduced in <ref> [11] </ref>. Recall that a substitution # is a partial computed answer for the goal G in the program P iff there exists G 0 and such that G fl (cf. [11]). Informally, the atoms in Max (Atom) allow us to transform any partial derivation for G in P into a successful derivation for G in P [ Max (Atom). The following result is therefore immediate by Theorem 6.2 and Theorem 5.4 in [11]. <p> G 0 and such that G fl (cf. <ref> [11] </ref>). Informally, the atoms in Max (Atom) allow us to transform any partial derivation for G in P into a successful derivation for G in P [ Max (Atom). The following result is therefore immediate by Theorem 6.2 and Theorem 5.4 in [11]. Theorem 6.3 Let P 2 Program and G be a goal. # is a partial computed answer substitution for G in P iff there exist b &lt;&lt; G [[P ]] S~C such that G# = G mgu (g; b).
Reference: 12. <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative modeling of the operational behavior of logic languages. </title> <journal> TCS , 69(3) </journal> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: After some results in Section 4 on complementation and reduced product in denotational semantics, we show in Sections 5-7 the interaction between well known semantics, like the s-semantics for computed answers of <ref> [12] </ref>, Clark's semantics for correct answers ([2, 12]), least Herbrand model semantics for successful computations ([10]), and the semantics for call patterns in [16]. Logic programming provides here a clean and simple interpretation for the operators of our framework. 2 Preliminaries Basic Notation. Let A and B be sets. <p> In this case, we abuse notation by letting also hY (D); T Y i 2 Sem (X ). 4.3 A Hierarchy of Logic Program Semantics s-semantics, denoted by S, has been introduced in <ref> [12] </ref> in order to provide a fully abstract description of computed answer substitutions of logic programs. Recall that # is a computed answer substitution for a goal G and a program P iff G # fl Clark's semantics, denoted by C, has been introduced in [2]. In [12], it was proved <p> been introduced in <ref> [12] </ref> in order to provide a fully abstract description of computed answer substitutions of logic programs. Recall that # is a computed answer substitution for a goal G and a program P iff G # fl Clark's semantics, denoted by C, has been introduced in [2]. In [12], it was proved that C is fully abstract with respect to the "more abstract" notion of correct answer substitution. Recall that # is a correct answer substitution for a goal G and a program P iff G#! fl P fl.
Reference: 13. <author> M. Falaschi, G. Levi, M. Martelli, and C. </author> <title> Palamidessi.A model theoretic reconstruction of the operational semantics of logic programs. </title> <journal> Inf. & Comp., </journal> <volume> 103(1) </volume> <pages> 86-113, </pages> <year> 1993. </year>
Reference-contexts: T C ffi #=# ffiT S . Hence, by Proposition 4.3, this implies that for any P 2 Program, [[P ]] C =# ([[P ]] S ) = [[P ]] S # . This last observation has been firstly reported in <ref> [13] </ref>. It is worth noting that we have derived it by exploiting the techniques offered by abstract interpretation, which are intrinsically language-independent. <p> This abstraction is also complete, namely bcffiT C = T H ffibc. Again by Proposition 4.3, we get that [[P ]] H = b [[P ]] C c, another observation already reported in <ref> [13] </ref>. Finally, composing the previous two abstractions, we get the abstraction between s-semantics and Herbrand's semantics. This is defined in terms of the G.i. (-(Atom); bc; -(bAtomc); de), where, by a slight abuse of notation, we again denote by de the right adjoint to bc for the concrete domain -(Atom). <p> Also in this case, we have a complete abstraction. Hence, bcffiT S = T H ffibc, and, by Proposition 4.3, [[P ]] H = b [[P ]] S c. As above, this last observation is in <ref> [13] </ref>. In this case, I :dbI ce 2 uco (-(Atom)) is the closure associated with Herbrand's semantics. 5 Decomposition of Semantics Let O be a given standard semantics.
Reference: 14. <author> G. File, R. Giacobazzi, and F. Ranzato. </author> <title> A unifying view of abstract domain design. </title> <journal> ACM Comp. Surveys, </journal> <volume> 28(2), </volume> <booktitle> Symp. on Models of Progr. Lang. and Computation, </booktitle> <year> 1996. </year>
Reference-contexts: SOS) for the language. Abstract interpretation provides therefore both a mathematical framework where different semantics at different levels of abstraction can be compared to each other, and a number of systematic methods to specify new semantic definitions from more concrete ones by abstraction. As observed in <ref> [14] </ref>, among these methods, the operations for abstract domain refinement and their inverses, like reduced product ([7]), complementation ([5]), disjunctive completion ([7]), least disjunctive basis ([20]), and reduced power for functional dependencies ([7, 19]), may play a central role in semantics design, as well as in analysis, in order to provide
Reference: 15. <author> G. File and F. Ranzato. </author> <title> Complementation of abstract domains made easy. </title> <booktitle> In Proc. </booktitle> <publisher> JICSLP '96 , The MIT Press, </publisher> <year> 1996. </year>
Reference-contexts: A (possible infinite) family of semantics hX i i i2I Sem (O) is a (conjunctive) decomposition for Y 2 Sem (O) if Y = u i2I X i . File and Ranzato observed in <ref> [15] </ref> that h i i i2I is a minimal decomposition for a closure ffi (i.e., for all k 2 I and closure, ( k &lt; ) ) (ffi &lt; (u i2I nfkg i ) u )) iff for any k 2 I , ffi ~ (u i2I nfkg i ) =
Reference: 16. <author> M. Gabbrielli and M.C. Meo. </author> <title> Fixpoint semantics for partial computed answer substitutions and call patterns. </title> <booktitle> In Proc. </booktitle> <volume> ALP '92 , LNCS 632, </volume> <pages> pp. 84-99, </pages> <year> 1992. </year>
Reference-contexts: 4 on complementation and reduced product in denotational semantics, we show in Sections 5-7 the interaction between well known semantics, like the s-semantics for computed answers of [12], Clark's semantics for correct answers ([2, 12]), least Herbrand model semantics for successful computations ([10]), and the semantics for call patterns in <ref> [16] </ref>. Logic programming provides here a clean and simple interpretation for the operators of our framework. 2 Preliminaries Basic Notation. Let A and B be sets. <p> Hence, call patterns need computed answers to be computed. We formally justify this by complementing the semantics of computed answer substitutions in that of call patterns. A least fixpoint semantics for call patterns has been introduced by Gabbrielli and Meo in <ref> [16] </ref> as q = h-(BClause); T q P i, where, if = fp (x ) p (x ) j p 2 g is the set of tautological clauses, then, for any I BClause, T q 8 : fi fi fi c = h b 1 ; :::; b k1 ; b
Reference: 17. <author> R. Giacobazzi. </author> <title> "Optimal" collecting semantics for analysis in a hierarchy of logic program semantics. </title> <booktitle> In Proc. STACS '96 , LNCS 1046, </booktitle> <pages> pp. 503-514, </pages> <year> 1996. </year>
Reference-contexts: Logic programming is an example of high-level programming language enjoying a simple semantic definition. Due to its semantic simplicity, logic programming is probably the programming language where the abstract interpretation-based approach to semantics design was mostly successful, as shown by the increasing literature in this field (cf. <ref> [3, 4, 17, 19] </ref>). Our approach gives rise to a hierarchy of declarative semantics for logic programs where semantics, and the corresponding observable properties, can be manipulated algebraically by complementation and reduced product. <p> Thus, [[P ]] S = lfp (T S P ), [[P ]] C = lfp (T C P ). As proved in <ref> [17] </ref>, s-semantics, Clark's semantics and Herbrand's semantics constitute a hierarchy in our framework (i.e. for abstract interpretation), where S is more precise than C, which in turn is more precise than H. We now recall from [17] the details of the abstraction mappings of this hierarchy. <p> As proved in <ref> [17] </ref>, s-semantics, Clark's semantics and Herbrand's semantics constitute a hierarchy in our framework (i.e. for abstract interpretation), where S is more precise than C, which in turn is more precise than H. We now recall from [17] the details of the abstraction mappings of this hierarchy. As expected, the operator of instantiation # is the closure on the domain of s-semantics defining Clark's semantics. In particular, we have that T C =# ffiT S . <p> Indeed, since for any h 2 Atom, Atom nfhg 62 db-(Atom)ce, then S ~ H = t; = S. Thus, for any program P , [[P ]] S~H = [[P ]] S . If we recall the meaning of the "best" semantics for analysis introduced in <ref> [17] </ref>, we can draw a striking consequence of this fact. Due to lack of space, we omit the details of the constructions of [17], to which the reader is referred. Roughly, [17] calls a semantics X too concrete for a given property on X (indeed a closure on the semantic domain <p> If we recall the meaning of the "best" semantics for analysis introduced in <ref> [17] </ref>, we can draw a striking consequence of this fact. Due to lack of space, we omit the details of the constructions of [17], to which the reader is referred. Roughly, [17] calls a semantics X too concrete for a given property on X (indeed a closure on the semantic domain of X ) if there exists a proper abstraction Y of X that allows to perform the desired analysis (viz. ) without loosing <p> If we recall the meaning of the "best" semantics for analysis introduced in <ref> [17] </ref>, we can draw a striking consequence of this fact. Due to lack of space, we omit the details of the constructions of [17], to which the reader is referred. Roughly, [17] calls a semantics X too concrete for a given property on X (indeed a closure on the semantic domain of X ) if there exists a proper abstraction Y of X that allows to perform the desired analysis (viz. ) without loosing any information with respect to X . <p> In this sense, <ref> [17] </ref> shows that there exists always a best semantics for analysis, and provides an equational characterization for it involving the reduced product.
Reference: 18. <author> R. Giacobazzi, C. Palamidessi, and F. Ranzato. </author> <title> Weak relative pseudo-complements of closure operators. </title> <journal> Algebra Universalis, </journal> <note> 1996. To appear. </note>
Reference-contexts: The following result is recalled from <ref> [18] </ref>. Theorem 3.1 ([18]) If C is meet-continuous then uco (C ) is pseudo-complemented.
Reference: 19. <author> R. Giacobazzi and F. Ranzato. </author> <title> Functional dependencies and Moore-set completions of abstract interpretations and semantics. </title> <booktitle> In Proc. </booktitle> <pages> ILPS '95 , pp. 321-335, </pages> <year> 1995. </year>
Reference-contexts: Logic programming is an example of high-level programming language enjoying a simple semantic definition. Due to its semantic simplicity, logic programming is probably the programming language where the abstract interpretation-based approach to semantics design was mostly successful, as shown by the increasing literature in this field (cf. <ref> [3, 4, 17, 19] </ref>). Our approach gives rise to a hierarchy of declarative semantics for logic programs where semantics, and the corresponding observable properties, can be manipulated algebraically by complementation and reduced product.
Reference: 20. <author> R. Giacobazzi and F. Ranzato. </author> <title> Compositional optimization of disjunctive abstract interpretations. </title> <booktitle> In Proc. ESOP '96 , LNCS 1058, </booktitle> <pages> pp. 141-155, </pages> <year> 1996. </year>
Reference: 21. <author> A. Mycroft. </author> <title> Completeness and predicate-based abstract interpretation. </title> <booktitle> In Proc. ACM PEPM '93 , 1993. </booktitle>
Reference-contexts: However, it is known (see e.g. [9]) that for any monotonic operator T , (lfp (T )) lfp (ffiT ) holds. Completeness of the abstraction is a well known sufficient condition assuring that the equality holds (see <ref> [9, 21] </ref>). The abstraction 2 uco (D) is complete if ffiT = ffiT ffi; analogously, the abstraction given by the Galois insertion (D; ff; A; fl) is complete if ffffiT = ffffiT ffiflffiff.
Reference: 22. <author> J. Morgado. </author> <title> Some results on the closure operators of partially ordered sets. </title> <journal> Portug. Math., </journal> <volume> 19(2) </volume> <pages> 101-139, </pages> <year> 1960. </year>
Reference-contexts: Among the possible minimal decompositions, we consider those given by the most abstract factors. It is well known (cf. <ref> [22] </ref>) that if L is a complete lattice, then uco (L) is a dual-atomistic complete lattice, viz. for any 2 uco (L), = u x2 (L)nf&gt;g ' x , where ' x = f&gt;; x g. We call the ' x 's atomic closures.
Reference: 23. <author> J. Morgado. </author> <title> Note on complemented closure operators of complete lattices. </title> <journal> Portug. Math., </journal> <volume> 21(3) </volume> <pages> 135-142, </pages> <year> 1962. </year>
Reference-contexts: Then, h' x i x2MI ((L)) is a minimal decomposition for , involving the least number of atomic closures only. Morgado proved in <ref> [23] </ref> that atomic closures ' x defined on meet-irreducible elements are always complemented, i.e. for any x 2 MI (L), there exists ' x 2 uco (L) such that ' x u ' x = id , and ' x t ' x = x :&gt;.
References-found: 23

