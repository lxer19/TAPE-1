URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1997/1997-30.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: email: -saraiva,kuiper,swierstra-@cs.ruu.nl  
Phone: phone: +31 30 2536761  
Title: Strictification of Computations on Trees  
Author: Joo Saraiva Doaitse Swierstra and Matthijs Kuiper 
Keyword: (i.e. memoized) and parallel evaluation.  
Address: P.O. Box 80.089, 3508 TB Utrecht, The Netherlands  
Affiliation: Department of Computer Science, University of Utrecht  
Abstract: An attribute grammars describes a computation over a recursive data structure (syntax tree). The corresponding evaluator can be directly encoded as a set of lazy evaluated functions. In this paper we show how this set may be converted into a larger set of strict functions and a collection of new data types. We call this process, which is based on a global data ow analysis, strictitcation. The resulting set of small functions and the new data types are amenable to further analysis and optimization. Especially the elimination transformation leads to very ecient programs, both in time and space, and which are much more suited for incremental 
Abstract-found: 1
Intro-found: 1
Reference: [Alb91] <author> Henk Alblas. </author> <title> Introduction to attribute grammars. </title> <editor> In H. Alblas and B. Melichar, editors, </editor> <booktitle> International Summer School on Attribute Grammars, Applications and Systems, volume 545 of LNCS, </booktitle> <pages> pages 115. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Although this protle was obtained using the Haskell strict ag, the lazy accumulation is not avoided. 2 Strictitcation In this section we present our technique to transform circular programs into strict ones. We use well known attribute grammar static analysis techniques <ref> [Alb91, Paa95] </ref> in order to break up the circularities into a large set of small multiple traversal functions.
Reference: [BdM96] <author> Richard Bird and Oegerikus de Moor. </author> <title> Algebra of programming, </title> <booktitle> volume 100 of Prentice-Hall Inernational Series in Computer Science. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1996. </year>
Reference-contexts: More recently this class of functions became known as catamorphisms, although the context in which such catamorphisms got their name (i.e. the formal derivation of functional programs) usually restricts itself to recursive functions which take only one parameter of one specitc data type as an argument <ref> [BdM96] </ref>. In attribute grammar terms one would say that one is dealing with a grammar which has only a single non-terminal.
Reference: [Bir84] <author> R. S. Bird. </author> <title> Using circular programs to eliminate multiple traversals of data. </title> <journal> Acta Informatica, </journal> <volume> (21):239250, </volume> <month> January </month> <year> 1984. </year>
Reference-contexts: The techniques shown have all been implemented and form part of the current Lrc-attribute grammar based program synthesizer. 1 The Class of Functions Considered The class of functions we are considering are the so-called circular functional programs, as introduced in <ref> [Bir84] </ref>. Although such programs have proved to be surprisingly hard to explain to the average functional programmer, they actually become a lot simpler to understand and design if one considers them as the representation in a lazy functional language of an attribute grammar evaluator [KS87, Joh87].
Reference: [CP96] <author> Alan Carle and Lori Pollock. </author> <title> On the optimality of change propagation for incremental evaluation of hierarchical attribute grammars. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 18(1):1629, </volume> <month> January </month> <year> 1996. </year>
Reference-contexts: tree by means of a generated tree-walking automaton proved to be no longer applicable due to the fact that the abstract syntax tree (i.e. the argument controlling the overall computation) is no longer an invariant data structure in the computation but depends also on intermediate results of the overall computation <ref> [Pen94, CP96] </ref>. Since our new evaluation model only uses the generated strict functions we can rely on ecient function caching for achieving incremental evaluation. <p> Traditional techniques for incremental attribute evaluations which are based on change propagation [RTD83] do not handle higher order attribute grammars eciently <ref> [CP96] </ref>. An ecient and elegant incremental attribute evaluator can be implemented through visit function memoization [CP96]. <p> Traditional techniques for incremental attribute evaluations which are based on change propagation [RTD83] do not handle higher order attribute grammars eciently <ref> [CP96] </ref>. An ecient and elegant incremental attribute evaluator can be implemented through visit function memoization [CP96].
Reference: [Joh87] <author> Thomas Johnsson. </author> <title> Attribute grammars as a functional programming paradigm. </title> <editor> In G. Kahn, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, volume 274 of LNCS, </booktitle> <pages> pages 154173. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1987. </year>
Reference-contexts: Although such programs have proved to be surprisingly hard to explain to the average functional programmer, they actually become a lot simpler to understand and design if one considers them as the representation in a lazy functional language of an attribute grammar evaluator <ref> [KS87, Joh87] </ref>. More recently this class of functions became known as catamorphisms, although the context in which such catamorphisms got their name (i.e. the formal derivation of functional programs) usually restricts itself to recursive functions which take only one parameter of one specitc data type as an argument [BdM96].
Reference: [Jou91] <author> Martin Jourdan. </author> <title> A survey of parallel attribute evaluation methods. </title> <editor> In H. Alblas and B. Melichar, editors, </editor> <booktitle> International Summer School on Attribute Grammars, Applications and Systems, volume 545 of LNCS, </booktitle> <pages> pages 234255. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: 2 ) = eval 2 Items items 2 dclo ( error_aux) = error errors 2 ( errors 3 ) = eval 2 Items Items 3 env ( errors) = error_aux errors 3 The static detection of independent visit functions per se can lead to a too tne grain of parallelism <ref> [Jou91] </ref>. The size of a visit tree can be used dynamically to decide whether two independent function calls may be computed in parallel or not. 5.3 Implementation of Attribute Grammars Our work was developed in the context of incremental attribute evaluation of Higher Order Attribute Grammars.
Reference: [Kas80] <author> Uwe Kastens. </author> <title> Ordered attribute grammars. </title> <journal> Acta Informatica, </journal> <volume> 13:229256, </volume> <year> 1980. </year>
Reference-contexts: In the circular program these dependencies are handle by the lazy evaluation machinery. 2.1 Computing Visit Sequences In this section, we show how to derive visit sequences from the circular programs. We use Kastens' ordered scheduling algorithm to derive the visit sequences <ref> [Kas80] </ref>. Our presentation in this paper is necessarily short. Full detnitions can be found in [Kas80] and [Pen94] (page 122). We start by briey describing visit sequences since they are the result of this step. <p> We use Kastens' ordered scheduling algorithm to derive the visit sequences <ref> [Kas80] </ref>. Our presentation in this paper is necessarily short. Full detnitions can be found in [Kas80] and [Pen94] (page 122). We start by briey describing visit sequences since they are the result of this step.
Reference: [KS87] <author> Matthijs Kuiper and Doaitse Swierstra. </author> <title> Using attribute grammars to derive ecient functional programs. </title> <booktitle> In Computing Science in the Netherlands CSN'87, </booktitle> <month> November </month> <year> 1987. ftp://ftp.cs.ruu.nl/pub/RUU/CS/techreps/CS-1986/1986-16.ps.gz. </year>
Reference-contexts: Although such programs have proved to be surprisingly hard to explain to the average functional programmer, they actually become a lot simpler to understand and design if one considers them as the representation in a lazy functional language of an attribute grammar evaluator <ref> [KS87, Joh87] </ref>. More recently this class of functions became known as catamorphisms, although the context in which such catamorphisms got their name (i.e. the formal derivation of functional programs) usually restricts itself to recursive functions which take only one parameter of one specitc data type as an argument [BdM96].
Reference: [Paa95] <author> Jukka Paakki. </author> <title> Attribute grammar paradigms a high-level methodology in language implementation. </title> <journal> ACM Computing Surveys, </journal> <volume> 27(2):196255, </volume> <month> June </month> <year> 1995. </year>
Reference-contexts: Although this protle was obtained using the Haskell strict ag, the lazy accumulation is not avoided. 2 Strictitcation In this section we present our technique to transform circular programs into strict ones. We use well known attribute grammar static analysis techniques <ref> [Alb91, Paa95] </ref> in order to break up the circularities into a large set of small multiple traversal functions.
Reference: [Pen94] <author> Maarten Pennings. </author> <title> Generating Incremental Evaluators. </title> <type> PhD thesis, </type> <institution> Utrecht University, </institution> <month> November </month> <year> 1994. </year> <month> ftp://ftp.cs.ruu.nl/pub/RUU/CS/phdtheses/Pennings/. </month>
Reference-contexts: tree by means of a generated tree-walking automaton proved to be no longer applicable due to the fact that the abstract syntax tree (i.e. the argument controlling the overall computation) is no longer an invariant data structure in the computation but depends also on intermediate results of the overall computation <ref> [Pen94, CP96] </ref>. Since our new evaluation model only uses the generated strict functions we can rely on ecient function caching for achieving incremental evaluation. <p> We use Kastens' ordered scheduling algorithm to derive the visit sequences [Kas80]. Our presentation in this paper is necessarily short. Full detnitions can be found in [Kas80] and <ref> [Pen94] </ref> (page 122). We start by briey describing visit sequences since they are the result of this step.
Reference: [PSV92] <author> Maarten Pennings, Doaitse Swierstra, and Harald Vogt. </author> <title> Using cached functions and constructors for incremental attribute evaluation. </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Programming Language Implementation and Logic Programming, volume 631 of LNCS, </booktitle> <pages> pages 130144. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Secondly we transform these visit sequences into visit functions. To combine the eects of the individual traversals we introduce visit trees. These visist trees are a small adaption of our previously introduced bindings <ref> [PSV92] </ref>. Visit trees are needed to pass values that are computed in one traversal and that are used in a subsequent one 1 . We call such dependencies between traversals inter-traversal dependencies.
Reference: [PT89] <author> William Pugh and Tim Teitelbaum. </author> <title> Incremental computation via function caching. </title> <booktitle> In 16th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <volume> volume 1, </volume> <pages> pages 315328. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1989. </year>
Reference-contexts: produces more ecient memory consumption programs. 5 Applications In this section we consider three areas where our techniques can be applied: the incremental and parallel computation of circular programs and the implementation of higher order attribute grammars. 5.1 Incremental Computation Function memoization is a ecient technique to implement incremental computations <ref> [PT89] </ref>. Circular programs relying on lazy evaluation cannot use standard memoization techniques to achieve such incremental behaviour, since comparing unevaluated arguments is not likely to work in our situation. After the strictitcation process however function memoization can be applied straightforwardly.
Reference: [Pug88] <author> William Pugh. </author> <title> An improved replacement strategy for function caching. </title> <booktitle> In ACM Conference on Lisp and Functional Programming, </booktitle> <volume> volume 7, </volume> <pages> pages 269276. </pages> <publisher> ACM, </publisher> <month> july </month> <year> 1988. </year> <month> 14 </month>
Reference-contexts: The size of visit trees give a better estimative of the computations needed to be performed on a traversal than using a total tree. This more accurate information can be used dynamically to decide if a function call is to be memoized or not <ref> [Pug88] </ref>. 5.2 Parallel Computation Implicit parallelism exhibit by multiple traversal algorithms may be hidden by the circular detnitions. In a circular program it may be impossible to discover 12 which traversal functions may be computed in parallel. Consider for example the circular program presented in tgure 1.
Reference: [RR96] <author> Colin Runciman and Niklas Rjemo. </author> <title> Heap protling for space eciency. </title> <editor> In John Launchbury, Erik Meijer, and Tim Sheard, editors, </editor> <booktitle> Second International School on Advanced Functional Programming, volume 1129 of LNCS, </booktitle> <pages> pages 159183. </pages> <publisher> Springer-Verlag, </publisher> <year> 1996. </year>
Reference-contexts: The protle was produced by the nhc heap protler <ref> [RR96] </ref>. This protle shows a heap that grows quickly to a peak size of 50kbyte diminishing afterwards. The unnecessary accumulation of the environment is causing this huge memory consumption (lrc cons env, which constructs the environment, produces 70% of the total heap space).
Reference: [RTD83] <author> Thomas Reps, Tim Teitelbaum, and Alan Demers. </author> <title> Incremental context-dependent analysis for language-based editors. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 5(3):449477, </volume> <month> July </month> <year> 1983. </year>
Reference-contexts: Traditional techniques for incremental attribute evaluations which are based on change propagation <ref> [RTD83] </ref> do not handle higher order attribute grammars eciently [CP96]. An ecient and elegant incremental attribute evaluator can be implemented through visit function memoization [CP96].
Reference: [VSK91] <author> Harald Vogt, Doaitse Swierstra, and Matthijs Kuiper. </author> <title> Ecient incremental evaluation of higher order attribute grammars. </title> <editor> In J. Maluszynki and M. Wirsing, editors, </editor> <booktitle> Programming Language Implementation and Logic Programming, volume 528 of LNCS, </booktitle> <pages> pages 231242. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <month> 15 </month>
Reference-contexts: The work described here originates from our work on constructing an incremental evaluator for higher-order attribute grammars <ref> [VSK91] </ref>; the traditional approaches for evaluating attribute grammars i.e. the decoration of an abstract syntax tree by means of a generated tree-walking automaton proved to be no longer applicable due to the fact that the abstract syntax tree (i.e. the argument controlling the overall computation) is no longer an invariant data
References-found: 16

