URL: ftp://www.cs.rutgers.edu/pub/technical-reports/lcsr-tr-250-a.ps.Z
Refering-URL: http://www.cs.rutgers.edu/pub/technical-reports/
Root-URL: 
Email: email: fpande,ryderg@cs.rutgers.edu  
Phone: phone: (908)445-f4070,3699g  
Title: Static Type Determination and Aliasing for C  
Author: Hemant D. Pande Barbara G. Ryder 
Address: Piscataway, NJ 08855  
Affiliation: Department of Computer Science Rutgers University Hill Center, Busch Campus  
Abstract: Laboratory of Computer Science Research Technical Report LCSR-TR-250-A, October 1995 Abstract Determining the type of an object to which a pointer may point at each statement during execution is the goal of static type determination. We prove NP-hardness of type determination and aliasing for C ++ . We show the interdependence of the two problems for general-purpose pointers and present a polynomial approximation algorithm to solve the combined problem. We include empirical results to demonstrate the feasibility of our analysis. 
Abstract-found: 1
Intro-found: 1
Reference: [AH95] <author> A. Agesen and U. Holzle. </author> <title> Type feedback vs. concrete type inference: a comparison of optimization techniques for object-oriented languages. </title> <institution> Department of Computer Science Technical Report TRCS 95-04, University of Califor-nia, Santa Barbara, </institution> <month> March </month> <year> 1995. </year>
Reference-contexts: Related Work 1 Recent research in optimizations for object-oriented languages has mainly concentrated on two analysis techniques: type feedback (run time) and type inference (compile time). A comparison of the two techniques appears in <ref> [AH95] </ref>. (*The following abbreviated discussion of related work will be expanded in the full paper.*) Notable recent research on type feedback includes work by Calder and Grunwald [CG94], Holzle and Ungar [HU94], and Dean et al. [DCG95].
Reference: [APS93] <author> O. Agesen, J. Palsberg, and M Schwartzbach. </author> <title> Type inference of SELF: Analysis of objects with dynamic and multiple inheritance. </title> <booktitle> In ECOOP '93 Conference Proceedings, </booktitle> <pages> pages 247-267, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: Diwan et al. apply hierarchy information and a limited form of static analysis to optimize Modula-3 programs [DMM95]. Agesen et al. present a polynomial time constraint based type inferencing algorithm for SELF <ref> [APS93] </ref>. Kumar et al. improve on this technique by utilizing the Static Single Assignment form of object-oriented programs [KAI95]. Plevyak and Chien describe an incremental constraint based type inference technique for Concurrent Aggregates, a concurrent object-oriented language [PC94].
Reference: [BCC + 94] <author> M. Burke, P. Carini, J-D. Choi and M. Hind. </author> <title> Flow-insensitive interprocedural alias analysis in the presence of pointers. </title> <booktitle> In Proceedings of the Seventh International Workshop on Languages and Compilers for Parallel Computing, </booktitle> <month> August </month> <year> 19994. </year>
Reference-contexts: Since virtual function calls in C ++ can be modeled using function pointers in C, algorithms which handle them <ref> [BCC + 94, EGH94, WL95, Wei80] </ref> may be applied towards analysis of C ++ . Nevertheless, these approaches i) have a different emphasis and are ill-tuned to function pointer analysis and/or ii) have impractical worst case complexity, and are unsuitable in C ++ context where virtual functions are ubiquitous.
Reference: [Bar78] <author> J. Barth. </author> <title> A practical interprocedural data flow analysis algorithm. </title> <journal> In Communications of the ACM, </journal> <volume> 21(9) </volume> <pages> 724-736, </pages> <month> September </month> <year> 1978. </year>
Reference-contexts: A more recent paper [RHS95] also addresses these issues. 4 Under the standard assumption of static analysis that all intraprocedural paths are executable <ref> [Bar78] </ref>. 3 3 Approximate Type Determination and Aliasing Algorithm Aliasing and Type Determination In programs restricted to single level pointers, one pointer cannot be aliased to another, as this requires multiple levels of indirection [LR91].
Reference: [CBC93] <author> J.-D. Choi, M. Burke, and P. Carini. </author> <title> Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. </title> <booktitle> In Proceedings of the Twentieth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1993. </year>
Reference: [CG94] <author> B. Calder and D. Grunwald. </author> <title> Reducing indirect function call overhead in C ++ programs. </title> <booktitle> In Proceedings of the Twenty First Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January </month> <year> 1994. </year>
Reference-contexts: code in suitable circumstances. (*In the full paper we will supply an example of optimizations enabled by our analysis.*) Recent empirical studies of dynamic behavior of C ++ programs indicate there is opportunity to avoid late bindings in many cases, which is particularly significant for architectures which employ deep pipelin-ing <ref> [CG94] </ref>. A uniquely resolved call site would eliminate pipeline delays, as the target of the call is unambiguously known. Short-listing the functions may allow the compiler to replace the late binding mechanism of virtual call with appropriate function calls within a decision statement. <p> A comparison of the two techniques appears in [AH95]. (*The following abbreviated discussion of related work will be expanded in the full paper.*) Notable recent research on type feedback includes work by Calder and Grunwald <ref> [CG94] </ref>, Holzle and Ungar [HU94], and Dean et al. [DCG95]. We briefly discuss the type inference techniques based on class hierarchy, type constraints, function pointer analysis and control flow analysis of higher order languages. <p> In Figure 5 we classify the reachable virtual call sites in terms of the number of virtual functions found invocable. Our results corroborate the observation by Calder and Grunwald that although object-oriented libraries support polymorphism through virtual functions, the target of most indirect function calls can be accurately predicted <ref> [CG94] </ref>. While their observation is based on execution profiles of programs, our results eliminate the dependence on profile data by using compile time analysis which accounts for all possible executions of the program.
Reference: [CU89] <author> C. Chambers and D. Ungar. </author> <title> Customization: optimizing compiler technology for SELF, a dynamically-typed object-oriented programming language. </title> <booktitle> In Proceedings of the SIGPLAN '89 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 146-160, </pages> <month> June </month> <year> 1989. </year>
Reference-contexts: Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques [JW95]. Earlier work on dynamically dispatched methods includes <ref> [CU89, CU90, HCU91, Lar92, PS91, Par92, SS92, Suz81, VHU92] </ref>. 2 Problem Definition Program Representation A control flow graph (CFG) for a function consists of nodes which represent single-entry, single-exit regions of executable code, and edges which represent possible execution branches between code regions.
Reference: [CU90] <author> C. Chambers and D. Ungar. </author> <title> Iterative type analysis and extended message splitting: optimizing dynamically-typed object-oriented programs. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 150-164, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques [JW95]. Earlier work on dynamically dispatched methods includes <ref> [CU89, CU90, HCU91, Lar92, PS91, Par92, SS92, Suz81, VHU92] </ref>. 2 Problem Definition Program Representation A control flow graph (CFG) for a function consists of nodes which represent single-entry, single-exit regions of executable code, and edges which represent possible execution branches between code regions.
Reference: [DCG95] <author> J. Dean, C. Chambers and D. Grove. </author> <title> Selective specialization for object-oriented languages. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 93-102, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: A comparison of the two techniques appears in [AH95]. (*The following abbreviated discussion of related work will be expanded in the full paper.*) Notable recent research on type feedback includes work by Calder and Grunwald [CG94], Holzle and Ungar [HU94], and Dean et al. <ref> [DCG95] </ref>. We briefly discuss the type inference techniques based on class hierarchy, type constraints, function pointer analysis and control flow analysis of higher order languages. The type determination aspect of our work can be viewed as type inference using data flow analysis.
Reference: [DMM95] <author> A. Diwan, J. Eliot B. Moss and and K. S. McKinley. </author> <title> Analyzing statically-typed object-oriented programs for modern processors. </title> <type> Technical Report, </type> <institution> Department of Computer Science, University of Massachusetts, Amherst, </institution> <month> July </month> <year> 1995. </year>
Reference-contexts: Class hierarchy information is used at link time by Fernandez to replace method invocations with direct calls in Modula-3 programs [Fer95]. Diwan et al. apply hierarchy information and a limited form of static analysis to optimize Modula-3 programs <ref> [DMM95] </ref>. Agesen et al. present a polynomial time constraint based type inferencing algorithm for SELF [APS93]. Kumar et al. improve on this technique by utilizing the Static Single Assignment form of object-oriented programs [KAI95].
Reference: [EGH94] <author> M. Emami, R. Ghiya and L. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 242-256, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Since virtual function calls in C ++ can be modeled using function pointers in C, algorithms which handle them <ref> [BCC + 94, EGH94, WL95, Wei80] </ref> may be applied towards analysis of C ++ . Nevertheless, these approaches i) have a different emphasis and are ill-tuned to function pointer analysis and/or ii) have impractical worst case complexity, and are unsuitable in C ++ context where virtual functions are ubiquitous.
Reference: [Fer95] <author> M. Fernandez. </author> <title> Simple and effective link-time optimization of Modula-3 programs. </title> <booktitle> In Proceedings of the SIG-PLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 103-115, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: The type determination aspect of our work can be viewed as type inference using data flow analysis. Class hierarchy information is used at link time by Fernandez to replace method invocations with direct calls in Modula-3 programs <ref> [Fer95] </ref>. Diwan et al. apply hierarchy information and a limited form of static analysis to optimize Modula-3 programs [DMM95]. Agesen et al. present a polynomial time constraint based type inferencing algorithm for SELF [APS93].
Reference: [HCU91] <author> U. Holzle, C. Chambers and D. Ungar. </author> <title> Optimizing dynamically-typed object-oriented languages with polymorphic inline caches. </title> <booktitle> In Proceedings of the European Conference on Object Oriented Programming, </booktitle> <month> July </month> <year> 1991. </year>
Reference-contexts: Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques [JW95]. Earlier work on dynamically dispatched methods includes <ref> [CU89, CU90, HCU91, Lar92, PS91, Par92, SS92, Suz81, VHU92] </ref>. 2 Problem Definition Program Representation A control flow graph (CFG) for a function consists of nodes which represent single-entry, single-exit regions of executable code, and edges which represent possible execution branches between code regions.
Reference: [HU94] <author> U. Holzle and D. Ungar. </author> <title> Optimizing dynamically-dispatched calls with tun-time type feedback. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 326-336, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: A comparison of the two techniques appears in [AH95]. (*The following abbreviated discussion of related work will be expanded in the full paper.*) Notable recent research on type feedback includes work by Calder and Grunwald [CG94], Holzle and Ungar <ref> [HU94] </ref>, and Dean et al. [DCG95]. We briefly discuss the type inference techniques based on class hierarchy, type constraints, function pointer analysis and control flow analysis of higher order languages. The type determination aspect of our work can be viewed as type inference using data flow analysis.
Reference: [Har89] <author> L. W. Harrison III. </author> <title> The interprocedural analysis and automatic parallelization of Scheme programs. </title> <journal> Lisp and Symbolic Computation, </journal> 2(3/4):179-396, 1989. 
Reference-contexts: Nevertheless, these approaches i) have a different emphasis and are ill-tuned to function pointer analysis and/or ii) have impractical worst case complexity, and are unsuitable in C ++ context where virtual functions are ubiquitous. Techniques for flow analysis of higher order languages like Scheme <ref> [Har89, JM79, Shi90] </ref> may be adapted for analyzing function pointers (and hence C ++ ); however, they do not have acceptable complexity for reasonable precision on real programs. Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques [JW95].
Reference: [JM79] <author> N. Jones and S. Muchnick. </author> <title> Flow analysis and optimization of lisp-like structures. </title> <booktitle> In Conference Record of the Sixth Annual ACM symposium on Principles of Programming Languages, </booktitle> <pages> pages 244-256, </pages> <month> January </month> <year> 1979. </year>
Reference-contexts: Nevertheless, these approaches i) have a different emphasis and are ill-tuned to function pointer analysis and/or ii) have impractical worst case complexity, and are unsuitable in C ++ context where virtual functions are ubiquitous. Techniques for flow analysis of higher order languages like Scheme <ref> [Har89, JM79, Shi90] </ref> may be adapted for analyzing function pointers (and hence C ++ ); however, they do not have acceptable complexity for reasonable precision on real programs. Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques [JW95]. <p> To reduce the number and length of object names (and subsequently the number of aliases and pointer-types) to a finite number, we use the notion of k-limiting, similar to that introduced by Jones and Muchnick <ref> [JM79] </ref>. Intuitively, k-limiting implies that up to k explicit dereferences are maintained in an object name and further dereferences are abstracted into a special # dereference. For example, we represent p!next!next!next!i by p!next!next#, where k is 2.
Reference: [JW95] <author> S. Jagannathan and A. Wright. </author> <title> Efficient flow analysis for avoiding run-time checks. In Proceedings of the Second International Static Analysis Symposium (SAS '95). </title> <note> Also appears as Springer-Verlag LNCS-983. </note>
Reference-contexts: Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques <ref> [JW95] </ref>.
Reference: [KAI95] <author> S. Kumar, D. P. Agrawal and S. P. Iyer. </author> <title> An improved type-inference algorithm to expose parallelism in object-oriented programs. </title> <booktitle> In Proceedings of the Third Workshop on Languages, Compilers, and Run-Time Systems for Scalable Computers, </booktitle> <publisher> Kluwer Academic Publications, </publisher> <address> Troy, New York, </address> <month> May 22-24, </month> <year> 1995. </year>
Reference-contexts: Agesen et al. present a polynomial time constraint based type inferencing algorithm for SELF [APS93]. Kumar et al. improve on this technique by utilizing the Static Single Assignment form of object-oriented programs <ref> [KAI95] </ref>. Plevyak and Chien describe an incremental constraint based type inference technique for Concurrent Aggregates, a concurrent object-oriented language [PC94].
Reference: [LR91] <author> W. Landi and B. G. Ryder. </author> <title> Pointer-induced aliasing: A problem classification. </title> <booktitle> In Conference Record of the Eighteenth Annual ACM symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: We represent a program with an interprocedural control flow graph (ICFG), which intuitively is the union of CFGs for the individual functions comprising the program <ref> [LR91, PR94] </ref>. Formally, an ICFG is a triple (N , E , ) where N is the set of nodes, E is the set of edges and is the entry node for main. <p> Terminology * An ICFG path is realizable if, whenever a called function on that path returns, it returns to the corresponding return node of the call site which invoked it <ref> [LR91] </ref>. Not all ICFG paths are realizable. * A realizable path is balanced if for each intermediate call node, the path contains a corresponding return node representing the return of control from the called function 3 . <p> An easy corollary follows, since the theorem involves a subproblem of the general type determination and aliasing problem.*) 3 We defined the terms realizable and balanced paths independently <ref> [LR91, PR94a] </ref>, and have only recently found that the ideas already existed in literature, referred to as valid and complete respectively in [SP81]. <p> these issues. 4 Under the standard assumption of static analysis that all intraprocedural paths are executable [Bar78]. 3 3 Approximate Type Determination and Aliasing Algorithm Aliasing and Type Determination In programs restricted to single level pointers, one pointer cannot be aliased to another, as this requires multiple levels of indirection <ref> [LR91] </ref>. As a result, when a pointer changes its value (to point to an object of another type), it does not affect the value of any other pointers [PR94]. <p> Thus, aliasing affects type determination and vice versa. In this section, we formulate the combined problem and state our tractable approximation of it. Then, we describe our algorithm at a high level, aided by examples. Problem Formulation Conditional analysis <ref> [LR91] </ref> involves analyzing execution flow in a function, assuming certain information holds at the entry of the function.
Reference: [LR92] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '92 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 235-248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: Similarly, we represent the return of control from the called function by an interprocedural edge from the exit node to the return node. However, virtual function invocation makes it impossible to determine the correspondence 1 For related work on pointer-induced aliasing for imperative languages, see <ref> [LR92] </ref>. 2 We use the terms call and invocation interchangeably. 2 between a call and entry before analysis, since the function invoked depends on the type of the receiver at the call site. <p> path from to the entry node of the procedure containing node n, on which AAP T (if any) holds and there exists a conditionally consistent path P n;fAAP Tg 5 S 0 serves as an approximation of the call stack at the invocation, similar to the reaching alias abstraction in <ref> [LR92, LRZ93] </ref>. An abstraction determines how well the algorithm approximates consistent paths. 6 In our previous papers [PR94, PR94a], points-to-type was called points-to. 7 AAPT may be ;. 4 to n on which &lt;a; b&gt; holds. <p> class. type-bind (call c2 ; entry C::bar ; &lt;r!d1 ) B&gt;) includes: f&lt;r!d1 ) B&gt;; &lt;bar2 ) B&gt;g 3.3 Initialization and Introduction Phases The algorithm starts by lazily initializing all the points-to-type and may-hold predicates to false; this enables us to perform initialization of all the predicates in constant time <ref> [LR92] </ref>. We also initialize the worklist to empty. The intraprocedural aspects of the introduction phase are summarized in Figure 3. This introduces pointer-type and alias pairs generated locally at a pointer assignment ICFG node. <p> The prototype is written in C and runs on a Sun SPARC-20. We are using the MasterCraft C ++ system of Tata Consultancy Services as the front end C ++ parser for the implementation. Our aliasing and type determination algorithm reuses some code from Landi-Ryder aliasing algorithm <ref> [LR92] </ref> with suitable modifications. We present empirical results of analyzing 19 C ++ programs obtained from various (publicly available) sources such as textbooks, demonstration programs accompanying a C ++ compiler and undergraduate projects.
Reference: [LRZ93] <author> W. Landi, B. G. Ryder, and S. Zhang. </author> <title> Interprocedural modification side effect analysis with pointer aliasing. </title> <booktitle> In Proceedings of the SIGPLAN '93 Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1993. </year>
Reference-contexts: path from to the entry node of the procedure containing node n, on which AAP T (if any) holds and there exists a conditionally consistent path P n;fAAP Tg 5 S 0 serves as an approximation of the call stack at the invocation, similar to the reaching alias abstraction in <ref> [LR92, LRZ93] </ref>. An abstraction determines how well the algorithm approximates consistent paths. 6 In our previous papers [PR94, PR94a], points-to-type was called points-to. 7 AAPT may be ;. 4 to n on which &lt;a; b&gt; holds.
Reference: [Lan92] <author> W. Landi. </author> <title> Interprocedural aliasing in the presence of pointers. </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Science, Rutgers University, </institution> <month> January </month> <year> 1992. </year>
Reference: [Lar92] <author> J. M. Larcheveque. </author> <title> Interprocedural type propagation for object-oriented languages. </title> <booktitle> In proceedings of the Fourth European Symposium on Programming (ESOP '92), </booktitle> <month> February </month> <year> 1992. </year> <month> 14 </month>
Reference-contexts: Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques [JW95]. Earlier work on dynamically dispatched methods includes <ref> [CU89, CU90, HCU91, Lar92, PS91, Par92, SS92, Suz81, VHU92] </ref>. 2 Problem Definition Program Representation A control flow graph (CFG) for a function consists of nodes which represent single-entry, single-exit regions of executable code, and edges which represent possible execution branches between code regions.
Reference: [MLR + 93] <author> T. J. Marlowe, W. A. Landi, B. G. Ryder, J. Choi, M. Burke, and P. Carini. </author> <title> Pointer-induce aliasing: A clarification. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(9), </volume> <month> September </month> <year> 1993. </year>
Reference: [PC94] <author> J. Plevyak and A. Chien. </author> <title> Precise concrete type inference for object oriented languages. </title> <booktitle> In Proceeding of Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA '94), </booktitle> <pages> pages 324-340, </pages> <month> October </month> <year> 1994. </year>
Reference-contexts: Kumar et al. improve on this technique by utilizing the Static Single Assignment form of object-oriented programs [KAI95]. Plevyak and Chien describe an incremental constraint based type inference technique for Concurrent Aggregates, a concurrent object-oriented language <ref> [PC94] </ref>. While constraint based inferencing is most suitable for purely dynamic, untyped languages like SELF and ours for typed languages like C ++ , the two approaches may supplement each other for languages which combine these separate domains.
Reference: [PLR94] <author> H. D. Pande, W. Landi and B. G. Ryder. </author> <title> Interprocedural def-use associations for C systems with single level pointers. </title> <journal> In IEEE Transactions on Software Engineering, </journal> <volume> SE-20(5):385-403, </volume> <month> May </month> <year> 1994. </year>
Reference: [PR94] <author> H. D. Pande and B. G. Ryder. </author> <booktitle> Static type determination for C ++ . In Proceedings of USENIX Sixth C ++ Technical Conference, </booktitle> <pages> pages 85-97, </pages> <month> April </month> <year> 1994. </year>
Reference-contexts: Also, exclusion of the statically non-invocable functions from analysis can eliminate spurious side effects, thereby improving the precision of subsequent analyses. Last year, we presented a static type determination algorithm for C ++ programs restricted to using only single level pointers <ref> [PR94] </ref>. In this context, type determination can be solved independent of aliasing. However, in the presence of multiple level pointers, these two problems cannot be solved separately, but are interdependent. We have designed a combined approximation algorithm that solves type determination and aliasing simultaneously for C ++ programs. <p> We represent a program with an interprocedural control flow graph (ICFG), which intuitively is the union of CFGs for the individual functions comprising the program <ref> [LR91, PR94] </ref>. Formally, an ICFG is a triple (N , E , ) where N is the set of nodes, E is the set of edges and is the entry node for main. <p> As a result, when a pointer changes its value (to point to an object of another type), it does not affect the value of any other pointers <ref> [PR94] </ref>. In this context, type determination impinges on aliasing since the receiver types decide which virtual function is invoked at a call site, and the invoked function can affect aliasing. Nevertheless, aliasing plays no part in type determination. Such a separation does not occur when we allow multiple level pointers. <p> An abstraction determines how well the algorithm approximates consistent paths. 6 In our previous papers <ref> [PR94, PR94a] </ref>, points-to-type was called points-to. 7 AAPT may be ;. 4 to n on which &lt;a; b&gt; holds.
Reference: [PR94a] <author> H. D. Pande and B. G. Ryder. </author> <title> Static type determination and aliasing for C ++ . Laboratory of Computer Science Research Technical Report LCSR-TR-236, </title> <institution> Rutgers University, </institution> <month> December </month> <year> 1994. </year> <note> Note: This is an expanded version of [PR94]. </note>
Reference-contexts: An easy corollary follows, since the theorem involves a subproblem of the general type determination and aliasing problem.*) 3 We defined the terms realizable and balanced paths independently <ref> [LR91, PR94a] </ref>, and have only recently found that the ideas already existed in literature, referred to as valid and complete respectively in [SP81]. <p> An abstraction determines how well the algorithm approximates consistent paths. 6 In our previous papers <ref> [PR94, PR94a] </ref>, points-to-type was called points-to. 7 AAPT may be ;. 4 to n on which &lt;a; b&gt; holds.
Reference: [PS91] <author> J. Palsberg and M. Schwartzbach. </author> <title> Object-oriented type inference. </title> <booktitle> In Proceedings of Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA '91), </booktitle> <pages> pages 146-161, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques [JW95]. Earlier work on dynamically dispatched methods includes <ref> [CU89, CU90, HCU91, Lar92, PS91, Par92, SS92, Suz81, VHU92] </ref>. 2 Problem Definition Program Representation A control flow graph (CFG) for a function consists of nodes which represent single-entry, single-exit regions of executable code, and edges which represent possible execution branches between code regions.
Reference: [Pan95] <author> H. D. Pande. </author> <title> Interprocedural compile time analysis of C and C ++ systems. </title> <type> PhD Thesis, </type> <institution> Department of Computer Science, Rutgers University, </institution> <note> in preparation, </note> <year> 1995. </year>
Reference-contexts: We use the pair in S 0 (i) to approximate a conditionally consistent path to n, and (ii) as the only necessary assumption for conditional analysis 5 . This approximation leads to a safe overestimate of consistent paths and conditional analysis solution <ref> [Pan95] </ref>. <p> Similarly, if there exists an execution path to node n on which &lt;a; b&gt; holds, our algorithm will report may-hold (n; AAP T; &lt;a; b&gt;) for some AAPT. The worst case complexity of our algorithm is polynomial in the number of ICFG nodes <ref> [Pan95] </ref>. <p> predicates true and put them on the worklist. (*Sections 3.3-3.5 will be expanded in the full paper.*) The calculation of a fixed point for points-to-type and may-hold is tantamount to the solution of a monotone data flow framework defined on a lattice whose elements are sets of [assumption, alias/pointer-type] tuples <ref> [Pan95] </ref>. Whenever a predicate becomes true for the first time, it is placed on the worklist. We refer to this action as make-true. Once marked true, a predicate stays true. <p> Details of the algorithm in the presence of k-limited object names and the impact of k-limiting on analysis precision are beyond the purview of this paper, and appear in <ref> [Pan95] </ref>. 4 Implementation Results The results presented in this section represent our efforts to empirically demonstrate the contributions of the algorithm and assess its practicality using a prototype implementation. The prototype is written in C and runs on a Sun SPARC-20. <p> We also observed that the size of alias and pointer-type solution usually decreased with lower values of k. This was the net result of two opposite effects of k-limiting <ref> [Pan95] </ref>: On the one hand, multiple object names may map to a single k-limited object name for a lower value of k, leading to reduction in the number of object names and correspondingly alias and pointer-type solution size.
Reference: [Par92] <author> R. Parameswaran. </author> <title> Interprocedural alias and type analysis for pointers. </title> <type> Masters Thesis, </type> <institution> Department of Computer Science, University of Wisconsin - Madison, </institution> <year> 1992. </year>
Reference-contexts: Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques [JW95]. Earlier work on dynamically dispatched methods includes <ref> [CU89, CU90, HCU91, Lar92, PS91, Par92, SS92, Suz81, VHU92] </ref>. 2 Problem Definition Program Representation A control flow graph (CFG) for a function consists of nodes which represent single-entry, single-exit regions of executable code, and edges which represent possible execution branches between code regions.
Reference: [RHS95] <author> T. Reps, S. Horwitz and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In Twenty Second Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: A more recent paper <ref> [RHS95] </ref> also addresses these issues. 4 Under the standard assumption of static analysis that all intraprocedural paths are executable [Bar78]. 3 3 Approximate Type Determination and Aliasing Algorithm Aliasing and Type Determination In programs restricted to single level pointers, one pointer cannot be aliased to another, as this requires multiple levels
Reference: [Ruf95] <author> E. Ruf. </author> <title> Context-insensitive alias analysis reconsidered. </title> <booktitle> In Proceedings of the SIGPLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> Pages 13-22, </pages> <month> June </month> <year> 1995. </year>
Reference: [SP81] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. In Program Flow Analysis: Theory and Applications, </title> <editor> ed. S. S. Muchnick and N. D. Jones, </editor> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, NJ. </address> <pages> Pages 189-233, </pages> <year> 1981. </year>
Reference-contexts: An easy corollary follows, since the theorem involves a subproblem of the general type determination and aliasing problem.*) 3 We defined the terms realizable and balanced paths independently [LR91, PR94a], and have only recently found that the ideas already existed in literature, referred to as valid and complete respectively in <ref> [SP81] </ref>.
Reference: [SS92] <author> M. Suedholt and C. Steigner. </author> <title> On interprocedural data flow analysis for object oriented languages. </title> <booktitle> In Proceedings of the International Conference on Compiler Construction, </booktitle> <address> Germany, </address> <year> 1992. </year>
Reference-contexts: Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques [JW95]. Earlier work on dynamically dispatched methods includes <ref> [CU89, CU90, HCU91, Lar92, PS91, Par92, SS92, Suz81, VHU92] </ref>. 2 Problem Definition Program Representation A control flow graph (CFG) for a function consists of nodes which represent single-entry, single-exit regions of executable code, and edges which represent possible execution branches between code regions.
Reference: [Shi90] <author> O. Shivers. </author> <title> Data-flow analysis and type recovery in Scheme. </title> <booktitle> In Topics in Advanced Language Implementation, </booktitle> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Nevertheless, these approaches i) have a different emphasis and are ill-tuned to function pointer analysis and/or ii) have impractical worst case complexity, and are unsuitable in C ++ context where virtual functions are ubiquitous. Techniques for flow analysis of higher order languages like Scheme <ref> [Har89, JM79, Shi90] </ref> may be adapted for analyzing function pointers (and hence C ++ ); however, they do not have acceptable complexity for reasonable precision on real programs. Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques [JW95].
Reference: [Suz81] <author> N. Suzuki. </author> <title> Inferring types in smalltalk. </title> <booktitle> In Eighth Symposium on Principles of Programming Languages, </booktitle> <pages> pages 187-199, </pages> <month> January </month> <year> 1981. </year>
Reference-contexts: Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques [JW95]. Earlier work on dynamically dispatched methods includes <ref> [CU89, CU90, HCU91, Lar92, PS91, Par92, SS92, Suz81, VHU92] </ref>. 2 Problem Definition Program Representation A control flow graph (CFG) for a function consists of nodes which represent single-entry, single-exit regions of executable code, and edges which represent possible execution branches between code regions.
Reference: [VHU92] <author> J. Vitek, R. N. Harspool and J. S. Uhl. </author> <title> Compile-time analysis of object oriented programs. </title> <booktitle> In Proceedings of the International Conference on Compiler Construction, </booktitle> <address> Germany, </address> <year> 1992. </year>
Reference-contexts: Jagannathan and Wright compare various existing techniques for analysis of such languages and motivate the need for alternative data flow techniques [JW95]. Earlier work on dynamically dispatched methods includes <ref> [CU89, CU90, HCU91, Lar92, PS91, Par92, SS92, Suz81, VHU92] </ref>. 2 Problem Definition Program Representation A control flow graph (CFG) for a function consists of nodes which represent single-entry, single-exit regions of executable code, and edges which represent possible execution branches between code regions.
Reference: [WL95] <author> R. Wilson and M. Lam. </author> <title> Efficient Context-Sensitive Pointer Analysis for C Programs. </title> <booktitle> In Proceedings of the SIG-PLAN '95 Conference on Programming Language Design and Implementation, </booktitle> <pages> Pages 1-12, </pages> <month> June </month> <year> 1995. </year>
Reference-contexts: Since virtual function calls in C ++ can be modeled using function pointers in C, algorithms which handle them <ref> [BCC + 94, EGH94, WL95, Wei80] </ref> may be applied towards analysis of C ++ . Nevertheless, these approaches i) have a different emphasis and are ill-tuned to function pointer analysis and/or ii) have impractical worst case complexity, and are unsuitable in C ++ context where virtual functions are ubiquitous.
Reference: [Wei80] <author> W. E. Weihl. </author> <title> Interprocedural data flow analysis in the presence of pointers, procedure variables and label variables. </title> <booktitle> In Seventh Symposium on Principles of Programming Languages, </booktitle> <pages> pages 83-94, </pages> <year> 1980. </year> <month> 15 </month>
Reference-contexts: Since virtual function calls in C ++ can be modeled using function pointers in C, algorithms which handle them <ref> [BCC + 94, EGH94, WL95, Wei80] </ref> may be applied towards analysis of C ++ . Nevertheless, these approaches i) have a different emphasis and are ill-tuned to function pointer analysis and/or ii) have impractical worst case complexity, and are unsuitable in C ++ context where virtual functions are ubiquitous.
References-found: 40

