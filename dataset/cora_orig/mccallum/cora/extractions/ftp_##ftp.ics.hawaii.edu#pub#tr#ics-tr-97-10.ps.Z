URL: ftp://ftp.ics.hawaii.edu/pub/tr/ics-tr-97-10.ps.Z
Refering-URL: ftp://ftp.ics.hawaii.edu/pub/tr/INDEX.html
Root-URL: 
Email: corbett@hawaii.edu  
Title: Constructing Compact Models of Concurrent Java Programs  
Author: James C. Corbett 
Keyword: Static Analysis, Model Extraction, Finite-state Verification  
Address: Honolulu, HI 96822  
Affiliation: Department of Information and Computer Science University of Hawai`i  
Abstract: Finite-state verification technology (e.g., model checking) provides a powerful means to detect con-currency errors, which are often subtle and difficult to reproduce. Nevertheless, widespread use of this technology by developers is unlikely until tools provide automated support for extracting the required finite-state models directly from program source. In this paper, we explore the extraction of compact concurrency models from Java code. In particular, we show how static pointer analysis, which has traditionally been used for computing alias information in optimizers, can be used to greatly reduce the size of finite-state models of concurrent Java programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> E. Ashcroft and Z. Manna. </author> <title> Formalization of properties of parallel programs. </title> <journal> Machine Intelligence, </journal> <volume> 6 </volume> <pages> 17-41, </pages> <year> 1971. </year>
Reference-contexts: This can be exploited to reduce the size of the model. The main contribution of this paper is to show how static pointer analysis can be used to reduce the size of finite-state models of concurrent Java programs. The method employs virtual coarsening <ref> [1] </ref>, a well-known technique for reducing the size of concurrency models by collapsing invisible actions (e.g., updates to variables that are local or protected by a lock) into adjacent visible actions. <p> Instead, we construct a reduced transition system (S fl ; T fl ) where S fl S and use this for the analysis. We reduce the size of the transition system using virtual coarsening <ref> [1] </ref>, a well-known technique for reducing the size of concurrency models by amalgamating transitions. Since we are using an interleaving model of concurrency, reducing the number of transitions in each thread greatly reduces the number of possible states by eliminating the interleavings of the collapsed transition sequences.
Reference: [2] <author> G. S. Avrunin, U. A. Buy, J. C. Corbett, L. K. Dillon, and J. C. Wileden. </author> <title> Automated analysis of concurrent systems with the constrained expression toolset. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 17(11) </volume> <pages> 1204-1222, </pages> <month> Nov. </month> <year> 1991. </year>
Reference-contexts: Most previous work on concurrency analysis of software has used Ada <ref> [7, 13, 12, 2, 3, 8] </ref>. Although some aspects of these methods can also be applied to Java programs, the Java language presents several new challenges/opportunities: 1.
Reference: [3] <author> T. Bultan, J. Fisher, and R. Gerber. </author> <title> Compositional verification by model checking for counter examples. </title> <booktitle> In Ziel [14], </booktitle> <pages> pages 224-238. </pages>
Reference-contexts: Most previous work on concurrency analysis of software has used Ada <ref> [7, 13, 12, 2, 3, 8] </ref>. Although some aspects of these methods can also be applied to Java programs, the Java language presents several new challenges/opportunities: 1.
Reference: [4] <author> D. R. Chase, M. Wegman, and F. K. Zadeck. </author> <title> Analysis of pointers and structures. </title> <booktitle> In Proceedings of the ACM SIGPLAN'90 Conference on Programming Language Design and Implementation (PLDI), </booktitle> <pages> pages 296-310, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: Several different algorithms have been proposed, differing in the method of approximation. Our algorithm is an extension of the simple algorithm given by Chase et al <ref> [4] </ref>, which uses this basic approach. We extend Chase's algorithm in three ways. First, we handle multi-threading; Chase's algorithm is for sequential code. Second, we distinguish current and summary heap nodes; this allows us to collect information on one-to-one relationships between objects. <p> We often omit disconnected nodes (e.g., the summary node for an allocator that is not in a loop). Note that the linked list is represented with a self loop on node 2:C*. Like Chase et al <ref> [4] </ref>, we distinguish objects of the same class that were allocated by different allocators. This heuristic is based on the observation that objects allocated by a given allocator tend to be treated similarly.
Reference: [5] <author> J. C. Corbett. </author> <title> Timing analysis of Ada tasking programs. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 22(7) </volume> <pages> 461-483, </pages> <year> 1996. </year>
Reference-contexts: The method of constructing the transition system representing a Java program is similar to the method presented in <ref> [5] </ref> for constructing the (untimed) transition system representing an Ada program.
Reference: [6] <author> D. L. Dill, A. J. Drexler, A. J. Hu, and C. H. Yang. </author> <title> Protocol verification as a hardware design aid. </title> <booktitle> In IEEE International Conference on Computer Design, </booktitle> <month> Octo-ber </month> <year> 1992. </year>
Reference-contexts: Although a model that restricts the range of a variable does not represent all possible behaviors of the program and thus cannot technically be used to verify the program has a property, the conventional wisdom is that most concurrency errors are present in small versions of a system <ref> [6, 9] </ref>, thus these models can still be useful for finding errors (testing). Most previous work on concurrency analysis of software has used Ada [7, 13, 12, 2, 3, 8].
Reference: [7] <author> S. Duri, U. Buy, R. Devarapalli, and S. M. Shatz. </author> <title> Using state space reduction methods for deadlock analysis in Ada tasking. </title> <editor> In T. Ostrand and E. Weyuker, editors, </editor> <booktitle> Proceedings of the 1993 International Symposium on Software Testing and Analysis (ISSTA), </booktitle> <pages> pages 51-60, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Most previous work on concurrency analysis of software has used Ada <ref> [7, 13, 12, 2, 3, 8] </ref>. Although some aspects of these methods can also be applied to Java programs, the Java language presents several new challenges/opportunities: 1.
Reference: [8] <author> M. B. Dwyer and L. A. Clarke. </author> <title> Data flow analysis for verifying properties of concurrent programs. </title> <editor> In D. Wile, editor, </editor> <booktitle> Proceedings of the Second Symposium on Foundations of Software Engineering, </booktitle> <pages> pages 62-75, </pages> <month> Dec. </month> <year> 1994. </year>
Reference-contexts: Most previous work on concurrency analysis of software has used Ada <ref> [7, 13, 12, 2, 3, 8] </ref>. Although some aspects of these methods can also be applied to Java programs, the Java language presents several new challenges/opportunities: 1.
Reference: [9] <author> D. Jackson and C. A. Damon. </author> <title> Elements of style: Analyzing a software design feature with a counterexample detector. </title> <booktitle> In Ziel [14], </booktitle> <pages> pages 239-249. </pages>
Reference-contexts: Although a model that restricts the range of a variable does not represent all possible behaviors of the program and thus cannot technically be used to verify the program has a property, the conventional wisdom is that most concurrency errors are present in small versions of a system <ref> [6, 9] </ref>, thus these models can still be useful for finding errors (testing). Most previous work on concurrency analysis of software has used Ada [7, 13, 12, 2, 3, 8].
Reference: [10] <author> D. Lea. </author> <title> Concurrent Programming in Java: Design Principles and Patterns. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: Nevertheless, it is common for variables to be protected by locks in other objects. For instance, in the bounded buffer example, the array object referenced by instance variable data is protected by the lock on the enclosing IntBuffer object. This very common design pattern is known as containment <ref> [10] </ref>: an object X is conceptually 2 nested in an object Y by placing a reference to X in Y and accessing X only within the methods of Y. Another common design pattern in which locks protect variables in other objects is splitting locks [10]. <p> design pattern is known as containment <ref> [10] </ref>: an object X is conceptually 2 nested in an object Y by placing a reference to X in Y and accessing X only within the methods of Y. Another common design pattern in which locks protect variables in other objects is splitting locks [10]. A class might contain independent sets of instance variables that may be updated concurrently. In this case, acquiring a lock on the entire instance would excessively limit potential parallelism. Instead, each such set of instance variables has its own lock, usually an instance of the root class Object. <p> In general, the relationship between a variable and the lock that protects it may be too elaborate to determine with static analysis. Here, we propose a heuristic that we believe is widely applicable and, in particular, works for the locking design patterns given in <ref> [10] </ref>.
Reference: [11] <author> O. Lichtenstein and A. Pnueli. </author> <title> Checking that finite state concurrent programs satisfy their linear specifications. </title> <booktitle> In Proceedings of the Twelfth ACM Symposium on the Priciples of Programming Languages, </booktitle> <pages> pages 97-105, </pages> <year> 1985. </year>
Reference-contexts: We assume the requirement to be verified (tested) is specified as a stuttering-invariant formula f in linear temporal logic (LTL) <ref> [11] </ref>, the atomic propositions of which are of the form v i = d i where v i is a state variable and d i 2 D i . Statement s j= (S;T ) f denotes that formula f is true in state s of transition system (S; T ).
Reference: [12] <author> S. P. Masticola and B. G. Ryder. </author> <title> Static infinite wait anomaly detection in polynomial time. </title> <booktitle> In Proceedings of the 1990 International Conference on Parallel Processing, </booktitle> <volume> volume II, </volume> <pages> pages 78-87, </pages> <year> 1990. </year>
Reference-contexts: Most previous work on concurrency analysis of software has used Ada <ref> [7, 13, 12, 2, 3, 8] </ref>. Although some aspects of these methods can also be applied to Java programs, the Java language presents several new challenges/opportunities: 1.
Reference: [13] <author> M. Young, R. N. Taylor, K. Forester, and D. Brod-beck. </author> <title> Integrated concurrency analysis in a software development environment. </title> <editor> In R. A. Kemmerer, editor, </editor> <booktitle> Proceedings of the ACM SIGSOFT '89 Third Symposium on Software Testing, Analysis and Verification, </booktitle> <pages> pages 200-209, </pages> <year> 1989. </year> <note> Appeared as Software Engineering Notes, 14(8). </note>
Reference-contexts: Most previous work on concurrency analysis of software has used Ada <ref> [7, 13, 12, 2, 3, 8] </ref>. Although some aspects of these methods can also be applied to Java programs, the Java language presents several new challenges/opportunities: 1.
Reference: [14] <editor> S. Ziel, editor. </editor> <booktitle> Proceedings of the 1996 International Symposium on Software Testing and Analysis (ISSTA). </booktitle> <publisher> ACM Press, </publisher> <month> January </month> <year> 1996. </year> <month> 10 </month>
References-found: 14

