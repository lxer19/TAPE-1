URL: http://www.cs.nmsu.edu/lldap/download/realtime.ps.Z
Refering-URL: http://www.cs.nmsu.edu/lldap/prj_lp/realtime/
Root-URL: http://www.cs.nmsu.edu
Title: A Constraint-based Approach for Specification and Verification of Real-time Systems  
Author: Enrico Pontelli Gopal Gupta 
Keyword: Constraint Programming, Real-time systems, Systems Verification, Timed Automata.  
Address: Box 30001,  Las Cruces, NM 88003-0001  
Affiliation: Laboratory for Logic, Databases, and Advanced Programming Dept. Computer Science New Mexico State University  Dept. CS  
Email: fgupta,epontellg@cs.nmsu.edu  
Phone: Phone: +1 (505) 646-6239 646-6236 Fax: +1 (505) 646-1002  
Web: http:==www.cs.nmsu.edu=lldap  
Abstract: We present a general constraint logic programming (CLP) based framework for specifying timed automata. In this framework a user specifies the grammar of the language accepted by the automata. The real-time constraints on transitions are captured in denotations of the grammar productions specified by the user. Thus, the grammar is specified as a Definite Clause Grammar (DCG), while the denotations are specified in constraint logic. The resulting specification is hence a constraint logic program (CLP), and is executable. Moreover, many interesting properties of the real-time system can be verified by posing appropriate queries to this CLP program. Our constraint-based methodology for specifying and verifying real-time systems is presented, and illustrated via examples. We also introduce a new type of automata called Constraint Automata that is a generalization of timed automata. Using our formal framework we were able to find an error in one of the examples of Alur and Dill [2]. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur and D.L. Dill. </author> <title> Automata for Modeling Real-Time Systems. In Automata, Languages, and Programming, </title> <publisher> Springer Verlag, </publisher> <year> 1990. </year>
Reference-contexts: In this paper we present a framework for specifying and automatically verifying real-time systems. Our approach is based on the Constraint Logic Programming paradigm and the Timed Automata formalism. Timed automata have been devised for specifying real-time systems <ref> [1] </ref>. A timed automata is an !-automata extended with the notion of time. !-automata are automata that accept languages with infinite words. A timed-automata considers execution in a real-time system to be an infinite sequence of events. <p> A timed-automata considers execution in a real-time system to be an infinite sequence of events. Transitions in a timed-automata are made not only on alphabet symbols in the language but also based on time-constraints. Timed automata are adequate for specifying real-time systems <ref> [1, 2] </ref>. Research has also been done on verifying timed automata, though the approaches adopted for verification are ad-hoc, in our opinion. Our approach, in contrast, provides a uniform framework for both specifying and verifying a real-time system. <p> Section 7 presents another example to illustrate our technique. Finally, Section 8 presents our conclusions and comparison with other work. 2 Timed Automata Various extensions of finite state automata have been proposed for embedding the notion of time and time constraints <ref> [12, 1, 22, 16] </ref>. A timed automata is a generalization of an automata capable of recognizing infinite words (also known as !-automata [26]).
Reference: [2] <author> R. Alur and D.L. Dill. </author> <title> The Theory of Timed Automata. In Real Time: Theory in Practice, </title> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: A timed-automata considers execution in a real-time system to be an infinite sequence of events. Transitions in a timed-automata are made not only on alphabet symbols in the language but also based on time-constraints. Timed automata are adequate for specifying real-time systems <ref> [1, 2] </ref>. Research has also been done on verifying timed automata, though the approaches adopted for verification are ad-hoc, in our opinion. Our approach, in contrast, provides a uniform framework for both specifying and verifying a real-time system. <p> If the property is satisfied, an answer will be found for the query, else the query will fail. It should be noted that using our formal approach we were able to spot an error in one of the examples used by Alur and Dill <ref> [2] </ref>. This demonstrates the power of our approach. (It should be noted though that later versions of this paper had the error fixed [3]). Our research also suggests a much more general notion of automata, namely, the Constraint Au 2 tomata. A constraint automata has constraints attached to its edges. <p> Furthermore, it has been shown that the problem of verifying whether the language of a deterministic timed automata is included in that of another timed automata is decidable <ref> [2] </ref>. Example 2.1 Let us consider the following problem. An automatic controller is designed to handle a gate at a railroad crossing. The system is composed by three entities, a gate-controller, the gate itself, and the train. The train is modeled by the automata shown in figure 2 (i). <p> Our framework captures the syntax and semantics of real-time automata as a constraint logic program. The resulting constraint logic program can be directly executed. Additionally, it can be used for verifying interesting properties (e.g., safety, liveness, etc. <ref> [2] </ref>). Our approach is inspired by the denotational method of specifying programming language semantics [23]. In the denotational approach a language is specified by giving both its syntax and semantics formally. The syntax is specified as a context free grammar, while the semantics is given via valuation functions. <p> ; T out c i 62o C i = T in A top level driver can be used to perform the execution of the syntactic and semantic part, as well as driving a lock step execution of multiple automata at the same time (as required for systems with multiple timed-automata <ref> [2] </ref>). <p> It is interesting to note that using our system we were able to spot an error in the paper of Alur and Dill <ref> [2] </ref>. In the paper, the train automata of Figure 2 had the exit constraint erroneously labeled as c &gt; 5. With this constraint changed, their real-time liveness property does not hold. The real-time liveness property states that the gate is never closed at a stretch for more than 10 minutes. <p> In the example above we have relied on the programmer to indicate the general boundaries of the input fragment to consider for verification. On one hand, one can argue that this is not more complex than developing a complete timed automata to express the property to be verified <ref> [2] </ref>, as in both cases a thorough understanding of the problem and its properties is required. <p> On the other hand the restriction typically posed on the nature of the time constraints in the timed-automata frameworks <ref> [2, 12] </ref> are such that the existence of an !-automata which accepts the same language as the timed automata is guaranteed. <p> Constraint automata thus allow us to reason about not just time by other physical quantities as well, such as distance. In other frameworks, e.g. that of Alur, Henzinger, and Ho [7], a switch has to be made from purely automata based theory (as in <ref> [2] </ref>) to more complicated types of temporal logics such as integrator computation tree logic (ICTL). We illustrate the constraint automata with an example (taken from [7]).
Reference: [3] <author> R. Alur and D.L. Dill. </author> <title> The Theory of Timed Automata. </title> <booktitle> In Theoretical Computer Science, </booktitle> <volume> Vol. 126, </volume> <year> 1994. </year>
Reference-contexts: It should be noted that using our formal approach we were able to spot an error in one of the examples used by Alur and Dill [2]. This demonstrates the power of our approach. (It should be noted though that later versions of this paper had the error fixed <ref> [3] </ref>). Our research also suggests a much more general notion of automata, namely, the Constraint Au 2 tomata. A constraint automata has constraints attached to its edges. It can be shown that timed automata is an instance of the much more general constraint automata. <p> This indeed produces a solution (if the exit constraint is changed from T1 - T2 &lt; 5 to T1 - T2 &gt; 5). However, we did find that the error had been fixed in their subsequent paper <ref> [3] </ref>. <p> This is possible because the timing constraints imposed by transitions of a timed-automata can be captured as time-intervals which can then be encoded in the states of a !- automata <ref> [3] </ref>. The restrictions imposed on the types of propositions allowed essentially ensure that such a translation is possible. In any timed automata the infinite sentences consist of a finite number 11 of sentences of finite size occurring unbounded number of times.
Reference: [4] <author> R. Alur and T.A. Henzinger. </author> <title> A Really Temporal Logic. </title> <booktitle> In Proc. 30th Symp. on Foundations of Computer Science, IEEE Computer Society, </booktitle> <year> 1989. </year>
Reference-contexts: A host of Real-time Logics have also been proposed. There are linear time temporal logics and branching time temporal logics, temporal logics with freeze quantification, with bounded temporal operators, and with explicit clock variables. Some example temporal logics are MTL (metric temporal logic [5]), TPTL (timed temporal logic <ref> [4] </ref>), RTTL (real-time temporal logic [22], XCTL (Explicit Clock temporal logic [17]), RTCTL (real-time computation tree logic), etc. There are also automata based real-time formalisms such as timed automata and timed transition systems.
Reference: [5] <author> R. Alur and T.A. Henzinger. </author> <title> Real-time Logics: Complexity and Expressiveness. </title> <booktitle> In Proc. Symp on Logic in Computer Science, IEEE Computer Society, </booktitle> <year> 1990. </year>
Reference-contexts: A host of Real-time Logics have also been proposed. There are linear time temporal logics and branching time temporal logics, temporal logics with freeze quantification, with bounded temporal operators, and with explicit clock variables. Some example temporal logics are MTL (metric temporal logic <ref> [5] </ref>), TPTL (timed temporal logic [4]), RTTL (real-time temporal logic [22], XCTL (Explicit Clock temporal logic [17]), RTCTL (real-time computation tree logic), etc. There are also automata based real-time formalisms such as timed automata and timed transition systems.
Reference: [6] <author> R. Alur and T.A. Henzinger. </author> <title> Logics and Models of Real-time: A Survey. In Real Time: Theory in Practice, </title> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction There has been tremendous amount of research in specification of real-time system <ref> [6, 13, 9, 20] </ref>, however, the process of designing and verifying the correctness of a real-time system is still not completely automated. Verifying the implementation of a real-time system manually can be error-prone. In addition, errors can be made while translating a specification into an implementation. <p> In general, any semantics (trace semantics, interleaving semantics, fictitious clock semantics, etc. <ref> [6] </ref>) can be chosen. Our framework is along the lines of denotational semantics approach [24] for design of programming languages, where syntax and semantics are cleanly separated, and meaning of language constructs are given in terms of their components [23]. <p> Cost 2hrpass &lt; 3 fl Cost 1wayticket Note that having more stations poses really no problems, and the above example can be generalized in an obvious way. 8 Comparison with Other Work and Conclusions There is a tremendous amount of work that has been done in verification of real-time systems <ref> [6] </ref>. Real-time systems have been studied with several types of formal semantics assigned to them. A host of Real-time Logics have also been proposed. There are linear time temporal logics and branching time temporal logics, temporal logics with freeze quantification, with bounded temporal operators, and with explicit clock variables.
Reference: [7] <author> R. Alur, T.A. Henzinger, P-H. Ho. </author> <title> Automatic Symbolic Verification of Embedded Systems. </title> <booktitle> In Proc. Symp. on Real Time Systems, IEEE Computer Society, </booktitle> <year> 1993. </year>
Reference-contexts: Constraint automata thus allow us to reason about not just time by other physical quantities as well, such as distance. In other frameworks, e.g. that of Alur, Henzinger, and Ho <ref> [7] </ref>, a switch has to be made from purely automata based theory (as in [2]) to more complicated types of temporal logics such as integrator computation tree logic (ICTL). We illustrate the constraint automata with an example (taken from [7]). <p> In other frameworks, e.g. that of Alur, Henzinger, and Ho <ref> [7] </ref>, a switch has to be made from purely automata based theory (as in [2]) to more complicated types of temporal logics such as integrator computation tree logic (ICTL). We illustrate the constraint automata with an example (taken from [7]).
Reference: [8] <author> M. Abadi and Z. Manna. </author> <title> Temporal Logic Programming. </title> <journal> In Journal of Symbolic Computation, </journal> <volume> Vol. 8, </volume> <year> 1989. </year>
Reference-contexts: Few proposals have been made for modeling real time systems using a logic programming or a constraint logic programming framework. The most notable is that of Brzoska [9, 10], which provides a translation of simple temporal formulas (following the structure of Templog <ref> [8] </ref>) into a simple CLP scheme over an algebra based on the set of integer numbers with and +. BNR-Prolog [11], a constraint logic language on interval arithmetics, has also been used to capture temporal properties. Some preliminary work on constraint temporal logic has also been done by Fruwirth [14].
Reference: [9] <author> C. Brzoska. </author> <title> Temporal Logic Programming and its Relation to Constraint Logic Programming. </title> <booktitle> In Proc. of the International Logic Programming Symposium, </booktitle> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction There has been tremendous amount of research in specification of real-time system <ref> [6, 13, 9, 20] </ref>, however, the process of designing and verifying the correctness of a real-time system is still not completely automated. Verifying the implementation of a real-time system manually can be error-prone. In addition, errors can be made while translating a specification into an implementation. <p> There are also automata based real-time formalisms such as timed automata and timed transition systems. Few proposals have been made for modeling real time systems using a logic programming or a constraint logic programming framework. The most notable is that of Brzoska <ref> [9, 10] </ref>, which provides a translation of simple temporal formulas (following the structure of Templog [8]) into a simple CLP scheme over an algebra based on the set of integer numbers with and +.
Reference: [10] <author> C. Brzoska. </author> <title> Temporal Logic Programming with Metric and Past Operators. In Executable Modal and Temporal Logics, </title> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: There are also automata based real-time formalisms such as timed automata and timed transition systems. Few proposals have been made for modeling real time systems using a logic programming or a constraint logic programming framework. The most notable is that of Brzoska <ref> [9, 10] </ref>, which provides a translation of simple temporal formulas (following the structure of Templog [8]) into a simple CLP scheme over an algebra based on the set of integer numbers with and +.
Reference: [11] <author> J. Cleary and V. Kaushik. </author> <title> Updates in Temporal Logic Programming Languages. </title> <type> Tech. Report, </type> <institution> Univ. of Calgary, </institution> <year> 1991. </year>
Reference-contexts: The most notable is that of Brzoska [9, 10], which provides a translation of simple temporal formulas (following the structure of Templog [8]) into a simple CLP scheme over an algebra based on the set of integer numbers with and +. BNR-Prolog <ref> [11] </ref>, a constraint logic language on interval arithmetics, has also been used to capture temporal properties. Some preliminary work on constraint temporal logic has also been done by Fruwirth [14]. Our work can be seen as providing a computational framework for timed automata based real-time system.
Reference: [12] <author> D.L. Dill. </author> <title> Timing Assumptions and Verifications of Finite-state Concurrent Systems. In Automatic Verification Methods for Finite-state Systems, </title> <publisher> Springer Verlag, </publisher> <year> 1989. </year>
Reference-contexts: Section 7 presents another example to illustrate our technique. Finally, Section 8 presents our conclusions and comparison with other work. 2 Timed Automata Various extensions of finite state automata have been proposed for embedding the notion of time and time constraints <ref> [12, 1, 22, 16] </ref>. A timed automata is a generalization of an automata capable of recognizing infinite words (also known as !-automata [26]). <p> On the other hand the restriction typically posed on the nature of the time constraints in the timed-automata frameworks <ref> [2, 12] </ref> are such that the existence of an !-automata which accepts the same language as the timed automata is guaranteed.
Reference: [13] <author> M. Fisher and R. Owens. </author> <title> Executable Modal and Temporal Logics. </title> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: 1 Introduction There has been tremendous amount of research in specification of real-time system <ref> [6, 13, 9, 20] </ref>, however, the process of designing and verifying the correctness of a real-time system is still not completely automated. Verifying the implementation of a real-time system manually can be error-prone. In addition, errors can be made while translating a specification into an implementation.
Reference: [14] <author> T. Fruwirth. </author> <title> Temporal Logic and Annotated Logic Programming. In Executable Modal and Temporal Logics, </title> <publisher> Springer Verlag, </publisher> <year> 1995. </year>
Reference-contexts: BNR-Prolog [11], a constraint logic language on interval arithmetics, has also been used to capture temporal properties. Some preliminary work on constraint temporal logic has also been done by Fruwirth <ref> [14] </ref>. Our work can be seen as providing a computational framework for timed automata based real-time system. We believe that a constraint logic based approach like ours can also be used for providing a computational framework for other formalisms such as various kinds of temporal logics.
Reference: [15] <author> G. Gupta. </author> <title> Logical Denotations: An Executable Denotational Framework. </title> <type> Internal Report, </type> <institution> NMSU, </institution> <year> 1997. </year>
Reference-contexts: If the grammar is specified as a Definite Clause Grammar [25] then a parser for it is obtained immediately by using a logic programming system. Likewise, if the functions corresponding to each production are specified in constraint logic <ref> [15] </ref>, then an implementation of the timed automata is immediately obtained. The implementation thus obtained takes a stream of events (events are alphabet of the language), parses it producing a parse tree, then passes the parse tree as input to the function that captures the meaning of the automata.
Reference: [16] <author> T.A. Henzinger, Z. Manna, A. Pnueli. </author> <title> Temporal Proof Methodologies for Real-time Systems. </title> <booktitle> In Proc. of the 18th Symposium on Principles of Programming Languages, </booktitle> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: Section 7 presents another example to illustrate our technique. Finally, Section 8 presents our conclusions and comparison with other work. 2 Timed Automata Various extensions of finite state automata have been proposed for embedding the notion of time and time constraints <ref> [12, 1, 22, 16] </ref>. A timed automata is a generalization of an automata capable of recognizing infinite words (also known as !-automata [26]).
Reference: [17] <author> E. Harel, O. Lichtenstein, A. Pnueli. </author> <title> Explicit-clock Temporal Logic. </title> <booktitle> In Proc. Symp. on Logic in Computer Science, IEEE Computer Society, </booktitle> <year> 1990. </year>
Reference-contexts: Some example temporal logics are MTL (metric temporal logic [5]), TPTL (timed temporal logic [4]), RTTL (real-time temporal logic [22], XCTL (Explicit Clock temporal logic <ref> [17] </ref>), RTCTL (real-time computation tree logic), etc. There are also automata based real-time formalisms such as timed automata and timed transition systems. Few proposals have been made for modeling real time systems using a logic programming or a constraint logic programming framework.
Reference: [18] <author> J. Jaffar and M.J. Maher. </author> <title> Constraint Logic Programming. </title> <journal> In Journal of Logic Programming, </journal> <volume> Vol. </volume> <month> 19/20, </month> <year> 1994. </year>
Reference-contexts: The intuitive idea is to introduce special classes of formulae (constraints) which are not handled using traditional resolution, but are interpreted under a predefined specific interpretation and handled by external constraint solvers. For a more precise and complete presentation of CLP the reader is referred to the literature <ref> [21, 18] </ref>. The language at hand is built on two collections of symbols, , containing all the function symbols, and , containing the predicate symbols. Furthermore, predicate symbols are classified in two separate classes, = c [ p ; p contains the user-defined predicates, while c contains the constraint predicates. <p> Let ( C ; C ) be a signature (constraint language|where C collects the functional symbols while C collects the predicate symbols), and let D be an interpretation for such language <ref> [18] </ref>. Furthermore, let X be the tuple h C [ C ; D; Ai where A is a collection of ( C ; C )-formulae (admissible constraints). Intuitively, X identifies a class of formulae over a given language (the constraints) together with their desired interpretation (D). <p> Intuitively, X identifies a class of formulae over a given language (the constraints) together with their desired interpretation (D). We require X to satisfy the typical requirements for constraint domains (as in <ref> [18] </ref>). Let us denote with S C the set of all ground terms expressible with the set of symbols C .
Reference: [19] <author> F. Jahanian, A.K. Mok, D.A. Stuart. </author> <title> Formal Specification of Real-time Systems. </title> <type> Technical Report, </type> <institution> UTCS-TR-88-25, </institution> <year> 1988. </year>
Reference: [20] <author> R. Koymans. </author> <title> Specifying Message Passing and Time-critical Systems with Temporal Logic. </title> <publisher> Springer Verlag, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction There has been tremendous amount of research in specification of real-time system <ref> [6, 13, 9, 20] </ref>, however, the process of designing and verifying the correctness of a real-time system is still not completely automated. Verifying the implementation of a real-time system manually can be error-prone. In addition, errors can be made while translating a specification into an implementation.
Reference: [21] <author> J.L. Lassez and J. Jaffar. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. of the 14th Symposium on Principles of Programming Languages, </booktitle> <publisher> ACM Press, </publisher> <year> 1987. </year>
Reference-contexts: The intuitive idea is to introduce special classes of formulae (constraints) which are not handled using traditional resolution, but are interpreted under a predefined specific interpretation and handled by external constraint solvers. For a more precise and complete presentation of CLP the reader is referred to the literature <ref> [21, 18] </ref>. The language at hand is built on two collections of symbols, , containing all the function symbols, and , containing the predicate symbols. Furthermore, predicate symbols are classified in two separate classes, = c [ p ; p contains the user-defined predicates, while c contains the constraint predicates. <p> The negated property will be that the event in occurs before down. Thus, the query: ?- driver (0,X,s0,s0,s0,0,0,0,0,R), append (A, [(down,_)|_], R), append (_, [(in,_)|_], A). will fail when run on a constraint logic programming system (we used the CLP (R) <ref> [21] </ref> system). The append program is the standard logic program for appending two lists. Likewise, if we want to verify that the gate will be down at least 4 units of time.
Reference: [22] <author> J.S. Ostroff. </author> <title> Temporal Logic of Real-time Systems. </title> <publisher> Research Studies Press, </publisher> <year> 1990. </year>
Reference-contexts: Section 7 presents another example to illustrate our technique. Finally, Section 8 presents our conclusions and comparison with other work. 2 Timed Automata Various extensions of finite state automata have been proposed for embedding the notion of time and time constraints <ref> [12, 1, 22, 16] </ref>. A timed automata is a generalization of an automata capable of recognizing infinite words (also known as !-automata [26]). <p> There are linear time temporal logics and branching time temporal logics, temporal logics with freeze quantification, with bounded temporal operators, and with explicit clock variables. Some example temporal logics are MTL (metric temporal logic [5]), TPTL (timed temporal logic [4]), RTTL (real-time temporal logic <ref> [22] </ref>, XCTL (Explicit Clock temporal logic [17]), RTCTL (real-time computation tree logic), etc. There are also automata based real-time formalisms such as timed automata and timed transition systems. Few proposals have been made for modeling real time systems using a logic programming or a constraint logic programming framework.
Reference: [23] <author> D.A. Schmidt. </author> <title> Denotational Semantics: A Methodology for Language Development. </title> <publisher> Wm.C. Brown Publishers, </publisher> <year> 1986. </year>
Reference-contexts: Our framework is along the lines of denotational semantics approach [24] for design of programming languages, where syntax and semantics are cleanly separated, and meaning of language constructs are given in terms of their components <ref> [23] </ref>. So it is up to the person specifying the real-time system to choose the semantics he/she wishes. <p> The resulting constraint logic program can be directly executed. Additionally, it can be used for verifying interesting properties (e.g., safety, liveness, etc. [2]). Our approach is inspired by the denotational method of specifying programming language semantics <ref> [23] </ref>. In the denotational approach a language is specified by giving both its syntax and semantics formally. The syntax is specified as a context free grammar, while the semantics is given via valuation functions. A valuation function is given for each production in the grammar.
Reference: [24] <author> D.S. Scott and C. Strachey. </author> <title> Towards a Mathematical Semantics for Computer Languages. </title> <type> Tech. monograph, </type> <institution> Programming Research Group, Univ. of Oxford, </institution> <year> 1971. </year>
Reference-contexts: In general, any semantics (trace semantics, interleaving semantics, fictitious clock semantics, etc. [6]) can be chosen. Our framework is along the lines of denotational semantics approach <ref> [24] </ref> for design of programming languages, where syntax and semantics are cleanly separated, and meaning of language constructs are given in terms of their components [23]. So it is up to the person specifying the real-time system to choose the semantics he/she wishes.
Reference: [25] <author> L. Sterling and E. Shapiro. </author> <title> The Art of Prolog. </title> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: If the grammar is specified as a Definite Clause Grammar <ref> [25] </ref> then a parser for it is obtained immediately by using a logic programming system. Likewise, if the functions corresponding to each production are specified in constraint logic [15], then an implementation of the timed automata is immediately obtained. <p> Following, the denotational approach, in our framework the syntax of the language is described as a context free grammar. The behavior of the timed automata is captured as valuation functions. Since our approach is based on Constraint Logic Programming, the grammar is expressed as a Definite Clause Grammar <ref> [25] </ref>, and the valuation functions are expressed as Horn clauses with constraints. The valuation functions are a mapping from the stream of events in the real-time system to the list of he; o e i pairs. Both the syntax and semantic specification are immediately executable.
Reference: [26] <author> W. Thomas. </author> <title> Automata on Infinite Objects. </title> <booktitle> In Handbook of Theoretical Computer Science, Volume B, </booktitle> <publisher> Elsevier Science, </publisher> <year> 1990. </year> <month> 19 </month>
Reference-contexts: A timed automata is a generalization of an automata capable of recognizing infinite words (also known as !-automata <ref> [26] </ref>).
References-found: 26

