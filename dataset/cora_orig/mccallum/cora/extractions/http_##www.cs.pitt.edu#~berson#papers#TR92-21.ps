URL: http://www.cs.pitt.edu/~berson/papers/TR92-21.ps
Refering-URL: http://www.cs.pitt.edu/~berson/papers.html
Root-URL: 
Email: (berson@cs.pitt.edu)  
Title: A Unified ReSource Allocator for Registers and Functional Units In VLIW Architectures yz  
Author: David A. Berson Rajiv Gupta Mary Lou Soffa 
Date: December 1992  
Address: Pittsburgh Pittsburgh, PA 15260  
Affiliation: Department of Computer Science University of  
Note: URSA:  
Abstract: Technical Report 92-21 y Partially supported by National Science Foundation Presidential Young Investigator Award CCR-9157371 and Grant CCR-91090809 to the University of Pittsburgh z A shorter version of this technical report was presented at the IFIP WG 10.3 Working Conference on Architectures and Compliation Techniques for Fine and Medium Grain Parallelism, January, 1993 
Abstract-found: 1
Intro-found: 1
Reference: [AiN88] <author> A. Aiken and A. Nicolau, </author> <title> A Development Environment for Horizontal Microcode, </title> <journal> IEEE Trans. on Software Engineering 14 , 5(May 1988) pp. </journal> <pages> 584-594. </pages>
Reference-contexts: By constructing DAGs of traces, which are basic block sequences, trace scheduling allows code motion across basic blocks. Other techniques that also allow code motion across basic blocks include percolation scheduling and region scheduling <ref> [AiN88, GuS90] </ref>. However, they do not use an explicit DAG representation during code motion. In this work we use DAGs since they represent a partial order on the execution of instructions, which provides a basis for measuring resource requirements.
Reference: [BEH91] <author> D. G. Bradlee, S. J. Eggers and R. R. Henry, </author> <title> Integrating Register Allocation and Instruction Scheduling for RISCs, </title> <booktitle> Proc. Fourth International Conf. on ASPLOS, </booktitle> <address> Santa Clara, CA, </address> <month> April 8-11, </month> <year> 1991, </year> <pages> pp. 122-131. </pages>
Reference-contexts: Several techniques have been proposed to address the issue of interaction between the two problems for pipelined architectures <ref> [BEH91, GoH88, SwB90] </ref>. However all of these techniques still attempt to solve the problems separately while taking into account the interactions to a limited extent.
Reference: [CLR90] <author> T. H. Cormen, C. E. Leiserson and R. L. Rivest, </author> <title> Introduction to Algorithms, </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1990. </year>
Reference: [Dil50] <author> R. P. </author> <title> Dilworth, A Decomposition Theorem for Partially Ordered Sets, </title> <booktitle> Annuals of Mathematics 51 (1950) pp. </booktitle> <pages> 161-166. </pages>
Reference: [Fis81] <author> J. A. Fisher, </author> <title> Trace Scheduling: A Technique for Global Microcode Compaction, </title> <journal> IEEE Trans. on Computers C-30 , 7(July 1981) pp. </journal> <pages> 478-490. </pages>
Reference-contexts: The major steps of URSA are summarized in Figure 2. The basic structure that is used for representing parallelism in straight line code is the dependence DAG 1 . A DAG representation is suitable for exploiting parallelism present within basic blocks as well as parallelism across basic block boundaries <ref> [Fis81] </ref>. By constructing DAGs of traces, which are basic block sequences, trace scheduling allows code motion across basic blocks. Other techniques that also allow code motion across basic blocks include percolation scheduling and region scheduling [AiN88, GuS90]. However, they do not use an explicit DAG representation during code motion.
Reference: [FoF65] <author> L. R. Ford and D. R. Fulkerson, </author> <title> Flows in Networks, </title> <publisher> Princeton University Press, </publisher> <address> Prince-ton, N.J., </address> <year> 1965. </year>
Reference-contexts: Clearly, all chains in a Reuse R DAG are allocation chains. Therefore, by Theorem 1, a minimum decomposition of a Reuse R DAG into allocation chains gives the maximum resource requirements of R for the original DAG. Ford and Fulkerson <ref> [FoF65] </ref> have shown that the problem of finding a minimum chain decomposition can be solved by transforming it into a maximum bipartite graph matching problem. The bipartite graph represents all possible pairs of nodes (a; b) 2 CanReuse R .
Reference: [GaJ79] <author> M. R. Garey and D. S. Johnson, </author> <title> Computers and Intractability: A Guide to the Theory of NP-Completenesss, </title> <editor> W. H. </editor> <publisher> Freeman and Co., </publisher> <address> New York, New York, </address> <year> 1979. </year>
Reference: [GoH88] <author> J. R. Goodman and W. Hsu, </author> <title> Code Scheduling and Register Allocation in Large Basic Blocks, </title> <booktitle> Proc. of the ACM Supercomputing Conference, </booktitle> <year> 1988, </year> <pages> pp. 442-452. </pages>
Reference-contexts: Several techniques have been proposed to address the issue of interaction between the two problems for pipelined architectures <ref> [BEH91, GoH88, SwB90] </ref>. However all of these techniques still attempt to solve the problems separately while taking into account the interactions to a limited extent. <p> The effective goal of our technique is to maximize the average utilization of the resources by minimizing the execution time, without ever exceeding the limits of the target architecture. Goodman and Hsu also present a DAG driven technique <ref> [GoH88] </ref>. However, their technique uses prepass scheduling and does not have a mechanism for inserting spill code. Section 2 gives an overview of the URSA technique. Section 3 presents the techniques for measuring the resource requirements. Section 4 presents the resource requirements reduction transformations and discusses their interaction and integration.
Reference: [GuS90] <author> R. Gupta and M. L. Soffa, </author> <title> Region Scheduling: An Approach for Detecting and Redistributing Parallelism, </title> <journal> IEEE Trans. on Software Engineering 16 , 4(April 1990) pp. </journal> <pages> 421-431. </pages>
Reference-contexts: By constructing DAGs of traces, which are basic block sequences, trace scheduling allows code motion across basic blocks. Other techniques that also allow code motion across basic blocks include percolation scheduling and region scheduling <ref> [AiN88, GuS90] </ref>. However, they do not use an explicit DAG representation during code motion. In this work we use DAGs since they represent a partial order on the execution of instructions, which provides a basis for measuring resource requirements.
Reference: [Kar72] <author> R. J. Karp, </author> <title> Reducibility Among Combinatorial Problems, Complexity of Computer Computations, </title> <editor> R. E. Miller and J. W. Thatcher(eds.), </editor> <publisher> Plenum Press, </publisher> <address> New York, </address> <year> 1972pp. </year> <pages> 85-103, </pages> . 
Reference: [SwB90] <author> P. Sweany and S. Beaty, </author> <title> Post-Compaction Register Assignment in a Retargetable Compiler, </title> <booktitle> Proc. of the 23rd Annual Workshop on Microprogramming and Microarchitecture, </booktitle> <month> Nov. </month> <year> 1990, </year> <pages> pp. 107-116. 19 </pages>
Reference-contexts: Several techniques have been proposed to address the issue of interaction between the two problems for pipelined architectures <ref> [BEH91, GoH88, SwB90] </ref>. However all of these techniques still attempt to solve the problems separately while taking into account the interactions to a limited extent.
References-found: 11

