URL: http://ftp.eecs.umich.edu/people/yenmin/hicss26.ps
Refering-URL: http://ftp.eecs.umich.edu/people/yenmin/
Root-URL: http://www.eecs.umich.edu
Email: yenmin@eecs.umich.edu ravi@eecs.umich.edu  
Title: Accommodating RPC Heterogeneities In Large Heterogeneous Distributed Environments 1  
Author: Yen-Min Huang and Chinya V. Ravishankar 
Address: Ann Arbor, MI. 48109  
Affiliation: Dept. of EECS, The University of Michigan,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> B. H. Tay and A. L. Ananda. </author> <title> A Survey of Remote Procedure Calls. </title> <journal> Operating Systems Review, </journal> <volume> 24(3) </volume> <pages> 68-78, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Many RPC semantics have been designed and implemented in recent years to meet various application-specific requirements. Examples are synchronous RPC, asynchronous RPC, fault tolerant RPC, broadcast RPC, maybe RPC (no-return RPC), RPC with atomic transactions, and RPC with call-back mechanism <ref> [1, 2] </ref>. With emerging applications like multimedia conferencing and distributed real-time applications, it is conceivable that even more RPC protocols will be designed and implemented. This diversity of RPC protocols makes us adopt a general view of RPC as a protocol above OSI transport layer in this paper.
Reference: [2] <author> A. L. Ananda, B. H. Tay, and E. K. Koh. </author> <title> A Survey of Asynchronous Remote Procedure Calls. </title> <journal> Operating Systems Review, </journal> <volume> 26(2) </volume> <pages> 92-109, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: 1 Introduction Many RPC semantics have been designed and implemented in recent years to meet various application-specific requirements. Examples are synchronous RPC, asynchronous RPC, fault tolerant RPC, broadcast RPC, maybe RPC (no-return RPC), RPC with atomic transactions, and RPC with call-back mechanism <ref> [1, 2] </ref>. With emerging applications like multimedia conferencing and distributed real-time applications, it is conceivable that even more RPC protocols will be designed and implemented. This diversity of RPC protocols makes us adopt a general view of RPC as a protocol above OSI transport layer in this paper.
Reference: [3] <author> B. N. Bershad, D. T. Ching, E. D. Lazowska, J. San-islo, and M. Schwartz. </author> <title> A Remote Procedure Call Facility for Interconnecting Heterogeneous Computer Systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(8) </volume> <pages> 880-894, </pages> <month> August </month> <year> 1987. </year>
Reference-contexts: The problem with having many different RPC protocols is that user programs built on top of different RPC protocols cannot be interconnected directly, greatly reducing the availability of software and resources in a large heterogeneous distributed environment. This problem has been addressed by HRPC/HCS <ref> [3] </ref> on a smaller scale, where the number of different RPC instances is small, RPC protocols are similar, and new RPC instances are rarely introduced. However, these characteristics do not always hold in a large heterogeneous environment.
Reference: [4] <author> Y. Huang and C. V. Ravishankar. </author> <title> Accommodating RPC Heterogeneities Using Automatic Agent Synthesis. </title> <type> Technical Report CSE-TR-131-92, </type> <institution> Dept. of EECS, The University of Michigan, Ann Arbor, Michigan, </institution> <year> 1992. </year>
Reference-contexts: In such an environment, an acceptable solution must handle a large number of RPC instances, diversified RPC protocols, and rapid RPC protocol evolution at low software development and maintenance costs. Our RPC agent synthesis scheme is a such solution <ref> [4] </ref>. Our system also includes a mechanism for distributing and acquiring synthesis information, and it supports RPC protocol evolution with minimum disturbance to the environment. Our approach is best for cross RPC within the same class of RPC semantics, for example, cross RPC among at-most-once RPCs, or among at-least-one RPCs.
Reference: [5] <author> C. V Ravishankar and R. Finkel. </author> <title> Linguistic Support for Dataflow. </title> <type> Technical Report CSE-TR-14-89, </type> <institution> Dept. of EECS, The University of Michigan, Ann Arbor, Michigan, </institution> <year> 1989. </year>
Reference-contexts: Broadly speaking, our RPC agent synthesis scheme has two components (see Figure 1): a set of language constructs (Cicero) to describe RPC protocol constructions, and a program (Nestor) to synthesize and activate RPC agents automatically. A novel feature of Cicero is the use of event patterns <ref> [5] </ref> to control synchrony, asynchrony and concurrency in protocol execution (Section 4.1). Nestor is a remote evaluation system [6, 7] specialized for synthesizing RPC agents. <p> Because complex dependencies often exist among event instances, Cicero borrows a feature called event action e1 e2 (e1 , e2):action T e1 action e2 action (e1 ~ e2):action T = action termination e1 e2 action (e1 ^ e2):action patterns from the language Post <ref> [5] </ref> to help programmers express such dependencies. An event pattern specifies the precise relationships between event instances that trigger actions in a protocol, and it is used by programmers to control synchrony, asynchrony, and sequencing in protocol construction.
Reference: [6] <author> J. R. Falcone. </author> <title> A Programmable Interface Language for Heterogeneous Distributed Systems. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 5(4) </volume> <pages> 331-351, </pages> <year> 1987. </year>
Reference-contexts: A novel feature of Cicero is the use of event patterns [5] to control synchrony, asynchrony and concurrency in protocol execution (Section 4.1). Nestor is a remote evaluation system <ref> [6, 7] </ref> specialized for synthesizing RPC agents.
Reference: [7] <author> J. W. Stamos and D. E. Gifford. </author> <title> Implementing Remote Evaluation. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(7) </volume> <pages> 710-722, </pages> <month> July </month> <year> 1988. </year>
Reference-contexts: A novel feature of Cicero is the use of event patterns [5] to control synchrony, asynchrony and concurrency in protocol execution (Section 4.1). Nestor is a remote evaluation system <ref> [6, 7] </ref> specialized for synthesizing RPC agents.
Reference: [8] <author> K. M. Kavi, B. P. Buckles, and U. N. Bhat. </author> <title> Isomorph-ism Between Petri nets and Dataflow Graphs. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 13(10) </volume> <pages> 1127-1134, </pages> <month> October </month> <year> 1987. </year>
Reference-contexts: The central notion the when construct is based on is event patterns, which provide a dataflow execution model. The dataflow model is chosen because it represents maximal parallelism, and is used in today's high-performance architecture/microprocessors. Also, it can be translated into Petri nets <ref> [8] </ref> to take advantage of existing protocol verification methods/tools [9]. 4.1 Event Patterns Each event is a unbounded sequence of its event instances. An event instance is an object representing an occurrence of an event.
Reference: [9] <author> T. Suzuki, S. M. Shatz, and T. Murata. </author> <title> A Protocol Modeling and Verification Approach Based On A Specification Language and Petri Nets. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> 16(5) </volume> <pages> 523-536, </pages> <month> May </month> <year> 1990. </year>
Reference-contexts: The dataflow model is chosen because it represents maximal parallelism, and is used in today's high-performance architecture/microprocessors. Also, it can be translated into Petri nets [8] to take advantage of existing protocol verification methods/tools <ref> [9] </ref>. 4.1 Event Patterns Each event is a unbounded sequence of its event instances. An event instance is an object representing an occurrence of an event. For example, if timeouts are modeled as events, then the third occurrence of timeout is represented by the third timeout event instance.
References-found: 9

