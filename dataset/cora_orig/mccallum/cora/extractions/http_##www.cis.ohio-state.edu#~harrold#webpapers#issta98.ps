URL: http://www.cis.ohio-state.edu/~harrold/webpapers/issta98.ps
Refering-URL: http://www.cis.ohio-state.edu/~harrold/allpapers.html
Root-URL: 
Email: harrold@cis.ohio-state.edu  grother@cs.orst.edu  sinha@cis.ohio-state.edu  
Title: Computation of Interprocedural Control Dependence  
Author: Mary Jean Harrold Gregg Rothermel Saurabh Sinha 
Keyword: Control and semantic dependence, interprocedural analysis.  
Address: Columbus, OH 43210 USA  Dearborn Hall 307-A Corvallis, OR 97331 USA  Columbus, OH 43210 USA  
Affiliation: Computer and Info. Science Ohio State University 395 Dreese Lab  Computer Science Oregon State University  Computer and Info. Science Ohio State University 395 Dreese Lab  
Abstract: Program dependence information is useful for a variety of software testing and maintenance tasks. Properly defined, control and data dependencies can be used to identify semantic dependencies. To function effectively on whole programs, tools that utilize dependence information require information about interprocedural dependencies: dependencies that exist because of interactions among procedures. Many techniques for computing data and control dependencies exist; however, in our search of the literature we find only one attempt to define and compute interprocedural control dependencies. Unfortunately, that approach can omit important control dependencies, and incorrectly identifies control dependencies for a large class of programs. This paper presents a definition of in-terprocedural control dependence that supports the relationship of control and data dependence to semantic dependence, an efficient algorithm for calculating interprocedural control dependencies, and empirical results obtained by our implementation of the algorithm. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <title> Compilers, Prin., Techniques, and Tools. </title> <publisher> Addison-Wesley Publishing Company, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Given the ACFG G A for P i , ComputeInterCD computes the intraprocedural control dependencies for P i using an existing technique <ref> [1, 4, 6, 8, 17] </ref>. To illustrate the construction of an ACFG, consider procedure M from our example program. Figure 4 displays the CFG and the ACFG for M.
Reference: [2] <author> D. C. Atkinson and W. G. Griswold. </author> <title> The design of whole-program analysis tools. </title> <booktitle> In Proc. of the 18th Int'l. Conf. on Softw. Eng., </booktitle> <pages> pages 1627, </pages> <month> Mar. </month> <year> 1996. </year>
Reference-contexts: Like the invocation graph [7] and the context graph <ref> [2] </ref>, the IIFG is fully context-sensitive: it accounts for the calling sequence that leads to each call. However, unlike the invocation and context graphs, the IIFG is also flow sensitive: it accounts for the control flow of the individual procedures. We define the IIFG more formally as follows: Definition 9.
Reference: [3] <author> R. Ballance and B. Maccabe. </author> <title> Program dependence graphs for the rest of us. </title> <type> Technical report, </type> <institution> University of New Mexico, </institution> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: Our definition 9 clarifies the application of Podgurski and Clarke's (and other flow-graph based) definitions of control dependence to interprocedural control dependence. Various algorithms for calculating control dependencies exist (e.g., <ref> [3, 4, 6, 8, 9, 15, 17] </ref>). Some of these algorithms (e.g., [3, 9]) operate on abstract syntax trees for individual procedures, and are therefore strictly intraprocedural. As presented, most other algorithms operate on control flow graphs. <p> Our definition 9 clarifies the application of Podgurski and Clarke's (and other flow-graph based) definitions of control dependence to interprocedural control dependence. Various algorithms for calculating control dependencies exist (e.g., [3, 4, 6, 8, 9, 15, 17]). Some of these algorithms (e.g., <ref> [3, 9] </ref>) operate on abstract syntax trees for individual procedures, and are therefore strictly intraprocedural. As presented, most other algorithms operate on control flow graphs.
Reference: [4] <author> G. Bilardi and K. Pingali. </author> <title> A framework for generalized control dependence. </title> <booktitle> In Proc. of SIGPLAN'96 Conf. on Prog. Lang. Design and Implem., </booktitle> <pages> pages 291300, </pages> <month> May </month> <year> 1996. </year>
Reference-contexts: Much research (e.g., <ref> [4, 6, 8, 17, 19, 21] </ref>) has addressed the problem of computing intraprocedural dependencies: dependencies that exist within procedures and can be computed by analyzing procedures independently. <p> Several types of control dependence exist. We restrict our attention to the form of control dependence found most commonly in the literature, described as control dependence [8], as direct, strong control dependence [18], and as classical control dependence <ref> [4] </ref>. Definition 4. Let G = (N; E) be a CFG, and let u; v 2 N . Node u is control dependent on node v iff v has successors v 0 and v 00 such that u postdominates v 0 but u does not postdominate v 00 . <p> Given the ACFG G A for P i , ComputeInterCD computes the intraprocedural control dependencies for P i using an existing technique <ref> [1, 4, 6, 8, 17] </ref>. To illustrate the construction of an ACFG, consider procedure M from our example program. Figure 4 displays the CFG and the ACFG for M. <p> Definitions of control dependence appear frequently in the research literature (e.g., <ref> [4, 6, 8, 15, 18] </ref>). In most cases these definitions are stated in terms of relationships between nodes in flow graphs that are said to represent programs. However, these definitions seldom explicitly describe the relationship of these graphs to whole programs. <p> Our definition 9 clarifies the application of Podgurski and Clarke's (and other flow-graph based) definitions of control dependence to interprocedural control dependence. Various algorithms for calculating control dependencies exist (e.g., <ref> [3, 4, 6, 8, 9, 15, 17] </ref>). Some of these algorithms (e.g., [3, 9]) operate on abstract syntax trees for individual procedures, and are therefore strictly intraprocedural. As presented, most other algorithms operate on control flow graphs. <p> Future work could investigate this extension, and the relationship of these results to generalized control dependence <ref> [4] </ref>. 8 ACKNOWLEDGMENTS This work was supported in part by a grant from Microsoft, Inc., by NSF under NYI award CCR-9696157 to Ohio State University and under ESS Award CCR-9707792 to Ohio State University, Oregon State University, and the University of Maryland, and by an Ohio State University Research Foundation Seed
Reference: [5] <author> D. Binkley. </author> <title> Using semantic differencing to reduce the cost of regression testing. </title> <booktitle> Proc. of the 1992 Conf. on Softw. Maint., </booktitle> <pages> pages 4150, </pages> <month> Nov. </month> <year> 1992. </year>
Reference-contexts: non-embedded exit () statements at the ends of their main function: because these statements cannot affect control dependencies, we did not count them. sites, and construct a control flow graph from the resulting pro-gram; as such, an IIFG represents the control flow in a program that has been rolled out <ref> [5] </ref>. Like the invocation graph [7] and the context graph [2], the IIFG is fully context-sensitive: it accounts for the calling sequence that leads to each call. However, unlike the invocation and context graphs, the IIFG is also flow sensitive: it accounts for the control flow of the individual procedures.
Reference: [6] <author> R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and F. Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependence graph. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 13(4):45090, </volume> <month> Oct. </month> <year> 1991. </year>
Reference-contexts: Much research (e.g., <ref> [4, 6, 8, 17, 19, 21] </ref>) has addressed the problem of computing intraprocedural dependencies: dependencies that exist within procedures and can be computed by analyzing procedures independently. <p> Given the ACFG G A for P i , ComputeInterCD computes the intraprocedural control dependencies for P i using an existing technique <ref> [1, 4, 6, 8, 17] </ref>. To illustrate the construction of an ACFG, consider procedure M from our example program. Figure 4 displays the CFG and the ACFG for M. <p> Definitions of control dependence appear frequently in the research literature (e.g., <ref> [4, 6, 8, 15, 18] </ref>). In most cases these definitions are stated in terms of relationships between nodes in flow graphs that are said to represent programs. However, these definitions seldom explicitly describe the relationship of these graphs to whole programs. <p> Our definition 9 clarifies the application of Podgurski and Clarke's (and other flow-graph based) definitions of control dependence to interprocedural control dependence. Various algorithms for calculating control dependencies exist (e.g., <ref> [3, 4, 6, 8, 9, 15, 17] </ref>). Some of these algorithms (e.g., [3, 9]) operate on abstract syntax trees for individual procedures, and are therefore strictly intraprocedural. As presented, most other algorithms operate on control flow graphs.
Reference: [7] <author> M. Emami, R. Ghiya, and L. J. Hendren. </author> <title> Context-sensitive interprocedural points-to analysis in the presence of function pointers. </title> <booktitle> Proc. of the ACM SIGPLAN'94 Conf. on Prog. Lang. Design and Implem., </booktitle> <pages> pages 242256, </pages> <month> June </month> <year> 1994. </year>
Reference-contexts: Like the invocation graph <ref> [7] </ref> and the context graph [2], the IIFG is fully context-sensitive: it accounts for the calling sequence that leads to each call. However, unlike the invocation and context graphs, the IIFG is also flow sensitive: it accounts for the control flow of the individual procedures.
Reference: [8] <author> J. Ferrante, K. J. Ottenstein, and J. D. Warren. </author> <title> The program dependence graph and its use in optimization. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 9(3):319349, </volume> <month> July </month> <year> 1987. </year>
Reference-contexts: Much research (e.g., <ref> [4, 6, 8, 17, 19, 21] </ref>) has addressed the problem of computing intraprocedural dependencies: dependencies that exist within procedures and can be computed by analyzing procedures independently. <p> A node u 2 N post-dominates a node v 2 N iff every walk from v to n x in G contains u. Several types of control dependence exist. We restrict our attention to the form of control dependence found most commonly in the literature, described as control dependence <ref> [8] </ref>, as direct, strong control dependence [18], and as classical control dependence [4]. Definition 4. Let G = (N; E) be a CFG, and let u; v 2 N . <p> For control dependence computation, a CFG, G, is augmented with a unique predicate node, n s , and edges, (n s ,n e ), labeled true, and (n s ,n x ), labeled false <ref> [8] </ref>. By this mechanism, nodes in G that are not control dependent on any predicate nodes are control dependent on entry to the procedure. The following definitions extend the CFG to model data elements, and use this extension to define data dependence. Definition 5. <p> Given the ACFG G A for P i , ComputeInterCD computes the intraprocedural control dependencies for P i using an existing technique <ref> [1, 4, 6, 8, 17] </ref>. To illustrate the construction of an ACFG, consider procedure M from our example program. Figure 4 displays the CFG and the ACFG for M. <p> We wanted to study (1) the efficiency of our algorithm in practice and (2) the differences between the interprocedural control dependencies computed by our algorithm, and the intraprocedural control dependencies computed by a traditional algorithm <ref> [8] </ref>. The intent of our study is to demonstrate the inadequacy of intraprocedural control-dependence information alone at representing the control dependencies that exist interprocedurally in whole programs not to demonstrate a flaw in those algorithms' ability to compute in-traprocedural control dependencies. <p> To measure the degree to which control dependencies calculated interprocedurally can differ from those computed by an intraproce-dural algorithm, we measured the differences between the interpro-cedural control dependencies computed by our algorithm, and the intraprocedural control dependencies computed by a traditional algorithm <ref> [8] </ref>. Table 4 displays these statistics. <p> Definitions of control dependence appear frequently in the research literature (e.g., <ref> [4, 6, 8, 15, 18] </ref>). In most cases these definitions are stated in terms of relationships between nodes in flow graphs that are said to represent programs. However, these definitions seldom explicitly describe the relationship of these graphs to whole programs. <p> Our definition 9 clarifies the application of Podgurski and Clarke's (and other flow-graph based) definitions of control dependence to interprocedural control dependence. Various algorithms for calculating control dependencies exist (e.g., <ref> [3, 4, 6, 8, 9, 15, 17] </ref>). Some of these algorithms (e.g., [3, 9]) operate on abstract syntax trees for individual procedures, and are therefore strictly intraprocedural. As presented, most other algorithms operate on control flow graphs.
Reference: [9] <author> M. J. Harrold and G. Rothermel. </author> <title> Syntax-directed construction of program dependence graphs. </title> <type> Technical Report OSU-CISRC-5/96-TR32, </type> <institution> The Ohio State University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Our definition 9 clarifies the application of Podgurski and Clarke's (and other flow-graph based) definitions of control dependence to interprocedural control dependence. Various algorithms for calculating control dependencies exist (e.g., <ref> [3, 4, 6, 8, 9, 15, 17] </ref>). Some of these algorithms (e.g., [3, 9]) operate on abstract syntax trees for individual procedures, and are therefore strictly intraprocedural. As presented, most other algorithms operate on control flow graphs. <p> Our definition 9 clarifies the application of Podgurski and Clarke's (and other flow-graph based) definitions of control dependence to interprocedural control dependence. Various algorithms for calculating control dependencies exist (e.g., [3, 4, 6, 8, 9, 15, 17]). Some of these algorithms (e.g., <ref> [3, 9] </ref>) operate on abstract syntax trees for individual procedures, and are therefore strictly intraprocedural. As presented, most other algorithms operate on control flow graphs.
Reference: [10] <author> M. J. Harrold and G. Rothermel. Aristotle: </author> <title> A system for research on and development of program-analysis-based tools. </title> <type> Technical Report OSU-CISRC-3/97-TR17, </type> <institution> The Ohio State University, </institution> <month> Mar. </month> <year> 1997. </year>
Reference-contexts: We examined 20 programs from the Aristotle analysis system <ref> [10] </ref>; 23 programs from the Eli text processor generation system; the Empire Internet game; 20 programs from the GCC 2.3.3 compiler distribution; the Omega data dependence analyzer; seven programs that were used by researchers at Siemens Laboratories for a study on data-flow testing [13]; and the XVCG tool for displaying graphs. <p> To obtain the CFGs and intraprocedural control dependence information required for this implementation, we used the Aristotle program analysis system <ref> [10] </ref>. We wanted to study (1) the efficiency of our algorithm in practice and (2) the differences between the interprocedural control dependencies computed by our algorithm, and the intraprocedural control dependencies computed by a traditional algorithm [8].
Reference: [11] <author> M. J. Harrold, G. Rothermel, and S. Sinha. </author> <title> Computation of interprocedural control dependencies. </title> <type> Technical Report OSU-CISRC-7/97-TR36, </type> <institution> The Ohio State University, </institution> <month> July </month> <year> 1997. </year>
Reference-contexts: The definitions of walks, postdominance, and dependencies presented in the preceding section apply to IIFGs, or to a def/use-graph extension of the IIFG similar to that employed in Definition 5. Moreover, as we show in <ref> [11] </ref>, the IIFG (in its def/use-graph extension) possesses the characteristics of graphs, defined in [18], that are required to support the proof of Theorem 1. Thus, the syntactic semantic relationship holds for appropriate definitions of control dependence based on the IIFG. <p> The algorithm proceeds in three steps, which correspond to the steps described above. We next describe each step of the algorithm; additional details can be found in <ref> [11] </ref>. Step 1 (line 1) of ComputeInterCD identifies call sites in P from which, due to the presence of embedded halts, control may not return to the caller. To identify these call sites, the algorithm requires information about interprocedural flow of control in P. <p> We illustrate this step by example; details are presented in <ref> [11] </ref>. Consider the ICFG shown in Figure 3. ComputeInterCD performs a reverse depth-first traversal of the ICFG from node 18 the node that contains the halt statement. <p> Also, although we do not discuss it here, the algorithm correctly handles procedures from which, due to embedded halts that are unconditionally executed, control cannot return <ref> [11] </ref>. In Step 2 (lines 25), ComputeInterCD computes intraprocedu-ral control dependencies for each P i in P. <p> 77 54 main.c 590 198 81 Siemens print tok.c 820 492 142 print tok.c 833 482 133 replace.c 908 625 205 schedule.c 439 233 110 schedule2.c 447 276 130 tcas.c 137 68 48 tot info.c 518 182 95 Average 593 271 115 6 Related Work We briefly review related work; <ref> [11] </ref> extends this discussion. Definitions of control dependence appear frequently in the research literature (e.g., [4, 6, 8, 15, 18]). In most cases these definitions are stated in terms of relationships between nodes in flow graphs that are said to represent programs. <p> Podgurski and Clarke [18] state that their definition of the control flow graph can represent any procedural program; however, as presented, that definition also applies to a class of ICFGs on which the syntactic semantic relationship does not hold <ref> [11] </ref>. Our definition 9 clarifies the application of Podgurski and Clarke's (and other flow-graph based) definitions of control dependence to interprocedural control dependence. Various algorithms for calculating control dependencies exist (e.g., [3, 4, 6, 8, 9, 15, 17]).
Reference: [12] <author> M. J. Harrold and M. L. Soffa. </author> <title> Efficient computation of inter-procedural definition-use chains. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 16(2):175204, </volume> <month> Mar. </month> <year> 1994. </year>
Reference-contexts: To function effectively on whole programs, however, tools that require dependence information also require information about interprocedural dependencies: dependencies that exist because of interactions among procedures. Many definitions of, and methods for computing, interprocedural data dependencies have been presented (e.g., <ref> [12, 14, 16, 20, 22] </ref>). In contrast, our search of the research literature reveals only one attempt to define and compute interprocedural control dependencies [15].
Reference: [13] <author> M. Hutchins, H. Foster, T. Goradia, and T. </author> <title> Ostrand. Experiments on the effectiveness of dataflow- and controlflow-based test adequacy criteria. </title> <booktitle> In Proc. of the 16th Int'l. on Softw. </booktitle> <address> Eng., pages 191200, </address> <month> May </month> <year> 1994. </year>
Reference-contexts: 20 programs from the Aristotle analysis system [10]; 23 programs from the Eli text processor generation system; the Empire Internet game; 20 programs from the GCC 2.3.3 compiler distribution; the Omega data dependence analyzer; seven programs that were used by researchers at Siemens Laboratories for a study on data-flow testing <ref> [13] </ref>; and the XVCG tool for displaying graphs. Over 63% of the programs we examined contained exit () statements. 3 Although preliminary, these results suggest that in C programs, embedded halts are used frequently.
Reference: [14] <author> W. Landi and B. G. Ryder. </author> <title> A safe approximate algorithm for interprocedural pointer aliasing. </title> <booktitle> In Proc. of SIGPLAN '92 Conf. on Prog. Lang. Design and Implem., </booktitle> <pages> pages 235248, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: To function effectively on whole programs, however, tools that require dependence information also require information about interprocedural dependencies: dependencies that exist because of interactions among procedures. Many definitions of, and methods for computing, interprocedural data dependencies have been presented (e.g., <ref> [12, 14, 16, 20, 22] </ref>). In contrast, our search of the research literature reveals only one attempt to define and compute interprocedural control dependencies [15]. <p> To identify these call sites, the algorithm requires information about interprocedural flow of control in P. To obtain this information, the algorithm constructs an interprocedural control flow graph (ICFG) that connects individual CF G i s at call sites <ref> [14] </ref>. We define the ICFG more formally as follows: Definition 11.
Reference: [15] <author> J. Loyall and S. Mathisen. </author> <title> Using dependence analysis to support the software maintenance process. </title> <booktitle> In Proc. of the Conf. on Softw. Maint., </booktitle> <pages> pages 28291, </pages> <month> Sept. </month> <year> 1993. </year>
Reference-contexts: Many definitions of, and methods for computing, interprocedural data dependencies have been presented (e.g., [12, 14, 16, 20, 22]). In contrast, our search of the research literature reveals only one attempt to define and compute interprocedural control dependencies <ref> [15] </ref>. Unfortunately, that approach omits control dependencies that may indicate the presence of semantic dependencies, and it incorrectly identifies control dependencies for a large class of programs. <p> Moreover, these statements execute regardless of the evaluation of statement 4. One possible application of the definition of postdominance (Definition 3) might seem to imply that statements 10, 11, 14 and 17 postdominate statement 4, and thus, cannot be control dependent on statement 4. (Reference <ref> [15] </ref> draws this conclusion.) However, despite the fact that the second call to B guarantees that statements 10, 11, 14, and 17 execute at least once, statement 4 does determine the number of times that the statements execute. <p> Moreover, as we show in the next section, there is an efficient algorithm to precisely calculate s-control dependencies. Furthermore, for applications such as the calculation of procedure-level control dependencies <ref> [15] </ref>, s-control dependencies yield results just as precise as do control dependencies. 4 Computation of Interprocedural S-Control-Dependencies One way to compute interprocedural s-control dependencies for a non-recursive program P is to build the IIFG G I for P, use an existing algorithm to compute node-based control dependencies in G I , <p> Definitions of control dependence appear frequently in the research literature (e.g., <ref> [4, 6, 8, 15, 18] </ref>). In most cases these definitions are stated in terms of relationships between nodes in flow graphs that are said to represent programs. However, these definitions seldom explicitly describe the relationship of these graphs to whole programs. <p> Our definition 9 clarifies the application of Podgurski and Clarke's (and other flow-graph based) definitions of control dependence to interprocedural control dependence. Various algorithms for calculating control dependencies exist (e.g., <ref> [3, 4, 6, 8, 9, 15, 17] </ref>). Some of these algorithms (e.g., [3, 9]) operate on abstract syntax trees for individual procedures, and are therefore strictly intraprocedural. As presented, most other algorithms operate on control flow graphs. <p> Alternatively, given an IIFG, these algorithms can calculate correct control dependencies for P for non-recursive programs; however, the size of the IIFG may be exponential in program size; thus, such an application may be inefficient. A recent paper by Loyall and Mathisen <ref> [15] </ref> uses ICFGs to define interprocedural control dependence. The authors define postdom-inance in terms of realizable paths in ICFGs, and use that definition to define control dependence in a manner similar to that of our Definition 4. They also extend their definitions to account for the presence of embedded halts. <p> Our current work includes development of a representation and an algorithm that lets us compute such slices. For further example, precise s-control dependencies can be used to calculate procedure-level dependencies <ref> [15] </ref>, which provide a higher-level view of dependencies than statement dependencies for use in program comprehension, debugging, and impact analysis. Just as transfers of control inside procedures complicate control dependence analysis for their enclosing procedures, so, we have shown, halt statements complicate control dependence analysis for their enclosing programs.
Reference: [16] <author> H. Pande, W. Landi, and B. G. Ryder. </author> <title> Interprocedural defuse associations in C programs. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 20(5):385403, </volume> <month> May </month> <year> 1994. </year>
Reference-contexts: To function effectively on whole programs, however, tools that require dependence information also require information about interprocedural dependencies: dependencies that exist because of interactions among procedures. Many definitions of, and methods for computing, interprocedural data dependencies have been presented (e.g., <ref> [12, 14, 16, 20, 22] </ref>). In contrast, our search of the research literature reveals only one attempt to define and compute interprocedural control dependencies [15].
Reference: [17] <author> K. Pingali and G. Bilardi. </author> <title> Optimal control dependence computation and the Roman Chariots problsm. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 19(3):462, </volume> <month> May </month> <year> 1997. </year>
Reference-contexts: Much research (e.g., <ref> [4, 6, 8, 17, 19, 21] </ref>) has addressed the problem of computing intraprocedural dependencies: dependencies that exist within procedures and can be computed by analyzing procedures independently. <p> Given the ACFG G A for P i , ComputeInterCD computes the intraprocedural control dependencies for P i using an existing technique <ref> [1, 4, 6, 8, 17] </ref>. To illustrate the construction of an ACFG, consider procedure M from our example program. Figure 4 displays the CFG and the ACFG for M. <p> Our definition 9 clarifies the application of Podgurski and Clarke's (and other flow-graph based) definitions of control dependence to interprocedural control dependence. Various algorithms for calculating control dependencies exist (e.g., <ref> [3, 4, 6, 8, 9, 15, 17] </ref>). Some of these algorithms (e.g., [3, 9]) operate on abstract syntax trees for individual procedures, and are therefore strictly intraprocedural. As presented, most other algorithms operate on control flow graphs.
Reference: [18] <author> A. Podgurski and L. Clarke. </author> <title> A formal model of program dependences and its implications for software testing, debugging, and maintenance. </title> <journal> IEEE Trans. Softw. Eng., </journal> <volume> 16(9):965 79, </volume> <month> Sept. </month> <year> 1990. </year>
Reference-contexts: Data dependence information captures the effects of data interactions on program behavior. Tools such as slicers use this information for tasks such as debugging, impact analysis, and regression testing. To demonstrate the semantic basis for uses of program dependencies, and to evaluate some of those uses, Podgurski and Clarke <ref> [18] </ref> present a formal model of program dependencies. They distinguish several types of control and data dependencies, and describe conditions under which identification of such dependencies implies, or may not imply, identification of semantic dependencies. <p> Finally, we describe our implementation of a tool based on our algorithm, and empirical results obtained with that tool. 2 Background Unless otherwise stated, the definitions in this section are based on those presented by Podgurski and Clarke <ref> [18] </ref>. Control dependencies are typically defined in terms of control flow graphs, paths in those graphs, and the postdominance relation. Definition 1. <p> Several types of control dependence exist. We restrict our attention to the form of control dependence found most commonly in the literature, described as control dependence [8], as direct, strong control dependence <ref> [18] </ref>, and as classical control dependence [4]. Definition 4. Let G = (N; E) be a CFG, and let u; v 2 N . <p> First, consider the version of Sum created by substituting the alternative versions of lines 6 and 18: 2 For a proof, see <ref> [18] </ref>. Podgurski and Clarke present additional definitions of control and syntactic dependence that provide a necessary condition for semantic dependence for programs that do not halt. this version contains only one call to B, and halts (assuming normal termination) only on reaching the implicit halt at 8. <p> The definitions of walks, postdominance, and dependencies presented in the preceding section apply to IIFGs, or to a def/use-graph extension of the IIFG similar to that employed in Definition 5. Moreover, as we show in [11], the IIFG (in its def/use-graph extension) possesses the characteristics of graphs, defined in <ref> [18] </ref>, that are required to support the proof of Theorem 1. Thus, the syntactic semantic relationship holds for appropriate definitions of control dependence based on the IIFG. Definitions of walks and postdominance based on IIFGs yield a definition of control dependence between IIFG nodes. <p> Definitions of control dependence appear frequently in the research literature (e.g., <ref> [4, 6, 8, 15, 18] </ref>). In most cases these definitions are stated in terms of relationships between nodes in flow graphs that are said to represent programs. However, these definitions seldom explicitly describe the relationship of these graphs to whole programs. <p> In most cases these definitions are stated in terms of relationships between nodes in flow graphs that are said to represent programs. However, these definitions seldom explicitly describe the relationship of these graphs to whole programs. Podgurski and Clarke <ref> [18] </ref> state that their definition of the control flow graph can represent any procedural program; however, as presented, that definition also applies to a class of ICFGs on which the syntactic semantic relationship does not hold [11]. <p> Future work will investigate the effects of such transfers on interprocedural control dependence and its computation, with the aim of generalizing the results presented in this paper to interprocedural arbitrary transfers of control. We believe that our definitions extend to weak control dependence <ref> [18] </ref>, and thus, can define interprocedural control dependencies that preserve the relationship demonstrated in that work between weak syntactic dependence and (possibly non-finitely-demonstrated) semantic dependence.
Reference: [19] <author> L. Pollock and M. L. Soffa. </author> <title> An incremental version of iterative data flow analysis. </title> <journal> IEEE Trans. on Softw. Eng., </journal> <volume> 15(12):15371549, </volume> <month> Dec. </month> <year> 1989. </year>
Reference-contexts: Much research (e.g., <ref> [4, 6, 8, 17, 19, 21] </ref>) has addressed the problem of computing intraprocedural dependencies: dependencies that exist within procedures and can be computed by analyzing procedures independently.
Reference: [20] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In Proc. of the 22nd ACM SIGPLAN-SIGACT Symp. on Prin. of Prog. Lang., </booktitle> <pages> pages 4961, </pages> <month> Jan. </month> <year> 1995. </year>
Reference-contexts: To function effectively on whole programs, however, tools that require dependence information also require information about interprocedural dependencies: dependencies that exist because of interactions among procedures. Many definitions of, and methods for computing, interprocedural data dependencies have been presented (e.g., <ref> [12, 14, 16, 20, 22] </ref>). In contrast, our search of the research literature reveals only one attempt to define and compute interprocedural control dependencies [15].
Reference: [21] <author> B. G. Ryder and M. C. Paull. </author> <title> Incremental data flow analysis algorithms. </title> <journal> ACM Trans. on Prog. Lang. and Sys., </journal> <volume> 10(1):150, </volume> <month> Jan. </month> <year> 1988. </year>
Reference-contexts: Much research (e.g., <ref> [4, 6, 8, 17, 19, 21] </ref>) has addressed the problem of computing intraprocedural dependencies: dependencies that exist within procedures and can be computed by analyzing procedures independently.
Reference: [22] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches to interprocedural data flow analysis. </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: To function effectively on whole programs, however, tools that require dependence information also require information about interprocedural dependencies: dependencies that exist because of interactions among procedures. Many definitions of, and methods for computing, interprocedural data dependencies have been presented (e.g., <ref> [12, 14, 16, 20, 22] </ref>). In contrast, our search of the research literature reveals only one attempt to define and compute interprocedural control dependencies [15].
References-found: 22

