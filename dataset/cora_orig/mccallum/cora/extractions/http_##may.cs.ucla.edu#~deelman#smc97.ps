URL: http://may.cs.ucla.edu/~deelman/smc97.ps
Refering-URL: http://may.cs.ucla.edu/~deelman/vitae.html
Root-URL: http://www.cs.ucla.edu
Title: System Knowledge Acquisition in Parallel Discrete Event Simulation  
Author: Ewa Deelman Boleslaw K. Szymanski 
Address: Troy, NY 12180  Troy, NY 12180  
Affiliation: Computer Science Department Rensselaer Polytechnic Institute  Computer Science Department Rensselaer Polytechnic Institute  
Abstract: Optimistic protocols designed for Parallel Discrete Event Simulation (PDES) rely heavily on the Global Virtual Time (GVT) calculation. Since the simulation uses large amounts of memory, the GVT is used to synchronize processes and discard obsolete system information. In this paper we present a new algorithm, the Continuously Monitored Global Virtual Time (CMGVT). System information, such as the Local Virtual Time (LVT) of each process and information about messages in transit, is appended to simulation messages. We describe and analyze three variants of our GVT algorithm: direct, indirect and transitive knowledge. The direct knowledge algorithm maintains only the local information about outstanding messages. The indirect version is augmented with the information about the knowledge of its direct neighbors. Finally, the transitive version is the most comprehensive. It keeps track of the outstanding messages sent by all processes in the system. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> C.G. Cassandras. </author> <title> Discrete Event Systems: Modeling and Performance Analysis. </title> <address> New York, NY: </address> <publisher> Irwin Publ., </publisher> <year> 1993. </year>
Reference-contexts: 1 Introduction In Discrete Event Simulation (DES) <ref> [1] </ref>, the physical system is modeled by a Logical Process (LP) consisting of the process state, the clock, and the event queue. Events are placed in the queue in the order of the time for which they are scheduled to occur. <p> This gives us the size of the additional overhead introduced by the CMGVT to be O (p). T F V 1 = 6 4 17 26 <ref> [F (9; 1; 3)] </ref> 7 5 A simple TFV is shown in Eqn.2. This TFV belongs to LP 1 . Forcing F (10; 1; 4) represents a message sent by LP 1 to LP 0 . The message has serial number 4 and was sent at virtual time 10.
Reference: [2] <author> R. M. Fujimoto. </author> <title> Parallel Discrete Event Simulation. </title> <journal> Communications of the ACM, </journal> <volume> Vol. 33, No. 10, </volume> <month> Oct. </month> <year> 1990, </year> <pages> pp. 31-53. </pages>
Reference-contexts: The content of this paper does not necessarily reflect the position or policy of the U.S. Government|no official endorsement should be inferred or implied. approaches developed to solve this challenge are based on conservative and optimistic protocols <ref> [2] </ref>. The former prevents causality errors by limiting each LP's progress in time, so although causality is guaranteed [3], tight synchronization between LPs is introduced. The optimistic approach allows causality errors to occur; however, recovery requires rolling back the computation to the time just prior to such an error [4].
Reference: [3] <author> K. M. Chandy and J. Misra. </author> <title> Distributed Simulation: A Case Study in Design and Verification of Distributed Programs. </title> <journal> IEEE Trans. on Software Engineering, </journal> <volume> Vol. 5, </volume> <year> 1979, </year> <pages> pp. 440-452. </pages>
Reference-contexts: Government|no official endorsement should be inferred or implied. approaches developed to solve this challenge are based on conservative and optimistic protocols [2]. The former prevents causality errors by limiting each LP's progress in time, so although causality is guaranteed <ref> [3] </ref>, tight synchronization between LPs is introduced. The optimistic approach allows causality errors to occur; however, recovery requires rolling back the computation to the time just prior to such an error [4]. Once the rollback is completed, the computation is restarted. In this paper, we concentrate on optimistic PDES.
Reference: [4] <author> D.R. Jefferson. </author> <title> Virtual Time. </title> <journal> Trans. Prog. Lang. and Syst., </journal> <volume> Vol. 7, </volume> <year> 1985, </year> <pages> pp. 404-425. </pages>
Reference-contexts: The former prevents causality errors by limiting each LP's progress in time, so although causality is guaranteed [3], tight synchronization between LPs is introduced. The optimistic approach allows causality errors to occur; however, recovery requires rolling back the computation to the time just prior to such an error <ref> [4] </ref>. Once the rollback is completed, the computation is restarted. In this paper, we concentrate on optimistic PDES.
Reference: [5] <author> M. Raynal and M. Singhal. </author> <title> Logical Time: Capturing Causality in Distributed Systems. </title> <journal> IEEE Computer, </journal> <volume> Vol. 29, </volume> <month> Feb. </month> <year> 1996, </year> <pages> pp. 49-53. </pages>
Reference-contexts: Our algorithm keeps track of all messages in transit by appending information about them to event messages as well as to antimessages. This algorithm is based on the idea of the vector and matrix clocks <ref> [5] </ref>, used to order events and discard obsolete system information in distributed systems. The challenge, however, is to be able to handle logical time going backward as well as forward, which is not supported by the vector and matrix clocks. <p> The vector clock [9], which consists of a vector with a size equal to the number of processes, describes the logical progress of each process in the system. This clock can be used, for example, for causal ordering of messages in a distributed environment. A matrix clock <ref> [5] </ref>, which is represented by a p fi p matrix, where p is the number of processes, describes the knowledge a particular process has about the knowledge that all the processes in the system have about each other. The matrix clock is mostly used to discard obsolete system information.
Reference: [6] <author> G. </author> <title> Tel. </title> <booktitle> Topics in distributed algorithms. </booktitle> <address> Cambridge, UK: </address> <publisher> Cambridge University Press, </publisher> <year> 1991. </year>
Reference-contexts: Upon receipt of the message, the receiving LP will have to roll back to the time just prior to t m . To keep track of messages in transit, some approaches involve acknowledging every message received while keeping track of the messages that were not acknowledged <ref> [6] </ref>. Each process keeps a list of unacknowledged messages. Upon receipt of a message, the receiving LP sends an acknowledgment. When it is received, the message is removed from the unacknowledged list.
Reference: [7] <author> H. Bauer and C. Sporrer. </author> <title> Distributed Logic Simulation and an Approach to Asynchronous GVT-Calculation. </title> <booktitle> Workshop on Parallel and Distributed Simulation, </booktitle> <year> 1992, </year> <pages> pp. 205-208. </pages>
Reference-contexts: When it is received, the message is removed from the unacknowledged list. The GVT is calculated by synchronizing the LPs and taking the minimum of all local virtual times and the timestamp of all unacknowledged messages. A centralized message tracking algorithm was proposed by Bauer <ref> [7] </ref>. In this algorithm, the processes send information messages to a central process. The messages contain information about what messages were sent and received via static communication channels. The central process combines the available information and redistributes its knowledge back to the processes.
Reference: [8] <author> J. S. Steinman, C. A. Lee, L. F. Wilson, and D. M. Nicol. </author> <title> Global Virtual Time and Distributed Synchronization. </title> <booktitle> Workshop on Parallel and Distributed Simulation, </booktitle> <year> 1995, </year> <pages> pp. 139-148, </pages>
Reference-contexts: The central process combines the available information and redistributes its knowledge back to the processes. This approach, however, suffers from a communication bottleneck, since the central process can be flooded with incoming messages. The SPEEDES system uses a practical approach to the GVT calculation <ref> [8] </ref>. When this calculation is initiated, the processes enter a risk free mode, in which, although they continue to process local events, they do not send any event messages; however, antimessages are sent in order to minimize impending rollbacks.
Reference: [9] <author> C. Fidge. </author> <title> Logical time in distributed computing systems. </title> <journal> IEEE Computer, </journal> <volume> Vol. 24, No. 1, </volume> <year> 1991, </year> <pages> pp. 28-33. </pages>
Reference-contexts: Once a process receives a message from another process, it knows at least as much about the system as the sender knew at the time the message was issued. The idea of piggy-backing system information has been used before in distributed systems. The vector clock <ref> [9] </ref>, which consists of a vector with a size equal to the number of processes, describes the logical progress of each process in the system. This clock can be used, for example, for causal ordering of messages in a distributed environment.
Reference: [10] <author> E. Deelman and B. K. Szymanski. </author> <title> Continuously Monitored Global Virtual Time. </title> <booktitle> to appear in International Conference on Parallel and Distributed Processing Techniques and Applications, </booktitle> <year> 1997. </year>
Reference-contexts: It can do so periodically, or only when on the verge of running out of memory. A more detailed explanation of the algorithm and its performance comparison with the SPEEDES algorithm is presented in <ref> [10] </ref>. 4 Three Levels of Knowledge In this paper, we investigate the impact of the amount of knowledge that is sent between the LPs on the quality of the GVT estimate. The algorithm described above contains the TRANSITIVE knowledge an LP has about the system.
Reference: [11] <author> E. Deelman, T. Caraco, and B. K. Szyman-ski. </author> <title> Parallel Discrete Event Simulation of Lyme Disease. </title> <booktitle> Pacific Biocomputing Conference, </booktitle> <year> 1996, </year> <pages> pp. 191-202. </pages>
Reference-contexts: This message contains the object being moved, the "Move Event", and all the future events associated with the object. We have currently implemented in our system a simulation of the spread of Lyme disease <ref> [11] </ref>. The application is programmed in C++ using MPI [12] for message passing. The simulation runs on the IBM SP2, an MIMD distributed memory machine with several processors (our configuration consists of 32). We used a strip decomposition in the dominant direction to divide the lattice among LPs.
Reference: [12] <author> W. Gropp, E. Lusk, and A. Skjellum. </author> <title> Using MPI. </title> <address> Cambridge, MA: </address> <publisher> The MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: This message contains the object being moved, the "Move Event", and all the future events associated with the object. We have currently implemented in our system a simulation of the spread of Lyme disease [11]. The application is programmed in C++ using MPI <ref> [12] </ref> for message passing. The simulation runs on the IBM SP2, an MIMD distributed memory machine with several processors (our configuration consists of 32). We used a strip decomposition in the dominant direction to divide the lattice among LPs.
Reference: [13] <author> E. Deelman and B. K. Szymanski. </author> <title> Simulating Lyme Disease Using Parallel Discrete Event Simulation. </title> <booktitle> Winter Simulation Conference, </booktitle> <year> 1996, </year> <pages> pp. 1191-1198. </pages>
Reference-contexts: The results presented below were obtained with the division of the space into as many strips as we have processors, giving the assignment of one LP per processor. We have also investigated multiple LP-to-processor mappings <ref> [13] </ref>. We use the CMGVT algorithm to calculate the GVT at predetermined intervals of the simulated time. 6 Results First, we present the runtime differences of the three versions of the algorithm.
References-found: 13

