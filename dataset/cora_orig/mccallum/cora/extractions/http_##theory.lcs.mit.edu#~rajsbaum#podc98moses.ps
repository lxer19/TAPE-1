URL: http://theory.lcs.mit.edu/~rajsbaum/podc98moses.ps
Refering-URL: http://theory.lcs.mit.edu/~rajsbaum/
Root-URL: 
Email: Email: yoram@cs.weizmann.ac.il  Email: rajsbaum@servidor.unam.mx  
Title: The Unified Structure of Consensus: a Layered Analysis Approach  
Author: Yoram Moses Sergio Rajsbaum 
Address: Rehovot, 76100 Israel.  Ciudad Universitaria, D.F. 04510, Mexico.  
Affiliation: Department of Applied Math and CS, The Weizmann Institute of Science,  Instituto de Matematicas, UNAM,  
Abstract: We introduce a simple notion of layering that provides a tool for defining submodels of a given model of distributed computation. We describe two layerings, the synchronic and the permutation layering, and show that they induce appropriate submodels of several asynchronous models of computation. The synchronic layering applies to the synchronous model too. We perform a model-independent analysis of the consensus problem in terms of abstract connectivity properties of layering functions. By defining particular layerings in specific models, we derive several popular (and some new) lower bounds and impossibility results for consensus in various classical models. These results are often stronger in the sense that they apply to the submodel induced by the layering. The proofs obtained in this way are also simpler and more direct than existing ones. Moreover, the analysis is done in a uniform fashion and demonstrates the fundamental common structure of the consensus problem in the presence of failures. The analysis is then extended to general decision problems (1-resilient in the asynchronous models, t-rounds in the t-resilient synchronous model), providing a characterization of solvability of decision problems in the style of [8] which, for some of the models, is given for the first time. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Baruch Awerbuch, </author> <title> "Complexity of Network Synchronization," </title> <journal> Journal of the ACM, </journal> <volume> Vol. 32, No. 4, </volume> <month> Oct. </month> <year> 1985, </year> <pages> pp. 804-823. </pages>
Reference-contexts: Various such simulations have been given, e.g. between shared memory and message passing [3]; between snapshot shared memory and read/write shared memory [2], or between immediate snapshot shared memory and read/write shared memory [5, 6]; between synchronous and asynchronous message passing <ref> [1] </ref>; between two shared memory models of different resilience [5].
Reference: [2] <author> Y. Afek, H. Attiya, D. Dolev, E. Gafni, M. Merritt, N. Shavit, </author> <title> "Atomic snapshots of shared memory," </title> <journal> Journal of the ACM, </journal> <volume> Vol. 40, No. 4, </volume> <month> (September </month> <year> 1993), </year> <pages> pp. 873-890. </pages>
Reference-contexts: Various such simulations have been given, e.g. between shared memory and message passing [3]; between snapshot shared memory and read/write shared memory <ref> [2] </ref>, or between immediate snapshot shared memory and read/write shared memory [5, 6]; between synchronous and asynchronous message passing [1]; between two shared memory models of different resilience [5]. <p> In the full paper we use the same techniques to extend the equivalence to snapshot shared memory <ref> [2] </ref>, iterated immediate snapshot [6], and related models. The Synchronous Model We now consider decision problems in the t-resilient synchronous model of computation of Section 6. It is well-known that consensus and a large class of decision problems are solvable in t + 1 rounds in the synchronous model.
Reference: [3] <author> H. Attiya, A. Bar-Noy and D. Dolev, </author> <title> "Sharing Memory Robustly in Message-Passing Systems," </title> <journal> Journal of the ACM, </journal> <volume> Vol. 42, No. </volume> <month> 1 (January </month> <year> 1995), </year> <pages> pp. 124-142. </pages>
Reference-contexts: This is used to establish impossibility results in particular models, or to provide a systematic way to transform protocols written in one model into protocols for another model. Various such simulations have been given, e.g. between shared memory and message passing <ref> [3] </ref>; between snapshot shared memory and read/write shared memory [2], or between immediate snapshot shared memory and read/write shared memory [5, 6]; between synchronous and asynchronous message passing [1]; between two shared memory models of different resilience [5].
Reference: [4] <author> Hagit Attiya and Sergio Rajsbaum, </author> <title> "The Combinatorial Structure of Wait-free Solvable Tasks," </title> <booktitle> 10th International Workshop on Distributed Algorithms (WDAG), </booktitle> <month> October </month> <year> 1996, </year> <editor> (O. Babaoglu and K. Marzullo, </editor> <booktitle> Eds.), </booktitle> <pages> pp. 321-343. </pages> <booktitle> Lecture Notes in Computer Science #1151, </booktitle> <publisher> Springer-Verlag. </publisher>
Reference-contexts: The use of layerings facilitates performing round-by-round analysis: Almost all of our results regarding consensus will follow from analyzing a single layer of computation. The benefit of working in a submodel with a simpler structure than that of the original model is well known; some recent examples are <ref> [4, 5, 6, 8, 19, 25] </ref>. In the main part of the paper we concentrate on the consensus problem. First, we perform an abstract and model-independent analysis of consensus using layering. <p> We consider the layering technique to be useful in a num ber of ways: * It provides a tool for performing model-independent round-by-round analysis of decision tasks and related problems. * Results are obtained directly, and not by means of spe cially tailored reductions. * Popular topological treatments (e.g. <ref> [18, 25, 5, 4] </ref>) focus on the local final states of processes. We consider states at intermediate stages of the computation as well. <p> We shall present this proof with respect to the asynchronous message passing model [14], to provide a direct and simple proof in this model too. The permutation layering is inspired by wait-free immediate snapshot executions in shared memory <ref> [5, 25, 4] </ref>, and pro-vides an analogue of these executions for message passing. 5 In this case, in a local phase for process i, first all outstanding messages that have been sent to i are delivered, and then process i sends messages (according to its protocol) to a maximal set of
Reference: [5] <author> E. Borowsky and E. Gafni, </author> <title> "Generalized FLP impossibility result for t-resilient asynchronous computations," </title> <booktitle> in Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: Various such simulations have been given, e.g. between shared memory and message passing [3]; between snapshot shared memory and read/write shared memory [2], or between immediate snapshot shared memory and read/write shared memory <ref> [5, 6] </ref>; between synchronous and asynchronous message passing [1]; between two shared memory models of different resilience [5]. <p> Various such simulations have been given, e.g. between shared memory and message passing [3]; between snapshot shared memory and read/write shared memory [2], or between immediate snapshot shared memory and read/write shared memory [5, 6]; between synchronous and asynchronous message passing [1]; between two shared memory models of different resilience <ref> [5] </ref>. <p> The use of layerings facilitates performing round-by-round analysis: Almost all of our results regarding consensus will follow from analyzing a single layer of computation. The benefit of working in a submodel with a simpler structure than that of the original model is well known; some recent examples are <ref> [4, 5, 6, 8, 19, 25] </ref>. In the main part of the paper we concentrate on the consensus problem. First, we perform an abstract and model-independent analysis of consensus using layering. <p> The synchronic layering defines a sub-model of the asynchronous models that is very close in structure to being synchronous. Indeed, we show that the syn-chronic layering applies to the synchronous message passing model too. The permutation layering is inspired by the immediate snapshot wait-free model of <ref> [5] </ref>, although we define it both for the message passing and for the shared memory models, 1-resilient. This appears to be the first variant of the immediate snapshot model suggested for a message-passing model. <p> We consider the layering technique to be useful in a num ber of ways: * It provides a tool for performing model-independent round-by-round analysis of decision tasks and related problems. * Results are obtained directly, and not by means of spe cially tailored reductions. * Popular topological treatments (e.g. <ref> [18, 25, 5, 4] </ref>) focus on the local final states of processes. We consider states at intermediate stages of the computation as well. <p> We shall present this proof with respect to the asynchronous message passing model [14], to provide a direct and simple proof in this model too. The permutation layering is inspired by wait-free immediate snapshot executions in shared memory <ref> [5, 25, 4] </ref>, and pro-vides an analogue of these executions for message passing. 5 In this case, in a local phase for process i, first all outstanding messages that have been sent to i are delivered, and then process i sends messages (according to its protocol) to a maximal set of
Reference: [6] <author> E. Borowsky and E. Gafni, </author> <title> "A simple algorithmically reasoned characterization of wait-free computations," </title> <booktitle> in Proceedings of the 16th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 189-198, </pages> <year> 1997. </year>
Reference-contexts: Various such simulations have been given, e.g. between shared memory and message passing [3]; between snapshot shared memory and read/write shared memory [2], or between immediate snapshot shared memory and read/write shared memory <ref> [5, 6] </ref>; between synchronous and asynchronous message passing [1]; between two shared memory models of different resilience [5]. <p> The use of layerings facilitates performing round-by-round analysis: Almost all of our results regarding consensus will follow from analyzing a single layer of computation. The benefit of working in a submodel with a simpler structure than that of the original model is well known; some recent examples are <ref> [4, 5, 6, 8, 19, 25] </ref>. In the main part of the paper we concentrate on the consensus problem. First, we perform an abstract and model-independent analysis of consensus using layering. <p> In the full paper we use the same techniques to extend the equivalence to snapshot shared memory [2], iterated immediate snapshot <ref> [6] </ref>, and related models. The Synchronous Model We now consider decision problems in the t-resilient synchronous model of computation of Section 6. It is well-known that consensus and a large class of decision problems are solvable in t + 1 rounds in the synchronous model.
Reference: [7] <author> O. Biran, S. Moran, S. Zaks, </author> <title> "A combinatorial characterization of the distributed 1-solvable tasks," </title> <journal> Journal of Algorithms, </journal> <volume> Vol. 11 (1990), </volume> <pages> pp. 420-440. </pages>
Reference-contexts: A complex is a set of simplexes that is closed under containment. In an n-size-complex the maximal simplexes have n elements. The consensus problem is an example of a decision problem (e.g. <ref> [7] </ref>). Roughly, these are problems where processes start with input values, communicate with each other, and decide on output values according to the problem specification. <p> This condition essentially coincides with the one in <ref> [7] </ref>. Since in [7] the condition was shown to be also sufficient, then it is also sufficient in the submodels that we have presented. That is, in all these models, the same problems are solvable 1-resiliently. <p> This condition essentially coincides with the one in <ref> [7] </ref>. Since in [7] the condition was shown to be also sufficient, then it is also sufficient in the submodels that we have presented. That is, in all these models, the same problems are solvable 1-resiliently.
Reference: [8] <author> O. Biran, S. Moran and S. Zaks, </author> <title> "Tight Bounds on the Round Complexity of Distributed 1-solvable Tasks," </title> <journal> Theoretical Computer Science, </journal> <volume> Vol. </volume> <pages> 145 (1995) pp. 271-290. </pages>
Reference-contexts: 1 Introduction For almost two decades now, the consensus problem has played a central role in the study of fault-tolerant distributed computing, e.g. <ref> [23, 13, 12, 10, 14, 20, 16, 8, 9] </ref>. It has clearly received the greatest amount of attention in the theoretical literature on distributed computing, and has been studied in a large variety of models and under many types of failure assumptions. <p> The use of layerings facilitates performing round-by-round analysis: Almost all of our results regarding consensus will follow from analyzing a single layer of computation. The benefit of working in a submodel with a simpler structure than that of the original model is well known; some recent examples are <ref> [4, 5, 6, 8, 19, 25] </ref>. In the main part of the paper we concentrate on the consensus problem. First, we perform an abstract and model-independent analysis of consensus using layering. <p> Moreover, in the full paper we show that in a sense, they are strictly stronger than what can be done t-resiliently in t rounds of the standard synchronous model. Thus, our results can be viewed as providing characterizations of solvability of decision problems in the style of <ref> [8] </ref> which, for the mobile failure and synchronous models, are new. <p> Although the condition is similar to the one for the asynchronous systems, it is stronger: There are problems that are solvable 1-resiliently in the asynchronous models we considered, that are not solvable in t rounds of the synchronous model (cf. <ref> [8] </ref>). Fix an arbitrary algorithm A that runs for at most t rounds, and the layering function S t . <p> We now prove a stronger necessary condition, which proves that there are decision problems that are solvable 1-resiliently in the asynchronous models and are not solvable in t rounds of the synchronous model. The additional condition (in the style of <ref> [8] </ref>) bounds the diameter of 0 (s), for any input simplex s. Formally, we define the s-diameter of a set of states X to be the diameter of the graph (X; ~ s ) induced by the similarity relation on X.
Reference: [9] <author> T. Chandra and S. Toueg, </author> <title> "Unreliable failure detectors for asynchronous systems,". </title> <booktitle> in Proceedings of the 10th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <pages> pages 257-272, </pages> <year> 1991. </year>
Reference-contexts: 1 Introduction For almost two decades now, the consensus problem has played a central role in the study of fault-tolerant distributed computing, e.g. <ref> [23, 13, 12, 10, 14, 20, 16, 8, 9] </ref>. It has clearly received the greatest amount of attention in the theoretical literature on distributed computing, and has been studied in a large variety of models and under many types of failure assumptions.
Reference: [10] <author> D. Dolev, H.R. </author> <title> Strong, " Polynomial algorithms for multiple processor agreement," </title> <booktitle> in Proceedings of the 14th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pp. 401-407, </pages> <month> May </month> <year> 1982. </year>
Reference-contexts: 1 Introduction For almost two decades now, the consensus problem has played a central role in the study of fault-tolerant distributed computing, e.g. <ref> [23, 13, 12, 10, 14, 20, 16, 8, 9] </ref>. It has clearly received the greatest amount of attention in the theoretical literature on distributed computing, and has been studied in a large variety of models and under many types of failure assumptions. <p> The well-known lower bound for this case (due originally to <ref> [13, 10] </ref>) states that every consensus protocol must require at least t + 1 rounds in its worst case run. In this model, the environment can use one failure in every round for t to simulate a prefix of an S 1 -run for t rounds. <p> This result was first proved for crash failures by Dolev and Strong <ref> [10] </ref>, and the latest version of the proof is in [11]. Our proof here is the first one we are aware of that is in the style and spirit of the impossibility proofs for the asynchronous case. Moreover, we feel that it is even simpler than the one of [11].
Reference: [11] <author> C. Dwork, Y. Moses, </author> <title> "Knowledge and common knowledge in a byzantine environment: crash failures," </title> <journal> Information and Computation, </journal> <volume> vol. 8, no. 2, </volume> <pages> pp. 156-186, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: This result was first proved for crash failures by Dolev and Strong [10], and the latest version of the proof is in <ref> [11] </ref>. Our proof here is the first one we are aware of that is in the style and spirit of the impossibility proofs for the asynchronous case. Moreover, we feel that it is even simpler than the one of [11]. <p> Strong [10], and the latest version of the proof is in <ref> [11] </ref>. Our proof here is the first one we are aware of that is in the style and spirit of the impossibility proofs for the asynchronous case. Moreover, we feel that it is even simpler than the one of [11]. In addition to generalizing the lower bound for t-resilient consensus, we feel that our proof provides further insight into the structure of consensus protocols in this model. Let us briefly consider an example. <p> Clearly, Lemma 6.1 also partially describes the situation in runs in which potentially more than one process can crash in a given round. It matches the upper (and lower) bounds given in <ref> [11] </ref>, which show roughly that if in some execution k +w crashes are detected by the end of round k, then agreement can be secured by the end of round t + 1 w.
Reference: [12] <author> M. Fischer, </author> <title> "The consensus problem in unreliable distributed systems (a brief survey)," </title> <institution> Research Report YALE/DCS/RR-273, Yale University, Department of Computer Science, </institution> <address> New Haven, Conn., </address> <month> June </month> <year> 1983. </year>
Reference-contexts: 1 Introduction For almost two decades now, the consensus problem has played a central role in the study of fault-tolerant distributed computing, e.g. <ref> [23, 13, 12, 10, 14, 20, 16, 8, 9] </ref>. It has clearly received the greatest amount of attention in the theoretical literature on distributed computing, and has been studied in a large variety of models and under many types of failure assumptions.
Reference: [13] <author> M.J. Fischer, N.A. Lynch, </author> <title> "A lower bound for the time to assure interactive consistency," </title> <journal> Information Processing Letters, </journal> <volume> vol. 14, no. 4, </volume> <pages> pp. 183-186, </pages> <month> June </month> <year> 1982. </year>
Reference-contexts: 1 Introduction For almost two decades now, the consensus problem has played a central role in the study of fault-tolerant distributed computing, e.g. <ref> [23, 13, 12, 10, 14, 20, 16, 8, 9] </ref>. It has clearly received the greatest amount of attention in the theoretical literature on distributed computing, and has been studied in a large variety of models and under many types of failure assumptions. <p> If the state x of R is bivalent, then no process has decided by x. Connectivity As has been observed by many authors starting with <ref> [13] </ref>, connectivity plays a central role in the analysis of decision problems. We use two types of connectivity: Definition 3.1 Let x and y be states of R. <p> The well-known lower bound for this case (due originally to <ref> [13, 10] </ref>) states that every consensus protocol must require at least t + 1 rounds in its worst case run. In this model, the environment can use one failure in every round for t to simulate a prefix of an S 1 -run for t rounds.
Reference: [14] <author> M. Fischer, N.A. Lynch, </author> <title> and M.S. Paterson, "Impossibility of distributed commit with one faulty process," </title> <journal> Journal of the ACM, </journal> <volume> 32(2), </volume> <month> April </month> <year> 1985. </year>
Reference-contexts: 1 Introduction For almost two decades now, the consensus problem has played a central role in the study of fault-tolerant distributed computing, e.g. <ref> [23, 13, 12, 10, 14, 20, 16, 8, 9] </ref>. It has clearly received the greatest amount of attention in the theoretical literature on distributed computing, and has been studied in a large variety of models and under many types of failure assumptions. <p> Obviously, in some models it is possible to determine that a process is faulty by considering only a prefix of the run, sometimes even a single state. In other cases, however, it is impossible to determine this after a finite amount of time. (See, e.g., the asynchronous systems in <ref> [14] </ref>.) 3 Consensus and Connectivity In the classical binary consensus problem [23], processes start with binary values and have to decide on binary values satisfying three conditions. <p> In Sections 3-6, all systems referred to will be assumed to be systems for consensus. Decisions and valence It has long been recognized <ref> [14] </ref> that considering what the possible decisions in the future of a given state are can be a useful tool for analyzing the structure of the consensus problem. This gives rise to the following notions of the valence of a state. <p> Lemma 3.5 Let R satisfy the decision requirement and let X be similarity connected. If R displays an arbitrary crash failure with respect to X, then X is valence connected. Lemma 3.4 and Lemma 3.5 allow us to reprove in our setting the well-known fact from <ref> [14] </ref> that when even a single process can crash, there must be a bivalent initial state for consensus. Lemma 3.6 The set Con 0 is similarity connected. <p> This result is a simple corollary of a theorem of Santoro and Widmayer in [24]. Their proof is the only one we have found that uses a bivalence-based argument in the style of Fischer et al. <ref> [14] </ref> in the synchronous context. 5.1 Impossibility in Asynchronous Models The same outline of the impossibility proof for M mf can be used in the two typical models of asynchronous systems with a single crash failure [14, 20]: message passing and shared memory. <p> have found that uses a bivalence-based argument in the style of Fischer et al. [14] in the synchronous context. 5.1 Impossibility in Asynchronous Models The same outline of the impossibility proof for M mf can be used in the two typical models of asynchronous systems with a single crash failure <ref> [14, 20] </ref>: message passing and shared memory. In these models, "slow" behavior of processes can be used to imitate the omitting behavior in M mf . <p> As for the synchronic layering, essentially the same proof will work in both the shared memory and the message passing models. We shall present this proof with respect to the asynchronous message passing model <ref> [14] </ref>, to provide a direct and simple proof in this model too.
Reference: [15] <author> E. Gafni, </author> <title> "Round-by-round fault detectors: unifying synchrony and asynchrony," </title> <booktitle> these proceedings. </booktitle>
Reference-contexts: We believe that, with small modifications, the same type of analysis and style of reasoning can be applied to study more general problems involving higher levels of topological connectivity. Two other papers that attempt to unify synchronous and asynchronous models in a round by round style are: <ref> [15] </ref> via failure detectors in shared memory, and [17] using topological techniques in synchronous, asynchronous and partially synchronous message passing systems, with applications to set-consensus. A different abstract model based on the runs of a distributed system is proposed in [21].
Reference: [16] <author> M.P. Herlihy, </author> <title> "Wait-Free Synchronization," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> vol. 13, no. 1, </volume> <pages> pp. 123-149, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: 1 Introduction For almost two decades now, the consensus problem has played a central role in the study of fault-tolerant distributed computing, e.g. <ref> [23, 13, 12, 10, 14, 20, 16, 8, 9] </ref>. It has clearly received the greatest amount of attention in the theoretical literature on distributed computing, and has been studied in a large variety of models and under many types of failure assumptions.
Reference: [17] <author> M.P. Herlihy, S. Rajsbaum, M. R. Tuttle, </author> <title> "Unifying synchronous and asynchronous message-passing models," </title> <booktitle> these proceedings. </booktitle>
Reference-contexts: Two other papers that attempt to unify synchronous and asynchronous models in a round by round style are: [15] via failure detectors in shared memory, and <ref> [17] </ref> using topological techniques in synchronous, asynchronous and partially synchronous message passing systems, with applications to set-consensus. A different abstract model based on the runs of a distributed system is proposed in [21].
Reference: [18] <author> M.P. Herlihy and N. Shavit, </author> <title> "The asynchronous computability theorem for t-resilient tasks," </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: We consider the layering technique to be useful in a num ber of ways: * It provides a tool for performing model-independent round-by-round analysis of decision tasks and related problems. * Results are obtained directly, and not by means of spe cially tailored reductions. * Popular topological treatments (e.g. <ref> [18, 25, 5, 4] </ref>) focus on the local final states of processes. We consider states at intermediate stages of the computation as well.
Reference: [19] <author> Gunnar Hoest and Nir Shavit, </author> <title> "Towards a topological characterization of asynchronous complexity," </title> <booktitle> Proc. of the 16th Annual ACM Symposium on Principles of Distributed Computing, </booktitle> <address> Santa Barbara, </address> <year> 1997, </year> <pages> pp. 199-208. </pages>
Reference-contexts: The use of layerings facilitates performing round-by-round analysis: Almost all of our results regarding consensus will follow from analyzing a single layer of computation. The benefit of working in a submodel with a simpler structure than that of the original model is well known; some recent examples are <ref> [4, 5, 6, 8, 19, 25] </ref>. In the main part of the paper we concentrate on the consensus problem. First, we perform an abstract and model-independent analysis of consensus using layering.
Reference: [20] <author> M. C. Loui and H.H. Abu-Amara, </author> <title> "Memory requirements for agreement among unreliable asynchronous processes," In Parallel and Distributed Computing, </title> <editor> F. P. Preparata, editor, </editor> <volume> vol. </volume> <booktitle> 4 of Advances in Computing Research, </booktitle> <pages> pages 163-183. </pages> <publisher> JAI Press, </publisher> <year> 1987. </year>
Reference-contexts: 1 Introduction For almost two decades now, the consensus problem has played a central role in the study of fault-tolerant distributed computing, e.g. <ref> [23, 13, 12, 10, 14, 20, 16, 8, 9] </ref>. It has clearly received the greatest amount of attention in the theoretical literature on distributed computing, and has been studied in a large variety of models and under many types of failure assumptions. <p> have found that uses a bivalence-based argument in the style of Fischer et al. [14] in the synchronous context. 5.1 Impossibility in Asynchronous Models The same outline of the impossibility proof for M mf can be used in the two typical models of asynchronous systems with a single crash failure <ref> [14, 20] </ref>: message passing and shared memory. In these models, "slow" behavior of processes can be used to imitate the omitting behavior in M mf . <p> In this sense, we are going slightly beyond the scope of most of the recent work on topological approaches. Shared memory: the synchronic layering We shall now consider the standard (see for example <ref> [22, 20] </ref>) shared-memory model M rw in which variables are single-writer multiple-reader. For ease of exposition, we shall ignore the decision and other local actions, as their role is obvious, and consider only read and write actions explicitly. <p> By part (ii) and Lemma 3.3 we obtain that y ~ v y 0 , and hence x (j; n) ~ v x (j; A) and we are done. As for M mf , Theorem 4.2, Lemma 4.3 and Lemma 5.1 (iii) now yield the impossibility result <ref> [20] </ref>: Corollary 5.4 No protocol solves the consensus problem in the asynchronous r/w shared memory model while tolerating one crash failure. We remark that a completely analogous impossibility proof can be given for asynchronous message passing as well. <p> The structure of the layering function, and the reasoning underlying the results remain unchanged. Our development leading to Corollary 5.4 can reasonably be viewed as reproving the impossibility result for M rw given in <ref> [20] </ref> by Loui and Abu-Amara. Indeed, we hope the reader finds this version to be somewhat more concise and perhaps easier to digest. We believe, however, that our result can be interpreted as saying quite a bit more.
Reference: [21] <author> Ronit Lubitch and Shlomo Moran, </author> <title> "Closed schedulers: a novel technique for analyzing asynchronous protocols," </title> <journal> Distributed Computing, </journal> <volume> Vol. 8, </volume> <year> 1995, </year> <pages> pp. 203-210. </pages>
Reference-contexts: A different abstract model based on the runs of a distributed system is proposed in <ref> [21] </ref>. For lack of space, some of the proofs are omitted or just sketched in this extended abstract. 2 Definitions In this paper we wish to present an approach that is relevant in a number of different models.
Reference: [22] <author> N.A. Lynch, </author> <title> Distributed Algorithms, </title> <publisher> Morgan Kauf-mann Publishers, Inc. </publisher> <year> 1996. </year>
Reference-contexts: In this sense, we are going slightly beyond the scope of most of the recent work on topological approaches. Shared memory: the synchronic layering We shall now consider the standard (see for example <ref> [22, 20] </ref>) shared-memory model M rw in which variables are single-writer multiple-reader. For ease of exposition, we shall ignore the decision and other local actions, as their role is obvious, and consider only read and write actions explicitly.
Reference: [23] <author> M., Pease, R. Shostak and L. Lamport, </author> <title> "Reaching agreement in the presence of faults," </title> <journal> Journal of the ACM, </journal> <volume> Vol. 27, No. 2, </volume> <pages> pp. 228-234. </pages>
Reference-contexts: 1 Introduction For almost two decades now, the consensus problem has played a central role in the study of fault-tolerant distributed computing, e.g. <ref> [23, 13, 12, 10, 14, 20, 16, 8, 9] </ref>. It has clearly received the greatest amount of attention in the theoretical literature on distributed computing, and has been studied in a large variety of models and under many types of failure assumptions. <p> In other cases, however, it is impossible to determine this after a finite amount of time. (See, e.g., the asynchronous systems in [14].) 3 Consensus and Connectivity In the classical binary consensus problem <ref> [23] </ref>, processes start with binary values and have to decide on binary values satisfying three conditions. Decision, requires that every nonfaulty process eventually decides; Agreement requires that the decisions are identical; and Validity requires that each decision was somebody's input. <p> Moreover, we feel that it is even simpler than the one of [11]. In addition to generalizing the lower bound for t-resilient consensus, we feel that our proof provides further insight into the structure of consensus protocols in this model. Let us briefly consider an example. It is well-known <ref> [23] </ref> that there are t-resilient consensus protocols that are guaranteed to decide in precisely t + 1 rounds. Thus, the worst-case lower bound of Dolev and Strong is tight. Let us call a protocol in which consensus is always reached in at most t + 1 rounds fast.
Reference: [24] <author> N. Santoro and P. Widmayer, </author> <title> "Time is not a healer," </title> <booktitle> In Proc. 6th Annual Symp. Theor. Aspects of Computer Science, Paderborn, </booktitle> <address> Germany, February 1989. </address> <publisher> Springer Verlag LNCS Vol. </publisher> <pages> 349 pp. 304-313. </pages>
Reference-contexts: The set X is said to be valence connected if the graph (X; ~ v ) is connected, and X is said to be similarity connected if (X; ~ s ) is connected. Similarity connectedness has often been considered in the literature (see, e.g., <ref> [24] </ref>). Valence connectedness is, to the best of our knowledge, new. In general, valence connectedness is not a very strong condition. <p> Throughout the paper, we will focus on deterministic protocols. We start with an impossibility for a single mobile failure in the synchronous model <ref> [24] </ref>. We are talking about the standard synchronous model, except that, in every round there can be at most one process some of whose messages are lost. <p> Given Lemma 4.3 and Lemma 5.1 (iii), Theorem 4.2 now yields Corollary 5.2 No protocol solves the consensus problem in the single mobile failure model. This result is a simple corollary of a theorem of Santoro and Widmayer in <ref> [24] </ref>. <p> Acknowledgments: We would like to thank Juan Garay for pointing to us the mobile failure model and the related reference <ref> [24] </ref>.
Reference: [25] <author> M. Saks and F. Zaharoglou, </author> <title> "Wait-free k-set agreement is impossible: The topology of public knowledge," </title> <booktitle> In Proceedings of the 1993 ACM Symposium on Theory of Computing, </booktitle> <month> May </month> <year> 1993. </year>
Reference-contexts: The use of layerings facilitates performing round-by-round analysis: Almost all of our results regarding consensus will follow from analyzing a single layer of computation. The benefit of working in a submodel with a simpler structure than that of the original model is well known; some recent examples are <ref> [4, 5, 6, 8, 19, 25] </ref>. In the main part of the paper we concentrate on the consensus problem. First, we perform an abstract and model-independent analysis of consensus using layering. <p> We consider the layering technique to be useful in a num ber of ways: * It provides a tool for performing model-independent round-by-round analysis of decision tasks and related problems. * Results are obtained directly, and not by means of spe cially tailored reductions. * Popular topological treatments (e.g. <ref> [18, 25, 5, 4] </ref>) focus on the local final states of processes. We consider states at intermediate stages of the computation as well. <p> We shall present this proof with respect to the asynchronous message passing model [14], to provide a direct and simple proof in this model too. The permutation layering is inspired by wait-free immediate snapshot executions in shared memory <ref> [5, 25, 4] </ref>, and pro-vides an analogue of these executions for message passing. 5 In this case, in a local phase for process i, first all outstanding messages that have been sent to i are delivered, and then process i sends messages (according to its protocol) to a maximal set of
References-found: 25

