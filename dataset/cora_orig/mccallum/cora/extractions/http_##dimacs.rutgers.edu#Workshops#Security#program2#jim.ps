URL: http://dimacs.rutgers.edu/Workshops/Security/program2/jim.ps
Refering-URL: http://dimacs.rutgers.edu/Workshops/Security/program2/program.html
Root-URL: http://www.cs.rutgers.edu
Title: Design of an Application-Level Security Infrastructure  
Author: Carl A. Gunter and Trevor Jim 
Affiliation: University of Pennsylvania  
Abstract: We propose a security infrastructure based on authenticated data distribution, implemented via the automatic management of queries and certificates. This approach is appropriate for an infrastructure to be used by application programmers, because they are not experts in cryptographic algorithms or security protocols. Our query certificate managers hide the use of cryptography and message sending from the programmer, and hence prevent programmer errors that could lead to security failures. The system has a formal semantics and correctness guarantees.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Serge Abiteboul, Richard Hull, and Victor Vianu. </author> <title> Foundations of Databases. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: A full semantics can be found in a separate paper [6]. The basis of QCM is the named relational algebra, which can be found in any standard database textbook (e.g., <ref> [1] </ref>). A QCM program is a set of definitions, R 1 = M 1 ; : : : ; R n = M n where each R i is a relation symbol and each M i is a relational algebra expression.
Reference: [2] <author> Ross Anderson. </author> <title> Why cryptosystems fail. </title> <booktitle> In 1st ACM Conference on Computer and Communications Security, </booktitle> <month> November </month> <year> 1993. </year>
Reference-contexts: Many cryptographic protocols designed by experts have turned out to be flawed, and application programmers are not experts in cryptographic algorithms, security protocols, and formal methods. Even when provided with formally verified, bug-free cryptography and protocols, they still build insecure systems <ref> [2, 3] </ref>. Taking automatic memory management as a guide, we seek to eliminate security bugs by hiding the use of cryptography, protocols, and message exchange from the programmer. Instead, the basic primitive we provide is authenticated data distribution, and we implement it by the automatic management of queries and certificates.
Reference: [3] <author> Ross Anderson. </author> <title> Making smartcard systems robust. </title> <booktitle> In Cardis 94, </booktitle> <year> 1994. </year>
Reference-contexts: Many cryptographic protocols designed by experts have turned out to be flawed, and application programmers are not experts in cryptographic algorithms, security protocols, and formal methods. Even when provided with formally verified, bug-free cryptography and protocols, they still build insecure systems <ref> [2, 3] </ref>. Taking automatic memory management as a guide, we seek to eliminate security bugs by hiding the use of cryptography, protocols, and message exchange from the programmer. Instead, the basic primitive we provide is authenticated data distribution, and we implement it by the automatic management of queries and certificates.
Reference: [4] <author> Matt Blaze, Joan Feigenbaum, and Jack Lacy. </author> <title> Decentralized trust management. </title> <booktitle> In Proceedings of the 17th Symposium on Security and Privacy, </booktitle> <pages> pages 164-173. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1996. </year>
Reference-contexts: Essentially, we implement a QCM program by a protocol of message exchange and signature verification, and we have proven the correctness of a large class of protocols, namely, the protocols corresponding to all QCM programs. There have been many other recent proposals for managing certificates, including PolicyMaker <ref> [4] </ref>, SDSI [7], and SPKI [5]. These systems include only limited support for distributed database operations (to form groups, define access control lists, provide for queries about identity certificates, and so on). <p> Conceptually, the principal of a QCM program accepts queries from other principals, supplies the queries as input to the QCM program, and returns the result after signing it. Following standard practice <ref> [4, 7] </ref>, a QCM principal is actually a public key. A principal signs documents using its associated secret key, and the signature can be verified using only the signed document and the principal itself.
Reference: [5] <author> Carl M. Ellison, Bill Frantz, Ron Rivest, and Brian M. Thomas. </author> <title> SPKI certificate documentation. </title> <address> http://www.clark.net/pub/cme/html/spki.html. </address>
Reference-contexts: There have been many other recent proposals for managing certificates, including PolicyMaker [4], SDSI [7], and SPKI <ref> [5] </ref>. These systems include only limited support for distributed database operations (to form groups, define access control lists, provide for queries about identity certificates, and so on).
Reference: [6] <author> Carl A. Gunter, Trevor Jim, and Bow-Yaw Wang. </author> <title> Authenticated data distribution using query certificate managers. </title> <note> Submitted for publication, </note> <year> 1997. </year>
Reference-contexts: The remainder of the paper presents an informal overview of QCM, omitting most technical details. A complete definition can be found in a separate paper <ref> [6] </ref>. In x2 we give some examples of QCM programming. In x3 we discuss our semantics and correctness guarantees, and we conclude in x4. 2 Query Certificate Managers A QCM program defines a database and resides at a node in a computer network. <p> A full semantics can be found in a separate paper <ref> [6] </ref>. The basis of QCM is the named relational algebra, which can be found in any standard database textbook (e.g., [1]).
Reference: [7] <author> Butler Lampson and Ron Rivest. </author> <title> SDSI|a simple distributed security infrastructure. </title> <address> http://theory.lcs.mit.edu/~cis/sdsi.html. </address>
Reference-contexts: Essentially, we implement a QCM program by a protocol of message exchange and signature verification, and we have proven the correctness of a large class of protocols, namely, the protocols corresponding to all QCM programs. There have been many other recent proposals for managing certificates, including PolicyMaker [4], SDSI <ref> [7] </ref>, and SPKI [5]. These systems include only limited support for distributed database operations (to form groups, define access control lists, provide for queries about identity certificates, and so on). <p> Conceptually, the principal of a QCM program accepts queries from other principals, supplies the queries as input to the QCM program, and returns the result after signing it. Following standard practice <ref> [4, 7] </ref>, a QCM principal is actually a public key. A principal signs documents using its associated secret key, and the signature can be verified using only the signed document and the principal itself.
Reference: [8] <author> Paul Resnick and James Miller. PICS: </author> <title> Internet access controls without censorship. </title> <journal> Communications of the ACM, </journal> <volume> 39(10) </volume> <pages> 87-93, </pages> <month> October </month> <year> 1996. </year>
Reference-contexts: If the rating services do not give s a good rating for its pages, it may not be willing to carry their certificates. For this reason, other filtering proposals, such as PICS <ref> [8] </ref>, also specify that both ways of obtaining ratings should be possible. The advantage of our system is that it covers all possibilities, without forcing the programmer to write code for each case.
Reference: [9] <institution> VeriSign, Inc. home page: </institution> <note> www.verisign.com. 9 </note>
Reference-contexts: Although complete databases can be programmed entirely in QCM, we think that the authenticated integration of existing databases into the network will be one of the most important services provided by QCM. Take, for example, the problem of public key distribution. VeriSign <ref> [9] </ref> is a company that issues digital IDs, certificates that associate a public key and an e-mail address with a name. There are several classes of IDs, and the class of an ID reflects how much trust should be put in the binding of key to name.
References-found: 9

