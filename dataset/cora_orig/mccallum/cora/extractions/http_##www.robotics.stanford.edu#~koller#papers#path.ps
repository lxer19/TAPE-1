URL: http://www.robotics.stanford.edu/~koller/papers/path.ps
Refering-URL: http://www.robotics.stanford.edu/~koller/papers/path.html
Root-URL: http://www.robotics.stanford.edu
Title: FINDING THE HIDDEN PATH: TIME BOUNDS FOR ALL-PAIRS SHORTEST PATHS  
Author: DAVID R. KARGER DAPHNE KOLLER AND STEVEN J. PHILLIPS 
Abstract: We investigate the all-pairs shortest paths problem in weighted graphs. We present an algorithm|the Hidden Paths Algorithm|that finds these paths in time O(m fl n+n 2 log n), where m fl is the number of edges participating in shortest paths. Our algorithm is a practical substitute for Dijkstra's algorithm. We argue that m fl is likely to be small in practice, since m fl = O(n log n) with high probability for many probability distributions on edge weights. We also prove an (mn) lower bound on the running time of any path-comparison based algorithm for the all-pairs shortest paths problem. Path-comparison based algorithms form a natural class containing the Hidden Paths Algorithm, as well as the algorithms of Dijkstra and Floyd. Lastly, we consider generalized forms of the shortest paths problem, and show that many of the standard shortest paths algorithms are effective in this more general setting. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> N. Alon, Z. Galil, and O. Margalit, </author> <title> "On the exponent of the all pairs shortest path problem", </title> <booktitle> in Proceedings of the 32nd Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1991, </year> <pages> pp. 569-575. </pages>
Reference-contexts: in practice, because it is known [14, 18, 27] that m fl = O (n log n) with high probability when the input graph is the complete graph with edge weights chosen independently from any of a large class of probability distributions, including the uniform distribution on the real interval <ref> [0; 1] </ref> or the uniform distribution on the range f1; : : : ; n 2 g. The Hidden Paths Algorithm is also useful when the graph has (possibly negative) integer edge weights. <p> Fredman's algorithm was simplified and the running time was decreased slightly by Takaoka [33]. For the important special cases where the graph is unweighted or the edge-weights are bounded integers, the algorithms of Alon, Galil, and Margalit <ref> [1] </ref> and Seidel [30] use fast matrix multiplication to find all-pairs shortest distances very quickly. <p> Consider a distribution F on non-negative edge weights, which does not depend on n, such that F (0) = 0, and F 0 (0) exists and is positive. In particular, the uniform distribution on <ref> [0; 1] </ref> and the exponential distribution with mean both satisfy these conditions. The work of Frieze and Grimmet [14] implies that m fl (G) = O (n log n) with high probability. In particular, they prove the following result: Theorem 2.6 (Frieze and Grimmet). <p> To define the weight function, we work in base n+ 1 notation, generalized to allow negative digits. Define [a r ; : : : ; a 0 ] b = i=0 The edge weights are k (u i ; v j )k = <ref> [1; 0; i; 0; j; 0; 0] </ref> n+1 and thus k (u i ; v j ; w k )k = [1; 1; i; k; j; j; 0] n+1 : Note that we allow negative digits to appear in the numbers. <p> Define [a r ; : : : ; a 0 ] b = i=0 The edge weights are k (u i ; v j )k = [1; 0; i; 0; j; 0; 0] n+1 and thus k (u i ; v j ; w k )k = <ref> [1; 1; i; k; j; j; 0] </ref> n+1 : Note that we allow negative digits to appear in the numbers. The standard positive digit representation of these numbers would require that a carry be taken from the next number to the left. <p> Proof. Immediate from the base n + 1 notation. For example, item 3 follows from the fact that k (v j ; w k )k &lt; <ref> [1; 0; 0; 0; 0; 0; 0] </ref> n+1 k (u i ; v j )k. <p> It follows that the unique optimal path from u i to w k goes through v 0 , and has weight <ref> [1; 1; i; k; 0; 0; 0] </ref> n+1 : Define L to be the set of optimal paths. Consider providing (G; k k) as input to A, and suppose that A runs correctly. It must therefore output the set of optimal paths L. <p> For all j j fl ; we decrease the weight of the edge (u i fl ; v j ): k (u i fl ; v j )k 0 = <ref> [1; 0; i fl ; 0; 0; j; j] </ref> n+1 : We also decrease the weight of the edge (v j fl ; w k fl ): k (v j fl ; w k fl )k 0 = [0; 1; 0; k fl ; 0; j fl ; n] n+1 : <p> j ): k (u i fl ; v j )k 0 = [1; 0; i fl ; 0; 0; j; j] n+1 : We also decrease the weight of the edge (v j fl ; w k fl ): k (v j fl ; w k fl )k 0 = <ref> [0; 1; 0; k fl ; 0; j fl ; n] </ref> n+1 : Thus k (u i fl ; v j fl ; w k fl )k 0 = [1; 1; i fl ; k fl ; 0; 0; j fl n] n+1 &lt; k (u i fl ; v 0
Reference: [2] <author> N. Alon, Z. Galil, O. Margalit, and M. Naor, </author> <title> "Witnesses for boolean matrix multiplication and for shortest paths", </title> <type> Tech. Report RJ 8744, </type> <institution> IBM, </institution> <year> 1992. </year>
Reference-contexts: For example, Seidel's algorithm finds all-pairs shortest distances in an unweighted undirected graph in time n ! log n, where ! is the exponent of matrix multiplication (the current bound is ! &lt; 2:376, due to Coppersmith and Winograd [5]). Alon, Galil, Margalit and Naor <ref> [2] </ref> show how to extend these algorithms to find the paths, rather than just the distances, with a polylogarithmic slowdown.
Reference: [3] <author> P. A. Bloniarz, </author> <title> "A shortest-path algorithm with expected time O(n 2 log n log fl n)", </title> <type> Tech. Report 80-3, </type> <institution> Department of Computer Science, State University of New York at Albany, </institution> <month> Aug. </month> <year> 1980. </year>
Reference-contexts: A variant of Dijkstra's algorithm developed by Spira [31] has an expected running time of O (n 2 log 2 n) if the edge weights are independently and identically distributed random variables. Bloniarz <ref> [3] </ref> provided an algorithm with an expected running time of O (n 2 log n log fl n). Another algorithm, developed by Frieze and Grimmet [14], achieves an expected running time of O (n 2 log n), but is suitable only for random graphs. <p> Corollary 2.7. If the edge weights of G are chosen independently according to F , then with high probability the running time of the Hidden Paths Algorithm is O (n 2 log n). This time bound is an improvement over earlier algorithms by Spira [31] and Bloniarz <ref> [3] </ref>, and matches the performance of the algorithm of Frieze and Grimmet. However, the Hidden Paths Algorithm can be effectively used in any situation where m fl is significantly less than m, whereas the algorithm of Frieze and Grimmet is designed specifically for random graphs. 3. A Lower Bound.
Reference: [4] <author> J. Cheriyan and R. Thurimella, </author> <title> "Algorithms for parallel k-vertex connectivity and sparse certificates", </title> <booktitle> in Proceedings of the 23rd ACM Symposium on Theory of Computing, </booktitle> <year> 1991, </year> <pages> pp. 391-401. </pages>
Reference-contexts: One can think of the optimal edges as forming a certificate of the shortest path structure of the graph, that must be revealed. The philosophy of the Hidden Paths Algorithm is thus similar to recent algorithms for connectivity <ref> [4, 29] </ref>, that work by first finding a sparse subgraph (or certificate) with the same connectivity. We have shown a lower bound of (mn) on the running time of path-comparison based algorithms for all-pairs shortest paths.
Reference: [5] <author> D. Coppersmith and S. Winograd, </author> <title> "Matrix multiplication via arithmetic progressions", </title> <journal> Journal of Symbolic Computation, </journal> <volume> 9 (1990), </volume> <pages> pp. 251-280. </pages>
Reference-contexts: For example, Seidel's algorithm finds all-pairs shortest distances in an unweighted undirected graph in time n ! log n, where ! is the exponent of matrix multiplication (the current bound is ! &lt; 2:376, due to Coppersmith and Winograd <ref> [5] </ref>). Alon, Galil, Margalit and Naor [2] show how to extend these algorithms to find the paths, rather than just the distances, with a polylogarithmic slowdown.
Reference: [6] <author> R. B. Dial, </author> <title> "Algorithm 360: Shortest path forest with topological ordering", </title> <journal> Communications of the ACM, </journal> <volume> 12 (1969), </volume> <pages> pp. 632-633. </pages>
Reference-contexts: Overall, there can be at most a + 1 priority change operations for the pair u; v. In fact, an even better bound can be achieved if we modify the algorithm slightly. The modified algorithm is similar to Dial's implementation <ref> [6] </ref> of Dijkstra's algorithm. Note that if the maximum edge weight is a, the weight of any optimal path is at most a (n 1). Rather than using a heap to store candidate paths, we can use an array of size a (n 1) + 1.
Reference: [7] <author> E. W. Dijkstra, </author> <title> "A note on two problems in connection with graphs", </title> <journal> Numerische Mathe-matik, </journal> <volume> 1 (1959), </volume> <pages> pp. 260-271. </pages>
Reference-contexts: The algorithm operates by running Dijkstra's single-source shortest paths algorithm <ref> [7] </ref> in parallel from all nodes in the graph, using information gained at one node to reduce the work done at other nodes. Our algorithm is practical and simple to implement. <p> Previous Work. The most widely known algorithms for the all-pairs shortest paths problem are those of Floyd [9] and Dijkstra <ref> [7] </ref>. Floyd's algorithm works by dynamic programming and runs in time fi (n 3 ).
Reference: [8] <author> T. Feder and R. Motwani, </author> <title> "Clique partitions, graph compression and speeding-up algorithms", </title> <booktitle> in Proceedings of the 23rd ACM Symposium on Theory of Computing, </booktitle> <year> 1991, </year> <pages> pp. 123-133. </pages>
Reference-contexts: All of these algorithms are path-comparison based, so by the lower bound of Section 3 they have a worst case running time of (mn). Fast algorithms exist for special cases of the all-pairs shortest paths problem, for instance when the graph is unweighted <ref> [8] </ref> or planar [10]. Other researchers have looked at shortest paths from the perspective of matrix multiplication. Fredman [11] shows that O (n 5=2 ) comparisons between sums of edge weights suffice to solve the all-pairs shortest paths problem.
Reference: [9] <author> R. W. Floyd, </author> <title> "Algorithm 97: Shortest path", </title> <journal> Communications of the ACM, </journal> <note> 5 (1962), p. 345. </note>
Reference-contexts: Previous Work. The most widely known algorithms for the all-pairs shortest paths problem are those of Floyd <ref> [9] </ref> and Dijkstra [7]. Floyd's algorithm works by dynamic programming and runs in time fi (n 3 ).
Reference: [10] <author> G. N. Frederickson, </author> <title> "Planar graph decomposition and all pairs shortest paths", </title> <journal> Journal of the ACM, </journal> <volume> 38 (1991), </volume> <pages> pp. 162-204. </pages>
Reference-contexts: All of these algorithms are path-comparison based, so by the lower bound of Section 3 they have a worst case running time of (mn). Fast algorithms exist for special cases of the all-pairs shortest paths problem, for instance when the graph is unweighted [8] or planar <ref> [10] </ref>. Other researchers have looked at shortest paths from the perspective of matrix multiplication. Fredman [11] shows that O (n 5=2 ) comparisons between sums of edge weights suffice to solve the all-pairs shortest paths problem.
Reference: [11] <author> M. L. Fredman, </author> <title> "New bounds on the complexity of the shortest path problem", </title> <journal> SIAM Journal on Computing, </journal> <volume> 5 (1976), </volume> <pages> pp. 83-89. </pages>
Reference-contexts: Fast algorithms exist for special cases of the all-pairs shortest paths problem, for instance when the graph is unweighted [8] or planar [10]. Other researchers have looked at shortest paths from the perspective of matrix multiplication. Fredman <ref> [11] </ref> shows that O (n 5=2 ) comparisons between sums of edge weights suffice to solve the all-pairs shortest paths problem. He uses this fact to do preprocessing, producing an algorithm that runs in time O (n 3 (log log n = log n) 1=3 ). <p> On the other hand, Fredman's o (n 3 ) algorithm <ref> [11] </ref> is not path-comparison based because it adds weights of edges that do not form a single path. This algorithm conform to the more general algebraic decision tree model.
Reference: [12] <author> M. L. Fredman and R. E. Tarjan, </author> <title> "Fibonacci heaps and their uses in improved network optimization algorithms", </title> <journal> Journal of the ACM, </journal> <volume> 36 (1986), </volume> <pages> pp. 596-615. </pages>
Reference-contexts: Let an edge be called optimal if it is a shortest path, and let m fl be the number of optimal edges in the graph. The Hidden Paths Algorithm runs in time O (m fl n + n 2 log n) if we use a Fibonacci heap <ref> [12] </ref> to implement a priority queue; the running time increases to O (m fl n log n) if a standard heap is used instead. <p> On graphs with non-negative edge weights, Dijkstra's algorithm for the single-source shortest path problem can be run from each vertex (as noted by Johnson [21]), resulting in a running time of fi (mn + n 2 log n) if Fibonacci heaps <ref> [12] </ref> are used to implement priority queues. A variant of Dijkstra's algorithm developed by Spira [31] has an expected running time of O (n 2 log 2 n) if the edge weights are independently and identically distributed random variables. <p> Using a standard heap implementation, the time for a priority change 6 operation is O (log n) and we get a total complexity of fi (m fl n log n). Using Fibonacci heaps (described in <ref> [12] </ref>), priority change operations take constant amortized time, and we therefore get a complexity of fi (n 2 log n + m fl n). The Hidden Paths Algorithm is also very simple and easy to implement, and thus provides a practical substitute for Dijkstra's algorithm. 2.4. Extensions and Refinements.
Reference: [13] <author> A. Frieze, </author> <title> "Minimum paths in directed graphs", </title> <journal> Operations Research Quarterly, </journal> <year> (1977). </year>
Reference-contexts: Generalized weight functions have been studied extensively in various contexts, and standard algorithms have been extended to work in generalized settings (see, for example, Frieze <ref> [13] </ref>). In particular, the all-pairs shortest path problem has been studied in arbitrary semirings, generalizing the semiring of reals with minimum and addition (see Zimmerman [35] for a survey and further references). <p> Solving single-source shortest paths under this weight function is referred to as the bottleneck path problem in [34]. In the literature on generalizing shortest paths to semirings (see [35]), the semiring axioms imply both inductiveness and monotonicity of the weight function. Frieze <ref> [13] </ref> restricts to a narrower class, which essentially consists of monotonic, acyclic, inductive weight functions over the reals. Lengauer and Theune [26] study extensions of the shortest paths problem to situations where the path weights are only partially ordered; this allows them to deal with certain non-monotonic weight functions. <p> Change the weight of this path to be 3. It is simple to verify that the modified weight function remains monotonic and non-negative. This lower bound can also be extended to the case of inductive weight functions studied in <ref> [13] </ref>. To do this, assign to each edge e in the graph a unique weight kek. We are then free to assign arbitrary weights to paths of length 2, because each such path contains a different pair of subpath weights.
Reference: [14] <author> A. M. Frieze and G. R. Grimmet, </author> <title> "The shortest-path problem for graphs with random arc-lengths", </title> <journal> Discrete Applied Mathematics, </journal> <volume> 10 (1985), </volume> <pages> pp. 57-77. </pages>
Reference-contexts: Our algorithm is practical and simple to implement. Is is also likely to be fast in practice, because it is known <ref> [14, 18, 27] </ref> that m fl = O (n log n) with high probability when the input graph is the complete graph with edge weights chosen independently from any of a large class of probability distributions, including the uniform distribution on the real interval [0; 1] or the uniform distribution on <p> Bloniarz [3] provided an algorithm with an expected running time of O (n 2 log n log fl n). Another algorithm, developed by Frieze and Grimmet <ref> [14] </ref>, achieves an expected running time of O (n 2 log n), but is suitable only for random graphs. All of these algorithms are path-comparison based, so by the lower bound of Section 3 they have a worst case running time of (mn). <p> In particular, the uniform distribution on [0; 1] and the exponential distribution with mean both satisfy these conditions. The work of Frieze and Grimmet <ref> [14] </ref> implies that m fl (G) = O (n log n) with high probability. In particular, they prove the following result: Theorem 2.6 (Frieze and Grimmet). Let G be a complete directed graph, whose edge weights are chosen independently according to F .
Reference: [15] <author> H. N. Gabow and R. E. Tarjan, </author> <title> "Faster scaling algorithms for network problems", </title> <journal> SIAM Journal on Computing, </journal> <year> (1989), </year> <pages> pp. 1013-1036. </pages>
Reference-contexts: The Hidden Paths Algorithm is also useful when the graph has (possibly negative) integer edge weights. Such a graph can be reweighted using an o (mn) runtime scaling algorithm for single-source shortest paths (for example, Gabow and Tarjan <ref> [15] </ref>, Goldberg [16]) before applying the Hidden Paths Algorithm. <p> The Hidden Paths Algorithm requires that the graph have non-negative edge weights. However, in the case of an integer edge weight function, several scaling algorithms (such as Gabow, Tarjan <ref> [15] </ref> and Goldberg [16]) transform the weight function into a non-negative weight function, that induces the same shortest paths structure on the graph.
Reference: [16] <author> A. V. Goldberg, </author> <title> "Scaling algorithms for the shortest paths problem", </title> <type> Tech. Report STAN-CS-92-1429, </type> <institution> Stanford University, </institution> <year> 1992. </year>
Reference-contexts: The Hidden Paths Algorithm is also useful when the graph has (possibly negative) integer edge weights. Such a graph can be reweighted using an o (mn) runtime scaling algorithm for single-source shortest paths (for example, Gabow and Tarjan [15], Goldberg <ref> [16] </ref>) before applying the Hidden Paths Algorithm. <p> The Hidden Paths Algorithm requires that the graph have non-negative edge weights. However, in the case of an integer edge weight function, several scaling algorithms (such as Gabow, Tarjan [15] and Goldberg <ref> [16] </ref>) transform the weight function into a non-negative weight function, that induces the same shortest paths structure on the graph. We can solve the shortest paths problem on such graphs by first using one of these algorithms to make the edge weights positive, and then applying the Hidden Paths Algorithm.
Reference: [17] <author> R. E. Gomory and T. C. Hu, </author> <title> "Multi-terminal network flows", </title> <journal> SIAM Journal on Applied Mathematics, </journal> <volume> 9 (1961), </volume> <pages> pp. 551-570. </pages>
Reference-contexts: The different single-source threads are integrated in a way that allows the use of intermediate results from one thread to reduce the work done by another. There is a similarity here to the all-pairs min-cut algorithm of Gomory and Hu <ref> [17] </ref>, which uses the information gained during one min-cut computation to speed up the other computations. In a sense, the Hidden Paths Algorithm discovers the hidden "shortest path structure" of the graph by pruning away the unnecessary edges.
Reference: [18] <author> R. Hassin and E. Zemel, </author> <title> "On shortest paths in graphs with random weights", </title> <journal> Mathematics of Operations Research, </journal> <volume> 10 (1985), </volume> <pages> pp. 557-564. </pages>
Reference-contexts: Our algorithm is practical and simple to implement. Is is also likely to be fast in practice, because it is known <ref> [14, 18, 27] </ref> that m fl = O (n log n) with high probability when the input graph is the complete graph with edge weights chosen independently from any of a large class of probability distributions, including the uniform distribution on the real interval [0; 1] or the uniform distribution on <p> Similar results are derived in a different context by Luby and Ragde [27]. Hassin and Zemel <ref> [18] </ref> prove a similar theorem (with a different constant) for both directed and undirected graphs, when the edge weights are uniformly distributed. The constant factors given by these analyses are small.
Reference: [19] <author> J. E. Hopcroft and J. D. Ullman, </author> <title> Introduction to Automata Theory, </title> <booktitle> Languages and Computation, Series in Computer Science, </booktitle> <publisher> Addison-Wesley, </publisher> <year> 1979. </year>
Reference-contexts: This generalization provides a common framework for such problems as the construction of regular expressions for the languages accepted by finite automata <ref> [19] </ref>. Lengauer and The-une [26] extend standard algorithms to a yet more general framework. Knuth [24], generalizes the notion of paths to allow for compound edges, extending Dijkstra's algorithm to apply to derivations in context-free grammars. 2. The Hidden Paths Algorithm.
Reference: [20] <author> H. Jakobsson, </author> <title> "Mixed-approach algorithms for transitive closure", </title> <booktitle> in Proceedings of the 10th ACM Symposium on Principles of Database Systems, </booktitle> <year> 1991, </year> <pages> pp. 199-205. </pages>
Reference-contexts: An algorithm similar to the Hidden Paths Algorithm, with the same time bound, has been developed independently by McGeoch [28]. A variant of our algorithm has been developed independently by Jakobsson <ref> [20] </ref> as a transitive closure algorithm. Both these algorithms require more complex data structures than those used by the Hidden Paths Algorithm. Lower bounds on the computational complexity of the all-pairs shortest paths problem have been proved in some other models. <p> This property is useful for "anytime" applications, 8 which might require the algorithm to be stopped in the middle of execution with good intermediate results. Finally, we note that the Hidden Paths Algorithm considers some unnecessary candidate paths. One possible improvement, which was also developed independently by Jakobsson <ref> [20] </ref>, creates only candidate paths of which every subpath is optimal. More specifically, a path p = (u; v ; w; t) is made a candidate path iff (u; v ; w) and (v ; w; t) are already known to be optimal.
Reference: [21] <author> D. B. Johnson, </author> <title> "Efficient algorithms for shortest paths in sparse networks", </title> <journal> Journal of the ACM, </journal> <volume> 24 (1977), </volume> <pages> pp. 1-13. </pages>
Reference-contexts: Floyd's algorithm works by dynamic programming and runs in time fi (n 3 ). On graphs with non-negative edge weights, Dijkstra's algorithm for the single-source shortest path problem can be run from each vertex (as noted by Johnson <ref> [21] </ref>), resulting in a running time of fi (mn + n 2 log n) if Fibonacci heaps [12] are used to implement priority queues.
Reference: [22] <author> D. R. Karger, D. Koller, and S. J. Phillips, </author> <title> "Finding the hidden path: Time bounds for all-pairs shortest paths, </title> <booktitle> in Proceedings of the 32nd Annual Symposium on Foundations of Computer Science, </booktitle> <year> 1991, </year> <pages> pp. 560-568. </pages>
Reference: [23] <author> L. R. Kerr, </author> <title> The Effect of Algebraic Structure on the Computational Complexity of Matrix Multiplications, </title> <type> PhD thesis, </type> <institution> Cornell University, </institution> <year> 1970. </year>
Reference-contexts: Both these algorithms require more complex data structures than those used by the Hidden Paths Algorithm. Lower bounds on the computational complexity of the all-pairs shortest paths problem have been proved in some other models. If the permissible operations are addition and minimum in a straight line computation, Kerr <ref> [23] </ref> shows that any algorithm requires (n 3 ) running time. Regarding algebraic decision tree complexity, Spira and Pan [32] show that (n 2 ) comparisons between sums of edge weights are necessary to solve the single-source shortest paths problem.
Reference: [24] <author> D. E. Knuth, </author> <title> "A generalization of Dijkstra's algorithm", </title> <journal> Information Processing Letters, </journal> <volume> 6 (1977), </volume> <pages> pp. 1-5. </pages>
Reference-contexts: This generalization provides a common framework for such problems as the construction of regular expressions for the languages accepted by finite automata [19]. Lengauer and The-une [26] extend standard algorithms to a yet more general framework. Knuth <ref> [24] </ref>, generalizes the notion of paths to allow for compound edges, extending Dijkstra's algorithm to apply to derivations in context-free grammars. 2. The Hidden Paths Algorithm.
Reference: [25] <author> J. Komlos, </author> <title> "Linear verification for spanning trees", </title> <journal> Combinatorica, </journal> <volume> 5 (1985), </volume> <pages> pp. 57-65. 19 </pages>
Reference-contexts: It is of particular interest that the construction and verification algorithms have the same worst case complexity. Compare this to the situation for the minimum spanning tree problem, where there is a linear-time algorithm to verify a minimum spanning tree <ref> [25] </ref>, although no algorithm is known that finds one in linear-time.
Reference: [26] <author> T. Lengauer and D. Theune, </author> <title> "Efficient algorithms for path problems with general cost cri-teria", </title> <booktitle> in Proceedings of the 18th International Colloquium on Automata, Languages and Programming, </booktitle> <year> 1991, </year> <pages> pp. 314-326. </pages>
Reference-contexts: This generalization provides a common framework for such problems as the construction of regular expressions for the languages accepted by finite automata [19]. Lengauer and The-une <ref> [26] </ref> extend standard algorithms to a yet more general framework. Knuth [24], generalizes the notion of paths to allow for compound edges, extending Dijkstra's algorithm to apply to derivations in context-free grammars. 2. The Hidden Paths Algorithm. <p> In the literature on generalizing shortest paths to semirings (see [35]), the semiring axioms imply both inductiveness and monotonicity of the weight function. Frieze [13] restricts to a narrower class, which essentially consists of monotonic, acyclic, inductive weight functions over the reals. Lengauer and Theune <ref> [26] </ref> study extensions of the shortest paths problem to situations where the path weights are only partially ordered; this allows them to deal with certain non-monotonic weight functions. Fact 4.1. Any non-negative weight function is also acyclic. Proof. Let v be any vertex, and (v ; v) any cycle.
Reference: [27] <author> M. Luby and P. Ragde, </author> <title> "A bidirectional shortest-path algorithm with good average case behavior", </title> <journal> Algorithmica, </journal> <volume> 4 (1989), </volume> <pages> pp. 551-567. </pages>
Reference-contexts: Our algorithm is practical and simple to implement. Is is also likely to be fast in practice, because it is known <ref> [14, 18, 27] </ref> that m fl = O (n log n) with high probability when the input graph is the complete graph with edge weights chosen independently from any of a large class of probability distributions, including the uniform distribution on the real interval [0; 1] or the uniform distribution on <p> Hence, under the conditions of the theorem, m fl (G) = O (n log n) with probability 1 O (n 1 ) (and therefore E [m fl (G)] = O (n log n) ). Similar results are derived in a different context by Luby and Ragde <ref> [27] </ref>. Hassin and Zemel [18] prove a similar theorem (with a different constant) for both directed and undirected graphs, when the edge weights are uniformly distributed. The constant factors given by these analyses are small.
Reference: [28] <author> C. C. McGeoch, </author> <title> "A new all-pairs shortest-path algorithm", </title> <type> Tech. Report 91-30, </type> <institution> DIMACS, </institution> <year> 1991. </year> <note> to appear in Algorithmica. </note>
Reference-contexts: It is surprising that one must allow such comparisons in order to improve on the (n 3 ) bound. An algorithm similar to the Hidden Paths Algorithm, with the same time bound, has been developed independently by McGeoch <ref> [28] </ref>. A variant of our algorithm has been developed independently by Jakobsson [20] as a transitive closure algorithm. Both these algorithms require more complex data structures than those used by the Hidden Paths Algorithm. <p> Hassin and Zemel [18] prove a similar theorem (with a different constant) for both directed and undirected graphs, when the edge weights are uniformly distributed. The constant factors given by these analyses are small. In fact, empirical studies by McGeoch <ref> [28] </ref> indicate that when the edge weights are uniformly distributed, m fl (G) grows approximately as 0:5n ln n + 0:3n.
Reference: [29] <author> H. Nagamochi and T. Ibaraki, </author> <title> "Linear time algorithms for finding a sparse k-connected spanning subgraph of a k-connected graph", </title> <journal> Algorithmica, </journal> <note> to appear, </note> <year> (1991). </year>
Reference-contexts: One can think of the optimal edges as forming a certificate of the shortest path structure of the graph, that must be revealed. The philosophy of the Hidden Paths Algorithm is thus similar to recent algorithms for connectivity <ref> [4, 29] </ref>, that work by first finding a sparse subgraph (or certificate) with the same connectivity. We have shown a lower bound of (mn) on the running time of path-comparison based algorithms for all-pairs shortest paths.
Reference: [30] <author> R. Seidel, </author> <title> "On the all-pairs-shortest-path problem", </title> <booktitle> in Proceedings of the 24th ACM Symposium on Theory of Computing, </booktitle> <year> 1992, </year> <pages> pp. 745-749. </pages>
Reference-contexts: Fredman's algorithm was simplified and the running time was decreased slightly by Takaoka [33]. For the important special cases where the graph is unweighted or the edge-weights are bounded integers, the algorithms of Alon, Galil, and Margalit [1] and Seidel <ref> [30] </ref> use fast matrix multiplication to find all-pairs shortest distances very quickly.
Reference: [31] <author> P. M. Spira, </author> <title> "A new algorithm for finding all shortest paths in a graph of positive arcs in average time O(n 2 log 2 n)", </title> <journal> SIAM Journal on Computing, </journal> <volume> 2 (1973), </volume> <pages> pp. 28-32. </pages>
Reference-contexts: A variant of Dijkstra's algorithm developed by Spira <ref> [31] </ref> has an expected running time of O (n 2 log 2 n) if the edge weights are independently and identically distributed random variables. Bloniarz [3] provided an algorithm with an expected running time of O (n 2 log n log fl n). <p> Corollary 2.7. If the edge weights of G are chosen independently according to F , then with high probability the running time of the Hidden Paths Algorithm is O (n 2 log n). This time bound is an improvement over earlier algorithms by Spira <ref> [31] </ref> and Bloniarz [3], and matches the performance of the algorithm of Frieze and Grimmet. However, the Hidden Paths Algorithm can be effectively used in any situation where m fl is significantly less than m, whereas the algorithm of Frieze and Grimmet is designed specifically for random graphs. 3.
Reference: [32] <author> P. M. Spira and A. Pan, </author> <title> "On finding and updating shortest paths and spanning trees", </title> <booktitle> in Conference Record, IEEE 14th Annual Symposium on Switching and Automata Theory, </booktitle> <year> 1973. </year>
Reference-contexts: If the permissible operations are addition and minimum in a straight line computation, Kerr [23] shows that any algorithm requires (n 3 ) running time. Regarding algebraic decision tree complexity, Spira and Pan <ref> [32] </ref> show that (n 2 ) comparisons between sums of edge weights are necessary to solve the single-source shortest paths problem. Generalized weight functions have been studied extensively in various contexts, and standard algorithms have been extended to work in generalized settings (see, for example, Frieze [13]).
Reference: [33] <author> T. Takaoka, </author> <title> "A new upper bound on the complexity of the all pairs shortest path problem", </title> <booktitle> in Proceedings of the 17th International Workshop on Graph-Theoretic Concepts in Computer Science, </booktitle> <year> 1991, </year> <pages> pp. 209-213. </pages>
Reference-contexts: He uses this fact to do preprocessing, producing an algorithm that runs in time O (n 3 (log log n = log n) 1=3 ). Fredman's algorithm was simplified and the running time was decreased slightly by Takaoka <ref> [33] </ref>. For the important special cases where the graph is unweighted or the edge-weights are bounded integers, the algorithms of Alon, Galil, and Margalit [1] and Seidel [30] use fast matrix multiplication to find all-pairs shortest distances very quickly.
Reference: [34] <author> R. E. Tarjan, </author> <title> Data Structures and Network Algorithms, </title> <booktitle> vol. 44 of CBMS-NSF Regional Conference Series in Applied Mathematics, Society for Industrial and Applied Mathematics, </booktitle> <year> 1983. </year>
Reference-contexts: An example of a monotonic, non-negative, inductive, nonstandard weight function is one that assigns to every path a weight equal to the weight of the maximal edge on the path. Solving single-source shortest paths under this weight function is referred to as the bottleneck path problem in <ref> [34] </ref>. In the literature on generalizing shortest paths to semirings (see [35]), the semiring axioms imply both inductiveness and monotonicity of the weight function. Frieze [13] restricts to a narrower class, which essentially consists of monotonic, acyclic, inductive weight functions over the reals.
Reference: [35] <author> U. Zimmerman, </author> <title> Linear and Combinatorial Optimization in Ordered Algebraic Structures, </title> <booktitle> vol. 10 of Annals of Discrete Mathematics, </booktitle> <publisher> North-Holland Publishing Company, </publisher> <year> 1981. </year> <month> 20 </month>
Reference-contexts: In particular, the all-pairs shortest path problem has been studied in arbitrary semirings, generalizing the semiring of reals with minimum and addition (see Zimmerman <ref> [35] </ref> for a survey and further references). This generalization provides a common framework for such problems as the construction of regular expressions for the languages accepted by finite automata [19]. Lengauer and The-une [26] extend standard algorithms to a yet more general framework. <p> Solving single-source shortest paths under this weight function is referred to as the bottleneck path problem in [34]. In the literature on generalizing shortest paths to semirings (see <ref> [35] </ref>), the semiring axioms imply both inductiveness and monotonicity of the weight function. Frieze [13] restricts to a narrower class, which essentially consists of monotonic, acyclic, inductive weight functions over the reals.
References-found: 35

