URL: http://www.sci.tamucc.edu/constraint95/scholl.ps
Refering-URL: http://www.sci.tamucc.edu/constraint95/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Phone: 1420  
Title: Assertion-Based Program Verification Using A Constraint Logic Programming Tool 1 2  
Author: Martina Schollmeyer Bruce McMillin 
Keyword: program verification, constraint logic programming, proof checking, assertion-based reasoning, formal methods.  
Address: 6300 Ocean Drive, Corpus Christi, TX 78412  Room  Building Stony Brook, NY 11794-4400 USA  
Affiliation: Texas A&M University-Corpus Christi Department of Computer Science  Computer Science Department State University of New York at Stony Brook  Computer Science  
Abstract: In this paper we show how a constraint logic programming tool, CLP(R), can be used to help in determining whether the given pre- and postconditions of a program proof match the actual statement that is supposed to be performed. In addition to that, CLP(R) was used as part of a weakest precondition generator which was used to fill in program proofs that were incom plete.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G.R. Andrews. </author> <title> Concurrent Programming - Principles and Practice. </title> <publisher> Benjamin Cummings Publishing Company, Inc., </publisher> <year> 1991. </year>
Reference-contexts: Weakest precondition generation rules are discussed in much detail in [3] and <ref> [1] </ref>, and we simply give a brief summary here for our language.
Reference: [2] <author> R.S. Boyer and J.S. Moore. </author> <title> A Computational Logic. </title> <publisher> Academic Press, </publisher> <year> 1979. </year>
Reference-contexts: Scientific Research under contract numbers F49620-92-J-0546 and F49620-93-I-0409 and, in part, by a grant from the University of Missouri Research Board. 2 This work was performed while the authors were at the University of Missouri-Rolla in the Department of Computer Science. been many efforts in trying to mechanize program verification <ref> [2] </ref>, [4], [5], [6], [7], [8], [14], etc. Unfortunately, it has been shown that it is impossible, in principle, to design a decision procedure which decides automatically the truth or falsehood of an arbitrary (mathematical) statement [13]. Sadly, this also applies to program verification.
Reference: [3] <author> E. Dijkstra. </author> <title> A Discipline of Programming. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1976. </year>
Reference-contexts: Weakest precondition generation rules are discussed in much detail in <ref> [3] </ref> and [1], and we simply give a brief summary here for our language.
Reference: [4] <author> D. Good, R. Cohen, C. Hoch, I. Hunter, and D. Hare. </author> <title> Report on the Language Gypsy. </title> <type> Technical Report ICSCA-CMP-10, </type> <institution> The University of Texas at Austin, </institution> <year> 1978. </year>
Reference-contexts: Research under contract numbers F49620-92-J-0546 and F49620-93-I-0409 and, in part, by a grant from the University of Missouri Research Board. 2 This work was performed while the authors were at the University of Missouri-Rolla in the Department of Computer Science. been many efforts in trying to mechanize program verification [2], <ref> [4] </ref>, [5], [6], [7], [8], [14], etc. Unfortunately, it has been shown that it is impossible, in principle, to design a decision procedure which decides automatically the truth or falsehood of an arbitrary (mathematical) statement [13]. Sadly, this also applies to program verification.
Reference: [5] <author> D.I. </author> <title> Good. Mechanical proofs about computer programs. In C.A.R. Hoare and J.C. </title> <editor> Shepherd-son, editors, </editor> <booktitle> Mathematical Logic and Programming Languages. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: under contract numbers F49620-92-J-0546 and F49620-93-I-0409 and, in part, by a grant from the University of Missouri Research Board. 2 This work was performed while the authors were at the University of Missouri-Rolla in the Department of Computer Science. been many efforts in trying to mechanize program verification [2], [4], <ref> [5] </ref>, [6], [7], [8], [14], etc. Unfortunately, it has been shown that it is impossible, in principle, to design a decision procedure which decides automatically the truth or falsehood of an arbitrary (mathematical) statement [13]. Sadly, this also applies to program verification.
Reference: [6] <author> M.J.C. Gordon. </author> <title> Programming Language Theory and its Implementation. </title> <publisher> Prentice-Hall, Inc., </publisher> <year> 1988. </year>
Reference-contexts: contract numbers F49620-92-J-0546 and F49620-93-I-0409 and, in part, by a grant from the University of Missouri Research Board. 2 This work was performed while the authors were at the University of Missouri-Rolla in the Department of Computer Science. been many efforts in trying to mechanize program verification [2], [4], [5], <ref> [6] </ref>, [7], [8], [14], etc. Unfortunately, it has been shown that it is impossible, in principle, to design a decision procedure which decides automatically the truth or falsehood of an arbitrary (mathematical) statement [13]. Sadly, this also applies to program verification.
Reference: [7] <editor> M.J.C. Gordon and T.F. Melham, editors. </editor> <title> Introduction to HOL: A theorem proving environment for higher order logic. </title> <publisher> Cambridge University Press, </publisher> <year> 1993. </year>
Reference-contexts: numbers F49620-92-J-0546 and F49620-93-I-0409 and, in part, by a grant from the University of Missouri Research Board. 2 This work was performed while the authors were at the University of Missouri-Rolla in the Department of Computer Science. been many efforts in trying to mechanize program verification [2], [4], [5], [6], <ref> [7] </ref>, [8], [14], etc. Unfortunately, it has been shown that it is impossible, in principle, to design a decision procedure which decides automatically the truth or falsehood of an arbitrary (mathematical) statement [13]. Sadly, this also applies to program verification.
Reference: [8] <author> J.V. Guttag and J.J. Horning. </author> <title> Larch: Languages and Tools for Formal Specification. Texts and Monographs in Computer Science. </title> <publisher> Springer Ver-lag, </publisher> <year> 1993. </year>
Reference-contexts: F49620-92-J-0546 and F49620-93-I-0409 and, in part, by a grant from the University of Missouri Research Board. 2 This work was performed while the authors were at the University of Missouri-Rolla in the Department of Computer Science. been many efforts in trying to mechanize program verification [2], [4], [5], [6], [7], <ref> [8] </ref>, [14], etc. Unfortunately, it has been shown that it is impossible, in principle, to design a decision procedure which decides automatically the truth or falsehood of an arbitrary (mathematical) statement [13]. Sadly, this also applies to program verification.
Reference: [9] <author> N. Heintze, J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(R) Programmer's Manual, </title> <type> Version 1.2. </type> <institution> IBM Thomas J. Watson Research Center, </institution> <year> 1992. </year>
Reference-contexts: It is implemented in C and available for UNIX systems <ref> [9] </ref>. Since the platform we use for the execution of our programs allows only for assertions in propositional calculus rather than predicate calculus, we also restrict the use of CLP (R) to the use of propositional expressions. <p> Because of that, it was decided to help with the generation of assertions for these two types of constructs by again using the CLP (R) prover <ref> [9] </ref>. As discussed before, certain format requirements have to be met when the assertions are transformed into CLP (R) input format. As an input file, CLP (R) takes the assertions which are necessary for the gen eration of the preconditions, generally post-assertions immediately following the branching/looping conditions.
Reference: [10] <author> C. Hoare. </author> <title> An axiomatic basis for computer programming. </title> <journal> Communications of the ACM, </journal> <volume> 12(10) </volume> <pages> 576-583, </pages> <year> 1969. </year>
Reference-contexts: For example, for checking the correctness of the pre- and post-assertion of an assignment statement, a proof checker could use the assignment axiom <ref> [10] </ref> as follows: pre-assertion: fa = 6g assignment axiom: fa + 1 = 7g assignment statement: a := a + 1; post-assertion: fa = 7g to verify that the assertions that are given with an assignment properly describe the predicate transformation that is performed by the program statement (in this case <p> These assertions characterize properties of program variables and relationships between them at various stages of the program execution. Program verification requires proofs of theorems of the following type: fP gSfQg where P is said to be the precondition and Q the postcondition of S <ref> [10] </ref>. Here, S can be an individual statement of the language or a sequence of statements. The interpretation of the theorem above is as follows: if P is true before the execution of S and if the execution of S terminates, then Q is true after the execution of S.
Reference: [11] <author> J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(R) language and system. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3) </volume> <pages> 339-395, </pages> <month> July </month> <year> 1992. </year>
Reference-contexts: These specifications were translated into program code written in C. The details on how the individual parts of the proof checker work together are discussed in Section 5. 4 Program Verification in CLP (R) CLP (R) is an automated theorem prover based on constraint logic programming, using PROLOG-like syntax <ref> [11] </ref>. It is implemented in C and available for UNIX systems [9]. Since the platform we use for the execution of our programs allows only for assertions in propositional calculus rather than predicate calculus, we also restrict the use of CLP (R) to the use of propositional expressions.
Reference: [12] <author> J.R. Levine, T. Mason, and D. Brown. </author> <title> lex & yacc. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <address> 2nd edition, </address> <year> 1992. </year>
Reference-contexts: The output is a copy of this same program, but with the redundant assertions removed from the file. The individual components of the tool are as follows: * A scanner to read the program, written using the UNIX programming tool lex <ref> [12] </ref>. As input, it takes an annotated program listing and it provides as an output the list of program statements, the assertions, and the line numbers for all statements. * A program flow graph generator which is intimately linked with the scanner.
Reference: [13] <author> E. Nagel and J.R. Newman. </author> <title> Godel's Proof. </title> <publisher> Rout-ledge & Kegan Paul, </publisher> <address> London, </address> <year> 1959. </year>
Reference-contexts: Unfortunately, it has been shown that it is impossible, in principle, to design a decision procedure which decides automatically the truth or falsehood of an arbitrary (mathematical) statement <ref> [13] </ref>. Sadly, this also applies to program verification. Simply providing a program and the desired results in form of an arbitrary postcondition, and then letting an automated tool perform a verification proof is hardly ever doable.
Reference: [14] <author> S. Owre, J.M. Rushby, and N. Shankar. PVS: </author> <title> A prototype verification syten. </title> <editor> In Deepak Kapur, editor, </editor> <booktitle> 11th International Conference on Automated Deduction (CADE), volume 607 of Lecture Notes in Computer Science, </booktitle> <pages> pages 748-752. </pages> <publisher> Springer Verlag, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: and F49620-93-I-0409 and, in part, by a grant from the University of Missouri Research Board. 2 This work was performed while the authors were at the University of Missouri-Rolla in the Department of Computer Science. been many efforts in trying to mechanize program verification [2], [4], [5], [6], [7], [8], <ref> [14] </ref>, etc. Unfortunately, it has been shown that it is impossible, in principle, to design a decision procedure which decides automatically the truth or falsehood of an arbitrary (mathematical) statement [13]. Sadly, this also applies to program verification.
Reference: [15] <author> M. Schollmeyer. </author> <title> Using Temporal Subsump-tion to Generate Efficient Error-Detecting Distributed Algorithms. </title> <type> Ph.D Thesis, </type> <institution> Computer Science Department, University of Missouri-Rolla, </institution> <year> 1994. </year>
Reference-contexts: In the implementation, nextnode is the terminal node of the remaining outgoing edge with the smallest terminal node. * The actual (static) evaluation rules for the different program statements as discussed previously. The axiomatic rules that provide the specifications for the implementation are discussed in detail in <ref> [15] </ref>. These specifications were realized into program code written in C in the analysis tool and are executed during the flow graph traversal. <p> Here, the LU-decomposition was a problem where most "normal" theorem provers had difficulties because of the relationships between variables during the computation. CLP (R) solved this problem without trouble. For details, see <ref> [15] </ref>. 8 Conclusion In this paper we described how to use CLP (R) as part of a simple proof checker. It was especially suitable for this task because it allows us to define complicated numerical dependencies between variables as common in programs performing intensive numerical computations.
References-found: 15

