URL: http://www-i2.informatik.rwth-aachen.de/hanus/publications/reports/MPI-I-94-224/paper08.ps.Z
Refering-URL: http://www.informatik.uni-trier.de/~ley/db/conf/iclp/iclp94-w8.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: grivas@inf.ethz.ch  
Title: Efficient Integration of Declarative Paradigms into Symbolic Computation Systems  
Author: Georgios Grivas 
Address: Zrich  
Affiliation: Department of Computer Science ETH  
Abstract: This paper describes the efficient integration of the functional, logic and constraint paradigms into symbolic computation systems. Moreover, it proposes the constraint logic paradigm for the programming language of symbolic computation systems. First, it describes the integration of a separate constraint logic inference engine with the functional language of the symbolic computation system AlgBench. The procedural, functional, and APL-like programming styles are inherited from Mathematica and are integrated on top of its term-rewriting mechanism. The proposed language could serve as a stand alone programming language. Second, it shows the efficient compilation of the resulting language to an intermediate code. The compiler generates code for a uniform abstract machine (extend ed WAM) which is achieved in an objectoriented way.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> H. At-Kaci. </author> <title> Warren's Abstract Machine. A Tutorial Reconstruction. </title> <publisher> MIT Press, </publisher> <year> 1991 </year>
Reference-contexts: Some efficient rewriting implementations have been done in the compilation of narrowing languages such as ALF [9]. They compile the rewrite rules into an extension of "Warrens Abstract Machine " (WAM) which is the well-known and the de facto technology to compile logic languages <ref> [20, 1] </ref>. However, the most narrowing languages need a complicated compile-time analysis. The AlgBench abstract machine is an extension of the W AM as well. <p> an intermediate code is the consequence to retain AlgBenchs portability (AlgBench runs on Sun SP ARCstations, Cray Y-MP, Convex C220, Alliant FX/80 and Sequent S81b, among others). 4.1 Overall WAM extensions and modifications In this section, we give the main extensions and simplifications compared to the WAM as described in <ref> [1] </ref>. Note that we use the WAM terminology of [1] throughout this paper. The abstract machine is implemented as a class. Although this is related with some inef ficien-cies, it is for functional logic programs of significant worth. <p> portability (AlgBench runs on Sun SP ARCstations, Cray Y-MP, Convex C220, Alliant FX/80 and Sequent S81b, among others). 4.1 Overall WAM extensions and modifications In this section, we give the main extensions and simplifications compared to the WAM as described in <ref> [1] </ref>. Note that we use the WAM terminology of [1] throughout this paper. The abstract machine is implemented as a class. Although this is related with some inef ficien-cies, it is for functional logic programs of significant worth. <p> A new page is allocated only when a memory access on a non existent page is attempted. In this way, the memory grows dynamically up to a maximum dependent on the page table size and no pages are allocated after the initialization of the abstract machine. Unlike <ref> [1] </ref>, where the compiled code is stored in memory and the X-registers are treated separately from the heap, we store the code separately in a double-linked list and we use the memory to store the X-registers. <p> To reduce the set of rules that have to be tried, indexing is applied. This can be realized by looking at the type or the value of one or more arguments. The conventional WAM-based compilers employ first argument indexing <ref> [1] </ref> where the rules are grouped only upon the topmost functional symbol of the first argument. Instead, in complete indexing all arguments and all nested subterms of each argument are indexed as well. The complete indexing method implemented in our system is based on the work done in [8]. <p> This will be subject of future work. Acknowledgments. We would like to thank R. Mder and J. Christian for many useful suggestions. We also thank M. Levy and C.T. Visser for the errata of <ref> [1] </ref>. Many thanks to G. Dolge who realized the logic part of the mentioned implementations.
Reference: 2. <author> H. At-Kaci. </author> <title> Towards a Meaning of LIFE. </title> <booktitle> In Proc of the 3rd International Symposium on Programming Language Implementation and Logic Programming (PLILP91), </booktitle> <publisher> Springer-Verlag, LNCS 528, </publisher> <address> Passau, Germany, </address> <month> August </month> <year> 1991. </year>
Reference: 3. <author> B. </author> <title> Buchberger. Mathematica: A System for doing Mathematics by Computer? Invited T alk. </title> <booktitle> In Proc. of the 3r d Intern. Symposium on Design and Implementation of Symbolic Computation Systems (DIS-CO93), </booktitle> <publisher> Springer Verlag, LNCS 722, </publisher> <address> Gmunden, Austria, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: Given a problem, the user can take one style related to its requirements or combine them in a seamless interface. The need for more logic and proving capabilities in systems doing mathematics (especially in Mathematica) is highlighted in <ref> [3] </ref>. Besides pattern matching, we have also introduced in [7] unification as a primitive operation in AlgBenchs term rewriting environment. Another paradigm whose need for mathematical programs has been shown early in [17] is that of constraint-based programming.
Reference: 4. <author> B. W. Char, K. O. Geddes, G. H. Gonnet, M. B. Monagan, and S. M. </author> <title> W att. MAPLE: Reference Manual. </title> <institution> University of Waterloo, </institution> <address> 5th edition, </address> <year> 1988. </year>
Reference-contexts: On the other hand, there are also relatively ef ficient symbolic computation systems that do not support this declarative kind of programming (e.g. Maple <ref> [4] </ref>). This gives the indication that a procedural language is more ef ficient. The main reason for this is the relatively bad ef ficiency of pattern-matching algorithms used in existing declarative symbolic computation interpreters, since the pattern matcher is at the core of a rule-based system.
Reference: 5. <author> G. E. Collins and R. Loos. </author> <title> The SAC-2 Computer Algebra System . Research Institute for Symbolic Computation, </title> <institution> Johannes Kepler University, Linz, Austria. </institution>
Reference-contexts: The recently introduced language RISC-CLP (Real) [10] can be viewed as a constraint logic user interface for accessing some constraint solvers of the symbolic computation system SAC-2 <ref> [5] </ref>. While the language is intended for scientists and engineers, it does not allow the full access to SAC-2. Constraint logic languages [12, 1 1], replace their primitive operation (unification) by the more general operation of constraint solving . <p> Assume the following constraint logic program of the factorial function: fac [0,1] :-. n1_ + 1 =:= n_, fac [n1_, r1_]. In AlgBench we may use a space instead of an asterisk (*) to denote multiplication. To the query Query [fac <ref> [5, x_] </ref>] we get the binding list -x, 120- although the variables r1_ and r_ are unbound during the execution of the condition r1_ n_ =:= r_ . If we exchange the last two goals of the above program, we take a more ef ficient version.
Reference: 6. <author> M. Fay. </author> <title> First order unification in equational theories. </title> <booktitle> InProc. of the 4th Intern. Conference on Automated Deduction (CADE-4), </booktitle> <publisher> Academic Press, </publisher> <address> Austin, Texas, </address> <year> 1979. </year>
Reference-contexts: From a theoretical point of view , unification is a kind of constraint solving. Constraint logic programs are usually more efficient than logic programs. In addition, programs augmented with constraints achieve often narrowing <ref> [6] </ref> behavior such as the computation of inverse of functions, for example. For these reasons, we have done without the general narrowing mechanism and have introduced two simple inference engines: a rewriting engine and a constraint logic engine. <p> In order to provide a full integration we plan to adopt in AlgBench the residuation control strategy (as e.g. in LIFE <ref> [6] </ref>). A bridge between the two inference engines is the Prolog non-declarative operator is/2. Any functional symbolic expression may occur on its right hand side. That means we can make use of the arbitrary precision numbers and the algebraic manipulation capabilities of the system in its logic part. <p> The system AXIOM provides a compiler, but it is not based on term-rewriting or SLD-resolution. 5 appending a new constraint in the store does not require to solve old constraints. We are currently working on adopting in AlgBench the residuation control strategy (as in <ref> [6] </ref>) in order to provide full integration of the constraint, functional and logic paradigms and in order to give an adequate operational model for our language. Furthermore we plan to incorporate a solver for inequality constraints as in the most constraint logic languages.
Reference: 7. <author> G. Grivas and R. E. </author> <title> Maeder . Matching and Unification for the ObjectOriented Symbolic Computation System AlgBench. In Pr oc. </title> <booktitle> of the 3r d Intern. Symposium on Design and Implementation of Symbolic Computation Systems (DISCO93), </booktitle> <publisher> Springer-Verlag, LNCS 722, </publisher> <address> Gmunden, Austria, </address> <month> September </month> <year> 1993. </year>
Reference-contexts: Given a problem, the user can take one style related to its requirements or combine them in a seamless interface. The need for more logic and proving capabilities in systems doing mathematics (especially in Mathematica) is highlighted in [3]. Besides pattern matching, we have also introduced in <ref> [7] </ref> unification as a primitive operation in AlgBenchs term rewriting environment. Another paradigm whose need for mathematical programs has been shown early in [17] is that of constraint-based programming.
Reference: 8. <author> W. Hans. </author> <title> A Complete Indexing Scheme for WAM-based Abstract Machines. </title> <booktitle> In Proc. of the 4th International Symposium on Pr ogramming Language Implementation and Logic Pr ogramming (PLILP92) , Springer-Verlag, LNCS 631, </booktitle> <address> Leuven, Belgium, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Instead, in complete indexing all arguments and all nested subterms of each argument are indexed as well. The complete indexing method implemented in our system is based on the work done in <ref> [8] </ref>. This scheme allows an independent analysis of ar gument positions and of the nested subterms. It views the rules as sets and it assigns to each formal parameter the rule set in which it appears. <p> Since a functional query does not contain any variables, a new simplified (compared to <ref> [8] </ref>) in- dexing instruction is required: switch_on_term X i , (clab, calt), (ab, falt): jumps to the instruction labeled clab or ab depending on whether the dereferenced value of the X i register is a constant or a structure, respectively. <p> In order to take into account conditions on rewrite rules, a preprocessing is needed at compilation time. The satisfaction of these conditions is ensured by the indexing instructions retry and a new modified (compared to <ref> [8] </ref>) instruction try: try #arg, -r i , 1 i m-: removes the first element i from Alt and calls the condition code of rule r i as long as all conditions of the rule are satisfied or Alt is empty.
Reference: 9. <author> M. Hanus. </author> <title> The Integration of Functions into Logic Programming: A Survey. </title> <note> To appear in Journal of Logic Programming. </note>
Reference-contexts: Almost all symbolic computation systems are based on imperative languages or on LISP. Most of them are symbolic interpreters. The computer algebra system AXIOM provides a compiler, but it is not based on term-rewriting. Compared to other functional-logic languages <ref> [9] </ref>, our language possesses more sophisticated pattern and algebraic manipulation capabilities but it does not yet provide full support of constraint functional logic programming. <p> It offers type-constrained matching, conditional rewrite rules, named patterns, associative, commutative and identity matching, etc. Higher order functions and pure functions are supported along with term-rewriting to give full functional programming support. The user is free from some restrictions of various narrowing languages <ref> [9] </ref>, functional languages [15, 19] or equational languages [16] such as left linearity, strong sequentiality or non-ambiguity restrictions and has the possibility to choose between eager or lazy evaluation. As we have already mentioned in the introduction, AlgBenchs language inherited from Mathe-matica the functional, procedural and APL-like programming styles. <p> The generated code was then compiled with the corresponding compiler of the high-level language and the system did not turn out to be faster than modern compilers of functional languages. Some efficient rewriting implementations have been done in the compilation of narrowing languages such as ALF <ref> [9] </ref>. They compile the rewrite rules into an extension of "Warrens Abstract Machine " (WAM) which is the well-known and the de facto technology to compile logic languages [20, 1]. However, the most narrowing languages need a complicated compile-time analysis.
Reference: 10. <author> H. Hong. RISC-CLP(Real): </author> <title> Logic Programming with Nonlinear Constraints over real numbers. </title> <editor> In F . Benhamou and A. Colmeraurer , editors, </editor> <title> Constraint Logic Pr ogramming: Selected Research, </title> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: Although, compared to other constraint languages, the existing symbolic computation systems contain sophisticated constraint solvers, they do not make use of 1 Research supported by the Swiss National Science Foundation them as a means of programming 2 . The recently introduced language RISC-CLP (Real) <ref> [10] </ref> can be viewed as a constraint logic user interface for accessing some constraint solvers of the symbolic computation system SAC-2 [5]. While the language is intended for scientists and engineers, it does not allow the full access to SAC-2.
Reference: 11. <author> J. Jaffar, S. Michaylov, P. Stuckey and R. Yap. </author> <title> The CLP() Language and the System. </title> <journal> ACM Transactions on Programming Languages, </journal> <volume> 14(3), </volume> <pages> 339-395, </pages> <year> 1992. </year>
Reference-contexts: In our objectoriented compiler the constraints are implemented as a new class of terms. The implementation of the constraint solver uses similar techniques as the implementation of the extended WAM (e.g. it is also realized as a class). As in the most implementations of constraint logic languages <ref> [12, 11] </ref> the constraint solver consists of a memory, a register set and an instruction set. We introduce a new slot in the cell definition of our abstract machine &lt; SOV, cid&gt; to hold a solver variable. The cid field is a unique key to identify a solver variable.
Reference: 12. <author> J. Jaffar. </author> <title> Constraint Logic Programming: A Survey. </title> <note> To appear in Journal of Logic Programming. </note>
Reference-contexts: The recently introduced language RISC-CLP (Real) [10] can be viewed as a constraint logic user interface for accessing some constraint solvers of the symbolic computation system SAC-2 [5]. While the language is intended for scientists and engineers, it does not allow the full access to SAC-2. Constraint logic languages <ref> [12, 1 1] </ref>, replace their primitive operation (unification) by the more general operation of constraint solving . From a theoretical point of view , unification is a kind of constraint solving. Constraint logic programs are usually more efficient than logic programs. <p> In our objectoriented compiler the constraints are implemented as a new class of terms. The implementation of the constraint solver uses similar techniques as the implementation of the extended WAM (e.g. it is also realized as a class). As in the most implementations of constraint logic languages <ref> [12, 11] </ref> the constraint solver consists of a memory, a register set and an instruction set. We introduce a new slot in the cell definition of our abstract machine &lt; SOV, cid&gt; to hold a solver variable. The cid field is a unique key to identify a solver variable.
Reference: 13. <author> R. Jenks and R. Sutor. </author> <title> AXIOM, The Scientific Computation System, </title> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction The new generation of symbolic computation systems, such as Mathematica [21] or AXIOM <ref> [13] </ref> provides beyond the usual mathematical and calculational capabilities a full programming language. The user of such systems has the possibility to write programs that might call the conventional symbolic commands, which appear as built-in compiled (and hence quite efficient) functions.
Reference: 14. <author> R. E. Maeder . AlgBench: </author> <title> An ObjectOriented Symbolic Core System. </title> <booktitle> In Proc. of the 2nd International Symposium on Design and Implementation of Symbolic Computation Systems (DISCO92), </booktitle> <publisher> Springer Ver-lag, LNCS 721, </publisher> <address> Bath, England, </address> <month> April </month> <year> 1992. </year>
Reference-contexts: The user of such systems has the possibility to write programs that might call the conventional symbolic commands, which appear as built-in compiled (and hence quite efficient) functions. The experimental symbolic computation core system AlgBench <ref> [14] </ref> provides a functional language with the syntax and operational model (term-rewriting) of Mathematica. It is designed and implemented in an objectoriented way (in C++). From the programmer s point of view , AlgBench has inherited from Mathematica a multi-paradigm language.
Reference: 15. <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: Section 5 concludes the paper and gives our future aims and directions. 2 Integrating declarative paradigms in AlgBench In contrast to other modern symbolic computation languages such as AXIOM or functional languag es such as Miranda [19] or Standard ML <ref> [15] </ref>, AlgBench provides a more sophisticated algebraic pattern matcher. It offers type-constrained matching, conditional rewrite rules, named patterns, associative, commutative and identity matching, etc. Higher order functions and pure functions are supported along with term-rewriting to give full functional programming support. <p> It offers type-constrained matching, conditional rewrite rules, named patterns, associative, commutative and identity matching, etc. Higher order functions and pure functions are supported along with term-rewriting to give full functional programming support. The user is free from some restrictions of various narrowing languages [9], functional languages <ref> [15, 19] </ref> or equational languages [16] such as left linearity, strong sequentiality or non-ambiguity restrictions and has the possibility to choose between eager or lazy evaluation. As we have already mentioned in the introduction, AlgBenchs language inherited from Mathe-matica the functional, procedural and APL-like programming styles.
Reference: 16. <author> M. ODonnell. </author> <title> Equational Logic as a Pr ogramming Language . Foundations of Computing, </title> <publisher> MIT Press, </publisher> <year> 1985. </year>
Reference-contexts: Higher order functions and pure functions are supported along with term-rewriting to give full functional programming support. The user is free from some restrictions of various narrowing languages [9], functional languages [15, 19] or equational languages <ref> [16] </ref> such as left linearity, strong sequentiality or non-ambiguity restrictions and has the possibility to choose between eager or lazy evaluation. As we have already mentioned in the introduction, AlgBenchs language inherited from Mathe-matica the functional, procedural and APL-like programming styles. <p> Cond [abs [y_] == y_], fib0 [n_, r_]. A capitalized variable of Prolog, e.g. X, is here of the form x_ or X_. T o the logic queries Query [fib1 <ref> [16, r_] </ref>] and Query [fib2 [16, r_]] , we get the binding list -r, 987- . Of course fib0, fib1 and fib2 is not an efficient way to program the Fibonacci function. <p> Cond [abs [y_] == y_], fib0 [n_, r_]. A capitalized variable of Prolog, e.g. X, is here of the form x_ or X_. T o the logic queries Query [fib1 <ref> [16, r_] </ref>] and Query [fib2 [16, r_]] , we get the binding list -r, 987- . Of course fib0, fib1 and fib2 is not an efficient way to program the Fibonacci function. Here we just want to demonstrate the two kinds of a function call in the predicates fib1 and fib2, respectively.
Reference: 17. <author> Alexander Schriver. </author> <title> Theory of Linear and Integer Programming. </title> <publisher> John Wiley, </publisher> <year> 1980. </year>
Reference-contexts: Besides pattern matching, we have also introduced in [7] unification as a primitive operation in AlgBenchs term rewriting environment. Another paradigm whose need for mathematical programs has been shown early in <ref> [17] </ref> is that of constraint-based programming. Although, compared to other constraint languages, the existing symbolic computation systems contain sophisticated constraint solvers, they do not make use of 1 Research supported by the Swiss National Science Foundation them as a means of programming 2 .
Reference: 18. <author> A. Tanenbaum. </author> <title> Operating Systems: Design and Implementation. </title> <publisher> Prentice-Hall, </publisher> <year> 1987. </year>
Reference-contexts: Another way is to realize the memory as a linked list. The problem of this method is the inef ficient direct memory accesses. The memory of our abstract machine is realized as a demand paging <ref> [18] </ref> system. Pages are fixed-size blocks of contiguous memory. Every access on a page is managed through a page table. A new page is allocated only when a memory access on a non existent page is attempted.
Reference: 19. <author> D. T urner. Miranda: </author> <title> A non-strict functional language with polymorphic types. </title> <booktitle> In Proc. of Functional Programming Languages and Computer Architecture FPCA85, </booktitle> <month> September </month> <year> 1985. </year>
Reference-contexts: Subsection 4.4 is devoted to the compilation of arithmetic constraints. Section 5 concludes the paper and gives our future aims and directions. 2 Integrating declarative paradigms in AlgBench In contrast to other modern symbolic computation languages such as AXIOM or functional languag es such as Miranda <ref> [19] </ref> or Standard ML [15], AlgBench provides a more sophisticated algebraic pattern matcher. It offers type-constrained matching, conditional rewrite rules, named patterns, associative, commutative and identity matching, etc. Higher order functions and pure functions are supported along with term-rewriting to give full functional programming support. <p> It offers type-constrained matching, conditional rewrite rules, named patterns, associative, commutative and identity matching, etc. Higher order functions and pure functions are supported along with term-rewriting to give full functional programming support. The user is free from some restrictions of various narrowing languages [9], functional languages <ref> [15, 19] </ref> or equational languages [16] such as left linearity, strong sequentiality or non-ambiguity restrictions and has the possibility to choose between eager or lazy evaluation. As we have already mentioned in the introduction, AlgBenchs language inherited from Mathe-matica the functional, procedural and APL-like programming styles.
Reference: 20. <author> D. H. D. Warren. </author> <title> An Abstract Prolog Instruction Set . Technical Note 309, </title> <institution> SRI International, AI Center , Computer Science and Technology Division, </institution> <month> October </month> <year> 1983. </year>
Reference-contexts: Some efficient rewriting implementations have been done in the compilation of narrowing languages such as ALF [9]. They compile the rewrite rules into an extension of "Warrens Abstract Machine " (WAM) which is the well-known and the de facto technology to compile logic languages <ref> [20, 1] </ref>. However, the most narrowing languages need a complicated compile-time analysis. The AlgBench abstract machine is an extension of the W AM as well.
Reference: 21. <author> S. Wolfram. </author> <title> Mathematica: A System for Doing Mathematics by Computer . Addison-Wesley, </title> <note> second edition, </note> <year> 1991. </year>
Reference-contexts: 1 Introduction The new generation of symbolic computation systems, such as Mathematica <ref> [21] </ref> or AXIOM [13] provides beyond the usual mathematical and calculational capabilities a full programming language. The user of such systems has the possibility to write programs that might call the conventional symbolic commands, which appear as built-in compiled (and hence quite efficient) functions. <p> In this section we discuss the reasons for this compilations. But first, we explain why AlgBenchs operational model is term-rewriting. Mathematicas way of thinking with pattern matching and a database of rules arise from its designers goal: a system must fit naturally the way a scientist works <ref> [21] </ref>. Looking up tables of mathematical functions in handbooks is an important (and tedious) aspect of this work. A rule-based system can implement the implicit pattern matching that goes on during this activity .
References-found: 21

