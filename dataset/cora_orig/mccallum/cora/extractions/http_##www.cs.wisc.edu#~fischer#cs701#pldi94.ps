URL: http://www.cs.wisc.edu/~fischer/cs701/pldi94.ps
Refering-URL: http://www.cs.wisc.edu/~fischer/cs701/readings.html
Root-URL: 
Email: knoop@fmi.uni-passau.de  or@informatik.uni-kiel.d400.de  steffen@fmi.uni-passau.de  
Title: Partial Dead Code Elimination  
Author: Jens Knoop Oliver Ruthing Bernhard Steffen 
Keyword: Topics: data flow analysis, program optimization, dead code elimination, partial redundancy elimination, code motion, assignment motion, bit-vector data flow analyses.  
Date: (1994), 147 158.  
Note: In Proceedings of the 7 th ACM SIGPLAN'94 Conference on Programming Language Design and Implementation (PLDI'94), Orlando, Florida, SIGPLAN Notices 29 6  
Address: Passau  Kiel  Passau  
Affiliation: Universitat  CAU  Universitat  
Abstract: A new aggressive algorithm for the elimination of partially dead code is presented, i.e., of code which is only dead on some program paths. Besides being more powerful than the usual approaches to dead code elimination, this algorithm is optimal in the following sense: partially dead code remaining in the resulting program cannot be eliminated without changing the branching structure or the semantics of the program, or without impairing some program executions. Our approach is based on techniques for partial redundancy elimination. Besides some new technical problems there is a significant difference here: partial dead code elimination introduces second order effects, which we overcome by means of exhaustive motion and elimination steps. The optimality and the uniqueness of the program obtained is proved by means of a new technique which is universally applicable and particularly useful in the case of mutually interdependent program optimizations. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, S. C. Johnson, and J. D. Ullman. </author> <title> Code generation for expressions with common subexpressions. </title> <journal> Journal of the ACM, </journal> <volume> 24(1):146 - 160, </volume> <year> 1977. </year>
Reference-contexts: Finally, instruction scheduling techniques are usually restricted to basic blocks or for-loops and focus on specific goals of code generation, for instance to yield short evaluation sequences with respect to some machine model <ref> [1, 28] </ref>, or to prepare the code for efficient execution on a parallel or pipelined machine [3, 15]. Structure of the Paper The paper develops along the following lines.
Reference: [2] <author> A. V. Aho, R. Sethi, and J. D. Ullman. Compil--ers: </author> <title> Principles, Techniques and Tools. </title> <publisher> Addison-Wesley, </publisher> <year> 1985. </year>
Reference-contexts: A complexity estimation is given in Section 6. 5.2 Eliminating Dead (Faint) Assign ments The elimination of dead (faint) assignments is based on the determination of dead (faint) variables. Dead variables can be computed by means of a backwards directed bit-vector data flow analysis <ref> [2, 17, 24] </ref>. A standard formulation can be found in Table 1, where N-DEAD (x) (or X-DEAD (x)) mean that variable x is dead at the entry (or exit) of statement . <p> Standard methods to dead code elimination are usually based on definition-use graphs <ref> [2, 21] </ref>, which connect the definition sites of a variable with their corresponding use sites. Thus, dead assignments can be identified indirectly by means of a simple marking algorithm working on the definition-use graph.
Reference: [3] <author> D. Bernstein and M. Rodeh. </author> <title> Global instruction scheduling for superscalar machines. </title> <booktitle> In Proc. ACM SIGPLAN Conference on Programming Language Design and Implementation'91, volume 26,6 of ACM SIGPLAN Notices, </booktitle> <pages> pages 241-255, </pages> <address> Toronto, Ontario, </address> <month> June </month> <year> 1991. </year>
Reference-contexts: Finally, instruction scheduling techniques are usually restricted to basic blocks or for-loops and focus on specific goals of code generation, for instance to yield short evaluation sequences with respect to some machine model [1, 28], or to prepare the code for efficient execution on a parallel or pipelined machine <ref> [3, 15] </ref>. Structure of the Paper The paper develops along the following lines. After the preliminary Section 2, Section 3 presents the central notions of our approach and establishes the essential features of partial dead code elimination.
Reference: [4] <author> P. Briggs and K. D. Cooper. </author> <title> Effective partial redundancy elimination. </title> <booktitle> In Proc. ACM SIG-PLAN Conference on Programming Language Design and Implementation'94, volume 29,6 of ACM SIGPLAN Notices, </booktitle> <pages> pages 159 - 170, </pages> <address> Or-lando, FL, </address> <month> June </month> <year> 1994. </year>
Reference-contexts: For instance, in Figure 7 the partially dead assignments of a := a + 1 at node 1 and node 2 can only be eliminated by a simultaneous treatment of both occurrences. Briggs' and Cooper's algorithm <ref> [4] </ref> published in this proceedings employs instruction sinking for the reassociation of expressions. As a by-product some partially dead assignments can be removed.
Reference: [5] <author> R. Cytron, J. Ferrante, B. Rosen, M. Wegman, and F. K. Zadeck. </author> <title> Efficiently computing static single assignment form and the control dependency graph. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4):451 - 490, </volume> <year> 1991. </year>
Reference-contexts: Unfortunately, definition-use graphs are usually quite large, i.e. of order O (i 2 v) in the worst case, where i denotes the number of instructions and v the number of variables occurring in the flow graph [30]. The algorithm of <ref> [5] </ref> improves on this result by working on a sparse definition-use graph based on the SSA form. This results in a worst case time complexity of O (i v), which coincides with the complexity of our simple iterative algorithm (cf.
Reference: [6] <author> D. M. Dhamdhere. </author> <title> A fast algorithm for code movement optimization. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 23(10):172 - 180, </volume> <year> 1988. </year>
Reference-contexts: in a program) is denoted by AP. 2.1 Critical Edges Like partial redundancy elimination also partial dead code elimination can be blocked by critical edges in a flow graph, i.e., by edges leading from a node with more than one successor to a node with more than one predecessor (cf. <ref> [6, 10, 23, 22] </ref>). In Figure 8 (a) the assignment x := a + b at node 1 is partially dead with respect to the assignment at node 3.
Reference: [7] <author> D. M. Dhamdhere. </author> <title> Register assignment using code placement techniques. </title> <journal> Journal of Computer Languages, </journal> <volume> 13(2):75 - 93, </volume> <year> 1988. </year>
Reference-contexts: For example in Figure 6 their algorithm would sink the instruction of node S 4;5 into the loop to node 7. Note that subse-quent partial redundancy elimination fails to hoist it back because of safety reasons. In <ref> [7, 8] </ref> Dhamdhere presents an application of code hoisting and sinking techniques to register assignment which, however, does not provide a contribution to the general problem of partial dead code elimination.
Reference: [8] <author> D. M. Dhamdhere. </author> <title> A usually linear algorithm for register assignment using edge placement of load and store instructions. </title> <journal> Journal of Computer Languages, </journal> <volume> 15(2):83 - 94, </volume> <year> 1990. </year>
Reference-contexts: For example in Figure 6 their algorithm would sink the instruction of node S 4;5 into the loop to node 7. Note that subse-quent partial redundancy elimination fails to hoist it back because of safety reasons. In <ref> [7, 8] </ref> Dhamdhere presents an application of code hoisting and sinking techniques to register assignment which, however, does not provide a contribution to the general problem of partial dead code elimination.
Reference: [9] <author> D. M. Dhamdhere. </author> <title> Practical adaptation of the global optimization algorithm of Morel and Ren-voise. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2):291 - 294, </volume> <year> 1991. </year> <type> Technical Correspondence. </type>
Reference-contexts: This process places the statements in an as specific context as possible, and therefore maximizes the potential of dead code, which is subsequently eliminated. This approach is essentially dual to partial redundancy elimination <ref> [9, 11, 12, 23, 22, 26] </ref>, where computations are moved against the control flow as far as possible, in order to make their effects as universal as possible. Thus similar techniques can be applied. <p> Related Work The idea of assignment sinking and its use in dead code elimination in a global optimizer is already sketched in [25]. However, this algorithm is restricted to a few special control flow patterns, and does not address the general problem at all. Moreover, in <ref> [9] </ref> Dhamdhere proposed an extension of partial redundancy elimination to assignment movement, where, in contrast to our approach, assignments are hoisted rather than sunk, which does not allow any elimination of partially dead code. Recently, Feigen et al. pointed to the importance of partial dead code elimination [13].
Reference: [10] <author> D. M. Dhamdhere, B. K. Rosen, and F. K. Zadeck. </author> <title> How to analyze large programs efficiently and informatively. </title> <booktitle> In Proc. ACM SIG-PLAN Conference on Programming Language Design and Implementation'92, volume 27,7 of ACM SIGPLAN Notices, </booktitle> <pages> pages 212 - 223, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: is obviously the "loop invariant" code fragment in node 2, which cannot be removed from the loop by standard techniques for loop invariant code motion, since the first instruction defines an operand of the second assignment. 1 1 Note that even interleaving code motion and copy propagation as suggested in <ref> [10] </ref> only succeeds in removing the right hand side computations from the loop, but the assignment to x would remain in it. <p> in a program) is denoted by AP. 2.1 Critical Edges Like partial redundancy elimination also partial dead code elimination can be blocked by critical edges in a flow graph, i.e., by edges leading from a node with more than one successor to a node with more than one predecessor (cf. <ref> [6, 10, 23, 22] </ref>). In Figure 8 (a) the assignment x := a + b at node 1 is partially dead with respect to the assignment at node 3. <p> Though the faint problem does not have a bit-vector form, it can easily be solved by means of an iterative worklist algorithm operating slotwise on bit-vectors (cp. <ref> [10] </ref>). The only subtlety here is that a slot (; x) for an assignment statement may be influenced not only by the x-slot of some successor node ^, but also by the slot (; lhs ). <p> For well-structured flow graphs the efficient bit-vector techniques [19, 20, 29] become applicable, yielding an almost linear complexity in terms of fast bit-vector operations. For arbitrary control flow structures, however, the slotwise approach of <ref> [10] </ref> is the best we can do yielding O (ba) as the worst case time complexity for the assignment sinking procedure. 6.1.2 Dead (Faint) Variable Analysis Like the delayability also the dead code analysis is a bit-vector problem. <p> Unfortunately, the faint variable analysis is not a bit-vector problem, i.e. the solution cannot be computed for each variable independently. Thus there are no special algorithms for structured programs, and the slotwise approach of <ref> [10] </ref> must always be applied. Note that the structure of faint code analysis requires a computation at the instruction level.
Reference: [11] <author> K.-H. Drechsler and M. P. Stadel. </author> <title> A solution to a problem with Morel and Renvoise's "Global optimization by suppression of partial redundancies". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 10(4):635 - 640, </volume> <year> 1988. </year> <type> Technical Correspondence. </type>
Reference-contexts: This process places the statements in an as specific context as possible, and therefore maximizes the potential of dead code, which is subsequently eliminated. This approach is essentially dual to partial redundancy elimination <ref> [9, 11, 12, 23, 22, 26] </ref>, where computations are moved against the control flow as far as possible, in order to make their effects as universal as possible. Thus similar techniques can be applied.
Reference: [12] <author> K.-H. Drechsler and M. P. Stadel. </author> <title> A variation of Knoop, Ruthing and Steffen's lazy code motion. </title> <journal> ACM SIGPLAN Notices, </journal> <volume> 28(5):29 - 38, </volume> <year> 1993. </year>
Reference-contexts: This process places the statements in an as specific context as possible, and therefore maximizes the potential of dead code, which is subsequently eliminated. This approach is essentially dual to partial redundancy elimination <ref> [9, 11, 12, 23, 22, 26] </ref>, where computations are moved against the control flow as far as possible, in order to make their effects as universal as possible. Thus similar techniques can be applied.
Reference: [13] <author> L. Feigen, D. Klappholz, R. Casazza, and X. Xue. </author> <title> The revival transformation. </title> <booktitle> In Conf. Record of the 21 nd ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 421 - 434, </pages> <address> Portland, Oregon, </address> <month> January </month> <year> 1994. </year>
Reference-contexts: Moreover, in [9] Dhamdhere proposed an extension of partial redundancy elimination to assignment movement, where, in contrast to our approach, assignments are hoisted rather than sunk, which does not allow any elimination of partially dead code. Recently, Feigen et al. pointed to the importance of partial dead code elimination <ref> [13] </ref>. Their algorithm is characterized by considering more complex statements as movement candidates whenever the elementary statements are blocked. Thus, in contrast to the usual code motion algorithms, it may modify the branching structure of the program under consideration.
Reference: [14] <author> A. Geser, J. Knoop, G. Luttgen, O. Ruthing, and B. Steffen. </author> <title> Chaotic fixed point iterations. </title> <type> MIP-Bericht 9403, </type> <institution> Fakultat fur Mathematik und Informatik, Universitat Passau, Germany, </institution> <year> 1994. </year>
Reference-contexts: Monotonicity: 8 G 0 ; G 00 2 G t 8 f 2 F t : Given such a family of functions F t , we can apply the generalized version of Tarski's Fixed Point Theorem presented in <ref> [14] </ref>, in order to obtain: Theorem 3.7 (Existence of Optimal Programs) G t has an optimal element (wrt &lt; ~ ) which can be computed by any sequence of function applications that contains all elements of F t `sufficiently' often. The optimal program is not unique.
Reference: [15] <author> P. B. Gibbons and S. S. Muchnik. </author> <title> Efficient instruction scheduling for a pipline architecture. </title> <booktitle> In Proc. ACM SIGPLAN Symposium on Compiler Construction'86, volume 21, 7 of ACM SIG-PLAN Notices, </booktitle> <pages> pages 11-16, </pages> <month> June </month> <year> 1986. </year>
Reference-contexts: Finally, instruction scheduling techniques are usually restricted to basic blocks or for-loops and focus on specific goals of code generation, for instance to yield short evaluation sequences with respect to some machine model [1, 28], or to prepare the code for efficient execution on a parallel or pipelined machine <ref> [3, 15] </ref>. Structure of the Paper The paper develops along the following lines. After the preliminary Section 2, Section 3 presents the central notions of our approach and establishes the essential features of partial dead code elimination.
Reference: [16] <author> R. Giegerich, U. Moncke, and R. Wilhelm. </author> <title> In-variance of approximative semantics with respect to program transformations. </title> <booktitle> In Proc. of the third Conference of the European Co-operation in In-formatics, </booktitle> <volume> Informatik-Fachberichte 50, </volume> <pages> pages 1-10. </pages> <publisher> Springer, </publisher> <year> 1981. </year>
Reference-contexts: This simple definition, however, is too strong in order to characterize all assignments that are of no use for any relevant computation. The following recursive definition yields such a characterization. An occurrence of an assignment pattern ff x := t in a basic block n is faint (cp. <ref> [16, 18] </ref>), if its left-hand side variable x is faint , i.e. on every path from n to e every right-hand side occurrence of x following the instance of ff is either preceded by a modification of x or is in an assignment whose left hand side variable is faint as
Reference: [17] <author> M. S. Hecht. </author> <title> Flow Analysis of Computer Programs. </title> <publisher> Elsevier, North-Holland, </publisher> <year> 1977. </year>
Reference-contexts: A complexity estimation is given in Section 6. 5.2 Eliminating Dead (Faint) Assign ments The elimination of dead (faint) assignments is based on the determination of dead (faint) variables. Dead variables can be computed by means of a backwards directed bit-vector data flow analysis <ref> [2, 17, 24] </ref>. A standard formulation can be found in Table 1, where N-DEAD (x) (or X-DEAD (x)) mean that variable x is dead at the entry (or exit) of statement .
Reference: [18] <author> S. Horwitz, A. Demers, and T. Teitelbaum. </author> <title> An efficient general iterative algorithm for data flow analysis. </title> <journal> Acta Informatica, </journal> <volume> 24:679 - 694, </volume> <year> 1987. </year>
Reference-contexts: This simple definition, however, is too strong in order to characterize all assignments that are of no use for any relevant computation. The following recursive definition yields such a characterization. An occurrence of an assignment pattern ff x := t in a basic block n is faint (cp. <ref> [16, 18] </ref>), if its left-hand side variable x is faint , i.e. on every path from n to e every right-hand side occurrence of x following the instance of ff is either preceded by a modification of x or is in an assignment whose left hand side variable is faint as <p> The following example taken from <ref> [18] </ref> shows a faint assignment which is out of the scope of dead code elimination. Thus faint code elimination is more powerful than dead code elimination. On the other hand, in contrast to faint code elimination dead code elimination can be based on an efficient bit-vector data flow analysis.
Reference: [19] <author> J. B. Kam and J. D. Ullman. </author> <title> Global data flow analysis and iterative algorithms. </title> <journal> Journal of the ACM, </journal> <volume> 23(1):158 - 171, </volume> <year> 1976. </year>
Reference-contexts: For well-structured flow graphs the efficient bit-vector techniques <ref> [19, 20, 29] </ref> become applicable, yielding an almost linear complexity in terms of fast bit-vector operations.
Reference: [20] <author> K. Kennedy. </author> <title> Node listings applied to data flow analysis. </title> <booktitle> In Conf. Record of the 2 nd ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 10 - 21, </pages> <address> Palo Alto, CA, </address> <year> 1975. </year>
Reference-contexts: For well-structured flow graphs the efficient bit-vector techniques <ref> [19, 20, 29] </ref> become applicable, yielding an almost linear complexity in terms of fast bit-vector operations.
Reference: [21] <author> K. Kennedy. </author> <title> A survey of data flow analysis techniques. </title> <editor> In S. S. Muchnick and N. D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 1, </volume> <pages> pages 5 - 54. </pages> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1981. </year>
Reference-contexts: Standard methods to dead code elimination are usually based on definition-use graphs <ref> [2, 21] </ref>, which connect the definition sites of a variable with their corresponding use sites. Thus, dead assignments can be identified indirectly by means of a simple marking algorithm working on the definition-use graph.
Reference: [22] <author> J. Knoop, O. Ruthing, and B. Steffen. </author> <title> Lazy code motion. </title> <booktitle> In Proc. ACM SIGPLAN Conference on Programming Language Design and Implementation'92, volume 27,7 of ACM SIGPLAN Notices, </booktitle> <pages> pages 224 - 234, </pages> <address> San Francisco, CA, </address> <month> June </month> <year> 1992. </year>
Reference-contexts: This process places the statements in an as specific context as possible, and therefore maximizes the potential of dead code, which is subsequently eliminated. This approach is essentially dual to partial redundancy elimination <ref> [9, 11, 12, 23, 22, 26] </ref>, where computations are moved against the control flow as far as possible, in order to make their effects as universal as possible. Thus similar techniques can be applied. <p> in a program) is denoted by AP. 2.1 Critical Edges Like partial redundancy elimination also partial dead code elimination can be blocked by critical edges in a flow graph, i.e., by edges leading from a node with more than one successor to a node with more than one predecessor (cf. <ref> [6, 10, 23, 22] </ref>). In Figure 8 (a) the assignment x := a + b at node 1 is partially dead with respect to the assignment at node 3.
Reference: [23] <author> J. Knoop, O. Ruthing, and B. Steffen. </author> <title> Optimal code motion: </title> <journal> Theory and practice. ACM Transactions on Programming Languages and Systems, </journal> <volume> 16(4) </volume> <pages> 1117-1155, </pages> <year> 1994. </year>
Reference-contexts: This process places the statements in an as specific context as possible, and therefore maximizes the potential of dead code, which is subsequently eliminated. This approach is essentially dual to partial redundancy elimination <ref> [9, 11, 12, 23, 22, 26] </ref>, where computations are moved against the control flow as far as possible, in order to make their effects as universal as possible. Thus similar techniques can be applied. <p> in a program) is denoted by AP. 2.1 Critical Edges Like partial redundancy elimination also partial dead code elimination can be blocked by critical edges in a flow graph, i.e., by edges leading from a node with more than one successor to a node with more than one predecessor (cf. <ref> [6, 10, 23, 22] </ref>). In Figure 8 (a) the assignment x := a + b at node 1 is partially dead with respect to the assignment at node 3.
Reference: [24] <author> L. T. Kou. </author> <title> On live-dead analysis for global data flow problems. </title> <journal> Journal of the ACM, </journal> <volume> 24(3):473 - 483, </volume> <month> July </month> <year> 1977. </year>
Reference-contexts: A complexity estimation is given in Section 6. 5.2 Eliminating Dead (Faint) Assign ments The elimination of dead (faint) assignments is based on the determination of dead (faint) variables. Dead variables can be computed by means of a backwards directed bit-vector data flow analysis <ref> [2, 17, 24] </ref>. A standard formulation can be found in Table 1, where N-DEAD (x) (or X-DEAD (x)) mean that variable x is dead at the entry (or exit) of statement .
Reference: [25] <author> R. J. Mintz, G. A. Fisher, and M. Sharir. </author> <title> The design of a global optimizer. </title> <booktitle> In Proc. ACM SIG-PLAN Symposium on Compiler Construction'79, volume 14, 8 of ACM SIGPLAN Notices, </booktitle> <pages> pages 226 - 234, </pages> <address> Denver, Col., </address> <year> 1979. </year>
Reference-contexts: Related Work The idea of assignment sinking and its use in dead code elimination in a global optimizer is already sketched in <ref> [25] </ref>. However, this algorithm is restricted to a few special control flow patterns, and does not address the general problem at all.
Reference: [26] <author> E. Morel and C. </author> <title> Renvoise. Global optimization by suppression of partial redundancies. </title> <journal> Communications of the ACM, </journal> <volume> 22(2):96 - 103, </volume> <year> 1979. </year>
Reference-contexts: This process places the statements in an as specific context as possible, and therefore maximizes the potential of dead code, which is subsequently eliminated. This approach is essentially dual to partial redundancy elimination <ref> [9, 11, 12, 23, 22, 26] </ref>, where computations are moved against the control flow as far as possible, in order to make their effects as universal as possible. Thus similar techniques can be applied.
Reference: [27] <author> B. K. Rosen, M. N. Wegman, and F. K. Zadeck. </author> <title> Global value numbers and redundant computations. </title> <booktitle> In Conf. Record of the 15 th ACM Symposium on the Principles of Programming Languages, </booktitle> <pages> pages 12 - 27, </pages> <address> San Diego, CA, </address> <year> 1988. </year>
Reference-contexts: Summarizing, the overall time bound for our algorithms is only slightly worse than the one for the significantly weaker technique of dead code elimination based on definition-use graphs, and it is comparable with the complexity of other aggressive code motion techniques. E.g., the algorithm for global value numbering of <ref> [27] </ref>, which requires reducible flow graphs and guarantees optimality only for acyclic program structures, is of third order. 7 Conclusions We have presented a new aggressive algorithm for the optimal elimination of partially dead (faint) code, which captures all second order effects that are due to the mutual dependences between assignment
Reference: [28] <author> R. Sethi and J. D. Ullman. </author> <title> The generation of optimal code for arithmetic expressions. </title> <journal> Journal of the ACM, </journal> <volume> 17(4) </volume> <pages> 715-728, </pages> <year> 1970. </year>
Reference-contexts: Finally, instruction scheduling techniques are usually restricted to basic blocks or for-loops and focus on specific goals of code generation, for instance to yield short evaluation sequences with respect to some machine model <ref> [1, 28] </ref>, or to prepare the code for efficient execution on a parallel or pipelined machine [3, 15]. Structure of the Paper The paper develops along the following lines.
Reference: [29] <author> R. E. Tarjan. </author> <title> Applications of path compression on balanced trees. </title> <journal> Journal of the ACM, </journal> <volume> 26(4):690 - 715, </volume> <year> 1979. </year>
Reference-contexts: For well-structured flow graphs the efficient bit-vector techniques <ref> [19, 20, 29] </ref> become applicable, yielding an almost linear complexity in terms of fast bit-vector operations.
Reference: [30] <author> M. N. Wegman and F. K. Zadeck. </author> <title> Constant propagation with conditional branches. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(2), </volume> <month> April </month> <year> 1991. </year>
Reference-contexts: Unfortunately, definition-use graphs are usually quite large, i.e. of order O (i 2 v) in the worst case, where i denotes the number of instructions and v the number of variables occurring in the flow graph <ref> [30] </ref>. The algorithm of [5] improves on this result by working on a sparse definition-use graph based on the SSA form. This results in a worst case time complexity of O (i v), which coincides with the complexity of our simple iterative algorithm (cf.
References-found: 30

