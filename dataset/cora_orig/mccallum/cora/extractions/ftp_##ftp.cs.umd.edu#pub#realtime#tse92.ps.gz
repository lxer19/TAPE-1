URL: ftp://ftp.cs.umd.edu/pub/realtime/tse92.ps.gz
Refering-URL: http://www.cs.umd.edu/projects/TimeWare/TimeWare-index-no-abs.html
Root-URL: 
Email: rich@cs.umd.edu lee@cis.upenn.edu  
Title: A Layered Approach to Automating the Verification of Real-Time Systems  
Author: Richard Gerber Insup Lee 
Keyword: Index Terms: Real-time, specification, configuration, verification, process algebras, prior ity, reachability, programming languages.  
Note: This research was supported in part by NSF CCR-9209333, ONR N00014-89-J-1131, and ARPA/NSF CCR90 14621.  
Address: College Park, MD 20742 Philadelphia, PA 19104  
Affiliation: Dept. of Computer Science Dept. of Computer and Info. Science University of Maryland University of Pennsylvania  
Abstract: We describe a layered approach to the specification and verification of real-time systems. Application processes are specified in the CSR Application Language, which includes high-level language constructs such as timeouts, deadlines, periodic processes, interrupts and exception-handling. Then, a configuration schema is used to map the processes to system resources, and to specify the communication links between them. We automatically translate the result of the mapping into the CCSR process algebra, which characterizes CSR's resource-based computation model by a prioritized transition system. For the purposes of verification, we have implemented a reachability analyzer based on the CCSR semantics. This tool mechanically evaluates the correctness of the CSR specification, by checking whether an exception state can be reached in its corresponding CCSR term. We illustrate the effectiveness of this technique on a multi-sensor robot example. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Alur and T. Henzinger. </author> <title> Real-Time Logics: Complexity and Expressiveness. </title> <booktitle> In Proc. of IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1990. </year>
Reference-contexts: For example, QTL [2] allows one to express the execution time of a program fragment. The model of execution, however, is unrealistic for true real-time programming, in that it employs a pure interleaving approach, and assumes a single resource. Other contributions in real-time temporal logics include <ref> [1, 4, 12, 19, 23, 25] </ref>. The execution model in [23] provides the framework for true concurrency, in that multiple actions can occur simultaneously. In [25], a maximum parallelism semantics is used to capture concurrency.
Reference: [2] <author> A. Bernstein and P.K. Harter Jr. </author> <title> Proving Real-Time Properties of Programs with Temporal Logic. </title> <booktitle> In Proc. Symposium on Operating Systems Principles, </booktitle> <year> 1981. </year>
Reference-contexts: However, the classical temporal logic is not suitable for reasoning about real-time environments, as it cannot formalize assertions that treat finite intervals of time. This and other shortcomings were obviated by several early research efforts. For example, QTL <ref> [2] </ref> allows one to express the execution time of a program fragment. The model of execution, however, is unrealistic for true real-time programming, in that it employs a pure interleaving approach, and assumes a single resource. Other contributions in real-time temporal logics include [1, 4, 12, 19, 23, 25].
Reference: [3] <author> S.D. Brookes, C.A.R. Hoare, and A.W. Roscoe. </author> <title> A Theory of Communicating Sequential Processes. </title> <journal> Journal of the ACM, </journal> <volume> 31(3) </volume> <pages> 560-599, </pages> <month> July </month> <year> 1984. </year>
Reference-contexts: Also, TCCS cannot express timeouts; once an action is enabled it must remain enabled until it is executed. The Timed Stability [26], Timed Failures [8], and Timed Acceptances [28] models are all temporal extensions to the semantics of CSP <ref> [3, 15] </ref>. The Timed Acceptances model possesses a complete axiomatization, which has been automated using the HOL theorem prover [6]. Both [8] and [28] have partially-ordered process domains, so that mapping from a specification to an implementation can often be a matter of deterministic refinement.
Reference: [4] <author> M.K. Franklin and A. Gabrielian. </author> <title> A Transformational Method for Verifying Safety Properties in Real-Time Systems. </title> <booktitle> In Proc. IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 112-123, </pages> <month> December </month> <year> 1989. </year>
Reference-contexts: For example, QTL [2] allows one to express the execution time of a program fragment. The model of execution, however, is unrealistic for true real-time programming, in that it employs a pure interleaving approach, and assumes a single resource. Other contributions in real-time temporal logics include <ref> [1, 4, 12, 19, 23, 25] </ref>. The execution model in [23] provides the framework for true concurrency, in that multiple actions can occur simultaneously. In [25], a maximum parallelism semantics is used to capture concurrency.
Reference: [5] <author> R. Gerber. </author> <title> Communicating Shared Resources: A Model for Distributed Real-Time Systems. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <year> 1991. </year>
Reference-contexts: Then for two actions A and B, if A B, we can say that "A is preempted by B". This means that in all real-time contexts, if a system can choose between executing either A or B, it will execute B. In <ref> [5] </ref>, we present a detailed treatment of real-time preemption, and show how one arrives at an adequate preemption order. Here we can give some intuitive justification for our selection of "." Assume that a term may execute either A or B (e.g., (A : E) + (B : F )).
Reference: [6] <author> R. Gerber, E. Gunter, and I. Lee. </author> <title> Implementing a Real-Time Process Algebra in HOL. </title> <booktitle> In Proceedings of IEEE Int. Workshop on the HOL Theorem Proving System. </booktitle> <publisher> IEEE Press, </publisher> <month> August </month> <year> 1991. </year>
Reference-contexts: The Timed Stability [26], Timed Failures [8], and Timed Acceptances [28] models are all temporal extensions to the semantics of CSP [3, 15]. The Timed Acceptances model possesses a complete axiomatization, which has been automated using the HOL theorem prover <ref> [6] </ref>. Both [8] and [28] have partially-ordered process domains, so that mapping from a specification to an implementation can often be a matter of deterministic refinement. That is, an implementation is a process which is "greater R. Gerber and I. Lee 5 than" the specification process.
Reference: [7] <author> R. Gerber and I. Lee. </author> <title> A Proof System for Communicating Shared Resources. </title> <booktitle> In Proc. 11th IEEE Real-Time Systems Symposium, </booktitle> <year> 1990. </year>
Reference-contexts: For all A 0 2 D, E 00 2 E such that E A 0 Equivalence between processes is based on the concept of strong bisimulation [22]. We denote "~ " as the largest strong bisimulation over ! , and we call it prioritized strong equivalence. In <ref> [7] </ref> we show that "~ " forms a congruence over the CCSR operators; that is, whenever two terms are equivalent, all CCSR "contexts" will preserve their equivalence. Furthermore, the calculus lends itself to an axiomatization that is sound with respect to prioritized equivalence, and complete for finite fragments.
Reference: [8] <author> R. Gerth and A. Boucher. </author> <title> A Timed Failure Semantics for Extended Communicating Processes. </title> <booktitle> In Proceedings of ICALP '87, LNCS 267, </booktitle> <year> 1987. </year>
Reference-contexts: The semantics of TCCS mandates that t -actions are executed immediately, which guarantees maximal parallelism. Also, TCCS cannot express timeouts; once an action is enabled it must remain enabled until it is executed. The Timed Stability [26], Timed Failures <ref> [8] </ref>, and Timed Acceptances [28] models are all temporal extensions to the semantics of CSP [3, 15]. The Timed Acceptances model possesses a complete axiomatization, which has been automated using the HOL theorem prover [6]. Both [8] and [28] have partially-ordered process domains, so that mapping from a specification to an <p> The Timed Stability [26], Timed Failures <ref> [8] </ref>, and Timed Acceptances [28] models are all temporal extensions to the semantics of CSP [3, 15]. The Timed Acceptances model possesses a complete axiomatization, which has been automated using the HOL theorem prover [6]. Both [8] and [28] have partially-ordered process domains, so that mapping from a specification to an implementation can often be a matter of deterministic refinement. That is, an implementation is a process which is "greater R. Gerber and I. Lee 5 than" the specification process.
Reference: [9] <author> C. Ghezzi and R. Kemmerer. ASTRAL: </author> <title> an Assertional Language for Specifying Realtime Systems. </title> <type> Technical Report TRCS 90-25, </type> <institution> Department of Computer Science, University of California, Santa Barbara, </institution> <year> 1990. </year>
Reference-contexts: However, since all possible schedules may have to be considered, the underlying model of time must be finite. A convenient interface to TRIO is presented in <ref> [9] </ref> in which a high-level, assertional language can be automatically translated into TRIO for verification. This technique is similar to our own, in which CSR specifications are translated into CCSR. Real-Time Logic (RTL) [16] is a typed, first-order logic with a syntax particularly suited for the specification of real-time systems.
Reference: [10] <author> C. Ghezzi, D. Mandrioli, and A. Morzenti. </author> <title> TRIO: A Logic Language for Executable Specifications of Real-Time Systems. </title> <journal> Journal of Systems Software, </journal> <volume> 12 </volume> <pages> 107-123, </pages> <year> 1990. </year>
Reference-contexts: In [14] it is shown R. Gerber and I. Lee 4 that real-time constraints (e.g., timeouts and deadlines) can be posed as safety properties in temporal logic. This is quite different from our approach, where we pose real-time properties as constrained programs written in the CSR Application Language. TRIO <ref> [10] </ref> is a real-time, executable temporal logic that provides the basis for several automated tools; among these are tablaux-based programs for satisfiability and model-checking. To determine the satisfiability of a formula f , a Prolog program attempts to construct a "schedule" of variable assignments that satisfies f .
Reference: [11] <author> D. Harel. Statecharts: </author> <title> A visual formalism for complex systems. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 8(3) </volume> <pages> 231-274, </pages> <month> June </month> <year> 1987. </year>
Reference-contexts: In [16] another two-phased approach is presented, in which the high-level, Event-Action language is translated into RTL for the purposes of verification. In [17], RTL is given a graphical specification formalism called Modechart. Based on Harel's Statechart paradigm <ref> [11] </ref>, Modechart incorporates a notion of states called modes; the transitions between modes are labeled by triggering conditions, including deadline information. Again, given Modechart specification, the objective is to prove the implication of an RTL safety assertion.
Reference: [12] <author> E. Harel, O. Lichtenstein, and A. Pnueli. </author> <title> Explicit Clock Temporal Logic. </title> <booktitle> In Proc. of IEEE Symposium on Logic in Computer Science, </booktitle> <year> 1990. </year> <editor> R. Gerber and I. </editor> <booktitle> Lee 37 </booktitle>
Reference-contexts: For example, QTL [2] allows one to express the execution time of a program fragment. The model of execution, however, is unrealistic for true real-time programming, in that it employs a pure interleaving approach, and assumes a single resource. Other contributions in real-time temporal logics include <ref> [1, 4, 12, 19, 23, 25] </ref>. The execution model in [23] provides the framework for true concurrency, in that multiple actions can occur simultaneously. In [25], a maximum parallelism semantics is used to capture concurrency.
Reference: [13] <author> R. Harper. </author> <title> Introduction to standard ML. </title> <type> Technical Report ECS-LFCS-86-14, </type> <institution> Department of Computer Science, University of Edinburgh, The King's Buildings|Edinburgh EH9 3JZ|Scotland, </institution> <year> 1986. </year>
Reference-contexts: The only restriction we make is that no forward references are allowed; this rules out any possibility of "recursive" configurator invocation. Those readers familiar with the ML programming language will note that the relationship between configuration schemas and configurators is similar to that between structures and functors <ref> [13] </ref>. Configuration of the Robot System. We illustrate the Configuration Language by using it to build the system layout depicted in Figure 2. Within the main schema the configurators MakeSensor, MakeConv and MakeBChan are instantiated to create four replicas of each subsystem. <p> This path is a sequence of actions that the system may execute to arrive at the current state being checked for errors. If indeed an error is detected, the execution path is printed out for the user. The analysis tool is implemented in the ML Programming Language <ref> [13] </ref>, specifically Standard ML of New Jersey, Version 0.66. In addition, we used ML-Yacc and ML-Lex to generate a compiler for CSR. R. Gerber and I.
Reference: [14] <author> T. Henzinger, Z. Manna, and A. Pnueli. </author> <title> Temporal Proof Methodologies for Real-Time Systems. </title> <booktitle> In Proc. of ACM Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: In [25], a maximum parallelism semantics is used to capture concurrency. Maximum parallelism is, in a sense, the extreme opposite of interleaving parallelism: it assumes that at every time instant, as much concurrent activity as possible takes place. In <ref> [14] </ref> it is shown R. Gerber and I. Lee 4 that real-time constraints (e.g., timeouts and deadlines) can be posed as safety properties in temporal logic. This is quite different from our approach, where we pose real-time properties as constrained programs written in the CSR Application Language.
Reference: [15] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice-Hall, </publisher> <year> 1985. </year>
Reference-contexts: Also, TCCS cannot express timeouts; once an action is enabled it must remain enabled until it is executed. The Timed Stability [26], Timed Failures [8], and Timed Acceptances [28] models are all temporal extensions to the semantics of CSP <ref> [3, 15] </ref>. The Timed Acceptances model possesses a complete axiomatization, which has been automated using the HOL theorem prover [6]. Both [8] and [28] have partially-ordered process domains, so that mapping from a specification to an implementation can often be a matter of deterministic refinement. <p> Rather, they serve as "flags" that help indicate whether a process satisfies a particular property. One such event in is " p ," which we call the termination event. In the spirit of CSP <ref> [15] </ref> and TCSP [26], a system that executes p at some time t is capable of terminating at that time. For example, if the action fS1:Sensor:data; C1:Conv:data; p executed, then upon their communication, both S1.Sensor and C1.Conv are able to terminate. The Event Mapping .
Reference: [16] <author> F. Jahanian and A.K. Mok. </author> <title> Safety analysis of timing properties in real-time systems. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-12(9):890-904, </volume> <month> September </month> <year> 1986. </year>
Reference-contexts: A convenient interface to TRIO is presented in [9] in which a high-level, assertional language can be automatically translated into TRIO for verification. This technique is similar to our own, in which CSR specifications are translated into CCSR. Real-Time Logic (RTL) <ref> [16] </ref> is a typed, first-order logic with a syntax particularly suited for the specification of real-time systems. RTL is essentially a requirements language, in that the formalism possesses no execution model per se. <p> RTL is essentially a requirements language, in that the formalism possesses no execution model per se. The system requirements, as well as the safety assertion, are posed in first-order formulas; the system is considered safe if the requirements maintain the safety assertion by implication. In <ref> [16] </ref> another two-phased approach is presented, in which the high-level, Event-Action language is translated into RTL for the purposes of verification. In [17], RTL is given a graphical specification formalism called Modechart.
Reference: [17] <author> F. Jahanian and D.A. Stuart. </author> <title> A Method for Verifying Properties of Modechart Specifications. </title> <booktitle> In Proc. IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 12-21, </pages> <month> December </month> <year> 1988. </year>
Reference-contexts: In [16] another two-phased approach is presented, in which the high-level, Event-Action language is translated into RTL for the purposes of verification. In <ref> [17] </ref>, RTL is given a graphical specification formalism called Modechart. Based on Harel's Statechart paradigm [11], Modechart incorporates a notion of states called modes; the transitions between modes are labeled by triggering conditions, including deadline information.
Reference: [18] <author> M. Joseph and A. Goswami. </author> <booktitle> What's 'Real' about Real-time Systems? In IEEE Real-Time Systems Symposium, </booktitle> <year> 1988. </year>
Reference-contexts: In addition, these systems are costly to prototype, requiring careful prediction of timing properties before implementation and evaluation of design alternatives. In this paper we present a layered paradigm to specify, and then automatically verify a resource-bound, real-time system. As in <ref> [18] </ref>, we model a real-time system not only by its functionality and timing constraints, but also as a collection of one or more shared resources. Each resource is inherently sequential in nature; that is, a resource only has the capacity to execute a solitary event at any time.
Reference: [19] <author> R. Koymans. </author> <title> Specifying Message Passing and Time-Critical Systems with Temporal Logic. </title> <booktitle> Real-Time Systems, </booktitle> <volume> 16(11), </volume> <month> November </month> <year> 1990. </year>
Reference-contexts: For example, QTL [2] allows one to express the execution time of a program fragment. The model of execution, however, is unrealistic for true real-time programming, in that it employs a pure interleaving approach, and assumes a single resource. Other contributions in real-time temporal logics include <ref> [1, 4, 12, 19, 23, 25] </ref>. The execution model in [23] provides the framework for true concurrency, in that multiple actions can occur simultaneously. In [25], a maximum parallelism semantics is used to capture concurrency.
Reference: [20] <author> I. Lee and V. Gehlot. </author> <title> Language Constructs for Distributed Real-Time Programming. </title> <booktitle> In Proc. IEEE Real-Time Systems Symposium, </booktitle> <year> 1985. </year>
Reference-contexts: The Parallel operator E I k J E has two functions: It limits the resources that can be used by the two terms, and also forces synchronization between them. The Scope construct E 4 (B;C) t (F; G; H) binds the term E by a temporal scope <ref> [20] </ref>, and it incorporates both the features of timeouts and interrupts. We call t the time bound, where t 2 NN + [ f1g (i.e., t is either a positive integer or infinity).
Reference: [21] <author> R. Milner. </author> <title> Calculi for synchrony and asynchrony. </title> <journal> Theoretical Computer Science, </journal> <volume> 25 </volume> <pages> 267-310, </pages> <year> 1983. </year>
Reference-contexts: The following grammar defines the terms of CCSR: E := NIL j A : E j E + E j E I k J E j E 4 t (E; E; E) j [E] I j f ix (X:E) j X The term NIL corresponds to 0 in SCCS <ref> [21] </ref> it can execute no action. The Action operator, A : E, denotes that the action A is executed at the first time unit, proceeded by the term E. The Choice operator represents nondeterminism either of the terms can be chosen to execute, subject to the constraints of the environment.
Reference: [22] <author> R. Milner. </author> <title> Communication and Concurrency. </title> <publisher> Prentice-Hall, </publisher> <year> 1989. </year>
Reference-contexts: For this reason, it provides a convenient, user-friendly interface to our low-level representation of a real-time system; that is, as a term in the CCSR process algebra. CCSR possesses a small set of operators which, in the spirit of CCS <ref> [22] </ref>, we can describe by a simple operational semantics. Armed with the CCSR model, R. Gerber and I. <p> For all A 0 2 D, E 00 2 E such that E A 0 Equivalence between processes is based on the concept of strong bisimulation <ref> [22] </ref>. We denote "~ " as the largest strong bisimulation over ! , and we call it prioritized strong equivalence. In [7] we show that "~ " forms a congruence over the CCSR operators; that is, whenever two terms are equivalent, all CCSR "contexts" will preserve their equivalence.
Reference: [23] <author> J.S. Ostroff and W.M. Wonham. </author> <title> Modelling, Specifying and Verifying Real-time Embedded Computer Systems. </title> <booktitle> In Proc. IEEE Real-Time Systems Symposium, </booktitle> <pages> pages 124-132, </pages> <month> December </month> <year> 1987. </year>
Reference-contexts: For example, QTL [2] allows one to express the execution time of a program fragment. The model of execution, however, is unrealistic for true real-time programming, in that it employs a pure interleaving approach, and assumes a single resource. Other contributions in real-time temporal logics include <ref> [1, 4, 12, 19, 23, 25] </ref>. The execution model in [23] provides the framework for true concurrency, in that multiple actions can occur simultaneously. In [25], a maximum parallelism semantics is used to capture concurrency. <p> The model of execution, however, is unrealistic for true real-time programming, in that it employs a pure interleaving approach, and assumes a single resource. Other contributions in real-time temporal logics include [1, 4, 12, 19, 23, 25]. The execution model in <ref> [23] </ref> provides the framework for true concurrency, in that multiple actions can occur simultaneously. In [25], a maximum parallelism semantics is used to capture concurrency.
Reference: [24] <author> Gordon Plotkin. </author> <title> A structural approach to operational semantics. </title> <type> Technical Report DAIMI FN-19, </type> <institution> Computer Science Dept., Aarhus University, </institution> <year> 1981. </year>
Reference-contexts: The term f ix (X:P ) denotes standard recursion, allowing the specification of infinite behaviors. The semantics of E is defined in two steps. First, in the style of <ref> [24] </ref>, we develop the unconstrained transition system ! E fi D fi E, where we denote each member (E; A; F ) of "!" as "E ! F ".
Reference: [25] <author> A. Pnueli and E. Harel. </author> <title> Applications of Temporal Logic to the Specification of Real-Time Systems. </title> <booktitle> In Proc. Formal Techniques in Real-Time and Fault-Tolerant Systems (LNCS 331), </booktitle> <pages> pages 84-98, </pages> <year> 1988. </year>
Reference-contexts: For example, QTL [2] allows one to express the execution time of a program fragment. The model of execution, however, is unrealistic for true real-time programming, in that it employs a pure interleaving approach, and assumes a single resource. Other contributions in real-time temporal logics include <ref> [1, 4, 12, 19, 23, 25] </ref>. The execution model in [23] provides the framework for true concurrency, in that multiple actions can occur simultaneously. In [25], a maximum parallelism semantics is used to capture concurrency. <p> Other contributions in real-time temporal logics include [1, 4, 12, 19, 23, 25]. The execution model in [23] provides the framework for true concurrency, in that multiple actions can occur simultaneously. In <ref> [25] </ref>, a maximum parallelism semantics is used to capture concurrency. Maximum parallelism is, in a sense, the extreme opposite of interleaving parallelism: it assumes that at every time instant, as much concurrent activity as possible takes place. In [14] it is shown R. Gerber and I.
Reference: [26] <author> G.M. Reed and A.W. Roscoe. </author> <title> Metric Spaces as Models for Real-Time Concurrency. </title> <booktitle> In Proceedings of Math. </booktitle> <institution> Found. of Computer Science, </institution> <note> LNCS 298, 1987. </note> <author> R. Gerber and I. </author> <type> Lee 38 </type>
Reference-contexts: The semantics of TCCS mandates that t -actions are executed immediately, which guarantees maximal parallelism. Also, TCCS cannot express timeouts; once an action is enabled it must remain enabled until it is executed. The Timed Stability <ref> [26] </ref>, Timed Failures [8], and Timed Acceptances [28] models are all temporal extensions to the semantics of CSP [3, 15]. The Timed Acceptances model possesses a complete axiomatization, which has been automated using the HOL theorem prover [6]. <p> Rather, they serve as "flags" that help indicate whether a process satisfies a particular property. One such event in is " p ," which we call the termination event. In the spirit of CSP [15] and TCSP <ref> [26] </ref>, a system that executes p at some time t is capable of terminating at that time. For example, if the action fS1:Sensor:data; C1:Conv:data; p executed, then upon their communication, both S1.Sensor and C1.Conv are able to terminate. The Event Mapping .
Reference: [27] <author> W. Yi. </author> <title> CCS + Time = An Interleaving Model for Real Time Systems. </title> <booktitle> In Proc. of Int. Conf. on Automata, Languages and Programming, </booktitle> <year> 1991. </year>
Reference-contexts: Again, given Modechart specification, the objective is to prove the implication of an RTL safety assertion. This is done by expanding a Modechart into a computation graph, and by checking the formula in each state. Several process algebras have also been developed for real-time specification. As presented in <ref> [27] </ref>, TCCS is a temporal extension to the interleaving model for CCS. The standard action prefix is replaced by a delay-sensitive prefix operator, "ff@t:P ," where "ff" is an uninterpreted action and "t" is a time variable.
Reference: [28] <author> A. Zwarico. </author> <title> Timed Acceptance: An Algebra of Time Dependent Computing. </title> <type> PhD thesis, </type> <institution> Department of Computer and Information Science, University of Pennsylvania, </institution> <year> 1988. </year>
Reference-contexts: The semantics of TCCS mandates that t -actions are executed immediately, which guarantees maximal parallelism. Also, TCCS cannot express timeouts; once an action is enabled it must remain enabled until it is executed. The Timed Stability [26], Timed Failures [8], and Timed Acceptances <ref> [28] </ref> models are all temporal extensions to the semantics of CSP [3, 15]. The Timed Acceptances model possesses a complete axiomatization, which has been automated using the HOL theorem prover [6]. Both [8] and [28] have partially-ordered process domains, so that mapping from a specification to an implementation can often be <p> The Timed Stability [26], Timed Failures [8], and Timed Acceptances <ref> [28] </ref> models are all temporal extensions to the semantics of CSP [3, 15]. The Timed Acceptances model possesses a complete axiomatization, which has been automated using the HOL theorem prover [6]. Both [8] and [28] have partially-ordered process domains, so that mapping from a specification to an implementation can often be a matter of deterministic refinement. That is, an implementation is a process which is "greater R. Gerber and I. Lee 5 than" the specification process.
References-found: 28

