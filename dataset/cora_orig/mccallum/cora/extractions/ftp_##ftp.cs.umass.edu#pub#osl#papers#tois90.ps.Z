URL: ftp://ftp.cs.umass.edu/pub/osl/papers/tois90.ps.Z
Refering-URL: http://spa-www.cs.umass.edu/bibliography.html
Root-URL: 
Title: Design of the Mneme Persistent Object Store  
Author: J. Eliot B. Moss 
Keyword: General Terms: Design, Languages, Performance Additional Key Words and Phrases: Database programming languages, object-based systems, object management, object-oriented database systems, object-oriented programming languages, persistent object stores, persistent programming languages  
Date: August 1990  
Address: Amherst  
Affiliation: Department of Computer and Information Science University of Massachusetts,  
Abstract: The Mneme project is an investigation of techniques for integrating programming language and database features to provide better support for cooperative, information-intensive tasks such as computer aided software engineering. The project strategy is to implement efficient distributed persistent programming languages. We report here on the Mneme persistent object store, a fundamental component of the project, discussing its design and initial prototype. Mneme stores objects, in a simple and general format, preserving object identity and object inter-relationships. Specific goals for the store include portability, extensibility (especially with respect to object management policies), and performance. The model of memory that the store aims to present is a single, cooperatively shared heap, distributed across a collection of networked computers. The initial prototype is intended mainly to explore performance issues and to support object-oriented persistent programming languages. We include performance measurements from the prototype as well as more qualitative results. Categories and Subject Descriptors: D.3.4 [Programming Languages]: Processorsrun-time environments; D.4.2 [Operating Systems]: Storage Managementdistributed memories, segmentation, storage hierarchies, virtual memory; D.4.3 [Operating Systems]: File Systems Managementaccess methods, directory structures, file organization; D.4.7 [Operating Systems]: Organization and Design; D.4.8 [Operating Systems]: Performancemeasurements; D.4.9 [Operating Systems]: Systems Programs and Utilities; H.2.2 [Database Management]: Physical Designaccess methods; H.2.4 [Database Management]: Systems 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> AGRAWAL, R., AND GEHANI, N. H. </author> <title> ODE (Object Database and Environment): The language and the data model. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data (Portland, OR, May-June 1989), </booktitle> <volume> vol. 18, no. </volume> <booktitle> 2 of ACM SIGMOD Record, ACM, </booktitle> <pages> pp. 36-45. </pages>
Reference-contexts: Also, these other systems are all attempts at complete database management systems, and end up being heavy weight compared with Mneme. 34 5.3 Persistent and Database Programming Languages PS-Algol [4, 5] is representative of the persistent programming languages, and E (already mentioned), O 2 [27, 6], O++ <ref> [1, 2] </ref>, and Opal (the language in the Gemstone system) of recent database programming languages. These systems are all oriented toward particular programming languages and/or data models, whereas Mneme is attempting to provide a generic substrate (possibly suitable for building some of the other systems).
Reference: [2] <author> AGRAWAL, R., AND GEHANI, N. H. </author> <title> Rationale for the design of persistence and query processing facilities in the database language O++. </title> <booktitle> In Proceedings of the Second International Workshop on Database Programming Languages (Gleneden Beach, </booktitle> <address> OR, June 1989), </address> <publisher> Morgan Kaufmann, </publisher> <pages> pp. 25-40. </pages>
Reference-contexts: Also, these other systems are all attempts at complete database management systems, and end up being heavy weight compared with Mneme. 34 5.3 Persistent and Database Programming Languages PS-Algol [4, 5] is representative of the persistent programming languages, and E (already mentioned), O 2 [27, 6], O++ <ref> [1, 2] </ref>, and Opal (the language in the Gemstone system) of recent database programming languages. These systems are all oriented toward particular programming languages and/or data models, whereas Mneme is attempting to provide a generic substrate (possibly suitable for building some of the other systems).
Reference: [3] <author> ANDREWS, T., AND HARRIS, C. </author> <title> Combining language and database advances in an object-oriented developement environment. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (Orlando, </booktitle> <address> FL, </address> <month> Oct. </month> <year> 1987), </year> <journal> ACM SIGPLAN Notices, ACM, </journal> <pages> pp. 430-440. </pages>
Reference-contexts: like the other systems, is designed for centralized rather than distributed use, and its large object identifiers and higher overhead interface make it less efficient as a platform for our persistent programming languages. 5.2 Object Oriented Databases Some relevant object oriented database systems are Orion [25], GemStone [36], and VBase <ref> [3] </ref>. These systems are oriented toward specific languages (Lisp, Smalltalk, and C/C++, respectively). Orion and GemStone do support (single) servers, but none of the systems have Mneme's orientation toward a large distributed space of objects.
Reference: [4] <author> ATKINSON, M., CHISOLM, K., AND COCKSHOTT, P. </author> <title> PS-algol: an Algol with a persistent heap. </title> <journal> ACM SIGPLAN Notices 17, </journal> <month> 7 (July </month> <year> 1982), </year> <pages> 24-31. </pages>
Reference-contexts: Also, these other systems are all attempts at complete database management systems, and end up being heavy weight compared with Mneme. 34 5.3 Persistent and Database Programming Languages PS-Algol <ref> [4, 5] </ref> is representative of the persistent programming languages, and E (already mentioned), O 2 [27, 6], O++ [1, 2], and Opal (the language in the Gemstone system) of recent database programming languages.
Reference: [5] <author> ATKINSON, M. P., AND MORRISON, R. </author> <title> Procedures as persistent data objects. </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 7, </volume> <month> 4 (Oct. </month> <year> 1985), </year> <pages> 539-559. </pages>
Reference-contexts: Also, these other systems are all attempts at complete database management systems, and end up being heavy weight compared with Mneme. 34 5.3 Persistent and Database Programming Languages PS-Algol <ref> [4, 5] </ref> is representative of the persistent programming languages, and E (already mentioned), O 2 [27, 6], O++ [1, 2], and Opal (the language in the Gemstone system) of recent database programming languages.
Reference: [6] <author> BANCILHON, F., BARBEDETTE, G., BENZAKEN, V., DELOBEL, C., GAMERMAN, S., L ECLUSE, C., PFEFFER, P., RICHARD, P., AND VELEZ, F. </author> <title> The design and implementation of O 2 , an object-oriented database system. </title> <booktitle> In Advances in Object-Oriented Database Systems (Sept. </booktitle> <year> 1988), </year> <editor> K. R. Dittrich, Ed., </editor> <volume> vol. </volume> <booktitle> 334 of Lecture Notes in Computer Science, </booktitle> <publisher> Springer-Verlag, </publisher> <pages> pp. 1-22. </pages>
Reference-contexts: Also, these other systems are all attempts at complete database management systems, and end up being heavy weight compared with Mneme. 34 5.3 Persistent and Database Programming Languages PS-Algol [4, 5] is representative of the persistent programming languages, and E (already mentioned), O 2 <ref> [27, 6] </ref>, O++ [1, 2], and Opal (the language in the Gemstone system) of recent database programming languages. These systems are all oriented toward particular programming languages and/or data models, whereas Mneme is attempting to provide a generic substrate (possibly suitable for building some of the other systems).
Reference: [7] <author> BATORY, D. S., BARNETT, J. R., GARZA, J. F., SMITH, K. P., TSUKUDA, K., TWITCHELL, B. C., AND WISE, T. E. </author> <title> GENESIS: an extensible database management system. </title> <journal> IEEE Trans. on Soft. Eng. </journal> <month> (Nov. </month> <year> 1988), </year> <pages> 1711-1730. 38 </pages>
Reference-contexts: In the interests of brevity and incisiveness we relate the Mneme design (not the prototype) to well known exemplars of the various approaches rather than attempting exhaustive enumeration of all related work. 5.1 Extensible Databases POSTGRES [42], Exodus [10, 37, 18], and Genesis <ref> [7] </ref> take different approaches to extensibility. POSTGRES is built on the relational database model. While it has significant extensions, it does 33 not support object identity or tight language integration. It is not a lightweight system. Rather, it attempts to provide a full featured database system.
Reference: [8] <author> BISHOP, P. B. </author> <title> Computer Systems with a Very Large Address Space and Garbage Collection. </title> <type> PhD thesis, </type> <institution> Massachusetts Institute of Technology, </institution> <address> Cambridge, MA, </address> <month> May </month> <year> 1977. </year>
Reference-contexts: Every Mneme object resides in a file. We are exploring whether and how to allow objects to move from file to file, which may be important for global garbage collection (cf. <ref> [8] </ref>). Files are a convenient unit for storage, and provide modularity of the object space, one of the stated goals. We intend that Mneme files, or groups of related files, be reasonable units of backup, recovery, garbage collection, and transfer between different Mneme stores. <p> Garbage collection is more of problem in a shared address space, since the whole space may have to be searched to be able to determine reachability. The segmentation introduced by files, similar to the areas of <ref> [8] </ref>, makes garbage collection more realistic. The main advantages of the virtual memory approach are simplicity and familiarity, though the simplicity may be only apparent, not real, when we consider administration of a very large distributed store. <p> object idea may turn out to be useful in addition to the incoming reference table: object reachable from the root object in some sense belong in the file, whereas those that are reachable only from the incoming reference table are candidates to move to other files. (This idea comes from <ref> [8] </ref>.) 3.2.4 Miscellaneous Operations The interface includes several operations for acquiring statistics and counts. These are clearly very important considering our goals of measuring performance.
Reference: [9] <author> CARDELLI, L., DONAHUE, J., GLASSMAN, L., JORDAN, M., KALSOW, B., AND NELSON, G. </author> <type> Modula-3 report (revised). Tech. Rep. </type> <institution> DEC SRC 52, DEC Systems Research Center/Olivetti Research Center, </institution> <address> Palo Alto/Menlo Park, CA, </address> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: There are specific implications, though, deriving from the project direction. The store should be suited to integration with some ponent of the Trellis system was formerly called Owl. 4 programming languages (current efforts include Smalltalk-80 and Modula-3 <ref> [9] </ref>), it should allow experimentation with techniques for sharing data cooperatively, and it should be a suitable basis for an architecture examining issues of distributed execution as well as distributed storage. 2 Concepts of the Mneme Store Design We now introduce the architecture, concepts, and semantics of the Mneme store design.
Reference: [10] <author> CAREY, M. J., DEWITT, D. J., RICHARDSON, J. E., AND SHEKITA, E. J. </author> <title> Object and file management in the EXODUS extensible database system. </title> <booktitle> In Proceedings of the Twelfth International Conference on Very Large Databases (Kyoto, </booktitle> <address> Japan, </address> <month> Sept. </month> <year> 1986), </year> <booktitle> ACM, </booktitle> <pages> pp. 91-100. </pages>
Reference-contexts: Additionally, one can change the size of an object, replace it by another object, and delete it. We developed this specific object concept for several reasons, most easily discussed by considering alternatives. Perhaps the simplest notion of object, used in some well-known designs (e.g., <ref> [39, 20, 10] </ref>), is a vector of bytes alone. Our addition of attribute bits is not very profound; requiring that ids inside objects be enumerable is more interesting. <p> The primary comparison we make is with non-persistent forms of similar manipulations. In addition there are absolute measures and some comparison with the Exodus storage manager (ESM) <ref> [10] </ref>. The comparison with ESM is necessarily rough, because it provides different abstractions and different functionality. Thus, though Mneme performs better than ESM on most of the tests reported here, those tests are not necessarily representative of what ESM was designed to do. <p> In the interests of brevity and incisiveness we relate the Mneme design (not the prototype) to well known exemplars of the various approaches rather than attempting exhaustive enumeration of all related work. 5.1 Extensible Databases POSTGRES [42], Exodus <ref> [10, 37, 18] </ref>, and Genesis [7] take different approaches to extensibility. POSTGRES is built on the relational database model. While it has significant extensions, it does 33 not support object identity or tight language integration. It is not a lightweight system.
Reference: [11] <author> CHANG, A., AND MERGEN, M. F. </author> <title> 801 storage: Architecture and programming. </title> <journal> ACM Trans. Comput. Syst. </journal> <volume> 6, </volume> <month> 1 (Feb. </month> <year> 1988), </year> <pages> 28-50. </pages>
Reference-contexts: None of these systems have Mneme's goal of supporting a large, distributed, unbounded object space. 5.4 Object Stores and Persistent Memories Related work in this area could be stretched to include Multics [34] and a variety of capability architectures. More narrowly construed, some interesting examples are Camelot [40], 801 <ref> [11] </ref>, FAD [12], ObServer [39, 20], and CACTIS [21]. Camelot and 801 offer different versions of persistent/recoverable virtual memory. While Camelot supports multiple servers in a distributed environment, it does not provide uniform naming throughout a system.
Reference: [12] <author> COPELAND, G., FRANKLIN, M., AND WEIKUM, G. </author> <title> Uniform object management. </title> <type> MCC Technical Report ACA-ST-411-88, </type> <institution> Microelectronics and Computer Technology Corporation, Austin, TX, </institution> <month> Dec. </month> <year> 1988. </year>
Reference-contexts: More narrowly construed, some interesting examples are Camelot [40], 801 [11], FAD <ref> [12] </ref>, ObServer [39, 20], and CACTIS [21]. Camelot and 801 offer different versions of persistent/recoverable virtual memory. While Camelot supports multiple servers in a distributed environment, it does not provide uniform naming throughout a system.
Reference: [13] <author> COPELAND, G., AND MAIER, D. </author> <title> Making Smalltalk a database system. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data (Boston, </booktitle> <address> MA, </address> <month> June </month> <year> 1984), </year> <title> vol. </title> <booktitle> 14, no.2 of ACM SIGMOD Record, ACM, </booktitle> <pages> pp. 316-325. </pages>
Reference-contexts: frequently residing in a different process, and having to convert data between programming language and database formats, are examples of performance obstacles that integration can address. (Another motivation for integration is the relatively poorer functionality and less desirable semantics of non-integrated systems, which has been called the impedance mismatch problem <ref> [13] </ref>.) Further, many cooperative, information intensive applications, especially CAD, are quite demanding.
Reference: [14] <author> DEWITT, D. J., FUTTERSACK, P., MAIER, D., AND VELEZ, F. </author> <title> A study of three alternative workstation-server architectures for object oriented database systems. </title> <booktitle> In Proceedings of the Sixteenth International Conference of Very Large Data Bases (Brisbane, </booktitle> <address> Australia, Aug. 1990), </address> <publisher> Morgan Kaufmann, </publisher> <pages> pp. 107-121. </pages>
Reference-contexts: We are not committed to client-server interaction at a single level of granularity, though, and there is some evidence that multiple granularities need to be offered <ref> [14] </ref>. We are also not committed to any specific servers or modes of interactions with them; the architecture is designed to be independent of that issue. 5 We now discuss three issues that arise from this architectural approach: safety, concurrency control, and buffering.
Reference: [15] <author> ELHARD, K., AND BAYER, R. </author> <title> A database cache for high performance and fast restart in database systems. </title> <journal> ACM Trans. Database Syst. </journal> <volume> 9, </volume> <month> 4 (Dec. </month> <year> 1984), </year> <pages> 503-525. </pages>
Reference-contexts: We expect that logically storing the log information with the segments, but recording changes physically using techniques such as the database cache <ref> [15, 33] </ref>, will help overcome the potential performance problems. In summary, the Mneme store design includes a basic transaction facility, a transaction extension facility, and support for crash resiliency.
Reference: [16] <author> ESWAREN, K. P., GRAY, J. N., LORIE, R. A., AND TRAIGER, I. L. </author> <title> The notion of consistency and predicate locks in a database system. </title> <journal> Commun. ACM 19, </journal> <volume> 11 (Nov. </volume> <year> 1976), </year> <pages> 624-633. </pages>
Reference-contexts: A related problem is that different servers may provide different concurrency control features, yet the programmer should be isolated from server idiosyncrasies. Our approach to these problems is to assume that serializability <ref> [16] </ref> of reads and writes is adequate in most cases, and that the programmer will become explicitly involved when more subtle concurrency control is required. Section 2.2.5 describes our approach to extensible concurrency control within the object store design.
Reference: [17] <author> GOLDBERG, A., AND ROBSON, D. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: least 100,000 references per second to fields of objects, to support dragging collections of items on a workstation display screen, 2 and being able to retrieve 10,000 useful, typical size objects per second from external storage into memory. 3 Typical size for languages such as CLU [29, 28], Smalltalk-80 4 <ref> [17] </ref>, and Trellis 5 [38] appears to be in the range of 30 to 50 bytes, but this is 2 This number comes from informal discussion with a Smalltalk CAD tool developer at a workshop. 3 This goal came from CAD tool developers of a large computer manufacturer. 4 Smalltalk-80 is
Reference: [18] <author> GRAEFE, G., AND DEWITT, D. J. </author> <title> The EXODUS optimizer generator. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data (San Francisco, </booktitle> <address> CA, </address> <month> May </month> <year> 1987), </year> <journal> vol. </journal> <volume> 16, no. </volume> <booktitle> 3 of ACM SIGMOD Record, ACM, </booktitle> <pages> pp. 160-172. </pages>
Reference-contexts: In the interests of brevity and incisiveness we relate the Mneme design (not the prototype) to well known exemplars of the various approaches rather than attempting exhaustive enumeration of all related work. 5.1 Extensible Databases POSTGRES [42], Exodus <ref> [10, 37, 18] </ref>, and Genesis [7] take different approaches to extensibility. POSTGRES is built on the relational database model. While it has significant extensions, it does 33 not support object identity or tight language integration. It is not a lightweight system.
Reference: [19] <author> GRAY, J. N. </author> <title> Notes on database operating systems. In Operating Systems: An Advanced Course, </title> <editor> R. Bayer et al., Eds., </editor> <booktitle> Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1978. </year>
Reference-contexts: Granularity is also relevant to concurrency control, and again it is necessary to support more than one granularity. In addition to supporting multiple granularities of locks, e.g., lock hierarchies as described in <ref> [19] </ref>, or some other concurrency control technique such as timestamps or optimistic concurrency control [26], concurrency control may be needed at multiple levels of abstraction 6 [32]. <p> locking on a per-object basis is correct and allows high concurrency, one can lock in more restrictive modes (e.g., write lock when an object has only been read, in anticipation of a possible write) or in larger granularities (physical groups of objects, whole pools, or even entire files, as in <ref> [19] </ref>). This allows use of simpler and more efficient techniques to boost performance when the highest concurrency is not required. For example, when an entire design file is checked out, it is not necessary to lock each individual object within the file.
Reference: [20] <author> HORNICK, M. F., AND ZDONIK, S. B. </author> <title> A shared, segmented memory system for an object-oriented database. </title> <journal> ACM Trans. Office Inf. Syst. </journal> <volume> 5, </volume> <month> 1 (Jan. </month> <year> 1987), </year> <pages> 70-95. </pages>
Reference-contexts: Additionally, one can change the size of an object, replace it by another object, and delete it. We developed this specific object concept for several reasons, most easily discussed by considering alternatives. Perhaps the simplest notion of object, used in some well-known designs (e.g., <ref> [39, 20, 10] </ref>), is a vector of bytes alone. Our addition of attribute bits is not very profound; requiring that ids inside objects be enumerable is more interesting. <p> More narrowly construed, some interesting examples are Camelot [40], 801 [11], FAD [12], ObServer <ref> [39, 20] </ref>, and CACTIS [21]. Camelot and 801 offer different versions of persistent/recoverable virtual memory. While Camelot supports multiple servers in a distributed environment, it does not provide uniform naming throughout a system.
Reference: [21] <author> HUDSON, S., AND KING, R. CACTIS: </author> <title> A database system for specifying functionally-defined data. </title> <booktitle> In Proceedings of the Workshop on Object-Oriented Databases (Pacific Grove, </booktitle> <address> CA, </address> <month> Sept. </month> <year> 1986), </year> <booktitle> ACM, </booktitle> <pages> pp. 26-37. </pages>
Reference-contexts: More narrowly construed, some interesting examples are Camelot [40], 801 [11], FAD [12], ObServer [39, 20], and CACTIS <ref> [21] </ref>. Camelot and 801 offer different versions of persistent/recoverable virtual memory. While Camelot supports multiple servers in a distributed environment, it does not provide uniform naming throughout a system.
Reference: [22] <author> INTEL CORPORATION. </author> <title> Introduction to the iAPX 432 Architecture, Manual 171821-001. </title> <publisher> Intel Corporation, </publisher> <address> Santa Clara, CA, </address> <year> 1981. </year>
Reference-contexts: Most of the problems mentioned occur for any byte/word addressed store, regardless of whether the virtual memory is more structured, e.g., segmented as on Multics [34] or the Intel 432 system <ref> [22, 35] </ref>. Another alternative to the Mneme addressing scheme is immutable object identifiers. Sometimes provision of such identifiers is seen as equivalent to supporting object identity, though we argue that object identity and persistence of immutable names for objects are distinct ideas.
Reference: [23] <author> KERNIGHAN, B. W., AND RITCHIE, D. M. </author> <title> The C Programming Language. </title> <publisher> Prentice-Hall, </publisher> <year> 1978. </year>
Reference-contexts: There are also a number of other minor functions to handle matters such as initialization, shutdown, the error handler stack, and so forth. 3.3 Implementation The prototype is written in C <ref> [23] </ref> and has been run on the VAX/VMS, Ultrix, 10 and SunOS 11 operating systems, and should run under other systems supporting C, if they have adequate memory and disk capacity.
Reference: [24] <author> KHOSHAFIAN, S. N., AND COPELAND, G. P. </author> <title> Object identity. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (Portland, </booktitle> <address> OR, </address> <month> Sept. </month> <journal> 1986), </journal> <volume> vol. 21, no. </volume> <booktitle> 11 of ACM SIGPLAN Notices, ACM, </booktitle> <pages> pp. 406-416. </pages>
Reference-contexts: Another alternative to the Mneme addressing scheme is immutable object identifiers. Sometimes provision of such identifiers is seen as equivalent to supporting object identity, though we argue that object identity and persistence of immutable names for objects are distinct ideas. For further discussion of the concept of identity, see <ref> [24] </ref>. Note that Mneme supports identity in the sense of preserving the graph structure defined by object references, but without the most frequently used kind of name (object ids) being immutable.
Reference: [25] <author> KIM, W., BALLOU, N., BANERJEE, J., CHOU, H., GARZA, J. F., AND WOELK, D. </author> <title> Integrating an object-oriented programming system with a database system. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (San Diego, </booktitle> <address> California, </address> <month> Nov. </month> <journal> 1988), </journal> <volume> vol. 23, no. </volume> <booktitle> 11 of ACM SIGPLAN Notices, ACM, </booktitle> <pages> pp. 142-152. </pages>
Reference-contexts: Mneme in those respects, it, like the other systems, is designed for centralized rather than distributed use, and its large object identifiers and higher overhead interface make it less efficient as a platform for our persistent programming languages. 5.2 Object Oriented Databases Some relevant object oriented database systems are Orion <ref> [25] </ref>, GemStone [36], and VBase [3]. These systems are oriented toward specific languages (Lisp, Smalltalk, and C/C++, respectively). Orion and GemStone do support (single) servers, but none of the systems have Mneme's orientation toward a large distributed space of objects.
Reference: [26] <author> KUNG, H. T., AND ROBINSON, J. T. </author> <title> On optimistic methods for concurrency control. </title> <journal> ACM Trans. Database Syst. </journal> <volume> 9, </volume> <month> 4 (June </month> <year> 1981), </year> <pages> 213-226. </pages>
Reference-contexts: Granularity is also relevant to concurrency control, and again it is necessary to support more than one granularity. In addition to supporting multiple granularities of locks, e.g., lock hierarchies as described in [19], or some other concurrency control technique such as timestamps or optimistic concurrency control <ref> [26] </ref>, concurrency control may be needed at multiple levels of abstraction 6 [32]. For example, objects, which might sometimes move from segment to segment, are at a higher level of abstraction than physical segments or ranges of bytes within segments.
Reference: [27] <author> L ECLUSE, C., RICHARD, P., AND VELEZ, F. </author> <title> o 2 , an object-oriented data model. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data (Chicago, Illinois, Sept. 1988), </booktitle> <volume> vol. 17, no. </volume> <booktitle> 3 of ACM SIGMOD Record, ACM, </booktitle> <pages> pp. 424-433. </pages>
Reference-contexts: Also, these other systems are all attempts at complete database management systems, and end up being heavy weight compared with Mneme. 34 5.3 Persistent and Database Programming Languages PS-Algol [4, 5] is representative of the persistent programming languages, and E (already mentioned), O 2 <ref> [27, 6] </ref>, O++ [1, 2], and Opal (the language in the Gemstone system) of recent database programming languages. These systems are all oriented toward particular programming languages and/or data models, whereas Mneme is attempting to provide a generic substrate (possibly suitable for building some of the other systems).
Reference: [28] <author> LISKOV, B., ATKINSON, R., BLOOM, T., MOSS, E., SCHAFFERT, C., SCHEIFLER, R., AND SNYDER, A. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1981. </year>
Reference-contexts: able to do at least 100,000 references per second to fields of objects, to support dragging collections of items on a workstation display screen, 2 and being able to retrieve 10,000 useful, typical size objects per second from external storage into memory. 3 Typical size for languages such as CLU <ref> [29, 28] </ref>, Smalltalk-80 4 [17], and Trellis 5 [38] appears to be in the range of 30 to 50 bytes, but this is 2 This number comes from informal discussion with a Smalltalk CAD tool developer at a workshop. 3 This goal came from CAD tool developers of a large computer
Reference: [29] <author> LISKOV, B., SNYDER, A., ATKINSON, R., AND SCHAFFERT, C. </author> <title> Abstraction mechanisms in CLU. </title> <journal> Commun. ACM 20, </journal> <month> 8 (Aug. </month> <year> 1977), </year> <pages> 564-576. </pages>
Reference-contexts: able to do at least 100,000 references per second to fields of objects, to support dragging collections of items on a workstation display screen, 2 and being able to retrieve 10,000 useful, typical size objects per second from external storage into memory. 3 Typical size for languages such as CLU <ref> [29, 28] </ref>, Smalltalk-80 4 [17], and Trellis 5 [38] appears to be in the range of 30 to 50 bytes, but this is 2 This number comes from informal discussion with a Smalltalk CAD tool developer at a workshop. 3 This goal came from CAD tool developers of a large computer
Reference: [30] <author> MOSS, J. E. B. </author> <title> Addressing large distributed collections of persistent objects: The Mneme project's approach. </title> <booktitle> In Second International Workshop on Database Programming Languages (Gleneden Beach, </booktitle> <address> OR, June 1989), </address> <publisher> Morgan Kaufmann, </publisher> <pages> pp. 269-285. </pages> <note> Also available as University of Massachusetts, Department of Computer and Information Science Technical Report 89-68. </note>
Reference-contexts: The file concept also maps well onto existing file systems as well as the client/server model of distributed data storage and access. In addition, the model is a relatively simple one. It is useful, though, to compare it with alternative approaches. (We have presented more detailed arguments in <ref> [30] </ref>.) One alternative approach is a very large shared distributed virtual memory, where object ids are addresses naming bytes or words. Problems with that approach include lack of object semantics, difficulty in garbage collection, the need for long addresses and large pointers, and poor support for autonomy, modularity, and extensibility. <p> Larger ids will also consume more disk and network bandwidth for transmission. Further, manipulating multi-word identifiers will take more instructions. In short, identifier length has a global effect on performance. This issue is explored in more detail in <ref> [30] </ref>. Using short ids does mean that to disambiguate object ids from different files requires some sort of mapping between the form in the files (which we call persistent ids) and the form ordinarily used by clients (client ids).
Reference: [31] <author> MOSS, J. E. B. </author> <title> Working with persistent objects: To swizzle or not to swizzle. </title> <type> COINS Technical Report TR 90-38, </type> <institution> Department of Computer and Information Science, University of Massachusetts, </institution> <address> Amherst, MA, </address> <month> May </month> <year> 1990. </year> <note> Submitted for publication. </note>
Reference-contexts: This avoids the subroutine call overhead and the indirections and checks of the handle interface, but requires more care on the part of the programmer. We have explored the performance aspects of handles versus direct pointers in more depth elsewhere <ref> [31] </ref>. In brief, direct pointer access substantially boosts performance of object manipulation compared with the handle interface. <p> Thus, though Mneme performs better than ESM on most of the tests reported here, those tests are not necessarily representative of what ESM was designed to do. Most of the performance results also appear in <ref> [31] </ref>, though in the context of a somewhat different research question. 4.1 Measurement Approach We measured the prototype mostly with an instrumented program that constructs and traverses trees. <p> The program can construct and traverse non-persistent trees as well as ones stored in Mneme. It was written in C and run on a DECStation 12 3100 system; further details appear in <ref> [31] </ref>. We consider the performance of various user level operations, examining in turn: object creation, writing objects to disk, reading objects from disk, and locating and manipulating resident objects. 4.2 Creation The table below presents measured per-object creation times (except the malloc line, which is an estimate).
Reference: [32] <author> MOSS, J. E. B., GRIFFETH, N. D., AND GRAHAM, M. H. </author> <title> Abstraction in concurrency control and recovery. </title> <type> COINS Technical Report 86-20, </type> <institution> Department of Computer and Information Science, University of Massachusetts, </institution> <address> Amherst, MA, </address> <month> May </month> <year> 1986. </year>
Reference-contexts: In addition to supporting multiple granularities of locks, e.g., lock hierarchies as described in [19], or some other concurrency control technique such as timestamps or optimistic concurrency control [26], concurrency control may be needed at multiple levels of abstraction 6 <ref> [32] </ref>. For example, objects, which might sometimes move from segment to segment, are at a higher level of abstraction than physical segments or ranges of bytes within segments.
Reference: [33] <author> MOSS, J. E. B., LEBAN, B., AND CHRYSANTHIS, P. K. </author> <title> Finer grained concurrency control for the database cache. </title> <booktitle> In Proceedings of the Third International Conference on Data Engineering (Los Angeles, </booktitle> <address> CA, </address> <month> Feb. </month> <year> 1987), </year> <journal> IEEE, </journal> <pages> pp. 96-103. </pages>
Reference-contexts: We expect that logically storing the log information with the segments, but recording changes physically using techniques such as the database cache <ref> [15, 33] </ref>, will help overcome the potential performance problems. In summary, the Mneme store design includes a basic transaction facility, a transaction extension facility, and support for crash resiliency.
Reference: [34] <author> ORGANICK, E. I. </author> <title> The Multics System: An Examination of Its Structure. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1972. </year>
Reference-contexts: Most of the problems mentioned occur for any byte/word addressed store, regardless of whether the virtual memory is more structured, e.g., segmented as on Multics <ref> [34] </ref> or the Intel 432 system [22, 35]. Another alternative to the Mneme addressing scheme is immutable object identifiers. Sometimes provision of such identifiers is seen as equivalent to supporting object identity, though we argue that object identity and persistence of immutable names for objects are distinct ideas. <p> None of these systems have Mneme's goal of supporting a large, distributed, unbounded object space. 5.4 Object Stores and Persistent Memories Related work in this area could be stretched to include Multics <ref> [34] </ref> and a variety of capability architectures. More narrowly construed, some interesting examples are Camelot [40], 801 [11], FAD [12], ObServer [39, 20], and CACTIS [21]. Camelot and 801 offer different versions of persistent/recoverable virtual memory.
Reference: [35] <author> ORGANICK, E. I. </author> <title> A Programmer's View of the Intel 432. </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1983. </year>
Reference-contexts: Most of the problems mentioned occur for any byte/word addressed store, regardless of whether the virtual memory is more structured, e.g., segmented as on Multics [34] or the Intel 432 system <ref> [22, 35] </ref>. Another alternative to the Mneme addressing scheme is immutable object identifiers. Sometimes provision of such identifiers is seen as equivalent to supporting object identity, though we argue that object identity and persistence of immutable names for objects are distinct ideas.
Reference: [36] <author> PURDY, A., SCHUCHARDT, B., AND MAIER, D. </author> <title> Integrating an object server with other worlds. </title> <journal> ACM Trans. Office Inf. Syst. </journal> <volume> 5, </volume> <month> 1 (Jan. </month> <year> 1987), </year> <pages> 27-47. </pages>
Reference-contexts: those respects, it, like the other systems, is designed for centralized rather than distributed use, and its large object identifiers and higher overhead interface make it less efficient as a platform for our persistent programming languages. 5.2 Object Oriented Databases Some relevant object oriented database systems are Orion [25], GemStone <ref> [36] </ref>, and VBase [3]. These systems are oriented toward specific languages (Lisp, Smalltalk, and C/C++, respectively). Orion and GemStone do support (single) servers, but none of the systems have Mneme's orientation toward a large distributed space of objects.
Reference: [37] <author> RICHARDSON, J. E., AND CAREY, M. J. </author> <title> Programming constructs for database system implementations in EXODUS. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data (San Francisco, </booktitle> <address> CA, </address> <month> May </month> <year> 1987), </year> <journal> vol. </journal> <volume> 16, no. </volume> <booktitle> 3 of ACM SIGMOD Record, ACM, </booktitle> <pages> pp. 208-219. 40 </pages>
Reference-contexts: In the interests of brevity and incisiveness we relate the Mneme design (not the prototype) to well known exemplars of the various approaches rather than attempting exhaustive enumeration of all related work. 5.1 Extensible Databases POSTGRES [42], Exodus <ref> [10, 37, 18] </ref>, and Genesis [7] take different approaches to extensibility. POSTGRES is built on the relational database model. While it has significant extensions, it does 33 not support object identity or tight language integration. It is not a lightweight system.
Reference: [38] <author> SCHAFFERT, C., COOPER, T., BULLIS, B., KILIAN, M., AND WILPOLT, C. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In Proceedings of the Conference on Object-Oriented Programming Systems, Languages, and Applications (Portland, </booktitle> <address> OR, </address> <month> Sept. </month> <journal> 1986), </journal> <volume> vol. 21, no. </volume> <booktitle> 11 of ACM SIGPLAN Notices, ACM, </booktitle> <pages> pp. 9-16. </pages>
Reference-contexts: second to fields of objects, to support dragging collections of items on a workstation display screen, 2 and being able to retrieve 10,000 useful, typical size objects per second from external storage into memory. 3 Typical size for languages such as CLU [29, 28], Smalltalk-80 4 [17], and Trellis 5 <ref> [38] </ref> appears to be in the range of 30 to 50 bytes, but this is 2 This number comes from informal discussion with a Smalltalk CAD tool developer at a workshop. 3 This goal came from CAD tool developers of a large computer manufacturer. 4 Smalltalk-80 is a registered trademark of
Reference: [39] <author> SKARRA, A., ZDONIK, S. B., AND REISS, S. P. </author> <title> An object server for an object oriented database system. </title> <booktitle> In Proceedings of International Workshop on Object-Oriented Database Systems (Pacific Grove, </booktitle> <address> CA, </address> <month> Sept. </month> <year> 1987), </year> <booktitle> ACM, </booktitle> <pages> pp. 196-204. </pages>
Reference-contexts: Additionally, one can change the size of an object, replace it by another object, and delete it. We developed this specific object concept for several reasons, most easily discussed by considering alternatives. Perhaps the simplest notion of object, used in some well-known designs (e.g., <ref> [39, 20, 10] </ref>), is a vector of bytes alone. Our addition of attribute bits is not very profound; requiring that ids inside objects be enumerable is more interesting. <p> More narrowly construed, some interesting examples are Camelot [40], 801 [11], FAD [12], ObServer <ref> [39, 20] </ref>, and CACTIS [21]. Camelot and 801 offer different versions of persistent/recoverable virtual memory. While Camelot supports multiple servers in a distributed environment, it does not provide uniform naming throughout a system.
Reference: [40] <author> SPECTOR, A. Z., BLOCH, J. J., DANIELS, D. S., DRAVES, R. P., DUCHAMP, D., EPPINGER, J. L., MENEES, S. G., AND THOMPSON, D. S. </author> <title> The Camelot project. </title> <type> Tech. Rep. </type> <institution> CMU-CS-86-166, Department of Computer Science, Carnegie-Mellon University, </institution> <address> Pittsburgh, PA, </address> <year> 1986. </year>
Reference-contexts: None of these systems have Mneme's goal of supporting a large, distributed, unbounded object space. 5.4 Object Stores and Persistent Memories Related work in this area could be stretched to include Multics [34] and a variety of capability architectures. More narrowly construed, some interesting examples are Camelot <ref> [40] </ref>, 801 [11], FAD [12], ObServer [39, 20], and CACTIS [21]. Camelot and 801 offer different versions of persistent/recoverable virtual memory. While Camelot supports multiple servers in a distributed environment, it does not provide uniform naming throughout a system.
Reference: [41] <author> STONEBRAKER, M. </author> <title> The design of the POSTGRES storage system. </title> <booktitle> In Proceedings of the Thirteenth International Conference on Very Large Databases (Brighton, </booktitle> <address> England, Sept. 1987), </address> <publisher> Morgan Kaufmann, </publisher> <pages> pp. 289-300. </pages>
Reference-contexts: In Mneme we chose to adapt the recovery methods of the POSTGRES storage manager <ref> [41] </ref>. The idea is to locate (insofar as possible) log information pertaining to a particular segment of data in that same segment, with the only global log being the record of committed transactions.
Reference: [42] <author> STONEBRAKER, M., AND ROWE, L. A. </author> <title> The design of POSTGRES. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data (Washington, </booktitle> <address> D.C., </address> <month> May </month> <year> 1986), </year> <booktitle> ACM SIGMOD Record, ACM, </booktitle> <pages> pp. 340-355. </pages>
Reference-contexts: In the interests of brevity and incisiveness we relate the Mneme design (not the prototype) to well known exemplars of the various approaches rather than attempting exhaustive enumeration of all related work. 5.1 Extensible Databases POSTGRES <ref> [42] </ref>, Exodus [10, 37, 18], and Genesis [7] take different approaches to extensibility. POSTGRES is built on the relational database model. While it has significant extensions, it does 33 not support object identity or tight language integration. It is not a lightweight system.
Reference: [43] <author> STROUSTRUP, B. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <year> 1986. </year>
Reference-contexts: The Genesis technology might possibly be used to build something like Mneme, but usually general routines composed together do not perform as well as a hand coded implementation. Exodus takes more of a language approach to extensibility. Its architecture includes the E language, an extension of C++ <ref> [43] </ref>. Of the extensible database systems, Exodus is the one most similar to Mneme, but the fairest comparison is between Mneme and the Exodus storage manager (as opposed to other components of the Exodus system).
Reference: [44] <author> WEIHL, W., AND LISKOV, B. </author> <title> Implementation of resilient, atomic data types. </title> <journal> ACM Trans. Program. Lang. Syst. </journal> <volume> 7, </volume> <month> 2 (Apr. </month> <year> 1985), </year> <pages> 244-269. 41 </pages>
Reference-contexts: The short exclusive-mode lock is used for locking the data structure containing lock and scheduling information for the user-defined locks, similar to the techniques of <ref> [44] </ref>. While this approach is fully general, interesting performance questions remain, such as how best to cache volatile objects, which can be treated differently by different volatile pool strategies. Notification is required to support continuation after waiting for a transaction to change state (abort, commit, etc.).
References-found: 44

