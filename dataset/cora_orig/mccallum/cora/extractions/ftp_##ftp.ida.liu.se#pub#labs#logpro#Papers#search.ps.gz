URL: ftp://ftp.ida.liu.se/pub/labs/logpro/Papers/search.ps.gz
Refering-URL: http://meryl.csd.uu.se/~rolandb/papers/index.html
Root-URL: 
Email: Email:bol@win.tue.nl  Email: larde@ida.liu.se  
Title: The Underlying Search for Magic Templates and Tabulation  
Author: Roland Bol Lars Degerstedt 
Address: HG 8.88, P.O.Box 513 NL 5600 MB Eindhoven, Netherlands  S-581 83 Linkoping, Sweden  
Affiliation: Technische Universiteit Eindhoven  IDA, Linkoping University  
Abstract: The main aim of this paper is to present a framework for tabulated SLD-resolution that allows a strict separation between search space and search. We introduce the notion of a search forest to model the search space, and we define what we understand by a search strategy for it. We present some basic search strategies and discuss how a particular tabulation technique, OLDT-resolution, and a particular transformation technique, Magic Templates, relate to our approach. This comparison also reveals an inherent difference between the tabulation and the transformation approach. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Bancilhon, D. Maier, Y. Sagiv, and J. Ullman. </author> <title> Magic sets and other strange ways to implement logic programs. </title> <booktitle> In Proc. of the Fifth Symposium on Principles of Database Systems, </booktitle> <year> 1986. </year>
Reference-contexts: We can divide these methods in two groups. One idea is to perform a bottom-up computation, but on a transformed program <ref> [1] </ref>. The transformation depends on the query and introduces goal-orientedness. One such method is known as "Magic Templates" [16]. The other idea is to add so-called tabulation [20] (memo-ing [6], lemma resolution [21]) to SLD-resolution.
Reference: [2] <author> R.N. Bol and L. Degerstedt. </author> <title> The underlying search for magic templates and tabulation. </title> <type> Technical Report LiTH-IDA-R-93-01, </type> <institution> IDA, Linkoping University, </institution> <year> 1993. </year>
Reference-contexts: Bottom-up computation on a transformed program is conceptually diverging from SLD-resolution, while tabulation is not. Also, the transformed program introduces its own search space with new relations, thus hiding the search space of the original program. However, it is shown in <ref> [2, 18] </ref> that the two methods perform essentially the same computation (modulo some small details, which we will see later): both methods are "equally" goal-oriented. A disadvantage common to both methods is that their current formulation does not separate the search space from the search strategy. <p> Only now it is also prescribed where the answer must be applied, namely, at the solution node. forests) also reveals the exact relationship between the two. In contrast to <ref> [2, 18] </ref>, we show not only that they are essentially doing the same computation, but also where they differ. Future work will proceed along two lines. The first involves more detailed (case-)studies of search strategies.
Reference: [3] <author> F. Bry. </author> <title> Query evaluation in recursive databases: Bottom-up and top-down reconciled. </title> <booktitle> In Proc. of the First International Conference on Deductive and Object-Oriented Databases, </booktitle> <year> 1989. </year>
Reference-contexts: Secondly, we are currently extending the framework to incorporate negation, aiming at soundness (and where possible completeness) w.r.t. the well founded model semantics [8, 15]. In order to be prepared for the incorporation of constructive negation <ref> [3, 7] </ref> into our framework, we treat positive and negative literals symmetrically. This means that we do not impose a "positivistic" computation rule [14, 17] (i.e., one that always prefers positive literals).
Reference: [4] <author> D. Chan. </author> <title> Constructive negation based on the completed database. </title> <booktitle> In Kowalski and Bowen [10], </booktitle> <pages> pages 111-125. </pages>
Reference-contexts: Moreover, in contrast to extensions of OLDT-resolution for stratified programs [9, 19], we maintain only one table, where the entry for an atom can be used either positively or negatively. This is the main point where our research deviates from <ref> [4, 5] </ref>. Acknowledgments We thank W lodzimierz Drabent, Ulf Nilsson, Halina Przymusinska, Teodor Przymusinski and David S. Warren for many valuable discussions. This research was carried out while the first author visited Linkoping University, supported by the Netherlands Organization for Scientific Research (NWO).
Reference: [5] <author> W. Chen and D. S. Warren. </author> <title> A goal-oriented approach to computing well founded semantics. </title> <editor> In K. R. Apt, editor, </editor> <booktitle> Proc. of the Joint International Conference and Symposium on Logic Programming, </booktitle> <pages> pages 589-603, </pages> <address> Washington, 1992. </address> <publisher> ALP, MIT Press. </publisher>
Reference-contexts: If such a tree is not yet present, we add it; initially it consists of just this root. 2 A similar construction was independently proposed in <ref> [5] </ref>. See also Section 6. From now on, we shall refer to "a tree of which the root is a B-instantiation of a program clause" as a tree for B (which program is involved shall always be clear from the context). <p> The following definition shows how an OLDT construction sequence fT g i defines a sequence of multiforests fF g i , together with a sequence fg i of bijections that provide this correspondence between the nodes of the OLDT-trees and the nodes of the multiforests. 5 In <ref> [5] </ref>, the situation is slightly different. There the roots of trees are of the form A A. <p> Moreover, in contrast to extensions of OLDT-resolution for stratified programs [9, 19], we maintain only one table, where the entry for an atom can be used either positively or negatively. This is the main point where our research deviates from <ref> [4, 5] </ref>. Acknowledgments We thank W lodzimierz Drabent, Ulf Nilsson, Halina Przymusinska, Teodor Przymusinski and David S. Warren for many valuable discussions. This research was carried out while the first author visited Linkoping University, supported by the Netherlands Organization for Scientific Research (NWO).
Reference: [6] <author> W. Chen and D. S. Warren. </author> <title> A practical approach to computing the well founded semantics. </title> <type> Technical Report 92-CSE-9, </type> <institution> Southern Methodist University, </institution> <year> 1992. </year>
Reference-contexts: One idea is to perform a bottom-up computation, but on a transformed program [1]. The transformation depends on the query and introduces goal-orientedness. One such method is known as "Magic Templates" [16]. The other idea is to add so-called tabulation [20] (memo-ing <ref> [6] </ref>, lemma resolution [21]) to SLD-resolution. In its simplest form, this involves storing intermediate results (lemmas) in a table, and looking up these tabled results instead of recomputing them.
Reference: [7] <author> S. W. Dietrich. </author> <title> Extension tables: Memo relations in logic programming. </title> <booktitle> In Proc. of the 1987 Symposium on Logic Programming, </booktitle> <pages> pages 264-273, </pages> <address> San Francisco, </address> <month> August - September </month> <year> 1987. </year> <title> IEEE, </title> <publisher> Computer Society Press. </publisher>
Reference-contexts: Secondly, we are currently extending the framework to incorporate negation, aiming at soundness (and where possible completeness) w.r.t. the well founded model semantics [8, 15]. In order to be prepared for the incorporation of constructive negation <ref> [3, 7] </ref> into our framework, we treat positive and negative literals symmetrically. This means that we do not impose a "positivistic" computation rule [14, 17] (i.e., one that always prefers positive literals).
Reference: [8] <author> W. Drabent. </author> <title> What is failure? An approach to constructive negation. </title> <type> Draft, </type> <year> 1992. </year> <note> Provisionally accepted by Acta Informatica. </note>
Reference-contexts: Secondly, we are currently extending the framework to incorporate negation, aiming at soundness (and where possible completeness) w.r.t. the well founded model semantics <ref> [8, 15] </ref>. In order to be prepared for the incorporation of constructive negation [3, 7] into our framework, we treat positive and negative literals symmetrically. This means that we do not impose a "positivistic" computation rule [14, 17] (i.e., one that always prefers positive literals).
Reference: [9] <author> A. van Gelder, K. Ross, and J. Schlipf. </author> <title> The well-founded semantics for general logic programs. </title> <journal> J. of the ACM, </journal> <volume> 38(3) </volume> <pages> 620-650, </pages> <year> 1991. </year>
Reference-contexts: This means that we do not impose a "positivistic" computation rule [14, 17] (i.e., one that always prefers positive literals). Moreover, in contrast to extensions of OLDT-resolution for stratified programs <ref> [9, 19] </ref>, we maintain only one table, where the entry for an atom can be used either positively or negatively. This is the main point where our research deviates from [4, 5]. Acknowledgments We thank W lodzimierz Drabent, Ulf Nilsson, Halina Przymusinska, Teodor Przymusinski and David S.
Reference: [10] <author> D. B. Kemp and R. W. Topor. </author> <title> Completeness of a top-down query evaluation procedure for stratified databases. </title> <booktitle> In Kowalski and Bowen [10], </booktitle> <pages> pages 178-194. </pages>
Reference: [11] <editor> R. A. Kowalski and K. A. Bowen, editors. </editor> <booktitle> Proc. of the Fifth International Conference and Symposium on Logic Programming, </booktitle> <address> Seattle, 1988. </address> <publisher> ALP, MIT Press. </publisher>
Reference-contexts: The top-down methods are perhaps the most intuitive ones, because their starting point is the query: they are goal-oriented . As a result they will not compute irrelevant facts, but intermediate results that are needed several times can be computed again and again, e.g., in SLD-resolution <ref> [11] </ref>. The well-known SLD-tree provides a nice separation between the search space: what has to be computed, and search strategies: the order of the computation. SLD-resolution is complete, i.e., all correct answers are represented in an SLD-tree.
Reference: [12] <author> J. W. Lloyd. </author> <note> Foundations of Logic Programming. Springer-Verlag, second, extended edition, </note> <year> 1987. </year>
Reference-contexts: In order to distinguish these derived clauses from program clauses, we refer to them as resultants <ref> [12] </ref>. In particular, we refer to resultants with empty bodies as answers. We assume the existence of a fixed computation rule R, which selects one atom in the body of every resultant that is not an answer. Definition 3.2 Let P be a program and A an atom.
Reference: [13] <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial evaluation in logic programming. </title> <journal> J. of Logic Programming, </journal> <volume> 11(3 </volume> & 4):217-242, October/November 1991. 
Reference-contexts: In particular, we will no go into the role of "sideways information passing strategies" (SIPs) [16, 18], but only consider the SIP that corresponds to the leftmost computation rule. We now give a short description of the Magic Templates approach, following closely the presentation in <ref> [13] </ref>. Let P be a program and A an atom of the form p (t 1 ; : : : ; t n ).
Reference: [14] <author> U. Nilsson. </author> <title> Abstract interpretation: A kind of Magic. </title> <booktitle> In Programming Language Implementation and Logic Programming 91, Lecture Notes in Computer Science 528, </booktitle> <pages> pages 299-309. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year> <note> Extended version to appear in Theoretical Computer Science. </note>
Reference-contexts: In order to be prepared for the incorporation of constructive negation [3, 7] into our framework, we treat positive and negative literals symmetrically. This means that we do not impose a "positivistic" computation rule <ref> [14, 17] </ref> (i.e., one that always prefers positive literals). Moreover, in contrast to extensions of OLDT-resolution for stratified programs [9, 19], we maintain only one table, where the entry for an atom can be used either positively or negatively.
Reference: [15] <author> T. Przymusinski. </author> <title> Every logic program has a natural stratification and an iterated fixed point model. </title> <booktitle> In Proc. of the 8th Symposium on Principles of Database Systems, </booktitle> <pages> pages 11-21. </pages> <booktitle> ACM SIGACT-SIGMOD, </booktitle> <year> 1989. </year>
Reference-contexts: Secondly, we are currently extending the framework to incorporate negation, aiming at soundness (and where possible completeness) w.r.t. the well founded model semantics <ref> [8, 15] </ref>. In order to be prepared for the incorporation of constructive negation [3, 7] into our framework, we treat positive and negative literals symmetrically. This means that we do not impose a "positivistic" computation rule [14, 17] (i.e., one that always prefers positive literals).
Reference: [16] <author> T. C. Przymusinski and D. S. Warren. </author> <title> Well founded semantics: Theory and implementation. </title> <type> Draft, </type> <year> 1992. </year>
Reference-contexts: We can divide these methods in two groups. One idea is to perform a bottom-up computation, but on a transformed program [1]. The transformation depends on the query and introduces goal-orientedness. One such method is known as "Magic Templates" <ref> [16] </ref>. The other idea is to add so-called tabulation [20] (memo-ing [6], lemma resolution [21]) to SLD-resolution. In its simplest form, this involves storing intermediate results (lemmas) in a table, and looking up these tabled results instead of recomputing them. <p> Rather should we see the framework as an "undeter-ministic procedure", which can be made deterministic by adding a certain "construction strategy". 3 Magic Templates and Deduction Sets In this section, we introduce the other starting point of this paper: "magic" bottom-up computation. In particular, we focus on Magic Templates <ref> [16] </ref>. Whereas OLDT-resolution has in some sense "too much structure", the Magic Templates method appears to have too little. Therefore we present deduction sets as a reformulation of the method with some more structure. <p> In this way, we will arrive at our final framework: the search forest. 3.1 Magic Templates As with OLDT-resolution, we will not discuss Magic Templates in full generality. In particular, we will no go into the role of "sideways information passing strategies" (SIPs) <ref> [16, 18] </ref>, but only consider the SIP that corresponds to the leftmost computation rule. We now give a short description of the Magic Templates approach, following closely the presentation in [13].
Reference: [17] <author> R. Ramakrishnan. </author> <title> Magic Templates: A spellbinding approach to logic programs. </title> <booktitle> In Kowalski and Bowen [10], </booktitle> <pages> pages 140-159. </pages>
Reference-contexts: In order to be prepared for the incorporation of constructive negation [3, 7] into our framework, we treat positive and negative literals symmetrically. This means that we do not impose a "positivistic" computation rule <ref> [14, 17] </ref> (i.e., one that always prefers positive literals). Moreover, in contrast to extensions of OLDT-resolution for stratified programs [9, 19], we maintain only one table, where the entry for an atom can be used either positively or negatively.
Reference: [18] <author> K. Ross. </author> <title> A procedural semantics for well founded negation in logic programs. </title> <booktitle> In Proc. of the 8th Symposium on Principles of Database Systems, </booktitle> <pages> pages 22-33. </pages> <booktitle> ACM SIGACT-SIGMOD, </booktitle> <year> 1989. </year>
Reference-contexts: Bottom-up computation on a transformed program is conceptually diverging from SLD-resolution, while tabulation is not. Also, the transformed program introduces its own search space with new relations, thus hiding the search space of the original program. However, it is shown in <ref> [2, 18] </ref> that the two methods perform essentially the same computation (modulo some small details, which we will see later): both methods are "equally" goal-oriented. A disadvantage common to both methods is that their current formulation does not separate the search space from the search strategy. <p> In this way, we will arrive at our final framework: the search forest. 3.1 Magic Templates As with OLDT-resolution, we will not discuss Magic Templates in full generality. In particular, we will no go into the role of "sideways information passing strategies" (SIPs) <ref> [16, 18] </ref>, but only consider the SIP that corresponds to the leftmost computation rule. We now give a short description of the Magic Templates approach, following closely the presentation in [13]. <p> Only now it is also prescribed where the answer must be applied, namely, at the solution node. forests) also reveals the exact relationship between the two. In contrast to <ref> [2, 18] </ref>, we show not only that they are essentially doing the same computation, but also where they differ. Future work will proceed along two lines. The first involves more detailed (case-)studies of search strategies.
Reference: [19] <author> H. Seki. </author> <title> On the power of Alexander Templates. </title> <booktitle> In Proc. of the 8th Symposium on Principles of Database Systems. ACM SIGACT-SIGMOD, </booktitle> <year> 1989. </year>
Reference-contexts: This means that we do not impose a "positivistic" computation rule [14, 17] (i.e., one that always prefers positive literals). Moreover, in contrast to extensions of OLDT-resolution for stratified programs <ref> [9, 19] </ref>, we maintain only one table, where the entry for an atom can be used either positively or negatively. This is the main point where our research deviates from [4, 5]. Acknowledgments We thank W lodzimierz Drabent, Ulf Nilsson, Halina Przymusinska, Teodor Przymusinski and David S.
Reference: [20] <author> H. Seki and H. Itoh. </author> <title> A query evaluation method for stratified programs under the extended CWA. </title> <booktitle> In Kowalski and Bowen [10], </booktitle> <pages> pages 195-211. </pages>
Reference-contexts: We can divide these methods in two groups. One idea is to perform a bottom-up computation, but on a transformed program [1]. The transformation depends on the query and introduces goal-orientedness. One such method is known as "Magic Templates" [16]. The other idea is to add so-called tabulation <ref> [20] </ref> (memo-ing [6], lemma resolution [21]) to SLD-resolution. In its simplest form, this involves storing intermediate results (lemmas) in a table, and looking up these tabled results instead of recomputing them. <p> Moreover, it will facilitate the analysis of their behavior, in particular the prediction and explanation of their incompletenesses, if any. The plan of this paper is as follows. In Section 2 we give the traditional presentation of OLDT-resolution <ref> [20] </ref>, a specific variant of tabulated SLD-resolution. In Section 3, we present the Magic Templates transformation and the related bottom-up computation. We also give an alternative characterization of the resulting computation by what we call deduction sets: a set of statements is expanded until it includes the (atomic) query. <p> All proofs can be found in the full version of the paper [?]. Without loss of generality, we shall assume throughout the paper that the initial query is atomic. 2 Tabulation traditional presentation The main idea of OLDT-resolution <ref> [20] </ref> is to build a table during the search of an OLD-tree (i.e., an SLD-tree constructed using the leftmost computation rule). In the table we store answers obtained for subgoals. These answers are to be used later, where ordinary OLD-resolution would recompute that subgoal. <p> The example shows that the discussion on "search strategies" in <ref> [20] </ref> is a little suspect: there is no explicit common search space for all strategies in this framework .
Reference: [21] <author> H. Tamaki and T. Sato. </author> <title> OLD resolution with tabulation. </title> <editor> In E. Shapiro, editor, </editor> <booktitle> Proc. of the Third International Conference on Logic Programming, Lecture Notes in Computer Science 225, </booktitle> <pages> pages 84-98, </pages> <address> London, 1986. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: One idea is to perform a bottom-up computation, but on a transformed program [1]. The transformation depends on the query and introduces goal-orientedness. One such method is known as "Magic Templates" [16]. The other idea is to add so-called tabulation [20] (memo-ing [6], lemma resolution <ref> [21] </ref>) to SLD-resolution. In its simplest form, this involves storing intermediate results (lemmas) in a table, and looking up these tabled results instead of recomputing them. <p> Thus it is important that, when an atom is selected in a goal, it is resolved completely before any other atom is selected, in order to avoid "mixing" the answers for the two atoms. In other words, the computation rule must be local <ref> [21] </ref>. The leftmost computation rule satisfies this property. OLDT-resolution formalizes this idea in the following way 1 . An OLDT-structure is a triple consisting of an OLDT-tree, a solution table, and a lookup table.
Reference: [22] <author> L. Vieille. </author> <title> Recursive query processing: the power of logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(1) </volume> <pages> 1-53, </pages> <year> 1989. </year>
References-found: 22

