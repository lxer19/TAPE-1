URL: ftp://ftp.research.microsoft.com/pub/tr/tr-98-22.ps
Refering-URL: http://www.research.microsoft.com/~tedb/interest.htm
Root-URL: http://www.research.microsoft.com
Title: Composite Folding and Optimization in Domain Specific Translation  
Author: Ted J. Biggerstaff 
Address: One Microsoft Way Redmond, WA 98052  
Affiliation: Microsoft Research Microsoft Corporation  
Date: June, 1998  
Abstract: Technical Report MSR-TR-98-22 Copyright 1998, Microsoft Corporation. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> David F. Bacon, Susan L. Graham, and Oliver J. Sharp, </author> <title> Compiler Transformations for High-Performance Computing, </title> <journal> ACM Surveys, </journal> <volume> Vol. 26, No. 4, </volume> <month> December, </month> <year> 1994. </year>
Reference-contexts: components. - 10 - Copyright, Microsoft, 1998 Other generation methods are largely orthogonal but complementary to the AO aspect of the generation problem. [2, 14] 5.2 Conventional optimization techniques Each of the optimizations that I have discussed in the AO method have their analogs in the conventional programming language domain <ref> [1] </ref> with the fundamental difference being that AO achieves the optimizations directly on the domain specific forms without deep program analysis. Conventional optimization, on the other hand, must recover the flow and dependency information via complex analysis techniques that induce large, open-ended searches.
Reference: [2] <author> Don Batory, Vivek Singhal, Marty Sirkin, and Jeff Thomas, </author> <title> Scalable Software Libraries, </title> <booktitle> Symposium on the Foundations of Software Engineering. </booktitle> <address> Los Angeles, CA, </address> <month> December, </month> <year> 1993. </year>
Reference-contexts: This factoring means that the individual optimization pieces are themselves reusable over many past and future reusable code components. - 10 - Copyright, Microsoft, 1998 Other generation methods are largely orthogonal but complementary to the AO aspect of the generation problem. <ref> [2, 14] </ref> 5.2 Conventional optimization techniques Each of the optimizations that I have discussed in the AO method have their analogs in the conventional programming language domain [1] with the fundamental difference being that AO achieves the optimizations directly on the domain specific forms without deep program analysis.
Reference: [3] <author> Ted J. Biggerstaff, </author> <title> The Library Scaling Problem and The Limits of Concrete Component Reuse, </title> <booktitle> International Conference on Software Reuse, </booktitle> <month> November, </month> <year> 1994. </year>
Reference: [4] <author> Ted J. Biggerstaff, </author> <title> Anticipatory Optimization in Domain Specific Translation, </title> <booktitle> International Conference on Software Reuse, </booktitle> <month> June, </month> <year> 1998a. </year>
Reference-contexts: We will come back to this subject later in the example. The loop fusion phase is treated in greater detail in <ref> [4] </ref> and we will not consider it further in this paper.
Reference: [5] <author> Ted J. Biggerstaff, </author> <title> A Perspective of Generative Reuse, </title> <journal> Annals of Software Engineering, </journal> <year> 1998b. </year>
Reference: [6] <author> Ted J. Biggerstaff, </author> <title> Delocalization vs Performance: The Dilemma of Domain Translation, </title> <booktitle> International Conference on Software Reuse, </booktitle> <month> June, </month> <year> 1998c. </year>
Reference: [7] <author> L. J. Guibas and D. K. Wyatt, </author> <title> Compilation and Delayed Evaluation in APL, </title> <booktitle> Fifth ACM Symposium Principles of Programming Languages, </booktitle> <pages> pp. 1-8, </pages> <year> 1978. </year>
Reference-contexts: Further, conventional optimization often misses opportunities for optimizations because of the difficulty of the associated inference problems (e.g., alias analysis). AO avoids these difficulties by recasting the problem into a form handled by simpler and more effective methods. The optimization techniques used in APL <ref> [7] </ref> perform loop fusion like optimization on their built-in data types but provide no way to achieve similar optimization on domain specific types that are not built-in. 5.3 Other transformational approaches Other transformational approaches are often based on some set of general (i.e., not domain specific) technological underpinnings such as functional
Reference: [8] <author> Neil D. Jones, </author> <title> An Introduction to Partial Evaluation, </title> <journal> ACM Computing Surveys, </journal> <volume> Vol. 28, No. 3, </volume> <month> Sept. </month> <year> 1996. </year>
Reference-contexts: like optimization on their built-in data types but provide no way to achieve similar optimization on domain specific types that are not built-in. 5.3 Other transformational approaches Other transformational approaches are often based on some set of general (i.e., not domain specific) technological underpinnings such as functional programming, partial evaluation <ref> [8] </ref>, lazy transformations, or particular transformation algorithms. A good example of this class is the Deforestation technique of Wadler [15], which uses a set of transformations to remove intermediate computational forms in a functional programming context, i.e., remove temporary lists and trees.
Reference: [9] <author> Gregor Kiczales, John Lamping, Anurag Mendhekar, Chris Maede, Cristina Lopes, Jean-Marc Loingtier and John Irwin, </author> <title> Aspect Oriented Programming, </title> <type> Tech. </type> <note> Report SPL97-08 P9710042, Xerox PARC, </note> <year> 1997. </year>
Reference-contexts: Aspect Oriented Programming (AOP) shares with AO the intention and the accomplishment of reweaving code for efficiency. <ref> [9] </ref> The main difference appears to be that in AOP the optimization plan is a centralized a reweaving algorithm and in AO the plan is factored into a set of separate optimization plan pieces that are distributed over the program in the form of annotation tags.
Reference: [10] <author> S. Letovsky, E. Soloway, </author> <title> Delocalized Plans and Program Comprehension, </title> <journal> IEEE Software, </journal> <month> May, </month> <year> 1986. </year>
Reference-contexts: The central difficulty revolves around delocalization of information. <ref> [10] </ref> If I factor the operators and operands into highly general constructs, I can write combinatorially many compact expressions with them that effectively form an infinite virtual library of reusable components, one component for each possible composite expression.
Reference: [11] <author> James M. Neighbors, </author> <title> Software Construction Using Components, </title> <type> Ph.D. Dissertation, </type> <institution> Univ. of Calif. at Irvine, </institution> <year> 1980. </year>
Reference-contexts: similar techniques. 5.1 Generation systems The Draco program generation system shares the domain oriented optimization philosophy of AO, but while it does perform many powerful domain specific optimizations, it does not use AO-like optimization methods or distributed optimization plans for melding and reweaving portions of the code (e.g., loop prefixes). <ref> [11, 12] </ref> To accomplish similar optimizations, Draco would face a large solution search space or need to resort to programmer intervention and guidance.
Reference: [12] <author> James M. Neighbors, </author> <title> Draco: A Method for Engineering Reusable Software Systems. </title> <editor> In Ted J. Biggerstaff and Alan Perlis (Eds.), </editor> <booktitle> Software Reusability, </booktitle> <publisher> Addison-Wesley/ACM Press, </publisher> <year> 1989. </year>
Reference-contexts: similar techniques. 5.1 Generation systems The Draco program generation system shares the domain oriented optimization philosophy of AO, but while it does perform many powerful domain specific optimizations, it does not use AO-like optimization methods or distributed optimization plans for melding and reweaving portions of the code (e.g., loop prefixes). <ref> [11, 12] </ref> To accomplish similar optimizations, Draco would face a large solution search space or need to resort to programmer intervention and guidance.
Reference: [13] <author> G. X. Ritter and J. N Wilson, </author> <title> Handbook of Computer Vision Algorithms in Image Algebra, </title> <publisher> CRC Press, </publisher> <year> 1996. </year>
Reference-contexts: which cross operator and cross expression code is already localized for performance reasons, the number of possible variations that can be produced by my generator drops precipitously and my infinite virtual library very likely becomes a finite library. [3-6] An example of this delocalization is illustrated by the Image Algebra <ref> [13] </ref> expression for Sobel edge detection in bitmapped images [ 4-6].
Reference: [14] <author> Douglas R. Smith, </author> <title> KIDSA Knowledge-Based Software Development System, in Automating Software Design, </title> <editor> M. Lowry & R. McCartney, Eds., </editor> <publisher> AAAI/MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: This factoring means that the individual optimization pieces are themselves reusable over many past and future reusable code components. - 10 - Copyright, Microsoft, 1998 Other generation methods are largely orthogonal but complementary to the AO aspect of the generation problem. <ref> [2, 14] </ref> 5.2 Conventional optimization techniques Each of the optimizations that I have discussed in the AO method have their analogs in the conventional programming language domain [1] with the fundamental difference being that AO achieves the optimizations directly on the domain specific forms without deep program analysis.
Reference: [15] <author> Philip Wadler, </author> <title> Deforestation: Transforming Programs to Eliminate Trees, </title> <journal> Journal of Theoretical Computer Science, </journal> <volume> Vol. 73, </volume> <pages> pp. 231-248, </pages> <year> 1990. </year>
Reference-contexts: A good example of this class is the Deforestation technique of Wadler <ref> [15] </ref>, which uses a set of transformations to remove intermediate computational forms in a functional programming context, i.e., remove temporary lists and trees. Such transformation systems emphasize broad generality in the application domain and it is unclear what negative effects such generality will have on the solution search space.
References-found: 15

