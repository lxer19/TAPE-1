URL: file://ftp.di.unipi.it/pub/Papers/meo/CompSem94.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: bossi@pdmat1.unipd.it  fgabbri,levi,meog@di.unipi.it  
Phone: 2)  
Title: A Compositional Semantics for Logic Programs  
Author: A. Bossi M. Gabbrielli G. Levi and M.C. Meo 
Address: Via Belzoni 7, I-35131 Padova, Italy  Corso Italia 40, 56125 Pisa, Italy  
Affiliation: 1) Dipartimento di Matematica Pura ed Applicata Universita di Padova  Dipartimento di Informatica Universita di Pisa  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> K. R. Apt. </author> <title> Introduction to Logic Programming. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, volume B: Formal Models and Semantics. </booktitle> <publisher> Elsevier, Amsterdam and The MIT Press, </publisher> <address> Cambridge, </address> <year> 1990. </year>
Reference-contexts: Some proofs are deferred to the appendix. A preliminary short version of this paper appeared in [6]. 1.1 Preliminaries The reader is assumed to be familiar with the terminology of and the basic results in the semantics of logic programs <ref> [44, 1] </ref>. Let the signature S consist of a set F of function symbols, a finite set of predicate symbols, a denumerable set V of variable symbols. All the definitions in the following will assume a given signature S. <p> By the independence from the selection rule for SLD refutations <ref> [44, 1] </ref>, we can assume that the selection of the atoms is performed according to the following rule denoted by S 1. select first the non-open atoms (i.e. the p ( ~ t)'s such that p 62 ) 2. among the non-open atoms, select first those which are added to the
Reference: [2] <author> R. Barbuti, M. Codish, R. Giacobazzi, and G. Levi. </author> <title> Modelling Prolog Control. </title> <booktitle> In Proc. Nineteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 95-104. </pages> <publisher> ACM Press, </publisher> <year> 1992. </year>
Reference-contexts: A satisfactory solution even to the simple case of positive logic programs is needed to gain a better understanding of more practical languages, such as real Prolog <ref> [2] </ref> and its purely declarative counterparts. A partial solution was the s-semantics [18, 19], which was the first (non-compositional) semantics correct wrt computed answers and which used sets of unit clauses as semantic domain. In this paper we extend the s-semantics approach to compositionality, starting from the results in [7].
Reference: [3] <author> R. Barbuti, R. Giacobazzi, and G. Levi. </author> <title> A General Framework for Semantics based Bottom-up Abstract Interpretation of Logic Programs. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 15, </volume> <year> 1993. </year>
Reference-contexts: The need for better semantics was also recognized in the case of semantics-based abstract interpretation <ref> [48, 37, 11, 3] </ref> and transformation [36, 5], where, as already mentioned, less abstract observables, such as partial computed answers or call patterns, have sometimes to be modeled. The same problem was even earlier recognized in relation to some extensions of pure logic programming.
Reference: [4] <author> A. Bossi, M. Bugliesi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Differential logic programming. </title> <booktitle> In Proc.Twentieth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 359-370. </pages> <publisher> ACM Press, </publisher> <year> 1993. </year>
Reference-contexts: Of course also such mechanisms are 4 interesting. For example, when considering programs structured by using inheritance operators, in some cases we want the new information to replace the old one. The specific semantic treatment for inheritance by extension and/or overriding, is in <ref> [4] </ref> and is obtained by a modification of the framework we show here. In this paper we generalize the semantics given in [7] for -open programs, following the general approach in [23]. <p> Modified versions of O (P ) allow to obtain semantics compositional wrt various composition operators. A semantic compositional wrt a generalized inheritance operator is obtained in <ref> [4] </ref>. Static and dynamic extension/overriding mechanisms can be expressed using the generalized operator. Since the semantic domains are (equivalence classes of) clauses we have a uniform treatment of static and dynamic inheritance, which in other compositional semantics [9] require different semantic objects to coexist. Moreover, the semantics in [4] is the <p> obtained in <ref> [4] </ref>. Static and dynamic extension/overriding mechanisms can be expressed using the generalized operator. Since the semantic domains are (equivalence classes of) clauses we have a uniform treatment of static and dynamic inheritance, which in other compositional semantics [9] require different semantic objects to coexist. Moreover, the semantics in [4] is the first compositional semantics of units and inheritance which correctly models computed answer substitutions. * The open semantics can be considered as the semantic base for modular program analysis. <p> In particular this matches quite naturally the semantics of CLP and concurrent constraint programs given in [22]. 33 * The modification of the O (P ) semantics developed in <ref> [4] </ref> could be used to de velop a modular analysis for programs which are structured by using inheritance mechanisms, according to the usual object-oriented style.
Reference: [5] <author> A. Bossi and N. Cocco. </author> <title> Basic transformation operations for logic programs which preserve computed answer substitutions. </title> <journal> Journal of Logic Programming, </journal> <note> 1991. To appear. </note>
Reference-contexts: The need for better semantics was also recognized in the case of semantics-based abstract interpretation [48, 37, 11, 3] and transformation <ref> [36, 5] </ref>, where, as already mentioned, less abstract observables, such as partial computed answers or call patterns, have sometimes to be modeled. The same problem was even earlier recognized in relation to some extensions of pure logic programming.
Reference: [6] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Contributions to the Semantics of Open Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 570-580, </pages> <year> 1992. </year>
Reference-contexts: A comparison between -models and the S -models is made in section 6. Finally, section 7 discusses some applications of our semantics and points out some connections with other works. Some proofs are deferred to the appendix. A preliminary short version of this paper appeared in <ref> [6] </ref>. 1.1 Preliminaries The reader is assumed to be familiar with the terminology of and the basic results in the semantics of logic programs [44, 1].
Reference: [7] <editor> A. Bossi and M. Menegus. Una Semantica Composizionale per Programmi Logici Aperti. In P. Asirelli, editor, </editor> <booktitle> Proc. Sixth Italian Conference on Logic Programming, </booktitle> <pages> pages 95-109, </pages> <year> 1991. </year>
Reference-contexts: Over the last few years we have developed a general approach to the semantics [23], whose aim was modeling the observable behaviors, possibly in a compositional way, for a variety of logic languages, ranging from positive logic programs <ref> [18, 19, 20, 7] </ref>, to general logic programs [54, 27], constraint logic programs [22, 32] and concurrent constraint programs [24]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. <p> A partial solution was the s-semantics [18, 19], which was the first (non-compositional) semantics correct wrt computed answers and which used sets of unit clauses as semantic domain. In this paper we extend the s-semantics approach to compositionality, starting from the results in <ref> [7] </ref>. Note that all the existing OR-compositional semantics (apart from those in [31, 7]) are correct wrt successful derivations only [39, 49, 47, 46, 30]. Gaifman and Shapiro [30] first introduced an OR-compositional semantics in a proof-theoretic framework. OR-compositionality is achieved by using sets of non-unit clauses as semantic domain. <p> In this paper we extend the s-semantics approach to compositionality, starting from the results in [7]. Note that all the existing OR-compositional semantics (apart from those in <ref> [31, 7] </ref>) are correct wrt successful derivations only [39, 49, 47, 46, 30]. Gaifman and Shapiro [30] first introduced an OR-compositional semantics in a proof-theoretic framework. OR-compositionality is achieved by using sets of non-unit clauses as semantic domain. This semantics was then extended to model computed answers in [31]. <p> These characterizations are in fact useful to effectively compute approximations of the denotation, as in the case of abstract interpretation. The -semantics <ref> [7] </ref> was the first real compositional generalization of the s-semantics and was defined by a fixpoint construction. This semantics is based on the notion of -open program. An -open program P is a program in which the predicate symbols belonging to the set are considered partially defined in P . <p> The specific semantic treatment for inheritance by extension and/or overriding, is in [4] and is obtained by a modification of the framework we show here. In this paper we generalize the semantics given in <ref> [7] </ref> for -open programs, following the general approach in [23]. In the specific case of -open programs, -interpretations are called -denotations and are sets of conditional atoms, i.e., clauses such that all the atoms in the body are open. <p> In the specific case of -open programs, -interpretations are called -denotations and are sets of conditional atoms, i.e., clauses such that all the atoms in the body are open. We give a fixpoint semantics, which is a variation of the one proposed in <ref> [7] </ref>, described in terms of -denotations and an equivalent operational semantics. The resulting denotation is then characterized from the model-theoretic viewpoint, by defining a set of denotations which encompass standard Herbrand models. <p> Our -models are related to the S -models defined in <ref> [7] </ref> by means of an ad-hoc notion of truth. The remaining of this paper is organized as follows. Subsection 1.1 contains notation and useful definitions on the semantics of logic programs. In section 2 we define an operational semantics O (P ) modeling computed answer substitutions which is OR-compositional. <p> Moreover, we consider a particular kind of -models (compositional models). F (P ) is a (non-minimal) compositional -model equivalent to the model-theoretic semantics defined in <ref> [7] </ref> in terms of S -models. A suitable abstraction of O (P ) is a compositional -model which is fully abstract wrt the equivalence induced by successful derivations. A comparison between -models and the S -models is made in section 6. <p> program P = f p (X; Y ) : r (X); s (Y ): s (Y ) : q (Y ): unf P (P ) = f p (X; Y ) : s (X); q (Y ): r (X) : q (X): s (a): g Definition 4.3 (Immediate consequences operator) <ref> [7] </ref> Let P be an -open program and let I be an -denotation. Then we define T Note that, for = ;, T P is the immediate consequence operator introduced in [18] whose least fixpoint is the s-semantics. Proposition 4.4 [7] T P is monotonic and continuous on the complete lattice <p> q (X): s (a): g Definition 4.3 (Immediate consequences operator) <ref> [7] </ref> Let P be an -open program and let I be an -denotation. Then we define T Note that, for = ;, T P is the immediate consequence operator introduced in [18] whose least fixpoint is the s-semantics. Proposition 4.4 [7] T P is monotonic and continuous on the complete lattice (D; ). The notion of ordinal powers for T P is defined as usual, namely T P "0 = ;, T = T P "n) and T S P "n ). <p> Therefore, by definition 5.18, M (P )= wcf ([O (P )]) is a compositional -model of P . 30 6 S -models We will now consider the relation between -models (definition 5.3) and the S -models defined in <ref> [7] </ref> on the same set of denotations. Both the -models and the S -models are intended to capture specific operational properties, from a model-theoretic point of view. <p> Note that, by definition of S -Truth, I 2 D is an S -model of P iff unf P (I [ Id ) I. Proposition 6.2 Every S -model is an -model (according to definition 5.3). Proof Similar to that one of theorem 5.23. Proposition 6.3 <ref> [7] </ref> If fl is a non-empty set of S -models of an -open program P, then T M2fl M is an S -model of P. <p> The previous proposition allows to define the model theoretic semantics M S (P ) for a program P in terms of the S -models as follows. Definition 6.4 <ref> [7] </ref> Let P be an -open program and let S be the set of all the S -models of P . Then M S (P ) = T Corollary 6.5 Let fl be a non-empty set of S -models of an -open program P . <p> Moreover since I J implies I v J, M S (P ) is a lower bound (w.r.t. v) of S. Therefore M S (P )=glb (S). The following theorem shows the equivalence of the least S -model M S (P ) and the fixpoint semantics (definition 4.6). Theorem 6.7 <ref> [7] </ref> Let P be an -open program. Then F (P ) = M S (P ). 31 Corollary 6.8 Let P be an -open program. Then F (P ) is an -model of P . Proof Straightforward from theorem 6.7 and proposition 6.2. <p> It is worth noting that, since O (P )= F (P )= M S (P ), theorem 2.13 shows that the least S -model M S (P ) is compositional w.r.t. -union of programs when considering computed answer substitutions as observables. This result was already proved in <ref> [7] </ref> for the M S (P ) model. Finally note that, as shown by the following example, T P is not monotonic (and therefore it is not continuous) on the complete lattice (D; v).
Reference: [8] <author> A. Brogi, E. Lamma, and P. Mello. </author> <title> Open Logic Theories. </title> <editor> In P. Krueger L.-H. Eriks son and P. Shroeder-Heister, editors, </editor> <booktitle> Proc. of the Second Workshop on Extensions to Logic Programming, Lecture Notes in Artificial Intelligence. </booktitle> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: Moreover, the presence of an operational or a fixpoint semantics makes our construction useful as a formal basis for program analysis. Another related paper is <ref> [8] </ref>, where -open logic programs are called open theories. Open theories are provided with a model-theoretic semantics which is based on ideas very similar to those underlying our definition 5.1. [8] however does not consider semantic definitions in the style of our O (P ) which gives a unique denotation to <p> Another related paper is <ref> [8] </ref>, where -open logic programs are called open theories. Open theories are provided with a model-theoretic semantics which is based on ideas very similar to those underlying our definition 5.1. [8] however does not consider semantic definitions in the style of our O (P ) which gives a unique denotation to any open program and does not consider computed answers as observables. Our -semantics O (P ) has already been used for several applications.
Reference: [9] <author> M. Bugliesi. </author> <title> A Declarative View of Inheritance in Logic Programming. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. Joint Int'l Conf. and Symposium on Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: A semantic compositional wrt a generalized inheritance operator is obtained in [4]. Static and dynamic extension/overriding mechanisms can be expressed using the generalized operator. Since the semantic domains are (equivalence classes of) clauses we have a uniform treatment of static and dynamic inheritance, which in other compositional semantics <ref> [9] </ref> require different semantic objects to coexist. Moreover, the semantics in [4] is the first compositional semantics of units and inheritance which correctly models computed answer substitutions. * The open semantics can be considered as the semantic base for modular program analysis.
Reference: [10] <author> K. L. Clark. </author> <title> Predicate logic as a computational formalism. Res. </title> <type> Report DOC 79/59, </type> <institution> Imperial College, Dept. of Computing, </institution> <address> London, </address> <year> 1979. </year>
Reference-contexts: This is the reason why the need for a different formal semantics, correct wrt answer substitutions, was recognized by many authors, giving rise to several new definitions (see, for example, <ref> [10, 21, 57, 18, 31] </ref>). The need for better semantics was also recognized in the case of semantics-based abstract interpretation [48, 37, 11, 3] and transformation [36, 5], where, as already mentioned, less abstract observables, such as partial computed answers or call patterns, have sometimes to be modeled.
Reference: [11] <author> M. Codish, D. Dams, and E. Yardeni. </author> <title> Bottom-up Abstract Interpretation of Logic Programs. </title> <type> Technical report, </type> <institution> Dept. of Computer Science, The Weizmann Institute, Rehovot, </institution> <year> 1990. </year> <note> To appear in Theoretical Computer Science. 34 </note>
Reference-contexts: The need for better semantics was also recognized in the case of semantics-based abstract interpretation <ref> [48, 37, 11, 3] </ref> and transformation [36, 5], where, as already mentioned, less abstract observables, such as partial computed answers or call patterns, have sometimes to be modeled. The same problem was even earlier recognized in relation to some extensions of pure logic programming.
Reference: [12] <author> M. Codish, S. K. Debray, and R. Giacobazzi. </author> <title> Compositional Analysis of Modular Logic Programs. </title> <booktitle> In Proc.Twentieth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <year> 1993. </year>
Reference-contexts: Modularity helps considerably in reducing the complexity of analysis and in proving correctness of programs, since it allows an incremental and structured specification and verification of the software. A first use of our semantics for modular analysis is in <ref> [12] </ref>. Let finally remark some other interesting properties of the -semantics O (P ) which could be further investigated. * By means of a syntactic device, we obtain a unique representation for a possibly infinite set of Herbrand models when a unique representative Herbrand model does not exist.
Reference: [13] <author> F. S. de Boer and C. Palamidessi. </author> <title> Concurrent logic languages: Asynchronism and language comparison. </title> <editor> In S. Debray and M. Hermenegildo, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'90, </booktitle> <pages> pages 99-114. </pages> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1990. </year>
Reference-contexts: For example, finding definitions modeling the observable behavior was, from the very beginning, the aim of most of the research on the semantics of concurrent logic languages (see, for example, <ref> [43, 29, 24, 53, 13] </ref>). This was primarily motivated by the fact that these languages closely resemble traditional concurrent languages, whose semantics usually model observables such as traces of input-output interactions, deadlocks, etc.
Reference: [14] <author> F. Denis and J.-P. Delahaye. </author> <title> Unfolding, Procedural and Fixpoint Semantics of Logic Programs. </title> <editor> In C. Choffrut and M. Jantzen, editors, </editor> <booktitle> STACS 91, volume 480 of Lecture Notes in Computer Science, </booktitle> <pages> pages 511-522. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: (Y ): p (X; a) : q (X): r (X) : q (X): r (a): F (P ) = T 15 4.1 Unfolding semantics and equivalence results The equivalence between the operational and the fixpoint semantics can be proved by introducing the intermediate notion of unfolding semantics U (P ) <ref> [41, 42, 14] </ref>. U (P ) is obtained as the limit of the (top-down) unfolding process. Since the unfolding rule preserves computed answers in a compositional way, U (P ) is equivalent to the operational semantics O (P ). <p> The first one states the associativity of the unfolding operator. Lemma 4.11 <ref> [14] </ref> Let P; Q; W be programs. Then unf P (unf Q (W )) = unf unf P (Q) (W ). Lemma 4.12 Let P be an -open program and let P n be as in definition 4.9.
Reference: [15] <author> Phan Minh Dung and K. Kanchanasut. </author> <title> A Fixpoint Approach to Declarative Seman tics of Logic Programs. </title> <editor> In E. Lusk and R. Overbeck, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 604-625. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: A similar device was used in <ref> [15, 35, 27] </ref> to characterize logic programs with negation. A combination of these result with our semantics could be considered to develop a compositional semantics for programs with negation. * Our framework is strongly related to abduction [17].
Reference: [16] <author> E. Eder. </author> <title> Properties of substitutions and unifications. </title> <journal> Journal of Symbolic Compu tation, </journal> <volume> 1 </volume> <pages> 31-46, </pages> <year> 1985. </year>
Reference: [17] <author> K. Eshghi and R. A. Kowalski. </author> <title> Abduction compared with Negation by Failure. </title> <editor> In G. Levi and M. Martelli, editors, </editor> <booktitle> Proc. Sixth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 234-254. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: A similar device was used in [15, 35, 27] to characterize logic programs with negation. A combination of these result with our semantics could be considered to develop a compositional semantics for programs with negation. * Our framework is strongly related to abduction <ref> [17] </ref>.
Reference: [18] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A new Declarative Semantics for Logic Languages. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 993-1005. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: We can now note that, as first shown in <ref> [18, 19] </ref>, the van Emden and Kowalski's semantics is not correct wrt the observational equivalence based on computed answer substitutions, while it is correct wrt the one based on successful derivations. Namely, there exist programs which have the same least Herbrand model, yet compute different answer substitutions. <p> This is the reason why the need for a different formal semantics, correct wrt answer substitutions, was recognized by many authors, giving rise to several new definitions (see, for example, <ref> [10, 21, 57, 18, 31] </ref>). The need for better semantics was also recognized in the case of semantics-based abstract interpretation [48, 37, 11, 3] and transformation [36, 5], where, as already mentioned, less abstract observables, such as partial computed answers or call patterns, have sometimes to be modeled. <p> Over the last few years we have developed a general approach to the semantics [23], whose aim was modeling the observable behaviors, possibly in a compositional way, for a variety of logic languages, ranging from positive logic programs <ref> [18, 19, 20, 7] </ref>, to general logic programs [54, 27], constraint logic programs [22, 32] and concurrent constraint programs [24]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. <p> Our denotations are then defined by syntactic objects, as in the case of Herbrand interpretations. Denotations, that we sometimes call -interpretations, have some nice model-theoretic properties. However, they are not interpretations in the conventional mathematical logic sense, even if -interpretations used in <ref> [18, 19, 20] </ref> can indeed be viewed as interpretations as done in [52, 38], where they were called canonical realizations. <p> A satisfactory solution even to the simple case of positive logic programs is needed to gain a better understanding of more practical languages, such as real Prolog [2] and its purely declarative counterparts. A partial solution was the s-semantics <ref> [18, 19] </ref>, which was the first (non-compositional) semantics correct wrt computed answers and which used sets of unit clauses as semantic domain. In this paper we extend the s-semantics approach to compositionality, starting from the results in [7]. <p> As already noted, the least Herbrand model semantics, as originally proposed in [55] and the computed answer substitution semantics in <ref> [18, 19, 20] </ref>, are not compositional wrt program union. <p> The notations ~ t, ~ X will be used to denote tuples of terms and variables respectively, while ~ B denotes a (possibly empty) conjunction of atoms. 2 Computed answer substitution semantics for open programs The operational semantics of logic programs with computed answer substitutions as observable <ref> [18, 19, 20] </ref> can be defined as O (P ) = fp (X 1 ; : : : ; X n ) j p (X 1 ; : : : ; X n ) 7! P 2g The denotation of a program is a set of non-ground atoms, which can be <p> Note that, for = ;, i.e. when all the predicates are considered completely defined, the previous definition boils down to the definition of the s-semantics <ref> [18] </ref>. O (P ) is a set of resultants [45] obtained from goals of the form p ( ~ X ) in P and is essentially the result of the partial evaluation of P , where derivations terminate at open predicates (i.e. predicates in ). <p> Note that when considering = ;, the theorem 2.10 is the completeness theorem of the s-semantics in <ref> [18] </ref>. 3 Semantic domain for -open programs In this section we formally define the semantic domain which characterizes the above introduced operational semantics O . Since O contains clauses (whose body predicates are all in ), we have to accomodate clauses in the semantic domain we use. <p> Then we define T Note that, for = ;, T P is the immediate consequence operator introduced in <ref> [18] </ref> whose least fixpoint is the s-semantics. Proposition 4.4 [7] T P is monotonic and continuous on the complete lattice (D; ). <p> Proof The completeness theorem of s-semantics <ref> [18] </ref> can be obtained as the particular case = ; of theorem 2.10 and can be stated as follows.
Reference: [19] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> Declarative Modeling of the Operational Behavior of Logic Languages. </title> <journal> Theoretical Computer Science, </journal> <volume> 69(3) </volume> <pages> 289-318, </pages> <year> 1989. </year>
Reference-contexts: We can now note that, as first shown in <ref> [18, 19] </ref>, the van Emden and Kowalski's semantics is not correct wrt the observational equivalence based on computed answer substitutions, while it is correct wrt the one based on successful derivations. Namely, there exist programs which have the same least Herbrand model, yet compute different answer substitutions. <p> Over the last few years we have developed a general approach to the semantics [23], whose aim was modeling the observable behaviors, possibly in a compositional way, for a variety of logic languages, ranging from positive logic programs <ref> [18, 19, 20, 7] </ref>, to general logic programs [54, 27], constraint logic programs [22, 32] and concurrent constraint programs [24]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. <p> Our denotations are then defined by syntactic objects, as in the case of Herbrand interpretations. Denotations, that we sometimes call -interpretations, have some nice model-theoretic properties. However, they are not interpretations in the conventional mathematical logic sense, even if -interpretations used in <ref> [18, 19, 20] </ref> can indeed be viewed as interpretations as done in [52, 38], where they were called canonical realizations. <p> A satisfactory solution even to the simple case of positive logic programs is needed to gain a better understanding of more practical languages, such as real Prolog [2] and its purely declarative counterparts. A partial solution was the s-semantics <ref> [18, 19] </ref>, which was the first (non-compositional) semantics correct wrt computed answers and which used sets of unit clauses as semantic domain. In this paper we extend the s-semantics approach to compositionality, starting from the results in [7]. <p> As already noted, the least Herbrand model semantics, as originally proposed in [55] and the computed answer substitution semantics in <ref> [18, 19, 20] </ref>, are not compositional wrt program union. <p> The notations ~ t, ~ X will be used to denote tuples of terms and variables respectively, while ~ B denotes a (possibly empty) conjunction of atoms. 2 Computed answer substitution semantics for open programs The operational semantics of logic programs with computed answer substitutions as observable <ref> [18, 19, 20] </ref> can be defined as O (P ) = fp (X 1 ; : : : ; X n ) j p (X 1 ; : : : ; X n ) 7! P 2g The denotation of a program is a set of non-ground atoms, which can be <p> The denotation of a program P is a -interpretation I, which has the following property. P and I are observationally equivalent with respect to any goal G. This is the property which allows us to state that the semantics does indeed capture the observable behavior <ref> [19] </ref>. The above semantics (as well as the least Herbrand model semantics) however, is only compositional wrt the conjunction of atoms in a goal or in a clause body. In fact the denotation of a conjunction can be obtained from the denotation of its conjuncts. <p> Theorem 2.13 shows the compositionality of the semantics wrt the [ operator. The proof of lemma 2.12 is also in the appendix. The proof of lemma 2.9 is in the appendix and is an extension of the proof of the completeness theorem in <ref> [19] </ref>. Lemma 2.9 Let P be a program.
Reference: [20] <author> M. Falaschi, G. Levi, M. Martelli, and C. Palamidessi. </author> <title> A Model-Theoretic Re construction of the Operational Semantics of Logic Programs. </title> <type> Technical Report TR 32/89, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1989. </year> <note> To appear in Information and Computation. </note>
Reference-contexts: Over the last few years we have developed a general approach to the semantics [23], whose aim was modeling the observable behaviors, possibly in a compositional way, for a variety of logic languages, ranging from positive logic programs <ref> [18, 19, 20, 7] </ref>, to general logic programs [54, 27], constraint logic programs [22, 32] and concurrent constraint programs [24]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. <p> Our denotations are then defined by syntactic objects, as in the case of Herbrand interpretations. Denotations, that we sometimes call -interpretations, have some nice model-theoretic properties. However, they are not interpretations in the conventional mathematical logic sense, even if -interpretations used in <ref> [18, 19, 20] </ref> can indeed be viewed as interpretations as done in [52, 38], where they were called canonical realizations. <p> As already noted, the least Herbrand model semantics, as originally proposed in [55] and the computed answer substitution semantics in <ref> [18, 19, 20] </ref>, are not compositional wrt program union. <p> The notations ~ t, ~ X will be used to denote tuples of terms and variables respectively, while ~ B denotes a (possibly empty) conjunction of atoms. 2 Computed answer substitution semantics for open programs The operational semantics of logic programs with computed answer substitutions as observable <ref> [18, 19, 20] </ref> can be defined as O (P ) = fp (X 1 ; : : : ; X n ) j p (X 1 ; : : : ; X n ) 7! P 2g The denotation of a program is a set of non-ground atoms, which can be <p> It is worth noting that the least u-closed -model is the standard least Herbrand model (proposition 5.17). Moreover, the most expressive -model O (P ) is a non-minimal -model (see next subsection). The following definitions are similar to those given in <ref> [20] </ref> for the non compositional semantics of positive logic programs. Definition 5.8 Let I 1 , I 2 be -denotations. <p> The proof of the following proposition is the same of the analogous in <ref> [20] </ref>. Proposition 5.9 The relation d is a preorder and the relation v is an ordering. Note that if I 1 I 2 , then I 1 v I 2 , since I 1 I 2 implies I 1 d I 2 . <p> We introduce the following notations. * 5fl = I2fl I * fl = A where A = M in (fl) S Note that M in (fl) = M in ( F fl). We can now prove the following proposition. The proof is essentially that one in <ref> [20] </ref>, rephrased by using proposition 5.12. Proposition 5.14 For any set fl of -denotations there exists the least upper bound of fl , lub (fl), and lub (fl) = fl holds. Proof. 1. ( fl is an upper bound of fl).
Reference: [21] <author> G. Ferrand. </author> <title> Error Diagnosis in Logic Programming, an Adaptation of E.Y. Shapiro's Method. </title> <journal> Journal of Logic Programming, </journal> <volume> 4 </volume> <pages> 177-198, </pages> <year> 1987. </year>
Reference-contexts: This is the reason why the need for a different formal semantics, correct wrt answer substitutions, was recognized by many authors, giving rise to several new definitions (see, for example, <ref> [10, 21, 57, 18, 31] </ref>). The need for better semantics was also recognized in the case of semantics-based abstract interpretation [48, 37, 11, 3] and transformation [36, 5], where, as already mentioned, less abstract observables, such as partial computed answers or call patterns, have sometimes to be modeled.
Reference: [22] <author> M. Gabbrielli and G. Levi. </author> <title> Modeling Answer Constraints in Constraint Logic Pro grams. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, pages 238- 252. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: In fact, even if the aim was not finding a semantics modeling the 2 observable behavior, most of the constructions proposed by Jaffar and Lassez [34] are different from the van Emden and Kowalski construction (i.e. they are not &lt;-models) and one of the proposed semantics was later proved <ref> [22] </ref> to correctly model the answer constraint observable. It is worth noting that it is exactly the declarative reading of logic programs which fails capturing the computed answers observable. <p> the last few years we have developed a general approach to the semantics [23], whose aim was modeling the observable behaviors, possibly in a compositional way, for a variety of logic languages, ranging from positive logic programs [18, 19, 20, 7], to general logic programs [54, 27], constraint logic programs <ref> [22, 32] </ref> and concurrent constraint programs [24]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. Our denotations are then defined by syntactic objects, as in the case of Herbrand interpretations. <p> In particular this matches quite naturally the semantics of CLP and concurrent constraint programs given in <ref> [22] </ref>. 33 * The modification of the O (P ) semantics developed in [4] could be used to de velop a modular analysis for programs which are structured by using inheritance mechanisms, according to the usual object-oriented style.
Reference: [23] <author> M. Gabbrielli and G. Levi. </author> <title> On the Semantics of Logic Programs. </title> <editor> In J. Leach Albert, B. Monien, and M. Rodriguez-Artalejo, editors, </editor> <booktitle> Automata, Languages and Programming, 18th International Colloquium, volume 510 of Lecture Notes in Computer Science, </booktitle> <pages> pages 1-19. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year> <month> 35 </month>
Reference-contexts: Still, OR-compositionality can be understood in logical terms. In fact, the set of all the models is correct wrt successful derivations and OR-compositional [46]. Over the last few years we have developed a general approach to the semantics <ref> [23] </ref>, whose aim was modeling the observable behaviors, possibly in a compositional way, for a variety of logic languages, ranging from positive logic programs [18, 19, 20, 7], to general logic programs [54, 27], constraint logic programs [22, 32] and concurrent constraint programs [24]. <p> The specific semantic treatment for inheritance by extension and/or overriding, is in [4] and is obtained by a modification of the framework we show here. In this paper we generalize the semantics given in [7] for -open programs, following the general approach in <ref> [23] </ref>. In the specific case of -open programs, -interpretations are called -denotations and are sets of conditional atoms, i.e., clauses such that all the atoms in the body are open. <p> More precisely, a denotation is a (possibly infinite) set of equivalence classes of clauses, or a -interpretation according to <ref> [23] </ref>. The equivalence is 6 needed to abstract from irrelevant syntactic differences and in the above semantics it is simply the variance relation. The denotation of a program P is a -interpretation I, which has the following property. P and I are observationally equivalent with respect to any goal G.
Reference: [24] <author> M. Gabbrielli and G. Levi. </author> <title> Unfolding and Fixpoint Semantics of Concurrent Con straint Programs. </title> <journal> Theoretical Computer Science, </journal> <volume> 105(1), </volume> <year> 1992. </year>
Reference-contexts: For example, finding definitions modeling the observable behavior was, from the very beginning, the aim of most of the research on the semantics of concurrent logic languages (see, for example, <ref> [43, 29, 24, 53, 13] </ref>). This was primarily motivated by the fact that these languages closely resemble traditional concurrent languages, whose semantics usually model observables such as traces of input-output interactions, deadlocks, etc. <p> developed a general approach to the semantics [23], whose aim was modeling the observable behaviors, possibly in a compositional way, for a variety of logic languages, ranging from positive logic programs [18, 19, 20, 7], to general logic programs [54, 27], constraint logic programs [22, 32] and concurrent constraint programs <ref> [24] </ref>. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. Our denotations are then defined by syntactic objects, as in the case of Herbrand interpretations. Denotations, that we sometimes call -interpretations, have some nice model-theoretic properties.
Reference: [25] <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Observable Behaviors and Equivalences of Logic Programs. </title> <institution> Research Report IIAS-RR-92-9E, International Institute for Advanced Study of Social Information Science, FUJITSU LAB. Ltd., </institution> <year> 1992. </year>
Reference-contexts: The following theorem generalizes the result given in [31] for the case = . Theorem 5.20 <ref> [25] </ref> Let P 1 ; P 2 be programs. Then P 1 6 P 2 iff there exists a set of atoms Q B such that P 1 [ Q 6 ; P 2 [ Q. <p> Moreover P 1 6 ;g P 2 iff there exists a set of (ground) atoms Q B such that P 1 [ Q 6 ;;g P 2 [ Q. Corollary 5.21 <ref> [25] </ref> Let P 1 and P 2 be -open programs and let assume that programs are defined on a signature containing infinite constant symbols. <p> Moreover [28] defines also an extension of the omega semantics which takes into account the selection rule and which allows to correctly model those ob-servables which depend on it. O (P ) is also useful for studying new equivalences of logic programs <ref> [26, 25] </ref> based on computed answer substitutions which are not considered in [46]. * The open semantics is useful to model incomplete knowledge bases, where new chunks of knowledge can incrementally be assimilated, and logic languages provided with a module-like structure.
Reference: [26] <author> M. Gabbrielli, G. Levi, and M. C. Meo. </author> <title> Observational Equivalences for Logic Pro grams. </title> <editor> In K. Apt, editor, </editor> <booktitle> Proc. Joint Int'l Conf. and Symposium on Logic Programming. </booktitle> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1992. </year>
Reference-contexts: Moreover [28] defines also an extension of the omega semantics which takes into account the selection rule and which allows to correctly model those ob-servables which depend on it. O (P ) is also useful for studying new equivalences of logic programs <ref> [26, 25] </ref> based on computed answer substitutions which are not considered in [46]. * The open semantics is useful to model incomplete knowledge bases, where new chunks of knowledge can incrementally be assimilated, and logic languages provided with a module-like structure.
Reference: [27] <author> M. Gabbrielli, G. Levi, and D. Turi. </author> <title> A Two Steps Semantics for Logic Programs with Negation. </title> <booktitle> In Proceedings of the Int'l Conf. on Logic Programming and Automated Reasoning, volume 624 of Lecture Notes in Artificial Intelligence, </booktitle> <pages> pages 297-308. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Over the last few years we have developed a general approach to the semantics [23], whose aim was modeling the observable behaviors, possibly in a compositional way, for a variety of logic languages, ranging from positive logic programs [18, 19, 20, 7], to general logic programs <ref> [54, 27] </ref>, constraint logic programs [22, 32] and concurrent constraint programs [24]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. Our denotations are then defined by syntactic objects, as in the case of Herbrand interpretations. <p> A similar device was used in <ref> [15, 35, 27] </ref> to characterize logic programs with negation. A combination of these result with our semantics could be considered to develop a compositional semantics for programs with negation. * Our framework is strongly related to abduction [17].
Reference: [28] <author> M. Gabbrielli and M. C. Meo. </author> <title> Fixpoint Semantics for Partial Computed Answer Substitutions and Call Patterns. </title> <editor> In H. Kirchner and G. Levi, editors, </editor> <booktitle> Proceedings of Third International Conference on Algebraic and Logic Programming, volume 632 of Lecture Notes in Computer Science, </booktitle> <pages> pages 84-99. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1992. </year>
Reference-contexts: Our -semantics O (P ) has already been used for several applications. Let us briefly discuss some of them. 32 * Suitable abstractions of the open semantics can be used to model non-standard ob servables useful for program analysis. For example in <ref> [28] </ref> a fully abstract semantics for partial answers is obtained essentially by considering the heads of the clauses in O (P ). Moreover [28] defines also an extension of the omega semantics which takes into account the selection rule and which allows to correctly model those ob-servables which depend on it. <p> For example in <ref> [28] </ref> a fully abstract semantics for partial answers is obtained essentially by considering the heads of the clauses in O (P ). Moreover [28] defines also an extension of the omega semantics which takes into account the selection rule and which allows to correctly model those ob-servables which depend on it.
Reference: [29] <author> H. Gaifman, M. J. Maher, and E. Y. Shapiro. </author> <title> Reactive Behavior Semantics for Concurrent Constraint Logic Programs. </title> <editor> In E. Lusk and R. Overbeck, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'89, </booktitle> <pages> pages 553-572. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1989. </year>
Reference-contexts: For example, finding definitions modeling the observable behavior was, from the very beginning, the aim of most of the research on the semantics of concurrent logic languages (see, for example, <ref> [43, 29, 24, 53, 13] </ref>). This was primarily motivated by the fact that these languages closely resemble traditional concurrent languages, whose semantics usually model observables such as traces of input-output interactions, deadlocks, etc.
Reference: [30] <author> H. Gaifman and E. Shapiro. </author> <title> Fully abstract compositional semantics for logic pro grams. </title> <booktitle> In Proc. Sixteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 134-142. </pages> <publisher> ACM, </publisher> <year> 1989. </year>
Reference-contexts: In the case of logic programs, the construct which raises a compositionality problem is the union of clauses. The related property is sometimes called OR-compositionality. People got interested in OR-compositional semantics <ref> [39, 49, 47, 30, 31] </ref> both for theoretical and for practical purposes, such as defining the semantics for modular versions of logic programs. When composition of programs is taken into account, for a given observable property we obtain different equivalences depending on which kind of program composition we consider. <p> In this paper we extend the s-semantics approach to compositionality, starting from the results in [7]. Note that all the existing OR-compositional semantics (apart from those in [31, 7]) are correct wrt successful derivations only <ref> [39, 49, 47, 46, 30] </ref>. Gaifman and Shapiro [30] first introduced an OR-compositional semantics in a proof-theoretic framework. OR-compositionality is achieved by using sets of non-unit clauses as semantic domain. This semantics was then extended to model computed answers in [31]. <p> In this paper we extend the s-semantics approach to compositionality, starting from the results in [7]. Note that all the existing OR-compositional semantics (apart from those in [31, 7]) are correct wrt successful derivations only [39, 49, 47, 46, 30]. Gaifman and Shapiro <ref> [30] </ref> first introduced an OR-compositional semantics in a proof-theoretic framework. OR-compositionality is achieved by using sets of non-unit clauses as semantic domain. This semantics was then extended to model computed answers in [31]. The resulting denotation, which is also fully abstract, uses semantic domains more complex than sets of clauses. <p> However note that lemma 5.28 does not hold if we consider possibly non-ground clauses and therefore we consider wcf as the weak canonical form as in [46]. A counter example can be obtained by considering the program P given in <ref> [30] </ref> P = f c 1 )A : R (X 1 ; X 1 ) . . . . . . g since in this case we have an infinite chain c 1 &gt; c 2 &gt; : : : (c 1 properly subsumed by c 2 : : :). <p> The following theorem 5.31 shows the full abstraction result. A different fully abstract invariant wrt ;g was already given in <ref> [30] </ref>. Lemma 5.29 Let P 1 ; P 2 be programs. Then P 1 ;g P 2 iff [P 1 ] ;g [P 2 ]. <p> By continuity of T P , n0 T least fixpoint with respect to set inclusion. Then the thesis follows, since I J implies I v J . 7 Related work and applications The result of our semantic construction has several similarities with the proof-theoretic semantics defined in <ref> [30, 31] </ref>. Our construction however is closer to the usual characterization of the semantics of logic programs. Namely we define a top-down operational and a bottom-up fixpoint semantics, and, last but not least a model-theoretic semantics which allows us to obtain a declarative characterization of syntactically defined models. <p> Our construction however is closer to the usual characterization of the semantics of logic programs. Namely we define a top-down operational and a bottom-up fixpoint semantics, and, last but not least a model-theoretic semantics which allows us to obtain a declarative characterization of syntactically defined models. The semantics in <ref> [30] </ref> does not characterize computed answer substitutions, while the denotation defined by the fully abstract semantics in [31] is not a set of clauses (i.e. a program). <p> The semantics in [30] does not characterize computed answer substitutions, while the denotation defined by the fully abstract semantics in [31] is not a set of clauses (i.e. a program). The framework of <ref> [30, 31] </ref> can be useful for defining a program equivalence notion, even if our more declarative (model-theoretic) characterization is even more adequate. Moreover, the presence of an operational or a fixpoint semantics makes our construction useful as a formal basis for program analysis.
Reference: [31] <author> H. Gaifman and E. Shapiro. </author> <title> Proof theory and semantics of logic programs. </title> <booktitle> In Proc. Fourth IEEE Symp. on Logic In Computer Science, </booktitle> <pages> pages 50-62. </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1989. </year>
Reference-contexts: This is the reason why the need for a different formal semantics, correct wrt answer substitutions, was recognized by many authors, giving rise to several new definitions (see, for example, <ref> [10, 21, 57, 18, 31] </ref>). The need for better semantics was also recognized in the case of semantics-based abstract interpretation [48, 37, 11, 3] and transformation [36, 5], where, as already mentioned, less abstract observables, such as partial computed answers or call patterns, have sometimes to be modeled. <p> In the case of logic programs, the construct which raises a compositionality problem is the union of clauses. The related property is sometimes called OR-compositionality. People got interested in OR-compositional semantics <ref> [39, 49, 47, 30, 31] </ref> both for theoretical and for practical purposes, such as defining the semantics for modular versions of logic programs. When composition of programs is taken into account, for a given observable property we obtain different equivalences depending on which kind of program composition we consider. <p> In this paper we extend the s-semantics approach to compositionality, starting from the results in [7]. Note that all the existing OR-compositional semantics (apart from those in <ref> [31, 7] </ref>) are correct wrt successful derivations only [39, 49, 47, 46, 30]. Gaifman and Shapiro [30] first introduced an OR-compositional semantics in a proof-theoretic framework. OR-compositionality is achieved by using sets of non-unit clauses as semantic domain. This semantics was then extended to model computed answers in [31]. <p> Gaifman and Shapiro [30] first introduced an OR-compositional semantics in a proof-theoretic framework. OR-compositionality is achieved by using sets of non-unit clauses as semantic domain. This semantics was then extended to model computed answers in <ref> [31] </ref>. The resulting denotation, which is also fully abstract, uses semantic domains more complex than sets of clauses. <p> In fact in general it is not sufficient to define denotations as sets of equivalence classes of clauses. A full abstractness result (wrt ) was obtained in <ref> [31] </ref>. However, denotations in [31] are not sets of clauses and the result is obtained by saturating the denotation of a program using essentially the definition of (restricted to union with atoms). A similar full abstractness result could be obtained in our case by using the equivalence on the domain. <p> In fact in general it is not sufficient to define denotations as sets of equivalence classes of clauses. A full abstractness result (wrt ) was obtained in <ref> [31] </ref>. However, denotations in [31] are not sets of clauses and the result is obtained by saturating the denotation of a program using essentially the definition of (restricted to union with atoms). A similar full abstractness result could be obtained in our case by using the equivalence on the domain. <p> Then P 1 ;g P 2 iff for any -open program Q such that P 1 [ Q and P 2 [ Q are defined and for any goal G, G # iff G ; P 2 [ Q 2. The following theorem generalizes the result given in <ref> [31] </ref> for the case = . Theorem 5.20 [25] Let P 1 ; P 2 be programs. Then P 1 6 P 2 iff there exists a set of atoms Q B such that P 1 [ Q 6 ; P 2 [ Q. <p> By continuity of T P , n0 T least fixpoint with respect to set inclusion. Then the thesis follows, since I J implies I v J . 7 Related work and applications The result of our semantic construction has several similarities with the proof-theoretic semantics defined in <ref> [30, 31] </ref>. Our construction however is closer to the usual characterization of the semantics of logic programs. Namely we define a top-down operational and a bottom-up fixpoint semantics, and, last but not least a model-theoretic semantics which allows us to obtain a declarative characterization of syntactically defined models. <p> The semantics in [30] does not characterize computed answer substitutions, while the denotation defined by the fully abstract semantics in <ref> [31] </ref> is not a set of clauses (i.e. a program). The framework of [30, 31] can be useful for defining a program equivalence notion, even if our more declarative (model-theoretic) characterization is even more adequate. <p> The semantics in [30] does not characterize computed answer substitutions, while the denotation defined by the fully abstract semantics in [31] is not a set of clauses (i.e. a program). The framework of <ref> [30, 31] </ref> can be useful for defining a program equivalence notion, even if our more declarative (model-theoretic) characterization is even more adequate. Moreover, the presence of an operational or a fixpoint semantics makes our construction useful as a formal basis for program analysis.
Reference: [32] <author> R. Giacobazzi, S. K. Debray, and G. Levi. </author> <title> A Generalized Semantics for Constraint Logic Programs. </title> <booktitle> In Proceedings of the International Conference on Fifth Generation Computer Systems 1992, </booktitle> <pages> pages 581-591, </pages> <year> 1992. </year>
Reference-contexts: the last few years we have developed a general approach to the semantics [23], whose aim was modeling the observable behaviors, possibly in a compositional way, for a variety of logic languages, ranging from positive logic programs [18, 19, 20, 7], to general logic programs [54, 27], constraint logic programs <ref> [22, 32] </ref> and concurrent constraint programs [24]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. Our denotations are then defined by syntactic objects, as in the case of Herbrand interpretations.
Reference: [33] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth An nual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference: [34] <author> J. Jaffar and J.-L. Lassez. </author> <title> Constraint Logic Programming. </title> <type> Technical report, </type> <institution> De partment of Computer Science, Monash University, </institution> <month> June </month> <year> 1986. </year>
Reference-contexts: Something similar took place in the case of Constraint Logic Programming. In fact, even if the aim was not finding a semantics modeling the 2 observable behavior, most of the constructions proposed by Jaffar and Lassez <ref> [34] </ref> are different from the van Emden and Kowalski construction (i.e. they are not &lt;-models) and one of the proposed semantics was later proved [22] to correctly model the answer constraint observable.
Reference: [35] <author> K. Kanchanasut and P. Stuckey. </author> <title> Eliminating Negation from Normal Logic Pro grams. </title> <editor> In H. Kirchner and W. Wechler, editors, </editor> <booktitle> Proc. Second Int'l Conf. on Algebraic and Logic Programming, volume 463 of Lecture Notes in Computer Science, </booktitle> <pages> pages 217-231. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year> <month> 36 </month>
Reference-contexts: A similar device was used in <ref> [15, 35, 27] </ref> to characterize logic programs with negation. A combination of these result with our semantics could be considered to develop a compositional semantics for programs with negation. * Our framework is strongly related to abduction [17].
Reference: [36] <author> T. Kawamura and T. Kanamori. </author> <title> Preservation of Stronger Equivalence in Un fold/Fold Logic Programming Transformation. </title> <booktitle> In Proc. Int'l Conf. on Fifth Generation Computer Systems, </booktitle> <pages> pages 413-422. </pages> <institution> Institute for New Generation Computer Technology, </institution> <address> Tokyo, </address> <year> 1988. </year>
Reference-contexts: The need for better semantics was also recognized in the case of semantics-based abstract interpretation [48, 37, 11, 3] and transformation <ref> [36, 5] </ref>, where, as already mentioned, less abstract observables, such as partial computed answers or call patterns, have sometimes to be modeled. The same problem was even earlier recognized in relation to some extensions of pure logic programming.
Reference: [37] <author> R. Kemp and G. Ringwood. </author> <title> An Algebraic Framework for the Abstract Interpreta tion of Logic Programs. </title> <editor> In S. Debray and M. Hermenegildo, editors, </editor> <booktitle> Proc. North American Conf. on Logic Programming'90, </booktitle> <pages> pages 506-520. </pages> <publisher> The MIT Press, </publisher> <address> Cam-bridge, Mass., </address> <year> 1990. </year>
Reference-contexts: The need for better semantics was also recognized in the case of semantics-based abstract interpretation <ref> [48, 37, 11, 3] </ref> and transformation [36, 5], where, as already mentioned, less abstract observables, such as partial computed answers or call patterns, have sometimes to be modeled. The same problem was even earlier recognized in relation to some extensions of pure logic programming.
Reference: [38] <author> G. Kreisel and J. L. Krivine. </author> <title> Elements of Mathematical Logic (Model Theory). </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1967. </year>
Reference-contexts: Denotations, that we sometimes call -interpretations, have some nice model-theoretic properties. However, they are not interpretations in the conventional mathematical logic sense, even if -interpretations used in [18, 19, 20] can indeed be viewed as interpretations as done in <ref> [52, 38] </ref>, where they were called canonical realizations. As in the case of the traditional van Emden and Kowalski semantics, our denotations can be computed both by a top-down construction (a success set) and by a bottom-up construction (the least fixpoint of suitable continuous immediate consequence operators on -interpretations).
Reference: [39] <author> J.-L. Lassez and M. J. Maher. </author> <title> Closures and Fairness in the Semantics of Program ming Logic. </title> <journal> Theoretical Computer Science, </journal> <volume> 29 </volume> <pages> 167-184, </pages> <year> 1984. </year>
Reference-contexts: In the case of logic programs, the construct which raises a compositionality problem is the union of clauses. The related property is sometimes called OR-compositionality. People got interested in OR-compositional semantics <ref> [39, 49, 47, 30, 31] </ref> both for theoretical and for practical purposes, such as defining the semantics for modular versions of logic programs. When composition of programs is taken into account, for a given observable property we obtain different equivalences depending on which kind of program composition we consider. <p> In this paper we extend the s-semantics approach to compositionality, starting from the results in [7]. Note that all the existing OR-compositional semantics (apart from those in [31, 7]) are correct wrt successful derivations only <ref> [39, 49, 47, 46, 30] </ref>. Gaifman and Shapiro [30] first introduced an OR-compositional semantics in a proof-theoretic framework. OR-compositionality is achieved by using sets of non-unit clauses as semantic domain. This semantics was then extended to model computed answers in [31]. <p> In order for a semantics to be compositional it must contain information in the form of a mapping from sets of atoms to sets of atoms. This is indeed the case of the semantics based on the closure operator <ref> [39] </ref> and on the T P operator [49, 47]. If we want a semantics expressed by the program syntax, compositionality w.r.t. union of programs can only be obtained by choosing as semantic domain a set of (equivalence classes of) clauses.
Reference: [40] <author> J.-L. Lassez, M. J. Maher, and K. Marriott. </author> <title> Unification Revisited. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 587-625. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year>
Reference: [41] <author> G. Levi. </author> <title> Models, Unfolding Rules and Fixpoint Semantics. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1649-1665. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: (Y ): p (X; a) : q (X): r (X) : q (X): r (a): F (P ) = T 15 4.1 Unfolding semantics and equivalence results The equivalence between the operational and the fixpoint semantics can be proved by introducing the intermediate notion of unfolding semantics U (P ) <ref> [41, 42, 14] </ref>. U (P ) is obtained as the limit of the (top-down) unfolding process. Since the unfolding rule preserves computed answers in a compositional way, U (P ) is equivalent to the operational semantics O (P ).
Reference: [42] <author> G. Levi and P. Mancarella. </author> <title> The Unfolding Semantics of Logic Programs. </title> <type> Technical Report TR-13/88, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1988. </year>
Reference-contexts: (Y ): p (X; a) : q (X): r (X) : q (X): r (a): F (P ) = T 15 4.1 Unfolding semantics and equivalence results The equivalence between the operational and the fixpoint semantics can be proved by introducing the intermediate notion of unfolding semantics U (P ) <ref> [41, 42, 14] </ref>. U (P ) is obtained as the limit of the (top-down) unfolding process. Since the unfolding rule preserves computed answers in a compositional way, U (P ) is equivalent to the operational semantics O (P ).
Reference: [43] <author> G. Levi and C. Palamidessi. </author> <title> An approach to the declarative semantics of synchro nization in logic languages. </title> <editor> In J.-L. Lassez, editor, </editor> <booktitle> Proc. Fourth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 877-893. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1987. </year>
Reference-contexts: For example, finding definitions modeling the observable behavior was, from the very beginning, the aim of most of the research on the semantics of concurrent logic languages (see, for example, <ref> [43, 29, 24, 53, 13] </ref>). This was primarily motivated by the fact that these languages closely resemble traditional concurrent languages, whose semantics usually model observables such as traces of input-output interactions, deadlocks, etc.
Reference: [44] <author> J. W. Lloyd. </author> <title> Foundations of Logic Programming. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1987. </year> <note> Second edition. </note>
Reference-contexts: Some proofs are deferred to the appendix. A preliminary short version of this paper appeared in [6]. 1.1 Preliminaries The reader is assumed to be familiar with the terminology of and the basic results in the semantics of logic programs <ref> [44, 1] </ref>. Let the signature S consist of a set F of function symbols, a finite set of predicate symbols, a denumerable set V of variable symbols. All the definitions in the following will assume a given signature S. <p> By the independence from the selection rule for SLD refutations <ref> [44, 1] </ref>, we can assume that the selection of the atoms is performed according to the following rule denoted by S 1. select first the non-open atoms (i.e. the p ( ~ t)'s such that p 62 ) 2. among the non-open atoms, select first those which are added to the
Reference: [45] <author> J. W. Lloyd and J. C. Shepherdson. </author> <title> Partial Evaluation in Logic Programming. </title> <journal> Journal of Logic Programming, </journal> <volume> 11 </volume> <pages> 217-242, </pages> <year> 1991. </year>
Reference-contexts: Note that, for = ;, i.e. when all the predicates are considered completely defined, the previous definition boils down to the definition of the s-semantics [18]. O (P ) is a set of resultants <ref> [45] </ref> obtained from goals of the form p ( ~ X ) in P and is essentially the result of the partial evaluation of P , where derivations terminate at open predicates (i.e. predicates in ).
Reference: [46] <author> M. J. Maher. </author> <title> Equivalences of Logic Programs. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 627-658. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, Ca., </address> <year> 1988. </year>
Reference-contexts: Therefore, logical equivalence is not the same as the equivalence wrt computed answers. The same statement is true for all the equivalence relations considered in <ref> [46] </ref>. In addition to the problem of modeling observational equivalences, there exists a very important property which does not hold in the traditional least Herbrand model semantics, i.e. compositionality. <p> If the observable property is successful derivations, we find out that the least Herbrand model is not even OR-compositional. Still, OR-compositionality can be understood in logical terms. In fact, the set of all the models is correct wrt successful derivations and OR-compositional <ref> [46] </ref>. <p> In this paper we extend the s-semantics approach to compositionality, starting from the results in [7]. Note that all the existing OR-compositional semantics (apart from those in [31, 7]) are correct wrt successful derivations only <ref> [39, 49, 47, 46, 30] </ref>. Gaifman and Shapiro [30] first introduced an OR-compositional semantics in a proof-theoretic framework. OR-compositionality is achieved by using sets of non-unit clauses as semantic domain. This semantics was then extended to model computed answers in [31]. <p> For a set Q of ground clauses, wcf (Q) returns the clauses in Q, modified by deleting repetitions of atoms in the body, which are not subsumed by other clauses in Q and which are not tautologies. Note that wcf (Q) is the weak canonical form <ref> [46] </ref> of Q. The (weak) canonical form of a set P of (possibly non-ground) clauses can be obtained [46] by "partitioning the clauses of P according to subsumption equivalence, by choosing the reduced clause for each equivalence class and then deleting those clauses which are subsumed by some other clauses (and <p> Note that wcf (Q) is the weak canonical form <ref> [46] </ref> of Q. The (weak) canonical form of a set P of (possibly non-ground) clauses can be obtained [46] by "partitioning the clauses of P according to subsumption equivalence, by choosing the reduced clause for each equivalence class and then deleting those clauses which are subsumed by some other clauses (and tautologies)". <p> A clause c is reduced [51] if it contains no identical atoms in the body and cannot be subsumed by a non-renaming instance of c. <ref> [46] </ref> shows that each clause is subsumption-equal (up to renaming) to a reduced clause and that the (weak) canonical form is unique up to renaming (considering bodies as sets). The following theorem shows the relation of these notions with the T P operator. <p> Moreover in the following by T P + id = T Q + id we mean that for every set of ground atoms X, T P (X) [ X = T Q (X) [ X (id is the identity). Theorem 5.27 <ref> [46] </ref> Let P; Q be sets of clauses. P and Q are weakly subsumption equivalent iff T P + id = T Q + id. Lemma 5.28 Let P; Q be (possibly infinite) sets of ground clauses. <p> Then, by definition of wcf , 8 c 0 2 P 0 9c 2 wcf (P 0 ) such that c subsumes c 0 and the thesis holds. For finite sets, the non-ground version of the previous lemma was proved in <ref> [46] </ref> (i.e. two finite sets of possibly non-ground clauses are weakly subsumption equivalent iff they have the same weak canonical form). However note that lemma 5.28 does not hold if we consider possibly non-ground clauses and therefore we consider wcf as the weak canonical form as in [46]. <p> was proved in <ref> [46] </ref> (i.e. two finite sets of possibly non-ground clauses are weakly subsumption equivalent iff they have the same weak canonical form). However note that lemma 5.28 does not hold if we consider possibly non-ground clauses and therefore we consider wcf as the weak canonical form as in [46]. <p> O (P ) is also useful for studying new equivalences of logic programs [26, 25] based on computed answer substitutions which are not considered in <ref> [46] </ref>. * The open semantics is useful to model incomplete knowledge bases, where new chunks of knowledge can incrementally be assimilated, and logic languages provided with a module-like structure. Modified versions of O (P ) allow to obtain semantics compositional wrt various composition operators.
Reference: [47] <author> P. Mancarella and D. Pedreschi. </author> <title> An Algebra of Logic Programs. </title> <editor> In R. A. Kowalski and K. A. Bowen, editors, </editor> <booktitle> Proc. Fifth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 1006-1023. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1988. </year>
Reference-contexts: In the case of logic programs, the construct which raises a compositionality problem is the union of clauses. The related property is sometimes called OR-compositionality. People got interested in OR-compositional semantics <ref> [39, 49, 47, 30, 31] </ref> both for theoretical and for practical purposes, such as defining the semantics for modular versions of logic programs. When composition of programs is taken into account, for a given observable property we obtain different equivalences depending on which kind of program composition we consider. <p> In this paper we extend the s-semantics approach to compositionality, starting from the results in [7]. Note that all the existing OR-compositional semantics (apart from those in [31, 7]) are correct wrt successful derivations only <ref> [39, 49, 47, 46, 30] </ref>. Gaifman and Shapiro [30] first introduced an OR-compositional semantics in a proof-theoretic framework. OR-compositionality is achieved by using sets of non-unit clauses as semantic domain. This semantics was then extended to model computed answers in [31]. <p> In order for a semantics to be compositional it must contain information in the form of a mapping from sets of atoms to sets of atoms. This is indeed the case of the semantics based on the closure operator [39] and on the T P operator <ref> [49, 47] </ref>. If we want a semantics expressed by the program syntax, compositionality w.r.t. union of programs can only be obtained by choosing as semantic domain a set of (equivalence classes of) clauses.
Reference: [48] <author> K. Marriott and H. Stndergaard. </author> <title> Semantics-based Dataflow Analysis of Logic Pro grams. </title> <editor> In G. Ritter, editor, </editor> <booktitle> Information Processing 89. </booktitle> <publisher> North-Holland, </publisher> <year> 1989. </year>
Reference-contexts: The need for better semantics was also recognized in the case of semantics-based abstract interpretation <ref> [48, 37, 11, 3] </ref> and transformation [36, 5], where, as already mentioned, less abstract observables, such as partial computed answers or call patterns, have sometimes to be modeled. The same problem was even earlier recognized in relation to some extensions of pure logic programming.
Reference: [49] <author> R. A. O'Keefe. </author> <title> Towards an Algebra for Constructing Logic Programs. </title> <booktitle> In Proc. IEEE Symp. on Logic Programming, </booktitle> <pages> pages 152-160, </pages> <year> 1985. </year> <month> 37 </month>
Reference-contexts: In the case of logic programs, the construct which raises a compositionality problem is the union of clauses. The related property is sometimes called OR-compositionality. People got interested in OR-compositional semantics <ref> [39, 49, 47, 30, 31] </ref> both for theoretical and for practical purposes, such as defining the semantics for modular versions of logic programs. When composition of programs is taken into account, for a given observable property we obtain different equivalences depending on which kind of program composition we consider. <p> In this paper we extend the s-semantics approach to compositionality, starting from the results in [7]. Note that all the existing OR-compositional semantics (apart from those in [31, 7]) are correct wrt successful derivations only <ref> [39, 49, 47, 46, 30] </ref>. Gaifman and Shapiro [30] first introduced an OR-compositional semantics in a proof-theoretic framework. OR-compositionality is achieved by using sets of non-unit clauses as semantic domain. This semantics was then extended to model computed answers in [31]. <p> In order for a semantics to be compositional it must contain information in the form of a mapping from sets of atoms to sets of atoms. This is indeed the case of the semantics based on the closure operator [39] and on the T P operator <ref> [49, 47] </ref>. If we want a semantics expressed by the program syntax, compositionality w.r.t. union of programs can only be obtained by choosing as semantic domain a set of (equivalence classes of) clauses.
Reference: [50] <author> C. Palamidessi. </author> <title> Algebraic properties of idempotent substitutions. </title> <editor> In M. S. Paterson, editor, </editor> <booktitle> Proc. of the 17th International Colloquium on Automata, Languages and Programming, volume 443 of Lecture Notes in Computer Science, </booktitle> <pages> pages 386-399. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1990. </year>
Reference: [51] <author> G. Plotkin. </author> <title> A Note on Inductive Generalization. </title> <journal> Machine Intelligence, </journal> <volume> 5 </volume> <pages> 153-165, </pages> <year> 1970. </year>
Reference-contexts: A clause c is reduced <ref> [51] </ref> if it contains no identical atoms in the body and cannot be subsumed by a non-renaming instance of c. [46] shows that each clause is subsumption-equal (up to renaming) to a reduced clause and that the (weak) canonical form is unique up to renaming (considering bodies as sets).
Reference: [52] <author> H. Rasiowa and R. Sikorski. </author> <title> The Mathematics of Metamathematics. </title> <publisher> North-Holland, </publisher> <address> Amsterdam, </address> <year> 1963. </year>
Reference-contexts: Denotations, that we sometimes call -interpretations, have some nice model-theoretic properties. However, they are not interpretations in the conventional mathematical logic sense, even if -interpretations used in [18, 19, 20] can indeed be viewed as interpretations as done in <ref> [52, 38] </ref>, where they were called canonical realizations. As in the case of the traditional van Emden and Kowalski semantics, our denotations can be computed both by a top-down construction (a success set) and by a bottom-up construction (the least fixpoint of suitable continuous immediate consequence operators on -interpretations).
Reference: [53] <author> V.A. Saraswat and M. Rinard. </author> <title> Concurrent constraint programming. </title> <booktitle> In Proc. of the Seventeenth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 232-245. </pages> <publisher> ACM, </publisher> <address> New York, </address> <year> 1990. </year>
Reference-contexts: For example, finding definitions modeling the observable behavior was, from the very beginning, the aim of most of the research on the semantics of concurrent logic languages (see, for example, <ref> [43, 29, 24, 53, 13] </ref>). This was primarily motivated by the fact that these languages closely resemble traditional concurrent languages, whose semantics usually model observables such as traces of input-output interactions, deadlocks, etc.
Reference: [54] <author> D. Turi. </author> <title> Extending S-Models to Logic Programs with Negation. </title> <editor> In K. Furukawa, editor, </editor> <booktitle> Proc. Eighth Int'l Conf. on Logic Programming, </booktitle> <pages> pages 397-411. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1991. </year>
Reference-contexts: Over the last few years we have developed a general approach to the semantics [23], whose aim was modeling the observable behaviors, possibly in a compositional way, for a variety of logic languages, ranging from positive logic programs [18, 19, 20, 7], to general logic programs <ref> [54, 27] </ref>, constraint logic programs [22, 32] and concurrent constraint programs [24]. Our approach is based on the idea of choosing (equivalence classes of) sets of clauses as semantic domains. Our denotations are then defined by syntactic objects, as in the case of Herbrand interpretations.
Reference: [55] <author> M. H. van Emden and R. A. Kowalski. </author> <title> The semantics of predicate logic as a programming language. </title> <journal> Journal of the ACM, </journal> <volume> 23(4) </volume> <pages> 733-742, </pages> <year> 1976. </year>
Reference-contexts: This is exactly what van Emden and Kowalski did in their seminal paper <ref> [55] </ref>, where the proof procedure was SLD-resolution and the representative model was the least Herbrand model. According to [55], the semantics is a mathematical object which is defined in model-theoretic terms and which can be computed both by a top-down construction and by a bottom-up construction. <p> This is exactly what van Emden and Kowalski did in their seminal paper <ref> [55] </ref>, where the proof procedure was SLD-resolution and the representative model was the least Herbrand model. According to [55], the semantics is a mathematical object which is defined in model-theoretic terms and which can be computed both by a top-down construction and by a bottom-up construction. <p> As already noted, the least Herbrand model semantics, as originally proposed in <ref> [55] </ref> and the computed answer substitution semantics in [18, 19, 20], are not compositional wrt program union.
Reference: [56] <author> D. A. Wolfram, M.J. Maher, and J-L. Lassez. </author> <title> A Unified Treatment of Resolution Strategies for Logic Programs. </title> <editor> In Sten -Ake Tarnlund, editor, </editor> <booktitle> Proc. Second Int'l Conf. on Logic Programming, </booktitle> <pages> pages 263-276, </pages> <year> 1984. </year>
Reference: [57] <author> S. Yamasaki, M. Yoshida, and S. Doshita. </author> <title> A fixpoint semantics of Horn Sentences based on Substitution Sets. </title> <journal> Theoretical Computer Science, </journal> <volume> 51 </volume> <pages> 309-324, </pages> <year> 1987. </year> <month> 38 </month>
Reference-contexts: This is the reason why the need for a different formal semantics, correct wrt answer substitutions, was recognized by many authors, giving rise to several new definitions (see, for example, <ref> [10, 21, 57, 18, 31] </ref>). The need for better semantics was also recognized in the case of semantics-based abstract interpretation [48, 37, 11, 3] and transformation [36, 5], where, as already mentioned, less abstract observables, such as partial computed answers or call patterns, have sometimes to be modeled.
References-found: 57

