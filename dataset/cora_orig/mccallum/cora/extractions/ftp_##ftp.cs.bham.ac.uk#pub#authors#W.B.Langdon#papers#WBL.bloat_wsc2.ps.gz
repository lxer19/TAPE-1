URL: ftp://ftp.cs.bham.ac.uk/pub/authors/W.B.Langdon/papers/WBL.bloat_wsc2.ps.gz
Refering-URL: http://www.cs.bham.ac.uk/~wbl/WBL_papers.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: fW.B.Langdon,R.Polig@cs.bham.ac.uk  
Phone: Tel: +44 (0) 121 414 4791, Fax: +44 (0) 121 414 4281  
Title: 2 nd On-line World Conference on Soft Computing in Engineering Design and Manufacturing Fitness Causes
Author: W. B. Langdon, R. Poli 
Note: That is  
Web: http://www.cs.bham.ac.uk/~wbl, ~rmp  
Address: B15 2TT, UK  
Affiliation: School of Computer Science, The University of Birmingham, Birmingham  
Date: 2327 June 1997  
Pubnum: (WSC2)  
Abstract: The problem of evolving an artificial ant to follow the Santa Fe trail is used to study the well known genetic programming feature of growth in solution length. Known variously as bloat, fluff and increasing structural complexity, this is often described in terms of increasing redundancy in the code caused by introns. Comparison between runs with and without fitness selection pressure, backed by Price's Theorem, shows the tendency for solutions to grow in size is caused by fitness based selection. We argue that such growth is inherent in using a fixed evaluation function with a discrete but variable length representation. With simple static evaluation search converges to mainly finding trial solutions with the same fitness as existing trial solutions. In general variable length allows many more long representations of a given solution than short ones. Thus in search (without a length bias) we expect longer representations to occur more often and so representation length to tend to increase. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Walter Alden Tackett, </author> <year> 1993, </year> <title> Genetic programming for feature discovery and image discrimination, </title> <booktitle> Proceedings of the 5th International Conference on Genetic Algorithms, ICGA-93, </booktitle> <institution> University of Illinois at Urbana-Champaign, </institution> <month> July, </month> <pages> pp. 303309. </pages>
Reference-contexts: 1 Introduction The tendency for programs in genetic programming (GP) populations to grow in length has been widely reported <ref> [1, 2, 3, 4, 5, 6, 7] </ref>. This tendency has gone under various names such as bloat, fluff and increasing structural complexity. <p> In some data fitting problems growth in solution size may be indicative of over fitting, i.e. better matching on the test data but at the expense of general performance. For example <ref> [1, page 309] </ref> suggests parsimony may be an important factor not for `aesthetic' reasons or ease of analysis, but because of a more direct relationship to fitness: there is a bound on the `appropriate size' of solution tree for a given problem.
Reference: [2] <author> Walter Alden Tackett, </author> <year> 1994, </year> <title> Recombination, Selection, and the Genetic Construction of Computer Programs, </title> <type> PhD thesis, </type> <institution> University of Southern California, USA. </institution>
Reference-contexts: 1 Introduction The tendency for programs in genetic programming (GP) populations to grow in length has been widely reported <ref> [1, 2, 3, 4, 5, 6, 7] </ref>. This tendency has gone under various names such as bloat, fluff and increasing structural complexity. <p> If it is negative, then the GA will tend to reduce it in the next generation. For a given distribution of representation lengths Equation 1 says the change in mean representation length will be linearly related to the selection pressure. This provides some theoretical justification for the claim <ref> [2, page 112] </ref> that average growth in size ... is proportional to selection pressure. <p> This provides some theoretical justification for the claim [2, page 112] that average growth in size ... is proportional to selection pressure. Which is based upon experimental measurements with a small number of radically different selection and crossover operators on Tackett's Royal Road problem <ref> [2] </ref>. (Solutions to the Royal Road problem are required to have prespecified syntactic properties which mean that the optimal solution has a fixed size and does not admit extraneous code selections. <p> Figure 4). Similarly program size statistics fluctuate but are essentially the same as those of the initial population (cf. Figure 5). This is in keeping with results with no selection reported in <ref> [2, page 112] </ref>. Given crossover produces random changes in length we might have expected the spread of lengths to gradually increase. This is not observed. The slow fall in maximum program size can be seen in Figure 5.
Reference: [3] <editor> Peter John Angeline, </editor> <booktitle> 1994, Genetic programming and emergent intelligence, Advances in Genetic Programming, chapter 4, </booktitle> <pages> pp. 7598, </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, USA. </address>
Reference-contexts: 1 Introduction The tendency for programs in genetic programming (GP) populations to grow in length has been widely reported <ref> [1, 2, 3, 4, 5, 6, 7] </ref>. This tendency has gone under various names such as bloat, fluff and increasing structural complexity. <p> By providing a defence against crossover [11, page 118] bloat causes the production of many programs of identical performance. These can consume the bulk of the available machine resources and by clogging up the population may prevent GP from effectively searching for better programs. On the other hand <ref> [3, page 84] </ref> quotes results from fixed length GAs in favour of representations which include introns, to argue we should not ... impede this emergent property [i.e. introns] as it may be crucial to the successful development of genetic programs.
Reference: [4] <author> Walter Alden Tackett, </author> <year> 1995, </year> <title> Greedy recombination and genetic search on the space of computer programs, </title> <booktitle> Foundations of Genetic Algorithms 3, </booktitle> <address> Estes Park, Colorado, USA, </address> <month> 31 July2 August, </month> <pages> pp. 271297. </pages>
Reference-contexts: 1 Introduction The tendency for programs in genetic programming (GP) populations to grow in length has been widely reported <ref> [1, 2, 3, 4, 5, 6, 7] </ref>. This tendency has gone under various names such as bloat, fluff and increasing structural complexity.
Reference: [5] <author> W. B. Langdon, </author> <year> 1995, </year> <title> Evolving data structures using genetic programming, </title> <booktitle> Genetic Algorithms: Proceedings of the Sixth International Conference (ICGA95), </booktitle> <address> Pittsburgh, PA, USA, </address> <month> July, </month> <pages> pp. 295302. </pages>
Reference-contexts: 1 Introduction The tendency for programs in genetic programming (GP) populations to grow in length has been widely reported <ref> [1, 2, 3, 4, 5, 6, 7] </ref>. This tendency has gone under various names such as bloat, fluff and increasing structural complexity.
Reference: [6] <author> Peter Nordin and Wolfgang Banzhaf, </author> <year> 1995, </year> <title> Complexity compression and evolution, </title> <booktitle> Genetic Algorithms: Proceedings of the Sixth International Conference (ICGA95), </booktitle> <address> Pittsburgh, PA, USA, </address> <month> July, </month> <pages> pp. 310317. </pages>
Reference-contexts: 1 Introduction The tendency for programs in genetic programming (GP) populations to grow in length has been widely reported <ref> [1, 2, 3, 4, 5, 6, 7] </ref>. This tendency has gone under various names such as bloat, fluff and increasing structural complexity.
Reference: [7] <author> Terence Soule, James A. Foster, and John Dickinson, </author> <year> 1996, </year> <title> Code growth in genetic programming, </title> <booktitle> Genetic Programming 1996: Proceedings of the First Annual Conference, </booktitle> <address> Stanford University, CA, USA, </address> <month> July, </month> <pages> pp. 215223. </pages>
Reference-contexts: 1 Introduction The tendency for programs in genetic programming (GP) populations to grow in length has been widely reported <ref> [1, 2, 3, 4, 5, 6, 7] </ref>. This tendency has gone under various names such as bloat, fluff and increasing structural complexity. <p> This is seldom used, perhaps due to the complexity of identifying redundant code. <ref> [7] </ref> showed bloat continuing despite their targeted genetic operations. Possibly this was because of the difficulty of reliably detecting introns. There was a route whereby the GP could evolve junk code which masqueraded as being useful and thereby protected itself from removal.
Reference: [8] <author> Annie S. Wu and Robert K. Lindsay, </author> <year> 1996, </year> <title> A survey of intron research in genetics, Parallel Problem Solving From Nature IV. </title> <booktitle> Proceedings of the International Conference on Evolutionary Computation, </booktitle> <address> Berlin, Germany, </address> <month> September, </month> <pages> pp. 101110. </pages>
Reference: [9] <author> Tobias Blickle and Lothar Thiele, </author> <year> 1994, </year> <title> Genetic programming and redundancy, Genetic Algorithms within the Framework of Evolutionary Computation (Workshop at KI-94, </title> <address> Saarbr ucken), Im Stadtwald, Building 44, D-66123 Saarbrucken, Germany, </address> <pages> pp. 3338, </pages> <institution> Max-Planck-Institut fur Informatik (MPI-I-94-241). </institution> <month> 9 </month>
Reference-contexts: Such introns are said to protect the program containing them from crossover <ref> [9, 10, 11] </ref>. [12] presents an analysis of some simple GP problems designed to investigate bloat. This shows that, with some function sets, longer programs can replicate more accurately when using crossover.
Reference: [10] <author> Tobias Blickle, </author> <year> 1996, </year> <title> Theory of Evolutionary Algorithms and Application to System Synthesis, </title> <type> PhD thesis, </type> <institution> Swiss Federal Institute of Technology, </institution> <address> Zurich. </address>
Reference-contexts: Such introns are said to protect the program containing them from crossover <ref> [9, 10, 11] </ref>. [12] presents an analysis of some simple GP problems designed to investigate bloat. This shows that, with some function sets, longer programs can replicate more accurately when using crossover. <p> Multi-objective fitness measures where one objective is compact or fast programs have also been used [25]. The third method is to tailor the genetic operations. [26, page 469] uses several mutation operators but adjusts their frequencies so a decrease in complexity is slightly more probable than an increase. <ref> [10] </ref> suggests targeting genetic operations at redundant code. This is seldom used, perhaps due to the complexity of identifying redundant code. [7] showed bloat continuing despite their targeted genetic operations. Possibly this was because of the difficulty of reliably detecting introns.
Reference: [11] <author> Peter Nordin, Frank Francone, and Wolfgang Banzhaf, </author> <year> 1996, </year> <title> Explicitly defined introns and destructive crossover in genetic programming, </title> <booktitle> Advances in Genetic Programming 2, chapter 6, </booktitle> <pages> pp. 111134, </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, USA. </address>
Reference-contexts: Such introns are said to protect the program containing them from crossover <ref> [9, 10, 11] </ref>. [12] presents an analysis of some simple GP problems designed to investigate bloat. This shows that, with some function sets, longer programs can replicate more accurately when using crossover. <p> By the end of the run, no children are produced with a fitness greater than their parent. Similar behaviour has been reported on other problems <ref> [11] </ref> [20, page 183] [14, Chapter 7]. 5.6 Non-Disruptive Crossover and Program Length In Section 2 we argued that there are more long programs with a given performance than short ones and so a random search for programs with a given level of performance is more likely to find long programs. <p> By providing a defence against crossover <ref> [11, page 118] </ref> bloat causes the production of many programs of identical performance. These can consume the bulk of the available machine resources and by clogging up the population may prevent GP from effectively searching for better programs.
Reference: [12] <author> Nicholas Freitag McPhee and Justin Darwin Miller, </author> <year> 1995, </year> <title> Accurate replication in genetic programming, </title> <booktitle> Genetic Algorithms: Proceedings of the Sixth International Conference (ICGA95), </booktitle> <address> Pittsburgh, PA, USA, </address> <month> July, </month> <pages> pp. 303309. </pages>
Reference-contexts: Such introns are said to protect the program containing them from crossover [9, 10, 11]. <ref> [12] </ref> presents an analysis of some simple GP problems designed to investigate bloat. This shows that, with some function sets, longer programs can replicate more accurately when using crossover.
Reference: [13] <author> Justinian P. Rosca and Dana H. Ballard, </author> <year> 1996, </year> <title> Complexity drift in evolutionary computation with tree representations, </title> <type> Technical Report NRL5, </type> <institution> University of Rochester, Computer Science Department, Rochester, NY, USA. </institution>
Reference-contexts: This shows that, with some function sets, longer programs can replicate more accurately when using crossover. That is offspring produced by crossover between longer programs are more likely to behave as their parents than children of shorter programs. <ref> [13] </ref> provides a detailed analysis of bloat using tree schemata specifically for GP. In this paper we advance a more general explanation which should apply generally to any discrete variable length representation and generally to any progressive search technique. <p> The second (also commonly used) is to incorporate program size directly into the fitness measure (often called parsimony pressure) [15, 23, 24]. <ref> [13] </ref> gives an analysis of the effect of parsimony pressure which varies linearly with program length. Multi-objective fitness measures where one objective is compact or fast programs have also been used [25]. <p> Possibly this was because of the difficulty of reliably detecting introns. There was a route whereby the GP could evolve junk code which masqueraded as being useful and thereby protected itself from removal. While <ref> [13] </ref> propose a method where the likelihood of potentially disruptive genetic operations increases with parent size. 7 Conclusions We have generalised existing explanations for the widely observed growth in GP program size with successive generations (bloat) to give a simple statistical argument which should be generally applicable both to GP and
Reference: [14] <author> W. B. Langdon, </author> <year> 1996, </year> <title> Data Structures and Genetic Programming, </title> <type> PhD thesis, </type> <institution> University College, </institution> <address> London. </address>
Reference-contexts: On problems of interest, finding improved solutions is relatively easy initially but becomes increasingly more difficult. In these circumstances, especially with a discrete fitness function, there is little chance of finding a representation that does better than the representation (s) from which it was created (cf. death of crossover <ref> [14, page 222] </ref>). So the selection bias favours representations which have the same fitness as those from which they were created. In general the easiest way to create one representation from another and retain the same fitness is for the new representation to represent identical behaviour. <p> We have used it to help explain the evolution of the number of copies of functions and terminals in GP populations <ref> [14, 18] </ref>. generation. <p> By the end of the run, no children are produced with a fitness greater than their parent. Similar behaviour has been reported on other problems [11] [20, page 183] <ref> [14, Chapter 7] </ref>. 5.6 Non-Disruptive Crossover and Program Length In Section 2 we argued that there are more long programs with a given performance than short ones and so a random search for programs with a given level of performance is more likely to find long programs.
Reference: [15] <author> John R. Koza, </author> <year> 1992, </year> <title> Genetic Programming: On the Programming of Computers by Natural Selection, </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, USA. </address>
Reference-contexts: In GP this has become known as bloat. 3 The Artificial Ant Problem The artificial ant problem is described in <ref> [15, pages 147155] </ref>. It is a well studied problem and was chosen as it has a simple fitness function. Briefly the problem is to devise a program which can successfully navigate an artificial ant along a twisting trail on a square 32 fi 32 toroidal grid. <p> Each time the ant enters a square containing food it eats it. The amount of food eaten is used as the fitness measure of the controlling program. 4 GP Parameters Our GP system was set up to be the same as given in <ref> [15, pages 147155] </ref> except the populations were allowed to continue to evolve even after an ant succeeded in traversing the whole trail, each crossover produces one child rather than two, tournament selection was used and the ants were allowed 600 operations (Move, Left, Right) to complete the trail. <p> Note a limit of 500 allows the evolved programs to be far bigger than required to solve the problem. For example the 100% correct solution given in <ref> [15, page 154] </ref> takes about 543 time steps to traverse the Santa Fe trail but has a length of only 18 nodes and this is not the most compact solution possible. 5 Results 5.1 Standard Runs In 50 independent runs 6 found ants that could eat all the food on the <p> However in practice we may not wish to operate the system continually. For example it may quickly find a satisfactory solution or better performance may be achieved by cutting short its operation and running it repeatedly with different starting configurations <ref> [15, page 758] </ref>. In some data fitting problems growth in solution size may be indicative of over fitting, i.e. better matching on the test data but at the expense of general performance. <p> Firstly, and most widely used (e.g. in these experiments), is to place a universal upper bound either on tree depth <ref> [15] </ref> or program length. ([22, 18] discuss unexpected problems with this approach). The second (also commonly used) is to incorporate program size directly into the fitness measure (often called parsimony pressure) [15, 23, 24]. [13] gives an analysis of the effect of parsimony pressure which varies linearly with program length. <p> The second (also commonly used) is to incorporate program size directly into the fitness measure (often called parsimony pressure) <ref> [15, 23, 24] </ref>. [13] gives an analysis of the effect of parsimony pressure which varies linearly with program length. Multi-objective fitness measures where one objective is compact or fast programs have also been used [25].
Reference: [16] <author> John R. Koza, </author> <year> 1994, </year> <title> Genetic Programming II: Automatic Discovery of Reusable Programs, </title> <publisher> MIT Press, </publisher> <address> Cambridge MA, USA. </address>
Reference-contexts: The details are given in Table 1, parameters not shown are as <ref> [16, page 655] </ref>. On each version of the problem 50 independent runs were conducted. Since bloating is widespread in GP it is common to impose a limit on the size of programs. Commonly this is in 2 of food eaten. Error bars indicate one standard devia tion.
Reference: [17] <author> George R. Price, </author> <year> 1970, </year> <title> Selection and covariance, </title> <journal> Nature, </journal> <volume> 227, </volume> <year> 1:520521. </year>
Reference-contexts: This random choice leads to random fluctuations in apparent program size which can be seen in Figure 2 after generation 27 despite averaging over 50 runs. 5.1.1 Fitness is Necessary for Bloat Price's Theorem Applied to Representation Length Price's Covariance and Selection Theorem <ref> [17] </ref> from population genetics relates the expected change in frequency of a gene q in a population from one generation to the next, to the covariance of the gene's frequency in the original population with the number of offspring z produced by individuals in that population (see Equation 1).
Reference: [18] <author> W. B. Langdon and R. Poli, </author> <year> 1997, </year> <title> An analysis of the MAX problem in genetic programming, </title> <booktitle> Genetic Programming 1997: Proceedings of the Second Annual Conference, </booktitle> <address> Stanford University, CA, USA, </address> <month> July. </month>
Reference-contexts: We have used it to help explain the evolution of the number of copies of functions and terminals in GP populations <ref> [14, 18] </ref>. generation.
Reference: [19] <author> Lee Altenberg, </author> <year> 1995, </year> <title> The Schema Theorem and Price's Theorem, </title> <booktitle> Foundations of Genetic Algorithms 3, </booktitle> <address> Estes Park, Colorado, USA, </address> <month> 31 July2 August, </month> <pages> pp. 2349. </pages>
Reference-contexts: Where representation length is inherited, such as in GP and other search techniques, Equation 1 should hold for representation length. More formally Price's theorem applies (provided length and genetic operators are uncorrelated) since representation length is a measurement function of the genotype <ref> [19, page 28] </ref>. If it held exactly a plot of covariance vs. change in mean length would be a straight line (assuming z is constant). The solid line plot in Figure 3 shows good agreement between theory and measurement until generation 20.
Reference: [20] <author> Justinian P. Rosca and Dana H. Ballard, </author> <year> 1996, </year> <title> Discovery of subroutines in genetic programming, </title> <booktitle> Advances in Genetic Programming 2, chapter 9, </booktitle> <pages> pp. 177202, </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, USA. </address>
Reference-contexts: By the end of the run, no children are produced with a fitness greater than their parent. Similar behaviour has been reported on other problems [11] <ref> [20, page 183] </ref> [14, Chapter 7]. 5.6 Non-Disruptive Crossover and Program Length In Section 2 we argued that there are more long programs with a given performance than short ones and so a random search for programs with a given level of performance is more likely to find long programs.
Reference: [21] <author> Chris Gathercole and Peter Ross, </author> <year> 1994, </year> <title> Dynamic training subset selection for supervised learning in genetic programming, Parallel Problem Solving from Nature III, </title> <address> Jerusalem, </address> <month> October, </month> <pages> pp. 312321. </pages>
Reference-contexts: In complex problems it may not be possible to test every solution on every aspect of the problem and some form of dynamic selection of test cases may be required <ref> [21] </ref>. For example in some cases co-evolution has been claimed to be beneficial to GP.
Reference: [22] <author> Chris Gathercole and Peter Ross, </author> <year> 1996, </year> <title> An adverse interaction between crossover and restricted tree depth in genetic programming, </title> <booktitle> Genetic Programming 1996: Proceedings of the First Annual Conference, </booktitle> <address> Stanford University, CA, USA, </address> <month> July, </month> <pages> pp. 291296. </pages>
Reference: [23] <author> Byoung-Tak Zhang and Heinz Muhlenbein, </author> <year> 1993, </year> <title> Evolving optimal neural networks using genetic algorithms with Occam's razor, </title> <journal> Complex Systems, </journal> <volume> 7, </volume> <year> 199220. </year>
Reference-contexts: The second (also commonly used) is to incorporate program size directly into the fitness measure (often called parsimony pressure) <ref> [15, 23, 24] </ref>. [13] gives an analysis of the effect of parsimony pressure which varies linearly with program length. Multi-objective fitness measures where one objective is compact or fast programs have also been used [25].
Reference: [24] <author> Hitoshi Iba, Hugo de Garis, and Taisuke Sato, </author> <year> 1994, </year> <title> Genetic programming using a minimum description length principle, </title> <booktitle> Advances in Genetic Programming, chapter 12, </booktitle> <pages> pp. 265284, </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, USA. </address>
Reference-contexts: The second (also commonly used) is to incorporate program size directly into the fitness measure (often called parsimony pressure) <ref> [15, 23, 24] </ref>. [13] gives an analysis of the effect of parsimony pressure which varies linearly with program length. Multi-objective fitness measures where one objective is compact or fast programs have also been used [25].
Reference: [25] <author> William B. Langdon, </author> <year> 1996, </year> <title> Data structures and genetic programming, </title> <booktitle> Advances in Genetic Programming 2, chapter 20, </booktitle> <pages> pp. 395414, </pages> <publisher> MIT Press, </publisher> <address> Cambridge, MA, USA. </address>
Reference-contexts: Multi-objective fitness measures where one objective is compact or fast programs have also been used <ref> [25] </ref>. The third method is to tailor the genetic operations. [26, page 469] uses several mutation operators but adjusts their frequencies so a decrease in complexity is slightly more probable than an increase. [10] suggests targeting genetic operations at redundant code.
Reference: [26] <author> K. Sims, </author> <year> 1993, </year> <title> Interactive evolution of equations for procedural models, </title> <journal> The Visual Computer, </journal> <volume> 9, 466476. </volume> <pages> 10 </pages>
Reference-contexts: Multi-objective fitness measures where one objective is compact or fast programs have also been used [25]. The third method is to tailor the genetic operations. <ref> [26, page 469] </ref> uses several mutation operators but adjusts their frequencies so a decrease in complexity is slightly more probable than an increase. [10] suggests targeting genetic operations at redundant code.
References-found: 26

