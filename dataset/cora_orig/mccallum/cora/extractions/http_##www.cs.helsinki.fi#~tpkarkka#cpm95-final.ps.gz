URL: http://www.cs.helsinki.fi/~tpkarkka/cpm95-final.ps.gz
Refering-URL: http://www.cs.helsinki.fi/research/pmdm/publications/
Root-URL: 
Email: E-mail: Juha.Karkkainen@cs.Helsinki.FI  
Title: Suffix Cactus: A Cross between Suffix Tree and Suffix Array  
Author: Juha Karkkainen 
Web: URL: http://www.cs.helsinki.fi/~tpkarkka  
Address: P. O. Box 26 (Teollisuuskatu 23) FIN-00014 University of Helsinki, Finland.  
Affiliation: Department of Computer Science,  
Abstract: The suffix cactus is a new alternative to the suffix tree and the suffix array as an index of large static texts. Its size and its performance in searches lies between those of the suffix tree and the suffix array. Structurally, the suffix cactus can be seen either as a compact variation of the suffix tree or as an augmented suffix array.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Com puter Algorithms, </title> <booktitle> chapter 9, </booktitle> <pages> pages 318-361. </pages> <publisher> Addison-Wesley, </publisher> <year> 1974. </year>
Reference-contexts: Both of these problems can be solved by scanning the text. Regular expression matching takes O (n) time (excluding the preprocessing of the regular expression) <ref> [1] </ref> and approximate string matching O (kn) time [7, 18]. Baeza-Yates and Gonnet have described methods to use the suffix tree to do both regular expression matching [5] and approximate string matching [6]. The latter idea was also independently mentioned in [10, Remark 2].
Reference: 2. <author> A. Andersson and S. Nilsson. </author> <title> Improved behaviour of tries by adaptive branching. </title> <journal> Inf. Process. Lett., </journal> <volume> 46(6) </volume> <pages> 295-300, </pages> <month> July </month> <year> 1993. </year>
Reference-contexts: The suffix cactus could be described either as a compact version of the suffix tree or as a suffix array augmented with some extra information. The suffix cactus can therefore be called a cross between the suffix tree and the suffix array. Recently, Anderson and Nilsson <ref> [2, 3] </ref>, and Irving [9] have introduced new alternative data structures. The level compressed trie of Andersson and Nilsson takes about 12 bytes per text symbol and has matching properties comparable to the suffix cactus.
Reference: 3. <author> A. Andersson and S. Nilsson. </author> <title> Efficient implementation of suffix trees. </title> <journal> Software| Practice and Experience, </journal> <volume> 25(2) </volume> <pages> 129-141, </pages> <month> Feb. </month> <year> 1995. </year>
Reference-contexts: The suffix cactus could be described either as a compact version of the suffix tree or as a suffix array augmented with some extra information. The suffix cactus can therefore be called a cross between the suffix tree and the suffix array. Recently, Anderson and Nilsson <ref> [2, 3] </ref>, and Irving [9] have introduced new alternative data structures. The level compressed trie of Andersson and Nilsson takes about 12 bytes per text symbol and has matching properties comparable to the suffix cactus.
Reference: 4. <author> A. Apostolico. </author> <title> The myriad virtues of subword trees. </title> <editor> In A. Apostolico and Z. Galil, editors, </editor> <booktitle> Combinatorial Algorithms on Words, </booktitle> <pages> pages 85-95. </pages> <publisher> Springer-Verlag, </publisher> <year> 1985. </year>
Reference-contexts: What makes the suffix tree attractive is that its size and its construction time are linear in the length of the text [19, 14, 17]. Suffix trees have a wide variety of applications. Apostolico <ref> [4] </ref> cites over forty references on suffix trees, and Manber and Myers [13] mention several newer ones. The application, that we are mostly interested in in this paper, is the use of a suffix tree as an index of a large static text to allow fast searches.
Reference: 5. <author> R. A. Baeza-Yates and G. H. Gonnet. </author> <title> Efficient text searching of regular expres sions. </title> <booktitle> In Proc. 16th International Colloquium on Automata, Languages and Programming (ICALP), </booktitle> <pages> pages 46-62, </pages> <year> 1989. </year>
Reference-contexts: Regular expression matching takes O (n) time (excluding the preprocessing of the regular expression) [1] and approximate string matching O (kn) time [7, 18]. Baeza-Yates and Gonnet have described methods to use the suffix tree to do both regular expression matching <ref> [5] </ref> and approximate string matching [6]. The latter idea was also independently mentioned in [10, Remark 2]. Both of these methods are based on scanning one suffix of T at a time to find whether it has a matching prefix.
Reference: 6. <author> R. A. Baeza-Yates and G. H. Gonnet. </author> <title> All-against-all sequence matching. </title> <type> Techni cal report, </type> <institution> Department of Computer Science, University of Chile, </institution> <year> 1990. </year>
Reference-contexts: Regular expression matching takes O (n) time (excluding the preprocessing of the regular expression) [1] and approximate string matching O (kn) time [7, 18]. Baeza-Yates and Gonnet have described methods to use the suffix tree to do both regular expression matching [5] and approximate string matching <ref> [6] </ref>. The latter idea was also independently mentioned in [10, Remark 2]. Both of these methods are based on scanning one suffix of T at a time to find whether it has a matching prefix.
Reference: 7. <author> Z. Galil and K. Park. </author> <title> An improved algorithm for approximate string matching. </title> <journal> SIAM J. Comput., </journal> <volume> 19(6) </volume> <pages> 989-999, </pages> <month> Dec. </month> <year> 1990. </year>
Reference-contexts: Both of these problems can be solved by scanning the text. Regular expression matching takes O (n) time (excluding the preprocessing of the regular expression) [1] and approximate string matching O (kn) time <ref> [7, 18] </ref>. Baeza-Yates and Gonnet have described methods to use the suffix tree to do both regular expression matching [5] and approximate string matching [6]. The latter idea was also independently mentioned in [10, Remark 2].
Reference: 8. <author> G. H. Gonnet, R. A. Baeza-Yates, and T. Snider. </author> <title> Lexicographical indices for text: Inverted files vs. pat trees. </title> <type> Technical Report OED-91-01, </type> <institution> Centre for the New OED, University of Waterloo, </institution> <year> 1991. </year>
Reference-contexts: The basic search type is string matching, i.e. searching for the occurrences of a pattern string in the text. Other useful forms of queries include regular expression matching and approximate string matching. Examples of very large texts requiring fast searching are electronic dictionaries <ref> [8] </ref>, and biological sequence databases [16]. To work efficiently, the whole suffix tree must fit in the main memory. Thus the space requirement of the suffix tree is an important issue. Gonnet, Baeza-Yates and Snider [8] have studied the use of suffix trees with only a small part at a time <p> Examples of very large texts requiring fast searching are electronic dictionaries <ref> [8] </ref>, and biological sequence databases [16]. To work efficiently, the whole suffix tree must fit in the main memory. Thus the space requirement of the suffix tree is an important issue. Gonnet, Baeza-Yates and Snider [8] have studied the use of suffix trees with only a small part at a time in the main memory, but many applications slow down unacceptably. The exact size of the suffix tree depends on the implementation and the type of the text. <p> The exact size of the suffix tree depends on the implementation and the type of the text. A typical size for a tight implementation on english text is about 15 bytes per text symbol. The suffix array <ref> [13, 8] </ref> is a data structure which, like the suffix tree, allows fast searches on a text. The size of an efficient implementation of a suffix array, including the text itself, is only 6 bytes per text symbol. <p> The suffixes are represented by their starting positions as illustraded in Fig. 2 (b). The suffix array was discovered by Manber and Myers [13], and independently by Gonnet, Baeza-Yates and Snider <ref> [8] </ref>. String matching in suffix arrays can be done in O (m log n) time by a binary search. Manber and Myers [13] improved the string matching time to O (m+log n) by providing additional information about the lengths of the longest common prefixes (lcps) between the suffixes.
Reference: 9. <author> R. W. Irving. </author> <title> Suffix binary search trees. </title> <type> Technical report TR-1995-7, </type> <institution> Computing Science Department, University of Glasgow, </institution> <month> Apr. </month> <year> 1995. </year>
Reference-contexts: The suffix cactus can therefore be called a cross between the suffix tree and the suffix array. Recently, Anderson and Nilsson [2, 3], and Irving <ref> [9] </ref> have introduced new alternative data structures. The level compressed trie of Andersson and Nilsson takes about 12 bytes per text symbol and has matching properties comparable to the suffix cactus.
Reference: 10. <author> P. Jokinen and E. Ukkonen. </author> <title> Two algorithms for approximate string matching in static texts. </title> <booktitle> In Proc. 16th International Symposium on Mathematical Foundations of Computer Science (MFCS), </booktitle> <pages> pages 240-248, </pages> <month> Sept. </month> <year> 1991. </year>
Reference-contexts: Baeza-Yates and Gonnet have described methods to use the suffix tree to do both regular expression matching [5] and approximate string matching [6]. The latter idea was also independently mentioned in <ref> [10, Remark 2] </ref>. Both of these methods are based on scanning one suffix of T at a time to find whether it has a matching prefix.
Reference: 11. <author> D. E. Knuth. </author> <title> Sorting and Searching, </title> <booktitle> volume 3 of The Art of Computer Program ming, chapter 6.3, </booktitle> <pages> pages 481-505. </pages> <publisher> Addison-Wesley, </publisher> <year> 1973. </year>
Reference-contexts: Then the string S j = T j is called the longest common prefix of S and T and its length j is denoted lcp (S; T ). A trie (see e.g. Knuth <ref> [11] </ref>) is a rooted tree with the following properties. 1. Each node, except the root, contains a symbol of the alphabet. 2. No two children of the same node contain the same symbol.
Reference: 12. <author> D. E. Knuth, J. H. Morris, and V. R. Pratt. </author> <title> Fast pattern matching in strings. </title> <journal> SIAM J. Comput., </journal> <volume> 6(2) </volume> <pages> 323-350, </pages> <month> June </month> <year> 1977. </year>
Reference-contexts: The problem of string matching is to find the occurrences of string P as a subtring of T . It can be solved in linear time by scanning text T using, e.g., the Knuth-Morris-Pratt algorithm <ref> [12] </ref>. For a large static text, a faster solution can be achieved by preprocessing the text. Suffix trees, suffix arrays and suffix cactuses are suitable preprocessing structures. In regular expression matching the goal is to find all substrings of text T that match a given regular expression.
Reference: 13. <author> U. Manber and G. Myers. </author> <title> Suffix arrays: A new method for on-line string searches. </title> <journal> SIAM J. Comput., </journal> <volume> 22(5) </volume> <pages> 935-948, </pages> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: What makes the suffix tree attractive is that its size and its construction time are linear in the length of the text [19, 14, 17]. Suffix trees have a wide variety of applications. Apostolico [4] cites over forty references on suffix trees, and Manber and Myers <ref> [13] </ref> mention several newer ones. The application, that we are mostly interested in in this paper, is the use of a suffix tree as an index of a large static text to allow fast searches. <p> The exact size of the suffix tree depends on the implementation and the type of the text. A typical size for a tight implementation on english text is about 15 bytes per text symbol. The suffix array <ref> [13, 8] </ref> is a data structure which, like the suffix tree, allows fast searches on a text. The size of an efficient implementation of a suffix array, including the text itself, is only 6 bytes per text symbol. <p> In its basic form, the suffix array is just a lexicographically ordered array of the suffixes of the text. The suffixes are represented by their starting positions as illustraded in Fig. 2 (b). The suffix array was discovered by Manber and Myers <ref> [13] </ref>, and independently by Gonnet, Baeza-Yates and Snider [8]. String matching in suffix arrays can be done in O (m log n) time by a binary search. Manber and Myers [13] improved the string matching time to O (m+log n) by providing additional information about the lengths of the longest common <p> The suffix array was discovered by Manber and Myers <ref> [13] </ref>, and independently by Gonnet, Baeza-Yates and Snider [8]. String matching in suffix arrays can be done in O (m log n) time by a binary search. Manber and Myers [13] improved the string matching time to O (m+log n) by providing additional information about the lengths of the longest common prefixes (lcps) between the suffixes. The lcps are provided for each parent-child pair in an implicit tree structure called the interval tree. <p> The suffix array can be constructed in linear time by constructing first the suffix tree and then listing the suffixes in lexicographic order from the tree. Man-ber and Myers <ref> [13] </ref> have also described a construction algorithm that works by sorting the suffixes. It takes O (n log n) time in the worst case and O (n log log n) time on average for random texts with even and independent distribution of characters. <p> The tests were run on a 90 MHz Pentium PC with 16 Mbytes of memory running Linux operating system. We implemented the standard suffix tree construction [14, 17], the suffix array construction by sorting <ref> [13] </ref>, and both of the suffix cactus construction algorithms described in the previous section. Table 1 gives the execution times and the space requirements of these construction algorithms. The space requirements include the text.
Reference: 14. <author> E. M. McCreight. </author> <title> A space-economical suffix tree construction algorithm. </title> <journal> J. ACM, </journal> <volume> 23(2) </volume> <pages> 262-272, </pages> <month> Apr. </month> <year> 1976. </year>
Reference-contexts: The suffix tree is an index-like structure formed from a string that allows many kinds of fast queries about the string. What makes the suffix tree attractive is that its size and its construction time are linear in the length of the text <ref> [19, 14, 17] </ref>. Suffix trees have a wide variety of applications. Apostolico [4] cites over forty references on suffix trees, and Manber and Myers [13] mention several newer ones. <p> If the alphabet size jj is considered constant, the suffix tree can be constructed in time O (n) <ref> [19, 14, 17] </ref> and string matching takes time O (m). The dependency on jj may be linear, logarithmic or constant depending on the implementation of branching. The most compact alternative uses linked lists and has linear dependency on jj. <p> The tests were run on a 90 MHz Pentium PC with 16 Mbytes of memory running Linux operating system. We implemented the standard suffix tree construction <ref> [14, 17] </ref>, the suffix array construction by sorting [13], and both of the suffix cactus construction algorithms described in the previous section. Table 1 gives the execution times and the space requirements of these construction algorithms. The space requirements include the text.
Reference: 15. <author> E. W. Myers. </author> <title> A sublinear algorithm for approximate keyword searching. </title> <journal> Algorith mica, </journal> 12(4/5):345-374, Oct./Nov. 1994. 
Reference-contexts: The suffix tree provides the information about common prefixes. It can be replaced by another suffix structure. The above method for approximate string matching is more efficient than the basic text scan method only with short patterns and small values of k. However, Myers <ref> [15] </ref> has developed a method to do efficient approximate string matching even with long patterns and large k. The method divides the pattern into smaller parts whose approximate occurrences with small edit distance limit are searched separately.
Reference: 16. <institution> Nucleic Acids Research, 20(Sequences Supplement):2009-2210, </institution> <month> May </month> <year> 1992. </year>
Reference-contexts: The basic search type is string matching, i.e. searching for the occurrences of a pattern string in the text. Other useful forms of queries include regular expression matching and approximate string matching. Examples of very large texts requiring fast searching are electronic dictionaries [8], and biological sequence databases <ref> [16] </ref>. To work efficiently, the whole suffix tree must fit in the main memory. Thus the space requirement of the suffix tree is an important issue.
Reference: 17. <author> E. Ukkonen. </author> <title> Constructing suffix trees on-line in linear time. </title> <editor> In J. van Leeuwen, editor, </editor> <booktitle> Algorithms, Software, Architecture. Information Processing 92, </booktitle> <volume> volume 1, </volume> <pages> pages 484-492, </pages> <year> 1992. </year> <note> Full version is to appear in Algorithmica. </note>
Reference-contexts: The suffix tree is an index-like structure formed from a string that allows many kinds of fast queries about the string. What makes the suffix tree attractive is that its size and its construction time are linear in the length of the text <ref> [19, 14, 17] </ref>. Suffix trees have a wide variety of applications. Apostolico [4] cites over forty references on suffix trees, and Manber and Myers [13] mention several newer ones. <p> If the alphabet size jj is considered constant, the suffix tree can be constructed in time O (n) <ref> [19, 14, 17] </ref> and string matching takes time O (m). The dependency on jj may be linear, logarithmic or constant depending on the implementation of branching. The most compact alternative uses linked lists and has linear dependency on jj. <p> The tests were run on a 90 MHz Pentium PC with 16 Mbytes of memory running Linux operating system. We implemented the standard suffix tree construction <ref> [14, 17] </ref>, the suffix array construction by sorting [13], and both of the suffix cactus construction algorithms described in the previous section. Table 1 gives the execution times and the space requirements of these construction algorithms. The space requirements include the text.
Reference: 18. <author> E. Ukkonen and D. Wood. </author> <title> Approximate string matching with suffix automata. </title> <journal> Algorithmica, </journal> <volume> 10(5) </volume> <pages> 353-364, </pages> <month> Nov. </month> <year> 1993. </year>
Reference-contexts: Both of these problems can be solved by scanning the text. Regular expression matching takes O (n) time (excluding the preprocessing of the regular expression) [1] and approximate string matching O (kn) time <ref> [7, 18] </ref>. Baeza-Yates and Gonnet have described methods to use the suffix tree to do both regular expression matching [5] and approximate string matching [6]. The latter idea was also independently mentioned in [10, Remark 2].
Reference: 19. <author> P. Weiner. </author> <title> Linear pattern matching algorithms. </title> <booktitle> In Proc. IEEE 14th Annual Sym posium on Switching and Automata Theory, </booktitle> <pages> pages 1-11, </pages> <year> 1973. </year> <title> This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: The suffix tree is an index-like structure formed from a string that allows many kinds of fast queries about the string. What makes the suffix tree attractive is that its size and its construction time are linear in the length of the text <ref> [19, 14, 17] </ref>. Suffix trees have a wide variety of applications. Apostolico [4] cites over forty references on suffix trees, and Manber and Myers [13] mention several newer ones. <p> The matching of the parts can be done with the method of Baeza-Yates and Gonnet; Myers uses a slightly different method. 1.3 Suffix Tree and Suffix Array The suffix tree discovered by Weiner <ref> [19] </ref> is a compact version of the suffix trie. It is formed by catenating each unary node (a node with exactly one child) with its child. An example is shown in Fig. 2 (a). <p> If the alphabet size jj is considered constant, the suffix tree can be constructed in time O (n) <ref> [19, 14, 17] </ref> and string matching takes time O (m). The dependency on jj may be linear, logarithmic or constant depending on the implementation of branching. The most compact alternative uses linked lists and has linear dependency on jj.
References-found: 19

