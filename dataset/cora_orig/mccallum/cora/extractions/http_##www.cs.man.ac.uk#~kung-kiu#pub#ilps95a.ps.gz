URL: http://www.cs.man.ac.uk/~kung-kiu/pub/ilps95a.ps.gz
Refering-URL: http://www.cs.man.ac.uk/~kung-kiu/pub/
Root-URL: http://www.cs.man.ac.uk
Email: kung-kiu@cs.man.ac.uk  ornaghi@hermes.mc.dsi.unimi.it  
Title: A Formal Approach to Deductive Synthesis of Constraint Logic Programs  
Author: Kung-Kiu Lau Mario Ornaghi 
Address: Oxford Road, Manchester M13 9PL, United Kingdom  Milano, Via Comelico 39/41, Milano, Italy  
Affiliation: Department of Computer Science, University of Manchester  Dipartimento di Scienze dell'Informazione Universita' degli studi di  
Abstract: Formal program synthesis is concerned with deriving programs that are (formally) correct wrt their specifications, and is therefore of crucial importance to formal development of verifiably correct software. Declarative paradigms such as logic programming are particularly suitable for program synthesis, and we have formulated a formal approach to synthesising standard logic programs. Our approach is object-oriented in the sense that it allows the synthesis of modular, reusable, and hence maintainable programs. In this paper, we propose a formal approach to syn-thesising constraint logic programs based on our current work. We will show that this approach can be used to synthesise modular and reusable CLP programs. An integral part of this paper is the introduction of an abstract semantics to reason about the synthesis of CLP programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Bertoni, G. Mauri and P. Miglioli. </author> <title> On the power of model theory in specifying abstract data types and in capturing their recursiveness. </title> <note> Fundamenta Informaticae VI(2):127-170, </note> <year> 1983. </year>
Reference-contexts: It should therefore define not only the abstract data types (ADT's) involved, but also their salient properties, e.g. induction axioms, for reasoning purposes. Furthermore, F should have a good semantics to allow us to reason precisely and soundly about specifications, synthesis and programs. We have used isoinitial semantics <ref> [1] </ref> since we believe it is the right choice for this purpose. In this section, we give a brief description of the main features of specification frameworks with isoinitial semantics. More details can be found in [11]. We distinguish between closed and open frameworks. <p> This is due to the fact that isomorphic embeddings preserve relations and their negations. Furthermore, isoinitial semantics has the advantage that we have the following criterion for the existence of isoinitial models of full first-order theories (see <ref> [1] </ref>): Theorem 2.1 If a theory F has at least one reachable model, then F admits an isoinitial model if and only if it is atomically complete. <p> of natural numbers N . 2.2 Reasoning about Synthesis In a given specification framework F , we can specify many different problems, i.e. relations to be computed. 4 More precisely, all isoinitial models are isomorphic, and the intended model is one such model. 5 See [15] for a survey, and <ref> [1] </ref> for an extensive comparison of the two kinds of semantics. <p> Then T has an isoinitial model iff T is atomically decidable. The proof is based on the following construction, which associates the theory T with a structure D T (as in <ref> [1] </ref>). This structure is built in a similar manner to Herbrand models, but it is based on data constraints instead of ground terms. In the construction of D T , we do not make use of L-reachability. <p> Now we can prove that an L-reachable T has an isoinitial model if and only if it is atomically decidable. We shall make use of a theorem in <ref> [1] </ref> (Theorem 5.4, p.158) which essentially says that a theory T has an isoinitial model iff D T is a model of T , and T is atomically decidable. To apply this theorem, each equivalence class [ffi (x)] must be representable by an existential formula (see end of Section 3.2). <p> To apply this theorem, each equivalence class [ffi (x)] must be representable by an existential formula (see end of Section 3.2). Assume that T has an isoinitial model. Then, by the theorem in <ref> [1] </ref>, D T is an isoinitial model and T is atomically decidable. Now, assume that the hypotheses of our theorem are satisfied. Then D T can be constructed, since the set of ffi (x) such that T ` 9!x ffi (x) is not empty. <p> Since D and D T are isomorphic and D is a model of T , D T is a model of T and, again by the theorem in <ref> [1] </ref>, it is an isoinitial model. 2 An important corollary of Theorem 3.1 is that for every constraint domain (D; L) such that T is L-reachable wrt to D, D and D T are isomorphic (isoinitial) models. <p> That is, for every model M of T there is an isomorphic embedding : D T ! M , but the unicity of is no longer guaranteed. This causes the loss of abstractness (see <ref> [1] </ref>). However, we can recover isoinitiality by expanding the language of T as follows. For each equivalence class [ffi (x)] that is not representable by an existential formula, we introduce a new atomic formula r (x), by a definition axiom 8x (r (x) $ ffi (x)).
Reference: [2] <author> M. Bugliesi, E. Lamma and P. Mello. </author> <title> Modularity in logic programming. </title> <journal> J. Logic Programming 19,20:443-502, </journal> <note> 1994. Special issue: Ten years of logic programming. </note>
Reference-contexts: We have chosen this simple example for brevity. Nevertheless, it makes the important point that we can prove steadfastness in CLP. Moreover, steadfastness is the natural characterisation of correctness of CLP modules. In this respect, it is related to the compositional semantics of <ref> [2, 7] </ref>. Thus we have shown that our approach can be used to synthesise reusable CLP modules. More interestingly, parameters of an open constraint specification framework can themselves be instantiated by constraint domains.
Reference: [3] <author> C.C. Chang and H.J. Keisler. </author> <title> Model Theory. </title> <publisher> North-Holland, </publisher> <year> 1973. </year>
Reference-contexts: In isoinitial semantics, the intended model of a theory F is the isoinitial model 4 (when it exists), namely a model I of F such that for every other model M of F, there is a unique isomorphic embedding (see e.g. <ref> [3] </ref>) of I in M .
Reference: [4] <author> K.L. Clark. </author> <title> Negation as failure. </title> <editor> In H. Gallaire and J. Minker, editors, </editor> <booktitle> Logic and Data Bases, </booktitle> <pages> pages 293-322. </pages> <publisher> Plenum Press, </publisher> <year> 1978. </year>
Reference-contexts: We call such a criterion a halting criterion. Now we state these criteria. They are based on the completion C omp (P ) of a program P <ref> [4, 9] </ref>, and are similar to our criteria for synthesis in standard LP [12]. Consider synthesis in the constraint specification framework F T containing the constraint theory T .
Reference: [5] <author> Y. Deville and K.K. Lau. </author> <title> Logic program synthesis. </title> <journal> J. Logic Programming 19,20:321-350, </journal> <note> 1994. Special issue: Ten years of logic programming. </note>
Reference-contexts: However, in this paper, for lack of space, we will concentrate on closed frameworks, and only briefly consider open frameworks in Section 5. 2 A survey of such methods can be found in <ref> [5] </ref>. 3 Our semantics is a contribution to the semantics of CLP programs. In this paper, however, we will consider only constraint domains without limit elements. 2.1 Closed Frameworks A first-order theory T with signature is a set of closed formulas of the (first-order) language L generated by .
Reference: [6] <author> Y. Deville and P. Van Hentenryck. </author> <title> Construction of CLP Programs. In D.R. </title> <editor> Brough, editor, </editor> <booktitle> Logic Programming: New Frontiers, </booktitle> <pages> pages 112-135, </pages> <publisher> Kluwer, </publisher> <year> 1992. </year>
Reference-contexts: More interestingly, parameters of an open constraint specification framework can themselves be instantiated by constraint domains. Our approach therefore provides a basis for object-oriented CLP software engineering. 6 Conclusion To date, the only work (as far as we are aware) on constructing CLP programs from specifications is <ref> [6] </ref>. However, their approach is different from ours in that it is informal, whereas ours is completely formal, the advantage of a formal approach being that it can formally verify correctness. In our approach, we start from constraint specification frameworks. These are specification frameworks that contain constraint theories.
Reference: [7] <author> M. Gabbrielli, G.M. Dore and G. Levi. </author> <title> Observable semantics for constraint logic programs. </title> <note> To appear in J. Logic and Computation. </note>
Reference-contexts: We have chosen this simple example for brevity. Nevertheless, it makes the important point that we can prove steadfastness in CLP. Moreover, steadfastness is the natural characterisation of correctness of CLP modules. In this respect, it is related to the compositional semantics of <ref> [2, 7] </ref>. Thus we have shown that our approach can be used to synthesise reusable CLP modules. More interestingly, parameters of an open constraint specification framework can themselves be instantiated by constraint domains. <p> Whichever way we choose to axiomatise (D; L) , we need suitable conditions for the validity of our halting criterion. We are concerned with a good semantics for synthesis, not just for computation (e.g. <ref> [7] </ref>), which enables us to reason precisely and soundly about synthesis. To this end, our constraint specification frameworks are endowed with isoinitial semantics. This provides an abstract semantics for defining the meaning of specifications and program correctness. This semantics is thus a major contribution of this paper.
Reference: [8] <author> J. Jaffar and J.L. Lassez. </author> <title> Constraint logic programming. </title> <booktitle> In Proc. 14 th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1987. </year>
Reference-contexts: Our approach can indeed be used to synthesise modular and reusable (and hence maintainable) programs. Moreover, the formal framework that underlies our approach is very general, and it should be equally applicable to the synthesis of constraint logic programs <ref> [8, 9] </ref>. In this paper, we propose a formal approach to deductive synthesis of CLP programs, based on our work in standard LP. Our approach to synthesis in standard LP is deductive [10, 12, 11], i.e. it iteratively derives clauses for a program from its specification.
Reference: [9] <author> J. Jaffar and M. Maher. </author> <title> Constraint logic programming: A survey. </title> <journal> J. Logic Programming 19,20:503-581, </journal> <note> 1994. Special issue: Ten years of logic programming. </note>
Reference-contexts: Our approach can indeed be used to synthesise modular and reusable (and hence maintainable) programs. Moreover, the formal framework that underlies our approach is very general, and it should be equally applicable to the synthesis of constraint logic programs <ref> [8, 9] </ref>. In this paper, we propose a formal approach to deductive synthesis of CLP programs, based on our work in standard LP. Our approach to synthesis in standard LP is deductive [10, 12, 11], i.e. it iteratively derives clauses for a program from its specification. <p> To this end, we shall define constraint theories, i.e. theories that correspond to constraint domains. Then we define constraint specification frameworks as extensions of constraint theories. 3.1 CLP Terminology First we recall some basic CLP terminology. We will follow Jaffar and Maher <ref> [9] </ref>, but we will be very brief and somewhat informal. <p> Elements of D that can only be represented by an infinite set of constraints are called limit elements. 8 This is briefly discussed in [12]. 9 L is the whole language, not to be confused with L in <ref> [9] </ref> which is a sub-language of L . 3.2 Constraint Theories In this section, we will state the CLP counterpart to Theorem 2.1, namely an existence criterion for the isoinitial models of the theory T in a CLP-instance. <p> We can now give a criterion for determining if a L-reachable theory T has an isoinitial model. We recall from <ref> [9] </ref> that L is normally assumed to be the smallest subset of L that contains the atomic formulas and is closed under ^ and 9. <p> For now, we call these constraints T -constraints. 11 If the set of T -constraints is not empty, then we can 10 A data constraint thus identifies a single element of D, and we use ffi (x) to distinguish it. In <ref> [9] </ref>, x is said to be determined or grounded by ffi. 11 They become data constraints when we prove D T to be a model. construct the structure D T as described below. <p> We call such a criterion a halting criterion. Now we state these criteria. They are based on the completion C omp (P ) of a program P <ref> [4, 9] </ref>, and are similar to our criteria for synthesis in standard LP [12]. Consider synthesis in the constraint specification framework F T containing the constraint theory T . <p> This follows easily from point 2 of Theorem 6.1 in <ref> [9] </ref>. <p> This follows from points 2, 4 and 6 of Theorem 6.1 in <ref> [9] </ref>, using the hypotheses of L-reachability and termination. Looking at Example 4.2, we see that PA [ D prod ` C omp (P 2 ; prod). <p> Then P [ d iag (q 1 ; : : : ; q m ) is semantically correct in F T [ I T [ D P , i.e. the minimum D T - model of P (as defined in <ref> [9] </ref>) interprets p 1 ; : : : ; p n in the same way as the isoinitial model of F T [ I T expanded according to the definition axioms D P .
Reference: [10] <author> K.K. Lau and M. Ornaghi. </author> <title> An incompleteness result for deductive synthesis of logic programs. </title> <editor> In D.S. Warren, editor, </editor> <booktitle> Proc. 10 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 456-477, </pages> <publisher> MIT Press, </publisher> <year> 1993. </year>
Reference-contexts: In this paper, we propose a formal approach to deductive synthesis of CLP programs, based on our work in standard LP. Our approach to synthesis in standard LP is deductive <ref> [10, 12, 11] </ref>, i.e. it iteratively derives clauses for a program from its specification.
Reference: [11] <author> K.K. Lau and M. Ornaghi. </author> <title> On specification frameworks and deductive synthesis of logic programs. </title> <editor> In L. Fribourg and F. Turini, editors, </editor> <booktitle> Proc. LOPSTR 94 and META 94 , Lecture Notes in Computer Science 883, </booktitle> <pages> pages 104-121, </pages> <publisher> Springer-Verlag, </publisher> <year> 1994. </year>
Reference-contexts: In this paper, we propose a formal approach to deductive synthesis of CLP programs, based on our work in standard LP. Our approach to synthesis in standard LP is deductive <ref> [10, 12, 11] </ref>, i.e. it iteratively derives clauses for a program from its specification. <p> A steadfast program can be correctly (re)used in a class of computation domains. Therefore steadfastness provides a basis for modular programming. Furthermore, specification frameworks (both open and closed) can be constructed, and thus maintained, in an incremental manner by using the result of synthesis itself, as we showed in <ref> [11] </ref>. Thus, altogether our approach can provide a basis for object-oriented LP software engineering. In this paper, we extend our approach to the synthesis of CLP programs. <p> We have used isoinitial semantics [1] since we believe it is the right choice for this purpose. In this section, we give a brief description of the main features of specification frameworks with isoinitial semantics. More details can be found in <ref> [11] </ref>. We distinguish between closed and open frameworks. Intuitively a closed framework completely characterises a unique intended model (under isoinitial semantics), whereas an open framework has a class of intended models. <p> For instance elemr might be instantiated by some ordering relation. As discussed in <ref> [12, 11] </ref>, in an adequate open framework F T : ( , we can specify and synthesise open programs of the form P : p 1 ; : : : ; p n ( q 1 ; : : : ; q m , where p 1 ; : : :
Reference: [12] <author> K.K. Lau, M. Ornaghi and S.-. A. </author> <title> Tarnlund. The halting problem for deductive synthesis of logic programs. </title> <editor> In P. van Hentenryck, editor, </editor> <booktitle> Proc. 11 th Int. Conf. on Logic Programming, </booktitle> <pages> pages 665-683, </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: In this paper, we propose a formal approach to deductive synthesis of CLP programs, based on our work in standard LP. Our approach to synthesis in standard LP is deductive <ref> [10, 12, 11] </ref>, i.e. it iteratively derives clauses for a program from its specification. <p> More interestingly, from the point of view of object-oriented synthesis, specification frameworks may be open, i.e. not completely defined and hence parametric. In such frameworks, we can synthesise steadfast, or modular and reusable, programs <ref> [12] </ref>. A steadfast program can be correctly (re)used in a class of computation domains. Therefore steadfastness provides a basis for modular programming. <p> It is usually assumed that every element of D can be represented by a (possibly infinite) set of constraints. Elements of D that can only be represented by an infinite set of constraints are called limit elements. 8 This is briefly discussed in <ref> [12] </ref>. 9 L is the whole language, not to be confused with L in [9] which is a sub-language of L . 3.2 Constraint Theories In this section, we will state the CLP counterpart to Theorem 2.1, namely an existence criterion for the isoinitial models of the theory T in a <p> We call such a criterion a halting criterion. Now we state these criteria. They are based on the completion C omp (P ) of a program P [4, 9], and are similar to our criteria for synthesis in standard LP <ref> [12] </ref>. Consider synthesis in the constraint specification framework F T containing the constraint theory T . <p> Thus P 2 is totally correct, i.e. the synthesis process can successfully halt. 5 Synthesis in Open Frameworks In our work in synthesis in standard LP, the single most important result, from the point of view of object-oriented synthesis, is the characterisation of steadfast programs <ref> [12] </ref>. Such a program can be synthesised in an open specification framework, and thus it contains parameters. However, it can be synthesised once and for all, and then reused correctly with any programs that correctly compute its parameters. <p> For instance elemr might be instantiated by some ordering relation. As discussed in <ref> [12, 11] </ref>, in an adequate open framework F T : ( , we can specify and synthesise open programs of the form P : p 1 ; : : : ; p n ( q 1 ; : : : ; q m , where p 1 ; : : :
Reference: [13] <author> J.W. Lloyd. </author> <title> Practical advantages of declarative programming. </title> <booktitle> Invited talk at 1994 Joint Conference on Declarative Programming. </booktitle>
Reference-contexts: For practical software engineering, however, we need techniques that can synthesise modular, reusable, and hence maintainable software. Declarative paradigms such as logic programming provide particularly suitable formalisms for program synthesis. Indeed in <ref> [13] </ref>, Lloyd cites synthesis as `the ultimate goal' of declarative programming. We share this view, and have formulated a formal approach to the synthesis of standard logic programs. Our approach can indeed be used to synthesise modular and reusable (and hence maintainable) programs.
Reference: [14] <author> J.C. Shepherdson. </author> <title> Negation in logic programming. </title> <editor> In J. Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 19-88. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1988. </year>
Reference-contexts: Normally, will be understood and we will omit it. A closed framework F is a (first-order) theory with the following key properties: * Freeness. A subset of the constant and function symbols of F , which we shall call the construction symbols, satisfy the freeness axioms <ref> [14] </ref>. * Reachability. There is at least one model of F reachable by the construction symbols. This means that every element of the domain of the model is represented by a ground term using the construction symbols. We will call such a term a construction. * Atomic completeness.
Reference: [15] <author> M. Wirsing. </author> <title> Algebraic specification. </title> <editor> In J. Van Leeuwen, editor, </editor> <booktitle> Handbook of Theoretical Computer Science, </booktitle> <pages> pages 675-788. </pages> <publisher> Elsevier, </publisher> <year> 1990. </year>
Reference-contexts: is just the standard structure of natural numbers N . 2.2 Reasoning about Synthesis In a given specification framework F , we can specify many different problems, i.e. relations to be computed. 4 More precisely, all isoinitial models are isomorphic, and the intended model is one such model. 5 See <ref> [15] </ref> for a survey, and [1] for an extensive comparison of the two kinds of semantics.
References-found: 15

