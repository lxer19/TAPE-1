URL: http://www.cs.yale.edu/~kao-ming-yang/kao_Unrooted_Evolutionary_Trees.ps
Refering-URL: http://www.cs.yale.edu/~kao-ming-yang/papers.html
Root-URL: http://www.cs.yale.edu
Title: LABEL COMPRESSIONS AND UNROOTED EVOLUTIONARY TREES  
Author: MING-YANG KAO TAK-WAH LAM WING-KIN SUNG AND HING-FUNG TING 
Abstract: We present an algorithm for computing a maximum agreement subtree for two unrooted evolutionary trees. It takes O(n 1:5 log n) time for trees with unbounded degrees, matching the best algorithm for the rooted case. The time complexity reduces to O(n log 4 n) if the input trees have degrees bounded by a constant. Our algorithm allows the input trees to be mixed trees, i.e., trees which may contain directed and undirected edges at the same time. Unlike previous algorithms, our algorithm is not based on dynamic programming. Instead it adopts a recursive strategy exploiting a technique called label compression. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agarwala and D. Fernandez-Baca. </author> <title> A polynomial-time algorithm for the perfect phylogeny problem when the number of character states is fixed. </title> <journal> SIAM Journal on Computing, </journal> <volume> 23(6) </volume> <pages> 1216-1224, </pages> <year> 1994. </year>
Reference-contexts: Since both the first and the second cases are not satisfied, a maximum agreement subtree of U 1 and U 2 is labeled over some J i . Therefore, mast (U 1 ; U 2 ) = maxfmast (U 1;i ; U 2 kJ i ) j i 2 <ref> [1; b] </ref>g, and we compute each mast (U 1;i ; U 2 kJ i ) recursively. the time complexity T (N ) based on Lemma 2.2. Cases 1 and 2 each take ' 3 (N; N; d) time. Let N i = jU 1;i j. <p> mast (U x 1 ; ~ U 2 ); let U 1;1 ; U 1;2 ; : : : ; U 1;b be the evolutionary trees formed by the connected components of U 1 fxg; let J i be the set of labels of U 1;i for all i 2 <ref> [1; b] </ref>; for all i 2 [1; b] val i = mast (U 1;i ; U 2 kJ i )g; return maxfval; val 0 ; max 1ib val i g Fig. 1. Algorithm for mast (U 1 ; U 2 ). time bound in Theorem 2.1 follows from these inequalities. <p> U 2 ); let U 1;1 ; U 1;2 ; : : : ; U 1;b be the evolutionary trees formed by the connected components of U 1 fxg; let J i be the set of labels of U 1;i for all i 2 <ref> [1; b] </ref>; for all i 2 [1; b] val i = mast (U 1;i ; U 2 kJ i )g; return maxfval; val 0 ; max 1ib val i g Fig. 1. Algorithm for mast (U 1 ; U 2 ). time bound in Theorem 2.1 follows from these inequalities. <p> Let A (T; K; y) = fT v 1 ; T v 2 ; : : : ; T v k g. We store the following values at z: * ff 1 (z) = maxfmast (T v i ; R 1 ) j i 2 <ref> [1; k] </ref>g; * ff 2 (z) = maxfmast (T v i ; R 2 ) j i 2 [1; k]g; 7 * ff + (z) = maxfmast (T v i ; R + ) j i 2 [1; k]g; * fi (z) = maxfmast (T v i ; R 1 ) <p> We store the following values at z: * ff 1 (z) = maxfmast (T v i ; R 1 ) j i 2 <ref> [1; k] </ref>g; * ff 2 (z) = maxfmast (T v i ; R 2 ) j i 2 [1; k]g; 7 * ff + (z) = maxfmast (T v i ; R + ) j i 2 [1; k]g; * fi (z) = maxfmast (T v i ; R 1 ) + mast (T v i 0 ; R 2 ) j T v i and T v i <p> (z) = maxfmast (T v i ; R 1 ) j i 2 <ref> [1; k] </ref>g; * ff 2 (z) = maxfmast (T v i ; R 2 ) j i 2 [1; k]g; 7 * ff + (z) = maxfmast (T v i ; R + ) j i 2 [1; k]g; * fi (z) = maxfmast (T v i ; R 1 ) + mast (T v i 0 ; R 2 ) j T v i and T v i 0 are distinct subtrees in A (T; K; y)g. <p> ; X 1 ); (W 2 ; X 2 ); : : : ; (W b ; X b )g */ new subproblem (W; X; y) let v 1 ; v 2 ; : : : ; v b be the neighbors of y in X; for all i 2 <ref> [1; b] </ref> let X i be the unrooted tree formed by shrinking the subtree X v i y into a shrunk leaf; let W i be the rooted tree formed by compressing W with respect to X v i y ; compute and store the auxiliary information in W i for <p> i be the unrooted tree formed by shrinking the subtree X v i y into a shrunk leaf; let W i be the rooted tree formed by compressing W with respect to X v i y ; compute and store the auxiliary information in W i for all i 2 <ref> [1; b] </ref> Fig. 3. <p> (W 2 ; X 2 ), : : :, mast (W b ; X b )g such that their total size is n and maxfmast (W; X z ) j z is an internal node and z 6= yg = maxfmast (W i ; X i ) j i 2 <ref> [1; b] </ref>g. <p> Assume that the separator y has b neighbors in X, namely, v 1 ; v 2 ; : : : ; v b . Note that b d, the maximum degree of U 1 and U 2 . For each i 2 <ref> [1; b] </ref>, let C i be the connected component in X fyg that contains v i . The size of C i is at most half that of X. <p> Proof. Let T (n) be the computation time of mast (W; X). The computation is divided into two cases. Case 1 of x4.1 takes ' 2 (n; N; d) time. For Case 2, a set of subproblems, fmast (W i ; X i ) j i 2 <ref> [1; b] </ref>g, are generated. As to be shown in x5 and x6, the time to prepare all these subproblems is also ' 2 (n; N; d). These subproblems, except possibly one, are each of size less than n=2. <p> Therefore, the overall computation time for preprocessing and finding auxiliary information in the leaves of all W i is ' 2 (n; N; d). 5.2. Auxiliary information in the internal nodes of W i . Consider any internal node v in W i , i 2 <ref> [1; b] </ref>. We want to compute the auxiliary information ff (v) = mast (W v ; R i ). Note that R i may be of size fi (n). <p> Exploiting this similarity and making use of an efficient algorithm for the all-cavity maximum matching [22], we can perform a ' 2 (n; N; d) time preprocessing, and then we can retrieve mast (W v ; R i ) for any internal node v in W and i 2 <ref> [1; b] </ref> in O (log 2 n) time. Therefore, it takes O (jW i j log 2 n) time to compute ff (v) for all internal nodes v of one particular W i , and O (n log 2 n) time for all W i . Details are as follows. <p> Thus, the total size of all R i is at most n. The following lemma extends Lemmas 3.2 and 3.4. Lemma 5.2. We can compute mast (W; R i ) for all i 2 <ref> [1; b] </ref> in ' 2 (n; N; d) total time. Afterwards, we can retrieve mast (W v ; R i ) for any node v in W and i 2 [1; b] in O (log n) time. Proof. Let J i be the set of labels in R i . <p> Lemma 5.2. We can compute mast (W; R i ) for all i 2 <ref> [1; b] </ref> in ' 2 (n; N; d) total time. Afterwards, we can retrieve mast (W v ; R i ) for any node v in W and i 2 [1; b] in O (log n) time. Proof. Let J i be the set of labels in R i . From Lemma 3.4, all the mast (W kJ i ; R i ), i 2 [1; b], can be computed in P 12 [1;b] ' 2 (jR i j; N; d) <p> (W v ; R i ) for any node v in W and i 2 <ref> [1; b] </ref> in O (log n) time. Proof. Let J i be the set of labels in R i . From Lemma 3.4, all the mast (W kJ i ; R i ), i 2 [1; b], can be computed in P 12 [1;b] ' 2 (jR i j; N; d) = ' 2 (n; N; d) total time. Afterwards, we can retrieve mast ((W kJ i ) v ; R i ) for any i 2 [1; b] and v 2 W kJ i in <p> kJ i ; R i ), i 2 <ref> [1; b] </ref>, can be computed in P 12 [1;b] ' 2 (jR i j; N; d) = ' 2 (n; N; d) total time. Afterwards, we can retrieve mast ((W kJ i ) v ; R i ) for any i 2 [1; b] and v 2 W kJ i in O (1) time. <p> The lemma follows. Below, we give a formula which enables us to compute mast (W v ; R i ) efficiently. For any z 2 W and i 2 <ref> [1; b] </ref>, let r-mast (W z ; R i ) denote the maximum size among all the agreement subtrees of W z and R i in which z (i.e., the root of W z ) is mapped to the root of R i . <p> Lemma 5.3. mast (W v ; R i ) = max ( maxfmast (W v ; R j ) j j 2 <ref> [1; b] </ref>; j 6= ig; maxfr-mast (W z ; R i ) j z 2 W v g: Proof. <p> We perform some preprocessing on W and X and build a different data structure for each part. From Lemma 5.2, after a ' 2 (n; N; d) time preprocessing, we can retrieve mast (W v ; R i ) for any v in W and any i 2 <ref> [1; b] </ref> in O (log n) time. Based on the set of values fmast (W v ; R i ) j i 2 [1; b] and v 2 W i g, we can perform a preprocessing in 13 O (n log 2 n) time, and then we can determine maxfmast (W <p> a ' 2 (n; N; d) time preprocessing, we can retrieve mast (W v ; R i ) for any v in W and any i 2 <ref> [1; b] </ref> in O (log n) time. Based on the set of values fmast (W v ; R i ) j i 2 [1; b] and v 2 W i g, we can perform a preprocessing in 13 O (n log 2 n) time, and then we can determine maxfmast (W v ; R j ) j j 2 [1; b]; j 6= ig (5) for any v 2 W and i 2 [1; <p> the set of values fmast (W v ; R i ) j i 2 <ref> [1; b] </ref> and v 2 W i g, we can perform a preprocessing in 13 O (n log 2 n) time, and then we can determine maxfmast (W v ; R j ) j j 2 [1; b]; j 6= ig (5) for any v 2 W and i 2 [1; b] in O (log 2 n) time (see [10]). The computation of maxfr-mast (W z ; R i ) j z 2 W v g is more difficult. <p> <ref> [1; b] </ref> and v 2 W i g, we can perform a preprocessing in 13 O (n log 2 n) time, and then we can determine maxfmast (W v ; R j ) j j 2 [1; b]; j 6= ig (5) for any v 2 W and i 2 [1; b] in O (log 2 n) time (see [10]). The computation of maxfr-mast (W z ; R i ) j z 2 W v g is more difficult. For one thing, for a fixed v and i, there may already be n values involved in the expression. <p> Let m = z2W m z . We show that in O (m log 2 m) time we can build a data structure on top of all the sparse arrays A (z) such that we can retrieve for any v 2 W and i 2 <ref> [1; b] </ref> the value of maxfA (z)[i] j z 2 W v g in O (log m) time. From Lemma 5.5, we have m z d z + 1 for all z 2 W . <p> Hence, the total preprocessing time is O (n log 2 n) and the retrieval time of (6) is O (log n). To summarize, after all the preprocessings, we can retrieve maxfmast (W v ; R j ) j j 2 <ref> [1; b] </ref>; j 6= ig in O (log 2 n) time and maxfr-mast (W z ; R i ) j z 2 W v g in O (log n) time. Hence, for any v 2 W and i 2 [1; b], mast (W v ; R i ) can be computed <p> retrieve maxfmast (W v ; R j ) j j 2 <ref> [1; b] </ref>; j 6= ig in O (log 2 n) time and maxfr-mast (W z ; R i ) j z 2 W v g in O (log n) time. Hence, for any v 2 W and i 2 [1; b], mast (W v ; R i ) can be computed in O (log 2 n) time. To complete our discussion, we show below how to construct a sparse array A (z) or equivalently compute the values fmwm (G z;i ) j i 2 [1; b]g efficiently. <p> 2 W and i 2 <ref> [1; b] </ref>, mast (W v ; R i ) can be computed in O (log 2 n) time. To complete our discussion, we show below how to construct a sparse array A (z) or equivalently compute the values fmwm (G z;i ) j i 2 [1; b]g efficiently. We cannot afford to examine every G z;i and compute mwm (G z;i ) separately. Instead we build only one weighted bipartite graph G z Ch (z) fi fR 1 ; : : : ; R b g as follows. <p> Based on [10], we can perform an O (n log 2 n) preprocessing, and afterwards we can retrieve the value maxfmast (W u ; R j ) j j 2 Ig for any u 2 W and I <ref> [1; b] </ref> in O (log 2 n) time. Since there are at most (z) R i which are connected to some non-max-child of z, all the other R i are partitioned into at most (z) + 1 groups with consecutive indices. <p> Let G z R i denote the bipartite subgraph constructed by removing node R i from G z . 15 Lemma 5.6. For all i 2 <ref> [1; b] </ref>, mwm (G z R i ) = mwm (G z;i ). Furthermore, the graph G z can be built in O (minf ((z) + b) log n; ((z) + 1) log 2 ng) time. Proof. <p> Furthermore, the graph G z can be built in O (minf ((z) + b) log n; ((z) + 1) log 2 ng) time. Proof. The fact that mwm (G z R i ) = mwm (G z;i ) for all i 2 <ref> [1; b] </ref> follows from the construction of G z . Note that G z is a graph containing O (jCh (z)j + b) nodes and O ((z) + 1) edges. <p> It is shown in [22] that the same amount of time suffices to compute mwm (G z R i ) for all i 2 <ref> [1; b] </ref> and store the results in a sparse array A (z). In conclusion, all the G z , z 2 W , can be constructed in P z2W minfO (((z) + b) log n); O ((z) + 1) log 2 n)g total time. <p> Also, for every i 2 <ref> [1; b] </ref>, R i and R i denote the subtrees X v i y and X yv i , respectively. Without loss of generality, we assume that the shrunk leaf of X is in R b . <p> Moreover, v is compressed from some subtrees attached to the nodes p i . For every 17 i 2 <ref> [1; k] </ref>, let Tree i be the set of subtrees of W attached to p i which are compressed into v. Note that both v and the subtrees in [ 1ik Tree i represent the same set of subtrees in T 1 . <p> The auxiliary information stored at v can be expressed as follows. * ff 1 (v) = maxfmast (W q ; fl 1 ) j W q 2 Tree i for some i 2 <ref> [1; k] </ref>g; * ff 2 (v) = maxfmast (W q ; R b ) j W q 2 Tree i for some i 2 [1; k]g; * ff + (v) = maxfmast (W q ; Q + ) j W q 2 Tree i for some i 2 [1; k]g; * <p> be expressed as follows. * ff 1 (v) = maxfmast (W q ; fl 1 ) j W q 2 Tree i for some i 2 <ref> [1; k] </ref>g; * ff 2 (v) = maxfmast (W q ; R b ) j W q 2 Tree i for some i 2 [1; k]g; * ff + (v) = maxfmast (W q ; Q + ) j W q 2 Tree i for some i 2 [1; k]g; * fi (v) = max 1ik [maxfmast (W q ; fl 1 ) + mast (W q 0 ; R b ) j W q <p> i 2 <ref> [1; k] </ref>g; * ff 2 (v) = maxfmast (W q ; R b ) j W q 2 Tree i for some i 2 [1; k]g; * ff + (v) = maxfmast (W q ; Q + ) j W q 2 Tree i for some i 2 [1; k]g; * fi (v) = max 1ik [maxfmast (W q ; fl 1 ) + mast (W q 0 ; R b ) j W q ; W q 0 2 Tree i g]; * fi 12 (v) = max 1j&lt;ik [maxfmast (W q ; fl 1 ) j W
Reference: [2] <author> A. V. Aho, J. E. Hopcroft, and J. D. Ullman. </author> <title> The Design and Analysis of Computer Algorithms. </title> <publisher> Addision Wesley, </publisher> <address> Reading, MA, </address> <year> 1974. </year>
Reference-contexts: For an implementation of sparse array, see Exercise 2.12, page 71 of <ref> [2] </ref>. 14 Before showing how to build these sparse arrays, we first illustrate how they support the computation of mast (W v ; R i ).
Reference: [3] <author> N. Alon and B. Schieber. </author> <title> Optimal preprocessing for answering on-line product queries. </title> <type> Manuscript. </type>
Reference-contexts: Then we can preprocess W and X and construct additional data structures in O (n log fl n) time so that any value of the above types can be retrieved in O (1) time. Proof. By adapting preprocessing techniques for on-line product queries <ref> [3] </ref>. With the preprocessing stated in Lemma 5.1, we can determine ff (v). Note that S v is either a subset of the subtrees attached to a node u in W or the set of subtrees attached to nodes on a particular path in W . <p> To find this value, we need to compute maxfmwm (G z;i ) j z 2 W v g; which equals maxfA (z)[i] j z 2 W v g:(6) Note that (6) is a generalization of tree product queries <ref> [3] </ref>. An efficient preprocessing for answering such queries is given in [21]. Let m z be the number of distinct values in A (z). Let m = z2W m z .
Reference: [4] <author> H. L. Bodlaender, M. R. Fellows, and T. J. Warnow. </author> <title> Two strikes against perfect phylogeny. </title> <booktitle> In Lecture Notes in Computer Science 623: Proceedings of the 19th International Colloquium on Automata, Languages, and Programming, </booktitle> <pages> pages 273-283. </pages> <publisher> Springer-Verlag, </publisher> <address> New York, NY, </address> <year> 1992. </year>
Reference: [5] <author> R. Cole and R. Hariharan. </author> <title> An O(n log n) algorithm for the maximum agreement subtree problem for binary trees. </title> <booktitle> In Proceedings of the 7th Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 323-332, </pages> <year> 1996. </year>
Reference-contexts: The algorithm of Farach, Przytycka and Thorup [8] runs in O (n log 3 n) time, and Kao [20] has also obtained an O (n log 2 n) time algorithm. The case when the inputs are further restricted to binary rooted trees was considered by Cole and Hariharan <ref> [5] </ref>; they gave an O (n log n) time algorithm. For unrooted trees, no similar improvement has been known, however. This paper presents an algorithm for computing a maximum agreement subtree of two unrooted evolutionary trees.
Reference: [6] <author> S. Dress and M. Steel. </author> <title> Convex tree realizations of partitions. </title> <journal> Applied Mathematics Letters, </journal> <volume> 5(3) </volume> <pages> 3-6, </pages> <year> 1992. </year>
Reference: [7] <author> M. Farach, S. Kannan, and T. Warnow. </author> <title> A robust model for finding optimal evolutionary trees. </title> <journal> Algorithmica, </journal> 13(1/2):155-179, 1995. 
Reference: [8] <author> M. Farach, T. Przytycka, and M. </author> <title> Thorup. Computing the agreement of trees with bounded degrees. </title> <booktitle> In Proceedings of the 3rd European Symposium on Algorithms, </booktitle> <pages> pages 381-393, </pages> <year> 1995. </year>
Reference-contexts: Research supported in part by Hong Kong RGC Grants 338/065/0027 and 338/065/0028. Algorithms that work well for rooted trees with degrees bounded by a constant have also been revealed recently. The algorithm of Farach, Przytycka and Thorup <ref> [8] </ref> runs in O (n log 3 n) time, and Kao [20] has also obtained an O (n log 2 n) time algorithm. <p> Let n = maxfjW j; jW 0 jg and ^ N = maxfjT j; jT 0 jg. Let ^ d be the maximum degree of W and W 0 . We can compute mast (W; W 0 ) by modifying existing algorithms for ordinary evolutionary trees <ref> [10, 20, 8] </ref>. Lemma 3.2. Suppose that all the auxiliary information of W has been given. <p> In conclusion, all the G z , z 2 W , can be constructed in P z2W minfO (((z) + b) log n); O ((z) + 1) log 2 n)g total time. As P z2W (z) = O (n log n) <ref> [8] </ref>, the total construction time of all the G z is ' 2 (n; N; d). <p> We can compute mast (W 1 ; W 2 ) as if they are ordinary rooted evolutionary tree with some special procedures on handling shrunk leaves. In fact, our algorithm for computing mast (U 1 ; U 2 ) is obtained by modifying slightly the algorithms in <ref> [10, 20, 8] </ref> for computing a maximum agreement subtree of two ordinary rooted evolutionary trees. 19 A.2. Overview of existing algorithms. We briefly review the algorithms in [10, 20, 8]. Let u and v be internal nodes of two rooted evolutionary trees T 1 and T 2 , respectively. <p> In fact, our algorithm for computing mast (U 1 ; U 2 ) is obtained by modifying slightly the algorithms in <ref> [10, 20, 8] </ref> for computing a maximum agreement subtree of two ordinary rooted evolutionary trees. 19 A.2. Overview of existing algorithms. We briefly review the algorithms in [10, 20, 8]. Let u and v be internal nodes of two rooted evolutionary trees T 1 and T 2 , respectively. <p> Given a node y, let Ch (y) denote the set of children of y. The following formula is the cornerstone of the dynamic programming approach of <ref> [10, 20, 8] </ref>: mast (T u 1 ; T v 8 &gt; : maxfmast (T x 1 ; T v maxfmast (T u 1 ; T 2 ) j y 2 Ch (v)g; r-mast (T u 1 ; T v (8) Given any two subsets A and B of Ch (u) <p> Ch (v)g; r-mast (W u 1 ; W v (9) To compute r-mast (W u 1 ; W v 2 ), we show later that it suffices to compute the maximum weight matching of up to a constant number of bipartite graphs of the same nature as those considered in <ref> [10, 20, 8] </ref>. Moreover, we can ignore many of these bipartite graphs and most of the edges in the remaining ones. <p> Given any subtree t , let J t denote the set of labels over which t is labeled. Observe that all the subtrees in S (P ) contain no shrunk leaf. Using the algorithms in <ref> [10, 20, 8] </ref>, we can compute mast (W 1 kJ t ; t ) for all t 2 S (P ) in ' 2 (n; n; d) time.
Reference: [9] <author> M. Farach and M. </author> <title> Thorup. Fast comparison of evolutionary trees. </title> <booktitle> In Proceedings of the 5th Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 481-488, </pages> <year> 1994. </year>
Reference-contexts: Steel and Warnow [27] gave the first polynomial-time algorithm for general unrooted trees, i.e., those with no restriction on the degrees. Their algorithm runs in O (n 4:5 log n) time. Farach and Thorup <ref> [9] </ref> reduced the time complexity to O (n 2+o (1) ) for unrooted trees and O (n 2 ) for rooted trees. <p> We can obtain U x 1 kJ i by constructing W kJ i . Note that J = S 1ib J i and all the label sets J i are disjoint. Using a procedure in <ref> [9] </ref>, we can construct all the trees W kJ i from W in O (n) time. Next, we show how to construct W i from W kJ i in time linear in the size of W kJ i . <p> Hence, to find mast (T 1 ; T 2 ) based on (8), we need to solve fi (N 2 ) maximum weight matching problems, where N is the size of T 1 and T 2 . These matching problems can be sparsified. Farach and Thorup <ref> [9] </ref> observed that most of the edges in these bipartite graphs can be ignored and the maximum weight matchings of all these bipartite graphs can be computed in O (N 2 ) time.
Reference: [10] <author> M. Farach and M. </author> <title> Thorup. Optimal evolutionary tree comparison by sparse dynamic programming. </title> <booktitle> In Proceedings of the 35th Annual Symposium on the Foundations of Computer Science, </booktitle> <pages> pages 770-779, </pages> <year> 1994. </year>
Reference-contexts: Their algorithm runs in O (n 4:5 log n) time. Farach and Thorup [9] reduced the time complexity to O (n 2+o (1) ) for unrooted trees and O (n 2 ) for rooted trees. More recently, they gave an algorithm for rooted trees <ref> [10] </ref> that runs in O (n 1:5 log n) time, and showed that this time bound cannot be improved unless there is a breakthrough in a longstanding open problem of maximum bipartite matching. <p> For unrooted trees, no similar improvement has been known, however. This paper presents an algorithm for computing a maximum agreement subtree of two unrooted evolutionary trees. It takes O (n 1:5 log n) time for trees with unbounded degrees, matching the best algorithm for the rooted case <ref> [10] </ref>. If the degrees are bounded by a constant, the running time is shortened to O (n log 4 n). <p> Such trees can handle a broader range of information than rooted trees and unrooted trees. This paper focuses on unrooted trees only in order to simplify the discussion. Unlike the existing sub-quadratic time algorithms for unrooted and rooted trees <ref> [10, 25] </ref>, our algorithm is not based on dynamic programming. It adopts a conceptually simple recursive strategy exploiting a novel technique called label compression. This technique enables our algorithm to process overlapping subtrees iteratively while keeping the total tree size very close to the original input size. <p> Let n = maxfjW j; jW 0 jg and ^ N = maxfjT j; jT 0 jg. Let ^ d be the maximum degree of W and W 0 . We can compute mast (W; W 0 ) by modifying existing algorithms for ordinary evolutionary trees <ref> [10, 20, 8] </ref>. Lemma 3.2. Suppose that all the auxiliary information of W has been given. <p> Afterwards, we can retrieve mast ((W kJ i ) v ; R i ) for any i 2 [1; b] and v 2 W kJ i in O (1) time. Also, it is known <ref> [10] </ref> that given any node u 2 W , mast (W u ; R i ) = mast ((W kJ i ) u 0 ; R i ) for some u 0 2 W kJ i and this u 0 can be found in O (log n) time. <p> can perform a preprocessing in 13 O (n log 2 n) time, and then we can determine maxfmast (W v ; R j ) j j 2 [1; b]; j 6= ig (5) for any v 2 W and i 2 [1; b] in O (log 2 n) time (see <ref> [10] </ref>). The computation of maxfr-mast (W z ; R i ) j z 2 W v g is more difficult. For one thing, for a fixed v and i, there may already be n values involved in the expression. We cannot afford to evaluate them separately. <p> For one thing, for a fixed v and i, there may already be n values involved in the expression. We cannot afford to evaluate them separately. However, we can take advantage of the similarities between the R i . It is known <ref> [10] </ref> that r-mast (W z ; R i ) can be derived from a maximum weight matching of some bipartite graph. <p> This edge is given a weight of mast (W w ; R j ), which is at most N . Let mwm (G z;i ) denote the weight of a maximum weight matching of G z;i . Lemma 5.4 (see <ref> [10] </ref>). If the root of R i is mapped to z in some maximum agreement subtree of W z and R i , then the maximum weight matching of G z;i consists of at least two edges, and mwm (G z;i ) equals r-mast (W z ; R i ). <p> Using Lemma 5.2, we can find R i 0 and R i 00 in O (b log n) time. We can also find R i 0 and R i 00 in a different way. Based on <ref> [10] </ref>, we can perform an O (n log 2 n) preprocessing, and afterwards we can retrieve the value maxfmast (W u ; R j ) j j 2 Ig for any u 2 W and I [1; b] in O (log 2 n) time. <p> We can compute mast (W 1 ; W 2 ) as if they are ordinary rooted evolutionary tree with some special procedures on handling shrunk leaves. In fact, our algorithm for computing mast (U 1 ; U 2 ) is obtained by modifying slightly the algorithms in <ref> [10, 20, 8] </ref> for computing a maximum agreement subtree of two ordinary rooted evolutionary trees. 19 A.2. Overview of existing algorithms. We briefly review the algorithms in [10, 20, 8]. Let u and v be internal nodes of two rooted evolutionary trees T 1 and T 2 , respectively. <p> In fact, our algorithm for computing mast (U 1 ; U 2 ) is obtained by modifying slightly the algorithms in <ref> [10, 20, 8] </ref> for computing a maximum agreement subtree of two ordinary rooted evolutionary trees. 19 A.2. Overview of existing algorithms. We briefly review the algorithms in [10, 20, 8]. Let u and v be internal nodes of two rooted evolutionary trees T 1 and T 2 , respectively. <p> Given a node y, let Ch (y) denote the set of children of y. The following formula is the cornerstone of the dynamic programming approach of <ref> [10, 20, 8] </ref>: mast (T u 1 ; T v 8 &gt; : maxfmast (T x 1 ; T v maxfmast (T u 1 ; T 2 ) j y 2 Ch (v)g; r-mast (T u 1 ; T v (8) Given any two subsets A and B of Ch (u) <p> This edge is given a weight of mast (T x 1 ; T 2 ). To compute r-mast (T u 1 ; T v 2 ), it suffices to find the maximum weight matching of G [Ch (u); Ch (v)] <ref> [10] </ref>. Hence, to find mast (T 1 ; T 2 ) based on (8), we need to solve fi (N 2 ) maximum weight matching problems, where N is the size of T 1 and T 2 . These matching problems can be sparsified. <p> These matching problems can be sparsified. Farach and Thorup [9] observed that most of the edges in these bipartite graphs can be ignored and the maximum weight matchings of all these bipartite graphs can be computed in O (N 2 ) time. They further observed <ref> [10] </ref> that many of the above-mentioned maximum weight match-ings can be ignored, which leads to an algorithm for computing mast (T 1 ; T 2 ) in time O (N 1:5 log N ), or more precisely, O (N 1:5 log (N mast (T 1 ; T 2 )). <p> Ch (v)g; r-mast (W u 1 ; W v (9) To compute r-mast (W u 1 ; W v 2 ), we show later that it suffices to compute the maximum weight matching of up to a constant number of bipartite graphs of the same nature as those considered in <ref> [10, 20, 8] </ref>. Moreover, we can ignore many of these bipartite graphs and most of the edges in the remaining ones. <p> Given any subtree t , let J t denote the set of labels over which t is labeled. Observe that all the subtrees in S (P ) contain no shrunk leaf. Using the algorithms in <ref> [10, 20, 8] </ref>, we can compute mast (W 1 kJ t ; t ) for all t 2 S (P ) in ' 2 (n; n; d) time. <p> Afterwards, for any node w 0 2 W i and any subtree t 2 S (P ), mast (W w 0 1 ; t ) can be retrieved in O (log n) time. Using these values and a technique of Lemma 5.2 in <ref> [10] </ref>, the value maxfmast (W w 0 1 ; t ) j t 2 S (P )g for all w 0 2 W 1 can be found using additional O (n log n) time.
Reference: [11] <author> C. R. Finden and A. D. Gordon. </author> <title> Obtaining common pruned trees. </title> <journal> Journal of Classification, </journal> <volume> 2 </volume> <pages> 255-276, </pages> <year> 1985. </year>
Reference-contexts: A fundamental problem in computational biology is to determine how much two theories have in common. To a certain extent, this problem can be solved by computing a maximum agreement subtree of two given evolutionary trees <ref> [11] </ref>. Algorithms for computing a maximum agreement subtree for two unrooted evolutionary trees, as well as two rooted evolutionary trees, have been studied intensively in the past few years. The unrooted case is more difficult than the rooted case. <p> The unrooted case is more difficult than the rooted case. There is indeed a linear-time reduction from the rooted case to the unrooted one, but the reverse is not known. Finden and Gordon <ref> [11] </ref> gave a heuristic for finding an agreement subtree of two unrooted trees in O (n 5 ) time where n is the size of the trees.
Reference: [12] <author> H. N. Gabow and R. E. Tarjan. </author> <title> Faster scaling algorithms for network problems. </title> <journal> SIAM Journal on Computing, </journal> <volume> 18 </volume> <pages> 1013-1036, </pages> <year> 1989. </year>
Reference-contexts: The lemma follows. Since G z contains jCh (z)j + b 2d nodes and O ((z) + 1) edges, and the weight of every edge in G z is at most N, using Gabow and Tarjan's algorithm <ref> [12] </ref>, we can compute mwm (G z ) in O (minf p q (z) + 1g ((z) + 1) log dN) time.
Reference: [13] <author> D. Gusfield. </author> <title> Optimal mixed graph augmentation. </title> <journal> SIAM Journal on Computing, </journal> <volume> 16 </volume> <pages> 599-612, </pages> <year> 1987. </year>
Reference-contexts: Our algorithm allows the input trees to be mixed trees, i.e., trees which may contain directed and undirected edges at the same time <ref> [13, 18] </ref>. Such trees can handle a broader range of information than rooted trees and unrooted trees. This paper focuses on unrooted trees only in order to simplify the discussion.
Reference: [14] <author> D. Gusfield. </author> <title> Efficient algorithms for inferring evolutionary trees. </title> <journal> Networks, </journal> <volume> 21 </volume> <pages> 19-28, </pages> <year> 1991. </year>
Reference: [15] <author> T. Jiang, E. L. Lawler, and L. Wang. </author> <title> Aligning sequences via an evolutionary tree: complexity and approximation. </title> <booktitle> In Proceedings of the 26th Annual ACM Symposium on Theory of Computing, </booktitle> <pages> pages 760-769, </pages> <year> 1994. </year>
Reference: [16] <author> S. Kannan, E. Lawler, and T. Warnow. </author> <title> Determining the evolutionary tree. </title> <booktitle> In Proceedings of the 1st Annual ACM-SIAM Symposium on Discrete Algorithms, </booktitle> <pages> pages 475-484, </pages> <year> 1990. </year> <note> To appear in Journal of Algorithms. </note>
Reference: [17] <author> S. K. Kannan and T. J. Warnow. </author> <title> Inferring evolutionary history from DNA sequences. </title> <journal> SIAM Journal on Computing, </journal> <volume> 23(4) </volume> <pages> 713-737, </pages> <month> August </month> <year> 1994. </year>
Reference: [18] <author> M. Y. Kao. </author> <title> Data security equals graph connectivity. </title> <journal> SIAM Journal on Discrete Mathematics, </journal> <volume> 9 </volume> <pages> 87-100, </pages> <year> 1996. </year>
Reference-contexts: Our algorithm allows the input trees to be mixed trees, i.e., trees which may contain directed and undirected edges at the same time <ref> [13, 18] </ref>. Such trees can handle a broader range of information than rooted trees and unrooted trees. This paper focuses on unrooted trees only in order to simplify the discussion.
Reference: [19] <author> M. Y. Kao. </author> <title> Multiple-size divide-and-conquer recurrences. </title> <booktitle> In Proceedings of the International Conference on Algorithms, the 1996 International Computer Symposium, </booktitle> <pages> pages 159-161. </pages> <institution> National Sun Yat-Sen University, Kaohsiung, Taiwan, Republic of China, </institution> <year> 1996. </year>
Reference-contexts: Then, since P i2 [1;b] N i N , we have f (N ) = O (d 2 N log d log 4 N ), g (N ) = O ( dN log 5 N ), and h (N ) = O (N 1:5 log N ) <ref> [19] </ref>.
Reference: [20] <author> M. Y. Kao. </author> <title> Tree contractions and evolutionary trees. </title> <journal> SIAM Journal on Computing, </journal> <note> 1996. To appear. </note>
Reference-contexts: Research supported in part by Hong Kong RGC Grants 338/065/0027 and 338/065/0028. Algorithms that work well for rooted trees with degrees bounded by a constant have also been revealed recently. The algorithm of Farach, Przytycka and Thorup [8] runs in O (n log 3 n) time, and Kao <ref> [20] </ref> has also obtained an O (n log 2 n) time algorithm. The case when the inputs are further restricted to binary rooted trees was considered by Cole and Hariharan [5]; they gave an O (n log n) time algorithm. For unrooted trees, no similar improvement has been known, however. <p> Let n = maxfjW j; jW 0 jg and ^ N = maxfjT j; jT 0 jg. Let ^ d be the maximum degree of W and W 0 . We can compute mast (W; W 0 ) by modifying existing algorithms for ordinary evolutionary trees <ref> [10, 20, 8] </ref>. Lemma 3.2. Suppose that all the auxiliary information of W has been given. <p> We can compute mast (W 1 ; W 2 ) as if they are ordinary rooted evolutionary tree with some special procedures on handling shrunk leaves. In fact, our algorithm for computing mast (U 1 ; U 2 ) is obtained by modifying slightly the algorithms in <ref> [10, 20, 8] </ref> for computing a maximum agreement subtree of two ordinary rooted evolutionary trees. 19 A.2. Overview of existing algorithms. We briefly review the algorithms in [10, 20, 8]. Let u and v be internal nodes of two rooted evolutionary trees T 1 and T 2 , respectively. <p> In fact, our algorithm for computing mast (U 1 ; U 2 ) is obtained by modifying slightly the algorithms in <ref> [10, 20, 8] </ref> for computing a maximum agreement subtree of two ordinary rooted evolutionary trees. 19 A.2. Overview of existing algorithms. We briefly review the algorithms in [10, 20, 8]. Let u and v be internal nodes of two rooted evolutionary trees T 1 and T 2 , respectively. <p> Given a node y, let Ch (y) denote the set of children of y. The following formula is the cornerstone of the dynamic programming approach of <ref> [10, 20, 8] </ref>: mast (T u 1 ; T v 8 &gt; : maxfmast (T x 1 ; T v maxfmast (T u 1 ; T 2 ) j y 2 Ch (v)g; r-mast (T u 1 ; T v (8) Given any two subsets A and B of Ch (u) <p> Ch (v)g; r-mast (W u 1 ; W v (9) To compute r-mast (W u 1 ; W v 2 ), we show later that it suffices to compute the maximum weight matching of up to a constant number of bipartite graphs of the same nature as those considered in <ref> [10, 20, 8] </ref>. Moreover, we can ignore many of these bipartite graphs and most of the edges in the remaining ones. <p> Given any subtree t , let J t denote the set of labels over which t is labeled. Observe that all the subtrees in S (P ) contain no shrunk leaf. Using the algorithms in <ref> [10, 20, 8] </ref>, we can compute mast (W 1 kJ t ; t ) for all t 2 S (P ) in ' 2 (n; n; d) time.
Reference: [21] <author> M. Y. Kao, T. W. Lam, W. K. Sung, and H. F. Ting. </author> <title> Efficent data structures for range maximum problems. </title> <note> To be submitted. </note>
Reference-contexts: To find this value, we need to compute maxfmwm (G z;i ) j z 2 W v g; which equals maxfA (z)[i] j z 2 W v g:(6) Note that (6) is a generalization of tree product queries [3]. An efficient preprocessing for answering such queries is given in <ref> [21] </ref>. Let m z be the number of distinct values in A (z). Let m = z2W m z .
Reference: [22] <author> M. Y. Kao, T. W. Lam, W. K. Sung, and H. F. Ting. </author> <title> Efficient algorithms for all-cavity maximum matching probelms. </title> <note> To be submitted. </note>
Reference-contexts: The technical backbone of label compression is a technique that computes maximum weight matchings over many subgraphs of a bipartite graph as efficiently as it takes to compute a single matching <ref> [22] </ref>. This technique solves the all-cavity maximum weight matching problem which is to find a maximum weight matching of G fug for all nodes u of a given weighted bipartite graph G. <p> Fortunately, these R i are very similar. Each R i is X y with R i removed. Exploiting this similarity and making use of an efficient algorithm for the all-cavity maximum matching <ref> [22] </ref>, we can perform a ' 2 (n; N; d) time preprocessing, and then we can retrieve mast (W v ; R i ) for any internal node v in W and i 2 [1; b] in O (log 2 n) time. <p> It is shown in <ref> [22] </ref> that the same amount of time suffices to compute mwm (G z R i ) for all i 2 [1; b] and store the results in a sparse array A (z).
Reference: [23] <author> D. Keselman and A. Amir. </author> <title> Maximum agreement subtree in a set of evolutionary trees - metrics and efficient algorithms. </title> <booktitle> In Proceedings of the 35th Annual IEEE Symposium on Foundations of Computer Science, </booktitle> <pages> pages 758-769, </pages> <year> 1994. </year> <note> To appear in SIAM Journal on Computing. </note>
Reference: [24] <author> E. Kubicka, G. Kubicki, and F.R. McMorris. </author> <title> An algorithm to find agreement subtrees. </title> <journal> Journal of Classification, </journal> <volume> 12(1) </volume> <pages> 91-99, </pages> <year> 1995. </year>
Reference-contexts: Finden and Gordon [11] gave a heuristic for finding an agreement subtree of two unrooted trees in O (n 5 ) time where n is the size of the trees. Kubicka, Kubicki and McMorris <ref> [24] </ref> studied binary unrooted trees and gave an algorithm that can compute a maximum agreement subtree in O (n ( 1 2 +*) log n ) time. Steel and Warnow [27] gave the first polynomial-time algorithm for general unrooted trees, i.e., those with no restriction on the degrees.
Reference: [25] <author> T. W. Lam, W. K. Sung, and H. F. Ting. </author> <title> Computing the unrooted maximum agreement subtree in sub-quadratic time. </title> <booktitle> In Proceedings of the 5th Scandinavian Workshop on Algorithm Theory, </booktitle> <pages> pages 124-135, </pages> <year> 1996. </year>
Reference-contexts: For the unrooted case, the time complexity was improved by Lam, Sung and Ting <ref> [25] </ref> to O (n 1:75+o (1) ). fl Department of Computer Science, Duke University, Durham, NC 27708, U.S.A., kao@cs.duke.edu. Research supported in part by NSF Grant CCR-9101385. y Department of Computer Science, University of Hong Kong, Hong Kong, ftwlam, wksung, hftingg@cs.hku.hk. <p> Such trees can handle a broader range of information than rooted trees and unrooted trees. This paper focuses on unrooted trees only in order to simplify the discussion. Unlike the existing sub-quadratic time algorithms for unrooted and rooted trees <ref> [10, 25] </ref>, our algorithm is not based on dynamic programming. It adopts a conceptually simple recursive strategy exploiting a novel technique called label compression. This technique enables our algorithm to process overlapping subtrees iteratively while keeping the total tree size very close to the original input size.
Reference: [26] <author> M. Steel. </author> <title> The complexity of reconstructing trees from qualitative characters and subtrees. </title> <journal> Journal of Classification, </journal> <volume> 9 </volume> <pages> 91-116, </pages> <year> 1992. </year>
Reference: [27] <author> M. Steel and T. Warnow. </author> <title> Kaikoura tree theorems: Computing the maximum agreement subtree. </title> <journal> Information Processing Letters, </journal> <volume> 48 </volume> <pages> 77-82, </pages> <year> 1993. </year>
Reference-contexts: Kubicka, Kubicki and McMorris [24] studied binary unrooted trees and gave an algorithm that can compute a maximum agreement subtree in O (n ( 1 2 +*) log n ) time. Steel and Warnow <ref> [27] </ref> gave the first polynomial-time algorithm for general unrooted trees, i.e., those with no restriction on the degrees. Their algorithm runs in O (n 4:5 log n) time.
Reference: [28] <author> L. Wang, T. Jiang, and E. Lawler. </author> <title> Approximation algorithms for tree alignment with a given phylogeny. </title> <journal> Algorithmica, </journal> <note> 1996. To appear. </note>
Reference: [29] <author> T. J. Warnow. </author> <title> Tree compatibility and inferring evolutionary history. </title> <journal> Journal of Algorithms, </journal> <volume> 16(3) </volume> <pages> 388-407, </pages> <month> May </month> <year> 1994. </year> <month> 23 </month>
References-found: 29

