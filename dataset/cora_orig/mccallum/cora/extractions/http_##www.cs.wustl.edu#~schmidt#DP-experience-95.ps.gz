URL: http://www.cs.wustl.edu/~schmidt/DP-experience-95.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: http://www.cs.wustl.edu
Email: schmidt@cs.wustl.edu ebupsn@ebu.ericsson.se  
Title: Using Design Patterns to Evolve System Software from UNIX to Windows NT  
Author: Douglas C. Schmidt Paul Stephenson 
Note: An earlier version of the paper appeared in the March/April 1995 issue of the C++ Report magazine.  
Address: St. Louis, MO 63130 Cypress, CA 90630  
Affiliation: Department of Computer Science Ericsson, Inc. Washington University,  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: This article describes our experiences using a large-scale reuse strategy for system software based on design patterns. Design patterns capture the static and dynamic structures of solutions that occur repeatedly when producing applications in a particular context <ref> [1, 2] </ref>. Design patterns are an important technique for improving system software quality since they address a fundamental challenge in large-scale software development: communication of architectural knowledge among developers [3]. This article describes our experiences with a large-scale reuse strategy based upon design patterns. <p> Likewise, user-level threads may reduce robustness by restricting the use of OS features such as signals or synchronous I/O operations. 3 Design Pattern Overview A design pattern is a recurring architectural theme that provides a solution to a set of requirements within a particular context <ref> [1] </ref>. Design patterns facilitate architectural level reuse by providing blueprints or guidelines for defining, composing, and reasoning about the key components in a software system. In general, a large amount of reuse is possible at the architectural level. <p> However, reusing design patterns does not necessarily result in direct reuse of algorithms, detailed designs, interfaces, or implementations. OO frameworks typically embody a wide range of design patterns. For example, the ET++ graphical user-interface (GUI) framework [8] incorporates design patterns (such as Abstract Factory <ref> [1] </ref>) that hide the details of creating user-interface objects. This enables an application to be portable across different window systems (such as X windows and Mi-crosoft Windows). Likewise, the InterViews [9] GUI framework contains design patterns (such as Strategy and Iterator [1]) that allow algorithms and/or application behavior to be decoupled <p> framework [8] incorporates design patterns (such as Abstract Factory <ref> [1] </ref>) that hide the details of creating user-interface objects. This enables an application to be portable across different window systems (such as X windows and Mi-crosoft Windows). Likewise, the InterViews [9] GUI framework contains design patterns (such as Strategy and Iterator [1]) that allow algorithms and/or application behavior to be decoupled from mechanisms provided by the reusable GUI components. In the context of distributed applications, OO toolkits such as the Orbix CORBA object request broker [10] and the ADAPTIVE Service eXecutive (ASX) framework [4] embody many common design patterns. <p> Finding an appropriate mapping was non-trivial, as we describe below. Nevertheless, our knowledge of the design patterns significantly reduced redevelopment effort and minimized the level of risk in our projects. 3.1 The Reactor Pattern The Reactor pattern is an object behavioral pattern <ref> [1] </ref>. This pattern simplifies the development of event-driven applications (such as a CORBA ORB [10], an X-windows host resource manager, or a distributed logging service [5]). The Reactor pattern provides a common infrastructure that integrates event demultiplexing and the dispatching of event handlers. <p> In these cases, the Reactor pattern may be used in lieu of, or in conjunction with, OS multi-threading or multi-processing mechanisms, as described in Section 3.2. 3.2 The Acceptor Pattern The Acceptor pattern is an object creational pattern <ref> [1] </ref> that decouples the act of establishing a connection from the service (s) provided after a connection is established. Connection-oriented services (such as file transfer, remote login, distributed logging, and video-on-demand) are particularly amenable to this pattern. <p> Achieving this degree of flexibility and extensibility requires the use of OO language features (such as templates, inheritance, and dynamic binding), OO design techniques (such as the Factory Method or Abstract Factory design patterns <ref> [1] </ref>), and advanced operating system mechanisms (such as explicit dynamic linking and multi-threading [4]). 4 Evolving Design Patterns Across OS Platforms 4.1 Motivation Based on our experience at Ericsson, explicitly modeling design patterns is a very beneficial activity. <p> In our experience, it is essential to illustrate how design patterns are realized in actual systems. One observation we discuss in Section 5 is that existing design pattern catalogs <ref> [1, 2] </ref> do not present wide spectrum coverage of patterns. Often, this makes it difficult for novices to recognize how to 4 apply patterns in practice on their projects. <p> Templates trade additional compile-time and link-time overhead for improved run-time efficiency. Note that a similar degree of decoupling also could be achieved via inheritance and dynamic binding by using the Abstract Factory or Factory Method patterns described in <ref> [1] </ref>. 4.4 Evolving the Design Patterns to Windows NT This section describes the Windows NT implementation of the Reactor and Acceptor design patterns performed at the Ericsson facility in Cypress, California. <p> One drawback we observed with much of the existing pattern literature <ref> [1, 2] </ref>, however, is that it is often too abstract. Abstraction is a benefit in many cases since it avoids inundating a casual reader with excessive details. <p> The extended discussion in Section 4 is one example of a wide-spectrum exemplar using this approach. This example contains in-depth coverage of tradeoffs encountered in actual use. * Integrate patterns with OO frameworks: Ideally, examples in pattern catalogs <ref> [2, 1] </ref> should reference (or better yet, contain hyper-text links to) source code that comprises an actual OO framework. We have begun building such an environment at Ericsson, in order to disseminate our patterns and frameworks to a wider audience.
Reference: [2] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <journal> Wileys and Sons, </journal> <note> to appear 1996. </note>
Reference-contexts: This article describes our experiences using a large-scale reuse strategy for system software based on design patterns. Design patterns capture the static and dynamic structures of solutions that occur repeatedly when producing applications in a particular context <ref> [1, 2] </ref>. Design patterns are an important technique for improving system software quality since they address a fundamental challenge in large-scale software development: communication of architectural knowledge among developers [3]. This article describes our experiences with a large-scale reuse strategy based upon design patterns. <p> In our experience, it is essential to illustrate how design patterns are realized in actual systems. One observation we discuss in Section 5 is that existing design pattern catalogs <ref> [1, 2] </ref> do not present wide spectrum coverage of patterns. Often, this makes it difficult for novices to recognize how to 4 apply patterns in practice on their projects. <p> One drawback we observed with much of the existing pattern literature <ref> [1, 2] </ref>, however, is that it is often too abstract. Abstraction is a benefit in many cases since it avoids inundating a casual reader with excessive details. <p> The extended discussion in Section 4 is one example of a wide-spectrum exemplar using this approach. This example contains in-depth coverage of tradeoffs encountered in actual use. * Integrate patterns with OO frameworks: Ideally, examples in pattern catalogs <ref> [2, 1] </ref> should reference (or better yet, contain hyper-text links to) source code that comprises an actual OO framework. We have begun building such an environment at Ericsson, in order to disseminate our patterns and frameworks to a wider audience.
Reference: [3] <author> J. O. Coplien, </author> <title> A Development Process Generative Pattern Language, in Pattern Languages of Programs (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <month> June </month> <year> 1995. </year>
Reference-contexts: Design patterns capture the static and dynamic structures of solutions that occur repeatedly when producing applications in a particular context [1, 2]. Design patterns are an important technique for improving system software quality since they address a fundamental challenge in large-scale software development: communication of architectural knowledge among developers <ref> [3] </ref>. This article describes our experiences with a large-scale reuse strategy based upon design patterns. We have used this strategy at Ericsson to facilitate the development of efficient OO telecommunication system software.
Reference: [4] <author> D. C. Schmidt, ASX: </author> <title> an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: We have used this strategy at Ericsson to facilitate the development of efficient OO telecommunication system software. In this article, we present a case study that describes the cross-platform evolution of portions of an OO framework called the ADAPTIVE Service eXecutive (ASX) <ref> [4] </ref>. The ASX framework is an integrated collection of components that collaborate to produce a reusable infrastructure for developing distributed applications. This article focuses on the ASX framework's support for event-driven distributed applications. One of the key components in the ASX framework is the Reactor class category [5]. <p> In the context of distributed applications, OO toolkits such as the Orbix CORBA object request broker [10] and the ADAPTIVE Service eXecutive (ASX) framework <ref> [4] </ref> embody many common design patterns. These design patterns express recurring architectural themes (such as event demul-tiplexing, connection establishment, message routing, publish/subscribe communication, remote object proxies, and flexible composition of hierarchically-related services) found in most distributed applications. <p> Using multi-threading to implement event demultiplexing has several drawbacks, however. It may require the use of complex concurrency control schemes; it may lead to poor performance on uni-processors <ref> [4] </ref>; and it may not be available on widely available OS platforms (such as many variants of UNIX). <p> For example, the standard UNIX superserver, inetd, uses the Acceptor pattern in this manner to execute the standard Internet ftp and telnet services in separate processes [12]. The ASX framework described in <ref> [4] </ref> provides mechanisms that support all three of these types of concurrency dynamics. Moreover, the selection of concurrency mechanism may be deferred until late in the design, or even until run-time. This flexibility increases the range of design alternatives available to developers. <p> Achieving this degree of flexibility and extensibility requires the use of OO language features (such as templates, inheritance, and dynamic binding), OO design techniques (such as the Factory Method or Abstract Factory design patterns [1]), and advanced operating system mechanisms (such as explicit dynamic linking and multi-threading <ref> [4] </ref>). 4 Evolving Design Patterns Across OS Platforms 4.1 Motivation Based on our experience at Ericsson, explicitly modeling design patterns is a very beneficial activity. In particular, design patterns focus attention on relatively stable aspects of a system's software architecture. <p> A derived Event Handler returns the I/O mechanism HANDLE via its get handle method and returns the destination buffer location and length information via the Message Block abstraction described in <ref> [4] </ref>. The current implementation of the Windows NT-based Reactor pattern is about 2,600 lines C++ code (not including comments or extraneous whitespace). This code is approximately 200 lines longer than the UNIX version. The additional code primarily ensures the fairness of WaitForMultipleObjects event demultiplexing, as discussed above. <p> This distribution contains complete source code, documentation, and example test drivers for the C++ components developed as part of the ADAPTIVE project <ref> [4] </ref> at the University of California, Irvine and Washington University.
Reference: [5] <author> D. C. Schmidt, </author> <title> Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching, in Pattern Languages of Program Design (J. </title> <editor> O. Coplien and D. C. Schmidt, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: The ASX framework is an integrated collection of components that collaborate to produce a reusable infrastructure for developing distributed applications. This article focuses on the ASX framework's support for event-driven distributed applications. One of the key components in the ASX framework is the Reactor class category <ref> [5] </ref>. The Reactor integrates the demultiplexing of events and the dispatching of the corresponding event handlers. Event handlers are triggered by various types of events such as timers, synchronization objects, signals, or I/O operations. We recently ported the ASX framework from several UNIX platforms to the Windows NT platform. <p> These design patterns express recurring architectural themes (such as event demul-tiplexing, connection establishment, message routing, publish/subscribe communication, remote object proxies, and flexible composition of hierarchically-related services) found in most distributed applications. This article focuses on two specific design patterns (the Reactor <ref> [5] </ref> and Acceptor patterns) that are implemented by the ASX framework. Components in the ASX framework have been ported to a number of UNIX platforms, as well as Windows NT. <p> This pattern simplifies the development of event-driven applications (such as a CORBA ORB [10], an X-windows host resource manager, or a distributed logging service <ref> [5] </ref>). The Reactor pattern provides a common infrastructure that integrates event demultiplexing and the dispatching of event handlers. Event handlers perform application-specific processing operations in response to various types of events.
Reference: [6] <author> D. C. Schmidt and P. Stephenson, </author> <title> An Object-Oriented Framework for Developing Network Server Daemons, </title> <booktitle> in Proceedings of the 2 nd C++ World Conference, </booktitle> <address> (Dallas, Texas), SIGS, </address> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: the experience we gained, both pro and con, while deploying a design pattern-based system development methodology in a production software environment; and Section 6 presents concluding remarks. 2 Background The design patterns and framework described in this article are currently being applied at Ericsson on a family of distributed applications <ref> [6] </ref>. These applications use ASX framework as the basis for a highly flexible and extensible telecommunication system management framework. The ASX framework enhances the flexibility and reuse of system software that monitors and manages telecommunication switch performance across multiple hardware and software platforms. <p> These systems include the Bellcore Q.port ATM signaling software product, the system control segment for the Motorola Iridium global personal communications system, and a family of system/network management applications for Ericsson telecommunication switches <ref> [6] </ref>. The design patterns described in the following section provided a concise set of architectural blueprints that guided our porting effort from UNIX to Windows NT. In particular, by employing the patterns, we did not have to rediscover the key collaborations between architectural components. <p> The Reactor will also initiate the next connection acceptance sequence asynchronously. 5 Lessons Learned Our group at Ericsson has been developing OO frameworks based on design patterns for the past two years <ref> [6] </ref>. During this time, we have identified a number of pros and cons related to using design patterns as the basis for our system design, implementation, and documentation. We have also formulated a number of workarounds for the problems we observed using design patterns in a production environment.
Reference: [7] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin-giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: For instance, many traditional OS kernels do not support pre-emptive multi-threading. Therefore, writing a portable user-level threads mechanism may be less efficient than programming with thread mechanisms supported by the kernel <ref> [7] </ref>. Likewise, user-level threads may reduce robustness by restricting the use of OS features such as signals or synchronous I/O operations. 3 Design Pattern Overview A design pattern is a recurring architectural theme that provides a solution to a set of requirements within a particular context [1]. <p> The Svc Handler object then processes messages exchanged over the connection within the new slave thread. Threads are useful for cooperating services that frequently reference common memory-resident data structures shared by the threads within a process address space <ref> [7] </ref>. * Run in a separate OS process: This approach is similar in form to the previous bullet. However, a separate process is created rather than a separate thread. <p> The next major modification to the Reactor extended it for use with multi-threaded applications on SunOS 5.x using Solaris threads <ref> [7] </ref>. Adding multi-threading support required changes to the internals of both the select-based and poll-based versions of the Reactor. These changes involved a SunOS 5.x mutual exclusion mechanism known as a mutex. <p> These changes involved a SunOS 5.x mutual exclusion mechanism known as a mutex. A mutex serializes the execution of multiple threads by defining a critical section where only one thread executes the code at a time <ref> [7] </ref>. Critical sections of the Reactor's code that concurrently access shared resources (such as the Reactor's internal dispatch table containing Event Handler objects) are protected by a mutex. The standard SunOS 5.x synchronization type (mutex t) provides support for non-recursive mutexes.
Reference: [8] <author> A. Weinand, E. Gamma, and R. Marty, </author> <title> ET++ an object-oriented application framework in C++, </title> <booktitle> in Proceedings of the Object-Oriented Programming Systems, Languages and Applications Conference, </booktitle> <pages> pp. 46-57, </pages> <publisher> ACM, </publisher> <month> Sept. </month> <year> 1988. </year>
Reference-contexts: In general, a large amount of reuse is possible at the architectural level. However, reusing design patterns does not necessarily result in direct reuse of algorithms, detailed designs, interfaces, or implementations. OO frameworks typically embody a wide range of design patterns. For example, the ET++ graphical user-interface (GUI) framework <ref> [8] </ref> incorporates design patterns (such as Abstract Factory [1]) that hide the details of creating user-interface objects. This enables an application to be portable across different window systems (such as X windows and Mi-crosoft Windows).
Reference: [9] <author> M. A. Linton, J. Vlissides, and P. Calder, </author> <title> Composing User Interfaces with InterViews, </title> <journal> IEEE Computer, </journal> <volume> vol. 22, </volume> <pages> pp. 8-22, </pages> <month> February </month> <year> 1989. </year>
Reference-contexts: For example, the ET++ graphical user-interface (GUI) framework [8] incorporates design patterns (such as Abstract Factory [1]) that hide the details of creating user-interface objects. This enables an application to be portable across different window systems (such as X windows and Mi-crosoft Windows). Likewise, the InterViews <ref> [9] </ref> GUI framework contains design patterns (such as Strategy and Iterator [1]) that allow algorithms and/or application behavior to be decoupled from mechanisms provided by the reusable GUI components. <p> Therefore, computation and communication may not occur in parallel unless separate threads or processes are used. The original implementation of the Reactor pattern provided by the ASX framework was derived from the Dispatcher class category available in the InterViews OO GUI framework <ref> [9] </ref>. The Dispatcher is an OO interface to the UNIX select system call. InterViews uses the Dispatcher to define an application's main event loop and to manage connections to one or more physical window displays. The Reactor framework's first modification to the Dispatcher framework added support for signal-based event dispatching.
Reference: [10] <author> S. Vinoski, </author> <title> Distributed Object Computing with CORBA, </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> July/August </month> <year> 1993. </year>
Reference-contexts: Likewise, the InterViews [9] GUI framework contains design patterns (such as Strategy and Iterator [1]) that allow algorithms and/or application behavior to be decoupled from mechanisms provided by the reusable GUI components. In the context of distributed applications, OO toolkits such as the Orbix CORBA object request broker <ref> [10] </ref> and the ADAPTIVE Service eXecutive (ASX) framework [4] embody many common design patterns. These design patterns express recurring architectural themes (such as event demul-tiplexing, connection establishment, message routing, publish/subscribe communication, remote object proxies, and flexible composition of hierarchically-related services) found in most distributed applications. <p> Nevertheless, our knowledge of the design patterns significantly reduced redevelopment effort and minimized the level of risk in our projects. 3.1 The Reactor Pattern The Reactor pattern is an object behavioral pattern [1]. This pattern simplifies the development of event-driven applications (such as a CORBA ORB <ref> [10] </ref>, an X-windows host resource manager, or a distributed logging service [5]). The Reactor pattern provides a common infrastructure that integrates event demultiplexing and the dispatching of event handlers. Event handlers perform application-specific processing operations in response to various types of events.
Reference: [11] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Applications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: These subclasses are derived from the Event Handler abstract base class, which defines virtual methods for handling events. A Concrete Event Handler subclass may override these virtual methods to perform application-specific functionality when the corresponding events occur. 1 Relationships between components are illustrated throughout the article via Booch notation <ref> [11] </ref>. Dashed clouds indicate classes; non-dashed directed edges indicate inheritance relationships between classes; dashed directed edges indicate a template instantiation relationship; and an undi-rected edge with a solid bullet at one end indicates a composition relation. <p> However, we were able to reuse the underlying design patterns, which reduced project risk significantly and simplified our re-development effort. Our experiences with patterns reinforce the observation that the transition from OO analysis to OO design and implementation is challenging <ref> [11] </ref>. Often, the constraints of the underlying OS and hardware platform influence design and implementation details significantly. This is particularly problematic for system software, which is frequently targeted for particular platforms with particular non-portable characteristics.
Reference: [12] <author> W. R. Stevens, </author> <title> UNIX Network Programming. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: For example, the standard UNIX superserver, inetd, uses the Acceptor pattern in this manner to execute the standard Internet ftp and telnet services in separate processes <ref> [12] </ref>. The ASX framework described in [4] provides mechanisms that support all three of these types of concurrency dynamics. Moreover, the selection of concurrency mechanism may be deferred until late in the design, or even until run-time. This flexibility increases the range of design alternatives available to developers. <p> The application then reacts by processing the handle (s) accordingly (such as reading or writing data, accepting connections, etc.). Reactive demultiplexing and I/O semantics are provided on standard BSD and System V UNIX systems <ref> [12] </ref>. In contrast, proactive semantics allow an application to proactively initiate I/O-related operations (such as a read, write, or connection request/accept) or general-purpose event-signaling operations (such as a semaphore lock being acquired or a thread terminating). The invoked operation proceeds asynchronously and does not block the caller. <p> SVR4 provides another event demultiplexing system call named poll. Poll is similar to select, though it uses a different interface and provides a broader, more flexible model for event demultiplexing that supports SVR4 features such as STREAM pipe band-data <ref> [12] </ref>. 2 The Reactor's interfaces for signals and timer-based event handling are not shown in this article due to space limitations. 5 The SunOS 5.x port of the Reactor was enhanced to support either select or poll as the underlying event demultiplexer. <p> SOCK SAP encapsulates the SOCK STREAM semantics of the socket transport layer interface within a type-secure, OO interface. SOCK STREAM sockets support the reliable transfer of bytestream data between two processes, which may run on the same or on different host machines in a network <ref> [12] </ref>. By using templates, it is relatively straightforward to instantiate a different IPC interface (such as the TLI SAP C++ wrappers that encapsulate the System V UNIX TLI interface). Templates trade additional compile-time and link-time overhead for improved run-time efficiency.
Reference: [13] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: </address> <publisher> Mi-crosoft Press, </publisher> <year> 1993. </year>
Reference-contexts: When an operation completes, it signals the application. At this point, the application runs a completion routine that determines the exit status of the operation and potentially starts up another asynchronous operation. Proactive demultiplexing and I/O semantics are provided on Windows NT <ref> [13] </ref> and VMS. For performance reasons, we were not able to completely encapsulate the variation in behavior between the UNIX and Windows NT demultiplexing and I/O semantics. Thus, we could not directly reuse existing C++ code, algorithms, or detailed designs.
Reference: [14] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year> <month> 14 </month>
Reference-contexts: The SOCK Stream, SOCK Acceptor and INET Addr classes used in the template instantiations are part of the SOCK SAP C++ wrapper library <ref> [14] </ref>. SOCK SAP encapsulates the SOCK STREAM semantics of the socket transport layer interface within a type-secure, OO interface. SOCK STREAM sockets support the reliable transfer of bytestream data between two processes, which may run on the same or on different host machines in a network [12].
References-found: 14

