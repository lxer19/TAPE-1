URL: http://www.cs.princeton.edu/sip/pub/preprint.ps
Refering-URL: http://www.apl.jhu.edu/~hall/java/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: ddean@cs.princeton.edu felten@cs.princeton.edu dwallach@cs.princeton.edu  
Title: Java Security: From HotJava to Netscape and Beyond  
Author: Drew Dean Edward W. Felten Dan S. Wallach 
Address: Princeton, NJ 08544  
Affiliation: Department of Computer Science Princeton University  
Abstract: The introduction of Java applets has taken the World Wide Web by storm. Information servers can customize the presentation of their content with server-supplied code which executes inside the Web browser. We examine the Java language and both the HotJava and Netscape browsers which support it, and find a significant number of flaws which compromise their security. These flaws arise for several reasons, including implementation errors, unintended interactions between browser features, differences between the Java language and bytecode semantics, and weaknesses in the design of the language and the bytecode format. On a deeper level, these flaws arise because of weaknesses in the design methodology used in creating Java and the browsers. In addition to the flaws, we discuss the underlying tension between the openness desired by Web application writers and the security needs of their users, and we suggest how both might be accommodated. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. R. Ames, Jr., M. Gasser, and R. G. Schell. </author> <title> Security kernel design and implementation: An introduction. </title> <booktitle> Computer, </booktitle> <pages> pages 14-22, </pages> <month> July </month> <year> 1983. </year> <title> Reprinted in Tutorial: Computer and Network Security, </title> <editor> M. D. Abrams and H. J. Podell, editors, </editor> <publisher> IEEE Computer Society Press, </publisher> <year> 1987, </year> <pages> pp. 142-157. </pages>
Reference: [2] <author> J. P. Anderson. </author> <title> Computer security technology planning study. </title> <type> Technical Report ESD-TR-73-51, U.S. </type> <institution> Air Force, Electronic Systems Division, Deputy for Command and Management Systems, HQ Electronic Systems Division (AFSC), L. G. Hanscom Field, Bedford, </institution> <address> MA 01730 USA, </address> <month> Oct. </month> <journal> 1972. </journal> <volume> Volume 2, </volume> <pages> pages 58-69. </pages>
Reference-contexts: The language's type system should be safe preventing forged pointers and checking array bounds. Additionally, the system should garbage-collect memory to prevent memory leakage, and carefully manage system calls that can access the environment outside the program, as well as allow applets to affect each other. The Anderson report <ref> [2] </ref> describes an early attempt to build a secure subset of Fortran. This effort was a failure because the implementors failed to consider all of the consequences of the implementation of one construct: assigned GOTO. This subtle flaw resulted in a complete break of the system.
Reference: [3] <author> N. S. Borenstein. </author> <title> Email with a mind of its own: The Safe-Tcl language for enabled mail. </title> <booktitle> In IFIP International Working Conference on Upper Layer Protocols, Architectures and Applications, </booktitle> <year> 1994. </year>
Reference-contexts: Such remote code raises serious security issues; a casual Web reader should not be concerned about malicious side-effects from visiting a Web page. Languages such as Java [9], Safe-Tcl <ref> [3] </ref>, Phantom [8], and Telescript [10] have been proposed for running downloaded code, and each has varying ideas of how to thwart malicious programs. After several years of development inside Sun Microsys-tems, the Java language was released in mid-1995 as part of Sun's HotJava Web browser.
Reference: [4] <author> D. F. C. Brewer and M. J. Nash. </author> <title> The Chinese wall security policy. </title> <booktitle> In Proceedings of the 1989 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 206-214, </pages> <year> 1989. </year>
Reference: [5] <author> G. Castagna. </author> <title> Covariance and contravariance: Conflict without a cause. </title> <type> Technical Report LIENS-94-18, </type> <institution> Departement de Mathematiques et d'Informatique, Ecole Normale Superieure, </institution> <month> Oct. </month> <year> 1994. </year> <note> ftp://ftp.ens.fr/ pub/reports/liens/liens-94-18.A4.ps.Z. </note>
Reference-contexts: Thus, if the system libraries are specified safely, the runtime system assures application code cannot break these specifications. The Java documentation claims that the safety of Java bytecodes can be statically determined at load time. This is not entirely true: the type system uses a covariant <ref> [5] </ref> rule for subtyping arrays, so array stores require run time type checks 3 in addition to the normal array bounds checks. Unfortunately, this means the bytecode verifier is not the only piece of the runtime system that must be correct to ensure security.
Reference: [6] <institution> CERT Coordination Center. Syslog vulnerability - a workaround for sendmail. CERT Advisory CA-95:13, </institution> <month> Oct. </month> <year> 1995. </year> <note> ftp://ftp.cert.org/pub/ cert advisories/CA-95%3A13.syslog.vul. </note>
Reference-contexts: Because sprintf () does not check for buffer overflows, an attacker could overwrite the execution stack, thereby transferring control to arbitrary code. Attackers have exploited the same bug in the Unix syslog () library routine (via sendmail) to take over machines from across the network <ref> [6] </ref>. In Netscape and the beta release of JDK, all of these calls were fixed in the Java runtime. However, the disassembler was overlooked all the way through the JDK 1.0 release.
Reference: [7] <author> W. R. Cheswick and S. M. Bellovin. </author> <title> Firewalls and Internet Security: Repelling the Wily Hacker. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference-contexts: Repeated DNS calls by the applet establish a channel between the applet and the attacker's DNS server. This channel also passes through a number of firewalls <ref> [7] </ref>. In HotJava, the DNS channel was available even with the security mode set to no network access, although this was fixed in JDK and Netscape. DNS has other security implications; see section 3.5 for details. Another third-party channel is available with the URL redirect feature.
Reference: [8] <author> A. Courtney. Phantom: </author> <title> An interpreted language for distributed programming. </title> <booktitle> In Usenix Conference on Object-Oriented Technologies, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: Such remote code raises serious security issues; a casual Web reader should not be concerned about malicious side-effects from visiting a Web page. Languages such as Java [9], Safe-Tcl [3], Phantom <ref> [8] </ref>, and Telescript [10] have been proposed for running downloaded code, and each has varying ideas of how to thwart malicious programs. After several years of development inside Sun Microsys-tems, the Java language was released in mid-1995 as part of Sun's HotJava Web browser.
Reference: [9] <author> D. Flanagan. </author> <title> Java in a Nutshell. </title> <publisher> O'Reilly & Associates, Inc., </publisher> <address> 1st edition, </address> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: Such remote code raises serious security issues; a casual Web reader should not be concerned about malicious side-effects from visiting a Web page. Languages such as Java <ref> [9] </ref>, Safe-Tcl [3], Phantom [8], and Telescript [10] have been proposed for running downloaded code, and each has varying ideas of how to thwart malicious programs. After several years of development inside Sun Microsys-tems, the Java language was released in mid-1995 as part of Sun's HotJava Web browser. <p> There are significant differences between the semantics of the Java language and the semantics of the bytecode. We discuss super-class constructors and David Hopwood's attack [17] based on package names as examples of language versus bytecode differences. We then discuss related security weaknesses. Superclass Constructors The Java language <ref> [9] </ref> requires that all constructors call either another constructor of the same class, or a superclass constructor as their first action. The system classes ClassLoader, SecurityManager, and FileInputStream all rely on this behavior for their security.
Reference: [10] <institution> General Magic, Inc., 420 North Mary Ave., </institution> <address> Sunnyvale, CA 94086 USA. </address> <booktitle> The Telescript Language Reference, </booktitle> <month> Oct. </month> <year> 1995. </year> <note> http://www.genmagic.com/Telescript/ TDE/TDEDOCS HTML/telescript.html. </note>
Reference-contexts: Such remote code raises serious security issues; a casual Web reader should not be concerned about malicious side-effects from visiting a Web page. Languages such as Java [9], Safe-Tcl [3], Phantom [8], and Telescript <ref> [10] </ref> have been proposed for running downloaded code, and each has varying ideas of how to thwart malicious programs. After several years of development inside Sun Microsys-tems, the Java language was released in mid-1995 as part of Sun's HotJava Web browser.
Reference: [11] <author> S. Gibbons. </author> <type> Personal communication, </type> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: FTP retrievals may be redirected with similar code. can attack any machine behind the firewall. At this point, a rogue applet can exploit a whole legion of known network security problems to break into other nearby machines. This problem was postulated independently by Steve Gibbons <ref> [11] </ref> and by us. To demonstrate this flaw, we produced an applet that exploits an old sendmail hole to run arbitrary Unix commands as user daemon. As of this writing, Sun and Netscape have both issued patches to fix this problem.
Reference: [12] <author> J. A. Goguen and J. Meseguer. </author> <title> Security policies and security models. </title> <booktitle> In Proceedings of the 1982 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 11-20, </pages> <year> 1982. </year>
Reference-contexts: Inter-Applet Security Since applets can persist after the Web browser leaves the page which contains them, it becomes important to separate applets from each other. Otherwise, an attacker's applet could deliberately sabotage a third party's applet. More formally, the Java runtime should maintain noninterference <ref> [12, 13] </ref> between applets. In many environments, it would be unacceptable for an applet to even learn of the existence of another applet. In Netscape, AppletContext.getApplets () is careful to only return handles to applets on the same Web page as the caller.
Reference: [13] <author> J. A. Goguen and J. Meseguer. </author> <title> Unwinding and inference control. </title> <booktitle> In Proceedings of the 1984 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 75-86, </pages> <year> 1984. </year>
Reference-contexts: Inter-Applet Security Since applets can persist after the Web browser leaves the page which contains them, it becomes important to separate applets from each other. Otherwise, an attacker's applet could deliberately sabotage a third party's applet. More formally, the Java runtime should maintain noninterference <ref> [12, 13] </ref> between applets. In many environments, it would be unacceptable for an applet to even learn of the existence of another applet. In Netscape, AppletContext.getApplets () is careful to only return handles to applets on the same Web page as the caller.
Reference: [14] <author> J. Gosling. </author> <type> Personal communication, </type> <month> Oct. </month> <year> 1995. </year>
Reference-contexts: For example, the locking-based attack could be used to hold a critical system lock most of the time, releasing it only briefly and occasionally. The result would be a browser that runs very slowly. Sun has said that they consider denial of service attacks to be low-priority problems <ref> [14] </ref>. 3.2. Two vs. Three Party Attacks It is useful to distinguish between two different kinds of attack, which we shall call two-party and three-party. A two-party attack requires that the Web server the applet resides on participate in the attack.
Reference: [15] <author> J. Gosling and H. McGilton. </author> <title> The Java Language Environment. </title> <publisher> Sun Microsystems Computer Company, </publisher> <address> 2550 Gar-cia Avenue, Mountain View, CA 94043 USA, </address> <month> May </month> <year> 1995. </year> <note> http://java.sun.com/whitePaper/ javawhitepaper 1.html. </note>
Reference-contexts: In support of this downloaded code, Java distinguishes remote code from local code. Separate sources 2 of Java bytecode are loaded in separate naming environments to prevent both accidental and malicious name clashes. Byte-code loaded from the local file system is visible to all applets. The documentation <ref> [15] </ref> says the system name space has two special properties: 1. It is shared by all name spaces. 2. It is always searched first, to prevent downloaded code from overriding a system class. 2 While the documentation [15] does not define source, it appears to mean the machine and Web page <p> The documentation <ref> [15] </ref> says the system name space has two special properties: 1. It is shared by all name spaces. 2. It is always searched first, to prevent downloaded code from overriding a system class. 2 While the documentation [15] does not define source, it appears to mean the machine and Web page of origin. Sun has announced plans to include support for digital signatures in a future version. However, we have found that the second property does not hold. <p> ClassLoaders are the most interesting class to instantiate, as any code loaded by a ClassLoader asks its ClassLoader to load any classes it needs. This is contrary to the documentation <ref> [15] </ref> that claims the system name space is always searched first; we have verified this difference experimentally. Fortunately from the attacker's viewpoint, ClassLoaders don't have any instance variables, and the actual code in ClassLoader's constructor only needs to run once and it always runs before the first applet is loaded.
Reference: [16] <author> L. Hasiuk. </author> <type> Personal communication, </type> <month> Feb. </month> <year> 1996. </year>
Reference-contexts: The language has neither a formal semantics nor a formal description of its type system. The module system is weak, the scoping rules are too liberal, and methods may be called on partially initialized objects <ref> [16] </ref>. The bytecode is in linear form rather than a tree representation, it has no formal semantics, it has unnaturally typed constructors, and it does not enforce the private modifier on code loaded from the local file system. The separation of object creation and initialization poses problems.
Reference: [17] <author> D. Hopwood. </author> <title> Java security bug (applets can load native methods). </title> <journal> RISKS Forum, </journal> <volume> 17(83), </volume> <month> Mar. </month> <year> 1996. </year> <month> ftp://ftp.sri.com/risks/risks-17.83. </month>
Reference-contexts: Java Language and Bytecode Differences Unfortunately, the Java language and the bytecode it compiles to are not as secure as they could be. There are significant differences between the semantics of the Java language and the semantics of the bytecode. We discuss super-class constructors and David Hopwood's attack <ref> [17] </ref> based on package names as examples of language versus bytecode differences. We then discuss related security weaknesses. Superclass Constructors The Java language [9] requires that all constructors call either another constructor of the same class, or a superclass constructor as their first action. <p> David Hopwood found that if the first character of a package name was `/', the Java runtime system would attempt to load code from an absolute path <ref> [17] </ref>, since absolute pathnames begin with a `/' character.
Reference: [18] <author> W.-M. Hu. </author> <title> Reducing timing channels with fuzzy time. </title> <booktitle> In Proceedings of the 1991 IEEE Symposium on Research in Security and Privacy, </booktitle> <pages> pages 8-20, </pages> <year> 1991. </year>
Reference-contexts: Java allows applets to read the system clock, making it possible to benchmark the user's machine. As a Java-enabled Web browser may well run on pre-release hardware and/or software, an attacker could learn valuable information. Timing information is also needed for the exploitation of covert timing channels. Fuzzy time <ref> [18] </ref> should be investigated to see if it can be used to mitigate both of these problems. 3.5. Implementation Errors Some bugs arise from fairly localized errors in the implementation of the browser or the Java subsystem.
Reference: [19] <author> P. A. Karger. </author> <title> Limiting the damage potential of discretionary trojan horses. </title> <booktitle> In Proceedings of the 1987 IEEE Symposium on Security and Privacy, </booktitle> <pages> pages 32-37, </pages> <year> 1987. </year>
Reference-contexts: An untrusted applet could call a trusted File Save dialog with no default choice which returns an open handle to the file chosen by the user. This would allow the user to grant authorization for a specific file access without exposing the full file system to an untrusted applet <ref> [19] </ref>. A similar trusted dialog could be used for initiating network connections, as might be used in chat systems or games.
Reference: [20] <author> B. W. Lampson. </author> <title> Protection. </title> <booktitle> In Proceedings of the Fifth Princeton Symposium on Information Sciences and Systems, </booktitle> <pages> pages 437-443, </pages> <institution> Princeton University, </institution> <month> Mar. </month> <year> 1971. </year> <booktitle> Reprinted in Operating Systems Review, </booktitle> <volume> 8(1) </volume> <pages> 18-24, </pages> <month> Jan. </month> <year> 1974. </year>
Reference-contexts: Dynamic checks also introduce a performance penalty. 2.1. Java Security Mechanisms In HotJava, all of the access controls were done on an ad hoc basis which was clearly insufficient. The beta release of JDK introduced the SecurityManager class, meant to be a reference monitor <ref> [20] </ref>. The SecurityManager defines and implements a security policy, centralizing all access control decisions. Netscape also uses this architecture. When the Java runtime system starts up, there is no security manager installed. <p> Web applets, however, cannot be trusted with the full authority granted to a given user, and so require that Java define and implement a protected subsystem with an appropriate security policy. 4.2. Enforcement The Java SecurityManager is intended to be a reference monitor <ref> [20] </ref>. A reference monitor has three important properties: 1. It is always invoked. 2. It is tamperproof. 3. It is verifiable. Unfortunately, the Java SecurityManager design has weaknesses in all three areas.
Reference: [21] <author> B. W. Lampson and D. D. Redell. </author> <title> Experience with processes and monitors in Mesa. </title> <journal> Communications of the ACM, </journal> <volume> 23(2) </volume> <pages> 105-117, </pages> <month> Feb. </month> <year> 1980. </year>
Reference-contexts: Java supplies each class and object with a lock, and provides the synchronized keyword so each class (or instance of a class, as appropriate) can operate as a Mesa-style monitor <ref> [21] </ref>. Java compilers produce a machine-independent byte-code, which may be transmitted across a network and then interpreted or compiled to native code by the Java runtime system. In support of this downloaded code, Java distinguishes remote code from local code.
Reference: [22] <author> C. E. Landwehr. </author> <title> Formal models for computer security. </title> <journal> Computing Surveys, </journal> <volume> 13(3) </volume> <pages> 247-278, </pages> <month> Sept. </month> <year> 1981. </year>
Reference-contexts: This contradicts the first of the Orange Book's Fundamental Computer Security Requirements, namely that There must be an explicit and well-defined security policy enforced by the system.[27] Without such a policy, it is unclear how a secure implementation is supposed to behave <ref> [22] </ref>. In fact, Java has two entirely different uses: as a general purpose programming language, like C++, and as a system for developing untrusted applets on the Web. These roles will require vastly different security policies for Java.
Reference: [23] <author> L. Lemay and C. Perkins. </author> <title> Yes, Java's Secure. Here's Why. </title> <journal> Datamation, </journal> <volume> 42(5) </volume> <pages> 47-49, </pages> <month> March 1, </month> <year> 1996. </year>
Reference: [24] <author> H. M. Levy. </author> <title> Capability-Based Computer Systems. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: With properly nested modules, a programmer could limit the visibility of security-critical components. In the present Java system, only access to variables is controlled, not their visibility. Traditional capability systems <ref> [24] </ref> treat capabilities as hidden names with associated access control rights. Java object references are less flexible than capabilities they must give either all access rights or no access rights to an object.
Reference: [25] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: This nesting depth is then used to make access control decisions. Java programmers can combine related classes into a package. These packages are similar to name spaces in C++[32], modules in Modula-2 [33], or structures in Standard ML <ref> [25] </ref>. While package names consist of components separated by dots, the package name space is actually flat: scoping rules are not related to the apparent name hierarchy. <p> By having multiple interfaces to a module, a module could declare a richer interface for trusted clients, and a more restrictive interface for untrusted clients. The introduction of parameterized modules, like Standard ML's functors <ref> [25] </ref>, should also be investigated. Parameterized modules are a solution to the program structuring problem that opened up our man-in-the-middle attack (see section 3.5). 4. Security Analysis We found a number of interesting problems in both Hot-Java, an alpha release, and Netscape 2.0, a released product.
Reference: [26] <author> M. Mueller. </author> <title> Regarding java security. </title> <journal> RISKS Forum, </journal> <volume> 17(45), </volume> <month> Nov. </month> <year> 1995. </year> <note> ftp://ftp.sri.com/ risks/risks-17.45. </note>
Reference-contexts: Normally, an applet may instruct the browser to load any page on the Web. An attacker's server could record the URL as a message, then redirect the browser to the original destination. When we notified Sun about these channels, they said the DNS channel would be fixed <ref> [26] </ref>, but in fact it was still available in JDK and Netscape. Netscape has since issued a patch to fix this problem. As far as we know, nobody has done an analyis of storage or timing channels in Java. 3.4.
Reference: [27] <institution> National Computer Security Center. Department of Defense Trusted Computer System Evaluation Criteria. National Computer Security Center, </institution> <year> 1985. </year>
Reference: [28] <editor> S. L. Peyton Jones. </editor> <booktitle> The Implementation of Functional Programming Languages. </booktitle> <publisher> Prentice Hall, </publisher> <year> 1987. </year>
Reference-contexts: Type checking normally occurs in the front end of a compiler, where it is a traversal of the abstract syntax tree <ref> [28] </ref>. In the traditional case, type checking is compositional: the type correctness of a construct depends upon the current typing context, the type correctness of subexpressions, and whether the current construct is typable by one of a finite set of rules.
Reference: [29] <author> J. Roskind. </author> <title> Java and security. In Netscape Internet Developer Conference, Netscape Communications Corp., 501 E. </title> <address> Middlefield Road, Mountain View, CA 94043 USA, </address> <month> Mar. </month> <year> 1996. </year> <note> http://home.netscape.com/misc/ developer/conference/. </note>
Reference-contexts: The integrity of the runtime system can also be compromised by applets. To compound these problems, no audit trail exists to reconstruct an attack afterward. In short, the Java runtime is not a high assurance system. 4.1. Policy The present documents on Netscape <ref> [29] </ref> and HotJava do not formally define a security policy.
Reference: [30] <author> J. M. Rushby. </author> <title> Design and verification of secure systems. </title> <booktitle> In Proceedings of the Eighth Symposium on Operating Systems Principles, </booktitle> <pages> pages 12-21, </pages> <month> Dec. </month> <year> 1981. </year>
Reference: [31] <author> B. Stroustrup. </author> <title> The C++ Programming Langauge. </title> <publisher> Addison-Wesley, </publisher> <address> 2nd edition, </address> <year> 1991. </year>
Reference: [32] <author> B. Stroustrup. </author> <title> The Design and Evolution of C++. </title> <publisher> Addison-Wesley, </publisher> <year> 1994. </year>
Reference: [33] <author> N. Wirth. </author> <title> Programming in Modula-2. </title> <publisher> Springer-Verlag, </publisher> <address> 2nd edition, </address> <year> 1983. </year>
Reference-contexts: This nesting depth is then used to make access control decisions. Java programmers can combine related classes into a package. These packages are similar to name spaces in C++[32], modules in Modula-2 <ref> [33] </ref>, or structures in Standard ML [25]. While package names consist of components separated by dots, the package name space is actually flat: scoping rules are not related to the apparent name hierarchy.
Reference: [34] <author> F. Yellin. </author> <title> Low level security in Java. </title> <booktitle> In Fourth International World Wide Web Conference, </booktitle> <address> Boston, MA, </address> <month> Dec. </month> <year> 1995. </year> <title> World Wide Web Consortium. </title> <note> http://www.w3.org/pub/Conferences/WWW4/ Papers/197/40.html. Online For more information related to this paper, please visit our Web page: http://www.cs.princeton.edu/ddean/java/ </note>
Reference-contexts: Unfortunately, it is rather difficult to verify the bytecode. The bytecode is in a linear form, so type checking it requires global dataflow analysis similar to the back end of an optimizing compiler <ref> [34] </ref>; this analysis is complicated further by the existence of exceptions and exception handlers. Type checking normally occurs in the front end of a compiler, where it is a traversal of the abstract syntax tree [28].
References-found: 34

