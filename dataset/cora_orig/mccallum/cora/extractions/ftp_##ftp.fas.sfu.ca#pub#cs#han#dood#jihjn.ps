URL: ftp://ftp.fas.sfu.ca/pub/cs/han/dood/jihjn.ps
Refering-URL: http://fas.sfu.ca/cs/research/groups/DB/sections/publication/dood/dood.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Join Index Hierarchy: An Indexing Structure for Efficient Navigation in Object-Oriented Databases  
Author: Jiawei Han Zhaohui Xie Yongjian Fu 
Keyword: Index Terms: index structures, join indices, query processing, query optimization, object-oriented database.  
Abstract: A novel indexing structure, join index hierarchy, is proposed to handle the "goto's on disk" problem in object-oriented query processing. The method constructs a hierarchy of join indices and transforms a sequence of pointer chasing operations into a simple search in an appropriate join index file, and thus accelerates navigation in object-oriented databases. The method extends the join index structure studied in relational and spatial databases, supports both forward and backward navigations among objects and classes, and localizes update propagations in the hierarchy. Our performance study shows that partial join index hierarchy outperforms several other indexing mechanisms in object-oriented query processing.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> J. Banerjee, W. Kim, and K. C. Kim. </author> <title> Queries in object-oriented databases. </title> <booktitle> In Proc. Int. Conf. Data Engineering, </booktitle> <pages> pages 31-39, </pages> <address> Los Angeles, CA, </address> <month> February </month> <year> 1988. </year> <month> 29 </month>
Reference: [2] <author> E. Bertino. </author> <title> An indexing technique for object-oriented databases. </title> <booktitle> In Proc. Int. Conf. Data Engineering, </booktitle> <pages> pages 160-170, </pages> <address> Kobe, Japan, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: In Bertino and Kim [4], three index structures are presented: nested index, path index and multiindex, which have been later extended to handle inheritance of classes appearing in a path expression <ref> [3, 2] </ref>. The nested index structure facilitates associative search and update by storing together the key values of the tail attribute and the objects of the head class and intermediate objects of a path expression in primary records. <p> An auxiliary index, which basically keeps direct reference information between objects, together with the extra information in the primary records are used to propagate updates. The nested index structure in general outperforms the other two index structures <ref> [3, 2] </ref>. Choenni et. al. [7] propose an optimal index configuration by splitting a long path expression into shorter ones, and by indexing the shorter paths with existing index structures such as those in [4, 2]. <p> The nested index structure in general outperforms the other two index structures [3, 2]. Choenni et. al. [7] propose an optimal index configuration by splitting a long path expression into shorter ones, and by indexing the shorter paths with existing index structures such as those in <ref> [4, 2] </ref>. Shekita and Carey [30] describe a mechanism called field replications which replicate the values of the nested attributes. In-place field replication stores the replicated data with the objects, whereas separate field replication stores the replicated data in a separated place. <p> The navigations, however, are supported efficiently only if the starting points of the navigations can be located by using some nested indexes such as those in <ref> [4, 2] </ref>. Besides, an update is required to be propagated over the network of object identifiers and the nested indexes. 2.2 Preliminaries Following the previous research, a join index hierarchy structure is proposed here to support efficient navigation through multiple object classes. <p> JIH although the update algorithm is similar to Algorithm 3.3. 4 Performance Evaluation of Join Index Hierarchies An analytical model is constructed to study the performance of different join index hierarchies, access support relation [15], a competitive index structure for navigation through a sequence of object classes, and nested index <ref> [4, 2] </ref> for associative search. The study is focused on several crucial performance measurements, including the storage size of a join index hierarchy, the cost of navigation (query processing), and the cost of update propagation over a join index hierarchy. <p> In the second group experiment, six index structures, which support associative searches, are compared: (1) C-JIH as shown in Figure 5 (a); (2) B-JIH as shown in Figure 5 (b); (3) P-JIH as shown in Figure 16; (4) Full-ASR; (4) P-ASR; and (5) Nest which denotes the nested index in <ref> [4, 2] </ref>. Notice that the target node is 4 not shown here due to space limitation. 24 J I (0; 5) in the partial join index hierarchy in Figure 16. navigation between C 0 and C 5 is considered.). <p> For example, if a set of subclasses have similar kinds of attributes and their objects are usually accessed together, it could be beneficial to construct one (combined) base join index node, which is in the same spirit of Kim, Kim and Dale [18] and Bertino <ref> [2] </ref>. A dynamic indexing approach is proposed by Chan, Goh and Ooi [6] which builds a multi-dimensional index for objects in a class hierarchy based on not only class hierarchy and attribute dimension but also query patterns. Similar ideas may be adopted when constructing base join index nodes.
Reference: [3] <author> E. Bertino and P. Foscoli. </author> <title> Index organizations for object-oriented database systems. </title> <journal> IEEE Trans. on Knowledge and Data Engineering,, </journal> <volume> 7 </volume> <pages> 193-209, </pages> <year> 1995. </year>
Reference-contexts: The typical examples are the path indices which associate the values of nested attributes with the objects in the head class of a path expression, e.g., by Maier and Stein [23], Bertino and Kim [4], and Bertino and Foscoli <ref> [3] </ref>. The second kind of index structures, which support navigations, includes the access support relations proposed by Kemper and Moerkotte [15], and the object skeleton by Hua and Tripathy [12]. <p> In Bertino and Kim [4], three index structures are presented: nested index, path index and multiindex, which have been later extended to handle inheritance of classes appearing in a path expression <ref> [3, 2] </ref>. The nested index structure facilitates associative search and update by storing together the key values of the tail attribute and the objects of the head class and intermediate objects of a path expression in primary records. <p> An auxiliary index, which basically keeps direct reference information between objects, together with the extra information in the primary records are used to propagate updates. The nested index structure in general outperforms the other two index structures <ref> [3, 2] </ref>. Choenni et. al. [7] propose an optimal index configuration by splitting a long path expression into shorter ones, and by indexing the shorter paths with existing index structures such as those in [4, 2].
Reference: [4] <author> E. Bertino and W. Kim. </author> <title> Indexing techniques for queries on nested objects. </title> <journal> IEEE Trans. Knowledge and Data Engineering, </journal> <volume> 1(2) </volume> <pages> 196-214, </pages> <year> 1989. </year>
Reference-contexts: The typical examples are the path indices which associate the values of nested attributes with the objects in the head class of a path expression, e.g., by Maier and Stein [23], Bertino and Kim <ref> [4] </ref>, and Bertino and Foscoli [3]. The second kind of index structures, which support navigations, includes the access support relations proposed by Kemper and Moerkotte [15], and the object skeleton by Hua and Tripathy [12]. <p> In Maier and Stein [23], a series of index components, indices on each level of the nested attributes, are maintained for the purpose of update propagations. In Bertino and Kim <ref> [4] </ref>, three index structures are presented: nested index, path index and multiindex, which have been later extended to handle inheritance of classes appearing in a path expression [3, 2]. <p> The nested index structure in general outperforms the other two index structures [3, 2]. Choenni et. al. [7] propose an optimal index configuration by splitting a long path expression into shorter ones, and by indexing the shorter paths with existing index structures such as those in <ref> [4, 2] </ref>. Shekita and Carey [30] describe a mechanism called field replications which replicate the values of the nested attributes. In-place field replication stores the replicated data with the objects, whereas separate field replication stores the replicated data in a separated place. <p> The navigations, however, are supported efficiently only if the starting points of the navigations can be located by using some nested indexes such as those in <ref> [4, 2] </ref>. Besides, an update is required to be propagated over the network of object identifiers and the nested indexes. 2.2 Preliminaries Following the previous research, a join index hierarchy structure is proposed here to support efficient navigation through multiple object classes. <p> JIH although the update algorithm is similar to Algorithm 3.3. 4 Performance Evaluation of Join Index Hierarchies An analytical model is constructed to study the performance of different join index hierarchies, access support relation [15], a competitive index structure for navigation through a sequence of object classes, and nested index <ref> [4, 2] </ref> for associative search. The study is focused on several crucial performance measurements, including the storage size of a join index hierarchy, the cost of navigation (query processing), and the cost of update propagation over a join index hierarchy. <p> In the second group experiment, six index structures, which support associative searches, are compared: (1) C-JIH as shown in Figure 5 (a); (2) B-JIH as shown in Figure 5 (b); (3) P-JIH as shown in Figure 16; (4) Full-ASR; (4) P-ASR; and (5) Nest which denotes the nested index in <ref> [4, 2] </ref>. Notice that the target node is 4 not shown here due to space limitation. 24 J I (0; 5) in the partial join index hierarchy in Figure 16. navigation between C 0 and C 5 is considered.).
Reference: [5] <author> J. A. Blakeley, W. J. McKenna, and G. Graefe. </author> <title> Experiences building the open OODB query optimizer. </title> <booktitle> In Proc. ACM-SIGMOD Conf. Management of Data, </booktitle> <pages> pages 287-296, </pages> <address> Washington, DC, </address> <month> May </month> <year> 1993. </year>
Reference: [6] <author> Chee Yong Chan, Cheng Hian Goh, and Beng Chin Ooi. </author> <title> Indexing oodb instances based on access proximity. </title> <booktitle> In Proc. 13th International Conf. on Data Engineering, </booktitle> <pages> pages 14-21, </pages> <address> Birmingham, UK, </address> <year> 1997. </year>
Reference-contexts: Further, an update on one object may need to be propagated to several components or to the entire index [24], -tree <ref> [6] </ref>, CH-tree [18], H-tree [21] and CG-tree [17], will not be discussed in this paper. 5 access support relation, which could be costly. Hua and Tripathy [12] propose a navigation structure called object skeleton which essentially is a network of object identifiers. <p> A dynamic indexing approach is proposed by Chan, Goh and Ooi <ref> [6] </ref> which builds a multi-dimensional index for objects in a class hierarchy based on not only class hierarchy and attribute dimension but also query patterns. Similar ideas may be adopted when constructing base join index nodes. Furthermore, there may exist more than one semantic linkage between two object classes.
Reference: [7] <author> S. Choenni, E. Bertino, H. M. Blanken, and T. Chang. </author> <title> On the selection of optimal index configuration in OO databases. </title> <booktitle> In Proc. Int. Conf. Data Engineering, </booktitle> <pages> pages 526-537, </pages> <address> Phoenix, AZ, USA, </address> <month> February </month> <year> 1994. </year>
Reference-contexts: An auxiliary index, which basically keeps direct reference information between objects, together with the extra information in the primary records are used to propagate updates. The nested index structure in general outperforms the other two index structures [3, 2]. Choenni et. al. <ref> [7] </ref> propose an optimal index configuration by splitting a long path expression into shorter ones, and by indexing the shorter paths with existing index structures such as those in [4, 2]. Shekita and Carey [30] describe a mechanism called field replications which replicate the values of the nested attributes.
Reference: [8] <author> S. Cluet and C. Delobel. </author> <title> A general framework for the optimization of object-oriented queries. </title> <booktitle> In Proc. ACM-SIGMOD Conf. Management of Data, </booktitle> <pages> pages 383-392, </pages> <year> 1992. </year>
Reference: [9] <author> G. Graefe. </author> <title> Query evaluation techniques for large databases. </title> <journal> ACM Computing Survey, </journal> <volume> 25(2) </volume> <pages> 73-170, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: a class to objects in other classes are essentially "pointer chasing" (using object identity "OID" references) operations which may cause significant performance degradation because the objects to be accessed may be stored at widely scattered locations and many disk read operations may be required to fetch them into main memory <ref> [9] </ref>. The attempts to solve this problem can be classified into three classes of techniques: the indexing method (e.g., [15, 12]), the read-ahead buffering method (e.g., [26]), and complex object assembly method (e.g., [14]).
Reference: [10] <author> G. Graefe and D. Maier. </author> <title> Query optimization in object-oriented database systems: a prospectus. </title> <booktitle> In Advances in Object-Oriented Database Systems. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1988. </year>
Reference: [11] <author> T. Haerder. </author> <title> Implementing a generalized access path structure for a relational database system. </title> <journal> ACM Trans. Database Systems, </journal> <volume> 3(3) </volume> <pages> 285-298, </pages> <month> September </month> <year> 1978. </year>
Reference-contexts: In Section 5, implementation considerations, improvements and extensions of the approach are discussed. Finally, the study is summarized in Section 6. 2 Join Index Hierarchy 2.1 Previous work Haerder <ref> [11] </ref> proposed links to optimize joins. The links are implemented by chaining tuples using tuple identifiers, an implementation similar to that of CODASYL systems. The join index structure was proposed by Valduriez [32] for optimizing join and semijoin operations in relational databases.
Reference: [12] <author> K. A. Hua and C. Tripathy. </author> <title> Object skeletons: an efficient navigation structure for object-oriented database systems. </title> <booktitle> In Proc. Int. Conf. Data Engineering, </booktitle> <pages> pages 508-517, </pages> <address> Houston, TX, </address> <month> Feb </month> <year> 1994. </year>
Reference-contexts: The attempts to solve this problem can be classified into three classes of techniques: the indexing method (e.g., <ref> [15, 12] </ref>), the read-ahead buffering method (e.g., [26]), and complex object assembly method (e.g., [14]). <p> The second kind of index structures, which support navigations, includes the access support relations proposed by Kemper and Moerkotte [15], and the object skeleton by Hua and Tripathy <ref> [12] </ref>. In Maier and Stein [23], a series of index components, indices on each level of the nested attributes, are maintained for the purpose of update propagations. <p> Further, an update on one object may need to be propagated to several components or to the entire index [24], -tree [6], CH-tree [18], H-tree [21] and CG-tree [17], will not be discussed in this paper. 5 access support relation, which could be costly. Hua and Tripathy <ref> [12] </ref> propose a navigation structure called object skeleton which essentially is a network of object identifiers. The two object identifiers are connected if the corresponding objects are associated by, for example, attribute relationship.
Reference: [13] <author> K. Kato and T. Masuda. </author> <title> Persistent caching: an implementation technique for complex objects with object identity. </title> <journal> IEEE Trans. Software Engineering, </journal> <volume> 18(7), </volume> <month> July </month> <year> 1992. </year>
Reference-contexts: The separated replication is used to solve the issue of updating the shared replicated data. Inverted path structures, which are similar to the index components in [23], are used to support update propagation. Kato and Masuda <ref> [13] </ref> present a mechanism called persistent caching which is similar to the field replication [30]. In this approach, the referenced objects are cached into the referencing objects. Update is delayed until the cached objects are required.
Reference: [14] <author> T. Keller, G. Graefe, and D. Maier. </author> <title> Efficient assembly of complex objects. </title> <booktitle> In Proc. ACM-SIGMOD Conf. Management of Data, </booktitle> <pages> pages 148-157, </pages> <address> Denver, CO, </address> <month> May </month> <year> 1991. </year>
Reference-contexts: The attempts to solve this problem can be classified into three classes of techniques: the indexing method (e.g., [15, 12]), the read-ahead buffering method (e.g., [26]), and complex object assembly method (e.g., <ref> [14] </ref>). <p> It is interesting to compare and/or integrate the join index hierarchy method with other object query optimization techniques, such as read-ahead buffering [26] and complex object assembly <ref> [14] </ref>.
Reference: [15] <author> A. Kemper and G. Moerkotte. </author> <title> Access support in object bases. </title> <booktitle> In Proc. ACM-SIGMOD Conf. Management of Data, </booktitle> <pages> pages 364-374, </pages> <address> Atlantic City, NJ, </address> <month> May </month> <year> 1990. </year> <month> 30 </month>
Reference-contexts: The attempts to solve this problem can be classified into three classes of techniques: the indexing method (e.g., <ref> [15, 12] </ref>), the read-ahead buffering method (e.g., [26]), and complex object assembly method (e.g., [14]). <p> The second kind of index structures, which support navigations, includes the access support relations proposed by Kemper and Moerkotte <ref> [15] </ref>, and the object skeleton by Hua and Tripathy [12]. In Maier and Stein [23], a series of index components, indices on each level of the nested attributes, are maintained for the purpose of update propagations. <p> A hash table stored in the main memory is employed to maintain the cached values consistent with the original objects. These approaches support only the associated retrieval of objects through nested attributes but not navigations in both directions along a reference chain. Kemper and Moerkotte <ref> [15] </ref> present a data structure called access support relation which keeps the identifiers of those objects connected by attribute relationships in a path expression and can span over the reference chains of a path expression. <p> a complete JIH obviously takes more storage space and more update propagation cost than a partial JIH although the update algorithm is similar to Algorithm 3.3. 4 Performance Evaluation of Join Index Hierarchies An analytical model is constructed to study the performance of different join index hierarchies, access support relation <ref> [15] </ref>, a competitive index structure for navigation through a sequence of object classes, and nested index [4, 2] for associative search. <p> Notice that cases (2) and (4) correspond to two extreme cases of the access support relation method proposed in <ref> [15] </ref>, in which the former (case 2) decomposes each class pair into one component (i.e., binary decomposition of a full ASR: thus, a B-JIH is labeled B-JIH/B-ASR in the performance curves.), whereas the latter (case 4) merges the access path (sequence) into one relation.
Reference: [16] <author> A. Kemper and G Moerkotte. </author> <title> Advanced query processing in object bases using access support relations. </title> <booktitle> In Proc. Int. Conf. Very Large Database, </booktitle> <pages> pages 290-301, </pages> <address> Brisbane, Australia, </address> <month> August </month> <year> 1990. </year>
Reference: [17] <author> C. Kilger and G. Moerkotte. </author> <title> Indexing multiple sets. </title> <booktitle> In Proc. Int. Conf. Very Large Database, </booktitle> <address> Santiago, Chile, </address> <month> September </month> <year> 1994. </year>
Reference-contexts: Further, an update on one object may need to be propagated to several components or to the entire index [24], -tree [6], CH-tree [18], H-tree [21] and CG-tree <ref> [17] </ref>, will not be discussed in this paper. 5 access support relation, which could be costly. Hua and Tripathy [12] propose a navigation structure called object skeleton which essentially is a network of object identifiers.
Reference: [18] <author> K. C. Kim, W. Kim, and A. Dale. </author> <title> Indexing techniques for object-oriented databases. </title> <editor> In W. Kim and F. H. Lochovsky, editors, </editor> <booktitle> Object-oriented concepts, Databases, and Applications, </booktitle> <pages> pages 371-394. </pages> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Further, an update on one object may need to be propagated to several components or to the entire index [24], -tree [6], CH-tree <ref> [18] </ref>, H-tree [21] and CG-tree [17], will not be discussed in this paper. 5 access support relation, which could be costly. Hua and Tripathy [12] propose a navigation structure called object skeleton which essentially is a network of object identifiers. <p> For example, if a set of subclasses have similar kinds of attributes and their objects are usually accessed together, it could be beneficial to construct one (combined) base join index node, which is in the same spirit of Kim, Kim and Dale <ref> [18] </ref> and Bertino [2]. A dynamic indexing approach is proposed by Chan, Goh and Ooi [6] which builds a multi-dimensional index for objects in a class hierarchy based on not only class hierarchy and attribute dimension but also query patterns.
Reference: [19] <author> H. A. Kuno and H. A. Rundensteiner. </author> <title> Augmented inherited multi-index structure for maintenance of materialized path query views. </title> <booktitle> In Proc. Sixth International Workshop on Research Issues in Data Engineering, </booktitle> <pages> pages 128-137, </pages> <address> New Orleans, LA, </address> <year> 1996. </year>
Reference: [20] <author> R. S. G. Lanzelotte, P. Valduriez, M. Ziane, and J. Cheiney. </author> <title> Optimization of nonrecursive queries in OODBs. </title> <booktitle> In Proc. Int. Conf. Deductive and Object-Oriented Databases(DOOD), </booktitle> <address> Munich, Germany, </address> <month> December </month> <year> 1991. </year>
Reference: [21] <author> C. C. Low, B. C. Ooi, and H. Lu. H-tree: </author> <title> a dynamic associative search index for OODB. </title> <booktitle> In Proc. ACM-SIGMOD Conf. Management of Data, </booktitle> <pages> pages 134-143, </pages> <address> San Diego, CA, </address> <month> May </month> <year> 1992. </year>
Reference-contexts: Further, an update on one object may need to be propagated to several components or to the entire index [24], -tree [6], CH-tree [18], H-tree <ref> [21] </ref> and CG-tree [17], will not be discussed in this paper. 5 access support relation, which could be costly. Hua and Tripathy [12] propose a navigation structure called object skeleton which essentially is a network of object identifiers.
Reference: [22] <author> W. Lu and J. Han. </author> <title> Distance-associated join indices for spatial range search. </title> <booktitle> In Proc. 8th Int. Conf. Data Engineering, </booktitle> <pages> pages 284-292, </pages> <address> Phoenix, AZ, </address> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: Following the philosophy of indexing methods, a join index hierarchy method is proposed in this paper, which extends the join index technique developed in relational databases [32] and its variations in spatial databases <ref> [28, 22] </ref>, by constructing hierarchies of join indices to accelerate navigations via a sequence of objects and classes. In a broad sense, a join index in our method stores the pairs of identifiers of objects 2 of two classes that are connected via direct or indirect logical relationships. <p> For example, a spatial join index structure was developed by Rotem [28] and organized in the form of grid files. Further, certain precom-puted information (e.g. distance) can be associated with such spatial join index structure to speed up query processing as shown by Lu and Han <ref> [22] </ref>. Two kinds of index structures have been studied in object-oriented databases 2 . The first one aims at 2 Since we concentrate on the index structures for efficient navigations, the index structures for class hierarchies, e.g., Multikey 4 associative search. <p> The evaluation of such linkages at the join index construction time and the storage of the join indices together with other frequently used information (such as distance, etc. <ref> [22] </ref>) in join indices will trade storage space for query evaluation efficiency. It will be especially beneficial if such computation must be performed repeatedly or iteratively. <p> For example, to find all the lake and park pairs whose intersected regions greater than 1 square kilometer, one can retrieve the join indices and return the results directly (if the information-associated join indices <ref> [22] </ref> are constructed and the area of intersection is the associated information).
Reference: [23] <author> D. Maier and J. Stein. </author> <title> Indexing in an object-oriented DBMS. </title> <booktitle> In Proc. IEEE Int. Workshop on Object-oriented Database System, </booktitle> <pages> pages 171-182, </pages> <address> Asilomar, Pacific Grove, CA, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: The typical examples are the path indices which associate the values of nested attributes with the objects in the head class of a path expression, e.g., by Maier and Stein <ref> [23] </ref>, Bertino and Kim [4], and Bertino and Foscoli [3]. The second kind of index structures, which support navigations, includes the access support relations proposed by Kemper and Moerkotte [15], and the object skeleton by Hua and Tripathy [12]. In Maier and Stein [23], a series of index components, indices on <p> path expression, e.g., by Maier and Stein <ref> [23] </ref>, Bertino and Kim [4], and Bertino and Foscoli [3]. The second kind of index structures, which support navigations, includes the access support relations proposed by Kemper and Moerkotte [15], and the object skeleton by Hua and Tripathy [12]. In Maier and Stein [23], a series of index components, indices on each level of the nested attributes, are maintained for the purpose of update propagations. <p> In-place field replication stores the replicated data with the objects, whereas separate field replication stores the replicated data in a separated place. The separated replication is used to solve the issue of updating the shared replicated data. Inverted path structures, which are similar to the index components in <ref> [23] </ref>, are used to support update propagation. Kato and Masuda [13] present a mechanism called persistent caching which is similar to the field replication [30]. In this approach, the referenced objects are cached into the referencing objects. Update is delayed until the cached objects are required.
Reference: [24] <author> T.A. </author> <title> Mueck and M.L. Polaschek. The multikey type index for persistent object sets. </title> <booktitle> In Proc. 13th International Conf. on Data Engineering, </booktitle> <pages> pages 22-31, </pages> <address> Birmingham, UK, </address> <year> 1997. </year>
Reference-contexts: Further, an update on one object may need to be propagated to several components or to the entire index <ref> [24] </ref>, -tree [6], CH-tree [18], H-tree [21] and CG-tree [17], will not be discussed in this paper. 5 access support relation, which could be costly. Hua and Tripathy [12] propose a navigation structure called object skeleton which essentially is a network of object identifiers.
Reference: [25] <author> Beng Chin Ooi, Jiawei Han, Hongjun Lu, and Kian Lee Tan. </author> <title> Index nesting an efficient approach to indexing in object-oriented databases. </title> <journal> VLDB Journal, </journal> <volume> 5 </volume> <pages> 215-228, </pages> <year> 1996. </year>
Reference: [26] <author> M. Palmer and S. B. Zdonik. </author> <title> FIDO: a cach that learns to fetch. </title> <booktitle> In Proc. Int. Conf. Very Large Database, </booktitle> <address> Barcelona, Spain, </address> <year> 1991. </year>
Reference-contexts: The attempts to solve this problem can be classified into three classes of techniques: the indexing method (e.g., [15, 12]), the read-ahead buffering method (e.g., <ref> [26] </ref>), and complex object assembly method (e.g., [14]). <p> Join index hierarchy is an interesting indexing structure which could be a promising candidate at solving "pointer chasing" problems in object-oriented database query processing. It is interesting to compare and/or integrate the join index hierarchy method with other object query optimization techniques, such as read-ahead buffering <ref> [26] </ref> and complex object assembly [14].
Reference: [27] <author> S. Ramaswamy and P.C. Kanellakis. </author> <title> Oodb indexing by class-division. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 24 </volume> <pages> 139-150, </pages> <year> 1995. </year>
Reference: [28] <author> D. Rotem. </author> <title> Spatial join indices. </title> <booktitle> In Proc. 7th Int. Conf. Data Engineering, </booktitle> <pages> pages 500-509, </pages> <address> Kobe, Japan, </address> <month> April </month> <year> 1991. </year>
Reference-contexts: Following the philosophy of indexing methods, a join index hierarchy method is proposed in this paper, which extends the join index technique developed in relational databases [32] and its variations in spatial databases <ref> [28, 22] </ref>, by constructing hierarchies of join indices to accelerate navigations via a sequence of objects and classes. In a broad sense, a join index in our method stores the pairs of identifiers of objects 2 of two classes that are connected via direct or indirect logical relationships. <p> Join index structures can be applied to different application domains. For example, a spatial join index structure was developed by Rotem <ref> [28] </ref> and organized in the form of grid files. Further, certain precom-puted information (e.g. distance) can be associated with such spatial join index structure to speed up query processing as shown by Lu and Han [22]. Two kinds of index structures have been studied in object-oriented databases 2 .
Reference: [29] <author> Sang Koo Seo and Yoon Joon Lee. </author> <title> Methodology for index configurations in object-oriented databases. </title> <journal> Information Sciences, </journal> <volume> 93 </volume> <pages> 187-210, </pages> <year> 1996. </year> <month> 31 </month>
Reference: [30] <author> E. J. Shekita and M. J. Carey. </author> <title> Performance enhancement through replication in an object-oriented DBMS. </title> <booktitle> In Proc. ACM-SIGMOD Conf. Management of Data, </booktitle> <pages> pages 325-336, </pages> <year> 1989. </year>
Reference-contexts: Choenni et. al. [7] propose an optimal index configuration by splitting a long path expression into shorter ones, and by indexing the shorter paths with existing index structures such as those in [4, 2]. Shekita and Carey <ref> [30] </ref> describe a mechanism called field replications which replicate the values of the nested attributes. In-place field replication stores the replicated data with the objects, whereas separate field replication stores the replicated data in a separated place. <p> Inverted path structures, which are similar to the index components in [23], are used to support update propagation. Kato and Masuda [13] present a mechanism called persistent caching which is similar to the field replication <ref> [30] </ref>. In this approach, the referenced objects are cached into the referencing objects. Update is delayed until the cached objects are required. A hash table stored in the main memory is employed to maintain the cached values consistent with the original objects.
Reference: [31] <author> D. D. Straube and M. T. Ozsu. </author> <title> Queries and query processing in object-oriented database systems. </title> <journal> ACM Trans. Office and Information Systems, </journal> <volume> 6(4) </volume> <pages> 387-430, </pages> <month> Oct </month> <year> 1990. </year>
Reference: [32] <author> P. Valduriez. </author> <title> Join indices. </title> <journal> ACM Trans. Database Systems, </journal> <volume> 12(2) </volume> <pages> 218-246, </pages> <year> 1987. </year>
Reference-contexts: Following the philosophy of indexing methods, a join index hierarchy method is proposed in this paper, which extends the join index technique developed in relational databases <ref> [32] </ref> and its variations in spatial databases [28, 22], by constructing hierarchies of join indices to accelerate navigations via a sequence of objects and classes. <p> Finally, the study is summarized in Section 6. 2 Join Index Hierarchy 2.1 Previous work Haerder [11] proposed links to optimize joins. The links are implemented by chaining tuples using tuple identifiers, an implementation similar to that of CODASYL systems. The join index structure was proposed by Valduriez <ref> [32] </ref> for optimizing join and semijoin operations in relational databases. A join index file stores pairs of the surrogates of joining tuples from two relations, which transforms expensive joins to selections in join index files. <p> Since efficient access structures can be constructed on join indices, it has been shown that relational join using join index structures outperforms other relational join methods in many cases <ref> [32] </ref>. Join index structures can be applied to different application domains. For example, a spatial join index structure was developed by Rotem [28] and organized in the form of grid files. <p> The details of the estimation of some of these parameters are in Appendix A. 18 4.1 Storage and navigation costs The number of pages for a join index JI (i; j) is jjJ I (i; j)jj = d B fl ff Following Valduriez <ref> [32] </ref>, the number of disk accesses 3 for a forward navigation from a set of n i objects in C i to objects in C j using a target join index is 1 + y (n i ; d BT f e; jC i j) + y (n i ; jjJI <p> Here 3 Here it is assumed that a typical B + -tree is of two levels. The results for a B + -tree of more than two levels can be calculated similarly as in Valduriez <ref> [32] </ref>. 19 jffiJ I (k; k + 1)j k and jffiJI (k; k + 1)j k+1 are initialized, e.g., to 1 at the beginning. One page access is needed to retrieve the root node of the B + -tree of J I (k; k + 1).
Reference: [33] <author> Z. Xie and J. Han. </author> <title> Optimization of queries containing complex selections, joins and aggregations. </title> <booktitle> In Proc. International Conference on Computing and Information, </booktitle> <address> Peterborough, Ontario, Canada, </address> <month> May </month> <year> 1994. </year>
Reference: [34] <author> S. B. Yao. </author> <title> Approximating block accesses in database organizations. </title> <journal> Communications of the ACM, </journal> <volume> 20(4) </volume> <pages> 260-261, </pages> <month> April </month> <year> 1977. </year>
Reference-contexts: set of n i objects in C i to objects in C j using a target join index is 1 + y (n i ; d BT f e; jC i j) + y (n i ; jjJI (i; j)jj; jC i j); where y is a function from Yao <ref> [34] </ref>, y (k; m; n) = dm fl (1 i=1 m i + 1 )e: It represents the number of page accesses for retrieving k objects out of n objects distributed over m pages. One page access is needed to retrieve the root node.
References-found: 34

