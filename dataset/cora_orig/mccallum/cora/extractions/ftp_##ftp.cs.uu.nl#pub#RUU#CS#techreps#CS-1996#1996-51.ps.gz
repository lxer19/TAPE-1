URL: ftp://ftp.cs.uu.nl/pub/RUU/CS/techreps/CS-1996/1996-51.ps.gz
Refering-URL: http://www.cs.ruu.nl/docs/research/publication/TechList1.html
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: emails: fsaraiva,kuiper,swierstrag@cs.ruu.nl penningm@natlab.research.philips.com  
Title: Strictification of Lazy Functions  
Author: Jo~ao Saraiva Doaitse Swierstra, Matthijs Kuiper and Maarten Pennings 
Address: P.O. Box 80.089, 3508 TB Utrecht, The Netherlands  
Affiliation: Department of Computer Science, University of Utrecht  
Abstract: This papers describes a transformation from lazy functions into efficient non-lazy ones. The functions we study perform multiple traversals over a data structure. Our transformation performs a global analysis of the calling structure of a set of mutually recursive lazy-functions in order to transform them into sets of functions which must be called in sequence. Many of the resulting functions can be eliminated by the optimizations presented in this paper. We present measurements that show that transformed and optimized functions allow efficient incremental execution. The paper contains examples that were automatically constructed with a generator of incremental functional programs.
Abstract-found: 1
Intro-found: 1
Reference: [Bir84] <author> R. S. Bird. </author> <title> Using circular programs to eliminate multiple traversals of data. </title> <journal> Acta Informatica, </journal> (21):239-250, January 1984. 
Reference-contexts: 1 Introduction One of the more intricate parts of the world of functional programming deals with the construction of so-called circular programs, with the program repmin of Bird acting as the canonical representative of this class <ref> [Bir84] </ref>. For almost everyone, when first introduced to such programs, it takes a while before (s)he actually is convinced that such a program may work indeed as claimed by their authors. It is the use of lazy evaluation which does the trick. <p> It is the use of lazy evaluation which does the trick. For those who have not seen such programs before, we present here again the example of <ref> [Bir84] </ref>. <p> Gofer) is "straightforward". The complete program is presented in figure 1. Where the function access takes as arguments the environment and the variable being accessed and returns the appropriate instruction. Observe that this program is a circular program (in the sense of <ref> [Bir84] </ref>), that is, one of the results of a function call is also one of its arguments.
Reference: [Hug85] <editor> John Hughes. Lazy memo-functions. In Jean-Pierre Jouannaud, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, volume 201 of LNCS, </booktitle> <pages> pages 129-146. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1985. </year>
Reference-contexts: The fact that the arguments to these functions can be evaluated before the call, without changing the termination properties, makes the resulting evaluators efficient and simple, and thus there is no need anymore to implement the much more complicated, and much less efficient, caching of lazy functions <ref> [Hug85] </ref>. In this paper we present the techniques we present our techniques in the setting of functional languages and transformations thereof. One might foresee that these methods find their way into a compiler, as has happened with techniques like deforestation and virtual data structures [Wad90, SdM93].
Reference: [Joh87] <author> Thomas Johnsson. </author> <title> Attribute grammars as a functional programming paradigm. </title> <editor> In G. Kahn, editor, </editor> <booktitle> Functional Programming Languages and Computer Architecture, volume 274 of LNCS, </booktitle> <pages> pages 154-173. </pages> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1987. </year>
Reference-contexts: It has furthermore been noticed by <ref> [KS87, Joh87] </ref> that there exists a direct translation from attribute grammars into this class of circular programs. Those acquainted with cata-morphisms will furthermore recognise a catamorphims which returns a higher order type in the above program [MFP91].
Reference: [Kas80] <author> Uwe Kastens. </author> <title> Ordered attribute grammars. </title> <journal> Acta Informatica, </journal> <volume> 13 </volume> <pages> 229-256, </pages> <year> 1980. </year>
Reference-contexts: results of traversal functions 2. linearization of dependencies 3. definition of interfaces of sub-traversals 4. dealing with interdependencies between sub-traversals 5. generation of Gofer code The first step determines how arguments and results of functions may depend upon each other, and is based on well known attribute grammar analysis techniques <ref> [Kas80] </ref>. This step builds two kinds of dependencies: those among the arguments and results of one function and those among all arguments and results of all calls occurring in a function body.
Reference: [KS87] <author> Matthijs Kuiper and Doaitse Swierstra. </author> <title> Using attribute grammars to derive efficient functional programs. </title> <booktitle> In Computing Science in the Netherlands CSN'87, </booktitle> <month> November </month> <year> 1987. ftp://ftp.cs.ruu.nl/pub/RUU/CS/techreps/CS-1986/1986-16.ps.gz. </year>
Reference-contexts: It has furthermore been noticed by <ref> [KS87, Joh87] </ref> that there exists a direct translation from attribute grammars into this class of circular programs. Those acquainted with cata-morphisms will furthermore recognise a catamorphims which returns a higher order type in the above program [MFP91].
Reference: [MFP91] <author> Erik Meyer, Maarten Fokkinga, and Ross Patterson. </author> <title> Functional programming with bananas, lenses and barbed wire. </title> <booktitle> In Functional Programming Languages and Computer Architecture, </booktitle> <year> 1991. </year>
Reference-contexts: It has furthermore been noticed by [KS87, Joh87] that there exists a direct translation from attribute grammars into this class of circular programs. Those acquainted with cata-morphisms will furthermore recognise a catamorphims which returns a higher order type in the above program <ref> [MFP91] </ref>. In recent years we have been interested in the incremental evaluation of (higher order) attribute grammars [VSK91, SV91, PSV92, Pen94].
Reference: [Pen94] <author> Maarten Pennings. </author> <title> Generating Incremental Evaluators. </title> <type> PhD thesis, </type> <institution> Utrecht University, </institution> <month> November </month> <year> 1994. </year> <month> ftp://ftp.cs.ruu.nl/pub/RUU/CS/phdtheses/Pennings/. </month>
Reference-contexts: Those acquainted with cata-morphisms will furthermore recognise a catamorphims which returns a higher order type in the above program [MFP91]. In recent years we have been interested in the incremental evaluation of (higher order) attribute grammars <ref> [VSK91, SV91, PSV92, Pen94] </ref>. The main aspect of the method being used is that attribute grammars are transformed into large sets of mutually recursive strict functions, the calls to which are being cached in order to avoid unnecessary reevaluations. <p> Some traversal functions are transformed in as many as 12 sub-traversals. 5.1 Attribute Evaluator We have incorporated a new back-end to the Lrc system <ref> [Pen94] </ref> in order to produce Gofer based evaluators. The code presented in figure 4 has been automatically generated by our system, starting from the attribute-grammar-equivalent of the initial circular program.
Reference: [PSV92] <author> Maarten Pennings, Doaitse Swierstra, and Harald Vogt. </author> <title> Using cached functions and constructors for incremental attribute evaluation. </title> <editor> In M. Bruynooghe and M. Wirsing, editors, </editor> <booktitle> Programming Language Implementation and Logic Programming, volume 631 of LNCS, </booktitle> <pages> pages 130-144. </pages> <publisher> Springer-Verlag, </publisher> <year> 1992. </year>
Reference-contexts: Those acquainted with cata-morphisms will furthermore recognise a catamorphims which returns a higher order type in the above program [MFP91]. In recent years we have been interested in the incremental evaluation of (higher order) attribute grammars <ref> [VSK91, SV91, PSV92, Pen94] </ref>. The main aspect of the method being used is that attribute grammars are transformed into large sets of mutually recursive strict functions, the calls to which are being cached in order to avoid unnecessary reevaluations.
Reference: [SdM93] <author> S. Doaitse Swierstra and O. de Moor. </author> <title> Virtual data structures. </title> <editor> In Bernhard Moller, Helmut Partsch, and Steve Schuman, editors, </editor> <booktitle> Formal Program Development, volume 755 of LNCS, </booktitle> <pages> pages 355-371, </pages> <year> 1993. </year>
Reference-contexts: In this paper we present the techniques we present our techniques in the setting of functional languages and transformations thereof. One might foresee that these methods find their way into a compiler, as has happened with techniques like deforestation and virtual data structures <ref> [Wad90, SdM93] </ref>. It is relatively easy to see how the program repmin 0 might be splitted into two functions: one that computes the minimal value of all the leaves, and one that constructs the resulting tree. In this way the circular dependency is broken.
Reference: [SV91] <author> Doaitse Swierstra and Harald Vogt. </author> <title> Higher order attribute grammars. </title> <editor> In H. Alblas and B. Melichar, editors, </editor> <booktitle> International Summer School on Attribute Grammars, Applications and Systems, volume 545 of LNCS, </booktitle> <pages> pages 48-113. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Those acquainted with cata-morphisms will furthermore recognise a catamorphims which returns a higher order type in the above program [MFP91]. In recent years we have been interested in the incremental evaluation of (higher order) attribute grammars <ref> [VSK91, SV91, PSV92, Pen94] </ref>. The main aspect of the method being used is that attribute grammars are transformed into large sets of mutually recursive strict functions, the calls to which are being cached in order to avoid unnecessary reevaluations.
Reference: [VSK91] <author> Harald Vogt, Doaitse Swierstra, and Matthijs Kuiper. </author> <title> Efficient incremental evaluation of higher order attribute grammars. </title> <editor> In J. Maluszynki and M. Wirsing, editors, </editor> <booktitle> Programming Language Implementation and Logic Programming, volume 528 of LNCS, </booktitle> <pages> pages 231-242. </pages> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: Those acquainted with cata-morphisms will furthermore recognise a catamorphims which returns a higher order type in the above program [MFP91]. In recent years we have been interested in the incremental evaluation of (higher order) attribute grammars <ref> [VSK91, SV91, PSV92, Pen94] </ref>. The main aspect of the method being used is that attribute grammars are transformed into large sets of mutually recursive strict functions, the calls to which are being cached in order to avoid unnecessary reevaluations.
Reference: [Wad90] <author> Philip Wadler. </author> <title> Deforestation: transforming programs to eliminate trees. </title> <journal> Theoretical Computer Science, </journal> <volume> 73 </volume> <pages> 231-248, </pages> <year> 1990. </year> <month> 12 </month>
Reference-contexts: In this paper we present the techniques we present our techniques in the setting of functional languages and transformations thereof. One might foresee that these methods find their way into a compiler, as has happened with techniques like deforestation and virtual data structures <ref> [Wad90, SdM93] </ref>. It is relatively easy to see how the program repmin 0 might be splitted into two functions: one that computes the minimal value of all the leaves, and one that constructs the resulting tree. In this way the circular dependency is broken.
References-found: 12

