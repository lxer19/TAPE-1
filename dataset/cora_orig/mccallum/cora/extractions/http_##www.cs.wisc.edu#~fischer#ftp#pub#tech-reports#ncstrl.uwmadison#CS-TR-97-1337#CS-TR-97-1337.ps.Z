URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-97-1337/CS-TR-97-1337.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-97-1337/
Root-URL: http://www.cs.wisc.edu
Title: Identifying Modules Via Concept Analysis  
Author: Michael Siff and Thomas Reps 
Keyword: Concept analysis, modularization, software migration, software restructuring, reverse engineering, design recovery.  
Address: 1210 West Dayton Street Madison, WI 53706  
Affiliation: University of Wisconsin-Madison  
Email: fsiff, repsg@cs.wisc.edu  
Phone: phone: (608) 262-1204 fax: (608) 262-9777  
Date: January 31, 1997  
Abstract: We describe a general technique for identifying modules in programs that do not designate them explicitly. The method is based on concept analysis | a branch of lattice theory that can be used to identify similarities among a set of objects based on their attributes. We discuss how concept analysis can identify potential modules using both "positive" and "negative" information. We present an algorithmic framework to construct a lattice of concepts from a program, where each concept represents a potential module. We describe an algorithm that, given a concept lattice, identifies possible ways of partitioning the program into modules. We discuss a prototype implementation and some results on small and medium-sized programs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> B. L. Achee and Doris L. Carver. </author> <title> A greedy approach to object identification in imperative code. </title> <booktitle> In Third Workshop on Program Comprehension, </booktitle> <pages> pages 4-11, </pages> <year> 1994. </year> <month> 18 </month>
Reference-contexts: The set of ancestors of x, denoted by ancs (x), is the set of lattice elements y such that y x and y 6= x. 14 <ref> [1] </ref> A sups (?) // the atomic partition [2] P fAg [4] while W 6= ; do [5] remove some p from W [6] for each c 2 p [7] for each c 0 2 sups (c) [8] p 0 p ancs (c 0 ) [9] if ( p 0 ) <p> The additional discriminatory power of the concept-analysis approach is due to the fact that it is able to exploit both positive and negative information. In contrast with the approach to identifying objects described in <ref> [1] </ref>, our technique is aimed at analyzing relationships among functions and types to identify classes. In [1], the aim is to identify objects that link functions to specific variables. A similar effect can be achieved via concept analysis by introducing one attribute for each actual parameter. <p> In contrast with the approach to identifying objects described in <ref> [1] </ref>, our technique is aimed at analyzing relationships among functions and types to identify classes. In [1], the aim is to identify objects that link functions to specific variables. A similar effect can be achieved via concept analysis by introducing one attribute for each actual parameter. <p> A similar effect can be achieved via concept analysis by introducing one attribute for each actual parameter. There has been a certain amount of work involving the use of cluster analysis to identify potential modules (e.g., <ref> [5, 1, 7] </ref>). This work (implicitly or explicitly) involves the identification of potential modules by determining a similarity measure among pairs of functions. We are currently investigating the link between concept analysis and cluster analysis.
Reference: [2] <author> G. Canfora, A. Cimitile, M. Tortorella, and M. Munro. </author> <title> Experiments in identifying reusable abstract data types in program code. </title> <booktitle> In Second Workshop on Program Comprehension, </booktitle> <pages> pages 36-45, </pages> <year> 1993. </year>
Reference-contexts: The resulting information can then be supplied to a suitable transformation tool that maps C code to C++ code, as in the aforementioned example. Although other modularization algorithms are able to identify the same decomposition <ref> [2, 14] </ref>, they are unable to handle a variant of this example in which stack and queue are more tightly intertwined (see Section 3.2). In Section 3.2, we show that concept analysis is able to group the code from the latter example into separate queue and stack modules. <p> It is relatively straightforward to separate the code shown in Figure 1 into two modules, and techniques such as those described in <ref> [2, 14] </ref> will also create the same grouping. In essence, the concept analysis described above emulates these techniques. This shows that concept analysis encompasses previously defined methods for modularization. <p> The set of ancestors of x, denoted by ancs (x), is the set of lattice elements y such that y x and y 6= x. 14 [1] A sups (?) // the atomic partition <ref> [2] </ref> P fAg [4] while W 6= ; do [5] remove some p from W [6] for each c 2 p [7] for each c 0 2 sups (c) [8] p 0 p ancs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p <p> As explained above, the concept-analysis approach can naturally generate a variety of possible decompositions (i.e., different collections of concepts that partition the set of objects). The concept-analysis approach is more general than that of Canfora et al. <ref> [2] </ref>, which identifies abstract data types by analyzing a graph that links functions to their argument types and return types. <p> By adding attributes that indicate whether fields of compound data types are used in a function, as is done in the example used in this paper, concept-analysis becomes a more powerful tool for identifying potential modules than the technique described in <ref> [2] </ref>. The work described in [3] and [4] expands on the abstract-data-type identification technique described in [2]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. <p> of compound data types are used in a function, as is done in the example used in this paper, concept-analysis becomes a more powerful tool for identifying potential modules than the technique described in <ref> [2] </ref>. The work described in [3] and [4] expands on the abstract-data-type identification technique described in [2]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [3] and [4] with the concept-analysis approach of the present paper.
Reference: [3] <author> G. Canfora, A. De Lucia, G. A. Di Lucca, and A. R. Fasolino. </author> <title> Recovering the architectural design for software comprehension. </title> <booktitle> In Third Workshop on Program Comprehension, </booktitle> <pages> pages 30-38, </pages> <year> 1994. </year>
Reference-contexts: By adding attributes that indicate whether fields of compound data types are used in a function, as is done in the example used in this paper, concept-analysis becomes a more powerful tool for identifying potential modules than the technique described in [2]. The work described in <ref> [3] </ref> and [4] expands on the abstract-data-type identification technique described in [2]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [3] and [4] with the concept-analysis approach of the present paper. <p> The work described in <ref> [3] </ref> and [4] expands on the abstract-data-type identification technique described in [2]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [3] and [4] with the concept-analysis approach of the present paper. The concept-analysis approach is also more general than technique used in the OBAD tool [14], which is designed to identify abstract data types in C programs.
Reference: [4] <author> A. Cimitile, M. Tortorella, and M. Munro. </author> <title> Program comprehension through the identification of abstract data types. </title> <booktitle> In Third Workshop on Program Comprehension, </booktitle> <pages> pages 12-19, </pages> <year> 1994. </year>
Reference-contexts: The set of ancestors of x, denoted by ancs (x), is the set of lattice elements y such that y x and y 6= x. 14 [1] A sups (?) // the atomic partition [2] P fAg <ref> [4] </ref> while W 6= ; do [5] remove some p from W [6] for each c 2 p [7] for each c 0 2 sups (c) [8] p 0 p ancs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c <p> By adding attributes that indicate whether fields of compound data types are used in a function, as is done in the example used in this paper, concept-analysis becomes a more powerful tool for identifying potential modules than the technique described in [2]. The work described in [3] and <ref> [4] </ref> expands on the abstract-data-type identification technique described in [2]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [3] and [4] with the concept-analysis approach of the present paper. <p> The work described in [3] and <ref> [4] </ref> expands on the abstract-data-type identification technique described in [2]: Call and dominance information is used to introduce a hierarchical nesting structure to modules. It may be possible to combine the techniques from [3] and [4] with the concept-analysis approach of the present paper. The concept-analysis approach is also more general than technique used in the OBAD tool [14], which is designed to identify abstract data types in C programs.
Reference: [5] <author> David H. Hutchens and Victor R. Basili. </author> <title> System structure analysis: Clustering with data bindings. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-11(8):749-757, </volume> <month> August </month> <year> 1985. </year>
Reference-contexts: The set of ancestors of x, denoted by ancs (x), is the set of lattice elements y such that y x and y 6= x. 14 [1] A sups (?) // the atomic partition [2] P fAg [4] while W 6= ; do <ref> [5] </ref> remove some p from W [6] for each c 2 p [7] for each c 0 2 sups (c) [8] p 0 p ancs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 <p> A similar effect can be achieved via concept analysis by introducing one attribute for each actual parameter. There has been a certain amount of work involving the use of cluster analysis to identify potential modules (e.g., <ref> [5, 1, 7] </ref>). This work (implicitly or explicitly) involves the identification of potential modules by determining a similarity measure among pairs of functions. We are currently investigating the link between concept analysis and cluster analysis.
Reference: [6] <editor> IEEE. </editor> <booktitle> IEEE Third Workshop on Program Comprehension. </booktitle> <publisher> IEEE Computer Science Press, </publisher> <month> November </month> <year> 1994. </year>
Reference-contexts: The set of ancestors of x, denoted by ancs (x), is the set of lattice elements y such that y x and y 6= x. 14 [1] A sups (?) // the atomic partition [2] P fAg [4] while W 6= ; do [5] remove some p from W <ref> [6] </ref> for each c 2 p [7] for each c 0 2 sups (c) [8] p 0 p ancs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g <p> Volumed, Convexity, PrintFaces 7 tEdge, tFace MakeCcw, CleanEdges, Consistency 8 tVertex, tEdge, tFace Print, Tetrahedron, AddOne, MakeStructs, Checks Table 3: The atomic partition of the concept lattice derived for chull.c. 6 Related Work Although there is a growing body of literature concerning module and abstract-data-type recovery from non-modular code (e.g., <ref> [13, 6] </ref>), we are unaware of previous work on the problem involving the use of concept analysis. Because modularization reflects a design decision that is inherently subjective, it is unlikely that the modularization process can ever be fully automated.
Reference: [7] <author> Thomas Kunz. </author> <title> Evaluating process clusters to support automatic program understanding. </title> <booktitle> In Fourth Workshop on Program Comprehension, </booktitle> <pages> pages 198-207, </pages> <year> 1996. </year>
Reference-contexts: x, denoted by ancs (x), is the set of lattice elements y such that y x and y 6= x. 14 [1] A sups (?) // the atomic partition [2] P fAg [4] while W 6= ; do [5] remove some p from W [6] for each c 2 p <ref> [7] </ref> for each c 0 2 sups (c) [8] p 0 p ancs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g [12] P P [ fp 00 <p> A similar effect can be achieved via concept analysis by introducing one attribute for each actual parameter. There has been a certain amount of work involving the use of cluster analysis to identify potential modules (e.g., <ref> [5, 1, 7] </ref>). This work (implicitly or explicitly) involves the identification of potential modules by determining a similarity measure among pairs of functions. We are currently investigating the link between concept analysis and cluster analysis.
Reference: [8] <author> Sying-Syang Liu and Norman Wilde. </author> <title> Identifying objects in a conventional procedural language: An example of data design recovery. </title> <booktitle> In Conference on Software Maintenance, </booktitle> <pages> pages 266-271. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> November </month> <year> 1990. </year>
Reference-contexts: of lattice elements y such that y x and y 6= x. 14 [1] A sups (?) // the atomic partition [2] P fAg [4] while W 6= ; do [5] remove some p from W [6] for each c 2 p [7] for each c 0 2 sups (c) <ref> [8] </ref> p 0 p ancs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g [12] P P [ fp 00 g [14] endif [15] endif [16] endfor [17] <p> The work most closely related to ours is that of Liu and Wilde <ref> [8] </ref>, which makes use of a table that is very much like the object-attribute relation of a context. However, whereas our work uses concept analysis to analyze such tables, Liu and Wilde propose a less powerful analysis.
Reference: [9] <author> Robert O'Callahan and Daniel Jackson. </author> <title> Practical program understanding with type inference. </title> <type> Technical Report CMU-CS-96-130, </type> <institution> Carnegie Mellon University, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: Attributes capturing this information might be of the form "may use a value that flows from statement s" or "is part of the slice with respect to statement s". * Information obtained from type inferencing: Type inference can be used to uncover distinctions between seemingly identical types <ref> [10, 9] </ref>. For example, if f is a function declared to be of type int fi int ! bool, type inference might discover that f 's most general type is of the form ff fi fi ! bool. <p> and y 6= x. 14 [1] A sups (?) // the atomic partition [2] P fAg [4] while W 6= ; do [5] remove some p from W [6] for each c 2 p [7] for each c 0 2 sups (c) [8] p 0 p ancs (c 0 ) <ref> [9] </ref> if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g [12] P P [ fp 00 g [14] endif [15] endif [16] endfor [17] endfor [18] endwhile The algorithm builds up a
Reference: [10] <author> Michael Siff and Thomas Reps. </author> <title> Program generalization for software reuse: From C to C++. </title> <booktitle> In Fourth ACM SIGSOFT Symposium on the Foundations of Software Engineering, </booktitle> <pages> pages 135-146, </pages> <address> San Francisco, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Attributes capturing this information might be of the form "may use a value that flows from statement s" or "is part of the slice with respect to statement s". * Information obtained from type inferencing: Type inference can be used to uncover distinctions between seemingly identical types <ref> [10, 9] </ref>. For example, if f is a function declared to be of type int fi int ! bool, type inference might discover that f 's most general type is of the form ff fi fi ! bool. <p> ; do [5] remove some p from W [6] for each c 2 p [7] for each c 0 2 sups (c) [8] p 0 p ancs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint <ref> [10] </ref> p 00 p 0 [ fc 0 g [12] P P [ fp 00 g [14] endif [15] endif [16] endfor [17] endfor [18] endwhile The algorithm builds up a collection of all the partitions of a concept lattice.
Reference: [11] <author> Gregor Snelting. </author> <title> Reengineering of configurations based on mathematical concept analysis. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <volume> 5(2) </volume> <pages> 146-189, </pages> <month> April </month> <year> 1996. </year>
Reference-contexts: In order to understand the basics of concept analysis, a few definitions are required. We follow the presentation in <ref> [11] </ref>. A context is a triple C = (O; A; R), where O and A are finite sets (the objects and attributes, respectively), and R is a binary relation between O and A. <p> There are several algorithms for computing a concept lattice from a given context <ref> [11] </ref>. We describe a simple bottom-up algorithm here. An important fact about concepts and contexts used in the algorithm is that, given a set of objects X, the smallest concept with extent containing X is (t ((X)); (X)). <p> We are currently investigating the link between concept analysis and cluster analysis. Concept analysis has previously been applied in a software-engineering tool, albeit for a problem much different from modularization: the NORA/RECS tool uses concept analysis to identify conflicts in software-configuration information <ref> [11] </ref>. Acknowledgements This work was supported in part by the National Science Foundation under grant CCR-9625667 and by the Defense Advanced Research Projects Agency under ARPA Order No. 8856 (monitored by the Office of Naval Research under contract N00014-92-J-1937).
Reference: [12] <author> Rudolf Wille. </author> <title> Restructuring lattice theory: An approach based on hierarchies of concepts. </title> <editor> In Ivan Rival, editor, </editor> <booktitle> Ordered Sets, </booktitle> <pages> pages 445-470. </pages> <institution> NATO Advanced Study Institute, </institution> <month> September </month> <year> 1981. </year>
Reference-contexts: c 5 (fchimpanzees; dolphins; humans; whalesg; fintelligentg) c 4 (fcats; chimpanzees; dogsg; fhair-coveredg) c 3 (fchimpanzees; humansg; fintelligent; thumbedg) c 2 (fdolphins, whalesg; fintelligent; marineg) c 1 (fchimpanzeesg; fhair-covered; intelligent; thumbedg) c 0 (fcats; dogsg; fhair-covered; four-leggedg) bot (;; ffour-legged; hair-covered; intelligent; marine; thumbedg) The fundamental theorem for concept lattices <ref> [12] </ref> relates subconcepts and superconcepts as follows: G (X i ; Y i ) = t [ X i ; i2I ! The significance of the theorem is that the least common superconcept of a set of concepts can be computed by intersecting their intents, and by taking the union of <p> for each c 2 p [7] for each c 0 2 sups (c) [8] p 0 p ancs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g <ref> [12] </ref> P P [ fp 00 g [14] endif [15] endif [16] endfor [17] endfor [18] endwhile The algorithm builds up a collection of all the partitions of a concept lattice. Let P be the collection of partitions that we are forming. Let W be a worklist of partitions.
Reference: [13] <author> Lida Wills, Phillip Newcomb, and Elliot Chikofsky, </author> <title> editors. </title> <booktitle> Second Working Conference on Reverse Engineering. </booktitle> <publisher> IEEE Computer Science Press, </publisher> <month> July </month> <year> 1995. </year>
Reference-contexts: Volumed, Convexity, PrintFaces 7 tEdge, tFace MakeCcw, CleanEdges, Consistency 8 tVertex, tEdge, tFace Print, Tetrahedron, AddOne, MakeStructs, Checks Table 3: The atomic partition of the concept lattice derived for chull.c. 6 Related Work Although there is a growing body of literature concerning module and abstract-data-type recovery from non-modular code (e.g., <ref> [13, 6] </ref>), we are unaware of previous work on the problem involving the use of concept analysis. Because modularization reflects a design decision that is inherently subjective, it is unlikely that the modularization process can ever be fully automated.
Reference: [14] <author> Alexander Yeh, David R. Harris, and Howard B. Reubenstein. </author> <title> Recovering abstract data types and object instances from a conventional procedural language. </title> <booktitle> In Second Working Conference on Reverse Engineering, </booktitle> <pages> pages 227-236, </pages> <year> 1995. </year> <month> 19 </month>
Reference-contexts: The resulting information can then be supplied to a suitable transformation tool that maps C code to C++ code, as in the aforementioned example. Although other modularization algorithms are able to identify the same decomposition <ref> [2, 14] </ref>, they are unable to handle a variant of this example in which stack and queue are more tightly intertwined (see Section 3.2). In Section 3.2, we show that concept analysis is able to group the code from the latter example into separate queue and stack modules. <p> It is relatively straightforward to separate the code shown in Figure 1 into two modules, and techniques such as those described in <ref> [2, 14] </ref> will also create the same grouping. In essence, the concept analysis described above emulates these techniques. This shows that concept analysis encompasses previously defined methods for modularization. <p> each c 0 2 sups (c) [8] p 0 p ancs (c 0 ) [9] if ( p 0 ) " c 0 = ; // if p 0 and c 0 are disjoint [10] p 00 p 0 [ fc 0 g [12] P P [ fp 00 g <ref> [14] </ref> endif [15] endif [16] endfor [17] endfor [18] endwhile The algorithm builds up a collection of all the partitions of a concept lattice. Let P be the collection of partitions that we are forming. Let W be a worklist of partitions. <p> It may be possible to combine the techniques from [3] and [4] with the concept-analysis approach of the present paper. The concept-analysis approach is also more general than technique used in the OBAD tool <ref> [14] </ref>, which is designed to identify abstract data types in C programs. OBAD analyzes a graph that consists of nodes representing functions and struct types, and edges representing the use of internal fields of a struct type by a function.
References-found: 14

