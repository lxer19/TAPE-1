URL: http://www.cs.unc.edu/~stuerzl/papers/loadbalancing.ps.gz
Refering-URL: http://www.cs.unc.edu/~stuerzl/publications.html
Root-URL: http://www.cs.unc.edu
Email: [stuerzlinger schauer volkert]@gup.uni-linz.ac.at  
Phone: Tel.: +43 732 2468 9228  
Title: Load Balancing for a Parallel Radiosity Algorithm  
Author: W. Strzlinger, G. Schauer and J. Volkert 
Address: Altenbergerstrae 69, A-4040 Linz, Austria/Europe  
Affiliation: GUP Linz Johannes Kepler University Linz  
Abstract: The radiosity method models the interaction of light between diffuse surfaces, thereby accurately predicting global illumination effects. Due to the high computational effort to calculate the transfer of light between surfaces and the memory requirements for the scene description, a distributed, parallelized version of the algorithm is needed for scenes consisting of thousands of surfaces. We present several load distribution schemes for such a parallel algorithm which includes progressive refinement and adaptive subdivision for fast solutions of high quality. The load is distributed before the calculations in a static way. During the computation the load is redistributed dynamically to make up for individual differences in processor loads. The dynamic load balancing scheme never generates more data packets than the original algorithm and avoids overloading proces sors through actions taken by the scheme.
Abstract-found: 1
Intro-found: 1
Reference: [Baum89] <author> Daniel R. Baum, Holly E. Rushmeier, James M. Winget, </author> <title> Improving Radiosity Solutions through the Use of Analytically Determined Form-Factors, </title> <booktitle> Computer Graphics (SIGGRAPH 89 Proceedings), </booktitle> <month> July </month> <year> 1989. </year>
Reference-contexts: A hemicube is placed around the centre of a patch and all other patches are projected onto its surfaces. The projected area gives an estimate for the formfactor between the patches. As this estimate of the formfactors may be inexact even for simple cases <ref> [Baum89] </ref>, other methods for computing the formfactors were suggested [Wall89], [Sill89], [Mall88], [Tamp91]. During the calculation of the formfactors the visibility calculations account for most of the computation time of the radiosity method (e.g. 70 - 95%) and the memory requirement increases with the number of patches.
Reference: [Baum90] <author> Daniel R. Baum, James M. Winget, </author> <title> Real Time Radiosity Through Parallel Processing and Hardware Acceleration, </title> <booktitle> Computer Graphics (SIGGRAPH 90), </booktitle> <month> July </month> <year> 1990. </year>
Reference-contexts: During the calculation of the formfactors the visibility calculations account for most of the computation time of the radiosity method (e.g. 70 - 95%) and the memory requirement increases with the number of patches. These problems led to the development of parallel implementations of the progressive refinement radiosity method <ref> [Baum90] </ref>, [Reck90], [Feda91], [Chal91]. 2 1.1 Progressive Refinement The radiosity method partitions the surfaces of the scene in small, at patches and computes the illumination for each of those patches. The radiosity of a patch is determined by the radios-ity it emits directly plus all light that is reected. <p> B i E i r i F i j, B j n 1 3 2 Parallelization of the Progressive Refinement Method 2.1 Previous Research Parallelizations of the progressive refinement method have been proposed by Baum <ref> [Baum90] </ref> for a multiprocessor workstation and Recker [Reck90] for a cluster of workstations. Feda [Feda91] and Chalmers [Chal91] presented an implementation on a transputer network with local memory on each transputer.
Reference: [Capi93] <author> T. K. Capin, C. Aykanat, B. zgc, </author> <title> Progressive Refinement Radiosiy on Ring-Connected Multicomputers, </title> <booktitle> Parallel Rendering Symposium, </booktitle> <pages> pp 71-88, </pages> <year> 1993. </year>
Reference: [Casp89] <author> E. Caspary, I. D. Scherson, </author> <title> A self-balanced parallel ray-tracing algorithm, Parallel Processing for Computer Vision and Display, </title> <editor> P. M. Dew, R. A. Earnskaw, T.R. Heywood (Ed.), </editor> <publisher> Addison Wesley, </publisher> <year> 1989. </year>
Reference-contexts: Polygons are classi 5 fied as lying in one or more of the subspaces defined by the BSP-tree. Only those polygons sit uated in subspaces penetrated by the ray must be considered (e.g. [Sung92]). Caspary et al. <ref> [Casp89] </ref> introduced a new method of storing such a BSP-tree in the local mem ory of processors of a parallel computer. The upper part of the tree from the root node down to some predetermined level of subdivision is stored on all processors.
Reference: [Chal91] <author> Alan G. Chalmers, Derek J. Paddon, </author> <title> Parallel Processing of Progressive Refinement Radiosity Methods, </title> <booktitle> in Proceedings of the Second Eurographics Workshop on Rendering, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: These problems led to the development of parallel implementations of the progressive refinement radiosity method [Baum90], [Reck90], [Feda91], <ref> [Chal91] </ref>. 2 1.1 Progressive Refinement The radiosity method partitions the surfaces of the scene in small, at patches and computes the illumination for each of those patches. The radiosity of a patch is determined by the radios-ity it emits directly plus all light that is reected. <p> Feda [Feda91] and Chalmers <ref> [Chal91] </ref> presented an implementation on a transputer network with local memory on each transputer. <p> When there is not enough memory to store all patches on one processor the data transfer overhead becomes prohibitively large if patch geometries are retrieved from other processors [Feda91], <ref> [Chal91] </ref>. Instead of transferring patches to compute visibility, we transfer the sampling points with respective visibility information. Using a fixed subdivision of the shooter into M (e.g. 16 or 64) parts the visibility for each part is determined by casting a ray to the parts centre.
Reference: [Cohe85] <author> Michael Cohen, Donald P. Greenberg, </author> <title> The Hemicube: A Radiosity Solution for Complex Environments, </title> <booktitle> Computer Graphics (SIGGRAPH 85 Proceedings), </booktitle> <month> August </month> <year> 1985. </year>
Reference-contexts: These patches are used to store the radiosity on the respective part of the surface. A formfactor is a value describing the inuence of two patches onto each other. These form-factors were first calculated by the use of a hemicube <ref> [Cohe85] </ref>. A hemicube is placed around the centre of a patch and all other patches are projected onto its surfaces. The projected area gives an estimate for the formfactor between the patches.
Reference: [Cohe86] <author> Michael Cohen, Donald P. Greenberg, Dave S. Immel, Phillip J. Brock, </author> <title> An Efficient Radiosity Approach for Realistic Image Synthesis, </title> <journal> IEEE Computer Graphics and Applications, </journal> <month> March </month> <year> 1986. </year>
Reference-contexts: One solution is to use smaller patches which increases both memory and cpu time consumption. However, for shooting the radiosity bigger patches have been found to give sufficiently accurate results and, therefore, a two-level hierarchy of patches and elements was proposed by Cohen et al. <ref> [Cohe86] </ref>. Each patch is subdivided into elements. The radiosity is computed for all elements which are used during display of the solution.
Reference: [Cohe88] <author> Michael Cohen, Shenchang Eric Chen, John R. Wallace, Donald P. Greenberg, </author> <title> A Progressive Refinement Approach to Fast Radiosity Image Generation, </title> <booktitle> Computer Graphics (SIGGRAPH 88 Proceedings), </booktitle> <month> August </month> <year> 1988. </year>
Reference-contexts: 1 Introduction Radiosity has become a popular method for image synthesis due to its ability to generate images of high realism. It was first introduced to computer graphics by Goral et al. [Gora84]. Further research resulted in the progressive refinement method, which quickly produces good approximations of the final solution <ref> [Cohe88] </ref>. For recent developments see [Cohe93],[Sill94]. Common to all these methods is the representation of the surfaces of the environment by a mesh of quadrilaterals and triangles. These patches are used to store the radiosity on the respective part of the surface. <p> As the memory requirement for the formfactor matrix is proportional to n 2 this method becomes impractical for larger n (n &gt; 10000). Also the computational effort to compute all F i,j becomes prohibitively large. The progressive refinement method <ref> [Cohe88] </ref> uses a reordering of the solution process which just needs to calculate (and store) one column of the matrix per iteration step.
Reference: [Cohe93] <author> Michael F. Cohen, John R. Wallace, </author> <title> Radiosity and Realistic Image Synthesis, </title> <publisher> Academic Press Professional, Harcourt Brace & Company, Publishers, </publisher> <year> 1993. </year>
Reference-contexts: Each patch is subdivided into elements. The radiosity is computed for all elements which are used during display of the solution. The average of the element radiosities is used as the patch radiosity for shooting. 1.3 Adaptive Subdivision Adaptive subdivision <ref> [Cohe93] </ref> extends the two level hierarchy of patches and elements to a hierarchy of several levels: whenever the radiosities at the corners of an element differ by more than a given threshold the element is subdivided into several smaller elements and only the inuence of the current shooter must be recalculated
Reference: [Feda91] <author> Martin Feda, Werner Purgathofer, </author> <title> Progressive Refinement Radiosity on a Trans-puter Network, </title> <booktitle> in Proceedings of the Second Eurographics Workshop on Rendering, </booktitle> <month> May </month> <year> 1991. </year> <month> 13 </month>
Reference-contexts: These problems led to the development of parallel implementations of the progressive refinement radiosity method [Baum90], [Reck90], <ref> [Feda91] </ref>, [Chal91]. 2 1.1 Progressive Refinement The radiosity method partitions the surfaces of the scene in small, at patches and computes the illumination for each of those patches. The radiosity of a patch is determined by the radios-ity it emits directly plus all light that is reected. <p> B i E i r i F i j, B j n 1 3 2 Parallelization of the Progressive Refinement Method 2.1 Previous Research Parallelizations of the progressive refinement method have been proposed by Baum [Baum90] for a multiprocessor workstation and Recker [Reck90] for a cluster of workstations. Feda <ref> [Feda91] </ref> and Chalmers [Chal91] presented an implementation on a transputer network with local memory on each transputer. <p> When there is not enough memory to store all patches on one processor the data transfer overhead becomes prohibitively large if patch geometries are retrieved from other processors <ref> [Feda91] </ref>, [Chal91]. Instead of transferring patches to compute visibility, we transfer the sampling points with respective visibility information. Using a fixed subdivision of the shooter into M (e.g. 16 or 64) parts the visibility for each part is determined by casting a ray to the parts centre.
Reference: [Gora84] <author> Cindy M. Goral, Kenneth E. Torrance, Donald P. Greenberg, Bennett Battaile, </author> <title> Modelling the Interaction of Light Between Diffuse Surfaces, </title> <booktitle> Computer Graphics (SIGGRAPH 84 Proceedings), </booktitle> <month> July </month> <year> 1984. </year>
Reference-contexts: 1 Introduction Radiosity has become a popular method for image synthesis due to its ability to generate images of high realism. It was first introduced to computer graphics by Goral et al. <ref> [Gora84] </ref>. Further research resulted in the progressive refinement method, which quickly produces good approximations of the final solution [Cohe88]. For recent developments see [Cohe93],[Sill94]. Common to all these methods is the representation of the surfaces of the environment by a mesh of quadrilaterals and triangles.
Reference: [Kuma94] <author> Vipin Kumar, Ananth Y. Grama, Nageshwara Rao Vempaty, </author> <title> Scalable Load Balancing Techniques for Parallel Computers, </title> <journal> Journal of Parallel and Distributed Computing 22, </journal> <month> 60-79 </month> <year> (1994). </year>
Reference-contexts: Processor A initializes the visibility computations of packet P, sends it around the ring and returns it to Processor B afterwards. Processor A repeats the random polling until all processors have finished the current iteration. The method of random polling was chosen as the work of Kumar et al. <ref> [Kuma94] </ref> shows that this method is in general superior to all other methods considered by them in a comprehensive survey, especially when used with massively parallel computer systems.
Reference: [Lamo93] <author> W. Lamotte, F.Reeth, L. Vandeurzen, E. Flerackers, </author> <title> Parallel Processing in Radi-osity Calculations, </title> <booktitle> Computer Graphics International, </booktitle> <pages> pp 485-495, </pages> <year> 1993. </year>
Reference-contexts: A better method is to calculate formfactors and visibilities directly for each receiver. Even most recent implementations such as those by Capin et al.[Capi93], Ng et al. [Ng93] and Lamotte et al. <ref> [Lamo93] </ref> are not easily extended to parallel computers of several hundred processors. Capin uses one ring of processors where round trip times become prohibitively large. Ng and Lamotte use master-slave approaches where the master soon becomes the bottle neck.
Reference: [Mall88] <author> Thomas J.V. Malley, </author> <title> A Shading Method for Computer Generated Images, </title> <type> Masters Thesis, </type> <institution> University of Utah, </institution> <month> June </month> <year> 1988. </year>
Reference-contexts: The projected area gives an estimate for the formfactor between the patches. As this estimate of the formfactors may be inexact even for simple cases [Baum89], other methods for computing the formfactors were suggested [Wall89], [Sill89], <ref> [Mall88] </ref>, [Tamp91]. During the calculation of the formfactors the visibility calculations account for most of the computation time of the radiosity method (e.g. 70 - 95%) and the memory requirement increases with the number of patches.
Reference: [Ng93] <author> Adelene Ng, Mel Slater, </author> <title> A Multiprocessor Implementation of Radiosity, </title> <journal> Computer Graphics forum, </journal> <volume> Volume 12, 5, </volume> <pages> pp 329-342, </pages> <year> 1993. </year>
Reference-contexts: A better method is to calculate formfactors and visibilities directly for each receiver. Even most recent implementations such as those by Capin et al.[Capi93], Ng et al. <ref> [Ng93] </ref> and Lamotte et al. [Lamo93] are not easily extended to parallel computers of several hundred processors. Capin uses one ring of processors where round trip times become prohibitively large. Ng and Lamotte use master-slave approaches where the master soon becomes the bottle neck.
Reference: [Reck90] <author> Rodney J. Recker, David W. George, Donald P. Greenberg, </author> <title> Acceleration technique for Progressive Refinement Radiosity, </title> <booktitle> Computer Graphics (SIGGRAPH 90), </booktitle> <month> July </month> <year> 1990. </year>
Reference-contexts: These problems led to the development of parallel implementations of the progressive refinement radiosity method [Baum90], <ref> [Reck90] </ref>, [Feda91], [Chal91]. 2 1.1 Progressive Refinement The radiosity method partitions the surfaces of the scene in small, at patches and computes the illumination for each of those patches. The radiosity of a patch is determined by the radios-ity it emits directly plus all light that is reected. <p> B i E i r i F i j, B j n 1 3 2 Parallelization of the Progressive Refinement Method 2.1 Previous Research Parallelizations of the progressive refinement method have been proposed by Baum [Baum90] for a multiprocessor workstation and Recker <ref> [Reck90] </ref> for a cluster of workstations. Feda [Feda91] and Chalmers [Chal91] presented an implementation on a transputer network with local memory on each transputer.
Reference: [Scha95] <author> G. Schauer, W. Strzlinger, C. Wild, </author> <title> Load Balancing Schemes for a Parallel Radiosity Algorithm, </title> <type> Technical Report, </type> <institution> Institute for Computer Science, University of Linz, Austria, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: The tests have shown dynamic load balancing to be particularly useful with adaptive refinement as it increases the number of certain samples in a way not predictable before the begin of the calculations <ref> [Scha95] </ref>. All times were measured using sample packets of 50 samples each. In the following tables and figures N denotes the number of processors and R denotes the length of the rings.
Reference: [Sill89] <author> Francois Sillion, Claude Puech, </author> <title> A General Two-Pass Method Integrating Specular and Diffuse Reection, </title> <booktitle> Computer Graphics (SIGGRAPH 89 Proceedings), </booktitle> <month> July </month> <year> 1989. </year>
Reference-contexts: The projected area gives an estimate for the formfactor between the patches. As this estimate of the formfactors may be inexact even for simple cases [Baum89], other methods for computing the formfactors were suggested [Wall89], <ref> [Sill89] </ref>, [Mall88], [Tamp91]. During the calculation of the formfactors the visibility calculations account for most of the computation time of the radiosity method (e.g. 70 - 95%) and the memory requirement increases with the number of patches.
Reference: [Sill91] <author> Francois X. Sillion, James R. Arvo, Stephen H. Westin, Donald P. Greenberg, </author> <title> A Global Illumination Solution for General Reectance Distributions, </title> <booktitle> Computer Graphics (SIGGRAPH 91 Proceedings), </booktitle> <month> July </month> <year> 1991. </year>
Reference: [Sill94] <author> Francois X. Sillion, Claude Puech, </author> <title> Radiosity & Global Illumination, </title> <publisher> Morgan Kaufmann, </publisher> <year> 1994. </year>
Reference: [Str93] <author> W. Strzlinger, </author> <title> FXFIRE - Global Illumination with Radiosity, </title> <type> Technical Report, </type> <institution> Institute for Computer Science, University of Linz, Austria, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: The performance of a single processor is approximately 3 MFLOPS. As a basis we used the progressive radiosity program described by Strzlinger et al. <ref> [Str93] </ref>. The algorithm has been improved to use a global BSP-Tree (described in section 4) and it includes static load balancing of radiosity samples (see section 6.1) and of visibility complexity (see section 6.2).
Reference: [Str94a] <author> W. Strzlinger, C. Wild, G. Schauer, </author> <title> Description and Implementation of a Parallel Radiosity Algorithm, </title> <institution> Technical Report , Institute for Computer Science, University of Linz, Austria, </institution> <month> July </month> <year> 1994. </year>
Reference: [Str94b] <author> W. Strzlinger, C. Wild, </author> <title> Parallel Progressive Radiosity with Parallel Visibility Computations, </title> <booktitle> Winter School of Computer Graphics and CAD Systems 94, Plzen, CZ, </booktitle> <pages> pp 66--74, </pages> <month> Feb. </month> <year> 1994. </year>
Reference-contexts: As different patches are subdivided into different numbers of elements it is insufficient to only assign the same amount of patches to one processor. Patches with large numbers of elements must be split into smaller ones to allow an even distribution of elements among processors <ref> [Str94b] </ref>.
Reference: [Str94c] <author> W. Strzlinger, C. Wild, </author> <title> Parallel Visibility Calculations for Radiosity, </title> <booktitle> ACPC Paragraph Workshop, Hagenberg, Austria, </booktitle> <pages> pp 32-40, </pages> <month> March </month> <year> 1994. </year>
Reference-contexts: The binary AND operation of the visibility vectors of all processors determines the visibility of the shooter with respect to the whole scene. Strzlinger et al. <ref> [Str94c] </ref> proposed to arrange the processors in a ring which is used as a pipeline for packets of sampling point. Each processor generates a packet, sends it around the ring, computes the local visibility of the samples in the packet and ANDs it to the visibility vectors in the packet. <p> On the ring-topology of processors introduced by Strzlinger <ref> [Str94c] </ref> it can be calculated in advance to which processors in the ring the packet must be sent and which can be left out. <p> 57 11 6432168421 speed-up CPUs ld N 4 256128 no load balancing static dynamic both 2 6432168421 speed-up CPUs ld N 4 256128 no load balancing static dynamic both 2 12 8 Conclusions This paper reports on several major improvements over the parallel radiosity algorithm described by Strzlinger et al. <ref> [Str94c] </ref>. First a global BSP-Tree has been introduced as a data structure to speed up ray-patch intersections and to optimize the routing of sample packets around the processor rings in conjunction with processor vectors.
Reference: [Sung92] <author> Kelvin Sung, Peter Shirley, </author> <title> Ray Tracing with the BSP Tree, Graphics Gems III, </title> <publisher> Academic Press, </publisher> <year> 1992. </year>
Reference-contexts: Polygons are classi 5 fied as lying in one or more of the subspaces defined by the BSP-tree. Only those polygons sit uated in subspaces penetrated by the ray must be considered (e.g. <ref> [Sung92] </ref>). Caspary et al. [Casp89] introduced a new method of storing such a BSP-tree in the local mem ory of processors of a parallel computer. The upper part of the tree from the root node down to some predetermined level of subdivision is stored on all processors.
Reference: [Tamp91] <author> F. Tampieri, D. Lischinski, </author> <title> The Constant Radiosity Assumption Syndrome, </title> <booktitle> in Proceedings of the Second Eurographics Workshop on Rendering, </booktitle> <month> May </month> <year> 1991. </year>
Reference-contexts: The projected area gives an estimate for the formfactor between the patches. As this estimate of the formfactors may be inexact even for simple cases [Baum89], other methods for computing the formfactors were suggested [Wall89], [Sill89], [Mall88], <ref> [Tamp91] </ref>. During the calculation of the formfactors the visibility calculations account for most of the computation time of the radiosity method (e.g. 70 - 95%) and the memory requirement increases with the number of patches.
Reference: [Wall89] <author> John R. Wallace, Kells A. Elmquist, Eric A. Haines, </author> <title> A Ray Tracing Algorithm for Progressive Radiosity, </title> <booktitle> Computer Graphics (SIGGRAPH 89 Proceedings), </booktitle> <month> July </month> <year> 1989. </year>
Reference-contexts: The projected area gives an estimate for the formfactor between the patches. As this estimate of the formfactors may be inexact even for simple cases [Baum89], other methods for computing the formfactors were suggested <ref> [Wall89] </ref>, [Sill89], [Mall88], [Tamp91]. During the calculation of the formfactors the visibility calculations account for most of the computation time of the radiosity method (e.g. 70 - 95%) and the memory requirement increases with the number of patches. <p> In the following sections we assume that we have a number of processors with local memory and an interconnecting network. 2.2 Parallel Progressive Refinement This paper presents an approach based on the calculation of formfactors by raycasting as described by Wallace <ref> [Wall89] </ref>. Raycasting is used to determine the visible parts of the shooter as seen from each receiving patch. The formfactor of these visible parts is then calculated using the analytical solution to the contour integral.
References-found: 27

