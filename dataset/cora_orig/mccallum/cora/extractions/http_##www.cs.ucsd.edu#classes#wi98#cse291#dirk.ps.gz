URL: http://www.cs.ucsd.edu/classes/wi98/cse291/dirk.ps.gz
Refering-URL: http://www.cs.ucsd.edu/classes/wi98/cse291/
Root-URL: http://www.cs.ucsd.edu
Email: grunwald@cs.colorado.edu  
Title: Selective Eager Execution on the PolyPath Architecture  
Author: Artur Klauser, Abhijit Paithankar, Dirk Grunwald 
Note: submitted to ISCA-25 1998 do not distribute  
Address: Boulder, Colorado, 80309-0430  
Affiliation: Department of Computer Science University of Colorado  
Abstract: Control-flow misprediction penalties are a major impediment to high performance in wide-issue superscalar processors. In this paper we present Selective Eager Execution (SEE), an execution model to overcome mis-speculation penalties by executing both paths after diffident branches. We present the micro-architecture of the PolyPath processor, which is an extension of an aggressive superscalar, out-of-order architecture. The PolyPath architecture uses a novel instruction tagging and register renaming mechanism to execute instructions from multiple paths simultaneously in the same processor pipeline, while retaining maximum resource availability for single-path code sequences. Performance results of our detailed execution-driven, pipeline-level simulations show that the SEE concept achieves a potential average performance improvement of 48% on the SPECint95 benchmarks. A realistic implementation with a dynamic branch confidence estimator can improve performance by as much as 36% for the go benchmark, and an average of 14% on SPECint95, when compared to a normal superscalar, out-of-order, speculative execution, monopath processor. Moreover, our architectural model is both elegant and practical to implement, using a small amount of additional state and control logic. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Undisclosed authors for blind review. </author> <title> Confidence Estimation for Speculation Control. </title> <booktitle> Submitted to 25th Annual Intl. Symp. on Computer Architecture, </booktitle> <month> June </month> <year> 1998. </year>
Reference-contexts: In this paper we propose Selective Eager Execution (SEE) and the PolyPath architecture model, which help to overcome branch misprediction latency. SEE recognizes the fact that some branches are predicted more accurately than others, where it draws from research in branch confidence estimation <ref> [1, 6] </ref>. SEE behaves like a normal monopath speculative execution architecture for highly predictable branches. In this case it predicts the most likely successor path of a branch, and evaluates instructions only along this path. <p> Our work uses similar concepts for tagging instructions from multiple paths, but we dynamically estimate prediction accuracy of dynamic branch predictions to make the path traversal decisions. Additionally we draw from work in the area of branch confidence estimation <ref> [1, 6, 20] </ref> to determine if branch prediction or selective eager execution is more effective for each particular occurrence of a branch. 3 The PolyPath Architecture In the following sections, we first outline the operation of a normal (monopath) speculative architecture, which is commonly found in today's high performance processors. <p> We believe that we can enhance the performance of SEE by better matching the confidence estimator to our application. For this matter, we are looking at applying techniques as discussed in <ref> [1] </ref> to SEE. An in-depth discussion of alternative confidence estimators, however, is outside the scope of this paper. This concludes the overview of our PolyPath architecture.
Reference: [2] <author> J. Bondi, A. Nanda, and S. Dutta. </author> <title> Integrating a Mispredic-tion Recovery Cache into a Superscalar Pipeline. </title> <booktitle> In 29th Intl. Conf. on Microarchitecture, </booktitle> <month> December </month> <year> 1996. </year>
Reference-contexts: In the third cycle, the branch has completed execution and only the instructions from the correct path continue to flow through the rest of the pipeline. This eliminates the branch misprediction penalty in this simple pipeline altogether. The work on the misprediction recovery cache (MRC) <ref> [2] </ref> inserts a small predecoded instruction cache before the execution stage into the middle of a super-scalar, in-order pipeline. This cache holds short instruction sequences following previous mispre-dictions. After a misprediction, the MRC is searched for a valid entry.
Reference: [3] <author> Tien-Fu Chen. </author> <title> Supporting Highly Speculative Execution via Adaptive Branch Trees. </title> <booktitle> In Fourth Intl. Symp. on High-Performance Computer Architecture, </booktitle> <month> February </month> <year> 1998. </year>
Reference-contexts: Also, non-looping, control intensive programs cannot make optimal use of the eager execution hardware. The authors estimate a cost of approximately 100 million transistors for a reasonable implementation of the architecture. Adaptive Branch Tree (ABT) <ref> [3] </ref> has been proposed to steer execution in a multi-path processor. ABT uses static branch (taken) probabilities to decide which path to execute next. <p> This comparator structure comprises the core functionality of the control-flow state machine logic as described later in Sec. 3.2.3, the store buffer forwarding logic (Sec. 3.2.4), and the CTX table manager (Sec. 3.2.6). The work on Adaptive Branch Trees (ABT) <ref> [3] </ref> uses a similar scheme to encode the tree-structured relationship of branch paths. ABT uses a 1-bit encoding scheme, which is more restrictive since it only allows in order branch resolution in the tree.
Reference: [4] <author> John Edmondson et al. </author> <title> Internal Organization of the Alpha 21164. A 300 MHz 64-bit Quad-issue CMOS RISC Microprocessor. </title> <journal> Digital Technical Journal, </journal> <volume> 7(1):119135, </volume> <year> 1995. </year>
Reference-contexts: We are confident that the possibly more complex implementation of the control-flow state-machines, as compared to the data-flow state machines, will not be in the critical timing path, since its inputs arrive earlier in the clock cycle. Current implementations of high performance processors <ref> [4] </ref> have shown that the result of condition evaluations (branch resolution) is available much earlier in the clock cycle than results from other ALU operations.
Reference: [5] <author> Timothy Heil and James Smith. </author> <title> Selective Dual Path Execution, </title> <month> November </month> <year> 1996. </year> <institution> University of Wisconsin-Madison, </institution> <address> http://www.ece.wisc.edu/ jes/papers/isca.sdpe.ps. </address>
Reference-contexts: lesson we learned from this experience is that a successful branch confidence estimator for SEE should be able to monitor its performance dynamically and revert back to strict monopath execution (always indicating high-confidence) if it makes too many errors. 5.2 Dual Path Execution In work reported by Heil and Smith <ref> [5] </ref> and Lick and Tyson [10, 20] the concept of dual-path execution addresses many of the same problems that we address with SEE. Both concepts are only evaluated with trace based simulations.
Reference: [6] <author> Erik Jacobsen, Eric Rotenberg, and J. E. Smith. </author> <title> Assigning Confidence to Conditional Branch Predictions. </title> <booktitle> In Proceedings of the 29th Annual Intl. Symp. on Microarchitecture, </booktitle> <pages> pages 142152, </pages> <address> Paris, France, </address> <month> December </month> <year> 1996. </year>
Reference-contexts: In this paper we propose Selective Eager Execution (SEE) and the PolyPath architecture model, which help to overcome branch misprediction latency. SEE recognizes the fact that some branches are predicted more accurately than others, where it draws from research in branch confidence estimation <ref> [1, 6] </ref>. SEE behaves like a normal monopath speculative execution architecture for highly predictable branches. In this case it predicts the most likely successor path of a branch, and evaluates instructions only along this path. <p> Our work uses similar concepts for tagging instructions from multiple paths, but we dynamically estimate prediction accuracy of dynamic branch predictions to make the path traversal decisions. Additionally we draw from work in the area of branch confidence estimation <ref> [1, 6, 20] </ref> to determine if branch prediction or selective eager execution is more effective for each particular occurrence of a branch. 3 The PolyPath Architecture In the following sections, we first outline the operation of a normal (monopath) speculative architecture, which is commonly found in today's high performance processors. <p> Another possible aspect of the confidence estimator is the guidance of fetch bandwidth arbitration. However, we do not explore this dimension in this paper. To show the effectiveness of the PolyPath model, we use a dynamic branch confidence estimator as described by Jacobsen et al <ref> [6] </ref>. We believe that we can enhance the performance of SEE by better matching the confidence estimator to our application. For this matter, we are looking at applying techniques as discussed in [1] to SEE. An in-depth discussion of alternative confidence estimators, however, is outside the scope of this paper. <p> The correct history state is restored at misprediction recovery time. Speculative history update improved the overall branch prediction accu racy by approximately 1% in our simulations. * We use a modified version of the Jacobsen-Rotenberg-Smith (JRS) 1-level branch confidence estimator with resetting counters as described in <ref> [6] </ref>. The indexing method into the predictor is the same as for gshare. However, each counter in the confidence estimator reflects the number of correct predictions since the last branch misprediction for this index. <p> This resulted in a substantial performance improvement over the original indexing method, which uses the same global history as used to index into the branch predictor table <ref> [6] </ref>. <p> This improvement is a function of both the accuracy of the branch predictor as well as the accuracy of the branch confidence estimator. Note that we use a branch confidence estimator that has been published elsewhere in the literature <ref> [6] </ref>, and have not particularly tuned this estimator for our application. We believe that higher speedups are attainable with realistic confidence estimator implementations. We are currently looking at better matching the confidence estimator to the specific application of SEE.
Reference: [7] <author> Q. Jacobson, S. Bennett, N. Sharama, and J. Smith. </author> <title> Control Flow Speculation in Multiscalar Processors. </title> <booktitle> In 3rd Intl. Symp. on High Perf. Computer Architecture, </booktitle> <pages> pages 218229, </pages> <month> February </month> <year> 1997. </year>
Reference-contexts: There are numerous studies on branch prediction, for example Yeh and Patt [23], Mc-Farling [12], Sprangle [18], and Lee et al [9] to name just a few. Multi-block ahead prediction [16] and hierarchical prediction in Multiscalar <ref> [7, 14] </ref> has been proposed to predict across multiple basic blocks in one cycle. The second category of work, which is closer related to SEE, strives to reduce the cost of each misprediction. Branch delay slots have been used in some architectures, e.g.
Reference: [8] <author> Michael J. Knieser and Christos A. Papachristou. Y-Pipe: </author> <title> A Conditional Branching Scheme Without Pipeline Delays. </title> <booktitle> In 25th Intl. Conf. on Microarchitecture, </booktitle> <pages> pages 125128, </pages> <year> 1992. </year>
Reference-contexts: MIPS [22], to reduce the cost of misprediction recovery by pushing the branch instruction further into the pipeline before the control flow is changed. Branch delay slots do not provide much advantage in super-scalar, deep pipeline architectures, however, and contribute to complex processor implementations. In the Y-pipe architecture <ref> [8] </ref>, the first two stages of a 5-stage pipeline are duplicated. After a branch is fetched, the first two pipeline stages, fetch and decode, are filled with instructions from both sides after the branch.
Reference: [9] <author> Chih-Chieh Lee, I-Cheng Chen, and Trevor Mundge. </author> <title> The Bi-Mode Branch Predictor. </title> <booktitle> In Proceedings of the 30th Annual Intl. Symp. on Microarchitecture, </booktitle> <institution> Research Triangle Park, North Carolina, </institution> <month> December </month> <year> 1997. </year>
Reference-contexts: Work in the first category tackles the control flow problem by reducing the number of mispredictions. There are numerous studies on branch prediction, for example Yeh and Patt [23], Mc-Farling [12], Sprangle [18], and Lee et al <ref> [9] </ref> to name just a few. Multi-block ahead prediction [16] and hierarchical prediction in Multiscalar [7, 14] has been proposed to predict across multiple basic blocks in one cycle. The second category of work, which is closer related to SEE, strives to reduce the cost of each misprediction.
Reference: [10] <author> Kelsey Lick. </author> <title> Limited Dual Path Execution. </title> <type> Master's thesis, </type> <institution> University of California, Riverside, </institution> <year> 1996. </year>
Reference-contexts: experience is that a successful branch confidence estimator for SEE should be able to monitor its performance dynamically and revert back to strict monopath execution (always indicating high-confidence) if it makes too many errors. 5.2 Dual Path Execution In work reported by Heil and Smith [5] and Lick and Tyson <ref> [10, 20] </ref> the concept of dual-path execution addresses many of the same problems that we address with SEE. Both concepts are only evaluated with trace based simulations.
Reference: [11] <author> Mikko Lipasti. </author> <title> Value Locality and Speculative Execution. </title> <type> PhD thesis, </type> <institution> Carnegie Mellon University, </institution> <month> April </month> <year> 1997. </year>
Reference-contexts: SEE trades off the reduction in branch misprediction latency with an increase in processing bandwidth requirement. We believe that it will be easier in future architectures to provide higher execution bandwidth, rather than being able to hide increased latency. Current research in other areas, like dependence and value prediction <ref> [11] </ref>, makes the same underlying assumption and tries to hide data-dependence latencies through increased execution bandwidth. The rest of this paper is organized as follows. Section 2 describes related work and Sec. 3 introduces the details of the SEE concept.
Reference: [12] <author> Scott McFarling. </author> <title> Combining Branch Predictors. </title> <address> TN 36, DEC-WRL, </address> <month> June </month> <year> 1993. </year>
Reference-contexts: Work in the first category tackles the control flow problem by reducing the number of mispredictions. There are numerous studies on branch prediction, for example Yeh and Patt [23], Mc-Farling <ref> [12] </ref>, Sprangle [18], and Lee et al [9] to name just a few. Multi-block ahead prediction [16] and hierarchical prediction in Multiscalar [7, 14] has been proposed to predict across multiple basic blocks in one cycle. <p> Loads dependent on previous stores can only execute after the store. The architecture forwards store results to dependent loads in the instruc tion window in one cycle. * We use a gshare branch predictor as described by McFarling <ref> [12] </ref>, which uses a global history xor branch address to index into a table of saturating 2-bit counters. We use a 14-bit global history and 2 14 (16 k) counters for the baseline architecture.
Reference: [13] <author> Abhijit Paithankar. AINT: </author> <title> A Tool for Simulation of Shared-Memory Multiprocessors. </title> <type> Master's thesis, </type> <institution> University of Col-orado at Boulder, </institution> <year> 1996. </year>
Reference-contexts: We use scaled down input data sets for some benchmarks to reduce simulation time. All benchmarks are simulated to completion. Table 1 lists the characteristics of these benchmarks on our architecture. 4.2 Architecture Model We used an extended version of the AINT architecture simulation tool <ref> [13] </ref> to build a micro-architecture level simulator for the Poly-Path architecture as depicted in Fig. 2 and described in Sec. 3.2. Out AINT simulator is execution-driven and handles native DigitalUnix executables with the Alpha instruction set.
Reference: [14] <author> Eric Rotenberg, Quinn Jacobson, Yiannakis Sazeides, and Jim Smith. </author> <title> Trace Processors. </title> <booktitle> In 30th Intl. Conf. on Microar-chitecture, </booktitle> <month> December </month> <year> 1997. </year>
Reference-contexts: There are numerous studies on branch prediction, for example Yeh and Patt [23], Mc-Farling [12], Sprangle [18], and Lee et al [9] to name just a few. Multi-block ahead prediction [16] and hierarchical prediction in Multiscalar <ref> [7, 14] </ref> has been proposed to predict across multiple basic blocks in one cycle. The second category of work, which is closer related to SEE, strives to reduce the cost of each misprediction. Branch delay slots have been used in some architectures, e.g.
Reference: [15] <author> Digital Semiconductor. </author> <title> Alpha AXP-21164 Processor Hardware Reference Manual, </title> <month> September </month> <year> 1997. </year> <month> 10 </month>
Reference-contexts: Our simulated baseline machine model is an 8-way superscalar, out-of-order execution, in-order commit architecture, with a 256 entry central instruction window/reorder buffer and an 8-stage pipeline. Instruction latencies and functional unit compositions are taken from the DEC Alpha AXP-21164 processor <ref> [15] </ref>, and reflect a 500 MHz execution core. All simple integer instructions have a latency of one cycle. More complex instructions, like integer multiply and all floating point operations, have higher latencies as specified in the AXP-21164 hardware reference manual.
Reference: [16] <author> Andre Seznec, Stephan Jourdan, Pascal Sainrat, and Pierre Michaud. </author> <title> Multiple-Block Ahead Branch Predictors. </title> <booktitle> In Proceedings of the 7th Intl. Conf. on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 116 127, </pages> <address> Cambridge, Massachusetts, </address> <month> October </month> <year> 1996. </year>
Reference-contexts: Work in the first category tackles the control flow problem by reducing the number of mispredictions. There are numerous studies on branch prediction, for example Yeh and Patt [23], Mc-Farling [12], Sprangle [18], and Lee et al [9] to name just a few. Multi-block ahead prediction <ref> [16] </ref> and hierarchical prediction in Multiscalar [7, 14] has been proposed to predict across multiple basic blocks in one cycle. The second category of work, which is closer related to SEE, strives to reduce the cost of each misprediction. Branch delay slots have been used in some architectures, e.g.
Reference: [17] <author> J. E. Smith and A. R. Pleszkun. </author> <title> Implementing Precise Interrupts in Pipelined Processors. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 37(5):562573, </volume> <month> May </month> <year> 1988. </year>
Reference-contexts: Up to this point, there was the potential that restoring a checkpointed RegMap that maps a logical register to the old physical register could revive this physical register. This architecture uses precise exceptions <ref> [17] </ref>. Exceptions, which occur during the execution of an instruction in the out-of-order core, are stored together with the result of the instruction. They are not signaled until an instruction is ready to retire.
Reference: [18] <author> E. Sprangle, R.S. Chappell, M. Alsup, and Y.N. Patt. </author> <title> The Agree Predictor: A Mechanism for Reducing Negative Branch History Interference. </title> <booktitle> In 24th Annual Intl. Symp. on Computer Architecture, </booktitle> <pages> pages 284291, </pages> <month> May </month> <year> 1997. </year>
Reference-contexts: Work in the first category tackles the control flow problem by reducing the number of mispredictions. There are numerous studies on branch prediction, for example Yeh and Patt [23], Mc-Farling [12], Sprangle <ref> [18] </ref>, and Lee et al [9] to name just a few. Multi-block ahead prediction [16] and hierarchical prediction in Multiscalar [7, 14] has been proposed to predict across multiple basic blocks in one cycle.
Reference: [19] <author> M. Tremblay, B. Joy, and K. Shin. </author> <title> A Three Dimensional Register File for Superscalar Processors. </title> <booktitle> In 28th Hawaii Intl. Conf. on System Sciences, </booktitle> <pages> pages 191201, </pages> <month> January </month> <year> 1995. </year>
Reference-contexts: We are confident though, that it is possible to build such a RegMap with the same timing performance as the original RegMap for a monopath architecture. One promising direction for implementing the RegMap is the use of a 3D register file <ref> [19] </ref>. However, in Sec. 5.3.4 we also provide results for the case where an additional cycle for this operation might become necessary. 5 3.2.6 Context Management The front-end also performs CTX management operations. This involves CTX tag management, as described in Sec. 3.2.2, as well as CTX fetch path management.
Reference: [20] <author> Gary Tyson, Kelsey Lick, and Matthew Farrens. </author> <title> Limited Dual Path Execution. </title> <type> CSE-TR 346-97, </type> <institution> University of Michigan, </institution> <year> 1997. </year>
Reference-contexts: Our work uses similar concepts for tagging instructions from multiple paths, but we dynamically estimate prediction accuracy of dynamic branch predictions to make the path traversal decisions. Additionally we draw from work in the area of branch confidence estimation <ref> [1, 6, 20] </ref> to determine if branch prediction or selective eager execution is more effective for each particular occurrence of a branch. 3 The PolyPath Architecture In the following sections, we first outline the operation of a normal (monopath) speculative architecture, which is commonly found in today's high performance processors. <p> experience is that a successful branch confidence estimator for SEE should be able to monitor its performance dynamically and revert back to strict monopath execution (always indicating high-confidence) if it makes too many errors. 5.2 Dual Path Execution In work reported by Heil and Smith [5] and Lick and Tyson <ref> [10, 20] </ref> the concept of dual-path execution addresses many of the same problems that we address with SEE. Both concepts are only evaluated with trace based simulations.
Reference: [21] <author> A. K. Uht, V. Sindagi, and K. Hall. </author> <title> Disjoint Eager Execution: An Optimal Form of Speculative Execution. </title> <booktitle> In 28th Intl. Conf. on Microarchitecture, </booktitle> <pages> pages 313325, </pages> <month> December </month> <year> 1995. </year>
Reference-contexts: If one is found, it is used to feed instructions into the execution stages while instruction fetch is restarted at the correct successor address. The paper evaluates MRC in the context of an in-order CISC pipeline without register renaming. Disjoint eager execution <ref> [21] </ref> uses a form of eager execution to speed up the execution of loops. The architecture uses a fixed-size static instruction window. Iterations are mapped to execution paths depending on a predetermined average global branch prediction accuracy, which determines the exact structure of the hardware.
Reference: [22] <author> Keneth C. Yeager. </author> <title> The MIPS R10000 Superscalar Microprocessor. </title> <journal> IEEE Micro, </journal> <volume> 16(2):2841, </volume> <month> February </month> <year> 1996. </year>
Reference-contexts: The second category of work, which is closer related to SEE, strives to reduce the cost of each misprediction. Branch delay slots have been used in some architectures, e.g. MIPS <ref> [22] </ref>, to reduce the cost of misprediction recovery by pushing the branch instruction further into the pipeline before the control flow is changed. Branch delay slots do not provide much advantage in super-scalar, deep pipeline architectures, however, and contribute to complex processor implementations. <p> The in-order back-end retires the oldest completed instructions from the instruction window. In this model the central instruction window also acts as a reorder buffer. Some implementations split this functionality into a separate reorder buffer and out-of-order reservation stations to increase circuit speed <ref> [22] </ref>. The instruction fetch stage uses a branch predictor to predict the fetch address after branches, before the correct address is computed by the back-end. When the branch is resolved in the execution stage, the prediction is compared against the correct outcome.
Reference: [23] <author> Tse-Yu Yeh and Yale N. Patt. </author> <title> A Comparison of Dynamic Branch Predictors that use Two Levels of Branch History. </title> <booktitle> In 20th Intl. Symp. on Computer Architecture, </booktitle> <pages> pages 257266, </pages> <month> May </month> <year> 1993. </year> <month> 11 </month>
Reference-contexts: Work in the first category tackles the control flow problem by reducing the number of mispredictions. There are numerous studies on branch prediction, for example Yeh and Patt <ref> [23] </ref>, Mc-Farling [12], Sprangle [18], and Lee et al [9] to name just a few. Multi-block ahead prediction [16] and hierarchical prediction in Multiscalar [7, 14] has been proposed to predict across multiple basic blocks in one cycle.
References-found: 23

