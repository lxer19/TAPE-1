URL: ftp://ftp.cs.washington.edu/tr/1993/03/UW-CSE-93-03-05.PS.Z
Refering-URL: http://www.cs.washington.edu/research/tr/tr-by-title.html
Root-URL: 
Phone: (206) 685-2094; fax: (206) 543-2969  
Title: The Cecil Language Specification and Rationale  
Author: Craig Chambers 
Note: chambers@cs.washington.edu  
Address: Seattle, Washington 98195 USA  
Affiliation: Department of Computer Science and Engineering, FR-35 University of Washington  
Abstract: Technical Report 93-03-05 March 1993 
Abstract-found: 1
Intro-found: 1
Reference: [Agrawal et al. 91] <author> Rakesh Agrawal, Linda G. DeMichiel, and Bruce G. Lindsay. </author> <title> Static Type Checking of Multi-Methods. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 113-128, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(11), </note> <month> November, </month> <year> 1991. </year>
Reference-contexts: However, final checking still is needed once the whole program is assembled to ensure that no two multi-methods are mutually ambiguous. 3.7.4 Comparison with Type Systems for Multiply-Dispatched Languages Few multiply-dispatched languages support static type systems. Two that are most relevant are Polyglot <ref> [Agrawal et al. 91] </ref> and Kea [Mugridge et al. 91]. <p> Dylan supports a form of type declarations, but these are not checked statically, cannot be parameterized, and are treated both as argument specializers and type declarations, unlike Cecil where argument specializers and argument type declarations are distinct. Polyglot is a CLOS-like language with a static type system <ref> [Agrawal et al. 91] </ref>. However, the type system for Polyglot does not distinguish subtyping from code inheritance (classes are the same as types in Polyglot), does not support parameterized or parametrically polymorphic classes or methods, and does not address abstract methods.
Reference: [America & van der Linden 90] <author> Pierre America and Frank van der Linden. </author> <title> A Parallel Object-Oriented Language with Inheritance and Subtyping. </title> <booktitle> In OOPSLA/ECOOP 90 Conference Proceedings, </booktitle> <pages> pp. 161-168, </pages> <address> Ottawa, Canada, </address> <month> October, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(10), </note> <month> October, </month> <year> 1990. </year>
Reference-contexts: Trellis restricts the inheritance hierarchy to conform to the subtype hierarchy; it only supports isa-style superclasses. POOL is a statically-typed object-oriented language that distinguishes inheritance of implementation from inheritance of interface <ref> [America & van der Linden 90] </ref>. POOL generates types automatically from all class declarations (Cecil allows the programmer to restrict which objects may be used as types) and also allows the programmer to define explicit types separate from class declarations (a feature Cecil does not provide).
Reference: [Apple 92] <author> Dylan, </author> <title> an Object-Oriented Dynamic Language. </title> <institution> Apple Computer, </institution> <month> April, </month> <year> 1992. </year>
Reference-contexts: CLOS enables get and/or set accessor methods to be defined automatically as part of the defclass form, but CLOS also provides a lower-level slot-value primitive that can read and write any slot directly. Dylan <ref> [Apple 92] </ref>, a descendant of CLOS, joins SELF and Trellis in accessing instance variables solely through accessor methods. An object may define or inherit several fields with the same name. <p> Cecil offers a simpler, purer object model, optional static type checking, and encapsulation. CLOS and its predecessors include extensive support for method combination rules and reective operations [Kiczales et al. 91] not present in Cecil. Dylan <ref> [Apple 92] </ref> is a new language which can be viewed as a slimmed-down CLOS, based in a Scheme-like language instead of Common Lisp. Dylan is similar to CLOS in most of the respects described above, except that Dylan always accesses state through messages.
Reference: [Black et al. 86] <author> Andrew Black, Norman Hutchinson, Eric Jul, and Henry Levy. </author> <title> Object Structure in the Emerald System. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 78-86, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: This ameliorates some of the drawbacks of implicit subtyping. The only other classless object-oriented language with a static type system of which we are aware is Emerald <ref> [Black et al. 86, Hutchinson 87, Hutchinson et al. 87] </ref>. Emerald is not based on multiple dispatching and in fact does not include support for inheritance of implementation.
Reference: [Black & Hutchinson 90] <author> Andrew P. Black and Norman C. Hutchinson. </author> <title> Typechecking Polymorphism in Emerald. </title> <type> Technical report TR 90-34, </type> <institution> Department of Computer Science, University of Arizona, </institution> <month> December, </month> <year> 1990. </year>
Reference-contexts: F-bounded polymorphism [Canning et al. 89, Cook et al. 90] is a different kind of subtyping relation that can describe that two objects come from the same type. One way of describing F-bounded polymorphism, adapted from Black and Hutchinsons version of F-bounded polymorphism in Emerald <ref> [Black & Hutchinson 90] </ref> is that a type definition is treated as a type generator, a function from a type to a type.
Reference: [Bobrow et al. 86] <author> Daniel G. Bobrow, Kenneth Kahn, Gregor Kiczales, Larry Masinter, Mark Stefik, and Frank Zdybel. CommonLoops: </author> <title> Merging Lisp and Object-Oriented Programming. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 17-29, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: However, linearization can produce unexpected method lookup results, especially if the program contains errors [Snyder 86]. CommonLoops <ref> [Bobrow et al. 86] </ref> and CLOS extend this linearization approach to multi-methods, totally ordering multi-methods by prioritizing argument position, with earlier argument positions completely dominating later argument positions. <p> Cecils model of object creation is different than SELFs. However, Cecil has yet to incorporate dynamic inheritance, one of the most interesting features of SELF. Freeman-Benson independently developed a proposal for adding multi-methods to SELF [Freeman-Benson 89]. Common Loops <ref> [Bobrow et al. 86] </ref> and CLOS [Bobrow et al. 88, Gabriel et al. 91] incorporate multi-methods in dynamically-typed class-based object-oriented extensions to Lisp. Method specializations (at least in CLOS) can be either on the class of the argument object or on its value.
Reference: [Bobrow et al. 88] <author> D. G. Bobrow, L. G. DeMichiel, R. P. Gabriel, S. E. Keene, G. Kiczales, D. A. Moon. </author> <title> Common Lisp Object System Specification X3J13. </title> <journal> In SIGPLAN Notices 23(Special Issue), </journal> <month> September, </month> <year> 1988. </year>
Reference-contexts: Cecil is unusual in combining a pure, classless (prototype-based) object model, multiple dispatching (multi-methods), and mixed static and dynamic type checking. Cecil was inspired primarily by SELF [Ungar & Smith 87, Hlzle et al. 91a], CLOS <ref> [Bobrow et al. 88, Gabriel et al. 91] </ref>, and Trellis [Schaffert et al. 85, Schaffert et al. 86]. 1.1 Design Goals and Major Features Cecils design results from several goals: Maximize the programmers ability to develop software quickly and to reuse and modify existing software easily. <p> Cecils model of object creation is different than SELFs. However, Cecil has yet to incorporate dynamic inheritance, one of the most interesting features of SELF. Freeman-Benson independently developed a proposal for adding multi-methods to SELF [Freeman-Benson 89]. Common Loops [Bobrow et al. 86] and CLOS <ref> [Bobrow et al. 88, Gabriel et al. 91] </ref> incorporate multi-methods in dynamically-typed class-based object-oriented extensions to Lisp. Method specializations (at least in CLOS) can be either on the class of the argument object or on its value.
Reference: [Borning 86] <author> A. H. Borning. </author> <title> Classes Versus Prototypes in Object-Oriented Languages. </title> <booktitle> In Proceedings of the 1986 Fall Joint Computer Conference, </booktitle> <pages> pp. 36-40, </pages> <address> Dallas, TX, </address> <month> November, </month> <year> 1986. </year>
Reference: [Canning et al. 89] <author> Peter S. Canning, William R. Cook, Walter L. Hill, John C. Mitchell, and William Olthoff. </author> <title> F-Bounded Quantification for Object-Oriented Programming. </title> <booktitle> In Proceedings of the Conference on Functional Programming Languages and Computer Architecture, </booktitle> <year> 1989. </year>
Reference-contexts: What we need to do for this case is to be able to describe that two objects come from related types, e.g., that both arguments to min are subtypes of number or that both are subtypes of the collection type instantiated with related types. F-bounded polymorphism <ref> [Canning et al. 89, Cook et al. 90] </ref> is a different kind of subtyping relation that can describe that two objects come from the same type.
Reference: [Cardelli & Wegner 85] <author> Luca Cardelli and Peter Wegner. </author> <title> On Understanding Types, Data Abstraction, and Polymorphism. </title> <booktitle> In Computing Surveys 17(4), </booktitle> <pages> pp. 471-522, </pages> <month> December, </month> <year> 1985. </year>
Reference-contexts: The upper bound of a formal type parameter is type, if the &lt;= type suffix is provided, or any, otherwise. Similar facilities appear under the name of bounded quantification <ref> [Cardelli & Wegner 85] </ref> and constrained genericity [Meyer 86]. Type parameters are scoped over the whole object, method, or field declaration; type parameters must have distinct names.
Reference: [Castagna et al. 92] <author> Giuseppe Castagna, Giorgio Ghelli, and Giuseppe Longo. </author> <title> A Calculus for Overloaded Functions with Subtyping. </title> <booktitle> In Proceedings of the 1992 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pp. 182-192, </pages> <address> San Francisco, </address> <month> June, </month> <year> 1992. </year> <note> Published as Lisp Pointers 5(1), January-March, </note> <year> 1992. </year>
Reference-contexts: Other theoretical treatments of multi-methods have been pursued by Rouaix [Rouaix 90], Ghelli <ref> [Ghelli 91, Castagna et al. 92] </ref>, and Pierce and Turner [Pierce & Turner 92, Pierce & Turner 93]. The RPDE 3 environment supports subdivided methods where the value of a parameter to the method or of a global variable helps select among alternative method implementations [Harrison & Ossher 90].
Reference: [Chambers et al. 89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89 Conference Proceedings, </booktitle> <pages> pp. 49-70, </pages> <address> New Orleans, LA, </address> <month> October, </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference: [Chambers et al. 91] <author> Craig Chambers, David Ungar, Bay-Wei Chang, and Urs Hlzle. </author> <title> Parents are Shared Parts: Inheritance and Encapsulation in SELF. In Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Furthermore, inheriting the instance variable part of the implementation of one data type into another is more difficult in SELF than in class-based languages, relying on complex inheritance rules and dynamic inheritance <ref> [Chambers et al. 91] </ref>. Copy-down fields in Cecil solve these problems in SELF without sacrificing the simple classless object model. <p> Cecils encapsulation rules are simpler in some ways than the corresponding rules for SELF <ref> [Chambers et al. 91] </ref>. Unlike Cecil, SELF grants privileged access to an object as long as the sending method is in an ancestor of the receiving object, with this relationship determined dynamically each time the message is sent. <p> Our experience with SELF also encourages us to strive for the simplest possible inheritance rules that are adequate. Even apparently straightforward extensions can have subtle interactions that make the extensions difficult to understand and use <ref> [Chambers et al. 91] </ref>.
Reference: [Chambers & Ungar 91] <author> Craig Chambers and David Ungar. </author> <title> Making Pure Object-Oriented Languages Practical. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(10), </note> <month> October, </month> <year> 1991. </year>
Reference-contexts: Cecils type system strives for specification only of those properties of objects that affect program correctness, i.e., the interfaces to objects, and not of how those properties are implemented. To achieve run-time efficiency, Cecil will rely on advanced implementation techniques such as those used for the dynamically-typed language SELF <ref> [Chambers & Ungar 91, Hlzle et al. 91b, Chambers 92a] </ref>. Finally, Cecils type system is descriptive rather than prescriptive. The semantics of a Cecil program are determined completely by the dynamically-typed core of the program.
Reference: [Chambers 92a] <author> Craig Chambers. </author> <title> The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> Ph.D. thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <month> March, </month> <year> 1992. </year> <month> 71 </month>
Reference-contexts: Other languages such as Scheme [Rees & Clinger 86] avoid the need for such a primitive by relying instead on user-level tail recursion and implementation-provided tail-recursion elimination. However, tail-recursion elimination precludes complete source-level debugging <ref> [Chambers 92a, Hlzle et al. 92] </ref> and consequently is undesirable in general. <p> Cecils type system strives for specification only of those properties of objects that affect program correctness, i.e., the interfaces to objects, and not of how those properties are implemented. To achieve run-time efficiency, Cecil will rely on advanced implementation techniques such as those used for the dynamically-typed language SELF <ref> [Chambers & Ungar 91, Hlzle et al. 91b, Chambers 92a] </ref>. Finally, Cecils type system is descriptive rather than prescriptive. The semantics of a Cecil program are determined completely by the dynamically-typed core of the program.
Reference: [Chambers 92b] <author> Craig Chambers. </author> <title> Object-Oriented Multi-Methods in Cecil. </title> <booktitle> In ECOOP 92 Conference Proceedings, </booktitle> <address> Utrecht, The Netherlands, </address> <month> July, </month> <year> 1992. </year>
Reference-contexts: 1 Introduction This document describes the initial design of Cecil, an object-oriented language intended to support the rapid construction of high-quality, reusable, extensible software systems <ref> [Chambers 92b] </ref>. Cecil is unusual in combining a pure, classless (prototype-based) object model, multiple dispatching (multi-methods), and mixed static and dynamic type checking. <p> Multiple dispatching automates much of the machinery normally implemented by hand using double-dispatching [Ingalls 86]. However, multiple dispatching can alter the normal programming style from a data-abstraction-oriented style to a function-oriented style <ref> [Chambers 92b] </ref>. With Cecil, we rely on language and programming environment support and tutorial documentation of the intended programming methodology to foster a data-abstraction-oriented view of multi-methods. Methods and objects are connected through the methods argument specializers.
Reference: [Chambers 93] <author> Craig Chambers. </author> <title> Predicate Classes. </title> <booktitle> To appear in ECOOP 93 Conference Proceedings, </booktitle> <address> Kaiserslautern, Germany, </address> <month> July, </month> <year> 1993. </year>
Reference-contexts: not admit the possibility of ambiguity, it need only support undirected resends (i.e., call-next-method); there is no need for directed resends. * This example was adapted from Ungar and Smiths original SELF paper [Ungar & Smith 87]. 33 2.7 Predicate Objects Cecil has been extended experimentally to support predicate objects <ref> [Chambers 93] </ref>. Predicate objects are like normal objects except that they have an associated predicate expression.
Reference: [Chang & Ungar 90] <author> Bay-Wei Chang and David Ungar. </author> <title> Experiencing SELF Objects: An Object-Based Artificial Reality. </title> <type> Unpublished manuscript, </type> <year> 1990. </year>
Reference-contexts: This interface might look something like the following: Programmers would design, code, and debug Cecil programs entirely within such an environment; programmers would never need to look at a at textual form of a Cecil program. The prototype SELF user interface <ref> [Chang & Ungar 90] </ref> could provide a good starting point for the design of the Cecil user interface, since it is graphical, interactive, and good at displaying non-hierarchical relationships among objects and at reecting the identity of shared objects.
Reference: [Cook 89] <author> W. R. Cook. </author> <title> A Proposal for Making Eiffel Type-Safe. </title> <booktitle> In ECOOP 89 Conference Proceedings, </booktitle> <pages> pp. 57-70, </pages> <publisher> Cambridge University Press, </publisher> <month> July, </month> <year> 1989. </year>
Reference-contexts: Other times, a class reusing another classs code cannot or should not be considered a subtype; covariant redefinition as commonly occurs in Eiffel programs is one example of this case <ref> [Cook 89] </ref>. To increase exibility and expressiveness, Cecil separates subtyping from code inheritance. However, since in most cases the subtyping graphs and the inheritance graphs are parallel, requiring programmers to define and maintain two separate hierarchies would become too onerous to be practical.
Reference: [Cook et al. 90] <author> William Cook, Walter Hill, and Peter Canning. </author> <title> Inheritance is not Subtyping. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January, </month> <year> 1990. </year>
Reference-contexts: In Cecil, the subtype graph is distinguished from the code inheritance graph, since type checking has different goals and requirements than have code reuse and module extension <ref> [Snyder 86, Halbert & OBrien 86, Cook et al. 90] </ref>. Another important kind of static declaration distinguishes the external interface of an object from its internal implementation. Cecil includes a mechanism for encapsulating internal details of objects and enforcing this boundary. <p> What we need to do for this case is to be able to describe that two objects come from related types, e.g., that both arguments to min are subtypes of number or that both are subtypes of the collection type instantiated with related types. F-bounded polymorphism <ref> [Canning et al. 89, Cook et al. 90] </ref> is a different kind of subtyping relation that can describe that two objects come from the same type.
Reference: [Cook 92] <author> William R. Cook. </author> <title> Interfaces and Specifications for the Smalltalk-80 Collection Classes. </title> <booktitle> In In OOPSLA 92 Conference Proceedings, </booktitle> <pages> pp. 1-15, </pages> <address> Vancouver, Canada, </address> <month> October, </month> <year> 1992. </year> <note> Published as SIGPLAN Notices 27(10), </note> <month> October, </month> <year> 1992. </year>
Reference-contexts: However, there is merit in clearly separating the two concepts, and allowing inheritance of code from objects which are not legal supertypes. Studies have found this to be fairly common in dynamically-typed languages <ref> [Cook 92] </ref>. With the current Cecil design, the only way that an object might not be a legal subtype of an object from which it inherits is if the child overrides a method of the parent and restricts at least one argument type declaration, a relatively rare occurrence.
Reference: [Ellis & Stroustrup 90] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1990. </year>
Reference-contexts: Similarly, particular applications may need to add application-specific behavior to objects defined as part of other applications. For example, an application may need specialized tab-to-space conversion to be provided by strings and other collections of characters. Other object-oriented languages such as C++ <ref> [Stroustrup 86, Ellis & Stroustrup 90] </ref> and Eiffel do not allow programmers to add behavior to existing classes without modifying the source code of the existing classes, and completely disallow adding behavior to built-in classes like strings. <p> However, a method can be subdivided only for particular values of a parameter or global variable, not its class; this is much like supporting only CLOSs eql specializers. A number of languages, including C++ <ref> [Stroustrup 86, Ellis & Stroustrup 90] </ref> and Haskell [Hudak et al. 90], support static overloading on function arguments, but all overloading is resolved at compile-time based on the static types of the arguments rather than on their dynamic types as would be required for true multiple dispatching.
Reference: [Freeman-Benson 89] <author> Bjorn N. Freeman-Benson. </author> <title> A Proposal for Multi-Methods in SELF. </title> <type> Unpublished manuscript, </type> <month> December, </month> <year> 1989. </year>
Reference-contexts: Cecils model of object creation is different than SELFs. However, Cecil has yet to incorporate dynamic inheritance, one of the most interesting features of SELF. Freeman-Benson independently developed a proposal for adding multi-methods to SELF <ref> [Freeman-Benson 89] </ref>. Common Loops [Bobrow et al. 86] and CLOS [Bobrow et al. 88, Gabriel et al. 91] incorporate multi-methods in dynamically-typed class-based object-oriented extensions to Lisp. Method specializations (at least in CLOS) can be either on the class of the argument object or on its value.
Reference: [Gabriel et al. 91] <author> Richard P. Gabriel, Jon L White, and Daniel G. Bobrow. </author> <title> CLOS: </title> <booktitle> Integrating Object-Oriented and Functional Programming. In Communications of the ACM 34(9), </booktitle> <pages> pp. 28-38, </pages> <month> September, </month> <year> 1991. </year>
Reference-contexts: Cecil is unusual in combining a pure, classless (prototype-based) object model, multiple dispatching (multi-methods), and mixed static and dynamic type checking. Cecil was inspired primarily by SELF [Ungar & Smith 87, Hlzle et al. 91a], CLOS <ref> [Bobrow et al. 88, Gabriel et al. 91] </ref>, and Trellis [Schaffert et al. 85, Schaffert et al. 86]. 1.1 Design Goals and Major Features Cecils design results from several goals: Maximize the programmers ability to develop software quickly and to reuse and modify existing software easily. <p> Cecils model of object creation is different than SELFs. However, Cecil has yet to incorporate dynamic inheritance, one of the most interesting features of SELF. Freeman-Benson independently developed a proposal for adding multi-methods to SELF [Freeman-Benson 89]. Common Loops [Bobrow et al. 86] and CLOS <ref> [Bobrow et al. 88, Gabriel et al. 91] </ref> incorporate multi-methods in dynamically-typed class-based object-oriented extensions to Lisp. Method specializations (at least in CLOS) can be either on the class of the argument object or on its value.
Reference: [Ghelli 91] <author> Giorgio Ghelli. </author> <title> A Static Type System for Message Passing. </title> <booktitle> In OOPSLA 91 Conference Proceedings, </booktitle> <pages> pp. 129-145, </pages> <address> Phoenix, AZ, </address> <month> October, </month> <year> 1991. </year> <note> Published as SIGPLAN Notices 26(11), </note> <month> November, </month> <year> 1991. </year>
Reference-contexts: Other theoretical treatments of multi-methods have been pursued by Rouaix [Rouaix 90], Ghelli <ref> [Ghelli 91, Castagna et al. 92] </ref>, and Pierce and Turner [Pierce & Turner 92, Pierce & Turner 93]. The RPDE 3 environment supports subdivided methods where the value of a parameter to the method or of a global variable helps select among alternative method implementations [Harrison & Ossher 90].
Reference: [Goldberg & Robson 83] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: A non-local return returns to the caller of the closest lexically-enclosing non-closure method rather than to the caller of the eval method, just like a non-local return in Smalltalk-80 * <ref> [Goldberg & Robson 83] </ref> or SELF and similar to a return statement in C. The language currently prohibits invoking a non-local return after the lexically-enclosing scope of a closure has returned; first-class continuations are not supported. In Cecil, a method specifies explicitly whether or not it returns a result.
Reference: [Goldberg 84] <author> Adele Goldberg. </author> <title> Smalltalk-80: The Interactive Programming Environment. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1984. </year>
Reference-contexts: ... x@small_int + y@small_int prim_add (x, y, -...-) as_big_int (x@small_int) ... zero + ? ? + zero zero inherits specialized on is_zero (int) factorial (int) for (int, int, ?) zero + zero . . . . . . 14 representation of the program is as objects in the Smalltalk-80 heap <ref> [Goldberg 84] </ref>. Sharing a program with another programmer requires saving part of this heap to a text file and then loading this text file into the other programmers system.
Reference: [Halbert & OBrien 86] <author> Daniel C. Halbert and Patrick D. OBrien. </author> <title> Using Types and Inheritance in Object-Oriented Languages. </title> <type> Technical report DEC-TR-437, </type> <institution> Digital Equipment Corp., </institution> <month> April, </month> <year> 1986. </year>
Reference-contexts: In Cecil, the subtype graph is distinguished from the code inheritance graph, since type checking has different goals and requirements than have code reuse and module extension <ref> [Snyder 86, Halbert & OBrien 86, Cook et al. 90] </ref>. Another important kind of static declaration distinguishes the external interface of an object from its internal implementation. Cecil includes a mechanism for encapsulating internal details of objects and enforcing this boundary.
Reference: [Harbison 92] <author> Samuel P. Harbison. </author> <title> Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1992. </year>
Reference-contexts: BETA uses the same syntax to access both global variables and inherited instance variables, making the semantics of the construct somewhat more complicated. Nested methods can be used to achieve the effect of a typecase statement as found in other languages, including Trellis and Modula-3 <ref> [Nelson 91, Harbison 92] </ref>. <p> Cedar supports a similar mechanism through its REF ANY type [Teitelman 84]. Modula-3 retains the REFANY type and includes several operations including NARROW and TYPECASE that can produce a more precisely-typed value from a REFANY type <ref> [Nelson 91, Harbison 92] </ref>. Cecil provides better support for exploratory programming than these other languages since there is no source code overhead for using dynamic typing: variable type declarations are simply omitted, and coercions between dynamically-typed expressions and statically-typed variables are implicit.
Reference: [Harrison & Ossher 90] <author> William Harrison and Harold Ossher. </author> <title> Subdivided Procedures: A Language Extension Supporting Extensible Programming. </title> <booktitle> In Proceedings of the 1990 International Conference on Computer Languages, </booktitle> <pages> pp. 190-197, </pages> <address> New Orleans, LA, </address> <month> March, </month> <year> 1990. </year>
Reference-contexts: The RPDE 3 environment supports subdivided methods where the value of a parameter to the method or of a global variable helps select among alternative method implementations <ref> [Harrison & Ossher 90] </ref>. However, a method can be subdivided only for particular values of a parameter or global variable, not its class; this is much like supporting only CLOSs eql specializers.
Reference: [Hlzle et al. 91a] <author> Urs Hlzle, Bay-Wei Chang, Craig Chambers, Ole Agesen, and David Ungar. </author> <title> The SELF Manual, </title> <note> Version 1.1. Unpublished manual, </note> <month> February, </month> <year> 1991. </year>
Reference-contexts: Cecil is unusual in combining a pure, classless (prototype-based) object model, multiple dispatching (multi-methods), and mixed static and dynamic type checking. Cecil was inspired primarily by SELF <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref>, CLOS [Bobrow et al. 88, Gabriel et al. 91], and Trellis [Schaffert et al. 85, Schaffert et al. 86]. 1.1 Design Goals and Major Features Cecils design results from several goals: Maximize the programmers ability to develop software quickly and to reuse and <p> Consequently, min may be invoked on a pair of numbers or on a pair of collections of numbers, but without requiring a number to be comparable to a collection of numbers. 66 4 Related Work Cecil builds upon much of the work done with the SELF programming language <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref>. SELF offers a simple, pure, classless object model with state accessed via message passing just like methods. Cecil extends SELF with multi-methods, copy-down and initialize-only data slots, lexically-scoped local methods and fields, object extensions, and static typing.
Reference: [Hlzle et al. 91b] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Optimizing Dynamically-Typed Object-Oriented Programming Languages with Polymorphic Inline Caches. </title> <booktitle> In ECOOP 91 Conference Proceedings, </booktitle> <pages> pp. 21-38, </pages> <address> Geneva, Switzerland, </address> <month> July, </month> <year> 1991. </year>
Reference-contexts: Cecils type system strives for specification only of those properties of objects that affect program correctness, i.e., the interfaces to objects, and not of how those properties are implemented. To achieve run-time efficiency, Cecil will rely on advanced implementation techniques such as those used for the dynamically-typed language SELF <ref> [Chambers & Ungar 91, Hlzle et al. 91b, Chambers 92a] </ref>. Finally, Cecils type system is descriptive rather than prescriptive. The semantics of a Cecil program are determined completely by the dynamically-typed core of the program.
Reference: [Hlzle et al. 92] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Debugging Optimized Code with Dynamic Deoptimization. </title> <booktitle> To appear in Proceedings of the SIGPLAN 92 Conference on Programming Language Design and Implementation, </booktitle> <address> San Francisco, CA, </address> <month> June, </month> <year> 1992. </year>
Reference-contexts: Other languages such as Scheme [Rees & Clinger 86] avoid the need for such a primitive by relying instead on user-level tail recursion and implementation-provided tail-recursion elimination. However, tail-recursion elimination precludes complete source-level debugging <ref> [Chambers 92a, Hlzle et al. 92] </ref> and consequently is undesirable in general.
Reference: [Hudak et al. 90] <author> Paul Hudak, Philip Wadler, Arvind, Brian Boutel, Jon Fairbairn, Joseph Fasel, Kevin Hammond, John Hughes, Thomas Johnsson, Dick Kieburtz, Rishiyur Nikhil, Simon Peyton Jones, Mike Reeve, David Wise, Jonathan Young. </author> <title> Report on the Programming Language Haskell, </title> <note> Version 1.0. Unpublished manual, </note> <month> April, </month> <year> 1990. </year> <month> 72 </month>
Reference-contexts: However, a method can be subdivided only for particular values of a parameter or global variable, not its class; this is much like supporting only CLOSs eql specializers. A number of languages, including C++ [Stroustrup 86, Ellis & Stroustrup 90] and Haskell <ref> [Hudak et al. 90] </ref>, support static overloading on function arguments, but all overloading is resolved at compile-time based on the static types of the arguments rather than on their dynamic types as would be required for true multiple dispatching.
Reference: [Hutchinson 87] <author> Norman C. Hutchinson. </author> <title> Emerald: An Object-Based Language for Distributed Programming. </title> <type> Ph.D. thesis, </type> <institution> University of Washington, </institution> <month> January, </month> <year> 1987. </year>
Reference-contexts: This ameliorates some of the drawbacks of implicit subtyping. The only other classless object-oriented language with a static type system of which we are aware is Emerald <ref> [Black et al. 86, Hutchinson 87, Hutchinson et al. 87] </ref>. Emerald is not based on multiple dispatching and in fact does not include support for inheritance of implementation.
Reference: [Hutchinson et al. 87] <author> Norman C. Hutchinson, Rajendra K. Raj, Andrew P. Black, Henry M. Levy, and Eric Jul. </author> <title> The Emerald Programming Language Report. </title> <type> Technical Report 87-10-07, </type> <institution> Department of Computer Science, University of Washington, </institution> <month> October, </month> <year> 1987. </year>
Reference-contexts: This ameliorates some of the drawbacks of implicit subtyping. The only other classless object-oriented language with a static type system of which we are aware is Emerald <ref> [Black et al. 86, Hutchinson 87, Hutchinson et al. 87] </ref>. Emerald is not based on multiple dispatching and in fact does not include support for inheritance of implementation.
Reference: [Ingalls 86] <author> Daniel H. H. Ingalls. </author> <title> A Simple Technique for Handling Multiple Polymorphism. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 347-349, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Multiple dispatching automates much of the machinery normally implemented by hand using double-dispatching <ref> [Ingalls 86] </ref>. However, multiple dispatching can alter the normal programming style from a data-abstraction-oriented style to a function-oriented style [Chambers 92b]. With Cecil, we rely on language and programming environment support and tutorial documentation of the intended programming methodology to foster a data-abstraction-oriented view of multi-methods.
Reference: [Jenks & Sutor 92] <author> Richard D. Jenks and Robert S. Sutor. </author> <title> Axiom: the Scientific Computing System. </title> <publisher> Springer-Verlag. </publisher> <year> 1992. </year>
Reference-contexts: These default implementations are easy to provide in Cecil by always generating a corresponding object with the type and using the object as the repository for the default implementations. In other languages, such as Axiom (formerly Scratchpad II) <ref> [Watt et al., Jenks & Sutor 92] </ref>, default implementations are stored with the type (called the category in Axiom). 40 Subtyping and conformance in Cecil is explicit, in that the programmer must explicitly declare that an object conforms to a type and that a type is a subtype of another type. <p> Unlike a normal subtype, the extended type is not necessarily substitutable wherever its base type might appear. Alternative versions of this idea arise in the categories of Axiom (formerly Scratchpad II) <ref> [Watt et al., Jenks & Sutor 92] </ref> and the metaclasses of k-bench [Santas 93]. To illustrate these ideas, we will rewrite the above min example with some language extensions under consideration.
Reference: [Kiczales et al. 91] <author> Gregor Kiczales, James des Rivires, and Daniel G. Bobrow. </author> <title> The Art of the Meta-Object Protocol. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1991. </year>
Reference-contexts: Cecil offers a simpler, purer object model, optional static type checking, and encapsulation. CLOS and its predecessors include extensive support for method combination rules and reective operations <ref> [Kiczales et al. 91] </ref> not present in Cecil. Dylan [Apple 92] is a new language which can be viewed as a slimmed-down CLOS, based in a Scheme-like language instead of Common Lisp.
Reference: [Kristensen et al. 87] <author> B. B. Kristensen, Ole Lehrmann Madsen, Birger Mller-Pedersen, and Kristen Nygaard. </author> <title> The BETA Programming Language. </title> <booktitle> In Research Directions in Object-Oriented Programming, </booktitle> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1987. </year>
Reference-contexts: Once this augmented inheritance graph is constructed, method lookup proceeds as before without reference to the scope in which some object or method is defined. Other languages, such as BETA <ref> [Kristensen et al. 87] </ref>, take the opposite approach, searching for a matching method in one scope before proceeding to the enclosing scope. If a matching method is found in one scope, it is selected even if a more specialized method is defined in an enclosing scope.
Reference: [LaLonde et al. 86] <author> Wilf R. LaLonde, Dave A. Thomas, and John R. Pugh. </author> <title> An Exemplar Based Smalltalk. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 322-330, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference: [Leavens 89] <author> Gary Todd Leavens. </author> <title> Verifying Object-Oriented Programs that use Subtypes. </title> <type> Ph.D. thesis, </type> <institution> MIT, </institution> <year> 1989. </year>
Reference-contexts: It appears that Kea has a notion of abstract methods as well. Leavens describes a statically-typed applicative language NOAL that supports multi-methods using run-time overloading on the declared argument types of methods <ref> [Leavens 89, Leavens & Weihl 90] </ref>.
Reference: [Leavens & Weihl 90] <author> Gary T. Leavens and William E. Weihl. </author> <title> Reasoning about Object-Oriented Programs that use Subtypes. </title> <booktitle> In OOPSLA/ECOOP 90 Conference Proceedings, </booktitle> <pages> pp. 212-223, </pages> <address> Ottawa, Canada, </address> <month> October, </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(10), </note> <month> October, </month> <year> 1990. </year>
Reference-contexts: It appears that Kea has a notion of abstract methods as well. Leavens describes a statically-typed applicative language NOAL that supports multi-methods using run-time overloading on the declared argument types of methods <ref> [Leavens 89, Leavens & Weihl 90] </ref>.
Reference: [Lieberman 86] <author> Henry Lieberman. </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 214-223, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Each of an objects parents must be an object declared and named using an object declaration (not an object constructor expression). These restrictions unfortunately preclude some interesting language features traditionally associated with prototype-based languages, such as dynamic inheritance as in SELF and delegation to run-time objects as in Actra <ref> [Lieberman 86] </ref>, but it simplifies other parts of the language such as the type system and guarantees a certain amount of program structure to readers of a program.
Reference: [Lieberman et al. 87] <author> Henry Lieberman, Lynn Andrea Stein, and David Ungar. </author> <booktitle> The Treaty of Orlando. In Addendum to the OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 43-44, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 23(5), </note> <month> May, </month> <year> 1988. </year>
Reference: [Liskov et al. 77] <author> Barbara Liskov, Alan Snyder, Russell Atkinson, and J. Craig Schaffert. </author> <title> Abstraction Mechanisms in CLU. </title> <booktitle> In Communications of the ACM 20(8), </booktitle> <pages> pp. 564-576, </pages> <month> August, </month> <year> 1977. </year>
Reference-contexts: Although Rapide does not support multi-methods and relies on implicit subtyping, many other design goals for Rapide are similar to those for Cecil. Several languages support some form of mixed static and dynamic type checking. For example, CLU <ref> [Liskov et al. 77, Liskov et al. 81] </ref> allows variables to be declared to be of type any.
Reference: [Liskov et al. 81] <author> Barbara Liskov, Russell Atkinson, Toby Bloom, Eliot Moss, J. Craig Schaffert, Robert Scheier, and Alan Snyder. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1981. </year>
Reference-contexts: Although Rapide does not support multi-methods and relies on implicit subtyping, many other design goals for Rapide are similar to those for Cecil. Several languages support some form of mixed static and dynamic type checking. For example, CLU <ref> [Liskov et al. 77, Liskov et al. 81] </ref> allows variables to be declared to be of type any.
Reference: [Meyer 86] <author> Bertrand Meyer. </author> <title> Genericity versus Inheritance. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 391-405, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: The upper bound of a formal type parameter is type, if the &lt;= type suffix is provided, or any, otherwise. Similar facilities appear under the name of bounded quantification [Cardelli & Wegner 85] and constrained genericity <ref> [Meyer 86] </ref>. Type parameters are scoped over the whole object, method, or field declaration; type parameters must have distinct names.
Reference: [Meyer 88] <author> Bertrand Meyer. </author> <title> Object-Oriented Software Construction. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1988. </year>
Reference-contexts: Inheriting from the same ancestor more than once, either directly or indirectly, has no effect other than to place the ancestor in relation to other ancestors; Cecil has no repeated inheritance as in Eiffel <ref> [Meyer 88, Meyer 92] </ref>. An object need not have any parents. The inheritance graph must be acyclic. Like most object-oriented languages, in Cecil the inheritance graph is static.
Reference: [Meyer 92] <author> Bertrand Meyer. </author> <title> Eiffel: The Language. </title> <publisher> Prentice Hall, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: Inheriting from the same ancestor more than once, either directly or indirectly, has no effect other than to place the ancestor in relation to other ancestors; Cecil has no repeated inheritance as in Eiffel <ref> [Meyer 88, Meyer 92] </ref>. An object need not have any parents. The inheritance graph must be acyclic. Like most object-oriented languages, in Cecil the inheritance graph is static. <p> These errors occur when two multi-methods are legal separately but become mutually ambiguous when combined. This problem can only appear in the presence of multi-methods, however, and so is qualitatively different than the kind of link-time type errors that can arise with system-level type-checking in Eiffel <ref> [Meyer 92] </ref>. Extending Cecil with a module facility might solve both of these problems. With modules, programs could be broken up into components which could be completely type-checked and partially compiled in isolation.
Reference: [Milner et al. 90] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <address> Cambridge, MA, </address> <year> 1990. </year>
Reference-contexts: Like explicit type parameters, implicit type parameters may be used in the type declarations of earlier formal arguments, as in the prepend method above, as long as no cyclic dependencies result. Implicit type parameters are akin to polymorphic type variables in languages like ML <ref> [Milner et al. 90] </ref>. Implicit type parameters are useful not only for parameterized types but also for performing simple calculations on argument types to compute appropriate result types. <p> Emerald is not based on multiple dispatching and in fact does not include support for inheritance of implementation. Types in Emerald are arranged in a subtype lattice, however. * Formerly known as Owl and Trellis/Owl. 68 Rapide [Mitchell et al. 91] is an extension of Standard ML modules <ref> [Milner et al. 90] </ref> with subtyping and inheritance. Although Rapide does not support multi-methods and relies on implicit subtyping, many other design goals for Rapide are similar to those for Cecil. Several languages support some form of mixed static and dynamic type checking.
Reference: [Mitchell et al. 91] <author> John Mitchell, Sigurd Meldal, and Neel Hadhav. </author> <title> An Extension of Standard ML Modules with Subtyping and Inheritance. </title> <booktitle> In Conference Record of the ACM Symposium on Principles of Programming Languages, </booktitle> <address> Williamsburg, VA, </address> <month> January, </month> <year> 1991. </year>
Reference-contexts: Emerald is not based on multiple dispatching and in fact does not include support for inheritance of implementation. Types in Emerald are arranged in a subtype lattice, however. * Formerly known as Owl and Trellis/Owl. 68 Rapide <ref> [Mitchell et al. 91] </ref> is an extension of Standard ML modules [Milner et al. 90] with subtyping and inheritance. Although Rapide does not support multi-methods and relies on implicit subtyping, many other design goals for Rapide are similar to those for Cecil.
Reference: [Moon 86] <author> David A. Moon. </author> <title> Object-Oriented Programming with Flavors. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 1-8, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year> <month> 73 </month>
Reference-contexts: Consequently, the key distinguishing characteristic of method lookup in a language with multiple inheritance and/or multiple dispatching is how exactly this ambiguity problem is resolved. Some languages resolve all ambiguities automatically. For example, Flavors <ref> [Moon 86] </ref> linearizes the class hierarchy, producing a total ordering on classes, derived from each class local left-to-right ordering of superclasses, that can be searched without ambiguity just as in the single inheritance case. However, linearization can produce unexpected method lookup results, especially if the program contains errors [Snyder 86].
Reference: [Mugridge et al. 91] <author> W. B. Mugridge, J. G. Hosking, and J. Hamer. </author> <title> Multi-Methods in a Statically-Typed Programming Language. </title> <type> Technical report #50, </type> <institution> Department of Computer Science, University of Auckland, </institution> <year> 1991. </year> <booktitle> Also in ECOOP 91 Conference Proceedings, </booktitle> <address> Geneva, Switzerland, </address> <month> July, </month> <year> 1991. </year>
Reference-contexts: However, final checking still is needed once the whole program is assembled to ensure that no two multi-methods are mutually ambiguous. 3.7.4 Comparison with Type Systems for Multiply-Dispatched Languages Few multiply-dispatched languages support static type systems. Two that are most relevant are Polyglot [Agrawal et al. 91] and Kea <ref> [Mugridge et al. 91] </ref>. In both of these systems, type checking of method consistency and completeness requires that all related methods (all methods in the same generic function in Polyglot and all variants of a function in Kea) be available to the type checker, just as does Cecil. <p> This requirement is similar to that of Cecil that the whole program be available at type-check-time to guarantee that two multi-methods are not mutually ambiguous for some set of argument objects. Kea is a higher-order polymorphic functional language supporting multi-methods <ref> [Mugridge et al. 91] </ref>. Like Polyglot (and most other object-oriented languages), inheritance and subtyping in Kea 67 are unified. Keas type checking of multi-methods is similar to Cecils in that multi-methods must be both complete and consistent. It appears that Kea has a notion of abstract methods as well.
Reference: [Nelson 91] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference-contexts: BETA uses the same syntax to access both global variables and inherited instance variables, making the semantics of the construct somewhat more complicated. Nested methods can be used to achieve the effect of a typecase statement as found in other languages, including Trellis and Modula-3 <ref> [Nelson 91, Harbison 92] </ref>. <p> Cedar supports a similar mechanism through its REF ANY type [Teitelman 84]. Modula-3 retains the REFANY type and includes several operations including NARROW and TYPECASE that can produce a more precisely-typed value from a REFANY type <ref> [Nelson 91, Harbison 92] </ref>. Cecil provides better support for exploratory programming than these other languages since there is no source code overhead for using dynamic typing: variable type declarations are simply omitted, and coercions between dynamically-typed expressions and statically-typed variables are implicit.
Reference: [Pierce & Turner 92] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Statically Typed Multi-Methods via Partially Abstract Types. </title> <type> Unpublished manuscript, </type> <month> October, </month> <year> 1992. </year>
Reference-contexts: Other theoretical treatments of multi-methods have been pursued by Rouaix [Rouaix 90], Ghelli [Ghelli 91, Castagna et al. 92], and Pierce and Turner <ref> [Pierce & Turner 92, Pierce & Turner 93] </ref>. The RPDE 3 environment supports subdivided methods where the value of a parameter to the method or of a global variable helps select among alternative method implementations [Harrison & Ossher 90].
Reference: [Pierce & Turner 93] <author> Benjamin C. Pierce and David N. Turner. </author> <title> Object-Oriented Programming Without Recursive Types. </title> <booktitle> In Conference Record of the 20th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <month> January, </month> <year> 1993. </year>
Reference-contexts: Other theoretical treatments of multi-methods have been pursued by Rouaix [Rouaix 90], Ghelli [Ghelli 91, Castagna et al. 92], and Pierce and Turner <ref> [Pierce & Turner 92, Pierce & Turner 93] </ref>. The RPDE 3 environment supports subdivided methods where the value of a parameter to the method or of a global variable helps select among alternative method implementations [Harrison & Ossher 90].
Reference: [Rees & Clinger 86] <editor> Jonathan Rees and William Clinger, editors. </editor> <title> Revised 3 Report on the Algorithmic Language Scheme. </title> <booktitle> In SIGPLAN Notices 21(12), </booktitle> <month> December, </month> <year> 1986. </year>
Reference-contexts: Looping primitive behavior is provided by the loop primitive method specialized on the closure predefined object. This method repeatedly invokes its argument closure until some closure performs a non-local return to break out of the loop. Other languages such as Scheme <ref> [Rees & Clinger 86] </ref> avoid the need for such a primitive by relying instead on user-level tail recursion and implementation-provided tail-recursion elimination. However, tail-recursion elimination precludes complete source-level debugging [Chambers 92a, Hlzle et al. 92] and consequently is undesirable in general.
Reference: [Rouaix 90] <author> Francois Rouaix. </author> <title> Safe Run-Time Overloading. </title> <booktitle> In Conference Record of the 17th Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 355-366, </pages> <address> San Francisco, CA, </address> <month> January, </month> <year> 1990. </year>
Reference-contexts: Other theoretical treatments of multi-methods have been pursued by Rouaix <ref> [Rouaix 90] </ref>, Ghelli [Ghelli 91, Castagna et al. 92], and Pierce and Turner [Pierce & Turner 92, Pierce & Turner 93].
Reference: [Santas 93] <author> Philip S. Santas. </author> <title> A Type System for Computer Algebra. </title> <booktitle> In International Symposium on Symbolic and Algebraic Computation. </booktitle> <year> 1993. </year>
Reference-contexts: Unlike a normal subtype, the extended type is not necessarily substitutable wherever its base type might appear. Alternative versions of this idea arise in the categories of Axiom (formerly Scratchpad II) [Watt et al., Jenks & Sutor 92] and the metaclasses of k-bench <ref> [Santas 93] </ref>. To illustrate these ideas, we will rewrite the above min example with some language extensions under consideration.
Reference: [Schaffert et al. 85] <author> Craig Schaffert, Topher Cooper, and Carrie Wilpolt. </author> <title> Trellis Object-Based Environment, Language Reference Manual. </title> <type> Technical report DEC-TR-372, </type> <month> November, </month> <year> 1985. </year>
Reference-contexts: Cecil is unusual in combining a pure, classless (prototype-based) object model, multiple dispatching (multi-methods), and mixed static and dynamic type checking. Cecil was inspired primarily by SELF [Ungar & Smith 87, Hlzle et al. 91a], CLOS [Bobrow et al. 88, Gabriel et al. 91], and Trellis <ref> [Schaffert et al. 85, Schaffert et al. 86] </ref>. 1.1 Design Goals and Major Features Cecils design results from several goals: Maximize the programmers ability to develop software quickly and to reuse and modify existing software easily. <p> Trellis * supports an expressive, safe static type system <ref> [Schaffert et al. 85, Schaffert et al. 86] </ref>. Cecils parameterized type system includes features not present in Trellis, such as implicitly-bound type variables and uniform treatment of constrained type variables. Trellis restricts the inheritance hierarchy to conform to the subtype hierarchy; it only supports isa-style superclasses.
Reference: [Schaffert et al. 86] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 9-16, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Cecil is unusual in combining a pure, classless (prototype-based) object model, multiple dispatching (multi-methods), and mixed static and dynamic type checking. Cecil was inspired primarily by SELF [Ungar & Smith 87, Hlzle et al. 91a], CLOS [Bobrow et al. 88, Gabriel et al. 91], and Trellis <ref> [Schaffert et al. 85, Schaffert et al. 86] </ref>. 1.1 Design Goals and Major Features Cecils design results from several goals: Maximize the programmers ability to develop software quickly and to reuse and modify existing software easily. <p> Trellis * supports an expressive, safe static type system <ref> [Schaffert et al. 85, Schaffert et al. 86] </ref>. Cecils parameterized type system includes features not present in Trellis, such as implicitly-bound type variables and uniform treatment of constrained type variables. Trellis restricts the inheritance hierarchy to conform to the subtype hierarchy; it only supports isa-style superclasses.
Reference: [Snyder 86] <author> Alan Snyder. </author> <title> Encapsulation and Inheritance in Object-Oriented Programming Languages. </title> <booktitle> In OOPSLA 86 Conference Proceedings, </booktitle> <pages> pp. 38-45, </pages> <address> Portland, OR, </address> <month> September, </month> <year> 1986. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: In Cecil, the subtype graph is distinguished from the code inheritance graph, since type checking has different goals and requirements than have code reuse and module extension <ref> [Snyder 86, Halbert & OBrien 86, Cook et al. 90] </ref>. Another important kind of static declaration distinguishes the external interface of an object from its internal implementation. Cecil includes a mechanism for encapsulating internal details of objects and enforcing this boundary. <p> However, linearization can produce unexpected method lookup results, especially if the program contains errors <ref> [Snyder 86] </ref>. CommonLoops [Bobrow et al. 86] and CLOS extend this linearization approach to multi-methods, totally ordering multi-methods by prioritizing argument position, with earlier argument positions completely dominating later argument positions. <p> Sometimes this constraint becomes awkward <ref> [Snyder 86] </ref>, for example when a class supports the interface of some 38 other class or type, but does not wish to inherit any code.
Reference: [Steele 84] <author> Guy L. Steele Jr. </author> <title> Common LISP. </title> <publisher> Digital Press, </publisher> <year> 1984. </year>
Reference-contexts: The initializing expression is evaluated in a context where the name of the variable being declared and any later variables within the same declaration block are considered undefined. * This avoids potential misunderstandings about the meaning of apparently self-referential or mutually recursive initializers, supporting a kind of let* <ref> [Steele 84] </ref> variable binding sequence. Variable declarations may appear at the top level as well as inside a method. However, the ordering of variable declarations at the top level is less well defined.
Reference: [Stroustrup 86] <author> Bjarne Stroustrup. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference-contexts: Similarly, particular applications may need to add application-specific behavior to objects defined as part of other applications. For example, an application may need specialized tab-to-space conversion to be provided by strings and other collections of characters. Other object-oriented languages such as C++ <ref> [Stroustrup 86, Ellis & Stroustrup 90] </ref> and Eiffel do not allow programmers to add behavior to existing classes without modifying the source code of the existing classes, and completely disallow adding behavior to built-in classes like strings. <p> However, a method can be subdivided only for particular values of a parameter or global variable, not its class; this is much like supporting only CLOSs eql specializers. A number of languages, including C++ <ref> [Stroustrup 86, Ellis & Stroustrup 90] </ref> and Haskell [Hudak et al. 90], support static overloading on function arguments, but all overloading is resolved at compile-time based on the static types of the arguments rather than on their dynamic types as would be required for true multiple dispatching.
Reference: [Teitelman 84] <author> Warren Teitelman. </author> <title> The Cedar Programming Environment: A Midterm Report and Examination. </title> <note> Xerox PARC technical report CSL-83-11, </note> <month> June, </month> <year> 1984. </year>
Reference-contexts: Any expression may be assigned to a variable of type any, but any assignments of an expression of type any to an expression of another type must be explicitly coerced using the parameterized force procedure. Cedar supports a similar mechanism through its REF ANY type <ref> [Teitelman 84] </ref>. Modula-3 retains the REFANY type and includes several operations including NARROW and TYPECASE that can produce a more precisely-typed value from a REFANY type [Nelson 91, Harbison 92].
Reference: [Touretzky 86] <author> D. Touretzky. </author> <title> The Mathematics of Inheritance Systems. </title> <publisher> Morgan-Kaufmann, </publisher> <year> 1986. </year>
Reference-contexts: ordering, and it usually is unclear from the program text which details are important for a particular application. 26 Accordingly, we have striven for a very simple system of multiple inheritance and multiple dispatching for Cecil. 2.5.2 Semantics Method lookup in Cecil uses a form of Touretzkys inferential distance heuristic <ref> [Touretzky 86] </ref>, where children override parents.
Reference: [Ungar & Smith 87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, </booktitle> <pages> pp. 227-241, </pages> <address> Orlando, FL, </address> <month> October, </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Cecil is unusual in combining a pure, classless (prototype-based) object model, multiple dispatching (multi-methods), and mixed static and dynamic type checking. Cecil was inspired primarily by SELF <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref>, CLOS [Bobrow et al. 88, Gabriel et al. 91], and Trellis [Schaffert et al. 85, Schaffert et al. 86]. 1.1 Design Goals and Major Features Cecils design results from several goals: Maximize the programmers ability to develop software quickly and to reuse and <p> Since CLOS does not admit the possibility of ambiguity, it need only support undirected resends (i.e., call-next-method); there is no need for directed resends. * This example was adapted from Ungar and Smiths original SELF paper <ref> [Ungar & Smith 87] </ref>. 33 2.7 Predicate Objects Cecil has been extended experimentally to support predicate objects [Chambers 93]. Predicate objects are like normal objects except that they have an associated predicate expression. <p> Consequently, min may be invoked on a pair of numbers or on a pair of collections of numbers, but without requiring a number to be comparable to a collection of numbers. 66 4 Related Work Cecil builds upon much of the work done with the SELF programming language <ref> [Ungar & Smith 87, Hlzle et al. 91a] </ref>. SELF offers a simple, pure, classless object model with state accessed via message passing just like methods. Cecil extends SELF with multi-methods, copy-down and initialize-only data slots, lexically-scoped local methods and fields, object extensions, and static typing.
Reference: [Ungar et al. 91] <author> David Ungar, Craig Chambers, Bay-Wei Chang, and Urs Hlzle. </author> <title> Organizing Programs without Classes. In Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Similarly, Cecils classless object model is designed so that a single object declaration can define an entire data type. This contrasts with the situation in SELF, where two objects are needed to define most data types <ref> [Ungar et al. 91] </ref>. Similarly, Cecils object model supports both concise inheritance of representation and concise overriding of representation, unlike most class-based object-oriented languages which only support the former and most classless object-oriented languages which only conveniently support the latter. Finally, Cecil avoids requiring annotations for exploratory programming. <p> state, most data types are actually defined with two objects: one object, the prototype, includes all the instance-specific variables that objects of the data type need, while the other object, the traits object, is inherited by the prototype and holds the methods and shared state 17 of the data type <ref> [Ungar et al. 91] </ref>. New SELF objects are created by cloning (shallow-copying) a prototype, thus giving new objects their own instance variables while sharing the parent traits object and its methods and state.
Reference: [Watt et al. 88] <author> Steven M. Watt, Richard D. Jenks, Robert S. Sutor, and Barry M. Trager. </author> <title> The Scratchpad II Type System: Domains and Subdomains. </title> <booktitle> In Proceedings of the International Workshop on Scientific Computation, </booktitle> <address> Capri, Italy, </address> <year> 1988. </year> <title> Published in Computing Tools for Scientific Problem Solving, </title> <editor> A. M. Miola, ed., </editor> <publisher> Academic Press, </publisher> <year> 1990. </year> <month> 74 </month>
References-found: 70

