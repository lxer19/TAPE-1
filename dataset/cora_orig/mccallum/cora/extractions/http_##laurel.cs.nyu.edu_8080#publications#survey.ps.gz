URL: http://laurel.cs.nyu.edu:8080/publications/survey.ps.gz
Refering-URL: http://laurel.cs.nyu.edu:8080/disser/
Root-URL: http://www.cs.nyu.edu
Email: yung@cs.nyu.edu  
Title: Survey Paper Update-in-place Analysis for Sets  
Author: Chung Yung 
Date: December 15, 1997  
Address: New York University  
Affiliation: Computer Science Department Courant Institute of Mathematical Sciences  
Abstract: This survey paper describes the current approaches on the update-in-place analysis for sets. Pure functional languages do not allow mutations, destructive updates, or selective updates so that straightforward implementations of functional language compilers may induce large amounts of copying to preserve program semantics. The unnecessary copying of data can increase both the execution time and the memory requirements of an application. Introducing sets to functional languages as a primitive data constructor posts a new problem of update-in-place analysis in functional languages. Moreover, most of the compiler optimization techniques depend on the side-effects and the update-in-place analysis serves as the premise of applying such optimization techniques. Among other compiler optimization techniques, finite differencing captures common yet distinctive program constructions of costly repeated calculations and transforms them into more efficient incremental program constructions. This dissertation is an attempt to explore the update-in-place analysis for sets in functional languages in order to apply finite differencing to compiling pure functional languages. In this survey paper, we will describe the approaches of update-in-place analysis and the finite differencing techniques.
Abstract-found: 1
Intro-found: 1
Reference: [App92] <author> A. W. Appel. </author> <title> Compiling with Continuations, </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference: [Ber82] <author> F. Le Berre. </author> <title> Un Langage pour manipuler les ensembles: MANENS, </title> <type> Ph.D. thesis, </type> <institution> Paris VII, </institution> <year> 1982. </year>
Reference-contexts: The optimization of programs with set operations is discussed in Freudenberger et al. [FSS83]. Manens <ref> [Ber82] </ref> and S3L [Lac92] are lambda-calculi with sets. Goubault [Gou94]described HimML, an extension of Standard ML [MTH90] with fast polymorphic set-theoretic data structures. The destructive update optimization has been considered in the literature before. One of the early works is Mycroft [Myc81].
Reference: [Blo94] <author> A. Bloss. </author> <title> "Path Analysis and the Optimization of Non-strict Functional Languages," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 16, No. 3, </volume> <pages> pp. 328-369, </pages> <month> May </month> <year> 1994. </year>
Reference-contexts: We will describe three of the well-known approaches, all of which are based on the abstract interpretation framework. Section 2 is a brief description on the basic frameworks of abstraction interpretation. We introduce the path analysis by Bloss <ref> [Blo94, Blo89a, Blo89b] </ref>, the reduction to variable analysis by Draghicescu and Pu-rushothaman [DP93], and the effect analysis by Odersky [Ode91], in Sections 3, 4, and 5, respectively . In Section 6, we present the used-once analysis by Turner, Wadler, and Mossin [TWM95]. <p> However, the extended semantics is not computable at compile-time since it relies on the standard semantics <ref> [Blo94] </ref>. She then abstracted only the path information away from path semantics. <p> The path semantics, presented by Bloss <ref> [Blo89a, Blo94] </ref>, is an exact but non-standard semantics that describes the operational notion of order of evaluation in a program. Since the order of evaluation at runtime depends on the values themselves, path semantics contains the information of the standard semantics as well as path information.
Reference: [Blo89a] <author> A. Bloss. </author> <title> Path Analysis and the Optimization of Non-strict Functional Languages, </title> <type> Ph.D. thesis, </type> <institution> YALEU/DCS/RR-704, Yale University, </institution> <month> May </month> <year> 1989. </year>
Reference-contexts: An applicative-order language is treated in Hudak [Hud87] using an abstraction of reference counting. A related analysis is presented by Schmidt [Sch85, Sch88], also in an applicative-order setting. The problem is also discussed in Bloss <ref> [Blo89a, Blo89b] </ref> as an application of path analysis. A variation of path analysis is also used in Gopinath and Hennessy [GH89] for a language with call-by-value semantics. Draghicescu and Purushothaman [DP93] offered a solution to object sharing and evaluation order problems for lazy functional languages. <p> We will describe three of the well-known approaches, all of which are based on the abstract interpretation framework. Section 2 is a brief description on the basic frameworks of abstraction interpretation. We introduce the path analysis by Bloss <ref> [Blo94, Blo89a, Blo89b] </ref>, the reduction to variable analysis by Draghicescu and Pu-rushothaman [DP93], and the effect analysis by Odersky [Ode91], in Sections 3, 4, and 5, respectively . In Section 6, we present the used-once analysis by Turner, Wadler, and Mossin [TWM95]. <p> The path semantics, presented by Bloss <ref> [Blo89a, Blo94] </ref>, is an exact but non-standard semantics that describes the operational notion of order of evaluation in a program. Since the order of evaluation at runtime depends on the values themselves, path semantics contains the information of the standard semantics as well as path information.
Reference: [Blo89b] <author> A. Bloss. </author> <title> "Update Analysis and the Efficient Implementation of Functional Aggregates," </title> <booktitle> 4 th International Conference on Functional Programming and Computer Architecture, </booktitle> <pages> pp. 26-38, </pages> <year> 1989. </year>
Reference-contexts: An applicative-order language is treated in Hudak [Hud87] using an abstraction of reference counting. A related analysis is presented by Schmidt [Sch85, Sch88], also in an applicative-order setting. The problem is also discussed in Bloss <ref> [Blo89a, Blo89b] </ref> as an application of path analysis. A variation of path analysis is also used in Gopinath and Hennessy [GH89] for a language with call-by-value semantics. Draghicescu and Purushothaman [DP93] offered a solution to object sharing and evaluation order problems for lazy functional languages. <p> We will describe three of the well-known approaches, all of which are based on the abstract interpretation framework. Section 2 is a brief description on the basic frameworks of abstraction interpretation. We introduce the path analysis by Bloss <ref> [Blo94, Blo89a, Blo89b] </ref>, the reduction to variable analysis by Draghicescu and Pu-rushothaman [DP93], and the effect analysis by Odersky [Ode91], in Sections 3, 4, and 5, respectively . In Section 6, we present the used-once analysis by Turner, Wadler, and Mossin [TWM95].
Reference: [CP93] <author> J. Cai, and R. Paige. </author> <title> "Towards Increased Productivity of Algorithm Implementation," </title> <booktitle> Proceedings on ACM SIGSOFT 1993, </booktitle> <pages> pp. 71-78, </pages> <booktitle> also in ACM Software Engineering Notes, </booktitle> <volume> Vol. 18, No. 5, </volume> <month> December </month> <year> 1993. </year>
Reference-contexts: Zrset = initZ S count --; 27. in TSort Zrset succ count []; 4 reduction, and provides a convenient framework to implement a host of program transfor-mations, including Earley's "iteration inversion" [PK82]. It has been applied to program transformation systems between imperative languages <ref> [CP93, Pai94] </ref>. Some recent work caught the spirit of finite differencing and applied it to incremental computation systems [Liu96], and semi-automatic program development systems [Smi90]. 1.3 A First-Order Functional Language As a basis of the following discussion, we will define a first-order functional language as follows. <p> Since the destructive updates may be performed on the values when they are last used, these two techniques together show the light to an interesting and potentially new approach. We present, in Section 8, the technique of finite differencing on computable expressions by Paige <ref> [CP93, Pai81, PK82, Pai86] </ref>, since finite differencing is one of the most important applications of the update-in-place analysis for sets. We include a short conclusion at last. 2 Abstract Interpretation A standard interpretation gives a program its intended denotational semantics.
Reference: [CG92] <author> T-R. Chuang, and B. Goldberg, </author> <title> "Backward Analysis for Higher-Order Functions Using Inverse Images," </title> <type> Technical Report, </type> <institution> TR1992-620, Computer Science Department, </institution> <address> New York University, </address> <month> November </month> <year> 1992. </year>
Reference-contexts: In Section 6, we present the used-once analysis by Turner, Wadler, and Mossin [TWM95]. They extended the Hindley-Milner type system with uses, and developed a type-int`ference based program analysis which determines when values are accessed at most once. We describe the backward analysis technique by Chuang and Goldberg <ref> [CG92] </ref> in Section 7. Since the destructive updates may be performed on the values when they are last used, these two techniques together show the light to an interesting and potentially new approach. <p> ` fi e : t 0 jt j = ! ; ` fi letrec x = v in e : t 0 7 Backward Analysis Chuang and Goldberg proposed a method for performing backward analysis on higher-order functional programming languages based on computing inverse images of functions over abstract domains <ref> [CG92] </ref>. This method can be viewed as abstract interpretation done backward. Given an abstract semantics which supports forward analysis, we can transform it into an abstract semantics which performs backward analysis with Chuang and Goldberg's backward analysis method. 7.1 Main Theorem We start with some definitions. Definition CG1.
Reference: [DP93] <author> M. Draghicescu, and S. Purushothaman. </author> <title> "A Uniform Treatment of Order of Evaluation and Aggregate Update," </title> <booktitle> Theoretical Computer Science, B , 2(118), September 1993; also in Proceeding of the 1990 ACM Conference on Lisp and Functional Programming. </booktitle>
Reference-contexts: The problem is also discussed in Bloss [Blo89a, Blo89b] as an application of path analysis. A variation of path analysis is also used in Gopinath and Hennessy [GH89] for a language with call-by-value semantics. Draghicescu and Purushothaman <ref> [DP93] </ref> offered a solution to object sharing and evaluation order problems for lazy functional languages. Fitzgerald and Oldehoeft explored update-in-place analysis for true multidimensional arrays with a graph-based language as an intermediate form [FO95]. Odersky presented effect analysis for a safe embedding of mutable data structure in functional languages [Ode91]. <p> Section 2 is a brief description on the basic frameworks of abstraction interpretation. We introduce the path analysis by Bloss [Blo94, Blo89a, Blo89b], the reduction to variable analysis by Draghicescu and Pu-rushothaman <ref> [DP93] </ref>, and the effect analysis by Odersky [Ode91], in Sections 3, 4, and 5, respectively . In Section 6, we present the used-once analysis by Turner, Wadler, and Mossin [TWM95]. <p> The domain DP ath has been abstracted to the powerdomain of P ath so that the information from the standard semantics is no longer in a set of possible paths. 4 Reduction To Variable Analysis The reduction to variable analysis by Draghicescu and Purushothaman <ref> [DP93] </ref> is based on the assumptions: * that no object is copied during evaluation; * that if never creates a new object but just returns the reference of the selected branch, * that all primitive functions except if always create a new object as their result, i.e., a call to such
Reference: [FO95] <author> S. M. Fitzgerald, and R. R. Oldehoeft. </author> <title> "Update-in-place Analysis for True Multidimensional Arrays," High Performance Functional Computing, </title> <editor> A. P. Wim Bohm, and J. T. Feo, </editor> <booktitle> editors, </booktitle> <pages> pp. 105-118, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: An implementation that strictly adheres to the applicative model is required to copy when data values are modified. However, the cost associated with copying large data aggregates such as arrays and sets can become prohibitive <ref> [FO95] </ref>. This leads to our investigation in optimization techniques for optimizing pure functional programs with aggregates. <p> Draghicescu and Purushothaman [DP93] offered a solution to object sharing and evaluation order problems for lazy functional languages. Fitzgerald and Oldehoeft explored update-in-place analysis for true multidimensional arrays with a graph-based language as an intermediate form <ref> [FO95] </ref>. Odersky presented effect analysis for a safe embedding of mutable data structure in functional languages [Ode91].
Reference: [FSS83] <author> S. M. Freudenberger, J. T. Schwartz, and M. Sharir. </author> <title> "Experience with the SETL Optimizer," </title> <journal> ACM Transaction on Programming Languages and Systems, pp. </journal> <volume> 26-45, Vol. 5, No. 1, </volume> <month> January </month> <year> 1983. </year>
Reference-contexts: We will describe more of this in Section 2. 1.2 Related Works The SETL programming language, developed at New York University [SDDS86, Sny90], is the first programming language with a general purpose set data structure. The optimization of programs with set operations is discussed in Freudenberger et al. <ref> [FSS83] </ref>. Manens [Ber82] and S3L [Lac92] are lambda-calculi with sets. Goubault [Gou94]described HimML, an extension of Standard ML [MTH90] with fast polymorphic set-theoretic data structures. The destructive update optimization has been considered in the literature before. One of the early works is Mycroft [Myc81].
Reference: [GH89] <author> K. Gopinath, and J. L. Hennessy. </author> <title> "Copy Elimination in Functional Languages," </title> <booktitle> 16 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 303-314, </pages> <year> 1989. </year>
Reference-contexts: A related analysis is presented by Schmidt [Sch85, Sch88], also in an applicative-order setting. The problem is also discussed in Bloss [Blo89a, Blo89b] as an application of path analysis. A variation of path analysis is also used in Gopinath and Hennessy <ref> [GH89] </ref> for a language with call-by-value semantics. Draghicescu and Purushothaman [DP93] offered a solution to object sharing and evaluation order problems for lazy functional languages. Fitzgerald and Oldehoeft explored update-in-place analysis for true multidimensional arrays with a graph-based language as an intermediate form [FO95].
Reference: [Gou94] <author> J. Goubault. "HimML: </author> <title> Standard ML with fast sets and maps," </title> <booktitle> ACM SIGPLAN Workshop on Standard ML and its Applications, </booktitle> <month> June </month> <year> 1994. </year>
Reference: [Hal77] <author> M. H. Halstead. </author> <title> Elements of Software Science, </title> <publisher> Elsevier North-Holland Publishing, </publisher> <address> New York, </address> <year> 1977. </year>
Reference: [Hud87] <author> P. Hudak. </author> <title> "A Semantic Model of Reference Counting and Its Abstraction," Abstract Interpretation of Declarative Languages, </title> <editor> S. Abramsky and C. Hankin, editors, </editor> <publisher> Ellis Horwood Press, </publisher> <year> 1987. </year>
Reference-contexts: The destructive update optimization has been considered in the literature before. One of the early works is Mycroft [Myc81]. In Hudak and Bloss [HB85], the problem is discussed in an operational model based on graph reduction. An applicative-order language is treated in Hudak <ref> [Hud87] </ref> using an abstraction of reference counting. A related analysis is presented by Schmidt [Sch85, Sch88], also in an applicative-order setting. The problem is also discussed in Bloss [Blo89a, Blo89b] as an application of path analysis.
Reference: [HB85] <author> P. Hudak, and A. Bloss. </author> <title> "The Aggregate Update Problem in Functional Programming Systems," </title> <booktitle> 12 th ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pp. 300-314, </pages> <year> 1985. </year>
Reference-contexts: Manens [Ber82] and S3L [Lac92] are lambda-calculi with sets. Goubault [Gou94]described HimML, an extension of Standard ML [MTH90] with fast polymorphic set-theoretic data structures. The destructive update optimization has been considered in the literature before. One of the early works is Mycroft [Myc81]. In Hudak and Bloss <ref> [HB85] </ref>, the problem is discussed in an operational model based on graph reduction. An applicative-order language is treated in Hudak [Hud87] using an abstraction of reference counting. A related analysis is presented by Schmidt [Sch85, Sch88], also in an applicative-order setting.
Reference: [Joh85] <author> T. Johnsson. </author> <title> "Lambda Lifting: Transforming Programs to Recursive Equations," </title> <booktitle> Functional Languages and Computer Architecture, </booktitle> <volume> LNCS Vol. 201, </volume> <pages> pp. 190-203, </pages> <publisher> Springer-Verlag Press 1985. </publisher>
Reference-contexts: (e 1 ; : : : ; e n ) pr 2 P rog programs, where pr = ff i (x 1 ; : : : ; x n ) = e i g Note that we assume that all nested lambda abstractions have been lifted to the top level <ref> [Joh85] </ref>.
Reference: [Lac92] <author> J.-J. Larcrampe. "S3L a tire d'ailes," </author> <type> Technical Report 92-11, </type> <institution> Laboratoire d'Informatique Fondamentale de l'Universite d'Orleans, </institution> <address> BP 6759-45067, Orleans Cedex 2, France, </address> <year> 1992. </year>
Reference-contexts: The optimization of programs with set operations is discussed in Freudenberger et al. [FSS83]. Manens [Ber82] and S3L <ref> [Lac92] </ref> are lambda-calculi with sets. Goubault [Gou94]described HimML, an extension of Standard ML [MTH90] with fast polymorphic set-theoretic data structures. The destructive update optimization has been considered in the literature before. One of the early works is Mycroft [Myc81].
Reference: [Liu96] <author> Y. A. Liu, </author> <title> Incremental Computation: A Semantics-Based Systematic Transformational Approach, </title> <type> Ph.D. Dissertation, </type> <institution> Computer Science Department, Cornell University, </institution> <month> January </month> <year> 1996. </year>
Reference-contexts: It has been applied to program transformation systems between imperative languages [CP93, Pai94]. Some recent work caught the spirit of finite differencing and applied it to incremental computation systems <ref> [Liu96] </ref>, and semi-automatic program development systems [Smi90]. 1.3 A First-Order Functional Language As a basis of the following discussion, we will define a first-order functional language as follows.
Reference: [MTH90] <author> R. Milner, M. Tofte, and R. Harper. </author> <title> The Definition of Standard ML, </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: The optimization of programs with set operations is discussed in Freudenberger et al. [FSS83]. Manens [Ber82] and S3L [Lac92] are lambda-calculi with sets. Goubault [Gou94]described HimML, an extension of Standard ML <ref> [MTH90] </ref> with fast polymorphic set-theoretic data structures. The destructive update optimization has been considered in the literature before. One of the early works is Mycroft [Myc81]. In Hudak and Bloss [HB85], the problem is discussed in an operational model based on graph reduction.
Reference: [Myc81] <author> A. Mycroft. </author> <title> Abstract Interpretation and Optimising Transformations for Applicative Programs, </title> <type> Ph.D. thesis, </type> <institution> University of Edinburgh, </institution> <year> 1981. </year>
Reference-contexts: Manens [Ber82] and S3L [Lac92] are lambda-calculi with sets. Goubault [Gou94]described HimML, an extension of Standard ML [MTH90] with fast polymorphic set-theoretic data structures. The destructive update optimization has been considered in the literature before. One of the early works is Mycroft <ref> [Myc81] </ref>. In Hudak and Bloss [HB85], the problem is discussed in an operational model based on graph reduction. An applicative-order language is treated in Hudak [Hud87] using an abstraction of reference counting. A related analysis is presented by Schmidt [Sch85, Sch88], also in an applicative-order setting.
Reference: [NN92] <author> F. Neilson, and H. R. Neilson. </author> <title> Two-level Functional Languages, </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference: [Nik90] <author> R. S. Nikhil. </author> <title> "The Semantics of Update in a Functional Database Programming Language," </title> <booktitle> Advances in Database Programming Languages, </booktitle> <editor> eds. F. Bancilhon and P. Buneman, </editor> <publisher> ACM Press, </publisher> <year> 1990. </year>
Reference: [Ode91] <author> M. Odersky. </author> <title> "How to Make Destructive Update Less Destructive," </title> <booktitle> Proceedings on 18 th ACM Symposium on Principles of Programming Languages, </booktitle> <year> 1991. </year>
Reference-contexts: Fitzgerald and Oldehoeft explored update-in-place analysis for true multidimensional arrays with a graph-based language as an intermediate form [FO95]. Odersky presented effect analysis for a safe embedding of mutable data structure in functional languages <ref> [Ode91] </ref>. Finite differencing was developed by Paige [Pai81] as a high-level global program optimization method that captures a commonly occurring yet distinctive mechanism of program construction in which repeated costly calculations are replaced by inexpensive incremental counterparts. <p> Section 2 is a brief description on the basic frameworks of abstraction interpretation. We introduce the path analysis by Bloss [Blo94, Blo89a, Blo89b], the reduction to variable analysis by Draghicescu and Pu-rushothaman [DP93], and the effect analysis by Odersky <ref> [Ode91] </ref>, in Sections 3, 4, and 5, respectively . In Section 6, we present the used-once analysis by Turner, Wadler, and Mossin [TWM95]. They extended the Hindley-Milner type system with uses, and developed a type-int`ference based program analysis which determines when values are accessed at most once.
Reference: [Pai81] <author> R. Paige. </author> <title> Formal Differentiation: A Program Synthesis Technique, </title> <publisher> UMI Research Press, </publisher> <year> 1981. </year>
Reference-contexts: Fitzgerald and Oldehoeft explored update-in-place analysis for true multidimensional arrays with a graph-based language as an intermediate form [FO95]. Odersky presented effect analysis for a safe embedding of mutable data structure in functional languages [Ode91]. Finite differencing was developed by Paige <ref> [Pai81] </ref> as a high-level global program optimization method that captures a commonly occurring yet distinctive mechanism of program construction in which repeated costly calculations are replaced by inexpensive incremental counterparts. <p> Since the destructive updates may be performed on the values when they are last used, these two techniques together show the light to an interesting and potentially new approach. We present, in Section 8, the technique of finite differencing on computable expressions by Paige <ref> [CP93, Pai81, PK82, Pai86] </ref>, since finite differencing is one of the most important applications of the update-in-place analysis for sets. We include a short conclusion at last. 2 Abstract Interpretation A standard interpretation gives a program its intended denotational semantics. <p> Let D ff and D fi be domains, and let f 2 D ff ! D fi . If (P 0 O (f 1 )) f? D fi g w P 0 then f is strict. 2 25 8 Finite Differencing Finite differencing was developed by Paige <ref> [Pai81] </ref> as a global program optimization method that captures a commonly occurring yet distinctive mechanism of program construction in which repeated costly calculations are replaced by inexpensive incremental counterparts.
Reference: [PK82] <author> R. Paige, and S. Koenig. </author> <title> "Finite Differencing of Computable Expressions," </title> <journal> ACM Transactions on Programming Languages and Systems, pp. </journal> <volume> 402-454, Vol. 4, No. 3, </volume> <month> July </month> <year> 1982. </year> <month> 31 </month>
Reference-contexts: Zrset = initZ S count --; 27. in TSort Zrset succ count []; 4 reduction, and provides a convenient framework to implement a host of program transfor-mations, including Earley's "iteration inversion" <ref> [PK82] </ref>. It has been applied to program transformation systems between imperative languages [CP93, Pai94]. <p> Since the destructive updates may be performed on the values when they are last used, these two techniques together show the light to an interesting and potentially new approach. We present, in Section 8, the technique of finite differencing on computable expressions by Paige <ref> [CP93, Pai81, PK82, Pai86] </ref>, since finite differencing is one of the most important applications of the update-in-place analysis for sets. We include a short conclusion at last. 2 Abstract Interpretation A standard interpretation gives a program its intended denotational semantics. <p> This method generalizes John Cocke's method of strength reduction, and provides a convenient framework with which to implement a host of program transformations, including Earley's "iteration inversion" <ref> [PK82] </ref>. When compared with some other program transformations, finite differencing shows its advantages in several ways: 1. Finite differencing may be applied over a large spectrum of language levels from high level specifications to low-level program representations; 2.
Reference: [Pai86] <author> R. Paige. </author> <title> "Programming with Invariants," </title> <journal> IEEE Software, pp. </journal> <volume> 560-69, Vol. 3, No. 1, </volume> <month> January </month> <year> 1986. </year>
Reference-contexts: Since the destructive updates may be performed on the values when they are last used, these two techniques together show the light to an interesting and potentially new approach. We present, in Section 8, the technique of finite differencing on computable expressions by Paige <ref> [CP93, Pai81, PK82, Pai86] </ref>, since finite differencing is one of the most important applications of the update-in-place analysis for sets. We include a short conclusion at last. 2 Abstract Interpretation A standard interpretation gives a program its intended denotational semantics.
Reference: [Pai89] <author> R. Paige. </author> <title> "Real-Time Simulation of A Set Machine on a RAM," </title> <booktitle> Proceedings on ICCI 89, </booktitle> <month> May </month> <year> 1989, </year> <note> also in Computing and Information, Vol. </note> <editor> II, eds. R. Janicki and W. </editor> <booktitle> Koczkodaj, </booktitle> <pages> pp. 69-73, </pages> <publisher> Canadian Scholars Press, </publisher> <year> 1989. </year>
Reference: [Pai94] <author> R. Paige. </author> <title> "Viewing a Program Transformation System at Work," </title> <booktitle> Joint 6th International Conference on Programming Language Implementation and Logic programming (PLILP) and 4th International Conference on Algebraic and Logic Programming (ALP), </booktitle> <volume> LNCS 844, </volume> <editor> eds. M. Hermenegildo and J. Penjam, </editor> <publisher> Springer-Verlag, </publisher> <month> September </month> <year> 1994, </year> <pages> pp. 5-24. </pages>
Reference-contexts: Zrset = initZ S count --; 27. in TSort Zrset succ count []; 4 reduction, and provides a convenient framework to implement a host of program transfor-mations, including Earley's "iteration inversion" [PK82]. It has been applied to program transformation systems between imperative languages <ref> [CP93, Pai94] </ref>. Some recent work caught the spirit of finite differencing and applied it to incremental computation systems [Liu96], and semi-automatic program development systems [Smi90]. 1.3 A First-Order Functional Language As a basis of the following discussion, we will define a first-order functional language as follows.
Reference: [Pip97] <author> N. Pippenger. </author> <title> "Pure versus Impure Lisp," </title> <journal> Transactions on Programming Languages ans Systems, </journal> <volume> Vol. 19, No. 2, </volume> <pages> pp. 223-238, </pages> <month> March </month> <year> 1997. </year>
Reference-contexts: One feature of functional languages that goes beyond the applicative realm is the inclusion of primitives for what is variously referred to as "mutations," "destructive updates," or "selective updates." We shall refer to a functional language with or without mutation primitives as impure or pure, respectively <ref> [Pip97] </ref>. 1 /* loop in TopSort */ 1. fun TSort -- S L = L; 2. | TSort (T with a) S L = 3. let S1 = S less a; 4.
Reference: [Sch85] <author> D. A. Schmidt. </author> <title> "Detecting Global Variables in Denotational Specifications," </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> Vol. 7, No. 2, </volume> <pages> pp. 299-310, </pages> <year> 1985. </year>
Reference-contexts: One of the early works is Mycroft [Myc81]. In Hudak and Bloss [HB85], the problem is discussed in an operational model based on graph reduction. An applicative-order language is treated in Hudak [Hud87] using an abstraction of reference counting. A related analysis is presented by Schmidt <ref> [Sch85, Sch88] </ref>, also in an applicative-order setting. The problem is also discussed in Bloss [Blo89a, Blo89b] as an application of path analysis. A variation of path analysis is also used in Gopinath and Hennessy [GH89] for a language with call-by-value semantics.
Reference: [Sch88] <author> D. A. Schmidt. </author> <title> "Detecting Stack-Based Environments in Denotational Definitions," </title> <booktitle> Science of Computer Programming, </booktitle> <volume> Vol. 11, </volume> <pages> pp 107-131, </pages> <year> 1988. </year>
Reference-contexts: One of the early works is Mycroft [Myc81]. In Hudak and Bloss [HB85], the problem is discussed in an operational model based on graph reduction. An applicative-order language is treated in Hudak [Hud87] using an abstraction of reference counting. A related analysis is presented by Schmidt <ref> [Sch85, Sch88] </ref>, also in an applicative-order setting. The problem is also discussed in Bloss [Blo89a, Blo89b] as an application of path analysis. A variation of path analysis is also used in Gopinath and Hennessy [GH89] for a language with call-by-value semantics.
Reference: [SDDS86] <author> J. T. Schwartz, R. B. K. Dewar, E. Dubinsky, E. Schonberg. </author> <title> Programming With Sets: An Introduction to SETL, </title> <publisher> Springer-Verlag Press, </publisher> <year> 1986. </year>
Reference-contexts: We will describe more of this in Section 2. 1.2 Related Works The SETL programming language, developed at New York University <ref> [SDDS86, Sny90] </ref>, is the first programming language with a general purpose set data structure. The optimization of programs with set operations is discussed in Freudenberger et al. [FSS83]. Manens [Ber82] and S3L [Lac92] are lambda-calculi with sets.
Reference: [Set89] <author> R. Sethi. </author> <title> Programming languages: Concepts and Constructs, </title> <publisher> Addison-Wesley Press, </publisher> <year> 1989. </year>
Reference: [SK95] <author> K. Slonneger, and B. L. Kurtz. </author> <title> Formal Syntax and Semantics of Programming Languages, </title> <publisher> Addison-Wesley Press, </publisher> <year> 1995. </year>
Reference: [Smi90] <author> D. R. Smith. "KIDS: </author> <title> A Semi-Automatic Program Development System," </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Formal Methods, </journal> <month> Sep. </month> <year> 1990. </year>
Reference-contexts: It has been applied to program transformation systems between imperative languages [CP93, Pai94]. Some recent work caught the spirit of finite differencing and applied it to incremental computation systems [Liu96], and semi-automatic program development systems <ref> [Smi90] </ref>. 1.3 A First-Order Functional Language As a basis of the following discussion, we will define a first-order functional language as follows.
Reference: [Sny90] <author> W. K. Snyder. </author> <title> "The SETL2 Programming Language," </title> <type> Technical Report 490, </type> <institution> Computer Science Department, Courant Institute of Mathematical Sciences, </institution> <address> New York University, </address> <month> September </month> <year> 1990. </year>
Reference-contexts: We will describe more of this in Section 2. 1.2 Related Works The SETL programming language, developed at New York University <ref> [SDDS86, Sny90] </ref>, is the first programming language with a general purpose set data structure. The optimization of programs with set operations is discussed in Freudenberger et al. [FSS83]. Manens [Ber82] and S3L [Lac92] are lambda-calculi with sets.
Reference: [TWM95] <author> D. N. Turner, P. Wadler, and C. Mossin. </author> <title> "Once Upon A Type," </title> <booktitle> Proceedings on 7 th International Conference on Functional Programming and Computer Architecture, </booktitle> <month> June </month> <year> 1995. </year>
Reference-contexts: We introduce the path analysis by Bloss [Blo94, Blo89a, Blo89b], the reduction to variable analysis by Draghicescu and Pu-rushothaman [DP93], and the effect analysis by Odersky [Ode91], in Sections 3, 4, and 5, respectively . In Section 6, we present the used-once analysis by Turner, Wadler, and Mossin <ref> [TWM95] </ref>. They extended the Hindley-Milner type system with uses, and developed a type-int`ference based program analysis which determines when values are accessed at most once. We describe the backward analysis technique by Chuang and Goldberg [CG92] in Section 7. <p> 1 ]] f e be; ; (L [[e 2 ]] f e be t L [[e 3 ]] f e be) 6 Used-Once Analysis Turner, Wadler, and Mossin extended the Hindley-Milner type system with uses, yielding a type-inference based program analysis which determines when values are accessed at most once <ref> [TWM95] </ref>. 18 6.1 Syntax And Semantics Syntax Variables x; y; z Values v ::= x:e j n j nil j cons x y Terms e ::= v j x j e x j e 0 + e 1 j case e 0 of fnil ! e 1 ; cons x y
Reference: [Yun97] <author> C. Yung. </author> <title> "Extending Typed Lambda Calculus to Sets," </title> <booktitle> The Proceedings of MAS-PLAS'97, in cooperation with ACM SIGPLAN, </booktitle> <address> Stroudsburg PA, </address> <month> April </month> <year> 1997. </year> <month> 32 </month>
References-found: 38

