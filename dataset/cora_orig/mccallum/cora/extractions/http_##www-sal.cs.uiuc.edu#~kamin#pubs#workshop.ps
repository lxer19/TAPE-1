URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/workshop.ps
Refering-URL: http://www-sal.cs.uiuc.edu/~kamin/pubs/index.html
Root-URL: http://www.cs.uiuc.edu
Title: Purpose  panel consisted of:  
Author: Robert Cartwright Charles Consel Charles N. Fischer Susan L. Graham Gilles Kahn Bernard Lang James McGraw Lawrence Steven Muchnick SUN Microsystems Tom Reps John C. Reynolds David W. Wall David S. Warren Peter Wegner Brown University Jeannette M. Wing David S. Wise Samuel Kamin and Eric Golin, both 
Address: New York, Stony Brook  
Affiliation: Rice University  Oregon Graduate Institute  University of Wisconsin  University of California, Berkeley  INRIA, Sophia Antipolis  INRIA, Rocquencourt  Livermore National Lab  University of Wisconsin  Carnegie-Mellon University  Digital Equipment Corp.  State University of  Carnegie-Mellon University  Indiana University  of the University of Illinois.  
Date: May 31, 1994  
Note: Languages and Compilers  The  The discussion was led by  Also present were Forbes Lewis and John Cherniavsky of the National Science Foundation. The workshop was supported by NSF under grant CCR-9304990.  
Abstract: Report of a Workshop on Future Directions in Programming In January, 1993, a panel of experts in the area of programming languages and compilers met in a one and a half day workshop to discuss the future of research in that area. This paper is the report of their findings. Its purposes are to explain the need for, and benefits of, research in this field| both basic and applied; to broadly survey the various parts of the field and indicate its general research directions; and to propose an initiative aimed at moving basic research results into wider use. fl This report was compiled by Samuel Kamin, University of Illinois at Urbana-Champaign, kamin@cs.uiuc.edu. 1 Steven Muchnick was unable to attend the meeting, but participated in its preparation and in the preparation of this report. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> John Backus, </author> <title> "Can programming be liberated from the von Neumann style? A functional style and its algebra of programs," </title> <journal> Comm. ACM 21(8), </journal> <month> August </month> <year> 1978, </year> <pages> 612-641. </pages>
Reference-contexts: John Backus emphasized this in his famous Turing Award lecture: "Perhaps the most important element in providing powerful changeable parts in a program is the availability of combining forms that can be generally used to build new procedures from old ones" <ref> [1, page 627] </ref>. The motivation for this emphasis is that composability leads to reusability, the one sure-fire way to increase programmer productivity and program quality. * New designs for new applications. The central activity of the field is, and has always been, the design of new languages for new applications.
Reference: [2] <author> R. Ballance, S. Graham, </author> <title> M.L. Van De Vanter, "The Pan language-based editing system for integrated development environments," </title> <booktitle> in ACM SIGSOFT '90: Fourth Symposium on Software Development Environments, </booktitle> <editor> R. Taylor (ed.), </editor> <year> 1990, </year> <pages> 77-93. </pages>
Reference-contexts: Code browsers are an innovation of the 1980's to facilitate code reuse. Several current compiler generator projects emphasize the construction of entire "programming environments," including language-based editors, debuggers, and other tools <ref> [2, 4] </ref>. End-user programming has begun to place an even stronger emphasis on this aspect of programming language research. At the same time, the computing power now available to the average programmer creates great opportunities.
Reference: [3] <author> Gerard Berry, Georges Gonthier, </author> <title> "The Esterel synchronous programming language: design, semantics, </title> <booktitle> implementation," Science of Computer Programming 19, </booktitle> <year> 1992, </year> <pages> 87-152. </pages>
Reference-contexts: This model is very general, but very complex. However, many applications are substantially synchronous|service events occur at predictable intervals. The Esterel language <ref> [3] </ref> was designed for such applications. Its features are quite different from those of conventional sequential languages or the more general asynchronous programming languages.
Reference: [4] <author> P. Borras, D. Clement, T. Despeyroux, J. Incerpi, G. Kahn, B. Lang, V. Pascual, </author> <title> "Centaur: the system," </title> <booktitle> in ACM SIGSOFT '88: Third Symposium on Software Development Environments, </booktitle> <editor> P. Henderson (ed.), </editor> <year> 1988, </year> <pages> 14-24. </pages>
Reference-contexts: Code browsers are an innovation of the 1980's to facilitate code reuse. Several current compiler generator projects emphasize the construction of entire "programming environments," including language-based editors, debuggers, and other tools <ref> [2, 4] </ref>. End-user programming has begun to place an even stronger emphasis on this aspect of programming language research. At the same time, the computing power now available to the average programmer creates great opportunities.
Reference: [5] <author> David Cann, </author> <title> "Retire Fortran? A debate rekindled," </title> <journal> Comm. ACM 35(8), </journal> <month> August </month> <year> 1992, </year> <pages> 81-89. </pages>
Reference-contexts: Many observers have argued that fully exploiting parallel architectures requires a functional language, but such languages are difficult to compile efficiently, for reasons not directly related to parallelism. Sisal is an example of a dataflow language, a class of languages closely related to functional languages. Recent results <ref> [5] </ref> on a broad range of problems showed significant improvements in parallel speed-up for Sisal over Fortran codes compiled with vendor-supplied parallelizing Fortran compilers. * Special purpose languages are used by scientists to communicate models to computers.
Reference: [6] <author> B.W. Char, K.O. Geddes, G.H. Gonnet, B.L. Leong, M.B. Monagan, S.W. Watt, </author> <title> Maple V Language Reference Manual, </title> <publisher> Springer-Verlag, </publisher> <address> New York, </address> <year> 1991. </year>
Reference-contexts: Scientists and engineers design and use many special-purpose languages; examples include hardware description languages, simulation languages, visualization languages, and others. Also noteworthy is the increasing use of symbolic mathematics programs like Mathematica [24] and Maple <ref> [6] </ref>, that have underlying programming languages which all but the most casual users must learn. Thus, new languages eventually find their way into scientific and engineering projects. Fortran is here to stay, but its importance should not be exaggerated.
Reference: [7] <author> Dominique Clement, Janet Incerpi, </author> <title> "Specifying the behavior of graphical objects using Es-terel," </title> <institution> INRIA Rapports de Recherche No. </institution> <month> 836, April </month> <year> 1988. </year>
Reference-contexts: Its features are quite different from those of conventional sequential languages or the more general asynchronous programming languages. An example of its use is the specification of the very complex behaviors and interactions of menus, scrollbars, and so on, in a graphical user interface <ref> [7] </ref>. End-user programming. Just as the needs of the Artificial Intelligence community sparked intensive language design creativity in the 1960's, and the problems of large-scale programming did in the 1970's, so the needs of unsophisticated users will drive that creativity in the 1990's.
Reference: [8] <author> Roger Dannenberg, </author> <title> "The Canon score language," </title> <journal> Computer Music J. </journal> <volume> 13(1), </volume> <month> Spring </month> <year> 1989, </year> <pages> 47-56. </pages>
Reference-contexts: Used to program synthesizers and other electronic instruments (usually using the MIDI interface), these languages are a major improvement over simple note entry; an example is a drumbeat, which can be programmed as a fairly simple repetition of a single note. Pla [21] and Canon <ref> [8] </ref> are two well-known examples. What is unmistakable in reviewing the evolution of these languages is that it follows a trajectory similar to that of programming languages in general, with increasing emphasis on composability, i.e. the flexible interconnection of components. * Timeless designs.
Reference: [9] <author> R.W. Gray, V.P. Heuring, S.P. Levi, A.M. Sloane, W.M. Waite, "Eli: </author> <title> A complete, flexible compiler construction system," </title> <journal> Comm. ACM 35(2), </journal> <month> Feb. </month> <year> 1992, </year> <pages> 121-131. </pages>
Reference-contexts: These techniques and tools can be used in developing implementations for any computer language, not just traditional programming languages. Eli <ref> [9] </ref> is compiler construction system "shell"|in other words, a system that incorpo-rates a variety of compiler construction tools and is designed primarily to facilitate interactions among those tools. The tools include parser and lexer generators and attribute evaluators, among others.
Reference: [10] <author> J.V. Guttag, J.J. Horning, </author> <title> "Report on the Larch Shared Language," </title> <booktitle> Science of Computer Programming 6(2), </booktitle> <month> March </month> <year> 1986, </year> <pages> 103-157. </pages>
Reference-contexts: As mentioned earlier, there are a number of semantics models of concurrent and distributed systems. What is needed now are specification languages that the "run-of-the-mill" software designer can easily use|the equivalent, for concurrency, of languages like Z [23] and Larch <ref> [10] </ref>. The specification and prediction of run-time resource utilization|including, but not limited to, CPU time. This is essential, of course, for real-time applications.
Reference: [11] <author> P. Hilfinger, P. Colella, "Fidil: </author> <title> A language for scientific programming," in Symbolic Computation: Applications to Scientific Computing, </title> <editor> R. Grossman (ed.), </editor> <year> 1989, </year> <pages> 97-138. </pages>
Reference-contexts: Fidil <ref> [11] </ref> is a language designed specifically for programming these applications. It includes the particular high-level data structures and operations needed for computational fluid dynamics. The 10,000 lines of Fortran for the AMR example cited above become a few hundred lines of Fidil code.
Reference: [12] <author> E. Jungert, </author> <title> "Graqula|A visual information-flow query language for a geographical information system," </title> <journal> J. Visual Prog. </journal> <volume> 4, </volume> <year> 1993, </year> <pages> 383-401. </pages>
Reference-contexts: End-user programming. The growing ubiquity of powerful desktop computers is driving a need for computer languages that can be used by non-experts. Still in its infancy, two examples of languages developed to fill this need are Mathematica-whose programs are intended to look like mathematical assertions|and Graqula <ref> [12] </ref>, a visual language for constructing queries in a geographical information system. Despite the variety of motivations for their development, these languages have much in common in their underlying design|far more than is superficially apparent.
Reference: [13] <author> Brian W. Kernighan, Dennis M. Ritchie, </author> <title> The C Programming Language (Second Edition), </title> <publisher> Prentice-Hall, </publisher> <address> Englewood Cliffs, New Jersey, </address> <year> 1988. </year>
Reference: [14] <author> Mitch Kramer, </author> <title> "Developers find gains outweigh o-o learning curve," </title> <journal> Software Magazine 13(7) ("Client/server Computing"), </journal> <month> Nov. </month> <year> 1993, </year> <pages> 23-33. </pages>
Reference-contexts: The extent to which the programming language used affects the success of a programming project is a controversial subject, but it can be substantial. It is for this reason that so many software development managers are considering switching to object-oriented languages <ref> [14] </ref>. (It is interesting to note that, while much of the work in software engineering is language-independent, changing language paradigms has a very significant impact; thus, a popular textbook on software engineering states, "Object-oriented design representations are more prone than other to have a programming language dependency" [19, p. 425].) *
Reference: [15] <author> David A. Ladd, J. C. Ramming, </author> <title> "Switch software and software research," </title> <booktitle> Intl. Conf. on Communications Technology, </booktitle> <address> Beijiing, </address> <year> 1992. </year>
Reference-contexts: These rules are published in a document written largely in English, and their maintenance is so important that the 5ESS development team devotes approximately 250 programmers to interpreting and implementing this document. AT&T is now designing a language, called PRL5 <ref> [15] </ref>, in which population rules can be formally defined. Rules written in PRL5 can be compiled, so that much of the work of those 250 programmers will be done mechanically.
Reference: [16] <author> Wm Leler, </author> <title> Constraint Programming Languages, Their Specification and Generation, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1988. </year>
Reference-contexts: In these languages, "programming" consists of defining the basic parameters of the solution to a problem, and having the computer search for a satisfactory solution, instead of telling the computer exactly how to go about constructing a solution <ref> [16] </ref>. * Old designs for new applications. We are well past the time when languages were designed from scratch, often taking an unfortunate syntax-first approach. Much is now known about language design at a deep, semantic level.
Reference: [17] <author> James Martin, </author> <title> "Fourth-generation Languages, Volumes I, II, and III," </title> <publisher> Prentice-Hall, </publisher> <address> Engle-wood Cliffs, NJ, </address> <year> 1985. </year>
Reference-contexts: We see two areas where research in programming languages is impacting industry: * Adopting new general purpose programming languages. In the data processing world, a new class of languages is coming into use, the fourth-generation languages <ref> [17] </ref>, which add considerable power over COBOL, the traditional language in that field. Microcomputer software developers are switching to object-oriented languages (especially C++) with surprising speed. In each case, adoption of these new languages, though initially painful, has had a demonstrably positive affect on the cost and quality of software.
Reference: [18] <author> Robin Milner, </author> <title> "Elements of Interaction," 1992 Turing Award Lecture, </title> <journal> Comm. ACM 36(1), </journal> <month> Jan. </month> <year> 1993, </year> <pages> 78-89. </pages>
Reference-contexts: The central activity of the field is, and has always been, the design of new languages for new applications. Concurrent and parallel computing. Robin Milner, in his recent Turing Award address <ref> [18] </ref>, discussed the need for new design concepts in this area, stating, "Concur-rency requires a fresh approach, not merely an extension of the repertoire of entities and constructions which explain sequential computing." Most concurrent programming languages are based on an asynchronous communication model, in which programs must respond to requests at
Reference: [19] <author> Roger Pressman, </author> <title> Software Engineering, A Practitioner's Approach (3rd Ed.), </title> <publisher> McGraw-Hill, </publisher> <address> New York, </address> <year> 1992. </year>
Reference-contexts: to object-oriented languages [14]. (It is interesting to note that, while much of the work in software engineering is language-independent, changing language paradigms has a very significant impact; thus, a popular textbook on software engineering states, "Object-oriented design representations are more prone than other to have a programming language dependency" <ref> [19, p. 425] </ref>.) * Computer architecture. The fields of computer architecture and programming languages have a naturally symbiotic relationship. The C language was designed to take advantage of the minicomputers of the 1970's and has become the standard language for the microcomputers of the 80's and 90's.
Reference: [20] <author> R.V. Rubin, E.J. Golin, S.P. Reiss, "ThinkPad: </author> <title> A graphical system for programming by demonstration," </title> <booktitle> IEEE Software 2(2), </booktitle> <pages> 73-79, </pages> <year> 1985. </year>
Reference-contexts: These systems rely on the user's ability to describe that one case, from which the language processor can generalize to a complete program. (Since end users often view their problems in graphical terms, these languages are closely related to visual languages <ref> [20] </ref>.) fl Constraint languages. In these languages, "programming" consists of defining the basic parameters of the solution to a problem, and having the computer search for a satisfactory solution, instead of telling the computer exactly how to go about constructing a solution [16]. * Old designs for new applications.
Reference: [21] <author> Bill Schottstaedt, </author> <title> "Pla: A composer's idea of a language," </title> <journal> Computer Music J. </journal> <volume> 7(1), </volume> <month> Spring </month> <year> 1983, </year> <pages> 11-20. </pages>
Reference-contexts: Used to program synthesizers and other electronic instruments (usually using the MIDI interface), these languages are a major improvement over simple note entry; an example is a drumbeat, which can be programmed as a fairly simple repetition of a single note. Pla <ref> [21] </ref> and Canon [8] are two well-known examples. What is unmistakable in reviewing the evolution of these languages is that it follows a trajectory similar to that of programming languages in general, with increasing emphasis on composability, i.e. the flexible interconnection of components. * Timeless designs.
Reference: [22] <author> Nan C. Shu, </author> <title> Visual Programming, </title> <publisher> Van Nostrand Reinhold, </publisher> <year> 1988. </year>
Reference-contexts: Examples of new approaches to programming are: fl Visual programming. Since many modern computer applications are graphical, the needs of end-user programmers dictate a visual programming approach <ref> [22] </ref>, in which complex processes are described pictorially. fl Example-based programming. The central activity of programming is generalization|from a process that works for one case to one that will work for all of them.
Reference: [23] <author> J.M. Spivey, </author> <title> Understanding Z: A Specification Language and its Formal Semantics, </title> <publisher> Cambridge Univ. Press, </publisher> <year> 1988. </year>
Reference-contexts: As mentioned earlier, there are a number of semantics models of concurrent and distributed systems. What is needed now are specification languages that the "run-of-the-mill" software designer can easily use|the equivalent, for concurrency, of languages like Z <ref> [23] </ref> and Larch [10]. The specification and prediction of run-time resource utilization|including, but not limited to, CPU time. This is essential, of course, for real-time applications.
Reference: [24] <author> Stephen Wolfram, </author> <title> Mathematica (2nd ed.), </title> <publisher> Addison-Wesley, </publisher> <address> Reading, Mass., </address> <year> 1991. </year> <title> [25] "Use of `Mathematica' program spreads," The Chronicle of Higher Education, </title> <journal> Nov. </journal> <volume> 20, </volume> <year> 1991. </year>
Reference-contexts: Scientists and engineers design and use many special-purpose languages; examples include hardware description languages, simulation languages, visualization languages, and others. Also noteworthy is the increasing use of symbolic mathematics programs like Mathematica <ref> [24] </ref> and Maple [6], that have underlying programming languages which all but the most casual users must learn. Thus, new languages eventually find their way into scientific and engineering projects. Fortran is here to stay, but its importance should not be exaggerated.
References-found: 24

