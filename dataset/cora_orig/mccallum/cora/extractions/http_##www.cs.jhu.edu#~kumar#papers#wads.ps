URL: http://www.cs.jhu.edu/~kumar/papers/wads.ps
Refering-URL: http://www.cs.jhu.edu/~kumar/
Root-URL: http://www.cs.jhu.edu
Title: Topology B-Trees and Their Applications  
Author: Paul Callahan Michael T. Goodrich Kumar Ramaiyer 
Address: Baltimore, MD 21218, USA  
Affiliation: Dept. of Computer Science, The Johns Hopkins Univ.,  
Abstract: The well-known B-tree data structure provides a mechanism for dynamically maintaining balanced binary trees in external memory. We present an external-memory dynamic data structure for maintaining arbitrary binary trees. Our data structure, which we call the topology B-tree, is an external-memory analogue to the internal-memory topology tree data structure of Frederickson. It allows for dynamic expression evaluation and updates as well as various tree searching and evaluation queries. We show how to apply this data structure to a number of external-memory dynamic problems, including approximate nearest neighbor searching and closest-pair maintenance.
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> A. Aggarwal and J. S. Vitter. </author> <title> The input/output complexity of sorting and related problems. </title> <journal> Communications of the ACM, </journal> <volume> 31(9) </volume> <pages> 1116-1127, </pages> <year> 1988. </year>
Reference-contexts: 1 Introduction The B-tree [8, 12, 14, 15] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [1, 11, 13, 18, 19, 21, 22, 2] </ref>. Indeed, in his well-known survey paper [8], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [10], which is an elegant internal-memory method for maintaining unbalanced binary trees. Before we describe our results, let us review the model for external memory <ref> [1, 11, 13, 18, 19, 21, 22] </ref> that we will be assuming throughout this paper. 1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, ? This research supported
Reference: 2. <author> Lars Arge. </author> <title> The buffer tree: A new technique for optimal i/o algorithms. </title> <booktitle> In Proc. on Fourth Workshop on Algorithms and Data Structures, </booktitle> <year> 1995. </year>
Reference-contexts: 1 Introduction The B-tree [8, 12, 14, 15] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [1, 11, 13, 18, 19, 21, 22, 2] </ref>. Indeed, in his well-known survey paper [8], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees.
Reference: 3. <author> S. Arya and D. M. Mount. </author> <title> Approximate nearest neighbor queries in fixed dimensions. </title> <booktitle> In Proc. 4th ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 271-280, </pages> <year> 1993. </year>
Reference-contexts: In addition, we show that each of the operations on dynamic expression trees require O (log B N ) block i/o's 2 . Finally, using these primitives, we design optimal external-memory methods for dynamically solving the following geometric problems: Approximate nearest neighbor <ref> [3, 4] </ref>: given a set S of points in IR d , for fixed d, a query point p, a metric L t , and a parameter *, find a point q in S that is within distance at most (1 + *) times the distance of the actual nearest neighbor <p> Our goal is to come up with a data structure to answer this approximate nearest neighbor query, and to maintain the data structure under the operations of insertion and deletion of points in S. Arya and Mount <ref> [3] </ref> first presented a (static) linear-space data structure for the approximate nearest neighbor problem that answered queries in O (log 3 N ) time, which was later improved by Arya et al. [4] to O (log N ) time and also made dynamic.
Reference: 4. <author> S. Arya, D. M. Mount, N. S. Netanyahu, R. Silverman, and A. Wu. </author> <title> An optimal algorithm for approximate nearest neighbor searching. </title> <booktitle> In Proc. 5th ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 573-582, </pages> <year> 1994. </year>
Reference-contexts: In addition, we show that each of the operations on dynamic expression trees require O (log B N ) block i/o's 2 . Finally, using these primitives, we design optimal external-memory methods for dynamically solving the following geometric problems: Approximate nearest neighbor <ref> [3, 4] </ref>: given a set S of points in IR d , for fixed d, a query point p, a metric L t , and a parameter *, find a point q in S that is within distance at most (1 + *) times the distance of the actual nearest neighbor <p> Arya and Mount [3] first presented a (static) linear-space data structure for the approximate nearest neighbor problem that answered queries in O (log 3 N ) time, which was later improved by Arya et al. <ref> [4] </ref> to O (log N ) time and also made dynamic. All the previous work on this problem is for the internal memory model. We give a brief outline of their method here. The set of points in S in d dimensions is partitioned into boxes of "good" aspect ratio. <p> The tree of boxes can have linear depth in the worst case. But a topology tree is constructed on top of it to obtain a balanced structure. The algorithm of Arya et. al. <ref> [4] </ref> can be characterized as a method that performs constant number of point location queries on the topology tree constructed, maintaining the closest point found so far. This observation helps us to "externalize" the algorithm.
Reference: 5. <author> Sergei N. Bespamyatnikh. </author> <title> An optimal algorithm for closest pair maintenance. </title> <booktitle> In Proceedings 11th Annual Symposium on Computational Geometry, </booktitle> <year> 1995. </year>
Reference-contexts: We support this query under the operations of insertion and deletion of points in S. Closest pair <ref> [6, 5] </ref>: given a set S of points in IR d , for fixed d, find a pair of points in S which are the closest among all pairs of points in S under the Euclidean distance metric. We support this operation under insertion and deletion of points from S. <p> We can also update the data structure using O (log B N ) i/o's, during the operations of insertion and deletion of points. We give the details in the full version. 6.2 Dynamic Closest Pair Recently, Bespamyatnikh <ref> [5] </ref> has developed an algorithm to maintain the closest pair of points in a point set S in optimal worst case O (log N ) time for insertions and deletions. The space requirement is linear in N . <p> This is necessary for determining when new pairs must be added to E to account for the deletion of some point. Bespamyatnikh has shown that the size of A (v) is constant. Intuitively, this follows from conditions 2 and 3, which allow us to apply a packing argument. See <ref> [5] </ref> for a proof that these two operations are sufficient. The above searches can be reduced to an invocation of an approximate nearest neighbor search of the preceding section and a search defined in [6] in which we construct a ffi-rendering of a given d-cube C, denoted ffi (C). <p> It follows that the above operations can be performed in O (log B N ) i/o's. We use standard B-trees to implement heap maintenance in the same i/o complexity. Combining this with the result of <ref> [5] </ref>, we obtain an algorithm for closest-pair maintenance using O (log B N ) i/o's. 7 Conclusions We give an efficient method for maintaining arbitrary rooted binary trees in external memory in a dynamic fashion.
Reference: 6. <author> P. B. Callahan and S. R. Kosaraju. </author> <title> Algorithms for dynamic closest pair and n-body potential fields. </title> <booktitle> In Proc. 6th ACM-SIAM Symp. on Discrete Algorithms, </booktitle> <pages> pages 263-272, </pages> <year> 1995. </year>
Reference-contexts: We support this query under the operations of insertion and deletion of points in S. Closest pair <ref> [6, 5] </ref>: given a set S of points in IR d , for fixed d, find a pair of points in S which are the closest among all pairs of points in S under the Euclidean distance metric. We support this operation under insertion and deletion of points from S. <p> The space requirement is linear in N . We adapt his algorithm to the present framework in order to externalize it, using the same box decomposition used in the preceding section for computing approximate nearest neighbor queries. Callahan and Kosaraju <ref> [6] </ref> have shown how to maintain such a box decomposition of S under point insertions and deletions using only algebraic operations. In the present framework, this box decomposition corresponds to the tree T 0 in which each node v is labeled by a rectangle R (v). <p> Bespamyatnikh maintains a linear-size subset E of the set of distinct pairs of S such that E is guaranteed to contain the closest pair. As in the O (log 2 N ) algorithm of <ref> [6] </ref>, which solves a more general class of dynamic problems, these pairs are then maintained on a heap, resulting in the maintenance of the closest pair. The set E must satisfy certain invariants, which we now recast in the terminology of Callahan and Kosaraju [6]. <p> (log 2 N ) algorithm of <ref> [6] </ref>, which solves a more general class of dynamic problems, these pairs are then maintained on a heap, resulting in the maintenance of the closest pair. The set E must satisfy certain invariants, which we now recast in the terminology of Callahan and Kosaraju [6]. <p> See [5] for a proof that these two operations are sufficient. The above searches can be reduced to an invocation of an approximate nearest neighbor search of the preceding section and a search defined in <ref> [6] </ref> in which we construct a ffi-rendering of a given d-cube C, denoted ffi (C). Intuitively, ffi (C) is an approximate covering of the points in C using a constant number of rectangles from T 0 .
Reference: 7. <author> R. F. Cohen and R. Tamassia. </author> <title> Dynamic expression trees and their applications. </title> <booktitle> In Proc. 2nd ACM-SIAM Sympos. Discrete Algorithms, </booktitle> <pages> pages 52-61, </pages> <year> 1991. </year>
Reference-contexts: Nevertheless, there are many applications that operate on unbalanced binary trees. In this paper we describe a data structure, which we call the topology B-tree, for maintaining unbalanced binary trees in external memory. We allow for dynamic expression updates <ref> [7] </ref> and we consider a number of tree-search queries on arbitrary binary trees, which in turn can be used to solve a number of dynamic external-memory problems, including approximate nearest-neighbor searching and closest-pair maintenance.
Reference: 8. <author> D. Comer. </author> <title> The ubiquitous B-tree. </title> <journal> ACM Comput. Surv., </journal> <volume> 11 </volume> <pages> 121-137, </pages> <year> 1979. </year>
Reference-contexts: 1 Introduction The B-tree <ref> [8, 12, 14, 15] </ref> data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory [1, 11, 13, 18, 19, 21, 22, 2]. Indeed, in his well-known survey paper [8], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. <p> 1 Introduction The B-tree [8, 12, 14, 15] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory [1, 11, 13, 18, 19, 21, 22, 2]. Indeed, in his well-known survey paper <ref> [8] </ref>, Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. In this paper we describe a data structure, which we call the topology B-tree, for maintaining unbalanced binary trees in external memory.
Reference: 9. <author> G. N. Frederickson. </author> <title> Ambivalent data structures for dynamic 2-edge connectivity and k-smallest spanning trees. </title> <booktitle> In Proc. 32nd Annu. IEEE Sympos. Found. Com-put. Sci., </booktitle> <pages> pages 632-641, </pages> <year> 1991. </year>
Reference-contexts: Based upon these clustering rules, it is fairly straightforward to show that the number of levels in a topology tree is O (log N ), where N is the number of nodes in the base tree T . Freder-ickson <ref> [9] </ref> proves the following (stronger) lemma which relates the number of clusters at one level with the previous level: Lemma 1. [9] For any level l &gt; 0 in a topology tree, the number of clusters at level l is at most 5=6 of the number of clusters at level l <p> Freder-ickson <ref> [9] </ref> proves the following (stronger) lemma which relates the number of clusters at one level with the previous level: Lemma 1. [9] For any level l &gt; 0 in a topology tree, the number of clusters at level l is at most 5=6 of the number of clusters at level l 1. 2.1 Implementation of Primitives on Topology Tree In this section, we discuss how to implement the dynamic operations on the
Reference: 10. <author> G. N. Frederickson. </author> <title> A data structure for dynamically maintaining rooted trees. </title> <booktitle> In Proc. 4th ACM-SIAM Symp. on Discrete Algorithms (SODA), </booktitle> <pages> pages 175-184, </pages> <year> 1993. </year>
Reference-contexts: The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson <ref> [10] </ref>, which is an elegant internal-memory method for maintaining unbalanced binary trees. <p> Our query algorithms all use an optimal O (log B N ) external-memory i/o's. 2 The Topology Tree Data Structure Before we describe our data structure in detail, however, let us first review the structure of the topology tree <ref> [10] </ref>, and discuss how to implement insertion and 1 Personal communication. 2 We use the notation O (:) to describe amortized complexity. deletion of nodes, a generalized deepest-intersection search, and the evaluation of arithmetic expressions. <p> Our methods are very similar to those of Frederickson <ref> [10] </ref>, but simpler, since we consider here only a subset of the operations he considers. <p> This operation evaluates the arithmetic expression represented by the subtree T v rooted at v in T . Our implementation of the insert, delete, and swap operations is similar to Frederickson <ref> [10] </ref>. We implement these operations using constant number of reclustering operations i.e., removal of clusters along a root-to-leaf path in T , and performing the clustering again. The complexity of reclustering operation is O (log N ) as shown in the following lemma: Lemma 2.
Reference: 11. <author> Michael T. Goodrich, Jyh-Jong Tsay, Darren E. Vengroff, and Jeffrey Scott Vitter. </author> <title> External-memory computational geometry. </title> <booktitle> In Proc. 34th Annu. IEEE Sympos. Found. Comput. Sci. (FOCS 93), </booktitle> <pages> pages 714-723, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction The B-tree [8, 12, 14, 15] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [1, 11, 13, 18, 19, 21, 22, 2] </ref>. Indeed, in his well-known survey paper [8], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [10], which is an elegant internal-memory method for maintaining unbalanced binary trees. Before we describe our results, let us review the model for external memory <ref> [1, 11, 13, 18, 19, 21, 22] </ref> that we will be assuming throughout this paper. 1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, ? This research supported
Reference: 12. <author> O. Gunther and H.-J. Schek. </author> <title> Advances in spatial databases. </title> <booktitle> In Proc. 2nd Symposium, SSD '91, volume 525 of Lecture Notes in Computer Science. </booktitle> <publisher> Springer-Verlag, </publisher> <year> 1991. </year>
Reference-contexts: 1 Introduction The B-tree <ref> [8, 12, 14, 15] </ref> data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory [1, 11, 13, 18, 19, 21, 22, 2]. Indeed, in his well-known survey paper [8], Comer calls B-trees "ubiquitous," for they are found in a host of different applications.
Reference: 13. <author> P. C. Kanellakis, S. Ramaswamy, D. E. Vengroff, and J. S. Vitter. </author> <title> Indexing for data models with constraints and classes. </title> <booktitle> In Proc. 12th ACM SIGACT-SIGMOD-SIGART Conf. Princ. Database Sys., </booktitle> <pages> pages 233-243, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction The B-tree [8, 12, 14, 15] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [1, 11, 13, 18, 19, 21, 22, 2] </ref>. Indeed, in his well-known survey paper [8], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [10], which is an elegant internal-memory method for maintaining unbalanced binary trees. Before we describe our results, let us review the model for external memory <ref> [1, 11, 13, 18, 19, 21, 22] </ref> that we will be assuming throughout this paper. 1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, ? This research supported
Reference: 14. <author> Robert Laurini and Derek Thompson. </author> <title> Fundamentals of Spatial Information Systems. A.P.I.C. Series. </title> <publisher> Academic Press, </publisher> <year> 1992. </year>
Reference-contexts: 1 Introduction The B-tree <ref> [8, 12, 14, 15] </ref> data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory [1, 11, 13, 18, 19, 21, 22, 2]. Indeed, in his well-known survey paper [8], Comer calls B-trees "ubiquitous," for they are found in a host of different applications.
Reference: 15. <author> D. Maier and S. C. Salveter. </author> <title> Hysterical B-trees. </title> <journal> Information Processing Letters, </journal> <volume> 12(4) </volume> <pages> 199-202, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction The B-tree <ref> [8, 12, 14, 15] </ref> data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory [1, 11, 13, 18, 19, 21, 22, 2]. Indeed, in his well-known survey paper [8], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. <p> When we split (merge) blocks the pointers get added (removed) to (from) the blocks in the next B-list which may require further spliting (merging). We can do update operations on hierarchical B-lists as in hysterical B-trees <ref> [15] </ref>. We give the details in full version. In ungoverned hierarchical B-lists, during spliting and merging we may need to perform O (B) pointer changes, since we need to add new up pointers to parent blocks. But using a result of hysterical B-trees [15], we can prove that the number of <p> on hierarchical B-lists as in hysterical B-trees <ref> [15] </ref>. We give the details in full version. In ungoverned hierarchical B-lists, during spliting and merging we may need to perform O (B) pointer changes, since we need to add new up pointers to parent blocks. But using a result of hysterical B-trees [15], we can prove that the number of pointer changes during a split or merge is O (1). We now consider hierarchical B-lists consisting of O (log B N ) B-lists, which we can easily show as requiring a storage of O (N=B) i/o blocks.
Reference: 16. <author> J. Matousek. </author> <title> Reporting points in halfspaces. </title> <journal> Comput. Geom. Theory Appl., </journal> <volume> 2(3) </volume> <pages> 169-186, </pages> <year> 1992. </year>
Reference: 17. <author> D. Mount and S. Arya. </author> <title> Approximate range searching. </title> <booktitle> In Proc. 11th ACM Symp. on Computational Geometry, </booktitle> <year> 1995. </year>
Reference-contexts: We show how to perform the dynamic expression tree updates and how these can be applied to solve some interesting dynamic computational geometry problems in external memory. We believe there are other applications, as well, such as approximate range searching <ref> [17] </ref>. Acknowledgements We would like to thank David Mount for several helpful discussions concerning the topics of this paper.
Reference: 18. <author> M. H. Nodine, M. T. Goodrich, and J. S. Vitter. </author> <title> Blocking for external graph searching. </title> <booktitle> In Proceedings of the 12th Annual ACM Symposium on Principles of Database Systems (PODS '93), </booktitle> <pages> pages 222-232, </pages> <year> 1993. </year>
Reference-contexts: 1 Introduction The B-tree [8, 12, 14, 15] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [1, 11, 13, 18, 19, 21, 22, 2] </ref>. Indeed, in his well-known survey paper [8], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [10], which is an elegant internal-memory method for maintaining unbalanced binary trees. Before we describe our results, let us review the model for external memory <ref> [1, 11, 13, 18, 19, 21, 22] </ref> that we will be assuming throughout this paper. 1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, ? This research supported
Reference: 19. <author> M. H. Overmars, M. H. M. Smid, M. T. de Berg, and M. J. van Kreveld. </author> <title> Maintaining range trees in secondary memory, part I: partitions. </title> <journal> Acta Inform., </journal> <volume> 27 </volume> <pages> 423-452, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction The B-tree [8, 12, 14, 15] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [1, 11, 13, 18, 19, 21, 22, 2] </ref>. Indeed, in his well-known survey paper [8], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [10], which is an elegant internal-memory method for maintaining unbalanced binary trees. Before we describe our results, let us review the model for external memory <ref> [1, 11, 13, 18, 19, 21, 22] </ref> that we will be assuming throughout this paper. 1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, ? This research supported
Reference: 20. <author> W. Pugh. </author> <title> Skip lists: A probabilistic alternative to balanced trees. </title> <journal> Communications of the ACM, </journal> <volume> 33(6) </volume> <pages> 668-676, </pages> <year> 1990. </year>
Reference-contexts: This structure is motivated by the skip list structure of Pugh <ref> [20] </ref>. The hierarchical B-list consists of a hierarchy of B-lists in which only the blocks of adjacent B-lists are connected. We assign a level to each B-list, and the level numbers increase from bottom to the top of the hierarchy.
Reference: 21. <author> M. H. M. Smid and M. H. Overmars. </author> <title> Maintaining range trees in secondary memory, part II: lower bounds. </title> <journal> Acta Inform., </journal> <volume> 27 </volume> <pages> 453-480, </pages> <year> 1990. </year>
Reference-contexts: 1 Introduction The B-tree [8, 12, 14, 15] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [1, 11, 13, 18, 19, 21, 22, 2] </ref>. Indeed, in his well-known survey paper [8], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [10], which is an elegant internal-memory method for maintaining unbalanced binary trees. Before we describe our results, let us review the model for external memory <ref> [1, 11, 13, 18, 19, 21, 22] </ref> that we will be assuming throughout this paper. 1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, ? This research supported
Reference: 22. <author> J. S. Vitter. </author> <title> Efficient memory access in large-scale computation. </title> <booktitle> In 1991 Symposium on Theoretical Aspects of Computer Science (STACS), Lecture Notes in Computer Science,, </booktitle> <address> Hamburg, </address> <year> 1991. </year> <title> Springer-Verlag. This article was processed using the L a T E X macro package with LLNCS style </title>
Reference-contexts: 1 Introduction The B-tree [8, 12, 14, 15] data structure is a very efficient and powerful way for maintaining balanced binary trees in external memory <ref> [1, 11, 13, 18, 19, 21, 22, 2] </ref>. Indeed, in his well-known survey paper [8], Comer calls B-trees "ubiquitous," for they are found in a host of different applications. Nevertheless, there are many applications that operate on unbalanced binary trees. <p> The topology B-tree is an external memory analogue to the topology tree data structure of Frederickson [10], which is an elegant internal-memory method for maintaining unbalanced binary trees. Before we describe our results, let us review the model for external memory <ref> [1, 11, 13, 18, 19, 21, 22] </ref> that we will be assuming throughout this paper. 1.1 The External-Memory Model We assume that the external-memory device (e.g., a disk) is structured so that seek time is much larger than the time needed to transfer a single record; hence, ? This research supported
References-found: 22

