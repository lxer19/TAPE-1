URL: http://www.cs.iastate.edu/tech-reports/TR94-09.ps
Refering-URL: http://www.cs.iastate.edu/tech-reports/catalog.html
Root-URL: http://www.cs.iastate.edu
Title: Reliable General Purpose Dynamic Memory Management for Real-Time Systems TR94-09  
Author: Hong Gao, Kelvin Nilsen 
Address: 226 Atanasoff Ames, IA 50011  
Affiliation: Iowa State University of Science and Technology Department of Computer Science  
Date: July 14, 1994  
Abstract-found: 0
Intro-found: 0
Reference: 1. <author> B. Zorn and D. Grunwald, </author> <title> Evaluating Models of Memory Allocation, </title> <booktitle> ACM Transactions on Modeling and Computer Simulation 4, </booktitle> <month> 1 (Jan </month> <year> 1994), </year> . 
Reference-contexts: The new and delete operators invoke type-specific constructor and destructor functions when allocating and reclaiming dynamic memory respectively. C++'s new and delete implementations are generally implemented using C's malloc and free functions, for which numerous alternative implementations exist <ref> [1, 2] </ref>. In general, the various implementations offer a range of performance, with the most space efficient implementations running quite a bit slower than implementations that are more extravagant in their use of memory. <p> But it is rare in practice for high-performance memory managers to achieve 100% utilization of memory. Rather, typical memory utilizations range from 17 to 85% <ref> [1] </ref>. Cost comparisons between the hardware-assisted memory manager and traditional memory management techniques must take these factors into account. Our system garbage collects all of the objects allocated within the C++ dynamic heap without requiring any changes to C++ syntax.
Reference: 2. <author> D. Grunwald and B. Zorn, </author> <title> CustoMalloc: Efficient Synthesized Memory Allocators, </title> <institution> University of Colorado Tech. </institution> <type> Rep. </type> <institution> CU-CS-602-92, </institution> <month> July </month> <year> 1992. </year>
Reference-contexts: The new and delete operators invoke type-specific constructor and destructor functions when allocating and reclaiming dynamic memory respectively. C++'s new and delete implementations are generally implemented using C's malloc and free functions, for which numerous alternative implementations exist <ref> [1, 2] </ref>. In general, the various implementations offer a range of performance, with the most space efficient implementations running quite a bit slower than implementations that are more extravagant in their use of memory.
Reference: 3. <author> G. E. Collins, </author> <title> ``A Method for Overlapping and Erasure of Lists'', </title> <journal> Comm. ACM 3, </journal> <month> 1 2 (Dec </month> <year> 1960), </year> <pages> 655-657. </pages>
Reference-contexts: Howev er, the order in which program components overwrite their pointers to shared objects likely depends on a variety of dynamic factors. Therefore, programmers must implement some form of dynamic bookkeeping to determine when it is safe to reclaim the memory allocated to particular dynamic objects. Reference counting <ref> [3] </ref> is the most commonly used technique for automatic reclamation of dead heap memory in real-time systems.
Reference: 4. <author> J. Weizenbaum, </author> <title> ``Symmetric List Processor'', </title> <journal> Comm. ACM 6, </journal> <month> 9 (Sep. </month> <year> 1963), </year> <pages> 524-544. </pages>
Reference-contexts: Thus, the time required to place an object onto the free list in traditional reference counting systems is unbounded. In order to support real-time constraints, pointers contained within free objects are overwritten with zero when the object is reallocated instead of when the object is reclaimed <ref> [4] </ref>. Therefore, the worst-case time required to perform a pointer assignment is the time required to adjust two reference counts and to link a dead object onto the appropriate free list.
Reference: 5. <author> D. E. Knuth, </author> <title> The Art of Computer Programming, Volume I: Fundamental algorithms, </title> <publisher> Addison-Wesley, </publisher> <year> 1973. </year>
Reference-contexts: When an object is freed, the size index is calculated and the block is linked onto the appropriate free list. KNUTH: This allocator, implemented by Mark Moraes, uses the first-fit strategy described by Knuth <ref> [5] </ref>. In this algorithm, free blocks are connected together in a doubly-linked free list that is scanned during allocation for the first free block that is sufficiently large to satisfy an allocation request.
Reference: 6. <author> P. Rovner, </author> <title> On Adding Garbage Collection and Runtime Types to a Strongly-Typed Statically-Checked, Concurrent Language, </title> <type> CSL-84-7, </type> <institution> Xerox Palo Alto Research Center, </institution> <year> 1984. </year>
Reference-contexts: The application becomes confused because the dynamic memory manager reallocates an object that was erro neously placed onto its free list. Thereafter, the memory serves two different purposes. Rovner <ref> [6] </ref> estimates that the programming effort required to perform dynamic memory management is approximately 40% of the total cost of developing a large software system. This includes both the costs of developing and of debugging the memory management routines.
Reference: 7. <author> C. Chambers, </author> <title> Cost of Garbage Collection in the SELF System, </title> <booktitle> 1991 Workshop on Garbage Collection in Object-Oriented Systems of OOPSLA, </booktitle> <address> Phoenix, AZ, </address> <month> Oct </month> <year> 1991. </year>
Reference-contexts: Incremental garbage collectors allow application processing to continue while garbage collection is performed. But the frequent synchronization that is required between background garbage collection activities and ongoing application processing significantly reduces system throughput <ref> [7, 8] </ref>.
Reference: 8. <author> K. Nilsen, </author> <title> ``Garbage Collection of Strings and Linked Data Structures in Real Time'', </title> <journal> SoftwarePractice & Experience 18, </journal> <month> 7 (July </month> <year> 1988), </year> <pages> 613-640. </pages>
Reference-contexts: Incremental garbage collectors allow application processing to continue while garbage collection is performed. But the frequent synchronization that is required between background garbage collection activities and ongoing application processing significantly reduces system throughput <ref> [7, 8] </ref>. <p> It is important for these operations to be time-bounded so that the worst-case time required to execute real-time tasks that invoke these operations can be determined through static analysis. Though a number of incremental garbage collection techniques have been developed <ref> [8, 12-17] </ref>, the best worst-case latencies available from garbage collectors built on stock hardware (without special hardware assists such as the ones described in this paper) range from 500 msec to several msec [18-20].
Reference: 9. <author> A. Goldberg and D. Robson, </author> <title> Smalltalk-80: The Language and its Implementation, </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: One other significant overhead associated with most garbage-collection systems is the effort required to tag data stored within the garbage-collected heap so that the garbage collector can traverse live data structures 1 dynamically typed languages, like Smalltalk <ref> [9] </ref> and Icon [10], all data structures are generally tagged to support dynamic type checking, so the tags required for garbage collection are available without any additional run-time overhead.
Reference: 10. <author> R. E. Griswold and M. T. Griswold, </author> <title> The Icon Programming Language, </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1983. </year>
Reference-contexts: One other significant overhead associated with most garbage-collection systems is the effort required to tag data stored within the garbage-collected heap so that the garbage collector can traverse live data structures 1 dynamically typed languages, like Smalltalk [9] and Icon <ref> [10] </ref>, all data structures are generally tagged to support dynamic type checking, so the tags required for garbage collection are available without any additional run-time overhead.
Reference: 11. <author> W. J. Schmidt, </author> <title> Issues in the Design and Implementation of a Real-Time Garbage Collection Architecture, </title> <type> Ph.D. Dissertation, </type> <institution> Iowa State Univ. </institution> <type> Tech. Rep. </type> <pages> 92-25, </pages> <year> 1992. </year>
Reference-contexts: However, in s tatically typed languages such as C++, the burden of tagging data using naive techniques in order to support garbage collection has been measured to nearly double the execution time of many real programs <ref> [11] </ref>. For a combination of these reasons, many dev elopers feel that garbage collection is a luxury they simply cannot afford. Real-time garbage collectors must honor tight upper bounds on the duration of time during which they might suspend execution of application processing.
Reference: 12. <author> H. G. Baker Jr., </author> <title> ``List Processing in Real Time on a Serial Computer'', </title> <journal> Comm. ACM 21, </journal> <month> 4 (Apr. </month> <year> 1978), </year> <pages> 280-293. </pages>
Reference: 13. <author> D. Ungar, </author> <title> Generation Scavenging: A Non-disruptive High Performance Storage Reclamation Algorithm, </title> <journal> SIG-PLAN Notices 19, </journal> <month> 5 (May </month> <year> 1984), </year> <pages> 157-167. </pages>
Reference: 14. <author> T. W. Christopher, </author> <title> ``Reference Count Garbage Collection'', </title> <journal> SoftwarePractice & Experience 14(1984), </journal> <pages> 503-507. </pages>
Reference: 15. <author> H. Boehm, A. J. Demers and S. Shenker, </author> <title> ``Mostly Parallel Garbage Collection'', </title> <booktitle> ACM SIGPLAN Notices Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1991. </year>
Reference: 16. <author> T. Yuasa, </author> <title> Real-Time Garbage Collection on General-Purpose Machines, </title> <journal> Journal of Systems and Software 11(1990), </journal> <pages> 181-198. </pages>
Reference: 17. <author> S. Nettles, J. O'Toole, D. Pierce and N. Haines, </author> <title> Replication-Based Incremental Copying Collection, in Memory Management, </title> <editor> Y. Bekkers and J. Cohen (ed.), </editor> <publisher> Springer-Verlag , 1992, </publisher> <pages> 357-364. </pages>
Reference: 18. <author> S. L. Engelstad and J. E. Vandendorpe, </author> <title> Automatic Storage Management for Systems with Real-Time Constraints, </title> <booktitle> Oral presentation at 1991 Workshop on Garbage Collection in Object-Oriented Systems of OOPSLA, </booktitle> <address> Phoenix, AZ, </address> <month> Oct </month> <year> 1991. </year>
Reference: 19. <author> R. Johnson, </author> <title> Reducing the Latency of a Real-Time Garbage Collector, </title> <journal> ACM Letters on Pro g. Lang. and Systems 1, </journal> <month> 1 (Mar </month> <year> 1992), </year> <pages> 46-58. </pages>
Reference: 20. <author> J. R. Ellis, K. Li and A. W. Appel, </author> <title> ``Real-time Concurrent Collection on Stock Multiprocessors'', </title> <booktitle> ACM SIG-PLAN Notices Conference on Programming Language Design and Implementation, </booktitle> <month> June </month> <year> 1988. </year>
Reference: 21. <author> K. Nilsen, </author> <title> Cost-Effective Hardware-Assisted Real-Time Garbage Collection, ACM S IGPLAN Notices Workshop on Language, Compiler, and Tool Support for Real-Time Systems , June 1994. </title>
Reference-contexts: This can 2 We hav e recently redesigned the hardware-assisted memory module so that it supports a hybrid garbage collection algorithm that collects garbage in certain regions using incremental mark-and-sweep methods and collects garbage in other regions using real-time copying techniques <ref> [21] </ref>. Though we have not yet measured this new algorithm's throughput, we expect that overall performance will be roughly equivalent, if not superior, to the fully copying real-time garbage collection technique that we have already measured. <p> We hav e recently designed a hybrid defragmenting real-time garbage collector that garbage collects one portion of memory using the copying technique described in this paper, and garbage collects the remaining memory using an incremental mark and sweep technique <ref> [21] </ref>. Unlike the current design, which can allocate at most one half of the total heap, the new design allows the allocator to allocate up to ( N - 1 ) of the heap, where N is an integer number typically in the range from 2 to 16. <p> Currently, we are working to develop a hardware prototype of the proposed memory architecture <ref> [21] </ref> and an optimizing C++ compiler for the target system. Av ailability of this prototype system will greatly expand the domain of real-time applications that we can effectively analyze. 7.
Reference: 22. <author> K. Nilsen, </author> <title> Reliable Real-Time Garbage Collection of C++, </title> <booktitle> Computing Systems 6, </booktitle> <month> 4 (Fall </month> <year> 1994), </year> . 
Reference: 23. <author> K. D. Nilsen and W. J. Schmidt, </author> <title> A High-Performance Hardware-Assisted Real-Time Garbage Collection System, </title> <journal> Journal of Programming Languages, </journal> <note> To appear. -14- </note>
Reference-contexts: In either case, analysis of the real-time workload must account for the occasional delay imposed by the ip operation. Flips are always separated by the time required to perform a complete garbage collection. With typical work-loads, the time between ips is no less than 10 seconds <ref> [23] </ref>. By analyzing the dynamic memory allocation behavior of an application, as discussed below, it i s possible to guarantee a minimum time separation between ips. <p> It is important to recognize that Table 5.2 reports worst-case measured execution times. For most of the explicit memory management techniques, it is not practical to analytically derive the worst-case times required to service allocation requests. In contrast, proofs of real-time performance have been demonstrated for the garbage-collector's allocator <ref> [23] </ref>.
Reference: 24. <author> W. J. Schmidt and K. D. Nilsen, </author> <title> Performance of a Hardware-Assisted Real-Time Garbage Collector, </title> <booktitle> Sixth International Conference on Architectural Support for Programming Languages and Operating Systems, Submitted. </booktitle>
Reference-contexts: Instead, allow greater amounts of allocation during the early phases of garbage collection, and lesser amounts during the later phases. The total amount of allocation permitted during garbage collection is the same, but this technique allows improved average-case performance by reducing the need to stall the application <ref> [24] </ref>. This technique is described in greater detail in reference 23. 3. Assume that the application is known never to retain more than N bytes of live memory, and that the application is known never to allocate a total of more than A bytes within any time period U .
Reference: 25. <author> J. Hennessy and D. Patterson, </author> <title> Computer Architecture: A Quantitative Approach, </title> <publisher> Morgan Kaufmann Publishers, Inc., </publisher> <year> 1990. </year>
Reference-contexts: We hav e modified the dlxsim architectural simulator for the hypothetical DLX architecture <ref> [25] </ref> so that it simulates instruction and data caches, and a GCMM. Additionally, we hav e modified an implementation of the GNU C++ compiler, version 1.31.1, so that it generates code that communicates with the GCMM for all dynamic memory management.
Reference: 26. <author> H. Gao, </author> <title> Comparative Performance of a Hardware-Assisted Real-Time Garbage Collector for C++, </title> <type> Master's Thesis, </type> <year> 1994. </year>
References-found: 26

