URL: ftp://ftp.cs.indiana.edu/pub/techreports/TR389.ps.Z
Refering-URL: http://www.cs.indiana.edu/trindex.html
Root-URL: 
Title: Behavior Tables: A Basis for System Representation and Transformational System Synthesis  
Author: Kamlesh Rath, M. Esen Tuna, and Steven D. Johnson 
Note: To appear in the proceedings of the 1993 IEEE/ACM International Conference on Computer-Aided Design (ICCAD '93 Santa Clara, California, November, 1993.  
Date: 389  august 1993  
Affiliation: indiana university computer science department  
Pubnum: technical report no.  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> H. Trickey, "Flamel: </author> <title> A high-level hardware compiler," </title> <booktitle> in TCAD 1987, </booktitle> <pages> pp. 259-269, </pages> <publisher> IEEE, </publisher> <month> Mar. </month> <year> 1987. </year>
Reference-contexts: Along with the global view of a design, behavior tables can also provide abstract views of a design. A table form can be a useful visual output for a designer to interact with the design tool. Many design automation systems use graph based structures for design representation <ref> [1, 2, 3] </ref>, which are suited for either control-flow or data-flow representation.
Reference: [2] <author> D. E. Thomas, E. M. Dirkes, R. A. Walker, J. V. Ra-jan, J. A. Nestor, and R. L. Blackburn, </author> <title> "The system architect's workbench," </title> <booktitle> in Proceedings of 25th DAC, </booktitle> <year> 1988. </year>
Reference-contexts: Along with the global view of a design, behavior tables can also provide abstract views of a design. A table form can be a useful visual output for a designer to interact with the design tool. Many design automation systems use graph based structures for design representation <ref> [1, 2, 3] </ref>, which are suited for either control-flow or data-flow representation.

Reference: [4] <author> Z. Peng, </author> <title> A Formal Methodology for Automated Synthesis of VLSI Systems. </title> <type> PhD thesis, </type> <institution> Linkoping University, Sweden, </institution> <year> 1987. </year>
Reference-contexts: Petri-net based internal representations are fl Research reported herein was supported, in part, by NSF, under grants numbered MIP 89-21842 and MIP 92-08745. y Email: rathk@cs.indiana.edu also suited for control-flow representation but are not useful for data-flow representation <ref> [4] </ref>. A hierarchical design representation (e.g [5]) can not effectively represent orthogonal facets of a system. Behavior tables provide a unified representation on which transformations on different facets of a design can be performed.
Reference: [5] <author> M. R. K. Patel, </author> <title> "A design representation for high level synthesis," </title> <booktitle> in Proceedings of EDAC, </booktitle> <year> 1990. </year>
Reference-contexts: Petri-net based internal representations are fl Research reported herein was supported, in part, by NSF, under grants numbered MIP 89-21842 and MIP 92-08745. y Email: rathk@cs.indiana.edu also suited for control-flow representation but are not useful for data-flow representation [4]. A hierarchical design representation (e.g <ref> [5] </ref>) can not effectively represent orthogonal facets of a system. Behavior tables provide a unified representation on which transformations on different facets of a design can be performed.
Reference: [6] <author> F. Vahid and D. D. Gajski, </author> <title> "Specification partitioning for system design," </title> <booktitle> in Proceedings of 29th DAC, </booktitle> <year> 1992. </year>
Reference-contexts: Behavior tables can be decomposed into interacting sequential components using a general transformation that takes the protocol specification between components as a parameter. These components can be independently synthesized or mapped to off-the-shelf components. SpecPart <ref> [6] </ref> partitions algorithm/process grained computations from the SpecChart specifications using default protocols. The CHOP system-level design partitioner [7] uses special purpose modules on both sides of every interaction. Partitioning in the System Architect's Workbench is accomplished by behavioral transformations using a very simple message passing protocol.
Reference: [7] <author> K. Ku~cuk~cakar and A. C. Parker, "CHOP: </author> <title> A constraint-driven system-level partitioner," </title> <booktitle> in Pro ceedings of 28th DAC, </booktitle> <year> 1991. </year>
Reference-contexts: These components can be independently synthesized or mapped to off-the-shelf components. SpecPart [6] partitions algorithm/process grained computations from the SpecChart specifications using default protocols. The CHOP system-level design partitioner <ref> [7] </ref> uses special purpose modules on both sides of every interaction. Partitioning in the System Architect's Workbench is accomplished by behavioral transformations using a very simple message passing protocol. All these approaches are limited by the interaction protocols supported by the partitioning methods.
Reference: [8] <author> S. D. Johnson, </author> <title> Synthesis of Digital Designs from Re cursion Equations. </title> <publisher> Cambridge: MIT Press, </publisher> <year> 1984. </year>
Reference-contexts: Behavior tables also provide a mechanism to change levels of data abstraction. The research reported here grew out of our existing design derivation system, which is based on first order functional algebra <ref> [8, 9] </ref>. 2 Behavior Tables A behavior table is a representation for a finite state machine that models system behavior. Each row in a behavior table represents a transition in the machine described by the table. The columns are divided into two sections, the decision section and the action section.
Reference: [9] <author> S. D. Johnson, </author> <title> "Manipulating logical organization with system factorizations," in Hardware Specifica tion, Verification and Synthesis: Mathematical As pects, </title> <publisher> LNCS 408, Springer, </publisher> <year> 1989. </year>
Reference-contexts: Behavior tables also provide a mechanism to change levels of data abstraction. The research reported here grew out of our existing design derivation system, which is based on first order functional algebra <ref> [8, 9] </ref>. 2 Behavior Tables A behavior table is a representation for a finite state machine that models system behavior. Each row in a behavior table represents a transition in the machine described by the table. The columns are divided into two sections, the decision section and the action section. <p> Other control and datapath transformations are described in [11, 12]. 4 Sequential Decomposition Sequential decomposition is a generalization of factorization <ref> [9] </ref> to include protocols between components of a system. A behavior table can be decomposed into interacting behavior tables using a protocol specification with non-trivial control synchronization and data transfer interactions between components.
Reference: [10] <author> W. A. Hunt, </author> <title> "A formal HDL and its use in the FM9001 verification," in Mechanized Reasoning in Hardware Design, </title> <publisher> Prentice-Hall, </publisher> <year> 1992. </year>
Reference-contexts: For a sequence of transitions, the care set is defined as care t + = fp j t 2 ft + g : 9t (p) 6= #g. A behavior table description of Hunt's verified FM9001 <ref> [10] </ref> processor is shown in Table 1. We will use this description as an example to illustrate our methodology. 3 Control and Datapath The functional units (arithmetic/logic units, registers, switches) in a system and the interconnections between them are called the datapath of a system.
Reference: [11] <author> B. Bose and S. D. Johnson, "DDD-FM9001: </author> <title> Deriva tion of a verified microprocessor. an exercise in inte grating verification with formal derivation," in Pro ceedings of CHARME, </title> <publisher> Springer, </publisher> <year> 1993. </year> <note> LNCS 683. </note>
Reference-contexts: This reinforces our main thesis, that a design representation which unifies different facets of a system in a single formal model can be used to address unexplored aspects of system design. Other control and datapath transformations are described in <ref> [11, 12] </ref>. 4 Sequential Decomposition Sequential decomposition is a generalization of factorization [9] to include protocols between components of a system. A behavior table can be decomposed into interacting behavior tables using a protocol specification with non-trivial control synchronization and data transfer interactions between components.
Reference: [12] <author> B. Bose, </author> <title> "DDD ATransformation system for Digital Design Derivation," </title> <type> Tech. Rep. 331, </type> <institution> Indiana Univer sity, Computer Science Department, </institution> <month> May </month> <year> 1991. </year>
Reference-contexts: This reinforces our main thesis, that a design representation which unifies different facets of a system in a single formal model can be used to address unexplored aspects of system design. Other control and datapath transformations are described in <ref> [11, 12] </ref>. 4 Sequential Decomposition Sequential decomposition is a generalization of factorization [9] to include protocols between components of a system. A behavior table can be decomposed into interacting behavior tables using a protocol specification with non-trivial control synchronization and data transfer interactions between components.
Reference: [13] <author> S. Devadas and A. R. </author> <title> Newton, "Decomposition and factorization of sequential finite state machines," </title> <journal> TCAD 1989, </journal> <volume> vol. 8, </volume> <pages> pp. 1206-1217, </pages> <month> Nov. </month> <year> 1989. </year>
Reference-contexts: A behavior table can be decomposed into interacting behavior tables using a protocol specification with non-trivial control synchronization and data transfer interactions between components. This is different from classical FSM decomposition <ref> [13] </ref>, which assumes tightly-coupled sub-machines that can share state and input information. We use Interface specification language (ISL) to specify the interaction of a component with its environment over input/output ports [14]. ISL can be used to formalize timing diagrams for a component based on a reference clock speed.
Reference: [14] <author> K. Rath and S. D. Johnson, </author> <title> "Toward a basis for proto col specification and process decomposition," in Pro ceedings of CHDL, </title> <publisher> Elsevier, </publisher> <month> Apr. </month> <year> 1993. </year>
Reference-contexts: This is different from classical FSM decomposition [13], which assumes tightly-coupled sub-machines that can share state and input information. We use Interface specification language (ISL) to specify the interaction of a component with its environment over input/output ports <ref> [14] </ref>. ISL can be used to formalize timing diagrams for a component based on a reference clock speed. A specification in ISL constructs a machine with unique start and final states. The complement of a machine describes the protocol behavior of its environment. <p> Also, if s 1 is a wait state for a control input, then s 2 must also be a wait state for the same control input, or s 2 must lead to a wait state for the same control input <ref> [14] </ref>.
Reference: [15] <author> K. Rath, B. Bose, and S. D. Johnson, </author> <title> "Derivation of a DRAM memory interface by sequential decomposi tion," </title> <booktitle> in Proceedings of ICCD, IEEE, </booktitle> <year> 1993. </year>
Reference-contexts: This assures us that the processor can interact properly with the memory. Our methodology is powerful enough to derive the memory controller for a DRAM memory system, with a protocol specification from DRAM timing diagrams, (reported in <ref> [15] </ref>). 5 Data Expansion Data expansion enables a designer to reason at the abstract symbolic level before assigning representations to functional units and values in a system. The organization of the behavior tables helps in visualizing values in different levels of abstraction in a system.
Reference: [16] <author> Z. Zhu and S. D. Johnson, </author> <title> "An algebraic framework for data abstraction in hardware description," in De signing Correct Circuits, </title> <publisher> Springer, </publisher> <year> 1990. </year>
Reference-contexts: to vectors of values in another, V : V [ S [ ^ I fi type 7! V 0fl [ S 0fl [ ^ I 0 fl For the data representation changes to be valid, the representation function R must be onto, and it must also be one-to-one or conflict-free <ref> [16] </ref>. We will assume that R is onto, and we define the conflict-free condition. If two or more columns are mapped on to the same column, then they must be conflict-free.
References-found: 15

